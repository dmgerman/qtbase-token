begin_unit
begin_include
include|#
directive|include
file|"precompiled.h"
end_include
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2013 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Context.cpp: Implements the gl::Context class, managing all GL state and performing
end_comment
begin_comment
comment|// rendering operations. It is the GLES2 specific implementation of EGLContext.
end_comment
begin_include
include|#
directive|include
file|"libGLESv2/Context.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/main.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/utilities.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Buffer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Fence.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Framebuffer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Renderbuffer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Program.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/ProgramBinary.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Query.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Texture.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/ResourceManager.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/IndexDataManager.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/RenderTarget.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/Renderer.h"
end_include
begin_include
include|#
directive|include
file|"libEGL/Surface.h"
end_include
begin_undef
DECL|macro|near
undef|#
directive|undef
name|near
end_undef
begin_undef
DECL|macro|far
undef|#
directive|undef
name|far
end_undef
begin_namespace
DECL|namespace|gl
namespace|namespace
name|gl
block|{
DECL|function|makeStaticString
specifier|static
specifier|const
name|char
modifier|*
name|makeStaticString
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|str
parameter_list|)
block|{
specifier|static
name|std
operator|::
name|set
argument_list|<
name|std
operator|::
name|string
argument_list|>
name|strings
decl_stmt|;
name|std
operator|::
name|set
argument_list|<
name|std
operator|::
name|string
argument_list|>
operator|::
name|iterator
name|it
init|=
name|strings
operator|.
name|find
argument_list|(
name|str
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|strings
operator|.
name|end
argument_list|()
condition|)
return|return
name|it
operator|->
name|c_str
argument_list|()
return|;
return|return
name|strings
operator|.
name|insert
argument_list|(
name|str
argument_list|)
operator|.
name|first
operator|->
name|c_str
argument_list|()
return|;
block|}
DECL|function|Context
name|Context
operator|::
name|Context
parameter_list|(
specifier|const
name|gl
operator|::
name|Context
modifier|*
name|shareContext
parameter_list|,
name|rx
operator|::
name|Renderer
modifier|*
name|renderer
parameter_list|,
name|bool
name|notifyResets
parameter_list|,
name|bool
name|robustAccess
parameter_list|)
member_init_list|:
name|mRenderer
argument_list|(
name|renderer
argument_list|)
block|{
name|ASSERT
argument_list|(
name|robustAccess
operator|==
literal|false
argument_list|)
expr_stmt|;
comment|// Unimplemented
name|mFenceHandleAllocator
operator|.
name|setBaseHandle
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|setClearColor
argument_list|(
literal|0.0f
argument_list|,
literal|0.0f
argument_list|,
literal|0.0f
argument_list|,
literal|0.0f
argument_list|)
expr_stmt|;
name|mState
operator|.
name|depthClearValue
operator|=
literal|1.0f
expr_stmt|;
name|mState
operator|.
name|stencilClearValue
operator|=
literal|0
expr_stmt|;
name|mState
operator|.
name|rasterizer
operator|.
name|cullFace
operator|=
literal|false
expr_stmt|;
name|mState
operator|.
name|rasterizer
operator|.
name|cullMode
operator|=
name|GL_BACK
expr_stmt|;
name|mState
operator|.
name|rasterizer
operator|.
name|frontFace
operator|=
name|GL_CCW
expr_stmt|;
name|mState
operator|.
name|rasterizer
operator|.
name|polygonOffsetFill
operator|=
literal|false
expr_stmt|;
name|mState
operator|.
name|rasterizer
operator|.
name|polygonOffsetFactor
operator|=
literal|0.0f
expr_stmt|;
name|mState
operator|.
name|rasterizer
operator|.
name|polygonOffsetUnits
operator|=
literal|0.0f
expr_stmt|;
name|mState
operator|.
name|rasterizer
operator|.
name|pointDrawMode
operator|=
literal|false
expr_stmt|;
name|mState
operator|.
name|scissorTest
operator|=
literal|false
expr_stmt|;
name|mState
operator|.
name|scissor
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|mState
operator|.
name|scissor
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|mState
operator|.
name|scissor
operator|.
name|width
operator|=
literal|0
expr_stmt|;
name|mState
operator|.
name|scissor
operator|.
name|height
operator|=
literal|0
expr_stmt|;
name|mState
operator|.
name|blend
operator|.
name|blend
operator|=
literal|false
expr_stmt|;
name|mState
operator|.
name|blend
operator|.
name|sourceBlendRGB
operator|=
name|GL_ONE
expr_stmt|;
name|mState
operator|.
name|blend
operator|.
name|sourceBlendAlpha
operator|=
name|GL_ONE
expr_stmt|;
name|mState
operator|.
name|blend
operator|.
name|destBlendRGB
operator|=
name|GL_ZERO
expr_stmt|;
name|mState
operator|.
name|blend
operator|.
name|destBlendAlpha
operator|=
name|GL_ZERO
expr_stmt|;
name|mState
operator|.
name|blend
operator|.
name|blendEquationRGB
operator|=
name|GL_FUNC_ADD
expr_stmt|;
name|mState
operator|.
name|blend
operator|.
name|blendEquationAlpha
operator|=
name|GL_FUNC_ADD
expr_stmt|;
name|mState
operator|.
name|blend
operator|.
name|sampleAlphaToCoverage
operator|=
literal|false
expr_stmt|;
name|mState
operator|.
name|blend
operator|.
name|dither
operator|=
literal|true
expr_stmt|;
name|mState
operator|.
name|blendColor
operator|.
name|red
operator|=
literal|0
expr_stmt|;
name|mState
operator|.
name|blendColor
operator|.
name|green
operator|=
literal|0
expr_stmt|;
name|mState
operator|.
name|blendColor
operator|.
name|blue
operator|=
literal|0
expr_stmt|;
name|mState
operator|.
name|blendColor
operator|.
name|alpha
operator|=
literal|0
expr_stmt|;
name|mState
operator|.
name|depthStencil
operator|.
name|depthTest
operator|=
literal|false
expr_stmt|;
name|mState
operator|.
name|depthStencil
operator|.
name|depthFunc
operator|=
name|GL_LESS
expr_stmt|;
name|mState
operator|.
name|depthStencil
operator|.
name|depthMask
operator|=
literal|true
expr_stmt|;
name|mState
operator|.
name|depthStencil
operator|.
name|stencilTest
operator|=
literal|false
expr_stmt|;
name|mState
operator|.
name|depthStencil
operator|.
name|stencilFunc
operator|=
name|GL_ALWAYS
expr_stmt|;
name|mState
operator|.
name|depthStencil
operator|.
name|stencilMask
operator|=
operator|-
literal|1
expr_stmt|;
name|mState
operator|.
name|depthStencil
operator|.
name|stencilWritemask
operator|=
operator|-
literal|1
expr_stmt|;
name|mState
operator|.
name|depthStencil
operator|.
name|stencilBackFunc
operator|=
name|GL_ALWAYS
expr_stmt|;
name|mState
operator|.
name|depthStencil
operator|.
name|stencilBackMask
operator|=
operator|-
literal|1
expr_stmt|;
name|mState
operator|.
name|depthStencil
operator|.
name|stencilBackWritemask
operator|=
operator|-
literal|1
expr_stmt|;
name|mState
operator|.
name|depthStencil
operator|.
name|stencilFail
operator|=
name|GL_KEEP
expr_stmt|;
name|mState
operator|.
name|depthStencil
operator|.
name|stencilPassDepthFail
operator|=
name|GL_KEEP
expr_stmt|;
name|mState
operator|.
name|depthStencil
operator|.
name|stencilPassDepthPass
operator|=
name|GL_KEEP
expr_stmt|;
name|mState
operator|.
name|depthStencil
operator|.
name|stencilBackFail
operator|=
name|GL_KEEP
expr_stmt|;
name|mState
operator|.
name|depthStencil
operator|.
name|stencilBackPassDepthFail
operator|=
name|GL_KEEP
expr_stmt|;
name|mState
operator|.
name|depthStencil
operator|.
name|stencilBackPassDepthPass
operator|=
name|GL_KEEP
expr_stmt|;
name|mState
operator|.
name|stencilRef
operator|=
literal|0
expr_stmt|;
name|mState
operator|.
name|stencilBackRef
operator|=
literal|0
expr_stmt|;
name|mState
operator|.
name|sampleCoverage
operator|=
literal|false
expr_stmt|;
name|mState
operator|.
name|sampleCoverageValue
operator|=
literal|1.0f
expr_stmt|;
name|mState
operator|.
name|sampleCoverageInvert
operator|=
literal|false
expr_stmt|;
name|mState
operator|.
name|generateMipmapHint
operator|=
name|GL_DONT_CARE
expr_stmt|;
name|mState
operator|.
name|fragmentShaderDerivativeHint
operator|=
name|GL_DONT_CARE
expr_stmt|;
name|mState
operator|.
name|lineWidth
operator|=
literal|1.0f
expr_stmt|;
name|mState
operator|.
name|viewport
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|mState
operator|.
name|viewport
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|mState
operator|.
name|viewport
operator|.
name|width
operator|=
literal|0
expr_stmt|;
name|mState
operator|.
name|viewport
operator|.
name|height
operator|=
literal|0
expr_stmt|;
name|mState
operator|.
name|zNear
operator|=
literal|0.0f
expr_stmt|;
name|mState
operator|.
name|zFar
operator|=
literal|1.0f
expr_stmt|;
name|mState
operator|.
name|blend
operator|.
name|colorMaskRed
operator|=
literal|true
expr_stmt|;
name|mState
operator|.
name|blend
operator|.
name|colorMaskGreen
operator|=
literal|true
expr_stmt|;
name|mState
operator|.
name|blend
operator|.
name|colorMaskBlue
operator|=
literal|true
expr_stmt|;
name|mState
operator|.
name|blend
operator|.
name|colorMaskAlpha
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|shareContext
operator|!=
name|NULL
condition|)
block|{
name|mResourceManager
operator|=
name|shareContext
operator|->
name|mResourceManager
expr_stmt|;
name|mResourceManager
operator|->
name|addRef
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|mResourceManager
operator|=
operator|new
name|ResourceManager
argument_list|(
name|mRenderer
argument_list|)
expr_stmt|;
block|}
comment|// [OpenGL ES 2.0.24] section 3.7 page 83:
comment|// In the initial state, TEXTURE_2D and TEXTURE_CUBE_MAP have twodimensional
comment|// and cube map texture state vectors respectively associated with them.
comment|// In order that access to these initial textures not be lost, they are treated as texture
comment|// objects all of whose names are 0.
name|mTexture2DZero
operator|.
name|set
argument_list|(
operator|new
name|Texture2D
argument_list|(
name|mRenderer
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|mTextureCubeMapZero
operator|.
name|set
argument_list|(
operator|new
name|TextureCubeMap
argument_list|(
name|mRenderer
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|mState
operator|.
name|activeSampler
operator|=
literal|0
expr_stmt|;
name|bindArrayBuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindElementArrayBuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindTextureCubeMap
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindTexture2D
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindReadFramebuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindDrawFramebuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindRenderbuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|mState
operator|.
name|currentProgram
operator|=
literal|0
expr_stmt|;
name|mCurrentProgramBinary
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mState
operator|.
name|packAlignment
operator|=
literal|4
expr_stmt|;
name|mState
operator|.
name|unpackAlignment
operator|=
literal|4
expr_stmt|;
name|mState
operator|.
name|packReverseRowOrder
operator|=
literal|false
expr_stmt|;
name|mExtensionString
operator|=
name|NULL
expr_stmt|;
name|mRendererString
operator|=
name|NULL
expr_stmt|;
name|mInvalidEnum
operator|=
literal|false
expr_stmt|;
name|mInvalidValue
operator|=
literal|false
expr_stmt|;
name|mInvalidOperation
operator|=
literal|false
expr_stmt|;
name|mOutOfMemory
operator|=
literal|false
expr_stmt|;
name|mInvalidFramebufferOperation
operator|=
literal|false
expr_stmt|;
name|mHasBeenCurrent
operator|=
literal|false
expr_stmt|;
name|mContextLost
operator|=
literal|false
expr_stmt|;
name|mResetStatus
operator|=
name|GL_NO_ERROR
expr_stmt|;
name|mResetStrategy
operator|=
operator|(
name|notifyResets
condition|?
name|GL_LOSE_CONTEXT_ON_RESET_EXT
else|:
name|GL_NO_RESET_NOTIFICATION_EXT
operator|)
expr_stmt|;
name|mRobustAccess
operator|=
name|robustAccess
expr_stmt|;
name|mSupportsBGRATextures
operator|=
literal|false
expr_stmt|;
name|mSupportsDXT1Textures
operator|=
literal|false
expr_stmt|;
name|mSupportsDXT3Textures
operator|=
literal|false
expr_stmt|;
name|mSupportsDXT5Textures
operator|=
literal|false
expr_stmt|;
name|mSupportsEventQueries
operator|=
literal|false
expr_stmt|;
name|mSupportsOcclusionQueries
operator|=
literal|false
expr_stmt|;
name|mNumCompressedTextureFormats
operator|=
literal|0
expr_stmt|;
block|}
DECL|function|~Context
name|Context
operator|::
name|~
name|Context
parameter_list|()
block|{
if|if
condition|(
name|mState
operator|.
name|currentProgram
operator|!=
literal|0
condition|)
block|{
name|Program
modifier|*
name|programObject
init|=
name|mResourceManager
operator|->
name|getProgram
argument_list|(
name|mState
operator|.
name|currentProgram
argument_list|)
decl_stmt|;
if|if
condition|(
name|programObject
condition|)
block|{
name|programObject
operator|->
name|release
argument_list|()
expr_stmt|;
block|}
name|mState
operator|.
name|currentProgram
operator|=
literal|0
expr_stmt|;
block|}
name|mCurrentProgramBinary
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|mFramebufferMap
operator|.
name|empty
argument_list|()
condition|)
block|{
name|deleteFramebuffer
argument_list|(
name|mFramebufferMap
operator|.
name|begin
argument_list|()
operator|->
name|first
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|mFenceMap
operator|.
name|empty
argument_list|()
condition|)
block|{
name|deleteFence
argument_list|(
name|mFenceMap
operator|.
name|begin
argument_list|()
operator|->
name|first
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|mQueryMap
operator|.
name|empty
argument_list|()
condition|)
block|{
name|deleteQuery
argument_list|(
name|mQueryMap
operator|.
name|begin
argument_list|()
operator|->
name|first
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|type
init|=
literal|0
init|;
name|type
operator|<
name|TEXTURE_TYPE_COUNT
condition|;
name|type
operator|++
control|)
block|{
for|for
control|(
name|int
name|sampler
init|=
literal|0
init|;
name|sampler
operator|<
name|IMPLEMENTATION_MAX_COMBINED_TEXTURE_IMAGE_UNITS
condition|;
name|sampler
operator|++
control|)
block|{
name|mState
operator|.
name|samplerTexture
index|[
name|type
index|]
index|[
name|sampler
index|]
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|type
init|=
literal|0
init|;
name|type
operator|<
name|TEXTURE_TYPE_COUNT
condition|;
name|type
operator|++
control|)
block|{
name|mIncompleteTextures
index|[
name|type
index|]
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|i
operator|++
control|)
block|{
name|mState
operator|.
name|vertexAttribute
index|[
name|i
index|]
operator|.
name|mBoundBuffer
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|QUERY_TYPE_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|mState
operator|.
name|activeQuery
index|[
name|i
index|]
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
name|mState
operator|.
name|arrayBuffer
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mState
operator|.
name|elementArrayBuffer
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mState
operator|.
name|renderbuffer
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mTexture2DZero
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mTextureCubeMapZero
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mResourceManager
operator|->
name|release
argument_list|()
expr_stmt|;
block|}
DECL|function|makeCurrent
name|void
name|Context
operator|::
name|makeCurrent
parameter_list|(
name|egl
operator|::
name|Surface
modifier|*
name|surface
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mHasBeenCurrent
condition|)
block|{
name|mMajorShaderModel
operator|=
name|mRenderer
operator|->
name|getMajorShaderModel
argument_list|()
expr_stmt|;
name|mMaximumPointSize
operator|=
name|mRenderer
operator|->
name|getMaxPointSize
argument_list|()
expr_stmt|;
name|mSupportsVertexTexture
operator|=
name|mRenderer
operator|->
name|getVertexTextureSupport
argument_list|()
expr_stmt|;
name|mSupportsNonPower2Texture
operator|=
name|mRenderer
operator|->
name|getNonPower2TextureSupport
argument_list|()
expr_stmt|;
name|mSupportsInstancing
operator|=
name|mRenderer
operator|->
name|getInstancingSupport
argument_list|()
expr_stmt|;
name|mMaxViewportDimension
operator|=
name|mRenderer
operator|->
name|getMaxViewportDimension
argument_list|()
expr_stmt|;
name|mMaxTextureDimension
operator|=
name|std
operator|::
name|min
argument_list|(
name|std
operator|::
name|min
argument_list|(
name|mRenderer
operator|->
name|getMaxTextureWidth
argument_list|()
argument_list|,
name|mRenderer
operator|->
name|getMaxTextureHeight
argument_list|()
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_SIZE
argument_list|)
expr_stmt|;
name|mMaxCubeTextureDimension
operator|=
name|std
operator|::
name|min
argument_list|(
name|mMaxTextureDimension
argument_list|,
operator|(
name|int
operator|)
name|gl
operator|::
name|IMPLEMENTATION_MAX_CUBE_MAP_TEXTURE_SIZE
argument_list|)
expr_stmt|;
name|mMaxRenderbufferDimension
operator|=
name|mMaxTextureDimension
expr_stmt|;
name|mMaxTextureLevel
operator|=
name|log2
argument_list|(
name|mMaxTextureDimension
argument_list|)
operator|+
literal|1
expr_stmt|;
name|mMaxTextureAnisotropy
operator|=
name|mRenderer
operator|->
name|getTextureMaxAnisotropy
argument_list|()
expr_stmt|;
name|TRACE
argument_list|(
literal|"MaxTextureDimension=%d, MaxCubeTextureDimension=%d, MaxRenderbufferDimension=%d, MaxTextureLevel=%d, MaxTextureAnisotropy=%f"
argument_list|,
name|mMaxTextureDimension
argument_list|,
name|mMaxCubeTextureDimension
argument_list|,
name|mMaxRenderbufferDimension
argument_list|,
name|mMaxTextureLevel
argument_list|,
name|mMaxTextureAnisotropy
argument_list|)
expr_stmt|;
name|mSupportsEventQueries
operator|=
name|mRenderer
operator|->
name|getEventQuerySupport
argument_list|()
expr_stmt|;
name|mSupportsOcclusionQueries
operator|=
name|mRenderer
operator|->
name|getOcclusionQuerySupport
argument_list|()
expr_stmt|;
name|mSupportsBGRATextures
operator|=
name|mRenderer
operator|->
name|getBGRATextureSupport
argument_list|()
expr_stmt|;
name|mSupportsDXT1Textures
operator|=
name|mRenderer
operator|->
name|getDXT1TextureSupport
argument_list|()
expr_stmt|;
name|mSupportsDXT3Textures
operator|=
name|mRenderer
operator|->
name|getDXT3TextureSupport
argument_list|()
expr_stmt|;
name|mSupportsDXT5Textures
operator|=
name|mRenderer
operator|->
name|getDXT5TextureSupport
argument_list|()
expr_stmt|;
name|mSupportsFloat32Textures
operator|=
name|mRenderer
operator|->
name|getFloat32TextureSupport
argument_list|(
operator|&
name|mSupportsFloat32LinearFilter
argument_list|,
operator|&
name|mSupportsFloat32RenderableTextures
argument_list|)
expr_stmt|;
name|mSupportsFloat16Textures
operator|=
name|mRenderer
operator|->
name|getFloat16TextureSupport
argument_list|(
operator|&
name|mSupportsFloat16LinearFilter
argument_list|,
operator|&
name|mSupportsFloat16RenderableTextures
argument_list|)
expr_stmt|;
name|mSupportsLuminanceTextures
operator|=
name|mRenderer
operator|->
name|getLuminanceTextureSupport
argument_list|()
expr_stmt|;
name|mSupportsLuminanceAlphaTextures
operator|=
name|mRenderer
operator|->
name|getLuminanceAlphaTextureSupport
argument_list|()
expr_stmt|;
name|mSupportsDepthTextures
operator|=
name|mRenderer
operator|->
name|getDepthTextureSupport
argument_list|()
expr_stmt|;
name|mSupportsTextureFilterAnisotropy
operator|=
name|mRenderer
operator|->
name|getTextureFilterAnisotropySupport
argument_list|()
expr_stmt|;
name|mSupports32bitIndices
operator|=
name|mRenderer
operator|->
name|get32BitIndexSupport
argument_list|()
expr_stmt|;
name|mNumCompressedTextureFormats
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|supportsDXT1Textures
argument_list|()
condition|)
block|{
name|mNumCompressedTextureFormats
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|supportsDXT3Textures
argument_list|()
condition|)
block|{
name|mNumCompressedTextureFormats
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|supportsDXT5Textures
argument_list|()
condition|)
block|{
name|mNumCompressedTextureFormats
operator|+=
literal|1
expr_stmt|;
block|}
name|initExtensionString
argument_list|()
expr_stmt|;
name|initRendererString
argument_list|()
expr_stmt|;
name|mState
operator|.
name|viewport
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|mState
operator|.
name|viewport
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|mState
operator|.
name|viewport
operator|.
name|width
operator|=
name|surface
operator|->
name|getWidth
argument_list|()
expr_stmt|;
name|mState
operator|.
name|viewport
operator|.
name|height
operator|=
name|surface
operator|->
name|getHeight
argument_list|()
expr_stmt|;
name|mState
operator|.
name|scissor
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|mState
operator|.
name|scissor
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|mState
operator|.
name|scissor
operator|.
name|width
operator|=
name|surface
operator|->
name|getWidth
argument_list|()
expr_stmt|;
name|mState
operator|.
name|scissor
operator|.
name|height
operator|=
name|surface
operator|->
name|getHeight
argument_list|()
expr_stmt|;
name|mHasBeenCurrent
operator|=
literal|true
expr_stmt|;
block|}
comment|// Wrap the existing swapchain resources into GL objects and assign them to the '0' names
name|rx
operator|::
name|SwapChain
modifier|*
name|swapchain
init|=
name|surface
operator|->
name|getSwapChain
argument_list|()
decl_stmt|;
name|Colorbuffer
modifier|*
name|colorbufferZero
init|=
operator|new
name|Colorbuffer
argument_list|(
name|mRenderer
argument_list|,
name|swapchain
argument_list|)
decl_stmt|;
name|DepthStencilbuffer
modifier|*
name|depthStencilbufferZero
init|=
operator|new
name|DepthStencilbuffer
argument_list|(
name|mRenderer
argument_list|,
name|swapchain
argument_list|)
decl_stmt|;
name|Framebuffer
modifier|*
name|framebufferZero
init|=
operator|new
name|DefaultFramebuffer
argument_list|(
name|mRenderer
argument_list|,
name|colorbufferZero
argument_list|,
name|depthStencilbufferZero
argument_list|)
decl_stmt|;
name|setFramebufferZero
argument_list|(
name|framebufferZero
argument_list|)
expr_stmt|;
block|}
comment|// NOTE: this function should not assume that this context is current!
DECL|function|markContextLost
name|void
name|Context
operator|::
name|markContextLost
parameter_list|()
block|{
if|if
condition|(
name|mResetStrategy
operator|==
name|GL_LOSE_CONTEXT_ON_RESET_EXT
condition|)
name|mResetStatus
operator|=
name|GL_UNKNOWN_CONTEXT_RESET_EXT
expr_stmt|;
name|mContextLost
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|isContextLost
name|bool
name|Context
operator|::
name|isContextLost
parameter_list|()
block|{
return|return
name|mContextLost
return|;
block|}
DECL|function|setClearColor
name|void
name|Context
operator|::
name|setClearColor
parameter_list|(
name|float
name|red
parameter_list|,
name|float
name|green
parameter_list|,
name|float
name|blue
parameter_list|,
name|float
name|alpha
parameter_list|)
block|{
name|mState
operator|.
name|colorClearValue
operator|.
name|red
operator|=
name|red
expr_stmt|;
name|mState
operator|.
name|colorClearValue
operator|.
name|green
operator|=
name|green
expr_stmt|;
name|mState
operator|.
name|colorClearValue
operator|.
name|blue
operator|=
name|blue
expr_stmt|;
name|mState
operator|.
name|colorClearValue
operator|.
name|alpha
operator|=
name|alpha
expr_stmt|;
block|}
DECL|function|setClearDepth
name|void
name|Context
operator|::
name|setClearDepth
parameter_list|(
name|float
name|depth
parameter_list|)
block|{
name|mState
operator|.
name|depthClearValue
operator|=
name|depth
expr_stmt|;
block|}
DECL|function|setClearStencil
name|void
name|Context
operator|::
name|setClearStencil
parameter_list|(
name|int
name|stencil
parameter_list|)
block|{
name|mState
operator|.
name|stencilClearValue
operator|=
name|stencil
expr_stmt|;
block|}
DECL|function|setCullFace
name|void
name|Context
operator|::
name|setCullFace
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|mState
operator|.
name|rasterizer
operator|.
name|cullFace
operator|=
name|enabled
expr_stmt|;
block|}
DECL|function|isCullFaceEnabled
name|bool
name|Context
operator|::
name|isCullFaceEnabled
parameter_list|()
specifier|const
block|{
return|return
name|mState
operator|.
name|rasterizer
operator|.
name|cullFace
return|;
block|}
DECL|function|setCullMode
name|void
name|Context
operator|::
name|setCullMode
parameter_list|(
name|GLenum
name|mode
parameter_list|)
block|{
name|mState
operator|.
name|rasterizer
operator|.
name|cullMode
operator|=
name|mode
expr_stmt|;
block|}
DECL|function|setFrontFace
name|void
name|Context
operator|::
name|setFrontFace
parameter_list|(
name|GLenum
name|front
parameter_list|)
block|{
name|mState
operator|.
name|rasterizer
operator|.
name|frontFace
operator|=
name|front
expr_stmt|;
block|}
DECL|function|setDepthTest
name|void
name|Context
operator|::
name|setDepthTest
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|mState
operator|.
name|depthStencil
operator|.
name|depthTest
operator|=
name|enabled
expr_stmt|;
block|}
DECL|function|isDepthTestEnabled
name|bool
name|Context
operator|::
name|isDepthTestEnabled
parameter_list|()
specifier|const
block|{
return|return
name|mState
operator|.
name|depthStencil
operator|.
name|depthTest
return|;
block|}
DECL|function|setDepthFunc
name|void
name|Context
operator|::
name|setDepthFunc
parameter_list|(
name|GLenum
name|depthFunc
parameter_list|)
block|{
name|mState
operator|.
name|depthStencil
operator|.
name|depthFunc
operator|=
name|depthFunc
expr_stmt|;
block|}
DECL|function|setDepthRange
name|void
name|Context
operator|::
name|setDepthRange
parameter_list|(
name|float
name|zNear
parameter_list|,
name|float
name|zFar
parameter_list|)
block|{
name|mState
operator|.
name|zNear
operator|=
name|zNear
expr_stmt|;
name|mState
operator|.
name|zFar
operator|=
name|zFar
expr_stmt|;
block|}
DECL|function|setBlend
name|void
name|Context
operator|::
name|setBlend
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|mState
operator|.
name|blend
operator|.
name|blend
operator|=
name|enabled
expr_stmt|;
block|}
DECL|function|isBlendEnabled
name|bool
name|Context
operator|::
name|isBlendEnabled
parameter_list|()
specifier|const
block|{
return|return
name|mState
operator|.
name|blend
operator|.
name|blend
return|;
block|}
DECL|function|setBlendFactors
name|void
name|Context
operator|::
name|setBlendFactors
parameter_list|(
name|GLenum
name|sourceRGB
parameter_list|,
name|GLenum
name|destRGB
parameter_list|,
name|GLenum
name|sourceAlpha
parameter_list|,
name|GLenum
name|destAlpha
parameter_list|)
block|{
name|mState
operator|.
name|blend
operator|.
name|sourceBlendRGB
operator|=
name|sourceRGB
expr_stmt|;
name|mState
operator|.
name|blend
operator|.
name|destBlendRGB
operator|=
name|destRGB
expr_stmt|;
name|mState
operator|.
name|blend
operator|.
name|sourceBlendAlpha
operator|=
name|sourceAlpha
expr_stmt|;
name|mState
operator|.
name|blend
operator|.
name|destBlendAlpha
operator|=
name|destAlpha
expr_stmt|;
block|}
DECL|function|setBlendColor
name|void
name|Context
operator|::
name|setBlendColor
parameter_list|(
name|float
name|red
parameter_list|,
name|float
name|green
parameter_list|,
name|float
name|blue
parameter_list|,
name|float
name|alpha
parameter_list|)
block|{
name|mState
operator|.
name|blendColor
operator|.
name|red
operator|=
name|red
expr_stmt|;
name|mState
operator|.
name|blendColor
operator|.
name|green
operator|=
name|green
expr_stmt|;
name|mState
operator|.
name|blendColor
operator|.
name|blue
operator|=
name|blue
expr_stmt|;
name|mState
operator|.
name|blendColor
operator|.
name|alpha
operator|=
name|alpha
expr_stmt|;
block|}
DECL|function|setBlendEquation
name|void
name|Context
operator|::
name|setBlendEquation
parameter_list|(
name|GLenum
name|rgbEquation
parameter_list|,
name|GLenum
name|alphaEquation
parameter_list|)
block|{
name|mState
operator|.
name|blend
operator|.
name|blendEquationRGB
operator|=
name|rgbEquation
expr_stmt|;
name|mState
operator|.
name|blend
operator|.
name|blendEquationAlpha
operator|=
name|alphaEquation
expr_stmt|;
block|}
DECL|function|setStencilTest
name|void
name|Context
operator|::
name|setStencilTest
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|mState
operator|.
name|depthStencil
operator|.
name|stencilTest
operator|=
name|enabled
expr_stmt|;
block|}
DECL|function|isStencilTestEnabled
name|bool
name|Context
operator|::
name|isStencilTestEnabled
parameter_list|()
specifier|const
block|{
return|return
name|mState
operator|.
name|depthStencil
operator|.
name|stencilTest
return|;
block|}
DECL|function|setStencilParams
name|void
name|Context
operator|::
name|setStencilParams
parameter_list|(
name|GLenum
name|stencilFunc
parameter_list|,
name|GLint
name|stencilRef
parameter_list|,
name|GLuint
name|stencilMask
parameter_list|)
block|{
name|mState
operator|.
name|depthStencil
operator|.
name|stencilFunc
operator|=
name|stencilFunc
expr_stmt|;
name|mState
operator|.
name|stencilRef
operator|=
operator|(
name|stencilRef
operator|>
literal|0
operator|)
condition|?
name|stencilRef
else|:
literal|0
expr_stmt|;
name|mState
operator|.
name|depthStencil
operator|.
name|stencilMask
operator|=
name|stencilMask
expr_stmt|;
block|}
DECL|function|setStencilBackParams
name|void
name|Context
operator|::
name|setStencilBackParams
parameter_list|(
name|GLenum
name|stencilBackFunc
parameter_list|,
name|GLint
name|stencilBackRef
parameter_list|,
name|GLuint
name|stencilBackMask
parameter_list|)
block|{
name|mState
operator|.
name|depthStencil
operator|.
name|stencilBackFunc
operator|=
name|stencilBackFunc
expr_stmt|;
name|mState
operator|.
name|stencilBackRef
operator|=
operator|(
name|stencilBackRef
operator|>
literal|0
operator|)
condition|?
name|stencilBackRef
else|:
literal|0
expr_stmt|;
name|mState
operator|.
name|depthStencil
operator|.
name|stencilBackMask
operator|=
name|stencilBackMask
expr_stmt|;
block|}
DECL|function|setStencilWritemask
name|void
name|Context
operator|::
name|setStencilWritemask
parameter_list|(
name|GLuint
name|stencilWritemask
parameter_list|)
block|{
name|mState
operator|.
name|depthStencil
operator|.
name|stencilWritemask
operator|=
name|stencilWritemask
expr_stmt|;
block|}
DECL|function|setStencilBackWritemask
name|void
name|Context
operator|::
name|setStencilBackWritemask
parameter_list|(
name|GLuint
name|stencilBackWritemask
parameter_list|)
block|{
name|mState
operator|.
name|depthStencil
operator|.
name|stencilBackWritemask
operator|=
name|stencilBackWritemask
expr_stmt|;
block|}
DECL|function|setStencilOperations
name|void
name|Context
operator|::
name|setStencilOperations
parameter_list|(
name|GLenum
name|stencilFail
parameter_list|,
name|GLenum
name|stencilPassDepthFail
parameter_list|,
name|GLenum
name|stencilPassDepthPass
parameter_list|)
block|{
name|mState
operator|.
name|depthStencil
operator|.
name|stencilFail
operator|=
name|stencilFail
expr_stmt|;
name|mState
operator|.
name|depthStencil
operator|.
name|stencilPassDepthFail
operator|=
name|stencilPassDepthFail
expr_stmt|;
name|mState
operator|.
name|depthStencil
operator|.
name|stencilPassDepthPass
operator|=
name|stencilPassDepthPass
expr_stmt|;
block|}
DECL|function|setStencilBackOperations
name|void
name|Context
operator|::
name|setStencilBackOperations
parameter_list|(
name|GLenum
name|stencilBackFail
parameter_list|,
name|GLenum
name|stencilBackPassDepthFail
parameter_list|,
name|GLenum
name|stencilBackPassDepthPass
parameter_list|)
block|{
name|mState
operator|.
name|depthStencil
operator|.
name|stencilBackFail
operator|=
name|stencilBackFail
expr_stmt|;
name|mState
operator|.
name|depthStencil
operator|.
name|stencilBackPassDepthFail
operator|=
name|stencilBackPassDepthFail
expr_stmt|;
name|mState
operator|.
name|depthStencil
operator|.
name|stencilBackPassDepthPass
operator|=
name|stencilBackPassDepthPass
expr_stmt|;
block|}
DECL|function|setPolygonOffsetFill
name|void
name|Context
operator|::
name|setPolygonOffsetFill
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|mState
operator|.
name|rasterizer
operator|.
name|polygonOffsetFill
operator|=
name|enabled
expr_stmt|;
block|}
DECL|function|isPolygonOffsetFillEnabled
name|bool
name|Context
operator|::
name|isPolygonOffsetFillEnabled
parameter_list|()
specifier|const
block|{
return|return
name|mState
operator|.
name|rasterizer
operator|.
name|polygonOffsetFill
return|;
block|}
DECL|function|setPolygonOffsetParams
name|void
name|Context
operator|::
name|setPolygonOffsetParams
parameter_list|(
name|GLfloat
name|factor
parameter_list|,
name|GLfloat
name|units
parameter_list|)
block|{
comment|// An application can pass NaN values here, so handle this gracefully
name|mState
operator|.
name|rasterizer
operator|.
name|polygonOffsetFactor
operator|=
name|factor
operator|!=
name|factor
condition|?
literal|0.0f
else|:
name|factor
expr_stmt|;
name|mState
operator|.
name|rasterizer
operator|.
name|polygonOffsetUnits
operator|=
name|units
operator|!=
name|units
condition|?
literal|0.0f
else|:
name|units
expr_stmt|;
block|}
DECL|function|setSampleAlphaToCoverage
name|void
name|Context
operator|::
name|setSampleAlphaToCoverage
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|mState
operator|.
name|blend
operator|.
name|sampleAlphaToCoverage
operator|=
name|enabled
expr_stmt|;
block|}
DECL|function|isSampleAlphaToCoverageEnabled
name|bool
name|Context
operator|::
name|isSampleAlphaToCoverageEnabled
parameter_list|()
specifier|const
block|{
return|return
name|mState
operator|.
name|blend
operator|.
name|sampleAlphaToCoverage
return|;
block|}
DECL|function|setSampleCoverage
name|void
name|Context
operator|::
name|setSampleCoverage
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|mState
operator|.
name|sampleCoverage
operator|=
name|enabled
expr_stmt|;
block|}
DECL|function|isSampleCoverageEnabled
name|bool
name|Context
operator|::
name|isSampleCoverageEnabled
parameter_list|()
specifier|const
block|{
return|return
name|mState
operator|.
name|sampleCoverage
return|;
block|}
DECL|function|setSampleCoverageParams
name|void
name|Context
operator|::
name|setSampleCoverageParams
parameter_list|(
name|GLclampf
name|value
parameter_list|,
name|bool
name|invert
parameter_list|)
block|{
name|mState
operator|.
name|sampleCoverageValue
operator|=
name|value
expr_stmt|;
name|mState
operator|.
name|sampleCoverageInvert
operator|=
name|invert
expr_stmt|;
block|}
DECL|function|setScissorTest
name|void
name|Context
operator|::
name|setScissorTest
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|mState
operator|.
name|scissorTest
operator|=
name|enabled
expr_stmt|;
block|}
DECL|function|isScissorTestEnabled
name|bool
name|Context
operator|::
name|isScissorTestEnabled
parameter_list|()
specifier|const
block|{
return|return
name|mState
operator|.
name|scissorTest
return|;
block|}
DECL|function|setDither
name|void
name|Context
operator|::
name|setDither
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|mState
operator|.
name|blend
operator|.
name|dither
operator|=
name|enabled
expr_stmt|;
block|}
DECL|function|isDitherEnabled
name|bool
name|Context
operator|::
name|isDitherEnabled
parameter_list|()
specifier|const
block|{
return|return
name|mState
operator|.
name|blend
operator|.
name|dither
return|;
block|}
DECL|function|setLineWidth
name|void
name|Context
operator|::
name|setLineWidth
parameter_list|(
name|GLfloat
name|width
parameter_list|)
block|{
name|mState
operator|.
name|lineWidth
operator|=
name|width
expr_stmt|;
block|}
DECL|function|setGenerateMipmapHint
name|void
name|Context
operator|::
name|setGenerateMipmapHint
parameter_list|(
name|GLenum
name|hint
parameter_list|)
block|{
name|mState
operator|.
name|generateMipmapHint
operator|=
name|hint
expr_stmt|;
block|}
DECL|function|setFragmentShaderDerivativeHint
name|void
name|Context
operator|::
name|setFragmentShaderDerivativeHint
parameter_list|(
name|GLenum
name|hint
parameter_list|)
block|{
name|mState
operator|.
name|fragmentShaderDerivativeHint
operator|=
name|hint
expr_stmt|;
comment|// TODO: Propagate the hint to shader translator so we can write
comment|// ddx, ddx_coarse, or ddx_fine depending on the hint.
comment|// Ignore for now. It is valid for implementations to ignore hint.
block|}
DECL|function|setViewportParams
name|void
name|Context
operator|::
name|setViewportParams
parameter_list|(
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
name|mState
operator|.
name|viewport
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|mState
operator|.
name|viewport
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|mState
operator|.
name|viewport
operator|.
name|width
operator|=
name|width
expr_stmt|;
name|mState
operator|.
name|viewport
operator|.
name|height
operator|=
name|height
expr_stmt|;
block|}
DECL|function|setScissorParams
name|void
name|Context
operator|::
name|setScissorParams
parameter_list|(
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
name|mState
operator|.
name|scissor
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|mState
operator|.
name|scissor
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|mState
operator|.
name|scissor
operator|.
name|width
operator|=
name|width
expr_stmt|;
name|mState
operator|.
name|scissor
operator|.
name|height
operator|=
name|height
expr_stmt|;
block|}
DECL|function|setColorMask
name|void
name|Context
operator|::
name|setColorMask
parameter_list|(
name|bool
name|red
parameter_list|,
name|bool
name|green
parameter_list|,
name|bool
name|blue
parameter_list|,
name|bool
name|alpha
parameter_list|)
block|{
name|mState
operator|.
name|blend
operator|.
name|colorMaskRed
operator|=
name|red
expr_stmt|;
name|mState
operator|.
name|blend
operator|.
name|colorMaskGreen
operator|=
name|green
expr_stmt|;
name|mState
operator|.
name|blend
operator|.
name|colorMaskBlue
operator|=
name|blue
expr_stmt|;
name|mState
operator|.
name|blend
operator|.
name|colorMaskAlpha
operator|=
name|alpha
expr_stmt|;
block|}
DECL|function|setDepthMask
name|void
name|Context
operator|::
name|setDepthMask
parameter_list|(
name|bool
name|mask
parameter_list|)
block|{
name|mState
operator|.
name|depthStencil
operator|.
name|depthMask
operator|=
name|mask
expr_stmt|;
block|}
DECL|function|setActiveSampler
name|void
name|Context
operator|::
name|setActiveSampler
parameter_list|(
name|unsigned
name|int
name|active
parameter_list|)
block|{
name|mState
operator|.
name|activeSampler
operator|=
name|active
expr_stmt|;
block|}
DECL|function|getReadFramebufferHandle
name|GLuint
name|Context
operator|::
name|getReadFramebufferHandle
parameter_list|()
specifier|const
block|{
return|return
name|mState
operator|.
name|readFramebuffer
return|;
block|}
DECL|function|getDrawFramebufferHandle
name|GLuint
name|Context
operator|::
name|getDrawFramebufferHandle
parameter_list|()
specifier|const
block|{
return|return
name|mState
operator|.
name|drawFramebuffer
return|;
block|}
DECL|function|getRenderbufferHandle
name|GLuint
name|Context
operator|::
name|getRenderbufferHandle
parameter_list|()
specifier|const
block|{
return|return
name|mState
operator|.
name|renderbuffer
operator|.
name|id
argument_list|()
return|;
block|}
DECL|function|getArrayBufferHandle
name|GLuint
name|Context
operator|::
name|getArrayBufferHandle
parameter_list|()
specifier|const
block|{
return|return
name|mState
operator|.
name|arrayBuffer
operator|.
name|id
argument_list|()
return|;
block|}
DECL|function|getActiveQuery
name|GLuint
name|Context
operator|::
name|getActiveQuery
parameter_list|(
name|GLenum
name|target
parameter_list|)
specifier|const
block|{
name|Query
modifier|*
name|queryObject
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_ANY_SAMPLES_PASSED_EXT
case|:
name|queryObject
operator|=
name|mState
operator|.
name|activeQuery
index|[
name|QUERY_ANY_SAMPLES_PASSED
index|]
operator|.
name|get
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_ANY_SAMPLES_PASSED_CONSERVATIVE_EXT
case|:
name|queryObject
operator|=
name|mState
operator|.
name|activeQuery
index|[
name|QUERY_ANY_SAMPLES_PASSED_CONSERVATIVE
index|]
operator|.
name|get
argument_list|()
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|queryObject
condition|)
block|{
return|return
name|queryObject
operator|->
name|id
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
DECL|function|setEnableVertexAttribArray
name|void
name|Context
operator|::
name|setEnableVertexAttribArray
parameter_list|(
name|unsigned
name|int
name|attribNum
parameter_list|,
name|bool
name|enabled
parameter_list|)
block|{
name|mState
operator|.
name|vertexAttribute
index|[
name|attribNum
index|]
operator|.
name|mArrayEnabled
operator|=
name|enabled
expr_stmt|;
block|}
DECL|function|getVertexAttribState
specifier|const
name|VertexAttribute
modifier|&
name|Context
operator|::
name|getVertexAttribState
parameter_list|(
name|unsigned
name|int
name|attribNum
parameter_list|)
block|{
return|return
name|mState
operator|.
name|vertexAttribute
index|[
name|attribNum
index|]
return|;
block|}
DECL|function|setVertexAttribState
name|void
name|Context
operator|::
name|setVertexAttribState
parameter_list|(
name|unsigned
name|int
name|attribNum
parameter_list|,
name|Buffer
modifier|*
name|boundBuffer
parameter_list|,
name|GLint
name|size
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|bool
name|normalized
parameter_list|,
name|GLsizei
name|stride
parameter_list|,
specifier|const
name|void
modifier|*
name|pointer
parameter_list|)
block|{
name|mState
operator|.
name|vertexAttribute
index|[
name|attribNum
index|]
operator|.
name|mBoundBuffer
operator|.
name|set
argument_list|(
name|boundBuffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|vertexAttribute
index|[
name|attribNum
index|]
operator|.
name|mSize
operator|=
name|size
expr_stmt|;
name|mState
operator|.
name|vertexAttribute
index|[
name|attribNum
index|]
operator|.
name|mType
operator|=
name|type
expr_stmt|;
name|mState
operator|.
name|vertexAttribute
index|[
name|attribNum
index|]
operator|.
name|mNormalized
operator|=
name|normalized
expr_stmt|;
name|mState
operator|.
name|vertexAttribute
index|[
name|attribNum
index|]
operator|.
name|mStride
operator|=
name|stride
expr_stmt|;
name|mState
operator|.
name|vertexAttribute
index|[
name|attribNum
index|]
operator|.
name|mPointer
operator|=
name|pointer
expr_stmt|;
block|}
DECL|function|getVertexAttribPointer
specifier|const
name|void
modifier|*
name|Context
operator|::
name|getVertexAttribPointer
parameter_list|(
name|unsigned
name|int
name|attribNum
parameter_list|)
specifier|const
block|{
return|return
name|mState
operator|.
name|vertexAttribute
index|[
name|attribNum
index|]
operator|.
name|mPointer
return|;
block|}
DECL|function|setPackAlignment
name|void
name|Context
operator|::
name|setPackAlignment
parameter_list|(
name|GLint
name|alignment
parameter_list|)
block|{
name|mState
operator|.
name|packAlignment
operator|=
name|alignment
expr_stmt|;
block|}
DECL|function|getPackAlignment
name|GLint
name|Context
operator|::
name|getPackAlignment
parameter_list|()
specifier|const
block|{
return|return
name|mState
operator|.
name|packAlignment
return|;
block|}
DECL|function|setUnpackAlignment
name|void
name|Context
operator|::
name|setUnpackAlignment
parameter_list|(
name|GLint
name|alignment
parameter_list|)
block|{
name|mState
operator|.
name|unpackAlignment
operator|=
name|alignment
expr_stmt|;
block|}
DECL|function|getUnpackAlignment
name|GLint
name|Context
operator|::
name|getUnpackAlignment
parameter_list|()
specifier|const
block|{
return|return
name|mState
operator|.
name|unpackAlignment
return|;
block|}
DECL|function|setPackReverseRowOrder
name|void
name|Context
operator|::
name|setPackReverseRowOrder
parameter_list|(
name|bool
name|reverseRowOrder
parameter_list|)
block|{
name|mState
operator|.
name|packReverseRowOrder
operator|=
name|reverseRowOrder
expr_stmt|;
block|}
DECL|function|getPackReverseRowOrder
name|bool
name|Context
operator|::
name|getPackReverseRowOrder
parameter_list|()
specifier|const
block|{
return|return
name|mState
operator|.
name|packReverseRowOrder
return|;
block|}
DECL|function|createBuffer
name|GLuint
name|Context
operator|::
name|createBuffer
parameter_list|()
block|{
return|return
name|mResourceManager
operator|->
name|createBuffer
argument_list|()
return|;
block|}
DECL|function|createProgram
name|GLuint
name|Context
operator|::
name|createProgram
parameter_list|()
block|{
return|return
name|mResourceManager
operator|->
name|createProgram
argument_list|()
return|;
block|}
DECL|function|createShader
name|GLuint
name|Context
operator|::
name|createShader
parameter_list|(
name|GLenum
name|type
parameter_list|)
block|{
return|return
name|mResourceManager
operator|->
name|createShader
argument_list|(
name|type
argument_list|)
return|;
block|}
DECL|function|createTexture
name|GLuint
name|Context
operator|::
name|createTexture
parameter_list|()
block|{
return|return
name|mResourceManager
operator|->
name|createTexture
argument_list|()
return|;
block|}
DECL|function|createRenderbuffer
name|GLuint
name|Context
operator|::
name|createRenderbuffer
parameter_list|()
block|{
return|return
name|mResourceManager
operator|->
name|createRenderbuffer
argument_list|()
return|;
block|}
comment|// Returns an unused framebuffer name
DECL|function|createFramebuffer
name|GLuint
name|Context
operator|::
name|createFramebuffer
parameter_list|()
block|{
name|GLuint
name|handle
init|=
name|mFramebufferHandleAllocator
operator|.
name|allocate
argument_list|()
decl_stmt|;
name|mFramebufferMap
index|[
name|handle
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|handle
return|;
block|}
DECL|function|createFence
name|GLuint
name|Context
operator|::
name|createFence
parameter_list|()
block|{
name|GLuint
name|handle
init|=
name|mFenceHandleAllocator
operator|.
name|allocate
argument_list|()
decl_stmt|;
name|mFenceMap
index|[
name|handle
index|]
operator|=
operator|new
name|Fence
argument_list|(
name|mRenderer
argument_list|)
expr_stmt|;
return|return
name|handle
return|;
block|}
comment|// Returns an unused query name
DECL|function|createQuery
name|GLuint
name|Context
operator|::
name|createQuery
parameter_list|()
block|{
name|GLuint
name|handle
init|=
name|mQueryHandleAllocator
operator|.
name|allocate
argument_list|()
decl_stmt|;
name|mQueryMap
index|[
name|handle
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|handle
return|;
block|}
DECL|function|deleteBuffer
name|void
name|Context
operator|::
name|deleteBuffer
parameter_list|(
name|GLuint
name|buffer
parameter_list|)
block|{
if|if
condition|(
name|mResourceManager
operator|->
name|getBuffer
argument_list|(
name|buffer
argument_list|)
condition|)
block|{
name|detachBuffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
name|mResourceManager
operator|->
name|deleteBuffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
DECL|function|deleteShader
name|void
name|Context
operator|::
name|deleteShader
parameter_list|(
name|GLuint
name|shader
parameter_list|)
block|{
name|mResourceManager
operator|->
name|deleteShader
argument_list|(
name|shader
argument_list|)
expr_stmt|;
block|}
DECL|function|deleteProgram
name|void
name|Context
operator|::
name|deleteProgram
parameter_list|(
name|GLuint
name|program
parameter_list|)
block|{
name|mResourceManager
operator|->
name|deleteProgram
argument_list|(
name|program
argument_list|)
expr_stmt|;
block|}
DECL|function|deleteTexture
name|void
name|Context
operator|::
name|deleteTexture
parameter_list|(
name|GLuint
name|texture
parameter_list|)
block|{
if|if
condition|(
name|mResourceManager
operator|->
name|getTexture
argument_list|(
name|texture
argument_list|)
condition|)
block|{
name|detachTexture
argument_list|(
name|texture
argument_list|)
expr_stmt|;
block|}
name|mResourceManager
operator|->
name|deleteTexture
argument_list|(
name|texture
argument_list|)
expr_stmt|;
block|}
DECL|function|deleteRenderbuffer
name|void
name|Context
operator|::
name|deleteRenderbuffer
parameter_list|(
name|GLuint
name|renderbuffer
parameter_list|)
block|{
if|if
condition|(
name|mResourceManager
operator|->
name|getRenderbuffer
argument_list|(
name|renderbuffer
argument_list|)
condition|)
block|{
name|detachRenderbuffer
argument_list|(
name|renderbuffer
argument_list|)
expr_stmt|;
block|}
name|mResourceManager
operator|->
name|deleteRenderbuffer
argument_list|(
name|renderbuffer
argument_list|)
expr_stmt|;
block|}
DECL|function|deleteFramebuffer
name|void
name|Context
operator|::
name|deleteFramebuffer
parameter_list|(
name|GLuint
name|framebuffer
parameter_list|)
block|{
name|FramebufferMap
operator|::
name|iterator
name|framebufferObject
init|=
name|mFramebufferMap
operator|.
name|find
argument_list|(
name|framebuffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|framebufferObject
operator|!=
name|mFramebufferMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|detachFramebuffer
argument_list|(
name|framebuffer
argument_list|)
expr_stmt|;
name|mFramebufferHandleAllocator
operator|.
name|release
argument_list|(
name|framebufferObject
operator|->
name|first
argument_list|)
expr_stmt|;
operator|delete
name|framebufferObject
operator|->
name|second
expr_stmt|;
name|mFramebufferMap
operator|.
name|erase
argument_list|(
name|framebufferObject
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|deleteFence
name|void
name|Context
operator|::
name|deleteFence
parameter_list|(
name|GLuint
name|fence
parameter_list|)
block|{
name|FenceMap
operator|::
name|iterator
name|fenceObject
init|=
name|mFenceMap
operator|.
name|find
argument_list|(
name|fence
argument_list|)
decl_stmt|;
if|if
condition|(
name|fenceObject
operator|!=
name|mFenceMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|mFenceHandleAllocator
operator|.
name|release
argument_list|(
name|fenceObject
operator|->
name|first
argument_list|)
expr_stmt|;
operator|delete
name|fenceObject
operator|->
name|second
expr_stmt|;
name|mFenceMap
operator|.
name|erase
argument_list|(
name|fenceObject
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|deleteQuery
name|void
name|Context
operator|::
name|deleteQuery
parameter_list|(
name|GLuint
name|query
parameter_list|)
block|{
name|QueryMap
operator|::
name|iterator
name|queryObject
init|=
name|mQueryMap
operator|.
name|find
argument_list|(
name|query
argument_list|)
decl_stmt|;
if|if
condition|(
name|queryObject
operator|!=
name|mQueryMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|mQueryHandleAllocator
operator|.
name|release
argument_list|(
name|queryObject
operator|->
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|queryObject
operator|->
name|second
condition|)
block|{
name|queryObject
operator|->
name|second
operator|->
name|release
argument_list|()
expr_stmt|;
block|}
name|mQueryMap
operator|.
name|erase
argument_list|(
name|queryObject
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|getBuffer
name|Buffer
modifier|*
name|Context
operator|::
name|getBuffer
parameter_list|(
name|GLuint
name|handle
parameter_list|)
block|{
return|return
name|mResourceManager
operator|->
name|getBuffer
argument_list|(
name|handle
argument_list|)
return|;
block|}
DECL|function|getShader
name|Shader
modifier|*
name|Context
operator|::
name|getShader
parameter_list|(
name|GLuint
name|handle
parameter_list|)
block|{
return|return
name|mResourceManager
operator|->
name|getShader
argument_list|(
name|handle
argument_list|)
return|;
block|}
DECL|function|getProgram
name|Program
modifier|*
name|Context
operator|::
name|getProgram
parameter_list|(
name|GLuint
name|handle
parameter_list|)
block|{
return|return
name|mResourceManager
operator|->
name|getProgram
argument_list|(
name|handle
argument_list|)
return|;
block|}
DECL|function|getTexture
name|Texture
modifier|*
name|Context
operator|::
name|getTexture
parameter_list|(
name|GLuint
name|handle
parameter_list|)
block|{
return|return
name|mResourceManager
operator|->
name|getTexture
argument_list|(
name|handle
argument_list|)
return|;
block|}
DECL|function|getRenderbuffer
name|Renderbuffer
modifier|*
name|Context
operator|::
name|getRenderbuffer
parameter_list|(
name|GLuint
name|handle
parameter_list|)
block|{
return|return
name|mResourceManager
operator|->
name|getRenderbuffer
argument_list|(
name|handle
argument_list|)
return|;
block|}
DECL|function|getReadFramebuffer
name|Framebuffer
modifier|*
name|Context
operator|::
name|getReadFramebuffer
parameter_list|()
block|{
return|return
name|getFramebuffer
argument_list|(
name|mState
operator|.
name|readFramebuffer
argument_list|)
return|;
block|}
DECL|function|getDrawFramebuffer
name|Framebuffer
modifier|*
name|Context
operator|::
name|getDrawFramebuffer
parameter_list|()
block|{
return|return
name|mBoundDrawFramebuffer
return|;
block|}
DECL|function|bindArrayBuffer
name|void
name|Context
operator|::
name|bindArrayBuffer
parameter_list|(
name|unsigned
name|int
name|buffer
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkBufferAllocation
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|arrayBuffer
operator|.
name|set
argument_list|(
name|getBuffer
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindElementArrayBuffer
name|void
name|Context
operator|::
name|bindElementArrayBuffer
parameter_list|(
name|unsigned
name|int
name|buffer
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkBufferAllocation
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|elementArrayBuffer
operator|.
name|set
argument_list|(
name|getBuffer
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindTexture2D
name|void
name|Context
operator|::
name|bindTexture2D
parameter_list|(
name|GLuint
name|texture
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkTextureAllocation
argument_list|(
name|texture
argument_list|,
name|TEXTURE_2D
argument_list|)
expr_stmt|;
name|mState
operator|.
name|samplerTexture
index|[
name|TEXTURE_2D
index|]
index|[
name|mState
operator|.
name|activeSampler
index|]
operator|.
name|set
argument_list|(
name|getTexture
argument_list|(
name|texture
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindTextureCubeMap
name|void
name|Context
operator|::
name|bindTextureCubeMap
parameter_list|(
name|GLuint
name|texture
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkTextureAllocation
argument_list|(
name|texture
argument_list|,
name|TEXTURE_CUBE
argument_list|)
expr_stmt|;
name|mState
operator|.
name|samplerTexture
index|[
name|TEXTURE_CUBE
index|]
index|[
name|mState
operator|.
name|activeSampler
index|]
operator|.
name|set
argument_list|(
name|getTexture
argument_list|(
name|texture
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindReadFramebuffer
name|void
name|Context
operator|::
name|bindReadFramebuffer
parameter_list|(
name|GLuint
name|framebuffer
parameter_list|)
block|{
if|if
condition|(
operator|!
name|getFramebuffer
argument_list|(
name|framebuffer
argument_list|)
condition|)
block|{
name|mFramebufferMap
index|[
name|framebuffer
index|]
operator|=
operator|new
name|Framebuffer
argument_list|(
name|mRenderer
argument_list|)
expr_stmt|;
block|}
name|mState
operator|.
name|readFramebuffer
operator|=
name|framebuffer
expr_stmt|;
block|}
DECL|function|bindDrawFramebuffer
name|void
name|Context
operator|::
name|bindDrawFramebuffer
parameter_list|(
name|GLuint
name|framebuffer
parameter_list|)
block|{
if|if
condition|(
operator|!
name|getFramebuffer
argument_list|(
name|framebuffer
argument_list|)
condition|)
block|{
name|mFramebufferMap
index|[
name|framebuffer
index|]
operator|=
operator|new
name|Framebuffer
argument_list|(
name|mRenderer
argument_list|)
expr_stmt|;
block|}
name|mState
operator|.
name|drawFramebuffer
operator|=
name|framebuffer
expr_stmt|;
name|mBoundDrawFramebuffer
operator|=
name|getFramebuffer
argument_list|(
name|framebuffer
argument_list|)
expr_stmt|;
block|}
DECL|function|bindRenderbuffer
name|void
name|Context
operator|::
name|bindRenderbuffer
parameter_list|(
name|GLuint
name|renderbuffer
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkRenderbufferAllocation
argument_list|(
name|renderbuffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|renderbuffer
operator|.
name|set
argument_list|(
name|getRenderbuffer
argument_list|(
name|renderbuffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|useProgram
name|void
name|Context
operator|::
name|useProgram
parameter_list|(
name|GLuint
name|program
parameter_list|)
block|{
name|GLuint
name|priorProgram
init|=
name|mState
operator|.
name|currentProgram
decl_stmt|;
name|mState
operator|.
name|currentProgram
operator|=
name|program
expr_stmt|;
comment|// Must switch before trying to delete, otherwise it only gets flagged.
if|if
condition|(
name|priorProgram
operator|!=
name|program
condition|)
block|{
name|Program
modifier|*
name|newProgram
init|=
name|mResourceManager
operator|->
name|getProgram
argument_list|(
name|program
argument_list|)
decl_stmt|;
name|Program
modifier|*
name|oldProgram
init|=
name|mResourceManager
operator|->
name|getProgram
argument_list|(
name|priorProgram
argument_list|)
decl_stmt|;
name|mCurrentProgramBinary
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|newProgram
condition|)
block|{
name|newProgram
operator|->
name|addRef
argument_list|()
expr_stmt|;
name|mCurrentProgramBinary
operator|.
name|set
argument_list|(
name|newProgram
operator|->
name|getProgramBinary
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oldProgram
condition|)
block|{
name|oldProgram
operator|->
name|release
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|function|linkProgram
name|void
name|Context
operator|::
name|linkProgram
parameter_list|(
name|GLuint
name|program
parameter_list|)
block|{
name|Program
modifier|*
name|programObject
init|=
name|mResourceManager
operator|->
name|getProgram
argument_list|(
name|program
argument_list|)
decl_stmt|;
name|bool
name|linked
init|=
name|programObject
operator|->
name|link
argument_list|()
decl_stmt|;
comment|// if the current program was relinked successfully we
comment|// need to install the new executables
if|if
condition|(
name|linked
operator|&&
name|program
operator|==
name|mState
operator|.
name|currentProgram
condition|)
block|{
name|mCurrentProgramBinary
operator|.
name|set
argument_list|(
name|programObject
operator|->
name|getProgramBinary
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|setProgramBinary
name|void
name|Context
operator|::
name|setProgramBinary
parameter_list|(
name|GLuint
name|program
parameter_list|,
specifier|const
name|void
modifier|*
name|binary
parameter_list|,
name|GLint
name|length
parameter_list|)
block|{
name|Program
modifier|*
name|programObject
init|=
name|mResourceManager
operator|->
name|getProgram
argument_list|(
name|program
argument_list|)
decl_stmt|;
name|bool
name|loaded
init|=
name|programObject
operator|->
name|setProgramBinary
argument_list|(
name|binary
argument_list|,
name|length
argument_list|)
decl_stmt|;
comment|// if the current program was reloaded successfully we
comment|// need to install the new executables
if|if
condition|(
name|loaded
operator|&&
name|program
operator|==
name|mState
operator|.
name|currentProgram
condition|)
block|{
name|mCurrentProgramBinary
operator|.
name|set
argument_list|(
name|programObject
operator|->
name|getProgramBinary
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|beginQuery
name|void
name|Context
operator|::
name|beginQuery
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLuint
name|query
parameter_list|)
block|{
comment|// From EXT_occlusion_query_boolean: If BeginQueryEXT is called with an<id>
comment|// of zero, if the active query object name for<target> is non-zero (for the
comment|// targets ANY_SAMPLES_PASSED_EXT and ANY_SAMPLES_PASSED_CONSERVATIVE_EXT, if
comment|// the active query for either target is non-zero), if<id> is the name of an
comment|// existing query object whose type does not match<target>, or if<id> is the
comment|// active query object name for any query type, the error INVALID_OPERATION is
comment|// generated.
comment|// Ensure no other queries are active
comment|// NOTE: If other queries than occlusion are supported, we will need to check
comment|// separately that:
comment|//    a) The query ID passed is not the current active query for any target/type
comment|//    b) There are no active queries for the requested target (and in the case
comment|//       of GL_ANY_SAMPLES_PASSED_EXT and GL_ANY_SAMPLES_PASSED_CONSERVATIVE_EXT,
comment|//       no query may be active for either if glBeginQuery targets either.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|QUERY_TYPE_COUNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mState
operator|.
name|activeQuery
index|[
name|i
index|]
operator|.
name|get
argument_list|()
operator|!=
name|NULL
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
block|}
name|QueryType
name|qType
decl_stmt|;
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_ANY_SAMPLES_PASSED_EXT
case|:
name|qType
operator|=
name|QUERY_ANY_SAMPLES_PASSED
expr_stmt|;
break|break;
case|case
name|GL_ANY_SAMPLES_PASSED_CONSERVATIVE_EXT
case|:
name|qType
operator|=
name|QUERY_ANY_SAMPLES_PASSED_CONSERVATIVE
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return;
block|}
name|Query
modifier|*
name|queryObject
init|=
name|getQuery
argument_list|(
name|query
argument_list|,
literal|true
argument_list|,
name|target
argument_list|)
decl_stmt|;
comment|// check that name was obtained with glGenQueries
if|if
condition|(
operator|!
name|queryObject
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
comment|// check for type mismatch
if|if
condition|(
name|queryObject
operator|->
name|getType
argument_list|()
operator|!=
name|target
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
comment|// set query as active for specified target
name|mState
operator|.
name|activeQuery
index|[
name|qType
index|]
operator|.
name|set
argument_list|(
name|queryObject
argument_list|)
expr_stmt|;
comment|// begin query
name|queryObject
operator|->
name|begin
argument_list|()
expr_stmt|;
block|}
DECL|function|endQuery
name|void
name|Context
operator|::
name|endQuery
parameter_list|(
name|GLenum
name|target
parameter_list|)
block|{
name|QueryType
name|qType
decl_stmt|;
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_ANY_SAMPLES_PASSED_EXT
case|:
name|qType
operator|=
name|QUERY_ANY_SAMPLES_PASSED
expr_stmt|;
break|break;
case|case
name|GL_ANY_SAMPLES_PASSED_CONSERVATIVE_EXT
case|:
name|qType
operator|=
name|QUERY_ANY_SAMPLES_PASSED_CONSERVATIVE
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return;
block|}
name|Query
modifier|*
name|queryObject
init|=
name|mState
operator|.
name|activeQuery
index|[
name|qType
index|]
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|queryObject
operator|==
name|NULL
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|queryObject
operator|->
name|end
argument_list|()
expr_stmt|;
name|mState
operator|.
name|activeQuery
index|[
name|qType
index|]
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
DECL|function|setFramebufferZero
name|void
name|Context
operator|::
name|setFramebufferZero
parameter_list|(
name|Framebuffer
modifier|*
name|buffer
parameter_list|)
block|{
operator|delete
name|mFramebufferMap
index|[
literal|0
index|]
expr_stmt|;
name|mFramebufferMap
index|[
literal|0
index|]
operator|=
name|buffer
expr_stmt|;
if|if
condition|(
name|mState
operator|.
name|drawFramebuffer
operator|==
literal|0
condition|)
block|{
name|mBoundDrawFramebuffer
operator|=
name|buffer
expr_stmt|;
block|}
block|}
DECL|function|setRenderbufferStorage
name|void
name|Context
operator|::
name|setRenderbufferStorage
parameter_list|(
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|GLsizei
name|samples
parameter_list|)
block|{
name|RenderbufferStorage
modifier|*
name|renderbuffer
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|internalformat
condition|)
block|{
case|case
name|GL_DEPTH_COMPONENT16
case|:
name|renderbuffer
operator|=
operator|new
name|gl
operator|::
name|Depthbuffer
argument_list|(
name|mRenderer
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|samples
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_RGBA4
case|:
case|case
name|GL_RGB5_A1
case|:
case|case
name|GL_RGB565
case|:
case|case
name|GL_RGB8_OES
case|:
case|case
name|GL_RGBA8_OES
case|:
name|renderbuffer
operator|=
operator|new
name|gl
operator|::
name|Colorbuffer
argument_list|(
name|mRenderer
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|internalformat
argument_list|,
name|samples
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_INDEX8
case|:
name|renderbuffer
operator|=
operator|new
name|gl
operator|::
name|Stencilbuffer
argument_list|(
name|mRenderer
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|samples
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_DEPTH24_STENCIL8_OES
case|:
name|renderbuffer
operator|=
operator|new
name|gl
operator|::
name|DepthStencilbuffer
argument_list|(
name|mRenderer
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|samples
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return;
block|}
name|Renderbuffer
modifier|*
name|renderbufferObject
init|=
name|mState
operator|.
name|renderbuffer
operator|.
name|get
argument_list|()
decl_stmt|;
name|renderbufferObject
operator|->
name|setStorage
argument_list|(
name|renderbuffer
argument_list|)
expr_stmt|;
block|}
DECL|function|getFramebuffer
name|Framebuffer
modifier|*
name|Context
operator|::
name|getFramebuffer
parameter_list|(
name|unsigned
name|int
name|handle
parameter_list|)
block|{
name|FramebufferMap
operator|::
name|iterator
name|framebuffer
init|=
name|mFramebufferMap
operator|.
name|find
argument_list|(
name|handle
argument_list|)
decl_stmt|;
if|if
condition|(
name|framebuffer
operator|==
name|mFramebufferMap
operator|.
name|end
argument_list|()
condition|)
block|{
return|return
name|NULL
return|;
block|}
else|else
block|{
return|return
name|framebuffer
operator|->
name|second
return|;
block|}
block|}
DECL|function|getFence
name|Fence
modifier|*
name|Context
operator|::
name|getFence
parameter_list|(
name|unsigned
name|int
name|handle
parameter_list|)
block|{
name|FenceMap
operator|::
name|iterator
name|fence
init|=
name|mFenceMap
operator|.
name|find
argument_list|(
name|handle
argument_list|)
decl_stmt|;
if|if
condition|(
name|fence
operator|==
name|mFenceMap
operator|.
name|end
argument_list|()
condition|)
block|{
return|return
name|NULL
return|;
block|}
else|else
block|{
return|return
name|fence
operator|->
name|second
return|;
block|}
block|}
DECL|function|getQuery
name|Query
modifier|*
name|Context
operator|::
name|getQuery
parameter_list|(
name|unsigned
name|int
name|handle
parameter_list|,
name|bool
name|create
parameter_list|,
name|GLenum
name|type
parameter_list|)
block|{
name|QueryMap
operator|::
name|iterator
name|query
init|=
name|mQueryMap
operator|.
name|find
argument_list|(
name|handle
argument_list|)
decl_stmt|;
if|if
condition|(
name|query
operator|==
name|mQueryMap
operator|.
name|end
argument_list|()
condition|)
block|{
return|return
name|NULL
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|query
operator|->
name|second
operator|&&
name|create
condition|)
block|{
name|query
operator|->
name|second
operator|=
operator|new
name|Query
argument_list|(
name|mRenderer
argument_list|,
name|type
argument_list|,
name|handle
argument_list|)
expr_stmt|;
name|query
operator|->
name|second
operator|->
name|addRef
argument_list|()
expr_stmt|;
block|}
return|return
name|query
operator|->
name|second
return|;
block|}
block|}
DECL|function|getArrayBuffer
name|Buffer
modifier|*
name|Context
operator|::
name|getArrayBuffer
parameter_list|()
block|{
return|return
name|mState
operator|.
name|arrayBuffer
operator|.
name|get
argument_list|()
return|;
block|}
DECL|function|getElementArrayBuffer
name|Buffer
modifier|*
name|Context
operator|::
name|getElementArrayBuffer
parameter_list|()
block|{
return|return
name|mState
operator|.
name|elementArrayBuffer
operator|.
name|get
argument_list|()
return|;
block|}
DECL|function|getCurrentProgramBinary
name|ProgramBinary
modifier|*
name|Context
operator|::
name|getCurrentProgramBinary
parameter_list|()
block|{
return|return
name|mCurrentProgramBinary
operator|.
name|get
argument_list|()
return|;
block|}
DECL|function|getTexture2D
name|Texture2D
modifier|*
name|Context
operator|::
name|getTexture2D
parameter_list|()
block|{
return|return
cast|static_cast
argument_list|<
name|Texture2D
operator|*
argument_list|>
argument_list|(
name|getSamplerTexture
argument_list|(
name|mState
operator|.
name|activeSampler
argument_list|,
name|TEXTURE_2D
argument_list|)
argument_list|)
return|;
block|}
DECL|function|getTextureCubeMap
name|TextureCubeMap
modifier|*
name|Context
operator|::
name|getTextureCubeMap
parameter_list|()
block|{
return|return
cast|static_cast
argument_list|<
name|TextureCubeMap
operator|*
argument_list|>
argument_list|(
name|getSamplerTexture
argument_list|(
name|mState
operator|.
name|activeSampler
argument_list|,
name|TEXTURE_CUBE
argument_list|)
argument_list|)
return|;
block|}
DECL|function|getSamplerTexture
name|Texture
modifier|*
name|Context
operator|::
name|getSamplerTexture
parameter_list|(
name|unsigned
name|int
name|sampler
parameter_list|,
name|TextureType
name|type
parameter_list|)
block|{
name|GLuint
name|texid
init|=
name|mState
operator|.
name|samplerTexture
index|[
name|type
index|]
index|[
name|sampler
index|]
operator|.
name|id
argument_list|()
decl_stmt|;
if|if
condition|(
name|texid
operator|==
literal|0
condition|)
comment|// Special case: 0 refers to different initial textures based on the target
block|{
switch|switch
condition|(
name|type
condition|)
block|{
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
case|case
name|TEXTURE_2D
case|:
return|return
name|mTexture2DZero
operator|.
name|get
argument_list|()
return|;
case|case
name|TEXTURE_CUBE
case|:
return|return
name|mTextureCubeMapZero
operator|.
name|get
argument_list|()
return|;
block|}
block|}
return|return
name|mState
operator|.
name|samplerTexture
index|[
name|type
index|]
index|[
name|sampler
index|]
operator|.
name|get
argument_list|()
return|;
block|}
DECL|function|getBooleanv
name|bool
name|Context
operator|::
name|getBooleanv
parameter_list|(
name|GLenum
name|pname
parameter_list|,
name|GLboolean
modifier|*
name|params
parameter_list|)
block|{
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_SHADER_COMPILER
case|:
operator|*
name|params
operator|=
name|GL_TRUE
expr_stmt|;
break|break;
case|case
name|GL_SAMPLE_COVERAGE_INVERT
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|sampleCoverageInvert
expr_stmt|;
break|break;
case|case
name|GL_DEPTH_WRITEMASK
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|depthStencil
operator|.
name|depthMask
expr_stmt|;
break|break;
case|case
name|GL_COLOR_WRITEMASK
case|:
name|params
index|[
literal|0
index|]
operator|=
name|mState
operator|.
name|blend
operator|.
name|colorMaskRed
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|mState
operator|.
name|blend
operator|.
name|colorMaskGreen
expr_stmt|;
name|params
index|[
literal|2
index|]
operator|=
name|mState
operator|.
name|blend
operator|.
name|colorMaskBlue
expr_stmt|;
name|params
index|[
literal|3
index|]
operator|=
name|mState
operator|.
name|blend
operator|.
name|colorMaskAlpha
expr_stmt|;
break|break;
case|case
name|GL_CULL_FACE
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|rasterizer
operator|.
name|cullFace
expr_stmt|;
break|break;
case|case
name|GL_POLYGON_OFFSET_FILL
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|rasterizer
operator|.
name|polygonOffsetFill
expr_stmt|;
break|break;
case|case
name|GL_SAMPLE_ALPHA_TO_COVERAGE
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|blend
operator|.
name|sampleAlphaToCoverage
expr_stmt|;
break|break;
case|case
name|GL_SAMPLE_COVERAGE
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|sampleCoverage
expr_stmt|;
break|break;
case|case
name|GL_SCISSOR_TEST
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|scissorTest
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_TEST
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|depthStencil
operator|.
name|stencilTest
expr_stmt|;
break|break;
case|case
name|GL_DEPTH_TEST
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|depthStencil
operator|.
name|depthTest
expr_stmt|;
break|break;
case|case
name|GL_BLEND
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|blend
operator|.
name|blend
expr_stmt|;
break|break;
case|case
name|GL_DITHER
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|blend
operator|.
name|dither
expr_stmt|;
break|break;
case|case
name|GL_CONTEXT_ROBUST_ACCESS_EXT
case|:
operator|*
name|params
operator|=
name|mRobustAccess
condition|?
name|GL_TRUE
else|:
name|GL_FALSE
expr_stmt|;
break|break;
default|default:
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|getFloatv
name|bool
name|Context
operator|::
name|getFloatv
parameter_list|(
name|GLenum
name|pname
parameter_list|,
name|GLfloat
modifier|*
name|params
parameter_list|)
block|{
comment|// Please note: DEPTH_CLEAR_VALUE is included in our internal getFloatv implementation
comment|// because it is stored as a float, despite the fact that the GL ES 2.0 spec names
comment|// GetIntegerv as its native query function. As it would require conversion in any
comment|// case, this should make no difference to the calling application.
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_LINE_WIDTH
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|lineWidth
expr_stmt|;
break|break;
case|case
name|GL_SAMPLE_COVERAGE_VALUE
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|sampleCoverageValue
expr_stmt|;
break|break;
case|case
name|GL_DEPTH_CLEAR_VALUE
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|depthClearValue
expr_stmt|;
break|break;
case|case
name|GL_POLYGON_OFFSET_FACTOR
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|rasterizer
operator|.
name|polygonOffsetFactor
expr_stmt|;
break|break;
case|case
name|GL_POLYGON_OFFSET_UNITS
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|rasterizer
operator|.
name|polygonOffsetUnits
expr_stmt|;
break|break;
case|case
name|GL_ALIASED_LINE_WIDTH_RANGE
case|:
name|params
index|[
literal|0
index|]
operator|=
name|gl
operator|::
name|ALIASED_LINE_WIDTH_RANGE_MIN
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|gl
operator|::
name|ALIASED_LINE_WIDTH_RANGE_MAX
expr_stmt|;
break|break;
case|case
name|GL_ALIASED_POINT_SIZE_RANGE
case|:
name|params
index|[
literal|0
index|]
operator|=
name|gl
operator|::
name|ALIASED_POINT_SIZE_RANGE_MIN
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|getMaximumPointSize
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_DEPTH_RANGE
case|:
name|params
index|[
literal|0
index|]
operator|=
name|mState
operator|.
name|zNear
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|mState
operator|.
name|zFar
expr_stmt|;
break|break;
case|case
name|GL_COLOR_CLEAR_VALUE
case|:
name|params
index|[
literal|0
index|]
operator|=
name|mState
operator|.
name|colorClearValue
operator|.
name|red
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|mState
operator|.
name|colorClearValue
operator|.
name|green
expr_stmt|;
name|params
index|[
literal|2
index|]
operator|=
name|mState
operator|.
name|colorClearValue
operator|.
name|blue
expr_stmt|;
name|params
index|[
literal|3
index|]
operator|=
name|mState
operator|.
name|colorClearValue
operator|.
name|alpha
expr_stmt|;
break|break;
case|case
name|GL_BLEND_COLOR
case|:
name|params
index|[
literal|0
index|]
operator|=
name|mState
operator|.
name|blendColor
operator|.
name|red
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|mState
operator|.
name|blendColor
operator|.
name|green
expr_stmt|;
name|params
index|[
literal|2
index|]
operator|=
name|mState
operator|.
name|blendColor
operator|.
name|blue
expr_stmt|;
name|params
index|[
literal|3
index|]
operator|=
name|mState
operator|.
name|blendColor
operator|.
name|alpha
expr_stmt|;
break|break;
case|case
name|GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT
case|:
if|if
condition|(
operator|!
name|supportsTextureFilterAnisotropy
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
operator|*
name|params
operator|=
name|mMaxTextureAnisotropy
expr_stmt|;
break|break;
default|default:
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|getIntegerv
name|bool
name|Context
operator|::
name|getIntegerv
parameter_list|(
name|GLenum
name|pname
parameter_list|,
name|GLint
modifier|*
name|params
parameter_list|)
block|{
if|if
condition|(
name|pname
operator|>=
name|GL_DRAW_BUFFER0_EXT
operator|&&
name|pname
operator|<=
name|GL_DRAW_BUFFER15_EXT
condition|)
block|{
name|unsigned
name|int
name|colorAttachment
init|=
operator|(
name|pname
operator|-
name|GL_DRAW_BUFFER0_EXT
operator|)
decl_stmt|;
if|if
condition|(
name|colorAttachment
operator|>=
name|mRenderer
operator|->
name|getMaxRenderTargets
argument_list|()
condition|)
block|{
comment|// return true to stop further operation in the parent call
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|true
argument_list|)
return|;
block|}
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
operator|*
name|params
operator|=
name|framebuffer
operator|->
name|getDrawBufferState
argument_list|(
name|colorAttachment
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// Please note: DEPTH_CLEAR_VALUE is not included in our internal getIntegerv implementation
comment|// because it is stored as a float, despite the fact that the GL ES 2.0 spec names
comment|// GetIntegerv as its native query function. As it would require conversion in any
comment|// case, this should make no difference to the calling application. You may find it in
comment|// Context::getFloatv.
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_MAX_VERTEX_ATTRIBS
case|:
operator|*
name|params
operator|=
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
expr_stmt|;
break|break;
case|case
name|GL_MAX_VERTEX_UNIFORM_VECTORS
case|:
operator|*
name|params
operator|=
name|mRenderer
operator|->
name|getMaxVertexUniformVectors
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_MAX_VARYING_VECTORS
case|:
operator|*
name|params
operator|=
name|mRenderer
operator|->
name|getMaxVaryingVectors
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS
case|:
operator|*
name|params
operator|=
name|mRenderer
operator|->
name|getMaxCombinedTextureImageUnits
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS
case|:
operator|*
name|params
operator|=
name|mRenderer
operator|->
name|getMaxVertexTextureImageUnits
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_MAX_TEXTURE_IMAGE_UNITS
case|:
operator|*
name|params
operator|=
name|gl
operator|::
name|MAX_TEXTURE_IMAGE_UNITS
expr_stmt|;
break|break;
case|case
name|GL_MAX_FRAGMENT_UNIFORM_VECTORS
case|:
operator|*
name|params
operator|=
name|mRenderer
operator|->
name|getMaxFragmentUniformVectors
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_MAX_RENDERBUFFER_SIZE
case|:
operator|*
name|params
operator|=
name|getMaximumRenderbufferDimension
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_MAX_COLOR_ATTACHMENTS_EXT
case|:
operator|*
name|params
operator|=
name|mRenderer
operator|->
name|getMaxRenderTargets
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_MAX_DRAW_BUFFERS_EXT
case|:
operator|*
name|params
operator|=
name|mRenderer
operator|->
name|getMaxRenderTargets
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_NUM_SHADER_BINARY_FORMATS
case|:
operator|*
name|params
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|GL_SHADER_BINARY_FORMATS
case|:
comment|/* no shader binary formats are supported */
break|break;
case|case
name|GL_ARRAY_BUFFER_BINDING
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|arrayBuffer
operator|.
name|id
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_ELEMENT_ARRAY_BUFFER_BINDING
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|elementArrayBuffer
operator|.
name|id
argument_list|()
expr_stmt|;
break|break;
comment|//case GL_FRAMEBUFFER_BINDING:            // now equivalent to GL_DRAW_FRAMEBUFFER_BINDING_ANGLE
case|case
name|GL_DRAW_FRAMEBUFFER_BINDING_ANGLE
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|drawFramebuffer
expr_stmt|;
break|break;
case|case
name|GL_READ_FRAMEBUFFER_BINDING_ANGLE
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|readFramebuffer
expr_stmt|;
break|break;
case|case
name|GL_RENDERBUFFER_BINDING
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|renderbuffer
operator|.
name|id
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_CURRENT_PROGRAM
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|currentProgram
expr_stmt|;
break|break;
case|case
name|GL_PACK_ALIGNMENT
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|packAlignment
expr_stmt|;
break|break;
case|case
name|GL_PACK_REVERSE_ROW_ORDER_ANGLE
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|packReverseRowOrder
expr_stmt|;
break|break;
case|case
name|GL_UNPACK_ALIGNMENT
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|unpackAlignment
expr_stmt|;
break|break;
case|case
name|GL_GENERATE_MIPMAP_HINT
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|generateMipmapHint
expr_stmt|;
break|break;
case|case
name|GL_FRAGMENT_SHADER_DERIVATIVE_HINT_OES
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|fragmentShaderDerivativeHint
expr_stmt|;
break|break;
case|case
name|GL_ACTIVE_TEXTURE
case|:
operator|*
name|params
operator|=
operator|(
name|mState
operator|.
name|activeSampler
operator|+
name|GL_TEXTURE0
operator|)
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_FUNC
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|depthStencil
operator|.
name|stencilFunc
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_REF
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|stencilRef
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_VALUE_MASK
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|depthStencil
operator|.
name|stencilMask
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_BACK_FUNC
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|depthStencil
operator|.
name|stencilBackFunc
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_BACK_REF
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|stencilBackRef
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_BACK_VALUE_MASK
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|depthStencil
operator|.
name|stencilBackMask
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_FAIL
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|depthStencil
operator|.
name|stencilFail
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_PASS_DEPTH_FAIL
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|depthStencil
operator|.
name|stencilPassDepthFail
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_PASS_DEPTH_PASS
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|depthStencil
operator|.
name|stencilPassDepthPass
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_BACK_FAIL
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|depthStencil
operator|.
name|stencilBackFail
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_BACK_PASS_DEPTH_FAIL
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|depthStencil
operator|.
name|stencilBackPassDepthFail
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_BACK_PASS_DEPTH_PASS
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|depthStencil
operator|.
name|stencilBackPassDepthPass
expr_stmt|;
break|break;
case|case
name|GL_DEPTH_FUNC
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|depthStencil
operator|.
name|depthFunc
expr_stmt|;
break|break;
case|case
name|GL_BLEND_SRC_RGB
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|blend
operator|.
name|sourceBlendRGB
expr_stmt|;
break|break;
case|case
name|GL_BLEND_SRC_ALPHA
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|blend
operator|.
name|sourceBlendAlpha
expr_stmt|;
break|break;
case|case
name|GL_BLEND_DST_RGB
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|blend
operator|.
name|destBlendRGB
expr_stmt|;
break|break;
case|case
name|GL_BLEND_DST_ALPHA
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|blend
operator|.
name|destBlendAlpha
expr_stmt|;
break|break;
case|case
name|GL_BLEND_EQUATION_RGB
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|blend
operator|.
name|blendEquationRGB
expr_stmt|;
break|break;
case|case
name|GL_BLEND_EQUATION_ALPHA
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|blend
operator|.
name|blendEquationAlpha
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_WRITEMASK
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|depthStencil
operator|.
name|stencilWritemask
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_BACK_WRITEMASK
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|depthStencil
operator|.
name|stencilBackWritemask
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_CLEAR_VALUE
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|stencilClearValue
expr_stmt|;
break|break;
case|case
name|GL_SUBPIXEL_BITS
case|:
operator|*
name|params
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|GL_MAX_TEXTURE_SIZE
case|:
operator|*
name|params
operator|=
name|getMaximumTextureDimension
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_MAX_CUBE_MAP_TEXTURE_SIZE
case|:
operator|*
name|params
operator|=
name|getMaximumCubeTextureDimension
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_NUM_COMPRESSED_TEXTURE_FORMATS
case|:
name|params
index|[
literal|0
index|]
operator|=
name|mNumCompressedTextureFormats
expr_stmt|;
break|break;
case|case
name|GL_MAX_SAMPLES_ANGLE
case|:
block|{
name|GLsizei
name|maxSamples
init|=
name|getMaxSupportedSamples
argument_list|()
decl_stmt|;
if|if
condition|(
name|maxSamples
operator|!=
literal|0
condition|)
block|{
operator|*
name|params
operator|=
name|maxSamples
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
break|break;
block|}
case|case
name|GL_SAMPLE_BUFFERS
case|:
case|case
name|GL_SAMPLES
case|:
block|{
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|framebuffer
operator|->
name|completeness
argument_list|()
operator|==
name|GL_FRAMEBUFFER_COMPLETE
condition|)
block|{
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_SAMPLE_BUFFERS
case|:
if|if
condition|(
name|framebuffer
operator|->
name|getSamples
argument_list|()
operator|!=
literal|0
condition|)
block|{
operator|*
name|params
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|params
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|GL_SAMPLES
case|:
operator|*
name|params
operator|=
name|framebuffer
operator|->
name|getSamples
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
operator|*
name|params
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GL_IMPLEMENTATION_COLOR_READ_TYPE
case|:
case|case
name|GL_IMPLEMENTATION_COLOR_READ_FORMAT
case|:
block|{
name|GLenum
name|format
decl_stmt|,
name|type
decl_stmt|;
if|if
condition|(
name|getCurrentReadFormatType
argument_list|(
operator|&
name|format
argument_list|,
operator|&
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|pname
operator|==
name|GL_IMPLEMENTATION_COLOR_READ_FORMAT
condition|)
operator|*
name|params
operator|=
name|format
expr_stmt|;
else|else
operator|*
name|params
operator|=
name|type
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GL_MAX_VIEWPORT_DIMS
case|:
block|{
name|params
index|[
literal|0
index|]
operator|=
name|mMaxViewportDimension
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|mMaxViewportDimension
expr_stmt|;
block|}
break|break;
case|case
name|GL_COMPRESSED_TEXTURE_FORMATS
case|:
block|{
if|if
condition|(
name|supportsDXT1Textures
argument_list|()
condition|)
block|{
operator|*
name|params
operator|++
operator|=
name|GL_COMPRESSED_RGB_S3TC_DXT1_EXT
expr_stmt|;
operator|*
name|params
operator|++
operator|=
name|GL_COMPRESSED_RGBA_S3TC_DXT1_EXT
expr_stmt|;
block|}
if|if
condition|(
name|supportsDXT3Textures
argument_list|()
condition|)
block|{
operator|*
name|params
operator|++
operator|=
name|GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE
expr_stmt|;
block|}
if|if
condition|(
name|supportsDXT5Textures
argument_list|()
condition|)
block|{
operator|*
name|params
operator|++
operator|=
name|GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GL_VIEWPORT
case|:
name|params
index|[
literal|0
index|]
operator|=
name|mState
operator|.
name|viewport
operator|.
name|x
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|mState
operator|.
name|viewport
operator|.
name|y
expr_stmt|;
name|params
index|[
literal|2
index|]
operator|=
name|mState
operator|.
name|viewport
operator|.
name|width
expr_stmt|;
name|params
index|[
literal|3
index|]
operator|=
name|mState
operator|.
name|viewport
operator|.
name|height
expr_stmt|;
break|break;
case|case
name|GL_SCISSOR_BOX
case|:
name|params
index|[
literal|0
index|]
operator|=
name|mState
operator|.
name|scissor
operator|.
name|x
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|mState
operator|.
name|scissor
operator|.
name|y
expr_stmt|;
name|params
index|[
literal|2
index|]
operator|=
name|mState
operator|.
name|scissor
operator|.
name|width
expr_stmt|;
name|params
index|[
literal|3
index|]
operator|=
name|mState
operator|.
name|scissor
operator|.
name|height
expr_stmt|;
break|break;
case|case
name|GL_CULL_FACE_MODE
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|rasterizer
operator|.
name|cullMode
expr_stmt|;
break|break;
case|case
name|GL_FRONT_FACE
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|rasterizer
operator|.
name|frontFace
expr_stmt|;
break|break;
case|case
name|GL_RED_BITS
case|:
case|case
name|GL_GREEN_BITS
case|:
case|case
name|GL_BLUE_BITS
case|:
case|case
name|GL_ALPHA_BITS
case|:
block|{
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
name|gl
operator|::
name|Renderbuffer
modifier|*
name|colorbuffer
init|=
name|framebuffer
operator|->
name|getFirstColorbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|colorbuffer
condition|)
block|{
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_RED_BITS
case|:
operator|*
name|params
operator|=
name|colorbuffer
operator|->
name|getRedSize
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_GREEN_BITS
case|:
operator|*
name|params
operator|=
name|colorbuffer
operator|->
name|getGreenSize
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_BLUE_BITS
case|:
operator|*
name|params
operator|=
name|colorbuffer
operator|->
name|getBlueSize
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_ALPHA_BITS
case|:
operator|*
name|params
operator|=
name|colorbuffer
operator|->
name|getAlphaSize
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
operator|*
name|params
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GL_DEPTH_BITS
case|:
block|{
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
name|gl
operator|::
name|Renderbuffer
modifier|*
name|depthbuffer
init|=
name|framebuffer
operator|->
name|getDepthbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|depthbuffer
condition|)
block|{
operator|*
name|params
operator|=
name|depthbuffer
operator|->
name|getDepthSize
argument_list|()
expr_stmt|;
block|}
else|else
block|{
operator|*
name|params
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GL_STENCIL_BITS
case|:
block|{
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
name|gl
operator|::
name|Renderbuffer
modifier|*
name|stencilbuffer
init|=
name|framebuffer
operator|->
name|getStencilbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|stencilbuffer
condition|)
block|{
operator|*
name|params
operator|=
name|stencilbuffer
operator|->
name|getStencilSize
argument_list|()
expr_stmt|;
block|}
else|else
block|{
operator|*
name|params
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GL_TEXTURE_BINDING_2D
case|:
block|{
if|if
condition|(
name|mState
operator|.
name|activeSampler
operator|>
name|mRenderer
operator|->
name|getMaxCombinedTextureImageUnits
argument_list|()
operator|-
literal|1
condition|)
block|{
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
operator|*
name|params
operator|=
name|mState
operator|.
name|samplerTexture
index|[
name|TEXTURE_2D
index|]
index|[
name|mState
operator|.
name|activeSampler
index|]
operator|.
name|id
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|GL_TEXTURE_BINDING_CUBE_MAP
case|:
block|{
if|if
condition|(
name|mState
operator|.
name|activeSampler
operator|>
name|mRenderer
operator|->
name|getMaxCombinedTextureImageUnits
argument_list|()
operator|-
literal|1
condition|)
block|{
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
operator|*
name|params
operator|=
name|mState
operator|.
name|samplerTexture
index|[
name|TEXTURE_CUBE
index|]
index|[
name|mState
operator|.
name|activeSampler
index|]
operator|.
name|id
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|GL_RESET_NOTIFICATION_STRATEGY_EXT
case|:
operator|*
name|params
operator|=
name|mResetStrategy
expr_stmt|;
break|break;
case|case
name|GL_NUM_PROGRAM_BINARY_FORMATS_OES
case|:
operator|*
name|params
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|GL_PROGRAM_BINARY_FORMATS_OES
case|:
operator|*
name|params
operator|=
name|GL_PROGRAM_BINARY_ANGLE
expr_stmt|;
break|break;
default|default:
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|getQueryParameterInfo
name|bool
name|Context
operator|::
name|getQueryParameterInfo
parameter_list|(
name|GLenum
name|pname
parameter_list|,
name|GLenum
modifier|*
name|type
parameter_list|,
name|unsigned
name|int
modifier|*
name|numParams
parameter_list|)
block|{
if|if
condition|(
name|pname
operator|>=
name|GL_DRAW_BUFFER0_EXT
operator|&&
name|pname
operator|<=
name|GL_DRAW_BUFFER15_EXT
condition|)
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// Please note: the query type returned for DEPTH_CLEAR_VALUE in this implementation
comment|// is FLOAT rather than INT, as would be suggested by the GL ES 2.0 spec. This is due
comment|// to the fact that it is stored internally as a float, and so would require conversion
comment|// if returned from Context::getIntegerv. Since this conversion is already implemented
comment|// in the case that one calls glGetIntegerv to retrieve a float-typed state variable, we
comment|// place DEPTH_CLEAR_VALUE with the floats. This should make no difference to the calling
comment|// application.
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_COMPRESSED_TEXTURE_FORMATS
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
name|mNumCompressedTextureFormats
expr_stmt|;
block|}
break|break;
case|case
name|GL_SHADER_BINARY_FORMATS
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|GL_MAX_VERTEX_ATTRIBS
case|:
case|case
name|GL_MAX_VERTEX_UNIFORM_VECTORS
case|:
case|case
name|GL_MAX_VARYING_VECTORS
case|:
case|case
name|GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS
case|:
case|case
name|GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS
case|:
case|case
name|GL_MAX_TEXTURE_IMAGE_UNITS
case|:
case|case
name|GL_MAX_FRAGMENT_UNIFORM_VECTORS
case|:
case|case
name|GL_MAX_RENDERBUFFER_SIZE
case|:
case|case
name|GL_MAX_COLOR_ATTACHMENTS_EXT
case|:
case|case
name|GL_MAX_DRAW_BUFFERS_EXT
case|:
case|case
name|GL_NUM_SHADER_BINARY_FORMATS
case|:
case|case
name|GL_NUM_COMPRESSED_TEXTURE_FORMATS
case|:
case|case
name|GL_ARRAY_BUFFER_BINDING
case|:
case|case
name|GL_FRAMEBUFFER_BINDING
case|:
case|case
name|GL_RENDERBUFFER_BINDING
case|:
case|case
name|GL_CURRENT_PROGRAM
case|:
case|case
name|GL_PACK_ALIGNMENT
case|:
case|case
name|GL_PACK_REVERSE_ROW_ORDER_ANGLE
case|:
case|case
name|GL_UNPACK_ALIGNMENT
case|:
case|case
name|GL_GENERATE_MIPMAP_HINT
case|:
case|case
name|GL_FRAGMENT_SHADER_DERIVATIVE_HINT_OES
case|:
case|case
name|GL_RED_BITS
case|:
case|case
name|GL_GREEN_BITS
case|:
case|case
name|GL_BLUE_BITS
case|:
case|case
name|GL_ALPHA_BITS
case|:
case|case
name|GL_DEPTH_BITS
case|:
case|case
name|GL_STENCIL_BITS
case|:
case|case
name|GL_ELEMENT_ARRAY_BUFFER_BINDING
case|:
case|case
name|GL_CULL_FACE_MODE
case|:
case|case
name|GL_FRONT_FACE
case|:
case|case
name|GL_ACTIVE_TEXTURE
case|:
case|case
name|GL_STENCIL_FUNC
case|:
case|case
name|GL_STENCIL_VALUE_MASK
case|:
case|case
name|GL_STENCIL_REF
case|:
case|case
name|GL_STENCIL_FAIL
case|:
case|case
name|GL_STENCIL_PASS_DEPTH_FAIL
case|:
case|case
name|GL_STENCIL_PASS_DEPTH_PASS
case|:
case|case
name|GL_STENCIL_BACK_FUNC
case|:
case|case
name|GL_STENCIL_BACK_VALUE_MASK
case|:
case|case
name|GL_STENCIL_BACK_REF
case|:
case|case
name|GL_STENCIL_BACK_FAIL
case|:
case|case
name|GL_STENCIL_BACK_PASS_DEPTH_FAIL
case|:
case|case
name|GL_STENCIL_BACK_PASS_DEPTH_PASS
case|:
case|case
name|GL_DEPTH_FUNC
case|:
case|case
name|GL_BLEND_SRC_RGB
case|:
case|case
name|GL_BLEND_SRC_ALPHA
case|:
case|case
name|GL_BLEND_DST_RGB
case|:
case|case
name|GL_BLEND_DST_ALPHA
case|:
case|case
name|GL_BLEND_EQUATION_RGB
case|:
case|case
name|GL_BLEND_EQUATION_ALPHA
case|:
case|case
name|GL_STENCIL_WRITEMASK
case|:
case|case
name|GL_STENCIL_BACK_WRITEMASK
case|:
case|case
name|GL_STENCIL_CLEAR_VALUE
case|:
case|case
name|GL_SUBPIXEL_BITS
case|:
case|case
name|GL_MAX_TEXTURE_SIZE
case|:
case|case
name|GL_MAX_CUBE_MAP_TEXTURE_SIZE
case|:
case|case
name|GL_SAMPLE_BUFFERS
case|:
case|case
name|GL_SAMPLES
case|:
case|case
name|GL_IMPLEMENTATION_COLOR_READ_TYPE
case|:
case|case
name|GL_IMPLEMENTATION_COLOR_READ_FORMAT
case|:
case|case
name|GL_TEXTURE_BINDING_2D
case|:
case|case
name|GL_TEXTURE_BINDING_CUBE_MAP
case|:
case|case
name|GL_RESET_NOTIFICATION_STRATEGY_EXT
case|:
case|case
name|GL_NUM_PROGRAM_BINARY_FORMATS_OES
case|:
case|case
name|GL_PROGRAM_BINARY_FORMATS_OES
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|GL_MAX_SAMPLES_ANGLE
case|:
block|{
if|if
condition|(
name|getMaxSupportedSamples
argument_list|()
operator|!=
literal|0
condition|)
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
break|break;
case|case
name|GL_MAX_VIEWPORT_DIMS
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|2
expr_stmt|;
block|}
break|break;
case|case
name|GL_VIEWPORT
case|:
case|case
name|GL_SCISSOR_BOX
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|4
expr_stmt|;
block|}
break|break;
case|case
name|GL_SHADER_COMPILER
case|:
case|case
name|GL_SAMPLE_COVERAGE_INVERT
case|:
case|case
name|GL_DEPTH_WRITEMASK
case|:
case|case
name|GL_CULL_FACE
case|:
comment|// CULL_FACE through DITHER are natural to IsEnabled,
case|case
name|GL_POLYGON_OFFSET_FILL
case|:
comment|// but can be retrieved through the Get{Type}v queries.
case|case
name|GL_SAMPLE_ALPHA_TO_COVERAGE
case|:
comment|// For this purpose, they are treated here as bool-natural
case|case
name|GL_SAMPLE_COVERAGE
case|:
case|case
name|GL_SCISSOR_TEST
case|:
case|case
name|GL_STENCIL_TEST
case|:
case|case
name|GL_DEPTH_TEST
case|:
case|case
name|GL_BLEND
case|:
case|case
name|GL_DITHER
case|:
case|case
name|GL_CONTEXT_ROBUST_ACCESS_EXT
case|:
block|{
operator|*
name|type
operator|=
name|GL_BOOL
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|GL_COLOR_WRITEMASK
case|:
block|{
operator|*
name|type
operator|=
name|GL_BOOL
expr_stmt|;
operator|*
name|numParams
operator|=
literal|4
expr_stmt|;
block|}
break|break;
case|case
name|GL_POLYGON_OFFSET_FACTOR
case|:
case|case
name|GL_POLYGON_OFFSET_UNITS
case|:
case|case
name|GL_SAMPLE_COVERAGE_VALUE
case|:
case|case
name|GL_DEPTH_CLEAR_VALUE
case|:
case|case
name|GL_LINE_WIDTH
case|:
block|{
operator|*
name|type
operator|=
name|GL_FLOAT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|GL_ALIASED_LINE_WIDTH_RANGE
case|:
case|case
name|GL_ALIASED_POINT_SIZE_RANGE
case|:
case|case
name|GL_DEPTH_RANGE
case|:
block|{
operator|*
name|type
operator|=
name|GL_FLOAT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|2
expr_stmt|;
block|}
break|break;
case|case
name|GL_COLOR_CLEAR_VALUE
case|:
case|case
name|GL_BLEND_COLOR
case|:
block|{
operator|*
name|type
operator|=
name|GL_FLOAT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|4
expr_stmt|;
block|}
break|break;
case|case
name|GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT
case|:
if|if
condition|(
operator|!
name|supportsTextureFilterAnisotropy
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
operator|*
name|type
operator|=
name|GL_FLOAT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|// Applies the render target surface, depth stencil surface, viewport rectangle and
comment|// scissor rectangle to the renderer
DECL|function|applyRenderTarget
name|bool
name|Context
operator|::
name|applyRenderTarget
parameter_list|(
name|GLenum
name|drawMode
parameter_list|,
name|bool
name|ignoreViewport
parameter_list|)
block|{
name|Framebuffer
modifier|*
name|framebufferObject
init|=
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|framebufferObject
operator|||
name|framebufferObject
operator|->
name|completeness
argument_list|()
operator|!=
name|GL_FRAMEBUFFER_COMPLETE
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_FRAMEBUFFER_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|mRenderer
operator|->
name|applyRenderTarget
argument_list|(
name|framebufferObject
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mRenderer
operator|->
name|setViewport
argument_list|(
name|mState
operator|.
name|viewport
argument_list|,
name|mState
operator|.
name|zNear
argument_list|,
name|mState
operator|.
name|zFar
argument_list|,
name|drawMode
argument_list|,
name|mState
operator|.
name|rasterizer
operator|.
name|frontFace
argument_list|,
name|ignoreViewport
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|mRenderer
operator|->
name|setScissorRectangle
argument_list|(
name|mState
operator|.
name|scissor
argument_list|,
name|mState
operator|.
name|scissorTest
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// Applies the fixed-function state (culling, depth test, alpha blending, stenciling, etc) to the Direct3D 9 device
DECL|function|applyState
name|void
name|Context
operator|::
name|applyState
parameter_list|(
name|GLenum
name|drawMode
parameter_list|)
block|{
name|mState
operator|.
name|rasterizer
operator|.
name|pointDrawMode
operator|=
operator|(
name|drawMode
operator|==
name|GL_POINTS
operator|)
expr_stmt|;
name|mRenderer
operator|->
name|setRasterizerState
argument_list|(
name|mState
operator|.
name|rasterizer
argument_list|)
expr_stmt|;
name|unsigned
name|int
name|mask
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mState
operator|.
name|sampleCoverage
condition|)
block|{
if|if
condition|(
name|mState
operator|.
name|sampleCoverageValue
operator|!=
literal|0
condition|)
block|{
name|Framebuffer
modifier|*
name|framebufferObject
init|=
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
name|float
name|threshold
init|=
literal|0.5f
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|framebufferObject
operator|->
name|getSamples
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|mask
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|mState
operator|.
name|sampleCoverageValue
operator|>=
name|threshold
condition|)
block|{
name|threshold
operator|+=
literal|1.0f
expr_stmt|;
name|mask
operator||=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|mState
operator|.
name|sampleCoverageInvert
condition|)
block|{
name|mask
operator|=
operator|~
name|mask
expr_stmt|;
block|}
block|}
else|else
block|{
name|mask
operator|=
literal|0xFFFFFFFF
expr_stmt|;
block|}
name|mRenderer
operator|->
name|setBlendState
argument_list|(
name|mState
operator|.
name|blend
argument_list|,
name|mState
operator|.
name|blendColor
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|mRenderer
operator|->
name|setDepthStencilState
argument_list|(
name|mState
operator|.
name|depthStencil
argument_list|,
name|mState
operator|.
name|stencilRef
argument_list|,
name|mState
operator|.
name|stencilBackRef
argument_list|,
name|mState
operator|.
name|rasterizer
operator|.
name|frontFace
operator|==
name|GL_CCW
argument_list|)
expr_stmt|;
block|}
comment|// Applies the shaders and shader constants to the Direct3D 9 device
DECL|function|applyShaders
name|void
name|Context
operator|::
name|applyShaders
parameter_list|()
block|{
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|getCurrentProgramBinary
argument_list|()
decl_stmt|;
name|mRenderer
operator|->
name|applyShaders
argument_list|(
name|programBinary
argument_list|)
expr_stmt|;
name|programBinary
operator|->
name|applyUniforms
argument_list|()
expr_stmt|;
block|}
comment|// Applies the textures and sampler states to the Direct3D 9 device
DECL|function|applyTextures
name|void
name|Context
operator|::
name|applyTextures
parameter_list|()
block|{
name|applyTextures
argument_list|(
name|SAMPLER_PIXEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mSupportsVertexTexture
condition|)
block|{
name|applyTextures
argument_list|(
name|SAMPLER_VERTEX
argument_list|)
expr_stmt|;
block|}
block|}
comment|// For each Direct3D 9 sampler of either the pixel or vertex stage,
comment|// looks up the corresponding OpenGL texture image unit and texture type,
comment|// and sets the texture and its addressing/filtering state (or NULL when inactive).
DECL|function|applyTextures
name|void
name|Context
operator|::
name|applyTextures
parameter_list|(
name|SamplerType
name|type
parameter_list|)
block|{
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|getCurrentProgramBinary
argument_list|()
decl_stmt|;
comment|// Range of Direct3D samplers of given sampler type
name|int
name|samplerCount
init|=
operator|(
name|type
operator|==
name|SAMPLER_PIXEL
operator|)
condition|?
name|MAX_TEXTURE_IMAGE_UNITS
else|:
name|mRenderer
operator|->
name|getMaxVertexTextureImageUnits
argument_list|()
decl_stmt|;
name|int
name|samplerRange
init|=
name|programBinary
operator|->
name|getUsedSamplerRange
argument_list|(
name|type
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|samplerIndex
init|=
literal|0
init|;
name|samplerIndex
operator|<
name|samplerRange
condition|;
name|samplerIndex
operator|++
control|)
block|{
name|int
name|textureUnit
init|=
name|programBinary
operator|->
name|getSamplerMapping
argument_list|(
name|type
argument_list|,
name|samplerIndex
argument_list|)
decl_stmt|;
comment|// OpenGL texture image unit index
if|if
condition|(
name|textureUnit
operator|!=
operator|-
literal|1
condition|)
block|{
name|TextureType
name|textureType
init|=
name|programBinary
operator|->
name|getSamplerTextureType
argument_list|(
name|type
argument_list|,
name|samplerIndex
argument_list|)
decl_stmt|;
name|Texture
modifier|*
name|texture
init|=
name|getSamplerTexture
argument_list|(
name|textureUnit
argument_list|,
name|textureType
argument_list|)
decl_stmt|;
if|if
condition|(
name|texture
operator|->
name|isSamplerComplete
argument_list|()
condition|)
block|{
name|SamplerState
name|samplerState
decl_stmt|;
name|texture
operator|->
name|getSamplerState
argument_list|(
operator|&
name|samplerState
argument_list|)
expr_stmt|;
name|mRenderer
operator|->
name|setSamplerState
argument_list|(
name|type
argument_list|,
name|samplerIndex
argument_list|,
name|samplerState
argument_list|)
expr_stmt|;
name|mRenderer
operator|->
name|setTexture
argument_list|(
name|type
argument_list|,
name|samplerIndex
argument_list|,
name|texture
argument_list|)
expr_stmt|;
name|texture
operator|->
name|resetDirty
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|mRenderer
operator|->
name|setTexture
argument_list|(
name|type
argument_list|,
name|samplerIndex
argument_list|,
name|getIncompleteTexture
argument_list|(
name|textureType
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|mRenderer
operator|->
name|setTexture
argument_list|(
name|type
argument_list|,
name|samplerIndex
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|samplerIndex
init|=
name|samplerRange
init|;
name|samplerIndex
operator|<
name|samplerCount
condition|;
name|samplerIndex
operator|++
control|)
block|{
name|mRenderer
operator|->
name|setTexture
argument_list|(
name|type
argument_list|,
name|samplerIndex
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|readPixels
name|void
name|Context
operator|::
name|readPixels
parameter_list|(
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLsizei
modifier|*
name|bufSize
parameter_list|,
name|void
modifier|*
name|pixels
parameter_list|)
block|{
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|getReadFramebuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|framebuffer
operator|->
name|completeness
argument_list|()
operator|!=
name|GL_FRAMEBUFFER_COMPLETE
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_FRAMEBUFFER_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
name|getReadFramebufferHandle
argument_list|()
operator|!=
literal|0
operator|&&
name|framebuffer
operator|->
name|getSamples
argument_list|()
operator|!=
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|GLsizei
name|outputPitch
init|=
name|ComputePitch
argument_list|(
name|width
argument_list|,
name|ConvertSizedInternalFormat
argument_list|(
name|format
argument_list|,
name|type
argument_list|)
argument_list|,
name|getPackAlignment
argument_list|()
argument_list|)
decl_stmt|;
comment|// sized query sanity check
if|if
condition|(
name|bufSize
condition|)
block|{
name|int
name|requiredSize
init|=
name|outputPitch
operator|*
name|height
decl_stmt|;
if|if
condition|(
name|requiredSize
operator|>
operator|*
name|bufSize
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
block|}
name|mRenderer
operator|->
name|readPixels
argument_list|(
name|framebuffer
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|outputPitch
argument_list|,
name|getPackReverseRowOrder
argument_list|()
argument_list|,
name|getPackAlignment
argument_list|()
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
block|}
DECL|function|clear
name|void
name|Context
operator|::
name|clear
parameter_list|(
name|GLbitfield
name|mask
parameter_list|)
block|{
name|Framebuffer
modifier|*
name|framebufferObject
init|=
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|framebufferObject
operator|||
name|framebufferObject
operator|->
name|completeness
argument_list|()
operator|!=
name|GL_FRAMEBUFFER_COMPLETE
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_FRAMEBUFFER_OPERATION
argument_list|)
return|;
block|}
name|DWORD
name|flags
init|=
literal|0
decl_stmt|;
name|GLbitfield
name|finalMask
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mask
operator|&
name|GL_COLOR_BUFFER_BIT
condition|)
block|{
name|mask
operator|&=
operator|~
name|GL_COLOR_BUFFER_BIT
expr_stmt|;
if|if
condition|(
name|framebufferObject
operator|->
name|hasEnabledColorAttachment
argument_list|()
condition|)
block|{
name|finalMask
operator||=
name|GL_COLOR_BUFFER_BIT
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|GL_DEPTH_BUFFER_BIT
condition|)
block|{
name|mask
operator|&=
operator|~
name|GL_DEPTH_BUFFER_BIT
expr_stmt|;
if|if
condition|(
name|mState
operator|.
name|depthStencil
operator|.
name|depthMask
operator|&&
name|framebufferObject
operator|->
name|getDepthbufferType
argument_list|()
operator|!=
name|GL_NONE
condition|)
block|{
name|finalMask
operator||=
name|GL_DEPTH_BUFFER_BIT
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|GL_STENCIL_BUFFER_BIT
condition|)
block|{
name|mask
operator|&=
operator|~
name|GL_STENCIL_BUFFER_BIT
expr_stmt|;
if|if
condition|(
name|framebufferObject
operator|->
name|getStencilbufferType
argument_list|()
operator|!=
name|GL_NONE
condition|)
block|{
name|rx
operator|::
name|RenderTarget
modifier|*
name|depthStencil
init|=
name|framebufferObject
operator|->
name|getStencilbuffer
argument_list|()
operator|->
name|getDepthStencil
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|depthStencil
condition|)
block|{
name|ERR
argument_list|(
literal|"Depth stencil pointer unexpectedly null."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GetStencilSize
argument_list|(
name|depthStencil
operator|->
name|getActualFormat
argument_list|()
argument_list|)
operator|>
literal|0
condition|)
block|{
name|finalMask
operator||=
name|GL_STENCIL_BUFFER_BIT
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|mask
operator|!=
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|applyRenderTarget
argument_list|(
name|GL_TRIANGLES
argument_list|,
literal|true
argument_list|)
condition|)
comment|// Clips the clear to the scissor rectangle but not the viewport
block|{
return|return;
block|}
name|ClearParameters
name|clearParams
decl_stmt|;
name|clearParams
operator|.
name|mask
operator|=
name|finalMask
expr_stmt|;
name|clearParams
operator|.
name|colorClearValue
operator|=
name|mState
operator|.
name|colorClearValue
expr_stmt|;
name|clearParams
operator|.
name|colorMaskRed
operator|=
name|mState
operator|.
name|blend
operator|.
name|colorMaskRed
expr_stmt|;
name|clearParams
operator|.
name|colorMaskGreen
operator|=
name|mState
operator|.
name|blend
operator|.
name|colorMaskGreen
expr_stmt|;
name|clearParams
operator|.
name|colorMaskBlue
operator|=
name|mState
operator|.
name|blend
operator|.
name|colorMaskBlue
expr_stmt|;
name|clearParams
operator|.
name|colorMaskAlpha
operator|=
name|mState
operator|.
name|blend
operator|.
name|colorMaskAlpha
expr_stmt|;
name|clearParams
operator|.
name|depthClearValue
operator|=
name|mState
operator|.
name|depthClearValue
expr_stmt|;
name|clearParams
operator|.
name|stencilClearValue
operator|=
name|mState
operator|.
name|stencilClearValue
expr_stmt|;
name|clearParams
operator|.
name|stencilWriteMask
operator|=
name|mState
operator|.
name|depthStencil
operator|.
name|stencilWritemask
expr_stmt|;
name|mRenderer
operator|->
name|clear
argument_list|(
name|clearParams
argument_list|,
name|framebufferObject
argument_list|)
expr_stmt|;
block|}
DECL|function|drawArrays
name|void
name|Context
operator|::
name|drawArrays
parameter_list|(
name|GLenum
name|mode
parameter_list|,
name|GLint
name|first
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLsizei
name|instances
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mState
operator|.
name|currentProgram
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|mRenderer
operator|->
name|applyPrimitiveType
argument_list|(
name|mode
argument_list|,
name|count
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|applyRenderTarget
argument_list|(
name|mode
argument_list|,
literal|false
argument_list|)
condition|)
block|{
return|return;
block|}
name|applyState
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|getCurrentProgramBinary
argument_list|()
decl_stmt|;
name|GLenum
name|err
init|=
name|mRenderer
operator|->
name|applyVertexBuffer
argument_list|(
name|programBinary
argument_list|,
name|mState
operator|.
name|vertexAttribute
argument_list|,
name|first
argument_list|,
name|count
argument_list|,
name|instances
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|!=
name|GL_NO_ERROR
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|err
argument_list|)
return|;
block|}
name|applyShaders
argument_list|()
expr_stmt|;
name|applyTextures
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|programBinary
operator|->
name|validateSamplers
argument_list|(
name|NULL
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|skipDraw
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|mRenderer
operator|->
name|drawArrays
argument_list|(
name|mode
argument_list|,
name|count
argument_list|,
name|instances
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|drawElements
name|void
name|Context
operator|::
name|drawElements
parameter_list|(
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|GLsizei
name|instances
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mState
operator|.
name|currentProgram
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|indices
operator|&&
operator|!
name|mState
operator|.
name|elementArrayBuffer
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|mRenderer
operator|->
name|applyPrimitiveType
argument_list|(
name|mode
argument_list|,
name|count
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|applyRenderTarget
argument_list|(
name|mode
argument_list|,
literal|false
argument_list|)
condition|)
block|{
return|return;
block|}
name|applyState
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|rx
operator|::
name|TranslatedIndexData
name|indexInfo
decl_stmt|;
name|GLenum
name|err
init|=
name|mRenderer
operator|->
name|applyIndexBuffer
argument_list|(
name|indices
argument_list|,
name|mState
operator|.
name|elementArrayBuffer
operator|.
name|get
argument_list|()
argument_list|,
name|count
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
operator|&
name|indexInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|!=
name|GL_NO_ERROR
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|err
argument_list|)
return|;
block|}
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|getCurrentProgramBinary
argument_list|()
decl_stmt|;
name|GLsizei
name|vertexCount
init|=
name|indexInfo
operator|.
name|maxIndex
operator|-
name|indexInfo
operator|.
name|minIndex
operator|+
literal|1
decl_stmt|;
name|err
operator|=
name|mRenderer
operator|->
name|applyVertexBuffer
argument_list|(
name|programBinary
argument_list|,
name|mState
operator|.
name|vertexAttribute
argument_list|,
name|indexInfo
operator|.
name|minIndex
argument_list|,
name|vertexCount
argument_list|,
name|instances
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|GL_NO_ERROR
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|err
argument_list|)
return|;
block|}
name|applyShaders
argument_list|()
expr_stmt|;
name|applyTextures
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|programBinary
operator|->
name|validateSamplers
argument_list|(
name|NULL
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|skipDraw
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|mRenderer
operator|->
name|drawElements
argument_list|(
name|mode
argument_list|,
name|count
argument_list|,
name|type
argument_list|,
name|indices
argument_list|,
name|mState
operator|.
name|elementArrayBuffer
operator|.
name|get
argument_list|()
argument_list|,
name|indexInfo
argument_list|,
name|instances
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Implements glFlush when block is false, glFinish when block is true
DECL|function|sync
name|void
name|Context
operator|::
name|sync
parameter_list|(
name|bool
name|block
parameter_list|)
block|{
name|mRenderer
operator|->
name|sync
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
DECL|function|recordInvalidEnum
name|void
name|Context
operator|::
name|recordInvalidEnum
parameter_list|()
block|{
name|mInvalidEnum
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|recordInvalidValue
name|void
name|Context
operator|::
name|recordInvalidValue
parameter_list|()
block|{
name|mInvalidValue
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|recordInvalidOperation
name|void
name|Context
operator|::
name|recordInvalidOperation
parameter_list|()
block|{
name|mInvalidOperation
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|recordOutOfMemory
name|void
name|Context
operator|::
name|recordOutOfMemory
parameter_list|()
block|{
name|mOutOfMemory
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|recordInvalidFramebufferOperation
name|void
name|Context
operator|::
name|recordInvalidFramebufferOperation
parameter_list|()
block|{
name|mInvalidFramebufferOperation
operator|=
literal|true
expr_stmt|;
block|}
comment|// Get one of the recorded errors and clear its flag, if any.
comment|// [OpenGL ES 2.0.24] section 2.5 page 13.
DECL|function|getError
name|GLenum
name|Context
operator|::
name|getError
parameter_list|()
block|{
if|if
condition|(
name|mInvalidEnum
condition|)
block|{
name|mInvalidEnum
operator|=
literal|false
expr_stmt|;
return|return
name|GL_INVALID_ENUM
return|;
block|}
if|if
condition|(
name|mInvalidValue
condition|)
block|{
name|mInvalidValue
operator|=
literal|false
expr_stmt|;
return|return
name|GL_INVALID_VALUE
return|;
block|}
if|if
condition|(
name|mInvalidOperation
condition|)
block|{
name|mInvalidOperation
operator|=
literal|false
expr_stmt|;
return|return
name|GL_INVALID_OPERATION
return|;
block|}
if|if
condition|(
name|mOutOfMemory
condition|)
block|{
name|mOutOfMemory
operator|=
literal|false
expr_stmt|;
return|return
name|GL_OUT_OF_MEMORY
return|;
block|}
if|if
condition|(
name|mInvalidFramebufferOperation
condition|)
block|{
name|mInvalidFramebufferOperation
operator|=
literal|false
expr_stmt|;
return|return
name|GL_INVALID_FRAMEBUFFER_OPERATION
return|;
block|}
return|return
name|GL_NO_ERROR
return|;
block|}
DECL|function|getResetStatus
name|GLenum
name|Context
operator|::
name|getResetStatus
parameter_list|()
block|{
if|if
condition|(
name|mResetStatus
operator|==
name|GL_NO_ERROR
operator|&&
operator|!
name|mContextLost
condition|)
block|{
comment|// mResetStatus will be set by the markContextLost callback
comment|// in the case a notification is sent
name|mRenderer
operator|->
name|testDeviceLost
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|GLenum
name|status
init|=
name|mResetStatus
decl_stmt|;
if|if
condition|(
name|mResetStatus
operator|!=
name|GL_NO_ERROR
condition|)
block|{
name|ASSERT
argument_list|(
name|mContextLost
argument_list|)
expr_stmt|;
if|if
condition|(
name|mRenderer
operator|->
name|testDeviceResettable
argument_list|()
condition|)
block|{
name|mResetStatus
operator|=
name|GL_NO_ERROR
expr_stmt|;
block|}
block|}
return|return
name|status
return|;
block|}
DECL|function|isResetNotificationEnabled
name|bool
name|Context
operator|::
name|isResetNotificationEnabled
parameter_list|()
block|{
return|return
operator|(
name|mResetStrategy
operator|==
name|GL_LOSE_CONTEXT_ON_RESET_EXT
operator|)
return|;
block|}
DECL|function|getMajorShaderModel
name|int
name|Context
operator|::
name|getMajorShaderModel
parameter_list|()
specifier|const
block|{
return|return
name|mMajorShaderModel
return|;
block|}
DECL|function|getMaximumPointSize
name|float
name|Context
operator|::
name|getMaximumPointSize
parameter_list|()
specifier|const
block|{
return|return
name|mMaximumPointSize
return|;
block|}
DECL|function|getMaximumCombinedTextureImageUnits
name|unsigned
name|int
name|Context
operator|::
name|getMaximumCombinedTextureImageUnits
parameter_list|()
specifier|const
block|{
return|return
name|mRenderer
operator|->
name|getMaxCombinedTextureImageUnits
argument_list|()
return|;
block|}
DECL|function|getMaxSupportedSamples
name|int
name|Context
operator|::
name|getMaxSupportedSamples
parameter_list|()
specifier|const
block|{
return|return
name|mRenderer
operator|->
name|getMaxSupportedSamples
argument_list|()
return|;
block|}
DECL|function|getMaximumRenderTargets
name|unsigned
name|int
name|Context
operator|::
name|getMaximumRenderTargets
parameter_list|()
specifier|const
block|{
return|return
name|mRenderer
operator|->
name|getMaxRenderTargets
argument_list|()
return|;
block|}
DECL|function|supportsEventQueries
name|bool
name|Context
operator|::
name|supportsEventQueries
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsEventQueries
return|;
block|}
DECL|function|supportsOcclusionQueries
name|bool
name|Context
operator|::
name|supportsOcclusionQueries
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsOcclusionQueries
return|;
block|}
DECL|function|supportsBGRATextures
name|bool
name|Context
operator|::
name|supportsBGRATextures
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsBGRATextures
return|;
block|}
DECL|function|supportsDXT1Textures
name|bool
name|Context
operator|::
name|supportsDXT1Textures
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsDXT1Textures
return|;
block|}
DECL|function|supportsDXT3Textures
name|bool
name|Context
operator|::
name|supportsDXT3Textures
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsDXT3Textures
return|;
block|}
DECL|function|supportsDXT5Textures
name|bool
name|Context
operator|::
name|supportsDXT5Textures
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsDXT5Textures
return|;
block|}
DECL|function|supportsFloat32Textures
name|bool
name|Context
operator|::
name|supportsFloat32Textures
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsFloat32Textures
return|;
block|}
DECL|function|supportsFloat32LinearFilter
name|bool
name|Context
operator|::
name|supportsFloat32LinearFilter
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsFloat32LinearFilter
return|;
block|}
DECL|function|supportsFloat32RenderableTextures
name|bool
name|Context
operator|::
name|supportsFloat32RenderableTextures
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsFloat32RenderableTextures
return|;
block|}
DECL|function|supportsFloat16Textures
name|bool
name|Context
operator|::
name|supportsFloat16Textures
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsFloat16Textures
return|;
block|}
DECL|function|supportsFloat16LinearFilter
name|bool
name|Context
operator|::
name|supportsFloat16LinearFilter
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsFloat16LinearFilter
return|;
block|}
DECL|function|supportsFloat16RenderableTextures
name|bool
name|Context
operator|::
name|supportsFloat16RenderableTextures
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsFloat16RenderableTextures
return|;
block|}
DECL|function|getMaximumRenderbufferDimension
name|int
name|Context
operator|::
name|getMaximumRenderbufferDimension
parameter_list|()
specifier|const
block|{
return|return
name|mMaxRenderbufferDimension
return|;
block|}
DECL|function|getMaximumTextureDimension
name|int
name|Context
operator|::
name|getMaximumTextureDimension
parameter_list|()
specifier|const
block|{
return|return
name|mMaxTextureDimension
return|;
block|}
DECL|function|getMaximumCubeTextureDimension
name|int
name|Context
operator|::
name|getMaximumCubeTextureDimension
parameter_list|()
specifier|const
block|{
return|return
name|mMaxCubeTextureDimension
return|;
block|}
DECL|function|getMaximumTextureLevel
name|int
name|Context
operator|::
name|getMaximumTextureLevel
parameter_list|()
specifier|const
block|{
return|return
name|mMaxTextureLevel
return|;
block|}
DECL|function|supportsLuminanceTextures
name|bool
name|Context
operator|::
name|supportsLuminanceTextures
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsLuminanceTextures
return|;
block|}
DECL|function|supportsLuminanceAlphaTextures
name|bool
name|Context
operator|::
name|supportsLuminanceAlphaTextures
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsLuminanceAlphaTextures
return|;
block|}
DECL|function|supportsDepthTextures
name|bool
name|Context
operator|::
name|supportsDepthTextures
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsDepthTextures
return|;
block|}
DECL|function|supports32bitIndices
name|bool
name|Context
operator|::
name|supports32bitIndices
parameter_list|()
specifier|const
block|{
return|return
name|mSupports32bitIndices
return|;
block|}
DECL|function|supportsNonPower2Texture
name|bool
name|Context
operator|::
name|supportsNonPower2Texture
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsNonPower2Texture
return|;
block|}
DECL|function|supportsInstancing
name|bool
name|Context
operator|::
name|supportsInstancing
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsInstancing
return|;
block|}
DECL|function|supportsTextureFilterAnisotropy
name|bool
name|Context
operator|::
name|supportsTextureFilterAnisotropy
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsTextureFilterAnisotropy
return|;
block|}
DECL|function|getTextureMaxAnisotropy
name|float
name|Context
operator|::
name|getTextureMaxAnisotropy
parameter_list|()
specifier|const
block|{
return|return
name|mMaxTextureAnisotropy
return|;
block|}
DECL|function|getCurrentReadFormatType
name|bool
name|Context
operator|::
name|getCurrentReadFormatType
parameter_list|(
name|GLenum
modifier|*
name|format
parameter_list|,
name|GLenum
modifier|*
name|type
parameter_list|)
block|{
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|getReadFramebuffer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|framebuffer
operator|||
name|framebuffer
operator|->
name|completeness
argument_list|()
operator|!=
name|GL_FRAMEBUFFER_COMPLETE
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|Renderbuffer
modifier|*
name|renderbuffer
init|=
name|framebuffer
operator|->
name|getReadColorbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|renderbuffer
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
operator|*
name|format
operator|=
name|gl
operator|::
name|ExtractFormat
argument_list|(
name|renderbuffer
operator|->
name|getActualFormat
argument_list|()
argument_list|)
expr_stmt|;
operator|*
name|type
operator|=
name|gl
operator|::
name|ExtractType
argument_list|(
name|renderbuffer
operator|->
name|getActualFormat
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|detachBuffer
name|void
name|Context
operator|::
name|detachBuffer
parameter_list|(
name|GLuint
name|buffer
parameter_list|)
block|{
comment|// [OpenGL ES 2.0.24] section 2.9 page 22:
comment|// If a buffer object is deleted while it is bound, all bindings to that object in the current context
comment|// (i.e. in the thread that called Delete-Buffers) are reset to zero.
if|if
condition|(
name|mState
operator|.
name|arrayBuffer
operator|.
name|id
argument_list|()
operator|==
name|buffer
condition|)
block|{
name|mState
operator|.
name|arrayBuffer
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mState
operator|.
name|elementArrayBuffer
operator|.
name|id
argument_list|()
operator|==
name|buffer
condition|)
block|{
name|mState
operator|.
name|elementArrayBuffer
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|attribute
init|=
literal|0
init|;
name|attribute
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|attribute
operator|++
control|)
block|{
if|if
condition|(
name|mState
operator|.
name|vertexAttribute
index|[
name|attribute
index|]
operator|.
name|mBoundBuffer
operator|.
name|id
argument_list|()
operator|==
name|buffer
condition|)
block|{
name|mState
operator|.
name|vertexAttribute
index|[
name|attribute
index|]
operator|.
name|mBoundBuffer
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|detachTexture
name|void
name|Context
operator|::
name|detachTexture
parameter_list|(
name|GLuint
name|texture
parameter_list|)
block|{
comment|// [OpenGL ES 2.0.24] section 3.8 page 84:
comment|// If a texture object is deleted, it is as if all texture units which are bound to that texture object are
comment|// rebound to texture object zero
for|for
control|(
name|int
name|type
init|=
literal|0
init|;
name|type
operator|<
name|TEXTURE_TYPE_COUNT
condition|;
name|type
operator|++
control|)
block|{
for|for
control|(
name|int
name|sampler
init|=
literal|0
init|;
name|sampler
operator|<
name|IMPLEMENTATION_MAX_COMBINED_TEXTURE_IMAGE_UNITS
condition|;
name|sampler
operator|++
control|)
block|{
if|if
condition|(
name|mState
operator|.
name|samplerTexture
index|[
name|type
index|]
index|[
name|sampler
index|]
operator|.
name|id
argument_list|()
operator|==
name|texture
condition|)
block|{
name|mState
operator|.
name|samplerTexture
index|[
name|type
index|]
index|[
name|sampler
index|]
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// [OpenGL ES 2.0.24] section 4.4 page 112:
comment|// If a texture object is deleted while its image is attached to the currently bound framebuffer, then it is
comment|// as if FramebufferTexture2D had been called, with a texture of 0, for each attachment point to which this
comment|// image was attached in the currently bound framebuffer.
name|Framebuffer
modifier|*
name|readFramebuffer
init|=
name|getReadFramebuffer
argument_list|()
decl_stmt|;
name|Framebuffer
modifier|*
name|drawFramebuffer
init|=
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|readFramebuffer
condition|)
block|{
name|readFramebuffer
operator|->
name|detachTexture
argument_list|(
name|texture
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|drawFramebuffer
operator|&&
name|drawFramebuffer
operator|!=
name|readFramebuffer
condition|)
block|{
name|drawFramebuffer
operator|->
name|detachTexture
argument_list|(
name|texture
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|detachFramebuffer
name|void
name|Context
operator|::
name|detachFramebuffer
parameter_list|(
name|GLuint
name|framebuffer
parameter_list|)
block|{
comment|// [OpenGL ES 2.0.24] section 4.4 page 107:
comment|// If a framebuffer that is currently bound to the target FRAMEBUFFER is deleted, it is as though
comment|// BindFramebuffer had been executed with the target of FRAMEBUFFER and framebuffer of zero.
if|if
condition|(
name|mState
operator|.
name|readFramebuffer
operator|==
name|framebuffer
condition|)
block|{
name|bindReadFramebuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mState
operator|.
name|drawFramebuffer
operator|==
name|framebuffer
condition|)
block|{
name|bindDrawFramebuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|detachRenderbuffer
name|void
name|Context
operator|::
name|detachRenderbuffer
parameter_list|(
name|GLuint
name|renderbuffer
parameter_list|)
block|{
comment|// [OpenGL ES 2.0.24] section 4.4 page 109:
comment|// If a renderbuffer that is currently bound to RENDERBUFFER is deleted, it is as though BindRenderbuffer
comment|// had been executed with the target RENDERBUFFER and name of zero.
if|if
condition|(
name|mState
operator|.
name|renderbuffer
operator|.
name|id
argument_list|()
operator|==
name|renderbuffer
condition|)
block|{
name|bindRenderbuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// [OpenGL ES 2.0.24] section 4.4 page 111:
comment|// If a renderbuffer object is deleted while its image is attached to the currently bound framebuffer,
comment|// then it is as if FramebufferRenderbuffer had been called, with a renderbuffer of 0, for each attachment
comment|// point to which this image was attached in the currently bound framebuffer.
name|Framebuffer
modifier|*
name|readFramebuffer
init|=
name|getReadFramebuffer
argument_list|()
decl_stmt|;
name|Framebuffer
modifier|*
name|drawFramebuffer
init|=
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|readFramebuffer
condition|)
block|{
name|readFramebuffer
operator|->
name|detachRenderbuffer
argument_list|(
name|renderbuffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|drawFramebuffer
operator|&&
name|drawFramebuffer
operator|!=
name|readFramebuffer
condition|)
block|{
name|drawFramebuffer
operator|->
name|detachRenderbuffer
argument_list|(
name|renderbuffer
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|getIncompleteTexture
name|Texture
modifier|*
name|Context
operator|::
name|getIncompleteTexture
parameter_list|(
name|TextureType
name|type
parameter_list|)
block|{
name|Texture
modifier|*
name|t
init|=
name|mIncompleteTextures
index|[
name|type
index|]
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
block|{
specifier|static
specifier|const
name|GLubyte
name|color
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|255
block|}
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
comment|// default falls through to TEXTURE_2D
case|case
name|TEXTURE_2D
case|:
block|{
name|Texture2D
modifier|*
name|incomplete2d
init|=
operator|new
name|Texture2D
argument_list|(
name|mRenderer
argument_list|,
name|Texture
operator|::
name|INCOMPLETE_TEXTURE_ID
argument_list|)
decl_stmt|;
name|incomplete2d
operator|->
name|setImage
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
literal|1
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|t
operator|=
name|incomplete2d
expr_stmt|;
block|}
break|break;
case|case
name|TEXTURE_CUBE
case|:
block|{
name|TextureCubeMap
modifier|*
name|incompleteCube
init|=
operator|new
name|TextureCubeMap
argument_list|(
name|mRenderer
argument_list|,
name|Texture
operator|::
name|INCOMPLETE_TEXTURE_ID
argument_list|)
decl_stmt|;
name|incompleteCube
operator|->
name|setImagePosX
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
literal|1
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|incompleteCube
operator|->
name|setImageNegX
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
literal|1
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|incompleteCube
operator|->
name|setImagePosY
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
literal|1
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|incompleteCube
operator|->
name|setImageNegY
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
literal|1
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|incompleteCube
operator|->
name|setImagePosZ
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
literal|1
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|incompleteCube
operator|->
name|setImageNegZ
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
literal|1
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|t
operator|=
name|incompleteCube
expr_stmt|;
block|}
break|break;
block|}
name|mIncompleteTextures
index|[
name|type
index|]
operator|.
name|set
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
DECL|function|skipDraw
name|bool
name|Context
operator|::
name|skipDraw
parameter_list|(
name|GLenum
name|drawMode
parameter_list|)
block|{
if|if
condition|(
name|drawMode
operator|==
name|GL_POINTS
condition|)
block|{
comment|// ProgramBinary assumes non-point rendering if gl_PointSize isn't written,
comment|// which affects varying interpolation. Since the value of gl_PointSize is
comment|// undefined when not written, just skip drawing to avoid unexpected results.
if|if
condition|(
operator|!
name|getCurrentProgramBinary
argument_list|()
operator|->
name|usesPointSize
argument_list|()
condition|)
block|{
comment|// This is stictly speaking not an error, but developers should be
comment|// notified of risking undefined behavior.
name|ERR
argument_list|(
literal|"Point rendering without writing to gl_PointSize."
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|IsTriangleMode
argument_list|(
name|drawMode
argument_list|)
condition|)
block|{
if|if
condition|(
name|mState
operator|.
name|rasterizer
operator|.
name|cullFace
operator|&&
name|mState
operator|.
name|rasterizer
operator|.
name|cullMode
operator|==
name|GL_FRONT_AND_BACK
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|function|setVertexAttrib
name|void
name|Context
operator|::
name|setVertexAttrib
parameter_list|(
name|GLuint
name|index
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|values
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|index
operator|<
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
argument_list|)
expr_stmt|;
name|mState
operator|.
name|vertexAttribute
index|[
name|index
index|]
operator|.
name|mCurrentValue
index|[
literal|0
index|]
operator|=
name|values
index|[
literal|0
index|]
expr_stmt|;
name|mState
operator|.
name|vertexAttribute
index|[
name|index
index|]
operator|.
name|mCurrentValue
index|[
literal|1
index|]
operator|=
name|values
index|[
literal|1
index|]
expr_stmt|;
name|mState
operator|.
name|vertexAttribute
index|[
name|index
index|]
operator|.
name|mCurrentValue
index|[
literal|2
index|]
operator|=
name|values
index|[
literal|2
index|]
expr_stmt|;
name|mState
operator|.
name|vertexAttribute
index|[
name|index
index|]
operator|.
name|mCurrentValue
index|[
literal|3
index|]
operator|=
name|values
index|[
literal|3
index|]
expr_stmt|;
block|}
DECL|function|setVertexAttribDivisor
name|void
name|Context
operator|::
name|setVertexAttribDivisor
parameter_list|(
name|GLuint
name|index
parameter_list|,
name|GLuint
name|divisor
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|index
operator|<
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
argument_list|)
expr_stmt|;
name|mState
operator|.
name|vertexAttribute
index|[
name|index
index|]
operator|.
name|mDivisor
operator|=
name|divisor
expr_stmt|;
block|}
comment|// keep list sorted in following order
comment|// OES extensions
comment|// EXT extensions
comment|// Vendor extensions
DECL|function|initExtensionString
name|void
name|Context
operator|::
name|initExtensionString
parameter_list|()
block|{
name|std
operator|::
name|string
name|extensionString
init|=
literal|""
decl_stmt|;
comment|// OES extensions
if|if
condition|(
name|supports32bitIndices
argument_list|()
condition|)
block|{
name|extensionString
operator|+=
literal|"GL_OES_element_index_uint "
expr_stmt|;
block|}
name|extensionString
operator|+=
literal|"GL_OES_packed_depth_stencil "
expr_stmt|;
name|extensionString
operator|+=
literal|"GL_OES_get_program_binary "
expr_stmt|;
name|extensionString
operator|+=
literal|"GL_OES_rgb8_rgba8 "
expr_stmt|;
if|if
condition|(
name|mRenderer
operator|->
name|getDerivativeInstructionSupport
argument_list|()
condition|)
block|{
name|extensionString
operator|+=
literal|"GL_OES_standard_derivatives "
expr_stmt|;
block|}
if|if
condition|(
name|supportsFloat16Textures
argument_list|()
condition|)
block|{
name|extensionString
operator|+=
literal|"GL_OES_texture_half_float "
expr_stmt|;
block|}
if|if
condition|(
name|supportsFloat16LinearFilter
argument_list|()
condition|)
block|{
name|extensionString
operator|+=
literal|"GL_OES_texture_half_float_linear "
expr_stmt|;
block|}
if|if
condition|(
name|supportsFloat32Textures
argument_list|()
condition|)
block|{
name|extensionString
operator|+=
literal|"GL_OES_texture_float "
expr_stmt|;
block|}
if|if
condition|(
name|supportsFloat32LinearFilter
argument_list|()
condition|)
block|{
name|extensionString
operator|+=
literal|"GL_OES_texture_float_linear "
expr_stmt|;
block|}
if|if
condition|(
name|supportsNonPower2Texture
argument_list|()
condition|)
block|{
name|extensionString
operator|+=
literal|"GL_OES_texture_npot "
expr_stmt|;
block|}
comment|// Multi-vendor (EXT) extensions
if|if
condition|(
name|supportsOcclusionQueries
argument_list|()
condition|)
block|{
name|extensionString
operator|+=
literal|"GL_EXT_occlusion_query_boolean "
expr_stmt|;
block|}
name|extensionString
operator|+=
literal|"GL_EXT_read_format_bgra "
expr_stmt|;
name|extensionString
operator|+=
literal|"GL_EXT_robustness "
expr_stmt|;
if|if
condition|(
name|supportsDXT1Textures
argument_list|()
condition|)
block|{
name|extensionString
operator|+=
literal|"GL_EXT_texture_compression_dxt1 "
expr_stmt|;
block|}
if|if
condition|(
name|supportsTextureFilterAnisotropy
argument_list|()
condition|)
block|{
name|extensionString
operator|+=
literal|"GL_EXT_texture_filter_anisotropic "
expr_stmt|;
block|}
if|if
condition|(
name|supportsBGRATextures
argument_list|()
condition|)
block|{
name|extensionString
operator|+=
literal|"GL_EXT_texture_format_BGRA8888 "
expr_stmt|;
block|}
if|if
condition|(
name|mRenderer
operator|->
name|getMaxRenderTargets
argument_list|()
operator|>
literal|1
condition|)
block|{
name|extensionString
operator|+=
literal|"GL_EXT_draw_buffers "
expr_stmt|;
block|}
name|extensionString
operator|+=
literal|"GL_EXT_texture_storage "
expr_stmt|;
comment|// ANGLE-specific extensions
if|if
condition|(
name|supportsDepthTextures
argument_list|()
condition|)
block|{
name|extensionString
operator|+=
literal|"GL_ANGLE_depth_texture "
expr_stmt|;
block|}
name|extensionString
operator|+=
literal|"GL_ANGLE_framebuffer_blit "
expr_stmt|;
if|if
condition|(
name|getMaxSupportedSamples
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|extensionString
operator|+=
literal|"GL_ANGLE_framebuffer_multisample "
expr_stmt|;
block|}
if|if
condition|(
name|supportsInstancing
argument_list|()
condition|)
block|{
name|extensionString
operator|+=
literal|"GL_ANGLE_instanced_arrays "
expr_stmt|;
block|}
name|extensionString
operator|+=
literal|"GL_ANGLE_pack_reverse_row_order "
expr_stmt|;
if|if
condition|(
name|supportsDXT3Textures
argument_list|()
condition|)
block|{
name|extensionString
operator|+=
literal|"GL_ANGLE_texture_compression_dxt3 "
expr_stmt|;
block|}
if|if
condition|(
name|supportsDXT5Textures
argument_list|()
condition|)
block|{
name|extensionString
operator|+=
literal|"GL_ANGLE_texture_compression_dxt5 "
expr_stmt|;
block|}
name|extensionString
operator|+=
literal|"GL_ANGLE_texture_usage "
expr_stmt|;
name|extensionString
operator|+=
literal|"GL_ANGLE_translated_shader_source "
expr_stmt|;
comment|// Other vendor-specific extensions
if|if
condition|(
name|supportsEventQueries
argument_list|()
condition|)
block|{
name|extensionString
operator|+=
literal|"GL_NV_fence "
expr_stmt|;
block|}
name|std
operator|::
name|string
operator|::
name|size_type
name|end
init|=
name|extensionString
operator|.
name|find_last_not_of
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|!=
name|std
operator|::
name|string
operator|::
name|npos
condition|)
block|{
name|extensionString
operator|.
name|resize
argument_list|(
name|end
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|mExtensionString
operator|=
name|makeStaticString
argument_list|(
name|extensionString
argument_list|)
expr_stmt|;
block|}
DECL|function|getExtensionString
specifier|const
name|char
modifier|*
name|Context
operator|::
name|getExtensionString
parameter_list|()
specifier|const
block|{
return|return
name|mExtensionString
return|;
block|}
DECL|function|initRendererString
name|void
name|Context
operator|::
name|initRendererString
parameter_list|()
block|{
name|std
operator|::
name|ostringstream
name|rendererString
decl_stmt|;
name|rendererString
operator|<<
literal|"ANGLE ("
expr_stmt|;
name|rendererString
operator|<<
name|mRenderer
operator|->
name|getRendererDescription
argument_list|()
expr_stmt|;
name|rendererString
operator|<<
literal|")"
expr_stmt|;
name|mRendererString
operator|=
name|makeStaticString
argument_list|(
name|rendererString
operator|.
name|str
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|function|getRendererString
specifier|const
name|char
modifier|*
name|Context
operator|::
name|getRendererString
parameter_list|()
specifier|const
block|{
return|return
name|mRendererString
return|;
block|}
DECL|function|blitFramebuffer
name|void
name|Context
operator|::
name|blitFramebuffer
parameter_list|(
name|GLint
name|srcX0
parameter_list|,
name|GLint
name|srcY0
parameter_list|,
name|GLint
name|srcX1
parameter_list|,
name|GLint
name|srcY1
parameter_list|,
name|GLint
name|dstX0
parameter_list|,
name|GLint
name|dstY0
parameter_list|,
name|GLint
name|dstX1
parameter_list|,
name|GLint
name|dstY1
parameter_list|,
name|GLbitfield
name|mask
parameter_list|)
block|{
name|Framebuffer
modifier|*
name|readFramebuffer
init|=
name|getReadFramebuffer
argument_list|()
decl_stmt|;
name|Framebuffer
modifier|*
name|drawFramebuffer
init|=
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|readFramebuffer
operator|||
name|readFramebuffer
operator|->
name|completeness
argument_list|()
operator|!=
name|GL_FRAMEBUFFER_COMPLETE
operator|||
operator|!
name|drawFramebuffer
operator|||
name|drawFramebuffer
operator|->
name|completeness
argument_list|()
operator|!=
name|GL_FRAMEBUFFER_COMPLETE
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_FRAMEBUFFER_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
name|drawFramebuffer
operator|->
name|getSamples
argument_list|()
operator|!=
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|Renderbuffer
modifier|*
name|readColorBuffer
init|=
name|readFramebuffer
operator|->
name|getReadColorbuffer
argument_list|()
decl_stmt|;
name|Renderbuffer
modifier|*
name|drawColorBuffer
init|=
name|drawFramebuffer
operator|->
name|getFirstColorbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|drawColorBuffer
operator|==
name|NULL
condition|)
block|{
name|ERR
argument_list|(
literal|"Draw buffers formats don't match, which is not supported in this implementation of BlitFramebufferANGLE"
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|int
name|readBufferWidth
init|=
name|readColorBuffer
operator|->
name|getWidth
argument_list|()
decl_stmt|;
name|int
name|readBufferHeight
init|=
name|readColorBuffer
operator|->
name|getHeight
argument_list|()
decl_stmt|;
name|int
name|drawBufferWidth
init|=
name|drawColorBuffer
operator|->
name|getWidth
argument_list|()
decl_stmt|;
name|int
name|drawBufferHeight
init|=
name|drawColorBuffer
operator|->
name|getHeight
argument_list|()
decl_stmt|;
name|Rectangle
name|sourceRect
decl_stmt|;
name|Rectangle
name|destRect
decl_stmt|;
if|if
condition|(
name|srcX0
operator|<
name|srcX1
condition|)
block|{
name|sourceRect
operator|.
name|x
operator|=
name|srcX0
expr_stmt|;
name|destRect
operator|.
name|x
operator|=
name|dstX0
expr_stmt|;
name|sourceRect
operator|.
name|width
operator|=
name|srcX1
operator|-
name|srcX0
expr_stmt|;
name|destRect
operator|.
name|width
operator|=
name|dstX1
operator|-
name|dstX0
expr_stmt|;
block|}
else|else
block|{
name|sourceRect
operator|.
name|x
operator|=
name|srcX1
expr_stmt|;
name|destRect
operator|.
name|x
operator|=
name|dstX1
expr_stmt|;
name|sourceRect
operator|.
name|width
operator|=
name|srcX0
operator|-
name|srcX1
expr_stmt|;
name|destRect
operator|.
name|width
operator|=
name|dstX0
operator|-
name|dstX1
expr_stmt|;
block|}
if|if
condition|(
name|srcY0
operator|<
name|srcY1
condition|)
block|{
name|sourceRect
operator|.
name|height
operator|=
name|srcY1
operator|-
name|srcY0
expr_stmt|;
name|destRect
operator|.
name|height
operator|=
name|dstY1
operator|-
name|dstY0
expr_stmt|;
name|sourceRect
operator|.
name|y
operator|=
name|srcY0
expr_stmt|;
name|destRect
operator|.
name|y
operator|=
name|dstY0
expr_stmt|;
block|}
else|else
block|{
name|sourceRect
operator|.
name|height
operator|=
name|srcY0
operator|-
name|srcY1
expr_stmt|;
name|destRect
operator|.
name|height
operator|=
name|dstY0
operator|-
name|srcY1
expr_stmt|;
name|sourceRect
operator|.
name|y
operator|=
name|srcY1
expr_stmt|;
name|destRect
operator|.
name|y
operator|=
name|dstY1
expr_stmt|;
block|}
name|Rectangle
name|sourceScissoredRect
init|=
name|sourceRect
decl_stmt|;
name|Rectangle
name|destScissoredRect
init|=
name|destRect
decl_stmt|;
if|if
condition|(
name|mState
operator|.
name|scissorTest
condition|)
block|{
comment|// Only write to parts of the destination framebuffer which pass the scissor test.
if|if
condition|(
name|destRect
operator|.
name|x
operator|<
name|mState
operator|.
name|scissor
operator|.
name|x
condition|)
block|{
name|int
name|xDiff
init|=
name|mState
operator|.
name|scissor
operator|.
name|x
operator|-
name|destRect
operator|.
name|x
decl_stmt|;
name|destScissoredRect
operator|.
name|x
operator|=
name|mState
operator|.
name|scissor
operator|.
name|x
expr_stmt|;
name|destScissoredRect
operator|.
name|width
operator|-=
name|xDiff
expr_stmt|;
name|sourceScissoredRect
operator|.
name|x
operator|+=
name|xDiff
expr_stmt|;
name|sourceScissoredRect
operator|.
name|width
operator|-=
name|xDiff
expr_stmt|;
block|}
if|if
condition|(
name|destRect
operator|.
name|x
operator|+
name|destRect
operator|.
name|width
operator|>
name|mState
operator|.
name|scissor
operator|.
name|x
operator|+
name|mState
operator|.
name|scissor
operator|.
name|width
condition|)
block|{
name|int
name|xDiff
init|=
operator|(
name|destRect
operator|.
name|x
operator|+
name|destRect
operator|.
name|width
operator|)
operator|-
operator|(
name|mState
operator|.
name|scissor
operator|.
name|x
operator|+
name|mState
operator|.
name|scissor
operator|.
name|width
operator|)
decl_stmt|;
name|destScissoredRect
operator|.
name|width
operator|-=
name|xDiff
expr_stmt|;
name|sourceScissoredRect
operator|.
name|width
operator|-=
name|xDiff
expr_stmt|;
block|}
if|if
condition|(
name|destRect
operator|.
name|y
operator|<
name|mState
operator|.
name|scissor
operator|.
name|y
condition|)
block|{
name|int
name|yDiff
init|=
name|mState
operator|.
name|scissor
operator|.
name|y
operator|-
name|destRect
operator|.
name|y
decl_stmt|;
name|destScissoredRect
operator|.
name|y
operator|=
name|mState
operator|.
name|scissor
operator|.
name|y
expr_stmt|;
name|destScissoredRect
operator|.
name|height
operator|-=
name|yDiff
expr_stmt|;
name|sourceScissoredRect
operator|.
name|y
operator|+=
name|yDiff
expr_stmt|;
name|sourceScissoredRect
operator|.
name|height
operator|-=
name|yDiff
expr_stmt|;
block|}
if|if
condition|(
name|destRect
operator|.
name|y
operator|+
name|destRect
operator|.
name|height
operator|>
name|mState
operator|.
name|scissor
operator|.
name|y
operator|+
name|mState
operator|.
name|scissor
operator|.
name|height
condition|)
block|{
name|int
name|yDiff
init|=
operator|(
name|destRect
operator|.
name|y
operator|+
name|destRect
operator|.
name|height
operator|)
operator|-
operator|(
name|mState
operator|.
name|scissor
operator|.
name|y
operator|+
name|mState
operator|.
name|scissor
operator|.
name|height
operator|)
decl_stmt|;
name|destScissoredRect
operator|.
name|height
operator|-=
name|yDiff
expr_stmt|;
name|sourceScissoredRect
operator|.
name|height
operator|-=
name|yDiff
expr_stmt|;
block|}
block|}
name|bool
name|blitRenderTarget
init|=
literal|false
decl_stmt|;
name|bool
name|blitDepthStencil
init|=
literal|false
decl_stmt|;
name|Rectangle
name|sourceTrimmedRect
init|=
name|sourceScissoredRect
decl_stmt|;
name|Rectangle
name|destTrimmedRect
init|=
name|destScissoredRect
decl_stmt|;
comment|// The source& destination rectangles also may need to be trimmed if they fall out of the bounds of
comment|// the actual draw and read surfaces.
if|if
condition|(
name|sourceTrimmedRect
operator|.
name|x
operator|<
literal|0
condition|)
block|{
name|int
name|xDiff
init|=
literal|0
operator|-
name|sourceTrimmedRect
operator|.
name|x
decl_stmt|;
name|sourceTrimmedRect
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|sourceTrimmedRect
operator|.
name|width
operator|-=
name|xDiff
expr_stmt|;
name|destTrimmedRect
operator|.
name|x
operator|+=
name|xDiff
expr_stmt|;
name|destTrimmedRect
operator|.
name|width
operator|-=
name|xDiff
expr_stmt|;
block|}
if|if
condition|(
name|sourceTrimmedRect
operator|.
name|x
operator|+
name|sourceTrimmedRect
operator|.
name|width
operator|>
name|readBufferWidth
condition|)
block|{
name|int
name|xDiff
init|=
operator|(
name|sourceTrimmedRect
operator|.
name|x
operator|+
name|sourceTrimmedRect
operator|.
name|width
operator|)
operator|-
name|readBufferWidth
decl_stmt|;
name|sourceTrimmedRect
operator|.
name|width
operator|-=
name|xDiff
expr_stmt|;
name|destTrimmedRect
operator|.
name|width
operator|-=
name|xDiff
expr_stmt|;
block|}
if|if
condition|(
name|sourceTrimmedRect
operator|.
name|y
operator|<
literal|0
condition|)
block|{
name|int
name|yDiff
init|=
literal|0
operator|-
name|sourceTrimmedRect
operator|.
name|y
decl_stmt|;
name|sourceTrimmedRect
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|sourceTrimmedRect
operator|.
name|height
operator|-=
name|yDiff
expr_stmt|;
name|destTrimmedRect
operator|.
name|y
operator|+=
name|yDiff
expr_stmt|;
name|destTrimmedRect
operator|.
name|height
operator|-=
name|yDiff
expr_stmt|;
block|}
if|if
condition|(
name|sourceTrimmedRect
operator|.
name|y
operator|+
name|sourceTrimmedRect
operator|.
name|height
operator|>
name|readBufferHeight
condition|)
block|{
name|int
name|yDiff
init|=
operator|(
name|sourceTrimmedRect
operator|.
name|y
operator|+
name|sourceTrimmedRect
operator|.
name|height
operator|)
operator|-
name|readBufferHeight
decl_stmt|;
name|sourceTrimmedRect
operator|.
name|height
operator|-=
name|yDiff
expr_stmt|;
name|destTrimmedRect
operator|.
name|height
operator|-=
name|yDiff
expr_stmt|;
block|}
if|if
condition|(
name|destTrimmedRect
operator|.
name|x
operator|<
literal|0
condition|)
block|{
name|int
name|xDiff
init|=
literal|0
operator|-
name|destTrimmedRect
operator|.
name|x
decl_stmt|;
name|destTrimmedRect
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|destTrimmedRect
operator|.
name|width
operator|-=
name|xDiff
expr_stmt|;
name|sourceTrimmedRect
operator|.
name|x
operator|+=
name|xDiff
expr_stmt|;
name|sourceTrimmedRect
operator|.
name|width
operator|-=
name|xDiff
expr_stmt|;
block|}
if|if
condition|(
name|destTrimmedRect
operator|.
name|x
operator|+
name|destTrimmedRect
operator|.
name|width
operator|>
name|drawBufferWidth
condition|)
block|{
name|int
name|xDiff
init|=
operator|(
name|destTrimmedRect
operator|.
name|x
operator|+
name|destTrimmedRect
operator|.
name|width
operator|)
operator|-
name|drawBufferWidth
decl_stmt|;
name|destTrimmedRect
operator|.
name|width
operator|-=
name|xDiff
expr_stmt|;
name|sourceTrimmedRect
operator|.
name|width
operator|-=
name|xDiff
expr_stmt|;
block|}
if|if
condition|(
name|destTrimmedRect
operator|.
name|y
operator|<
literal|0
condition|)
block|{
name|int
name|yDiff
init|=
literal|0
operator|-
name|destTrimmedRect
operator|.
name|y
decl_stmt|;
name|destTrimmedRect
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|destTrimmedRect
operator|.
name|height
operator|-=
name|yDiff
expr_stmt|;
name|sourceTrimmedRect
operator|.
name|y
operator|+=
name|yDiff
expr_stmt|;
name|sourceTrimmedRect
operator|.
name|height
operator|-=
name|yDiff
expr_stmt|;
block|}
if|if
condition|(
name|destTrimmedRect
operator|.
name|y
operator|+
name|destTrimmedRect
operator|.
name|height
operator|>
name|drawBufferHeight
condition|)
block|{
name|int
name|yDiff
init|=
operator|(
name|destTrimmedRect
operator|.
name|y
operator|+
name|destTrimmedRect
operator|.
name|height
operator|)
operator|-
name|drawBufferHeight
decl_stmt|;
name|destTrimmedRect
operator|.
name|height
operator|-=
name|yDiff
expr_stmt|;
name|sourceTrimmedRect
operator|.
name|height
operator|-=
name|yDiff
expr_stmt|;
block|}
name|bool
name|partialBufferCopy
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|sourceTrimmedRect
operator|.
name|height
operator|<
name|readBufferHeight
operator|||
name|sourceTrimmedRect
operator|.
name|width
operator|<
name|readBufferWidth
operator|||
name|destTrimmedRect
operator|.
name|height
operator|<
name|drawBufferHeight
operator|||
name|destTrimmedRect
operator|.
name|width
operator|<
name|drawBufferWidth
operator|||
name|sourceTrimmedRect
operator|.
name|y
operator|!=
literal|0
operator|||
name|destTrimmedRect
operator|.
name|y
operator|!=
literal|0
operator|||
name|sourceTrimmedRect
operator|.
name|x
operator|!=
literal|0
operator|||
name|destTrimmedRect
operator|.
name|x
operator|!=
literal|0
condition|)
block|{
name|partialBufferCopy
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|GL_COLOR_BUFFER_BIT
condition|)
block|{
specifier|const
name|GLenum
name|readColorbufferType
init|=
name|readFramebuffer
operator|->
name|getReadColorbufferType
argument_list|()
decl_stmt|;
specifier|const
name|bool
name|validReadType
init|=
operator|(
name|readColorbufferType
operator|==
name|GL_TEXTURE_2D
operator|)
operator|||
operator|(
name|readColorbufferType
operator|==
name|GL_RENDERBUFFER
operator|)
decl_stmt|;
name|bool
name|validDrawType
init|=
literal|true
decl_stmt|;
name|bool
name|validDrawFormat
init|=
literal|true
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|colorAttachment
init|=
literal|0
init|;
name|colorAttachment
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
condition|;
name|colorAttachment
operator|++
control|)
block|{
if|if
condition|(
name|drawFramebuffer
operator|->
name|isEnabledColorAttachment
argument_list|(
name|colorAttachment
argument_list|)
condition|)
block|{
if|if
condition|(
name|drawFramebuffer
operator|->
name|getColorbufferType
argument_list|(
name|colorAttachment
argument_list|)
operator|!=
name|GL_TEXTURE_2D
operator|&&
name|drawFramebuffer
operator|->
name|getColorbufferType
argument_list|(
name|colorAttachment
argument_list|)
operator|!=
name|GL_RENDERBUFFER
condition|)
block|{
name|validDrawType
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|drawFramebuffer
operator|->
name|getColorbuffer
argument_list|(
name|colorAttachment
argument_list|)
operator|->
name|getActualFormat
argument_list|()
operator|!=
name|readColorBuffer
operator|->
name|getActualFormat
argument_list|()
condition|)
block|{
name|validDrawFormat
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|validReadType
operator|||
operator|!
name|validDrawType
operator|||
operator|!
name|validDrawFormat
condition|)
block|{
name|ERR
argument_list|(
literal|"Color buffer format conversion in BlitFramebufferANGLE not supported by this implementation"
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
name|partialBufferCopy
operator|&&
name|readFramebuffer
operator|->
name|getSamples
argument_list|()
operator|!=
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|blitRenderTarget
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
operator|(
name|GL_DEPTH_BUFFER_BIT
operator||
name|GL_STENCIL_BUFFER_BIT
operator|)
condition|)
block|{
name|Renderbuffer
modifier|*
name|readDSBuffer
init|=
name|NULL
decl_stmt|;
name|Renderbuffer
modifier|*
name|drawDSBuffer
init|=
name|NULL
decl_stmt|;
comment|// We support OES_packed_depth_stencil, and do not support a separately attached depth and stencil buffer, so if we have
comment|// both a depth and stencil buffer, it will be the same buffer.
if|if
condition|(
name|mask
operator|&
name|GL_DEPTH_BUFFER_BIT
condition|)
block|{
if|if
condition|(
name|readFramebuffer
operator|->
name|getDepthbuffer
argument_list|()
operator|&&
name|drawFramebuffer
operator|->
name|getDepthbuffer
argument_list|()
condition|)
block|{
if|if
condition|(
name|readFramebuffer
operator|->
name|getDepthbufferType
argument_list|()
operator|!=
name|drawFramebuffer
operator|->
name|getDepthbufferType
argument_list|()
operator|||
name|readFramebuffer
operator|->
name|getDepthbuffer
argument_list|()
operator|->
name|getActualFormat
argument_list|()
operator|!=
name|drawFramebuffer
operator|->
name|getDepthbuffer
argument_list|()
operator|->
name|getActualFormat
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|blitDepthStencil
operator|=
literal|true
expr_stmt|;
name|readDSBuffer
operator|=
name|readFramebuffer
operator|->
name|getDepthbuffer
argument_list|()
expr_stmt|;
name|drawDSBuffer
operator|=
name|drawFramebuffer
operator|->
name|getDepthbuffer
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|GL_STENCIL_BUFFER_BIT
condition|)
block|{
if|if
condition|(
name|readFramebuffer
operator|->
name|getStencilbuffer
argument_list|()
operator|&&
name|drawFramebuffer
operator|->
name|getStencilbuffer
argument_list|()
condition|)
block|{
if|if
condition|(
name|readFramebuffer
operator|->
name|getStencilbufferType
argument_list|()
operator|!=
name|drawFramebuffer
operator|->
name|getStencilbufferType
argument_list|()
operator|||
name|readFramebuffer
operator|->
name|getStencilbuffer
argument_list|()
operator|->
name|getActualFormat
argument_list|()
operator|!=
name|drawFramebuffer
operator|->
name|getStencilbuffer
argument_list|()
operator|->
name|getActualFormat
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|blitDepthStencil
operator|=
literal|true
expr_stmt|;
name|readDSBuffer
operator|=
name|readFramebuffer
operator|->
name|getStencilbuffer
argument_list|()
expr_stmt|;
name|drawDSBuffer
operator|=
name|drawFramebuffer
operator|->
name|getStencilbuffer
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|partialBufferCopy
condition|)
block|{
name|ERR
argument_list|(
literal|"Only whole-buffer depth and stencil blits are supported by this implementation."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
comment|// only whole-buffer copies are permitted
block|}
if|if
condition|(
operator|(
name|drawDSBuffer
operator|&&
name|drawDSBuffer
operator|->
name|getSamples
argument_list|()
operator|!=
literal|0
operator|)
operator|||
operator|(
name|readDSBuffer
operator|&&
name|readDSBuffer
operator|->
name|getSamples
argument_list|()
operator|!=
literal|0
operator|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|blitRenderTarget
operator|||
name|blitDepthStencil
condition|)
block|{
name|mRenderer
operator|->
name|blitRect
argument_list|(
name|readFramebuffer
argument_list|,
name|sourceTrimmedRect
argument_list|,
name|drawFramebuffer
argument_list|,
name|destTrimmedRect
argument_list|,
name|blitRenderTarget
argument_list|,
name|blitDepthStencil
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_namespace
begin_extern
extern|extern
literal|"C"
block|{
DECL|function|glCreateContext
name|gl
operator|::
name|Context
modifier|*
name|glCreateContext
parameter_list|(
specifier|const
name|gl
operator|::
name|Context
modifier|*
name|shareContext
parameter_list|,
name|rx
operator|::
name|Renderer
modifier|*
name|renderer
parameter_list|,
name|bool
name|notifyResets
parameter_list|,
name|bool
name|robustAccess
parameter_list|)
block|{
return|return
operator|new
name|gl
operator|::
name|Context
argument_list|(
name|shareContext
argument_list|,
name|renderer
argument_list|,
name|notifyResets
argument_list|,
name|robustAccess
argument_list|)
return|;
block|}
DECL|function|glDestroyContext
name|void
name|glDestroyContext
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|)
block|{
operator|delete
name|context
expr_stmt|;
if|if
condition|(
name|context
operator|==
name|gl
operator|::
name|getContext
argument_list|()
condition|)
block|{
name|gl
operator|::
name|makeCurrent
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|glMakeCurrent
name|void
name|glMakeCurrent
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|egl
operator|::
name|Display
modifier|*
name|display
parameter_list|,
name|egl
operator|::
name|Surface
modifier|*
name|surface
parameter_list|)
block|{
name|gl
operator|::
name|makeCurrent
argument_list|(
name|context
argument_list|,
name|display
argument_list|,
name|surface
argument_list|)
expr_stmt|;
block|}
DECL|function|glGetCurrentContext
name|gl
operator|::
name|Context
modifier|*
name|glGetCurrentContext
parameter_list|()
block|{
return|return
name|gl
operator|::
name|getContext
argument_list|()
return|;
block|}
block|}
end_extern
end_unit
