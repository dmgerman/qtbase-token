begin_unit
begin_include
include|#
directive|include
file|"precompiled.h"
end_include
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2013-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// validationES.h: Validation functions for generic OpenGL ES entry point parameters
end_comment
begin_include
include|#
directive|include
file|"libGLESv2/validationES.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/validationES2.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/validationES3.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Context.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Texture.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Framebuffer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/FramebufferAttachment.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/formatutils.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/main.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Query.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/ProgramBinary.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/TransformFeedback.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/VertexArray.h"
end_include
begin_include
include|#
directive|include
file|"common/mathutil.h"
end_include
begin_include
include|#
directive|include
file|"common/utilities.h"
end_include
begin_namespace
DECL|namespace|gl
namespace|namespace
name|gl
block|{
DECL|function|ValidCap
name|bool
name|ValidCap
parameter_list|(
specifier|const
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|cap
parameter_list|)
block|{
switch|switch
condition|(
name|cap
condition|)
block|{
case|case
name|GL_CULL_FACE
case|:
case|case
name|GL_POLYGON_OFFSET_FILL
case|:
case|case
name|GL_SAMPLE_ALPHA_TO_COVERAGE
case|:
case|case
name|GL_SAMPLE_COVERAGE
case|:
case|case
name|GL_SCISSOR_TEST
case|:
case|case
name|GL_STENCIL_TEST
case|:
case|case
name|GL_DEPTH_TEST
case|:
case|case
name|GL_BLEND
case|:
case|case
name|GL_DITHER
case|:
return|return
literal|true
return|;
case|case
name|GL_PRIMITIVE_RESTART_FIXED_INDEX
case|:
case|case
name|GL_RASTERIZER_DISCARD
case|:
return|return
operator|(
name|context
operator|->
name|getClientVersion
argument_list|()
operator|>=
literal|3
operator|)
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
DECL|function|ValidTextureTarget
name|bool
name|ValidTextureTarget
parameter_list|(
specifier|const
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|)
block|{
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TEXTURE_2D
case|:
case|case
name|GL_TEXTURE_CUBE_MAP
case|:
return|return
literal|true
return|;
case|case
name|GL_TEXTURE_3D
case|:
case|case
name|GL_TEXTURE_2D_ARRAY
case|:
return|return
operator|(
name|context
operator|->
name|getClientVersion
argument_list|()
operator|>=
literal|3
operator|)
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|// This function differs from ValidTextureTarget in that the target must be
comment|// usable as the destination of a 2D operation-- so a cube face is valid, but
comment|// GL_TEXTURE_CUBE_MAP is not.
comment|// Note: duplicate of IsInternalTextureTarget
DECL|function|ValidTexture2DDestinationTarget
name|bool
name|ValidTexture2DDestinationTarget
parameter_list|(
specifier|const
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|)
block|{
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TEXTURE_2D
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_X
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Y
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Z
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
case|:
return|return
literal|true
return|;
case|case
name|GL_TEXTURE_2D_ARRAY
case|:
case|case
name|GL_TEXTURE_3D
case|:
return|return
operator|(
name|context
operator|->
name|getClientVersion
argument_list|()
operator|>=
literal|3
operator|)
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
DECL|function|ValidFramebufferTarget
name|bool
name|ValidFramebufferTarget
parameter_list|(
name|GLenum
name|target
parameter_list|)
block|{
name|META_ASSERT
argument_list|(
name|GL_DRAW_FRAMEBUFFER_ANGLE
operator|==
name|GL_DRAW_FRAMEBUFFER
operator|&&
name|GL_READ_FRAMEBUFFER_ANGLE
operator|==
name|GL_READ_FRAMEBUFFER
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_FRAMEBUFFER
case|:
return|return
literal|true
return|;
case|case
name|GL_READ_FRAMEBUFFER
case|:
return|return
literal|true
return|;
case|case
name|GL_DRAW_FRAMEBUFFER
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
DECL|function|ValidBufferTarget
name|bool
name|ValidBufferTarget
parameter_list|(
specifier|const
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|)
block|{
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_ARRAY_BUFFER
case|:
case|case
name|GL_ELEMENT_ARRAY_BUFFER
case|:
return|return
literal|true
return|;
case|case
name|GL_PIXEL_PACK_BUFFER
case|:
case|case
name|GL_PIXEL_UNPACK_BUFFER
case|:
return|return
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|pixelBufferObject
return|;
case|case
name|GL_COPY_READ_BUFFER
case|:
case|case
name|GL_COPY_WRITE_BUFFER
case|:
case|case
name|GL_TRANSFORM_FEEDBACK_BUFFER
case|:
case|case
name|GL_UNIFORM_BUFFER
case|:
return|return
operator|(
name|context
operator|->
name|getClientVersion
argument_list|()
operator|>=
literal|3
operator|)
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
DECL|function|ValidBufferParameter
name|bool
name|ValidBufferParameter
parameter_list|(
specifier|const
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|pname
parameter_list|)
block|{
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_BUFFER_USAGE
case|:
case|case
name|GL_BUFFER_SIZE
case|:
return|return
literal|true
return|;
comment|// GL_BUFFER_MAP_POINTER is a special case, and may only be
comment|// queried with GetBufferPointerv
case|case
name|GL_BUFFER_ACCESS_FLAGS
case|:
case|case
name|GL_BUFFER_MAPPED
case|:
case|case
name|GL_BUFFER_MAP_OFFSET
case|:
case|case
name|GL_BUFFER_MAP_LENGTH
case|:
return|return
operator|(
name|context
operator|->
name|getClientVersion
argument_list|()
operator|>=
literal|3
operator|)
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
DECL|function|ValidMipLevel
name|bool
name|ValidMipLevel
parameter_list|(
specifier|const
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|)
block|{
name|size_t
name|maxDimension
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TEXTURE_2D
case|:
name|maxDimension
operator|=
name|context
operator|->
name|getCaps
argument_list|()
operator|.
name|max2DTextureSize
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_CUBE_MAP
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_X
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Y
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Z
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
case|:
name|maxDimension
operator|=
name|context
operator|->
name|getCaps
argument_list|()
operator|.
name|maxCubeMapTextureSize
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_3D
case|:
name|maxDimension
operator|=
name|context
operator|->
name|getCaps
argument_list|()
operator|.
name|max3DTextureSize
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_2D_ARRAY
case|:
name|maxDimension
operator|=
name|context
operator|->
name|getCaps
argument_list|()
operator|.
name|max2DTextureSize
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
name|level
operator|<=
name|gl
operator|::
name|log2
argument_list|(
name|maxDimension
argument_list|)
return|;
block|}
DECL|function|ValidImageSize
name|bool
name|ValidImageSize
parameter_list|(
specifier|const
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|depth
parameter_list|)
block|{
if|if
condition|(
name|level
operator|<
literal|0
operator|||
name|width
operator|<
literal|0
operator|||
name|height
operator|<
literal|0
operator|||
name|depth
operator|<
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|textureNPOT
operator|&&
operator|(
name|level
operator|!=
literal|0
operator|&&
operator|(
operator|!
name|gl
operator|::
name|isPow2
argument_list|(
name|width
argument_list|)
operator|||
operator|!
name|gl
operator|::
name|isPow2
argument_list|(
name|height
argument_list|)
operator|||
operator|!
name|gl
operator|::
name|isPow2
argument_list|(
name|depth
argument_list|)
operator|)
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|ValidMipLevel
argument_list|(
name|context
argument_list|,
name|target
argument_list|,
name|level
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidCompressedImageSize
name|bool
name|ValidCompressedImageSize
parameter_list|(
specifier|const
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|internalFormat
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
if|if
condition|(
operator|!
name|IsFormatCompressed
argument_list|(
name|internalFormat
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|GLint
name|blockWidth
init|=
name|GetCompressedBlockWidth
argument_list|(
name|internalFormat
argument_list|)
decl_stmt|;
name|GLint
name|blockHeight
init|=
name|GetCompressedBlockHeight
argument_list|(
name|internalFormat
argument_list|)
decl_stmt|;
if|if
condition|(
name|width
operator|<
literal|0
operator|||
operator|(
name|width
operator|>
name|blockWidth
operator|&&
name|width
operator|%
name|blockWidth
operator|!=
literal|0
operator|)
operator|||
name|height
operator|<
literal|0
operator|||
operator|(
name|height
operator|>
name|blockHeight
operator|&&
name|height
operator|%
name|blockHeight
operator|!=
literal|0
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidQueryType
name|bool
name|ValidQueryType
parameter_list|(
specifier|const
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|queryType
parameter_list|)
block|{
name|META_ASSERT
argument_list|(
name|GL_ANY_SAMPLES_PASSED
operator|==
name|GL_ANY_SAMPLES_PASSED_EXT
argument_list|)
expr_stmt|;
name|META_ASSERT
argument_list|(
name|GL_ANY_SAMPLES_PASSED_CONSERVATIVE
operator|==
name|GL_ANY_SAMPLES_PASSED_CONSERVATIVE_EXT
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|queryType
condition|)
block|{
case|case
name|GL_ANY_SAMPLES_PASSED
case|:
case|case
name|GL_ANY_SAMPLES_PASSED_CONSERVATIVE
case|:
return|return
literal|true
return|;
case|case
name|GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN
case|:
return|return
operator|(
name|context
operator|->
name|getClientVersion
argument_list|()
operator|>=
literal|3
operator|)
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
DECL|function|ValidProgram
name|bool
name|ValidProgram
parameter_list|(
specifier|const
name|Context
modifier|*
name|context
parameter_list|,
name|GLuint
name|id
parameter_list|)
block|{
comment|// ES3 spec (section 2.11.1) -- "Commands that accept shader or program object names will generate the
comment|// error INVALID_VALUE if the provided name is not the name of either a shader or program object and
comment|// INVALID_OPERATION if the provided name identifies an object that is not the expected type."
if|if
condition|(
name|context
operator|->
name|getProgram
argument_list|(
name|id
argument_list|)
operator|!=
name|NULL
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|context
operator|->
name|getShader
argument_list|(
name|id
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|// ID is the wrong type
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
else|else
block|{
comment|// No shader/program object has this ID
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
DECL|function|ValidateAttachmentTarget
name|bool
name|ValidateAttachmentTarget
parameter_list|(
specifier|const
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|attachment
parameter_list|)
block|{
if|if
condition|(
name|attachment
operator|>=
name|GL_COLOR_ATTACHMENT0_EXT
operator|&&
name|attachment
operator|<=
name|GL_COLOR_ATTACHMENT15_EXT
condition|)
block|{
specifier|const
name|unsigned
name|int
name|colorAttachment
init|=
operator|(
name|attachment
operator|-
name|GL_COLOR_ATTACHMENT0_EXT
operator|)
decl_stmt|;
if|if
condition|(
name|colorAttachment
operator|>=
name|context
operator|->
name|getCaps
argument_list|()
operator|.
name|maxColorAttachments
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|attachment
condition|)
block|{
case|case
name|GL_DEPTH_ATTACHMENT
case|:
case|case
name|GL_STENCIL_ATTACHMENT
case|:
break|break;
case|case
name|GL_DEPTH_STENCIL_ATTACHMENT
case|:
if|if
condition|(
name|context
operator|->
name|getClientVersion
argument_list|()
operator|<
literal|3
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
return|;
block|}
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateRenderbufferStorageParameters
name|bool
name|ValidateRenderbufferStorageParameters
parameter_list|(
specifier|const
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLsizei
name|samples
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|bool
name|angleExtension
parameter_list|)
block|{
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_RENDERBUFFER
case|:
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|width
operator|<
literal|0
operator|||
name|height
operator|<
literal|0
operator|||
name|samples
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|gl
operator|::
name|IsValidInternalFormat
argument_list|(
name|internalformat
argument_list|,
name|context
operator|->
name|getExtensions
argument_list|()
argument_list|,
name|context
operator|->
name|getClientVersion
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|// ANGLE_framebuffer_multisample does not explicitly state that the internal format must be
comment|// sized but it does state that the format must be in the ES2.0 spec table 4.5 which contains
comment|// only sized internal formats. The ES3 spec (section 4.4.2) does, however, state that the
comment|// internal format must be sized and not an integer format if samples is greater than zero.
if|if
condition|(
operator|!
name|gl
operator|::
name|IsSizedInternalFormat
argument_list|(
name|internalformat
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|GLenum
name|componentType
init|=
name|gl
operator|::
name|GetComponentType
argument_list|(
name|internalformat
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|componentType
operator|==
name|GL_UNSIGNED_INT
operator|||
name|componentType
operator|==
name|GL_INT
operator|)
operator|&&
name|samples
operator|>
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|const
name|TextureCaps
modifier|&
name|formatCaps
init|=
name|context
operator|->
name|getTextureCaps
argument_list|()
operator|.
name|get
argument_list|(
name|internalformat
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|formatCaps
operator|.
name|renderable
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|std
operator|::
name|max
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
argument_list|)
operator|>
name|context
operator|->
name|getCaps
argument_list|()
operator|.
name|maxRenderbufferSize
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|// ANGLE_framebuffer_multisample states that the value of samples must be less than or equal
comment|// to MAX_SAMPLES_ANGLE (Context::getMaxSupportedSamples) while the ES3.0 spec (section 4.4.2)
comment|// states that samples must be less than or equal to the maximum samples for the specified
comment|// internal format.
if|if
condition|(
name|angleExtension
condition|)
block|{
if|if
condition|(
name|samples
operator|>
name|context
operator|->
name|getMaxSupportedSamples
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|samples
operator|>
name|context
operator|->
name|getMaxSupportedFormatSamples
argument_list|(
name|internalformat
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
name|GLuint
name|handle
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getRenderbufferId
argument_list|()
decl_stmt|;
if|if
condition|(
name|handle
operator|==
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateFramebufferRenderbufferParameters
name|bool
name|ValidateFramebufferRenderbufferParameters
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLenum
name|attachment
parameter_list|,
name|GLenum
name|renderbuffertarget
parameter_list|,
name|GLuint
name|renderbuffer
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ValidFramebufferTarget
argument_list|(
name|target
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getTargetFramebuffer
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|GLuint
name|framebufferHandle
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getTargetFramebuffer
argument_list|(
name|target
argument_list|)
operator|->
name|id
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|framebuffer
operator|||
operator|(
name|framebufferHandle
operator|==
literal|0
operator|&&
name|renderbuffer
operator|!=
literal|0
operator|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|ValidateAttachmentTarget
argument_list|(
name|context
argument_list|,
name|attachment
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// [OpenGL ES 2.0.25] Section 4.4.3 page 112
comment|// [OpenGL ES 3.0.2] Section 4.4.2 page 201
comment|// 'renderbuffer' must be either zero or the name of an existing renderbuffer object of
comment|// type 'renderbuffertarget', otherwise an INVALID_OPERATION error is generated.
if|if
condition|(
name|renderbuffer
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|context
operator|->
name|getRenderbuffer
argument_list|(
name|renderbuffer
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|IsPartialBlit
specifier|static
name|bool
name|IsPartialBlit
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|readBuffer
parameter_list|,
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|writeBuffer
parameter_list|,
name|GLint
name|srcX0
parameter_list|,
name|GLint
name|srcY0
parameter_list|,
name|GLint
name|srcX1
parameter_list|,
name|GLint
name|srcY1
parameter_list|,
name|GLint
name|dstX0
parameter_list|,
name|GLint
name|dstY0
parameter_list|,
name|GLint
name|dstX1
parameter_list|,
name|GLint
name|dstY1
parameter_list|)
block|{
if|if
condition|(
name|srcX0
operator|!=
literal|0
operator|||
name|srcY0
operator|!=
literal|0
operator|||
name|dstX0
operator|!=
literal|0
operator|||
name|dstY0
operator|!=
literal|0
operator|||
name|dstX1
operator|!=
name|writeBuffer
operator|->
name|getWidth
argument_list|()
operator|||
name|dstY1
operator|!=
name|writeBuffer
operator|->
name|getHeight
argument_list|()
operator|||
name|srcX1
operator|!=
name|readBuffer
operator|->
name|getWidth
argument_list|()
operator|||
name|srcY1
operator|!=
name|readBuffer
operator|->
name|getHeight
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|context
operator|->
name|getState
argument_list|()
operator|.
name|isScissorTestEnabled
argument_list|()
condition|)
block|{
specifier|const
name|Rectangle
modifier|&
name|scissor
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getScissor
argument_list|()
decl_stmt|;
return|return
name|scissor
operator|.
name|x
operator|>
literal|0
operator|||
name|scissor
operator|.
name|y
operator|>
literal|0
operator|||
name|scissor
operator|.
name|width
operator|<
name|writeBuffer
operator|->
name|getWidth
argument_list|()
operator|||
name|scissor
operator|.
name|height
operator|<
name|writeBuffer
operator|->
name|getHeight
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
DECL|function|ValidateBlitFramebufferParameters
name|bool
name|ValidateBlitFramebufferParameters
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLint
name|srcX0
parameter_list|,
name|GLint
name|srcY0
parameter_list|,
name|GLint
name|srcX1
parameter_list|,
name|GLint
name|srcY1
parameter_list|,
name|GLint
name|dstX0
parameter_list|,
name|GLint
name|dstY0
parameter_list|,
name|GLint
name|dstX1
parameter_list|,
name|GLint
name|dstY1
parameter_list|,
name|GLbitfield
name|mask
parameter_list|,
name|GLenum
name|filter
parameter_list|,
name|bool
name|fromAngleExtension
parameter_list|)
block|{
switch|switch
condition|(
name|filter
condition|)
block|{
case|case
name|GL_NEAREST
case|:
break|break;
case|case
name|GL_LINEAR
case|:
if|if
condition|(
name|fromAngleExtension
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
return|;
block|}
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
operator|~
operator|(
name|GL_COLOR_BUFFER_BIT
operator||
name|GL_STENCIL_BUFFER_BIT
operator||
name|GL_DEPTH_BUFFER_BIT
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
block|{
comment|// ES3.0 spec, section 4.3.2 specifies that a mask of zero is valid and no
comment|// buffers are copied.
return|return
literal|false
return|;
block|}
if|if
condition|(
name|fromAngleExtension
operator|&&
operator|(
name|srcX1
operator|-
name|srcX0
operator|!=
name|dstX1
operator|-
name|dstX0
operator|||
name|srcY1
operator|-
name|srcY0
operator|!=
name|dstY1
operator|-
name|dstY0
operator|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Scaling and flipping in BlitFramebufferANGLE not supported by this implementation."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|// ES3.0 spec, section 4.3.2 states that linear filtering is only available for the
comment|// color buffer, leaving only nearest being unfiltered from above
if|if
condition|(
operator|(
name|mask
operator|&
operator|~
name|GL_COLOR_BUFFER_BIT
operator|)
operator|!=
literal|0
operator|&&
name|filter
operator|!=
name|GL_NEAREST
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getReadFramebuffer
argument_list|()
operator|->
name|id
argument_list|()
operator|==
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getDrawFramebuffer
argument_list|()
operator|->
name|id
argument_list|()
condition|)
block|{
if|if
condition|(
name|fromAngleExtension
condition|)
block|{
name|ERR
argument_list|(
literal|"Blits with the same source and destination framebuffer are not supported by this "
literal|"implementation."
argument_list|)
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|gl
operator|::
name|Framebuffer
modifier|*
name|readFramebuffer
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getReadFramebuffer
argument_list|()
decl_stmt|;
name|gl
operator|::
name|Framebuffer
modifier|*
name|drawFramebuffer
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|readFramebuffer
operator|||
name|readFramebuffer
operator|->
name|completeness
argument_list|()
operator|!=
name|GL_FRAMEBUFFER_COMPLETE
operator|||
operator|!
name|drawFramebuffer
operator|||
name|drawFramebuffer
operator|->
name|completeness
argument_list|()
operator|!=
name|GL_FRAMEBUFFER_COMPLETE
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_FRAMEBUFFER_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|drawFramebuffer
operator|->
name|getSamples
argument_list|()
operator|!=
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|bool
name|sameBounds
init|=
name|srcX0
operator|==
name|dstX0
operator|&&
name|srcY0
operator|==
name|dstY0
operator|&&
name|srcX1
operator|==
name|dstX1
operator|&&
name|srcY1
operator|==
name|dstY1
decl_stmt|;
if|if
condition|(
name|mask
operator|&
name|GL_COLOR_BUFFER_BIT
condition|)
block|{
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|readColorBuffer
init|=
name|readFramebuffer
operator|->
name|getReadColorbuffer
argument_list|()
decl_stmt|;
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|drawColorBuffer
init|=
name|drawFramebuffer
operator|->
name|getFirstColorbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|readColorBuffer
operator|&&
name|drawColorBuffer
condition|)
block|{
name|GLenum
name|readInternalFormat
init|=
name|readColorBuffer
operator|->
name|getActualFormat
argument_list|()
decl_stmt|;
name|GLenum
name|readComponentType
init|=
name|gl
operator|::
name|GetComponentType
argument_list|(
name|readInternalFormat
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|drawFramebuffer
operator|->
name|isEnabledColorAttachment
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|GLenum
name|drawInternalFormat
init|=
name|drawFramebuffer
operator|->
name|getColorbuffer
argument_list|(
name|i
argument_list|)
operator|->
name|getActualFormat
argument_list|()
decl_stmt|;
name|GLenum
name|drawComponentType
init|=
name|gl
operator|::
name|GetComponentType
argument_list|(
name|drawInternalFormat
argument_list|)
decl_stmt|;
comment|// The GL ES 3.0.2 spec (pg 193) states that:
comment|// 1) If the read buffer is fixed point format, the draw buffer must be as well
comment|// 2) If the read buffer is an unsigned integer format, the draw buffer must be as well
comment|// 3) If the read buffer is a signed integer format, the draw buffer must be as well
if|if
condition|(
operator|(
name|readComponentType
operator|==
name|GL_UNSIGNED_NORMALIZED
operator|||
name|readComponentType
operator|==
name|GL_SIGNED_NORMALIZED
operator|)
operator|&&
operator|!
operator|(
name|drawComponentType
operator|==
name|GL_UNSIGNED_NORMALIZED
operator|||
name|drawComponentType
operator|==
name|GL_SIGNED_NORMALIZED
operator|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|readComponentType
operator|==
name|GL_UNSIGNED_INT
operator|&&
name|drawComponentType
operator|!=
name|GL_UNSIGNED_INT
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|readComponentType
operator|==
name|GL_INT
operator|&&
name|drawComponentType
operator|!=
name|GL_INT
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|readColorBuffer
operator|->
name|getSamples
argument_list|()
operator|>
literal|0
operator|&&
operator|(
name|readInternalFormat
operator|!=
name|drawInternalFormat
operator|||
operator|!
name|sameBounds
operator|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|readComponentType
operator|==
name|GL_INT
operator|||
name|readComponentType
operator|==
name|GL_UNSIGNED_INT
operator|)
operator|&&
name|filter
operator|==
name|GL_LINEAR
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|fromAngleExtension
condition|)
block|{
specifier|const
name|GLenum
name|readColorbufferType
init|=
name|readFramebuffer
operator|->
name|getReadColorbufferType
argument_list|()
decl_stmt|;
if|if
condition|(
name|readColorbufferType
operator|!=
name|GL_TEXTURE_2D
operator|&&
name|readColorbufferType
operator|!=
name|GL_RENDERBUFFER
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
for|for
control|(
name|unsigned
name|int
name|colorAttachment
init|=
literal|0
init|;
name|colorAttachment
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
condition|;
name|colorAttachment
operator|++
control|)
block|{
if|if
condition|(
name|drawFramebuffer
operator|->
name|isEnabledColorAttachment
argument_list|(
name|colorAttachment
argument_list|)
condition|)
block|{
name|FramebufferAttachment
modifier|*
name|attachment
init|=
name|drawFramebuffer
operator|->
name|getColorbuffer
argument_list|(
name|colorAttachment
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|attachment
argument_list|)
expr_stmt|;
if|if
condition|(
name|attachment
operator|->
name|type
argument_list|()
operator|!=
name|GL_TEXTURE_2D
operator|&&
name|attachment
operator|->
name|type
argument_list|()
operator|!=
name|GL_RENDERBUFFER
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|attachment
operator|->
name|getActualFormat
argument_list|()
operator|!=
name|readColorBuffer
operator|->
name|getActualFormat
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
block|}
if|if
condition|(
name|readFramebuffer
operator|->
name|getSamples
argument_list|()
operator|!=
literal|0
operator|&&
name|IsPartialBlit
argument_list|(
name|context
argument_list|,
name|readColorBuffer
argument_list|,
name|drawColorBuffer
argument_list|,
name|srcX0
argument_list|,
name|srcY0
argument_list|,
name|srcX1
argument_list|,
name|srcY1
argument_list|,
name|dstX0
argument_list|,
name|dstY0
argument_list|,
name|dstX1
argument_list|,
name|dstY1
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|GL_DEPTH_BUFFER_BIT
condition|)
block|{
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|readDepthBuffer
init|=
name|readFramebuffer
operator|->
name|getDepthbuffer
argument_list|()
decl_stmt|;
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|drawDepthBuffer
init|=
name|drawFramebuffer
operator|->
name|getDepthbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|readDepthBuffer
operator|&&
name|drawDepthBuffer
condition|)
block|{
if|if
condition|(
name|readDepthBuffer
operator|->
name|getActualFormat
argument_list|()
operator|!=
name|drawDepthBuffer
operator|->
name|getActualFormat
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|readDepthBuffer
operator|->
name|getSamples
argument_list|()
operator|>
literal|0
operator|&&
operator|!
name|sameBounds
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|fromAngleExtension
condition|)
block|{
if|if
condition|(
name|IsPartialBlit
argument_list|(
name|context
argument_list|,
name|readDepthBuffer
argument_list|,
name|drawDepthBuffer
argument_list|,
name|srcX0
argument_list|,
name|srcY0
argument_list|,
name|srcX1
argument_list|,
name|srcY1
argument_list|,
name|dstX0
argument_list|,
name|dstY0
argument_list|,
name|dstX1
argument_list|,
name|dstY1
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Only whole-buffer depth and stencil blits are supported by this implementation."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
comment|// only whole-buffer copies are permitted
block|}
if|if
condition|(
name|readDepthBuffer
operator|->
name|getSamples
argument_list|()
operator|!=
literal|0
operator|||
name|drawDepthBuffer
operator|->
name|getSamples
argument_list|()
operator|!=
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|GL_STENCIL_BUFFER_BIT
condition|)
block|{
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|readStencilBuffer
init|=
name|readFramebuffer
operator|->
name|getStencilbuffer
argument_list|()
decl_stmt|;
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|drawStencilBuffer
init|=
name|drawFramebuffer
operator|->
name|getStencilbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|readStencilBuffer
operator|&&
name|drawStencilBuffer
condition|)
block|{
if|if
condition|(
name|readStencilBuffer
operator|->
name|getActualFormat
argument_list|()
operator|!=
name|drawStencilBuffer
operator|->
name|getActualFormat
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|readStencilBuffer
operator|->
name|getSamples
argument_list|()
operator|>
literal|0
operator|&&
operator|!
name|sameBounds
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|fromAngleExtension
condition|)
block|{
if|if
condition|(
name|IsPartialBlit
argument_list|(
name|context
argument_list|,
name|readStencilBuffer
argument_list|,
name|drawStencilBuffer
argument_list|,
name|srcX0
argument_list|,
name|srcY0
argument_list|,
name|srcX1
argument_list|,
name|srcY1
argument_list|,
name|dstX0
argument_list|,
name|dstY0
argument_list|,
name|dstX1
argument_list|,
name|dstY1
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Only whole-buffer depth and stencil blits are supported by this implementation."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
comment|// only whole-buffer copies are permitted
block|}
if|if
condition|(
name|readStencilBuffer
operator|->
name|getSamples
argument_list|()
operator|!=
literal|0
operator|||
name|drawStencilBuffer
operator|->
name|getSamples
argument_list|()
operator|!=
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateGetVertexAttribParameters
name|bool
name|ValidateGetVertexAttribParameters
parameter_list|(
name|GLenum
name|pname
parameter_list|,
name|int
name|clientVersion
parameter_list|)
block|{
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_VERTEX_ATTRIB_ARRAY_ENABLED
case|:
case|case
name|GL_VERTEX_ATTRIB_ARRAY_SIZE
case|:
case|case
name|GL_VERTEX_ATTRIB_ARRAY_STRIDE
case|:
case|case
name|GL_VERTEX_ATTRIB_ARRAY_TYPE
case|:
case|case
name|GL_VERTEX_ATTRIB_ARRAY_NORMALIZED
case|:
case|case
name|GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING
case|:
case|case
name|GL_CURRENT_VERTEX_ATTRIB
case|:
return|return
literal|true
return|;
case|case
name|GL_VERTEX_ATTRIB_ARRAY_DIVISOR
case|:
comment|// Don't verify ES3 context because GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE uses
comment|// the same constant.
name|META_ASSERT
argument_list|(
name|GL_VERTEX_ATTRIB_ARRAY_DIVISOR
operator|==
name|GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
case|case
name|GL_VERTEX_ATTRIB_ARRAY_INTEGER
case|:
return|return
operator|(
operator|(
name|clientVersion
operator|>=
literal|3
operator|)
condition|?
literal|true
else|:
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
operator|)
return|;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
DECL|function|ValidateTexParamParameters
name|bool
name|ValidateTexParamParameters
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLint
name|param
parameter_list|)
block|{
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_TEXTURE_WRAP_R
case|:
case|case
name|GL_TEXTURE_SWIZZLE_R
case|:
case|case
name|GL_TEXTURE_SWIZZLE_G
case|:
case|case
name|GL_TEXTURE_SWIZZLE_B
case|:
case|case
name|GL_TEXTURE_SWIZZLE_A
case|:
case|case
name|GL_TEXTURE_BASE_LEVEL
case|:
case|case
name|GL_TEXTURE_MAX_LEVEL
case|:
case|case
name|GL_TEXTURE_COMPARE_MODE
case|:
case|case
name|GL_TEXTURE_COMPARE_FUNC
case|:
case|case
name|GL_TEXTURE_MIN_LOD
case|:
case|case
name|GL_TEXTURE_MAX_LOD
case|:
if|if
condition|(
name|context
operator|->
name|getClientVersion
argument_list|()
operator|<
literal|3
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
return|;
block|}
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_TEXTURE_WRAP_S
case|:
case|case
name|GL_TEXTURE_WRAP_T
case|:
case|case
name|GL_TEXTURE_WRAP_R
case|:
switch|switch
condition|(
name|param
condition|)
block|{
case|case
name|GL_REPEAT
case|:
case|case
name|GL_CLAMP_TO_EDGE
case|:
case|case
name|GL_MIRRORED_REPEAT
case|:
return|return
literal|true
return|;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
return|;
block|}
case|case
name|GL_TEXTURE_MIN_FILTER
case|:
switch|switch
condition|(
name|param
condition|)
block|{
case|case
name|GL_NEAREST
case|:
case|case
name|GL_LINEAR
case|:
case|case
name|GL_NEAREST_MIPMAP_NEAREST
case|:
case|case
name|GL_LINEAR_MIPMAP_NEAREST
case|:
case|case
name|GL_NEAREST_MIPMAP_LINEAR
case|:
case|case
name|GL_LINEAR_MIPMAP_LINEAR
case|:
return|return
literal|true
return|;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_TEXTURE_MAG_FILTER
case|:
switch|switch
condition|(
name|param
condition|)
block|{
case|case
name|GL_NEAREST
case|:
case|case
name|GL_LINEAR
case|:
return|return
literal|true
return|;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_TEXTURE_USAGE_ANGLE
case|:
switch|switch
condition|(
name|param
condition|)
block|{
case|case
name|GL_NONE
case|:
case|case
name|GL_FRAMEBUFFER_ATTACHMENT_ANGLE
case|:
return|return
literal|true
return|;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_TEXTURE_MAX_ANISOTROPY_EXT
case|:
if|if
condition|(
operator|!
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|textureFilterAnisotropic
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|// we assume the parameter passed to this validation method is truncated, not rounded
if|if
condition|(
name|param
operator|<
literal|1
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|false
argument_list|)
return|;
block|}
return|return
literal|true
return|;
case|case
name|GL_TEXTURE_MIN_LOD
case|:
case|case
name|GL_TEXTURE_MAX_LOD
case|:
comment|// any value is permissible
return|return
literal|true
return|;
case|case
name|GL_TEXTURE_COMPARE_MODE
case|:
comment|// Acceptable mode parameters from GLES 3.0.2 spec, table 3.17
switch|switch
condition|(
name|param
condition|)
block|{
case|case
name|GL_NONE
case|:
case|case
name|GL_COMPARE_REF_TO_TEXTURE
case|:
return|return
literal|true
return|;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_TEXTURE_COMPARE_FUNC
case|:
comment|// Acceptable function parameters from GLES 3.0.2 spec, table 3.17
switch|switch
condition|(
name|param
condition|)
block|{
case|case
name|GL_LEQUAL
case|:
case|case
name|GL_GEQUAL
case|:
case|case
name|GL_LESS
case|:
case|case
name|GL_GREATER
case|:
case|case
name|GL_EQUAL
case|:
case|case
name|GL_NOTEQUAL
case|:
case|case
name|GL_ALWAYS
case|:
case|case
name|GL_NEVER
case|:
return|return
literal|true
return|;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_TEXTURE_SWIZZLE_R
case|:
case|case
name|GL_TEXTURE_SWIZZLE_G
case|:
case|case
name|GL_TEXTURE_SWIZZLE_B
case|:
case|case
name|GL_TEXTURE_SWIZZLE_A
case|:
switch|switch
condition|(
name|param
condition|)
block|{
case|case
name|GL_RED
case|:
case|case
name|GL_GREEN
case|:
case|case
name|GL_BLUE
case|:
case|case
name|GL_ALPHA
case|:
case|case
name|GL_ZERO
case|:
case|case
name|GL_ONE
case|:
return|return
literal|true
return|;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_TEXTURE_BASE_LEVEL
case|:
case|case
name|GL_TEXTURE_MAX_LEVEL
case|:
if|if
condition|(
name|param
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|false
argument_list|)
return|;
block|}
return|return
literal|true
return|;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
DECL|function|ValidateSamplerObjectParameter
name|bool
name|ValidateSamplerObjectParameter
parameter_list|(
name|GLenum
name|pname
parameter_list|)
block|{
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_TEXTURE_MIN_FILTER
case|:
case|case
name|GL_TEXTURE_MAG_FILTER
case|:
case|case
name|GL_TEXTURE_WRAP_S
case|:
case|case
name|GL_TEXTURE_WRAP_T
case|:
case|case
name|GL_TEXTURE_WRAP_R
case|:
case|case
name|GL_TEXTURE_MIN_LOD
case|:
case|case
name|GL_TEXTURE_MAX_LOD
case|:
case|case
name|GL_TEXTURE_COMPARE_MODE
case|:
case|case
name|GL_TEXTURE_COMPARE_FUNC
case|:
return|return
literal|true
return|;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
DECL|function|ValidateReadPixelsParameters
name|bool
name|ValidateReadPixelsParameters
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLsizei
modifier|*
name|bufSize
parameter_list|,
name|GLvoid
modifier|*
name|pixels
parameter_list|)
block|{
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getReadFramebuffer
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|framebuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|framebuffer
operator|->
name|completeness
argument_list|()
operator|!=
name|GL_FRAMEBUFFER_COMPLETE
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_FRAMEBUFFER_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getReadFramebuffer
argument_list|()
operator|->
name|id
argument_list|()
operator|!=
literal|0
operator|&&
name|framebuffer
operator|->
name|getSamples
argument_list|()
operator|!=
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|framebuffer
operator|->
name|getReadColorbuffer
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|GLenum
name|currentInternalFormat
decl_stmt|,
name|currentFormat
decl_stmt|,
name|currentType
decl_stmt|;
name|GLuint
name|clientVersion
init|=
name|context
operator|->
name|getClientVersion
argument_list|()
decl_stmt|;
name|context
operator|->
name|getCurrentReadFormatType
argument_list|(
operator|&
name|currentInternalFormat
argument_list|,
operator|&
name|currentFormat
argument_list|,
operator|&
name|currentType
argument_list|)
expr_stmt|;
name|bool
name|validReadFormat
init|=
operator|(
name|clientVersion
operator|<
literal|3
operator|)
condition|?
name|ValidES2ReadFormatType
argument_list|(
name|context
argument_list|,
name|format
argument_list|,
name|type
argument_list|)
else|:
name|ValidES3ReadFormatType
argument_list|(
name|context
argument_list|,
name|currentInternalFormat
argument_list|,
name|format
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|currentFormat
operator|==
name|format
operator|&&
name|currentType
operator|==
name|type
operator|)
operator|&&
operator|!
name|validReadFormat
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|GLenum
name|sizedInternalFormat
init|=
name|IsSizedInternalFormat
argument_list|(
name|format
argument_list|)
condition|?
name|format
else|:
name|GetSizedInternalFormat
argument_list|(
name|format
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|GLsizei
name|outputPitch
init|=
name|GetRowPitch
argument_list|(
name|sizedInternalFormat
argument_list|,
name|type
argument_list|,
name|width
argument_list|,
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getPackAlignment
argument_list|()
argument_list|)
decl_stmt|;
comment|// sized query sanity check
if|if
condition|(
name|bufSize
condition|)
block|{
name|int
name|requiredSize
init|=
name|outputPitch
operator|*
name|height
decl_stmt|;
if|if
condition|(
name|requiredSize
operator|>
operator|*
name|bufSize
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateBeginQuery
name|bool
name|ValidateBeginQuery
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLuint
name|id
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ValidQueryType
argument_list|(
name|context
argument_list|,
name|target
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|id
operator|==
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|// From EXT_occlusion_query_boolean: If BeginQueryEXT is called with an<id>
comment|// of zero, if the active query object name for<target> is non-zero (for the
comment|// targets ANY_SAMPLES_PASSED_EXT and ANY_SAMPLES_PASSED_CONSERVATIVE_EXT, if
comment|// the active query for either target is non-zero), if<id> is the name of an
comment|// existing query object whose type does not match<target>, or if<id> is the
comment|// active query object name for any query type, the error INVALID_OPERATION is
comment|// generated.
comment|// Ensure no other queries are active
comment|// NOTE: If other queries than occlusion are supported, we will need to check
comment|// separately that:
comment|//    a) The query ID passed is not the current active query for any target/type
comment|//    b) There are no active queries for the requested target (and in the case
comment|//       of GL_ANY_SAMPLES_PASSED_EXT and GL_ANY_SAMPLES_PASSED_CONSERVATIVE_EXT,
comment|//       no query may be active for either if glBeginQuery targets either.
if|if
condition|(
name|context
operator|->
name|getState
argument_list|()
operator|.
name|isQueryActive
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|Query
modifier|*
name|queryObject
init|=
name|context
operator|->
name|getQuery
argument_list|(
name|id
argument_list|,
literal|true
argument_list|,
name|target
argument_list|)
decl_stmt|;
comment|// check that name was obtained with glGenQueries
if|if
condition|(
operator|!
name|queryObject
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|// check for type mismatch
if|if
condition|(
name|queryObject
operator|->
name|getType
argument_list|()
operator|!=
name|target
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateEndQuery
name|bool
name|ValidateEndQuery
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ValidQueryType
argument_list|(
name|context
argument_list|,
name|target
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|const
name|Query
modifier|*
name|queryObject
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getActiveQuery
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|queryObject
operator|==
name|NULL
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|queryObject
operator|->
name|isStarted
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateUniformCommonBase
specifier|static
name|bool
name|ValidateUniformCommonBase
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|targetUniformType
parameter_list|,
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|LinkedUniform
modifier|*
modifier|*
name|uniformOut
parameter_list|)
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|gl
operator|::
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getCurrentProgramBinary
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|programBinary
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|location
operator|==
operator|-
literal|1
condition|)
block|{
comment|// Silently ignore the uniform command
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|programBinary
operator|->
name|isValidUniformLocation
argument_list|(
name|location
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|LinkedUniform
modifier|*
name|uniform
init|=
name|programBinary
operator|->
name|getUniformByLocation
argument_list|(
name|location
argument_list|)
decl_stmt|;
comment|// attempting to write an array to a non-array uniform is an INVALID_OPERATION
if|if
condition|(
name|uniform
operator|->
name|elementCount
argument_list|()
operator|==
literal|1
operator|&&
name|count
operator|>
literal|1
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
operator|*
name|uniformOut
operator|=
name|uniform
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|ValidateUniform
name|bool
name|ValidateUniform
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|uniformType
parameter_list|,
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|)
block|{
comment|// Check for ES3 uniform entry points
if|if
condition|(
name|VariableComponentType
argument_list|(
name|uniformType
argument_list|)
operator|==
name|GL_UNSIGNED_INT
operator|&&
name|context
operator|->
name|getClientVersion
argument_list|()
operator|<
literal|3
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|LinkedUniform
modifier|*
name|uniform
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|ValidateUniformCommonBase
argument_list|(
name|context
argument_list|,
name|uniformType
argument_list|,
name|location
argument_list|,
name|count
argument_list|,
operator|&
name|uniform
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|GLenum
name|targetBoolType
init|=
name|VariableBoolVectorType
argument_list|(
name|uniformType
argument_list|)
decl_stmt|;
name|bool
name|samplerUniformCheck
init|=
operator|(
name|IsSampler
argument_list|(
name|uniform
operator|->
name|type
argument_list|)
operator|&&
name|uniformType
operator|==
name|GL_INT
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|samplerUniformCheck
operator|&&
name|uniformType
operator|!=
name|uniform
operator|->
name|type
operator|&&
name|targetBoolType
operator|!=
name|uniform
operator|->
name|type
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateUniformMatrix
name|bool
name|ValidateUniformMatrix
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|matrixType
parameter_list|,
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|)
block|{
comment|// Check for ES3 uniform entry points
name|int
name|rows
init|=
name|VariableRowCount
argument_list|(
name|matrixType
argument_list|)
decl_stmt|;
name|int
name|cols
init|=
name|VariableColumnCount
argument_list|(
name|matrixType
argument_list|)
decl_stmt|;
if|if
condition|(
name|rows
operator|!=
name|cols
operator|&&
name|context
operator|->
name|getClientVersion
argument_list|()
operator|<
literal|3
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|transpose
operator|!=
name|GL_FALSE
operator|&&
name|context
operator|->
name|getClientVersion
argument_list|()
operator|<
literal|3
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|LinkedUniform
modifier|*
name|uniform
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|ValidateUniformCommonBase
argument_list|(
name|context
argument_list|,
name|matrixType
argument_list|,
name|location
argument_list|,
name|count
argument_list|,
operator|&
name|uniform
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|uniform
operator|->
name|type
operator|!=
name|matrixType
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateStateQuery
name|bool
name|ValidateStateQuery
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLenum
modifier|*
name|nativeType
parameter_list|,
name|unsigned
name|int
modifier|*
name|numParams
parameter_list|)
block|{
if|if
condition|(
operator|!
name|context
operator|->
name|getQueryParameterInfo
argument_list|(
name|pname
argument_list|,
name|nativeType
argument_list|,
name|numParams
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|pname
operator|>=
name|GL_DRAW_BUFFER0
operator|&&
name|pname
operator|<=
name|GL_DRAW_BUFFER15
condition|)
block|{
name|unsigned
name|int
name|colorAttachment
init|=
operator|(
name|pname
operator|-
name|GL_DRAW_BUFFER0
operator|)
decl_stmt|;
if|if
condition|(
name|colorAttachment
operator|>=
name|context
operator|->
name|getCaps
argument_list|()
operator|.
name|maxDrawBuffers
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_TEXTURE_BINDING_2D
case|:
case|case
name|GL_TEXTURE_BINDING_CUBE_MAP
case|:
case|case
name|GL_TEXTURE_BINDING_3D
case|:
case|case
name|GL_TEXTURE_BINDING_2D_ARRAY
case|:
if|if
condition|(
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getActiveSampler
argument_list|()
operator|>=
name|context
operator|->
name|getMaximumCombinedTextureImageUnits
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_IMPLEMENTATION_COLOR_READ_TYPE
case|:
case|case
name|GL_IMPLEMENTATION_COLOR_READ_FORMAT
case|:
block|{
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getReadFramebuffer
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|framebuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|framebuffer
operator|->
name|completeness
argument_list|()
operator|!=
name|GL_FRAMEBUFFER_COMPLETE
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|FramebufferAttachment
modifier|*
name|attachment
init|=
name|framebuffer
operator|->
name|getReadColorbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|attachment
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
break|break;
default|default:
break|break;
block|}
comment|// pname is valid, but there are no parameters to return
if|if
condition|(
name|numParams
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateCopyTexImageParametersBase
name|bool
name|ValidateCopyTexImageParametersBase
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|bool
name|isSubImage
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLint
name|zoffset
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLint
name|border
parameter_list|,
name|GLenum
modifier|*
name|textureFormatOut
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ValidTexture2DDestinationTarget
argument_list|(
name|context
argument_list|,
name|target
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|level
operator|<
literal|0
operator|||
name|xoffset
operator|<
literal|0
operator|||
name|yoffset
operator|<
literal|0
operator|||
name|zoffset
operator|<
literal|0
operator|||
name|width
operator|<
literal|0
operator|||
name|height
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|std
operator|::
name|numeric_limits
argument_list|<
name|GLsizei
argument_list|>
operator|::
name|max
argument_list|()
operator|-
name|xoffset
operator|<
name|width
operator|||
name|std
operator|::
name|numeric_limits
argument_list|<
name|GLsizei
argument_list|>
operator|::
name|max
argument_list|()
operator|-
name|yoffset
operator|<
name|height
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|border
operator|!=
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|ValidMipLevel
argument_list|(
name|context
argument_list|,
name|target
argument_list|,
name|level
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getReadFramebuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|framebuffer
operator|->
name|completeness
argument_list|()
operator|!=
name|GL_FRAMEBUFFER_COMPLETE
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_FRAMEBUFFER_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getReadFramebuffer
argument_list|()
operator|->
name|id
argument_list|()
operator|!=
literal|0
operator|&&
name|framebuffer
operator|->
name|getSamples
argument_list|()
operator|!=
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|const
name|gl
operator|::
name|Caps
modifier|&
name|caps
init|=
name|context
operator|->
name|getCaps
argument_list|()
decl_stmt|;
name|gl
operator|::
name|Texture
modifier|*
name|texture
init|=
name|NULL
decl_stmt|;
name|GLenum
name|textureInternalFormat
init|=
name|GL_NONE
decl_stmt|;
name|bool
name|textureCompressed
init|=
literal|false
decl_stmt|;
name|bool
name|textureIsDepth
init|=
literal|false
decl_stmt|;
name|GLint
name|textureLevelWidth
init|=
literal|0
decl_stmt|;
name|GLint
name|textureLevelHeight
init|=
literal|0
decl_stmt|;
name|GLint
name|textureLevelDepth
init|=
literal|0
decl_stmt|;
name|GLuint
name|maxDimension
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TEXTURE_2D
case|:
block|{
name|gl
operator|::
name|Texture2D
modifier|*
name|texture2d
init|=
name|context
operator|->
name|getTexture2D
argument_list|()
decl_stmt|;
if|if
condition|(
name|texture2d
condition|)
block|{
name|textureInternalFormat
operator|=
name|texture2d
operator|->
name|getInternalFormat
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|textureCompressed
operator|=
name|texture2d
operator|->
name|isCompressed
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|textureIsDepth
operator|=
name|texture2d
operator|->
name|isDepth
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|textureLevelWidth
operator|=
name|texture2d
operator|->
name|getWidth
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|textureLevelHeight
operator|=
name|texture2d
operator|->
name|getHeight
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|textureLevelDepth
operator|=
literal|1
expr_stmt|;
name|texture
operator|=
name|texture2d
expr_stmt|;
name|maxDimension
operator|=
name|caps
operator|.
name|max2DTextureSize
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_X
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Y
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Z
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
case|:
block|{
name|gl
operator|::
name|TextureCubeMap
modifier|*
name|textureCube
init|=
name|context
operator|->
name|getTextureCubeMap
argument_list|()
decl_stmt|;
if|if
condition|(
name|textureCube
condition|)
block|{
name|textureInternalFormat
operator|=
name|textureCube
operator|->
name|getInternalFormat
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|textureCompressed
operator|=
name|textureCube
operator|->
name|isCompressed
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|textureIsDepth
operator|=
literal|false
expr_stmt|;
name|textureLevelWidth
operator|=
name|textureCube
operator|->
name|getWidth
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|textureLevelHeight
operator|=
name|textureCube
operator|->
name|getHeight
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|textureLevelDepth
operator|=
literal|1
expr_stmt|;
name|texture
operator|=
name|textureCube
expr_stmt|;
name|maxDimension
operator|=
name|caps
operator|.
name|maxCubeMapTextureSize
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GL_TEXTURE_2D_ARRAY
case|:
block|{
name|gl
operator|::
name|Texture2DArray
modifier|*
name|texture2dArray
init|=
name|context
operator|->
name|getTexture2DArray
argument_list|()
decl_stmt|;
if|if
condition|(
name|texture2dArray
condition|)
block|{
name|textureInternalFormat
operator|=
name|texture2dArray
operator|->
name|getInternalFormat
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|textureCompressed
operator|=
name|texture2dArray
operator|->
name|isCompressed
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|textureIsDepth
operator|=
name|texture2dArray
operator|->
name|isDepth
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|textureLevelWidth
operator|=
name|texture2dArray
operator|->
name|getWidth
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|textureLevelHeight
operator|=
name|texture2dArray
operator|->
name|getHeight
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|textureLevelDepth
operator|=
name|texture2dArray
operator|->
name|getLayers
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|texture
operator|=
name|texture2dArray
expr_stmt|;
name|maxDimension
operator|=
name|caps
operator|.
name|max2DTextureSize
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GL_TEXTURE_3D
case|:
block|{
name|gl
operator|::
name|Texture3D
modifier|*
name|texture3d
init|=
name|context
operator|->
name|getTexture3D
argument_list|()
decl_stmt|;
if|if
condition|(
name|texture3d
condition|)
block|{
name|textureInternalFormat
operator|=
name|texture3d
operator|->
name|getInternalFormat
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|textureCompressed
operator|=
name|texture3d
operator|->
name|isCompressed
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|textureIsDepth
operator|=
name|texture3d
operator|->
name|isDepth
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|textureLevelWidth
operator|=
name|texture3d
operator|->
name|getWidth
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|textureLevelHeight
operator|=
name|texture3d
operator|->
name|getHeight
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|textureLevelDepth
operator|=
name|texture3d
operator|->
name|getDepth
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|texture
operator|=
name|texture3d
expr_stmt|;
name|maxDimension
operator|=
name|caps
operator|.
name|max3DTextureSize
expr_stmt|;
block|}
block|}
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|texture
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|texture
operator|->
name|isImmutable
argument_list|()
operator|&&
operator|!
name|isSubImage
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|textureIsDepth
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|textureCompressed
condition|)
block|{
name|GLint
name|blockWidth
init|=
name|GetCompressedBlockWidth
argument_list|(
name|textureInternalFormat
argument_list|)
decl_stmt|;
name|GLint
name|blockHeight
init|=
name|GetCompressedBlockHeight
argument_list|(
name|textureInternalFormat
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|width
operator|%
name|blockWidth
operator|)
operator|!=
literal|0
operator|&&
name|width
operator|!=
name|textureLevelWidth
operator|)
operator|||
operator|(
operator|(
name|height
operator|%
name|blockHeight
operator|)
operator|!=
literal|0
operator|&&
name|height
operator|!=
name|textureLevelHeight
operator|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|isSubImage
condition|)
block|{
if|if
condition|(
name|xoffset
operator|+
name|width
operator|>
name|textureLevelWidth
operator|||
name|yoffset
operator|+
name|height
operator|>
name|textureLevelHeight
operator|||
name|zoffset
operator|>=
name|textureLevelDepth
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|IsCubemapTextureTarget
argument_list|(
name|target
argument_list|)
operator|&&
name|width
operator|!=
name|height
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|IsValidInternalFormat
argument_list|(
name|internalformat
argument_list|,
name|context
operator|->
name|getExtensions
argument_list|()
argument_list|,
name|context
operator|->
name|getClientVersion
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|int
name|maxLevelDimension
init|=
operator|(
name|maxDimension
operator|>>
name|level
operator|)
decl_stmt|;
if|if
condition|(
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|width
argument_list|)
operator|>
name|maxLevelDimension
operator|||
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|height
argument_list|)
operator|>
name|maxLevelDimension
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
operator|*
name|textureFormatOut
operator|=
name|textureInternalFormat
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|ValidateDrawBase
specifier|static
name|bool
name|ValidateDrawBase
parameter_list|(
specifier|const
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|GL_POINTS
case|:
case|case
name|GL_LINES
case|:
case|case
name|GL_LINE_LOOP
case|:
case|case
name|GL_LINE_STRIP
case|:
case|case
name|GL_TRIANGLES
case|:
case|case
name|GL_TRIANGLE_STRIP
case|:
case|case
name|GL_TRIANGLE_FAN
case|:
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|// Check for mapped buffers
if|if
condition|(
name|context
operator|->
name|hasMappedBuffer
argument_list|(
name|GL_ARRAY_BUFFER
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|const
name|gl
operator|::
name|DepthStencilState
modifier|&
name|depthStencilState
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getDepthStencilState
argument_list|()
decl_stmt|;
if|if
condition|(
name|depthStencilState
operator|.
name|stencilWritemask
operator|!=
name|depthStencilState
operator|.
name|stencilBackWritemask
operator|||
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getStencilRef
argument_list|()
operator|!=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getStencilBackRef
argument_list|()
operator|||
name|depthStencilState
operator|.
name|stencilMask
operator|!=
name|depthStencilState
operator|.
name|stencilBackMask
condition|)
block|{
comment|// Note: these separate values are not supported in WebGL, due to D3D's limitations.
comment|// See Section 6.10 of the WebGL 1.0 spec
name|ERR
argument_list|(
literal|"This ANGLE implementation does not support separate front/back stencil "
literal|"writemasks, reference values, or stencil mask values."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|fbo
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|fbo
operator|||
name|fbo
operator|->
name|completeness
argument_list|()
operator|!=
name|GL_FRAMEBUFFER_COMPLETE
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_FRAMEBUFFER_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getCurrentProgramId
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|gl
operator|::
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getCurrentProgramBinary
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|programBinary
operator|->
name|validateSamplers
argument_list|(
name|NULL
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|// No-op if zero count
return|return
operator|(
name|count
operator|>
literal|0
operator|)
return|;
block|}
DECL|function|ValidateDrawArrays
name|bool
name|ValidateDrawArrays
parameter_list|(
specifier|const
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLint
name|first
parameter_list|,
name|GLsizei
name|count
parameter_list|)
block|{
if|if
condition|(
name|first
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|gl
operator|::
name|TransformFeedback
modifier|*
name|curTransformFeedback
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getCurrentTransformFeedback
argument_list|()
decl_stmt|;
if|if
condition|(
name|curTransformFeedback
operator|&&
name|curTransformFeedback
operator|->
name|isStarted
argument_list|()
operator|&&
operator|!
name|curTransformFeedback
operator|->
name|isPaused
argument_list|()
operator|&&
name|curTransformFeedback
operator|->
name|getDrawMode
argument_list|()
operator|!=
name|mode
condition|)
block|{
comment|// It is an invalid operation to call DrawArrays or DrawArraysInstanced with a draw mode
comment|// that does not match the current transform feedback object's draw mode (if transform feedback
comment|// is active), (3.0.2, section 2.14, pg 86)
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|ValidateDrawBase
argument_list|(
name|context
argument_list|,
name|mode
argument_list|,
name|count
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateDrawArraysInstanced
name|bool
name|ValidateDrawArraysInstanced
parameter_list|(
specifier|const
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLint
name|first
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLsizei
name|primcount
parameter_list|)
block|{
if|if
condition|(
name|primcount
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|ValidateDrawArrays
argument_list|(
name|context
argument_list|,
name|mode
argument_list|,
name|first
argument_list|,
name|count
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// No-op if zero primitive count
return|return
operator|(
name|primcount
operator|>
literal|0
operator|)
return|;
block|}
DECL|function|ValidateDrawElements
name|bool
name|ValidateDrawElements
parameter_list|(
specifier|const
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_UNSIGNED_BYTE
case|:
case|case
name|GL_UNSIGNED_SHORT
case|:
break|break;
case|case
name|GL_UNSIGNED_INT
case|:
if|if
condition|(
operator|!
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|elementIndexUint
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
return|;
block|}
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|gl
operator|::
name|TransformFeedback
modifier|*
name|curTransformFeedback
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getCurrentTransformFeedback
argument_list|()
decl_stmt|;
if|if
condition|(
name|curTransformFeedback
operator|&&
name|curTransformFeedback
operator|->
name|isStarted
argument_list|()
operator|&&
operator|!
name|curTransformFeedback
operator|->
name|isPaused
argument_list|()
condition|)
block|{
comment|// It is an invalid operation to call DrawElements, DrawRangeElements or DrawElementsInstanced
comment|// while transform feedback is active, (3.0.2, section 2.14, pg 86)
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|// Check for mapped buffers
if|if
condition|(
name|context
operator|->
name|hasMappedBuffer
argument_list|(
name|GL_ELEMENT_ARRAY_BUFFER
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|gl
operator|::
name|VertexArray
modifier|*
name|vao
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getVertexArray
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|indices
operator|&&
operator|!
name|vao
operator|->
name|getElementArrayBuffer
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|ValidateDrawBase
argument_list|(
name|context
argument_list|,
name|mode
argument_list|,
name|count
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateDrawElementsInstanced
name|bool
name|ValidateDrawElementsInstanced
parameter_list|(
specifier|const
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|GLsizei
name|primcount
parameter_list|)
block|{
if|if
condition|(
name|primcount
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|ValidateDrawElements
argument_list|(
name|context
argument_list|,
name|mode
argument_list|,
name|count
argument_list|,
name|type
argument_list|,
name|indices
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// No-op zero primitive count
return|return
operator|(
name|primcount
operator|>
literal|0
operator|)
return|;
block|}
DECL|function|ValidateFramebufferTextureBase
name|bool
name|ValidateFramebufferTextureBase
parameter_list|(
specifier|const
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLenum
name|attachment
parameter_list|,
name|GLuint
name|texture
parameter_list|,
name|GLint
name|level
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ValidFramebufferTarget
argument_list|(
name|target
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|ValidateAttachmentTarget
argument_list|(
name|context
argument_list|,
name|attachment
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|texture
operator|!=
literal|0
condition|)
block|{
name|gl
operator|::
name|Texture
modifier|*
name|tex
init|=
name|context
operator|->
name|getTexture
argument_list|(
name|texture
argument_list|)
decl_stmt|;
if|if
condition|(
name|tex
operator|==
name|NULL
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|level
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getTargetFramebuffer
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|GLuint
name|framebufferHandle
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getTargetFramebuffer
argument_list|(
name|target
argument_list|)
operator|->
name|id
argument_list|()
decl_stmt|;
if|if
condition|(
name|framebufferHandle
operator|==
literal|0
operator|||
operator|!
name|framebuffer
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateFramebufferTexture2D
name|bool
name|ValidateFramebufferTexture2D
parameter_list|(
specifier|const
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLenum
name|attachment
parameter_list|,
name|GLenum
name|textarget
parameter_list|,
name|GLuint
name|texture
parameter_list|,
name|GLint
name|level
parameter_list|)
block|{
comment|// Attachments are required to be bound to level 0 in ES2
if|if
condition|(
name|context
operator|->
name|getClientVersion
argument_list|()
operator|<
literal|3
operator|&&
name|level
operator|!=
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|ValidateFramebufferTextureBase
argument_list|(
name|context
argument_list|,
name|target
argument_list|,
name|attachment
argument_list|,
name|texture
argument_list|,
name|level
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|texture
operator|!=
literal|0
condition|)
block|{
name|gl
operator|::
name|Texture
modifier|*
name|tex
init|=
name|context
operator|->
name|getTexture
argument_list|(
name|texture
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|tex
argument_list|)
expr_stmt|;
specifier|const
name|gl
operator|::
name|Caps
modifier|&
name|caps
init|=
name|context
operator|->
name|getCaps
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|textarget
condition|)
block|{
case|case
name|GL_TEXTURE_2D
case|:
block|{
if|if
condition|(
name|level
operator|>
name|gl
operator|::
name|log2
argument_list|(
name|caps
operator|.
name|max2DTextureSize
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|tex
operator|->
name|getTarget
argument_list|()
operator|!=
name|GL_TEXTURE_2D
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|gl
operator|::
name|Texture2D
modifier|*
name|tex2d
init|=
cast|static_cast
argument_list|<
name|gl
operator|::
name|Texture2D
operator|*
argument_list|>
argument_list|(
name|tex
argument_list|)
decl_stmt|;
if|if
condition|(
name|tex2d
operator|->
name|isCompressed
argument_list|(
name|level
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
break|break;
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_X
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Y
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Z
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
case|:
block|{
if|if
condition|(
name|level
operator|>
name|gl
operator|::
name|log2
argument_list|(
name|caps
operator|.
name|maxCubeMapTextureSize
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|tex
operator|->
name|getTarget
argument_list|()
operator|!=
name|GL_TEXTURE_CUBE_MAP
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|gl
operator|::
name|TextureCubeMap
modifier|*
name|texcube
init|=
cast|static_cast
argument_list|<
name|gl
operator|::
name|TextureCubeMap
operator|*
argument_list|>
argument_list|(
name|tex
argument_list|)
decl_stmt|;
if|if
condition|(
name|texcube
operator|->
name|isCompressed
argument_list|(
name|textarget
argument_list|,
name|level
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
end_namespace
end_unit
