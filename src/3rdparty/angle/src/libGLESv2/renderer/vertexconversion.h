begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2010 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// vertexconversion.h: A library of vertex conversion classes that can be used to build
end_comment
begin_comment
comment|// the FormatConverter objects used by the buffer conversion system.
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|LIBGLESV2_VERTEXCONVERSION_H_
end_ifndef
begin_define
DECL|macro|LIBGLESV2_VERTEXCONVERSION_H_
define|#
directive|define
name|LIBGLESV2_VERTEXCONVERSION_H_
end_define
begin_include
include|#
directive|include
file|<limits>
end_include
begin_include
include|#
directive|include
file|<cstdint>
end_include
begin_include
include|#
directive|include
file|<cstddef>
end_include
begin_decl_stmt
name|namespace
name|rx
block|{
comment|// Conversion types:
comment|// static const bool identity: true if this is an identity transform, false otherwise
comment|// static U convert(T): convert a single element from the input type to the output type
comment|// typedef ... OutputType: the type produced by this conversion
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|Identity
block|{
specifier|static
specifier|const
name|bool
name|identity
operator|=
name|true
block|;
typedef|typedef
name|T
name|OutputType
typedef|;
specifier|static
name|T
name|convert
argument_list|(
argument|T x
argument_list|)
block|{
return|return
name|x
return|;
block|}
block|}
empty_stmt|;
name|template
operator|<
name|class
name|FromT
operator|,
name|class
name|ToT
operator|>
expr|struct
name|Cast
block|{
specifier|static
specifier|const
name|bool
name|identity
operator|=
name|false
block|;
typedef|typedef
name|ToT
name|OutputType
typedef|;
specifier|static
name|ToT
name|convert
argument_list|(
argument|FromT x
argument_list|)
block|{
return|return
name|static_cast
operator|<
name|ToT
operator|>
operator|(
name|x
operator|)
return|;
block|}
block|}
empty_stmt|;
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|Cast
operator|<
name|T
operator|,
name|T
operator|>
block|{
specifier|static
specifier|const
name|bool
name|identity
operator|=
name|true
block|;
typedef|typedef
name|T
name|OutputType
typedef|;
specifier|static
name|T
name|convert
argument_list|(
argument|T x
argument_list|)
block|{
return|return
name|static_cast
operator|<
name|T
operator|>
operator|(
name|x
operator|)
return|;
block|}
block|}
empty_stmt|;
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|Normalize
block|{
specifier|static
specifier|const
name|bool
name|identity
operator|=
name|false
block|;
typedef|typedef
name|float
name|OutputType
typedef|;
specifier|static
name|float
name|convert
argument_list|(
argument|T x
argument_list|)
block|{
typedef|typedef
name|std
operator|::
name|numeric_limits
operator|<
name|T
operator|>
name|NL
expr_stmt|;
name|float
name|f
operator|=
name|static_cast
operator|<
name|float
operator|>
operator|(
name|x
operator|)
expr_stmt|;
if|if
condition|(
name|NL
operator|::
name|is_signed
condition|)
block|{
comment|// const float => VC2008 computes it at compile time
comment|// static const float => VC2008 computes it the first time we get here, stores it to memory with static guard and all that.
specifier|const
name|float
name|divisor
init|=
literal|1.0f
operator|/
operator|(
literal|2
operator|*
name|static_cast
operator|<
name|float
operator|>
operator|(
name|NL
operator|::
name|max
argument_list|()
operator|)
operator|+
literal|1
operator|)
decl_stmt|;
return|return
operator|(
literal|2
operator|*
name|f
operator|+
literal|1
operator|)
operator|*
name|divisor
return|;
block|}
else|else
block|{
return|return
name|f
operator|/
name|NL
operator|::
name|max
argument_list|()
return|;
block|}
block|}
end_decl_stmt
begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|FromType
operator|,
name|std
operator|::
name|size_t
name|ScaleBits
operator|>
expr|struct
name|FixedToFloat
block|{
specifier|static
specifier|const
name|bool
name|identity
operator|=
name|false
block|;
typedef|typedef
name|float
name|OutputType
typedef|;
specifier|static
name|float
name|convert
argument_list|(
argument|FromType x
argument_list|)
block|{
specifier|const
name|float
name|divisor
operator|=
literal|1.0f
operator|/
name|static_cast
operator|<
name|float
operator|>
operator|(
name|static_cast
operator|<
name|FromType
operator|>
operator|(
literal|1
operator|)
operator|<<
name|ScaleBits
operator|)
block|;
return|return
name|static_cast
operator|<
name|float
operator|>
operator|(
name|x
operator|)
operator|*
name|divisor
return|;
block|}
block|}
end_expr_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_comment
comment|// Widen types:
end_comment
begin_comment
comment|// static const unsigned int initialWidth: number of components before conversion
end_comment
begin_comment
comment|// static const unsigned int finalWidth: number of components after conversion
end_comment
begin_comment
comment|// Float is supported at any size.
end_comment
begin_expr_stmt
name|template
operator|<
name|std
operator|::
name|size_t
name|N
operator|>
expr|struct
name|NoWiden
block|{
specifier|static
specifier|const
name|std
operator|::
name|size_t
name|initialWidth
operator|=
name|N
block|;
specifier|static
specifier|const
name|std
operator|::
name|size_t
name|finalWidth
operator|=
name|N
block|; }
expr_stmt|;
end_expr_stmt
begin_comment
comment|// SHORT, norm-SHORT, norm-UNSIGNED_SHORT are supported but only with 2 or 4 components
end_comment
begin_expr_stmt
name|template
operator|<
name|std
operator|::
name|size_t
name|N
operator|>
expr|struct
name|WidenToEven
block|{
specifier|static
specifier|const
name|std
operator|::
name|size_t
name|initialWidth
operator|=
name|N
block|;
specifier|static
specifier|const
name|std
operator|::
name|size_t
name|finalWidth
operator|=
name|N
operator|+
operator|(
name|N
operator|&
literal|1
operator|)
block|; }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|std
operator|::
name|size_t
name|N
operator|>
expr|struct
name|WidenToFour
block|{
specifier|static
specifier|const
name|std
operator|::
name|size_t
name|initialWidth
operator|=
name|N
block|;
specifier|static
specifier|const
name|std
operator|::
name|size_t
name|finalWidth
operator|=
literal|4
block|; }
expr_stmt|;
end_expr_stmt
begin_comment
comment|// Most types have 0 and 1 that are just that.
end_comment
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|SimpleDefaultValues
block|{
specifier|static
name|T
name|zero
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|T
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|T
name|one
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|T
operator|>
operator|(
literal|1
operator|)
return|;
block|}
end_expr_stmt
begin_comment
unit|};
comment|// But normalised types only store [0,1] or [-1,1] so 1.0 is represented by the max value.
end_comment
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|NormalizedDefaultValues
block|{
specifier|static
name|T
name|zero
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|T
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|T
name|one
argument_list|()
block|{
return|return
name|std
operator|::
name|numeric_limits
operator|<
name|T
operator|>
operator|::
name|max
argument_list|()
return|;
block|}
end_expr_stmt
begin_comment
unit|};
comment|// Converter:
end_comment
begin_comment
comment|// static const bool identity: true if this is an identity transform (with no widening)
end_comment
begin_comment
comment|// static const std::size_t finalSize: number of bytes per output vertex
end_comment
begin_comment
comment|// static void convertArray(const void *in, std::size_t stride, std::size_t n, void *out): convert an array of vertices. Input may be strided, but output will be unstrided.
end_comment
begin_expr_stmt
name|template
operator|<
name|class
name|InT
operator|,
name|class
name|WidenRule
operator|,
name|class
name|Converter
operator|,
name|class
name|DefaultValueRule
operator|=
name|SimpleDefaultValues
operator|<
name|InT
operator|>
expr|> struct
name|VertexDataConverter
block|{
typedef|typedef
name|typename
name|Converter
operator|::
name|OutputType
name|OutputType
expr_stmt|;
end_expr_stmt
begin_typedef
typedef|typedef
name|InT
name|InputType
typedef|;
end_typedef
begin_decl_stmt
specifier|static
specifier|const
name|bool
name|identity
init|=
operator|(
name|WidenRule
operator|::
name|initialWidth
operator|==
name|WidenRule
operator|::
name|finalWidth
operator|)
operator|&&
name|Converter
operator|::
name|identity
decl_stmt|;
end_decl_stmt
begin_expr_stmt
specifier|static
specifier|const
name|std
operator|::
name|size_t
name|finalSize
operator|=
name|WidenRule
operator|::
name|finalWidth
operator|*
sizeof|sizeof
argument_list|(
name|OutputType
argument_list|)
expr_stmt|;
end_expr_stmt
begin_function
specifier|static
name|void
name|convertArray
parameter_list|(
specifier|const
name|uint8_t
modifier|*
name|input
parameter_list|,
name|size_t
name|stride
parameter_list|,
name|size_t
name|n
parameter_list|,
name|uint8_t
modifier|*
name|output
parameter_list|)
block|{
name|OutputType
modifier|*
name|out
init|=
name|reinterpret_cast
operator|<
name|OutputType
operator|*
operator|>
operator|(
name|output
operator|)
decl_stmt|;
for|for
control|(
name|std
operator|::
name|size_t
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|InputType
modifier|*
name|ein
init|=
name|reinterpret_cast
operator|<
specifier|const
name|InputType
operator|*
operator|>
operator|(
name|input
operator|+
name|i
operator|*
name|stride
operator|)
decl_stmt|;
name|copyComponent
argument_list|(
name|out
argument_list|,
name|ein
argument_list|,
literal|0
argument_list|,
name|static_cast
operator|<
name|OutputType
operator|>
operator|(
name|DefaultValueRule
operator|::
name|zero
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|copyComponent
argument_list|(
name|out
argument_list|,
name|ein
argument_list|,
literal|1
argument_list|,
name|static_cast
operator|<
name|OutputType
operator|>
operator|(
name|DefaultValueRule
operator|::
name|zero
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|copyComponent
argument_list|(
name|out
argument_list|,
name|ein
argument_list|,
literal|2
argument_list|,
name|static_cast
operator|<
name|OutputType
operator|>
operator|(
name|DefaultValueRule
operator|::
name|zero
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|copyComponent
argument_list|(
name|out
argument_list|,
name|ein
argument_list|,
literal|3
argument_list|,
name|static_cast
operator|<
name|OutputType
operator|>
operator|(
name|DefaultValueRule
operator|::
name|one
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|out
operator|+=
name|WidenRule
operator|::
name|finalWidth
expr_stmt|;
block|}
block|}
end_function
begin_label
name|private
label|:
end_label
begin_decl_stmt
specifier|static
name|void
name|copyComponent
argument_list|(
name|OutputType
operator|*
name|out
argument_list|,
specifier|const
name|InputType
operator|*
name|in
argument_list|,
name|std
operator|::
name|size_t
name|elementindex
argument_list|,
name|OutputType
name|defaultvalue
argument_list|)
block|{
if|if
condition|(
name|WidenRule
operator|::
name|finalWidth
operator|>
name|elementindex
condition|)
block|{
if|if
condition|(
name|WidenRule
operator|::
name|initialWidth
operator|>
name|elementindex
condition|)
block|{
name|out
index|[
name|elementindex
index|]
operator|=
name|Converter
operator|::
name|convert
argument_list|(
name|in
index|[
name|elementindex
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
index|[
name|elementindex
index|]
operator|=
name|defaultvalue
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt
begin_endif
unit|};  }
endif|#
directive|endif
end_endif
begin_comment
comment|// LIBGLESV2_VERTEXCONVERSION_H_
end_comment
end_unit
