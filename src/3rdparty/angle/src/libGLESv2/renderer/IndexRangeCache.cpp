begin_unit
begin_include
include|#
directive|include
file|"precompiled.h"
end_include
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2013 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// IndexRangeCache.cpp: Defines the rx::IndexRangeCache class which stores information about
end_comment
begin_comment
comment|// ranges of indices.
end_comment
begin_include
include|#
directive|include
file|"libGLESv2/renderer/IndexRangeCache.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/formatutils.h"
end_include
begin_include
include|#
directive|include
file|"common/debug.h"
end_include
begin_include
include|#
directive|include
file|<tuple>
end_include
begin_namespace
DECL|namespace|rx
namespace|namespace
name|rx
block|{
DECL|function|addRange
name|void
name|IndexRangeCache
operator|::
name|addRange
parameter_list|(
name|GLenum
name|type
parameter_list|,
name|unsigned
name|int
name|offset
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|unsigned
name|int
name|minIdx
parameter_list|,
name|unsigned
name|int
name|maxIdx
parameter_list|,
name|unsigned
name|int
name|streamOffset
parameter_list|)
block|{
name|mIndexRangeCache
index|[
name|IndexRange
argument_list|(
name|type
argument_list|,
name|offset
argument_list|,
name|count
argument_list|)
index|]
operator|=
name|IndexBounds
argument_list|(
name|minIdx
argument_list|,
name|maxIdx
argument_list|,
name|streamOffset
argument_list|)
expr_stmt|;
block|}
DECL|function|invalidateRange
name|void
name|IndexRangeCache
operator|::
name|invalidateRange
parameter_list|(
name|unsigned
name|int
name|offset
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|unsigned
name|int
name|invalidateStart
init|=
name|offset
decl_stmt|;
name|unsigned
name|int
name|invalidateEnd
init|=
name|offset
operator|+
name|size
decl_stmt|;
name|IndexRangeMap
operator|::
name|iterator
name|i
init|=
name|mIndexRangeCache
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|mIndexRangeCache
operator|.
name|end
argument_list|()
condition|)
block|{
name|unsigned
name|int
name|rangeStart
init|=
name|i
operator|->
name|second
operator|.
name|streamOffset
decl_stmt|;
name|unsigned
name|int
name|rangeEnd
init|=
name|i
operator|->
name|second
operator|.
name|streamOffset
operator|+
operator|(
name|gl
operator|::
name|GetTypeBytes
argument_list|(
name|i
operator|->
name|first
operator|.
name|type
argument_list|)
operator|*
name|i
operator|->
name|first
operator|.
name|count
operator|)
decl_stmt|;
if|if
condition|(
name|invalidateEnd
argument_list|<
name|rangeStart
operator|||
name|invalidateStart
argument_list|>
name|rangeEnd
condition|)
block|{
operator|++
name|i
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|mIndexRangeCache
operator|.
name|erase
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|findRange
name|bool
name|IndexRangeCache
operator|::
name|findRange
parameter_list|(
name|GLenum
name|type
parameter_list|,
name|unsigned
name|int
name|offset
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|unsigned
name|int
modifier|*
name|outMinIndex
parameter_list|,
name|unsigned
name|int
modifier|*
name|outMaxIndex
parameter_list|,
name|unsigned
name|int
modifier|*
name|outStreamOffset
parameter_list|)
specifier|const
block|{
name|IndexRangeMap
operator|::
name|const_iterator
name|i
init|=
name|mIndexRangeCache
operator|.
name|find
argument_list|(
name|IndexRange
argument_list|(
name|type
argument_list|,
name|offset
argument_list|,
name|count
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|mIndexRangeCache
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|outMinIndex
condition|)
operator|*
name|outMinIndex
operator|=
name|i
operator|->
name|second
operator|.
name|minIndex
expr_stmt|;
if|if
condition|(
name|outMaxIndex
condition|)
operator|*
name|outMaxIndex
operator|=
name|i
operator|->
name|second
operator|.
name|maxIndex
expr_stmt|;
if|if
condition|(
name|outStreamOffset
condition|)
operator|*
name|outStreamOffset
operator|=
name|i
operator|->
name|second
operator|.
name|streamOffset
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
if|if
condition|(
name|outMinIndex
condition|)
operator|*
name|outMinIndex
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|outMaxIndex
condition|)
operator|*
name|outMaxIndex
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|outStreamOffset
condition|)
operator|*
name|outStreamOffset
operator|=
literal|0
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|clear
name|void
name|IndexRangeCache
operator|::
name|clear
parameter_list|()
block|{
name|mIndexRangeCache
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|function|IndexRange
name|IndexRangeCache
operator|::
name|IndexRange
operator|::
name|IndexRange
parameter_list|()
member_init_list|:
name|type
argument_list|(
name|GL_NONE
argument_list|)
member_init_list|,
name|offset
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|count
argument_list|(
literal|0
argument_list|)
block|{ }
DECL|function|IndexRange
name|IndexRangeCache
operator|::
name|IndexRange
operator|::
name|IndexRange
parameter_list|(
name|GLenum
name|typ
parameter_list|,
name|intptr_t
name|off
parameter_list|,
name|GLsizei
name|c
parameter_list|)
member_init_list|:
name|type
argument_list|(
name|typ
argument_list|)
member_init_list|,
name|offset
argument_list|(
name|off
argument_list|)
member_init_list|,
name|count
argument_list|(
name|c
argument_list|)
block|{ }
DECL|function|operator <
name|bool
name|IndexRangeCache
operator|::
name|IndexRange
operator|::
name|operator
name|<
parameter_list|(
specifier|const
name|IndexRange
modifier|&
name|rhs
parameter_list|)
specifier|const
block|{
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|_MSC_VER
operator|<
literal|1600
return|return
name|std
operator|::
name|tr1
operator|::
name|make_tuple
argument_list|(
name|type
argument_list|,
name|offset
argument_list|,
name|count
argument_list|)
operator|<
name|std
operator|::
name|tr1
operator|::
name|make_tuple
argument_list|(
name|rhs
operator|.
name|type
argument_list|,
name|rhs
operator|.
name|offset
argument_list|,
name|rhs
operator|.
name|count
argument_list|)
return|;
else|#
directive|else
return|return
name|std
operator|::
name|make_tuple
argument_list|(
name|type
argument_list|,
name|offset
argument_list|,
name|count
argument_list|)
operator|<
name|std
operator|::
name|make_tuple
argument_list|(
name|rhs
operator|.
name|type
argument_list|,
name|rhs
operator|.
name|offset
argument_list|,
name|rhs
operator|.
name|count
argument_list|)
return|;
endif|#
directive|endif
block|}
DECL|function|IndexBounds
name|IndexRangeCache
operator|::
name|IndexBounds
operator|::
name|IndexBounds
parameter_list|()
member_init_list|:
name|minIndex
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|maxIndex
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|streamOffset
argument_list|(
literal|0
argument_list|)
block|{ }
DECL|function|IndexBounds
name|IndexRangeCache
operator|::
name|IndexBounds
operator|::
name|IndexBounds
parameter_list|(
name|unsigned
name|int
name|minIdx
parameter_list|,
name|unsigned
name|int
name|maxIdx
parameter_list|,
name|unsigned
name|int
name|offset
parameter_list|)
member_init_list|:
name|minIndex
argument_list|(
name|minIdx
argument_list|)
member_init_list|,
name|maxIndex
argument_list|(
name|maxIdx
argument_list|)
member_init_list|,
name|streamOffset
argument_list|(
name|offset
argument_list|)
block|{ }
block|}
end_namespace
end_unit
