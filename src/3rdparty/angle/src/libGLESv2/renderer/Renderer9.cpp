begin_unit
begin_include
include|#
directive|include
file|"precompiled.h"
end_include
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2012-2013 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Renderer9.cpp: Implements a back-end specific class for the D3D9 renderer.
end_comment
begin_include
include|#
directive|include
file|"libGLESv2/main.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Buffer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Texture.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Framebuffer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Renderbuffer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/ProgramBinary.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/IndexDataManager.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/Renderer9.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/renderer9_utils.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/ShaderExecutable9.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/SwapChain9.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/TextureStorage9.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/Image9.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/Blit.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/RenderTarget9.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/VertexBuffer9.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/IndexBuffer9.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/BufferStorage9.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/Query9.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/Fence9.h"
end_include
begin_include
include|#
directive|include
file|"libEGL/Display.h"
end_include
begin_comment
comment|// Can also be enabled by defining FORCE_REF_RAST in the project's predefined macros
end_comment
begin_define
DECL|macro|REF_RAST
define|#
directive|define
name|REF_RAST
value|0
end_define
begin_comment
comment|// The "Debug This Pixel..." feature in PIX often fails when using the
end_comment
begin_comment
comment|// D3D9Ex interfaces.  In order to get debug pixel to work on a Vista/Win 7
end_comment
begin_comment
comment|// machine, define "ANGLE_ENABLE_D3D9EX=0" in your project file.
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ANGLE_ENABLE_D3D9EX
argument_list|)
end_if
begin_comment
comment|// Enables use of the IDirect3D9Ex interface, when available
end_comment
begin_define
DECL|macro|ANGLE_ENABLE_D3D9EX
define|#
directive|define
name|ANGLE_ENABLE_D3D9EX
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// !defined(ANGLE_ENABLE_D3D9EX)
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ANGLE_COMPILE_OPTIMIZATION_LEVEL
argument_list|)
end_if
begin_define
DECL|macro|ANGLE_COMPILE_OPTIMIZATION_LEVEL
define|#
directive|define
name|ANGLE_COMPILE_OPTIMIZATION_LEVEL
value|D3DCOMPILE_OPTIMIZATION_LEVEL3
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_namespace
DECL|namespace|rx
namespace|namespace
name|rx
block|{
DECL|member|RenderTargetFormats
specifier|static
specifier|const
name|D3DFORMAT
name|RenderTargetFormats
index|[]
init|=
block|{
name|D3DFMT_A1R5G5B5
block|,
comment|//  D3DFMT_A2R10G10B10,   // The color_ramp conformance test uses ReadPixels with UNSIGNED_BYTE causing it to think that rendering skipped a colour value.
name|D3DFMT_A8R8G8B8
block|,
name|D3DFMT_R5G6B5
block|,
comment|//  D3DFMT_X1R5G5B5,      // Has no compatible OpenGL ES renderbuffer format
name|D3DFMT_X8R8G8B8
block|}
decl_stmt|;
DECL|member|DepthStencilFormats
specifier|static
specifier|const
name|D3DFORMAT
name|DepthStencilFormats
index|[]
init|=
block|{
name|D3DFMT_UNKNOWN
block|,
comment|//  D3DFMT_D16_LOCKABLE,
name|D3DFMT_D32
block|,
comment|//  D3DFMT_D15S1,
name|D3DFMT_D24S8
block|,
name|D3DFMT_D24X8
block|,
comment|//  D3DFMT_D24X4S4,
name|D3DFMT_D16
block|,
comment|//  D3DFMT_D32F_LOCKABLE,
comment|//  D3DFMT_D24FS8
block|}
decl_stmt|;
enum|enum
block|{
DECL|enumerator|MAX_VERTEX_CONSTANT_VECTORS_D3D9
name|MAX_VERTEX_CONSTANT_VECTORS_D3D9
init|=
literal|256
block|,
DECL|enumerator|MAX_PIXEL_CONSTANT_VECTORS_SM2
name|MAX_PIXEL_CONSTANT_VECTORS_SM2
init|=
literal|32
block|,
DECL|enumerator|MAX_PIXEL_CONSTANT_VECTORS_SM3
name|MAX_PIXEL_CONSTANT_VECTORS_SM3
init|=
literal|224
block|,
DECL|enumerator|MAX_VARYING_VECTORS_SM2
name|MAX_VARYING_VECTORS_SM2
init|=
literal|8
block|,
DECL|enumerator|MAX_VARYING_VECTORS_SM3
name|MAX_VARYING_VECTORS_SM3
init|=
literal|10
block|,
DECL|enumerator|MAX_TEXTURE_IMAGE_UNITS_VTF_SM3
name|MAX_TEXTURE_IMAGE_UNITS_VTF_SM3
init|=
literal|4
block|}
enum|;
DECL|function|Renderer9
name|Renderer9
operator|::
name|Renderer9
parameter_list|(
name|egl
operator|::
name|Display
modifier|*
name|display
parameter_list|,
name|HDC
name|hDc
parameter_list|,
name|bool
name|softwareDevice
parameter_list|)
member_init_list|:
name|Renderer
argument_list|(
name|display
argument_list|)
member_init_list|,
name|mDc
argument_list|(
name|hDc
argument_list|)
member_init_list|,
name|mSoftwareDevice
argument_list|(
name|softwareDevice
argument_list|)
block|{
name|mD3d9Module
operator|=
name|NULL
expr_stmt|;
name|mD3d9
operator|=
name|NULL
expr_stmt|;
name|mD3d9Ex
operator|=
name|NULL
expr_stmt|;
name|mDevice
operator|=
name|NULL
expr_stmt|;
name|mDeviceEx
operator|=
name|NULL
expr_stmt|;
name|mDeviceWindow
operator|=
name|NULL
expr_stmt|;
name|mBlit
operator|=
name|NULL
expr_stmt|;
name|mAdapter
operator|=
name|D3DADAPTER_DEFAULT
expr_stmt|;
if|#
directive|if
name|REF_RAST
operator|==
literal|1
operator|||
name|defined
argument_list|(
name|FORCE_REF_RAST
argument_list|)
name|mDeviceType
operator|=
name|D3DDEVTYPE_REF
expr_stmt|;
else|#
directive|else
name|mDeviceType
operator|=
name|D3DDEVTYPE_HAL
expr_stmt|;
endif|#
directive|endif
name|mDeviceLost
operator|=
literal|false
expr_stmt|;
name|mMaxSupportedSamples
operator|=
literal|0
expr_stmt|;
name|mMaskedClearSavedState
operator|=
name|NULL
expr_stmt|;
name|mVertexDataManager
operator|=
name|NULL
expr_stmt|;
name|mIndexDataManager
operator|=
name|NULL
expr_stmt|;
name|mLineLoopIB
operator|=
name|NULL
expr_stmt|;
name|mMaxNullColorbufferLRU
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_NULL_COLORBUFFER_CACHE_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
name|mNullColorbufferCache
index|[
name|i
index|]
operator|.
name|lruCount
operator|=
literal|0
expr_stmt|;
name|mNullColorbufferCache
index|[
name|i
index|]
operator|.
name|width
operator|=
literal|0
expr_stmt|;
name|mNullColorbufferCache
index|[
name|i
index|]
operator|.
name|height
operator|=
literal|0
expr_stmt|;
name|mNullColorbufferCache
index|[
name|i
index|]
operator|.
name|buffer
operator|=
name|NULL
expr_stmt|;
block|}
block|}
DECL|function|~Renderer9
name|Renderer9
operator|::
name|~
name|Renderer9
parameter_list|()
block|{
name|releaseDeviceResources
argument_list|()
expr_stmt|;
if|if
condition|(
name|mDevice
condition|)
block|{
comment|// If the device is lost, reset it first to prevent leaving the driver in an unstable state
if|if
condition|(
name|testDeviceLost
argument_list|(
literal|false
argument_list|)
condition|)
block|{
name|resetDevice
argument_list|()
expr_stmt|;
block|}
name|mDevice
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mDevice
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mDeviceEx
condition|)
block|{
name|mDeviceEx
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mDeviceEx
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mD3d9
condition|)
block|{
name|mD3d9
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mD3d9
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mDeviceWindow
condition|)
block|{
name|DestroyWindow
argument_list|(
name|mDeviceWindow
argument_list|)
expr_stmt|;
name|mDeviceWindow
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mD3d9Ex
condition|)
block|{
name|mD3d9Ex
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mD3d9Ex
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mD3d9Module
condition|)
block|{
name|mD3d9Module
operator|=
name|NULL
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|mMultiSampleSupport
operator|.
name|empty
argument_list|()
condition|)
block|{
operator|delete
index|[]
name|mMultiSampleSupport
operator|.
name|begin
argument_list|()
operator|->
name|second
expr_stmt|;
name|mMultiSampleSupport
operator|.
name|erase
argument_list|(
name|mMultiSampleSupport
operator|.
name|begin
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|makeRenderer9
name|Renderer9
modifier|*
name|Renderer9
operator|::
name|makeRenderer9
parameter_list|(
name|Renderer
modifier|*
name|renderer
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|HAS_DYNAMIC_TYPE
argument_list|(
name|rx
operator|::
name|Renderer9
operator|*
argument_list|,
name|renderer
argument_list|)
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|rx
operator|::
name|Renderer9
operator|*
argument_list|>
argument_list|(
name|renderer
argument_list|)
return|;
block|}
DECL|function|initialize
name|EGLint
name|Renderer9
operator|::
name|initialize
parameter_list|()
block|{
if|if
condition|(
operator|!
name|initializeCompiler
argument_list|()
condition|)
block|{
return|return
name|EGL_NOT_INITIALIZED
return|;
block|}
if|if
condition|(
name|mSoftwareDevice
condition|)
block|{
name|mD3d9Module
operator|=
name|GetModuleHandle
argument_list|(
name|TEXT
argument_list|(
literal|"swiftshader_d3d9.dll"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mD3d9Module
operator|=
name|GetModuleHandle
argument_list|(
name|TEXT
argument_list|(
literal|"d3d9.dll"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mD3d9Module
operator|==
name|NULL
condition|)
block|{
name|ERR
argument_list|(
literal|"No D3D9 module found - aborting!\n"
argument_list|)
expr_stmt|;
return|return
name|EGL_NOT_INITIALIZED
return|;
block|}
typedef|typedef
name|HRESULT
function_decl|(
name|WINAPI
modifier|*
name|Direct3DCreate9ExFunc
function_decl|)
parameter_list|(
name|UINT
parameter_list|,
name|IDirect3D9Ex
modifier|*
modifier|*
parameter_list|)
function_decl|;
name|Direct3DCreate9ExFunc
name|Direct3DCreate9ExPtr
init|=
cast|reinterpret_cast
argument_list|<
name|Direct3DCreate9ExFunc
argument_list|>
argument_list|(
name|GetProcAddress
argument_list|(
name|mD3d9Module
argument_list|,
literal|"Direct3DCreate9Ex"
argument_list|)
argument_list|)
decl_stmt|;
comment|// Use Direct3D9Ex if available. Among other things, this version is less
comment|// inclined to report a lost context, for example when the user switches
comment|// desktop. Direct3D9Ex is available in Windows Vista and later if suitable drivers are available.
if|if
condition|(
name|ANGLE_ENABLE_D3D9EX
operator|&&
name|Direct3DCreate9ExPtr
operator|&&
name|SUCCEEDED
argument_list|(
name|Direct3DCreate9ExPtr
argument_list|(
name|D3D_SDK_VERSION
argument_list|,
operator|&
name|mD3d9Ex
argument_list|)
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|mD3d9Ex
argument_list|)
expr_stmt|;
name|mD3d9Ex
operator|->
name|QueryInterface
argument_list|(
name|IID_IDirect3D9
argument_list|,
cast|reinterpret_cast
argument_list|<
name|void
operator|*
operator|*
argument_list|>
argument_list|(
operator|&
name|mD3d9
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mD3d9
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mD3d9
operator|=
name|Direct3DCreate9
argument_list|(
name|D3D_SDK_VERSION
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mD3d9
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not create D3D9 device - aborting!\n"
argument_list|)
expr_stmt|;
return|return
name|EGL_NOT_INITIALIZED
return|;
block|}
if|if
condition|(
name|mDc
operator|!=
name|NULL
condition|)
block|{
comment|//  UNIMPLEMENTED();   // FIXME: Determine which adapter index the device context corresponds to
block|}
name|HRESULT
name|result
decl_stmt|;
comment|// Give up on getting device caps after about one second.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
operator|++
name|i
control|)
block|{
name|result
operator|=
name|mD3d9
operator|->
name|GetDeviceCaps
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
operator|&
name|mDeviceCaps
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|D3DERR_NOTAVAILABLE
condition|)
block|{
name|Sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|// Give the driver some time to initialize/recover
block|}
elseif|else
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
comment|// D3DERR_OUTOFVIDEOMEMORY, E_OUTOFMEMORY, D3DERR_INVALIDDEVICE, or another error we can't recover from
block|{
name|ERR
argument_list|(
literal|"failed to get device caps (0x%x)\n"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|EGL_NOT_INITIALIZED
return|;
block|}
block|}
if|if
condition|(
name|mDeviceCaps
operator|.
name|PixelShaderVersion
operator|<
name|D3DPS_VERSION
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Renderer does not support PS 2.0. aborting!\n"
argument_list|)
expr_stmt|;
return|return
name|EGL_NOT_INITIALIZED
return|;
block|}
comment|// When DirectX9 is running with an older DirectX8 driver, a StretchRect from a regular texture to a render target texture is not supported.
comment|// This is required by Texture2D::convertToRenderTarget.
if|if
condition|(
operator|(
name|mDeviceCaps
operator|.
name|DevCaps2
operator|&
name|D3DDEVCAPS2_CAN_STRETCHRECT_FROM_TEXTURES
operator|)
operator|==
literal|0
condition|)
block|{
name|ERR
argument_list|(
literal|"Renderer does not support stretctrect from textures!\n"
argument_list|)
expr_stmt|;
return|return
name|EGL_NOT_INITIALIZED
return|;
block|}
name|mD3d9
operator|->
name|GetAdapterIdentifier
argument_list|(
name|mAdapter
argument_list|,
literal|0
argument_list|,
operator|&
name|mAdapterIdentifier
argument_list|)
expr_stmt|;
comment|// ATI cards on XP have problems with non-power-of-two textures.
name|mSupportsNonPower2Textures
operator|=
operator|!
operator|(
name|mDeviceCaps
operator|.
name|TextureCaps
operator|&
name|D3DPTEXTURECAPS_POW2
operator|)
operator|&&
operator|!
operator|(
name|mDeviceCaps
operator|.
name|TextureCaps
operator|&
name|D3DPTEXTURECAPS_CUBEMAP_POW2
operator|)
operator|&&
operator|!
operator|(
name|mDeviceCaps
operator|.
name|TextureCaps
operator|&
name|D3DPTEXTURECAPS_NONPOW2CONDITIONAL
operator|)
operator|&&
operator|!
operator|(
name|getComparableOSVersion
argument_list|()
operator|<
name|versionWindowsVista
operator|&&
name|mAdapterIdentifier
operator|.
name|VendorId
operator|==
name|VENDOR_ID_AMD
operator|)
expr_stmt|;
comment|// Must support a minimum of 2:1 anisotropy for max anisotropy to be considered supported, per the spec
name|mSupportsTextureFilterAnisotropy
operator|=
operator|(
operator|(
name|mDeviceCaps
operator|.
name|RasterCaps
operator|&
name|D3DPRASTERCAPS_ANISOTROPY
operator|)
operator|&&
operator|(
name|mDeviceCaps
operator|.
name|MaxAnisotropy
operator|>=
literal|2
operator|)
operator|)
expr_stmt|;
name|mMinSwapInterval
operator|=
literal|4
expr_stmt|;
name|mMaxSwapInterval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mDeviceCaps
operator|.
name|PresentationIntervals
operator|&
name|D3DPRESENT_INTERVAL_IMMEDIATE
condition|)
block|{
name|mMinSwapInterval
operator|=
name|std
operator|::
name|min
argument_list|(
name|mMinSwapInterval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mMaxSwapInterval
operator|=
name|std
operator|::
name|max
argument_list|(
name|mMaxSwapInterval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mDeviceCaps
operator|.
name|PresentationIntervals
operator|&
name|D3DPRESENT_INTERVAL_ONE
condition|)
block|{
name|mMinSwapInterval
operator|=
name|std
operator|::
name|min
argument_list|(
name|mMinSwapInterval
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mMaxSwapInterval
operator|=
name|std
operator|::
name|max
argument_list|(
name|mMaxSwapInterval
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mDeviceCaps
operator|.
name|PresentationIntervals
operator|&
name|D3DPRESENT_INTERVAL_TWO
condition|)
block|{
name|mMinSwapInterval
operator|=
name|std
operator|::
name|min
argument_list|(
name|mMinSwapInterval
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|mMaxSwapInterval
operator|=
name|std
operator|::
name|max
argument_list|(
name|mMaxSwapInterval
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mDeviceCaps
operator|.
name|PresentationIntervals
operator|&
name|D3DPRESENT_INTERVAL_THREE
condition|)
block|{
name|mMinSwapInterval
operator|=
name|std
operator|::
name|min
argument_list|(
name|mMinSwapInterval
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|mMaxSwapInterval
operator|=
name|std
operator|::
name|max
argument_list|(
name|mMaxSwapInterval
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mDeviceCaps
operator|.
name|PresentationIntervals
operator|&
name|D3DPRESENT_INTERVAL_FOUR
condition|)
block|{
name|mMinSwapInterval
operator|=
name|std
operator|::
name|min
argument_list|(
name|mMinSwapInterval
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|mMaxSwapInterval
operator|=
name|std
operator|::
name|max
argument_list|(
name|mMaxSwapInterval
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|int
name|max
init|=
literal|0
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ArraySize
argument_list|(
name|RenderTargetFormats
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|bool
modifier|*
name|multisampleArray
init|=
operator|new
name|bool
index|[
name|D3DMULTISAMPLE_16_SAMPLES
operator|+
literal|1
index|]
decl_stmt|;
name|getMultiSampleSupport
argument_list|(
name|RenderTargetFormats
index|[
name|i
index|]
argument_list|,
name|multisampleArray
argument_list|)
expr_stmt|;
name|mMultiSampleSupport
index|[
name|RenderTargetFormats
index|[
name|i
index|]
index|]
operator|=
name|multisampleArray
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
name|D3DMULTISAMPLE_16_SAMPLES
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
block|{
if|if
condition|(
name|multisampleArray
index|[
name|j
index|]
operator|&&
name|j
operator|!=
name|D3DMULTISAMPLE_NONMASKABLE
operator|&&
name|j
operator|>
name|max
condition|)
block|{
name|max
operator|=
name|j
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ArraySize
argument_list|(
name|DepthStencilFormats
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|DepthStencilFormats
index|[
name|i
index|]
operator|==
name|D3DFMT_UNKNOWN
condition|)
continue|continue;
name|bool
modifier|*
name|multisampleArray
init|=
operator|new
name|bool
index|[
name|D3DMULTISAMPLE_16_SAMPLES
operator|+
literal|1
index|]
decl_stmt|;
name|getMultiSampleSupport
argument_list|(
name|DepthStencilFormats
index|[
name|i
index|]
argument_list|,
name|multisampleArray
argument_list|)
expr_stmt|;
name|mMultiSampleSupport
index|[
name|DepthStencilFormats
index|[
name|i
index|]
index|]
operator|=
name|multisampleArray
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
name|D3DMULTISAMPLE_16_SAMPLES
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
block|{
if|if
condition|(
name|multisampleArray
index|[
name|j
index|]
operator|&&
name|j
operator|!=
name|D3DMULTISAMPLE_NONMASKABLE
operator|&&
name|j
operator|>
name|max
condition|)
block|{
name|max
operator|=
name|j
expr_stmt|;
block|}
block|}
block|}
name|mMaxSupportedSamples
operator|=
name|max
expr_stmt|;
specifier|static
specifier|const
name|TCHAR
name|windowName
index|[]
init|=
name|TEXT
argument_list|(
literal|"AngleHiddenWindow"
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|TCHAR
name|className
index|[]
init|=
name|TEXT
argument_list|(
literal|"STATIC"
argument_list|)
decl_stmt|;
name|mDeviceWindow
operator|=
name|CreateWindowEx
argument_list|(
name|WS_EX_NOACTIVATE
argument_list|,
name|className
argument_list|,
name|windowName
argument_list|,
name|WS_DISABLED
operator||
name|WS_POPUP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|HWND_MESSAGE
argument_list|,
name|NULL
argument_list|,
name|GetModuleHandle
argument_list|(
name|NULL
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|D3DPRESENT_PARAMETERS
name|presentParameters
init|=
name|getDefaultPresentParameters
argument_list|()
decl_stmt|;
name|DWORD
name|behaviorFlags
init|=
name|D3DCREATE_FPU_PRESERVE
operator||
name|D3DCREATE_NOWINDOWCHANGES
decl_stmt|;
name|result
operator|=
name|mD3d9
operator|->
name|CreateDevice
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|mDeviceWindow
argument_list|,
name|behaviorFlags
operator||
name|D3DCREATE_HARDWARE_VERTEXPROCESSING
operator||
name|D3DCREATE_PUREDEVICE
argument_list|,
operator|&
name|presentParameters
argument_list|,
operator|&
name|mDevice
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|D3DERR_OUTOFVIDEOMEMORY
operator|||
name|result
operator|==
name|E_OUTOFMEMORY
operator|||
name|result
operator|==
name|D3DERR_DEVICELOST
condition|)
block|{
return|return
name|EGL_BAD_ALLOC
return|;
block|}
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|result
operator|=
name|mD3d9
operator|->
name|CreateDevice
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|mDeviceWindow
argument_list|,
name|behaviorFlags
operator||
name|D3DCREATE_SOFTWARE_VERTEXPROCESSING
argument_list|,
operator|&
name|presentParameters
argument_list|,
operator|&
name|mDevice
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|result
operator|==
name|D3DERR_OUTOFVIDEOMEMORY
operator|||
name|result
operator|==
name|E_OUTOFMEMORY
operator|||
name|result
operator|==
name|D3DERR_NOTAVAILABLE
operator|||
name|result
operator|==
name|D3DERR_DEVICELOST
argument_list|)
expr_stmt|;
return|return
name|EGL_BAD_ALLOC
return|;
block|}
block|}
if|if
condition|(
name|mD3d9Ex
condition|)
block|{
name|result
operator|=
name|mDevice
operator|->
name|QueryInterface
argument_list|(
name|IID_IDirect3DDevice9Ex
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|mDeviceEx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mVertexShaderCache
operator|.
name|initialize
argument_list|(
name|mDevice
argument_list|)
expr_stmt|;
name|mPixelShaderCache
operator|.
name|initialize
argument_list|(
name|mDevice
argument_list|)
expr_stmt|;
comment|// Check occlusion query support
name|IDirect3DQuery9
modifier|*
name|occlusionQuery
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|mDevice
operator|->
name|CreateQuery
argument_list|(
name|D3DQUERYTYPE_OCCLUSION
argument_list|,
operator|&
name|occlusionQuery
argument_list|)
argument_list|)
operator|&&
name|occlusionQuery
condition|)
block|{
name|occlusionQuery
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mOcclusionQuerySupport
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|mOcclusionQuerySupport
operator|=
literal|false
expr_stmt|;
block|}
comment|// Check event query support
name|IDirect3DQuery9
modifier|*
name|eventQuery
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|mDevice
operator|->
name|CreateQuery
argument_list|(
name|D3DQUERYTYPE_EVENT
argument_list|,
operator|&
name|eventQuery
argument_list|)
argument_list|)
operator|&&
name|eventQuery
condition|)
block|{
name|eventQuery
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mEventQuerySupport
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|mEventQuerySupport
operator|=
literal|false
expr_stmt|;
block|}
name|D3DDISPLAYMODE
name|currentDisplayMode
decl_stmt|;
name|mD3d9
operator|->
name|GetAdapterDisplayMode
argument_list|(
name|mAdapter
argument_list|,
operator|&
name|currentDisplayMode
argument_list|)
expr_stmt|;
comment|// Check vertex texture support
comment|// Only Direct3D 10 ready devices support all the necessary vertex texture formats.
comment|// We test this using D3D9 by checking support for the R16F format.
name|mVertexTextureSupport
operator|=
name|mDeviceCaps
operator|.
name|PixelShaderVersion
operator|>=
name|D3DPS_VERSION
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
operator|&&
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
name|D3DUSAGE_QUERY_VERTEXTEXTURE
argument_list|,
name|D3DRTYPE_TEXTURE
argument_list|,
name|D3DFMT_R16F
argument_list|)
argument_list|)
expr_stmt|;
comment|// Check depth texture support
comment|// we use INTZ for depth textures in Direct3D9
comment|// we also want NULL texture support to ensure the we can make depth-only FBOs
comment|// see http://aras-p.info/texts/D3D9GPUHacks.html
name|mDepthTextureSupport
operator|=
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
name|D3DUSAGE_DEPTHSTENCIL
argument_list|,
name|D3DRTYPE_TEXTURE
argument_list|,
name|D3DFMT_INTZ
argument_list|)
argument_list|)
operator|&&
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
name|D3DUSAGE_RENDERTARGET
argument_list|,
name|D3DRTYPE_SURFACE
argument_list|,
name|D3DFMT_NULL
argument_list|)
argument_list|)
expr_stmt|;
comment|// Check 32 bit floating point texture support
name|mFloat32FilterSupport
operator|=
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
name|D3DUSAGE_QUERY_FILTER
argument_list|,
name|D3DRTYPE_TEXTURE
argument_list|,
name|D3DFMT_A32B32G32R32F
argument_list|)
argument_list|)
operator|&&
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
name|D3DUSAGE_QUERY_FILTER
argument_list|,
name|D3DRTYPE_CUBETEXTURE
argument_list|,
name|D3DFMT_A32B32G32R32F
argument_list|)
argument_list|)
expr_stmt|;
name|mFloat32RenderSupport
operator|=
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
name|D3DUSAGE_RENDERTARGET
argument_list|,
name|D3DRTYPE_TEXTURE
argument_list|,
name|D3DFMT_A32B32G32R32F
argument_list|)
argument_list|)
operator|&&
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
name|D3DUSAGE_RENDERTARGET
argument_list|,
name|D3DRTYPE_CUBETEXTURE
argument_list|,
name|D3DFMT_A32B32G32R32F
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mFloat32FilterSupport
operator|&&
operator|!
name|mFloat32RenderSupport
condition|)
block|{
name|mFloat32TextureSupport
operator|=
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
literal|0
argument_list|,
name|D3DRTYPE_TEXTURE
argument_list|,
name|D3DFMT_A32B32G32R32F
argument_list|)
argument_list|)
operator|&&
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
literal|0
argument_list|,
name|D3DRTYPE_CUBETEXTURE
argument_list|,
name|D3DFMT_A32B32G32R32F
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mFloat32TextureSupport
operator|=
literal|true
expr_stmt|;
block|}
comment|// Check 16 bit floating point texture support
name|mFloat16FilterSupport
operator|=
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
name|D3DUSAGE_QUERY_FILTER
argument_list|,
name|D3DRTYPE_TEXTURE
argument_list|,
name|D3DFMT_A16B16G16R16F
argument_list|)
argument_list|)
operator|&&
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
name|D3DUSAGE_QUERY_FILTER
argument_list|,
name|D3DRTYPE_CUBETEXTURE
argument_list|,
name|D3DFMT_A16B16G16R16F
argument_list|)
argument_list|)
expr_stmt|;
name|mFloat16RenderSupport
operator|=
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
name|D3DUSAGE_RENDERTARGET
argument_list|,
name|D3DRTYPE_TEXTURE
argument_list|,
name|D3DFMT_A16B16G16R16F
argument_list|)
argument_list|)
operator|&&
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
name|D3DUSAGE_RENDERTARGET
argument_list|,
name|D3DRTYPE_CUBETEXTURE
argument_list|,
name|D3DFMT_A16B16G16R16F
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mFloat16FilterSupport
operator|&&
operator|!
name|mFloat16RenderSupport
condition|)
block|{
name|mFloat16TextureSupport
operator|=
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
literal|0
argument_list|,
name|D3DRTYPE_TEXTURE
argument_list|,
name|D3DFMT_A16B16G16R16F
argument_list|)
argument_list|)
operator|&&
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
literal|0
argument_list|,
name|D3DRTYPE_CUBETEXTURE
argument_list|,
name|D3DFMT_A16B16G16R16F
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mFloat16TextureSupport
operator|=
literal|true
expr_stmt|;
block|}
comment|// Check DXT texture support
name|mDXT1TextureSupport
operator|=
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
literal|0
argument_list|,
name|D3DRTYPE_TEXTURE
argument_list|,
name|D3DFMT_DXT1
argument_list|)
argument_list|)
expr_stmt|;
name|mDXT3TextureSupport
operator|=
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
literal|0
argument_list|,
name|D3DRTYPE_TEXTURE
argument_list|,
name|D3DFMT_DXT3
argument_list|)
argument_list|)
expr_stmt|;
name|mDXT5TextureSupport
operator|=
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
literal|0
argument_list|,
name|D3DRTYPE_TEXTURE
argument_list|,
name|D3DFMT_DXT5
argument_list|)
argument_list|)
expr_stmt|;
comment|// Check luminance[alpha] texture support
name|mLuminanceTextureSupport
operator|=
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
literal|0
argument_list|,
name|D3DRTYPE_TEXTURE
argument_list|,
name|D3DFMT_L8
argument_list|)
argument_list|)
expr_stmt|;
name|mLuminanceAlphaTextureSupport
operator|=
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
literal|0
argument_list|,
name|D3DRTYPE_TEXTURE
argument_list|,
name|D3DFMT_A8L8
argument_list|)
argument_list|)
expr_stmt|;
name|initializeDevice
argument_list|()
expr_stmt|;
return|return
name|EGL_SUCCESS
return|;
block|}
comment|// do any one-time device initialization
comment|// NOTE: this is also needed after a device lost/reset
comment|// to reset the scene status and ensure the default states are reset.
DECL|function|initializeDevice
name|void
name|Renderer9
operator|::
name|initializeDevice
parameter_list|()
block|{
comment|// Permanent non-default states
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_POINTSPRITEENABLE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_LASTPIXEL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mDeviceCaps
operator|.
name|PixelShaderVersion
operator|>=
name|D3DPS_VERSION
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_POINTSIZE_MAX
argument_list|,
operator|(
name|DWORD
operator|&
operator|)
name|mDeviceCaps
operator|.
name|MaxPointSize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_POINTSIZE_MAX
argument_list|,
literal|0x3F800000
argument_list|)
expr_stmt|;
comment|// 1.0f
block|}
name|markAllStateDirty
argument_list|()
expr_stmt|;
name|mSceneStarted
operator|=
literal|false
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|mBlit
operator|&&
operator|!
name|mVertexDataManager
operator|&&
operator|!
name|mIndexDataManager
argument_list|)
expr_stmt|;
name|mBlit
operator|=
operator|new
name|Blit
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|mVertexDataManager
operator|=
operator|new
name|rx
operator|::
name|VertexDataManager
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|mIndexDataManager
operator|=
operator|new
name|rx
operator|::
name|IndexDataManager
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
DECL|function|getDefaultPresentParameters
name|D3DPRESENT_PARAMETERS
name|Renderer9
operator|::
name|getDefaultPresentParameters
parameter_list|()
block|{
name|D3DPRESENT_PARAMETERS
name|presentParameters
init|=
block|{
literal|0
block|}
decl_stmt|;
comment|// The default swap chain is never actually used. Surface will create a new swap chain with the proper parameters.
name|presentParameters
operator|.
name|AutoDepthStencilFormat
operator|=
name|D3DFMT_UNKNOWN
expr_stmt|;
name|presentParameters
operator|.
name|BackBufferCount
operator|=
literal|1
expr_stmt|;
name|presentParameters
operator|.
name|BackBufferFormat
operator|=
name|D3DFMT_UNKNOWN
expr_stmt|;
name|presentParameters
operator|.
name|BackBufferWidth
operator|=
literal|1
expr_stmt|;
name|presentParameters
operator|.
name|BackBufferHeight
operator|=
literal|1
expr_stmt|;
name|presentParameters
operator|.
name|EnableAutoDepthStencil
operator|=
name|FALSE
expr_stmt|;
name|presentParameters
operator|.
name|Flags
operator|=
literal|0
expr_stmt|;
name|presentParameters
operator|.
name|hDeviceWindow
operator|=
name|mDeviceWindow
expr_stmt|;
name|presentParameters
operator|.
name|MultiSampleQuality
operator|=
literal|0
expr_stmt|;
name|presentParameters
operator|.
name|MultiSampleType
operator|=
name|D3DMULTISAMPLE_NONE
expr_stmt|;
name|presentParameters
operator|.
name|PresentationInterval
operator|=
name|D3DPRESENT_INTERVAL_DEFAULT
expr_stmt|;
name|presentParameters
operator|.
name|SwapEffect
operator|=
name|D3DSWAPEFFECT_DISCARD
expr_stmt|;
name|presentParameters
operator|.
name|Windowed
operator|=
name|TRUE
expr_stmt|;
return|return
name|presentParameters
return|;
block|}
DECL|function|generateConfigs
name|int
name|Renderer9
operator|::
name|generateConfigs
parameter_list|(
name|ConfigDesc
modifier|*
modifier|*
name|configDescList
parameter_list|)
block|{
name|D3DDISPLAYMODE
name|currentDisplayMode
decl_stmt|;
name|mD3d9
operator|->
name|GetAdapterDisplayMode
argument_list|(
name|mAdapter
argument_list|,
operator|&
name|currentDisplayMode
argument_list|)
expr_stmt|;
name|unsigned
name|int
name|numRenderFormats
init|=
name|ArraySize
argument_list|(
name|RenderTargetFormats
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|numDepthFormats
init|=
name|ArraySize
argument_list|(
name|DepthStencilFormats
argument_list|)
decl_stmt|;
operator|(
operator|*
name|configDescList
operator|)
operator|=
operator|new
name|ConfigDesc
index|[
name|numRenderFormats
operator|*
name|numDepthFormats
index|]
expr_stmt|;
name|int
name|numConfigs
init|=
literal|0
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|formatIndex
init|=
literal|0
init|;
name|formatIndex
operator|<
name|numRenderFormats
condition|;
name|formatIndex
operator|++
control|)
block|{
name|D3DFORMAT
name|renderTargetFormat
init|=
name|RenderTargetFormats
index|[
name|formatIndex
index|]
decl_stmt|;
name|HRESULT
name|result
init|=
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
name|D3DUSAGE_RENDERTARGET
argument_list|,
name|D3DRTYPE_SURFACE
argument_list|,
name|renderTargetFormat
argument_list|)
decl_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|depthStencilIndex
init|=
literal|0
init|;
name|depthStencilIndex
operator|<
name|numDepthFormats
condition|;
name|depthStencilIndex
operator|++
control|)
block|{
name|D3DFORMAT
name|depthStencilFormat
init|=
name|DepthStencilFormats
index|[
name|depthStencilIndex
index|]
decl_stmt|;
name|HRESULT
name|result
init|=
name|D3D_OK
decl_stmt|;
if|if
condition|(
name|depthStencilFormat
operator|!=
name|D3DFMT_UNKNOWN
condition|)
block|{
name|result
operator|=
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
name|D3DUSAGE_DEPTHSTENCIL
argument_list|,
name|D3DRTYPE_SURFACE
argument_list|,
name|depthStencilFormat
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
condition|)
block|{
if|if
condition|(
name|depthStencilFormat
operator|!=
name|D3DFMT_UNKNOWN
condition|)
block|{
name|result
operator|=
name|mD3d9
operator|->
name|CheckDepthStencilMatch
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
name|renderTargetFormat
argument_list|,
name|depthStencilFormat
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ConfigDesc
name|newConfig
decl_stmt|;
name|newConfig
operator|.
name|renderTargetFormat
operator|=
name|d3d9_gl
operator|::
name|ConvertBackBufferFormat
argument_list|(
name|renderTargetFormat
argument_list|)
expr_stmt|;
name|newConfig
operator|.
name|depthStencilFormat
operator|=
name|d3d9_gl
operator|::
name|ConvertDepthStencilFormat
argument_list|(
name|depthStencilFormat
argument_list|)
expr_stmt|;
name|newConfig
operator|.
name|multiSample
operator|=
literal|0
expr_stmt|;
comment|// FIXME: enumerate multi-sampling
name|newConfig
operator|.
name|fastConfig
operator|=
operator|(
name|currentDisplayMode
operator|.
name|Format
operator|==
name|renderTargetFormat
operator|)
expr_stmt|;
operator|(
operator|*
name|configDescList
operator|)
index|[
name|numConfigs
operator|++
index|]
operator|=
name|newConfig
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|numConfigs
return|;
block|}
DECL|function|deleteConfigs
name|void
name|Renderer9
operator|::
name|deleteConfigs
parameter_list|(
name|ConfigDesc
modifier|*
name|configDescList
parameter_list|)
block|{
operator|delete
index|[]
operator|(
name|configDescList
operator|)
expr_stmt|;
block|}
DECL|function|startScene
name|void
name|Renderer9
operator|::
name|startScene
parameter_list|()
block|{
if|if
condition|(
operator|!
name|mSceneStarted
condition|)
block|{
name|long
name|result
init|=
name|mDevice
operator|->
name|BeginScene
argument_list|()
decl_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
condition|)
block|{
comment|// This is defensive checking against the device being
comment|// lost at unexpected times.
name|mSceneStarted
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
DECL|function|endScene
name|void
name|Renderer9
operator|::
name|endScene
parameter_list|()
block|{
if|if
condition|(
name|mSceneStarted
condition|)
block|{
comment|// EndScene can fail if the device was lost, for example due
comment|// to a TDR during a draw call.
name|mDevice
operator|->
name|EndScene
argument_list|()
expr_stmt|;
name|mSceneStarted
operator|=
literal|false
expr_stmt|;
block|}
block|}
DECL|function|sync
name|void
name|Renderer9
operator|::
name|sync
parameter_list|(
name|bool
name|block
parameter_list|)
block|{
name|HRESULT
name|result
decl_stmt|;
name|IDirect3DQuery9
modifier|*
name|query
init|=
name|allocateEventQuery
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|query
condition|)
block|{
return|return;
block|}
name|result
operator|=
name|query
operator|->
name|Issue
argument_list|(
name|D3DISSUE_END
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|result
operator|=
name|query
operator|->
name|GetData
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|D3DGETDATA_FLUSH
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|&&
name|result
operator|==
name|S_FALSE
condition|)
block|{
comment|// Keep polling, but allow other threads to do something useful first
name|Sleep
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// explicitly check for device loss
comment|// some drivers seem to return S_FALSE even if the device is lost
comment|// instead of D3DERR_DEVICELOST like they should
if|if
condition|(
name|testDeviceLost
argument_list|(
literal|false
argument_list|)
condition|)
block|{
name|result
operator|=
name|D3DERR_DEVICELOST
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|block
operator|&&
name|result
operator|==
name|S_FALSE
condition|)
do|;
name|freeEventQuery
argument_list|(
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
name|d3d9
operator|::
name|isDeviceLostError
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|notifyDeviceLost
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|createSwapChain
name|SwapChain
modifier|*
name|Renderer9
operator|::
name|createSwapChain
parameter_list|(
name|HWND
name|window
parameter_list|,
name|HANDLE
name|shareHandle
parameter_list|,
name|GLenum
name|backBufferFormat
parameter_list|,
name|GLenum
name|depthBufferFormat
parameter_list|)
block|{
return|return
operator|new
name|rx
operator|::
name|SwapChain9
argument_list|(
name|this
argument_list|,
name|window
argument_list|,
name|shareHandle
argument_list|,
name|backBufferFormat
argument_list|,
name|depthBufferFormat
argument_list|)
return|;
block|}
DECL|function|allocateEventQuery
name|IDirect3DQuery9
modifier|*
name|Renderer9
operator|::
name|allocateEventQuery
parameter_list|()
block|{
name|IDirect3DQuery9
modifier|*
name|query
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|mEventQueryPool
operator|.
name|empty
argument_list|()
condition|)
block|{
name|HRESULT
name|result
init|=
name|mDevice
operator|->
name|CreateQuery
argument_list|(
name|D3DQUERYTYPE_EVENT
argument_list|,
operator|&
name|query
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|query
operator|=
name|mEventQueryPool
operator|.
name|back
argument_list|()
expr_stmt|;
name|mEventQueryPool
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
return|return
name|query
return|;
block|}
DECL|function|freeEventQuery
name|void
name|Renderer9
operator|::
name|freeEventQuery
parameter_list|(
name|IDirect3DQuery9
modifier|*
name|query
parameter_list|)
block|{
if|if
condition|(
name|mEventQueryPool
operator|.
name|size
argument_list|()
operator|>
literal|1000
condition|)
block|{
name|query
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|mEventQueryPool
operator|.
name|push_back
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|createVertexShader
name|IDirect3DVertexShader9
modifier|*
name|Renderer9
operator|::
name|createVertexShader
parameter_list|(
specifier|const
name|DWORD
modifier|*
name|function
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
return|return
name|mVertexShaderCache
operator|.
name|create
argument_list|(
name|function
argument_list|,
name|length
argument_list|)
return|;
block|}
DECL|function|createPixelShader
name|IDirect3DPixelShader9
modifier|*
name|Renderer9
operator|::
name|createPixelShader
parameter_list|(
specifier|const
name|DWORD
modifier|*
name|function
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
return|return
name|mPixelShaderCache
operator|.
name|create
argument_list|(
name|function
argument_list|,
name|length
argument_list|)
return|;
block|}
DECL|function|createVertexBuffer
name|HRESULT
name|Renderer9
operator|::
name|createVertexBuffer
parameter_list|(
name|UINT
name|Length
parameter_list|,
name|DWORD
name|Usage
parameter_list|,
name|IDirect3DVertexBuffer9
modifier|*
modifier|*
name|ppVertexBuffer
parameter_list|)
block|{
name|D3DPOOL
name|Pool
init|=
name|getBufferPool
argument_list|(
name|Usage
argument_list|)
decl_stmt|;
return|return
name|mDevice
operator|->
name|CreateVertexBuffer
argument_list|(
name|Length
argument_list|,
name|Usage
argument_list|,
literal|0
argument_list|,
name|Pool
argument_list|,
name|ppVertexBuffer
argument_list|,
name|NULL
argument_list|)
return|;
block|}
DECL|function|createVertexBuffer
name|VertexBuffer
modifier|*
name|Renderer9
operator|::
name|createVertexBuffer
parameter_list|()
block|{
return|return
operator|new
name|VertexBuffer9
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|function|createIndexBuffer
name|HRESULT
name|Renderer9
operator|::
name|createIndexBuffer
parameter_list|(
name|UINT
name|Length
parameter_list|,
name|DWORD
name|Usage
parameter_list|,
name|D3DFORMAT
name|Format
parameter_list|,
name|IDirect3DIndexBuffer9
modifier|*
modifier|*
name|ppIndexBuffer
parameter_list|)
block|{
name|D3DPOOL
name|Pool
init|=
name|getBufferPool
argument_list|(
name|Usage
argument_list|)
decl_stmt|;
return|return
name|mDevice
operator|->
name|CreateIndexBuffer
argument_list|(
name|Length
argument_list|,
name|Usage
argument_list|,
name|Format
argument_list|,
name|Pool
argument_list|,
name|ppIndexBuffer
argument_list|,
name|NULL
argument_list|)
return|;
block|}
DECL|function|createIndexBuffer
name|IndexBuffer
modifier|*
name|Renderer9
operator|::
name|createIndexBuffer
parameter_list|()
block|{
return|return
operator|new
name|IndexBuffer9
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|function|createBufferStorage
name|BufferStorage
modifier|*
name|Renderer9
operator|::
name|createBufferStorage
parameter_list|()
block|{
return|return
operator|new
name|BufferStorage9
argument_list|()
return|;
block|}
DECL|function|createQuery
name|QueryImpl
modifier|*
name|Renderer9
operator|::
name|createQuery
parameter_list|(
name|GLenum
name|type
parameter_list|)
block|{
return|return
operator|new
name|Query9
argument_list|(
name|this
argument_list|,
name|type
argument_list|)
return|;
block|}
DECL|function|createFence
name|FenceImpl
modifier|*
name|Renderer9
operator|::
name|createFence
parameter_list|()
block|{
return|return
operator|new
name|Fence9
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|function|setSamplerState
name|void
name|Renderer9
operator|::
name|setSamplerState
parameter_list|(
name|gl
operator|::
name|SamplerType
name|type
parameter_list|,
name|int
name|index
parameter_list|,
specifier|const
name|gl
operator|::
name|SamplerState
modifier|&
name|samplerState
parameter_list|)
block|{
name|bool
modifier|*
name|forceSetSamplers
init|=
operator|(
name|type
operator|==
name|gl
operator|::
name|SAMPLER_PIXEL
operator|)
condition|?
name|mForceSetPixelSamplerStates
else|:
name|mForceSetVertexSamplerStates
decl_stmt|;
name|gl
operator|::
name|SamplerState
modifier|*
name|appliedSamplers
init|=
operator|(
name|type
operator|==
name|gl
operator|::
name|SAMPLER_PIXEL
operator|)
condition|?
name|mCurPixelSamplerStates
else|:
name|mCurVertexSamplerStates
decl_stmt|;
if|if
condition|(
name|forceSetSamplers
index|[
name|index
index|]
operator|||
name|memcmp
argument_list|(
operator|&
name|samplerState
argument_list|,
operator|&
name|appliedSamplers
index|[
name|index
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|gl
operator|::
name|SamplerState
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|d3dSamplerOffset
init|=
operator|(
name|type
operator|==
name|gl
operator|::
name|SAMPLER_PIXEL
operator|)
condition|?
literal|0
else|:
name|D3DVERTEXTEXTURESAMPLER0
decl_stmt|;
name|int
name|d3dSampler
init|=
name|index
operator|+
name|d3dSamplerOffset
decl_stmt|;
name|mDevice
operator|->
name|SetSamplerState
argument_list|(
name|d3dSampler
argument_list|,
name|D3DSAMP_ADDRESSU
argument_list|,
name|gl_d3d9
operator|::
name|ConvertTextureWrap
argument_list|(
name|samplerState
operator|.
name|wrapS
argument_list|)
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetSamplerState
argument_list|(
name|d3dSampler
argument_list|,
name|D3DSAMP_ADDRESSV
argument_list|,
name|gl_d3d9
operator|::
name|ConvertTextureWrap
argument_list|(
name|samplerState
operator|.
name|wrapT
argument_list|)
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetSamplerState
argument_list|(
name|d3dSampler
argument_list|,
name|D3DSAMP_MAGFILTER
argument_list|,
name|gl_d3d9
operator|::
name|ConvertMagFilter
argument_list|(
name|samplerState
operator|.
name|magFilter
argument_list|,
name|samplerState
operator|.
name|maxAnisotropy
argument_list|)
argument_list|)
expr_stmt|;
name|D3DTEXTUREFILTERTYPE
name|d3dMinFilter
decl_stmt|,
name|d3dMipFilter
decl_stmt|;
name|gl_d3d9
operator|::
name|ConvertMinFilter
argument_list|(
name|samplerState
operator|.
name|minFilter
argument_list|,
operator|&
name|d3dMinFilter
argument_list|,
operator|&
name|d3dMipFilter
argument_list|,
name|samplerState
operator|.
name|maxAnisotropy
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetSamplerState
argument_list|(
name|d3dSampler
argument_list|,
name|D3DSAMP_MINFILTER
argument_list|,
name|d3dMinFilter
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetSamplerState
argument_list|(
name|d3dSampler
argument_list|,
name|D3DSAMP_MIPFILTER
argument_list|,
name|d3dMipFilter
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetSamplerState
argument_list|(
name|d3dSampler
argument_list|,
name|D3DSAMP_MAXMIPLEVEL
argument_list|,
name|samplerState
operator|.
name|lodOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|mSupportsTextureFilterAnisotropy
condition|)
block|{
name|mDevice
operator|->
name|SetSamplerState
argument_list|(
name|d3dSampler
argument_list|,
name|D3DSAMP_MAXANISOTROPY
argument_list|,
operator|(
name|DWORD
operator|)
name|samplerState
operator|.
name|maxAnisotropy
argument_list|)
expr_stmt|;
block|}
block|}
name|forceSetSamplers
index|[
name|index
index|]
operator|=
literal|false
expr_stmt|;
name|appliedSamplers
index|[
name|index
index|]
operator|=
name|samplerState
expr_stmt|;
block|}
DECL|function|setTexture
name|void
name|Renderer9
operator|::
name|setTexture
parameter_list|(
name|gl
operator|::
name|SamplerType
name|type
parameter_list|,
name|int
name|index
parameter_list|,
name|gl
operator|::
name|Texture
modifier|*
name|texture
parameter_list|)
block|{
name|int
name|d3dSamplerOffset
init|=
operator|(
name|type
operator|==
name|gl
operator|::
name|SAMPLER_PIXEL
operator|)
condition|?
literal|0
else|:
name|D3DVERTEXTEXTURESAMPLER0
decl_stmt|;
name|int
name|d3dSampler
init|=
name|index
operator|+
name|d3dSamplerOffset
decl_stmt|;
name|IDirect3DBaseTexture9
modifier|*
name|d3dTexture
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|serial
init|=
literal|0
decl_stmt|;
name|bool
name|forceSetTexture
init|=
literal|false
decl_stmt|;
name|unsigned
name|int
modifier|*
name|appliedSerials
init|=
operator|(
name|type
operator|==
name|gl
operator|::
name|SAMPLER_PIXEL
operator|)
condition|?
name|mCurPixelTextureSerials
else|:
name|mCurVertexTextureSerials
decl_stmt|;
if|if
condition|(
name|texture
condition|)
block|{
name|TextureStorageInterface
modifier|*
name|texStorage
init|=
name|texture
operator|->
name|getNativeTexture
argument_list|()
decl_stmt|;
if|if
condition|(
name|texStorage
condition|)
block|{
name|TextureStorage9
modifier|*
name|storage9
init|=
name|TextureStorage9
operator|::
name|makeTextureStorage9
argument_list|(
name|texStorage
operator|->
name|getStorageInstance
argument_list|()
argument_list|)
decl_stmt|;
name|d3dTexture
operator|=
name|storage9
operator|->
name|getBaseTexture
argument_list|()
expr_stmt|;
block|}
comment|// If we get NULL back from getBaseTexture here, something went wrong
comment|// in the texture class and we're unexpectedly missing the d3d texture
name|ASSERT
argument_list|(
name|d3dTexture
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|serial
operator|=
name|texture
operator|->
name|getTextureSerial
argument_list|()
expr_stmt|;
name|forceSetTexture
operator|=
name|texture
operator|->
name|hasDirtyImages
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|forceSetTexture
operator|||
name|appliedSerials
index|[
name|index
index|]
operator|!=
name|serial
condition|)
block|{
name|mDevice
operator|->
name|SetTexture
argument_list|(
name|d3dSampler
argument_list|,
name|d3dTexture
argument_list|)
expr_stmt|;
block|}
name|appliedSerials
index|[
name|index
index|]
operator|=
name|serial
expr_stmt|;
block|}
DECL|function|setRasterizerState
name|void
name|Renderer9
operator|::
name|setRasterizerState
parameter_list|(
specifier|const
name|gl
operator|::
name|RasterizerState
modifier|&
name|rasterState
parameter_list|)
block|{
name|bool
name|rasterStateChanged
init|=
name|mForceSetRasterState
operator|||
name|memcmp
argument_list|(
operator|&
name|rasterState
argument_list|,
operator|&
name|mCurRasterState
argument_list|,
sizeof|sizeof
argument_list|(
name|gl
operator|::
name|RasterizerState
argument_list|)
argument_list|)
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
name|rasterStateChanged
condition|)
block|{
comment|// Set the cull mode
if|if
condition|(
name|rasterState
operator|.
name|cullFace
condition|)
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_CULLMODE
argument_list|,
name|gl_d3d9
operator|::
name|ConvertCullMode
argument_list|(
name|rasterState
operator|.
name|cullMode
argument_list|,
name|rasterState
operator|.
name|frontFace
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_CULLMODE
argument_list|,
name|D3DCULL_NONE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rasterState
operator|.
name|polygonOffsetFill
condition|)
block|{
if|if
condition|(
name|mCurDepthSize
operator|>
literal|0
condition|)
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_SLOPESCALEDEPTHBIAS
argument_list|,
operator|*
operator|(
name|DWORD
operator|*
operator|)
operator|&
name|rasterState
operator|.
name|polygonOffsetFactor
argument_list|)
expr_stmt|;
name|float
name|depthBias
init|=
name|ldexp
argument_list|(
name|rasterState
operator|.
name|polygonOffsetUnits
argument_list|,
operator|-
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|mCurDepthSize
argument_list|)
argument_list|)
decl_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_DEPTHBIAS
argument_list|,
operator|*
operator|(
name|DWORD
operator|*
operator|)
operator|&
name|depthBias
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_SLOPESCALEDEPTHBIAS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_DEPTHBIAS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mCurRasterState
operator|=
name|rasterState
expr_stmt|;
block|}
name|mForceSetRasterState
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|setBlendState
name|void
name|Renderer9
operator|::
name|setBlendState
parameter_list|(
specifier|const
name|gl
operator|::
name|BlendState
modifier|&
name|blendState
parameter_list|,
specifier|const
name|gl
operator|::
name|Color
modifier|&
name|blendColor
parameter_list|,
name|unsigned
name|int
name|sampleMask
parameter_list|)
block|{
name|bool
name|blendStateChanged
init|=
name|mForceSetBlendState
operator|||
name|memcmp
argument_list|(
operator|&
name|blendState
argument_list|,
operator|&
name|mCurBlendState
argument_list|,
sizeof|sizeof
argument_list|(
name|gl
operator|::
name|BlendState
argument_list|)
argument_list|)
operator|!=
literal|0
decl_stmt|;
name|bool
name|blendColorChanged
init|=
name|mForceSetBlendState
operator|||
name|memcmp
argument_list|(
operator|&
name|blendColor
argument_list|,
operator|&
name|mCurBlendColor
argument_list|,
sizeof|sizeof
argument_list|(
name|gl
operator|::
name|Color
argument_list|)
argument_list|)
operator|!=
literal|0
decl_stmt|;
name|bool
name|sampleMaskChanged
init|=
name|mForceSetBlendState
operator|||
name|sampleMask
operator|!=
name|mCurSampleMask
decl_stmt|;
if|if
condition|(
name|blendStateChanged
operator|||
name|blendColorChanged
condition|)
block|{
if|if
condition|(
name|blendState
operator|.
name|blend
condition|)
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ALPHABLENDENABLE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|blendState
operator|.
name|sourceBlendRGB
operator|!=
name|GL_CONSTANT_ALPHA
operator|&&
name|blendState
operator|.
name|sourceBlendRGB
operator|!=
name|GL_ONE_MINUS_CONSTANT_ALPHA
operator|&&
name|blendState
operator|.
name|destBlendRGB
operator|!=
name|GL_CONSTANT_ALPHA
operator|&&
name|blendState
operator|.
name|destBlendRGB
operator|!=
name|GL_ONE_MINUS_CONSTANT_ALPHA
condition|)
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_BLENDFACTOR
argument_list|,
name|gl_d3d9
operator|::
name|ConvertColor
argument_list|(
name|blendColor
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_BLENDFACTOR
argument_list|,
name|D3DCOLOR_RGBA
argument_list|(
name|gl
operator|::
name|unorm
argument_list|<
literal|8
argument_list|>
argument_list|(
name|blendColor
operator|.
name|alpha
argument_list|)
argument_list|,
name|gl
operator|::
name|unorm
argument_list|<
literal|8
argument_list|>
argument_list|(
name|blendColor
operator|.
name|alpha
argument_list|)
argument_list|,
name|gl
operator|::
name|unorm
argument_list|<
literal|8
argument_list|>
argument_list|(
name|blendColor
operator|.
name|alpha
argument_list|)
argument_list|,
name|gl
operator|::
name|unorm
argument_list|<
literal|8
argument_list|>
argument_list|(
name|blendColor
operator|.
name|alpha
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_SRCBLEND
argument_list|,
name|gl_d3d9
operator|::
name|ConvertBlendFunc
argument_list|(
name|blendState
operator|.
name|sourceBlendRGB
argument_list|)
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_DESTBLEND
argument_list|,
name|gl_d3d9
operator|::
name|ConvertBlendFunc
argument_list|(
name|blendState
operator|.
name|destBlendRGB
argument_list|)
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_BLENDOP
argument_list|,
name|gl_d3d9
operator|::
name|ConvertBlendOp
argument_list|(
name|blendState
operator|.
name|blendEquationRGB
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|blendState
operator|.
name|sourceBlendRGB
operator|!=
name|blendState
operator|.
name|sourceBlendAlpha
operator|||
name|blendState
operator|.
name|destBlendRGB
operator|!=
name|blendState
operator|.
name|destBlendAlpha
operator|||
name|blendState
operator|.
name|blendEquationRGB
operator|!=
name|blendState
operator|.
name|blendEquationAlpha
condition|)
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_SEPARATEALPHABLENDENABLE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_SRCBLENDALPHA
argument_list|,
name|gl_d3d9
operator|::
name|ConvertBlendFunc
argument_list|(
name|blendState
operator|.
name|sourceBlendAlpha
argument_list|)
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_DESTBLENDALPHA
argument_list|,
name|gl_d3d9
operator|::
name|ConvertBlendFunc
argument_list|(
name|blendState
operator|.
name|destBlendAlpha
argument_list|)
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_BLENDOPALPHA
argument_list|,
name|gl_d3d9
operator|::
name|ConvertBlendOp
argument_list|(
name|blendState
operator|.
name|blendEquationAlpha
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_SEPARATEALPHABLENDENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ALPHABLENDENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|blendState
operator|.
name|sampleAlphaToCoverage
condition|)
block|{
name|FIXME
argument_list|(
literal|"Sample alpha to coverage is unimplemented."
argument_list|)
expr_stmt|;
block|}
comment|// Set the color mask
name|bool
name|zeroColorMaskAllowed
init|=
name|getAdapterVendor
argument_list|()
operator|!=
name|VENDOR_ID_AMD
decl_stmt|;
comment|// Apparently some ATI cards have a bug where a draw with a zero color
comment|// write mask can cause later draws to have incorrect results. Instead,
comment|// set a nonzero color write mask but modify the blend state so that no
comment|// drawing is done.
comment|// http://code.google.com/p/angleproject/issues/detail?id=169
name|DWORD
name|colorMask
init|=
name|gl_d3d9
operator|::
name|ConvertColorMask
argument_list|(
name|blendState
operator|.
name|colorMaskRed
argument_list|,
name|blendState
operator|.
name|colorMaskGreen
argument_list|,
name|blendState
operator|.
name|colorMaskBlue
argument_list|,
name|blendState
operator|.
name|colorMaskAlpha
argument_list|)
decl_stmt|;
if|if
condition|(
name|colorMask
operator|==
literal|0
operator|&&
operator|!
name|zeroColorMaskAllowed
condition|)
block|{
comment|// Enable green channel, but set blending so nothing will be drawn.
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_COLORWRITEENABLE
argument_list|,
name|D3DCOLORWRITEENABLE_GREEN
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ALPHABLENDENABLE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_SRCBLEND
argument_list|,
name|D3DBLEND_ZERO
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_DESTBLEND
argument_list|,
name|D3DBLEND_ONE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_BLENDOP
argument_list|,
name|D3DBLENDOP_ADD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_COLORWRITEENABLE
argument_list|,
name|colorMask
argument_list|)
expr_stmt|;
block|}
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_DITHERENABLE
argument_list|,
name|blendState
operator|.
name|dither
condition|?
name|TRUE
else|:
name|FALSE
argument_list|)
expr_stmt|;
name|mCurBlendState
operator|=
name|blendState
expr_stmt|;
name|mCurBlendColor
operator|=
name|blendColor
expr_stmt|;
block|}
if|if
condition|(
name|sampleMaskChanged
condition|)
block|{
comment|// Set the multisample mask
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_MULTISAMPLEANTIALIAS
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_MULTISAMPLEMASK
argument_list|,
cast|static_cast
argument_list|<
name|DWORD
argument_list|>
argument_list|(
name|sampleMask
argument_list|)
argument_list|)
expr_stmt|;
name|mCurSampleMask
operator|=
name|sampleMask
expr_stmt|;
block|}
name|mForceSetBlendState
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|setDepthStencilState
name|void
name|Renderer9
operator|::
name|setDepthStencilState
parameter_list|(
specifier|const
name|gl
operator|::
name|DepthStencilState
modifier|&
name|depthStencilState
parameter_list|,
name|int
name|stencilRef
parameter_list|,
name|int
name|stencilBackRef
parameter_list|,
name|bool
name|frontFaceCCW
parameter_list|)
block|{
name|bool
name|depthStencilStateChanged
init|=
name|mForceSetDepthStencilState
operator|||
name|memcmp
argument_list|(
operator|&
name|depthStencilState
argument_list|,
operator|&
name|mCurDepthStencilState
argument_list|,
sizeof|sizeof
argument_list|(
name|gl
operator|::
name|DepthStencilState
argument_list|)
argument_list|)
operator|!=
literal|0
decl_stmt|;
name|bool
name|stencilRefChanged
init|=
name|mForceSetDepthStencilState
operator|||
name|stencilRef
operator|!=
name|mCurStencilRef
operator|||
name|stencilBackRef
operator|!=
name|mCurStencilBackRef
decl_stmt|;
name|bool
name|frontFaceCCWChanged
init|=
name|mForceSetDepthStencilState
operator|||
name|frontFaceCCW
operator|!=
name|mCurFrontFaceCCW
decl_stmt|;
if|if
condition|(
name|depthStencilStateChanged
condition|)
block|{
if|if
condition|(
name|depthStencilState
operator|.
name|depthTest
condition|)
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ZENABLE
argument_list|,
name|D3DZB_TRUE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ZFUNC
argument_list|,
name|gl_d3d9
operator|::
name|ConvertComparison
argument_list|(
name|depthStencilState
operator|.
name|depthFunc
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ZENABLE
argument_list|,
name|D3DZB_FALSE
argument_list|)
expr_stmt|;
block|}
name|mCurDepthStencilState
operator|=
name|depthStencilState
expr_stmt|;
block|}
if|if
condition|(
name|depthStencilStateChanged
operator|||
name|stencilRefChanged
operator|||
name|frontFaceCCWChanged
condition|)
block|{
if|if
condition|(
name|depthStencilState
operator|.
name|stencilTest
operator|&&
name|mCurStencilSize
operator|>
literal|0
condition|)
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_STENCILENABLE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_TWOSIDEDSTENCILMODE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|// FIXME: Unsupported by D3D9
specifier|const
name|D3DRENDERSTATETYPE
name|D3DRS_CCW_STENCILREF
init|=
name|D3DRS_STENCILREF
decl_stmt|;
specifier|const
name|D3DRENDERSTATETYPE
name|D3DRS_CCW_STENCILMASK
init|=
name|D3DRS_STENCILMASK
decl_stmt|;
specifier|const
name|D3DRENDERSTATETYPE
name|D3DRS_CCW_STENCILWRITEMASK
init|=
name|D3DRS_STENCILWRITEMASK
decl_stmt|;
if|if
condition|(
name|depthStencilState
operator|.
name|stencilWritemask
operator|!=
name|depthStencilState
operator|.
name|stencilBackWritemask
operator|||
name|stencilRef
operator|!=
name|stencilBackRef
operator|||
name|depthStencilState
operator|.
name|stencilMask
operator|!=
name|depthStencilState
operator|.
name|stencilBackMask
condition|)
block|{
name|ERR
argument_list|(
literal|"Separate front/back stencil writemasks, reference values, or stencil mask values are invalid under WebGL."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
comment|// get the maximum size of the stencil ref
name|unsigned
name|int
name|maxStencil
init|=
operator|(
literal|1
operator|<<
name|mCurStencilSize
operator|)
operator|-
literal|1
decl_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|frontFaceCCW
condition|?
name|D3DRS_STENCILWRITEMASK
else|:
name|D3DRS_CCW_STENCILWRITEMASK
argument_list|,
name|depthStencilState
operator|.
name|stencilWritemask
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|frontFaceCCW
condition|?
name|D3DRS_STENCILFUNC
else|:
name|D3DRS_CCW_STENCILFUNC
argument_list|,
name|gl_d3d9
operator|::
name|ConvertComparison
argument_list|(
name|depthStencilState
operator|.
name|stencilFunc
argument_list|)
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|frontFaceCCW
condition|?
name|D3DRS_STENCILREF
else|:
name|D3DRS_CCW_STENCILREF
argument_list|,
operator|(
name|stencilRef
operator|<
operator|(
name|int
operator|)
name|maxStencil
operator|)
condition|?
name|stencilRef
else|:
name|maxStencil
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|frontFaceCCW
condition|?
name|D3DRS_STENCILMASK
else|:
name|D3DRS_CCW_STENCILMASK
argument_list|,
name|depthStencilState
operator|.
name|stencilMask
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|frontFaceCCW
condition|?
name|D3DRS_STENCILFAIL
else|:
name|D3DRS_CCW_STENCILFAIL
argument_list|,
name|gl_d3d9
operator|::
name|ConvertStencilOp
argument_list|(
name|depthStencilState
operator|.
name|stencilFail
argument_list|)
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|frontFaceCCW
condition|?
name|D3DRS_STENCILZFAIL
else|:
name|D3DRS_CCW_STENCILZFAIL
argument_list|,
name|gl_d3d9
operator|::
name|ConvertStencilOp
argument_list|(
name|depthStencilState
operator|.
name|stencilPassDepthFail
argument_list|)
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|frontFaceCCW
condition|?
name|D3DRS_STENCILPASS
else|:
name|D3DRS_CCW_STENCILPASS
argument_list|,
name|gl_d3d9
operator|::
name|ConvertStencilOp
argument_list|(
name|depthStencilState
operator|.
name|stencilPassDepthPass
argument_list|)
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
operator|!
name|frontFaceCCW
condition|?
name|D3DRS_STENCILWRITEMASK
else|:
name|D3DRS_CCW_STENCILWRITEMASK
argument_list|,
name|depthStencilState
operator|.
name|stencilBackWritemask
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
operator|!
name|frontFaceCCW
condition|?
name|D3DRS_STENCILFUNC
else|:
name|D3DRS_CCW_STENCILFUNC
argument_list|,
name|gl_d3d9
operator|::
name|ConvertComparison
argument_list|(
name|depthStencilState
operator|.
name|stencilBackFunc
argument_list|)
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
operator|!
name|frontFaceCCW
condition|?
name|D3DRS_STENCILREF
else|:
name|D3DRS_CCW_STENCILREF
argument_list|,
operator|(
name|stencilBackRef
operator|<
operator|(
name|int
operator|)
name|maxStencil
operator|)
condition|?
name|stencilBackRef
else|:
name|maxStencil
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
operator|!
name|frontFaceCCW
condition|?
name|D3DRS_STENCILMASK
else|:
name|D3DRS_CCW_STENCILMASK
argument_list|,
name|depthStencilState
operator|.
name|stencilBackMask
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
operator|!
name|frontFaceCCW
condition|?
name|D3DRS_STENCILFAIL
else|:
name|D3DRS_CCW_STENCILFAIL
argument_list|,
name|gl_d3d9
operator|::
name|ConvertStencilOp
argument_list|(
name|depthStencilState
operator|.
name|stencilBackFail
argument_list|)
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
operator|!
name|frontFaceCCW
condition|?
name|D3DRS_STENCILZFAIL
else|:
name|D3DRS_CCW_STENCILZFAIL
argument_list|,
name|gl_d3d9
operator|::
name|ConvertStencilOp
argument_list|(
name|depthStencilState
operator|.
name|stencilBackPassDepthFail
argument_list|)
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
operator|!
name|frontFaceCCW
condition|?
name|D3DRS_STENCILPASS
else|:
name|D3DRS_CCW_STENCILPASS
argument_list|,
name|gl_d3d9
operator|::
name|ConvertStencilOp
argument_list|(
name|depthStencilState
operator|.
name|stencilBackPassDepthPass
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_STENCILENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ZWRITEENABLE
argument_list|,
name|depthStencilState
operator|.
name|depthMask
condition|?
name|TRUE
else|:
name|FALSE
argument_list|)
expr_stmt|;
name|mCurStencilRef
operator|=
name|stencilRef
expr_stmt|;
name|mCurStencilBackRef
operator|=
name|stencilBackRef
expr_stmt|;
name|mCurFrontFaceCCW
operator|=
name|frontFaceCCW
expr_stmt|;
block|}
name|mForceSetDepthStencilState
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|setScissorRectangle
name|void
name|Renderer9
operator|::
name|setScissorRectangle
parameter_list|(
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|scissor
parameter_list|,
name|bool
name|enabled
parameter_list|)
block|{
name|bool
name|scissorChanged
init|=
name|mForceSetScissor
operator|||
name|memcmp
argument_list|(
operator|&
name|scissor
argument_list|,
operator|&
name|mCurScissor
argument_list|,
sizeof|sizeof
argument_list|(
name|gl
operator|::
name|Rectangle
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|enabled
operator|!=
name|mScissorEnabled
decl_stmt|;
if|if
condition|(
name|scissorChanged
condition|)
block|{
if|if
condition|(
name|enabled
condition|)
block|{
name|RECT
name|rect
decl_stmt|;
name|rect
operator|.
name|left
operator|=
name|gl
operator|::
name|clamp
argument_list|(
name|scissor
operator|.
name|x
argument_list|,
literal|0
argument_list|,
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|mRenderTargetDesc
operator|.
name|width
argument_list|)
argument_list|)
expr_stmt|;
name|rect
operator|.
name|top
operator|=
name|gl
operator|::
name|clamp
argument_list|(
name|scissor
operator|.
name|y
argument_list|,
literal|0
argument_list|,
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|mRenderTargetDesc
operator|.
name|height
argument_list|)
argument_list|)
expr_stmt|;
name|rect
operator|.
name|right
operator|=
name|gl
operator|::
name|clamp
argument_list|(
name|scissor
operator|.
name|x
operator|+
name|scissor
operator|.
name|width
argument_list|,
literal|0
argument_list|,
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|mRenderTargetDesc
operator|.
name|width
argument_list|)
argument_list|)
expr_stmt|;
name|rect
operator|.
name|bottom
operator|=
name|gl
operator|::
name|clamp
argument_list|(
name|scissor
operator|.
name|y
operator|+
name|scissor
operator|.
name|height
argument_list|,
literal|0
argument_list|,
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|mRenderTargetDesc
operator|.
name|height
argument_list|)
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetScissorRect
argument_list|(
operator|&
name|rect
argument_list|)
expr_stmt|;
block|}
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_SCISSORTESTENABLE
argument_list|,
name|enabled
condition|?
name|TRUE
else|:
name|FALSE
argument_list|)
expr_stmt|;
name|mScissorEnabled
operator|=
name|enabled
expr_stmt|;
name|mCurScissor
operator|=
name|scissor
expr_stmt|;
block|}
name|mForceSetScissor
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|setViewport
name|bool
name|Renderer9
operator|::
name|setViewport
parameter_list|(
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|viewport
parameter_list|,
name|float
name|zNear
parameter_list|,
name|float
name|zFar
parameter_list|,
name|GLenum
name|drawMode
parameter_list|,
name|GLenum
name|frontFace
parameter_list|,
name|bool
name|ignoreViewport
parameter_list|)
block|{
name|gl
operator|::
name|Rectangle
name|actualViewport
init|=
name|viewport
decl_stmt|;
name|float
name|actualZNear
init|=
name|gl
operator|::
name|clamp01
argument_list|(
name|zNear
argument_list|)
decl_stmt|;
name|float
name|actualZFar
init|=
name|gl
operator|::
name|clamp01
argument_list|(
name|zFar
argument_list|)
decl_stmt|;
if|if
condition|(
name|ignoreViewport
condition|)
block|{
name|actualViewport
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|actualViewport
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|actualViewport
operator|.
name|width
operator|=
name|mRenderTargetDesc
operator|.
name|width
expr_stmt|;
name|actualViewport
operator|.
name|height
operator|=
name|mRenderTargetDesc
operator|.
name|height
expr_stmt|;
name|actualZNear
operator|=
literal|0.0f
expr_stmt|;
name|actualZFar
operator|=
literal|1.0f
expr_stmt|;
block|}
name|D3DVIEWPORT9
name|dxViewport
decl_stmt|;
name|dxViewport
operator|.
name|X
operator|=
name|gl
operator|::
name|clamp
argument_list|(
name|actualViewport
operator|.
name|x
argument_list|,
literal|0
argument_list|,
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|mRenderTargetDesc
operator|.
name|width
argument_list|)
argument_list|)
expr_stmt|;
name|dxViewport
operator|.
name|Y
operator|=
name|gl
operator|::
name|clamp
argument_list|(
name|actualViewport
operator|.
name|y
argument_list|,
literal|0
argument_list|,
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|mRenderTargetDesc
operator|.
name|height
argument_list|)
argument_list|)
expr_stmt|;
name|dxViewport
operator|.
name|Width
operator|=
name|gl
operator|::
name|clamp
argument_list|(
name|actualViewport
operator|.
name|width
argument_list|,
literal|0
argument_list|,
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|mRenderTargetDesc
operator|.
name|width
argument_list|)
operator|-
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|dxViewport
operator|.
name|X
argument_list|)
argument_list|)
expr_stmt|;
name|dxViewport
operator|.
name|Height
operator|=
name|gl
operator|::
name|clamp
argument_list|(
name|actualViewport
operator|.
name|height
argument_list|,
literal|0
argument_list|,
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|mRenderTargetDesc
operator|.
name|height
argument_list|)
operator|-
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|dxViewport
operator|.
name|Y
argument_list|)
argument_list|)
expr_stmt|;
name|dxViewport
operator|.
name|MinZ
operator|=
name|actualZNear
expr_stmt|;
name|dxViewport
operator|.
name|MaxZ
operator|=
name|actualZFar
expr_stmt|;
if|if
condition|(
name|dxViewport
operator|.
name|Width
operator|<=
literal|0
operator|||
name|dxViewport
operator|.
name|Height
operator|<=
literal|0
condition|)
block|{
return|return
literal|false
return|;
comment|// Nothing to render
block|}
name|bool
name|viewportChanged
init|=
name|mForceSetViewport
operator|||
name|memcmp
argument_list|(
operator|&
name|actualViewport
argument_list|,
operator|&
name|mCurViewport
argument_list|,
sizeof|sizeof
argument_list|(
name|gl
operator|::
name|Rectangle
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|actualZNear
operator|!=
name|mCurNear
operator|||
name|actualZFar
operator|!=
name|mCurFar
decl_stmt|;
if|if
condition|(
name|viewportChanged
condition|)
block|{
name|mDevice
operator|->
name|SetViewport
argument_list|(
operator|&
name|dxViewport
argument_list|)
expr_stmt|;
name|mCurViewport
operator|=
name|actualViewport
expr_stmt|;
name|mCurNear
operator|=
name|actualZNear
expr_stmt|;
name|mCurFar
operator|=
name|actualZFar
expr_stmt|;
name|dx_VertexConstants
name|vc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|dx_PixelConstants
name|pc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|vc
operator|.
name|viewAdjust
index|[
literal|0
index|]
operator|=
call|(
name|float
call|)
argument_list|(
operator|(
name|actualViewport
operator|.
name|width
operator|-
operator|(
name|int
operator|)
name|dxViewport
operator|.
name|Width
operator|)
operator|+
literal|2
operator|*
operator|(
name|actualViewport
operator|.
name|x
operator|-
operator|(
name|int
operator|)
name|dxViewport
operator|.
name|X
operator|)
operator|-
literal|1
argument_list|)
operator|/
name|dxViewport
operator|.
name|Width
expr_stmt|;
name|vc
operator|.
name|viewAdjust
index|[
literal|1
index|]
operator|=
call|(
name|float
call|)
argument_list|(
operator|(
name|actualViewport
operator|.
name|height
operator|-
operator|(
name|int
operator|)
name|dxViewport
operator|.
name|Height
operator|)
operator|+
literal|2
operator|*
operator|(
name|actualViewport
operator|.
name|y
operator|-
operator|(
name|int
operator|)
name|dxViewport
operator|.
name|Y
operator|)
operator|-
literal|1
argument_list|)
operator|/
name|dxViewport
operator|.
name|Height
expr_stmt|;
name|vc
operator|.
name|viewAdjust
index|[
literal|2
index|]
operator|=
operator|(
name|float
operator|)
name|actualViewport
operator|.
name|width
operator|/
name|dxViewport
operator|.
name|Width
expr_stmt|;
name|vc
operator|.
name|viewAdjust
index|[
literal|3
index|]
operator|=
operator|(
name|float
operator|)
name|actualViewport
operator|.
name|height
operator|/
name|dxViewport
operator|.
name|Height
expr_stmt|;
name|pc
operator|.
name|viewCoords
index|[
literal|0
index|]
operator|=
name|actualViewport
operator|.
name|width
operator|*
literal|0.5f
expr_stmt|;
name|pc
operator|.
name|viewCoords
index|[
literal|1
index|]
operator|=
name|actualViewport
operator|.
name|height
operator|*
literal|0.5f
expr_stmt|;
name|pc
operator|.
name|viewCoords
index|[
literal|2
index|]
operator|=
name|actualViewport
operator|.
name|x
operator|+
operator|(
name|actualViewport
operator|.
name|width
operator|*
literal|0.5f
operator|)
expr_stmt|;
name|pc
operator|.
name|viewCoords
index|[
literal|3
index|]
operator|=
name|actualViewport
operator|.
name|y
operator|+
operator|(
name|actualViewport
operator|.
name|height
operator|*
literal|0.5f
operator|)
expr_stmt|;
name|pc
operator|.
name|depthFront
index|[
literal|0
index|]
operator|=
operator|(
name|actualZFar
operator|-
name|actualZNear
operator|)
operator|*
literal|0.5f
expr_stmt|;
name|pc
operator|.
name|depthFront
index|[
literal|1
index|]
operator|=
operator|(
name|actualZNear
operator|+
name|actualZFar
operator|)
operator|*
literal|0.5f
expr_stmt|;
name|pc
operator|.
name|depthFront
index|[
literal|2
index|]
operator|=
operator|!
name|gl
operator|::
name|IsTriangleMode
argument_list|(
name|drawMode
argument_list|)
condition|?
literal|0.0f
else|:
operator|(
name|frontFace
operator|==
name|GL_CCW
condition|?
literal|1.0f
else|:
operator|-
literal|1.0f
operator|)
expr_stmt|;
empty_stmt|;
name|vc
operator|.
name|depthRange
index|[
literal|0
index|]
operator|=
name|actualZNear
expr_stmt|;
name|vc
operator|.
name|depthRange
index|[
literal|1
index|]
operator|=
name|actualZFar
expr_stmt|;
name|vc
operator|.
name|depthRange
index|[
literal|2
index|]
operator|=
name|actualZFar
operator|-
name|actualZNear
expr_stmt|;
name|pc
operator|.
name|depthRange
index|[
literal|0
index|]
operator|=
name|actualZNear
expr_stmt|;
name|pc
operator|.
name|depthRange
index|[
literal|1
index|]
operator|=
name|actualZFar
expr_stmt|;
name|pc
operator|.
name|depthRange
index|[
literal|2
index|]
operator|=
name|actualZFar
operator|-
name|actualZNear
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|vc
argument_list|,
operator|&
name|mVertexConstants
argument_list|,
sizeof|sizeof
argument_list|(
name|dx_VertexConstants
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mVertexConstants
operator|=
name|vc
expr_stmt|;
name|mDxUniformsDirty
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|pc
argument_list|,
operator|&
name|mPixelConstants
argument_list|,
sizeof|sizeof
argument_list|(
name|dx_PixelConstants
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mPixelConstants
operator|=
name|pc
expr_stmt|;
name|mDxUniformsDirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|mForceSetViewport
operator|=
literal|false
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|applyPrimitiveType
name|bool
name|Renderer9
operator|::
name|applyPrimitiveType
parameter_list|(
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|GL_POINTS
case|:
name|mPrimitiveType
operator|=
name|D3DPT_POINTLIST
expr_stmt|;
name|mPrimitiveCount
operator|=
name|count
expr_stmt|;
break|break;
case|case
name|GL_LINES
case|:
name|mPrimitiveType
operator|=
name|D3DPT_LINELIST
expr_stmt|;
name|mPrimitiveCount
operator|=
name|count
operator|/
literal|2
expr_stmt|;
break|break;
case|case
name|GL_LINE_LOOP
case|:
name|mPrimitiveType
operator|=
name|D3DPT_LINESTRIP
expr_stmt|;
name|mPrimitiveCount
operator|=
name|count
operator|-
literal|1
expr_stmt|;
comment|// D3D doesn't support line loops, so we draw the last line separately
break|break;
case|case
name|GL_LINE_STRIP
case|:
name|mPrimitiveType
operator|=
name|D3DPT_LINESTRIP
expr_stmt|;
name|mPrimitiveCount
operator|=
name|count
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|GL_TRIANGLES
case|:
name|mPrimitiveType
operator|=
name|D3DPT_TRIANGLELIST
expr_stmt|;
name|mPrimitiveCount
operator|=
name|count
operator|/
literal|3
expr_stmt|;
break|break;
case|case
name|GL_TRIANGLE_STRIP
case|:
name|mPrimitiveType
operator|=
name|D3DPT_TRIANGLESTRIP
expr_stmt|;
name|mPrimitiveCount
operator|=
name|count
operator|-
literal|2
expr_stmt|;
break|break;
case|case
name|GL_TRIANGLE_FAN
case|:
name|mPrimitiveType
operator|=
name|D3DPT_TRIANGLEFAN
expr_stmt|;
name|mPrimitiveCount
operator|=
name|count
operator|-
literal|2
expr_stmt|;
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
return|;
block|}
return|return
name|mPrimitiveCount
operator|>
literal|0
return|;
block|}
DECL|function|getNullColorbuffer
name|gl
operator|::
name|Renderbuffer
modifier|*
name|Renderer9
operator|::
name|getNullColorbuffer
parameter_list|(
name|gl
operator|::
name|Renderbuffer
modifier|*
name|depthbuffer
parameter_list|)
block|{
if|if
condition|(
operator|!
name|depthbuffer
condition|)
block|{
name|ERR
argument_list|(
literal|"Unexpected null depthbuffer for depth-only FBO."
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|GLsizei
name|width
init|=
name|depthbuffer
operator|->
name|getWidth
argument_list|()
decl_stmt|;
name|GLsizei
name|height
init|=
name|depthbuffer
operator|->
name|getHeight
argument_list|()
decl_stmt|;
comment|// search cached nullcolorbuffers
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_NULL_COLORBUFFER_CACHE_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mNullColorbufferCache
index|[
name|i
index|]
operator|.
name|buffer
operator|!=
name|NULL
operator|&&
name|mNullColorbufferCache
index|[
name|i
index|]
operator|.
name|width
operator|==
name|width
operator|&&
name|mNullColorbufferCache
index|[
name|i
index|]
operator|.
name|height
operator|==
name|height
condition|)
block|{
name|mNullColorbufferCache
index|[
name|i
index|]
operator|.
name|lruCount
operator|=
operator|++
name|mMaxNullColorbufferLRU
expr_stmt|;
return|return
name|mNullColorbufferCache
index|[
name|i
index|]
operator|.
name|buffer
return|;
block|}
block|}
name|gl
operator|::
name|Renderbuffer
modifier|*
name|nullbuffer
init|=
operator|new
name|gl
operator|::
name|Renderbuffer
argument_list|(
name|this
argument_list|,
literal|0
argument_list|,
operator|new
name|gl
operator|::
name|Colorbuffer
argument_list|(
name|this
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|GL_NONE
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|// add nullbuffer to the cache
name|NullColorbufferCacheEntry
modifier|*
name|oldest
init|=
operator|&
name|mNullColorbufferCache
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|NUM_NULL_COLORBUFFER_CACHE_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mNullColorbufferCache
index|[
name|i
index|]
operator|.
name|lruCount
operator|<
name|oldest
operator|->
name|lruCount
condition|)
block|{
name|oldest
operator|=
operator|&
name|mNullColorbufferCache
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
operator|delete
name|oldest
operator|->
name|buffer
expr_stmt|;
name|oldest
operator|->
name|buffer
operator|=
name|nullbuffer
expr_stmt|;
name|oldest
operator|->
name|lruCount
operator|=
operator|++
name|mMaxNullColorbufferLRU
expr_stmt|;
name|oldest
operator|->
name|width
operator|=
name|width
expr_stmt|;
name|oldest
operator|->
name|height
operator|=
name|height
expr_stmt|;
return|return
name|nullbuffer
return|;
block|}
DECL|function|applyRenderTarget
name|bool
name|Renderer9
operator|::
name|applyRenderTarget
parameter_list|(
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
parameter_list|)
block|{
comment|// if there is no color attachment we must synthesize a NULL colorattachment
comment|// to keep the D3D runtime happy.  This should only be possible if depth texturing.
name|gl
operator|::
name|Renderbuffer
modifier|*
name|renderbufferObject
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|framebuffer
operator|->
name|getColorbufferType
argument_list|(
literal|0
argument_list|)
operator|!=
name|GL_NONE
condition|)
block|{
name|renderbufferObject
operator|=
name|framebuffer
operator|->
name|getColorbuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|renderbufferObject
operator|=
name|getNullColorbuffer
argument_list|(
name|framebuffer
operator|->
name|getDepthbuffer
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|renderbufferObject
condition|)
block|{
name|ERR
argument_list|(
literal|"unable to locate renderbuffer for FBO."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|bool
name|renderTargetChanged
init|=
literal|false
decl_stmt|;
name|unsigned
name|int
name|renderTargetSerial
init|=
name|renderbufferObject
operator|->
name|getSerial
argument_list|()
decl_stmt|;
if|if
condition|(
name|renderTargetSerial
operator|!=
name|mAppliedRenderTargetSerial
condition|)
block|{
comment|// Apply the render target on the device
name|IDirect3DSurface9
modifier|*
name|renderTargetSurface
init|=
name|NULL
decl_stmt|;
name|RenderTarget
modifier|*
name|renderTarget
init|=
name|renderbufferObject
operator|->
name|getRenderTarget
argument_list|()
decl_stmt|;
if|if
condition|(
name|renderTarget
condition|)
block|{
name|renderTargetSurface
operator|=
name|RenderTarget9
operator|::
name|makeRenderTarget9
argument_list|(
name|renderTarget
argument_list|)
operator|->
name|getSurface
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|renderTargetSurface
condition|)
block|{
name|ERR
argument_list|(
literal|"render target pointer unexpectedly null."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
comment|// Context must be lost
block|}
name|mDevice
operator|->
name|SetRenderTarget
argument_list|(
literal|0
argument_list|,
name|renderTargetSurface
argument_list|)
expr_stmt|;
name|renderTargetSurface
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mAppliedRenderTargetSerial
operator|=
name|renderTargetSerial
expr_stmt|;
name|renderTargetChanged
operator|=
literal|true
expr_stmt|;
block|}
name|gl
operator|::
name|Renderbuffer
modifier|*
name|depthStencil
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|depthbufferSerial
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|stencilbufferSerial
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|framebuffer
operator|->
name|getDepthbufferType
argument_list|()
operator|!=
name|GL_NONE
condition|)
block|{
name|depthStencil
operator|=
name|framebuffer
operator|->
name|getDepthbuffer
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|depthStencil
condition|)
block|{
name|ERR
argument_list|(
literal|"Depth stencil pointer unexpectedly null."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|depthbufferSerial
operator|=
name|depthStencil
operator|->
name|getSerial
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|framebuffer
operator|->
name|getStencilbufferType
argument_list|()
operator|!=
name|GL_NONE
condition|)
block|{
name|depthStencil
operator|=
name|framebuffer
operator|->
name|getStencilbuffer
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|depthStencil
condition|)
block|{
name|ERR
argument_list|(
literal|"Depth stencil pointer unexpectedly null."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|stencilbufferSerial
operator|=
name|depthStencil
operator|->
name|getSerial
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|depthbufferSerial
operator|!=
name|mAppliedDepthbufferSerial
operator|||
name|stencilbufferSerial
operator|!=
name|mAppliedStencilbufferSerial
operator|||
operator|!
name|mDepthStencilInitialized
condition|)
block|{
name|unsigned
name|int
name|depthSize
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|stencilSize
init|=
literal|0
decl_stmt|;
comment|// Apply the depth stencil on the device
if|if
condition|(
name|depthStencil
condition|)
block|{
name|IDirect3DSurface9
modifier|*
name|depthStencilSurface
init|=
name|NULL
decl_stmt|;
name|RenderTarget
modifier|*
name|depthStencilRenderTarget
init|=
name|depthStencil
operator|->
name|getDepthStencil
argument_list|()
decl_stmt|;
if|if
condition|(
name|depthStencilRenderTarget
condition|)
block|{
name|depthStencilSurface
operator|=
name|RenderTarget9
operator|::
name|makeRenderTarget9
argument_list|(
name|depthStencilRenderTarget
argument_list|)
operator|->
name|getSurface
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|depthStencilSurface
condition|)
block|{
name|ERR
argument_list|(
literal|"depth stencil pointer unexpectedly null."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
comment|// Context must be lost
block|}
name|mDevice
operator|->
name|SetDepthStencilSurface
argument_list|(
name|depthStencilSurface
argument_list|)
expr_stmt|;
name|depthStencilSurface
operator|->
name|Release
argument_list|()
expr_stmt|;
name|depthSize
operator|=
name|depthStencil
operator|->
name|getDepthSize
argument_list|()
expr_stmt|;
name|stencilSize
operator|=
name|depthStencil
operator|->
name|getStencilSize
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|mDevice
operator|->
name|SetDepthStencilSurface
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mDepthStencilInitialized
operator|||
name|depthSize
operator|!=
name|mCurDepthSize
condition|)
block|{
name|mCurDepthSize
operator|=
name|depthSize
expr_stmt|;
name|mForceSetRasterState
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mDepthStencilInitialized
operator|||
name|stencilSize
operator|!=
name|mCurStencilSize
condition|)
block|{
name|mCurStencilSize
operator|=
name|stencilSize
expr_stmt|;
name|mForceSetDepthStencilState
operator|=
literal|true
expr_stmt|;
block|}
name|mAppliedDepthbufferSerial
operator|=
name|depthbufferSerial
expr_stmt|;
name|mAppliedStencilbufferSerial
operator|=
name|stencilbufferSerial
expr_stmt|;
name|mDepthStencilInitialized
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|renderTargetChanged
operator|||
operator|!
name|mRenderTargetDescInitialized
condition|)
block|{
name|mForceSetScissor
operator|=
literal|true
expr_stmt|;
name|mForceSetViewport
operator|=
literal|true
expr_stmt|;
name|mRenderTargetDesc
operator|.
name|width
operator|=
name|renderbufferObject
operator|->
name|getWidth
argument_list|()
expr_stmt|;
name|mRenderTargetDesc
operator|.
name|height
operator|=
name|renderbufferObject
operator|->
name|getHeight
argument_list|()
expr_stmt|;
name|mRenderTargetDesc
operator|.
name|format
operator|=
name|renderbufferObject
operator|->
name|getActualFormat
argument_list|()
expr_stmt|;
name|mRenderTargetDescInitialized
operator|=
literal|true
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|applyVertexBuffer
name|GLenum
name|Renderer9
operator|::
name|applyVertexBuffer
parameter_list|(
name|gl
operator|::
name|ProgramBinary
modifier|*
name|programBinary
parameter_list|,
name|gl
operator|::
name|VertexAttribute
name|vertexAttributes
index|[]
parameter_list|,
name|GLint
name|first
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLsizei
name|instances
parameter_list|)
block|{
name|TranslatedAttribute
name|attributes
index|[
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
index|]
decl_stmt|;
name|GLenum
name|err
init|=
name|mVertexDataManager
operator|->
name|prepareVertexData
argument_list|(
name|vertexAttributes
argument_list|,
name|programBinary
argument_list|,
name|first
argument_list|,
name|count
argument_list|,
name|attributes
argument_list|,
name|instances
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|!=
name|GL_NO_ERROR
condition|)
block|{
return|return
name|err
return|;
block|}
return|return
name|mVertexDeclarationCache
operator|.
name|applyDeclaration
argument_list|(
name|mDevice
argument_list|,
name|attributes
argument_list|,
name|programBinary
argument_list|,
name|instances
argument_list|,
operator|&
name|mRepeatDraw
argument_list|)
return|;
block|}
comment|// Applies the indices and element array bindings to the Direct3D 9 device
DECL|function|applyIndexBuffer
name|GLenum
name|Renderer9
operator|::
name|applyIndexBuffer
parameter_list|(
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|gl
operator|::
name|Buffer
modifier|*
name|elementArrayBuffer
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|TranslatedIndexData
modifier|*
name|indexInfo
parameter_list|)
block|{
name|GLenum
name|err
init|=
name|mIndexDataManager
operator|->
name|prepareIndexData
argument_list|(
name|type
argument_list|,
name|count
argument_list|,
name|elementArrayBuffer
argument_list|,
name|indices
argument_list|,
name|indexInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|==
name|GL_NO_ERROR
condition|)
block|{
comment|// Directly binding the storage buffer is not supported for d3d9
name|ASSERT
argument_list|(
name|indexInfo
operator|->
name|storage
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|indexInfo
operator|->
name|serial
operator|!=
name|mAppliedIBSerial
condition|)
block|{
name|IndexBuffer9
modifier|*
name|indexBuffer
init|=
name|IndexBuffer9
operator|::
name|makeIndexBuffer9
argument_list|(
name|indexInfo
operator|->
name|indexBuffer
argument_list|)
decl_stmt|;
name|mDevice
operator|->
name|SetIndices
argument_list|(
name|indexBuffer
operator|->
name|getBuffer
argument_list|()
argument_list|)
expr_stmt|;
name|mAppliedIBSerial
operator|=
name|indexInfo
operator|->
name|serial
expr_stmt|;
block|}
block|}
return|return
name|err
return|;
block|}
DECL|function|drawArrays
name|void
name|Renderer9
operator|::
name|drawArrays
parameter_list|(
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLsizei
name|instances
parameter_list|)
block|{
name|startScene
argument_list|()
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|GL_LINE_LOOP
condition|)
block|{
name|drawLineLoop
argument_list|(
name|count
argument_list|,
name|GL_NONE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instances
operator|>
literal|0
condition|)
block|{
name|StaticIndexBufferInterface
modifier|*
name|countingIB
init|=
name|mIndexDataManager
operator|->
name|getCountingIndices
argument_list|(
name|count
argument_list|)
decl_stmt|;
if|if
condition|(
name|countingIB
condition|)
block|{
if|if
condition|(
name|mAppliedIBSerial
operator|!=
name|countingIB
operator|->
name|getSerial
argument_list|()
condition|)
block|{
name|IndexBuffer9
modifier|*
name|indexBuffer
init|=
name|IndexBuffer9
operator|::
name|makeIndexBuffer9
argument_list|(
name|countingIB
operator|->
name|getIndexBuffer
argument_list|()
argument_list|)
decl_stmt|;
name|mDevice
operator|->
name|SetIndices
argument_list|(
name|indexBuffer
operator|->
name|getBuffer
argument_list|()
argument_list|)
expr_stmt|;
name|mAppliedIBSerial
operator|=
name|countingIB
operator|->
name|getSerial
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mRepeatDraw
condition|;
name|i
operator|++
control|)
block|{
name|mDevice
operator|->
name|DrawIndexedPrimitive
argument_list|(
name|mPrimitiveType
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|count
argument_list|,
literal|0
argument_list|,
name|mPrimitiveCount
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ERR
argument_list|(
literal|"Could not create a counting index buffer for glDrawArraysInstanced."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
else|else
comment|// Regular case
block|{
name|mDevice
operator|->
name|DrawPrimitive
argument_list|(
name|mPrimitiveType
argument_list|,
literal|0
argument_list|,
name|mPrimitiveCount
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|drawElements
name|void
name|Renderer9
operator|::
name|drawElements
parameter_list|(
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|gl
operator|::
name|Buffer
modifier|*
name|elementArrayBuffer
parameter_list|,
specifier|const
name|TranslatedIndexData
modifier|&
name|indexInfo
parameter_list|,
name|GLsizei
comment|/*instances*/
parameter_list|)
block|{
name|startScene
argument_list|()
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|GL_POINTS
condition|)
block|{
name|drawIndexedPoints
argument_list|(
name|count
argument_list|,
name|type
argument_list|,
name|indices
argument_list|,
name|elementArrayBuffer
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|GL_LINE_LOOP
condition|)
block|{
name|drawLineLoop
argument_list|(
name|count
argument_list|,
name|type
argument_list|,
name|indices
argument_list|,
name|indexInfo
operator|.
name|minIndex
argument_list|,
name|elementArrayBuffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mRepeatDraw
condition|;
name|i
operator|++
control|)
block|{
name|GLsizei
name|vertexCount
init|=
name|indexInfo
operator|.
name|maxIndex
operator|-
name|indexInfo
operator|.
name|minIndex
operator|+
literal|1
decl_stmt|;
name|mDevice
operator|->
name|DrawIndexedPrimitive
argument_list|(
name|mPrimitiveType
argument_list|,
operator|-
operator|(
name|INT
operator|)
name|indexInfo
operator|.
name|minIndex
argument_list|,
name|indexInfo
operator|.
name|minIndex
argument_list|,
name|vertexCount
argument_list|,
name|indexInfo
operator|.
name|startIndex
argument_list|,
name|mPrimitiveCount
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|drawLineLoop
name|void
name|Renderer9
operator|::
name|drawLineLoop
parameter_list|(
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|int
name|minIndex
parameter_list|,
name|gl
operator|::
name|Buffer
modifier|*
name|elementArrayBuffer
parameter_list|)
block|{
comment|// Get the raw indices for an indexed draw
if|if
condition|(
name|type
operator|!=
name|GL_NONE
operator|&&
name|elementArrayBuffer
condition|)
block|{
name|gl
operator|::
name|Buffer
modifier|*
name|indexBuffer
init|=
name|elementArrayBuffer
decl_stmt|;
name|BufferStorage
modifier|*
name|storage
init|=
name|indexBuffer
operator|->
name|getStorage
argument_list|()
decl_stmt|;
name|intptr_t
name|offset
init|=
cast|reinterpret_cast
argument_list|<
name|intptr_t
argument_list|>
argument_list|(
name|indices
argument_list|)
decl_stmt|;
name|indices
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLubyte
operator|*
argument_list|>
argument_list|(
name|storage
operator|->
name|getData
argument_list|()
argument_list|)
operator|+
name|offset
expr_stmt|;
block|}
name|UINT
name|startIndex
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|get32BitIndexSupport
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|mLineLoopIB
condition|)
block|{
name|mLineLoopIB
operator|=
operator|new
name|StreamingIndexBufferInterface
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mLineLoopIB
operator|->
name|reserveBufferSpace
argument_list|(
name|INITIAL_INDEX_BUFFER_SIZE
argument_list|,
name|GL_UNSIGNED_INT
argument_list|)
condition|)
block|{
operator|delete
name|mLineLoopIB
expr_stmt|;
name|mLineLoopIB
operator|=
name|NULL
expr_stmt|;
name|ERR
argument_list|(
literal|"Could not create a 32-bit looping index buffer for GL_LINE_LOOP."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
specifier|const
name|int
name|spaceNeeded
init|=
operator|(
name|count
operator|+
literal|1
operator|)
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|mLineLoopIB
operator|->
name|reserveBufferSpace
argument_list|(
name|spaceNeeded
argument_list|,
name|GL_UNSIGNED_INT
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not reserve enough space in looping index buffer for GL_LINE_LOOP."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
name|void
modifier|*
name|mappedMemory
init|=
name|NULL
decl_stmt|;
name|int
name|offset
init|=
name|mLineLoopIB
operator|->
name|mapBuffer
argument_list|(
name|spaceNeeded
argument_list|,
operator|&
name|mappedMemory
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|==
operator|-
literal|1
operator|||
name|mappedMemory
operator|==
name|NULL
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not map index buffer for GL_LINE_LOOP."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
name|startIndex
operator|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|offset
argument_list|)
operator|/
literal|4
expr_stmt|;
name|unsigned
name|int
modifier|*
name|data
init|=
cast|reinterpret_cast
argument_list|<
name|unsigned
name|int
operator|*
argument_list|>
argument_list|(
name|mappedMemory
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_NONE
case|:
comment|// Non-indexed draw
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
name|data
index|[
name|count
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_BYTE
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLubyte
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
index|]
expr_stmt|;
block|}
name|data
index|[
name|count
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLubyte
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_SHORT
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLushort
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
index|]
expr_stmt|;
block|}
name|data
index|[
name|count
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLushort
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_INT
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLuint
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
index|]
expr_stmt|;
block|}
name|data
index|[
name|count
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLuint
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mLineLoopIB
operator|->
name|unmapBuffer
argument_list|()
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not unmap index buffer for GL_LINE_LOOP."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|mLineLoopIB
condition|)
block|{
name|mLineLoopIB
operator|=
operator|new
name|StreamingIndexBufferInterface
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mLineLoopIB
operator|->
name|reserveBufferSpace
argument_list|(
name|INITIAL_INDEX_BUFFER_SIZE
argument_list|,
name|GL_UNSIGNED_SHORT
argument_list|)
condition|)
block|{
operator|delete
name|mLineLoopIB
expr_stmt|;
name|mLineLoopIB
operator|=
name|NULL
expr_stmt|;
name|ERR
argument_list|(
literal|"Could not create a 16-bit looping index buffer for GL_LINE_LOOP."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
specifier|const
name|int
name|spaceNeeded
init|=
operator|(
name|count
operator|+
literal|1
operator|)
operator|*
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|mLineLoopIB
operator|->
name|reserveBufferSpace
argument_list|(
name|spaceNeeded
argument_list|,
name|GL_UNSIGNED_SHORT
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not reserve enough space in looping index buffer for GL_LINE_LOOP."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
name|void
modifier|*
name|mappedMemory
init|=
name|NULL
decl_stmt|;
name|int
name|offset
init|=
name|mLineLoopIB
operator|->
name|mapBuffer
argument_list|(
name|spaceNeeded
argument_list|,
operator|&
name|mappedMemory
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|==
operator|-
literal|1
operator|||
name|mappedMemory
operator|==
name|NULL
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not map index buffer for GL_LINE_LOOP."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
name|startIndex
operator|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|offset
argument_list|)
operator|/
literal|2
expr_stmt|;
name|unsigned
name|short
modifier|*
name|data
init|=
cast|reinterpret_cast
argument_list|<
name|unsigned
name|short
operator|*
argument_list|>
argument_list|(
name|mappedMemory
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_NONE
case|:
comment|// Non-indexed draw
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
name|data
index|[
name|count
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_BYTE
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLubyte
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
index|]
expr_stmt|;
block|}
name|data
index|[
name|count
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLubyte
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_SHORT
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLushort
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
index|]
expr_stmt|;
block|}
name|data
index|[
name|count
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLushort
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_INT
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLuint
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
index|]
expr_stmt|;
block|}
name|data
index|[
name|count
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLuint
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mLineLoopIB
operator|->
name|unmapBuffer
argument_list|()
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not unmap index buffer for GL_LINE_LOOP."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|mAppliedIBSerial
operator|!=
name|mLineLoopIB
operator|->
name|getSerial
argument_list|()
condition|)
block|{
name|IndexBuffer9
modifier|*
name|indexBuffer
init|=
name|IndexBuffer9
operator|::
name|makeIndexBuffer9
argument_list|(
name|mLineLoopIB
operator|->
name|getIndexBuffer
argument_list|()
argument_list|)
decl_stmt|;
name|mDevice
operator|->
name|SetIndices
argument_list|(
name|indexBuffer
operator|->
name|getBuffer
argument_list|()
argument_list|)
expr_stmt|;
name|mAppliedIBSerial
operator|=
name|mLineLoopIB
operator|->
name|getSerial
argument_list|()
expr_stmt|;
block|}
name|mDevice
operator|->
name|DrawIndexedPrimitive
argument_list|(
name|D3DPT_LINESTRIP
argument_list|,
operator|-
name|minIndex
argument_list|,
name|minIndex
argument_list|,
name|count
argument_list|,
name|startIndex
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|drawPoints
specifier|static
name|void
name|drawPoints
parameter_list|(
name|IDirect3DDevice9
modifier|*
name|device
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|indexValue
init|=
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|T
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|device
operator|->
name|DrawPrimitive
argument_list|(
name|D3DPT_POINTLIST
argument_list|,
name|indexValue
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|drawIndexedPoints
name|void
name|Renderer9
operator|::
name|drawIndexedPoints
parameter_list|(
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|gl
operator|::
name|Buffer
modifier|*
name|elementArrayBuffer
parameter_list|)
block|{
comment|// Drawing index point lists is unsupported in d3d9, fall back to a regular DrawPrimitive call
comment|// for each individual point. This call is not expected to happen often.
if|if
condition|(
name|elementArrayBuffer
condition|)
block|{
name|BufferStorage
modifier|*
name|storage
init|=
name|elementArrayBuffer
operator|->
name|getStorage
argument_list|()
decl_stmt|;
name|intptr_t
name|offset
init|=
cast|reinterpret_cast
argument_list|<
name|intptr_t
argument_list|>
argument_list|(
name|indices
argument_list|)
decl_stmt|;
name|indices
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLubyte
operator|*
argument_list|>
argument_list|(
name|storage
operator|->
name|getData
argument_list|()
argument_list|)
operator|+
name|offset
expr_stmt|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_UNSIGNED_BYTE
case|:
name|drawPoints
argument_list|<
name|GLubyte
argument_list|>
argument_list|(
name|mDevice
argument_list|,
name|count
argument_list|,
name|indices
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_SHORT
case|:
name|drawPoints
argument_list|<
name|GLushort
argument_list|>
argument_list|(
name|mDevice
argument_list|,
name|count
argument_list|,
name|indices
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_INT
case|:
name|drawPoints
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|mDevice
argument_list|,
name|count
argument_list|,
name|indices
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|applyShaders
name|void
name|Renderer9
operator|::
name|applyShaders
parameter_list|(
name|gl
operator|::
name|ProgramBinary
modifier|*
name|programBinary
parameter_list|)
block|{
name|unsigned
name|int
name|programBinarySerial
init|=
name|programBinary
operator|->
name|getSerial
argument_list|()
decl_stmt|;
if|if
condition|(
name|programBinarySerial
operator|!=
name|mAppliedProgramBinarySerial
condition|)
block|{
name|ShaderExecutable
modifier|*
name|vertexExe
init|=
name|programBinary
operator|->
name|getVertexExecutable
argument_list|()
decl_stmt|;
name|ShaderExecutable
modifier|*
name|pixelExe
init|=
name|programBinary
operator|->
name|getPixelExecutable
argument_list|()
decl_stmt|;
name|IDirect3DVertexShader9
modifier|*
name|vertexShader
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|vertexExe
condition|)
name|vertexShader
operator|=
name|ShaderExecutable9
operator|::
name|makeShaderExecutable9
argument_list|(
name|vertexExe
argument_list|)
operator|->
name|getVertexShader
argument_list|()
expr_stmt|;
name|IDirect3DPixelShader9
modifier|*
name|pixelShader
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|pixelExe
condition|)
name|pixelShader
operator|=
name|ShaderExecutable9
operator|::
name|makeShaderExecutable9
argument_list|(
name|pixelExe
argument_list|)
operator|->
name|getPixelShader
argument_list|()
expr_stmt|;
name|mDevice
operator|->
name|SetPixelShader
argument_list|(
name|pixelShader
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetVertexShader
argument_list|(
name|vertexShader
argument_list|)
expr_stmt|;
name|programBinary
operator|->
name|dirtyAllUniforms
argument_list|()
expr_stmt|;
name|mDxUniformsDirty
operator|=
literal|true
expr_stmt|;
name|mAppliedProgramBinarySerial
operator|=
name|programBinarySerial
expr_stmt|;
block|}
block|}
DECL|function|applyUniforms
name|void
name|Renderer9
operator|::
name|applyUniforms
parameter_list|(
name|gl
operator|::
name|ProgramBinary
modifier|*
name|programBinary
parameter_list|,
name|gl
operator|::
name|UniformArray
modifier|*
name|uniformArray
parameter_list|)
block|{
for|for
control|(
name|std
operator|::
name|vector
argument_list|<
name|gl
operator|::
name|Uniform
operator|*
argument_list|>
operator|::
name|const_iterator
name|ub
init|=
name|uniformArray
operator|->
name|begin
argument_list|()
init|,
name|ue
init|=
name|uniformArray
operator|->
name|end
argument_list|()
init|;
name|ub
operator|!=
name|ue
condition|;
operator|++
name|ub
control|)
block|{
name|gl
operator|::
name|Uniform
modifier|*
name|targetUniform
init|=
operator|*
name|ub
decl_stmt|;
if|if
condition|(
name|targetUniform
operator|->
name|dirty
condition|)
block|{
name|GLfloat
modifier|*
name|f
init|=
operator|(
name|GLfloat
operator|*
operator|)
name|targetUniform
operator|->
name|data
decl_stmt|;
name|GLint
modifier|*
name|i
init|=
operator|(
name|GLint
operator|*
operator|)
name|targetUniform
operator|->
name|data
decl_stmt|;
switch|switch
condition|(
name|targetUniform
operator|->
name|type
condition|)
block|{
case|case
name|GL_SAMPLER_2D
case|:
case|case
name|GL_SAMPLER_CUBE
case|:
break|break;
case|case
name|GL_BOOL
case|:
case|case
name|GL_BOOL_VEC2
case|:
case|case
name|GL_BOOL_VEC3
case|:
case|case
name|GL_BOOL_VEC4
case|:
name|applyUniformnbv
argument_list|(
name|targetUniform
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_FLOAT
case|:
case|case
name|GL_FLOAT_VEC2
case|:
case|case
name|GL_FLOAT_VEC3
case|:
case|case
name|GL_FLOAT_VEC4
case|:
case|case
name|GL_FLOAT_MAT2
case|:
case|case
name|GL_FLOAT_MAT3
case|:
case|case
name|GL_FLOAT_MAT4
case|:
name|applyUniformnfv
argument_list|(
name|targetUniform
argument_list|,
name|f
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_INT
case|:
case|case
name|GL_INT_VEC2
case|:
case|case
name|GL_INT_VEC3
case|:
case|case
name|GL_INT_VEC4
case|:
name|applyUniformniv
argument_list|(
name|targetUniform
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
name|targetUniform
operator|->
name|dirty
operator|=
literal|false
expr_stmt|;
block|}
block|}
comment|// Driver uniforms
if|if
condition|(
name|mDxUniformsDirty
condition|)
block|{
name|mDevice
operator|->
name|SetVertexShaderConstantF
argument_list|(
literal|0
argument_list|,
operator|(
name|float
operator|*
operator|)
operator|&
name|mVertexConstants
argument_list|,
sizeof|sizeof
argument_list|(
name|dx_VertexConstants
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|float
index|[
literal|4
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetPixelShaderConstantF
argument_list|(
literal|0
argument_list|,
operator|(
name|float
operator|*
operator|)
operator|&
name|mPixelConstants
argument_list|,
sizeof|sizeof
argument_list|(
name|dx_PixelConstants
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|float
index|[
literal|4
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|mDxUniformsDirty
operator|=
literal|false
expr_stmt|;
block|}
block|}
DECL|function|applyUniformnfv
name|void
name|Renderer9
operator|::
name|applyUniformnfv
parameter_list|(
name|gl
operator|::
name|Uniform
modifier|*
name|targetUniform
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
name|targetUniform
operator|->
name|psRegisterIndex
operator|>=
literal|0
condition|)
block|{
name|mDevice
operator|->
name|SetPixelShaderConstantF
argument_list|(
name|targetUniform
operator|->
name|psRegisterIndex
argument_list|,
name|v
argument_list|,
name|targetUniform
operator|->
name|registerCount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targetUniform
operator|->
name|vsRegisterIndex
operator|>=
literal|0
condition|)
block|{
name|mDevice
operator|->
name|SetVertexShaderConstantF
argument_list|(
name|targetUniform
operator|->
name|vsRegisterIndex
argument_list|,
name|v
argument_list|,
name|targetUniform
operator|->
name|registerCount
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|applyUniformniv
name|void
name|Renderer9
operator|::
name|applyUniformniv
parameter_list|(
name|gl
operator|::
name|Uniform
modifier|*
name|targetUniform
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|targetUniform
operator|->
name|registerCount
operator|<=
name|MAX_VERTEX_CONSTANT_VECTORS_D3D9
argument_list|)
expr_stmt|;
name|GLfloat
name|vector
index|[
name|MAX_VERTEX_CONSTANT_VECTORS_D3D9
index|]
index|[
literal|4
index|]
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|targetUniform
operator|->
name|registerCount
condition|;
name|i
operator|++
control|)
block|{
name|vector
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
operator|(
name|GLfloat
operator|)
name|v
index|[
literal|4
operator|*
name|i
operator|+
literal|0
index|]
expr_stmt|;
name|vector
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
operator|(
name|GLfloat
operator|)
name|v
index|[
literal|4
operator|*
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|vector
index|[
name|i
index|]
index|[
literal|2
index|]
operator|=
operator|(
name|GLfloat
operator|)
name|v
index|[
literal|4
operator|*
name|i
operator|+
literal|2
index|]
expr_stmt|;
name|vector
index|[
name|i
index|]
index|[
literal|3
index|]
operator|=
operator|(
name|GLfloat
operator|)
name|v
index|[
literal|4
operator|*
name|i
operator|+
literal|3
index|]
expr_stmt|;
block|}
name|applyUniformnfv
argument_list|(
name|targetUniform
argument_list|,
operator|(
name|GLfloat
operator|*
operator|)
name|vector
argument_list|)
expr_stmt|;
block|}
DECL|function|applyUniformnbv
name|void
name|Renderer9
operator|::
name|applyUniformnbv
parameter_list|(
name|gl
operator|::
name|Uniform
modifier|*
name|targetUniform
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|targetUniform
operator|->
name|registerCount
operator|<=
name|MAX_VERTEX_CONSTANT_VECTORS_D3D9
argument_list|)
expr_stmt|;
name|GLfloat
name|vector
index|[
name|MAX_VERTEX_CONSTANT_VECTORS_D3D9
index|]
index|[
literal|4
index|]
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|targetUniform
operator|->
name|registerCount
condition|;
name|i
operator|++
control|)
block|{
name|vector
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
operator|(
name|v
index|[
literal|4
operator|*
name|i
operator|+
literal|0
index|]
operator|==
name|GL_FALSE
operator|)
condition|?
literal|0.0f
else|:
literal|1.0f
expr_stmt|;
name|vector
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
operator|(
name|v
index|[
literal|4
operator|*
name|i
operator|+
literal|1
index|]
operator|==
name|GL_FALSE
operator|)
condition|?
literal|0.0f
else|:
literal|1.0f
expr_stmt|;
name|vector
index|[
name|i
index|]
index|[
literal|2
index|]
operator|=
operator|(
name|v
index|[
literal|4
operator|*
name|i
operator|+
literal|2
index|]
operator|==
name|GL_FALSE
operator|)
condition|?
literal|0.0f
else|:
literal|1.0f
expr_stmt|;
name|vector
index|[
name|i
index|]
index|[
literal|3
index|]
operator|=
operator|(
name|v
index|[
literal|4
operator|*
name|i
operator|+
literal|3
index|]
operator|==
name|GL_FALSE
operator|)
condition|?
literal|0.0f
else|:
literal|1.0f
expr_stmt|;
block|}
name|applyUniformnfv
argument_list|(
name|targetUniform
argument_list|,
operator|(
name|GLfloat
operator|*
operator|)
name|vector
argument_list|)
expr_stmt|;
block|}
DECL|function|clear
name|void
name|Renderer9
operator|::
name|clear
parameter_list|(
specifier|const
name|gl
operator|::
name|ClearParameters
modifier|&
name|clearParams
parameter_list|,
name|gl
operator|::
name|Framebuffer
modifier|*
name|frameBuffer
parameter_list|)
block|{
name|D3DCOLOR
name|color
init|=
name|D3DCOLOR_ARGB
argument_list|(
name|gl
operator|::
name|unorm
argument_list|<
literal|8
argument_list|>
argument_list|(
name|clearParams
operator|.
name|colorClearValue
operator|.
name|alpha
argument_list|)
argument_list|,
name|gl
operator|::
name|unorm
argument_list|<
literal|8
argument_list|>
argument_list|(
name|clearParams
operator|.
name|colorClearValue
operator|.
name|red
argument_list|)
argument_list|,
name|gl
operator|::
name|unorm
argument_list|<
literal|8
argument_list|>
argument_list|(
name|clearParams
operator|.
name|colorClearValue
operator|.
name|green
argument_list|)
argument_list|,
name|gl
operator|::
name|unorm
argument_list|<
literal|8
argument_list|>
argument_list|(
name|clearParams
operator|.
name|colorClearValue
operator|.
name|blue
argument_list|)
argument_list|)
decl_stmt|;
name|float
name|depth
init|=
name|gl
operator|::
name|clamp01
argument_list|(
name|clearParams
operator|.
name|depthClearValue
argument_list|)
decl_stmt|;
name|int
name|stencil
init|=
name|clearParams
operator|.
name|stencilClearValue
operator|&
literal|0x000000FF
decl_stmt|;
name|unsigned
name|int
name|stencilUnmasked
init|=
literal|0x0
decl_stmt|;
if|if
condition|(
operator|(
name|clearParams
operator|.
name|mask
operator|&
name|GL_STENCIL_BUFFER_BIT
operator|)
operator|&&
name|frameBuffer
operator|->
name|hasStencil
argument_list|()
condition|)
block|{
name|unsigned
name|int
name|stencilSize
init|=
name|gl
operator|::
name|GetStencilSize
argument_list|(
name|frameBuffer
operator|->
name|getStencilbuffer
argument_list|()
operator|->
name|getActualFormat
argument_list|()
argument_list|)
decl_stmt|;
name|stencilUnmasked
operator|=
operator|(
literal|0x1
operator|<<
name|stencilSize
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|bool
name|alphaUnmasked
init|=
operator|(
name|gl
operator|::
name|GetAlphaSize
argument_list|(
name|mRenderTargetDesc
operator|.
name|format
argument_list|)
operator|==
literal|0
operator|)
operator|||
name|clearParams
operator|.
name|colorMaskAlpha
decl_stmt|;
specifier|const
name|bool
name|needMaskedStencilClear
init|=
operator|(
name|clearParams
operator|.
name|mask
operator|&
name|GL_STENCIL_BUFFER_BIT
operator|)
operator|&&
operator|(
name|clearParams
operator|.
name|stencilWriteMask
operator|&
name|stencilUnmasked
operator|)
operator|!=
name|stencilUnmasked
decl_stmt|;
specifier|const
name|bool
name|needMaskedColorClear
init|=
operator|(
name|clearParams
operator|.
name|mask
operator|&
name|GL_COLOR_BUFFER_BIT
operator|)
operator|&&
operator|!
operator|(
name|clearParams
operator|.
name|colorMaskRed
operator|&&
name|clearParams
operator|.
name|colorMaskGreen
operator|&&
name|clearParams
operator|.
name|colorMaskBlue
operator|&&
name|alphaUnmasked
operator|)
decl_stmt|;
if|if
condition|(
name|needMaskedColorClear
operator|||
name|needMaskedStencilClear
condition|)
block|{
comment|// State which is altered in all paths from this point to the clear call is saved.
comment|// State which is altered in only some paths will be flagged dirty in the case that
comment|//  that path is taken.
name|HRESULT
name|hr
decl_stmt|;
if|if
condition|(
name|mMaskedClearSavedState
operator|==
name|NULL
condition|)
block|{
name|hr
operator|=
name|mDevice
operator|->
name|BeginStateBlock
argument_list|()
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|hr
argument_list|)
operator|||
name|hr
operator|==
name|D3DERR_OUTOFVIDEOMEMORY
operator|||
name|hr
operator|==
name|E_OUTOFMEMORY
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ZWRITEENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ZFUNC
argument_list|,
name|D3DCMP_ALWAYS
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ZENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_CULLMODE
argument_list|,
name|D3DCULL_NONE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_FILLMODE
argument_list|,
name|D3DFILL_SOLID
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ALPHATESTENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ALPHABLENDENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_CLIPPLANEENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_COLORWRITEENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_STENCILENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetPixelShader
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetVertexShader
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetFVF
argument_list|(
name|D3DFVF_XYZRHW
operator||
name|D3DFVF_DIFFUSE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetStreamSource
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_SEPARATEALPHABLENDENABLE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetTextureStageState
argument_list|(
literal|0
argument_list|,
name|D3DTSS_COLOROP
argument_list|,
name|D3DTOP_SELECTARG1
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetTextureStageState
argument_list|(
literal|0
argument_list|,
name|D3DTSS_COLORARG1
argument_list|,
name|D3DTA_TFACTOR
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetTextureStageState
argument_list|(
literal|0
argument_list|,
name|D3DTSS_ALPHAOP
argument_list|,
name|D3DTOP_SELECTARG1
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetTextureStageState
argument_list|(
literal|0
argument_list|,
name|D3DTSS_ALPHAARG1
argument_list|,
name|D3DTA_TFACTOR
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_TEXTUREFACTOR
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_MULTISAMPLEMASK
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
condition|;
name|i
operator|++
control|)
block|{
name|mDevice
operator|->
name|SetStreamSourceFreq
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|hr
operator|=
name|mDevice
operator|->
name|EndStateBlock
argument_list|(
operator|&
name|mMaskedClearSavedState
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|hr
argument_list|)
operator|||
name|hr
operator|==
name|D3DERR_OUTOFVIDEOMEMORY
operator|||
name|hr
operator|==
name|E_OUTOFMEMORY
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|mMaskedClearSavedState
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mMaskedClearSavedState
operator|!=
name|NULL
condition|)
block|{
name|hr
operator|=
name|mMaskedClearSavedState
operator|->
name|Capture
argument_list|()
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|hr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ZWRITEENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ZFUNC
argument_list|,
name|D3DCMP_ALWAYS
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ZENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_CULLMODE
argument_list|,
name|D3DCULL_NONE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_FILLMODE
argument_list|,
name|D3DFILL_SOLID
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ALPHATESTENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ALPHABLENDENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_CLIPPLANEENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|clearParams
operator|.
name|mask
operator|&
name|GL_COLOR_BUFFER_BIT
condition|)
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_COLORWRITEENABLE
argument_list|,
name|gl_d3d9
operator|::
name|ConvertColorMask
argument_list|(
name|clearParams
operator|.
name|colorMaskRed
argument_list|,
name|clearParams
operator|.
name|colorMaskGreen
argument_list|,
name|clearParams
operator|.
name|colorMaskBlue
argument_list|,
name|clearParams
operator|.
name|colorMaskAlpha
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_COLORWRITEENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stencilUnmasked
operator|!=
literal|0x0
operator|&&
operator|(
name|clearParams
operator|.
name|mask
operator|&
name|GL_STENCIL_BUFFER_BIT
operator|)
condition|)
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_STENCILENABLE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_TWOSIDEDSTENCILMODE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_STENCILFUNC
argument_list|,
name|D3DCMP_ALWAYS
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_STENCILREF
argument_list|,
name|stencil
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_STENCILWRITEMASK
argument_list|,
name|clearParams
operator|.
name|stencilWriteMask
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_STENCILFAIL
argument_list|,
name|D3DSTENCILOP_REPLACE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_STENCILZFAIL
argument_list|,
name|D3DSTENCILOP_REPLACE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_STENCILPASS
argument_list|,
name|D3DSTENCILOP_REPLACE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_STENCILENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|mDevice
operator|->
name|SetPixelShader
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetVertexShader
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetFVF
argument_list|(
name|D3DFVF_XYZRHW
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_SEPARATEALPHABLENDENABLE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetTextureStageState
argument_list|(
literal|0
argument_list|,
name|D3DTSS_COLOROP
argument_list|,
name|D3DTOP_SELECTARG1
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetTextureStageState
argument_list|(
literal|0
argument_list|,
name|D3DTSS_COLORARG1
argument_list|,
name|D3DTA_TFACTOR
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetTextureStageState
argument_list|(
literal|0
argument_list|,
name|D3DTSS_ALPHAOP
argument_list|,
name|D3DTOP_SELECTARG1
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetTextureStageState
argument_list|(
literal|0
argument_list|,
name|D3DTSS_ALPHAARG1
argument_list|,
name|D3DTA_TFACTOR
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_TEXTUREFACTOR
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_MULTISAMPLEMASK
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
condition|;
name|i
operator|++
control|)
block|{
name|mDevice
operator|->
name|SetStreamSourceFreq
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|float
name|quad
index|[
literal|4
index|]
index|[
literal|4
index|]
decl_stmt|;
comment|// A quadrilateral covering the target, aligned to match the edges
name|quad
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
operator|-
literal|0.5f
expr_stmt|;
name|quad
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|mRenderTargetDesc
operator|.
name|height
operator|-
literal|0.5f
expr_stmt|;
name|quad
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
literal|0.0f
expr_stmt|;
name|quad
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|=
literal|1.0f
expr_stmt|;
name|quad
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|mRenderTargetDesc
operator|.
name|width
operator|-
literal|0.5f
expr_stmt|;
name|quad
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|mRenderTargetDesc
operator|.
name|height
operator|-
literal|0.5f
expr_stmt|;
name|quad
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
literal|0.0f
expr_stmt|;
name|quad
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|=
literal|1.0f
expr_stmt|;
name|quad
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
operator|-
literal|0.5f
expr_stmt|;
name|quad
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
operator|-
literal|0.5f
expr_stmt|;
name|quad
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
literal|0.0f
expr_stmt|;
name|quad
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|=
literal|1.0f
expr_stmt|;
name|quad
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
name|mRenderTargetDesc
operator|.
name|width
operator|-
literal|0.5f
expr_stmt|;
name|quad
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
operator|-
literal|0.5f
expr_stmt|;
name|quad
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|=
literal|0.0f
expr_stmt|;
name|quad
index|[
literal|3
index|]
index|[
literal|3
index|]
operator|=
literal|1.0f
expr_stmt|;
name|startScene
argument_list|()
expr_stmt|;
name|mDevice
operator|->
name|DrawPrimitiveUP
argument_list|(
name|D3DPT_TRIANGLESTRIP
argument_list|,
literal|2
argument_list|,
name|quad
argument_list|,
sizeof|sizeof
argument_list|(
name|float
index|[
literal|4
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|clearParams
operator|.
name|mask
operator|&
name|GL_DEPTH_BUFFER_BIT
condition|)
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ZENABLE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ZWRITEENABLE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|Clear
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|D3DCLEAR_ZBUFFER
argument_list|,
name|color
argument_list|,
name|depth
argument_list|,
name|stencil
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mMaskedClearSavedState
operator|!=
name|NULL
condition|)
block|{
name|mMaskedClearSavedState
operator|->
name|Apply
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|clearParams
operator|.
name|mask
condition|)
block|{
name|DWORD
name|dxClearFlags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|clearParams
operator|.
name|mask
operator|&
name|GL_COLOR_BUFFER_BIT
condition|)
block|{
name|dxClearFlags
operator||=
name|D3DCLEAR_TARGET
expr_stmt|;
block|}
if|if
condition|(
name|clearParams
operator|.
name|mask
operator|&
name|GL_DEPTH_BUFFER_BIT
condition|)
block|{
name|dxClearFlags
operator||=
name|D3DCLEAR_ZBUFFER
expr_stmt|;
block|}
if|if
condition|(
name|clearParams
operator|.
name|mask
operator|&
name|GL_STENCIL_BUFFER_BIT
condition|)
block|{
name|dxClearFlags
operator||=
name|D3DCLEAR_STENCIL
expr_stmt|;
block|}
name|mDevice
operator|->
name|Clear
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|dxClearFlags
argument_list|,
name|color
argument_list|,
name|depth
argument_list|,
name|stencil
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|markAllStateDirty
name|void
name|Renderer9
operator|::
name|markAllStateDirty
parameter_list|()
block|{
name|mAppliedRenderTargetSerial
operator|=
literal|0
expr_stmt|;
name|mAppliedDepthbufferSerial
operator|=
literal|0
expr_stmt|;
name|mAppliedStencilbufferSerial
operator|=
literal|0
expr_stmt|;
name|mDepthStencilInitialized
operator|=
literal|false
expr_stmt|;
name|mRenderTargetDescInitialized
operator|=
literal|false
expr_stmt|;
name|mForceSetDepthStencilState
operator|=
literal|true
expr_stmt|;
name|mForceSetRasterState
operator|=
literal|true
expr_stmt|;
name|mForceSetScissor
operator|=
literal|true
expr_stmt|;
name|mForceSetViewport
operator|=
literal|true
expr_stmt|;
name|mForceSetBlendState
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_VERTEX_TEXTURE_IMAGE_UNITS
condition|;
name|i
operator|++
control|)
block|{
name|mForceSetVertexSamplerStates
index|[
name|i
index|]
operator|=
literal|true
expr_stmt|;
name|mCurVertexTextureSerials
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|MAX_TEXTURE_IMAGE_UNITS
condition|;
name|i
operator|++
control|)
block|{
name|mForceSetPixelSamplerStates
index|[
name|i
index|]
operator|=
literal|true
expr_stmt|;
name|mCurPixelTextureSerials
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|mAppliedIBSerial
operator|=
literal|0
expr_stmt|;
name|mAppliedProgramBinarySerial
operator|=
literal|0
expr_stmt|;
name|mDxUniformsDirty
operator|=
literal|true
expr_stmt|;
name|mVertexDeclarationCache
operator|.
name|markStateDirty
argument_list|()
expr_stmt|;
block|}
DECL|function|releaseDeviceResources
name|void
name|Renderer9
operator|::
name|releaseDeviceResources
parameter_list|()
block|{
while|while
condition|(
operator|!
name|mEventQueryPool
operator|.
name|empty
argument_list|()
condition|)
block|{
name|mEventQueryPool
operator|.
name|back
argument_list|()
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mEventQueryPool
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|mMaskedClearSavedState
condition|)
block|{
name|mMaskedClearSavedState
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mMaskedClearSavedState
operator|=
name|NULL
expr_stmt|;
block|}
name|mVertexShaderCache
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mPixelShaderCache
operator|.
name|clear
argument_list|()
expr_stmt|;
operator|delete
name|mBlit
expr_stmt|;
name|mBlit
operator|=
name|NULL
expr_stmt|;
operator|delete
name|mVertexDataManager
expr_stmt|;
name|mVertexDataManager
operator|=
name|NULL
expr_stmt|;
operator|delete
name|mIndexDataManager
expr_stmt|;
name|mIndexDataManager
operator|=
name|NULL
expr_stmt|;
operator|delete
name|mLineLoopIB
expr_stmt|;
name|mLineLoopIB
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_NULL_COLORBUFFER_CACHE_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
operator|delete
name|mNullColorbufferCache
index|[
name|i
index|]
operator|.
name|buffer
expr_stmt|;
name|mNullColorbufferCache
index|[
name|i
index|]
operator|.
name|buffer
operator|=
name|NULL
expr_stmt|;
block|}
block|}
DECL|function|notifyDeviceLost
name|void
name|Renderer9
operator|::
name|notifyDeviceLost
parameter_list|()
block|{
name|mDeviceLost
operator|=
literal|true
expr_stmt|;
name|mDisplay
operator|->
name|notifyDeviceLost
argument_list|()
expr_stmt|;
block|}
DECL|function|isDeviceLost
name|bool
name|Renderer9
operator|::
name|isDeviceLost
parameter_list|()
block|{
return|return
name|mDeviceLost
return|;
block|}
comment|// set notify to true to broadcast a message to all contexts of the device loss
DECL|function|testDeviceLost
name|bool
name|Renderer9
operator|::
name|testDeviceLost
parameter_list|(
name|bool
name|notify
parameter_list|)
block|{
name|HRESULT
name|status
init|=
name|S_OK
decl_stmt|;
if|if
condition|(
name|mDeviceEx
condition|)
block|{
name|status
operator|=
name|mDeviceEx
operator|->
name|CheckDeviceState
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|S_PRESENT_MODE_CHANGED
condition|)
block|{
comment|// Reset the device so that D3D stops reporting S_PRESENT_MODE_CHANGED. Otherwise it will report
comment|// it continuously, potentially masking a lost device. D3D resources are not lost on a mode change with WDDM.
name|D3DPRESENT_PARAMETERS
name|presentParameters
init|=
name|getDefaultPresentParameters
argument_list|()
decl_stmt|;
name|mDeviceEx
operator|->
name|Reset
argument_list|(
operator|&
name|presentParameters
argument_list|)
expr_stmt|;
comment|// Existing swap chains sometimes crash on the next present after a reset.
name|mDisplay
operator|->
name|recreateSwapChains
argument_list|()
expr_stmt|;
comment|// Reset will not always cause the device loss to be reported so issue a dummy present.
name|mDeviceEx
operator|->
name|Present
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|// Retest the device status to see if the mode change really indicated a lost device.
name|status
operator|=
name|mDeviceEx
operator|->
name|CheckDeviceState
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mDevice
condition|)
block|{
name|status
operator|=
name|mDevice
operator|->
name|TestCooperativeLevel
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// No device yet, so no reset required
block|}
name|bool
name|isLost
init|=
name|FAILED
argument_list|(
name|status
argument_list|)
operator|||
name|d3d9
operator|::
name|isDeviceLostError
argument_list|(
name|status
argument_list|)
decl_stmt|;
if|if
condition|(
name|isLost
condition|)
block|{
comment|// ensure we note the device loss --
comment|// we'll probably get this done again by notifyDeviceLost
comment|// but best to remember it!
comment|// Note that we don't want to clear the device loss status here
comment|// -- this needs to be done by resetDevice
name|mDeviceLost
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|notify
condition|)
block|{
name|notifyDeviceLost
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|isLost
return|;
block|}
DECL|function|testDeviceResettable
name|bool
name|Renderer9
operator|::
name|testDeviceResettable
parameter_list|()
block|{
name|HRESULT
name|status
init|=
name|D3D_OK
decl_stmt|;
if|if
condition|(
name|mDeviceEx
condition|)
block|{
name|status
operator|=
name|mDeviceEx
operator|->
name|CheckDeviceState
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mDevice
condition|)
block|{
name|status
operator|=
name|mDevice
operator|->
name|TestCooperativeLevel
argument_list|()
expr_stmt|;
block|}
comment|// On D3D9Ex, DEVICELOST represents a hung device that needs to be restarted
comment|// DEVICEREMOVED indicates the device has been stopped and must be recreated
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|D3DERR_DEVICENOTRESET
case|:
case|case
name|D3DERR_DEVICEHUNG
case|:
return|return
literal|true
return|;
case|case
name|D3DERR_DEVICELOST
case|:
return|return
operator|(
name|mDeviceEx
operator|!=
name|NULL
operator|)
return|;
case|case
name|D3DERR_DEVICEREMOVED
case|:
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
DECL|function|resetDevice
name|bool
name|Renderer9
operator|::
name|resetDevice
parameter_list|()
block|{
name|releaseDeviceResources
argument_list|()
expr_stmt|;
name|D3DPRESENT_PARAMETERS
name|presentParameters
init|=
name|getDefaultPresentParameters
argument_list|()
decl_stmt|;
name|HRESULT
name|result
init|=
name|D3D_OK
decl_stmt|;
name|bool
name|lost
init|=
name|testDeviceLost
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|int
name|attempts
init|=
literal|3
decl_stmt|;
while|while
condition|(
name|lost
operator|&&
name|attempts
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|mDeviceEx
condition|)
block|{
name|Sleep
argument_list|(
literal|500
argument_list|)
expr_stmt|;
comment|// Give the graphics driver some CPU time
name|result
operator|=
name|mDeviceEx
operator|->
name|ResetEx
argument_list|(
operator|&
name|presentParameters
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|mDevice
operator|->
name|TestCooperativeLevel
argument_list|()
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|D3DERR_DEVICELOST
condition|)
block|{
name|Sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|// Give the graphics driver some CPU time
name|result
operator|=
name|mDevice
operator|->
name|TestCooperativeLevel
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|D3DERR_DEVICENOTRESET
condition|)
block|{
name|result
operator|=
name|mDevice
operator|->
name|Reset
argument_list|(
operator|&
name|presentParameters
argument_list|)
expr_stmt|;
block|}
block|}
name|lost
operator|=
name|testDeviceLost
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|attempts
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Reset/ResetEx failed multiple times: 0x%08X"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// reset device defaults
name|initializeDevice
argument_list|()
expr_stmt|;
name|mDeviceLost
operator|=
literal|false
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|getAdapterVendor
name|DWORD
name|Renderer9
operator|::
name|getAdapterVendor
parameter_list|()
specifier|const
block|{
return|return
name|mAdapterIdentifier
operator|.
name|VendorId
return|;
block|}
DECL|function|getRendererDescription
name|std
operator|::
name|string
name|Renderer9
operator|::
name|getRendererDescription
parameter_list|()
specifier|const
block|{
name|std
operator|::
name|ostringstream
name|rendererString
decl_stmt|;
name|rendererString
operator|<<
name|mAdapterIdentifier
operator|.
name|Description
expr_stmt|;
if|if
condition|(
name|getShareHandleSupport
argument_list|()
condition|)
block|{
name|rendererString
operator|<<
literal|" Direct3D9Ex"
expr_stmt|;
block|}
else|else
block|{
name|rendererString
operator|<<
literal|" Direct3D9"
expr_stmt|;
block|}
name|rendererString
operator|<<
literal|" vs_"
operator|<<
name|D3DSHADER_VERSION_MAJOR
argument_list|(
name|mDeviceCaps
operator|.
name|VertexShaderVersion
argument_list|)
operator|<<
literal|"_"
operator|<<
name|D3DSHADER_VERSION_MINOR
argument_list|(
name|mDeviceCaps
operator|.
name|VertexShaderVersion
argument_list|)
expr_stmt|;
name|rendererString
operator|<<
literal|" ps_"
operator|<<
name|D3DSHADER_VERSION_MAJOR
argument_list|(
name|mDeviceCaps
operator|.
name|PixelShaderVersion
argument_list|)
operator|<<
literal|"_"
operator|<<
name|D3DSHADER_VERSION_MINOR
argument_list|(
name|mDeviceCaps
operator|.
name|PixelShaderVersion
argument_list|)
expr_stmt|;
return|return
name|rendererString
operator|.
name|str
argument_list|()
return|;
block|}
DECL|function|getAdapterIdentifier
name|GUID
name|Renderer9
operator|::
name|getAdapterIdentifier
parameter_list|()
specifier|const
block|{
return|return
name|mAdapterIdentifier
operator|.
name|DeviceIdentifier
return|;
block|}
DECL|function|getMultiSampleSupport
name|void
name|Renderer9
operator|::
name|getMultiSampleSupport
parameter_list|(
name|D3DFORMAT
name|format
parameter_list|,
name|bool
modifier|*
name|multiSampleArray
parameter_list|)
block|{
for|for
control|(
name|int
name|multiSampleIndex
init|=
literal|0
init|;
name|multiSampleIndex
operator|<=
name|D3DMULTISAMPLE_16_SAMPLES
condition|;
name|multiSampleIndex
operator|++
control|)
block|{
name|HRESULT
name|result
init|=
name|mD3d9
operator|->
name|CheckDeviceMultiSampleType
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|format
argument_list|,
name|TRUE
argument_list|,
operator|(
name|D3DMULTISAMPLE_TYPE
operator|)
name|multiSampleIndex
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|multiSampleArray
index|[
name|multiSampleIndex
index|]
operator|=
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|getBGRATextureSupport
name|bool
name|Renderer9
operator|::
name|getBGRATextureSupport
parameter_list|()
specifier|const
block|{
comment|// DirectX 9 always supports BGRA
return|return
literal|true
return|;
block|}
DECL|function|getDXT1TextureSupport
name|bool
name|Renderer9
operator|::
name|getDXT1TextureSupport
parameter_list|()
block|{
return|return
name|mDXT1TextureSupport
return|;
block|}
DECL|function|getDXT3TextureSupport
name|bool
name|Renderer9
operator|::
name|getDXT3TextureSupport
parameter_list|()
block|{
return|return
name|mDXT3TextureSupport
return|;
block|}
DECL|function|getDXT5TextureSupport
name|bool
name|Renderer9
operator|::
name|getDXT5TextureSupport
parameter_list|()
block|{
return|return
name|mDXT5TextureSupport
return|;
block|}
DECL|function|getDepthTextureSupport
name|bool
name|Renderer9
operator|::
name|getDepthTextureSupport
parameter_list|()
specifier|const
block|{
return|return
name|mDepthTextureSupport
return|;
block|}
DECL|function|getFloat32TextureSupport
name|bool
name|Renderer9
operator|::
name|getFloat32TextureSupport
parameter_list|(
name|bool
modifier|*
name|filtering
parameter_list|,
name|bool
modifier|*
name|renderable
parameter_list|)
block|{
operator|*
name|filtering
operator|=
name|mFloat32FilterSupport
expr_stmt|;
operator|*
name|renderable
operator|=
name|mFloat32RenderSupport
expr_stmt|;
return|return
name|mFloat32TextureSupport
return|;
block|}
DECL|function|getFloat16TextureSupport
name|bool
name|Renderer9
operator|::
name|getFloat16TextureSupport
parameter_list|(
name|bool
modifier|*
name|filtering
parameter_list|,
name|bool
modifier|*
name|renderable
parameter_list|)
block|{
operator|*
name|filtering
operator|=
name|mFloat16FilterSupport
expr_stmt|;
operator|*
name|renderable
operator|=
name|mFloat16RenderSupport
expr_stmt|;
return|return
name|mFloat16TextureSupport
return|;
block|}
DECL|function|getLuminanceTextureSupport
name|bool
name|Renderer9
operator|::
name|getLuminanceTextureSupport
parameter_list|()
block|{
return|return
name|mLuminanceTextureSupport
return|;
block|}
DECL|function|getLuminanceAlphaTextureSupport
name|bool
name|Renderer9
operator|::
name|getLuminanceAlphaTextureSupport
parameter_list|()
block|{
return|return
name|mLuminanceAlphaTextureSupport
return|;
block|}
DECL|function|getTextureFilterAnisotropySupport
name|bool
name|Renderer9
operator|::
name|getTextureFilterAnisotropySupport
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsTextureFilterAnisotropy
return|;
block|}
DECL|function|getTextureMaxAnisotropy
name|float
name|Renderer9
operator|::
name|getTextureMaxAnisotropy
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|mSupportsTextureFilterAnisotropy
condition|)
block|{
return|return
cast|static_cast
argument_list|<
name|float
argument_list|>
argument_list|(
name|mDeviceCaps
operator|.
name|MaxAnisotropy
argument_list|)
return|;
block|}
return|return
literal|1.0f
return|;
block|}
DECL|function|getEventQuerySupport
name|bool
name|Renderer9
operator|::
name|getEventQuerySupport
parameter_list|()
block|{
return|return
name|mEventQuerySupport
return|;
block|}
DECL|function|getMaxVertexTextureImageUnits
name|unsigned
name|int
name|Renderer9
operator|::
name|getMaxVertexTextureImageUnits
parameter_list|()
specifier|const
block|{
name|META_ASSERT
argument_list|(
name|MAX_TEXTURE_IMAGE_UNITS_VTF_SM3
operator|<=
name|gl
operator|::
name|IMPLEMENTATION_MAX_VERTEX_TEXTURE_IMAGE_UNITS
argument_list|)
expr_stmt|;
return|return
name|mVertexTextureSupport
condition|?
name|MAX_TEXTURE_IMAGE_UNITS_VTF_SM3
else|:
literal|0
return|;
block|}
DECL|function|getMaxCombinedTextureImageUnits
name|unsigned
name|int
name|Renderer9
operator|::
name|getMaxCombinedTextureImageUnits
parameter_list|()
specifier|const
block|{
return|return
name|gl
operator|::
name|MAX_TEXTURE_IMAGE_UNITS
operator|+
name|getMaxVertexTextureImageUnits
argument_list|()
return|;
block|}
DECL|function|getReservedVertexUniformVectors
name|unsigned
name|int
name|Renderer9
operator|::
name|getReservedVertexUniformVectors
parameter_list|()
specifier|const
block|{
return|return
literal|2
return|;
comment|// dx_ViewAdjust and dx_DepthRange.
block|}
DECL|function|getReservedFragmentUniformVectors
name|unsigned
name|int
name|Renderer9
operator|::
name|getReservedFragmentUniformVectors
parameter_list|()
specifier|const
block|{
return|return
literal|3
return|;
comment|// dx_ViewCoords, dx_DepthFront and dx_DepthRange.
block|}
DECL|function|getMaxVertexUniformVectors
name|unsigned
name|int
name|Renderer9
operator|::
name|getMaxVertexUniformVectors
parameter_list|()
specifier|const
block|{
return|return
name|MAX_VERTEX_CONSTANT_VECTORS_D3D9
operator|-
name|getReservedVertexUniformVectors
argument_list|()
return|;
block|}
DECL|function|getMaxFragmentUniformVectors
name|unsigned
name|int
name|Renderer9
operator|::
name|getMaxFragmentUniformVectors
parameter_list|()
specifier|const
block|{
specifier|const
name|int
name|maxPixelConstantVectors
init|=
operator|(
name|getMajorShaderModel
argument_list|()
operator|>=
literal|3
operator|)
condition|?
name|MAX_PIXEL_CONSTANT_VECTORS_SM3
else|:
name|MAX_PIXEL_CONSTANT_VECTORS_SM2
decl_stmt|;
return|return
name|maxPixelConstantVectors
operator|-
name|getReservedFragmentUniformVectors
argument_list|()
return|;
block|}
DECL|function|getMaxVaryingVectors
name|unsigned
name|int
name|Renderer9
operator|::
name|getMaxVaryingVectors
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|getMajorShaderModel
argument_list|()
operator|>=
literal|3
operator|)
condition|?
name|MAX_VARYING_VECTORS_SM3
else|:
name|MAX_VARYING_VECTORS_SM2
return|;
block|}
DECL|function|getNonPower2TextureSupport
name|bool
name|Renderer9
operator|::
name|getNonPower2TextureSupport
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsNonPower2Textures
return|;
block|}
DECL|function|getOcclusionQuerySupport
name|bool
name|Renderer9
operator|::
name|getOcclusionQuerySupport
parameter_list|()
specifier|const
block|{
return|return
name|mOcclusionQuerySupport
return|;
block|}
DECL|function|getInstancingSupport
name|bool
name|Renderer9
operator|::
name|getInstancingSupport
parameter_list|()
specifier|const
block|{
return|return
name|mDeviceCaps
operator|.
name|PixelShaderVersion
operator|>=
name|D3DPS_VERSION
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
return|;
block|}
DECL|function|getShareHandleSupport
name|bool
name|Renderer9
operator|::
name|getShareHandleSupport
parameter_list|()
specifier|const
block|{
comment|// PIX doesn't seem to support using share handles, so disable them.
return|return
operator|(
name|mD3d9Ex
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|gl
operator|::
name|perfActive
argument_list|()
return|;
block|}
DECL|function|getDerivativeInstructionSupport
name|bool
name|Renderer9
operator|::
name|getDerivativeInstructionSupport
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|mDeviceCaps
operator|.
name|PS20Caps
operator|.
name|Caps
operator|&
name|D3DPS20CAPS_GRADIENTINSTRUCTIONS
operator|)
operator|!=
literal|0
return|;
block|}
DECL|function|getPostSubBufferSupport
name|bool
name|Renderer9
operator|::
name|getPostSubBufferSupport
parameter_list|()
specifier|const
block|{
return|return
literal|true
return|;
block|}
DECL|function|getMajorShaderModel
name|int
name|Renderer9
operator|::
name|getMajorShaderModel
parameter_list|()
specifier|const
block|{
return|return
name|D3DSHADER_VERSION_MAJOR
argument_list|(
name|mDeviceCaps
operator|.
name|PixelShaderVersion
argument_list|)
return|;
block|}
DECL|function|getMaxPointSize
name|float
name|Renderer9
operator|::
name|getMaxPointSize
parameter_list|()
specifier|const
block|{
comment|// Point size clamped at 1.0f for SM2
return|return
name|getMajorShaderModel
argument_list|()
operator|==
literal|3
condition|?
name|mDeviceCaps
operator|.
name|MaxPointSize
else|:
literal|1.0f
return|;
block|}
DECL|function|getMaxViewportDimension
name|int
name|Renderer9
operator|::
name|getMaxViewportDimension
parameter_list|()
specifier|const
block|{
name|int
name|maxTextureDimension
init|=
name|std
operator|::
name|min
argument_list|(
name|std
operator|::
name|min
argument_list|(
name|getMaxTextureWidth
argument_list|()
argument_list|,
name|getMaxTextureHeight
argument_list|()
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_SIZE
argument_list|)
decl_stmt|;
return|return
name|maxTextureDimension
return|;
block|}
DECL|function|getMaxTextureWidth
name|int
name|Renderer9
operator|::
name|getMaxTextureWidth
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|int
operator|)
name|mDeviceCaps
operator|.
name|MaxTextureWidth
return|;
block|}
DECL|function|getMaxTextureHeight
name|int
name|Renderer9
operator|::
name|getMaxTextureHeight
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|int
operator|)
name|mDeviceCaps
operator|.
name|MaxTextureHeight
return|;
block|}
DECL|function|get32BitIndexSupport
name|bool
name|Renderer9
operator|::
name|get32BitIndexSupport
parameter_list|()
specifier|const
block|{
return|return
name|mDeviceCaps
operator|.
name|MaxVertexIndex
operator|>=
operator|(
literal|1
operator|<<
literal|16
operator|)
return|;
block|}
DECL|function|getCapsDeclTypes
name|DWORD
name|Renderer9
operator|::
name|getCapsDeclTypes
parameter_list|()
specifier|const
block|{
return|return
name|mDeviceCaps
operator|.
name|DeclTypes
return|;
block|}
DECL|function|getMinSwapInterval
name|int
name|Renderer9
operator|::
name|getMinSwapInterval
parameter_list|()
specifier|const
block|{
return|return
name|mMinSwapInterval
return|;
block|}
DECL|function|getMaxSwapInterval
name|int
name|Renderer9
operator|::
name|getMaxSwapInterval
parameter_list|()
specifier|const
block|{
return|return
name|mMaxSwapInterval
return|;
block|}
DECL|function|getMaxSupportedSamples
name|int
name|Renderer9
operator|::
name|getMaxSupportedSamples
parameter_list|()
specifier|const
block|{
return|return
name|mMaxSupportedSamples
return|;
block|}
DECL|function|getNearestSupportedSamples
name|int
name|Renderer9
operator|::
name|getNearestSupportedSamples
parameter_list|(
name|D3DFORMAT
name|format
parameter_list|,
name|int
name|requested
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|requested
operator|==
literal|0
condition|)
block|{
return|return
name|requested
return|;
block|}
name|std
operator|::
name|map
argument_list|<
name|D3DFORMAT
argument_list|,
name|bool
modifier|*
argument_list|>
operator|::
name|const_iterator
name|itr
init|=
name|mMultiSampleSupport
operator|.
name|find
argument_list|(
name|format
argument_list|)
decl_stmt|;
if|if
condition|(
name|itr
operator|==
name|mMultiSampleSupport
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|format
operator|==
name|D3DFMT_UNKNOWN
condition|)
return|return
literal|0
return|;
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|int
name|i
init|=
name|requested
init|;
name|i
operator|<=
name|D3DMULTISAMPLE_16_SAMPLES
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|itr
operator|->
name|second
index|[
name|i
index|]
operator|&&
name|i
operator|!=
name|D3DMULTISAMPLE_NONMASKABLE
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
DECL|function|getMaxRenderTargets
name|unsigned
name|int
name|Renderer9
operator|::
name|getMaxRenderTargets
parameter_list|()
specifier|const
block|{
comment|// we do not support MRT in d3d9
return|return
literal|1
return|;
block|}
DECL|function|ConvertTextureInternalFormat
name|D3DFORMAT
name|Renderer9
operator|::
name|ConvertTextureInternalFormat
parameter_list|(
name|GLint
name|internalformat
parameter_list|)
block|{
switch|switch
condition|(
name|internalformat
condition|)
block|{
case|case
name|GL_DEPTH_COMPONENT16
case|:
case|case
name|GL_DEPTH_COMPONENT32_OES
case|:
case|case
name|GL_DEPTH24_STENCIL8_OES
case|:
return|return
name|D3DFMT_INTZ
return|;
case|case
name|GL_COMPRESSED_RGB_S3TC_DXT1_EXT
case|:
case|case
name|GL_COMPRESSED_RGBA_S3TC_DXT1_EXT
case|:
return|return
name|D3DFMT_DXT1
return|;
case|case
name|GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE
case|:
return|return
name|D3DFMT_DXT3
return|;
case|case
name|GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE
case|:
return|return
name|D3DFMT_DXT5
return|;
case|case
name|GL_RGBA32F_EXT
case|:
case|case
name|GL_RGB32F_EXT
case|:
case|case
name|GL_ALPHA32F_EXT
case|:
case|case
name|GL_LUMINANCE32F_EXT
case|:
case|case
name|GL_LUMINANCE_ALPHA32F_EXT
case|:
return|return
name|D3DFMT_A32B32G32R32F
return|;
case|case
name|GL_RGBA16F_EXT
case|:
case|case
name|GL_RGB16F_EXT
case|:
case|case
name|GL_ALPHA16F_EXT
case|:
case|case
name|GL_LUMINANCE16F_EXT
case|:
case|case
name|GL_LUMINANCE_ALPHA16F_EXT
case|:
return|return
name|D3DFMT_A16B16G16R16F
return|;
case|case
name|GL_LUMINANCE8_EXT
case|:
if|if
condition|(
name|getLuminanceTextureSupport
argument_list|()
condition|)
block|{
return|return
name|D3DFMT_L8
return|;
block|}
break|break;
case|case
name|GL_LUMINANCE8_ALPHA8_EXT
case|:
if|if
condition|(
name|getLuminanceAlphaTextureSupport
argument_list|()
condition|)
block|{
return|return
name|D3DFMT_A8L8
return|;
block|}
break|break;
case|case
name|GL_RGB8_OES
case|:
case|case
name|GL_RGB565
case|:
return|return
name|D3DFMT_X8R8G8B8
return|;
block|}
return|return
name|D3DFMT_A8R8G8B8
return|;
block|}
DECL|function|copyToRenderTarget
name|bool
name|Renderer9
operator|::
name|copyToRenderTarget
parameter_list|(
name|TextureStorageInterface2D
modifier|*
name|dest
parameter_list|,
name|TextureStorageInterface2D
modifier|*
name|source
parameter_list|)
block|{
name|bool
name|result
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|source
operator|&&
name|dest
condition|)
block|{
name|TextureStorage9_2D
modifier|*
name|source9
init|=
name|TextureStorage9_2D
operator|::
name|makeTextureStorage9_2D
argument_list|(
name|source
operator|->
name|getStorageInstance
argument_list|()
argument_list|)
decl_stmt|;
name|TextureStorage9_2D
modifier|*
name|dest9
init|=
name|TextureStorage9_2D
operator|::
name|makeTextureStorage9_2D
argument_list|(
name|dest
operator|->
name|getStorageInstance
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|levels
init|=
name|source9
operator|->
name|levelCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|levels
condition|;
operator|++
name|i
control|)
block|{
name|IDirect3DSurface9
modifier|*
name|srcSurf
init|=
name|source9
operator|->
name|getSurfaceLevel
argument_list|(
name|i
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|IDirect3DSurface9
modifier|*
name|dstSurf
init|=
name|dest9
operator|->
name|getSurfaceLevel
argument_list|(
name|i
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|result
operator|=
name|copyToRenderTarget
argument_list|(
name|dstSurf
argument_list|,
name|srcSurf
argument_list|,
name|source9
operator|->
name|isManaged
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|srcSurf
condition|)
name|srcSurf
operator|->
name|Release
argument_list|()
expr_stmt|;
if|if
condition|(
name|dstSurf
condition|)
name|dstSurf
operator|->
name|Release
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
return|return
literal|false
return|;
block|}
block|}
return|return
name|result
return|;
block|}
DECL|function|copyToRenderTarget
name|bool
name|Renderer9
operator|::
name|copyToRenderTarget
parameter_list|(
name|TextureStorageInterfaceCube
modifier|*
name|dest
parameter_list|,
name|TextureStorageInterfaceCube
modifier|*
name|source
parameter_list|)
block|{
name|bool
name|result
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|source
operator|&&
name|dest
condition|)
block|{
name|TextureStorage9_Cube
modifier|*
name|source9
init|=
name|TextureStorage9_Cube
operator|::
name|makeTextureStorage9_Cube
argument_list|(
name|source
operator|->
name|getStorageInstance
argument_list|()
argument_list|)
decl_stmt|;
name|TextureStorage9_Cube
modifier|*
name|dest9
init|=
name|TextureStorage9_Cube
operator|::
name|makeTextureStorage9_Cube
argument_list|(
name|dest
operator|->
name|getStorageInstance
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|levels
init|=
name|source9
operator|->
name|levelCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|f
init|=
literal|0
init|;
name|f
operator|<
literal|6
condition|;
name|f
operator|++
control|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|levels
condition|;
name|i
operator|++
control|)
block|{
name|IDirect3DSurface9
modifier|*
name|srcSurf
init|=
name|source9
operator|->
name|getCubeMapSurface
argument_list|(
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
operator|+
name|f
argument_list|,
name|i
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|IDirect3DSurface9
modifier|*
name|dstSurf
init|=
name|dest9
operator|->
name|getCubeMapSurface
argument_list|(
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
operator|+
name|f
argument_list|,
name|i
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|result
operator|=
name|copyToRenderTarget
argument_list|(
name|dstSurf
argument_list|,
name|srcSurf
argument_list|,
name|source9
operator|->
name|isManaged
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|srcSurf
condition|)
name|srcSurf
operator|->
name|Release
argument_list|()
expr_stmt|;
if|if
condition|(
name|dstSurf
condition|)
name|dstSurf
operator|->
name|Release
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
DECL|function|getBufferPool
name|D3DPOOL
name|Renderer9
operator|::
name|getBufferPool
parameter_list|(
name|DWORD
name|usage
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|mD3d9Ex
operator|!=
name|NULL
condition|)
block|{
return|return
name|D3DPOOL_DEFAULT
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|usage
operator|&
name|D3DUSAGE_DYNAMIC
operator|)
condition|)
block|{
return|return
name|D3DPOOL_MANAGED
return|;
block|}
block|}
return|return
name|D3DPOOL_DEFAULT
return|;
block|}
DECL|function|copyImage
name|bool
name|Renderer9
operator|::
name|copyImage
parameter_list|(
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|sourceRect
parameter_list|,
name|GLenum
name|destFormat
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|TextureStorageInterface2D
modifier|*
name|storage
parameter_list|,
name|GLint
name|level
parameter_list|)
block|{
name|RECT
name|rect
decl_stmt|;
name|rect
operator|.
name|left
operator|=
name|sourceRect
operator|.
name|x
expr_stmt|;
name|rect
operator|.
name|top
operator|=
name|sourceRect
operator|.
name|y
expr_stmt|;
name|rect
operator|.
name|right
operator|=
name|sourceRect
operator|.
name|x
operator|+
name|sourceRect
operator|.
name|width
expr_stmt|;
name|rect
operator|.
name|bottom
operator|=
name|sourceRect
operator|.
name|y
operator|+
name|sourceRect
operator|.
name|height
expr_stmt|;
return|return
name|mBlit
operator|->
name|copy
argument_list|(
name|framebuffer
argument_list|,
name|rect
argument_list|,
name|destFormat
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|storage
argument_list|,
name|level
argument_list|)
return|;
block|}
DECL|function|copyImage
name|bool
name|Renderer9
operator|::
name|copyImage
parameter_list|(
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|sourceRect
parameter_list|,
name|GLenum
name|destFormat
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|TextureStorageInterfaceCube
modifier|*
name|storage
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|)
block|{
name|RECT
name|rect
decl_stmt|;
name|rect
operator|.
name|left
operator|=
name|sourceRect
operator|.
name|x
expr_stmt|;
name|rect
operator|.
name|top
operator|=
name|sourceRect
operator|.
name|y
expr_stmt|;
name|rect
operator|.
name|right
operator|=
name|sourceRect
operator|.
name|x
operator|+
name|sourceRect
operator|.
name|width
expr_stmt|;
name|rect
operator|.
name|bottom
operator|=
name|sourceRect
operator|.
name|y
operator|+
name|sourceRect
operator|.
name|height
expr_stmt|;
return|return
name|mBlit
operator|->
name|copy
argument_list|(
name|framebuffer
argument_list|,
name|rect
argument_list|,
name|destFormat
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|storage
argument_list|,
name|target
argument_list|,
name|level
argument_list|)
return|;
block|}
DECL|function|blitRect
name|bool
name|Renderer9
operator|::
name|blitRect
parameter_list|(
name|gl
operator|::
name|Framebuffer
modifier|*
name|readFramebuffer
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|readRect
parameter_list|,
name|gl
operator|::
name|Framebuffer
modifier|*
name|drawFramebuffer
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|drawRect
parameter_list|,
name|bool
name|blitRenderTarget
parameter_list|,
name|bool
name|blitDepthStencil
parameter_list|)
block|{
name|endScene
argument_list|()
expr_stmt|;
if|if
condition|(
name|blitRenderTarget
condition|)
block|{
name|gl
operator|::
name|Renderbuffer
modifier|*
name|readBuffer
init|=
name|readFramebuffer
operator|->
name|getColorbuffer
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Renderbuffer
modifier|*
name|drawBuffer
init|=
name|drawFramebuffer
operator|->
name|getColorbuffer
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RenderTarget9
modifier|*
name|readRenderTarget
init|=
name|NULL
decl_stmt|;
name|RenderTarget9
modifier|*
name|drawRenderTarget
init|=
name|NULL
decl_stmt|;
name|IDirect3DSurface9
modifier|*
name|readSurface
init|=
name|NULL
decl_stmt|;
name|IDirect3DSurface9
modifier|*
name|drawSurface
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|readBuffer
condition|)
block|{
name|readRenderTarget
operator|=
name|RenderTarget9
operator|::
name|makeRenderTarget9
argument_list|(
name|readBuffer
operator|->
name|getRenderTarget
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|drawBuffer
condition|)
block|{
name|drawRenderTarget
operator|=
name|RenderTarget9
operator|::
name|makeRenderTarget9
argument_list|(
name|drawBuffer
operator|->
name|getRenderTarget
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|readRenderTarget
condition|)
block|{
name|readSurface
operator|=
name|readRenderTarget
operator|->
name|getSurface
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|drawRenderTarget
condition|)
block|{
name|drawSurface
operator|=
name|drawRenderTarget
operator|->
name|getSurface
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|readSurface
operator|||
operator|!
name|drawSurface
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the render target."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|RECT
name|srcRect
decl_stmt|;
name|srcRect
operator|.
name|left
operator|=
name|readRect
operator|.
name|x
expr_stmt|;
name|srcRect
operator|.
name|right
operator|=
name|readRect
operator|.
name|x
operator|+
name|readRect
operator|.
name|width
expr_stmt|;
name|srcRect
operator|.
name|top
operator|=
name|readRect
operator|.
name|y
expr_stmt|;
name|srcRect
operator|.
name|bottom
operator|=
name|readRect
operator|.
name|y
operator|+
name|readRect
operator|.
name|height
expr_stmt|;
name|RECT
name|dstRect
decl_stmt|;
name|dstRect
operator|.
name|left
operator|=
name|drawRect
operator|.
name|x
expr_stmt|;
name|dstRect
operator|.
name|right
operator|=
name|drawRect
operator|.
name|x
operator|+
name|drawRect
operator|.
name|width
expr_stmt|;
name|dstRect
operator|.
name|top
operator|=
name|drawRect
operator|.
name|y
expr_stmt|;
name|dstRect
operator|.
name|bottom
operator|=
name|drawRect
operator|.
name|y
operator|+
name|drawRect
operator|.
name|height
expr_stmt|;
name|HRESULT
name|result
init|=
name|mDevice
operator|->
name|StretchRect
argument_list|(
name|readSurface
argument_list|,
operator|&
name|srcRect
argument_list|,
name|drawSurface
argument_list|,
operator|&
name|dstRect
argument_list|,
name|D3DTEXF_NONE
argument_list|)
decl_stmt|;
name|readSurface
operator|->
name|Release
argument_list|()
expr_stmt|;
name|drawSurface
operator|->
name|Release
argument_list|()
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"BlitFramebufferANGLE failed: StretchRect returned %x."
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|blitDepthStencil
condition|)
block|{
name|gl
operator|::
name|Renderbuffer
modifier|*
name|readBuffer
init|=
name|readFramebuffer
operator|->
name|getDepthOrStencilbuffer
argument_list|()
decl_stmt|;
name|gl
operator|::
name|Renderbuffer
modifier|*
name|drawBuffer
init|=
name|drawFramebuffer
operator|->
name|getDepthOrStencilbuffer
argument_list|()
decl_stmt|;
name|RenderTarget9
modifier|*
name|readDepthStencil
init|=
name|NULL
decl_stmt|;
name|RenderTarget9
modifier|*
name|drawDepthStencil
init|=
name|NULL
decl_stmt|;
name|IDirect3DSurface9
modifier|*
name|readSurface
init|=
name|NULL
decl_stmt|;
name|IDirect3DSurface9
modifier|*
name|drawSurface
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|readBuffer
condition|)
block|{
name|readDepthStencil
operator|=
name|RenderTarget9
operator|::
name|makeRenderTarget9
argument_list|(
name|readBuffer
operator|->
name|getDepthStencil
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|drawBuffer
condition|)
block|{
name|drawDepthStencil
operator|=
name|RenderTarget9
operator|::
name|makeRenderTarget9
argument_list|(
name|drawBuffer
operator|->
name|getDepthStencil
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|readDepthStencil
condition|)
block|{
name|readSurface
operator|=
name|readDepthStencil
operator|->
name|getSurface
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|drawDepthStencil
condition|)
block|{
name|drawSurface
operator|=
name|drawDepthStencil
operator|->
name|getSurface
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|readSurface
operator|||
operator|!
name|drawSurface
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the render target."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|HRESULT
name|result
init|=
name|mDevice
operator|->
name|StretchRect
argument_list|(
name|readSurface
argument_list|,
name|NULL
argument_list|,
name|drawSurface
argument_list|,
name|NULL
argument_list|,
name|D3DTEXF_NONE
argument_list|)
decl_stmt|;
name|readSurface
operator|->
name|Release
argument_list|()
expr_stmt|;
name|drawSurface
operator|->
name|Release
argument_list|()
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"BlitFramebufferANGLE failed: StretchRect returned %x."
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|readPixels
name|void
name|Renderer9
operator|::
name|readPixels
parameter_list|(
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLsizei
name|outputPitch
parameter_list|,
name|bool
name|packReverseRowOrder
parameter_list|,
name|GLint
name|packAlignment
parameter_list|,
name|void
modifier|*
name|pixels
parameter_list|)
block|{
name|RenderTarget9
modifier|*
name|renderTarget
init|=
name|NULL
decl_stmt|;
name|IDirect3DSurface9
modifier|*
name|surface
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Renderbuffer
modifier|*
name|colorbuffer
init|=
name|framebuffer
operator|->
name|getColorbuffer
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|colorbuffer
condition|)
block|{
name|renderTarget
operator|=
name|RenderTarget9
operator|::
name|makeRenderTarget9
argument_list|(
name|colorbuffer
operator|->
name|getRenderTarget
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|renderTarget
condition|)
block|{
name|surface
operator|=
name|renderTarget
operator|->
name|getSurface
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|surface
condition|)
block|{
comment|// context must be lost
return|return;
block|}
name|D3DSURFACE_DESC
name|desc
decl_stmt|;
name|surface
operator|->
name|GetDesc
argument_list|(
operator|&
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|.
name|MultiSampleType
operator|!=
name|D3DMULTISAMPLE_NONE
condition|)
block|{
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
comment|// FIXME: Requires resolve using StretchRect into non-multisampled render target
name|surface
operator|->
name|Release
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
name|HRESULT
name|result
decl_stmt|;
name|IDirect3DSurface9
modifier|*
name|systemSurface
init|=
name|NULL
decl_stmt|;
name|bool
name|directToPixels
init|=
operator|!
name|packReverseRowOrder
operator|&&
name|packAlignment
operator|<=
literal|4
operator|&&
name|getShareHandleSupport
argument_list|()
operator|&&
name|x
operator|==
literal|0
operator|&&
name|y
operator|==
literal|0
operator|&&
name|UINT
argument_list|(
name|width
argument_list|)
operator|==
name|desc
operator|.
name|Width
operator|&&
name|UINT
argument_list|(
name|height
argument_list|)
operator|==
name|desc
operator|.
name|Height
operator|&&
name|desc
operator|.
name|Format
operator|==
name|D3DFMT_A8R8G8B8
operator|&&
name|format
operator|==
name|GL_BGRA_EXT
operator|&&
name|type
operator|==
name|GL_UNSIGNED_BYTE
decl_stmt|;
if|if
condition|(
name|directToPixels
condition|)
block|{
comment|// Use the pixels ptr as a shared handle to write directly into client's memory
name|result
operator|=
name|mDevice
operator|->
name|CreateOffscreenPlainSurface
argument_list|(
name|desc
operator|.
name|Width
argument_list|,
name|desc
operator|.
name|Height
argument_list|,
name|desc
operator|.
name|Format
argument_list|,
name|D3DPOOL_SYSTEMMEM
argument_list|,
operator|&
name|systemSurface
argument_list|,
operator|&
name|pixels
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
comment|// Try again without the shared handle
name|directToPixels
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|directToPixels
condition|)
block|{
name|result
operator|=
name|mDevice
operator|->
name|CreateOffscreenPlainSurface
argument_list|(
name|desc
operator|.
name|Width
argument_list|,
name|desc
operator|.
name|Height
argument_list|,
name|desc
operator|.
name|Format
argument_list|,
name|D3DPOOL_SYSTEMMEM
argument_list|,
operator|&
name|systemSurface
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|result
operator|==
name|D3DERR_OUTOFVIDEOMEMORY
operator|||
name|result
operator|==
name|E_OUTOFMEMORY
argument_list|)
expr_stmt|;
name|surface
operator|->
name|Release
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
name|result
operator|=
name|mDevice
operator|->
name|GetRenderTargetData
argument_list|(
name|surface
argument_list|,
name|systemSurface
argument_list|)
expr_stmt|;
name|surface
operator|->
name|Release
argument_list|()
expr_stmt|;
name|surface
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|systemSurface
operator|->
name|Release
argument_list|()
expr_stmt|;
comment|// It turns out that D3D will sometimes produce more error
comment|// codes than those documented.
if|if
condition|(
name|d3d9
operator|::
name|isDeviceLostError
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|notifyDeviceLost
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
else|else
block|{
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|directToPixels
condition|)
block|{
name|systemSurface
operator|->
name|Release
argument_list|()
expr_stmt|;
return|return;
block|}
name|RECT
name|rect
decl_stmt|;
name|rect
operator|.
name|left
operator|=
name|gl
operator|::
name|clamp
argument_list|(
name|x
argument_list|,
literal|0L
argument_list|,
cast|static_cast
argument_list|<
name|LONG
argument_list|>
argument_list|(
name|desc
operator|.
name|Width
argument_list|)
argument_list|)
expr_stmt|;
name|rect
operator|.
name|top
operator|=
name|gl
operator|::
name|clamp
argument_list|(
name|y
argument_list|,
literal|0L
argument_list|,
cast|static_cast
argument_list|<
name|LONG
argument_list|>
argument_list|(
name|desc
operator|.
name|Height
argument_list|)
argument_list|)
expr_stmt|;
name|rect
operator|.
name|right
operator|=
name|gl
operator|::
name|clamp
argument_list|(
name|x
operator|+
name|width
argument_list|,
literal|0L
argument_list|,
cast|static_cast
argument_list|<
name|LONG
argument_list|>
argument_list|(
name|desc
operator|.
name|Width
argument_list|)
argument_list|)
expr_stmt|;
name|rect
operator|.
name|bottom
operator|=
name|gl
operator|::
name|clamp
argument_list|(
name|y
operator|+
name|height
argument_list|,
literal|0L
argument_list|,
cast|static_cast
argument_list|<
name|LONG
argument_list|>
argument_list|(
name|desc
operator|.
name|Height
argument_list|)
argument_list|)
expr_stmt|;
name|D3DLOCKED_RECT
name|lock
decl_stmt|;
name|result
operator|=
name|systemSurface
operator|->
name|LockRect
argument_list|(
operator|&
name|lock
argument_list|,
operator|&
name|rect
argument_list|,
name|D3DLOCK_READONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|UNREACHABLE
argument_list|()
expr_stmt|;
name|systemSurface
operator|->
name|Release
argument_list|()
expr_stmt|;
return|return;
comment|// No sensible error to generate
block|}
name|unsigned
name|char
modifier|*
name|dest
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|pixels
decl_stmt|;
name|unsigned
name|short
modifier|*
name|dest16
init|=
operator|(
name|unsigned
name|short
operator|*
operator|)
name|pixels
decl_stmt|;
name|unsigned
name|char
modifier|*
name|source
decl_stmt|;
name|int
name|inputPitch
decl_stmt|;
if|if
condition|(
name|packReverseRowOrder
condition|)
block|{
name|source
operator|=
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|lock
operator|.
name|pBits
operator|)
operator|+
name|lock
operator|.
name|Pitch
operator|*
operator|(
name|rect
operator|.
name|bottom
operator|-
name|rect
operator|.
name|top
operator|-
literal|1
operator|)
expr_stmt|;
name|inputPitch
operator|=
operator|-
name|lock
operator|.
name|Pitch
expr_stmt|;
block|}
else|else
block|{
name|source
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|lock
operator|.
name|pBits
expr_stmt|;
name|inputPitch
operator|=
name|lock
operator|.
name|Pitch
expr_stmt|;
block|}
name|unsigned
name|int
name|fastPixelSize
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|desc
operator|.
name|Format
operator|==
name|D3DFMT_A8R8G8B8
operator|&&
name|format
operator|==
name|GL_BGRA_EXT
operator|&&
name|type
operator|==
name|GL_UNSIGNED_BYTE
condition|)
block|{
name|fastPixelSize
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|desc
operator|.
name|Format
operator|==
name|D3DFMT_A4R4G4B4
operator|&&
name|format
operator|==
name|GL_BGRA_EXT
operator|&&
name|type
operator|==
name|GL_UNSIGNED_SHORT_4_4_4_4_REV_EXT
operator|)
operator|||
operator|(
name|desc
operator|.
name|Format
operator|==
name|D3DFMT_A1R5G5B5
operator|&&
name|format
operator|==
name|GL_BGRA_EXT
operator|&&
name|type
operator|==
name|GL_UNSIGNED_SHORT_1_5_5_5_REV_EXT
operator|)
condition|)
block|{
name|fastPixelSize
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|desc
operator|.
name|Format
operator|==
name|D3DFMT_A16B16G16R16F
operator|&&
name|format
operator|==
name|GL_RGBA
operator|&&
name|type
operator|==
name|GL_HALF_FLOAT_OES
condition|)
block|{
name|fastPixelSize
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|desc
operator|.
name|Format
operator|==
name|D3DFMT_A32B32G32R32F
operator|&&
name|format
operator|==
name|GL_RGBA
operator|&&
name|type
operator|==
name|GL_FLOAT
condition|)
block|{
name|fastPixelSize
operator|=
literal|16
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|rect
operator|.
name|bottom
operator|-
name|rect
operator|.
name|top
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|fastPixelSize
operator|!=
literal|0
condition|)
block|{
comment|// Fast path for formats which require no translation:
comment|// D3DFMT_A8R8G8B8 to BGRA/UNSIGNED_BYTE
comment|// D3DFMT_A4R4G4B4 to BGRA/UNSIGNED_SHORT_4_4_4_4_REV_EXT
comment|// D3DFMT_A1R5G5B5 to BGRA/UNSIGNED_SHORT_1_5_5_5_REV_EXT
comment|// D3DFMT_A16B16G16R16F to RGBA/HALF_FLOAT_OES
comment|// D3DFMT_A32B32G32R32F to RGBA/FLOAT
comment|//
comment|// Note that buffers with no alpha go through the slow path below.
name|memcpy
argument_list|(
name|dest
operator|+
name|j
operator|*
name|outputPitch
argument_list|,
name|source
operator|+
name|j
operator|*
name|inputPitch
argument_list|,
operator|(
name|rect
operator|.
name|right
operator|-
name|rect
operator|.
name|left
operator|)
operator|*
name|fastPixelSize
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|desc
operator|.
name|Format
operator|==
name|D3DFMT_A8R8G8B8
operator|&&
name|format
operator|==
name|GL_RGBA
operator|&&
name|type
operator|==
name|GL_UNSIGNED_BYTE
condition|)
block|{
comment|// Fast path for swapping red with blue
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rect
operator|.
name|right
operator|-
name|rect
operator|.
name|left
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|argb
init|=
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|(
name|source
operator|+
literal|4
operator|*
name|i
operator|+
name|j
operator|*
name|inputPitch
operator|)
decl_stmt|;
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|(
name|dest
operator|+
literal|4
operator|*
name|i
operator|+
name|j
operator|*
name|outputPitch
operator|)
operator|=
operator|(
name|argb
operator|&
literal|0xFF00FF00
operator|)
operator||
comment|// Keep alpha and green
operator|(
name|argb
operator|&
literal|0x00FF0000
operator|)
operator|>>
literal|16
operator||
comment|// Move red to blue
operator|(
name|argb
operator|&
literal|0x000000FF
operator|)
operator|<<
literal|16
expr_stmt|;
comment|// Move blue to red
block|}
continue|continue;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rect
operator|.
name|right
operator|-
name|rect
operator|.
name|left
condition|;
name|i
operator|++
control|)
block|{
name|float
name|r
decl_stmt|;
name|float
name|g
decl_stmt|;
name|float
name|b
decl_stmt|;
name|float
name|a
decl_stmt|;
switch|switch
condition|(
name|desc
operator|.
name|Format
condition|)
block|{
case|case
name|D3DFMT_R5G6B5
case|:
block|{
name|unsigned
name|short
name|rgb
init|=
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
name|source
operator|+
literal|2
operator|*
name|i
operator|+
name|j
operator|*
name|inputPitch
operator|)
decl_stmt|;
name|a
operator|=
literal|1.0f
expr_stmt|;
name|b
operator|=
operator|(
name|rgb
operator|&
literal|0x001F
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0x001F
operator|)
expr_stmt|;
name|g
operator|=
operator|(
name|rgb
operator|&
literal|0x07E0
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0x07E0
operator|)
expr_stmt|;
name|r
operator|=
operator|(
name|rgb
operator|&
literal|0xF800
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0xF800
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|D3DFMT_A1R5G5B5
case|:
block|{
name|unsigned
name|short
name|argb
init|=
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
name|source
operator|+
literal|2
operator|*
name|i
operator|+
name|j
operator|*
name|inputPitch
operator|)
decl_stmt|;
name|a
operator|=
operator|(
name|argb
operator|&
literal|0x8000
operator|)
condition|?
literal|1.0f
else|:
literal|0.0f
expr_stmt|;
name|b
operator|=
operator|(
name|argb
operator|&
literal|0x001F
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0x001F
operator|)
expr_stmt|;
name|g
operator|=
operator|(
name|argb
operator|&
literal|0x03E0
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0x03E0
operator|)
expr_stmt|;
name|r
operator|=
operator|(
name|argb
operator|&
literal|0x7C00
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0x7C00
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|D3DFMT_A8R8G8B8
case|:
block|{
name|unsigned
name|int
name|argb
init|=
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|(
name|source
operator|+
literal|4
operator|*
name|i
operator|+
name|j
operator|*
name|inputPitch
operator|)
decl_stmt|;
name|a
operator|=
operator|(
name|argb
operator|&
literal|0xFF000000
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0xFF000000
operator|)
expr_stmt|;
name|b
operator|=
operator|(
name|argb
operator|&
literal|0x000000FF
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0x000000FF
operator|)
expr_stmt|;
name|g
operator|=
operator|(
name|argb
operator|&
literal|0x0000FF00
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0x0000FF00
operator|)
expr_stmt|;
name|r
operator|=
operator|(
name|argb
operator|&
literal|0x00FF0000
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0x00FF0000
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|D3DFMT_X8R8G8B8
case|:
block|{
name|unsigned
name|int
name|xrgb
init|=
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|(
name|source
operator|+
literal|4
operator|*
name|i
operator|+
name|j
operator|*
name|inputPitch
operator|)
decl_stmt|;
name|a
operator|=
literal|1.0f
expr_stmt|;
name|b
operator|=
operator|(
name|xrgb
operator|&
literal|0x000000FF
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0x000000FF
operator|)
expr_stmt|;
name|g
operator|=
operator|(
name|xrgb
operator|&
literal|0x0000FF00
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0x0000FF00
operator|)
expr_stmt|;
name|r
operator|=
operator|(
name|xrgb
operator|&
literal|0x00FF0000
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0x00FF0000
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|D3DFMT_A2R10G10B10
case|:
block|{
name|unsigned
name|int
name|argb
init|=
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|(
name|source
operator|+
literal|4
operator|*
name|i
operator|+
name|j
operator|*
name|inputPitch
operator|)
decl_stmt|;
name|a
operator|=
operator|(
name|argb
operator|&
literal|0xC0000000
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0xC0000000
operator|)
expr_stmt|;
name|b
operator|=
operator|(
name|argb
operator|&
literal|0x000003FF
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0x000003FF
operator|)
expr_stmt|;
name|g
operator|=
operator|(
name|argb
operator|&
literal|0x000FFC00
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0x000FFC00
operator|)
expr_stmt|;
name|r
operator|=
operator|(
name|argb
operator|&
literal|0x3FF00000
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0x3FF00000
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|D3DFMT_A32B32G32R32F
case|:
block|{
comment|// float formats in D3D are stored rgba, rather than the other way round
name|r
operator|=
operator|*
operator|(
operator|(
name|float
operator|*
operator|)
operator|(
name|source
operator|+
literal|16
operator|*
name|i
operator|+
name|j
operator|*
name|inputPitch
operator|)
operator|+
literal|0
operator|)
expr_stmt|;
name|g
operator|=
operator|*
operator|(
operator|(
name|float
operator|*
operator|)
operator|(
name|source
operator|+
literal|16
operator|*
name|i
operator|+
name|j
operator|*
name|inputPitch
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
name|b
operator|=
operator|*
operator|(
operator|(
name|float
operator|*
operator|)
operator|(
name|source
operator|+
literal|16
operator|*
name|i
operator|+
name|j
operator|*
name|inputPitch
operator|)
operator|+
literal|2
operator|)
expr_stmt|;
name|a
operator|=
operator|*
operator|(
operator|(
name|float
operator|*
operator|)
operator|(
name|source
operator|+
literal|16
operator|*
name|i
operator|+
name|j
operator|*
name|inputPitch
operator|)
operator|+
literal|3
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|D3DFMT_A16B16G16R16F
case|:
block|{
comment|// float formats in D3D are stored rgba, rather than the other way round
name|r
operator|=
name|gl
operator|::
name|float16ToFloat32
argument_list|(
operator|*
operator|(
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
name|source
operator|+
literal|8
operator|*
name|i
operator|+
name|j
operator|*
name|inputPitch
operator|)
operator|+
literal|0
operator|)
argument_list|)
expr_stmt|;
name|g
operator|=
name|gl
operator|::
name|float16ToFloat32
argument_list|(
operator|*
operator|(
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
name|source
operator|+
literal|8
operator|*
name|i
operator|+
name|j
operator|*
name|inputPitch
operator|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|b
operator|=
name|gl
operator|::
name|float16ToFloat32
argument_list|(
operator|*
operator|(
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
name|source
operator|+
literal|8
operator|*
name|i
operator|+
name|j
operator|*
name|inputPitch
operator|)
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|a
operator|=
name|gl
operator|::
name|float16ToFloat32
argument_list|(
operator|*
operator|(
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
name|source
operator|+
literal|8
operator|*
name|i
operator|+
name|j
operator|*
name|inputPitch
operator|)
operator|+
literal|3
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
comment|// FIXME
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|GL_RGBA
case|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_UNSIGNED_BYTE
case|:
name|dest
index|[
literal|4
operator|*
name|i
operator|+
name|j
operator|*
name|outputPitch
operator|+
literal|0
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
literal|255
operator|*
name|r
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|i
operator|+
name|j
operator|*
name|outputPitch
operator|+
literal|1
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
literal|255
operator|*
name|g
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|i
operator|+
name|j
operator|*
name|outputPitch
operator|+
literal|2
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
literal|255
operator|*
name|b
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|i
operator|+
name|j
operator|*
name|outputPitch
operator|+
literal|3
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
literal|255
operator|*
name|a
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|GL_BGRA_EXT
case|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_UNSIGNED_BYTE
case|:
name|dest
index|[
literal|4
operator|*
name|i
operator|+
name|j
operator|*
name|outputPitch
operator|+
literal|0
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
literal|255
operator|*
name|b
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|i
operator|+
name|j
operator|*
name|outputPitch
operator|+
literal|1
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
literal|255
operator|*
name|g
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|i
operator|+
name|j
operator|*
name|outputPitch
operator|+
literal|2
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
literal|255
operator|*
name|r
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|i
operator|+
name|j
operator|*
name|outputPitch
operator|+
literal|3
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
literal|255
operator|*
name|a
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_SHORT_4_4_4_4_REV_EXT
case|:
comment|// According to the desktop GL spec in the "Transfer of Pixel Rectangles" section
comment|// this type is packed as follows:
comment|//   15   14   13   12   11   10    9    8    7    6    5    4    3    2    1    0
comment|//  --------------------------------------------------------------------------------
comment|// |       4th         |        3rd         |        2nd        |   1st component   |
comment|//  --------------------------------------------------------------------------------
comment|// in the case of BGRA_EXT, B is the first component, G the second, and so forth.
name|dest16
index|[
name|i
operator|+
name|j
operator|*
name|outputPitch
operator|/
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
expr|]
operator|=
operator|(
call|(
name|unsigned
name|short
call|)
argument_list|(
literal|15
operator|*
name|a
operator|+
literal|0.5f
argument_list|)
operator|<<
literal|12
operator|)
operator||
operator|(
call|(
name|unsigned
name|short
call|)
argument_list|(
literal|15
operator|*
name|r
operator|+
literal|0.5f
argument_list|)
operator|<<
literal|8
operator|)
operator||
operator|(
call|(
name|unsigned
name|short
call|)
argument_list|(
literal|15
operator|*
name|g
operator|+
literal|0.5f
argument_list|)
operator|<<
literal|4
operator|)
operator||
operator|(
call|(
name|unsigned
name|short
call|)
argument_list|(
literal|15
operator|*
name|b
operator|+
literal|0.5f
argument_list|)
operator|<<
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_SHORT_1_5_5_5_REV_EXT
case|:
comment|// According to the desktop GL spec in the "Transfer of Pixel Rectangles" section
comment|// this type is packed as follows:
comment|//   15   14   13   12   11   10    9    8    7    6    5    4    3    2    1    0
comment|//  --------------------------------------------------------------------------------
comment|// | 4th |          3rd           |           2nd          |      1st component     |
comment|//  --------------------------------------------------------------------------------
comment|// in the case of BGRA_EXT, B is the first component, G the second, and so forth.
name|dest16
index|[
name|i
operator|+
name|j
operator|*
name|outputPitch
operator|/
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
expr|]
operator|=
operator|(
call|(
name|unsigned
name|short
call|)
argument_list|(
name|a
operator|+
literal|0.5f
argument_list|)
operator|<<
literal|15
operator|)
operator||
operator|(
call|(
name|unsigned
name|short
call|)
argument_list|(
literal|31
operator|*
name|r
operator|+
literal|0.5f
argument_list|)
operator|<<
literal|10
operator|)
operator||
operator|(
call|(
name|unsigned
name|short
call|)
argument_list|(
literal|31
operator|*
name|g
operator|+
literal|0.5f
argument_list|)
operator|<<
literal|5
operator|)
operator||
operator|(
call|(
name|unsigned
name|short
call|)
argument_list|(
literal|31
operator|*
name|b
operator|+
literal|0.5f
argument_list|)
operator|<<
literal|0
operator|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|GL_RGB
case|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_UNSIGNED_SHORT_5_6_5
case|:
name|dest16
index|[
name|i
operator|+
name|j
operator|*
name|outputPitch
operator|/
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
expr|]
operator|=
operator|(
call|(
name|unsigned
name|short
call|)
argument_list|(
literal|31
operator|*
name|b
operator|+
literal|0.5f
argument_list|)
operator|<<
literal|0
operator|)
operator||
operator|(
call|(
name|unsigned
name|short
call|)
argument_list|(
literal|63
operator|*
name|g
operator|+
literal|0.5f
argument_list|)
operator|<<
literal|5
operator|)
operator||
operator|(
call|(
name|unsigned
name|short
call|)
argument_list|(
literal|31
operator|*
name|r
operator|+
literal|0.5f
argument_list|)
operator|<<
literal|11
operator|)
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_BYTE
case|:
name|dest
index|[
literal|3
operator|*
name|i
operator|+
name|j
operator|*
name|outputPitch
operator|+
literal|0
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
literal|255
operator|*
name|r
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
name|dest
index|[
literal|3
operator|*
name|i
operator|+
name|j
operator|*
name|outputPitch
operator|+
literal|1
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
literal|255
operator|*
name|g
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
name|dest
index|[
literal|3
operator|*
name|i
operator|+
name|j
operator|*
name|outputPitch
operator|+
literal|2
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
literal|255
operator|*
name|b
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|systemSurface
operator|->
name|UnlockRect
argument_list|()
expr_stmt|;
name|systemSurface
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
DECL|function|createRenderTarget
name|RenderTarget
modifier|*
name|Renderer9
operator|::
name|createRenderTarget
parameter_list|(
name|SwapChain
modifier|*
name|swapChain
parameter_list|,
name|bool
name|depth
parameter_list|)
block|{
name|SwapChain9
modifier|*
name|swapChain9
init|=
name|SwapChain9
operator|::
name|makeSwapChain9
argument_list|(
name|swapChain
argument_list|)
decl_stmt|;
name|IDirect3DSurface9
modifier|*
name|surface
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|depth
condition|)
block|{
name|surface
operator|=
name|swapChain9
operator|->
name|getDepthStencil
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|surface
operator|=
name|swapChain9
operator|->
name|getRenderTarget
argument_list|()
expr_stmt|;
block|}
name|RenderTarget9
modifier|*
name|renderTarget
init|=
operator|new
name|RenderTarget9
argument_list|(
name|this
argument_list|,
name|surface
argument_list|)
decl_stmt|;
return|return
name|renderTarget
return|;
block|}
DECL|function|createRenderTarget
name|RenderTarget
modifier|*
name|Renderer9
operator|::
name|createRenderTarget
parameter_list|(
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLsizei
name|samples
parameter_list|,
name|bool
name|depth
parameter_list|)
block|{
name|RenderTarget9
modifier|*
name|renderTarget
init|=
operator|new
name|RenderTarget9
argument_list|(
name|this
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|samples
argument_list|)
decl_stmt|;
return|return
name|renderTarget
return|;
block|}
DECL|function|loadExecutable
name|ShaderExecutable
modifier|*
name|Renderer9
operator|::
name|loadExecutable
parameter_list|(
specifier|const
name|void
modifier|*
name|function
parameter_list|,
name|size_t
name|length
parameter_list|,
name|rx
operator|::
name|ShaderType
name|type
parameter_list|)
block|{
name|ShaderExecutable9
modifier|*
name|executable
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|rx
operator|::
name|SHADER_VERTEX
case|:
block|{
name|IDirect3DVertexShader9
modifier|*
name|vshader
init|=
name|createVertexShader
argument_list|(
operator|(
name|DWORD
operator|*
operator|)
name|function
argument_list|,
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|vshader
condition|)
block|{
name|executable
operator|=
operator|new
name|ShaderExecutable9
argument_list|(
name|function
argument_list|,
name|length
argument_list|,
name|vshader
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|rx
operator|::
name|SHADER_PIXEL
case|:
block|{
name|IDirect3DPixelShader9
modifier|*
name|pshader
init|=
name|createPixelShader
argument_list|(
operator|(
name|DWORD
operator|*
operator|)
name|function
argument_list|,
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|pshader
condition|)
block|{
name|executable
operator|=
operator|new
name|ShaderExecutable9
argument_list|(
name|function
argument_list|,
name|length
argument_list|,
name|pshader
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
name|executable
return|;
block|}
DECL|function|compileToExecutable
name|ShaderExecutable
modifier|*
name|Renderer9
operator|::
name|compileToExecutable
parameter_list|(
name|gl
operator|::
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|char
modifier|*
name|shaderHLSL
parameter_list|,
name|rx
operator|::
name|ShaderType
name|type
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|profile
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|rx
operator|::
name|SHADER_VERTEX
case|:
name|profile
operator|=
name|getMajorShaderModel
argument_list|()
operator|>=
literal|3
condition|?
literal|"vs_3_0"
else|:
literal|"vs_2_0"
expr_stmt|;
break|break;
case|case
name|rx
operator|::
name|SHADER_PIXEL
case|:
name|profile
operator|=
name|getMajorShaderModel
argument_list|()
operator|>=
literal|3
condition|?
literal|"ps_3_0"
else|:
literal|"ps_2_0"
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ID3DBlob
modifier|*
name|binary
init|=
operator|(
name|ID3DBlob
operator|*
operator|)
name|compileToBinary
argument_list|(
name|infoLog
argument_list|,
name|shaderHLSL
argument_list|,
name|profile
argument_list|,
name|ANGLE_COMPILE_OPTIMIZATION_LEVEL
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|binary
condition|)
return|return
name|NULL
return|;
name|ShaderExecutable
modifier|*
name|executable
init|=
name|loadExecutable
argument_list|(
name|binary
operator|->
name|GetBufferPointer
argument_list|()
argument_list|,
name|binary
operator|->
name|GetBufferSize
argument_list|()
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|binary
operator|->
name|Release
argument_list|()
expr_stmt|;
return|return
name|executable
return|;
block|}
DECL|function|boxFilter
name|bool
name|Renderer9
operator|::
name|boxFilter
parameter_list|(
name|IDirect3DSurface9
modifier|*
name|source
parameter_list|,
name|IDirect3DSurface9
modifier|*
name|dest
parameter_list|)
block|{
return|return
name|mBlit
operator|->
name|boxFilter
argument_list|(
name|source
argument_list|,
name|dest
argument_list|)
return|;
block|}
DECL|function|getTexturePool
name|D3DPOOL
name|Renderer9
operator|::
name|getTexturePool
parameter_list|(
name|DWORD
name|usage
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|mD3d9Ex
operator|!=
name|NULL
condition|)
block|{
return|return
name|D3DPOOL_DEFAULT
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|usage
operator|&
operator|(
name|D3DUSAGE_DEPTHSTENCIL
operator||
name|D3DUSAGE_RENDERTARGET
operator|)
operator|)
condition|)
block|{
return|return
name|D3DPOOL_MANAGED
return|;
block|}
block|}
return|return
name|D3DPOOL_DEFAULT
return|;
block|}
DECL|function|copyToRenderTarget
name|bool
name|Renderer9
operator|::
name|copyToRenderTarget
parameter_list|(
name|IDirect3DSurface9
modifier|*
name|dest
parameter_list|,
name|IDirect3DSurface9
modifier|*
name|source
parameter_list|,
name|bool
name|fromManaged
parameter_list|)
block|{
if|if
condition|(
name|source
operator|&&
name|dest
condition|)
block|{
name|HRESULT
name|result
init|=
name|D3DERR_OUTOFVIDEOMEMORY
decl_stmt|;
if|if
condition|(
name|fromManaged
condition|)
block|{
name|D3DSURFACE_DESC
name|desc
decl_stmt|;
name|source
operator|->
name|GetDesc
argument_list|(
operator|&
name|desc
argument_list|)
expr_stmt|;
name|IDirect3DSurface9
modifier|*
name|surf
init|=
literal|0
decl_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|CreateOffscreenPlainSurface
argument_list|(
name|desc
operator|.
name|Width
argument_list|,
name|desc
operator|.
name|Height
argument_list|,
name|desc
operator|.
name|Format
argument_list|,
name|D3DPOOL_SYSTEMMEM
argument_list|,
operator|&
name|surf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|Image9
operator|::
name|copyLockableSurfaces
argument_list|(
name|surf
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|UpdateSurface
argument_list|(
name|surf
argument_list|,
name|NULL
argument_list|,
name|dest
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|surf
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|endScene
argument_list|()
expr_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|StretchRect
argument_list|(
name|source
argument_list|,
name|NULL
argument_list|,
name|dest
argument_list|,
name|NULL
argument_list|,
name|D3DTEXF_NONE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|result
operator|==
name|D3DERR_OUTOFVIDEOMEMORY
operator|||
name|result
operator|==
name|E_OUTOFMEMORY
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|createImage
name|Image
modifier|*
name|Renderer9
operator|::
name|createImage
parameter_list|()
block|{
return|return
operator|new
name|Image9
argument_list|()
return|;
block|}
DECL|function|generateMipmap
name|void
name|Renderer9
operator|::
name|generateMipmap
parameter_list|(
name|Image
modifier|*
name|dest
parameter_list|,
name|Image
modifier|*
name|src
parameter_list|)
block|{
name|Image9
modifier|*
name|src9
init|=
name|Image9
operator|::
name|makeImage9
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|Image9
modifier|*
name|dst9
init|=
name|Image9
operator|::
name|makeImage9
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|Image9
operator|::
name|generateMipmap
argument_list|(
name|dst9
argument_list|,
name|src9
argument_list|)
expr_stmt|;
block|}
DECL|function|createTextureStorage2D
name|TextureStorage
modifier|*
name|Renderer9
operator|::
name|createTextureStorage2D
parameter_list|(
name|SwapChain
modifier|*
name|swapChain
parameter_list|)
block|{
name|SwapChain9
modifier|*
name|swapChain9
init|=
name|SwapChain9
operator|::
name|makeSwapChain9
argument_list|(
name|swapChain
argument_list|)
decl_stmt|;
return|return
operator|new
name|TextureStorage9_2D
argument_list|(
name|this
argument_list|,
name|swapChain9
argument_list|)
return|;
block|}
DECL|function|createTextureStorage2D
name|TextureStorage
modifier|*
name|Renderer9
operator|::
name|createTextureStorage2D
parameter_list|(
name|int
name|levels
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|GLenum
name|usage
parameter_list|,
name|bool
name|forceRenderable
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
return|return
operator|new
name|TextureStorage9_2D
argument_list|(
name|this
argument_list|,
name|levels
argument_list|,
name|internalformat
argument_list|,
name|usage
argument_list|,
name|forceRenderable
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
return|;
block|}
DECL|function|createTextureStorageCube
name|TextureStorage
modifier|*
name|Renderer9
operator|::
name|createTextureStorageCube
parameter_list|(
name|int
name|levels
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|GLenum
name|usage
parameter_list|,
name|bool
name|forceRenderable
parameter_list|,
name|int
name|size
parameter_list|)
block|{
return|return
operator|new
name|TextureStorage9_Cube
argument_list|(
name|this
argument_list|,
name|levels
argument_list|,
name|internalformat
argument_list|,
name|usage
argument_list|,
name|forceRenderable
argument_list|,
name|size
argument_list|)
return|;
block|}
block|}
end_namespace
end_unit
