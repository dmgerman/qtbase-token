begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2013 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// copyvertex.h: Defines vertex buffer copying and conversion functions
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|LIBGLESV2_RENDERER_COPYVERTEX_H_
end_ifndef
begin_define
DECL|macro|LIBGLESV2_RENDERER_COPYVERTEX_H_
define|#
directive|define
name|LIBGLESV2_RENDERER_COPYVERTEX_H_
end_define
begin_include
include|#
directive|include
file|"common/mathutil.h"
end_include
begin_comment
comment|// 'widenDefaultValueBits' gives the default value for the alpha channel (4th component)
end_comment
begin_comment
comment|//  the sentinel value 0 means we do not want to widen the input or add an alpha channel
end_comment
begin_expr_stmt
DECL|variable|T
DECL|variable|componentCount
name|template
operator|<
name|typename
name|T
operator|,
name|unsigned
name|int
name|componentCount
operator|,
name|unsigned
name|int
name|widenDefaultValueBits
operator|>
DECL|function|copyVertexData
specifier|inline
name|void
name|copyVertexData
argument_list|(
argument|const void *input
argument_list|,
argument|size_t stride
argument_list|,
argument|size_t count
argument_list|,
argument|void *output
argument_list|)
block|{
specifier|const
name|unsigned
name|int
name|attribSize
operator|=
sizeof|sizeof
argument_list|(
name|T
argument_list|)
operator|*
name|componentCount
block|;
specifier|const
name|T
name|defaultValue
operator|=
name|gl
operator|::
name|bitCast
operator|<
name|T
operator|>
operator|(
name|widenDefaultValueBits
operator|)
block|;
specifier|const
name|bool
name|widen
operator|=
operator|(
name|widenDefaultValueBits
operator|!=
literal|0
operator|)
block|;
if|if
condition|(
name|attribSize
operator|==
name|stride
operator|&&
operator|!
name|widen
condition|)
block|{
name|memcpy
argument_list|(
name|output
argument_list|,
name|input
argument_list|,
name|count
operator|*
name|attribSize
argument_list|)
expr_stmt|;
block|}
end_expr_stmt
begin_else
else|else
block|{
name|unsigned
name|int
name|outputStride
init|=
name|widen
condition|?
literal|4
else|:
name|componentCount
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|T
modifier|*
name|offsetInput
init|=
name|reinterpret_cast
operator|<
specifier|const
name|T
operator|*
operator|>
operator|(
name|reinterpret_cast
operator|<
specifier|const
name|char
operator|*
operator|>
operator|(
name|input
operator|)
operator|+
name|i
operator|*
name|stride
operator|)
decl_stmt|;
name|T
modifier|*
name|offsetOutput
init|=
name|reinterpret_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|output
operator|)
operator|+
name|i
operator|*
name|outputStride
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|componentCount
condition|;
name|j
operator|++
control|)
block|{
name|offsetOutput
index|[
name|j
index|]
operator|=
name|offsetInput
index|[
name|j
index|]
expr_stmt|;
block|}
if|if
condition|(
name|widen
condition|)
block|{
name|offsetOutput
index|[
literal|3
index|]
operator|=
name|defaultValue
expr_stmt|;
block|}
block|}
block|}
end_else
begin_expr_stmt
unit|}  template
operator|<
name|unsigned
name|int
name|componentCount
operator|>
DECL|function|copyFixedVertexData
specifier|inline
name|void
name|copyFixedVertexData
argument_list|(
argument|const void* input
argument_list|,
argument|size_t stride
argument_list|,
argument|size_t count
argument_list|,
argument|void* output
argument_list|)
block|{
specifier|static
specifier|const
name|float
name|divisor
operator|=
literal|1.0f
operator|/
operator|(
literal|1
operator|<<
literal|16
operator|)
block|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|GLfixed
modifier|*
name|offsetInput
init|=
name|reinterpret_cast
operator|<
specifier|const
name|GLfixed
operator|*
operator|>
operator|(
name|reinterpret_cast
operator|<
specifier|const
name|char
operator|*
operator|>
operator|(
name|input
operator|)
operator|+
name|stride
operator|*
name|i
operator|)
decl_stmt|;
name|float
modifier|*
name|offsetOutput
init|=
name|reinterpret_cast
operator|<
name|float
operator|*
operator|>
operator|(
name|output
operator|)
operator|+
name|i
operator|*
name|componentCount
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|componentCount
condition|;
name|j
operator|++
control|)
block|{
name|offsetOutput
index|[
name|j
index|]
operator|=
name|static_cast
operator|<
name|float
operator|>
operator|(
name|offsetInput
index|[
name|j
index|]
operator|)
operator|*
name|divisor
expr_stmt|;
block|}
end_expr_stmt
begin_expr_stmt
unit|} }
DECL|variable|T
DECL|variable|componentCount
name|template
operator|<
name|typename
name|T
operator|,
name|unsigned
name|int
name|componentCount
operator|,
name|bool
name|normalized
operator|>
DECL|function|copyToFloatVertexData
specifier|inline
name|void
name|copyToFloatVertexData
argument_list|(
argument|const void* input
argument_list|,
argument|size_t stride
argument_list|,
argument|size_t count
argument_list|,
argument|void* output
argument_list|)
block|{
typedef|typedef
name|std
operator|::
name|numeric_limits
operator|<
name|T
operator|>
name|NL
expr_stmt|;
end_expr_stmt
begin_for
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|T
modifier|*
name|offsetInput
init|=
name|reinterpret_cast
operator|<
specifier|const
name|T
operator|*
operator|>
operator|(
name|reinterpret_cast
operator|<
specifier|const
name|char
operator|*
operator|>
operator|(
name|input
operator|)
operator|+
name|stride
operator|*
name|i
operator|)
decl_stmt|;
name|float
modifier|*
name|offsetOutput
init|=
name|reinterpret_cast
operator|<
name|float
operator|*
operator|>
operator|(
name|output
operator|)
operator|+
name|i
operator|*
name|componentCount
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|componentCount
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|normalized
condition|)
block|{
if|if
condition|(
name|NL
operator|::
name|is_signed
condition|)
block|{
specifier|const
name|float
name|divisor
init|=
literal|1.0f
operator|/
operator|(
literal|2
operator|*
name|static_cast
operator|<
name|float
operator|>
operator|(
name|NL
operator|::
name|max
argument_list|()
operator|)
operator|+
literal|1
operator|)
decl_stmt|;
name|offsetOutput
index|[
name|j
index|]
operator|=
operator|(
literal|2
operator|*
name|static_cast
operator|<
name|float
operator|>
operator|(
name|offsetInput
index|[
name|j
index|]
operator|)
operator|+
literal|1
operator|)
operator|*
name|divisor
expr_stmt|;
block|}
else|else
block|{
name|offsetOutput
index|[
name|j
index|]
operator|=
name|static_cast
operator|<
name|float
operator|>
operator|(
name|offsetInput
index|[
name|j
index|]
operator|)
operator|/
name|NL
operator|::
name|max
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|offsetOutput
index|[
name|j
index|]
operator|=
name|static_cast
operator|<
name|float
operator|>
operator|(
name|offsetInput
index|[
name|j
index|]
operator|)
expr_stmt|;
block|}
block|}
block|}
end_for
begin_function
unit|}  inline
DECL|function|copyPackedUnsignedVertexData
name|void
name|copyPackedUnsignedVertexData
parameter_list|(
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|stride
parameter_list|,
name|size_t
name|count
parameter_list|,
name|void
modifier|*
name|output
parameter_list|)
block|{
specifier|const
name|unsigned
name|int
name|attribSize
init|=
literal|4
decl_stmt|;
if|if
condition|(
name|attribSize
operator|==
name|stride
condition|)
block|{
name|memcpy
argument_list|(
name|output
argument_list|,
name|input
argument_list|,
name|count
operator|*
name|attribSize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|GLuint
modifier|*
name|offsetInput
init|=
name|reinterpret_cast
operator|<
specifier|const
name|GLuint
operator|*
operator|>
operator|(
name|reinterpret_cast
operator|<
specifier|const
name|char
operator|*
operator|>
operator|(
name|input
operator|)
operator|+
operator|(
name|i
operator|*
name|stride
operator|)
operator|)
decl_stmt|;
name|GLuint
modifier|*
name|offsetOutput
init|=
name|reinterpret_cast
operator|<
name|GLuint
operator|*
operator|>
operator|(
name|output
operator|)
operator|+
operator|(
name|i
operator|*
name|attribSize
operator|)
decl_stmt|;
name|offsetOutput
index|[
name|i
index|]
operator|=
name|offsetInput
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
end_function
begin_expr_stmt
DECL|variable|isSigned
DECL|variable|normalized
name|template
operator|<
name|bool
name|isSigned
operator|,
name|bool
name|normalized
operator|,
name|bool
name|toFloat
operator|>
DECL|function|copyPackedRGB
specifier|static
specifier|inline
name|void
name|copyPackedRGB
argument_list|(
argument|unsigned int data
argument_list|,
argument|void *output
argument_list|)
block|{
specifier|const
name|unsigned
name|int
name|rgbSignMask
operator|=
literal|0x200
block|;
comment|// 1 set at the 9 bit
specifier|const
name|unsigned
name|int
name|negativeMask
operator|=
literal|0xFFFFFC00
block|;
comment|// All bits from 10 to 31 set to 1
if|if
condition|(
name|toFloat
condition|)
block|{
name|GLfloat
modifier|*
name|floatOutput
init|=
name|reinterpret_cast
operator|<
name|GLfloat
operator|*
operator|>
operator|(
name|output
operator|)
decl_stmt|;
if|if
condition|(
name|isSigned
condition|)
block|{
name|GLfloat
name|finalValue
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|data
operator|&
name|rgbSignMask
condition|)
block|{
name|int
name|negativeNumber
init|=
name|data
operator||
name|negativeMask
decl_stmt|;
name|finalValue
operator|=
name|static_cast
operator|<
name|GLfloat
operator|>
operator|(
name|negativeNumber
operator|)
expr_stmt|;
block|}
end_expr_stmt
begin_else
else|else
block|{
name|finalValue
operator|=
name|static_cast
operator|<
name|GLfloat
operator|>
operator|(
name|data
operator|)
expr_stmt|;
block|}
end_else
begin_if
if|if
condition|(
name|normalized
condition|)
block|{
specifier|const
name|int
name|maxValue
init|=
literal|0x1FF
decl_stmt|;
comment|// 1 set in bits 0 through 8
specifier|const
name|int
name|minValue
init|=
literal|0xFFFFFE01
decl_stmt|;
comment|// Inverse of maxValue
comment|// A 10-bit two's complement number has the possibility of being minValue - 1 but
comment|// OpenGL's normalization rules dictate that it should be clamped to minValue in this
comment|// case.
if|if
condition|(
name|finalValue
operator|<
name|minValue
condition|)
block|{
name|finalValue
operator|=
name|minValue
expr_stmt|;
block|}
specifier|const
name|int
name|halfRange
init|=
operator|(
name|maxValue
operator|-
name|minValue
operator|)
operator|>>
literal|1
decl_stmt|;
operator|*
name|floatOutput
operator|=
operator|(
operator|(
name|finalValue
operator|-
name|minValue
operator|)
operator|/
name|halfRange
operator|)
operator|-
literal|1.0f
expr_stmt|;
block|}
else|else
block|{
operator|*
name|floatOutput
operator|=
name|finalValue
expr_stmt|;
block|}
end_if
begin_block
unit|}         else
block|{
if|if
condition|(
name|normalized
condition|)
block|{
specifier|const
name|unsigned
name|int
name|maxValue
init|=
literal|0x3FF
decl_stmt|;
comment|// 1 set in bits 0 through 9
operator|*
name|floatOutput
operator|=
name|static_cast
operator|<
name|GLfloat
operator|>
operator|(
name|data
operator|)
operator|/
name|static_cast
operator|<
name|GLfloat
operator|>
operator|(
name|maxValue
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|floatOutput
operator|=
name|static_cast
operator|<
name|GLfloat
operator|>
operator|(
name|data
operator|)
expr_stmt|;
block|}
block|}
end_block
begin_block
unit|}     else
block|{
if|if
condition|(
name|isSigned
condition|)
block|{
name|GLshort
modifier|*
name|intOutput
init|=
name|reinterpret_cast
operator|<
name|GLshort
operator|*
operator|>
operator|(
name|output
operator|)
decl_stmt|;
if|if
condition|(
name|data
operator|&
name|rgbSignMask
condition|)
block|{
operator|*
name|intOutput
operator|=
name|data
operator||
name|negativeMask
expr_stmt|;
block|}
else|else
block|{
operator|*
name|intOutput
operator|=
name|data
expr_stmt|;
block|}
block|}
else|else
block|{
name|GLushort
modifier|*
name|uintOutput
init|=
name|reinterpret_cast
operator|<
name|GLushort
operator|*
operator|>
operator|(
name|output
operator|)
decl_stmt|;
operator|*
name|uintOutput
operator|=
name|data
expr_stmt|;
block|}
block|}
end_block
begin_expr_stmt
unit|}  template
DECL|variable|isSigned
DECL|variable|normalized
operator|<
name|bool
name|isSigned
operator|,
name|bool
name|normalized
operator|,
name|bool
name|toFloat
operator|>
DECL|function|copyPackedAlpha
specifier|inline
name|void
name|copyPackedAlpha
argument_list|(
argument|unsigned int data
argument_list|,
argument|void *output
argument_list|)
block|{
if|if
condition|(
name|toFloat
condition|)
block|{
name|GLfloat
modifier|*
name|floatOutput
init|=
name|reinterpret_cast
operator|<
name|GLfloat
operator|*
operator|>
operator|(
name|output
operator|)
decl_stmt|;
if|if
condition|(
name|isSigned
condition|)
block|{
if|if
condition|(
name|normalized
condition|)
block|{
switch|switch
condition|(
name|data
condition|)
block|{
case|case
literal|0x0
case|:
operator|*
name|floatOutput
operator|=
literal|0.0f
expr_stmt|;
break|break;
case|case
literal|0x1
case|:
operator|*
name|floatOutput
operator|=
literal|1.0f
expr_stmt|;
break|break;
case|case
literal|0x2
case|:
operator|*
name|floatOutput
operator|=
operator|-
literal|1.0f
expr_stmt|;
break|break;
case|case
literal|0x3
case|:
operator|*
name|floatOutput
operator|=
operator|-
literal|1.0f
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
end_expr_stmt
begin_block
unit|}             else
block|{
switch|switch
condition|(
name|data
condition|)
block|{
case|case
literal|0x0
case|:
operator|*
name|floatOutput
operator|=
literal|0.0f
expr_stmt|;
break|break;
case|case
literal|0x1
case|:
operator|*
name|floatOutput
operator|=
literal|1.0f
expr_stmt|;
break|break;
case|case
literal|0x2
case|:
operator|*
name|floatOutput
operator|=
operator|-
literal|2.0f
expr_stmt|;
break|break;
case|case
literal|0x3
case|:
operator|*
name|floatOutput
operator|=
operator|-
literal|1.0f
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
end_block
begin_block
unit|}         else
block|{
if|if
condition|(
name|normalized
condition|)
block|{
switch|switch
condition|(
name|data
condition|)
block|{
case|case
literal|0x0
case|:
operator|*
name|floatOutput
operator|=
literal|0.0f
operator|/
literal|3.0f
expr_stmt|;
break|break;
case|case
literal|0x1
case|:
operator|*
name|floatOutput
operator|=
literal|1.0f
operator|/
literal|3.0f
expr_stmt|;
break|break;
case|case
literal|0x2
case|:
operator|*
name|floatOutput
operator|=
literal|2.0f
operator|/
literal|3.0f
expr_stmt|;
break|break;
case|case
literal|0x3
case|:
operator|*
name|floatOutput
operator|=
literal|3.0f
operator|/
literal|3.0f
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|data
condition|)
block|{
case|case
literal|0x0
case|:
operator|*
name|floatOutput
operator|=
literal|0.0f
expr_stmt|;
break|break;
case|case
literal|0x1
case|:
operator|*
name|floatOutput
operator|=
literal|1.0f
expr_stmt|;
break|break;
case|case
literal|0x2
case|:
operator|*
name|floatOutput
operator|=
literal|2.0f
expr_stmt|;
break|break;
case|case
literal|0x3
case|:
operator|*
name|floatOutput
operator|=
literal|3.0f
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_block
begin_block
unit|}     else
block|{
if|if
condition|(
name|isSigned
condition|)
block|{
name|GLshort
modifier|*
name|intOutput
init|=
name|reinterpret_cast
operator|<
name|GLshort
operator|*
operator|>
operator|(
name|output
operator|)
decl_stmt|;
switch|switch
condition|(
name|data
condition|)
block|{
case|case
literal|0x0
case|:
operator|*
name|intOutput
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|0x1
case|:
operator|*
name|intOutput
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0x2
case|:
operator|*
name|intOutput
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
case|case
literal|0x3
case|:
operator|*
name|intOutput
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|GLushort
modifier|*
name|uintOutput
init|=
name|reinterpret_cast
operator|<
name|GLushort
operator|*
operator|>
operator|(
name|output
operator|)
decl_stmt|;
switch|switch
condition|(
name|data
condition|)
block|{
case|case
literal|0x0
case|:
operator|*
name|uintOutput
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|0x1
case|:
operator|*
name|uintOutput
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0x2
case|:
operator|*
name|uintOutput
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|0x3
case|:
operator|*
name|uintOutput
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_block
begin_expr_stmt
unit|}  template
DECL|variable|isSigned
DECL|variable|normalized
operator|<
name|bool
name|isSigned
operator|,
name|bool
name|normalized
operator|,
name|bool
name|toFloat
operator|>
DECL|function|copyPackedVertexData
specifier|inline
name|void
name|copyPackedVertexData
argument_list|(
argument|const void* input
argument_list|,
argument|size_t stride
argument_list|,
argument|size_t count
argument_list|,
argument|void* output
argument_list|)
block|{
specifier|const
name|unsigned
name|int
name|outputComponentSize
operator|=
name|toFloat
operator|?
literal|4
operator|:
literal|2
block|;
specifier|const
name|unsigned
name|int
name|componentCount
operator|=
literal|4
block|;
specifier|const
name|unsigned
name|int
name|rgbMask
operator|=
literal|0x3FF
block|;
comment|// 1 set in bits 0 through 9
specifier|const
name|unsigned
name|int
name|redShift
operator|=
literal|0
block|;
comment|// red is bits 0 through 9
specifier|const
name|unsigned
name|int
name|greenShift
operator|=
literal|10
block|;
comment|// green is bits 10 through 19
specifier|const
name|unsigned
name|int
name|blueShift
operator|=
literal|20
block|;
comment|// blue is bits 20 through 29
specifier|const
name|unsigned
name|int
name|alphaMask
operator|=
literal|0x3
block|;
comment|// 1 set in bits 0 and 1
specifier|const
name|unsigned
name|int
name|alphaShift
operator|=
literal|30
block|;
comment|// Alpha is the 30 and 31 bits
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|GLuint
name|packedValue
init|=
operator|*
name|reinterpret_cast
operator|<
specifier|const
name|GLuint
operator|*
operator|>
operator|(
name|reinterpret_cast
operator|<
specifier|const
name|char
operator|*
operator|>
operator|(
name|input
operator|)
operator|+
operator|(
name|i
operator|*
name|stride
operator|)
operator|)
decl_stmt|;
name|GLbyte
modifier|*
name|offsetOutput
init|=
name|reinterpret_cast
operator|<
name|GLbyte
operator|*
operator|>
operator|(
name|output
operator|)
operator|+
operator|(
name|i
operator|*
name|outputComponentSize
operator|*
name|componentCount
operator|)
decl_stmt|;
name|copyPackedRGB
operator|<
name|isSigned
operator|,
name|normalized
operator|,
name|toFloat
operator|>
operator|(
operator|(
name|packedValue
operator|>>
name|redShift
operator|)
operator|&
name|rgbMask
operator|,
name|offsetOutput
operator|+
operator|(
literal|0
operator|*
name|outputComponentSize
operator|)
operator|)
expr_stmt|;
name|copyPackedRGB
operator|<
name|isSigned
operator|,
name|normalized
operator|,
name|toFloat
operator|>
operator|(
operator|(
name|packedValue
operator|>>
name|greenShift
operator|)
operator|&
name|rgbMask
operator|,
name|offsetOutput
operator|+
operator|(
literal|1
operator|*
name|outputComponentSize
operator|)
operator|)
expr_stmt|;
name|copyPackedRGB
operator|<
name|isSigned
operator|,
name|normalized
operator|,
name|toFloat
operator|>
operator|(
operator|(
name|packedValue
operator|>>
name|blueShift
operator|)
operator|&
name|rgbMask
operator|,
name|offsetOutput
operator|+
operator|(
literal|2
operator|*
name|outputComponentSize
operator|)
operator|)
expr_stmt|;
name|copyPackedAlpha
operator|<
name|isSigned
operator|,
name|normalized
operator|,
name|toFloat
operator|>
operator|(
operator|(
name|packedValue
operator|>>
name|alphaShift
operator|)
operator|&
name|alphaMask
operator|,
name|offsetOutput
operator|+
operator|(
literal|3
operator|*
name|outputComponentSize
operator|)
operator|)
expr_stmt|;
block|}
end_expr_stmt
begin_endif
unit|}
endif|#
directive|endif
end_endif
begin_comment
comment|// LIBGLESV2_RENDERER_COPYVERTEX_H_
end_comment
end_unit
