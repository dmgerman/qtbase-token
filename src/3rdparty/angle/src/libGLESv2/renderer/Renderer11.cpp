begin_unit
begin_include
include|#
directive|include
file|"precompiled.h"
end_include
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2012-2013 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Renderer11.cpp: Implements a back-end specific class for the D3D11 renderer.
end_comment
begin_include
include|#
directive|include
file|"libGLESv2/main.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/utilities.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Buffer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/ProgramBinary.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Framebuffer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/RenderBuffer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/Renderer11.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/RenderTarget11.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/renderer11_utils.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/ShaderExecutable11.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/SwapChain11.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/Image11.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/VertexBuffer11.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/IndexBuffer11.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/BufferStorage11.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/VertexDataManager.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/IndexDataManager.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/TextureStorage11.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/Query11.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/Fence11.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/shaders/compiled/passthrough11vs.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/shaders/compiled/passthroughrgba11ps.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/shaders/compiled/passthroughrgb11ps.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/shaders/compiled/passthroughlum11ps.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/shaders/compiled/passthroughlumalpha11ps.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/shaders/compiled/clear11vs.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/shaders/compiled/clear11ps.h"
end_include
begin_include
include|#
directive|include
file|"libEGL/Display.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|_DEBUG
end_ifdef
begin_comment
comment|// this flag enables suppressing some spurious warnings that pop up in certain WebGL samples
end_comment
begin_comment
comment|// and conformance tests. to enable all warnings, remove this define.
end_comment
begin_define
DECL|macro|ANGLE_SUPPRESS_D3D11_HAZARD_WARNINGS
define|#
directive|define
name|ANGLE_SUPPRESS_D3D11_HAZARD_WARNINGS
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_namespace
DECL|namespace|rx
namespace|namespace
name|rx
block|{
DECL|member|RenderTargetFormats
specifier|static
specifier|const
name|DXGI_FORMAT
name|RenderTargetFormats
index|[]
init|=
block|{
name|DXGI_FORMAT_B8G8R8A8_UNORM
block|,
name|DXGI_FORMAT_R8G8B8A8_UNORM
block|}
decl_stmt|;
DECL|member|DepthStencilFormats
specifier|static
specifier|const
name|DXGI_FORMAT
name|DepthStencilFormats
index|[]
init|=
block|{
name|DXGI_FORMAT_UNKNOWN
block|,
name|DXGI_FORMAT_D24_UNORM_S8_UINT
block|,
name|DXGI_FORMAT_D16_UNORM
block|}
decl_stmt|;
enum|enum
block|{
DECL|enumerator|MAX_TEXTURE_IMAGE_UNITS_VTF_SM4
name|MAX_TEXTURE_IMAGE_UNITS_VTF_SM4
init|=
literal|16
block|}
enum|;
DECL|function|Renderer11
name|Renderer11
operator|::
name|Renderer11
parameter_list|(
name|egl
operator|::
name|Display
modifier|*
name|display
parameter_list|,
name|HDC
name|hDc
parameter_list|)
member_init_list|:
name|Renderer
argument_list|(
name|display
argument_list|)
member_init_list|,
name|mDc
argument_list|(
name|hDc
argument_list|)
block|{
name|mVertexDataManager
operator|=
name|NULL
expr_stmt|;
name|mIndexDataManager
operator|=
name|NULL
expr_stmt|;
name|mLineLoopIB
operator|=
name|NULL
expr_stmt|;
name|mTriangleFanIB
operator|=
name|NULL
expr_stmt|;
name|mCopyResourcesInitialized
operator|=
literal|false
expr_stmt|;
name|mCopyVB
operator|=
name|NULL
expr_stmt|;
name|mCopySampler
operator|=
name|NULL
expr_stmt|;
name|mCopyIL
operator|=
name|NULL
expr_stmt|;
name|mCopyVS
operator|=
name|NULL
expr_stmt|;
name|mCopyRGBAPS
operator|=
name|NULL
expr_stmt|;
name|mCopyRGBPS
operator|=
name|NULL
expr_stmt|;
name|mCopyLumPS
operator|=
name|NULL
expr_stmt|;
name|mCopyLumAlphaPS
operator|=
name|NULL
expr_stmt|;
name|mClearResourcesInitialized
operator|=
literal|false
expr_stmt|;
name|mClearVB
operator|=
name|NULL
expr_stmt|;
name|mClearIL
operator|=
name|NULL
expr_stmt|;
name|mClearVS
operator|=
name|NULL
expr_stmt|;
name|mClearPS
operator|=
name|NULL
expr_stmt|;
name|mClearScissorRS
operator|=
name|NULL
expr_stmt|;
name|mClearNoScissorRS
operator|=
name|NULL
expr_stmt|;
name|mSyncQuery
operator|=
name|NULL
expr_stmt|;
name|mD3d11Module
operator|=
name|NULL
expr_stmt|;
name|mDxgiModule
operator|=
name|NULL
expr_stmt|;
name|mDeviceLost
operator|=
literal|false
expr_stmt|;
name|mMaxSupportedSamples
operator|=
literal|0
expr_stmt|;
name|mDevice
operator|=
name|NULL
expr_stmt|;
name|mDeviceContext
operator|=
name|NULL
expr_stmt|;
name|mDxgiAdapter
operator|=
name|NULL
expr_stmt|;
name|mDxgiFactory
operator|=
name|NULL
expr_stmt|;
name|mDriverConstantBufferVS
operator|=
name|NULL
expr_stmt|;
name|mDriverConstantBufferPS
operator|=
name|NULL
expr_stmt|;
name|mBGRATextureSupport
operator|=
literal|false
expr_stmt|;
name|mIsGeometryShaderActive
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|~Renderer11
name|Renderer11
operator|::
name|~
name|Renderer11
parameter_list|()
block|{
name|release
argument_list|()
expr_stmt|;
block|}
DECL|function|makeRenderer11
name|Renderer11
modifier|*
name|Renderer11
operator|::
name|makeRenderer11
parameter_list|(
name|Renderer
modifier|*
name|renderer
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|HAS_DYNAMIC_TYPE
argument_list|(
name|rx
operator|::
name|Renderer11
operator|*
argument_list|,
name|renderer
argument_list|)
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|rx
operator|::
name|Renderer11
operator|*
argument_list|>
argument_list|(
name|renderer
argument_list|)
return|;
block|}
ifndef|#
directive|ifndef
name|__d3d11_1_h__
DECL|macro|D3D11_MESSAGE_ID_DEVICE_DRAW_RENDERTARGETVIEW_NOT_SET
define|#
directive|define
name|D3D11_MESSAGE_ID_DEVICE_DRAW_RENDERTARGETVIEW_NOT_SET
value|((D3D11_MESSAGE_ID)3146081)
endif|#
directive|endif
DECL|function|initialize
name|EGLint
name|Renderer11
operator|::
name|initialize
parameter_list|()
block|{
if|if
condition|(
operator|!
name|initializeCompiler
argument_list|()
condition|)
block|{
return|return
name|EGL_NOT_INITIALIZED
return|;
block|}
name|mDxgiModule
operator|=
name|LoadLibrary
argument_list|(
name|TEXT
argument_list|(
literal|"dxgi.dll"
argument_list|)
argument_list|)
expr_stmt|;
name|mD3d11Module
operator|=
name|LoadLibrary
argument_list|(
name|TEXT
argument_list|(
literal|"d3d11.dll"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mD3d11Module
operator|==
name|NULL
operator|||
name|mDxgiModule
operator|==
name|NULL
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not load D3D11 or DXGI library - aborting!\n"
argument_list|)
expr_stmt|;
return|return
name|EGL_NOT_INITIALIZED
return|;
block|}
comment|// create the D3D11 device
name|ASSERT
argument_list|(
name|mDevice
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|PFN_D3D11_CREATE_DEVICE
name|D3D11CreateDevice
init|=
operator|(
name|PFN_D3D11_CREATE_DEVICE
operator|)
name|GetProcAddress
argument_list|(
name|mD3d11Module
argument_list|,
literal|"D3D11CreateDevice"
argument_list|)
decl_stmt|;
if|if
condition|(
name|D3D11CreateDevice
operator|==
name|NULL
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not retrieve D3D11CreateDevice address - aborting!\n"
argument_list|)
expr_stmt|;
return|return
name|EGL_NOT_INITIALIZED
return|;
block|}
name|D3D_FEATURE_LEVEL
name|featureLevels
index|[]
init|=
block|{
name|D3D_FEATURE_LEVEL_11_0
block|,
name|D3D_FEATURE_LEVEL_10_1
block|,
name|D3D_FEATURE_LEVEL_10_0
block|,     }
decl_stmt|;
name|HRESULT
name|result
init|=
name|D3D11CreateDevice
argument_list|(
name|NULL
argument_list|,
name|D3D_DRIVER_TYPE_HARDWARE
argument_list|,
name|NULL
argument_list|,
if|#
directive|if
name|defined
argument_list|(
name|_DEBUG
argument_list|)
name|D3D11_CREATE_DEVICE_DEBUG
argument_list|,
else|#
directive|else
literal|0
argument_list|,
endif|#
directive|endif
name|featureLevels
argument_list|,
name|ArraySize
argument_list|(
name|featureLevels
argument_list|)
argument_list|,
name|D3D11_SDK_VERSION
argument_list|,
operator|&
name|mDevice
argument_list|,
operator|&
name|mFeatureLevel
argument_list|,
operator|&
name|mDeviceContext
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mDevice
operator|||
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not create D3D11 device - aborting!\n"
argument_list|)
expr_stmt|;
return|return
name|EGL_NOT_INITIALIZED
return|;
comment|// Cleanup done by destructor through glDestroyRenderer
block|}
name|IDXGIDevice
modifier|*
name|dxgiDevice
init|=
name|NULL
decl_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|QueryInterface
argument_list|(
name|__uuidof
argument_list|(
name|IDXGIDevice
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dxgiDevice
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not query DXGI device - aborting!\n"
argument_list|)
expr_stmt|;
return|return
name|EGL_NOT_INITIALIZED
return|;
block|}
name|result
operator|=
name|dxgiDevice
operator|->
name|GetParent
argument_list|(
name|__uuidof
argument_list|(
name|IDXGIAdapter
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|mDxgiAdapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not retrieve DXGI adapter - aborting!\n"
argument_list|)
expr_stmt|;
return|return
name|EGL_NOT_INITIALIZED
return|;
block|}
name|dxgiDevice
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mDxgiAdapter
operator|->
name|GetDesc
argument_list|(
operator|&
name|mAdapterDescription
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|mDescription
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mDescription
argument_list|)
argument_list|)
expr_stmt|;
name|wcstombs
argument_list|(
name|mDescription
argument_list|,
name|mAdapterDescription
operator|.
name|Description
argument_list|,
sizeof|sizeof
argument_list|(
name|mDescription
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|mDxgiAdapter
operator|->
name|GetParent
argument_list|(
name|__uuidof
argument_list|(
name|IDXGIFactory
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|mDxgiFactory
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mDxgiFactory
operator|||
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not create DXGI factory - aborting!\n"
argument_list|)
expr_stmt|;
return|return
name|EGL_NOT_INITIALIZED
return|;
block|}
comment|// Disable some spurious D3D11 debug warnings to prevent them from flooding the output log
if|#
directive|if
name|defined
argument_list|(
name|ANGLE_SUPPRESS_D3D11_HAZARD_WARNINGS
argument_list|)
operator|&&
name|defined
argument_list|(
name|_DEBUG
argument_list|)
name|ID3D11InfoQueue
modifier|*
name|infoQueue
decl_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|QueryInterface
argument_list|(
name|__uuidof
argument_list|(
name|ID3D11InfoQueue
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|infoQueue
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|D3D11_MESSAGE_ID
name|hideMessages
index|[]
init|=
block|{
name|D3D11_MESSAGE_ID_DEVICE_OMSETRENDERTARGETS_HAZARD
block|,
name|D3D11_MESSAGE_ID_DEVICE_PSSETSHADERRESOURCES_HAZARD
block|,
name|D3D11_MESSAGE_ID_DEVICE_DRAW_RENDERTARGETVIEW_NOT_SET
block|}
decl_stmt|;
name|D3D11_INFO_QUEUE_FILTER
name|filter
init|=
block|{
literal|0
block|}
decl_stmt|;
name|filter
operator|.
name|DenyList
operator|.
name|NumIDs
operator|=
name|ArraySize
argument_list|(
name|hideMessages
argument_list|)
expr_stmt|;
name|filter
operator|.
name|DenyList
operator|.
name|pIDList
operator|=
name|hideMessages
expr_stmt|;
name|infoQueue
operator|->
name|AddStorageFilterEntries
argument_list|(
operator|&
name|filter
argument_list|)
expr_stmt|;
name|infoQueue
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|unsigned
name|int
name|maxSupportedSamples
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|rtFormatCount
init|=
name|ArraySize
argument_list|(
name|RenderTargetFormats
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|dsFormatCount
init|=
name|ArraySize
argument_list|(
name|DepthStencilFormats
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rtFormatCount
operator|+
name|dsFormatCount
condition|;
operator|++
name|i
control|)
block|{
name|DXGI_FORMAT
name|format
init|=
operator|(
name|i
operator|<
name|rtFormatCount
operator|)
condition|?
name|RenderTargetFormats
index|[
name|i
index|]
else|:
name|DepthStencilFormats
index|[
name|i
operator|-
name|rtFormatCount
index|]
decl_stmt|;
if|if
condition|(
name|format
operator|!=
name|DXGI_FORMAT_UNKNOWN
condition|)
block|{
name|UINT
name|formatSupport
decl_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|CheckFormatSupport
argument_list|(
name|format
argument_list|,
operator|&
name|formatSupport
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
operator|&&
operator|(
name|formatSupport
operator|&
name|D3D11_FORMAT_SUPPORT_MULTISAMPLE_RENDERTARGET
operator|)
condition|)
block|{
name|MultisampleSupportInfo
name|supportInfo
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<=
name|D3D11_MAX_MULTISAMPLE_SAMPLE_COUNT
condition|;
name|j
operator|++
control|)
block|{
name|result
operator|=
name|mDevice
operator|->
name|CheckMultisampleQualityLevels
argument_list|(
name|format
argument_list|,
name|j
argument_list|,
operator|&
name|supportInfo
operator|.
name|qualityLevels
index|[
name|j
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
operator|&&
name|supportInfo
operator|.
name|qualityLevels
index|[
name|j
operator|-
literal|1
index|]
operator|>
literal|0
condition|)
block|{
name|maxSupportedSamples
operator|=
name|std
operator|::
name|max
argument_list|(
name|j
argument_list|,
name|maxSupportedSamples
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|supportInfo
operator|.
name|qualityLevels
index|[
name|j
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|mMultisampleSupportMap
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|format
argument_list|,
name|supportInfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|mMaxSupportedSamples
operator|=
name|maxSupportedSamples
expr_stmt|;
name|initializeDevice
argument_list|()
expr_stmt|;
comment|// BGRA texture support is optional in feature levels 10 and 10_1
name|UINT
name|formatSupport
decl_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|CheckFormatSupport
argument_list|(
name|DXGI_FORMAT_B8G8R8A8_UNORM
argument_list|,
operator|&
name|formatSupport
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Error checking BGRA format support: 0x%08X"
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|int
name|flags
init|=
operator|(
name|D3D11_FORMAT_SUPPORT_TEXTURE2D
operator||
name|D3D11_FORMAT_SUPPORT_RENDER_TARGET
operator|)
decl_stmt|;
name|mBGRATextureSupport
operator|=
operator|(
name|formatSupport
operator|&
name|flags
operator|)
operator|==
name|flags
expr_stmt|;
block|}
comment|// Check floating point texture support
specifier|static
specifier|const
name|unsigned
name|int
name|requiredTextureFlags
init|=
name|D3D11_FORMAT_SUPPORT_TEXTURE2D
operator||
name|D3D11_FORMAT_SUPPORT_TEXTURECUBE
decl_stmt|;
specifier|static
specifier|const
name|unsigned
name|int
name|requiredRenderableFlags
init|=
name|D3D11_FORMAT_SUPPORT_RENDER_TARGET
decl_stmt|;
specifier|static
specifier|const
name|unsigned
name|int
name|requiredFilterFlags
init|=
name|D3D11_FORMAT_SUPPORT_SHADER_SAMPLE
decl_stmt|;
name|DXGI_FORMAT
name|float16Formats
index|[]
init|=
block|{
name|DXGI_FORMAT_R16_FLOAT
block|,
name|DXGI_FORMAT_R16G16_FLOAT
block|,
name|DXGI_FORMAT_R16G16B16A16_FLOAT
block|,     }
decl_stmt|;
name|DXGI_FORMAT
name|float32Formats
index|[]
init|=
block|{
name|DXGI_FORMAT_R32_FLOAT
block|,
name|DXGI_FORMAT_R32G32_FLOAT
block|,
name|DXGI_FORMAT_R32G32B32_FLOAT
block|,
name|DXGI_FORMAT_R32G32B32A32_FLOAT
block|,     }
decl_stmt|;
name|mFloat16TextureSupport
operator|=
literal|true
expr_stmt|;
name|mFloat16FilterSupport
operator|=
literal|true
expr_stmt|;
name|mFloat16RenderSupport
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ArraySize
argument_list|(
name|float16Formats
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|mDevice
operator|->
name|CheckFormatSupport
argument_list|(
name|float16Formats
index|[
name|i
index|]
argument_list|,
operator|&
name|formatSupport
argument_list|)
argument_list|)
condition|)
block|{
name|mFloat16TextureSupport
operator|=
name|mFloat16TextureSupport
operator|&&
operator|(
name|formatSupport
operator|&
name|requiredTextureFlags
operator|)
operator|==
name|requiredTextureFlags
expr_stmt|;
name|mFloat16FilterSupport
operator|=
name|mFloat16FilterSupport
operator|&&
operator|(
name|formatSupport
operator|&
name|requiredFilterFlags
operator|)
operator|==
name|requiredFilterFlags
expr_stmt|;
name|mFloat16RenderSupport
operator|=
name|mFloat16RenderSupport
operator|&&
operator|(
name|formatSupport
operator|&
name|requiredRenderableFlags
operator|)
operator|==
name|requiredRenderableFlags
expr_stmt|;
block|}
else|else
block|{
name|mFloat16TextureSupport
operator|=
literal|false
expr_stmt|;
name|mFloat16RenderSupport
operator|=
literal|false
expr_stmt|;
name|mFloat16FilterSupport
operator|=
literal|false
expr_stmt|;
block|}
block|}
name|mFloat32TextureSupport
operator|=
literal|true
expr_stmt|;
name|mFloat32FilterSupport
operator|=
literal|true
expr_stmt|;
name|mFloat32RenderSupport
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ArraySize
argument_list|(
name|float32Formats
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|mDevice
operator|->
name|CheckFormatSupport
argument_list|(
name|float32Formats
index|[
name|i
index|]
argument_list|,
operator|&
name|formatSupport
argument_list|)
argument_list|)
condition|)
block|{
name|mFloat32TextureSupport
operator|=
name|mFloat32TextureSupport
operator|&&
operator|(
name|formatSupport
operator|&
name|requiredTextureFlags
operator|)
operator|==
name|requiredTextureFlags
expr_stmt|;
name|mFloat32FilterSupport
operator|=
name|mFloat32FilterSupport
operator|&&
operator|(
name|formatSupport
operator|&
name|requiredFilterFlags
operator|)
operator|==
name|requiredFilterFlags
expr_stmt|;
name|mFloat32RenderSupport
operator|=
name|mFloat32RenderSupport
operator|&&
operator|(
name|formatSupport
operator|&
name|requiredRenderableFlags
operator|)
operator|==
name|requiredRenderableFlags
expr_stmt|;
block|}
else|else
block|{
name|mFloat32TextureSupport
operator|=
literal|false
expr_stmt|;
name|mFloat32FilterSupport
operator|=
literal|false
expr_stmt|;
name|mFloat32RenderSupport
operator|=
literal|false
expr_stmt|;
block|}
block|}
comment|// Check compressed texture support
specifier|const
name|unsigned
name|int
name|requiredCompressedTextureFlags
init|=
name|D3D11_FORMAT_SUPPORT_TEXTURE2D
decl_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|mDevice
operator|->
name|CheckFormatSupport
argument_list|(
name|DXGI_FORMAT_BC1_UNORM
argument_list|,
operator|&
name|formatSupport
argument_list|)
argument_list|)
condition|)
block|{
name|mDXT1TextureSupport
operator|=
operator|(
name|formatSupport
operator|&
name|requiredCompressedTextureFlags
operator|)
operator|==
name|requiredCompressedTextureFlags
expr_stmt|;
block|}
else|else
block|{
name|mDXT1TextureSupport
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|mDevice
operator|->
name|CheckFormatSupport
argument_list|(
name|DXGI_FORMAT_BC3_UNORM
argument_list|,
operator|&
name|formatSupport
argument_list|)
argument_list|)
condition|)
block|{
name|mDXT3TextureSupport
operator|=
operator|(
name|formatSupport
operator|&
name|requiredCompressedTextureFlags
operator|)
operator|==
name|requiredCompressedTextureFlags
expr_stmt|;
block|}
else|else
block|{
name|mDXT3TextureSupport
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|mDevice
operator|->
name|CheckFormatSupport
argument_list|(
name|DXGI_FORMAT_BC5_UNORM
argument_list|,
operator|&
name|formatSupport
argument_list|)
argument_list|)
condition|)
block|{
name|mDXT5TextureSupport
operator|=
operator|(
name|formatSupport
operator|&
name|requiredCompressedTextureFlags
operator|)
operator|==
name|requiredCompressedTextureFlags
expr_stmt|;
block|}
else|else
block|{
name|mDXT5TextureSupport
operator|=
literal|false
expr_stmt|;
block|}
comment|// Check depth texture support
name|DXGI_FORMAT
name|depthTextureFormats
index|[]
init|=
block|{
name|DXGI_FORMAT_D16_UNORM
block|,
name|DXGI_FORMAT_D24_UNORM_S8_UINT
block|,     }
decl_stmt|;
specifier|static
specifier|const
name|unsigned
name|int
name|requiredDepthTextureFlags
init|=
name|D3D11_FORMAT_SUPPORT_DEPTH_STENCIL
operator||
name|D3D11_FORMAT_SUPPORT_TEXTURE2D
decl_stmt|;
name|mDepthTextureSupport
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ArraySize
argument_list|(
name|depthTextureFormats
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|mDevice
operator|->
name|CheckFormatSupport
argument_list|(
name|depthTextureFormats
index|[
name|i
index|]
argument_list|,
operator|&
name|formatSupport
argument_list|)
argument_list|)
condition|)
block|{
name|mDepthTextureSupport
operator|=
name|mDepthTextureSupport
operator|&&
operator|(
operator|(
name|formatSupport
operator|&
name|requiredDepthTextureFlags
operator|)
operator|==
name|requiredDepthTextureFlags
operator|)
expr_stmt|;
block|}
else|else
block|{
name|mDepthTextureSupport
operator|=
literal|false
expr_stmt|;
block|}
block|}
return|return
name|EGL_SUCCESS
return|;
block|}
comment|// do any one-time device initialization
comment|// NOTE: this is also needed after a device lost/reset
comment|// to reset the scene status and ensure the default states are reset.
DECL|function|initializeDevice
name|void
name|Renderer11
operator|::
name|initializeDevice
parameter_list|()
block|{
name|mStateCache
operator|.
name|initialize
argument_list|(
name|mDevice
argument_list|)
expr_stmt|;
name|mInputLayoutCache
operator|.
name|initialize
argument_list|(
name|mDevice
argument_list|,
name|mDeviceContext
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|mVertexDataManager
operator|&&
operator|!
name|mIndexDataManager
argument_list|)
expr_stmt|;
name|mVertexDataManager
operator|=
operator|new
name|VertexDataManager
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|mIndexDataManager
operator|=
operator|new
name|IndexDataManager
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|markAllStateDirty
argument_list|()
expr_stmt|;
block|}
DECL|function|generateConfigs
name|int
name|Renderer11
operator|::
name|generateConfigs
parameter_list|(
name|ConfigDesc
modifier|*
modifier|*
name|configDescList
parameter_list|)
block|{
name|unsigned
name|int
name|numRenderFormats
init|=
name|ArraySize
argument_list|(
name|RenderTargetFormats
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|numDepthFormats
init|=
name|ArraySize
argument_list|(
name|DepthStencilFormats
argument_list|)
decl_stmt|;
operator|(
operator|*
name|configDescList
operator|)
operator|=
operator|new
name|ConfigDesc
index|[
name|numRenderFormats
operator|*
name|numDepthFormats
index|]
expr_stmt|;
name|int
name|numConfigs
init|=
literal|0
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|formatIndex
init|=
literal|0
init|;
name|formatIndex
operator|<
name|numRenderFormats
condition|;
name|formatIndex
operator|++
control|)
block|{
for|for
control|(
name|unsigned
name|int
name|depthStencilIndex
init|=
literal|0
init|;
name|depthStencilIndex
operator|<
name|numDepthFormats
condition|;
name|depthStencilIndex
operator|++
control|)
block|{
name|DXGI_FORMAT
name|renderTargetFormat
init|=
name|RenderTargetFormats
index|[
name|formatIndex
index|]
decl_stmt|;
name|UINT
name|formatSupport
init|=
literal|0
decl_stmt|;
name|HRESULT
name|result
init|=
name|mDevice
operator|->
name|CheckFormatSupport
argument_list|(
name|renderTargetFormat
argument_list|,
operator|&
name|formatSupport
argument_list|)
decl_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
operator|&&
operator|(
name|formatSupport
operator|&
name|D3D11_FORMAT_SUPPORT_RENDER_TARGET
operator|)
condition|)
block|{
name|DXGI_FORMAT
name|depthStencilFormat
init|=
name|DepthStencilFormats
index|[
name|depthStencilIndex
index|]
decl_stmt|;
name|bool
name|depthStencilFormatOK
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|depthStencilFormat
operator|!=
name|DXGI_FORMAT_UNKNOWN
condition|)
block|{
name|UINT
name|formatSupport
init|=
literal|0
decl_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|CheckFormatSupport
argument_list|(
name|depthStencilFormat
argument_list|,
operator|&
name|formatSupport
argument_list|)
expr_stmt|;
name|depthStencilFormatOK
operator|=
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
operator|&&
operator|(
name|formatSupport
operator|&
name|D3D11_FORMAT_SUPPORT_DEPTH_STENCIL
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|depthStencilFormatOK
condition|)
block|{
name|ConfigDesc
name|newConfig
decl_stmt|;
name|newConfig
operator|.
name|renderTargetFormat
operator|=
name|d3d11_gl
operator|::
name|ConvertBackBufferFormat
argument_list|(
name|renderTargetFormat
argument_list|)
expr_stmt|;
name|newConfig
operator|.
name|depthStencilFormat
operator|=
name|d3d11_gl
operator|::
name|ConvertDepthStencilFormat
argument_list|(
name|depthStencilFormat
argument_list|)
expr_stmt|;
name|newConfig
operator|.
name|multiSample
operator|=
literal|0
expr_stmt|;
comment|// FIXME: enumerate multi-sampling
name|newConfig
operator|.
name|fastConfig
operator|=
literal|true
expr_stmt|;
comment|// Assume all DX11 format conversions to be fast
operator|(
operator|*
name|configDescList
operator|)
index|[
name|numConfigs
operator|++
index|]
operator|=
name|newConfig
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|numConfigs
return|;
block|}
DECL|function|deleteConfigs
name|void
name|Renderer11
operator|::
name|deleteConfigs
parameter_list|(
name|ConfigDesc
modifier|*
name|configDescList
parameter_list|)
block|{
operator|delete
index|[]
operator|(
name|configDescList
operator|)
expr_stmt|;
block|}
DECL|function|sync
name|void
name|Renderer11
operator|::
name|sync
parameter_list|(
name|bool
name|block
parameter_list|)
block|{
if|if
condition|(
name|block
condition|)
block|{
name|HRESULT
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|mSyncQuery
condition|)
block|{
name|D3D11_QUERY_DESC
name|queryDesc
decl_stmt|;
name|queryDesc
operator|.
name|Query
operator|=
name|D3D11_QUERY_EVENT
expr_stmt|;
name|queryDesc
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|CreateQuery
argument_list|(
operator|&
name|queryDesc
argument_list|,
operator|&
name|mSyncQuery
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mDeviceContext
operator|->
name|End
argument_list|(
name|mSyncQuery
argument_list|)
expr_stmt|;
name|mDeviceContext
operator|->
name|Flush
argument_list|()
expr_stmt|;
do|do
block|{
name|result
operator|=
name|mDeviceContext
operator|->
name|GetData
argument_list|(
name|mSyncQuery
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|D3D11_ASYNC_GETDATA_DONOTFLUSH
argument_list|)
expr_stmt|;
comment|// Keep polling, but allow other threads to do something useful first
name|Sleep
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|testDeviceLost
argument_list|(
literal|true
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
do|while
condition|(
name|result
operator|==
name|S_FALSE
condition|)
do|;
block|}
else|else
block|{
name|mDeviceContext
operator|->
name|Flush
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|createSwapChain
name|SwapChain
modifier|*
name|Renderer11
operator|::
name|createSwapChain
parameter_list|(
name|HWND
name|window
parameter_list|,
name|HANDLE
name|shareHandle
parameter_list|,
name|GLenum
name|backBufferFormat
parameter_list|,
name|GLenum
name|depthBufferFormat
parameter_list|)
block|{
return|return
operator|new
name|rx
operator|::
name|SwapChain11
argument_list|(
name|this
argument_list|,
name|window
argument_list|,
name|shareHandle
argument_list|,
name|backBufferFormat
argument_list|,
name|depthBufferFormat
argument_list|)
return|;
block|}
DECL|function|setSamplerState
name|void
name|Renderer11
operator|::
name|setSamplerState
parameter_list|(
name|gl
operator|::
name|SamplerType
name|type
parameter_list|,
name|int
name|index
parameter_list|,
specifier|const
name|gl
operator|::
name|SamplerState
modifier|&
name|samplerState
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|gl
operator|::
name|SAMPLER_PIXEL
condition|)
block|{
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|gl
operator|::
name|MAX_TEXTURE_IMAGE_UNITS
condition|)
block|{
name|ERR
argument_list|(
literal|"Pixel shader sampler index %i is not valid."
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mForceSetPixelSamplerStates
index|[
name|index
index|]
operator|||
name|memcmp
argument_list|(
operator|&
name|samplerState
argument_list|,
operator|&
name|mCurPixelSamplerStates
index|[
name|index
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|gl
operator|::
name|SamplerState
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ID3D11SamplerState
modifier|*
name|dxSamplerState
init|=
name|mStateCache
operator|.
name|getSamplerState
argument_list|(
name|samplerState
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dxSamplerState
condition|)
block|{
name|ERR
argument_list|(
literal|"NULL sampler state returned by RenderStateCache::getSamplerState, setting the default"
literal|"sampler state for pixel shaders at slot %i."
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
name|mDeviceContext
operator|->
name|PSSetSamplers
argument_list|(
name|index
argument_list|,
literal|1
argument_list|,
operator|&
name|dxSamplerState
argument_list|)
expr_stmt|;
name|mCurPixelSamplerStates
index|[
name|index
index|]
operator|=
name|samplerState
expr_stmt|;
block|}
name|mForceSetPixelSamplerStates
index|[
name|index
index|]
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|gl
operator|::
name|SAMPLER_VERTEX
condition|)
block|{
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
operator|(
name|int
operator|)
name|getMaxVertexTextureImageUnits
argument_list|()
condition|)
block|{
name|ERR
argument_list|(
literal|"Vertex shader sampler index %i is not valid."
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mForceSetVertexSamplerStates
index|[
name|index
index|]
operator|||
name|memcmp
argument_list|(
operator|&
name|samplerState
argument_list|,
operator|&
name|mCurVertexSamplerStates
index|[
name|index
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|gl
operator|::
name|SamplerState
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ID3D11SamplerState
modifier|*
name|dxSamplerState
init|=
name|mStateCache
operator|.
name|getSamplerState
argument_list|(
name|samplerState
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dxSamplerState
condition|)
block|{
name|ERR
argument_list|(
literal|"NULL sampler state returned by RenderStateCache::getSamplerState, setting the default"
literal|"sampler state for vertex shaders at slot %i."
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
name|mDeviceContext
operator|->
name|VSSetSamplers
argument_list|(
name|index
argument_list|,
literal|1
argument_list|,
operator|&
name|dxSamplerState
argument_list|)
expr_stmt|;
name|mCurVertexSamplerStates
index|[
name|index
index|]
operator|=
name|samplerState
expr_stmt|;
block|}
name|mForceSetVertexSamplerStates
index|[
name|index
index|]
operator|=
literal|false
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
DECL|function|setTexture
name|void
name|Renderer11
operator|::
name|setTexture
parameter_list|(
name|gl
operator|::
name|SamplerType
name|type
parameter_list|,
name|int
name|index
parameter_list|,
name|gl
operator|::
name|Texture
modifier|*
name|texture
parameter_list|)
block|{
name|ID3D11ShaderResourceView
modifier|*
name|textureSRV
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|serial
init|=
literal|0
decl_stmt|;
name|bool
name|forceSetTexture
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|texture
condition|)
block|{
name|TextureStorageInterface
modifier|*
name|texStorage
init|=
name|texture
operator|->
name|getNativeTexture
argument_list|()
decl_stmt|;
if|if
condition|(
name|texStorage
condition|)
block|{
name|TextureStorage11
modifier|*
name|storage11
init|=
name|TextureStorage11
operator|::
name|makeTextureStorage11
argument_list|(
name|texStorage
operator|->
name|getStorageInstance
argument_list|()
argument_list|)
decl_stmt|;
name|textureSRV
operator|=
name|storage11
operator|->
name|getSRV
argument_list|()
expr_stmt|;
block|}
comment|// If we get NULL back from getSRV here, something went wrong in the texture class and we're unexpectedly
comment|// missing the shader resource view
name|ASSERT
argument_list|(
name|textureSRV
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|serial
operator|=
name|texture
operator|->
name|getTextureSerial
argument_list|()
expr_stmt|;
name|forceSetTexture
operator|=
name|texture
operator|->
name|hasDirtyImages
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|gl
operator|::
name|SAMPLER_PIXEL
condition|)
block|{
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|gl
operator|::
name|MAX_TEXTURE_IMAGE_UNITS
condition|)
block|{
name|ERR
argument_list|(
literal|"Pixel shader sampler index %i is not valid."
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|forceSetTexture
operator|||
name|mCurPixelTextureSerials
index|[
name|index
index|]
operator|!=
name|serial
condition|)
block|{
name|mDeviceContext
operator|->
name|PSSetShaderResources
argument_list|(
name|index
argument_list|,
literal|1
argument_list|,
operator|&
name|textureSRV
argument_list|)
expr_stmt|;
block|}
name|mCurPixelTextureSerials
index|[
name|index
index|]
operator|=
name|serial
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|gl
operator|::
name|SAMPLER_VERTEX
condition|)
block|{
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
operator|(
name|int
operator|)
name|getMaxVertexTextureImageUnits
argument_list|()
condition|)
block|{
name|ERR
argument_list|(
literal|"Vertex shader sampler index %i is not valid."
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|forceSetTexture
operator|||
name|mCurVertexTextureSerials
index|[
name|index
index|]
operator|!=
name|serial
condition|)
block|{
name|mDeviceContext
operator|->
name|VSSetShaderResources
argument_list|(
name|index
argument_list|,
literal|1
argument_list|,
operator|&
name|textureSRV
argument_list|)
expr_stmt|;
block|}
name|mCurVertexTextureSerials
index|[
name|index
index|]
operator|=
name|serial
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
DECL|function|setRasterizerState
name|void
name|Renderer11
operator|::
name|setRasterizerState
parameter_list|(
specifier|const
name|gl
operator|::
name|RasterizerState
modifier|&
name|rasterState
parameter_list|)
block|{
if|if
condition|(
name|mForceSetRasterState
operator|||
name|memcmp
argument_list|(
operator|&
name|rasterState
argument_list|,
operator|&
name|mCurRasterState
argument_list|,
sizeof|sizeof
argument_list|(
name|gl
operator|::
name|RasterizerState
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ID3D11RasterizerState
modifier|*
name|dxRasterState
init|=
name|mStateCache
operator|.
name|getRasterizerState
argument_list|(
name|rasterState
argument_list|,
name|mScissorEnabled
argument_list|,
name|mCurDepthSize
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dxRasterState
condition|)
block|{
name|ERR
argument_list|(
literal|"NULL rasterizer state returned by RenderStateCache::getRasterizerState, setting the default"
literal|"rasterizer state."
argument_list|)
expr_stmt|;
block|}
name|mDeviceContext
operator|->
name|RSSetState
argument_list|(
name|dxRasterState
argument_list|)
expr_stmt|;
name|mCurRasterState
operator|=
name|rasterState
expr_stmt|;
block|}
name|mForceSetRasterState
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|setBlendState
name|void
name|Renderer11
operator|::
name|setBlendState
parameter_list|(
specifier|const
name|gl
operator|::
name|BlendState
modifier|&
name|blendState
parameter_list|,
specifier|const
name|gl
operator|::
name|Color
modifier|&
name|blendColor
parameter_list|,
name|unsigned
name|int
name|sampleMask
parameter_list|)
block|{
if|if
condition|(
name|mForceSetBlendState
operator|||
name|memcmp
argument_list|(
operator|&
name|blendState
argument_list|,
operator|&
name|mCurBlendState
argument_list|,
sizeof|sizeof
argument_list|(
name|gl
operator|::
name|BlendState
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|memcmp
argument_list|(
operator|&
name|blendColor
argument_list|,
operator|&
name|mCurBlendColor
argument_list|,
sizeof|sizeof
argument_list|(
name|gl
operator|::
name|Color
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|sampleMask
operator|!=
name|mCurSampleMask
condition|)
block|{
name|ID3D11BlendState
modifier|*
name|dxBlendState
init|=
name|mStateCache
operator|.
name|getBlendState
argument_list|(
name|blendState
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dxBlendState
condition|)
block|{
name|ERR
argument_list|(
literal|"NULL blend state returned by RenderStateCache::getBlendState, setting the default "
literal|"blend state."
argument_list|)
expr_stmt|;
block|}
specifier|const
name|float
name|blendColors
index|[]
init|=
block|{
name|blendColor
operator|.
name|red
block|,
name|blendColor
operator|.
name|green
block|,
name|blendColor
operator|.
name|blue
block|,
name|blendColor
operator|.
name|alpha
block|}
decl_stmt|;
name|mDeviceContext
operator|->
name|OMSetBlendState
argument_list|(
name|dxBlendState
argument_list|,
name|blendColors
argument_list|,
name|sampleMask
argument_list|)
expr_stmt|;
name|mCurBlendState
operator|=
name|blendState
expr_stmt|;
name|mCurBlendColor
operator|=
name|blendColor
expr_stmt|;
name|mCurSampleMask
operator|=
name|sampleMask
expr_stmt|;
block|}
name|mForceSetBlendState
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|setDepthStencilState
name|void
name|Renderer11
operator|::
name|setDepthStencilState
parameter_list|(
specifier|const
name|gl
operator|::
name|DepthStencilState
modifier|&
name|depthStencilState
parameter_list|,
name|int
name|stencilRef
parameter_list|,
name|int
name|stencilBackRef
parameter_list|,
name|bool
name|frontFaceCCW
parameter_list|)
block|{
if|if
condition|(
name|mForceSetDepthStencilState
operator|||
name|memcmp
argument_list|(
operator|&
name|depthStencilState
argument_list|,
operator|&
name|mCurDepthStencilState
argument_list|,
sizeof|sizeof
argument_list|(
name|gl
operator|::
name|DepthStencilState
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|stencilRef
operator|!=
name|mCurStencilRef
operator|||
name|stencilBackRef
operator|!=
name|mCurStencilBackRef
condition|)
block|{
if|if
condition|(
name|depthStencilState
operator|.
name|stencilWritemask
operator|!=
name|depthStencilState
operator|.
name|stencilBackWritemask
operator|||
name|stencilRef
operator|!=
name|stencilBackRef
operator|||
name|depthStencilState
operator|.
name|stencilMask
operator|!=
name|depthStencilState
operator|.
name|stencilBackMask
condition|)
block|{
name|ERR
argument_list|(
literal|"Separate front/back stencil writemasks, reference values, or stencil mask values are "
literal|"invalid under WebGL."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|ID3D11DepthStencilState
modifier|*
name|dxDepthStencilState
init|=
name|mStateCache
operator|.
name|getDepthStencilState
argument_list|(
name|depthStencilState
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dxDepthStencilState
condition|)
block|{
name|ERR
argument_list|(
literal|"NULL depth stencil state returned by RenderStateCache::getDepthStencilState, "
literal|"setting the default depth stencil state."
argument_list|)
expr_stmt|;
block|}
name|mDeviceContext
operator|->
name|OMSetDepthStencilState
argument_list|(
name|dxDepthStencilState
argument_list|,
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|stencilRef
argument_list|)
argument_list|)
expr_stmt|;
name|mCurDepthStencilState
operator|=
name|depthStencilState
expr_stmt|;
name|mCurStencilRef
operator|=
name|stencilRef
expr_stmt|;
name|mCurStencilBackRef
operator|=
name|stencilBackRef
expr_stmt|;
block|}
name|mForceSetDepthStencilState
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|setScissorRectangle
name|void
name|Renderer11
operator|::
name|setScissorRectangle
parameter_list|(
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|scissor
parameter_list|,
name|bool
name|enabled
parameter_list|)
block|{
if|if
condition|(
name|mForceSetScissor
operator|||
name|memcmp
argument_list|(
operator|&
name|scissor
argument_list|,
operator|&
name|mCurScissor
argument_list|,
sizeof|sizeof
argument_list|(
name|gl
operator|::
name|Rectangle
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|enabled
operator|!=
name|mScissorEnabled
condition|)
block|{
if|if
condition|(
name|enabled
condition|)
block|{
name|D3D11_RECT
name|rect
decl_stmt|;
name|rect
operator|.
name|left
operator|=
name|std
operator|::
name|max
argument_list|(
literal|0
argument_list|,
name|scissor
operator|.
name|x
argument_list|)
expr_stmt|;
name|rect
operator|.
name|top
operator|=
name|std
operator|::
name|max
argument_list|(
literal|0
argument_list|,
name|scissor
operator|.
name|y
argument_list|)
expr_stmt|;
name|rect
operator|.
name|right
operator|=
name|scissor
operator|.
name|x
operator|+
name|std
operator|::
name|max
argument_list|(
literal|0
argument_list|,
name|scissor
operator|.
name|width
argument_list|)
expr_stmt|;
name|rect
operator|.
name|bottom
operator|=
name|scissor
operator|.
name|y
operator|+
name|std
operator|::
name|max
argument_list|(
literal|0
argument_list|,
name|scissor
operator|.
name|height
argument_list|)
expr_stmt|;
name|mDeviceContext
operator|->
name|RSSetScissorRects
argument_list|(
literal|1
argument_list|,
operator|&
name|rect
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|enabled
operator|!=
name|mScissorEnabled
condition|)
block|{
name|mForceSetRasterState
operator|=
literal|true
expr_stmt|;
block|}
name|mCurScissor
operator|=
name|scissor
expr_stmt|;
name|mScissorEnabled
operator|=
name|enabled
expr_stmt|;
block|}
name|mForceSetScissor
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|setViewport
name|bool
name|Renderer11
operator|::
name|setViewport
parameter_list|(
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|viewport
parameter_list|,
name|float
name|zNear
parameter_list|,
name|float
name|zFar
parameter_list|,
name|GLenum
name|drawMode
parameter_list|,
name|GLenum
name|frontFace
parameter_list|,
name|bool
name|ignoreViewport
parameter_list|)
block|{
name|gl
operator|::
name|Rectangle
name|actualViewport
init|=
name|viewport
decl_stmt|;
name|float
name|actualZNear
init|=
name|gl
operator|::
name|clamp01
argument_list|(
name|zNear
argument_list|)
decl_stmt|;
name|float
name|actualZFar
init|=
name|gl
operator|::
name|clamp01
argument_list|(
name|zFar
argument_list|)
decl_stmt|;
if|if
condition|(
name|ignoreViewport
condition|)
block|{
name|actualViewport
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|actualViewport
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|actualViewport
operator|.
name|width
operator|=
name|mRenderTargetDesc
operator|.
name|width
expr_stmt|;
name|actualViewport
operator|.
name|height
operator|=
name|mRenderTargetDesc
operator|.
name|height
expr_stmt|;
name|actualZNear
operator|=
literal|0.0f
expr_stmt|;
name|actualZFar
operator|=
literal|1.0f
expr_stmt|;
block|}
comment|// Get D3D viewport bounds, which depends on the feature level
specifier|const
name|Range
modifier|&
name|viewportBounds
init|=
name|getViewportBounds
argument_list|()
decl_stmt|;
comment|// Clamp width and height first to the gl maximum, then clamp further if we extend past the D3D maximum bounds
name|D3D11_VIEWPORT
name|dxViewport
decl_stmt|;
name|dxViewport
operator|.
name|TopLeftX
operator|=
name|gl
operator|::
name|clamp
argument_list|(
name|actualViewport
operator|.
name|x
argument_list|,
name|viewportBounds
operator|.
name|start
argument_list|,
name|viewportBounds
operator|.
name|end
argument_list|)
expr_stmt|;
name|dxViewport
operator|.
name|TopLeftY
operator|=
name|gl
operator|::
name|clamp
argument_list|(
name|actualViewport
operator|.
name|y
argument_list|,
name|viewportBounds
operator|.
name|start
argument_list|,
name|viewportBounds
operator|.
name|end
argument_list|)
expr_stmt|;
name|dxViewport
operator|.
name|Width
operator|=
name|gl
operator|::
name|clamp
argument_list|(
name|actualViewport
operator|.
name|width
argument_list|,
literal|0
argument_list|,
name|getMaxViewportDimension
argument_list|()
argument_list|)
expr_stmt|;
name|dxViewport
operator|.
name|Height
operator|=
name|gl
operator|::
name|clamp
argument_list|(
name|actualViewport
operator|.
name|height
argument_list|,
literal|0
argument_list|,
name|getMaxViewportDimension
argument_list|()
argument_list|)
expr_stmt|;
name|dxViewport
operator|.
name|Width
operator|=
name|std
operator|::
name|min
argument_list|(
operator|(
name|int
operator|)
name|dxViewport
operator|.
name|Width
argument_list|,
name|viewportBounds
operator|.
name|end
operator|-
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|dxViewport
operator|.
name|TopLeftX
argument_list|)
argument_list|)
expr_stmt|;
name|dxViewport
operator|.
name|Height
operator|=
name|std
operator|::
name|min
argument_list|(
operator|(
name|int
operator|)
name|dxViewport
operator|.
name|Height
argument_list|,
name|viewportBounds
operator|.
name|end
operator|-
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|dxViewport
operator|.
name|TopLeftY
argument_list|)
argument_list|)
expr_stmt|;
name|dxViewport
operator|.
name|MinDepth
operator|=
name|actualZNear
expr_stmt|;
name|dxViewport
operator|.
name|MaxDepth
operator|=
name|actualZFar
expr_stmt|;
if|if
condition|(
name|dxViewport
operator|.
name|Width
operator|<=
literal|0
operator|||
name|dxViewport
operator|.
name|Height
operator|<=
literal|0
condition|)
block|{
return|return
literal|false
return|;
comment|// Nothing to render
block|}
name|bool
name|viewportChanged
init|=
name|mForceSetViewport
operator|||
name|memcmp
argument_list|(
operator|&
name|actualViewport
argument_list|,
operator|&
name|mCurViewport
argument_list|,
sizeof|sizeof
argument_list|(
name|gl
operator|::
name|Rectangle
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|actualZNear
operator|!=
name|mCurNear
operator|||
name|actualZFar
operator|!=
name|mCurFar
decl_stmt|;
if|if
condition|(
name|viewportChanged
condition|)
block|{
name|mDeviceContext
operator|->
name|RSSetViewports
argument_list|(
literal|1
argument_list|,
operator|&
name|dxViewport
argument_list|)
expr_stmt|;
name|mCurViewport
operator|=
name|actualViewport
expr_stmt|;
name|mCurNear
operator|=
name|actualZNear
expr_stmt|;
name|mCurFar
operator|=
name|actualZFar
expr_stmt|;
name|mPixelConstants
operator|.
name|viewCoords
index|[
literal|0
index|]
operator|=
name|actualViewport
operator|.
name|width
operator|*
literal|0.5f
expr_stmt|;
name|mPixelConstants
operator|.
name|viewCoords
index|[
literal|1
index|]
operator|=
name|actualViewport
operator|.
name|height
operator|*
literal|0.5f
expr_stmt|;
name|mPixelConstants
operator|.
name|viewCoords
index|[
literal|2
index|]
operator|=
name|actualViewport
operator|.
name|x
operator|+
operator|(
name|actualViewport
operator|.
name|width
operator|*
literal|0.5f
operator|)
expr_stmt|;
name|mPixelConstants
operator|.
name|viewCoords
index|[
literal|3
index|]
operator|=
name|actualViewport
operator|.
name|y
operator|+
operator|(
name|actualViewport
operator|.
name|height
operator|*
literal|0.5f
operator|)
expr_stmt|;
name|mPixelConstants
operator|.
name|depthFront
index|[
literal|0
index|]
operator|=
operator|(
name|actualZFar
operator|-
name|actualZNear
operator|)
operator|*
literal|0.5f
expr_stmt|;
name|mPixelConstants
operator|.
name|depthFront
index|[
literal|1
index|]
operator|=
operator|(
name|actualZNear
operator|+
name|actualZFar
operator|)
operator|*
literal|0.5f
expr_stmt|;
name|mVertexConstants
operator|.
name|depthRange
index|[
literal|0
index|]
operator|=
name|actualZNear
expr_stmt|;
name|mVertexConstants
operator|.
name|depthRange
index|[
literal|1
index|]
operator|=
name|actualZFar
expr_stmt|;
name|mVertexConstants
operator|.
name|depthRange
index|[
literal|2
index|]
operator|=
name|actualZFar
operator|-
name|actualZNear
expr_stmt|;
name|mPixelConstants
operator|.
name|depthRange
index|[
literal|0
index|]
operator|=
name|actualZNear
expr_stmt|;
name|mPixelConstants
operator|.
name|depthRange
index|[
literal|1
index|]
operator|=
name|actualZFar
expr_stmt|;
name|mPixelConstants
operator|.
name|depthRange
index|[
literal|2
index|]
operator|=
name|actualZFar
operator|-
name|actualZNear
expr_stmt|;
block|}
name|mForceSetViewport
operator|=
literal|false
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|applyPrimitiveType
name|bool
name|Renderer11
operator|::
name|applyPrimitiveType
parameter_list|(
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|)
block|{
name|D3D11_PRIMITIVE_TOPOLOGY
name|primitiveTopology
init|=
name|D3D_PRIMITIVE_TOPOLOGY_UNDEFINED
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|GL_POINTS
case|:
name|primitiveTopology
operator|=
name|D3D11_PRIMITIVE_TOPOLOGY_POINTLIST
expr_stmt|;
break|break;
case|case
name|GL_LINES
case|:
name|primitiveTopology
operator|=
name|D3D_PRIMITIVE_TOPOLOGY_LINELIST
expr_stmt|;
break|break;
case|case
name|GL_LINE_LOOP
case|:
name|primitiveTopology
operator|=
name|D3D_PRIMITIVE_TOPOLOGY_LINESTRIP
expr_stmt|;
break|break;
case|case
name|GL_LINE_STRIP
case|:
name|primitiveTopology
operator|=
name|D3D_PRIMITIVE_TOPOLOGY_LINESTRIP
expr_stmt|;
break|break;
case|case
name|GL_TRIANGLES
case|:
name|primitiveTopology
operator|=
name|D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST
expr_stmt|;
break|break;
case|case
name|GL_TRIANGLE_STRIP
case|:
name|primitiveTopology
operator|=
name|D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP
expr_stmt|;
break|break;
comment|// emulate fans via rewriting index buffer
case|case
name|GL_TRIANGLE_FAN
case|:
name|primitiveTopology
operator|=
name|D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST
expr_stmt|;
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|mDeviceContext
operator|->
name|IASetPrimitiveTopology
argument_list|(
name|primitiveTopology
argument_list|)
expr_stmt|;
return|return
name|count
operator|>
literal|0
return|;
block|}
DECL|function|applyRenderTarget
name|bool
name|Renderer11
operator|::
name|applyRenderTarget
parameter_list|(
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
parameter_list|)
block|{
comment|// Get the color render buffer and serial
comment|// Also extract the render target dimensions and view
name|unsigned
name|int
name|renderTargetWidth
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|renderTargetHeight
init|=
literal|0
decl_stmt|;
name|GLenum
name|renderTargetFormat
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|renderTargetSerials
index|[
name|gl
operator|::
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|ID3D11RenderTargetView
modifier|*
name|framebufferRTVs
index|[
name|gl
operator|::
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
index|]
init|=
block|{
name|NULL
block|}
decl_stmt|;
name|bool
name|missingColorRenderTarget
init|=
literal|true
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|colorAttachment
init|=
literal|0
init|;
name|colorAttachment
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
condition|;
name|colorAttachment
operator|++
control|)
block|{
specifier|const
name|GLenum
name|drawBufferState
init|=
name|framebuffer
operator|->
name|getDrawBufferState
argument_list|(
name|colorAttachment
argument_list|)
decl_stmt|;
if|if
condition|(
name|framebuffer
operator|->
name|getColorbufferType
argument_list|(
name|colorAttachment
argument_list|)
operator|!=
name|GL_NONE
operator|&&
name|drawBufferState
operator|!=
name|GL_NONE
condition|)
block|{
comment|// the draw buffer must be either "none", "back" for the default buffer or the same index as this color (in order)
name|ASSERT
argument_list|(
name|drawBufferState
operator|==
name|GL_BACK
operator|||
name|drawBufferState
operator|==
operator|(
name|GL_COLOR_ATTACHMENT0_EXT
operator|+
name|colorAttachment
operator|)
argument_list|)
expr_stmt|;
name|gl
operator|::
name|Renderbuffer
modifier|*
name|colorbuffer
init|=
name|framebuffer
operator|->
name|getColorbuffer
argument_list|(
name|colorAttachment
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|colorbuffer
condition|)
block|{
name|ERR
argument_list|(
literal|"render target pointer unexpectedly null."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// check for zero-sized default framebuffer, which is a special case.
comment|// in this case we do not wish to modify any state and just silently return false.
comment|// this will not report any gl error but will cause the calling method to return.
if|if
condition|(
name|colorbuffer
operator|->
name|getWidth
argument_list|()
operator|==
literal|0
operator|||
name|colorbuffer
operator|->
name|getHeight
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|renderTargetSerials
index|[
name|colorAttachment
index|]
operator|=
name|colorbuffer
operator|->
name|getSerial
argument_list|()
expr_stmt|;
comment|// Extract the render target dimensions and view
name|RenderTarget11
modifier|*
name|renderTarget
init|=
name|RenderTarget11
operator|::
name|makeRenderTarget11
argument_list|(
name|colorbuffer
operator|->
name|getRenderTarget
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|renderTarget
condition|)
block|{
name|ERR
argument_list|(
literal|"render target pointer unexpectedly null."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|framebufferRTVs
index|[
name|colorAttachment
index|]
operator|=
name|renderTarget
operator|->
name|getRenderTargetView
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|framebufferRTVs
index|[
name|colorAttachment
index|]
condition|)
block|{
name|ERR
argument_list|(
literal|"render target view pointer unexpectedly null."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|missingColorRenderTarget
condition|)
block|{
name|renderTargetWidth
operator|=
name|colorbuffer
operator|->
name|getWidth
argument_list|()
expr_stmt|;
name|renderTargetHeight
operator|=
name|colorbuffer
operator|->
name|getHeight
argument_list|()
expr_stmt|;
name|renderTargetFormat
operator|=
name|colorbuffer
operator|->
name|getActualFormat
argument_list|()
expr_stmt|;
name|missingColorRenderTarget
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
comment|// Get the depth stencil render buffer and serials
name|gl
operator|::
name|Renderbuffer
modifier|*
name|depthStencil
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|depthbufferSerial
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|stencilbufferSerial
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|framebuffer
operator|->
name|getDepthbufferType
argument_list|()
operator|!=
name|GL_NONE
condition|)
block|{
name|depthStencil
operator|=
name|framebuffer
operator|->
name|getDepthbuffer
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|depthStencil
condition|)
block|{
name|ERR
argument_list|(
literal|"Depth stencil pointer unexpectedly null."
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|framebufferRTVs
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|depthbufferSerial
operator|=
name|depthStencil
operator|->
name|getSerial
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|framebuffer
operator|->
name|getStencilbufferType
argument_list|()
operator|!=
name|GL_NONE
condition|)
block|{
name|depthStencil
operator|=
name|framebuffer
operator|->
name|getStencilbuffer
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|depthStencil
condition|)
block|{
name|ERR
argument_list|(
literal|"Depth stencil pointer unexpectedly null."
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|framebufferRTVs
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|stencilbufferSerial
operator|=
name|depthStencil
operator|->
name|getSerial
argument_list|()
expr_stmt|;
block|}
comment|// Extract the depth stencil sizes and view
name|unsigned
name|int
name|depthSize
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|stencilSize
init|=
literal|0
decl_stmt|;
name|ID3D11DepthStencilView
modifier|*
name|framebufferDSV
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|depthStencil
condition|)
block|{
name|RenderTarget11
modifier|*
name|depthStencilRenderTarget
init|=
name|RenderTarget11
operator|::
name|makeRenderTarget11
argument_list|(
name|depthStencil
operator|->
name|getDepthStencil
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|depthStencilRenderTarget
condition|)
block|{
name|ERR
argument_list|(
literal|"render target pointer unexpectedly null."
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|framebufferRTVs
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|framebufferDSV
operator|=
name|depthStencilRenderTarget
operator|->
name|getDepthStencilView
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|framebufferDSV
condition|)
block|{
name|ERR
argument_list|(
literal|"depth stencil view pointer unexpectedly null."
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|framebufferRTVs
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// If there is no render buffer, the width, height and format values come from
comment|// the depth stencil
if|if
condition|(
name|missingColorRenderTarget
condition|)
block|{
name|renderTargetWidth
operator|=
name|depthStencil
operator|->
name|getWidth
argument_list|()
expr_stmt|;
name|renderTargetHeight
operator|=
name|depthStencil
operator|->
name|getHeight
argument_list|()
expr_stmt|;
name|renderTargetFormat
operator|=
name|depthStencil
operator|->
name|getActualFormat
argument_list|()
expr_stmt|;
block|}
name|depthSize
operator|=
name|depthStencil
operator|->
name|getDepthSize
argument_list|()
expr_stmt|;
name|stencilSize
operator|=
name|depthStencil
operator|->
name|getStencilSize
argument_list|()
expr_stmt|;
block|}
comment|// Apply the render target and depth stencil
if|if
condition|(
operator|!
name|mRenderTargetDescInitialized
operator|||
operator|!
name|mDepthStencilInitialized
operator|||
name|memcmp
argument_list|(
name|renderTargetSerials
argument_list|,
name|mAppliedRenderTargetSerials
argument_list|,
sizeof|sizeof
argument_list|(
name|renderTargetSerials
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|depthbufferSerial
operator|!=
name|mAppliedDepthbufferSerial
operator|||
name|stencilbufferSerial
operator|!=
name|mAppliedStencilbufferSerial
condition|)
block|{
name|mDeviceContext
operator|->
name|OMSetRenderTargets
argument_list|(
name|getMaxRenderTargets
argument_list|()
argument_list|,
name|framebufferRTVs
argument_list|,
name|framebufferDSV
argument_list|)
expr_stmt|;
name|mRenderTargetDesc
operator|.
name|width
operator|=
name|renderTargetWidth
expr_stmt|;
name|mRenderTargetDesc
operator|.
name|height
operator|=
name|renderTargetHeight
expr_stmt|;
name|mRenderTargetDesc
operator|.
name|format
operator|=
name|renderTargetFormat
expr_stmt|;
name|mForceSetViewport
operator|=
literal|true
expr_stmt|;
name|mForceSetScissor
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|mDepthStencilInitialized
operator|||
name|depthSize
operator|!=
name|mCurDepthSize
condition|)
block|{
name|mCurDepthSize
operator|=
name|depthSize
expr_stmt|;
name|mForceSetRasterState
operator|=
literal|true
expr_stmt|;
block|}
name|mCurStencilSize
operator|=
name|stencilSize
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|rtIndex
init|=
literal|0
init|;
name|rtIndex
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
condition|;
name|rtIndex
operator|++
control|)
block|{
name|mAppliedRenderTargetSerials
index|[
name|rtIndex
index|]
operator|=
name|renderTargetSerials
index|[
name|rtIndex
index|]
expr_stmt|;
block|}
name|mAppliedDepthbufferSerial
operator|=
name|depthbufferSerial
expr_stmt|;
name|mAppliedStencilbufferSerial
operator|=
name|stencilbufferSerial
expr_stmt|;
name|mRenderTargetDescInitialized
operator|=
literal|true
expr_stmt|;
name|mDepthStencilInitialized
operator|=
literal|true
expr_stmt|;
block|}
name|SafeRelease
argument_list|(
name|framebufferRTVs
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|framebufferDSV
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|applyVertexBuffer
name|GLenum
name|Renderer11
operator|::
name|applyVertexBuffer
parameter_list|(
name|gl
operator|::
name|ProgramBinary
modifier|*
name|programBinary
parameter_list|,
name|gl
operator|::
name|VertexAttribute
name|vertexAttributes
index|[]
parameter_list|,
name|GLint
name|first
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLsizei
name|instances
parameter_list|)
block|{
name|TranslatedAttribute
name|attributes
index|[
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
index|]
decl_stmt|;
name|GLenum
name|err
init|=
name|mVertexDataManager
operator|->
name|prepareVertexData
argument_list|(
name|vertexAttributes
argument_list|,
name|programBinary
argument_list|,
name|first
argument_list|,
name|count
argument_list|,
name|attributes
argument_list|,
name|instances
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|!=
name|GL_NO_ERROR
condition|)
block|{
return|return
name|err
return|;
block|}
return|return
name|mInputLayoutCache
operator|.
name|applyVertexBuffers
argument_list|(
name|attributes
argument_list|,
name|programBinary
argument_list|)
return|;
block|}
DECL|function|applyIndexBuffer
name|GLenum
name|Renderer11
operator|::
name|applyIndexBuffer
parameter_list|(
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|gl
operator|::
name|Buffer
modifier|*
name|elementArrayBuffer
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|TranslatedIndexData
modifier|*
name|indexInfo
parameter_list|)
block|{
name|GLenum
name|err
init|=
name|mIndexDataManager
operator|->
name|prepareIndexData
argument_list|(
name|type
argument_list|,
name|count
argument_list|,
name|elementArrayBuffer
argument_list|,
name|indices
argument_list|,
name|indexInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|==
name|GL_NO_ERROR
condition|)
block|{
if|if
condition|(
name|indexInfo
operator|->
name|storage
condition|)
block|{
if|if
condition|(
name|indexInfo
operator|->
name|serial
operator|!=
name|mAppliedStorageIBSerial
operator|||
name|indexInfo
operator|->
name|startOffset
operator|!=
name|mAppliedIBOffset
condition|)
block|{
name|BufferStorage11
modifier|*
name|storage
init|=
name|BufferStorage11
operator|::
name|makeBufferStorage11
argument_list|(
name|indexInfo
operator|->
name|storage
argument_list|)
decl_stmt|;
name|IndexBuffer11
modifier|*
name|indexBuffer
init|=
name|IndexBuffer11
operator|::
name|makeIndexBuffer11
argument_list|(
name|indexInfo
operator|->
name|indexBuffer
argument_list|)
decl_stmt|;
name|mDeviceContext
operator|->
name|IASetIndexBuffer
argument_list|(
name|storage
operator|->
name|getBuffer
argument_list|()
argument_list|,
name|indexBuffer
operator|->
name|getIndexFormat
argument_list|()
argument_list|,
name|indexInfo
operator|->
name|startOffset
argument_list|)
expr_stmt|;
name|mAppliedIBSerial
operator|=
literal|0
expr_stmt|;
name|mAppliedStorageIBSerial
operator|=
name|storage
operator|->
name|getSerial
argument_list|()
expr_stmt|;
name|mAppliedIBOffset
operator|=
name|indexInfo
operator|->
name|startOffset
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|indexInfo
operator|->
name|serial
operator|!=
name|mAppliedIBSerial
operator|||
name|indexInfo
operator|->
name|startOffset
operator|!=
name|mAppliedIBOffset
condition|)
block|{
name|IndexBuffer11
modifier|*
name|indexBuffer
init|=
name|IndexBuffer11
operator|::
name|makeIndexBuffer11
argument_list|(
name|indexInfo
operator|->
name|indexBuffer
argument_list|)
decl_stmt|;
name|mDeviceContext
operator|->
name|IASetIndexBuffer
argument_list|(
name|indexBuffer
operator|->
name|getBuffer
argument_list|()
argument_list|,
name|indexBuffer
operator|->
name|getIndexFormat
argument_list|()
argument_list|,
name|indexInfo
operator|->
name|startOffset
argument_list|)
expr_stmt|;
name|mAppliedIBSerial
operator|=
name|indexInfo
operator|->
name|serial
expr_stmt|;
name|mAppliedStorageIBSerial
operator|=
literal|0
expr_stmt|;
name|mAppliedIBOffset
operator|=
name|indexInfo
operator|->
name|startOffset
expr_stmt|;
block|}
block|}
return|return
name|err
return|;
block|}
DECL|function|drawArrays
name|void
name|Renderer11
operator|::
name|drawArrays
parameter_list|(
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLsizei
name|instances
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|==
name|GL_LINE_LOOP
condition|)
block|{
name|drawLineLoop
argument_list|(
name|count
argument_list|,
name|GL_NONE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|GL_TRIANGLE_FAN
condition|)
block|{
name|drawTriangleFan
argument_list|(
name|count
argument_list|,
name|GL_NONE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|instances
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instances
operator|>
literal|0
condition|)
block|{
name|mDeviceContext
operator|->
name|DrawInstanced
argument_list|(
name|count
argument_list|,
name|instances
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mDeviceContext
operator|->
name|Draw
argument_list|(
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|drawElements
name|void
name|Renderer11
operator|::
name|drawElements
parameter_list|(
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|gl
operator|::
name|Buffer
modifier|*
name|elementArrayBuffer
parameter_list|,
specifier|const
name|TranslatedIndexData
modifier|&
name|indexInfo
parameter_list|,
name|GLsizei
name|instances
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|==
name|GL_LINE_LOOP
condition|)
block|{
name|drawLineLoop
argument_list|(
name|count
argument_list|,
name|type
argument_list|,
name|indices
argument_list|,
name|indexInfo
operator|.
name|minIndex
argument_list|,
name|elementArrayBuffer
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|GL_TRIANGLE_FAN
condition|)
block|{
name|drawTriangleFan
argument_list|(
name|count
argument_list|,
name|type
argument_list|,
name|indices
argument_list|,
name|indexInfo
operator|.
name|minIndex
argument_list|,
name|elementArrayBuffer
argument_list|,
name|instances
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instances
operator|>
literal|0
condition|)
block|{
name|mDeviceContext
operator|->
name|DrawIndexedInstanced
argument_list|(
name|count
argument_list|,
name|instances
argument_list|,
literal|0
argument_list|,
operator|-
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|indexInfo
operator|.
name|minIndex
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mDeviceContext
operator|->
name|DrawIndexed
argument_list|(
name|count
argument_list|,
literal|0
argument_list|,
operator|-
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|indexInfo
operator|.
name|minIndex
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|drawLineLoop
name|void
name|Renderer11
operator|::
name|drawLineLoop
parameter_list|(
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|int
name|minIndex
parameter_list|,
name|gl
operator|::
name|Buffer
modifier|*
name|elementArrayBuffer
parameter_list|)
block|{
comment|// Get the raw indices for an indexed draw
if|if
condition|(
name|type
operator|!=
name|GL_NONE
operator|&&
name|elementArrayBuffer
condition|)
block|{
name|gl
operator|::
name|Buffer
modifier|*
name|indexBuffer
init|=
name|elementArrayBuffer
decl_stmt|;
name|BufferStorage
modifier|*
name|storage
init|=
name|indexBuffer
operator|->
name|getStorage
argument_list|()
decl_stmt|;
name|intptr_t
name|offset
init|=
cast|reinterpret_cast
argument_list|<
name|intptr_t
argument_list|>
argument_list|(
name|indices
argument_list|)
decl_stmt|;
name|indices
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLubyte
operator|*
argument_list|>
argument_list|(
name|storage
operator|->
name|getData
argument_list|()
argument_list|)
operator|+
name|offset
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mLineLoopIB
condition|)
block|{
name|mLineLoopIB
operator|=
operator|new
name|StreamingIndexBufferInterface
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mLineLoopIB
operator|->
name|reserveBufferSpace
argument_list|(
name|INITIAL_INDEX_BUFFER_SIZE
argument_list|,
name|GL_UNSIGNED_INT
argument_list|)
condition|)
block|{
operator|delete
name|mLineLoopIB
expr_stmt|;
name|mLineLoopIB
operator|=
name|NULL
expr_stmt|;
name|ERR
argument_list|(
literal|"Could not create a 32-bit looping index buffer for GL_LINE_LOOP."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
specifier|const
name|int
name|spaceNeeded
init|=
operator|(
name|count
operator|+
literal|1
operator|)
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|mLineLoopIB
operator|->
name|reserveBufferSpace
argument_list|(
name|spaceNeeded
argument_list|,
name|GL_UNSIGNED_INT
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not reserve enough space in looping index buffer for GL_LINE_LOOP."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
name|void
modifier|*
name|mappedMemory
init|=
name|NULL
decl_stmt|;
name|int
name|offset
init|=
name|mLineLoopIB
operator|->
name|mapBuffer
argument_list|(
name|spaceNeeded
argument_list|,
operator|&
name|mappedMemory
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|==
operator|-
literal|1
operator|||
name|mappedMemory
operator|==
name|NULL
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not map index buffer for GL_LINE_LOOP."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
name|unsigned
name|int
modifier|*
name|data
init|=
cast|reinterpret_cast
argument_list|<
name|unsigned
name|int
operator|*
argument_list|>
argument_list|(
name|mappedMemory
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|indexBufferOffset
init|=
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|offset
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_NONE
case|:
comment|// Non-indexed draw
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
name|data
index|[
name|count
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_BYTE
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLubyte
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
index|]
expr_stmt|;
block|}
name|data
index|[
name|count
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLubyte
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_SHORT
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLushort
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
index|]
expr_stmt|;
block|}
name|data
index|[
name|count
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLushort
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_INT
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLuint
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
index|]
expr_stmt|;
block|}
name|data
index|[
name|count
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLuint
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mLineLoopIB
operator|->
name|unmapBuffer
argument_list|()
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not unmap index buffer for GL_LINE_LOOP."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
if|if
condition|(
name|mAppliedIBSerial
operator|!=
name|mLineLoopIB
operator|->
name|getSerial
argument_list|()
operator|||
name|mAppliedIBOffset
operator|!=
name|indexBufferOffset
condition|)
block|{
name|IndexBuffer11
modifier|*
name|indexBuffer
init|=
name|IndexBuffer11
operator|::
name|makeIndexBuffer11
argument_list|(
name|mLineLoopIB
operator|->
name|getIndexBuffer
argument_list|()
argument_list|)
decl_stmt|;
name|mDeviceContext
operator|->
name|IASetIndexBuffer
argument_list|(
name|indexBuffer
operator|->
name|getBuffer
argument_list|()
argument_list|,
name|indexBuffer
operator|->
name|getIndexFormat
argument_list|()
argument_list|,
name|indexBufferOffset
argument_list|)
expr_stmt|;
name|mAppliedIBSerial
operator|=
name|mLineLoopIB
operator|->
name|getSerial
argument_list|()
expr_stmt|;
name|mAppliedStorageIBSerial
operator|=
literal|0
expr_stmt|;
name|mAppliedIBOffset
operator|=
name|indexBufferOffset
expr_stmt|;
block|}
name|mDeviceContext
operator|->
name|DrawIndexed
argument_list|(
name|count
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
operator|-
name|minIndex
argument_list|)
expr_stmt|;
block|}
DECL|function|drawTriangleFan
name|void
name|Renderer11
operator|::
name|drawTriangleFan
parameter_list|(
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|int
name|minIndex
parameter_list|,
name|gl
operator|::
name|Buffer
modifier|*
name|elementArrayBuffer
parameter_list|,
name|int
name|instances
parameter_list|)
block|{
comment|// Get the raw indices for an indexed draw
if|if
condition|(
name|type
operator|!=
name|GL_NONE
operator|&&
name|elementArrayBuffer
condition|)
block|{
name|gl
operator|::
name|Buffer
modifier|*
name|indexBuffer
init|=
name|elementArrayBuffer
decl_stmt|;
name|BufferStorage
modifier|*
name|storage
init|=
name|indexBuffer
operator|->
name|getStorage
argument_list|()
decl_stmt|;
name|intptr_t
name|offset
init|=
cast|reinterpret_cast
argument_list|<
name|intptr_t
argument_list|>
argument_list|(
name|indices
argument_list|)
decl_stmt|;
name|indices
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLubyte
operator|*
argument_list|>
argument_list|(
name|storage
operator|->
name|getData
argument_list|()
argument_list|)
operator|+
name|offset
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mTriangleFanIB
condition|)
block|{
name|mTriangleFanIB
operator|=
operator|new
name|StreamingIndexBufferInterface
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mTriangleFanIB
operator|->
name|reserveBufferSpace
argument_list|(
name|INITIAL_INDEX_BUFFER_SIZE
argument_list|,
name|GL_UNSIGNED_INT
argument_list|)
condition|)
block|{
operator|delete
name|mTriangleFanIB
expr_stmt|;
name|mTriangleFanIB
operator|=
name|NULL
expr_stmt|;
name|ERR
argument_list|(
literal|"Could not create a scratch index buffer for GL_TRIANGLE_FAN."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
specifier|const
name|int
name|numTris
init|=
name|count
operator|-
literal|2
decl_stmt|;
specifier|const
name|int
name|spaceNeeded
init|=
operator|(
name|numTris
operator|*
literal|3
operator|)
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|mTriangleFanIB
operator|->
name|reserveBufferSpace
argument_list|(
name|spaceNeeded
argument_list|,
name|GL_UNSIGNED_INT
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not reserve enough space in scratch index buffer for GL_TRIANGLE_FAN."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
name|void
modifier|*
name|mappedMemory
init|=
name|NULL
decl_stmt|;
name|int
name|offset
init|=
name|mTriangleFanIB
operator|->
name|mapBuffer
argument_list|(
name|spaceNeeded
argument_list|,
operator|&
name|mappedMemory
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|==
operator|-
literal|1
operator|||
name|mappedMemory
operator|==
name|NULL
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not map scratch index buffer for GL_TRIANGLE_FAN."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
name|unsigned
name|int
modifier|*
name|data
init|=
cast|reinterpret_cast
argument_list|<
name|unsigned
name|int
operator|*
argument_list|>
argument_list|(
name|mappedMemory
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|indexBufferOffset
init|=
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|offset
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_NONE
case|:
comment|// Non-indexed draw
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numTris
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
operator|*
literal|3
operator|+
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|data
index|[
name|i
operator|*
literal|3
operator|+
literal|1
index|]
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|data
index|[
name|i
operator|*
literal|3
operator|+
literal|2
index|]
operator|=
name|i
operator|+
literal|2
expr_stmt|;
block|}
break|break;
case|case
name|GL_UNSIGNED_BYTE
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numTris
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
operator|*
literal|3
operator|+
literal|0
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLubyte
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
name|data
index|[
name|i
operator|*
literal|3
operator|+
literal|1
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLubyte
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|data
index|[
name|i
operator|*
literal|3
operator|+
literal|2
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLubyte
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
block|}
break|break;
case|case
name|GL_UNSIGNED_SHORT
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numTris
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
operator|*
literal|3
operator|+
literal|0
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLushort
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
name|data
index|[
name|i
operator|*
literal|3
operator|+
literal|1
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLushort
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|data
index|[
name|i
operator|*
literal|3
operator|+
literal|2
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLushort
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
block|}
break|break;
case|case
name|GL_UNSIGNED_INT
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numTris
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
operator|*
literal|3
operator|+
literal|0
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLuint
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
name|data
index|[
name|i
operator|*
literal|3
operator|+
literal|1
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLuint
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|data
index|[
name|i
operator|*
literal|3
operator|+
literal|2
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLuint
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
block|}
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mTriangleFanIB
operator|->
name|unmapBuffer
argument_list|()
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not unmap scratch index buffer for GL_TRIANGLE_FAN."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
if|if
condition|(
name|mAppliedIBSerial
operator|!=
name|mTriangleFanIB
operator|->
name|getSerial
argument_list|()
operator|||
name|mAppliedIBOffset
operator|!=
name|indexBufferOffset
condition|)
block|{
name|IndexBuffer11
modifier|*
name|indexBuffer
init|=
name|IndexBuffer11
operator|::
name|makeIndexBuffer11
argument_list|(
name|mTriangleFanIB
operator|->
name|getIndexBuffer
argument_list|()
argument_list|)
decl_stmt|;
name|mDeviceContext
operator|->
name|IASetIndexBuffer
argument_list|(
name|indexBuffer
operator|->
name|getBuffer
argument_list|()
argument_list|,
name|indexBuffer
operator|->
name|getIndexFormat
argument_list|()
argument_list|,
name|indexBufferOffset
argument_list|)
expr_stmt|;
name|mAppliedIBSerial
operator|=
name|mTriangleFanIB
operator|->
name|getSerial
argument_list|()
expr_stmt|;
name|mAppliedStorageIBSerial
operator|=
literal|0
expr_stmt|;
name|mAppliedIBOffset
operator|=
name|indexBufferOffset
expr_stmt|;
block|}
if|if
condition|(
name|instances
operator|>
literal|0
condition|)
block|{
name|mDeviceContext
operator|->
name|DrawIndexedInstanced
argument_list|(
name|numTris
operator|*
literal|3
argument_list|,
name|instances
argument_list|,
literal|0
argument_list|,
operator|-
name|minIndex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mDeviceContext
operator|->
name|DrawIndexed
argument_list|(
name|numTris
operator|*
literal|3
argument_list|,
literal|0
argument_list|,
operator|-
name|minIndex
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|applyShaders
name|void
name|Renderer11
operator|::
name|applyShaders
parameter_list|(
name|gl
operator|::
name|ProgramBinary
modifier|*
name|programBinary
parameter_list|)
block|{
name|unsigned
name|int
name|programBinarySerial
init|=
name|programBinary
operator|->
name|getSerial
argument_list|()
decl_stmt|;
specifier|const
name|bool
name|updateProgramState
init|=
operator|(
name|programBinarySerial
operator|!=
name|mAppliedProgramBinarySerial
operator|)
decl_stmt|;
if|if
condition|(
name|updateProgramState
condition|)
block|{
name|ShaderExecutable
modifier|*
name|vertexExe
init|=
name|programBinary
operator|->
name|getVertexExecutable
argument_list|()
decl_stmt|;
name|ShaderExecutable
modifier|*
name|pixelExe
init|=
name|programBinary
operator|->
name|getPixelExecutable
argument_list|()
decl_stmt|;
name|ID3D11VertexShader
modifier|*
name|vertexShader
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|vertexExe
condition|)
name|vertexShader
operator|=
name|ShaderExecutable11
operator|::
name|makeShaderExecutable11
argument_list|(
name|vertexExe
argument_list|)
operator|->
name|getVertexShader
argument_list|()
expr_stmt|;
name|ID3D11PixelShader
modifier|*
name|pixelShader
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|pixelExe
condition|)
name|pixelShader
operator|=
name|ShaderExecutable11
operator|::
name|makeShaderExecutable11
argument_list|(
name|pixelExe
argument_list|)
operator|->
name|getPixelShader
argument_list|()
expr_stmt|;
name|mDeviceContext
operator|->
name|PSSetShader
argument_list|(
name|pixelShader
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mDeviceContext
operator|->
name|VSSetShader
argument_list|(
name|vertexShader
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|programBinary
operator|->
name|dirtyAllUniforms
argument_list|()
expr_stmt|;
name|mAppliedProgramBinarySerial
operator|=
name|programBinarySerial
expr_stmt|;
block|}
comment|// Only use the geometry shader currently for point sprite drawing
specifier|const
name|bool
name|usesGeometryShader
init|=
operator|(
name|programBinary
operator|->
name|usesGeometryShader
argument_list|()
operator|&&
name|mCurRasterState
operator|.
name|pointDrawMode
operator|)
decl_stmt|;
if|if
condition|(
name|updateProgramState
operator|||
name|usesGeometryShader
operator|!=
name|mIsGeometryShaderActive
condition|)
block|{
if|if
condition|(
name|usesGeometryShader
condition|)
block|{
name|ShaderExecutable
modifier|*
name|geometryExe
init|=
name|programBinary
operator|->
name|getGeometryExecutable
argument_list|()
decl_stmt|;
name|ID3D11GeometryShader
modifier|*
name|geometryShader
init|=
name|ShaderExecutable11
operator|::
name|makeShaderExecutable11
argument_list|(
name|geometryExe
argument_list|)
operator|->
name|getGeometryShader
argument_list|()
decl_stmt|;
name|mDeviceContext
operator|->
name|GSSetShader
argument_list|(
name|geometryShader
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mDeviceContext
operator|->
name|GSSetShader
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mIsGeometryShaderActive
operator|=
name|usesGeometryShader
expr_stmt|;
block|}
block|}
DECL|function|applyUniforms
name|void
name|Renderer11
operator|::
name|applyUniforms
parameter_list|(
name|gl
operator|::
name|ProgramBinary
modifier|*
name|programBinary
parameter_list|,
name|gl
operator|::
name|UniformArray
modifier|*
name|uniformArray
parameter_list|)
block|{
name|ShaderExecutable11
modifier|*
name|vertexExecutable
init|=
name|ShaderExecutable11
operator|::
name|makeShaderExecutable11
argument_list|(
name|programBinary
operator|->
name|getVertexExecutable
argument_list|()
argument_list|)
decl_stmt|;
name|ShaderExecutable11
modifier|*
name|pixelExecutable
init|=
name|ShaderExecutable11
operator|::
name|makeShaderExecutable11
argument_list|(
name|programBinary
operator|->
name|getPixelExecutable
argument_list|()
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|totalRegisterCountVS
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|totalRegisterCountPS
init|=
literal|0
decl_stmt|;
name|bool
name|vertexUniformsDirty
init|=
literal|false
decl_stmt|;
name|bool
name|pixelUniformsDirty
init|=
literal|false
decl_stmt|;
for|for
control|(
name|gl
operator|::
name|UniformArray
operator|::
name|const_iterator
name|uniform_iterator
init|=
name|uniformArray
operator|->
name|begin
argument_list|()
init|;
name|uniform_iterator
operator|!=
name|uniformArray
operator|->
name|end
argument_list|()
condition|;
name|uniform_iterator
operator|++
control|)
block|{
specifier|const
name|gl
operator|::
name|Uniform
modifier|*
name|uniform
init|=
operator|*
name|uniform_iterator
decl_stmt|;
if|if
condition|(
name|uniform
operator|->
name|vsRegisterIndex
operator|>=
literal|0
condition|)
block|{
name|totalRegisterCountVS
operator|+=
name|uniform
operator|->
name|registerCount
expr_stmt|;
name|vertexUniformsDirty
operator|=
name|vertexUniformsDirty
operator|||
name|uniform
operator|->
name|dirty
expr_stmt|;
block|}
if|if
condition|(
name|uniform
operator|->
name|psRegisterIndex
operator|>=
literal|0
condition|)
block|{
name|totalRegisterCountPS
operator|+=
name|uniform
operator|->
name|registerCount
expr_stmt|;
name|pixelUniformsDirty
operator|=
name|pixelUniformsDirty
operator|||
name|uniform
operator|->
name|dirty
expr_stmt|;
block|}
block|}
name|ID3D11Buffer
modifier|*
name|vertexConstantBuffer
init|=
name|vertexExecutable
operator|->
name|getConstantBuffer
argument_list|(
name|mDevice
argument_list|,
name|totalRegisterCountVS
argument_list|)
decl_stmt|;
name|ID3D11Buffer
modifier|*
name|pixelConstantBuffer
init|=
name|pixelExecutable
operator|->
name|getConstantBuffer
argument_list|(
name|mDevice
argument_list|,
name|totalRegisterCountPS
argument_list|)
decl_stmt|;
name|float
argument_list|(
operator|*
name|mapVS
argument_list|)
index|[
literal|4
index|]
operator|=
name|NULL
expr_stmt|;
name|float
argument_list|(
operator|*
name|mapPS
argument_list|)
index|[
literal|4
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|totalRegisterCountVS
operator|>
literal|0
operator|&&
name|vertexUniformsDirty
condition|)
block|{
name|D3D11_MAPPED_SUBRESOURCE
name|map
init|=
block|{
literal|0
block|}
decl_stmt|;
name|HRESULT
name|result
init|=
name|mDeviceContext
operator|->
name|Map
argument_list|(
name|vertexConstantBuffer
argument_list|,
literal|0
argument_list|,
name|D3D11_MAP_WRITE_DISCARD
argument_list|,
literal|0
argument_list|,
operator|&
name|map
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|mapVS
operator|=
operator|(
name|float
argument_list|(
operator|*
argument_list|)
index|[
literal|4
index|]
operator|)
name|map
operator|.
name|pData
expr_stmt|;
block|}
if|if
condition|(
name|totalRegisterCountPS
operator|>
literal|0
operator|&&
name|pixelUniformsDirty
condition|)
block|{
name|D3D11_MAPPED_SUBRESOURCE
name|map
init|=
block|{
literal|0
block|}
decl_stmt|;
name|HRESULT
name|result
init|=
name|mDeviceContext
operator|->
name|Map
argument_list|(
name|pixelConstantBuffer
argument_list|,
literal|0
argument_list|,
name|D3D11_MAP_WRITE_DISCARD
argument_list|,
literal|0
argument_list|,
operator|&
name|map
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|mapPS
operator|=
operator|(
name|float
argument_list|(
operator|*
argument_list|)
index|[
literal|4
index|]
operator|)
name|map
operator|.
name|pData
expr_stmt|;
block|}
for|for
control|(
name|gl
operator|::
name|UniformArray
operator|::
name|iterator
name|uniform_iterator
init|=
name|uniformArray
operator|->
name|begin
argument_list|()
init|;
name|uniform_iterator
operator|!=
name|uniformArray
operator|->
name|end
argument_list|()
condition|;
name|uniform_iterator
operator|++
control|)
block|{
name|gl
operator|::
name|Uniform
modifier|*
name|uniform
init|=
operator|*
name|uniform_iterator
decl_stmt|;
if|if
condition|(
name|uniform
operator|->
name|type
operator|!=
name|GL_SAMPLER_2D
operator|&&
name|uniform
operator|->
name|type
operator|!=
name|GL_SAMPLER_CUBE
condition|)
block|{
if|if
condition|(
name|uniform
operator|->
name|vsRegisterIndex
operator|>=
literal|0
operator|&&
name|mapVS
condition|)
block|{
name|memcpy
argument_list|(
name|mapVS
operator|+
name|uniform
operator|->
name|vsRegisterIndex
argument_list|,
name|uniform
operator|->
name|data
argument_list|,
name|uniform
operator|->
name|registerCount
operator|*
sizeof|sizeof
argument_list|(
name|float
index|[
literal|4
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uniform
operator|->
name|psRegisterIndex
operator|>=
literal|0
operator|&&
name|mapPS
condition|)
block|{
name|memcpy
argument_list|(
name|mapPS
operator|+
name|uniform
operator|->
name|psRegisterIndex
argument_list|,
name|uniform
operator|->
name|data
argument_list|,
name|uniform
operator|->
name|registerCount
operator|*
sizeof|sizeof
argument_list|(
name|float
index|[
literal|4
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|uniform
operator|->
name|dirty
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|mapVS
condition|)
block|{
name|mDeviceContext
operator|->
name|Unmap
argument_list|(
name|vertexConstantBuffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mapPS
condition|)
block|{
name|mDeviceContext
operator|->
name|Unmap
argument_list|(
name|pixelConstantBuffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mDeviceContext
operator|->
name|VSSetConstantBuffers
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|vertexConstantBuffer
argument_list|)
expr_stmt|;
name|mDeviceContext
operator|->
name|PSSetConstantBuffers
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|pixelConstantBuffer
argument_list|)
expr_stmt|;
comment|// Driver uniforms
if|if
condition|(
operator|!
name|mDriverConstantBufferVS
condition|)
block|{
name|D3D11_BUFFER_DESC
name|constantBufferDescription
init|=
block|{
literal|0
block|}
decl_stmt|;
name|constantBufferDescription
operator|.
name|ByteWidth
operator|=
sizeof|sizeof
argument_list|(
name|dx_VertexConstants
argument_list|)
expr_stmt|;
name|constantBufferDescription
operator|.
name|Usage
operator|=
name|D3D11_USAGE_DEFAULT
expr_stmt|;
name|constantBufferDescription
operator|.
name|BindFlags
operator|=
name|D3D11_BIND_CONSTANT_BUFFER
expr_stmt|;
name|constantBufferDescription
operator|.
name|CPUAccessFlags
operator|=
literal|0
expr_stmt|;
name|constantBufferDescription
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|constantBufferDescription
operator|.
name|StructureByteStride
operator|=
literal|0
expr_stmt|;
name|HRESULT
name|result
init|=
name|mDevice
operator|->
name|CreateBuffer
argument_list|(
operator|&
name|constantBufferDescription
argument_list|,
name|NULL
argument_list|,
operator|&
name|mDriverConstantBufferVS
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|mDeviceContext
operator|->
name|VSSetConstantBuffers
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
operator|&
name|mDriverConstantBufferVS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mDriverConstantBufferPS
condition|)
block|{
name|D3D11_BUFFER_DESC
name|constantBufferDescription
init|=
block|{
literal|0
block|}
decl_stmt|;
name|constantBufferDescription
operator|.
name|ByteWidth
operator|=
sizeof|sizeof
argument_list|(
name|dx_PixelConstants
argument_list|)
expr_stmt|;
name|constantBufferDescription
operator|.
name|Usage
operator|=
name|D3D11_USAGE_DEFAULT
expr_stmt|;
name|constantBufferDescription
operator|.
name|BindFlags
operator|=
name|D3D11_BIND_CONSTANT_BUFFER
expr_stmt|;
name|constantBufferDescription
operator|.
name|CPUAccessFlags
operator|=
literal|0
expr_stmt|;
name|constantBufferDescription
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|constantBufferDescription
operator|.
name|StructureByteStride
operator|=
literal|0
expr_stmt|;
name|HRESULT
name|result
init|=
name|mDevice
operator|->
name|CreateBuffer
argument_list|(
operator|&
name|constantBufferDescription
argument_list|,
name|NULL
argument_list|,
operator|&
name|mDriverConstantBufferPS
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|mDeviceContext
operator|->
name|PSSetConstantBuffers
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
operator|&
name|mDriverConstantBufferPS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|mVertexConstants
argument_list|,
operator|&
name|mAppliedVertexConstants
argument_list|,
sizeof|sizeof
argument_list|(
name|dx_VertexConstants
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mDeviceContext
operator|->
name|UpdateSubresource
argument_list|(
name|mDriverConstantBufferVS
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|mVertexConstants
argument_list|,
literal|16
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|mAppliedVertexConstants
argument_list|,
operator|&
name|mVertexConstants
argument_list|,
sizeof|sizeof
argument_list|(
name|dx_VertexConstants
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|mPixelConstants
argument_list|,
operator|&
name|mAppliedPixelConstants
argument_list|,
sizeof|sizeof
argument_list|(
name|dx_PixelConstants
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mDeviceContext
operator|->
name|UpdateSubresource
argument_list|(
name|mDriverConstantBufferPS
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|mPixelConstants
argument_list|,
literal|16
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|mAppliedPixelConstants
argument_list|,
operator|&
name|mPixelConstants
argument_list|,
sizeof|sizeof
argument_list|(
name|dx_PixelConstants
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// needed for the point sprite geometry shader
name|mDeviceContext
operator|->
name|GSSetConstantBuffers
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|mDriverConstantBufferPS
argument_list|)
expr_stmt|;
block|}
DECL|function|clear
name|void
name|Renderer11
operator|::
name|clear
parameter_list|(
specifier|const
name|gl
operator|::
name|ClearParameters
modifier|&
name|clearParams
parameter_list|,
name|gl
operator|::
name|Framebuffer
modifier|*
name|frameBuffer
parameter_list|)
block|{
name|bool
name|alphaUnmasked
init|=
operator|(
name|gl
operator|::
name|GetAlphaSize
argument_list|(
name|mRenderTargetDesc
operator|.
name|format
argument_list|)
operator|==
literal|0
operator|)
operator|||
name|clearParams
operator|.
name|colorMaskAlpha
decl_stmt|;
name|bool
name|needMaskedColorClear
init|=
operator|(
name|clearParams
operator|.
name|mask
operator|&
name|GL_COLOR_BUFFER_BIT
operator|)
operator|&&
operator|!
operator|(
name|clearParams
operator|.
name|colorMaskRed
operator|&&
name|clearParams
operator|.
name|colorMaskGreen
operator|&&
name|clearParams
operator|.
name|colorMaskBlue
operator|&&
name|alphaUnmasked
operator|)
decl_stmt|;
name|unsigned
name|int
name|stencilUnmasked
init|=
literal|0x0
decl_stmt|;
if|if
condition|(
name|frameBuffer
operator|->
name|hasStencil
argument_list|()
condition|)
block|{
name|unsigned
name|int
name|stencilSize
init|=
name|gl
operator|::
name|GetStencilSize
argument_list|(
name|frameBuffer
operator|->
name|getStencilbuffer
argument_list|()
operator|->
name|getActualFormat
argument_list|()
argument_list|)
decl_stmt|;
name|stencilUnmasked
operator|=
operator|(
literal|0x1
operator|<<
name|stencilSize
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|bool
name|needMaskedStencilClear
init|=
operator|(
name|clearParams
operator|.
name|mask
operator|&
name|GL_STENCIL_BUFFER_BIT
operator|)
operator|&&
operator|(
name|clearParams
operator|.
name|stencilWriteMask
operator|&
name|stencilUnmasked
operator|)
operator|!=
name|stencilUnmasked
decl_stmt|;
name|bool
name|needScissoredClear
init|=
name|mScissorEnabled
operator|&&
operator|(
name|mCurScissor
operator|.
name|x
operator|>
literal|0
operator|||
name|mCurScissor
operator|.
name|y
operator|>
literal|0
operator|||
name|mCurScissor
operator|.
name|x
operator|+
name|mCurScissor
operator|.
name|width
operator|<
name|mRenderTargetDesc
operator|.
name|width
operator|||
name|mCurScissor
operator|.
name|y
operator|+
name|mCurScissor
operator|.
name|height
operator|<
name|mRenderTargetDesc
operator|.
name|height
operator|)
decl_stmt|;
if|if
condition|(
name|needMaskedColorClear
operator|||
name|needMaskedStencilClear
operator|||
name|needScissoredClear
condition|)
block|{
name|maskedClear
argument_list|(
name|clearParams
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|clearParams
operator|.
name|mask
operator|&
name|GL_COLOR_BUFFER_BIT
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|colorAttachment
init|=
literal|0
init|;
name|colorAttachment
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
condition|;
name|colorAttachment
operator|++
control|)
block|{
if|if
condition|(
name|frameBuffer
operator|->
name|isEnabledColorAttachment
argument_list|(
name|colorAttachment
argument_list|)
condition|)
block|{
name|gl
operator|::
name|Renderbuffer
modifier|*
name|renderbufferObject
init|=
name|frameBuffer
operator|->
name|getColorbuffer
argument_list|(
name|colorAttachment
argument_list|)
decl_stmt|;
if|if
condition|(
name|renderbufferObject
condition|)
block|{
name|RenderTarget11
modifier|*
name|renderTarget
init|=
name|RenderTarget11
operator|::
name|makeRenderTarget11
argument_list|(
name|renderbufferObject
operator|->
name|getRenderTarget
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|renderTarget
condition|)
block|{
name|ERR
argument_list|(
literal|"render target pointer unexpectedly null."
argument_list|)
expr_stmt|;
return|return;
block|}
name|ID3D11RenderTargetView
modifier|*
name|framebufferRTV
init|=
name|renderTarget
operator|->
name|getRenderTargetView
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|framebufferRTV
condition|)
block|{
name|ERR
argument_list|(
literal|"render target view pointer unexpectedly null."
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|const
name|float
name|clearValues
index|[
literal|4
index|]
init|=
block|{
name|clearParams
operator|.
name|colorClearValue
operator|.
name|red
block|,
name|clearParams
operator|.
name|colorClearValue
operator|.
name|green
block|,
name|clearParams
operator|.
name|colorClearValue
operator|.
name|blue
block|,
name|clearParams
operator|.
name|colorClearValue
operator|.
name|alpha
block|}
decl_stmt|;
name|mDeviceContext
operator|->
name|ClearRenderTargetView
argument_list|(
name|framebufferRTV
argument_list|,
name|clearValues
argument_list|)
expr_stmt|;
name|framebufferRTV
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|clearParams
operator|.
name|mask
operator|&
name|GL_DEPTH_BUFFER_BIT
operator|||
name|clearParams
operator|.
name|mask
operator|&
name|GL_STENCIL_BUFFER_BIT
condition|)
block|{
name|gl
operator|::
name|Renderbuffer
modifier|*
name|renderbufferObject
init|=
name|frameBuffer
operator|->
name|getDepthOrStencilbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|renderbufferObject
condition|)
block|{
name|RenderTarget11
modifier|*
name|renderTarget
init|=
name|RenderTarget11
operator|::
name|makeRenderTarget11
argument_list|(
name|renderbufferObject
operator|->
name|getDepthStencil
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|renderTarget
condition|)
block|{
name|ERR
argument_list|(
literal|"render target pointer unexpectedly null."
argument_list|)
expr_stmt|;
return|return;
block|}
name|ID3D11DepthStencilView
modifier|*
name|framebufferDSV
init|=
name|renderTarget
operator|->
name|getDepthStencilView
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|framebufferDSV
condition|)
block|{
name|ERR
argument_list|(
literal|"depth stencil view pointer unexpectedly null."
argument_list|)
expr_stmt|;
return|return;
block|}
name|UINT
name|clearFlags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|clearParams
operator|.
name|mask
operator|&
name|GL_DEPTH_BUFFER_BIT
condition|)
block|{
name|clearFlags
operator||=
name|D3D11_CLEAR_DEPTH
expr_stmt|;
block|}
if|if
condition|(
name|clearParams
operator|.
name|mask
operator|&
name|GL_STENCIL_BUFFER_BIT
condition|)
block|{
name|clearFlags
operator||=
name|D3D11_CLEAR_STENCIL
expr_stmt|;
block|}
name|float
name|depthClear
init|=
name|gl
operator|::
name|clamp01
argument_list|(
name|clearParams
operator|.
name|depthClearValue
argument_list|)
decl_stmt|;
name|UINT8
name|stencilClear
init|=
name|clearParams
operator|.
name|stencilClearValue
operator|&
literal|0x000000FF
decl_stmt|;
name|mDeviceContext
operator|->
name|ClearDepthStencilView
argument_list|(
name|framebufferDSV
argument_list|,
name|clearFlags
argument_list|,
name|depthClear
argument_list|,
name|stencilClear
argument_list|)
expr_stmt|;
name|framebufferDSV
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|function|maskedClear
name|void
name|Renderer11
operator|::
name|maskedClear
parameter_list|(
specifier|const
name|gl
operator|::
name|ClearParameters
modifier|&
name|clearParams
parameter_list|)
block|{
name|HRESULT
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|mClearResourcesInitialized
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|mClearVB
operator|&&
operator|!
name|mClearVS
operator|&&
operator|!
name|mClearPS
operator|&&
operator|!
name|mClearScissorRS
operator|&&
operator|!
name|mClearNoScissorRS
argument_list|)
expr_stmt|;
name|D3D11_BUFFER_DESC
name|vbDesc
decl_stmt|;
name|vbDesc
operator|.
name|ByteWidth
operator|=
sizeof|sizeof
argument_list|(
name|d3d11
operator|::
name|PositionDepthColorVertex
argument_list|)
operator|*
literal|4
expr_stmt|;
name|vbDesc
operator|.
name|Usage
operator|=
name|D3D11_USAGE_DYNAMIC
expr_stmt|;
name|vbDesc
operator|.
name|BindFlags
operator|=
name|D3D11_BIND_VERTEX_BUFFER
expr_stmt|;
name|vbDesc
operator|.
name|CPUAccessFlags
operator|=
name|D3D11_CPU_ACCESS_WRITE
expr_stmt|;
name|vbDesc
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|vbDesc
operator|.
name|StructureByteStride
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|CreateBuffer
argument_list|(
operator|&
name|vbDesc
argument_list|,
name|NULL
argument_list|,
operator|&
name|mClearVB
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mClearVB
argument_list|,
literal|"Renderer11 masked clear vertex buffer"
argument_list|)
expr_stmt|;
name|D3D11_INPUT_ELEMENT_DESC
name|quadLayout
index|[]
init|=
block|{
block|{
literal|"POSITION"
block|,
literal|0
block|,
name|DXGI_FORMAT_R32G32B32_FLOAT
block|,
literal|0
block|,
literal|0
block|,
name|D3D11_INPUT_PER_VERTEX_DATA
block|,
literal|0
block|}
block|,
block|{
literal|"COLOR"
block|,
literal|0
block|,
name|DXGI_FORMAT_R32G32B32A32_FLOAT
block|,
literal|0
block|,
literal|12
block|,
name|D3D11_INPUT_PER_VERTEX_DATA
block|,
literal|0
block|}
block|,         }
decl_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|CreateInputLayout
argument_list|(
name|quadLayout
argument_list|,
literal|2
argument_list|,
name|g_VS_Clear
argument_list|,
sizeof|sizeof
argument_list|(
name|g_VS_Clear
argument_list|)
argument_list|,
operator|&
name|mClearIL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mClearIL
argument_list|,
literal|"Renderer11 masked clear input layout"
argument_list|)
expr_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|CreateVertexShader
argument_list|(
name|g_VS_Clear
argument_list|,
sizeof|sizeof
argument_list|(
name|g_VS_Clear
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|mClearVS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mClearVS
argument_list|,
literal|"Renderer11 masked clear vertex shader"
argument_list|)
expr_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|CreatePixelShader
argument_list|(
name|g_PS_Clear
argument_list|,
sizeof|sizeof
argument_list|(
name|g_PS_Clear
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|mClearPS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mClearPS
argument_list|,
literal|"Renderer11 masked clear pixel shader"
argument_list|)
expr_stmt|;
name|D3D11_RASTERIZER_DESC
name|rsScissorDesc
decl_stmt|;
name|rsScissorDesc
operator|.
name|FillMode
operator|=
name|D3D11_FILL_SOLID
expr_stmt|;
name|rsScissorDesc
operator|.
name|CullMode
operator|=
name|D3D11_CULL_NONE
expr_stmt|;
name|rsScissorDesc
operator|.
name|FrontCounterClockwise
operator|=
name|FALSE
expr_stmt|;
name|rsScissorDesc
operator|.
name|DepthBias
operator|=
literal|0
expr_stmt|;
name|rsScissorDesc
operator|.
name|DepthBiasClamp
operator|=
literal|0.0f
expr_stmt|;
name|rsScissorDesc
operator|.
name|SlopeScaledDepthBias
operator|=
literal|0.0f
expr_stmt|;
name|rsScissorDesc
operator|.
name|DepthClipEnable
operator|=
name|FALSE
expr_stmt|;
name|rsScissorDesc
operator|.
name|ScissorEnable
operator|=
name|TRUE
expr_stmt|;
name|rsScissorDesc
operator|.
name|MultisampleEnable
operator|=
name|FALSE
expr_stmt|;
name|rsScissorDesc
operator|.
name|AntialiasedLineEnable
operator|=
name|FALSE
expr_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|CreateRasterizerState
argument_list|(
operator|&
name|rsScissorDesc
argument_list|,
operator|&
name|mClearScissorRS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mClearScissorRS
argument_list|,
literal|"Renderer11 masked clear scissor rasterizer state"
argument_list|)
expr_stmt|;
name|D3D11_RASTERIZER_DESC
name|rsNoScissorDesc
decl_stmt|;
name|rsNoScissorDesc
operator|.
name|FillMode
operator|=
name|D3D11_FILL_SOLID
expr_stmt|;
name|rsNoScissorDesc
operator|.
name|CullMode
operator|=
name|D3D11_CULL_NONE
expr_stmt|;
name|rsNoScissorDesc
operator|.
name|FrontCounterClockwise
operator|=
name|FALSE
expr_stmt|;
name|rsNoScissorDesc
operator|.
name|DepthBias
operator|=
literal|0
expr_stmt|;
name|rsNoScissorDesc
operator|.
name|DepthBiasClamp
operator|=
literal|0.0f
expr_stmt|;
name|rsNoScissorDesc
operator|.
name|SlopeScaledDepthBias
operator|=
literal|0.0f
expr_stmt|;
name|rsNoScissorDesc
operator|.
name|DepthClipEnable
operator|=
name|FALSE
expr_stmt|;
name|rsNoScissorDesc
operator|.
name|ScissorEnable
operator|=
name|FALSE
expr_stmt|;
name|rsNoScissorDesc
operator|.
name|MultisampleEnable
operator|=
name|FALSE
expr_stmt|;
name|rsNoScissorDesc
operator|.
name|AntialiasedLineEnable
operator|=
name|FALSE
expr_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|CreateRasterizerState
argument_list|(
operator|&
name|rsNoScissorDesc
argument_list|,
operator|&
name|mClearNoScissorRS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mClearNoScissorRS
argument_list|,
literal|"Renderer11 masked clear no scissor rasterizer state"
argument_list|)
expr_stmt|;
name|mClearResourcesInitialized
operator|=
literal|true
expr_stmt|;
block|}
comment|// Prepare the depth stencil state to write depth values if the depth should be cleared
comment|// and stencil values if the stencil should be cleared
name|gl
operator|::
name|DepthStencilState
name|glDSState
decl_stmt|;
name|glDSState
operator|.
name|depthTest
operator|=
operator|(
name|clearParams
operator|.
name|mask
operator|&
name|GL_DEPTH_BUFFER_BIT
operator|)
operator|!=
literal|0
expr_stmt|;
name|glDSState
operator|.
name|depthFunc
operator|=
name|GL_ALWAYS
expr_stmt|;
name|glDSState
operator|.
name|depthMask
operator|=
operator|(
name|clearParams
operator|.
name|mask
operator|&
name|GL_DEPTH_BUFFER_BIT
operator|)
operator|!=
literal|0
expr_stmt|;
name|glDSState
operator|.
name|stencilTest
operator|=
operator|(
name|clearParams
operator|.
name|mask
operator|&
name|GL_STENCIL_BUFFER_BIT
operator|)
operator|!=
literal|0
expr_stmt|;
name|glDSState
operator|.
name|stencilFunc
operator|=
name|GL_ALWAYS
expr_stmt|;
name|glDSState
operator|.
name|stencilMask
operator|=
literal|0
expr_stmt|;
name|glDSState
operator|.
name|stencilFail
operator|=
name|GL_REPLACE
expr_stmt|;
name|glDSState
operator|.
name|stencilPassDepthFail
operator|=
name|GL_REPLACE
expr_stmt|;
name|glDSState
operator|.
name|stencilPassDepthPass
operator|=
name|GL_REPLACE
expr_stmt|;
name|glDSState
operator|.
name|stencilWritemask
operator|=
name|clearParams
operator|.
name|stencilWriteMask
expr_stmt|;
name|glDSState
operator|.
name|stencilBackFunc
operator|=
name|GL_ALWAYS
expr_stmt|;
name|glDSState
operator|.
name|stencilBackMask
operator|=
literal|0
expr_stmt|;
name|glDSState
operator|.
name|stencilBackFail
operator|=
name|GL_REPLACE
expr_stmt|;
name|glDSState
operator|.
name|stencilBackPassDepthFail
operator|=
name|GL_REPLACE
expr_stmt|;
name|glDSState
operator|.
name|stencilBackPassDepthPass
operator|=
name|GL_REPLACE
expr_stmt|;
name|glDSState
operator|.
name|stencilBackWritemask
operator|=
name|clearParams
operator|.
name|stencilWriteMask
expr_stmt|;
name|int
name|stencilClear
init|=
name|clearParams
operator|.
name|stencilClearValue
operator|&
literal|0x000000FF
decl_stmt|;
name|ID3D11DepthStencilState
modifier|*
name|dsState
init|=
name|mStateCache
operator|.
name|getDepthStencilState
argument_list|(
name|glDSState
argument_list|)
decl_stmt|;
comment|// Prepare the blend state to use a write mask if the color buffer should be cleared
name|gl
operator|::
name|BlendState
name|glBlendState
decl_stmt|;
name|glBlendState
operator|.
name|blend
operator|=
literal|false
expr_stmt|;
name|glBlendState
operator|.
name|sourceBlendRGB
operator|=
name|GL_ONE
expr_stmt|;
name|glBlendState
operator|.
name|destBlendRGB
operator|=
name|GL_ZERO
expr_stmt|;
name|glBlendState
operator|.
name|sourceBlendAlpha
operator|=
name|GL_ONE
expr_stmt|;
name|glBlendState
operator|.
name|destBlendAlpha
operator|=
name|GL_ZERO
expr_stmt|;
name|glBlendState
operator|.
name|blendEquationRGB
operator|=
name|GL_FUNC_ADD
expr_stmt|;
name|glBlendState
operator|.
name|blendEquationAlpha
operator|=
name|GL_FUNC_ADD
expr_stmt|;
name|glBlendState
operator|.
name|colorMaskRed
operator|=
operator|(
name|clearParams
operator|.
name|mask
operator|&
name|GL_COLOR_BUFFER_BIT
operator|)
condition|?
name|clearParams
operator|.
name|colorMaskRed
else|:
literal|false
expr_stmt|;
name|glBlendState
operator|.
name|colorMaskGreen
operator|=
operator|(
name|clearParams
operator|.
name|mask
operator|&
name|GL_COLOR_BUFFER_BIT
operator|)
condition|?
name|clearParams
operator|.
name|colorMaskGreen
else|:
literal|false
expr_stmt|;
name|glBlendState
operator|.
name|colorMaskBlue
operator|=
operator|(
name|clearParams
operator|.
name|mask
operator|&
name|GL_COLOR_BUFFER_BIT
operator|)
condition|?
name|clearParams
operator|.
name|colorMaskBlue
else|:
literal|false
expr_stmt|;
name|glBlendState
operator|.
name|colorMaskAlpha
operator|=
operator|(
name|clearParams
operator|.
name|mask
operator|&
name|GL_COLOR_BUFFER_BIT
operator|)
condition|?
name|clearParams
operator|.
name|colorMaskAlpha
else|:
literal|false
expr_stmt|;
name|glBlendState
operator|.
name|sampleAlphaToCoverage
operator|=
literal|false
expr_stmt|;
name|glBlendState
operator|.
name|dither
operator|=
literal|false
expr_stmt|;
specifier|static
specifier|const
name|float
name|blendFactors
index|[
literal|4
index|]
init|=
block|{
literal|1.0f
block|,
literal|1.0f
block|,
literal|1.0f
block|,
literal|1.0f
block|}
decl_stmt|;
specifier|static
specifier|const
name|UINT
name|sampleMask
init|=
literal|0xFFFFFFFF
decl_stmt|;
name|ID3D11BlendState
modifier|*
name|blendState
init|=
name|mStateCache
operator|.
name|getBlendState
argument_list|(
name|glBlendState
argument_list|)
decl_stmt|;
comment|// Set the vertices
name|D3D11_MAPPED_SUBRESOURCE
name|mappedResource
decl_stmt|;
name|result
operator|=
name|mDeviceContext
operator|->
name|Map
argument_list|(
name|mClearVB
argument_list|,
literal|0
argument_list|,
name|D3D11_MAP_WRITE_DISCARD
argument_list|,
literal|0
argument_list|,
operator|&
name|mappedResource
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to map masked clear vertex buffer, HRESULT: 0x%X."
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
name|d3d11
operator|::
name|PositionDepthColorVertex
modifier|*
name|vertices
init|=
cast|reinterpret_cast
argument_list|<
name|d3d11
operator|::
name|PositionDepthColorVertex
operator|*
argument_list|>
argument_list|(
name|mappedResource
operator|.
name|pData
argument_list|)
decl_stmt|;
name|float
name|depthClear
init|=
name|gl
operator|::
name|clamp01
argument_list|(
name|clearParams
operator|.
name|depthClearValue
argument_list|)
decl_stmt|;
name|d3d11
operator|::
name|SetPositionDepthColorVertex
argument_list|(
operator|&
name|vertices
index|[
literal|0
index|]
argument_list|,
operator|-
literal|1.0f
argument_list|,
literal|1.0f
argument_list|,
name|depthClear
argument_list|,
name|clearParams
operator|.
name|colorClearValue
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetPositionDepthColorVertex
argument_list|(
operator|&
name|vertices
index|[
literal|1
index|]
argument_list|,
operator|-
literal|1.0f
argument_list|,
operator|-
literal|1.0f
argument_list|,
name|depthClear
argument_list|,
name|clearParams
operator|.
name|colorClearValue
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetPositionDepthColorVertex
argument_list|(
operator|&
name|vertices
index|[
literal|2
index|]
argument_list|,
literal|1.0f
argument_list|,
literal|1.0f
argument_list|,
name|depthClear
argument_list|,
name|clearParams
operator|.
name|colorClearValue
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetPositionDepthColorVertex
argument_list|(
operator|&
name|vertices
index|[
literal|3
index|]
argument_list|,
literal|1.0f
argument_list|,
operator|-
literal|1.0f
argument_list|,
name|depthClear
argument_list|,
name|clearParams
operator|.
name|colorClearValue
argument_list|)
expr_stmt|;
name|mDeviceContext
operator|->
name|Unmap
argument_list|(
name|mClearVB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Apply state
name|mDeviceContext
operator|->
name|OMSetBlendState
argument_list|(
name|blendState
argument_list|,
name|blendFactors
argument_list|,
name|sampleMask
argument_list|)
expr_stmt|;
name|mDeviceContext
operator|->
name|OMSetDepthStencilState
argument_list|(
name|dsState
argument_list|,
name|stencilClear
argument_list|)
expr_stmt|;
name|mDeviceContext
operator|->
name|RSSetState
argument_list|(
name|mScissorEnabled
condition|?
name|mClearScissorRS
else|:
name|mClearNoScissorRS
argument_list|)
expr_stmt|;
comment|// Apply shaders
name|mDeviceContext
operator|->
name|IASetInputLayout
argument_list|(
name|mClearIL
argument_list|)
expr_stmt|;
name|mDeviceContext
operator|->
name|VSSetShader
argument_list|(
name|mClearVS
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mDeviceContext
operator|->
name|PSSetShader
argument_list|(
name|mClearPS
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mDeviceContext
operator|->
name|GSSetShader
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Apply vertex buffer
specifier|static
name|UINT
name|stride
init|=
sizeof|sizeof
argument_list|(
name|d3d11
operator|::
name|PositionDepthColorVertex
argument_list|)
decl_stmt|;
specifier|static
name|UINT
name|startIdx
init|=
literal|0
decl_stmt|;
name|mDeviceContext
operator|->
name|IASetVertexBuffers
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|mClearVB
argument_list|,
operator|&
name|stride
argument_list|,
operator|&
name|startIdx
argument_list|)
expr_stmt|;
name|mDeviceContext
operator|->
name|IASetPrimitiveTopology
argument_list|(
name|D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP
argument_list|)
expr_stmt|;
comment|// Draw the clear quad
name|mDeviceContext
operator|->
name|Draw
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Clean up
name|markAllStateDirty
argument_list|()
expr_stmt|;
block|}
DECL|function|markAllStateDirty
name|void
name|Renderer11
operator|::
name|markAllStateDirty
parameter_list|()
block|{
for|for
control|(
name|unsigned
name|int
name|rtIndex
init|=
literal|0
init|;
name|rtIndex
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
condition|;
name|rtIndex
operator|++
control|)
block|{
name|mAppliedRenderTargetSerials
index|[
name|rtIndex
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|mAppliedDepthbufferSerial
operator|=
literal|0
expr_stmt|;
name|mAppliedStencilbufferSerial
operator|=
literal|0
expr_stmt|;
name|mDepthStencilInitialized
operator|=
literal|false
expr_stmt|;
name|mRenderTargetDescInitialized
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_VERTEX_TEXTURE_IMAGE_UNITS
condition|;
name|i
operator|++
control|)
block|{
name|mForceSetVertexSamplerStates
index|[
name|i
index|]
operator|=
literal|true
expr_stmt|;
name|mCurVertexTextureSerials
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|MAX_TEXTURE_IMAGE_UNITS
condition|;
name|i
operator|++
control|)
block|{
name|mForceSetPixelSamplerStates
index|[
name|i
index|]
operator|=
literal|true
expr_stmt|;
name|mCurPixelTextureSerials
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|mForceSetBlendState
operator|=
literal|true
expr_stmt|;
name|mForceSetRasterState
operator|=
literal|true
expr_stmt|;
name|mForceSetDepthStencilState
operator|=
literal|true
expr_stmt|;
name|mForceSetScissor
operator|=
literal|true
expr_stmt|;
name|mForceSetViewport
operator|=
literal|true
expr_stmt|;
name|mAppliedIBSerial
operator|=
literal|0
expr_stmt|;
name|mAppliedStorageIBSerial
operator|=
literal|0
expr_stmt|;
name|mAppliedIBOffset
operator|=
literal|0
expr_stmt|;
name|mAppliedProgramBinarySerial
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|mAppliedVertexConstants
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dx_VertexConstants
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|mAppliedPixelConstants
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dx_PixelConstants
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|releaseDeviceResources
name|void
name|Renderer11
operator|::
name|releaseDeviceResources
parameter_list|()
block|{
name|mStateCache
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mInputLayoutCache
operator|.
name|clear
argument_list|()
expr_stmt|;
operator|delete
name|mVertexDataManager
expr_stmt|;
name|mVertexDataManager
operator|=
name|NULL
expr_stmt|;
operator|delete
name|mIndexDataManager
expr_stmt|;
name|mIndexDataManager
operator|=
name|NULL
expr_stmt|;
operator|delete
name|mLineLoopIB
expr_stmt|;
name|mLineLoopIB
operator|=
name|NULL
expr_stmt|;
operator|delete
name|mTriangleFanIB
expr_stmt|;
name|mTriangleFanIB
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|mCopyVB
condition|)
block|{
name|mCopyVB
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mCopyVB
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mCopySampler
condition|)
block|{
name|mCopySampler
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mCopySampler
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mCopyIL
condition|)
block|{
name|mCopyIL
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mCopyIL
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mCopyVS
condition|)
block|{
name|mCopyVS
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mCopyVS
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mCopyRGBAPS
condition|)
block|{
name|mCopyRGBAPS
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mCopyRGBAPS
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mCopyRGBPS
condition|)
block|{
name|mCopyRGBPS
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mCopyRGBPS
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mCopyLumPS
condition|)
block|{
name|mCopyLumPS
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mCopyLumPS
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mCopyLumAlphaPS
condition|)
block|{
name|mCopyLumAlphaPS
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mCopyLumAlphaPS
operator|=
name|NULL
expr_stmt|;
block|}
name|mCopyResourcesInitialized
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|mClearVB
condition|)
block|{
name|mClearVB
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mClearVB
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mClearIL
condition|)
block|{
name|mClearIL
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mClearIL
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mClearVS
condition|)
block|{
name|mClearVS
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mClearVS
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mClearPS
condition|)
block|{
name|mClearPS
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mClearPS
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mClearScissorRS
condition|)
block|{
name|mClearScissorRS
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mClearScissorRS
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mClearNoScissorRS
condition|)
block|{
name|mClearNoScissorRS
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mClearNoScissorRS
operator|=
name|NULL
expr_stmt|;
block|}
name|mClearResourcesInitialized
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|mDriverConstantBufferVS
condition|)
block|{
name|mDriverConstantBufferVS
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mDriverConstantBufferVS
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mDriverConstantBufferPS
condition|)
block|{
name|mDriverConstantBufferPS
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mDriverConstantBufferPS
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mSyncQuery
condition|)
block|{
name|mSyncQuery
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mSyncQuery
operator|=
name|NULL
expr_stmt|;
block|}
block|}
DECL|function|notifyDeviceLost
name|void
name|Renderer11
operator|::
name|notifyDeviceLost
parameter_list|()
block|{
name|mDeviceLost
operator|=
literal|true
expr_stmt|;
name|mDisplay
operator|->
name|notifyDeviceLost
argument_list|()
expr_stmt|;
block|}
DECL|function|isDeviceLost
name|bool
name|Renderer11
operator|::
name|isDeviceLost
parameter_list|()
block|{
return|return
name|mDeviceLost
return|;
block|}
comment|// set notify to true to broadcast a message to all contexts of the device loss
DECL|function|testDeviceLost
name|bool
name|Renderer11
operator|::
name|testDeviceLost
parameter_list|(
name|bool
name|notify
parameter_list|)
block|{
name|bool
name|isLost
init|=
literal|false
decl_stmt|;
comment|// GetRemovedReason is used to test if the device is removed
name|HRESULT
name|result
init|=
name|mDevice
operator|->
name|GetDeviceRemovedReason
argument_list|()
decl_stmt|;
name|isLost
operator|=
name|d3d11
operator|::
name|isDeviceLostError
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|isLost
condition|)
block|{
comment|// Log error if this is a new device lost event
if|if
condition|(
name|mDeviceLost
operator|==
literal|false
condition|)
block|{
name|ERR
argument_list|(
literal|"The D3D11 device was removed: 0x%08X"
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
comment|// ensure we note the device loss --
comment|// we'll probably get this done again by notifyDeviceLost
comment|// but best to remember it!
comment|// Note that we don't want to clear the device loss status here
comment|// -- this needs to be done by resetDevice
name|mDeviceLost
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|notify
condition|)
block|{
name|notifyDeviceLost
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|isLost
return|;
block|}
DECL|function|testDeviceResettable
name|bool
name|Renderer11
operator|::
name|testDeviceResettable
parameter_list|()
block|{
comment|// determine if the device is resettable by creating a dummy device
name|PFN_D3D11_CREATE_DEVICE
name|D3D11CreateDevice
init|=
operator|(
name|PFN_D3D11_CREATE_DEVICE
operator|)
name|GetProcAddress
argument_list|(
name|mD3d11Module
argument_list|,
literal|"D3D11CreateDevice"
argument_list|)
decl_stmt|;
if|if
condition|(
name|D3D11CreateDevice
operator|==
name|NULL
condition|)
block|{
return|return
literal|false
return|;
block|}
name|D3D_FEATURE_LEVEL
name|featureLevels
index|[]
init|=
block|{
name|D3D_FEATURE_LEVEL_11_0
block|,
name|D3D_FEATURE_LEVEL_10_1
block|,
name|D3D_FEATURE_LEVEL_10_0
block|,     }
decl_stmt|;
name|ID3D11Device
modifier|*
name|dummyDevice
decl_stmt|;
name|D3D_FEATURE_LEVEL
name|dummyFeatureLevel
decl_stmt|;
name|ID3D11DeviceContext
modifier|*
name|dummyContext
decl_stmt|;
name|HRESULT
name|result
init|=
name|D3D11CreateDevice
argument_list|(
name|NULL
argument_list|,
name|D3D_DRIVER_TYPE_HARDWARE
argument_list|,
name|NULL
argument_list|,
if|#
directive|if
name|defined
argument_list|(
name|_DEBUG
argument_list|)
name|D3D11_CREATE_DEVICE_DEBUG
argument_list|,
else|#
directive|else
literal|0
argument_list|,
endif|#
directive|endif
name|featureLevels
argument_list|,
name|ArraySize
argument_list|(
name|featureLevels
argument_list|)
argument_list|,
name|D3D11_SDK_VERSION
argument_list|,
operator|&
name|dummyDevice
argument_list|,
operator|&
name|dummyFeatureLevel
argument_list|,
operator|&
name|dummyContext
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mDevice
operator|||
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|dummyContext
operator|->
name|Release
argument_list|()
expr_stmt|;
name|dummyDevice
operator|->
name|Release
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|release
name|void
name|Renderer11
operator|::
name|release
parameter_list|()
block|{
name|releaseDeviceResources
argument_list|()
expr_stmt|;
if|if
condition|(
name|mDxgiFactory
condition|)
block|{
name|mDxgiFactory
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mDxgiFactory
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mDxgiAdapter
condition|)
block|{
name|mDxgiAdapter
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mDxgiAdapter
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mDeviceContext
condition|)
block|{
name|mDeviceContext
operator|->
name|ClearState
argument_list|()
expr_stmt|;
name|mDeviceContext
operator|->
name|Flush
argument_list|()
expr_stmt|;
name|mDeviceContext
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mDeviceContext
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mDevice
condition|)
block|{
name|mDevice
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mDevice
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mD3d11Module
condition|)
block|{
name|FreeLibrary
argument_list|(
name|mD3d11Module
argument_list|)
expr_stmt|;
name|mD3d11Module
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mDxgiModule
condition|)
block|{
name|FreeLibrary
argument_list|(
name|mDxgiModule
argument_list|)
expr_stmt|;
name|mDxgiModule
operator|=
name|NULL
expr_stmt|;
block|}
block|}
DECL|function|resetDevice
name|bool
name|Renderer11
operator|::
name|resetDevice
parameter_list|()
block|{
comment|// recreate everything
name|release
argument_list|()
expr_stmt|;
name|EGLint
name|result
init|=
name|initialize
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
operator|!=
name|EGL_SUCCESS
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not reinitialize D3D11 device: %08X"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|mDeviceLost
operator|=
literal|false
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|getAdapterVendor
name|DWORD
name|Renderer11
operator|::
name|getAdapterVendor
parameter_list|()
specifier|const
block|{
return|return
name|mAdapterDescription
operator|.
name|VendorId
return|;
block|}
DECL|function|getRendererDescription
name|std
operator|::
name|string
name|Renderer11
operator|::
name|getRendererDescription
parameter_list|()
specifier|const
block|{
name|std
operator|::
name|ostringstream
name|rendererString
decl_stmt|;
name|rendererString
operator|<<
name|mDescription
expr_stmt|;
name|rendererString
operator|<<
literal|" Direct3D11"
expr_stmt|;
name|rendererString
operator|<<
literal|" vs_"
operator|<<
name|getMajorShaderModel
argument_list|()
operator|<<
literal|"_"
operator|<<
name|getMinorShaderModel
argument_list|()
expr_stmt|;
name|rendererString
operator|<<
literal|" ps_"
operator|<<
name|getMajorShaderModel
argument_list|()
operator|<<
literal|"_"
operator|<<
name|getMinorShaderModel
argument_list|()
expr_stmt|;
return|return
name|rendererString
operator|.
name|str
argument_list|()
return|;
block|}
DECL|function|getAdapterIdentifier
name|GUID
name|Renderer11
operator|::
name|getAdapterIdentifier
parameter_list|()
specifier|const
block|{
comment|// Use the adapter LUID as our adapter ID
comment|// This number is local to a machine is only guaranteed to be unique between restarts
name|META_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|LUID
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|GUID
argument_list|)
argument_list|)
expr_stmt|;
name|GUID
name|adapterId
init|=
block|{
literal|0
block|}
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|adapterId
argument_list|,
operator|&
name|mAdapterDescription
operator|.
name|AdapterLuid
argument_list|,
sizeof|sizeof
argument_list|(
name|LUID
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|adapterId
return|;
block|}
DECL|function|getBGRATextureSupport
name|bool
name|Renderer11
operator|::
name|getBGRATextureSupport
parameter_list|()
specifier|const
block|{
return|return
name|mBGRATextureSupport
return|;
block|}
DECL|function|getDXT1TextureSupport
name|bool
name|Renderer11
operator|::
name|getDXT1TextureSupport
parameter_list|()
block|{
return|return
name|mDXT1TextureSupport
return|;
block|}
DECL|function|getDXT3TextureSupport
name|bool
name|Renderer11
operator|::
name|getDXT3TextureSupport
parameter_list|()
block|{
return|return
name|mDXT3TextureSupport
return|;
block|}
DECL|function|getDXT5TextureSupport
name|bool
name|Renderer11
operator|::
name|getDXT5TextureSupport
parameter_list|()
block|{
return|return
name|mDXT5TextureSupport
return|;
block|}
DECL|function|getDepthTextureSupport
name|bool
name|Renderer11
operator|::
name|getDepthTextureSupport
parameter_list|()
specifier|const
block|{
return|return
name|mDepthTextureSupport
return|;
block|}
DECL|function|getFloat32TextureSupport
name|bool
name|Renderer11
operator|::
name|getFloat32TextureSupport
parameter_list|(
name|bool
modifier|*
name|filtering
parameter_list|,
name|bool
modifier|*
name|renderable
parameter_list|)
block|{
operator|*
name|renderable
operator|=
name|mFloat32RenderSupport
expr_stmt|;
operator|*
name|filtering
operator|=
name|mFloat32FilterSupport
expr_stmt|;
return|return
name|mFloat32TextureSupport
return|;
block|}
DECL|function|getFloat16TextureSupport
name|bool
name|Renderer11
operator|::
name|getFloat16TextureSupport
parameter_list|(
name|bool
modifier|*
name|filtering
parameter_list|,
name|bool
modifier|*
name|renderable
parameter_list|)
block|{
operator|*
name|renderable
operator|=
name|mFloat16RenderSupport
expr_stmt|;
operator|*
name|filtering
operator|=
name|mFloat16FilterSupport
expr_stmt|;
return|return
name|mFloat16TextureSupport
return|;
block|}
DECL|function|getLuminanceTextureSupport
name|bool
name|Renderer11
operator|::
name|getLuminanceTextureSupport
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
DECL|function|getLuminanceAlphaTextureSupport
name|bool
name|Renderer11
operator|::
name|getLuminanceAlphaTextureSupport
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
DECL|function|getTextureFilterAnisotropySupport
name|bool
name|Renderer11
operator|::
name|getTextureFilterAnisotropySupport
parameter_list|()
specifier|const
block|{
return|return
literal|true
return|;
block|}
DECL|function|getTextureMaxAnisotropy
name|float
name|Renderer11
operator|::
name|getTextureMaxAnisotropy
parameter_list|()
specifier|const
block|{
switch|switch
condition|(
name|mFeatureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_MAX_MAXANISOTROPY
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_MAX_MAXANISOTROPY
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|getEventQuerySupport
name|bool
name|Renderer11
operator|::
name|getEventQuerySupport
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
DECL|function|getViewportBounds
name|Range
name|Renderer11
operator|::
name|getViewportBounds
parameter_list|()
specifier|const
block|{
switch|switch
condition|(
name|mFeatureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|Range
argument_list|(
name|D3D11_VIEWPORT_BOUNDS_MIN
argument_list|,
name|D3D11_VIEWPORT_BOUNDS_MAX
argument_list|)
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|Range
argument_list|(
name|D3D10_VIEWPORT_BOUNDS_MIN
argument_list|,
name|D3D10_VIEWPORT_BOUNDS_MAX
argument_list|)
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|Range
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
DECL|function|getMaxVertexTextureImageUnits
name|unsigned
name|int
name|Renderer11
operator|::
name|getMaxVertexTextureImageUnits
parameter_list|()
specifier|const
block|{
name|META_ASSERT
argument_list|(
name|MAX_TEXTURE_IMAGE_UNITS_VTF_SM4
operator|<=
name|gl
operator|::
name|IMPLEMENTATION_MAX_VERTEX_TEXTURE_IMAGE_UNITS
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mFeatureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|MAX_TEXTURE_IMAGE_UNITS_VTF_SM4
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|getMaxCombinedTextureImageUnits
name|unsigned
name|int
name|Renderer11
operator|::
name|getMaxCombinedTextureImageUnits
parameter_list|()
specifier|const
block|{
return|return
name|gl
operator|::
name|MAX_TEXTURE_IMAGE_UNITS
operator|+
name|getMaxVertexTextureImageUnits
argument_list|()
return|;
block|}
DECL|function|getReservedVertexUniformVectors
name|unsigned
name|int
name|Renderer11
operator|::
name|getReservedVertexUniformVectors
parameter_list|()
specifier|const
block|{
return|return
literal|0
return|;
comment|// Driver uniforms are stored in a separate constant buffer
block|}
DECL|function|getReservedFragmentUniformVectors
name|unsigned
name|int
name|Renderer11
operator|::
name|getReservedFragmentUniformVectors
parameter_list|()
specifier|const
block|{
return|return
literal|0
return|;
comment|// Driver uniforms are stored in a separate constant buffer
block|}
DECL|function|getMaxVertexUniformVectors
name|unsigned
name|int
name|Renderer11
operator|::
name|getMaxVertexUniformVectors
parameter_list|()
specifier|const
block|{
name|META_ASSERT
argument_list|(
name|MAX_VERTEX_UNIFORM_VECTORS_D3D11
operator|<=
name|D3D10_REQ_CONSTANT_BUFFER_ELEMENT_COUNT
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mFeatureLevel
operator|>=
name|D3D_FEATURE_LEVEL_10_0
argument_list|)
expr_stmt|;
return|return
name|MAX_VERTEX_UNIFORM_VECTORS_D3D11
return|;
block|}
DECL|function|getMaxFragmentUniformVectors
name|unsigned
name|int
name|Renderer11
operator|::
name|getMaxFragmentUniformVectors
parameter_list|()
specifier|const
block|{
name|META_ASSERT
argument_list|(
name|MAX_FRAGMENT_UNIFORM_VECTORS_D3D11
operator|<=
name|D3D10_REQ_CONSTANT_BUFFER_ELEMENT_COUNT
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mFeatureLevel
operator|>=
name|D3D_FEATURE_LEVEL_10_0
argument_list|)
expr_stmt|;
return|return
name|MAX_FRAGMENT_UNIFORM_VECTORS_D3D11
return|;
block|}
DECL|function|getMaxVaryingVectors
name|unsigned
name|int
name|Renderer11
operator|::
name|getMaxVaryingVectors
parameter_list|()
specifier|const
block|{
name|META_ASSERT
argument_list|(
name|gl
operator|::
name|IMPLEMENTATION_MAX_VARYING_VECTORS
operator|==
name|D3D11_VS_OUTPUT_REGISTER_COUNT
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mFeatureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_VS_OUTPUT_REGISTER_COUNT
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_VS_OUTPUT_REGISTER_COUNT
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|getNonPower2TextureSupport
name|bool
name|Renderer11
operator|::
name|getNonPower2TextureSupport
parameter_list|()
specifier|const
block|{
switch|switch
condition|(
name|mFeatureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
literal|true
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|getOcclusionQuerySupport
name|bool
name|Renderer11
operator|::
name|getOcclusionQuerySupport
parameter_list|()
specifier|const
block|{
switch|switch
condition|(
name|mFeatureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
literal|true
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|getInstancingSupport
name|bool
name|Renderer11
operator|::
name|getInstancingSupport
parameter_list|()
specifier|const
block|{
switch|switch
condition|(
name|mFeatureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
literal|true
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|getShareHandleSupport
name|bool
name|Renderer11
operator|::
name|getShareHandleSupport
parameter_list|()
specifier|const
block|{
comment|// We only currently support share handles with BGRA surfaces, because
comment|// chrome needs BGRA. Once chrome fixes this, we should always support them.
comment|// PIX doesn't seem to support using share handles, so disable them.
return|return
name|getBGRATextureSupport
argument_list|()
operator|&&
operator|!
name|gl
operator|::
name|perfActive
argument_list|()
return|;
block|}
DECL|function|getDerivativeInstructionSupport
name|bool
name|Renderer11
operator|::
name|getDerivativeInstructionSupport
parameter_list|()
specifier|const
block|{
switch|switch
condition|(
name|mFeatureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
literal|true
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|getPostSubBufferSupport
name|bool
name|Renderer11
operator|::
name|getPostSubBufferSupport
parameter_list|()
specifier|const
block|{
comment|// D3D11 does not support present with dirty rectangles until D3D11.1 and DXGI 1.2.
return|return
literal|false
return|;
block|}
DECL|function|getMajorShaderModel
name|int
name|Renderer11
operator|::
name|getMajorShaderModel
parameter_list|()
specifier|const
block|{
switch|switch
condition|(
name|mFeatureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_SHADER_MAJOR_VERSION
return|;
comment|// 5
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
return|return
name|D3D10_1_SHADER_MAJOR_VERSION
return|;
comment|// 4
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_SHADER_MAJOR_VERSION
return|;
comment|// 4
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|getMinorShaderModel
name|int
name|Renderer11
operator|::
name|getMinorShaderModel
parameter_list|()
specifier|const
block|{
switch|switch
condition|(
name|mFeatureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_SHADER_MINOR_VERSION
return|;
comment|// 0
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
return|return
name|D3D10_1_SHADER_MINOR_VERSION
return|;
comment|// 1
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_SHADER_MINOR_VERSION
return|;
comment|// 0
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|getMaxPointSize
name|float
name|Renderer11
operator|::
name|getMaxPointSize
parameter_list|()
specifier|const
block|{
comment|// choose a reasonable maximum. we enforce this in the shader.
comment|// (nb: on a Radeon 2600xt, DX9 reports a 256 max point size)
return|return
literal|1024.0f
return|;
block|}
DECL|function|getMaxViewportDimension
name|int
name|Renderer11
operator|::
name|getMaxViewportDimension
parameter_list|()
specifier|const
block|{
comment|// Maximum viewport size must be at least as large as the largest render buffer (or larger).
comment|// In our case return the maximum texture size, which is the maximum render buffer size.
name|META_ASSERT
argument_list|(
name|D3D11_REQ_TEXTURE2D_U_OR_V_DIMENSION
operator|*
literal|2
operator|-
literal|1
operator|<=
name|D3D11_VIEWPORT_BOUNDS_MAX
argument_list|)
expr_stmt|;
name|META_ASSERT
argument_list|(
name|D3D10_REQ_TEXTURE2D_U_OR_V_DIMENSION
operator|*
literal|2
operator|-
literal|1
operator|<=
name|D3D10_VIEWPORT_BOUNDS_MAX
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mFeatureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_REQ_TEXTURE2D_U_OR_V_DIMENSION
return|;
comment|// 16384
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_REQ_TEXTURE2D_U_OR_V_DIMENSION
return|;
comment|// 8192
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|getMaxTextureWidth
name|int
name|Renderer11
operator|::
name|getMaxTextureWidth
parameter_list|()
specifier|const
block|{
switch|switch
condition|(
name|mFeatureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_REQ_TEXTURE2D_U_OR_V_DIMENSION
return|;
comment|// 16384
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_REQ_TEXTURE2D_U_OR_V_DIMENSION
return|;
comment|// 8192
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|getMaxTextureHeight
name|int
name|Renderer11
operator|::
name|getMaxTextureHeight
parameter_list|()
specifier|const
block|{
switch|switch
condition|(
name|mFeatureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_REQ_TEXTURE2D_U_OR_V_DIMENSION
return|;
comment|// 16384
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_REQ_TEXTURE2D_U_OR_V_DIMENSION
return|;
comment|// 8192
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|get32BitIndexSupport
name|bool
name|Renderer11
operator|::
name|get32BitIndexSupport
parameter_list|()
specifier|const
block|{
switch|switch
condition|(
name|mFeatureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_REQ_DRAWINDEXED_INDEX_COUNT_2_TO_EXP
operator|>=
literal|32
return|;
comment|// true
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|getMinSwapInterval
name|int
name|Renderer11
operator|::
name|getMinSwapInterval
parameter_list|()
specifier|const
block|{
return|return
literal|0
return|;
block|}
DECL|function|getMaxSwapInterval
name|int
name|Renderer11
operator|::
name|getMaxSwapInterval
parameter_list|()
specifier|const
block|{
return|return
literal|4
return|;
block|}
DECL|function|getMaxSupportedSamples
name|int
name|Renderer11
operator|::
name|getMaxSupportedSamples
parameter_list|()
specifier|const
block|{
return|return
name|mMaxSupportedSamples
return|;
block|}
DECL|function|getNearestSupportedSamples
name|int
name|Renderer11
operator|::
name|getNearestSupportedSamples
parameter_list|(
name|DXGI_FORMAT
name|format
parameter_list|,
name|unsigned
name|int
name|requested
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|requested
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|MultisampleSupportMap
operator|::
name|const_iterator
name|iter
init|=
name|mMultisampleSupportMap
operator|.
name|find
argument_list|(
name|format
argument_list|)
decl_stmt|;
if|if
condition|(
name|iter
operator|!=
name|mMultisampleSupportMap
operator|.
name|end
argument_list|()
condition|)
block|{
specifier|const
name|MultisampleSupportInfo
modifier|&
name|info
init|=
name|iter
operator|->
name|second
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
name|requested
operator|-
literal|1
init|;
name|i
operator|<
name|D3D11_MAX_MULTISAMPLE_SAMPLE_COUNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|info
operator|.
name|qualityLevels
index|[
name|i
index|]
operator|>
literal|0
condition|)
block|{
return|return
name|i
operator|+
literal|1
return|;
block|}
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
DECL|function|getMaxRenderTargets
name|unsigned
name|int
name|Renderer11
operator|::
name|getMaxRenderTargets
parameter_list|()
specifier|const
block|{
name|META_ASSERT
argument_list|(
name|D3D11_SIMULTANEOUS_RENDER_TARGET_COUNT
operator|<=
name|gl
operator|::
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
argument_list|)
expr_stmt|;
name|META_ASSERT
argument_list|(
name|D3D10_SIMULTANEOUS_RENDER_TARGET_COUNT
operator|<=
name|gl
operator|::
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mFeatureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_SIMULTANEOUS_RENDER_TARGET_COUNT
return|;
comment|// 8
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_SIMULTANEOUS_RENDER_TARGET_COUNT
return|;
comment|// 8
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
DECL|function|copyToRenderTarget
name|bool
name|Renderer11
operator|::
name|copyToRenderTarget
parameter_list|(
name|TextureStorageInterface2D
modifier|*
name|dest
parameter_list|,
name|TextureStorageInterface2D
modifier|*
name|source
parameter_list|)
block|{
if|if
condition|(
name|source
operator|&&
name|dest
condition|)
block|{
name|TextureStorage11_2D
modifier|*
name|source11
init|=
name|TextureStorage11_2D
operator|::
name|makeTextureStorage11_2D
argument_list|(
name|source
operator|->
name|getStorageInstance
argument_list|()
argument_list|)
decl_stmt|;
name|TextureStorage11_2D
modifier|*
name|dest11
init|=
name|TextureStorage11_2D
operator|::
name|makeTextureStorage11_2D
argument_list|(
name|dest
operator|->
name|getStorageInstance
argument_list|()
argument_list|)
decl_stmt|;
name|mDeviceContext
operator|->
name|CopyResource
argument_list|(
name|dest11
operator|->
name|getBaseTexture
argument_list|()
argument_list|,
name|source11
operator|->
name|getBaseTexture
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|function|copyToRenderTarget
name|bool
name|Renderer11
operator|::
name|copyToRenderTarget
parameter_list|(
name|TextureStorageInterfaceCube
modifier|*
name|dest
parameter_list|,
name|TextureStorageInterfaceCube
modifier|*
name|source
parameter_list|)
block|{
if|if
condition|(
name|source
operator|&&
name|dest
condition|)
block|{
name|TextureStorage11_Cube
modifier|*
name|source11
init|=
name|TextureStorage11_Cube
operator|::
name|makeTextureStorage11_Cube
argument_list|(
name|source
operator|->
name|getStorageInstance
argument_list|()
argument_list|)
decl_stmt|;
name|TextureStorage11_Cube
modifier|*
name|dest11
init|=
name|TextureStorage11_Cube
operator|::
name|makeTextureStorage11_Cube
argument_list|(
name|dest
operator|->
name|getStorageInstance
argument_list|()
argument_list|)
decl_stmt|;
name|mDeviceContext
operator|->
name|CopyResource
argument_list|(
name|dest11
operator|->
name|getBaseTexture
argument_list|()
argument_list|,
name|source11
operator|->
name|getBaseTexture
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|function|copyImage
name|bool
name|Renderer11
operator|::
name|copyImage
parameter_list|(
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|sourceRect
parameter_list|,
name|GLenum
name|destFormat
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|TextureStorageInterface2D
modifier|*
name|storage
parameter_list|,
name|GLint
name|level
parameter_list|)
block|{
name|gl
operator|::
name|Renderbuffer
modifier|*
name|colorbuffer
init|=
name|framebuffer
operator|->
name|getReadColorbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|colorbuffer
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the color buffer from the frame buffer."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|RenderTarget11
modifier|*
name|sourceRenderTarget
init|=
name|RenderTarget11
operator|::
name|makeRenderTarget11
argument_list|(
name|colorbuffer
operator|->
name|getRenderTarget
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sourceRenderTarget
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the render target from the frame buffer."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|ID3D11ShaderResourceView
modifier|*
name|source
init|=
name|sourceRenderTarget
operator|->
name|getShaderResourceView
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|source
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the render target view from the render target."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|TextureStorage11_2D
modifier|*
name|storage11
init|=
name|TextureStorage11_2D
operator|::
name|makeTextureStorage11_2D
argument_list|(
name|storage
operator|->
name|getStorageInstance
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|storage11
condition|)
block|{
name|source
operator|->
name|Release
argument_list|()
expr_stmt|;
name|ERR
argument_list|(
literal|"Failed to retrieve the texture storage from the destination."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|RenderTarget11
modifier|*
name|destRenderTarget
init|=
name|RenderTarget11
operator|::
name|makeRenderTarget11
argument_list|(
name|storage11
operator|->
name|getRenderTarget
argument_list|(
name|level
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|destRenderTarget
condition|)
block|{
name|source
operator|->
name|Release
argument_list|()
expr_stmt|;
name|ERR
argument_list|(
literal|"Failed to retrieve the render target from the destination storage."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|ID3D11RenderTargetView
modifier|*
name|dest
init|=
name|destRenderTarget
operator|->
name|getRenderTargetView
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|dest
condition|)
block|{
name|source
operator|->
name|Release
argument_list|()
expr_stmt|;
name|ERR
argument_list|(
literal|"Failed to retrieve the render target view from the destination render target."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|gl
operator|::
name|Rectangle
name|destRect
decl_stmt|;
name|destRect
operator|.
name|x
operator|=
name|xoffset
expr_stmt|;
name|destRect
operator|.
name|y
operator|=
name|yoffset
expr_stmt|;
name|destRect
operator|.
name|width
operator|=
name|sourceRect
operator|.
name|width
expr_stmt|;
name|destRect
operator|.
name|height
operator|=
name|sourceRect
operator|.
name|height
expr_stmt|;
name|bool
name|ret
init|=
name|copyTexture
argument_list|(
name|source
argument_list|,
name|sourceRect
argument_list|,
name|sourceRenderTarget
operator|->
name|getWidth
argument_list|()
argument_list|,
name|sourceRenderTarget
operator|->
name|getHeight
argument_list|()
argument_list|,
name|dest
argument_list|,
name|destRect
argument_list|,
name|destRenderTarget
operator|->
name|getWidth
argument_list|()
argument_list|,
name|destRenderTarget
operator|->
name|getHeight
argument_list|()
argument_list|,
name|destFormat
argument_list|)
decl_stmt|;
name|source
operator|->
name|Release
argument_list|()
expr_stmt|;
name|dest
operator|->
name|Release
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
DECL|function|copyImage
name|bool
name|Renderer11
operator|::
name|copyImage
parameter_list|(
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|sourceRect
parameter_list|,
name|GLenum
name|destFormat
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|TextureStorageInterfaceCube
modifier|*
name|storage
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|)
block|{
name|gl
operator|::
name|Renderbuffer
modifier|*
name|colorbuffer
init|=
name|framebuffer
operator|->
name|getReadColorbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|colorbuffer
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the color buffer from the frame buffer."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|RenderTarget11
modifier|*
name|sourceRenderTarget
init|=
name|RenderTarget11
operator|::
name|makeRenderTarget11
argument_list|(
name|colorbuffer
operator|->
name|getRenderTarget
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sourceRenderTarget
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the render target from the frame buffer."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|ID3D11ShaderResourceView
modifier|*
name|source
init|=
name|sourceRenderTarget
operator|->
name|getShaderResourceView
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|source
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the render target view from the render target."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|TextureStorage11_Cube
modifier|*
name|storage11
init|=
name|TextureStorage11_Cube
operator|::
name|makeTextureStorage11_Cube
argument_list|(
name|storage
operator|->
name|getStorageInstance
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|storage11
condition|)
block|{
name|source
operator|->
name|Release
argument_list|()
expr_stmt|;
name|ERR
argument_list|(
literal|"Failed to retrieve the texture storage from the destination."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|RenderTarget11
modifier|*
name|destRenderTarget
init|=
name|RenderTarget11
operator|::
name|makeRenderTarget11
argument_list|(
name|storage11
operator|->
name|getRenderTarget
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|destRenderTarget
condition|)
block|{
name|source
operator|->
name|Release
argument_list|()
expr_stmt|;
name|ERR
argument_list|(
literal|"Failed to retrieve the render target from the destination storage."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|ID3D11RenderTargetView
modifier|*
name|dest
init|=
name|destRenderTarget
operator|->
name|getRenderTargetView
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|dest
condition|)
block|{
name|source
operator|->
name|Release
argument_list|()
expr_stmt|;
name|ERR
argument_list|(
literal|"Failed to retrieve the render target view from the destination render target."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|gl
operator|::
name|Rectangle
name|destRect
decl_stmt|;
name|destRect
operator|.
name|x
operator|=
name|xoffset
expr_stmt|;
name|destRect
operator|.
name|y
operator|=
name|yoffset
expr_stmt|;
name|destRect
operator|.
name|width
operator|=
name|sourceRect
operator|.
name|width
expr_stmt|;
name|destRect
operator|.
name|height
operator|=
name|sourceRect
operator|.
name|height
expr_stmt|;
name|bool
name|ret
init|=
name|copyTexture
argument_list|(
name|source
argument_list|,
name|sourceRect
argument_list|,
name|sourceRenderTarget
operator|->
name|getWidth
argument_list|()
argument_list|,
name|sourceRenderTarget
operator|->
name|getHeight
argument_list|()
argument_list|,
name|dest
argument_list|,
name|destRect
argument_list|,
name|destRenderTarget
operator|->
name|getWidth
argument_list|()
argument_list|,
name|destRenderTarget
operator|->
name|getHeight
argument_list|()
argument_list|,
name|destFormat
argument_list|)
decl_stmt|;
name|source
operator|->
name|Release
argument_list|()
expr_stmt|;
name|dest
operator|->
name|Release
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
DECL|function|copyTexture
name|bool
name|Renderer11
operator|::
name|copyTexture
parameter_list|(
name|ID3D11ShaderResourceView
modifier|*
name|source
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|sourceArea
parameter_list|,
name|unsigned
name|int
name|sourceWidth
parameter_list|,
name|unsigned
name|int
name|sourceHeight
parameter_list|,
name|ID3D11RenderTargetView
modifier|*
name|dest
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|destArea
parameter_list|,
name|unsigned
name|int
name|destWidth
parameter_list|,
name|unsigned
name|int
name|destHeight
parameter_list|,
name|GLenum
name|destFormat
parameter_list|)
block|{
name|HRESULT
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|mCopyResourcesInitialized
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|mCopyVB
operator|&&
operator|!
name|mCopySampler
operator|&&
operator|!
name|mCopyIL
operator|&&
operator|!
name|mCopyVS
operator|&&
operator|!
name|mCopyRGBAPS
operator|&&
operator|!
name|mCopyRGBPS
operator|&&
operator|!
name|mCopyLumPS
operator|&&
operator|!
name|mCopyLumAlphaPS
argument_list|)
expr_stmt|;
name|D3D11_BUFFER_DESC
name|vbDesc
decl_stmt|;
name|vbDesc
operator|.
name|ByteWidth
operator|=
sizeof|sizeof
argument_list|(
name|d3d11
operator|::
name|PositionTexCoordVertex
argument_list|)
operator|*
literal|4
expr_stmt|;
name|vbDesc
operator|.
name|Usage
operator|=
name|D3D11_USAGE_DYNAMIC
expr_stmt|;
name|vbDesc
operator|.
name|BindFlags
operator|=
name|D3D11_BIND_VERTEX_BUFFER
expr_stmt|;
name|vbDesc
operator|.
name|CPUAccessFlags
operator|=
name|D3D11_CPU_ACCESS_WRITE
expr_stmt|;
name|vbDesc
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|vbDesc
operator|.
name|StructureByteStride
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|CreateBuffer
argument_list|(
operator|&
name|vbDesc
argument_list|,
name|NULL
argument_list|,
operator|&
name|mCopyVB
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mCopyVB
argument_list|,
literal|"Renderer11 copy texture vertex buffer"
argument_list|)
expr_stmt|;
name|D3D11_SAMPLER_DESC
name|samplerDesc
decl_stmt|;
name|samplerDesc
operator|.
name|Filter
operator|=
name|D3D11_FILTER_MIN_MAG_MIP_LINEAR
expr_stmt|;
name|samplerDesc
operator|.
name|AddressU
operator|=
name|D3D11_TEXTURE_ADDRESS_CLAMP
expr_stmt|;
name|samplerDesc
operator|.
name|AddressV
operator|=
name|D3D11_TEXTURE_ADDRESS_CLAMP
expr_stmt|;
name|samplerDesc
operator|.
name|AddressW
operator|=
name|D3D11_TEXTURE_ADDRESS_CLAMP
expr_stmt|;
name|samplerDesc
operator|.
name|MipLODBias
operator|=
literal|0.0f
expr_stmt|;
name|samplerDesc
operator|.
name|MaxAnisotropy
operator|=
literal|0
expr_stmt|;
name|samplerDesc
operator|.
name|ComparisonFunc
operator|=
name|D3D11_COMPARISON_NEVER
expr_stmt|;
name|samplerDesc
operator|.
name|BorderColor
index|[
literal|0
index|]
operator|=
literal|0.0f
expr_stmt|;
name|samplerDesc
operator|.
name|BorderColor
index|[
literal|1
index|]
operator|=
literal|0.0f
expr_stmt|;
name|samplerDesc
operator|.
name|BorderColor
index|[
literal|2
index|]
operator|=
literal|0.0f
expr_stmt|;
name|samplerDesc
operator|.
name|BorderColor
index|[
literal|3
index|]
operator|=
literal|0.0f
expr_stmt|;
name|samplerDesc
operator|.
name|MinLOD
operator|=
literal|0.0f
expr_stmt|;
name|samplerDesc
operator|.
name|MaxLOD
operator|=
literal|0.0f
expr_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|CreateSamplerState
argument_list|(
operator|&
name|samplerDesc
argument_list|,
operator|&
name|mCopySampler
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mCopySampler
argument_list|,
literal|"Renderer11 copy sampler"
argument_list|)
expr_stmt|;
name|D3D11_INPUT_ELEMENT_DESC
name|quadLayout
index|[]
init|=
block|{
block|{
literal|"POSITION"
block|,
literal|0
block|,
name|DXGI_FORMAT_R32G32_FLOAT
block|,
literal|0
block|,
literal|0
block|,
name|D3D11_INPUT_PER_VERTEX_DATA
block|,
literal|0
block|}
block|,
block|{
literal|"TEXCOORD"
block|,
literal|0
block|,
name|DXGI_FORMAT_R32G32_FLOAT
block|,
literal|0
block|,
literal|8
block|,
name|D3D11_INPUT_PER_VERTEX_DATA
block|,
literal|0
block|}
block|,         }
decl_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|CreateInputLayout
argument_list|(
name|quadLayout
argument_list|,
literal|2
argument_list|,
name|g_VS_Passthrough
argument_list|,
sizeof|sizeof
argument_list|(
name|g_VS_Passthrough
argument_list|)
argument_list|,
operator|&
name|mCopyIL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mCopyIL
argument_list|,
literal|"Renderer11 copy texture input layout"
argument_list|)
expr_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|CreateVertexShader
argument_list|(
name|g_VS_Passthrough
argument_list|,
sizeof|sizeof
argument_list|(
name|g_VS_Passthrough
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|mCopyVS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mCopyVS
argument_list|,
literal|"Renderer11 copy texture vertex shader"
argument_list|)
expr_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|CreatePixelShader
argument_list|(
name|g_PS_PassthroughRGBA
argument_list|,
sizeof|sizeof
argument_list|(
name|g_PS_PassthroughRGBA
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|mCopyRGBAPS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mCopyRGBAPS
argument_list|,
literal|"Renderer11 copy texture RGBA pixel shader"
argument_list|)
expr_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|CreatePixelShader
argument_list|(
name|g_PS_PassthroughRGB
argument_list|,
sizeof|sizeof
argument_list|(
name|g_PS_PassthroughRGB
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|mCopyRGBPS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mCopyRGBPS
argument_list|,
literal|"Renderer11 copy texture RGB pixel shader"
argument_list|)
expr_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|CreatePixelShader
argument_list|(
name|g_PS_PassthroughLum
argument_list|,
sizeof|sizeof
argument_list|(
name|g_PS_PassthroughLum
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|mCopyLumPS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mCopyLumPS
argument_list|,
literal|"Renderer11 copy texture luminance pixel shader"
argument_list|)
expr_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|CreatePixelShader
argument_list|(
name|g_PS_PassthroughLumAlpha
argument_list|,
sizeof|sizeof
argument_list|(
name|g_PS_PassthroughLumAlpha
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|mCopyLumAlphaPS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mCopyLumAlphaPS
argument_list|,
literal|"Renderer11 copy texture luminance alpha pixel shader"
argument_list|)
expr_stmt|;
name|mCopyResourcesInitialized
operator|=
literal|true
expr_stmt|;
block|}
comment|// Verify the source and destination area sizes
if|if
condition|(
name|sourceArea
operator|.
name|x
argument_list|<
literal|0
operator|||
name|sourceArea
operator|.
name|x
operator|+
name|sourceArea
operator|.
name|width
argument_list|>
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|sourceWidth
argument_list|)
operator|||
name|sourceArea
operator|.
name|y
argument_list|<
literal|0
operator|||
name|sourceArea
operator|.
name|y
operator|+
name|sourceArea
operator|.
name|height
argument_list|>
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|sourceHeight
argument_list|)
operator|||
name|destArea
operator|.
name|x
argument_list|<
literal|0
operator|||
name|destArea
operator|.
name|x
operator|+
name|destArea
operator|.
name|width
argument_list|>
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|destWidth
argument_list|)
operator|||
name|destArea
operator|.
name|y
argument_list|<
literal|0
operator|||
name|destArea
operator|.
name|y
operator|+
name|destArea
operator|.
name|height
argument_list|>
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|destHeight
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|// Set vertices
name|D3D11_MAPPED_SUBRESOURCE
name|mappedResource
decl_stmt|;
name|result
operator|=
name|mDeviceContext
operator|->
name|Map
argument_list|(
name|mCopyVB
argument_list|,
literal|0
argument_list|,
name|D3D11_MAP_WRITE_DISCARD
argument_list|,
literal|0
argument_list|,
operator|&
name|mappedResource
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to map vertex buffer for texture copy, HRESULT: 0x%X."
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|d3d11
operator|::
name|PositionTexCoordVertex
modifier|*
name|vertices
init|=
cast|static_cast
argument_list|<
name|d3d11
operator|::
name|PositionTexCoordVertex
operator|*
argument_list|>
argument_list|(
name|mappedResource
operator|.
name|pData
argument_list|)
decl_stmt|;
comment|// Create a quad in homogeneous coordinates
name|float
name|x1
init|=
operator|(
name|destArea
operator|.
name|x
operator|/
name|float
argument_list|(
name|destWidth
argument_list|)
operator|)
operator|*
literal|2.0f
operator|-
literal|1.0f
decl_stmt|;
name|float
name|y1
init|=
operator|(
operator|(
name|destHeight
operator|-
name|destArea
operator|.
name|y
operator|-
name|destArea
operator|.
name|height
operator|)
operator|/
name|float
argument_list|(
name|destHeight
argument_list|)
operator|)
operator|*
literal|2.0f
operator|-
literal|1.0f
decl_stmt|;
name|float
name|x2
init|=
operator|(
operator|(
name|destArea
operator|.
name|x
operator|+
name|destArea
operator|.
name|width
operator|)
operator|/
name|float
argument_list|(
name|destWidth
argument_list|)
operator|)
operator|*
literal|2.0f
operator|-
literal|1.0f
decl_stmt|;
name|float
name|y2
init|=
operator|(
operator|(
name|destHeight
operator|-
name|destArea
operator|.
name|y
operator|)
operator|/
name|float
argument_list|(
name|destHeight
argument_list|)
operator|)
operator|*
literal|2.0f
operator|-
literal|1.0f
decl_stmt|;
name|float
name|u1
init|=
name|sourceArea
operator|.
name|x
operator|/
name|float
argument_list|(
name|sourceWidth
argument_list|)
decl_stmt|;
name|float
name|v1
init|=
name|sourceArea
operator|.
name|y
operator|/
name|float
argument_list|(
name|sourceHeight
argument_list|)
decl_stmt|;
name|float
name|u2
init|=
operator|(
name|sourceArea
operator|.
name|x
operator|+
name|sourceArea
operator|.
name|width
operator|)
operator|/
name|float
argument_list|(
name|sourceWidth
argument_list|)
decl_stmt|;
name|float
name|v2
init|=
operator|(
name|sourceArea
operator|.
name|y
operator|+
name|sourceArea
operator|.
name|height
operator|)
operator|/
name|float
argument_list|(
name|sourceHeight
argument_list|)
decl_stmt|;
name|d3d11
operator|::
name|SetPositionTexCoordVertex
argument_list|(
operator|&
name|vertices
index|[
literal|0
index|]
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|u1
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetPositionTexCoordVertex
argument_list|(
operator|&
name|vertices
index|[
literal|1
index|]
argument_list|,
name|x1
argument_list|,
name|y2
argument_list|,
name|u1
argument_list|,
name|v1
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetPositionTexCoordVertex
argument_list|(
operator|&
name|vertices
index|[
literal|2
index|]
argument_list|,
name|x2
argument_list|,
name|y1
argument_list|,
name|u2
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetPositionTexCoordVertex
argument_list|(
operator|&
name|vertices
index|[
literal|3
index|]
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|u2
argument_list|,
name|v1
argument_list|)
expr_stmt|;
name|mDeviceContext
operator|->
name|Unmap
argument_list|(
name|mCopyVB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
specifier|static
name|UINT
name|stride
init|=
sizeof|sizeof
argument_list|(
name|d3d11
operator|::
name|PositionTexCoordVertex
argument_list|)
decl_stmt|;
specifier|static
name|UINT
name|startIdx
init|=
literal|0
decl_stmt|;
name|mDeviceContext
operator|->
name|IASetVertexBuffers
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|mCopyVB
argument_list|,
operator|&
name|stride
argument_list|,
operator|&
name|startIdx
argument_list|)
expr_stmt|;
comment|// Apply state
name|mDeviceContext
operator|->
name|OMSetBlendState
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0xFFFFFFF
argument_list|)
expr_stmt|;
name|mDeviceContext
operator|->
name|OMSetDepthStencilState
argument_list|(
name|NULL
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|mDeviceContext
operator|->
name|RSSetState
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|// Apply shaders
name|mDeviceContext
operator|->
name|IASetInputLayout
argument_list|(
name|mCopyIL
argument_list|)
expr_stmt|;
name|mDeviceContext
operator|->
name|IASetPrimitiveTopology
argument_list|(
name|D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP
argument_list|)
expr_stmt|;
name|mDeviceContext
operator|->
name|VSSetShader
argument_list|(
name|mCopyVS
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ID3D11PixelShader
modifier|*
name|ps
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|destFormat
condition|)
block|{
case|case
name|GL_RGBA
case|:
name|ps
operator|=
name|mCopyRGBAPS
expr_stmt|;
break|break;
case|case
name|GL_RGB
case|:
name|ps
operator|=
name|mCopyRGBPS
expr_stmt|;
break|break;
case|case
name|GL_ALPHA
case|:
name|ps
operator|=
name|mCopyRGBAPS
expr_stmt|;
break|break;
case|case
name|GL_BGRA_EXT
case|:
name|ps
operator|=
name|mCopyRGBAPS
expr_stmt|;
break|break;
case|case
name|GL_LUMINANCE
case|:
name|ps
operator|=
name|mCopyLumPS
expr_stmt|;
break|break;
case|case
name|GL_LUMINANCE_ALPHA
case|:
name|ps
operator|=
name|mCopyLumAlphaPS
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
name|ps
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|mDeviceContext
operator|->
name|PSSetShader
argument_list|(
name|ps
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mDeviceContext
operator|->
name|GSSetShader
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Unset the currently bound shader resource to avoid conflicts
specifier|static
name|ID3D11ShaderResourceView
modifier|*
specifier|const
name|nullSRV
init|=
name|NULL
decl_stmt|;
name|mDeviceContext
operator|->
name|PSSetShaderResources
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|nullSRV
argument_list|)
expr_stmt|;
comment|// Apply render target
name|setOneTimeRenderTarget
argument_list|(
name|dest
argument_list|)
expr_stmt|;
comment|// Set the viewport
name|D3D11_VIEWPORT
name|viewport
decl_stmt|;
name|viewport
operator|.
name|TopLeftX
operator|=
literal|0
expr_stmt|;
name|viewport
operator|.
name|TopLeftY
operator|=
literal|0
expr_stmt|;
name|viewport
operator|.
name|Width
operator|=
name|destWidth
expr_stmt|;
name|viewport
operator|.
name|Height
operator|=
name|destHeight
expr_stmt|;
name|viewport
operator|.
name|MinDepth
operator|=
literal|0.0f
expr_stmt|;
name|viewport
operator|.
name|MaxDepth
operator|=
literal|1.0f
expr_stmt|;
name|mDeviceContext
operator|->
name|RSSetViewports
argument_list|(
literal|1
argument_list|,
operator|&
name|viewport
argument_list|)
expr_stmt|;
comment|// Apply textures
name|mDeviceContext
operator|->
name|PSSetShaderResources
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|source
argument_list|)
expr_stmt|;
name|mDeviceContext
operator|->
name|PSSetSamplers
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|mCopySampler
argument_list|)
expr_stmt|;
comment|// Draw the quad
name|mDeviceContext
operator|->
name|Draw
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Unbind textures and render targets and vertex buffer
name|mDeviceContext
operator|->
name|PSSetShaderResources
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|nullSRV
argument_list|)
expr_stmt|;
name|unapplyRenderTargets
argument_list|()
expr_stmt|;
name|UINT
name|zero
init|=
literal|0
decl_stmt|;
name|ID3D11Buffer
modifier|*
specifier|const
name|nullBuffer
init|=
name|NULL
decl_stmt|;
name|mDeviceContext
operator|->
name|IASetVertexBuffers
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|nullBuffer
argument_list|,
operator|&
name|zero
argument_list|,
operator|&
name|zero
argument_list|)
expr_stmt|;
name|markAllStateDirty
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|unapplyRenderTargets
name|void
name|Renderer11
operator|::
name|unapplyRenderTargets
parameter_list|()
block|{
name|setOneTimeRenderTarget
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
DECL|function|setOneTimeRenderTarget
name|void
name|Renderer11
operator|::
name|setOneTimeRenderTarget
parameter_list|(
name|ID3D11RenderTargetView
modifier|*
name|renderTargetView
parameter_list|)
block|{
name|ID3D11RenderTargetView
modifier|*
name|rtvArray
index|[
name|gl
operator|::
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
index|]
init|=
block|{
name|NULL
block|}
decl_stmt|;
name|rtvArray
index|[
literal|0
index|]
operator|=
name|renderTargetView
expr_stmt|;
name|mDeviceContext
operator|->
name|OMSetRenderTargets
argument_list|(
name|getMaxRenderTargets
argument_list|()
argument_list|,
name|rtvArray
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|// Do not preserve the serial for this one-time-use render target
for|for
control|(
name|unsigned
name|int
name|rtIndex
init|=
literal|0
init|;
name|rtIndex
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
condition|;
name|rtIndex
operator|++
control|)
block|{
name|mAppliedRenderTargetSerials
index|[
name|rtIndex
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
DECL|function|createRenderTarget
name|RenderTarget
modifier|*
name|Renderer11
operator|::
name|createRenderTarget
parameter_list|(
name|SwapChain
modifier|*
name|swapChain
parameter_list|,
name|bool
name|depth
parameter_list|)
block|{
name|SwapChain11
modifier|*
name|swapChain11
init|=
name|SwapChain11
operator|::
name|makeSwapChain11
argument_list|(
name|swapChain
argument_list|)
decl_stmt|;
name|RenderTarget11
modifier|*
name|renderTarget
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|depth
condition|)
block|{
comment|// Note: depth stencil may be NULL for 0 sized surfaces
name|renderTarget
operator|=
operator|new
name|RenderTarget11
argument_list|(
name|this
argument_list|,
name|swapChain11
operator|->
name|getDepthStencil
argument_list|()
argument_list|,
name|swapChain11
operator|->
name|getDepthStencilTexture
argument_list|()
argument_list|,
name|NULL
argument_list|,
name|swapChain11
operator|->
name|getWidth
argument_list|()
argument_list|,
name|swapChain11
operator|->
name|getHeight
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Note: render target may be NULL for 0 sized surfaces
name|renderTarget
operator|=
operator|new
name|RenderTarget11
argument_list|(
name|this
argument_list|,
name|swapChain11
operator|->
name|getRenderTarget
argument_list|()
argument_list|,
name|swapChain11
operator|->
name|getOffscreenTexture
argument_list|()
argument_list|,
name|swapChain11
operator|->
name|getRenderTargetShaderResource
argument_list|()
argument_list|,
name|swapChain11
operator|->
name|getWidth
argument_list|()
argument_list|,
name|swapChain11
operator|->
name|getHeight
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|renderTarget
return|;
block|}
DECL|function|createRenderTarget
name|RenderTarget
modifier|*
name|Renderer11
operator|::
name|createRenderTarget
parameter_list|(
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLsizei
name|samples
parameter_list|,
name|bool
name|depth
parameter_list|)
block|{
name|RenderTarget11
modifier|*
name|renderTarget
init|=
operator|new
name|RenderTarget11
argument_list|(
name|this
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|samples
argument_list|,
name|depth
argument_list|)
decl_stmt|;
return|return
name|renderTarget
return|;
block|}
DECL|function|loadExecutable
name|ShaderExecutable
modifier|*
name|Renderer11
operator|::
name|loadExecutable
parameter_list|(
specifier|const
name|void
modifier|*
name|function
parameter_list|,
name|size_t
name|length
parameter_list|,
name|rx
operator|::
name|ShaderType
name|type
parameter_list|)
block|{
name|ShaderExecutable11
modifier|*
name|executable
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|rx
operator|::
name|SHADER_VERTEX
case|:
block|{
name|ID3D11VertexShader
modifier|*
name|vshader
init|=
name|NULL
decl_stmt|;
name|HRESULT
name|result
init|=
name|mDevice
operator|->
name|CreateVertexShader
argument_list|(
name|function
argument_list|,
name|length
argument_list|,
name|NULL
argument_list|,
operator|&
name|vshader
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vshader
condition|)
block|{
name|executable
operator|=
operator|new
name|ShaderExecutable11
argument_list|(
name|function
argument_list|,
name|length
argument_list|,
name|vshader
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|rx
operator|::
name|SHADER_PIXEL
case|:
block|{
name|ID3D11PixelShader
modifier|*
name|pshader
init|=
name|NULL
decl_stmt|;
name|HRESULT
name|result
init|=
name|mDevice
operator|->
name|CreatePixelShader
argument_list|(
name|function
argument_list|,
name|length
argument_list|,
name|NULL
argument_list|,
operator|&
name|pshader
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pshader
condition|)
block|{
name|executable
operator|=
operator|new
name|ShaderExecutable11
argument_list|(
name|function
argument_list|,
name|length
argument_list|,
name|pshader
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|rx
operator|::
name|SHADER_GEOMETRY
case|:
block|{
name|ID3D11GeometryShader
modifier|*
name|gshader
init|=
name|NULL
decl_stmt|;
name|HRESULT
name|result
init|=
name|mDevice
operator|->
name|CreateGeometryShader
argument_list|(
name|function
argument_list|,
name|length
argument_list|,
name|NULL
argument_list|,
operator|&
name|gshader
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gshader
condition|)
block|{
name|executable
operator|=
operator|new
name|ShaderExecutable11
argument_list|(
name|function
argument_list|,
name|length
argument_list|,
name|gshader
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
name|executable
return|;
block|}
DECL|function|compileToExecutable
name|ShaderExecutable
modifier|*
name|Renderer11
operator|::
name|compileToExecutable
parameter_list|(
name|gl
operator|::
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|char
modifier|*
name|shaderHLSL
parameter_list|,
name|rx
operator|::
name|ShaderType
name|type
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|profile
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|rx
operator|::
name|SHADER_VERTEX
case|:
name|profile
operator|=
literal|"vs_4_0"
expr_stmt|;
break|break;
case|case
name|rx
operator|::
name|SHADER_PIXEL
case|:
name|profile
operator|=
literal|"ps_4_0"
expr_stmt|;
break|break;
case|case
name|rx
operator|::
name|SHADER_GEOMETRY
case|:
name|profile
operator|=
literal|"gs_4_0"
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ID3DBlob
modifier|*
name|binary
init|=
operator|(
name|ID3DBlob
operator|*
operator|)
name|compileToBinary
argument_list|(
name|infoLog
argument_list|,
name|shaderHLSL
argument_list|,
name|profile
argument_list|,
name|D3DCOMPILE_OPTIMIZATION_LEVEL0
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|binary
condition|)
return|return
name|NULL
return|;
name|ShaderExecutable
modifier|*
name|executable
init|=
name|loadExecutable
argument_list|(
operator|(
name|DWORD
operator|*
operator|)
name|binary
operator|->
name|GetBufferPointer
argument_list|()
argument_list|,
name|binary
operator|->
name|GetBufferSize
argument_list|()
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|binary
operator|->
name|Release
argument_list|()
expr_stmt|;
return|return
name|executable
return|;
block|}
DECL|function|createVertexBuffer
name|VertexBuffer
modifier|*
name|Renderer11
operator|::
name|createVertexBuffer
parameter_list|()
block|{
return|return
operator|new
name|VertexBuffer11
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|function|createIndexBuffer
name|IndexBuffer
modifier|*
name|Renderer11
operator|::
name|createIndexBuffer
parameter_list|()
block|{
return|return
operator|new
name|IndexBuffer11
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|function|createBufferStorage
name|BufferStorage
modifier|*
name|Renderer11
operator|::
name|createBufferStorage
parameter_list|()
block|{
return|return
operator|new
name|BufferStorage11
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|function|createQuery
name|QueryImpl
modifier|*
name|Renderer11
operator|::
name|createQuery
parameter_list|(
name|GLenum
name|type
parameter_list|)
block|{
return|return
operator|new
name|Query11
argument_list|(
name|this
argument_list|,
name|type
argument_list|)
return|;
block|}
DECL|function|createFence
name|FenceImpl
modifier|*
name|Renderer11
operator|::
name|createFence
parameter_list|()
block|{
return|return
operator|new
name|Fence11
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|function|getRenderTargetResource
name|bool
name|Renderer11
operator|::
name|getRenderTargetResource
parameter_list|(
name|gl
operator|::
name|Renderbuffer
modifier|*
name|colorbuffer
parameter_list|,
name|unsigned
name|int
modifier|*
name|subresourceIndex
parameter_list|,
name|ID3D11Texture2D
modifier|*
modifier|*
name|resource
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|colorbuffer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|RenderTarget11
modifier|*
name|renderTarget
init|=
name|RenderTarget11
operator|::
name|makeRenderTarget11
argument_list|(
name|colorbuffer
operator|->
name|getRenderTarget
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|renderTarget
condition|)
block|{
operator|*
name|subresourceIndex
operator|=
name|renderTarget
operator|->
name|getSubresourceIndex
argument_list|()
expr_stmt|;
name|ID3D11RenderTargetView
modifier|*
name|colorBufferRTV
init|=
name|renderTarget
operator|->
name|getRenderTargetView
argument_list|()
decl_stmt|;
if|if
condition|(
name|colorBufferRTV
condition|)
block|{
name|ID3D11Resource
modifier|*
name|textureResource
init|=
name|NULL
decl_stmt|;
name|colorBufferRTV
operator|->
name|GetResource
argument_list|(
operator|&
name|textureResource
argument_list|)
expr_stmt|;
name|colorBufferRTV
operator|->
name|Release
argument_list|()
expr_stmt|;
if|if
condition|(
name|textureResource
condition|)
block|{
name|HRESULT
name|result
init|=
name|textureResource
operator|->
name|QueryInterface
argument_list|(
name|IID_ID3D11Texture2D
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
name|resource
argument_list|)
decl_stmt|;
name|textureResource
operator|->
name|Release
argument_list|()
expr_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
name|ERR
argument_list|(
literal|"Failed to extract the ID3D11Texture2D from the render target resource, "
literal|"HRESULT: 0x%X."
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|function|blitRect
name|bool
name|Renderer11
operator|::
name|blitRect
parameter_list|(
name|gl
operator|::
name|Framebuffer
modifier|*
name|readTarget
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|readRect
parameter_list|,
name|gl
operator|::
name|Framebuffer
modifier|*
name|drawTarget
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|drawRect
parameter_list|,
name|bool
name|blitRenderTarget
parameter_list|,
name|bool
name|blitDepthStencil
parameter_list|)
block|{
if|if
condition|(
name|blitRenderTarget
condition|)
block|{
name|gl
operator|::
name|Renderbuffer
modifier|*
name|readBuffer
init|=
name|readTarget
operator|->
name|getReadColorbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|readBuffer
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the read buffer from the read framebuffer."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|RenderTarget
modifier|*
name|readRenderTarget
init|=
name|readBuffer
operator|->
name|getRenderTarget
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|colorAttachment
init|=
literal|0
init|;
name|colorAttachment
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
condition|;
name|colorAttachment
operator|++
control|)
block|{
if|if
condition|(
name|drawTarget
operator|->
name|isEnabledColorAttachment
argument_list|(
name|colorAttachment
argument_list|)
condition|)
block|{
name|gl
operator|::
name|Renderbuffer
modifier|*
name|drawBuffer
init|=
name|drawTarget
operator|->
name|getColorbuffer
argument_list|(
name|colorAttachment
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|drawBuffer
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the draw buffer from the draw framebuffer."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|RenderTarget
modifier|*
name|drawRenderTarget
init|=
name|drawBuffer
operator|->
name|getRenderTarget
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|blitRenderbufferRect
argument_list|(
name|readRect
argument_list|,
name|drawRect
argument_list|,
name|readRenderTarget
argument_list|,
name|drawRenderTarget
argument_list|,
literal|false
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|blitDepthStencil
condition|)
block|{
name|gl
operator|::
name|Renderbuffer
modifier|*
name|readBuffer
init|=
name|readTarget
operator|->
name|getDepthOrStencilbuffer
argument_list|()
decl_stmt|;
name|gl
operator|::
name|Renderbuffer
modifier|*
name|drawBuffer
init|=
name|drawTarget
operator|->
name|getDepthOrStencilbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|readBuffer
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the read depth-stencil buffer from the read framebuffer."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|drawBuffer
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the draw depth-stencil buffer from the draw framebuffer."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|RenderTarget
modifier|*
name|readRenderTarget
init|=
name|readBuffer
operator|->
name|getDepthStencil
argument_list|()
decl_stmt|;
name|RenderTarget
modifier|*
name|drawRenderTarget
init|=
name|drawBuffer
operator|->
name|getDepthStencil
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|blitRenderbufferRect
argument_list|(
name|readRect
argument_list|,
name|drawRect
argument_list|,
name|readRenderTarget
argument_list|,
name|drawRenderTarget
argument_list|,
literal|true
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|readPixels
name|void
name|Renderer11
operator|::
name|readPixels
parameter_list|(
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLsizei
name|outputPitch
parameter_list|,
name|bool
name|packReverseRowOrder
parameter_list|,
name|GLint
name|packAlignment
parameter_list|,
name|void
modifier|*
name|pixels
parameter_list|)
block|{
name|ID3D11Texture2D
modifier|*
name|colorBufferTexture
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|subresourceIndex
init|=
literal|0
decl_stmt|;
name|gl
operator|::
name|Renderbuffer
modifier|*
name|colorbuffer
init|=
name|framebuffer
operator|->
name|getReadColorbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|colorbuffer
operator|&&
name|getRenderTargetResource
argument_list|(
name|colorbuffer
argument_list|,
operator|&
name|subresourceIndex
argument_list|,
operator|&
name|colorBufferTexture
argument_list|)
condition|)
block|{
name|gl
operator|::
name|Rectangle
name|area
decl_stmt|;
name|area
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|area
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|area
operator|.
name|width
operator|=
name|width
expr_stmt|;
name|area
operator|.
name|height
operator|=
name|height
expr_stmt|;
name|readTextureData
argument_list|(
name|colorBufferTexture
argument_list|,
name|subresourceIndex
argument_list|,
name|area
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|outputPitch
argument_list|,
name|packReverseRowOrder
argument_list|,
name|packAlignment
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
name|colorBufferTexture
operator|->
name|Release
argument_list|()
expr_stmt|;
name|colorBufferTexture
operator|=
name|NULL
expr_stmt|;
block|}
block|}
DECL|function|createImage
name|Image
modifier|*
name|Renderer11
operator|::
name|createImage
parameter_list|()
block|{
return|return
operator|new
name|Image11
argument_list|()
return|;
block|}
DECL|function|generateMipmap
name|void
name|Renderer11
operator|::
name|generateMipmap
parameter_list|(
name|Image
modifier|*
name|dest
parameter_list|,
name|Image
modifier|*
name|src
parameter_list|)
block|{
name|Image11
modifier|*
name|dest11
init|=
name|Image11
operator|::
name|makeImage11
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|Image11
modifier|*
name|src11
init|=
name|Image11
operator|::
name|makeImage11
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|Image11
operator|::
name|generateMipmap
argument_list|(
name|dest11
argument_list|,
name|src11
argument_list|)
expr_stmt|;
block|}
DECL|function|createTextureStorage2D
name|TextureStorage
modifier|*
name|Renderer11
operator|::
name|createTextureStorage2D
parameter_list|(
name|SwapChain
modifier|*
name|swapChain
parameter_list|)
block|{
name|SwapChain11
modifier|*
name|swapChain11
init|=
name|SwapChain11
operator|::
name|makeSwapChain11
argument_list|(
name|swapChain
argument_list|)
decl_stmt|;
return|return
operator|new
name|TextureStorage11_2D
argument_list|(
name|this
argument_list|,
name|swapChain11
argument_list|)
return|;
block|}
DECL|function|createTextureStorage2D
name|TextureStorage
modifier|*
name|Renderer11
operator|::
name|createTextureStorage2D
parameter_list|(
name|int
name|levels
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|GLenum
name|usage
parameter_list|,
name|bool
name|forceRenderable
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
return|return
operator|new
name|TextureStorage11_2D
argument_list|(
name|this
argument_list|,
name|levels
argument_list|,
name|internalformat
argument_list|,
name|usage
argument_list|,
name|forceRenderable
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
return|;
block|}
DECL|function|createTextureStorageCube
name|TextureStorage
modifier|*
name|Renderer11
operator|::
name|createTextureStorageCube
parameter_list|(
name|int
name|levels
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|GLenum
name|usage
parameter_list|,
name|bool
name|forceRenderable
parameter_list|,
name|int
name|size
parameter_list|)
block|{
return|return
operator|new
name|TextureStorage11_Cube
argument_list|(
name|this
argument_list|,
name|levels
argument_list|,
name|internalformat
argument_list|,
name|usage
argument_list|,
name|forceRenderable
argument_list|,
name|size
argument_list|)
return|;
block|}
DECL|function|getFastPixelCopySize
specifier|static
specifier|inline
name|unsigned
name|int
name|getFastPixelCopySize
parameter_list|(
name|DXGI_FORMAT
name|sourceFormat
parameter_list|,
name|GLenum
name|destFormat
parameter_list|,
name|GLenum
name|destType
parameter_list|)
block|{
if|if
condition|(
name|sourceFormat
operator|==
name|DXGI_FORMAT_A8_UNORM
operator|&&
name|destFormat
operator|==
name|GL_ALPHA
operator|&&
name|destType
operator|==
name|GL_UNSIGNED_BYTE
condition|)
block|{
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|sourceFormat
operator|==
name|DXGI_FORMAT_R8G8B8A8_UNORM
operator|&&
name|destFormat
operator|==
name|GL_RGBA
operator|&&
name|destType
operator|==
name|GL_UNSIGNED_BYTE
condition|)
block|{
return|return
literal|4
return|;
block|}
elseif|else
if|if
condition|(
name|sourceFormat
operator|==
name|DXGI_FORMAT_B8G8R8A8_UNORM
operator|&&
name|destFormat
operator|==
name|GL_BGRA_EXT
operator|&&
name|destType
operator|==
name|GL_UNSIGNED_BYTE
condition|)
block|{
return|return
literal|4
return|;
block|}
elseif|else
if|if
condition|(
name|sourceFormat
operator|==
name|DXGI_FORMAT_R16G16B16A16_FLOAT
operator|&&
name|destFormat
operator|==
name|GL_RGBA
operator|&&
name|destType
operator|==
name|GL_HALF_FLOAT_OES
condition|)
block|{
return|return
literal|8
return|;
block|}
elseif|else
if|if
condition|(
name|sourceFormat
operator|==
name|DXGI_FORMAT_R32G32B32_FLOAT
operator|&&
name|destFormat
operator|==
name|GL_RGB
operator|&&
name|destType
operator|==
name|GL_FLOAT
condition|)
block|{
return|return
literal|12
return|;
block|}
elseif|else
if|if
condition|(
name|sourceFormat
operator|==
name|DXGI_FORMAT_R32G32B32A32_FLOAT
operator|&&
name|destFormat
operator|==
name|GL_RGBA
operator|&&
name|destType
operator|==
name|GL_FLOAT
condition|)
block|{
return|return
literal|16
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
DECL|function|readPixelColor
specifier|static
specifier|inline
name|void
name|readPixelColor
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|DXGI_FORMAT
name|format
parameter_list|,
name|unsigned
name|int
name|x
parameter_list|,
name|unsigned
name|int
name|y
parameter_list|,
name|int
name|inputPitch
parameter_list|,
name|gl
operator|::
name|Color
modifier|*
name|outColor
parameter_list|)
block|{
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|DXGI_FORMAT_R8G8B8A8_UNORM
case|:
block|{
name|unsigned
name|int
name|rgba
init|=
operator|*
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|int
operator|*
argument_list|>
argument_list|(
name|data
operator|+
literal|4
operator|*
name|x
operator|+
name|y
operator|*
name|inputPitch
argument_list|)
decl_stmt|;
name|outColor
operator|->
name|red
operator|=
operator|(
name|rgba
operator|&
literal|0x000000FF
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0x000000FF
operator|)
expr_stmt|;
name|outColor
operator|->
name|green
operator|=
operator|(
name|rgba
operator|&
literal|0x0000FF00
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0x0000FF00
operator|)
expr_stmt|;
name|outColor
operator|->
name|blue
operator|=
operator|(
name|rgba
operator|&
literal|0x00FF0000
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0x00FF0000
operator|)
expr_stmt|;
name|outColor
operator|->
name|alpha
operator|=
operator|(
name|rgba
operator|&
literal|0xFF000000
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0xFF000000
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|DXGI_FORMAT_A8_UNORM
case|:
block|{
name|outColor
operator|->
name|red
operator|=
literal|0.0f
expr_stmt|;
name|outColor
operator|->
name|green
operator|=
literal|0.0f
expr_stmt|;
name|outColor
operator|->
name|blue
operator|=
literal|0.0f
expr_stmt|;
name|outColor
operator|->
name|alpha
operator|=
operator|*
operator|(
name|data
operator|+
name|x
operator|+
name|y
operator|*
name|inputPitch
operator|)
operator|/
literal|255.0f
expr_stmt|;
block|}
break|break;
case|case
name|DXGI_FORMAT_R32G32B32A32_FLOAT
case|:
block|{
name|outColor
operator|->
name|red
operator|=
operator|*
operator|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|float
operator|*
argument_list|>
argument_list|(
name|data
operator|+
literal|16
operator|*
name|x
operator|+
name|y
operator|*
name|inputPitch
argument_list|)
operator|+
literal|0
operator|)
expr_stmt|;
name|outColor
operator|->
name|green
operator|=
operator|*
operator|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|float
operator|*
argument_list|>
argument_list|(
name|data
operator|+
literal|16
operator|*
name|x
operator|+
name|y
operator|*
name|inputPitch
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
name|outColor
operator|->
name|blue
operator|=
operator|*
operator|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|float
operator|*
argument_list|>
argument_list|(
name|data
operator|+
literal|16
operator|*
name|x
operator|+
name|y
operator|*
name|inputPitch
argument_list|)
operator|+
literal|2
operator|)
expr_stmt|;
name|outColor
operator|->
name|alpha
operator|=
operator|*
operator|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|float
operator|*
argument_list|>
argument_list|(
name|data
operator|+
literal|16
operator|*
name|x
operator|+
name|y
operator|*
name|inputPitch
argument_list|)
operator|+
literal|3
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|DXGI_FORMAT_R32G32B32_FLOAT
case|:
block|{
name|outColor
operator|->
name|red
operator|=
operator|*
operator|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|float
operator|*
argument_list|>
argument_list|(
name|data
operator|+
literal|12
operator|*
name|x
operator|+
name|y
operator|*
name|inputPitch
argument_list|)
operator|+
literal|0
operator|)
expr_stmt|;
name|outColor
operator|->
name|green
operator|=
operator|*
operator|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|float
operator|*
argument_list|>
argument_list|(
name|data
operator|+
literal|12
operator|*
name|x
operator|+
name|y
operator|*
name|inputPitch
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
name|outColor
operator|->
name|blue
operator|=
operator|*
operator|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|float
operator|*
argument_list|>
argument_list|(
name|data
operator|+
literal|12
operator|*
name|x
operator|+
name|y
operator|*
name|inputPitch
argument_list|)
operator|+
literal|2
operator|)
expr_stmt|;
name|outColor
operator|->
name|alpha
operator|=
literal|1.0f
expr_stmt|;
block|}
break|break;
case|case
name|DXGI_FORMAT_R16G16B16A16_FLOAT
case|:
block|{
name|outColor
operator|->
name|red
operator|=
name|gl
operator|::
name|float16ToFloat32
argument_list|(
operator|*
operator|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|short
operator|*
argument_list|>
argument_list|(
name|data
operator|+
literal|8
operator|*
name|x
operator|+
name|y
operator|*
name|inputPitch
argument_list|)
operator|+
literal|0
operator|)
argument_list|)
expr_stmt|;
name|outColor
operator|->
name|green
operator|=
name|gl
operator|::
name|float16ToFloat32
argument_list|(
operator|*
operator|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|short
operator|*
argument_list|>
argument_list|(
name|data
operator|+
literal|8
operator|*
name|x
operator|+
name|y
operator|*
name|inputPitch
argument_list|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|outColor
operator|->
name|blue
operator|=
name|gl
operator|::
name|float16ToFloat32
argument_list|(
operator|*
operator|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|short
operator|*
argument_list|>
argument_list|(
name|data
operator|+
literal|8
operator|*
name|x
operator|+
name|y
operator|*
name|inputPitch
argument_list|)
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|outColor
operator|->
name|alpha
operator|=
name|gl
operator|::
name|float16ToFloat32
argument_list|(
operator|*
operator|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|short
operator|*
argument_list|>
argument_list|(
name|data
operator|+
literal|8
operator|*
name|x
operator|+
name|y
operator|*
name|inputPitch
argument_list|)
operator|+
literal|3
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DXGI_FORMAT_B8G8R8A8_UNORM
case|:
block|{
name|unsigned
name|int
name|bgra
init|=
operator|*
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|int
operator|*
argument_list|>
argument_list|(
name|data
operator|+
literal|4
operator|*
name|x
operator|+
name|y
operator|*
name|inputPitch
argument_list|)
decl_stmt|;
name|outColor
operator|->
name|red
operator|=
operator|(
name|bgra
operator|&
literal|0x00FF0000
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0x00FF0000
operator|)
expr_stmt|;
name|outColor
operator|->
name|blue
operator|=
operator|(
name|bgra
operator|&
literal|0x000000FF
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0x000000FF
operator|)
expr_stmt|;
name|outColor
operator|->
name|green
operator|=
operator|(
name|bgra
operator|&
literal|0x0000FF00
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0x0000FF00
operator|)
expr_stmt|;
name|outColor
operator|->
name|alpha
operator|=
operator|(
name|bgra
operator|&
literal|0xFF000000
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0xFF000000
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|DXGI_FORMAT_R8_UNORM
case|:
block|{
name|outColor
operator|->
name|red
operator|=
operator|*
operator|(
name|data
operator|+
name|x
operator|+
name|y
operator|*
name|inputPitch
operator|)
operator|/
literal|255.0f
expr_stmt|;
name|outColor
operator|->
name|green
operator|=
literal|0.0f
expr_stmt|;
name|outColor
operator|->
name|blue
operator|=
literal|0.0f
expr_stmt|;
name|outColor
operator|->
name|alpha
operator|=
literal|1.0f
expr_stmt|;
block|}
break|break;
case|case
name|DXGI_FORMAT_R8G8_UNORM
case|:
block|{
name|unsigned
name|short
name|rg
init|=
operator|*
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|short
operator|*
argument_list|>
argument_list|(
name|data
operator|+
literal|2
operator|*
name|x
operator|+
name|y
operator|*
name|inputPitch
argument_list|)
decl_stmt|;
name|outColor
operator|->
name|red
operator|=
operator|(
name|rg
operator|&
literal|0xFF00
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0xFF00
operator|)
expr_stmt|;
name|outColor
operator|->
name|green
operator|=
operator|(
name|rg
operator|&
literal|0x00FF
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0x00FF
operator|)
expr_stmt|;
name|outColor
operator|->
name|blue
operator|=
literal|0.0f
expr_stmt|;
name|outColor
operator|->
name|alpha
operator|=
literal|1.0f
expr_stmt|;
block|}
break|break;
case|case
name|DXGI_FORMAT_R16_FLOAT
case|:
block|{
name|outColor
operator|->
name|red
operator|=
name|gl
operator|::
name|float16ToFloat32
argument_list|(
operator|*
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|short
operator|*
argument_list|>
argument_list|(
name|data
operator|+
literal|2
operator|*
name|x
operator|+
name|y
operator|*
name|inputPitch
argument_list|)
argument_list|)
expr_stmt|;
name|outColor
operator|->
name|green
operator|=
literal|0.0f
expr_stmt|;
name|outColor
operator|->
name|blue
operator|=
literal|0.0f
expr_stmt|;
name|outColor
operator|->
name|alpha
operator|=
literal|1.0f
expr_stmt|;
block|}
break|break;
case|case
name|DXGI_FORMAT_R16G16_FLOAT
case|:
block|{
name|outColor
operator|->
name|red
operator|=
name|gl
operator|::
name|float16ToFloat32
argument_list|(
operator|*
operator|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|short
operator|*
argument_list|>
argument_list|(
name|data
operator|+
literal|4
operator|*
name|x
operator|+
name|y
operator|*
name|inputPitch
argument_list|)
operator|+
literal|0
operator|)
argument_list|)
expr_stmt|;
name|outColor
operator|->
name|green
operator|=
name|gl
operator|::
name|float16ToFloat32
argument_list|(
operator|*
operator|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|short
operator|*
argument_list|>
argument_list|(
name|data
operator|+
literal|4
operator|*
name|x
operator|+
name|y
operator|*
name|inputPitch
argument_list|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|outColor
operator|->
name|blue
operator|=
literal|0.0f
expr_stmt|;
name|outColor
operator|->
name|alpha
operator|=
literal|1.0f
expr_stmt|;
block|}
break|break;
default|default:
name|ERR
argument_list|(
literal|"ReadPixelColor not implemented for DXGI format %u."
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
DECL|function|writePixelColor
specifier|static
specifier|inline
name|void
name|writePixelColor
parameter_list|(
specifier|const
name|gl
operator|::
name|Color
modifier|&
name|color
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|unsigned
name|int
name|x
parameter_list|,
name|unsigned
name|int
name|y
parameter_list|,
name|int
name|outputPitch
parameter_list|,
name|void
modifier|*
name|outData
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|byteData
init|=
cast|reinterpret_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|outData
argument_list|)
decl_stmt|;
name|unsigned
name|short
modifier|*
name|shortData
init|=
cast|reinterpret_cast
argument_list|<
name|unsigned
name|short
operator|*
argument_list|>
argument_list|(
name|outData
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|GL_RGBA
case|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_UNSIGNED_BYTE
case|:
name|byteData
index|[
literal|4
operator|*
name|x
operator|+
name|y
operator|*
name|outputPitch
operator|+
literal|0
index|]
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|char
argument_list|>
argument_list|(
literal|255
operator|*
name|color
operator|.
name|red
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
name|byteData
index|[
literal|4
operator|*
name|x
operator|+
name|y
operator|*
name|outputPitch
operator|+
literal|1
index|]
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|char
argument_list|>
argument_list|(
literal|255
operator|*
name|color
operator|.
name|green
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
name|byteData
index|[
literal|4
operator|*
name|x
operator|+
name|y
operator|*
name|outputPitch
operator|+
literal|2
index|]
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|char
argument_list|>
argument_list|(
literal|255
operator|*
name|color
operator|.
name|blue
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
name|byteData
index|[
literal|4
operator|*
name|x
operator|+
name|y
operator|*
name|outputPitch
operator|+
literal|3
index|]
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|char
argument_list|>
argument_list|(
literal|255
operator|*
name|color
operator|.
name|alpha
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ERR
argument_list|(
literal|"WritePixelColor not implemented for format GL_RGBA and type 0x%X."
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|GL_BGRA_EXT
case|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_UNSIGNED_BYTE
case|:
name|byteData
index|[
literal|4
operator|*
name|x
operator|+
name|y
operator|*
name|outputPitch
operator|+
literal|0
index|]
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|char
argument_list|>
argument_list|(
literal|255
operator|*
name|color
operator|.
name|blue
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
name|byteData
index|[
literal|4
operator|*
name|x
operator|+
name|y
operator|*
name|outputPitch
operator|+
literal|1
index|]
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|char
argument_list|>
argument_list|(
literal|255
operator|*
name|color
operator|.
name|green
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
name|byteData
index|[
literal|4
operator|*
name|x
operator|+
name|y
operator|*
name|outputPitch
operator|+
literal|2
index|]
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|char
argument_list|>
argument_list|(
literal|255
operator|*
name|color
operator|.
name|red
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
name|byteData
index|[
literal|4
operator|*
name|x
operator|+
name|y
operator|*
name|outputPitch
operator|+
literal|3
index|]
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|char
argument_list|>
argument_list|(
literal|255
operator|*
name|color
operator|.
name|alpha
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_SHORT_4_4_4_4_REV_EXT
case|:
comment|// According to the desktop GL spec in the "Transfer of Pixel Rectangles" section
comment|// this type is packed as follows:
comment|//   15   14   13   12   11   10    9    8    7    6    5    4    3    2    1    0
comment|//  --------------------------------------------------------------------------------
comment|// |       4th         |        3rd         |        2nd        |   1st component   |
comment|//  --------------------------------------------------------------------------------
comment|// in the case of BGRA_EXT, B is the first component, G the second, and so forth.
name|shortData
index|[
name|x
operator|+
name|y
operator|*
name|outputPitch
operator|/
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
expr|]
operator|=
operator|(
cast|static_cast
argument_list|<
name|unsigned
name|short
argument_list|>
argument_list|(
literal|15
operator|*
name|color
operator|.
name|alpha
operator|+
literal|0.5f
argument_list|)
operator|<<
literal|12
operator|)
operator||
operator|(
cast|static_cast
argument_list|<
name|unsigned
name|short
argument_list|>
argument_list|(
literal|15
operator|*
name|color
operator|.
name|red
operator|+
literal|0.5f
argument_list|)
operator|<<
literal|8
operator|)
operator||
operator|(
cast|static_cast
argument_list|<
name|unsigned
name|short
argument_list|>
argument_list|(
literal|15
operator|*
name|color
operator|.
name|green
operator|+
literal|0.5f
argument_list|)
operator|<<
literal|4
operator|)
operator||
operator|(
cast|static_cast
argument_list|<
name|unsigned
name|short
argument_list|>
argument_list|(
literal|15
operator|*
name|color
operator|.
name|blue
operator|+
literal|0.5f
argument_list|)
operator|<<
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_SHORT_1_5_5_5_REV_EXT
case|:
comment|// According to the desktop GL spec in the "Transfer of Pixel Rectangles" section
comment|// this type is packed as follows:
comment|//   15   14   13   12   11   10    9    8    7    6    5    4    3    2    1    0
comment|//  --------------------------------------------------------------------------------
comment|// | 4th |          3rd           |           2nd          |      1st component     |
comment|//  --------------------------------------------------------------------------------
comment|// in the case of BGRA_EXT, B is the first component, G the second, and so forth.
name|shortData
index|[
name|x
operator|+
name|y
operator|*
name|outputPitch
operator|/
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
expr|]
operator|=
operator|(
cast|static_cast
argument_list|<
name|unsigned
name|short
argument_list|>
argument_list|(
name|color
operator|.
name|alpha
operator|+
literal|0.5f
argument_list|)
operator|<<
literal|15
operator|)
operator||
operator|(
cast|static_cast
argument_list|<
name|unsigned
name|short
argument_list|>
argument_list|(
literal|31
operator|*
name|color
operator|.
name|red
operator|+
literal|0.5f
argument_list|)
operator|<<
literal|10
operator|)
operator||
operator|(
cast|static_cast
argument_list|<
name|unsigned
name|short
argument_list|>
argument_list|(
literal|31
operator|*
name|color
operator|.
name|green
operator|+
literal|0.5f
argument_list|)
operator|<<
literal|5
operator|)
operator||
operator|(
cast|static_cast
argument_list|<
name|unsigned
name|short
argument_list|>
argument_list|(
literal|31
operator|*
name|color
operator|.
name|blue
operator|+
literal|0.5f
argument_list|)
operator|<<
literal|0
operator|)
expr_stmt|;
break|break;
default|default:
name|ERR
argument_list|(
literal|"WritePixelColor not implemented for format GL_BGRA_EXT and type 0x%X."
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|GL_RGB
case|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_UNSIGNED_SHORT_5_6_5
case|:
name|shortData
index|[
name|x
operator|+
name|y
operator|*
name|outputPitch
operator|/
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
expr|]
operator|=
operator|(
cast|static_cast
argument_list|<
name|unsigned
name|short
argument_list|>
argument_list|(
literal|31
operator|*
name|color
operator|.
name|blue
operator|+
literal|0.5f
argument_list|)
operator|<<
literal|0
operator|)
operator||
operator|(
cast|static_cast
argument_list|<
name|unsigned
name|short
argument_list|>
argument_list|(
literal|63
operator|*
name|color
operator|.
name|green
operator|+
literal|0.5f
argument_list|)
operator|<<
literal|5
operator|)
operator||
operator|(
cast|static_cast
argument_list|<
name|unsigned
name|short
argument_list|>
argument_list|(
literal|31
operator|*
name|color
operator|.
name|red
operator|+
literal|0.5f
argument_list|)
operator|<<
literal|11
operator|)
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_BYTE
case|:
name|byteData
index|[
literal|3
operator|*
name|x
operator|+
name|y
operator|*
name|outputPitch
operator|+
literal|0
index|]
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|char
argument_list|>
argument_list|(
literal|255
operator|*
name|color
operator|.
name|red
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
name|byteData
index|[
literal|3
operator|*
name|x
operator|+
name|y
operator|*
name|outputPitch
operator|+
literal|1
index|]
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|char
argument_list|>
argument_list|(
literal|255
operator|*
name|color
operator|.
name|green
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
name|byteData
index|[
literal|3
operator|*
name|x
operator|+
name|y
operator|*
name|outputPitch
operator|+
literal|2
index|]
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|char
argument_list|>
argument_list|(
literal|255
operator|*
name|color
operator|.
name|blue
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ERR
argument_list|(
literal|"WritePixelColor not implemented for format GL_RGB and type 0x%X."
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|ERR
argument_list|(
literal|"WritePixelColor not implemented for format 0x%X."
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
DECL|function|readTextureData
name|void
name|Renderer11
operator|::
name|readTextureData
parameter_list|(
name|ID3D11Texture2D
modifier|*
name|texture
parameter_list|,
name|unsigned
name|int
name|subResource
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|area
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLsizei
name|outputPitch
parameter_list|,
name|bool
name|packReverseRowOrder
parameter_list|,
name|GLint
name|packAlignment
parameter_list|,
name|void
modifier|*
name|pixels
parameter_list|)
block|{
name|D3D11_TEXTURE2D_DESC
name|textureDesc
decl_stmt|;
name|texture
operator|->
name|GetDesc
argument_list|(
operator|&
name|textureDesc
argument_list|)
expr_stmt|;
name|D3D11_TEXTURE2D_DESC
name|stagingDesc
decl_stmt|;
name|stagingDesc
operator|.
name|Width
operator|=
name|area
operator|.
name|width
expr_stmt|;
name|stagingDesc
operator|.
name|Height
operator|=
name|area
operator|.
name|height
expr_stmt|;
name|stagingDesc
operator|.
name|MipLevels
operator|=
literal|1
expr_stmt|;
name|stagingDesc
operator|.
name|ArraySize
operator|=
literal|1
expr_stmt|;
name|stagingDesc
operator|.
name|Format
operator|=
name|textureDesc
operator|.
name|Format
expr_stmt|;
name|stagingDesc
operator|.
name|SampleDesc
operator|.
name|Count
operator|=
literal|1
expr_stmt|;
name|stagingDesc
operator|.
name|SampleDesc
operator|.
name|Quality
operator|=
literal|0
expr_stmt|;
name|stagingDesc
operator|.
name|Usage
operator|=
name|D3D11_USAGE_STAGING
expr_stmt|;
name|stagingDesc
operator|.
name|BindFlags
operator|=
literal|0
expr_stmt|;
name|stagingDesc
operator|.
name|CPUAccessFlags
operator|=
name|D3D11_CPU_ACCESS_READ
expr_stmt|;
name|stagingDesc
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|ID3D11Texture2D
modifier|*
name|stagingTex
init|=
name|NULL
decl_stmt|;
name|HRESULT
name|result
init|=
name|mDevice
operator|->
name|CreateTexture2D
argument_list|(
operator|&
name|stagingDesc
argument_list|,
name|NULL
argument_list|,
operator|&
name|stagingTex
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to create staging texture for readPixels, HRESULT: 0x%X."
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
name|ID3D11Texture2D
modifier|*
name|srcTex
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|textureDesc
operator|.
name|SampleDesc
operator|.
name|Count
operator|>
literal|1
condition|)
block|{
name|D3D11_TEXTURE2D_DESC
name|resolveDesc
decl_stmt|;
name|resolveDesc
operator|.
name|Width
operator|=
name|textureDesc
operator|.
name|Width
expr_stmt|;
name|resolveDesc
operator|.
name|Height
operator|=
name|textureDesc
operator|.
name|Height
expr_stmt|;
name|resolveDesc
operator|.
name|MipLevels
operator|=
literal|1
expr_stmt|;
name|resolveDesc
operator|.
name|ArraySize
operator|=
literal|1
expr_stmt|;
name|resolveDesc
operator|.
name|Format
operator|=
name|textureDesc
operator|.
name|Format
expr_stmt|;
name|resolveDesc
operator|.
name|SampleDesc
operator|.
name|Count
operator|=
literal|1
expr_stmt|;
name|resolveDesc
operator|.
name|SampleDesc
operator|.
name|Quality
operator|=
literal|0
expr_stmt|;
name|resolveDesc
operator|.
name|Usage
operator|=
name|D3D11_USAGE_DEFAULT
expr_stmt|;
name|resolveDesc
operator|.
name|BindFlags
operator|=
literal|0
expr_stmt|;
name|resolveDesc
operator|.
name|CPUAccessFlags
operator|=
literal|0
expr_stmt|;
name|resolveDesc
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|CreateTexture2D
argument_list|(
operator|&
name|resolveDesc
argument_list|,
name|NULL
argument_list|,
operator|&
name|srcTex
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to create resolve texture for readPixels, HRESULT: 0x%X."
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|stagingTex
operator|->
name|Release
argument_list|()
expr_stmt|;
return|return;
block|}
name|mDeviceContext
operator|->
name|ResolveSubresource
argument_list|(
name|srcTex
argument_list|,
literal|0
argument_list|,
name|texture
argument_list|,
name|subResource
argument_list|,
name|textureDesc
operator|.
name|Format
argument_list|)
expr_stmt|;
name|subResource
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|srcTex
operator|=
name|texture
expr_stmt|;
name|srcTex
operator|->
name|AddRef
argument_list|()
expr_stmt|;
block|}
name|D3D11_BOX
name|srcBox
decl_stmt|;
name|srcBox
operator|.
name|left
operator|=
name|area
operator|.
name|x
expr_stmt|;
name|srcBox
operator|.
name|right
operator|=
name|area
operator|.
name|x
operator|+
name|area
operator|.
name|width
expr_stmt|;
name|srcBox
operator|.
name|top
operator|=
name|area
operator|.
name|y
expr_stmt|;
name|srcBox
operator|.
name|bottom
operator|=
name|area
operator|.
name|y
operator|+
name|area
operator|.
name|height
expr_stmt|;
name|srcBox
operator|.
name|front
operator|=
literal|0
expr_stmt|;
name|srcBox
operator|.
name|back
operator|=
literal|1
expr_stmt|;
name|mDeviceContext
operator|->
name|CopySubresourceRegion
argument_list|(
name|stagingTex
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|srcTex
argument_list|,
name|subResource
argument_list|,
operator|&
name|srcBox
argument_list|)
expr_stmt|;
name|srcTex
operator|->
name|Release
argument_list|()
expr_stmt|;
name|srcTex
operator|=
name|NULL
expr_stmt|;
name|D3D11_MAPPED_SUBRESOURCE
name|mapping
decl_stmt|;
name|mDeviceContext
operator|->
name|Map
argument_list|(
name|stagingTex
argument_list|,
literal|0
argument_list|,
name|D3D11_MAP_READ
argument_list|,
literal|0
argument_list|,
operator|&
name|mapping
argument_list|)
expr_stmt|;
name|unsigned
name|char
modifier|*
name|source
decl_stmt|;
name|int
name|inputPitch
decl_stmt|;
if|if
condition|(
name|packReverseRowOrder
condition|)
block|{
name|source
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|mapping
operator|.
name|pData
argument_list|)
operator|+
name|mapping
operator|.
name|RowPitch
operator|*
operator|(
name|area
operator|.
name|height
operator|-
literal|1
operator|)
expr_stmt|;
name|inputPitch
operator|=
operator|-
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|mapping
operator|.
name|RowPitch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|source
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|mapping
operator|.
name|pData
argument_list|)
expr_stmt|;
name|inputPitch
operator|=
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|mapping
operator|.
name|RowPitch
argument_list|)
expr_stmt|;
block|}
name|unsigned
name|int
name|fastPixelSize
init|=
name|getFastPixelCopySize
argument_list|(
name|textureDesc
operator|.
name|Format
argument_list|,
name|format
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|fastPixelSize
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|char
modifier|*
name|dest
init|=
cast|static_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|pixels
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|area
operator|.
name|height
condition|;
name|j
operator|++
control|)
block|{
name|memcpy
argument_list|(
name|dest
operator|+
name|j
operator|*
name|outputPitch
argument_list|,
name|source
operator|+
name|j
operator|*
name|inputPitch
argument_list|,
name|area
operator|.
name|width
operator|*
name|fastPixelSize
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|textureDesc
operator|.
name|Format
operator|==
name|DXGI_FORMAT_B8G8R8A8_UNORM
operator|&&
name|format
operator|==
name|GL_RGBA
operator|&&
name|type
operator|==
name|GL_UNSIGNED_BYTE
condition|)
block|{
comment|// Fast path for swapping red with blue
name|unsigned
name|char
modifier|*
name|dest
init|=
cast|static_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|pixels
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|area
operator|.
name|height
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|area
operator|.
name|width
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|argb
init|=
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|(
name|source
operator|+
literal|4
operator|*
name|i
operator|+
name|j
operator|*
name|inputPitch
operator|)
decl_stmt|;
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|(
name|dest
operator|+
literal|4
operator|*
name|i
operator|+
name|j
operator|*
name|outputPitch
operator|)
operator|=
operator|(
name|argb
operator|&
literal|0xFF00FF00
operator|)
operator||
comment|// Keep alpha and green
operator|(
name|argb
operator|&
literal|0x00FF0000
operator|)
operator|>>
literal|16
operator||
comment|// Move red to blue
operator|(
name|argb
operator|&
literal|0x000000FF
operator|)
operator|<<
literal|16
expr_stmt|;
comment|// Move blue to red
block|}
block|}
block|}
else|else
block|{
name|gl
operator|::
name|Color
name|pixelColor
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|area
operator|.
name|height
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|area
operator|.
name|width
condition|;
name|i
operator|++
control|)
block|{
name|readPixelColor
argument_list|(
name|source
argument_list|,
name|textureDesc
operator|.
name|Format
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|inputPitch
argument_list|,
operator|&
name|pixelColor
argument_list|)
expr_stmt|;
name|writePixelColor
argument_list|(
name|pixelColor
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|outputPitch
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|mDeviceContext
operator|->
name|Unmap
argument_list|(
name|stagingTex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stagingTex
operator|->
name|Release
argument_list|()
expr_stmt|;
name|stagingTex
operator|=
name|NULL
expr_stmt|;
block|}
DECL|function|blitRenderbufferRect
name|bool
name|Renderer11
operator|::
name|blitRenderbufferRect
parameter_list|(
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|readRect
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|drawRect
parameter_list|,
name|RenderTarget
modifier|*
name|readRenderTarget
parameter_list|,
name|RenderTarget
modifier|*
name|drawRenderTarget
parameter_list|,
name|bool
name|wholeBufferCopy
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|readRect
operator|.
name|width
operator|==
name|drawRect
operator|.
name|width
operator|&&
name|readRect
operator|.
name|height
operator|==
name|drawRect
operator|.
name|height
argument_list|)
expr_stmt|;
name|RenderTarget11
modifier|*
name|readRenderTarget11
init|=
name|RenderTarget11
operator|::
name|makeRenderTarget11
argument_list|(
name|readRenderTarget
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|readRenderTarget
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the read render target from the read framebuffer."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|ID3D11Texture2D
modifier|*
name|readTexture
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|readSubresource
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|readRenderTarget
operator|->
name|getSamples
argument_list|()
operator|>
literal|0
condition|)
block|{
name|ID3D11Texture2D
modifier|*
name|unresolvedTexture
init|=
name|readRenderTarget11
operator|->
name|getTexture
argument_list|()
decl_stmt|;
name|readTexture
operator|=
name|resolveMultisampledTexture
argument_list|(
name|unresolvedTexture
argument_list|,
name|readRenderTarget11
operator|->
name|getSubresourceIndex
argument_list|()
argument_list|)
expr_stmt|;
name|readSubresource
operator|=
literal|0
expr_stmt|;
name|unresolvedTexture
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|readTexture
operator|=
name|readRenderTarget11
operator|->
name|getTexture
argument_list|()
expr_stmt|;
name|readSubresource
operator|=
name|readRenderTarget11
operator|->
name|getSubresourceIndex
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|readTexture
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the read render target view from the read render target."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|RenderTarget11
modifier|*
name|drawRenderTarget11
init|=
name|RenderTarget11
operator|::
name|makeRenderTarget11
argument_list|(
name|drawRenderTarget
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|drawRenderTarget
condition|)
block|{
name|readTexture
operator|->
name|Release
argument_list|()
expr_stmt|;
name|ERR
argument_list|(
literal|"Failed to retrieve the draw render target from the draw framebuffer."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|ID3D11Texture2D
modifier|*
name|drawTexture
init|=
name|drawRenderTarget11
operator|->
name|getTexture
argument_list|()
decl_stmt|;
name|unsigned
name|int
name|drawSubresource
init|=
name|drawRenderTarget11
operator|->
name|getSubresourceIndex
argument_list|()
decl_stmt|;
name|D3D11_BOX
name|readBox
decl_stmt|;
name|readBox
operator|.
name|left
operator|=
name|readRect
operator|.
name|x
expr_stmt|;
name|readBox
operator|.
name|right
operator|=
name|readRect
operator|.
name|x
operator|+
name|readRect
operator|.
name|width
expr_stmt|;
name|readBox
operator|.
name|top
operator|=
name|readRect
operator|.
name|y
expr_stmt|;
name|readBox
operator|.
name|bottom
operator|=
name|readRect
operator|.
name|y
operator|+
name|readRect
operator|.
name|height
expr_stmt|;
name|readBox
operator|.
name|front
operator|=
literal|0
expr_stmt|;
name|readBox
operator|.
name|back
operator|=
literal|1
expr_stmt|;
comment|// D3D11 needs depth-stencil CopySubresourceRegions to have a NULL pSrcBox
comment|// We also require complete framebuffer copies for depth-stencil blit.
name|D3D11_BOX
modifier|*
name|pSrcBox
init|=
name|wholeBufferCopy
condition|?
name|NULL
else|:
operator|&
name|readBox
decl_stmt|;
name|mDeviceContext
operator|->
name|CopySubresourceRegion
argument_list|(
name|drawTexture
argument_list|,
name|drawSubresource
argument_list|,
name|drawRect
operator|.
name|x
argument_list|,
name|drawRect
operator|.
name|y
argument_list|,
literal|0
argument_list|,
name|readTexture
argument_list|,
name|readSubresource
argument_list|,
name|pSrcBox
argument_list|)
expr_stmt|;
name|readTexture
operator|->
name|Release
argument_list|()
expr_stmt|;
name|drawTexture
operator|->
name|Release
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|resolveMultisampledTexture
name|ID3D11Texture2D
modifier|*
name|Renderer11
operator|::
name|resolveMultisampledTexture
parameter_list|(
name|ID3D11Texture2D
modifier|*
name|source
parameter_list|,
name|unsigned
name|int
name|subresource
parameter_list|)
block|{
name|D3D11_TEXTURE2D_DESC
name|textureDesc
decl_stmt|;
name|source
operator|->
name|GetDesc
argument_list|(
operator|&
name|textureDesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|textureDesc
operator|.
name|SampleDesc
operator|.
name|Count
operator|>
literal|1
condition|)
block|{
name|D3D11_TEXTURE2D_DESC
name|resolveDesc
decl_stmt|;
name|resolveDesc
operator|.
name|Width
operator|=
name|textureDesc
operator|.
name|Width
expr_stmt|;
name|resolveDesc
operator|.
name|Height
operator|=
name|textureDesc
operator|.
name|Height
expr_stmt|;
name|resolveDesc
operator|.
name|MipLevels
operator|=
literal|1
expr_stmt|;
name|resolveDesc
operator|.
name|ArraySize
operator|=
literal|1
expr_stmt|;
name|resolveDesc
operator|.
name|Format
operator|=
name|textureDesc
operator|.
name|Format
expr_stmt|;
name|resolveDesc
operator|.
name|SampleDesc
operator|.
name|Count
operator|=
literal|1
expr_stmt|;
name|resolveDesc
operator|.
name|SampleDesc
operator|.
name|Quality
operator|=
literal|0
expr_stmt|;
name|resolveDesc
operator|.
name|Usage
operator|=
name|textureDesc
operator|.
name|Usage
expr_stmt|;
name|resolveDesc
operator|.
name|BindFlags
operator|=
name|textureDesc
operator|.
name|BindFlags
expr_stmt|;
name|resolveDesc
operator|.
name|CPUAccessFlags
operator|=
literal|0
expr_stmt|;
name|resolveDesc
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|ID3D11Texture2D
modifier|*
name|resolveTexture
init|=
name|NULL
decl_stmt|;
name|HRESULT
name|result
init|=
name|mDevice
operator|->
name|CreateTexture2D
argument_list|(
operator|&
name|resolveDesc
argument_list|,
name|NULL
argument_list|,
operator|&
name|resolveTexture
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to create a multisample resolve texture, HRESULT: 0x%X."
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|mDeviceContext
operator|->
name|ResolveSubresource
argument_list|(
name|resolveTexture
argument_list|,
literal|0
argument_list|,
name|source
argument_list|,
name|subresource
argument_list|,
name|textureDesc
operator|.
name|Format
argument_list|)
expr_stmt|;
return|return
name|resolveTexture
return|;
block|}
else|else
block|{
name|source
operator|->
name|AddRef
argument_list|()
expr_stmt|;
return|return
name|source
return|;
block|}
block|}
block|}
end_namespace
end_unit
