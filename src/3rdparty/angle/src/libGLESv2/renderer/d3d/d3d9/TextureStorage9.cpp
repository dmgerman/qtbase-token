begin_unit
begin_include
include|#
directive|include
file|"precompiled.h"
end_include
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2012-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// TextureStorage9.cpp: Implements the abstract rx::TextureStorage9 class and its concrete derived
end_comment
begin_comment
comment|// classes TextureStorage9_2D and TextureStorage9_Cube, which act as the interface to the
end_comment
begin_comment
comment|// D3D9 texture.
end_comment
begin_include
include|#
directive|include
file|"libGLESv2/main.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/TextureD3D.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/d3d9/Renderer9.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/d3d9/TextureStorage9.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/d3d9/SwapChain9.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/d3d9/RenderTarget9.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/d3d9/renderer9_utils.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/d3d9/formatutils9.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Texture.h"
end_include
begin_namespace
DECL|namespace|rx
namespace|namespace
name|rx
block|{
DECL|function|TextureStorage9
name|TextureStorage9
operator|::
name|TextureStorage9
parameter_list|(
name|Renderer
modifier|*
name|renderer
parameter_list|,
name|DWORD
name|usage
parameter_list|)
member_init_list|:
name|mTopLevel
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mRenderer
argument_list|(
name|Renderer9
operator|::
name|makeRenderer9
argument_list|(
name|renderer
argument_list|)
argument_list|)
member_init_list|,
name|mD3DUsage
argument_list|(
name|usage
argument_list|)
member_init_list|,
name|mD3DPool
argument_list|(
name|mRenderer
operator|->
name|getTexturePool
argument_list|(
name|usage
argument_list|)
argument_list|)
block|{ }
DECL|function|~TextureStorage9
name|TextureStorage9
operator|::
name|~
name|TextureStorage9
parameter_list|()
block|{ }
DECL|function|makeTextureStorage9
name|TextureStorage9
modifier|*
name|TextureStorage9
operator|::
name|makeTextureStorage9
parameter_list|(
name|TextureStorage
modifier|*
name|storage
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|HAS_DYNAMIC_TYPE
argument_list|(
name|TextureStorage9
operator|*
argument_list|,
name|storage
argument_list|)
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|TextureStorage9
operator|*
argument_list|>
argument_list|(
name|storage
argument_list|)
return|;
block|}
DECL|function|GetTextureUsage
name|DWORD
name|TextureStorage9
operator|::
name|GetTextureUsage
parameter_list|(
name|GLenum
name|internalformat
parameter_list|,
name|bool
name|renderTarget
parameter_list|)
block|{
name|DWORD
name|d3dusage
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|gl
operator|::
name|GetDepthBits
argument_list|(
name|internalformat
argument_list|)
operator|>
literal|0
operator|||
name|gl
operator|::
name|GetStencilBits
argument_list|(
name|internalformat
argument_list|)
operator|>
literal|0
condition|)
block|{
name|d3dusage
operator||=
name|D3DUSAGE_DEPTHSTENCIL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|renderTarget
operator|&&
operator|(
name|gl_d3d9
operator|::
name|GetRenderFormat
argument_list|(
name|internalformat
argument_list|)
operator|!=
name|D3DFMT_UNKNOWN
operator|)
condition|)
block|{
name|d3dusage
operator||=
name|D3DUSAGE_RENDERTARGET
expr_stmt|;
block|}
return|return
name|d3dusage
return|;
block|}
DECL|function|isRenderTarget
name|bool
name|TextureStorage9
operator|::
name|isRenderTarget
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|mD3DUsage
operator|&
operator|(
name|D3DUSAGE_RENDERTARGET
operator||
name|D3DUSAGE_DEPTHSTENCIL
operator|)
operator|)
operator|!=
literal|0
return|;
block|}
DECL|function|isManaged
name|bool
name|TextureStorage9
operator|::
name|isManaged
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|mD3DPool
operator|==
name|D3DPOOL_MANAGED
operator|)
return|;
block|}
DECL|function|getPool
name|D3DPOOL
name|TextureStorage9
operator|::
name|getPool
parameter_list|()
specifier|const
block|{
return|return
name|mD3DPool
return|;
block|}
DECL|function|getUsage
name|DWORD
name|TextureStorage9
operator|::
name|getUsage
parameter_list|()
specifier|const
block|{
return|return
name|mD3DUsage
return|;
block|}
DECL|function|getTopLevel
name|int
name|TextureStorage9
operator|::
name|getTopLevel
parameter_list|()
specifier|const
block|{
return|return
name|mTopLevel
return|;
block|}
DECL|function|getLevelCount
name|int
name|TextureStorage9
operator|::
name|getLevelCount
parameter_list|()
specifier|const
block|{
return|return
name|getBaseTexture
argument_list|()
condition|?
operator|(
name|getBaseTexture
argument_list|()
operator|->
name|GetLevelCount
argument_list|()
operator|-
name|getTopLevel
argument_list|()
operator|)
else|:
literal|0
return|;
block|}
DECL|function|TextureStorage9_2D
name|TextureStorage9_2D
operator|::
name|TextureStorage9_2D
parameter_list|(
name|Renderer
modifier|*
name|renderer
parameter_list|,
name|SwapChain9
modifier|*
name|swapchain
parameter_list|)
member_init_list|:
name|TextureStorage9
argument_list|(
name|renderer
argument_list|,
name|D3DUSAGE_RENDERTARGET
argument_list|)
block|{
name|IDirect3DTexture9
modifier|*
name|surfaceTexture
init|=
name|swapchain
operator|->
name|getOffscreenTexture
argument_list|()
decl_stmt|;
name|mTexture
operator|=
name|surfaceTexture
expr_stmt|;
name|mRenderTarget
operator|=
name|NULL
expr_stmt|;
name|initializeRenderTarget
argument_list|()
expr_stmt|;
block|}
DECL|function|TextureStorage9_2D
name|TextureStorage9_2D
operator|::
name|TextureStorage9_2D
parameter_list|(
name|Renderer
modifier|*
name|renderer
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|bool
name|renderTarget
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|int
name|levels
parameter_list|)
member_init_list|:
name|TextureStorage9
argument_list|(
name|renderer
argument_list|,
name|GetTextureUsage
argument_list|(
name|internalformat
argument_list|,
name|renderTarget
argument_list|)
argument_list|)
block|{
name|mTexture
operator|=
name|NULL
expr_stmt|;
name|mRenderTarget
operator|=
name|NULL
expr_stmt|;
comment|// if the width or height is not positive this should be treated as an incomplete texture
comment|// we handle that here by skipping the d3d texture creation
if|if
condition|(
name|width
operator|>
literal|0
operator|&&
name|height
operator|>
literal|0
condition|)
block|{
name|IDirect3DDevice9
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|D3DFORMAT
name|format
init|=
name|gl_d3d9
operator|::
name|GetTextureFormat
argument_list|(
name|internalformat
argument_list|)
decl_stmt|;
name|d3d9
operator|::
name|MakeValidSize
argument_list|(
literal|false
argument_list|,
name|format
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|height
argument_list|,
operator|&
name|mTopLevel
argument_list|)
expr_stmt|;
name|UINT
name|creationLevels
init|=
operator|(
name|levels
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|mTopLevel
operator|+
name|levels
decl_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateTexture
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|creationLevels
argument_list|,
name|getUsage
argument_list|()
argument_list|,
name|format
argument_list|,
name|getPool
argument_list|()
argument_list|,
operator|&
name|mTexture
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|result
operator|==
name|D3DERR_OUTOFVIDEOMEMORY
operator|||
name|result
operator|==
name|E_OUTOFMEMORY
argument_list|)
expr_stmt|;
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
expr_stmt|;
block|}
block|}
name|initializeRenderTarget
argument_list|()
expr_stmt|;
block|}
DECL|function|~TextureStorage9_2D
name|TextureStorage9_2D
operator|::
name|~
name|TextureStorage9_2D
parameter_list|()
block|{
name|SafeRelease
argument_list|(
name|mTexture
argument_list|)
expr_stmt|;
name|SafeDelete
argument_list|(
name|mRenderTarget
argument_list|)
expr_stmt|;
block|}
DECL|function|makeTextureStorage9_2D
name|TextureStorage9_2D
modifier|*
name|TextureStorage9_2D
operator|::
name|makeTextureStorage9_2D
parameter_list|(
name|TextureStorage
modifier|*
name|storage
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|HAS_DYNAMIC_TYPE
argument_list|(
name|TextureStorage9_2D
operator|*
argument_list|,
name|storage
argument_list|)
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|TextureStorage9_2D
operator|*
argument_list|>
argument_list|(
name|storage
argument_list|)
return|;
block|}
comment|// Increments refcount on surface.
comment|// caller must Release() the returned surface
DECL|function|getSurfaceLevel
name|IDirect3DSurface9
modifier|*
name|TextureStorage9_2D
operator|::
name|getSurfaceLevel
parameter_list|(
name|int
name|level
parameter_list|,
name|bool
name|dirty
parameter_list|)
block|{
name|IDirect3DSurface9
modifier|*
name|surface
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|mTexture
condition|)
block|{
name|HRESULT
name|result
init|=
name|mTexture
operator|->
name|GetSurfaceLevel
argument_list|(
name|level
operator|+
name|mTopLevel
argument_list|,
operator|&
name|surface
argument_list|)
decl_stmt|;
name|UNUSED_ASSERTION_VARIABLE
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
comment|// With managed textures the driver needs to be informed of updates to the lower mipmap levels
if|if
condition|(
name|level
operator|+
name|mTopLevel
operator|!=
literal|0
operator|&&
name|isManaged
argument_list|()
operator|&&
name|dirty
condition|)
block|{
name|mTexture
operator|->
name|AddDirtyRect
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|surface
return|;
block|}
DECL|function|getRenderTarget
name|RenderTarget
modifier|*
name|TextureStorage9_2D
operator|::
name|getRenderTarget
parameter_list|(
name|int
name|level
parameter_list|)
block|{
return|return
name|mRenderTarget
return|;
block|}
DECL|function|generateMipmap
name|void
name|TextureStorage9_2D
operator|::
name|generateMipmap
parameter_list|(
name|int
name|level
parameter_list|)
block|{
name|IDirect3DSurface9
modifier|*
name|upper
init|=
name|getSurfaceLevel
argument_list|(
name|level
operator|-
literal|1
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|IDirect3DSurface9
modifier|*
name|lower
init|=
name|getSurfaceLevel
argument_list|(
name|level
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|upper
operator|!=
name|NULL
operator|&&
name|lower
operator|!=
name|NULL
condition|)
block|{
name|mRenderer
operator|->
name|boxFilter
argument_list|(
name|upper
argument_list|,
name|lower
argument_list|)
expr_stmt|;
block|}
name|SafeRelease
argument_list|(
name|upper
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|lower
argument_list|)
expr_stmt|;
block|}
DECL|function|getBaseTexture
name|IDirect3DBaseTexture9
modifier|*
name|TextureStorage9_2D
operator|::
name|getBaseTexture
parameter_list|()
specifier|const
block|{
return|return
name|mTexture
return|;
block|}
DECL|function|initializeRenderTarget
name|void
name|TextureStorage9_2D
operator|::
name|initializeRenderTarget
parameter_list|()
block|{
name|ASSERT
argument_list|(
name|mRenderTarget
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mTexture
operator|!=
name|NULL
operator|&&
name|isRenderTarget
argument_list|()
condition|)
block|{
name|IDirect3DSurface9
modifier|*
name|surface
init|=
name|getSurfaceLevel
argument_list|(
literal|0
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|mRenderTarget
operator|=
operator|new
name|RenderTarget9
argument_list|(
name|mRenderer
argument_list|,
name|surface
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|TextureStorage9_Cube
name|TextureStorage9_Cube
operator|::
name|TextureStorage9_Cube
parameter_list|(
name|Renderer
modifier|*
name|renderer
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|bool
name|renderTarget
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|levels
parameter_list|)
member_init_list|:
name|TextureStorage9
argument_list|(
name|renderer
argument_list|,
name|GetTextureUsage
argument_list|(
name|internalformat
argument_list|,
name|renderTarget
argument_list|)
argument_list|)
block|{
name|mTexture
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
operator|++
name|i
control|)
block|{
name|mRenderTarget
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|// if the size is not positive this should be treated as an incomplete texture
comment|// we handle that here by skipping the d3d texture creation
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|IDirect3DDevice9
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|int
name|height
init|=
name|size
decl_stmt|;
name|D3DFORMAT
name|format
init|=
name|gl_d3d9
operator|::
name|GetTextureFormat
argument_list|(
name|internalformat
argument_list|)
decl_stmt|;
name|d3d9
operator|::
name|MakeValidSize
argument_list|(
literal|false
argument_list|,
name|format
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|height
argument_list|,
operator|&
name|mTopLevel
argument_list|)
expr_stmt|;
name|UINT
name|creationLevels
init|=
operator|(
name|levels
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|mTopLevel
operator|+
name|levels
decl_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateCubeTexture
argument_list|(
name|size
argument_list|,
name|creationLevels
argument_list|,
name|getUsage
argument_list|()
argument_list|,
name|format
argument_list|,
name|getPool
argument_list|()
argument_list|,
operator|&
name|mTexture
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|result
operator|==
name|D3DERR_OUTOFVIDEOMEMORY
operator|||
name|result
operator|==
name|E_OUTOFMEMORY
argument_list|)
expr_stmt|;
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
expr_stmt|;
block|}
block|}
name|initializeRenderTarget
argument_list|()
expr_stmt|;
block|}
DECL|function|~TextureStorage9_Cube
name|TextureStorage9_Cube
operator|::
name|~
name|TextureStorage9_Cube
parameter_list|()
block|{
name|SafeRelease
argument_list|(
name|mTexture
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
operator|++
name|i
control|)
block|{
name|SafeDelete
argument_list|(
name|mRenderTarget
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|makeTextureStorage9_Cube
name|TextureStorage9_Cube
modifier|*
name|TextureStorage9_Cube
operator|::
name|makeTextureStorage9_Cube
parameter_list|(
name|TextureStorage
modifier|*
name|storage
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|HAS_DYNAMIC_TYPE
argument_list|(
name|TextureStorage9_Cube
operator|*
argument_list|,
name|storage
argument_list|)
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|TextureStorage9_Cube
operator|*
argument_list|>
argument_list|(
name|storage
argument_list|)
return|;
block|}
comment|// Increments refcount on surface.
comment|// caller must Release() the returned surface
DECL|function|getCubeMapSurface
name|IDirect3DSurface9
modifier|*
name|TextureStorage9_Cube
operator|::
name|getCubeMapSurface
parameter_list|(
name|GLenum
name|faceTarget
parameter_list|,
name|int
name|level
parameter_list|,
name|bool
name|dirty
parameter_list|)
block|{
name|IDirect3DSurface9
modifier|*
name|surface
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|mTexture
condition|)
block|{
name|D3DCUBEMAP_FACES
name|face
init|=
name|gl_d3d9
operator|::
name|ConvertCubeFace
argument_list|(
name|faceTarget
argument_list|)
decl_stmt|;
name|HRESULT
name|result
init|=
name|mTexture
operator|->
name|GetCubeMapSurface
argument_list|(
name|face
argument_list|,
name|level
operator|+
name|mTopLevel
argument_list|,
operator|&
name|surface
argument_list|)
decl_stmt|;
name|UNUSED_ASSERTION_VARIABLE
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
comment|// With managed textures the driver needs to be informed of updates to the lower mipmap levels
if|if
condition|(
name|level
operator|!=
literal|0
operator|&&
name|isManaged
argument_list|()
operator|&&
name|dirty
condition|)
block|{
name|mTexture
operator|->
name|AddDirtyRect
argument_list|(
name|face
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|surface
return|;
block|}
DECL|function|getRenderTargetFace
name|RenderTarget
modifier|*
name|TextureStorage9_Cube
operator|::
name|getRenderTargetFace
parameter_list|(
name|GLenum
name|faceTarget
parameter_list|,
name|int
name|level
parameter_list|)
block|{
return|return
name|mRenderTarget
index|[
name|TextureD3D_Cube
operator|::
name|targetToIndex
argument_list|(
name|faceTarget
argument_list|)
index|]
return|;
block|}
DECL|function|generateMipmap
name|void
name|TextureStorage9_Cube
operator|::
name|generateMipmap
parameter_list|(
name|int
name|faceIndex
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|IDirect3DSurface9
modifier|*
name|upper
init|=
name|getCubeMapSurface
argument_list|(
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
operator|+
name|faceIndex
argument_list|,
name|level
operator|-
literal|1
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|IDirect3DSurface9
modifier|*
name|lower
init|=
name|getCubeMapSurface
argument_list|(
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
operator|+
name|faceIndex
argument_list|,
name|level
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|upper
operator|!=
name|NULL
operator|&&
name|lower
operator|!=
name|NULL
condition|)
block|{
name|mRenderer
operator|->
name|boxFilter
argument_list|(
name|upper
argument_list|,
name|lower
argument_list|)
expr_stmt|;
block|}
name|SafeRelease
argument_list|(
name|upper
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|lower
argument_list|)
expr_stmt|;
block|}
DECL|function|getBaseTexture
name|IDirect3DBaseTexture9
modifier|*
name|TextureStorage9_Cube
operator|::
name|getBaseTexture
parameter_list|()
specifier|const
block|{
return|return
name|mTexture
return|;
block|}
DECL|function|initializeRenderTarget
name|void
name|TextureStorage9_Cube
operator|::
name|initializeRenderTarget
parameter_list|()
block|{
if|if
condition|(
name|mTexture
operator|!=
name|NULL
operator|&&
name|isRenderTarget
argument_list|()
condition|)
block|{
name|IDirect3DSurface9
modifier|*
name|surface
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
operator|++
name|i
control|)
block|{
name|ASSERT
argument_list|(
name|mRenderTarget
index|[
name|i
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|surface
operator|=
name|getCubeMapSurface
argument_list|(
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
operator|+
name|i
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|mRenderTarget
index|[
name|i
index|]
operator|=
operator|new
name|RenderTarget9
argument_list|(
name|mRenderer
argument_list|,
name|surface
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_namespace
end_unit
