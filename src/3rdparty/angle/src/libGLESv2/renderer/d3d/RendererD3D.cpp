begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// RendererD3D.cpp: Implementation of the base D3D Renderer.
end_comment
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/RendererD3D.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/IndexDataManager.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Framebuffer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/FramebufferAttachment.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/ResourceManager.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/State.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/VertexArray.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/formatutils.h"
end_include
begin_include
include|#
directive|include
file|"common/utilities.h"
end_include
begin_namespace
DECL|namespace|rx
namespace|namespace
name|rx
block|{
DECL|function|RendererD3D
name|RendererD3D
operator|::
name|RendererD3D
parameter_list|(
name|egl
operator|::
name|Display
modifier|*
name|display
parameter_list|)
member_init_list|:
name|mDisplay
argument_list|(
name|display
argument_list|)
block|{ }
DECL|function|~RendererD3D
name|RendererD3D
operator|::
name|~
name|RendererD3D
parameter_list|()
block|{
name|cleanup
argument_list|()
expr_stmt|;
block|}
DECL|function|cleanup
name|void
name|RendererD3D
operator|::
name|cleanup
parameter_list|()
block|{
for|for
control|(
name|gl
operator|::
name|TextureMap
operator|::
name|iterator
name|i
init|=
name|mIncompleteTextures
operator|.
name|begin
argument_list|()
init|;
name|i
operator|!=
name|mIncompleteTextures
operator|.
name|end
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|i
operator|->
name|second
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
name|mIncompleteTextures
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|// static
DECL|function|makeRendererD3D
name|RendererD3D
modifier|*
name|RendererD3D
operator|::
name|makeRendererD3D
parameter_list|(
name|Renderer
modifier|*
name|renderer
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|HAS_DYNAMIC_TYPE
argument_list|(
name|RendererD3D
operator|*
argument_list|,
name|renderer
argument_list|)
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|RendererD3D
operator|*
argument_list|>
argument_list|(
name|renderer
argument_list|)
return|;
block|}
DECL|function|drawElements
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|drawElements
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|GLsizei
name|instances
parameter_list|,
specifier|const
name|RangeUI
modifier|&
name|indexRange
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|data
operator|.
name|state
operator|->
name|getCurrentProgramId
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|gl
operator|::
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|data
operator|.
name|state
operator|->
name|getCurrentProgramBinary
argument_list|()
decl_stmt|;
name|programBinary
operator|->
name|updateSamplerMapping
argument_list|()
expr_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|generateSwizzles
argument_list|(
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
operator|!
name|applyPrimitiveType
argument_list|(
name|mode
argument_list|,
name|count
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
name|error
operator|=
name|applyRenderTarget
argument_list|(
name|data
argument_list|,
name|mode
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|applyState
argument_list|(
name|data
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|gl
operator|::
name|VertexArray
modifier|*
name|vao
init|=
name|data
operator|.
name|state
operator|->
name|getVertexArray
argument_list|()
decl_stmt|;
name|TranslatedIndexData
name|indexInfo
decl_stmt|;
name|indexInfo
operator|.
name|indexRange
operator|=
name|indexRange
expr_stmt|;
name|error
operator|=
name|applyIndexBuffer
argument_list|(
name|indices
argument_list|,
name|vao
operator|->
name|getElementArrayBuffer
argument_list|()
argument_list|,
name|count
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
operator|&
name|indexInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|GLsizei
name|vertexCount
init|=
name|indexInfo
operator|.
name|indexRange
operator|.
name|length
argument_list|()
operator|+
literal|1
decl_stmt|;
name|error
operator|=
name|applyVertexBuffer
argument_list|(
operator|*
name|data
operator|.
name|state
argument_list|,
name|indexInfo
operator|.
name|indexRange
operator|.
name|start
argument_list|,
name|vertexCount
argument_list|,
name|instances
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|bool
name|transformFeedbackActive
init|=
name|applyTransformFeedbackBuffers
argument_list|(
name|data
argument_list|)
decl_stmt|;
comment|// Transform feedback is not allowed for DrawElements, this error should have been caught at the API validation
comment|// layer.
name|ASSERT
argument_list|(
operator|!
name|transformFeedbackActive
argument_list|)
expr_stmt|;
name|error
operator|=
name|applyShaders
argument_list|(
name|data
argument_list|,
name|transformFeedbackActive
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|applyTextures
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|applyUniformBuffers
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
operator|!
name|skipDraw
argument_list|(
name|data
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|error
operator|=
name|drawElements
argument_list|(
name|mode
argument_list|,
name|count
argument_list|,
name|type
argument_list|,
name|indices
argument_list|,
name|vao
operator|->
name|getElementArrayBuffer
argument_list|()
argument_list|,
name|indexInfo
argument_list|,
name|instances
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|drawArrays
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|drawArrays
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLint
name|first
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLsizei
name|instances
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|data
operator|.
name|state
operator|->
name|getCurrentProgramId
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|gl
operator|::
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|data
operator|.
name|state
operator|->
name|getCurrentProgramBinary
argument_list|()
decl_stmt|;
name|programBinary
operator|->
name|updateSamplerMapping
argument_list|()
expr_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|generateSwizzles
argument_list|(
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
operator|!
name|applyPrimitiveType
argument_list|(
name|mode
argument_list|,
name|count
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
name|error
operator|=
name|applyRenderTarget
argument_list|(
name|data
argument_list|,
name|mode
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|applyState
argument_list|(
name|data
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|applyVertexBuffer
argument_list|(
operator|*
name|data
operator|.
name|state
argument_list|,
name|first
argument_list|,
name|count
argument_list|,
name|instances
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|bool
name|transformFeedbackActive
init|=
name|applyTransformFeedbackBuffers
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|error
operator|=
name|applyShaders
argument_list|(
name|data
argument_list|,
name|transformFeedbackActive
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|applyTextures
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|applyUniformBuffers
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
operator|!
name|skipDraw
argument_list|(
name|data
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|error
operator|=
name|drawArrays
argument_list|(
name|mode
argument_list|,
name|count
argument_list|,
name|instances
argument_list|,
name|transformFeedbackActive
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
name|transformFeedbackActive
condition|)
block|{
name|markTransformFeedbackUsage
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|generateSwizzles
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|generateSwizzles
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|gl
operator|::
name|SamplerType
name|type
parameter_list|)
block|{
name|gl
operator|::
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|data
operator|.
name|state
operator|->
name|getCurrentProgramBinary
argument_list|()
decl_stmt|;
name|size_t
name|samplerRange
init|=
name|programBinary
operator|->
name|getUsedSamplerRange
argument_list|(
name|type
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|samplerRange
condition|;
name|i
operator|++
control|)
block|{
name|GLenum
name|textureType
init|=
name|programBinary
operator|->
name|getSamplerTextureType
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|GLint
name|textureUnit
init|=
name|programBinary
operator|->
name|getSamplerMapping
argument_list|(
name|type
argument_list|,
name|i
argument_list|,
operator|*
name|data
operator|.
name|caps
argument_list|)
decl_stmt|;
if|if
condition|(
name|textureUnit
operator|!=
operator|-
literal|1
condition|)
block|{
name|gl
operator|::
name|Texture
modifier|*
name|texture
init|=
name|data
operator|.
name|state
operator|->
name|getSamplerTexture
argument_list|(
name|textureUnit
argument_list|,
name|textureType
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|texture
argument_list|)
expr_stmt|;
if|if
condition|(
name|texture
operator|->
name|getSamplerState
argument_list|()
operator|.
name|swizzleRequired
argument_list|()
condition|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|generateSwizzle
argument_list|(
name|texture
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|generateSwizzles
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|generateSwizzles
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|generateSwizzles
argument_list|(
name|data
argument_list|,
name|gl
operator|::
name|SAMPLER_VERTEX
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|generateSwizzles
argument_list|(
name|data
argument_list|,
name|gl
operator|::
name|SAMPLER_PIXEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
comment|// Applies the render target surface, depth stencil surface, viewport rectangle and
comment|// scissor rectangle to the renderer
DECL|function|applyRenderTarget
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|applyRenderTarget
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLenum
name|drawMode
parameter_list|,
name|bool
name|ignoreViewport
parameter_list|)
block|{
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebufferObject
init|=
name|data
operator|.
name|state
operator|->
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|framebufferObject
operator|&&
name|framebufferObject
operator|->
name|completeness
argument_list|(
name|data
argument_list|)
operator|==
name|GL_FRAMEBUFFER_COMPLETE
argument_list|)
expr_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|applyRenderTarget
argument_list|(
name|framebufferObject
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|float
name|nearZ
decl_stmt|,
name|farZ
decl_stmt|;
name|data
operator|.
name|state
operator|->
name|getDepthRange
argument_list|(
operator|&
name|nearZ
argument_list|,
operator|&
name|farZ
argument_list|)
expr_stmt|;
name|setViewport
argument_list|(
name|data
operator|.
name|state
operator|->
name|getViewport
argument_list|()
argument_list|,
name|nearZ
argument_list|,
name|farZ
argument_list|,
name|drawMode
argument_list|,
name|data
operator|.
name|state
operator|->
name|getRasterizerState
argument_list|()
operator|.
name|frontFace
argument_list|,
name|ignoreViewport
argument_list|)
expr_stmt|;
name|setScissorRectangle
argument_list|(
name|data
operator|.
name|state
operator|->
name|getScissor
argument_list|()
argument_list|,
name|data
operator|.
name|state
operator|->
name|isScissorTestEnabled
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
comment|// Applies the fixed-function state (culling, depth test, alpha blending, stenciling, etc) to the Direct3D device
DECL|function|applyState
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|applyState
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLenum
name|drawMode
parameter_list|)
block|{
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebufferObject
init|=
name|data
operator|.
name|state
operator|->
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
name|int
name|samples
init|=
name|framebufferObject
operator|->
name|getSamples
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|gl
operator|::
name|RasterizerState
name|rasterizer
init|=
name|data
operator|.
name|state
operator|->
name|getRasterizerState
argument_list|()
decl_stmt|;
name|rasterizer
operator|.
name|pointDrawMode
operator|=
operator|(
name|drawMode
operator|==
name|GL_POINTS
operator|)
expr_stmt|;
name|rasterizer
operator|.
name|multiSample
operator|=
operator|(
name|samples
operator|!=
literal|0
operator|)
expr_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|setRasterizerState
argument_list|(
name|rasterizer
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|unsigned
name|int
name|mask
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|data
operator|.
name|state
operator|->
name|isSampleCoverageEnabled
argument_list|()
condition|)
block|{
name|GLclampf
name|coverageValue
decl_stmt|;
name|bool
name|coverageInvert
init|=
literal|false
decl_stmt|;
name|data
operator|.
name|state
operator|->
name|getSampleCoverageParams
argument_list|(
operator|&
name|coverageValue
argument_list|,
operator|&
name|coverageInvert
argument_list|)
expr_stmt|;
if|if
condition|(
name|coverageValue
operator|!=
literal|0
condition|)
block|{
name|float
name|threshold
init|=
literal|0.5f
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|samples
condition|;
operator|++
name|i
control|)
block|{
name|mask
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|coverageValue
operator|>=
name|threshold
condition|)
block|{
name|threshold
operator|+=
literal|1.0f
expr_stmt|;
name|mask
operator||=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|coverageInvert
condition|)
block|{
name|mask
operator|=
operator|~
name|mask
expr_stmt|;
block|}
block|}
else|else
block|{
name|mask
operator|=
literal|0xFFFFFFFF
expr_stmt|;
block|}
name|error
operator|=
name|setBlendState
argument_list|(
name|framebufferObject
argument_list|,
name|data
operator|.
name|state
operator|->
name|getBlendState
argument_list|()
argument_list|,
name|data
operator|.
name|state
operator|->
name|getBlendColor
argument_list|()
argument_list|,
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|setDepthStencilState
argument_list|(
name|data
operator|.
name|state
operator|->
name|getDepthStencilState
argument_list|()
argument_list|,
name|data
operator|.
name|state
operator|->
name|getStencilRef
argument_list|()
argument_list|,
name|data
operator|.
name|state
operator|->
name|getStencilBackRef
argument_list|()
argument_list|,
name|rasterizer
operator|.
name|frontFace
operator|==
name|GL_CCW
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|applyTransformFeedbackBuffers
name|bool
name|RendererD3D
operator|::
name|applyTransformFeedbackBuffers
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|)
block|{
name|gl
operator|::
name|TransformFeedback
modifier|*
name|curTransformFeedback
init|=
name|data
operator|.
name|state
operator|->
name|getCurrentTransformFeedback
argument_list|()
decl_stmt|;
if|if
condition|(
name|curTransformFeedback
operator|&&
name|curTransformFeedback
operator|->
name|isStarted
argument_list|()
operator|&&
operator|!
name|curTransformFeedback
operator|->
name|isPaused
argument_list|()
condition|)
block|{
name|applyTransformFeedbackBuffers
argument_list|(
operator|*
name|data
operator|.
name|state
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
comment|// Applies the shaders and shader constants to the Direct3D device
DECL|function|applyShaders
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|applyShaders
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|bool
name|transformFeedbackActive
parameter_list|)
block|{
name|gl
operator|::
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|data
operator|.
name|state
operator|->
name|getCurrentProgramBinary
argument_list|()
decl_stmt|;
name|gl
operator|::
name|VertexFormat
name|inputLayout
index|[
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
index|]
decl_stmt|;
name|gl
operator|::
name|VertexFormat
operator|::
name|GetInputLayout
argument_list|(
name|inputLayout
argument_list|,
name|programBinary
argument_list|,
operator|*
name|data
operator|.
name|state
argument_list|)
expr_stmt|;
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|fbo
init|=
name|data
operator|.
name|state
operator|->
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|applyShaders
argument_list|(
name|programBinary
argument_list|,
name|inputLayout
argument_list|,
name|fbo
argument_list|,
name|data
operator|.
name|state
operator|->
name|getRasterizerState
argument_list|()
operator|.
name|rasterizerDiscard
argument_list|,
name|transformFeedbackActive
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
return|return
name|programBinary
operator|->
name|applyUniforms
argument_list|()
return|;
block|}
comment|// For each Direct3D sampler of either the pixel or vertex stage,
comment|// looks up the corresponding OpenGL texture image unit and texture type,
comment|// and sets the texture and its addressing/filtering state (or NULL when inactive).
DECL|function|applyTextures
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|applyTextures
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|gl
operator|::
name|SamplerType
name|shaderType
parameter_list|,
specifier|const
name|FramebufferTextureSerialArray
modifier|&
name|framebufferSerials
parameter_list|,
name|size_t
name|framebufferSerialCount
parameter_list|)
block|{
name|gl
operator|::
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|data
operator|.
name|state
operator|->
name|getCurrentProgramBinary
argument_list|()
decl_stmt|;
name|size_t
name|samplerRange
init|=
name|programBinary
operator|->
name|getUsedSamplerRange
argument_list|(
name|shaderType
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|samplerIndex
init|=
literal|0
init|;
name|samplerIndex
operator|<
name|samplerRange
condition|;
name|samplerIndex
operator|++
control|)
block|{
name|GLenum
name|textureType
init|=
name|programBinary
operator|->
name|getSamplerTextureType
argument_list|(
name|shaderType
argument_list|,
name|samplerIndex
argument_list|)
decl_stmt|;
name|GLint
name|textureUnit
init|=
name|programBinary
operator|->
name|getSamplerMapping
argument_list|(
name|shaderType
argument_list|,
name|samplerIndex
argument_list|,
operator|*
name|data
operator|.
name|caps
argument_list|)
decl_stmt|;
if|if
condition|(
name|textureUnit
operator|!=
operator|-
literal|1
condition|)
block|{
name|gl
operator|::
name|Texture
modifier|*
name|texture
init|=
name|data
operator|.
name|state
operator|->
name|getSamplerTexture
argument_list|(
name|textureUnit
argument_list|,
name|textureType
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|texture
argument_list|)
expr_stmt|;
name|gl
operator|::
name|SamplerState
name|sampler
init|=
name|texture
operator|->
name|getSamplerState
argument_list|()
decl_stmt|;
name|gl
operator|::
name|Sampler
modifier|*
name|samplerObject
init|=
name|data
operator|.
name|state
operator|->
name|getSampler
argument_list|(
name|textureUnit
argument_list|)
decl_stmt|;
if|if
condition|(
name|samplerObject
condition|)
block|{
name|samplerObject
operator|->
name|getState
argument_list|(
operator|&
name|sampler
argument_list|)
expr_stmt|;
block|}
comment|// TODO: std::binary_search may become unavailable using older versions of GCC
if|if
condition|(
name|texture
operator|->
name|isSamplerComplete
argument_list|(
name|sampler
argument_list|,
operator|*
name|data
operator|.
name|textureCaps
argument_list|,
operator|*
name|data
operator|.
name|extensions
argument_list|,
name|data
operator|.
name|clientVersion
argument_list|)
operator|&&
operator|!
name|std
operator|::
name|binary_search
argument_list|(
name|framebufferSerials
operator|.
name|begin
argument_list|()
argument_list|,
name|framebufferSerials
operator|.
name|begin
argument_list|()
operator|+
name|framebufferSerialCount
argument_list|,
name|texture
operator|->
name|getTextureSerial
argument_list|()
argument_list|)
condition|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|setSamplerState
argument_list|(
name|shaderType
argument_list|,
name|samplerIndex
argument_list|,
name|texture
argument_list|,
name|sampler
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|setTexture
argument_list|(
name|shaderType
argument_list|,
name|samplerIndex
argument_list|,
name|texture
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
else|else
block|{
comment|// Texture is not sampler complete or it is in use by the framebuffer.  Bind the incomplete texture.
name|gl
operator|::
name|Texture
modifier|*
name|incompleteTexture
init|=
name|getIncompleteTexture
argument_list|(
name|textureType
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|setTexture
argument_list|(
name|shaderType
argument_list|,
name|samplerIndex
argument_list|,
name|incompleteTexture
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
block|}
else|else
block|{
comment|// No texture bound to this slot even though it is used by the shader, bind a NULL texture
name|gl
operator|::
name|Error
name|error
init|=
name|setTexture
argument_list|(
name|shaderType
argument_list|,
name|samplerIndex
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
block|}
comment|// Set all the remaining textures to NULL
name|size_t
name|samplerCount
init|=
operator|(
name|shaderType
operator|==
name|gl
operator|::
name|SAMPLER_PIXEL
operator|)
condition|?
name|data
operator|.
name|caps
operator|->
name|maxTextureImageUnits
else|:
name|data
operator|.
name|caps
operator|->
name|maxVertexTextureImageUnits
decl_stmt|;
for|for
control|(
name|size_t
name|samplerIndex
init|=
name|samplerRange
init|;
name|samplerIndex
operator|<
name|samplerCount
condition|;
name|samplerIndex
operator|++
control|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|setTexture
argument_list|(
name|shaderType
argument_list|,
name|samplerIndex
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|applyTextures
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|applyTextures
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|)
block|{
name|FramebufferTextureSerialArray
name|framebufferSerials
decl_stmt|;
name|size_t
name|framebufferSerialCount
init|=
name|getBoundFramebufferTextureSerials
argument_list|(
name|data
argument_list|,
operator|&
name|framebufferSerials
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|applyTextures
argument_list|(
name|data
argument_list|,
name|gl
operator|::
name|SAMPLER_VERTEX
argument_list|,
name|framebufferSerials
argument_list|,
name|framebufferSerialCount
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|applyTextures
argument_list|(
name|data
argument_list|,
name|gl
operator|::
name|SAMPLER_PIXEL
argument_list|,
name|framebufferSerials
argument_list|,
name|framebufferSerialCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|applyUniformBuffers
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|applyUniformBuffers
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|)
block|{
name|gl
operator|::
name|Program
modifier|*
name|programObject
init|=
name|data
operator|.
name|resourceManager
operator|->
name|getProgram
argument_list|(
name|data
operator|.
name|state
operator|->
name|getCurrentProgramId
argument_list|()
argument_list|)
decl_stmt|;
name|gl
operator|::
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|programObject
operator|->
name|getProgramBinary
argument_list|()
decl_stmt|;
name|std
operator|::
name|vector
argument_list|<
name|gl
operator|::
name|Buffer
operator|*
argument_list|>
name|boundBuffers
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|uniformBlockIndex
init|=
literal|0
init|;
name|uniformBlockIndex
operator|<
name|programBinary
operator|->
name|getActiveUniformBlockCount
argument_list|()
condition|;
name|uniformBlockIndex
operator|++
control|)
block|{
name|GLuint
name|blockBinding
init|=
name|programObject
operator|->
name|getUniformBlockBinding
argument_list|(
name|uniformBlockIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|.
name|state
operator|->
name|getIndexedUniformBuffer
argument_list|(
name|blockBinding
argument_list|)
operator|->
name|id
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// undefined behaviour
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"It is undefined behaviour to have a used but unbound uniform buffer."
argument_list|)
return|;
block|}
else|else
block|{
name|gl
operator|::
name|Buffer
modifier|*
name|uniformBuffer
init|=
name|data
operator|.
name|state
operator|->
name|getIndexedUniformBuffer
argument_list|(
name|blockBinding
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|uniformBuffer
argument_list|)
expr_stmt|;
name|boundBuffers
operator|.
name|push_back
argument_list|(
name|uniformBuffer
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|programBinary
operator|->
name|applyUniformBuffers
argument_list|(
name|boundBuffers
argument_list|,
operator|*
name|data
operator|.
name|caps
argument_list|)
return|;
block|}
DECL|function|skipDraw
name|bool
name|RendererD3D
operator|::
name|skipDraw
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLenum
name|drawMode
parameter_list|)
block|{
if|if
condition|(
name|drawMode
operator|==
name|GL_POINTS
condition|)
block|{
comment|// ProgramBinary assumes non-point rendering if gl_PointSize isn't written,
comment|// which affects varying interpolation. Since the value of gl_PointSize is
comment|// undefined when not written, just skip drawing to avoid unexpected results.
if|if
condition|(
operator|!
name|data
operator|.
name|state
operator|->
name|getCurrentProgramBinary
argument_list|()
operator|->
name|usesPointSize
argument_list|()
condition|)
block|{
comment|// This is stictly speaking not an error, but developers should be
comment|// notified of risking undefined behavior.
name|ERR
argument_list|(
literal|"Point rendering without writing to gl_PointSize."
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|gl
operator|::
name|IsTriangleMode
argument_list|(
name|drawMode
argument_list|)
condition|)
block|{
if|if
condition|(
name|data
operator|.
name|state
operator|->
name|getRasterizerState
argument_list|()
operator|.
name|cullFace
operator|&&
name|data
operator|.
name|state
operator|->
name|getRasterizerState
argument_list|()
operator|.
name|cullMode
operator|==
name|GL_FRONT_AND_BACK
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|function|markTransformFeedbackUsage
name|void
name|RendererD3D
operator|::
name|markTransformFeedbackUsage
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|)
block|{
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|data
operator|.
name|caps
operator|->
name|maxTransformFeedbackSeparateAttributes
condition|;
name|i
operator|++
control|)
block|{
name|gl
operator|::
name|Buffer
modifier|*
name|buffer
init|=
name|data
operator|.
name|state
operator|->
name|getIndexedTransformFeedbackBuffer
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|buffer
condition|)
block|{
name|buffer
operator|->
name|markTransformFeedbackUsage
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|function|getBoundFramebufferTextureSerials
name|size_t
name|RendererD3D
operator|::
name|getBoundFramebufferTextureSerials
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|FramebufferTextureSerialArray
modifier|*
name|outSerialArray
parameter_list|)
block|{
name|size_t
name|serialCount
init|=
literal|0
decl_stmt|;
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|drawFramebuffer
init|=
name|data
operator|.
name|state
operator|->
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
condition|;
name|i
operator|++
control|)
block|{
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|attachment
init|=
name|drawFramebuffer
operator|->
name|getColorbuffer
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|attachment
operator|&&
name|attachment
operator|->
name|isTexture
argument_list|()
condition|)
block|{
name|gl
operator|::
name|Texture
modifier|*
name|texture
init|=
name|attachment
operator|->
name|getTexture
argument_list|()
decl_stmt|;
operator|(
operator|*
name|outSerialArray
operator|)
index|[
name|serialCount
operator|++
index|]
operator|=
name|texture
operator|->
name|getTextureSerial
argument_list|()
expr_stmt|;
block|}
block|}
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|depthStencilAttachment
init|=
name|drawFramebuffer
operator|->
name|getDepthOrStencilbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|depthStencilAttachment
operator|&&
name|depthStencilAttachment
operator|->
name|isTexture
argument_list|()
condition|)
block|{
name|gl
operator|::
name|Texture
modifier|*
name|depthStencilTexture
init|=
name|depthStencilAttachment
operator|->
name|getTexture
argument_list|()
decl_stmt|;
operator|(
operator|*
name|outSerialArray
operator|)
index|[
name|serialCount
operator|++
index|]
operator|=
name|depthStencilTexture
operator|->
name|getTextureSerial
argument_list|()
expr_stmt|;
block|}
name|std
operator|::
name|sort
argument_list|(
name|outSerialArray
operator|->
name|begin
argument_list|()
argument_list|,
name|outSerialArray
operator|->
name|begin
argument_list|()
operator|+
name|serialCount
argument_list|)
expr_stmt|;
return|return
name|serialCount
return|;
block|}
DECL|function|getIncompleteTexture
name|gl
operator|::
name|Texture
modifier|*
name|RendererD3D
operator|::
name|getIncompleteTexture
parameter_list|(
name|GLenum
name|type
parameter_list|)
block|{
if|if
condition|(
name|mIncompleteTextures
operator|.
name|find
argument_list|(
name|type
argument_list|)
operator|==
name|mIncompleteTextures
operator|.
name|end
argument_list|()
condition|)
block|{
specifier|const
name|GLubyte
name|color
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|255
block|}
decl_stmt|;
specifier|const
name|gl
operator|::
name|PixelUnpackState
name|incompleteUnpackState
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Texture
modifier|*
name|t
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
comment|// default falls through to TEXTURE_2D
case|case
name|GL_TEXTURE_2D
case|:
block|{
name|gl
operator|::
name|Texture2D
modifier|*
name|incomplete2d
init|=
operator|new
name|gl
operator|::
name|Texture2D
argument_list|(
name|createTexture
argument_list|(
name|GL_TEXTURE_2D
argument_list|)
argument_list|,
name|gl
operator|::
name|Texture
operator|::
name|INCOMPLETE_TEXTURE_ID
argument_list|)
decl_stmt|;
name|incomplete2d
operator|->
name|setImage
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
name|incompleteUnpackState
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|t
operator|=
name|incomplete2d
expr_stmt|;
block|}
break|break;
case|case
name|GL_TEXTURE_CUBE_MAP
case|:
block|{
name|gl
operator|::
name|TextureCubeMap
modifier|*
name|incompleteCube
init|=
operator|new
name|gl
operator|::
name|TextureCubeMap
argument_list|(
name|createTexture
argument_list|(
name|GL_TEXTURE_CUBE_MAP
argument_list|)
argument_list|,
name|gl
operator|::
name|Texture
operator|::
name|INCOMPLETE_TEXTURE_ID
argument_list|)
decl_stmt|;
name|incompleteCube
operator|->
name|setImage
argument_list|(
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
name|incompleteUnpackState
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|incompleteCube
operator|->
name|setImage
argument_list|(
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_X
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
name|incompleteUnpackState
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|incompleteCube
operator|->
name|setImage
argument_list|(
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Y
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
name|incompleteUnpackState
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|incompleteCube
operator|->
name|setImage
argument_list|(
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
name|incompleteUnpackState
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|incompleteCube
operator|->
name|setImage
argument_list|(
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Z
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
name|incompleteUnpackState
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|incompleteCube
operator|->
name|setImage
argument_list|(
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
name|incompleteUnpackState
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|t
operator|=
name|incompleteCube
expr_stmt|;
block|}
break|break;
case|case
name|GL_TEXTURE_3D
case|:
block|{
name|gl
operator|::
name|Texture3D
modifier|*
name|incomplete3d
init|=
operator|new
name|gl
operator|::
name|Texture3D
argument_list|(
name|createTexture
argument_list|(
name|GL_TEXTURE_3D
argument_list|)
argument_list|,
name|gl
operator|::
name|Texture
operator|::
name|INCOMPLETE_TEXTURE_ID
argument_list|)
decl_stmt|;
name|incomplete3d
operator|->
name|setImage
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
name|incompleteUnpackState
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|t
operator|=
name|incomplete3d
expr_stmt|;
block|}
break|break;
case|case
name|GL_TEXTURE_2D_ARRAY
case|:
block|{
name|gl
operator|::
name|Texture2DArray
modifier|*
name|incomplete2darray
init|=
operator|new
name|gl
operator|::
name|Texture2DArray
argument_list|(
name|createTexture
argument_list|(
name|GL_TEXTURE_2D_ARRAY
argument_list|)
argument_list|,
name|gl
operator|::
name|Texture
operator|::
name|INCOMPLETE_TEXTURE_ID
argument_list|)
decl_stmt|;
name|incomplete2darray
operator|->
name|setImage
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
name|incompleteUnpackState
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|t
operator|=
name|incomplete2darray
expr_stmt|;
block|}
break|break;
block|}
name|mIncompleteTextures
index|[
name|type
index|]
operator|.
name|set
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|mIncompleteTextures
index|[
name|type
index|]
operator|.
name|get
argument_list|()
return|;
block|}
DECL|function|clear
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|clear
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLbitfield
name|mask
parameter_list|)
block|{
name|gl
operator|::
name|ClearParameters
name|clearParams
init|=
name|data
operator|.
name|state
operator|->
name|getClearParameters
argument_list|(
name|mask
argument_list|)
decl_stmt|;
comment|// Clips the clear to the scissor rectangle but not the viewport
name|gl
operator|::
name|Error
name|error
init|=
name|applyRenderTarget
argument_list|(
name|data
argument_list|,
name|GL_TRIANGLES
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
return|return
name|clear
argument_list|(
name|clearParams
argument_list|,
name|data
operator|.
name|state
operator|->
name|getDrawFramebuffer
argument_list|()
argument_list|)
return|;
block|}
DECL|function|clearBufferfv
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|clearBufferfv
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLenum
name|buffer
parameter_list|,
name|GLint
name|drawbuffer
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|values
parameter_list|)
block|{
comment|// glClearBufferfv can be called to clear the color buffer or depth buffer
name|gl
operator|::
name|ClearParameters
name|clearParams
init|=
name|data
operator|.
name|state
operator|->
name|getClearParameters
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|buffer
operator|==
name|GL_COLOR
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ArraySize
argument_list|(
name|clearParams
operator|.
name|clearColor
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|clearParams
operator|.
name|clearColor
index|[
name|i
index|]
operator|=
operator|(
name|drawbuffer
operator|==
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|i
argument_list|)
operator|)
expr_stmt|;
block|}
name|clearParams
operator|.
name|colorFClearValue
operator|=
name|gl
operator|::
name|ColorF
argument_list|(
name|values
index|[
literal|0
index|]
argument_list|,
name|values
index|[
literal|1
index|]
argument_list|,
name|values
index|[
literal|2
index|]
argument_list|,
name|values
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|clearParams
operator|.
name|colorClearType
operator|=
name|GL_FLOAT
expr_stmt|;
block|}
if|if
condition|(
name|buffer
operator|==
name|GL_DEPTH
condition|)
block|{
name|clearParams
operator|.
name|clearDepth
operator|=
literal|true
expr_stmt|;
name|clearParams
operator|.
name|depthClearValue
operator|=
name|values
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|// Clips the clear to the scissor rectangle but not the viewport
name|gl
operator|::
name|Error
name|error
init|=
name|applyRenderTarget
argument_list|(
name|data
argument_list|,
name|GL_TRIANGLES
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
return|return
name|clear
argument_list|(
name|clearParams
argument_list|,
name|data
operator|.
name|state
operator|->
name|getDrawFramebuffer
argument_list|()
argument_list|)
return|;
block|}
DECL|function|clearBufferuiv
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|clearBufferuiv
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLenum
name|buffer
parameter_list|,
name|GLint
name|drawbuffer
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|values
parameter_list|)
block|{
comment|// glClearBufferuiv can only be called to clear a color buffer
name|gl
operator|::
name|ClearParameters
name|clearParams
init|=
name|data
operator|.
name|state
operator|->
name|getClearParameters
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ArraySize
argument_list|(
name|clearParams
operator|.
name|clearColor
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|clearParams
operator|.
name|clearColor
index|[
name|i
index|]
operator|=
operator|(
name|drawbuffer
operator|==
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|i
argument_list|)
operator|)
expr_stmt|;
block|}
name|clearParams
operator|.
name|colorUIClearValue
operator|=
name|gl
operator|::
name|ColorUI
argument_list|(
name|values
index|[
literal|0
index|]
argument_list|,
name|values
index|[
literal|1
index|]
argument_list|,
name|values
index|[
literal|2
index|]
argument_list|,
name|values
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|clearParams
operator|.
name|colorClearType
operator|=
name|GL_UNSIGNED_INT
expr_stmt|;
comment|// Clips the clear to the scissor rectangle but not the viewport
name|gl
operator|::
name|Error
name|error
init|=
name|applyRenderTarget
argument_list|(
name|data
argument_list|,
name|GL_TRIANGLES
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
return|return
name|clear
argument_list|(
name|clearParams
argument_list|,
name|data
operator|.
name|state
operator|->
name|getDrawFramebuffer
argument_list|()
argument_list|)
return|;
block|}
DECL|function|clearBufferiv
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|clearBufferiv
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLenum
name|buffer
parameter_list|,
name|GLint
name|drawbuffer
parameter_list|,
specifier|const
name|GLint
modifier|*
name|values
parameter_list|)
block|{
comment|// glClearBufferiv can be called to clear the color buffer or stencil buffer
name|gl
operator|::
name|ClearParameters
name|clearParams
init|=
name|data
operator|.
name|state
operator|->
name|getClearParameters
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|buffer
operator|==
name|GL_COLOR
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ArraySize
argument_list|(
name|clearParams
operator|.
name|clearColor
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|clearParams
operator|.
name|clearColor
index|[
name|i
index|]
operator|=
operator|(
name|drawbuffer
operator|==
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|i
argument_list|)
operator|)
expr_stmt|;
block|}
name|clearParams
operator|.
name|colorIClearValue
operator|=
name|gl
operator|::
name|ColorI
argument_list|(
name|values
index|[
literal|0
index|]
argument_list|,
name|values
index|[
literal|1
index|]
argument_list|,
name|values
index|[
literal|2
index|]
argument_list|,
name|values
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|clearParams
operator|.
name|colorClearType
operator|=
name|GL_INT
expr_stmt|;
block|}
if|if
condition|(
name|buffer
operator|==
name|GL_STENCIL
condition|)
block|{
name|clearParams
operator|.
name|clearStencil
operator|=
literal|true
expr_stmt|;
name|clearParams
operator|.
name|stencilClearValue
operator|=
name|values
index|[
literal|1
index|]
expr_stmt|;
block|}
comment|// Clips the clear to the scissor rectangle but not the viewport
name|gl
operator|::
name|Error
name|error
init|=
name|applyRenderTarget
argument_list|(
name|data
argument_list|,
name|GL_TRIANGLES
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
return|return
name|clear
argument_list|(
name|clearParams
argument_list|,
name|data
operator|.
name|state
operator|->
name|getDrawFramebuffer
argument_list|()
argument_list|)
return|;
block|}
DECL|function|clearBufferfi
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|clearBufferfi
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLenum
name|buffer
parameter_list|,
name|GLint
name|drawbuffer
parameter_list|,
name|GLfloat
name|depth
parameter_list|,
name|GLint
name|stencil
parameter_list|)
block|{
if|if
condition|(
name|data
operator|.
name|state
operator|->
name|isRasterizerDiscardEnabled
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
comment|// glClearBufferfi can only be called to clear a depth stencil buffer
name|gl
operator|::
name|ClearParameters
name|clearParams
init|=
name|data
operator|.
name|state
operator|->
name|getClearParameters
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|clearParams
operator|.
name|clearDepth
operator|=
literal|true
expr_stmt|;
name|clearParams
operator|.
name|depthClearValue
operator|=
name|depth
expr_stmt|;
name|clearParams
operator|.
name|clearStencil
operator|=
literal|true
expr_stmt|;
name|clearParams
operator|.
name|stencilClearValue
operator|=
name|stencil
expr_stmt|;
comment|// Clips the clear to the scissor rectangle but not the viewport
name|gl
operator|::
name|Error
name|error
init|=
name|applyRenderTarget
argument_list|(
name|data
argument_list|,
name|GL_TRIANGLES
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
return|return
name|clear
argument_list|(
name|clearParams
argument_list|,
name|data
operator|.
name|state
operator|->
name|getDrawFramebuffer
argument_list|()
argument_list|)
return|;
block|}
DECL|function|blitFramebuffer
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|blitFramebuffer
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLint
name|srcX0
parameter_list|,
name|GLint
name|srcY0
parameter_list|,
name|GLint
name|srcX1
parameter_list|,
name|GLint
name|srcY1
parameter_list|,
name|GLint
name|dstX0
parameter_list|,
name|GLint
name|dstY0
parameter_list|,
name|GLint
name|dstX1
parameter_list|,
name|GLint
name|dstY1
parameter_list|,
name|GLbitfield
name|mask
parameter_list|,
name|GLenum
name|filter
parameter_list|)
block|{
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|readFramebuffer
init|=
name|data
operator|.
name|state
operator|->
name|getReadFramebuffer
argument_list|()
decl_stmt|;
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|drawFramebuffer
init|=
name|data
operator|.
name|state
operator|->
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
name|bool
name|blitRenderTarget
init|=
literal|false
decl_stmt|;
name|bool
name|blitDepth
init|=
literal|false
decl_stmt|;
name|bool
name|blitStencil
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|GL_COLOR_BUFFER_BIT
operator|)
operator|&&
name|readFramebuffer
operator|->
name|getReadColorbuffer
argument_list|()
operator|&&
name|drawFramebuffer
operator|->
name|getFirstColorbuffer
argument_list|()
condition|)
block|{
name|blitRenderTarget
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|GL_STENCIL_BUFFER_BIT
operator|)
operator|&&
name|readFramebuffer
operator|->
name|getStencilbuffer
argument_list|()
operator|&&
name|drawFramebuffer
operator|->
name|getStencilbuffer
argument_list|()
condition|)
block|{
name|blitStencil
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|GL_DEPTH_BUFFER_BIT
operator|)
operator|&&
name|readFramebuffer
operator|->
name|getDepthbuffer
argument_list|()
operator|&&
name|drawFramebuffer
operator|->
name|getDepthbuffer
argument_list|()
condition|)
block|{
name|blitDepth
operator|=
literal|true
expr_stmt|;
block|}
name|gl
operator|::
name|Rectangle
name|srcRect
argument_list|(
name|srcX0
argument_list|,
name|srcY0
argument_list|,
name|srcX1
operator|-
name|srcX0
argument_list|,
name|srcY1
operator|-
name|srcY0
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Rectangle
name|dstRect
argument_list|(
name|dstX0
argument_list|,
name|dstY0
argument_list|,
name|dstX1
operator|-
name|dstX0
argument_list|,
name|dstY1
operator|-
name|dstY0
argument_list|)
decl_stmt|;
if|if
condition|(
name|blitRenderTarget
operator|||
name|blitDepth
operator|||
name|blitStencil
condition|)
block|{
specifier|const
name|gl
operator|::
name|Rectangle
modifier|*
name|scissor
init|=
name|data
operator|.
name|state
operator|->
name|isScissorTestEnabled
argument_list|()
condition|?
operator|&
name|data
operator|.
name|state
operator|->
name|getScissor
argument_list|()
else|:
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|blitRect
argument_list|(
name|readFramebuffer
argument_list|,
name|srcRect
argument_list|,
name|drawFramebuffer
argument_list|,
name|dstRect
argument_list|,
name|scissor
argument_list|,
name|blitRenderTarget
argument_list|,
name|blitDepth
argument_list|,
name|blitStencil
argument_list|,
name|filter
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|readPixels
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|readPixels
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLsizei
modifier|*
name|bufSize
parameter_list|,
name|void
modifier|*
name|pixels
parameter_list|)
block|{
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|data
operator|.
name|state
operator|->
name|getReadFramebuffer
argument_list|()
decl_stmt|;
name|GLenum
name|sizedInternalFormat
init|=
name|gl
operator|::
name|GetSizedInternalFormat
argument_list|(
name|format
argument_list|,
name|type
argument_list|)
decl_stmt|;
specifier|const
name|gl
operator|::
name|InternalFormat
modifier|&
name|sizedFormatInfo
init|=
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|sizedInternalFormat
argument_list|)
decl_stmt|;
name|GLuint
name|outputPitch
init|=
name|sizedFormatInfo
operator|.
name|computeRowPitch
argument_list|(
name|type
argument_list|,
name|width
argument_list|,
name|data
operator|.
name|state
operator|->
name|getPackAlignment
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|readPixels
argument_list|(
name|framebuffer
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|outputPitch
argument_list|,
name|data
operator|.
name|state
operator|->
name|getPackState
argument_list|()
argument_list|,
cast|reinterpret_cast
argument_list|<
name|uint8_t
operator|*
argument_list|>
argument_list|(
name|pixels
argument_list|)
argument_list|)
return|;
block|}
block|}
end_namespace
end_unit
