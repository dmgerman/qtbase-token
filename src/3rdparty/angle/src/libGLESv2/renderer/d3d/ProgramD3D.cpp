begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// ProgramD3D.cpp: Defines the rx::ProgramD3D class which implements rx::ProgramImpl.
end_comment
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/ProgramD3D.h"
end_include
begin_include
include|#
directive|include
file|"common/features.h"
end_include
begin_include
include|#
directive|include
file|"common/utilities.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Framebuffer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/FramebufferAttachment.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Program.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/ProgramBinary.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/main.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/ShaderExecutable.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/DynamicHLSL.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/RendererD3D.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/ShaderD3D.h"
end_include
begin_namespace
DECL|namespace|rx
namespace|namespace
name|rx
block|{
namespace|namespace
block|{
DECL|function|GetTextureType
name|GLenum
name|GetTextureType
parameter_list|(
name|GLenum
name|samplerType
parameter_list|)
block|{
switch|switch
condition|(
name|samplerType
condition|)
block|{
case|case
name|GL_SAMPLER_2D
case|:
case|case
name|GL_INT_SAMPLER_2D
case|:
case|case
name|GL_UNSIGNED_INT_SAMPLER_2D
case|:
case|case
name|GL_SAMPLER_2D_SHADOW
case|:
return|return
name|GL_TEXTURE_2D
return|;
case|case
name|GL_SAMPLER_3D
case|:
case|case
name|GL_INT_SAMPLER_3D
case|:
case|case
name|GL_UNSIGNED_INT_SAMPLER_3D
case|:
return|return
name|GL_TEXTURE_3D
return|;
case|case
name|GL_SAMPLER_CUBE
case|:
case|case
name|GL_SAMPLER_CUBE_SHADOW
case|:
return|return
name|GL_TEXTURE_CUBE_MAP
return|;
case|case
name|GL_INT_SAMPLER_CUBE
case|:
case|case
name|GL_UNSIGNED_INT_SAMPLER_CUBE
case|:
return|return
name|GL_TEXTURE_CUBE_MAP
return|;
case|case
name|GL_SAMPLER_2D_ARRAY
case|:
case|case
name|GL_INT_SAMPLER_2D_ARRAY
case|:
case|case
name|GL_UNSIGNED_INT_SAMPLER_2D_ARRAY
case|:
case|case
name|GL_SAMPLER_2D_ARRAY_SHADOW
case|:
return|return
name|GL_TEXTURE_2D_ARRAY
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
name|GL_TEXTURE_2D
return|;
block|}
DECL|function|GetDefaultInputLayoutFromShader
name|void
name|GetDefaultInputLayoutFromShader
parameter_list|(
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|Attribute
argument_list|>
modifier|&
name|shaderAttributes
parameter_list|,
name|gl
operator|::
name|VertexFormat
name|inputLayout
index|[
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
index|]
parameter_list|)
block|{
name|size_t
name|layoutIndex
init|=
literal|0
decl_stmt|;
for|for
control|(
name|size_t
name|attributeIndex
init|=
literal|0
init|;
name|attributeIndex
operator|<
name|shaderAttributes
operator|.
name|size
argument_list|()
condition|;
name|attributeIndex
operator|++
control|)
block|{
name|ASSERT
argument_list|(
name|layoutIndex
operator|<
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
argument_list|)
expr_stmt|;
specifier|const
name|sh
operator|::
name|Attribute
modifier|&
name|shaderAttr
init|=
name|shaderAttributes
index|[
name|attributeIndex
index|]
decl_stmt|;
if|if
condition|(
name|shaderAttr
operator|.
name|type
operator|!=
name|GL_NONE
condition|)
block|{
name|GLenum
name|transposedType
init|=
name|gl
operator|::
name|TransposeMatrixType
argument_list|(
name|shaderAttr
operator|.
name|type
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|rowIndex
init|=
literal|0
init|;
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|rowIndex
argument_list|)
operator|<
name|gl
operator|::
name|VariableRowCount
argument_list|(
name|transposedType
argument_list|)
condition|;
name|rowIndex
operator|++
operator|,
name|layoutIndex
operator|++
control|)
block|{
name|gl
operator|::
name|VertexFormat
modifier|*
name|defaultFormat
init|=
operator|&
name|inputLayout
index|[
name|layoutIndex
index|]
decl_stmt|;
name|defaultFormat
operator|->
name|mType
operator|=
name|gl
operator|::
name|VariableComponentType
argument_list|(
name|transposedType
argument_list|)
expr_stmt|;
name|defaultFormat
operator|->
name|mNormalized
operator|=
literal|false
expr_stmt|;
name|defaultFormat
operator|->
name|mPureInteger
operator|=
operator|(
name|defaultFormat
operator|->
name|mType
operator|!=
name|GL_FLOAT
operator|)
expr_stmt|;
comment|// note: inputs can not be bool
name|defaultFormat
operator|->
name|mComponents
operator|=
name|gl
operator|::
name|VariableColumnCount
argument_list|(
name|transposedType
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|function|GetDefaultOutputLayoutFromShader
name|std
operator|::
name|vector
argument_list|<
name|GLenum
argument_list|>
name|GetDefaultOutputLayoutFromShader
parameter_list|(
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|PixelShaderOutputVariable
argument_list|>
modifier|&
name|shaderOutputVars
parameter_list|)
block|{
name|std
operator|::
name|vector
argument_list|<
name|GLenum
argument_list|>
name|defaultPixelOutput
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|shaderOutputVars
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
name|defaultPixelOutput
index|[
literal|0
index|]
operator|=
name|GL_COLOR_ATTACHMENT0
operator|+
name|shaderOutputVars
index|[
literal|0
index|]
operator|.
name|outputIndex
expr_stmt|;
return|return
name|defaultPixelOutput
return|;
block|}
DECL|function|IsRowMajorLayout
name|bool
name|IsRowMajorLayout
parameter_list|(
specifier|const
name|sh
operator|::
name|InterfaceBlockField
modifier|&
name|var
parameter_list|)
block|{
return|return
name|var
operator|.
name|isRowMajorLayout
return|;
block|}
DECL|function|IsRowMajorLayout
name|bool
name|IsRowMajorLayout
parameter_list|(
specifier|const
name|sh
operator|::
name|ShaderVariable
modifier|&
name|var
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
DECL|function|VertexExecutable
name|ProgramD3D
operator|::
name|VertexExecutable
operator|::
name|VertexExecutable
parameter_list|(
specifier|const
name|gl
operator|::
name|VertexFormat
name|inputLayout
index|[]
parameter_list|,
specifier|const
name|GLenum
name|signature
index|[]
parameter_list|,
name|ShaderExecutable
modifier|*
name|shaderExecutable
parameter_list|)
member_init_list|:
name|mShaderExecutable
argument_list|(
name|shaderExecutable
argument_list|)
block|{
for|for
control|(
name|size_t
name|attributeIndex
init|=
literal|0
init|;
name|attributeIndex
operator|<
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
condition|;
name|attributeIndex
operator|++
control|)
block|{
name|mInputs
index|[
name|attributeIndex
index|]
operator|=
name|inputLayout
index|[
name|attributeIndex
index|]
expr_stmt|;
name|mSignature
index|[
name|attributeIndex
index|]
operator|=
name|signature
index|[
name|attributeIndex
index|]
expr_stmt|;
block|}
block|}
DECL|function|~VertexExecutable
name|ProgramD3D
operator|::
name|VertexExecutable
operator|::
name|~
name|VertexExecutable
parameter_list|()
block|{
name|SafeDelete
argument_list|(
name|mShaderExecutable
argument_list|)
expr_stmt|;
block|}
DECL|function|matchesSignature
name|bool
name|ProgramD3D
operator|::
name|VertexExecutable
operator|::
name|matchesSignature
parameter_list|(
specifier|const
name|GLenum
name|signature
index|[]
parameter_list|)
specifier|const
block|{
for|for
control|(
name|size_t
name|attributeIndex
init|=
literal|0
init|;
name|attributeIndex
operator|<
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
condition|;
name|attributeIndex
operator|++
control|)
block|{
if|if
condition|(
name|mSignature
index|[
name|attributeIndex
index|]
operator|!=
name|signature
index|[
name|attributeIndex
index|]
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|PixelExecutable
name|ProgramD3D
operator|::
name|PixelExecutable
operator|::
name|PixelExecutable
parameter_list|(
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|GLenum
argument_list|>
modifier|&
name|outputSignature
parameter_list|,
name|ShaderExecutable
modifier|*
name|shaderExecutable
parameter_list|)
member_init_list|:
name|mOutputSignature
argument_list|(
name|outputSignature
argument_list|)
member_init_list|,
name|mShaderExecutable
argument_list|(
name|shaderExecutable
argument_list|)
block|{ }
DECL|function|~PixelExecutable
name|ProgramD3D
operator|::
name|PixelExecutable
operator|::
name|~
name|PixelExecutable
parameter_list|()
block|{
name|SafeDelete
argument_list|(
name|mShaderExecutable
argument_list|)
expr_stmt|;
block|}
DECL|function|Sampler
name|ProgramD3D
operator|::
name|Sampler
operator|::
name|Sampler
parameter_list|()
member_init_list|:
name|active
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|logicalTextureUnit
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|textureType
argument_list|(
name|GL_TEXTURE_2D
argument_list|)
block|{ }
DECL|function|ProgramD3D
name|ProgramD3D
operator|::
name|ProgramD3D
parameter_list|(
name|RendererD3D
modifier|*
name|renderer
parameter_list|)
member_init_list|:
name|ProgramImpl
argument_list|()
member_init_list|,
name|mRenderer
argument_list|(
name|renderer
argument_list|)
member_init_list|,
name|mDynamicHLSL
argument_list|(
name|NULL
argument_list|)
member_init_list|,
name|mGeometryExecutable
argument_list|(
name|NULL
argument_list|)
member_init_list|,
name|mVertexWorkarounds
argument_list|(
name|ANGLE_D3D_WORKAROUND_NONE
argument_list|)
member_init_list|,
name|mPixelWorkarounds
argument_list|(
name|ANGLE_D3D_WORKAROUND_NONE
argument_list|)
member_init_list|,
name|mUsesPointSize
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mVertexUniformStorage
argument_list|(
name|NULL
argument_list|)
member_init_list|,
name|mFragmentUniformStorage
argument_list|(
name|NULL
argument_list|)
member_init_list|,
name|mUsedVertexSamplerRange
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mUsedPixelSamplerRange
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mDirtySamplerMapping
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|mShaderVersion
argument_list|(
literal|100
argument_list|)
block|{
name|mDynamicHLSL
operator|=
operator|new
name|DynamicHLSL
argument_list|(
name|renderer
argument_list|)
expr_stmt|;
block|}
DECL|function|~ProgramD3D
name|ProgramD3D
operator|::
name|~
name|ProgramD3D
parameter_list|()
block|{
name|reset
argument_list|()
expr_stmt|;
name|SafeDelete
argument_list|(
name|mDynamicHLSL
argument_list|)
expr_stmt|;
block|}
DECL|function|makeProgramD3D
name|ProgramD3D
modifier|*
name|ProgramD3D
operator|::
name|makeProgramD3D
parameter_list|(
name|ProgramImpl
modifier|*
name|impl
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|HAS_DYNAMIC_TYPE
argument_list|(
name|ProgramD3D
operator|*
argument_list|,
name|impl
argument_list|)
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|ProgramD3D
operator|*
argument_list|>
argument_list|(
name|impl
argument_list|)
return|;
block|}
DECL|function|makeProgramD3D
specifier|const
name|ProgramD3D
modifier|*
name|ProgramD3D
operator|::
name|makeProgramD3D
parameter_list|(
specifier|const
name|ProgramImpl
modifier|*
name|impl
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|HAS_DYNAMIC_TYPE
argument_list|(
specifier|const
name|ProgramD3D
operator|*
argument_list|,
name|impl
argument_list|)
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
specifier|const
name|ProgramD3D
operator|*
argument_list|>
argument_list|(
name|impl
argument_list|)
return|;
block|}
DECL|function|usesPointSpriteEmulation
name|bool
name|ProgramD3D
operator|::
name|usesPointSpriteEmulation
parameter_list|()
specifier|const
block|{
return|return
name|mUsesPointSize
operator|&&
name|mRenderer
operator|->
name|getMajorShaderModel
argument_list|()
operator|>=
literal|4
return|;
block|}
DECL|function|usesGeometryShader
name|bool
name|ProgramD3D
operator|::
name|usesGeometryShader
parameter_list|()
specifier|const
block|{
return|return
name|usesPointSpriteEmulation
argument_list|()
return|;
block|}
DECL|function|getSamplerMapping
name|GLint
name|ProgramD3D
operator|::
name|getSamplerMapping
parameter_list|(
name|gl
operator|::
name|SamplerType
name|type
parameter_list|,
name|unsigned
name|int
name|samplerIndex
parameter_list|,
specifier|const
name|gl
operator|::
name|Caps
modifier|&
name|caps
parameter_list|)
specifier|const
block|{
name|GLint
name|logicalTextureUnit
init|=
operator|-
literal|1
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|gl
operator|::
name|SAMPLER_PIXEL
case|:
name|ASSERT
argument_list|(
name|samplerIndex
operator|<
name|caps
operator|.
name|maxTextureImageUnits
argument_list|)
expr_stmt|;
if|if
condition|(
name|samplerIndex
operator|<
name|mSamplersPS
operator|.
name|size
argument_list|()
operator|&&
name|mSamplersPS
index|[
name|samplerIndex
index|]
operator|.
name|active
condition|)
block|{
name|logicalTextureUnit
operator|=
name|mSamplersPS
index|[
name|samplerIndex
index|]
operator|.
name|logicalTextureUnit
expr_stmt|;
block|}
break|break;
case|case
name|gl
operator|::
name|SAMPLER_VERTEX
case|:
name|ASSERT
argument_list|(
name|samplerIndex
operator|<
name|caps
operator|.
name|maxVertexTextureImageUnits
argument_list|)
expr_stmt|;
if|if
condition|(
name|samplerIndex
operator|<
name|mSamplersVS
operator|.
name|size
argument_list|()
operator|&&
name|mSamplersVS
index|[
name|samplerIndex
index|]
operator|.
name|active
condition|)
block|{
name|logicalTextureUnit
operator|=
name|mSamplersVS
index|[
name|samplerIndex
index|]
operator|.
name|logicalTextureUnit
expr_stmt|;
block|}
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|logicalTextureUnit
operator|>=
literal|0
operator|&&
name|logicalTextureUnit
operator|<
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|caps
operator|.
name|maxCombinedTextureImageUnits
argument_list|)
condition|)
block|{
return|return
name|logicalTextureUnit
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|// Returns the texture type for a given Direct3D 9 sampler type and
comment|// index (0-15 for the pixel shader and 0-3 for the vertex shader).
DECL|function|getSamplerTextureType
name|GLenum
name|ProgramD3D
operator|::
name|getSamplerTextureType
parameter_list|(
name|gl
operator|::
name|SamplerType
name|type
parameter_list|,
name|unsigned
name|int
name|samplerIndex
parameter_list|)
specifier|const
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|gl
operator|::
name|SAMPLER_PIXEL
case|:
name|ASSERT
argument_list|(
name|samplerIndex
operator|<
name|mSamplersPS
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mSamplersPS
index|[
name|samplerIndex
index|]
operator|.
name|active
argument_list|)
expr_stmt|;
return|return
name|mSamplersPS
index|[
name|samplerIndex
index|]
operator|.
name|textureType
return|;
case|case
name|gl
operator|::
name|SAMPLER_VERTEX
case|:
name|ASSERT
argument_list|(
name|samplerIndex
operator|<
name|mSamplersVS
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mSamplersVS
index|[
name|samplerIndex
index|]
operator|.
name|active
argument_list|)
expr_stmt|;
return|return
name|mSamplersVS
index|[
name|samplerIndex
index|]
operator|.
name|textureType
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
name|GL_TEXTURE_2D
return|;
block|}
DECL|function|getUsedSamplerRange
name|GLint
name|ProgramD3D
operator|::
name|getUsedSamplerRange
parameter_list|(
name|gl
operator|::
name|SamplerType
name|type
parameter_list|)
specifier|const
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|gl
operator|::
name|SAMPLER_PIXEL
case|:
return|return
name|mUsedPixelSamplerRange
return|;
case|case
name|gl
operator|::
name|SAMPLER_VERTEX
case|:
return|return
name|mUsedVertexSamplerRange
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|updateSamplerMapping
name|void
name|ProgramD3D
operator|::
name|updateSamplerMapping
parameter_list|()
block|{
if|if
condition|(
operator|!
name|mDirtySamplerMapping
condition|)
block|{
return|return;
block|}
name|mDirtySamplerMapping
operator|=
literal|false
expr_stmt|;
comment|// Retrieve sampler uniform values
for|for
control|(
name|size_t
name|uniformIndex
init|=
literal|0
init|;
name|uniformIndex
operator|<
name|mUniforms
operator|.
name|size
argument_list|()
condition|;
name|uniformIndex
operator|++
control|)
block|{
name|gl
operator|::
name|LinkedUniform
modifier|*
name|targetUniform
init|=
name|mUniforms
index|[
name|uniformIndex
index|]
decl_stmt|;
if|if
condition|(
name|targetUniform
operator|->
name|dirty
condition|)
block|{
if|if
condition|(
name|gl
operator|::
name|IsSampler
argument_list|(
name|targetUniform
operator|->
name|type
argument_list|)
condition|)
block|{
name|int
name|count
init|=
name|targetUniform
operator|->
name|elementCount
argument_list|()
decl_stmt|;
name|GLint
argument_list|(
operator|*
name|v
argument_list|)
index|[
literal|4
index|]
operator|=
expr|reinterpret_cast
operator|<
name|GLint
argument_list|(
operator|*
argument_list|)
index|[
literal|4
index|]
operator|>
operator|(
name|targetUniform
operator|->
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|targetUniform
operator|->
name|isReferencedByFragmentShader
argument_list|()
condition|)
block|{
name|unsigned
name|int
name|firstIndex
init|=
name|targetUniform
operator|->
name|psRegisterIndex
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|samplerIndex
init|=
name|firstIndex
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|samplerIndex
operator|<
name|mSamplersPS
operator|.
name|size
argument_list|()
condition|)
block|{
name|ASSERT
argument_list|(
name|mSamplersPS
index|[
name|samplerIndex
index|]
operator|.
name|active
argument_list|)
expr_stmt|;
name|mSamplersPS
index|[
name|samplerIndex
index|]
operator|.
name|logicalTextureUnit
operator|=
name|v
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|targetUniform
operator|->
name|isReferencedByVertexShader
argument_list|()
condition|)
block|{
name|unsigned
name|int
name|firstIndex
init|=
name|targetUniform
operator|->
name|vsRegisterIndex
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|samplerIndex
init|=
name|firstIndex
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|samplerIndex
operator|<
name|mSamplersVS
operator|.
name|size
argument_list|()
condition|)
block|{
name|ASSERT
argument_list|(
name|mSamplersVS
index|[
name|samplerIndex
index|]
operator|.
name|active
argument_list|)
expr_stmt|;
name|mSamplersVS
index|[
name|samplerIndex
index|]
operator|.
name|logicalTextureUnit
operator|=
name|v
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
DECL|function|validateSamplers
name|bool
name|ProgramD3D
operator|::
name|validateSamplers
parameter_list|(
name|gl
operator|::
name|InfoLog
modifier|*
name|infoLog
parameter_list|,
specifier|const
name|gl
operator|::
name|Caps
modifier|&
name|caps
parameter_list|)
block|{
comment|// if any two active samplers in a program are of different types, but refer to the same
comment|// texture image unit, and this is the current program, then ValidateProgram will fail, and
comment|// DrawArrays and DrawElements will issue the INVALID_OPERATION error.
name|updateSamplerMapping
argument_list|()
expr_stmt|;
name|std
operator|::
name|vector
argument_list|<
name|GLenum
argument_list|>
name|textureUnitTypes
argument_list|(
name|caps
operator|.
name|maxCombinedTextureImageUnits
argument_list|,
name|GL_NONE
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mUsedPixelSamplerRange
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|active
condition|)
block|{
name|unsigned
name|int
name|unit
init|=
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|logicalTextureUnit
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|textureUnitTypes
operator|.
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
name|infoLog
condition|)
block|{
name|infoLog
operator|->
name|append
argument_list|(
literal|"Sampler uniform (%d) exceeds GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS (%d)"
argument_list|,
name|unit
argument_list|,
name|textureUnitTypes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
if|if
condition|(
name|textureUnitTypes
index|[
name|unit
index|]
operator|!=
name|GL_NONE
condition|)
block|{
if|if
condition|(
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|textureType
operator|!=
name|textureUnitTypes
index|[
name|unit
index|]
condition|)
block|{
if|if
condition|(
name|infoLog
condition|)
block|{
name|infoLog
operator|->
name|append
argument_list|(
literal|"Samplers of conflicting types refer to the same texture image unit (%d)."
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
name|textureUnitTypes
index|[
name|unit
index|]
operator|=
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|textureType
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mUsedVertexSamplerRange
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|active
condition|)
block|{
name|unsigned
name|int
name|unit
init|=
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|logicalTextureUnit
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|textureUnitTypes
operator|.
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
name|infoLog
condition|)
block|{
name|infoLog
operator|->
name|append
argument_list|(
literal|"Sampler uniform (%d) exceeds GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS (%d)"
argument_list|,
name|unit
argument_list|,
name|textureUnitTypes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
if|if
condition|(
name|textureUnitTypes
index|[
name|unit
index|]
operator|!=
name|GL_NONE
condition|)
block|{
if|if
condition|(
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|textureType
operator|!=
name|textureUnitTypes
index|[
name|unit
index|]
condition|)
block|{
if|if
condition|(
name|infoLog
condition|)
block|{
name|infoLog
operator|->
name|append
argument_list|(
literal|"Samplers of conflicting types refer to the same texture image unit (%d)."
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
name|textureUnitTypes
index|[
name|unit
index|]
operator|=
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|textureType
expr_stmt|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|load
name|gl
operator|::
name|LinkResult
name|ProgramD3D
operator|::
name|load
parameter_list|(
name|gl
operator|::
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
name|gl
operator|::
name|BinaryInputStream
modifier|*
name|stream
parameter_list|)
block|{
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|mShaderVersion
argument_list|)
expr_stmt|;
specifier|const
name|unsigned
name|int
name|psSamplerCount
init|=
name|stream
operator|->
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|psSamplerCount
condition|;
operator|++
name|i
control|)
block|{
name|Sampler
name|sampler
decl_stmt|;
name|stream
operator|->
name|readBool
argument_list|(
operator|&
name|sampler
operator|.
name|active
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|sampler
operator|.
name|logicalTextureUnit
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|sampler
operator|.
name|textureType
argument_list|)
expr_stmt|;
name|mSamplersPS
operator|.
name|push_back
argument_list|(
name|sampler
argument_list|)
expr_stmt|;
block|}
specifier|const
name|unsigned
name|int
name|vsSamplerCount
init|=
name|stream
operator|->
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsSamplerCount
condition|;
operator|++
name|i
control|)
block|{
name|Sampler
name|sampler
decl_stmt|;
name|stream
operator|->
name|readBool
argument_list|(
operator|&
name|sampler
operator|.
name|active
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|sampler
operator|.
name|logicalTextureUnit
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|sampler
operator|.
name|textureType
argument_list|)
expr_stmt|;
name|mSamplersVS
operator|.
name|push_back
argument_list|(
name|sampler
argument_list|)
expr_stmt|;
block|}
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|mUsedVertexSamplerRange
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|mUsedPixelSamplerRange
argument_list|)
expr_stmt|;
specifier|const
name|unsigned
name|int
name|uniformCount
init|=
name|stream
operator|->
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|stream
operator|->
name|error
argument_list|()
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Invalid program binary."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
name|mUniforms
operator|.
name|resize
argument_list|(
name|uniformCount
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|uniformIndex
init|=
literal|0
init|;
name|uniformIndex
operator|<
name|uniformCount
condition|;
name|uniformIndex
operator|++
control|)
block|{
name|GLenum
name|type
init|=
name|stream
operator|->
name|readInt
argument_list|<
name|GLenum
argument_list|>
argument_list|()
decl_stmt|;
name|GLenum
name|precision
init|=
name|stream
operator|->
name|readInt
argument_list|<
name|GLenum
argument_list|>
argument_list|()
decl_stmt|;
name|std
operator|::
name|string
name|name
init|=
name|stream
operator|->
name|readString
argument_list|()
decl_stmt|;
name|unsigned
name|int
name|arraySize
init|=
name|stream
operator|->
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|blockIndex
init|=
name|stream
operator|->
name|readInt
argument_list|<
name|int
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|offset
init|=
name|stream
operator|->
name|readInt
argument_list|<
name|int
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|arrayStride
init|=
name|stream
operator|->
name|readInt
argument_list|<
name|int
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|matrixStride
init|=
name|stream
operator|->
name|readInt
argument_list|<
name|int
argument_list|>
argument_list|()
decl_stmt|;
name|bool
name|isRowMajorMatrix
init|=
name|stream
operator|->
name|readBool
argument_list|()
decl_stmt|;
specifier|const
name|sh
operator|::
name|BlockMemberInfo
name|blockInfo
argument_list|(
name|offset
argument_list|,
name|arrayStride
argument_list|,
name|matrixStride
argument_list|,
name|isRowMajorMatrix
argument_list|)
decl_stmt|;
name|gl
operator|::
name|LinkedUniform
modifier|*
name|uniform
init|=
operator|new
name|gl
operator|::
name|LinkedUniform
argument_list|(
name|type
argument_list|,
name|precision
argument_list|,
name|name
argument_list|,
name|arraySize
argument_list|,
name|blockIndex
argument_list|,
name|blockInfo
argument_list|)
decl_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|uniform
operator|->
name|psRegisterIndex
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|uniform
operator|->
name|vsRegisterIndex
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|uniform
operator|->
name|registerCount
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|uniform
operator|->
name|registerElement
argument_list|)
expr_stmt|;
name|mUniforms
index|[
name|uniformIndex
index|]
operator|=
name|uniform
expr_stmt|;
block|}
specifier|const
name|unsigned
name|int
name|uniformIndexCount
init|=
name|stream
operator|->
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|stream
operator|->
name|error
argument_list|()
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Invalid program binary."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
name|mUniformIndex
operator|.
name|resize
argument_list|(
name|uniformIndexCount
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|uniformIndexIndex
init|=
literal|0
init|;
name|uniformIndexIndex
operator|<
name|uniformIndexCount
condition|;
name|uniformIndexIndex
operator|++
control|)
block|{
name|stream
operator|->
name|readString
argument_list|(
operator|&
name|mUniformIndex
index|[
name|uniformIndexIndex
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|mUniformIndex
index|[
name|uniformIndexIndex
index|]
operator|.
name|element
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|mUniformIndex
index|[
name|uniformIndexIndex
index|]
operator|.
name|index
argument_list|)
expr_stmt|;
block|}
name|unsigned
name|int
name|uniformBlockCount
init|=
name|stream
operator|->
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|stream
operator|->
name|error
argument_list|()
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Invalid program binary."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
name|mUniformBlocks
operator|.
name|resize
argument_list|(
name|uniformBlockCount
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|uniformBlockIndex
init|=
literal|0
init|;
name|uniformBlockIndex
operator|<
name|uniformBlockCount
condition|;
operator|++
name|uniformBlockIndex
control|)
block|{
name|std
operator|::
name|string
name|name
init|=
name|stream
operator|->
name|readString
argument_list|()
decl_stmt|;
name|unsigned
name|int
name|elementIndex
init|=
name|stream
operator|->
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
name|unsigned
name|int
name|dataSize
init|=
name|stream
operator|->
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
name|gl
operator|::
name|UniformBlock
modifier|*
name|uniformBlock
init|=
operator|new
name|gl
operator|::
name|UniformBlock
argument_list|(
name|name
argument_list|,
name|elementIndex
argument_list|,
name|dataSize
argument_list|)
decl_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|uniformBlock
operator|->
name|psRegisterIndex
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|uniformBlock
operator|->
name|vsRegisterIndex
argument_list|)
expr_stmt|;
name|unsigned
name|int
name|numMembers
init|=
name|stream
operator|->
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
name|uniformBlock
operator|->
name|memberUniformIndexes
operator|.
name|resize
argument_list|(
name|numMembers
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|blockMemberIndex
init|=
literal|0
init|;
name|blockMemberIndex
operator|<
name|numMembers
condition|;
name|blockMemberIndex
operator|++
control|)
block|{
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|uniformBlock
operator|->
name|memberUniformIndexes
index|[
name|blockMemberIndex
index|]
argument_list|)
expr_stmt|;
block|}
name|mUniformBlocks
index|[
name|uniformBlockIndex
index|]
operator|=
name|uniformBlock
expr_stmt|;
block|}
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|mTransformFeedbackBufferMode
argument_list|)
expr_stmt|;
specifier|const
name|unsigned
name|int
name|transformFeedbackVaryingCount
init|=
name|stream
operator|->
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
name|mTransformFeedbackLinkedVaryings
operator|.
name|resize
argument_list|(
name|transformFeedbackVaryingCount
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|varyingIndex
init|=
literal|0
init|;
name|varyingIndex
operator|<
name|transformFeedbackVaryingCount
condition|;
name|varyingIndex
operator|++
control|)
block|{
name|gl
operator|::
name|LinkedVarying
modifier|&
name|varying
init|=
name|mTransformFeedbackLinkedVaryings
index|[
name|varyingIndex
index|]
decl_stmt|;
name|stream
operator|->
name|readString
argument_list|(
operator|&
name|varying
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|varying
operator|.
name|type
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|varying
operator|.
name|size
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readString
argument_list|(
operator|&
name|varying
operator|.
name|semanticName
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|varying
operator|.
name|semanticIndex
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|varying
operator|.
name|semanticIndexCount
argument_list|)
expr_stmt|;
block|}
name|stream
operator|->
name|readString
argument_list|(
operator|&
name|mVertexHLSL
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|mVertexWorkarounds
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readString
argument_list|(
operator|&
name|mPixelHLSL
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|mPixelWorkarounds
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readBool
argument_list|(
operator|&
name|mUsesFragDepth
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readBool
argument_list|(
operator|&
name|mUsesPointSize
argument_list|)
expr_stmt|;
specifier|const
name|size_t
name|pixelShaderKeySize
init|=
name|stream
operator|->
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
name|mPixelShaderKey
operator|.
name|resize
argument_list|(
name|pixelShaderKeySize
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|pixelShaderKeyIndex
init|=
literal|0
init|;
name|pixelShaderKeyIndex
operator|<
name|pixelShaderKeySize
condition|;
name|pixelShaderKeyIndex
operator|++
control|)
block|{
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|mPixelShaderKey
index|[
name|pixelShaderKeyIndex
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readString
argument_list|(
operator|&
name|mPixelShaderKey
index|[
name|pixelShaderKeyIndex
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readString
argument_list|(
operator|&
name|mPixelShaderKey
index|[
name|pixelShaderKeyIndex
index|]
operator|.
name|source
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|mPixelShaderKey
index|[
name|pixelShaderKeyIndex
index|]
operator|.
name|outputIndex
argument_list|)
expr_stmt|;
block|}
specifier|const
name|unsigned
name|char
modifier|*
name|binary
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|stream
operator|->
name|data
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|unsigned
name|int
name|vertexShaderCount
init|=
name|stream
operator|->
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|vertexShaderIndex
init|=
literal|0
init|;
name|vertexShaderIndex
operator|<
name|vertexShaderCount
condition|;
name|vertexShaderIndex
operator|++
control|)
block|{
name|gl
operator|::
name|VertexFormat
name|inputLayout
index|[
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
index|]
decl_stmt|;
for|for
control|(
name|size_t
name|inputIndex
init|=
literal|0
init|;
name|inputIndex
operator|<
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
condition|;
name|inputIndex
operator|++
control|)
block|{
name|gl
operator|::
name|VertexFormat
modifier|*
name|vertexInput
init|=
operator|&
name|inputLayout
index|[
name|inputIndex
index|]
decl_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|vertexInput
operator|->
name|mType
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|vertexInput
operator|->
name|mNormalized
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|vertexInput
operator|->
name|mComponents
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readBool
argument_list|(
operator|&
name|vertexInput
operator|->
name|mPureInteger
argument_list|)
expr_stmt|;
block|}
name|unsigned
name|int
name|vertexShaderSize
init|=
name|stream
operator|->
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|vertexShaderFunction
init|=
name|binary
operator|+
name|stream
operator|->
name|offset
argument_list|()
decl_stmt|;
name|ShaderExecutable
modifier|*
name|shaderExecutable
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|mRenderer
operator|->
name|loadExecutable
argument_list|(
name|vertexShaderFunction
argument_list|,
name|vertexShaderSize
argument_list|,
name|SHADER_VERTEX
argument_list|,
name|mTransformFeedbackLinkedVaryings
argument_list|,
operator|(
name|mTransformFeedbackBufferMode
operator|==
name|GL_SEPARATE_ATTRIBS
operator|)
argument_list|,
operator|&
name|shaderExecutable
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|error
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|shaderExecutable
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Could not create vertex shader."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
comment|// generated converted input layout
name|GLenum
name|signature
index|[
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
index|]
decl_stmt|;
name|getInputLayoutSignature
argument_list|(
name|inputLayout
argument_list|,
name|signature
argument_list|)
expr_stmt|;
comment|// add new binary
name|mVertexExecutables
operator|.
name|push_back
argument_list|(
operator|new
name|VertexExecutable
argument_list|(
name|inputLayout
argument_list|,
name|signature
argument_list|,
name|shaderExecutable
argument_list|)
argument_list|)
expr_stmt|;
name|stream
operator|->
name|skip
argument_list|(
name|vertexShaderSize
argument_list|)
expr_stmt|;
block|}
specifier|const
name|size_t
name|pixelShaderCount
init|=
name|stream
operator|->
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|pixelShaderIndex
init|=
literal|0
init|;
name|pixelShaderIndex
operator|<
name|pixelShaderCount
condition|;
name|pixelShaderIndex
operator|++
control|)
block|{
specifier|const
name|size_t
name|outputCount
init|=
name|stream
operator|->
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
name|std
operator|::
name|vector
argument_list|<
name|GLenum
argument_list|>
name|outputs
argument_list|(
name|outputCount
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|outputIndex
init|=
literal|0
init|;
name|outputIndex
operator|<
name|outputCount
condition|;
name|outputIndex
operator|++
control|)
block|{
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|outputs
index|[
name|outputIndex
index|]
argument_list|)
expr_stmt|;
block|}
specifier|const
name|size_t
name|pixelShaderSize
init|=
name|stream
operator|->
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|pixelShaderFunction
init|=
name|binary
operator|+
name|stream
operator|->
name|offset
argument_list|()
decl_stmt|;
name|ShaderExecutable
modifier|*
name|shaderExecutable
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|mRenderer
operator|->
name|loadExecutable
argument_list|(
name|pixelShaderFunction
argument_list|,
name|pixelShaderSize
argument_list|,
name|SHADER_PIXEL
argument_list|,
name|mTransformFeedbackLinkedVaryings
argument_list|,
operator|(
name|mTransformFeedbackBufferMode
operator|==
name|GL_SEPARATE_ATTRIBS
operator|)
argument_list|,
operator|&
name|shaderExecutable
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|error
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|shaderExecutable
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Could not create pixel shader."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
comment|// add new binary
name|mPixelExecutables
operator|.
name|push_back
argument_list|(
operator|new
name|PixelExecutable
argument_list|(
name|outputs
argument_list|,
name|shaderExecutable
argument_list|)
argument_list|)
expr_stmt|;
name|stream
operator|->
name|skip
argument_list|(
name|pixelShaderSize
argument_list|)
expr_stmt|;
block|}
name|unsigned
name|int
name|geometryShaderSize
init|=
name|stream
operator|->
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|geometryShaderSize
operator|>
literal|0
condition|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|geometryShaderFunction
init|=
name|binary
operator|+
name|stream
operator|->
name|offset
argument_list|()
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|mRenderer
operator|->
name|loadExecutable
argument_list|(
name|geometryShaderFunction
argument_list|,
name|geometryShaderSize
argument_list|,
name|SHADER_GEOMETRY
argument_list|,
name|mTransformFeedbackLinkedVaryings
argument_list|,
operator|(
name|mTransformFeedbackBufferMode
operator|==
name|GL_SEPARATE_ATTRIBS
operator|)
argument_list|,
operator|&
name|mGeometryExecutable
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|error
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|mGeometryExecutable
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Could not create geometry shader."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
name|stream
operator|->
name|skip
argument_list|(
name|geometryShaderSize
argument_list|)
expr_stmt|;
block|}
name|GUID
name|binaryIdentifier
init|=
block|{
literal|0
block|}
decl_stmt|;
name|stream
operator|->
name|readBytes
argument_list|(
cast|reinterpret_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
operator|&
name|binaryIdentifier
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|GUID
argument_list|)
argument_list|)
expr_stmt|;
name|GUID
name|identifier
init|=
name|mRenderer
operator|->
name|getAdapterIdentifier
argument_list|()
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|identifier
argument_list|,
operator|&
name|binaryIdentifier
argument_list|,
sizeof|sizeof
argument_list|(
name|GUID
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Invalid program binary."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
name|initializeUniformStorage
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|LinkResult
argument_list|(
literal|true
argument_list|,
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
DECL|function|save
name|gl
operator|::
name|Error
name|ProgramD3D
operator|::
name|save
parameter_list|(
name|gl
operator|::
name|BinaryOutputStream
modifier|*
name|stream
parameter_list|)
block|{
name|stream
operator|->
name|writeInt
argument_list|(
name|mShaderVersion
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|mSamplersPS
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mSamplersPS
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|stream
operator|->
name|writeInt
argument_list|(
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|active
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|logicalTextureUnit
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|textureType
argument_list|)
expr_stmt|;
block|}
name|stream
operator|->
name|writeInt
argument_list|(
name|mSamplersVS
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mSamplersVS
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|stream
operator|->
name|writeInt
argument_list|(
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|active
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|logicalTextureUnit
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|textureType
argument_list|)
expr_stmt|;
block|}
name|stream
operator|->
name|writeInt
argument_list|(
name|mUsedVertexSamplerRange
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|mUsedPixelSamplerRange
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|mUniforms
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|uniformIndex
init|=
literal|0
init|;
name|uniformIndex
operator|<
name|mUniforms
operator|.
name|size
argument_list|()
condition|;
operator|++
name|uniformIndex
control|)
block|{
specifier|const
name|gl
operator|::
name|LinkedUniform
modifier|&
name|uniform
init|=
operator|*
name|mUniforms
index|[
name|uniformIndex
index|]
decl_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|uniform
operator|.
name|type
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|uniform
operator|.
name|precision
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeString
argument_list|(
name|uniform
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|uniform
operator|.
name|arraySize
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|uniform
operator|.
name|blockIndex
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|uniform
operator|.
name|blockInfo
operator|.
name|offset
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|uniform
operator|.
name|blockInfo
operator|.
name|arrayStride
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|uniform
operator|.
name|blockInfo
operator|.
name|matrixStride
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|uniform
operator|.
name|blockInfo
operator|.
name|isRowMajorMatrix
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|uniform
operator|.
name|psRegisterIndex
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|uniform
operator|.
name|vsRegisterIndex
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|uniform
operator|.
name|registerCount
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|uniform
operator|.
name|registerElement
argument_list|)
expr_stmt|;
block|}
name|stream
operator|->
name|writeInt
argument_list|(
name|mUniformIndex
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mUniformIndex
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|stream
operator|->
name|writeString
argument_list|(
name|mUniformIndex
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|mUniformIndex
index|[
name|i
index|]
operator|.
name|element
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|mUniformIndex
index|[
name|i
index|]
operator|.
name|index
argument_list|)
expr_stmt|;
block|}
name|stream
operator|->
name|writeInt
argument_list|(
name|mUniformBlocks
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|uniformBlockIndex
init|=
literal|0
init|;
name|uniformBlockIndex
operator|<
name|mUniformBlocks
operator|.
name|size
argument_list|()
condition|;
operator|++
name|uniformBlockIndex
control|)
block|{
specifier|const
name|gl
operator|::
name|UniformBlock
modifier|&
name|uniformBlock
init|=
operator|*
name|mUniformBlocks
index|[
name|uniformBlockIndex
index|]
decl_stmt|;
name|stream
operator|->
name|writeString
argument_list|(
name|uniformBlock
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|uniformBlock
operator|.
name|elementIndex
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|uniformBlock
operator|.
name|dataSize
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|uniformBlock
operator|.
name|memberUniformIndexes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|blockMemberIndex
init|=
literal|0
init|;
name|blockMemberIndex
operator|<
name|uniformBlock
operator|.
name|memberUniformIndexes
operator|.
name|size
argument_list|()
condition|;
name|blockMemberIndex
operator|++
control|)
block|{
name|stream
operator|->
name|writeInt
argument_list|(
name|uniformBlock
operator|.
name|memberUniformIndexes
index|[
name|blockMemberIndex
index|]
argument_list|)
expr_stmt|;
block|}
name|stream
operator|->
name|writeInt
argument_list|(
name|uniformBlock
operator|.
name|psRegisterIndex
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|uniformBlock
operator|.
name|vsRegisterIndex
argument_list|)
expr_stmt|;
block|}
name|stream
operator|->
name|writeInt
argument_list|(
name|mTransformFeedbackBufferMode
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|mTransformFeedbackLinkedVaryings
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mTransformFeedbackLinkedVaryings
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|gl
operator|::
name|LinkedVarying
modifier|&
name|varying
init|=
name|mTransformFeedbackLinkedVaryings
index|[
name|i
index|]
decl_stmt|;
name|stream
operator|->
name|writeString
argument_list|(
name|varying
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|varying
operator|.
name|type
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|varying
operator|.
name|size
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeString
argument_list|(
name|varying
operator|.
name|semanticName
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|varying
operator|.
name|semanticIndex
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|varying
operator|.
name|semanticIndexCount
argument_list|)
expr_stmt|;
block|}
name|stream
operator|->
name|writeString
argument_list|(
name|mVertexHLSL
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|mVertexWorkarounds
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeString
argument_list|(
name|mPixelHLSL
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|mPixelWorkarounds
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|mUsesFragDepth
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|mUsesPointSize
argument_list|)
expr_stmt|;
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|PixelShaderOutputVariable
argument_list|>
modifier|&
name|pixelShaderKey
init|=
name|mPixelShaderKey
decl_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|pixelShaderKey
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|pixelShaderKeyIndex
init|=
literal|0
init|;
name|pixelShaderKeyIndex
operator|<
name|pixelShaderKey
operator|.
name|size
argument_list|()
condition|;
name|pixelShaderKeyIndex
operator|++
control|)
block|{
specifier|const
name|PixelShaderOutputVariable
modifier|&
name|variable
init|=
name|pixelShaderKey
index|[
name|pixelShaderKeyIndex
index|]
decl_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|variable
operator|.
name|type
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeString
argument_list|(
name|variable
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeString
argument_list|(
name|variable
operator|.
name|source
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|variable
operator|.
name|outputIndex
argument_list|)
expr_stmt|;
block|}
name|stream
operator|->
name|writeInt
argument_list|(
name|mVertexExecutables
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|vertexExecutableIndex
init|=
literal|0
init|;
name|vertexExecutableIndex
operator|<
name|mVertexExecutables
operator|.
name|size
argument_list|()
condition|;
name|vertexExecutableIndex
operator|++
control|)
block|{
name|VertexExecutable
modifier|*
name|vertexExecutable
init|=
name|mVertexExecutables
index|[
name|vertexExecutableIndex
index|]
decl_stmt|;
for|for
control|(
name|size_t
name|inputIndex
init|=
literal|0
init|;
name|inputIndex
operator|<
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
condition|;
name|inputIndex
operator|++
control|)
block|{
specifier|const
name|gl
operator|::
name|VertexFormat
modifier|&
name|vertexInput
init|=
name|vertexExecutable
operator|->
name|inputs
argument_list|()
index|[
name|inputIndex
index|]
decl_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|vertexInput
operator|.
name|mType
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|vertexInput
operator|.
name|mNormalized
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|vertexInput
operator|.
name|mComponents
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|vertexInput
operator|.
name|mPureInteger
argument_list|)
expr_stmt|;
block|}
name|size_t
name|vertexShaderSize
init|=
name|vertexExecutable
operator|->
name|shaderExecutable
argument_list|()
operator|->
name|getLength
argument_list|()
decl_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|vertexShaderSize
argument_list|)
expr_stmt|;
specifier|const
name|uint8_t
modifier|*
name|vertexBlob
init|=
name|vertexExecutable
operator|->
name|shaderExecutable
argument_list|()
operator|->
name|getFunction
argument_list|()
decl_stmt|;
name|stream
operator|->
name|writeBytes
argument_list|(
name|vertexBlob
argument_list|,
name|vertexShaderSize
argument_list|)
expr_stmt|;
block|}
name|stream
operator|->
name|writeInt
argument_list|(
name|mPixelExecutables
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|pixelExecutableIndex
init|=
literal|0
init|;
name|pixelExecutableIndex
operator|<
name|mPixelExecutables
operator|.
name|size
argument_list|()
condition|;
name|pixelExecutableIndex
operator|++
control|)
block|{
name|PixelExecutable
modifier|*
name|pixelExecutable
init|=
name|mPixelExecutables
index|[
name|pixelExecutableIndex
index|]
decl_stmt|;
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|GLenum
argument_list|>
name|outputs
init|=
name|pixelExecutable
operator|->
name|outputSignature
argument_list|()
decl_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|outputs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|outputIndex
init|=
literal|0
init|;
name|outputIndex
operator|<
name|outputs
operator|.
name|size
argument_list|()
condition|;
name|outputIndex
operator|++
control|)
block|{
name|stream
operator|->
name|writeInt
argument_list|(
name|outputs
index|[
name|outputIndex
index|]
argument_list|)
expr_stmt|;
block|}
name|size_t
name|pixelShaderSize
init|=
name|pixelExecutable
operator|->
name|shaderExecutable
argument_list|()
operator|->
name|getLength
argument_list|()
decl_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|pixelShaderSize
argument_list|)
expr_stmt|;
specifier|const
name|uint8_t
modifier|*
name|pixelBlob
init|=
name|pixelExecutable
operator|->
name|shaderExecutable
argument_list|()
operator|->
name|getFunction
argument_list|()
decl_stmt|;
name|stream
operator|->
name|writeBytes
argument_list|(
name|pixelBlob
argument_list|,
name|pixelShaderSize
argument_list|)
expr_stmt|;
block|}
name|size_t
name|geometryShaderSize
init|=
operator|(
name|mGeometryExecutable
operator|!=
name|NULL
operator|)
condition|?
name|mGeometryExecutable
operator|->
name|getLength
argument_list|()
else|:
literal|0
decl_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|geometryShaderSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|mGeometryExecutable
operator|!=
name|NULL
operator|&&
name|geometryShaderSize
operator|>
literal|0
condition|)
block|{
specifier|const
name|uint8_t
modifier|*
name|geometryBlob
init|=
name|mGeometryExecutable
operator|->
name|getFunction
argument_list|()
decl_stmt|;
name|stream
operator|->
name|writeBytes
argument_list|(
name|geometryBlob
argument_list|,
name|geometryShaderSize
argument_list|)
expr_stmt|;
block|}
name|GUID
name|binaryIdentifier
init|=
name|mRenderer
operator|->
name|getAdapterIdentifier
argument_list|()
decl_stmt|;
name|stream
operator|->
name|writeBytes
argument_list|(
cast|reinterpret_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
operator|&
name|binaryIdentifier
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|GUID
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|getPixelExecutableForFramebuffer
name|gl
operator|::
name|Error
name|ProgramD3D
operator|::
name|getPixelExecutableForFramebuffer
parameter_list|(
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|fbo
parameter_list|,
name|ShaderExecutable
modifier|*
modifier|*
name|outExecutable
parameter_list|)
block|{
name|std
operator|::
name|vector
argument_list|<
name|GLenum
argument_list|>
name|outputs
decl_stmt|;
specifier|const
name|gl
operator|::
name|ColorbufferInfo
modifier|&
name|colorbuffers
init|=
name|fbo
operator|->
name|getColorbuffersForRender
argument_list|(
name|mRenderer
operator|->
name|getWorkarounds
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|colorAttachment
init|=
literal|0
init|;
name|colorAttachment
operator|<
name|colorbuffers
operator|.
name|size
argument_list|()
condition|;
operator|++
name|colorAttachment
control|)
block|{
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|colorbuffer
init|=
name|colorbuffers
index|[
name|colorAttachment
index|]
decl_stmt|;
if|if
condition|(
name|colorbuffer
condition|)
block|{
name|outputs
operator|.
name|push_back
argument_list|(
name|colorbuffer
operator|->
name|getBinding
argument_list|()
operator|==
name|GL_BACK
condition|?
name|GL_COLOR_ATTACHMENT0
else|:
name|colorbuffer
operator|->
name|getBinding
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outputs
operator|.
name|push_back
argument_list|(
name|GL_NONE
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|getPixelExecutableForOutputLayout
argument_list|(
name|outputs
argument_list|,
name|outExecutable
argument_list|)
return|;
block|}
DECL|function|getPixelExecutableForOutputLayout
name|gl
operator|::
name|Error
name|ProgramD3D
operator|::
name|getPixelExecutableForOutputLayout
parameter_list|(
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|GLenum
argument_list|>
modifier|&
name|outputSignature
parameter_list|,
name|ShaderExecutable
modifier|*
modifier|*
name|outExectuable
parameter_list|)
block|{
for|for
control|(
name|size_t
name|executableIndex
init|=
literal|0
init|;
name|executableIndex
operator|<
name|mPixelExecutables
operator|.
name|size
argument_list|()
condition|;
name|executableIndex
operator|++
control|)
block|{
if|if
condition|(
name|mPixelExecutables
index|[
name|executableIndex
index|]
operator|->
name|matchesSignature
argument_list|(
name|outputSignature
argument_list|)
condition|)
block|{
operator|*
name|outExectuable
operator|=
name|mPixelExecutables
index|[
name|executableIndex
index|]
operator|->
name|shaderExecutable
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
block|}
name|std
operator|::
name|string
name|finalPixelHLSL
init|=
name|mDynamicHLSL
operator|->
name|generatePixelShaderForOutputSignature
argument_list|(
name|mPixelHLSL
argument_list|,
name|mPixelShaderKey
argument_list|,
name|mUsesFragDepth
argument_list|,
name|outputSignature
argument_list|)
decl_stmt|;
comment|// Generate new pixel executable
name|gl
operator|::
name|InfoLog
name|tempInfoLog
decl_stmt|;
name|ShaderExecutable
modifier|*
name|pixelExecutable
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|mRenderer
operator|->
name|compileToExecutable
argument_list|(
name|tempInfoLog
argument_list|,
name|finalPixelHLSL
argument_list|,
name|SHADER_PIXEL
argument_list|,
name|mTransformFeedbackLinkedVaryings
argument_list|,
operator|(
name|mTransformFeedbackBufferMode
operator|==
name|GL_SEPARATE_ATTRIBS
operator|)
argument_list|,
name|mPixelWorkarounds
argument_list|,
operator|&
name|pixelExecutable
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
operator|!
name|pixelExecutable
condition|)
block|{
name|std
operator|::
name|vector
argument_list|<
name|char
argument_list|>
name|tempCharBuffer
argument_list|(
name|tempInfoLog
operator|.
name|getLength
argument_list|()
operator|+
literal|3
argument_list|)
decl_stmt|;
name|tempInfoLog
operator|.
name|getLog
argument_list|(
name|tempInfoLog
operator|.
name|getLength
argument_list|()
argument_list|,
name|NULL
argument_list|,
operator|&
name|tempCharBuffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ERR
argument_list|(
literal|"Error compiling dynamic pixel executable:\n%s\n"
argument_list|,
operator|&
name|tempCharBuffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mPixelExecutables
operator|.
name|push_back
argument_list|(
operator|new
name|PixelExecutable
argument_list|(
name|outputSignature
argument_list|,
name|pixelExecutable
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|outExectuable
operator|=
name|pixelExecutable
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|getVertexExecutableForInputLayout
name|gl
operator|::
name|Error
name|ProgramD3D
operator|::
name|getVertexExecutableForInputLayout
parameter_list|(
specifier|const
name|gl
operator|::
name|VertexFormat
name|inputLayout
index|[
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
index|]
parameter_list|,
name|ShaderExecutable
modifier|*
modifier|*
name|outExectuable
parameter_list|)
block|{
name|GLenum
name|signature
index|[
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
index|]
decl_stmt|;
name|getInputLayoutSignature
argument_list|(
name|inputLayout
argument_list|,
name|signature
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|executableIndex
init|=
literal|0
init|;
name|executableIndex
operator|<
name|mVertexExecutables
operator|.
name|size
argument_list|()
condition|;
name|executableIndex
operator|++
control|)
block|{
if|if
condition|(
name|mVertexExecutables
index|[
name|executableIndex
index|]
operator|->
name|matchesSignature
argument_list|(
name|signature
argument_list|)
condition|)
block|{
operator|*
name|outExectuable
operator|=
name|mVertexExecutables
index|[
name|executableIndex
index|]
operator|->
name|shaderExecutable
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
block|}
comment|// Generate new dynamic layout with attribute conversions
name|std
operator|::
name|string
name|finalVertexHLSL
init|=
name|mDynamicHLSL
operator|->
name|generateVertexShaderForInputLayout
argument_list|(
name|mVertexHLSL
argument_list|,
name|inputLayout
argument_list|,
name|mShaderAttributes
argument_list|)
decl_stmt|;
comment|// Generate new vertex executable
name|gl
operator|::
name|InfoLog
name|tempInfoLog
decl_stmt|;
name|ShaderExecutable
modifier|*
name|vertexExecutable
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|mRenderer
operator|->
name|compileToExecutable
argument_list|(
name|tempInfoLog
argument_list|,
name|finalVertexHLSL
argument_list|,
name|SHADER_VERTEX
argument_list|,
name|mTransformFeedbackLinkedVaryings
argument_list|,
operator|(
name|mTransformFeedbackBufferMode
operator|==
name|GL_SEPARATE_ATTRIBS
operator|)
argument_list|,
name|mVertexWorkarounds
argument_list|,
operator|&
name|vertexExecutable
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
operator|!
name|vertexExecutable
condition|)
block|{
name|std
operator|::
name|vector
argument_list|<
name|char
argument_list|>
name|tempCharBuffer
argument_list|(
name|tempInfoLog
operator|.
name|getLength
argument_list|()
operator|+
literal|3
argument_list|)
decl_stmt|;
name|tempInfoLog
operator|.
name|getLog
argument_list|(
name|tempInfoLog
operator|.
name|getLength
argument_list|()
argument_list|,
name|NULL
argument_list|,
operator|&
name|tempCharBuffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ERR
argument_list|(
literal|"Error compiling dynamic vertex executable:\n%s\n"
argument_list|,
operator|&
name|tempCharBuffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mVertexExecutables
operator|.
name|push_back
argument_list|(
operator|new
name|VertexExecutable
argument_list|(
name|inputLayout
argument_list|,
name|signature
argument_list|,
name|vertexExecutable
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|outExectuable
operator|=
name|vertexExecutable
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|compileProgramExecutables
name|gl
operator|::
name|LinkResult
name|ProgramD3D
operator|::
name|compileProgramExecutables
parameter_list|(
name|gl
operator|::
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
name|gl
operator|::
name|Shader
modifier|*
name|fragmentShader
parameter_list|,
name|gl
operator|::
name|Shader
modifier|*
name|vertexShader
parameter_list|,
name|int
name|registers
parameter_list|)
block|{
name|ShaderD3D
modifier|*
name|vertexShaderD3D
init|=
name|ShaderD3D
operator|::
name|makeShaderD3D
argument_list|(
name|vertexShader
operator|->
name|getImplementation
argument_list|()
argument_list|)
decl_stmt|;
name|ShaderD3D
modifier|*
name|fragmentShaderD3D
init|=
name|ShaderD3D
operator|::
name|makeShaderD3D
argument_list|(
name|fragmentShader
operator|->
name|getImplementation
argument_list|()
argument_list|)
decl_stmt|;
name|gl
operator|::
name|VertexFormat
name|defaultInputLayout
index|[
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
index|]
decl_stmt|;
name|GetDefaultInputLayoutFromShader
argument_list|(
name|vertexShader
operator|->
name|getActiveAttributes
argument_list|()
argument_list|,
name|defaultInputLayout
argument_list|)
expr_stmt|;
name|ShaderExecutable
modifier|*
name|defaultVertexExecutable
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|getVertexExecutableForInputLayout
argument_list|(
name|defaultInputLayout
argument_list|,
operator|&
name|defaultVertexExecutable
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|error
argument_list|)
return|;
block|}
name|std
operator|::
name|vector
argument_list|<
name|GLenum
argument_list|>
name|defaultPixelOutput
init|=
name|GetDefaultOutputLayoutFromShader
argument_list|(
name|getPixelShaderKey
argument_list|()
argument_list|)
decl_stmt|;
name|ShaderExecutable
modifier|*
name|defaultPixelExecutable
init|=
name|NULL
decl_stmt|;
name|error
operator|=
name|getPixelExecutableForOutputLayout
argument_list|(
name|defaultPixelOutput
argument_list|,
operator|&
name|defaultPixelExecutable
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|error
argument_list|)
return|;
block|}
if|if
condition|(
name|usesGeometryShader
argument_list|()
condition|)
block|{
name|std
operator|::
name|string
name|geometryHLSL
init|=
name|mDynamicHLSL
operator|->
name|generateGeometryShaderHLSL
argument_list|(
name|registers
argument_list|,
name|fragmentShaderD3D
argument_list|,
name|vertexShaderD3D
argument_list|)
decl_stmt|;
name|error
operator|=
name|mRenderer
operator|->
name|compileToExecutable
argument_list|(
name|infoLog
argument_list|,
name|geometryHLSL
argument_list|,
name|SHADER_GEOMETRY
argument_list|,
name|mTransformFeedbackLinkedVaryings
argument_list|,
operator|(
name|mTransformFeedbackBufferMode
operator|==
name|GL_SEPARATE_ATTRIBS
operator|)
argument_list|,
name|ANGLE_D3D_WORKAROUND_NONE
argument_list|,
operator|&
name|mGeometryExecutable
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|error
argument_list|)
return|;
block|}
block|}
if|#
directive|if
name|ANGLE_SHADER_DEBUG_INFO
operator|==
name|ANGLE_ENABLED
if|if
condition|(
name|usesGeometryShader
argument_list|()
operator|&&
name|mGeometryExecutable
condition|)
block|{
comment|// Geometry shaders are currently only used internally, so there is no corresponding shader object at the interface level
comment|// For now the geometry shader debug info is pre-pended to the vertex shader, this is a bit of a clutch
name|vertexShaderD3D
operator|->
name|appendDebugInfo
argument_list|(
literal|"// GEOMETRY SHADER BEGIN\n\n"
argument_list|)
expr_stmt|;
name|vertexShaderD3D
operator|->
name|appendDebugInfo
argument_list|(
name|mGeometryExecutable
operator|->
name|getDebugInfo
argument_list|()
argument_list|)
expr_stmt|;
name|vertexShaderD3D
operator|->
name|appendDebugInfo
argument_list|(
literal|"\nGEOMETRY SHADER END\n\n\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|defaultVertexExecutable
condition|)
block|{
name|vertexShaderD3D
operator|->
name|appendDebugInfo
argument_list|(
name|defaultVertexExecutable
operator|->
name|getDebugInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|defaultPixelExecutable
condition|)
block|{
name|fragmentShaderD3D
operator|->
name|appendDebugInfo
argument_list|(
name|defaultPixelExecutable
operator|->
name|getDebugInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|bool
name|linkSuccess
init|=
operator|(
name|defaultVertexExecutable
operator|&&
name|defaultPixelExecutable
operator|&&
operator|(
operator|!
name|usesGeometryShader
argument_list|()
operator|||
name|mGeometryExecutable
operator|)
operator|)
decl_stmt|;
return|return
name|gl
operator|::
name|LinkResult
argument_list|(
name|linkSuccess
argument_list|,
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
DECL|function|link
name|gl
operator|::
name|LinkResult
name|ProgramD3D
operator|::
name|link
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|gl
operator|::
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
name|gl
operator|::
name|Shader
modifier|*
name|fragmentShader
parameter_list|,
name|gl
operator|::
name|Shader
modifier|*
name|vertexShader
parameter_list|,
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|std
operator|::
name|string
argument_list|>
modifier|&
name|transformFeedbackVaryings
parameter_list|,
name|GLenum
name|transformFeedbackBufferMode
parameter_list|,
name|int
modifier|*
name|registers
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|gl
operator|::
name|LinkedVarying
argument_list|>
modifier|*
name|linkedVaryings
parameter_list|,
name|std
operator|::
name|map
argument_list|<
name|int
argument_list|,
name|gl
operator|::
name|VariableLocation
argument_list|>
modifier|*
name|outputVariables
parameter_list|)
block|{
name|ShaderD3D
modifier|*
name|vertexShaderD3D
init|=
name|ShaderD3D
operator|::
name|makeShaderD3D
argument_list|(
name|vertexShader
operator|->
name|getImplementation
argument_list|()
argument_list|)
decl_stmt|;
name|ShaderD3D
modifier|*
name|fragmentShaderD3D
init|=
name|ShaderD3D
operator|::
name|makeShaderD3D
argument_list|(
name|fragmentShader
operator|->
name|getImplementation
argument_list|()
argument_list|)
decl_stmt|;
name|mSamplersPS
operator|.
name|resize
argument_list|(
name|data
operator|.
name|caps
operator|->
name|maxTextureImageUnits
argument_list|)
expr_stmt|;
name|mSamplersVS
operator|.
name|resize
argument_list|(
name|data
operator|.
name|caps
operator|->
name|maxVertexTextureImageUnits
argument_list|)
expr_stmt|;
name|mTransformFeedbackBufferMode
operator|=
name|transformFeedbackBufferMode
expr_stmt|;
name|mPixelHLSL
operator|=
name|fragmentShaderD3D
operator|->
name|getTranslatedSource
argument_list|()
expr_stmt|;
name|mPixelWorkarounds
operator|=
name|fragmentShaderD3D
operator|->
name|getD3DWorkarounds
argument_list|()
expr_stmt|;
name|mVertexHLSL
operator|=
name|vertexShaderD3D
operator|->
name|getTranslatedSource
argument_list|()
expr_stmt|;
name|mVertexWorkarounds
operator|=
name|vertexShaderD3D
operator|->
name|getD3DWorkarounds
argument_list|()
expr_stmt|;
name|mShaderVersion
operator|=
name|vertexShaderD3D
operator|->
name|getShaderVersion
argument_list|()
expr_stmt|;
comment|// Map the varyings to the register file
name|VaryingPacking
name|packing
init|=
block|{
name|NULL
block|}
decl_stmt|;
operator|*
name|registers
operator|=
name|mDynamicHLSL
operator|->
name|packVaryings
argument_list|(
name|infoLog
argument_list|,
name|packing
argument_list|,
name|fragmentShaderD3D
argument_list|,
name|vertexShaderD3D
argument_list|,
name|transformFeedbackVaryings
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|registers
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|gl
operator|::
name|ProgramBinary
operator|::
name|linkVaryings
argument_list|(
name|infoLog
argument_list|,
name|fragmentShader
argument_list|,
name|vertexShader
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|mDynamicHLSL
operator|->
name|generateShaderLinkHLSL
argument_list|(
name|data
argument_list|,
name|infoLog
argument_list|,
operator|*
name|registers
argument_list|,
name|packing
argument_list|,
name|mPixelHLSL
argument_list|,
name|mVertexHLSL
argument_list|,
name|fragmentShaderD3D
argument_list|,
name|vertexShaderD3D
argument_list|,
name|transformFeedbackVaryings
argument_list|,
name|linkedVaryings
argument_list|,
name|outputVariables
argument_list|,
operator|&
name|mPixelShaderKey
argument_list|,
operator|&
name|mUsesFragDepth
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
name|mUsesPointSize
operator|=
name|vertexShaderD3D
operator|->
name|usesPointSize
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|LinkResult
argument_list|(
literal|true
argument_list|,
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
DECL|function|getInputLayoutSignature
name|void
name|ProgramD3D
operator|::
name|getInputLayoutSignature
parameter_list|(
specifier|const
name|gl
operator|::
name|VertexFormat
name|inputLayout
index|[]
parameter_list|,
name|GLenum
name|signature
index|[]
parameter_list|)
specifier|const
block|{
name|mDynamicHLSL
operator|->
name|getInputLayoutSignature
argument_list|(
name|inputLayout
argument_list|,
name|signature
argument_list|)
expr_stmt|;
block|}
DECL|function|initializeUniformStorage
name|void
name|ProgramD3D
operator|::
name|initializeUniformStorage
parameter_list|()
block|{
comment|// Compute total default block size
name|unsigned
name|int
name|vertexRegisters
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|fragmentRegisters
init|=
literal|0
decl_stmt|;
for|for
control|(
name|size_t
name|uniformIndex
init|=
literal|0
init|;
name|uniformIndex
operator|<
name|mUniforms
operator|.
name|size
argument_list|()
condition|;
name|uniformIndex
operator|++
control|)
block|{
specifier|const
name|gl
operator|::
name|LinkedUniform
modifier|&
name|uniform
init|=
operator|*
name|mUniforms
index|[
name|uniformIndex
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|gl
operator|::
name|IsSampler
argument_list|(
name|uniform
operator|.
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|uniform
operator|.
name|isReferencedByVertexShader
argument_list|()
condition|)
block|{
name|vertexRegisters
operator|=
name|std
operator|::
name|max
argument_list|(
name|vertexRegisters
argument_list|,
name|uniform
operator|.
name|vsRegisterIndex
operator|+
name|uniform
operator|.
name|registerCount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uniform
operator|.
name|isReferencedByFragmentShader
argument_list|()
condition|)
block|{
name|fragmentRegisters
operator|=
name|std
operator|::
name|max
argument_list|(
name|fragmentRegisters
argument_list|,
name|uniform
operator|.
name|psRegisterIndex
operator|+
name|uniform
operator|.
name|registerCount
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|mVertexUniformStorage
operator|=
name|mRenderer
operator|->
name|createUniformStorage
argument_list|(
name|vertexRegisters
operator|*
literal|16u
argument_list|)
expr_stmt|;
name|mFragmentUniformStorage
operator|=
name|mRenderer
operator|->
name|createUniformStorage
argument_list|(
name|fragmentRegisters
operator|*
literal|16u
argument_list|)
expr_stmt|;
block|}
DECL|function|applyUniforms
name|gl
operator|::
name|Error
name|ProgramD3D
operator|::
name|applyUniforms
parameter_list|()
block|{
name|updateSamplerMapping
argument_list|()
expr_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|mRenderer
operator|->
name|applyUniforms
argument_list|(
operator|*
name|this
argument_list|,
name|mUniforms
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
for|for
control|(
name|size_t
name|uniformIndex
init|=
literal|0
init|;
name|uniformIndex
operator|<
name|mUniforms
operator|.
name|size
argument_list|()
condition|;
name|uniformIndex
operator|++
control|)
block|{
name|mUniforms
index|[
name|uniformIndex
index|]
operator|->
name|dirty
operator|=
literal|false
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|applyUniformBuffers
name|gl
operator|::
name|Error
name|ProgramD3D
operator|::
name|applyUniformBuffers
parameter_list|(
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|gl
operator|::
name|Buffer
operator|*
argument_list|>
name|boundBuffers
parameter_list|,
specifier|const
name|gl
operator|::
name|Caps
modifier|&
name|caps
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|boundBuffers
operator|.
name|size
argument_list|()
operator|==
name|mUniformBlocks
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|gl
operator|::
name|Buffer
modifier|*
name|vertexUniformBuffers
index|[
name|gl
operator|::
name|IMPLEMENTATION_MAX_VERTEX_SHADER_UNIFORM_BUFFERS
index|]
init|=
block|{
name|NULL
block|}
decl_stmt|;
specifier|const
name|gl
operator|::
name|Buffer
modifier|*
name|fragmentUniformBuffers
index|[
name|gl
operator|::
name|IMPLEMENTATION_MAX_FRAGMENT_SHADER_UNIFORM_BUFFERS
index|]
init|=
block|{
name|NULL
block|}
decl_stmt|;
specifier|const
name|unsigned
name|int
name|reservedBuffersInVS
init|=
name|mRenderer
operator|->
name|getReservedVertexUniformBuffers
argument_list|()
decl_stmt|;
specifier|const
name|unsigned
name|int
name|reservedBuffersInFS
init|=
name|mRenderer
operator|->
name|getReservedFragmentUniformBuffers
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|uniformBlockIndex
init|=
literal|0
init|;
name|uniformBlockIndex
operator|<
name|mUniformBlocks
operator|.
name|size
argument_list|()
condition|;
name|uniformBlockIndex
operator|++
control|)
block|{
name|gl
operator|::
name|UniformBlock
modifier|*
name|uniformBlock
init|=
name|mUniformBlocks
index|[
name|uniformBlockIndex
index|]
decl_stmt|;
name|gl
operator|::
name|Buffer
modifier|*
name|uniformBuffer
init|=
name|boundBuffers
index|[
name|uniformBlockIndex
index|]
decl_stmt|;
name|ASSERT
argument_list|(
name|uniformBlock
operator|&&
name|uniformBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|uniformBuffer
operator|->
name|getSize
argument_list|()
operator|<
name|uniformBlock
operator|->
name|dataSize
condition|)
block|{
comment|// undefined behaviour
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"It is undefined behaviour to use a uniform buffer that is too small."
argument_list|)
return|;
block|}
comment|// Unnecessary to apply an unreferenced standard or shared UBO
if|if
condition|(
operator|!
name|uniformBlock
operator|->
name|isReferencedByVertexShader
argument_list|()
operator|&&
operator|!
name|uniformBlock
operator|->
name|isReferencedByFragmentShader
argument_list|()
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|uniformBlock
operator|->
name|isReferencedByVertexShader
argument_list|()
condition|)
block|{
name|unsigned
name|int
name|registerIndex
init|=
name|uniformBlock
operator|->
name|vsRegisterIndex
operator|-
name|reservedBuffersInVS
decl_stmt|;
name|ASSERT
argument_list|(
name|vertexUniformBuffers
index|[
name|registerIndex
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|registerIndex
operator|<
name|caps
operator|.
name|maxVertexUniformBlocks
argument_list|)
expr_stmt|;
name|vertexUniformBuffers
index|[
name|registerIndex
index|]
operator|=
name|uniformBuffer
expr_stmt|;
block|}
if|if
condition|(
name|uniformBlock
operator|->
name|isReferencedByFragmentShader
argument_list|()
condition|)
block|{
name|unsigned
name|int
name|registerIndex
init|=
name|uniformBlock
operator|->
name|psRegisterIndex
operator|-
name|reservedBuffersInFS
decl_stmt|;
name|ASSERT
argument_list|(
name|fragmentUniformBuffers
index|[
name|registerIndex
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|registerIndex
operator|<
name|caps
operator|.
name|maxFragmentUniformBlocks
argument_list|)
expr_stmt|;
name|fragmentUniformBuffers
index|[
name|registerIndex
index|]
operator|=
name|uniformBuffer
expr_stmt|;
block|}
block|}
return|return
name|mRenderer
operator|->
name|setUniformBuffers
argument_list|(
name|vertexUniformBuffers
argument_list|,
name|fragmentUniformBuffers
argument_list|)
return|;
block|}
DECL|function|assignUniformBlockRegister
name|bool
name|ProgramD3D
operator|::
name|assignUniformBlockRegister
parameter_list|(
name|gl
operator|::
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
name|gl
operator|::
name|UniformBlock
modifier|*
name|uniformBlock
parameter_list|,
name|GLenum
name|shader
parameter_list|,
name|unsigned
name|int
name|registerIndex
parameter_list|,
specifier|const
name|gl
operator|::
name|Caps
modifier|&
name|caps
parameter_list|)
block|{
if|if
condition|(
name|shader
operator|==
name|GL_VERTEX_SHADER
condition|)
block|{
name|uniformBlock
operator|->
name|vsRegisterIndex
operator|=
name|registerIndex
expr_stmt|;
if|if
condition|(
name|registerIndex
operator|-
name|mRenderer
operator|->
name|getReservedVertexUniformBuffers
argument_list|()
operator|>=
name|caps
operator|.
name|maxVertexUniformBlocks
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Vertex shader uniform block count exceed GL_MAX_VERTEX_UNIFORM_BLOCKS (%u)"
argument_list|,
name|caps
operator|.
name|maxVertexUniformBlocks
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|shader
operator|==
name|GL_FRAGMENT_SHADER
condition|)
block|{
name|uniformBlock
operator|->
name|psRegisterIndex
operator|=
name|registerIndex
expr_stmt|;
if|if
condition|(
name|registerIndex
operator|-
name|mRenderer
operator|->
name|getReservedFragmentUniformBuffers
argument_list|()
operator|>=
name|caps
operator|.
name|maxFragmentUniformBlocks
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Fragment shader uniform block count exceed GL_MAX_FRAGMENT_UNIFORM_BLOCKS (%u)"
argument_list|,
name|caps
operator|.
name|maxFragmentUniformBlocks
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|dirtyAllUniforms
name|void
name|ProgramD3D
operator|::
name|dirtyAllUniforms
parameter_list|()
block|{
name|unsigned
name|int
name|numUniforms
init|=
name|mUniforms
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
name|numUniforms
condition|;
name|index
operator|++
control|)
block|{
name|mUniforms
index|[
name|index
index|]
operator|->
name|dirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|setUniform1fv
name|void
name|ProgramD3D
operator|::
name|setUniform1fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|setUniform
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|,
name|GL_FLOAT
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform2fv
name|void
name|ProgramD3D
operator|::
name|setUniform2fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|setUniform
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|,
name|GL_FLOAT_VEC2
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform3fv
name|void
name|ProgramD3D
operator|::
name|setUniform3fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|setUniform
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|,
name|GL_FLOAT_VEC3
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform4fv
name|void
name|ProgramD3D
operator|::
name|setUniform4fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|setUniform
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|,
name|GL_FLOAT_VEC4
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix2fv
name|void
name|ProgramD3D
operator|::
name|setUniformMatrix2fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
name|setUniformMatrixfv
argument_list|<
literal|2
argument_list|,
literal|2
argument_list|>
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|value
argument_list|,
name|GL_FLOAT_MAT2
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix3fv
name|void
name|ProgramD3D
operator|::
name|setUniformMatrix3fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
name|setUniformMatrixfv
argument_list|<
literal|3
argument_list|,
literal|3
argument_list|>
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|value
argument_list|,
name|GL_FLOAT_MAT3
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix4fv
name|void
name|ProgramD3D
operator|::
name|setUniformMatrix4fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
name|setUniformMatrixfv
argument_list|<
literal|4
argument_list|,
literal|4
argument_list|>
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|value
argument_list|,
name|GL_FLOAT_MAT4
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix2x3fv
name|void
name|ProgramD3D
operator|::
name|setUniformMatrix2x3fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
name|setUniformMatrixfv
argument_list|<
literal|2
argument_list|,
literal|3
argument_list|>
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|value
argument_list|,
name|GL_FLOAT_MAT2x3
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix3x2fv
name|void
name|ProgramD3D
operator|::
name|setUniformMatrix3x2fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
name|setUniformMatrixfv
argument_list|<
literal|3
argument_list|,
literal|2
argument_list|>
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|value
argument_list|,
name|GL_FLOAT_MAT3x2
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix2x4fv
name|void
name|ProgramD3D
operator|::
name|setUniformMatrix2x4fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
name|setUniformMatrixfv
argument_list|<
literal|2
argument_list|,
literal|4
argument_list|>
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|value
argument_list|,
name|GL_FLOAT_MAT2x4
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix4x2fv
name|void
name|ProgramD3D
operator|::
name|setUniformMatrix4x2fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
name|setUniformMatrixfv
argument_list|<
literal|4
argument_list|,
literal|2
argument_list|>
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|value
argument_list|,
name|GL_FLOAT_MAT4x2
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix3x4fv
name|void
name|ProgramD3D
operator|::
name|setUniformMatrix3x4fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
name|setUniformMatrixfv
argument_list|<
literal|3
argument_list|,
literal|4
argument_list|>
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|value
argument_list|,
name|GL_FLOAT_MAT3x4
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix4x3fv
name|void
name|ProgramD3D
operator|::
name|setUniformMatrix4x3fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
name|setUniformMatrixfv
argument_list|<
literal|4
argument_list|,
literal|3
argument_list|>
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|value
argument_list|,
name|GL_FLOAT_MAT4x3
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform1iv
name|void
name|ProgramD3D
operator|::
name|setUniform1iv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|setUniform
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|,
name|GL_INT
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform2iv
name|void
name|ProgramD3D
operator|::
name|setUniform2iv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|setUniform
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|,
name|GL_INT_VEC2
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform3iv
name|void
name|ProgramD3D
operator|::
name|setUniform3iv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|setUniform
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|,
name|GL_INT_VEC3
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform4iv
name|void
name|ProgramD3D
operator|::
name|setUniform4iv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|setUniform
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|,
name|GL_INT_VEC4
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform1uiv
name|void
name|ProgramD3D
operator|::
name|setUniform1uiv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|v
parameter_list|)
block|{
name|setUniform
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|,
name|GL_UNSIGNED_INT
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform2uiv
name|void
name|ProgramD3D
operator|::
name|setUniform2uiv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|v
parameter_list|)
block|{
name|setUniform
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|,
name|GL_UNSIGNED_INT_VEC2
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform3uiv
name|void
name|ProgramD3D
operator|::
name|setUniform3uiv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|v
parameter_list|)
block|{
name|setUniform
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|,
name|GL_UNSIGNED_INT_VEC3
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform4uiv
name|void
name|ProgramD3D
operator|::
name|setUniform4uiv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|v
parameter_list|)
block|{
name|setUniform
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|,
name|GL_UNSIGNED_INT_VEC4
argument_list|)
expr_stmt|;
block|}
DECL|function|getUniformfv
name|void
name|ProgramD3D
operator|::
name|getUniformfv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLfloat
modifier|*
name|params
parameter_list|)
block|{
name|getUniformv
argument_list|(
name|location
argument_list|,
name|params
argument_list|,
name|GL_FLOAT
argument_list|)
expr_stmt|;
block|}
DECL|function|getUniformiv
name|void
name|ProgramD3D
operator|::
name|getUniformiv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLint
modifier|*
name|params
parameter_list|)
block|{
name|getUniformv
argument_list|(
name|location
argument_list|,
name|params
argument_list|,
name|GL_INT
argument_list|)
expr_stmt|;
block|}
DECL|function|getUniformuiv
name|void
name|ProgramD3D
operator|::
name|getUniformuiv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLuint
modifier|*
name|params
parameter_list|)
block|{
name|getUniformv
argument_list|(
name|location
argument_list|,
name|params
argument_list|,
name|GL_UNSIGNED_INT
argument_list|)
expr_stmt|;
block|}
DECL|function|linkUniforms
name|bool
name|ProgramD3D
operator|::
name|linkUniforms
parameter_list|(
name|gl
operator|::
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|gl
operator|::
name|Shader
modifier|&
name|vertexShader
parameter_list|,
specifier|const
name|gl
operator|::
name|Shader
modifier|&
name|fragmentShader
parameter_list|,
specifier|const
name|gl
operator|::
name|Caps
modifier|&
name|caps
parameter_list|)
block|{
specifier|const
name|ShaderD3D
modifier|*
name|vertexShaderD3D
init|=
name|ShaderD3D
operator|::
name|makeShaderD3D
argument_list|(
name|vertexShader
operator|.
name|getImplementation
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|ShaderD3D
modifier|*
name|fragmentShaderD3D
init|=
name|ShaderD3D
operator|::
name|makeShaderD3D
argument_list|(
name|fragmentShader
operator|.
name|getImplementation
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|Uniform
argument_list|>
modifier|&
name|vertexUniforms
init|=
name|vertexShader
operator|.
name|getUniforms
argument_list|()
decl_stmt|;
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|Uniform
argument_list|>
modifier|&
name|fragmentUniforms
init|=
name|fragmentShader
operator|.
name|getUniforms
argument_list|()
decl_stmt|;
comment|// Check that uniforms defined in the vertex and fragment shaders are identical
typedef|typedef
name|std
operator|::
name|map
argument_list|<
name|std
operator|::
name|string
argument_list|,
specifier|const
name|sh
operator|::
name|Uniform
operator|*
argument_list|>
name|UniformMap
typedef|;
name|UniformMap
name|linkedUniforms
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|vertexUniformIndex
init|=
literal|0
init|;
name|vertexUniformIndex
operator|<
name|vertexUniforms
operator|.
name|size
argument_list|()
condition|;
name|vertexUniformIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|Uniform
modifier|&
name|vertexUniform
init|=
name|vertexUniforms
index|[
name|vertexUniformIndex
index|]
decl_stmt|;
name|linkedUniforms
index|[
name|vertexUniform
operator|.
name|name
index|]
operator|=
operator|&
name|vertexUniform
expr_stmt|;
block|}
for|for
control|(
name|unsigned
name|int
name|fragmentUniformIndex
init|=
literal|0
init|;
name|fragmentUniformIndex
operator|<
name|fragmentUniforms
operator|.
name|size
argument_list|()
condition|;
name|fragmentUniformIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|Uniform
modifier|&
name|fragmentUniform
init|=
name|fragmentUniforms
index|[
name|fragmentUniformIndex
index|]
decl_stmt|;
name|UniformMap
operator|::
name|const_iterator
name|entry
init|=
name|linkedUniforms
operator|.
name|find
argument_list|(
name|fragmentUniform
operator|.
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
name|linkedUniforms
operator|.
name|end
argument_list|()
condition|)
block|{
specifier|const
name|sh
operator|::
name|Uniform
modifier|&
name|vertexUniform
init|=
operator|*
name|entry
operator|->
name|second
decl_stmt|;
specifier|const
name|std
operator|::
name|string
modifier|&
name|uniformName
init|=
literal|"uniform '"
operator|+
name|vertexUniform
operator|.
name|name
operator|+
literal|"'"
decl_stmt|;
if|if
condition|(
operator|!
name|gl
operator|::
name|ProgramBinary
operator|::
name|linkValidateUniforms
argument_list|(
name|infoLog
argument_list|,
name|uniformName
argument_list|,
name|vertexUniform
argument_list|,
name|fragmentUniform
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
for|for
control|(
name|unsigned
name|int
name|uniformIndex
init|=
literal|0
init|;
name|uniformIndex
operator|<
name|vertexUniforms
operator|.
name|size
argument_list|()
condition|;
name|uniformIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|Uniform
modifier|&
name|uniform
init|=
name|vertexUniforms
index|[
name|uniformIndex
index|]
decl_stmt|;
if|if
condition|(
name|uniform
operator|.
name|staticUse
condition|)
block|{
name|defineUniformBase
argument_list|(
name|GL_VERTEX_SHADER
argument_list|,
name|uniform
argument_list|,
name|vertexShaderD3D
operator|->
name|getUniformRegister
argument_list|(
name|uniform
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|unsigned
name|int
name|uniformIndex
init|=
literal|0
init|;
name|uniformIndex
operator|<
name|fragmentUniforms
operator|.
name|size
argument_list|()
condition|;
name|uniformIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|Uniform
modifier|&
name|uniform
init|=
name|fragmentUniforms
index|[
name|uniformIndex
index|]
decl_stmt|;
if|if
condition|(
name|uniform
operator|.
name|staticUse
condition|)
block|{
name|defineUniformBase
argument_list|(
name|GL_FRAGMENT_SHADER
argument_list|,
name|uniform
argument_list|,
name|fragmentShaderD3D
operator|->
name|getUniformRegister
argument_list|(
name|uniform
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|indexUniforms
argument_list|(
name|infoLog
argument_list|,
name|caps
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|initializeUniformStorage
argument_list|()
expr_stmt|;
comment|// special case for gl_DepthRange, the only built-in uniform (also a struct)
if|if
condition|(
name|vertexShaderD3D
operator|->
name|usesDepthRange
argument_list|()
operator|||
name|fragmentShaderD3D
operator|->
name|usesDepthRange
argument_list|()
condition|)
block|{
specifier|const
name|sh
operator|::
name|BlockMemberInfo
modifier|&
name|defaultInfo
init|=
name|sh
operator|::
name|BlockMemberInfo
operator|::
name|getDefaultBlockInfo
argument_list|()
decl_stmt|;
name|mUniforms
operator|.
name|push_back
argument_list|(
operator|new
name|gl
operator|::
name|LinkedUniform
argument_list|(
name|GL_FLOAT
argument_list|,
name|GL_HIGH_FLOAT
argument_list|,
literal|"gl_DepthRange.near"
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|defaultInfo
argument_list|)
argument_list|)
expr_stmt|;
name|mUniforms
operator|.
name|push_back
argument_list|(
operator|new
name|gl
operator|::
name|LinkedUniform
argument_list|(
name|GL_FLOAT
argument_list|,
name|GL_HIGH_FLOAT
argument_list|,
literal|"gl_DepthRange.far"
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|defaultInfo
argument_list|)
argument_list|)
expr_stmt|;
name|mUniforms
operator|.
name|push_back
argument_list|(
operator|new
name|gl
operator|::
name|LinkedUniform
argument_list|(
name|GL_FLOAT
argument_list|,
name|GL_HIGH_FLOAT
argument_list|,
literal|"gl_DepthRange.diff"
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|defaultInfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|defineUniformBase
name|void
name|ProgramD3D
operator|::
name|defineUniformBase
parameter_list|(
name|GLenum
name|shader
parameter_list|,
specifier|const
name|sh
operator|::
name|Uniform
modifier|&
name|uniform
parameter_list|,
name|unsigned
name|int
name|uniformRegister
parameter_list|)
block|{
name|ShShaderOutput
name|outputType
init|=
name|ShaderD3D
operator|::
name|getCompilerOutputType
argument_list|(
name|shader
argument_list|)
decl_stmt|;
name|sh
operator|::
name|HLSLBlockEncoder
name|encoder
argument_list|(
name|sh
operator|::
name|HLSLBlockEncoder
operator|::
name|GetStrategyFor
argument_list|(
name|outputType
argument_list|)
argument_list|)
decl_stmt|;
name|encoder
operator|.
name|skipRegisters
argument_list|(
name|uniformRegister
argument_list|)
expr_stmt|;
name|defineUniform
argument_list|(
name|shader
argument_list|,
name|uniform
argument_list|,
name|uniform
operator|.
name|name
argument_list|,
operator|&
name|encoder
argument_list|)
expr_stmt|;
block|}
DECL|function|defineUniform
name|void
name|ProgramD3D
operator|::
name|defineUniform
parameter_list|(
name|GLenum
name|shader
parameter_list|,
specifier|const
name|sh
operator|::
name|ShaderVariable
modifier|&
name|uniform
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|fullName
parameter_list|,
name|sh
operator|::
name|HLSLBlockEncoder
modifier|*
name|encoder
parameter_list|)
block|{
if|if
condition|(
name|uniform
operator|.
name|isStruct
argument_list|()
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|elementIndex
init|=
literal|0
init|;
name|elementIndex
operator|<
name|uniform
operator|.
name|elementCount
argument_list|()
condition|;
name|elementIndex
operator|++
control|)
block|{
specifier|const
name|std
operator|::
name|string
modifier|&
name|elementString
init|=
operator|(
name|uniform
operator|.
name|isArray
argument_list|()
condition|?
name|ArrayString
argument_list|(
name|elementIndex
argument_list|)
else|:
literal|""
operator|)
decl_stmt|;
name|encoder
operator|->
name|enterAggregateType
argument_list|()
expr_stmt|;
for|for
control|(
name|size_t
name|fieldIndex
init|=
literal|0
init|;
name|fieldIndex
operator|<
name|uniform
operator|.
name|fields
operator|.
name|size
argument_list|()
condition|;
name|fieldIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|ShaderVariable
modifier|&
name|field
init|=
name|uniform
operator|.
name|fields
index|[
name|fieldIndex
index|]
decl_stmt|;
specifier|const
name|std
operator|::
name|string
modifier|&
name|fieldFullName
init|=
operator|(
name|fullName
operator|+
name|elementString
operator|+
literal|"."
operator|+
name|field
operator|.
name|name
operator|)
decl_stmt|;
name|defineUniform
argument_list|(
name|shader
argument_list|,
name|field
argument_list|,
name|fieldFullName
argument_list|,
name|encoder
argument_list|)
expr_stmt|;
block|}
name|encoder
operator|->
name|exitAggregateType
argument_list|()
expr_stmt|;
block|}
block|}
else|else
comment|// Not a struct
block|{
comment|// Arrays are treated as aggregate types
if|if
condition|(
name|uniform
operator|.
name|isArray
argument_list|()
condition|)
block|{
name|encoder
operator|->
name|enterAggregateType
argument_list|()
expr_stmt|;
block|}
name|gl
operator|::
name|LinkedUniform
modifier|*
name|linkedUniform
init|=
name|getUniformByName
argument_list|(
name|fullName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|linkedUniform
condition|)
block|{
name|linkedUniform
operator|=
operator|new
name|gl
operator|::
name|LinkedUniform
argument_list|(
name|uniform
operator|.
name|type
argument_list|,
name|uniform
operator|.
name|precision
argument_list|,
name|fullName
argument_list|,
name|uniform
operator|.
name|arraySize
argument_list|,
operator|-
literal|1
argument_list|,
name|sh
operator|::
name|BlockMemberInfo
operator|::
name|getDefaultBlockInfo
argument_list|()
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|linkedUniform
argument_list|)
expr_stmt|;
name|linkedUniform
operator|->
name|registerElement
operator|=
name|encoder
operator|->
name|getCurrentElement
argument_list|()
expr_stmt|;
name|mUniforms
operator|.
name|push_back
argument_list|(
name|linkedUniform
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|linkedUniform
operator|->
name|registerElement
operator|==
name|encoder
operator|->
name|getCurrentElement
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|shader
operator|==
name|GL_FRAGMENT_SHADER
condition|)
block|{
name|linkedUniform
operator|->
name|psRegisterIndex
operator|=
name|encoder
operator|->
name|getCurrentRegister
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shader
operator|==
name|GL_VERTEX_SHADER
condition|)
block|{
name|linkedUniform
operator|->
name|vsRegisterIndex
operator|=
name|encoder
operator|->
name|getCurrentRegister
argument_list|()
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
comment|// Advance the uniform offset, to track registers allocation for structs
name|encoder
operator|->
name|encodeType
argument_list|(
name|uniform
operator|.
name|type
argument_list|,
name|uniform
operator|.
name|arraySize
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Arrays are treated as aggregate types
if|if
condition|(
name|uniform
operator|.
name|isArray
argument_list|()
condition|)
block|{
name|encoder
operator|->
name|exitAggregateType
argument_list|()
expr_stmt|;
block|}
block|}
block|}
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|SetIfDirty
specifier|static
specifier|inline
name|void
name|SetIfDirty
parameter_list|(
name|T
modifier|*
name|dest
parameter_list|,
specifier|const
name|T
modifier|&
name|source
parameter_list|,
name|bool
modifier|*
name|dirtyFlag
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|dest
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dirtyFlag
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|dirtyFlag
operator|=
operator|*
name|dirtyFlag
operator|||
operator|(
name|memcmp
argument_list|(
name|dest
argument_list|,
operator|&
name|source
argument_list|,
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
operator|*
name|dest
operator|=
name|source
expr_stmt|;
block|}
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|setUniform
name|void
name|ProgramD3D
operator|::
name|setUniform
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|T
modifier|*
name|v
parameter_list|,
name|GLenum
name|targetUniformType
parameter_list|)
block|{
specifier|const
name|int
name|components
init|=
name|gl
operator|::
name|VariableComponentCount
argument_list|(
name|targetUniformType
argument_list|)
decl_stmt|;
specifier|const
name|GLenum
name|targetBoolType
init|=
name|gl
operator|::
name|VariableBoolVectorType
argument_list|(
name|targetUniformType
argument_list|)
decl_stmt|;
name|gl
operator|::
name|LinkedUniform
modifier|*
name|targetUniform
init|=
name|getUniformByLocation
argument_list|(
name|location
argument_list|)
decl_stmt|;
name|int
name|elementCount
init|=
name|targetUniform
operator|->
name|elementCount
argument_list|()
decl_stmt|;
name|count
operator|=
name|std
operator|::
name|min
argument_list|(
name|elementCount
operator|-
operator|(
name|int
operator|)
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|targetUniformType
condition|)
block|{
name|T
modifier|*
name|target
init|=
cast|reinterpret_cast
argument_list|<
name|T
operator|*
argument_list|>
argument_list|(
name|targetUniform
operator|->
name|data
argument_list|)
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|T
modifier|*
name|dest
init|=
name|target
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
decl_stmt|;
specifier|const
name|T
modifier|*
name|source
init|=
name|v
operator|+
operator|(
name|i
operator|*
name|components
operator|)
decl_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|components
condition|;
name|c
operator|++
control|)
block|{
name|SetIfDirty
argument_list|(
name|dest
operator|+
name|c
argument_list|,
name|source
index|[
name|c
index|]
argument_list|,
operator|&
name|targetUniform
operator|->
name|dirty
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|c
init|=
name|components
init|;
name|c
operator|<
literal|4
condition|;
name|c
operator|++
control|)
block|{
name|SetIfDirty
argument_list|(
name|dest
operator|+
name|c
argument_list|,
name|T
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|targetUniform
operator|->
name|dirty
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|targetBoolType
condition|)
block|{
name|GLint
modifier|*
name|boolParams
init|=
cast|reinterpret_cast
argument_list|<
name|GLint
operator|*
argument_list|>
argument_list|(
name|targetUniform
operator|->
name|data
argument_list|)
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|GLint
modifier|*
name|dest
init|=
name|boolParams
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
decl_stmt|;
specifier|const
name|T
modifier|*
name|source
init|=
name|v
operator|+
operator|(
name|i
operator|*
name|components
operator|)
decl_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|components
condition|;
name|c
operator|++
control|)
block|{
name|SetIfDirty
argument_list|(
name|dest
operator|+
name|c
argument_list|,
operator|(
name|source
index|[
name|c
index|]
operator|==
cast|static_cast
argument_list|<
name|T
argument_list|>
argument_list|(
literal|0
argument_list|)
operator|)
condition|?
name|GL_FALSE
else|:
name|GL_TRUE
argument_list|,
operator|&
name|targetUniform
operator|->
name|dirty
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|c
init|=
name|components
init|;
name|c
operator|<
literal|4
condition|;
name|c
operator|++
control|)
block|{
name|SetIfDirty
argument_list|(
name|dest
operator|+
name|c
argument_list|,
name|GL_FALSE
argument_list|,
operator|&
name|targetUniform
operator|->
name|dirty
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|gl
operator|::
name|IsSampler
argument_list|(
name|targetUniform
operator|->
name|type
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|targetUniformType
operator|==
name|GL_INT
argument_list|)
expr_stmt|;
name|GLint
modifier|*
name|target
init|=
cast|reinterpret_cast
argument_list|<
name|GLint
operator|*
argument_list|>
argument_list|(
name|targetUniform
operator|->
name|data
argument_list|)
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
name|bool
name|wasDirty
init|=
name|targetUniform
operator|->
name|dirty
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|GLint
modifier|*
name|dest
init|=
name|target
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
decl_stmt|;
specifier|const
name|GLint
modifier|*
name|source
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|GLint
operator|*
argument_list|>
argument_list|(
name|v
argument_list|)
operator|+
operator|(
name|i
operator|*
name|components
operator|)
decl_stmt|;
name|SetIfDirty
argument_list|(
name|dest
operator|+
literal|0
argument_list|,
name|source
index|[
literal|0
index|]
argument_list|,
operator|&
name|targetUniform
operator|->
name|dirty
argument_list|)
expr_stmt|;
name|SetIfDirty
argument_list|(
name|dest
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|targetUniform
operator|->
name|dirty
argument_list|)
expr_stmt|;
name|SetIfDirty
argument_list|(
name|dest
operator|+
literal|2
argument_list|,
literal|0
argument_list|,
operator|&
name|targetUniform
operator|->
name|dirty
argument_list|)
expr_stmt|;
name|SetIfDirty
argument_list|(
name|dest
operator|+
literal|3
argument_list|,
literal|0
argument_list|,
operator|&
name|targetUniform
operator|->
name|dirty
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|wasDirty
operator|&&
name|targetUniform
operator|->
name|dirty
condition|)
block|{
name|mDirtySamplerMapping
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|transposeMatrix
name|bool
name|transposeMatrix
parameter_list|(
name|T
modifier|*
name|target
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|,
name|int
name|targetWidth
parameter_list|,
name|int
name|targetHeight
parameter_list|,
name|int
name|srcWidth
parameter_list|,
name|int
name|srcHeight
parameter_list|)
block|{
name|bool
name|dirty
init|=
literal|false
decl_stmt|;
name|int
name|copyWidth
init|=
name|std
operator|::
name|min
argument_list|(
name|targetHeight
argument_list|,
name|srcWidth
argument_list|)
decl_stmt|;
name|int
name|copyHeight
init|=
name|std
operator|::
name|min
argument_list|(
name|targetWidth
argument_list|,
name|srcHeight
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|copyWidth
condition|;
name|x
operator|++
control|)
block|{
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|copyHeight
condition|;
name|y
operator|++
control|)
block|{
name|SetIfDirty
argument_list|(
name|target
operator|+
operator|(
name|x
operator|*
name|targetWidth
operator|+
name|y
operator|)
argument_list|,
cast|static_cast
argument_list|<
name|T
argument_list|>
argument_list|(
name|value
index|[
name|y
operator|*
name|srcWidth
operator|+
name|x
index|]
argument_list|)
argument_list|,
operator|&
name|dirty
argument_list|)
expr_stmt|;
block|}
block|}
comment|// clear unfilled right side
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|copyWidth
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
name|copyHeight
init|;
name|x
operator|<
name|targetWidth
condition|;
name|x
operator|++
control|)
block|{
name|SetIfDirty
argument_list|(
name|target
operator|+
operator|(
name|y
operator|*
name|targetWidth
operator|+
name|x
operator|)
argument_list|,
cast|static_cast
argument_list|<
name|T
argument_list|>
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|dirty
argument_list|)
expr_stmt|;
block|}
block|}
comment|// clear unfilled bottom.
for|for
control|(
name|int
name|y
init|=
name|copyWidth
init|;
name|y
operator|<
name|targetHeight
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|targetWidth
condition|;
name|x
operator|++
control|)
block|{
name|SetIfDirty
argument_list|(
name|target
operator|+
operator|(
name|y
operator|*
name|targetWidth
operator|+
name|x
operator|)
argument_list|,
cast|static_cast
argument_list|<
name|T
argument_list|>
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|dirty
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|dirty
return|;
block|}
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|expandMatrix
name|bool
name|expandMatrix
parameter_list|(
name|T
modifier|*
name|target
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|,
name|int
name|targetWidth
parameter_list|,
name|int
name|targetHeight
parameter_list|,
name|int
name|srcWidth
parameter_list|,
name|int
name|srcHeight
parameter_list|)
block|{
name|bool
name|dirty
init|=
literal|false
decl_stmt|;
name|int
name|copyWidth
init|=
name|std
operator|::
name|min
argument_list|(
name|targetWidth
argument_list|,
name|srcWidth
argument_list|)
decl_stmt|;
name|int
name|copyHeight
init|=
name|std
operator|::
name|min
argument_list|(
name|targetHeight
argument_list|,
name|srcHeight
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|copyHeight
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|copyWidth
condition|;
name|x
operator|++
control|)
block|{
name|SetIfDirty
argument_list|(
name|target
operator|+
operator|(
name|y
operator|*
name|targetWidth
operator|+
name|x
operator|)
argument_list|,
cast|static_cast
argument_list|<
name|T
argument_list|>
argument_list|(
name|value
index|[
name|y
operator|*
name|srcWidth
operator|+
name|x
index|]
argument_list|)
argument_list|,
operator|&
name|dirty
argument_list|)
expr_stmt|;
block|}
block|}
comment|// clear unfilled right side
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|copyHeight
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
name|copyWidth
init|;
name|x
operator|<
name|targetWidth
condition|;
name|x
operator|++
control|)
block|{
name|SetIfDirty
argument_list|(
name|target
operator|+
operator|(
name|y
operator|*
name|targetWidth
operator|+
name|x
operator|)
argument_list|,
cast|static_cast
argument_list|<
name|T
argument_list|>
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|dirty
argument_list|)
expr_stmt|;
block|}
block|}
comment|// clear unfilled bottom.
for|for
control|(
name|int
name|y
init|=
name|copyHeight
init|;
name|y
operator|<
name|targetHeight
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|targetWidth
condition|;
name|x
operator|++
control|)
block|{
name|SetIfDirty
argument_list|(
name|target
operator|+
operator|(
name|y
operator|*
name|targetWidth
operator|+
name|x
operator|)
argument_list|,
cast|static_cast
argument_list|<
name|T
argument_list|>
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|dirty
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|dirty
return|;
block|}
template|template
parameter_list|<
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|>
DECL|function|setUniformMatrixfv
name|void
name|ProgramD3D
operator|::
name|setUniformMatrixfv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|,
name|GLenum
name|targetUniformType
parameter_list|)
block|{
name|gl
operator|::
name|LinkedUniform
modifier|*
name|targetUniform
init|=
name|getUniformByLocation
argument_list|(
name|location
argument_list|)
decl_stmt|;
name|int
name|elementCount
init|=
name|targetUniform
operator|->
name|elementCount
argument_list|()
decl_stmt|;
name|count
operator|=
name|std
operator|::
name|min
argument_list|(
name|elementCount
operator|-
operator|(
name|int
operator|)
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
argument_list|,
name|count
argument_list|)
expr_stmt|;
specifier|const
name|unsigned
name|int
name|targetMatrixStride
init|=
operator|(
literal|4
operator|*
name|rows
operator|)
decl_stmt|;
name|GLfloat
modifier|*
name|target
init|=
operator|(
name|GLfloat
operator|*
operator|)
operator|(
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
sizeof|sizeof
argument_list|(
name|GLfloat
argument_list|)
operator|*
name|targetMatrixStride
operator|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|// Internally store matrices as transposed versions to accomodate HLSL matrix indexing
if|if
condition|(
name|transpose
operator|==
name|GL_FALSE
condition|)
block|{
name|targetUniform
operator|->
name|dirty
operator|=
name|transposeMatrix
argument_list|<
name|GLfloat
argument_list|>
argument_list|(
name|target
argument_list|,
name|value
argument_list|,
literal|4
argument_list|,
name|rows
argument_list|,
name|rows
argument_list|,
name|cols
argument_list|)
operator|||
name|targetUniform
operator|->
name|dirty
expr_stmt|;
block|}
else|else
block|{
name|targetUniform
operator|->
name|dirty
operator|=
name|expandMatrix
argument_list|<
name|GLfloat
argument_list|>
argument_list|(
name|target
argument_list|,
name|value
argument_list|,
literal|4
argument_list|,
name|rows
argument_list|,
name|cols
argument_list|,
name|rows
argument_list|)
operator|||
name|targetUniform
operator|->
name|dirty
expr_stmt|;
block|}
name|target
operator|+=
name|targetMatrixStride
expr_stmt|;
name|value
operator|+=
name|cols
operator|*
name|rows
expr_stmt|;
block|}
block|}
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|getUniformv
name|void
name|ProgramD3D
operator|::
name|getUniformv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|T
modifier|*
name|params
parameter_list|,
name|GLenum
name|uniformType
parameter_list|)
block|{
name|gl
operator|::
name|LinkedUniform
modifier|*
name|targetUniform
init|=
name|mUniforms
index|[
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|index
index|]
decl_stmt|;
if|if
condition|(
name|gl
operator|::
name|IsMatrixType
argument_list|(
name|targetUniform
operator|->
name|type
argument_list|)
condition|)
block|{
specifier|const
name|int
name|rows
init|=
name|gl
operator|::
name|VariableRowCount
argument_list|(
name|targetUniform
operator|->
name|type
argument_list|)
decl_stmt|;
specifier|const
name|int
name|cols
init|=
name|gl
operator|::
name|VariableColumnCount
argument_list|(
name|targetUniform
operator|->
name|type
argument_list|)
decl_stmt|;
name|transposeMatrix
argument_list|(
name|params
argument_list|,
operator|(
name|GLfloat
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
operator|*
name|rows
argument_list|,
name|rows
argument_list|,
name|cols
argument_list|,
literal|4
argument_list|,
name|rows
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uniformType
operator|==
name|gl
operator|::
name|VariableComponentType
argument_list|(
name|targetUniform
operator|->
name|type
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|size
init|=
name|gl
operator|::
name|VariableComponentCount
argument_list|(
name|targetUniform
operator|->
name|type
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|params
argument_list|,
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|size
init|=
name|gl
operator|::
name|VariableComponentCount
argument_list|(
name|targetUniform
operator|->
name|type
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|gl
operator|::
name|VariableComponentType
argument_list|(
name|targetUniform
operator|->
name|type
argument_list|)
condition|)
block|{
case|case
name|GL_BOOL
case|:
block|{
name|GLint
modifier|*
name|boolParams
init|=
operator|(
name|GLint
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|params
index|[
name|i
index|]
operator|=
operator|(
name|boolParams
index|[
name|i
index|]
operator|==
name|GL_FALSE
operator|)
condition|?
cast|static_cast
argument_list|<
name|T
argument_list|>
argument_list|(
literal|0
argument_list|)
else|:
cast|static_cast
argument_list|<
name|T
argument_list|>
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GL_FLOAT
case|:
block|{
name|GLfloat
modifier|*
name|floatParams
init|=
operator|(
name|GLfloat
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|params
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
name|T
argument_list|>
argument_list|(
name|floatParams
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GL_INT
case|:
block|{
name|GLint
modifier|*
name|intParams
init|=
operator|(
name|GLint
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|params
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
name|T
argument_list|>
argument_list|(
name|intParams
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GL_UNSIGNED_INT
case|:
block|{
name|GLuint
modifier|*
name|uintParams
init|=
operator|(
name|GLuint
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|params
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
name|T
argument_list|>
argument_list|(
name|uintParams
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
block|}
template|template
parameter_list|<
name|typename
name|VarT
parameter_list|>
DECL|function|defineUniformBlockMembers
name|void
name|ProgramD3D
operator|::
name|defineUniformBlockMembers
parameter_list|(
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|VarT
argument_list|>
modifier|&
name|fields
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|prefix
parameter_list|,
name|int
name|blockIndex
parameter_list|,
name|sh
operator|::
name|BlockLayoutEncoder
modifier|*
name|encoder
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|unsigned
name|int
argument_list|>
modifier|*
name|blockUniformIndexes
parameter_list|,
name|bool
name|inRowMajorLayout
parameter_list|)
block|{
for|for
control|(
name|unsigned
name|int
name|uniformIndex
init|=
literal|0
init|;
name|uniformIndex
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|uniformIndex
operator|++
control|)
block|{
specifier|const
name|VarT
modifier|&
name|field
init|=
name|fields
index|[
name|uniformIndex
index|]
decl_stmt|;
specifier|const
name|std
operator|::
name|string
modifier|&
name|fieldName
init|=
operator|(
name|prefix
operator|.
name|empty
argument_list|()
condition|?
name|field
operator|.
name|name
else|:
name|prefix
operator|+
literal|"."
operator|+
name|field
operator|.
name|name
operator|)
decl_stmt|;
if|if
condition|(
name|field
operator|.
name|isStruct
argument_list|()
condition|)
block|{
name|bool
name|rowMajorLayout
init|=
operator|(
name|inRowMajorLayout
operator|||
name|IsRowMajorLayout
argument_list|(
name|field
argument_list|)
operator|)
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|arrayElement
init|=
literal|0
init|;
name|arrayElement
operator|<
name|field
operator|.
name|elementCount
argument_list|()
condition|;
name|arrayElement
operator|++
control|)
block|{
name|encoder
operator|->
name|enterAggregateType
argument_list|()
expr_stmt|;
specifier|const
name|std
operator|::
name|string
name|uniformElementName
init|=
name|fieldName
operator|+
operator|(
name|field
operator|.
name|isArray
argument_list|()
condition|?
name|ArrayString
argument_list|(
name|arrayElement
argument_list|)
else|:
literal|""
operator|)
decl_stmt|;
name|defineUniformBlockMembers
argument_list|(
name|field
operator|.
name|fields
argument_list|,
name|uniformElementName
argument_list|,
name|blockIndex
argument_list|,
name|encoder
argument_list|,
name|blockUniformIndexes
argument_list|,
name|rowMajorLayout
argument_list|)
expr_stmt|;
name|encoder
operator|->
name|exitAggregateType
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|bool
name|isRowMajorMatrix
init|=
operator|(
name|gl
operator|::
name|IsMatrixType
argument_list|(
name|field
operator|.
name|type
argument_list|)
operator|&&
name|inRowMajorLayout
operator|)
decl_stmt|;
name|sh
operator|::
name|BlockMemberInfo
name|memberInfo
init|=
name|encoder
operator|->
name|encodeType
argument_list|(
name|field
operator|.
name|type
argument_list|,
name|field
operator|.
name|arraySize
argument_list|,
name|isRowMajorMatrix
argument_list|)
decl_stmt|;
name|gl
operator|::
name|LinkedUniform
modifier|*
name|newUniform
init|=
operator|new
name|gl
operator|::
name|LinkedUniform
argument_list|(
name|field
operator|.
name|type
argument_list|,
name|field
operator|.
name|precision
argument_list|,
name|fieldName
argument_list|,
name|field
operator|.
name|arraySize
argument_list|,
name|blockIndex
argument_list|,
name|memberInfo
argument_list|)
decl_stmt|;
comment|// add to uniform list, but not index, since uniform block uniforms have no location
name|blockUniformIndexes
operator|->
name|push_back
argument_list|(
name|mUniforms
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|mUniforms
operator|.
name|push_back
argument_list|(
name|newUniform
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|defineUniformBlock
name|bool
name|ProgramD3D
operator|::
name|defineUniformBlock
parameter_list|(
name|gl
operator|::
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|gl
operator|::
name|Shader
modifier|&
name|shader
parameter_list|,
specifier|const
name|sh
operator|::
name|InterfaceBlock
modifier|&
name|interfaceBlock
parameter_list|,
specifier|const
name|gl
operator|::
name|Caps
modifier|&
name|caps
parameter_list|)
block|{
specifier|const
name|ShaderD3D
modifier|*
name|shaderD3D
init|=
name|ShaderD3D
operator|::
name|makeShaderD3D
argument_list|(
name|shader
operator|.
name|getImplementation
argument_list|()
argument_list|)
decl_stmt|;
comment|// create uniform block entries if they do not exist
if|if
condition|(
name|getUniformBlockIndex
argument_list|(
name|interfaceBlock
operator|.
name|name
argument_list|)
operator|==
name|GL_INVALID_INDEX
condition|)
block|{
name|std
operator|::
name|vector
argument_list|<
name|unsigned
name|int
argument_list|>
name|blockUniformIndexes
decl_stmt|;
specifier|const
name|unsigned
name|int
name|blockIndex
init|=
name|mUniformBlocks
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// define member uniforms
name|sh
operator|::
name|BlockLayoutEncoder
modifier|*
name|encoder
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|interfaceBlock
operator|.
name|layout
operator|==
name|sh
operator|::
name|BLOCKLAYOUT_STANDARD
condition|)
block|{
name|encoder
operator|=
operator|new
name|sh
operator|::
name|Std140BlockEncoder
expr_stmt|;
block|}
else|else
block|{
name|encoder
operator|=
operator|new
name|sh
operator|::
name|HLSLBlockEncoder
argument_list|(
name|sh
operator|::
name|HLSLBlockEncoder
operator|::
name|ENCODE_PACKED
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
name|defineUniformBlockMembers
argument_list|(
name|interfaceBlock
operator|.
name|fields
argument_list|,
literal|""
argument_list|,
name|blockIndex
argument_list|,
name|encoder
argument_list|,
operator|&
name|blockUniformIndexes
argument_list|,
name|interfaceBlock
operator|.
name|isRowMajorLayout
argument_list|)
expr_stmt|;
name|size_t
name|dataSize
init|=
name|encoder
operator|->
name|getBlockSize
argument_list|()
decl_stmt|;
comment|// create all the uniform blocks
if|if
condition|(
name|interfaceBlock
operator|.
name|arraySize
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|uniformBlockElement
init|=
literal|0
init|;
name|uniformBlockElement
operator|<
name|interfaceBlock
operator|.
name|arraySize
condition|;
name|uniformBlockElement
operator|++
control|)
block|{
name|gl
operator|::
name|UniformBlock
modifier|*
name|newUniformBlock
init|=
operator|new
name|gl
operator|::
name|UniformBlock
argument_list|(
name|interfaceBlock
operator|.
name|name
argument_list|,
name|uniformBlockElement
argument_list|,
name|dataSize
argument_list|)
decl_stmt|;
name|newUniformBlock
operator|->
name|memberUniformIndexes
operator|=
name|blockUniformIndexes
expr_stmt|;
name|mUniformBlocks
operator|.
name|push_back
argument_list|(
name|newUniformBlock
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|gl
operator|::
name|UniformBlock
modifier|*
name|newUniformBlock
init|=
operator|new
name|gl
operator|::
name|UniformBlock
argument_list|(
name|interfaceBlock
operator|.
name|name
argument_list|,
name|GL_INVALID_INDEX
argument_list|,
name|dataSize
argument_list|)
decl_stmt|;
name|newUniformBlock
operator|->
name|memberUniformIndexes
operator|=
name|blockUniformIndexes
expr_stmt|;
name|mUniformBlocks
operator|.
name|push_back
argument_list|(
name|newUniformBlock
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|interfaceBlock
operator|.
name|staticUse
condition|)
block|{
comment|// Assign registers to the uniform blocks
specifier|const
name|GLuint
name|blockIndex
init|=
name|getUniformBlockIndex
argument_list|(
name|interfaceBlock
operator|.
name|name
argument_list|)
decl_stmt|;
specifier|const
name|unsigned
name|int
name|elementCount
init|=
name|std
operator|::
name|max
argument_list|(
literal|1u
argument_list|,
name|interfaceBlock
operator|.
name|arraySize
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|blockIndex
operator|!=
name|GL_INVALID_INDEX
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|blockIndex
operator|+
name|elementCount
operator|<=
name|mUniformBlocks
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|unsigned
name|int
name|interfaceBlockRegister
init|=
name|shaderD3D
operator|->
name|getInterfaceBlockRegister
argument_list|(
name|interfaceBlock
operator|.
name|name
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|uniformBlockElement
init|=
literal|0
init|;
name|uniformBlockElement
operator|<
name|elementCount
condition|;
name|uniformBlockElement
operator|++
control|)
block|{
name|gl
operator|::
name|UniformBlock
modifier|*
name|uniformBlock
init|=
name|mUniformBlocks
index|[
name|blockIndex
operator|+
name|uniformBlockElement
index|]
decl_stmt|;
name|ASSERT
argument_list|(
name|uniformBlock
operator|->
name|name
operator|==
name|interfaceBlock
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|assignUniformBlockRegister
argument_list|(
name|infoLog
argument_list|,
name|uniformBlock
argument_list|,
name|shader
operator|.
name|getType
argument_list|()
argument_list|,
name|interfaceBlockRegister
operator|+
name|uniformBlockElement
argument_list|,
name|caps
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|assignSamplers
name|bool
name|ProgramD3D
operator|::
name|assignSamplers
parameter_list|(
name|unsigned
name|int
name|startSamplerIndex
parameter_list|,
name|GLenum
name|samplerType
parameter_list|,
name|unsigned
name|int
name|samplerCount
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|Sampler
argument_list|>
modifier|&
name|outSamplers
parameter_list|,
name|GLuint
modifier|*
name|outUsedRange
parameter_list|)
block|{
name|unsigned
name|int
name|samplerIndex
init|=
name|startSamplerIndex
decl_stmt|;
do|do
block|{
if|if
condition|(
name|samplerIndex
operator|<
name|outSamplers
operator|.
name|size
argument_list|()
condition|)
block|{
name|Sampler
modifier|&
name|sampler
init|=
name|outSamplers
index|[
name|samplerIndex
index|]
decl_stmt|;
name|sampler
operator|.
name|active
operator|=
literal|true
expr_stmt|;
name|sampler
operator|.
name|textureType
operator|=
name|GetTextureType
argument_list|(
name|samplerType
argument_list|)
expr_stmt|;
name|sampler
operator|.
name|logicalTextureUnit
operator|=
literal|0
expr_stmt|;
operator|*
name|outUsedRange
operator|=
name|std
operator|::
name|max
argument_list|(
name|samplerIndex
operator|+
literal|1
argument_list|,
operator|*
name|outUsedRange
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
name|samplerIndex
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|samplerIndex
operator|<
name|startSamplerIndex
operator|+
name|samplerCount
condition|)
do|;
return|return
literal|true
return|;
block|}
DECL|function|indexSamplerUniform
name|bool
name|ProgramD3D
operator|::
name|indexSamplerUniform
parameter_list|(
specifier|const
name|gl
operator|::
name|LinkedUniform
modifier|&
name|uniform
parameter_list|,
name|gl
operator|::
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|gl
operator|::
name|Caps
modifier|&
name|caps
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|gl
operator|::
name|IsSampler
argument_list|(
name|uniform
operator|.
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|uniform
operator|.
name|vsRegisterIndex
operator|!=
name|GL_INVALID_INDEX
operator|||
name|uniform
operator|.
name|psRegisterIndex
operator|!=
name|GL_INVALID_INDEX
argument_list|)
expr_stmt|;
if|if
condition|(
name|uniform
operator|.
name|vsRegisterIndex
operator|!=
name|GL_INVALID_INDEX
condition|)
block|{
if|if
condition|(
operator|!
name|assignSamplers
argument_list|(
name|uniform
operator|.
name|vsRegisterIndex
argument_list|,
name|uniform
operator|.
name|type
argument_list|,
name|uniform
operator|.
name|arraySize
argument_list|,
name|mSamplersVS
argument_list|,
operator|&
name|mUsedVertexSamplerRange
argument_list|)
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Vertex shader sampler count exceeds the maximum vertex texture units (%d)."
argument_list|,
name|mSamplersVS
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|unsigned
name|int
name|maxVertexVectors
init|=
name|mRenderer
operator|->
name|getReservedVertexUniformVectors
argument_list|()
operator|+
name|caps
operator|.
name|maxVertexUniformVectors
decl_stmt|;
if|if
condition|(
name|uniform
operator|.
name|vsRegisterIndex
operator|+
name|uniform
operator|.
name|registerCount
operator|>
name|maxVertexVectors
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Vertex shader active uniforms exceed GL_MAX_VERTEX_UNIFORM_VECTORS (%u)"
argument_list|,
name|caps
operator|.
name|maxVertexUniformVectors
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|uniform
operator|.
name|psRegisterIndex
operator|!=
name|GL_INVALID_INDEX
condition|)
block|{
if|if
condition|(
operator|!
name|assignSamplers
argument_list|(
name|uniform
operator|.
name|psRegisterIndex
argument_list|,
name|uniform
operator|.
name|type
argument_list|,
name|uniform
operator|.
name|arraySize
argument_list|,
name|mSamplersPS
argument_list|,
operator|&
name|mUsedPixelSamplerRange
argument_list|)
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Pixel shader sampler count exceeds MAX_TEXTURE_IMAGE_UNITS (%d)."
argument_list|,
name|mSamplersPS
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|unsigned
name|int
name|maxFragmentVectors
init|=
name|mRenderer
operator|->
name|getReservedFragmentUniformVectors
argument_list|()
operator|+
name|caps
operator|.
name|maxFragmentUniformVectors
decl_stmt|;
if|if
condition|(
name|uniform
operator|.
name|psRegisterIndex
operator|+
name|uniform
operator|.
name|registerCount
operator|>
name|maxFragmentVectors
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Fragment shader active uniforms exceed GL_MAX_FRAGMENT_UNIFORM_VECTORS (%u)"
argument_list|,
name|caps
operator|.
name|maxFragmentUniformVectors
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|indexUniforms
name|bool
name|ProgramD3D
operator|::
name|indexUniforms
parameter_list|(
name|gl
operator|::
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|gl
operator|::
name|Caps
modifier|&
name|caps
parameter_list|)
block|{
for|for
control|(
name|size_t
name|uniformIndex
init|=
literal|0
init|;
name|uniformIndex
operator|<
name|mUniforms
operator|.
name|size
argument_list|()
condition|;
name|uniformIndex
operator|++
control|)
block|{
specifier|const
name|gl
operator|::
name|LinkedUniform
modifier|&
name|uniform
init|=
operator|*
name|mUniforms
index|[
name|uniformIndex
index|]
decl_stmt|;
if|if
condition|(
name|gl
operator|::
name|IsSampler
argument_list|(
name|uniform
operator|.
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|indexSamplerUniform
argument_list|(
name|uniform
argument_list|,
name|infoLog
argument_list|,
name|caps
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
for|for
control|(
name|unsigned
name|int
name|arrayElementIndex
init|=
literal|0
init|;
name|arrayElementIndex
operator|<
name|uniform
operator|.
name|elementCount
argument_list|()
condition|;
name|arrayElementIndex
operator|++
control|)
block|{
name|mUniformIndex
operator|.
name|push_back
argument_list|(
name|gl
operator|::
name|VariableLocation
argument_list|(
name|uniform
operator|.
name|name
argument_list|,
name|arrayElementIndex
argument_list|,
name|uniformIndex
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|reset
name|void
name|ProgramD3D
operator|::
name|reset
parameter_list|()
block|{
name|ProgramImpl
operator|::
name|reset
argument_list|()
expr_stmt|;
name|SafeDeleteContainer
argument_list|(
name|mVertexExecutables
argument_list|)
expr_stmt|;
name|SafeDeleteContainer
argument_list|(
name|mPixelExecutables
argument_list|)
expr_stmt|;
name|SafeDelete
argument_list|(
name|mGeometryExecutable
argument_list|)
expr_stmt|;
name|mTransformFeedbackBufferMode
operator|=
name|GL_NONE
expr_stmt|;
name|mVertexHLSL
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mVertexWorkarounds
operator|=
name|ANGLE_D3D_WORKAROUND_NONE
expr_stmt|;
name|mShaderVersion
operator|=
literal|100
expr_stmt|;
name|mPixelHLSL
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mPixelWorkarounds
operator|=
name|ANGLE_D3D_WORKAROUND_NONE
expr_stmt|;
name|mUsesFragDepth
operator|=
literal|false
expr_stmt|;
name|mPixelShaderKey
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mUsesPointSize
operator|=
literal|false
expr_stmt|;
name|SafeDelete
argument_list|(
name|mVertexUniformStorage
argument_list|)
expr_stmt|;
name|SafeDelete
argument_list|(
name|mFragmentUniformStorage
argument_list|)
expr_stmt|;
name|mSamplersPS
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mSamplersVS
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mUsedVertexSamplerRange
operator|=
literal|0
expr_stmt|;
name|mUsedPixelSamplerRange
operator|=
literal|0
expr_stmt|;
name|mDirtySamplerMapping
operator|=
literal|true
expr_stmt|;
block|}
block|}
end_namespace
end_unit
