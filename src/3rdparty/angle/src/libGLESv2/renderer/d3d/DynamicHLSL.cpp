begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// DynamicHLSL.cpp: Implementation for link and run-time HLSL generation
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/DynamicHLSL.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/ShaderD3D.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/Renderer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Shader.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Program.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/ProgramBinary.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/formatutils.h"
end_include
begin_include
include|#
directive|include
file|"common/utilities.h"
end_include
begin_include
include|#
directive|include
file|"common/blocklayout.h"
end_include
begin_comment
comment|// For use with ArrayString, see angleutils.h
end_comment
begin_expr_stmt
name|META_ASSERT
argument_list|(
name|GL_INVALID_INDEX
operator|==
name|UINT_MAX
argument_list|)
expr_stmt|;
end_expr_stmt
begin_using
using|using
namespace|namespace
name|gl
namespace|;
end_using
begin_namespace
namespace|namespace
block|{
DECL|function|HLSLComponentTypeString
name|std
operator|::
name|string
name|HLSLComponentTypeString
parameter_list|(
name|GLenum
name|componentType
parameter_list|)
block|{
switch|switch
condition|(
name|componentType
condition|)
block|{
case|case
name|GL_UNSIGNED_INT
case|:
return|return
literal|"uint"
return|;
case|case
name|GL_INT
case|:
return|return
literal|"int"
return|;
case|case
name|GL_UNSIGNED_NORMALIZED
case|:
case|case
name|GL_SIGNED_NORMALIZED
case|:
case|case
name|GL_FLOAT
case|:
return|return
literal|"float"
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|"not-component-type"
return|;
block|}
block|}
DECL|function|HLSLComponentTypeString
name|std
operator|::
name|string
name|HLSLComponentTypeString
parameter_list|(
name|GLenum
name|componentType
parameter_list|,
name|int
name|componentCount
parameter_list|)
block|{
return|return
name|HLSLComponentTypeString
argument_list|(
name|componentType
argument_list|)
operator|+
operator|(
name|componentCount
operator|>
literal|1
condition|?
name|Str
argument_list|(
name|componentCount
argument_list|)
else|:
literal|""
operator|)
return|;
block|}
DECL|function|HLSLMatrixTypeString
name|std
operator|::
name|string
name|HLSLMatrixTypeString
parameter_list|(
name|GLenum
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_FLOAT_MAT2
case|:
return|return
literal|"float2x2"
return|;
case|case
name|GL_FLOAT_MAT3
case|:
return|return
literal|"float3x3"
return|;
case|case
name|GL_FLOAT_MAT4
case|:
return|return
literal|"float4x4"
return|;
case|case
name|GL_FLOAT_MAT2x3
case|:
return|return
literal|"float2x3"
return|;
case|case
name|GL_FLOAT_MAT3x2
case|:
return|return
literal|"float3x2"
return|;
case|case
name|GL_FLOAT_MAT2x4
case|:
return|return
literal|"float2x4"
return|;
case|case
name|GL_FLOAT_MAT4x2
case|:
return|return
literal|"float4x2"
return|;
case|case
name|GL_FLOAT_MAT3x4
case|:
return|return
literal|"float3x4"
return|;
case|case
name|GL_FLOAT_MAT4x3
case|:
return|return
literal|"float4x3"
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|"not-matrix-type"
return|;
block|}
block|}
DECL|function|HLSLTypeString
name|std
operator|::
name|string
name|HLSLTypeString
parameter_list|(
name|GLenum
name|type
parameter_list|)
block|{
if|if
condition|(
name|gl
operator|::
name|IsMatrixType
argument_list|(
name|type
argument_list|)
condition|)
block|{
return|return
name|HLSLMatrixTypeString
argument_list|(
name|type
argument_list|)
return|;
block|}
return|return
name|HLSLComponentTypeString
argument_list|(
name|gl
operator|::
name|VariableComponentType
argument_list|(
name|type
argument_list|)
argument_list|,
name|gl
operator|::
name|VariableComponentCount
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
block|}
DECL|function|GetOutputAtLocation
specifier|const
name|rx
operator|::
name|PixelShaderOutputVariable
modifier|&
name|GetOutputAtLocation
parameter_list|(
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|rx
operator|::
name|PixelShaderOutputVariable
argument_list|>
modifier|&
name|outputVariables
parameter_list|,
name|unsigned
name|int
name|location
parameter_list|)
block|{
for|for
control|(
name|size_t
name|variableIndex
init|=
literal|0
init|;
name|variableIndex
operator|<
name|outputVariables
operator|.
name|size
argument_list|()
condition|;
operator|++
name|variableIndex
control|)
block|{
if|if
condition|(
name|outputVariables
index|[
name|variableIndex
index|]
operator|.
name|outputIndex
operator|==
name|location
condition|)
block|{
return|return
name|outputVariables
index|[
name|variableIndex
index|]
return|;
block|}
block|}
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|outputVariables
index|[
literal|0
index|]
return|;
block|}
block|}
end_namespace
begin_namespace
DECL|namespace|rx
namespace|namespace
name|rx
block|{
DECL|member|VERTEX_ATTRIBUTE_STUB_STRING
specifier|const
name|std
operator|::
name|string
name|VERTEX_ATTRIBUTE_STUB_STRING
init|=
literal|"@@ VERTEX ATTRIBUTES @@"
decl_stmt|;
DECL|member|PIXEL_OUTPUT_STUB_STRING
specifier|const
name|std
operator|::
name|string
name|PIXEL_OUTPUT_STUB_STRING
init|=
literal|"@@ PIXEL OUTPUT @@"
decl_stmt|;
DECL|function|DynamicHLSL
name|DynamicHLSL
operator|::
name|DynamicHLSL
parameter_list|(
name|rx
operator|::
name|Renderer
modifier|*
specifier|const
name|renderer
parameter_list|)
member_init_list|:
name|mRenderer
argument_list|(
name|renderer
argument_list|)
block|{ }
DECL|function|packVarying
specifier|static
name|bool
name|packVarying
parameter_list|(
name|PackedVarying
modifier|*
name|varying
parameter_list|,
specifier|const
name|int
name|maxVaryingVectors
parameter_list|,
name|VaryingPacking
name|packing
parameter_list|)
block|{
name|GLenum
name|transposedType
init|=
name|TransposeMatrixType
argument_list|(
name|varying
operator|->
name|type
argument_list|)
decl_stmt|;
comment|// matrices within varying structs are not transposed
name|int
name|registers
init|=
operator|(
name|varying
operator|->
name|isStruct
argument_list|()
condition|?
name|HLSLVariableRegisterCount
argument_list|(
operator|*
name|varying
argument_list|)
else|:
name|VariableRowCount
argument_list|(
name|transposedType
argument_list|)
operator|)
operator|*
name|varying
operator|->
name|elementCount
argument_list|()
decl_stmt|;
name|int
name|elements
init|=
operator|(
name|varying
operator|->
name|isStruct
argument_list|()
condition|?
literal|4
else|:
name|VariableColumnCount
argument_list|(
name|transposedType
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|elements
operator|>=
literal|2
operator|&&
name|elements
operator|<=
literal|4
condition|)
block|{
for|for
control|(
name|int
name|r
init|=
literal|0
init|;
name|r
operator|<=
name|maxVaryingVectors
operator|-
name|registers
condition|;
name|r
operator|++
control|)
block|{
name|bool
name|available
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|registers
operator|&&
name|available
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|elements
operator|&&
name|available
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|packing
index|[
name|r
operator|+
name|y
index|]
index|[
name|x
index|]
condition|)
block|{
name|available
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|available
condition|)
block|{
name|varying
operator|->
name|registerIndex
operator|=
name|r
expr_stmt|;
name|varying
operator|->
name|columnIndex
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|registers
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|elements
condition|;
name|x
operator|++
control|)
block|{
name|packing
index|[
name|r
operator|+
name|y
index|]
index|[
name|x
index|]
operator|=
operator|&
operator|*
name|varying
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
if|if
condition|(
name|elements
operator|==
literal|2
condition|)
block|{
for|for
control|(
name|int
name|r
init|=
name|maxVaryingVectors
operator|-
name|registers
init|;
name|r
operator|>=
literal|0
condition|;
name|r
operator|--
control|)
block|{
name|bool
name|available
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|registers
operator|&&
name|available
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|2
init|;
name|x
operator|<
literal|4
operator|&&
name|available
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|packing
index|[
name|r
operator|+
name|y
index|]
index|[
name|x
index|]
condition|)
block|{
name|available
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|available
condition|)
block|{
name|varying
operator|->
name|registerIndex
operator|=
name|r
expr_stmt|;
name|varying
operator|->
name|columnIndex
operator|=
literal|2
expr_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|registers
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|2
init|;
name|x
operator|<
literal|4
condition|;
name|x
operator|++
control|)
block|{
name|packing
index|[
name|r
operator|+
name|y
index|]
index|[
name|x
index|]
operator|=
operator|&
operator|*
name|varying
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|elements
operator|==
literal|1
condition|)
block|{
name|int
name|space
index|[
literal|4
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|maxVaryingVectors
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
literal|4
condition|;
name|x
operator|++
control|)
block|{
name|space
index|[
name|x
index|]
operator|+=
name|packing
index|[
name|y
index|]
index|[
name|x
index|]
condition|?
literal|0
else|:
literal|1
expr_stmt|;
block|}
block|}
name|int
name|column
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
literal|4
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|space
index|[
name|x
index|]
operator|>=
name|registers
operator|&&
operator|(
name|space
index|[
name|column
index|]
operator|<
name|registers
operator|||
name|space
index|[
name|x
index|]
operator|<
name|space
index|[
name|column
index|]
operator|)
condition|)
block|{
name|column
operator|=
name|x
expr_stmt|;
block|}
block|}
if|if
condition|(
name|space
index|[
name|column
index|]
operator|>=
name|registers
condition|)
block|{
for|for
control|(
name|int
name|r
init|=
literal|0
init|;
name|r
operator|<
name|maxVaryingVectors
condition|;
name|r
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|packing
index|[
name|r
index|]
index|[
name|column
index|]
condition|)
block|{
name|varying
operator|->
name|registerIndex
operator|=
name|r
expr_stmt|;
name|varying
operator|->
name|columnIndex
operator|=
name|column
expr_stmt|;
for|for
control|(
name|int
name|y
init|=
name|r
init|;
name|y
operator|<
name|r
operator|+
name|registers
condition|;
name|y
operator|++
control|)
block|{
name|packing
index|[
name|y
index|]
index|[
name|column
index|]
operator|=
operator|&
operator|*
name|varying
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Packs varyings into generic varying registers, using the algorithm from [OpenGL ES Shading Language 1.00 rev. 17] appendix A section 7 page 111
comment|// Returns the number of used varying registers, or -1 if unsuccesful
DECL|function|packVaryings
name|int
name|DynamicHLSL
operator|::
name|packVaryings
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
name|VaryingPacking
name|packing
parameter_list|,
name|rx
operator|::
name|ShaderD3D
modifier|*
name|fragmentShader
parameter_list|,
name|rx
operator|::
name|ShaderD3D
modifier|*
name|vertexShader
parameter_list|,
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|std
operator|::
name|string
argument_list|>
modifier|&
name|transformFeedbackVaryings
parameter_list|)
block|{
comment|// TODO (geofflang):  Use context's caps
specifier|const
name|int
name|maxVaryingVectors
init|=
name|mRenderer
operator|->
name|getRendererCaps
argument_list|()
operator|.
name|maxVaryingVectors
decl_stmt|;
name|vertexShader
operator|->
name|resetVaryingsRegisterAssignment
argument_list|()
expr_stmt|;
name|fragmentShader
operator|->
name|resetVaryingsRegisterAssignment
argument_list|()
expr_stmt|;
name|std
operator|::
name|set
argument_list|<
name|std
operator|::
name|string
argument_list|>
name|packedVaryings
decl_stmt|;
name|std
operator|::
name|vector
argument_list|<
name|gl
operator|::
name|PackedVarying
argument_list|>
modifier|&
name|fragmentVaryings
init|=
name|fragmentShader
operator|->
name|getVaryings
argument_list|()
decl_stmt|;
name|std
operator|::
name|vector
argument_list|<
name|gl
operator|::
name|PackedVarying
argument_list|>
modifier|&
name|vertexVaryings
init|=
name|vertexShader
operator|->
name|getVaryings
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|varyingIndex
init|=
literal|0
init|;
name|varyingIndex
operator|<
name|fragmentVaryings
operator|.
name|size
argument_list|()
condition|;
name|varyingIndex
operator|++
control|)
block|{
name|PackedVarying
modifier|*
name|varying
init|=
operator|&
name|fragmentVaryings
index|[
name|varyingIndex
index|]
decl_stmt|;
comment|// Do not assign registers to built-in or unreferenced varyings
if|if
condition|(
name|varying
operator|->
name|isBuiltIn
argument_list|()
operator|||
operator|!
name|varying
operator|->
name|staticUse
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|packVarying
argument_list|(
name|varying
argument_list|,
name|maxVaryingVectors
argument_list|,
name|packing
argument_list|)
condition|)
block|{
name|packedVaryings
operator|.
name|insert
argument_list|(
name|varying
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Could not pack varying %s"
argument_list|,
name|varying
operator|->
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
for|for
control|(
name|unsigned
name|int
name|feedbackVaryingIndex
init|=
literal|0
init|;
name|feedbackVaryingIndex
operator|<
name|transformFeedbackVaryings
operator|.
name|size
argument_list|()
condition|;
name|feedbackVaryingIndex
operator|++
control|)
block|{
specifier|const
name|std
operator|::
name|string
modifier|&
name|transformFeedbackVarying
init|=
name|transformFeedbackVaryings
index|[
name|feedbackVaryingIndex
index|]
decl_stmt|;
if|if
condition|(
name|packedVaryings
operator|.
name|find
argument_list|(
name|transformFeedbackVarying
argument_list|)
operator|==
name|packedVaryings
operator|.
name|end
argument_list|()
condition|)
block|{
name|bool
name|found
init|=
literal|false
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|varyingIndex
init|=
literal|0
init|;
name|varyingIndex
operator|<
name|vertexVaryings
operator|.
name|size
argument_list|()
condition|;
name|varyingIndex
operator|++
control|)
block|{
name|PackedVarying
modifier|*
name|varying
init|=
operator|&
name|vertexVaryings
index|[
name|varyingIndex
index|]
decl_stmt|;
if|if
condition|(
name|transformFeedbackVarying
operator|==
name|varying
operator|->
name|name
condition|)
block|{
if|if
condition|(
operator|!
name|packVarying
argument_list|(
name|varying
argument_list|,
name|maxVaryingVectors
argument_list|,
name|packing
argument_list|)
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Could not pack varying %s"
argument_list|,
name|varying
operator|->
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
operator|&&
name|transformFeedbackVarying
operator|!=
literal|"gl_Position"
operator|&&
name|transformFeedbackVarying
operator|!=
literal|"gl_PointSize"
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Transform feedback varying %s does not exist in the vertex shader."
argument_list|,
name|transformFeedbackVarying
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
comment|// Return the number of used registers
name|int
name|registers
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|r
init|=
literal|0
init|;
name|r
operator|<
name|maxVaryingVectors
condition|;
name|r
operator|++
control|)
block|{
if|if
condition|(
name|packing
index|[
name|r
index|]
index|[
literal|0
index|]
operator|||
name|packing
index|[
name|r
index|]
index|[
literal|1
index|]
operator|||
name|packing
index|[
name|r
index|]
index|[
literal|2
index|]
operator|||
name|packing
index|[
name|r
index|]
index|[
literal|3
index|]
condition|)
block|{
name|registers
operator|++
expr_stmt|;
block|}
block|}
return|return
name|registers
return|;
block|}
DECL|function|generateVaryingHLSL
name|std
operator|::
name|string
name|DynamicHLSL
operator|::
name|generateVaryingHLSL
parameter_list|(
specifier|const
name|ShaderD3D
modifier|*
name|shader
parameter_list|)
specifier|const
block|{
name|std
operator|::
name|string
name|varyingSemantic
init|=
name|getVaryingSemantic
argument_list|(
name|shader
operator|->
name|mUsesPointSize
argument_list|)
decl_stmt|;
name|std
operator|::
name|string
name|varyingHLSL
decl_stmt|;
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|gl
operator|::
name|PackedVarying
argument_list|>
modifier|&
name|varyings
init|=
name|shader
operator|->
name|getVaryings
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|varyingIndex
init|=
literal|0
init|;
name|varyingIndex
operator|<
name|varyings
operator|.
name|size
argument_list|()
condition|;
name|varyingIndex
operator|++
control|)
block|{
specifier|const
name|PackedVarying
modifier|&
name|varying
init|=
name|varyings
index|[
name|varyingIndex
index|]
decl_stmt|;
if|if
condition|(
name|varying
operator|.
name|registerAssigned
argument_list|()
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|varying
operator|.
name|isBuiltIn
argument_list|()
argument_list|)
expr_stmt|;
name|GLenum
name|transposedType
init|=
name|TransposeMatrixType
argument_list|(
name|varying
operator|.
name|type
argument_list|)
decl_stmt|;
name|int
name|variableRows
init|=
operator|(
name|varying
operator|.
name|isStruct
argument_list|()
condition|?
literal|1
else|:
name|VariableRowCount
argument_list|(
name|transposedType
argument_list|)
operator|)
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|elementIndex
init|=
literal|0
init|;
name|elementIndex
operator|<
name|varying
operator|.
name|elementCount
argument_list|()
condition|;
name|elementIndex
operator|++
control|)
block|{
for|for
control|(
name|int
name|row
init|=
literal|0
init|;
name|row
operator|<
name|variableRows
condition|;
name|row
operator|++
control|)
block|{
comment|// TODO: Add checks to ensure D3D interpolation modifiers don't result in too many registers being used.
comment|// For example, if there are N registers, and we have N vec3 varyings and 1 float varying, then D3D will pack them into N registers.
comment|// If the float varying has the 'nointerpolation' modifier on it then we would need N + 1 registers, and D3D compilation will fail.
switch|switch
condition|(
name|varying
operator|.
name|interpolation
condition|)
block|{
case|case
name|sh
operator|::
name|INTERPOLATION_SMOOTH
case|:
name|varyingHLSL
operator|+=
literal|"    "
expr_stmt|;
break|break;
case|case
name|sh
operator|::
name|INTERPOLATION_FLAT
case|:
name|varyingHLSL
operator|+=
literal|"    nointerpolation "
expr_stmt|;
break|break;
case|case
name|sh
operator|::
name|INTERPOLATION_CENTROID
case|:
name|varyingHLSL
operator|+=
literal|"    centroid "
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
name|unsigned
name|int
name|semanticIndex
init|=
name|elementIndex
operator|*
name|variableRows
operator|+
name|varying
operator|.
name|columnIndex
operator|*
name|mRenderer
operator|->
name|getRendererCaps
argument_list|()
operator|.
name|maxVaryingVectors
operator|+
name|varying
operator|.
name|registerIndex
operator|+
name|row
decl_stmt|;
name|std
operator|::
name|string
name|n
init|=
name|Str
argument_list|(
name|semanticIndex
argument_list|)
decl_stmt|;
name|std
operator|::
name|string
name|typeString
decl_stmt|;
if|if
condition|(
name|varying
operator|.
name|isStruct
argument_list|()
condition|)
block|{
comment|// matrices within structs are not transposed, so
comment|// do not use the special struct prefix "rm"
name|typeString
operator|=
name|decorateVariable
argument_list|(
name|varying
operator|.
name|structName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|GLenum
name|componentType
init|=
name|VariableComponentType
argument_list|(
name|transposedType
argument_list|)
decl_stmt|;
name|int
name|columnCount
init|=
name|VariableColumnCount
argument_list|(
name|transposedType
argument_list|)
decl_stmt|;
name|typeString
operator|=
name|HLSLComponentTypeString
argument_list|(
name|componentType
argument_list|,
name|columnCount
argument_list|)
expr_stmt|;
block|}
name|varyingHLSL
operator|+=
name|typeString
operator|+
literal|" v"
operator|+
name|n
operator|+
literal|" : "
operator|+
name|varyingSemantic
operator|+
name|n
operator|+
literal|";\n"
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|varyingHLSL
return|;
block|}
DECL|function|generateVertexShaderForInputLayout
name|std
operator|::
name|string
name|DynamicHLSL
operator|::
name|generateVertexShaderForInputLayout
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|sourceShader
parameter_list|,
specifier|const
name|VertexFormat
name|inputLayout
index|[]
parameter_list|,
specifier|const
name|sh
operator|::
name|Attribute
name|shaderAttributes
index|[]
parameter_list|)
specifier|const
block|{
name|std
operator|::
name|string
name|structHLSL
decl_stmt|,
name|initHLSL
decl_stmt|;
name|int
name|semanticIndex
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|inputIndex
init|=
literal|0
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|attributeIndex
init|=
literal|0
init|;
name|attributeIndex
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|attributeIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|Attribute
modifier|&
name|shaderAttribute
init|=
name|shaderAttributes
index|[
name|attributeIndex
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|shaderAttribute
operator|.
name|name
operator|.
name|empty
argument_list|()
condition|)
block|{
name|ASSERT
argument_list|(
name|inputIndex
operator|<
name|MAX_VERTEX_ATTRIBS
argument_list|)
expr_stmt|;
specifier|const
name|VertexFormat
modifier|&
name|vertexFormat
init|=
name|inputLayout
index|[
name|inputIndex
index|]
decl_stmt|;
comment|// HLSL code for input structure
if|if
condition|(
name|IsMatrixType
argument_list|(
name|shaderAttribute
operator|.
name|type
argument_list|)
condition|)
block|{
comment|// Matrix types are always transposed
name|structHLSL
operator|+=
literal|"    "
operator|+
name|HLSLMatrixTypeString
argument_list|(
name|TransposeMatrixType
argument_list|(
name|shaderAttribute
operator|.
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|GLenum
name|componentType
init|=
name|mRenderer
operator|->
name|getVertexComponentType
argument_list|(
name|vertexFormat
argument_list|)
decl_stmt|;
name|structHLSL
operator|+=
literal|"    "
operator|+
name|HLSLComponentTypeString
argument_list|(
name|componentType
argument_list|,
name|VariableComponentCount
argument_list|(
name|shaderAttribute
operator|.
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|structHLSL
operator|+=
literal|" "
operator|+
name|decorateVariable
argument_list|(
name|shaderAttribute
operator|.
name|name
argument_list|)
operator|+
literal|" : TEXCOORD"
operator|+
name|Str
argument_list|(
name|semanticIndex
argument_list|)
operator|+
literal|";\n"
expr_stmt|;
name|semanticIndex
operator|+=
name|VariableRegisterCount
argument_list|(
name|shaderAttribute
operator|.
name|type
argument_list|)
expr_stmt|;
comment|// HLSL code for initialization
name|initHLSL
operator|+=
literal|"    "
operator|+
name|decorateVariable
argument_list|(
name|shaderAttribute
operator|.
name|name
argument_list|)
operator|+
literal|" = "
expr_stmt|;
comment|// Mismatched vertex attribute to vertex input may result in an undefined
comment|// data reinterpretation (eg for pure integer->float, float->pure integer)
comment|// TODO: issue warning with gl debug info extension, when supported
if|if
condition|(
name|IsMatrixType
argument_list|(
name|shaderAttribute
operator|.
name|type
argument_list|)
operator|||
operator|(
name|mRenderer
operator|->
name|getVertexConversionType
argument_list|(
name|vertexFormat
argument_list|)
operator|&
name|rx
operator|::
name|VERTEX_CONVERT_GPU
operator|)
operator|!=
literal|0
condition|)
block|{
name|initHLSL
operator|+=
name|generateAttributeConversionHLSL
argument_list|(
name|vertexFormat
argument_list|,
name|shaderAttribute
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|initHLSL
operator|+=
literal|"input."
operator|+
name|decorateVariable
argument_list|(
name|shaderAttribute
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|initHLSL
operator|+=
literal|";\n"
expr_stmt|;
name|inputIndex
operator|+=
name|VariableRowCount
argument_list|(
name|TransposeMatrixType
argument_list|(
name|shaderAttribute
operator|.
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|std
operator|::
name|string
name|replacementHLSL
init|=
literal|"struct VS_INPUT\n"
literal|"{\n"
operator|+
name|structHLSL
operator|+
literal|"};\n"
literal|"\n"
literal|"void initAttributes(VS_INPUT input)\n"
literal|"{\n"
operator|+
name|initHLSL
operator|+
literal|"}\n"
decl_stmt|;
name|std
operator|::
name|string
name|vertexHLSL
argument_list|(
name|sourceShader
argument_list|)
decl_stmt|;
name|size_t
name|copyInsertionPos
init|=
name|vertexHLSL
operator|.
name|find
argument_list|(
name|VERTEX_ATTRIBUTE_STUB_STRING
argument_list|)
decl_stmt|;
name|vertexHLSL
operator|.
name|replace
argument_list|(
name|copyInsertionPos
argument_list|,
name|VERTEX_ATTRIBUTE_STUB_STRING
operator|.
name|length
argument_list|()
argument_list|,
name|replacementHLSL
argument_list|)
expr_stmt|;
return|return
name|vertexHLSL
return|;
block|}
DECL|function|generatePixelShaderForOutputSignature
name|std
operator|::
name|string
name|DynamicHLSL
operator|::
name|generatePixelShaderForOutputSignature
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|sourceShader
parameter_list|,
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|PixelShaderOutputVariable
argument_list|>
modifier|&
name|outputVariables
parameter_list|,
name|bool
name|usesFragDepth
parameter_list|,
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|GLenum
argument_list|>
modifier|&
name|outputLayout
parameter_list|)
specifier|const
block|{
specifier|const
name|int
name|shaderModel
init|=
name|mRenderer
operator|->
name|getMajorShaderModel
argument_list|()
decl_stmt|;
name|std
operator|::
name|string
name|targetSemantic
init|=
operator|(
name|shaderModel
operator|>=
literal|4
operator|)
condition|?
literal|"SV_TARGET"
else|:
literal|"COLOR"
decl_stmt|;
name|std
operator|::
name|string
name|depthSemantic
init|=
operator|(
name|shaderModel
operator|>=
literal|4
operator|)
condition|?
literal|"SV_Depth"
else|:
literal|"DEPTH"
decl_stmt|;
name|std
operator|::
name|string
name|declarationHLSL
decl_stmt|;
name|std
operator|::
name|string
name|copyHLSL
decl_stmt|;
for|for
control|(
name|size_t
name|layoutIndex
init|=
literal|0
init|;
name|layoutIndex
operator|<
name|outputLayout
operator|.
name|size
argument_list|()
condition|;
operator|++
name|layoutIndex
control|)
block|{
name|GLenum
name|binding
init|=
name|outputLayout
index|[
name|layoutIndex
index|]
decl_stmt|;
if|if
condition|(
name|binding
operator|!=
name|GL_NONE
condition|)
block|{
name|unsigned
name|int
name|location
init|=
operator|(
name|binding
operator|-
name|GL_COLOR_ATTACHMENT0
operator|)
decl_stmt|;
specifier|const
name|PixelShaderOutputVariable
modifier|&
name|outputVariable
init|=
name|GetOutputAtLocation
argument_list|(
name|outputVariables
argument_list|,
name|location
argument_list|)
decl_stmt|;
name|declarationHLSL
operator|+=
literal|"    "
operator|+
name|HLSLTypeString
argument_list|(
name|outputVariable
operator|.
name|type
argument_list|)
operator|+
literal|" "
operator|+
name|outputVariable
operator|.
name|name
operator|+
literal|" : "
operator|+
name|targetSemantic
operator|+
name|Str
argument_list|(
name|layoutIndex
argument_list|)
operator|+
literal|";\n"
expr_stmt|;
name|copyHLSL
operator|+=
literal|"    output."
operator|+
name|outputVariable
operator|.
name|name
operator|+
literal|" = "
operator|+
name|outputVariable
operator|.
name|source
operator|+
literal|";\n"
expr_stmt|;
block|}
block|}
if|if
condition|(
name|usesFragDepth
condition|)
block|{
name|declarationHLSL
operator|+=
literal|"    float gl_Depth : "
operator|+
name|depthSemantic
operator|+
literal|";\n"
expr_stmt|;
name|copyHLSL
operator|+=
literal|"    output.gl_Depth = gl_Depth; \n"
expr_stmt|;
block|}
name|std
operator|::
name|string
name|replacementHLSL
init|=
literal|"struct PS_OUTPUT\n"
literal|"{\n"
operator|+
name|declarationHLSL
operator|+
literal|"};\n"
literal|"\n"
literal|"PS_OUTPUT generateOutput()\n"
literal|"{\n"
literal|"    PS_OUTPUT output;\n"
operator|+
name|copyHLSL
operator|+
literal|"    return output;\n"
literal|"}\n"
decl_stmt|;
name|std
operator|::
name|string
name|pixelHLSL
argument_list|(
name|sourceShader
argument_list|)
decl_stmt|;
name|size_t
name|outputInsertionPos
init|=
name|pixelHLSL
operator|.
name|find
argument_list|(
name|PIXEL_OUTPUT_STUB_STRING
argument_list|)
decl_stmt|;
name|pixelHLSL
operator|.
name|replace
argument_list|(
name|outputInsertionPos
argument_list|,
name|PIXEL_OUTPUT_STUB_STRING
operator|.
name|length
argument_list|()
argument_list|,
name|replacementHLSL
argument_list|)
expr_stmt|;
return|return
name|pixelHLSL
return|;
block|}
DECL|function|getVaryingSemantic
name|std
operator|::
name|string
name|DynamicHLSL
operator|::
name|getVaryingSemantic
parameter_list|(
name|bool
name|pointSize
parameter_list|)
specifier|const
block|{
comment|// SM3 reserves the TEXCOORD semantic for point sprite texcoords (gl_PointCoord)
comment|// In D3D11 we manually compute gl_PointCoord in the GS.
name|int
name|shaderModel
init|=
name|mRenderer
operator|->
name|getMajorShaderModel
argument_list|()
decl_stmt|;
return|return
operator|(
operator|(
name|pointSize
operator|&&
name|shaderModel
operator|<
literal|4
operator|)
condition|?
literal|"COLOR"
else|:
literal|"TEXCOORD"
operator|)
return|;
block|}
DECL|struct|SemanticInfo
struct|struct
name|DynamicHLSL
operator|::
name|SemanticInfo
block|{
DECL|struct|BuiltinInfo
struct|struct
name|BuiltinInfo
block|{
DECL|function|BuiltinInfo
name|BuiltinInfo
parameter_list|()
member_init_list|:
name|enabled
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|index
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|systemValue
argument_list|(
literal|false
argument_list|)
block|{}
DECL|member|enabled
name|bool
name|enabled
decl_stmt|;
DECL|member|semantic
name|std
operator|::
name|string
name|semantic
decl_stmt|;
DECL|member|index
name|unsigned
name|int
name|index
decl_stmt|;
DECL|member|systemValue
name|bool
name|systemValue
decl_stmt|;
DECL|function|str
name|std
operator|::
name|string
name|str
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|systemValue
condition|?
name|semantic
else|:
operator|(
name|semantic
operator|+
name|Str
argument_list|(
name|index
argument_list|)
operator|)
operator|)
return|;
block|}
DECL|function|enableSystem
name|void
name|enableSystem
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|systemValueSemantic
parameter_list|)
block|{
name|enabled
operator|=
literal|true
expr_stmt|;
name|semantic
operator|=
name|systemValueSemantic
expr_stmt|;
name|systemValue
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|enable
name|void
name|enable
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|semanticVal
parameter_list|,
name|unsigned
name|int
name|indexVal
parameter_list|)
block|{
name|enabled
operator|=
literal|true
expr_stmt|;
name|semantic
operator|=
name|semanticVal
expr_stmt|;
name|index
operator|=
name|indexVal
expr_stmt|;
block|}
block|}
struct|;
DECL|member|dxPosition
name|BuiltinInfo
name|dxPosition
decl_stmt|;
DECL|member|glPosition
name|BuiltinInfo
name|glPosition
decl_stmt|;
DECL|member|glFragCoord
name|BuiltinInfo
name|glFragCoord
decl_stmt|;
DECL|member|glPointCoord
name|BuiltinInfo
name|glPointCoord
decl_stmt|;
DECL|member|glPointSize
name|BuiltinInfo
name|glPointSize
decl_stmt|;
block|}
struct|;
DECL|function|getSemanticInfo
name|DynamicHLSL
operator|::
name|SemanticInfo
name|DynamicHLSL
operator|::
name|getSemanticInfo
parameter_list|(
name|int
name|startRegisters
parameter_list|,
name|bool
name|fragCoord
parameter_list|,
name|bool
name|pointCoord
parameter_list|,
name|bool
name|pointSize
parameter_list|,
name|bool
name|pixelShader
parameter_list|)
specifier|const
block|{
name|SemanticInfo
name|info
decl_stmt|;
name|bool
name|hlsl4
init|=
operator|(
name|mRenderer
operator|->
name|getMajorShaderModel
argument_list|()
operator|>=
literal|4
operator|)
decl_stmt|;
specifier|const
name|std
operator|::
name|string
modifier|&
name|varyingSemantic
init|=
name|getVaryingSemantic
argument_list|(
name|pointSize
argument_list|)
decl_stmt|;
name|int
name|reservedRegisterIndex
init|=
name|startRegisters
decl_stmt|;
if|if
condition|(
name|hlsl4
condition|)
block|{
name|info
operator|.
name|dxPosition
operator|.
name|enableSystem
argument_list|(
literal|"SV_Position"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pixelShader
condition|)
block|{
name|info
operator|.
name|dxPosition
operator|.
name|enableSystem
argument_list|(
literal|"VPOS"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|info
operator|.
name|dxPosition
operator|.
name|enableSystem
argument_list|(
literal|"POSITION"
argument_list|)
expr_stmt|;
block|}
name|info
operator|.
name|glPosition
operator|.
name|enable
argument_list|(
name|varyingSemantic
argument_list|,
name|reservedRegisterIndex
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|fragCoord
condition|)
block|{
name|info
operator|.
name|glFragCoord
operator|.
name|enable
argument_list|(
name|varyingSemantic
argument_list|,
name|reservedRegisterIndex
operator|++
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pointCoord
condition|)
block|{
comment|// SM3 reserves the TEXCOORD semantic for point sprite texcoords (gl_PointCoord)
comment|// In D3D11 we manually compute gl_PointCoord in the GS.
if|if
condition|(
name|hlsl4
condition|)
block|{
name|info
operator|.
name|glPointCoord
operator|.
name|enable
argument_list|(
name|varyingSemantic
argument_list|,
name|reservedRegisterIndex
operator|++
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|info
operator|.
name|glPointCoord
operator|.
name|enable
argument_list|(
literal|"TEXCOORD"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Special case: do not include PSIZE semantic in HLSL 3 pixel shaders
if|if
condition|(
name|pointSize
operator|&&
operator|(
operator|!
name|pixelShader
operator|||
name|hlsl4
operator|)
condition|)
block|{
name|info
operator|.
name|glPointSize
operator|.
name|enableSystem
argument_list|(
literal|"PSIZE"
argument_list|)
expr_stmt|;
block|}
return|return
name|info
return|;
block|}
DECL|function|generateVaryingLinkHLSL
name|std
operator|::
name|string
name|DynamicHLSL
operator|::
name|generateVaryingLinkHLSL
parameter_list|(
specifier|const
name|SemanticInfo
modifier|&
name|info
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|varyingHLSL
parameter_list|)
specifier|const
block|{
name|std
operator|::
name|string
name|linkHLSL
init|=
literal|"{\n"
decl_stmt|;
name|ASSERT
argument_list|(
name|info
operator|.
name|dxPosition
operator|.
name|enabled
operator|&&
name|info
operator|.
name|glPosition
operator|.
name|enabled
argument_list|)
expr_stmt|;
name|linkHLSL
operator|+=
literal|"    float4 dx_Position : "
operator|+
name|info
operator|.
name|dxPosition
operator|.
name|str
argument_list|()
operator|+
literal|";\n"
expr_stmt|;
name|linkHLSL
operator|+=
literal|"    float4 gl_Position : "
operator|+
name|info
operator|.
name|glPosition
operator|.
name|str
argument_list|()
operator|+
literal|";\n"
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|glFragCoord
operator|.
name|enabled
condition|)
block|{
name|linkHLSL
operator|+=
literal|"    float4 gl_FragCoord : "
operator|+
name|info
operator|.
name|glFragCoord
operator|.
name|str
argument_list|()
operator|+
literal|";\n"
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|.
name|glPointCoord
operator|.
name|enabled
condition|)
block|{
name|linkHLSL
operator|+=
literal|"    float2 gl_PointCoord : "
operator|+
name|info
operator|.
name|glPointCoord
operator|.
name|str
argument_list|()
operator|+
literal|";\n"
expr_stmt|;
block|}
name|linkHLSL
operator|+=
name|varyingHLSL
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|glPointSize
operator|.
name|enabled
condition|)
block|{
name|linkHLSL
operator|+=
literal|"    float gl_PointSize : "
operator|+
name|info
operator|.
name|glPointSize
operator|.
name|str
argument_list|()
operator|+
literal|";\n"
expr_stmt|;
block|}
name|linkHLSL
operator|+=
literal|"};\n"
expr_stmt|;
return|return
name|linkHLSL
return|;
block|}
DECL|function|storeBuiltinLinkedVaryings
name|void
name|DynamicHLSL
operator|::
name|storeBuiltinLinkedVaryings
parameter_list|(
specifier|const
name|SemanticInfo
modifier|&
name|info
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|LinkedVarying
argument_list|>
modifier|*
name|linkedVaryings
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|info
operator|.
name|glPosition
operator|.
name|enabled
argument_list|)
expr_stmt|;
name|linkedVaryings
operator|->
name|push_back
argument_list|(
name|LinkedVarying
argument_list|(
literal|"gl_Position"
argument_list|,
name|GL_FLOAT_VEC4
argument_list|,
literal|1
argument_list|,
name|info
operator|.
name|glPosition
operator|.
name|semantic
argument_list|,
name|info
operator|.
name|glPosition
operator|.
name|index
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|glFragCoord
operator|.
name|enabled
condition|)
block|{
name|linkedVaryings
operator|->
name|push_back
argument_list|(
name|LinkedVarying
argument_list|(
literal|"gl_FragCoord"
argument_list|,
name|GL_FLOAT_VEC4
argument_list|,
literal|1
argument_list|,
name|info
operator|.
name|glFragCoord
operator|.
name|semantic
argument_list|,
name|info
operator|.
name|glFragCoord
operator|.
name|index
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|.
name|glPointSize
operator|.
name|enabled
condition|)
block|{
name|linkedVaryings
operator|->
name|push_back
argument_list|(
name|LinkedVarying
argument_list|(
literal|"gl_PointSize"
argument_list|,
name|GL_FLOAT
argument_list|,
literal|1
argument_list|,
literal|"PSIZE"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|storeUserLinkedVaryings
name|void
name|DynamicHLSL
operator|::
name|storeUserLinkedVaryings
parameter_list|(
specifier|const
name|rx
operator|::
name|ShaderD3D
modifier|*
name|vertexShader
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|LinkedVarying
argument_list|>
modifier|*
name|linkedVaryings
parameter_list|)
specifier|const
block|{
specifier|const
name|std
operator|::
name|string
modifier|&
name|varyingSemantic
init|=
name|getVaryingSemantic
argument_list|(
name|vertexShader
operator|->
name|mUsesPointSize
argument_list|)
decl_stmt|;
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|PackedVarying
argument_list|>
modifier|&
name|varyings
init|=
name|vertexShader
operator|->
name|getVaryings
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|varyingIndex
init|=
literal|0
init|;
name|varyingIndex
operator|<
name|varyings
operator|.
name|size
argument_list|()
condition|;
name|varyingIndex
operator|++
control|)
block|{
specifier|const
name|PackedVarying
modifier|&
name|varying
init|=
name|varyings
index|[
name|varyingIndex
index|]
decl_stmt|;
if|if
condition|(
name|varying
operator|.
name|registerAssigned
argument_list|()
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|varying
operator|.
name|isBuiltIn
argument_list|()
argument_list|)
expr_stmt|;
name|GLenum
name|transposedType
init|=
name|TransposeMatrixType
argument_list|(
name|varying
operator|.
name|type
argument_list|)
decl_stmt|;
name|int
name|variableRows
init|=
operator|(
name|varying
operator|.
name|isStruct
argument_list|()
condition|?
literal|1
else|:
name|VariableRowCount
argument_list|(
name|transposedType
argument_list|)
operator|)
decl_stmt|;
name|linkedVaryings
operator|->
name|push_back
argument_list|(
name|LinkedVarying
argument_list|(
name|varying
operator|.
name|name
argument_list|,
name|varying
operator|.
name|type
argument_list|,
name|varying
operator|.
name|elementCount
argument_list|()
argument_list|,
name|varyingSemantic
argument_list|,
name|varying
operator|.
name|registerIndex
argument_list|,
name|variableRows
operator|*
name|varying
operator|.
name|elementCount
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|generateShaderLinkHLSL
name|bool
name|DynamicHLSL
operator|::
name|generateShaderLinkHLSL
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
name|int
name|registers
parameter_list|,
specifier|const
name|VaryingPacking
name|packing
parameter_list|,
name|std
operator|::
name|string
modifier|&
name|pixelHLSL
parameter_list|,
name|std
operator|::
name|string
modifier|&
name|vertexHLSL
parameter_list|,
name|rx
operator|::
name|ShaderD3D
modifier|*
name|fragmentShader
parameter_list|,
name|rx
operator|::
name|ShaderD3D
modifier|*
name|vertexShader
parameter_list|,
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|std
operator|::
name|string
argument_list|>
modifier|&
name|transformFeedbackVaryings
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|LinkedVarying
argument_list|>
modifier|*
name|linkedVaryings
parameter_list|,
name|std
operator|::
name|map
argument_list|<
name|int
argument_list|,
name|VariableLocation
argument_list|>
modifier|*
name|programOutputVars
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|PixelShaderOutputVariable
argument_list|>
modifier|*
name|outPixelShaderKey
parameter_list|,
name|bool
modifier|*
name|outUsesFragDepth
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|pixelHLSL
operator|.
name|empty
argument_list|()
operator|||
name|vertexHLSL
operator|.
name|empty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|bool
name|usesMRT
init|=
name|fragmentShader
operator|->
name|mUsesMultipleRenderTargets
decl_stmt|;
name|bool
name|usesFragColor
init|=
name|fragmentShader
operator|->
name|mUsesFragColor
decl_stmt|;
name|bool
name|usesFragData
init|=
name|fragmentShader
operator|->
name|mUsesFragData
decl_stmt|;
name|bool
name|usesFragCoord
init|=
name|fragmentShader
operator|->
name|mUsesFragCoord
decl_stmt|;
name|bool
name|usesPointCoord
init|=
name|fragmentShader
operator|->
name|mUsesPointCoord
decl_stmt|;
name|bool
name|usesPointSize
init|=
name|vertexShader
operator|->
name|mUsesPointSize
decl_stmt|;
if|if
condition|(
name|usesFragColor
operator|&&
name|usesFragData
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Cannot use both gl_FragColor and gl_FragData in the same fragment shader."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Write the HLSL input/output declarations
specifier|const
name|int
name|shaderModel
init|=
name|mRenderer
operator|->
name|getMajorShaderModel
argument_list|()
decl_stmt|;
comment|// TODO (geofflang):  Use context's caps
specifier|const
name|int
name|maxVaryingVectors
init|=
name|mRenderer
operator|->
name|getRendererCaps
argument_list|()
operator|.
name|maxVaryingVectors
decl_stmt|;
specifier|const
name|int
name|registersNeeded
init|=
name|registers
operator|+
operator|(
name|usesFragCoord
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
name|usesPointCoord
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
comment|// Two cases when writing to gl_FragColor and using ESSL 1.0:
comment|// - with a 3.0 context, the output color is copied to channel 0
comment|// - with a 2.0 context, the output color is broadcast to all channels
specifier|const
name|bool
name|broadcast
init|=
operator|(
name|fragmentShader
operator|->
name|mUsesFragColor
operator|&&
name|mRenderer
operator|->
name|getCurrentClientVersion
argument_list|()
operator|<
literal|3
operator|)
decl_stmt|;
specifier|const
name|unsigned
name|int
name|numRenderTargets
init|=
operator|(
name|broadcast
operator|||
name|usesMRT
condition|?
name|mRenderer
operator|->
name|getRendererCaps
argument_list|()
operator|.
name|maxDrawBuffers
else|:
literal|1
operator|)
decl_stmt|;
name|int
name|shaderVersion
init|=
name|vertexShader
operator|->
name|getShaderVersion
argument_list|()
decl_stmt|;
if|if
condition|(
name|registersNeeded
operator|>
name|maxVaryingVectors
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"No varying registers left to support gl_FragCoord/gl_PointCoord"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|std
operator|::
name|string
modifier|&
name|varyingHLSL
init|=
name|generateVaryingHLSL
argument_list|(
name|vertexShader
argument_list|)
decl_stmt|;
specifier|const
name|SemanticInfo
modifier|&
name|vertexSemantics
init|=
name|getSemanticInfo
argument_list|(
name|registers
argument_list|,
name|usesFragCoord
argument_list|,
literal|false
argument_list|,
name|usesPointSize
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|storeUserLinkedVaryings
argument_list|(
name|vertexShader
argument_list|,
name|linkedVaryings
argument_list|)
expr_stmt|;
name|storeBuiltinLinkedVaryings
argument_list|(
name|vertexSemantics
argument_list|,
name|linkedVaryings
argument_list|)
expr_stmt|;
comment|// Add stub string to be replaced when shader is dynamically defined by its layout
name|vertexHLSL
operator|+=
literal|"\n"
operator|+
name|VERTEX_ATTRIBUTE_STUB_STRING
operator|+
literal|"\n"
literal|"struct VS_OUTPUT\n"
operator|+
name|generateVaryingLinkHLSL
argument_list|(
name|vertexSemantics
argument_list|,
name|varyingHLSL
argument_list|)
operator|+
literal|"\n"
literal|"VS_OUTPUT main(VS_INPUT input)\n"
literal|"{\n"
literal|"    initAttributes(input);\n"
expr_stmt|;
if|if
condition|(
name|shaderModel
operator|>=
literal|4
condition|)
block|{
name|vertexHLSL
operator|+=
literal|"\n"
literal|"    gl_main();\n"
literal|"\n"
literal|"    VS_OUTPUT output;\n"
literal|"    output.gl_Position = gl_Position;\n"
literal|"    output.dx_Position.x = gl_Position.x;\n"
literal|"    output.dx_Position.y = -gl_Position.y;\n"
literal|"    output.dx_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\n"
literal|"    output.dx_Position.w = gl_Position.w;\n"
expr_stmt|;
block|}
else|else
block|{
name|vertexHLSL
operator|+=
literal|"\n"
literal|"    gl_main();\n"
literal|"\n"
literal|"    VS_OUTPUT output;\n"
literal|"    output.gl_Position = gl_Position;\n"
literal|"    output.dx_Position.x = gl_Position.x * dx_ViewAdjust.z + dx_ViewAdjust.x * gl_Position.w;\n"
literal|"    output.dx_Position.y = -(gl_Position.y * dx_ViewAdjust.w + dx_ViewAdjust.y * gl_Position.w);\n"
literal|"    output.dx_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\n"
literal|"    output.dx_Position.w = gl_Position.w;\n"
expr_stmt|;
block|}
if|if
condition|(
name|usesPointSize
operator|&&
name|shaderModel
operator|>=
literal|3
condition|)
block|{
name|vertexHLSL
operator|+=
literal|"    output.gl_PointSize = gl_PointSize;\n"
expr_stmt|;
block|}
if|if
condition|(
name|usesFragCoord
condition|)
block|{
name|vertexHLSL
operator|+=
literal|"    output.gl_FragCoord = gl_Position;\n"
expr_stmt|;
block|}
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|PackedVarying
argument_list|>
modifier|&
name|vertexVaryings
init|=
name|vertexShader
operator|->
name|getVaryings
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|vertVaryingIndex
init|=
literal|0
init|;
name|vertVaryingIndex
operator|<
name|vertexVaryings
operator|.
name|size
argument_list|()
condition|;
name|vertVaryingIndex
operator|++
control|)
block|{
specifier|const
name|PackedVarying
modifier|&
name|varying
init|=
name|vertexVaryings
index|[
name|vertVaryingIndex
index|]
decl_stmt|;
if|if
condition|(
name|varying
operator|.
name|registerAssigned
argument_list|()
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|elementIndex
init|=
literal|0
init|;
name|elementIndex
operator|<
name|varying
operator|.
name|elementCount
argument_list|()
condition|;
name|elementIndex
operator|++
control|)
block|{
name|int
name|variableRows
init|=
operator|(
name|varying
operator|.
name|isStruct
argument_list|()
condition|?
literal|1
else|:
name|VariableRowCount
argument_list|(
name|TransposeMatrixType
argument_list|(
name|varying
operator|.
name|type
argument_list|)
argument_list|)
operator|)
decl_stmt|;
for|for
control|(
name|int
name|row
init|=
literal|0
init|;
name|row
operator|<
name|variableRows
condition|;
name|row
operator|++
control|)
block|{
name|int
name|r
init|=
name|varying
operator|.
name|registerIndex
operator|+
name|varying
operator|.
name|columnIndex
operator|*
name|mRenderer
operator|->
name|getRendererCaps
argument_list|()
operator|.
name|maxVaryingVectors
operator|+
name|elementIndex
operator|*
name|variableRows
operator|+
name|row
decl_stmt|;
name|vertexHLSL
operator|+=
literal|"    output.v"
operator|+
name|Str
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|vertexHLSL
operator|+=
literal|" = _"
operator|+
name|varying
operator|.
name|name
expr_stmt|;
if|if
condition|(
name|varying
operator|.
name|isArray
argument_list|()
condition|)
block|{
name|vertexHLSL
operator|+=
name|ArrayString
argument_list|(
name|elementIndex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|variableRows
operator|>
literal|1
condition|)
block|{
name|vertexHLSL
operator|+=
name|ArrayString
argument_list|(
name|row
argument_list|)
expr_stmt|;
block|}
name|vertexHLSL
operator|+=
literal|";\n"
expr_stmt|;
block|}
block|}
block|}
block|}
name|vertexHLSL
operator|+=
literal|"\n"
literal|"    return output;\n"
literal|"}\n"
expr_stmt|;
specifier|const
name|SemanticInfo
modifier|&
name|pixelSemantics
init|=
name|getSemanticInfo
argument_list|(
name|registers
argument_list|,
name|usesFragCoord
argument_list|,
name|usesPointCoord
argument_list|,
name|usesPointSize
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|pixelHLSL
operator|+=
literal|"struct PS_INPUT\n"
operator|+
name|generateVaryingLinkHLSL
argument_list|(
name|pixelSemantics
argument_list|,
name|varyingHLSL
argument_list|)
operator|+
literal|"\n"
expr_stmt|;
if|if
condition|(
name|shaderVersion
operator|<
literal|300
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|renderTargetIndex
init|=
literal|0
init|;
name|renderTargetIndex
operator|<
name|numRenderTargets
condition|;
name|renderTargetIndex
operator|++
control|)
block|{
name|PixelShaderOutputVariable
name|outputKeyVariable
decl_stmt|;
name|outputKeyVariable
operator|.
name|type
operator|=
name|GL_FLOAT_VEC4
expr_stmt|;
name|outputKeyVariable
operator|.
name|name
operator|=
literal|"gl_Color"
operator|+
name|Str
argument_list|(
name|renderTargetIndex
argument_list|)
expr_stmt|;
name|outputKeyVariable
operator|.
name|source
operator|=
name|broadcast
condition|?
literal|"gl_Color[0]"
else|:
literal|"gl_Color["
operator|+
name|Str
argument_list|(
name|renderTargetIndex
argument_list|)
operator|+
literal|"]"
expr_stmt|;
name|outputKeyVariable
operator|.
name|outputIndex
operator|=
name|renderTargetIndex
expr_stmt|;
name|outPixelShaderKey
operator|->
name|push_back
argument_list|(
name|outputKeyVariable
argument_list|)
expr_stmt|;
block|}
operator|*
name|outUsesFragDepth
operator|=
name|fragmentShader
operator|->
name|mUsesFragDepth
expr_stmt|;
block|}
else|else
block|{
name|defineOutputVariables
argument_list|(
name|fragmentShader
argument_list|,
name|programOutputVars
argument_list|)
expr_stmt|;
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|Attribute
argument_list|>
modifier|&
name|shaderOutputVars
init|=
name|fragmentShader
operator|->
name|getActiveOutputVariables
argument_list|()
decl_stmt|;
for|for
control|(
name|auto
name|locationIt
init|=
name|programOutputVars
operator|->
name|begin
argument_list|()
init|;
name|locationIt
operator|!=
name|programOutputVars
operator|->
name|end
argument_list|()
condition|;
name|locationIt
operator|++
control|)
block|{
specifier|const
name|VariableLocation
modifier|&
name|outputLocation
init|=
name|locationIt
operator|->
name|second
decl_stmt|;
specifier|const
name|sh
operator|::
name|ShaderVariable
modifier|&
name|outputVariable
init|=
name|shaderOutputVars
index|[
name|outputLocation
operator|.
name|index
index|]
decl_stmt|;
specifier|const
name|std
operator|::
name|string
modifier|&
name|variableName
init|=
literal|"out_"
operator|+
name|outputLocation
operator|.
name|name
decl_stmt|;
specifier|const
name|std
operator|::
name|string
modifier|&
name|elementString
init|=
operator|(
name|outputLocation
operator|.
name|element
operator|==
name|GL_INVALID_INDEX
condition|?
literal|""
else|:
name|Str
argument_list|(
name|outputLocation
operator|.
name|element
argument_list|)
operator|)
decl_stmt|;
name|ASSERT
argument_list|(
name|outputVariable
operator|.
name|staticUse
argument_list|)
expr_stmt|;
name|PixelShaderOutputVariable
name|outputKeyVariable
decl_stmt|;
name|outputKeyVariable
operator|.
name|type
operator|=
name|outputVariable
operator|.
name|type
expr_stmt|;
name|outputKeyVariable
operator|.
name|name
operator|=
name|variableName
operator|+
name|elementString
expr_stmt|;
name|outputKeyVariable
operator|.
name|source
operator|=
name|variableName
operator|+
name|ArrayString
argument_list|(
name|outputLocation
operator|.
name|element
argument_list|)
expr_stmt|;
name|outputKeyVariable
operator|.
name|outputIndex
operator|=
name|locationIt
operator|->
name|first
expr_stmt|;
name|outPixelShaderKey
operator|->
name|push_back
argument_list|(
name|outputKeyVariable
argument_list|)
expr_stmt|;
block|}
operator|*
name|outUsesFragDepth
operator|=
literal|false
expr_stmt|;
block|}
name|pixelHLSL
operator|+=
name|PIXEL_OUTPUT_STUB_STRING
operator|+
literal|"\n"
expr_stmt|;
if|if
condition|(
name|fragmentShader
operator|->
name|mUsesFrontFacing
condition|)
block|{
if|if
condition|(
name|shaderModel
operator|>=
literal|4
condition|)
block|{
name|pixelHLSL
operator|+=
literal|"PS_OUTPUT main(PS_INPUT input, bool isFrontFace : SV_IsFrontFace)\n"
literal|"{\n"
expr_stmt|;
block|}
else|else
block|{
name|pixelHLSL
operator|+=
literal|"PS_OUTPUT main(PS_INPUT input, float vFace : VFACE)\n"
literal|"{\n"
expr_stmt|;
block|}
block|}
else|else
block|{
name|pixelHLSL
operator|+=
literal|"PS_OUTPUT main(PS_INPUT input)\n"
literal|"{\n"
expr_stmt|;
block|}
if|if
condition|(
name|usesFragCoord
condition|)
block|{
name|pixelHLSL
operator|+=
literal|"    float rhw = 1.0 / input.gl_FragCoord.w;\n"
expr_stmt|;
if|if
condition|(
name|shaderModel
operator|>=
literal|4
condition|)
block|{
name|pixelHLSL
operator|+=
literal|"    gl_FragCoord.x = input.dx_Position.x;\n"
literal|"    gl_FragCoord.y = input.dx_Position.y;\n"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shaderModel
operator|>=
literal|3
condition|)
block|{
name|pixelHLSL
operator|+=
literal|"    gl_FragCoord.x = input.dx_Position.x + 0.5;\n"
literal|"    gl_FragCoord.y = input.dx_Position.y + 0.5;\n"
expr_stmt|;
block|}
else|else
block|{
comment|// dx_ViewCoords contains the viewport width/2, height/2, center.x and center.y. See Renderer::setViewport()
name|pixelHLSL
operator|+=
literal|"    gl_FragCoord.x = (input.gl_FragCoord.x * rhw) * dx_ViewCoords.x + dx_ViewCoords.z;\n"
literal|"    gl_FragCoord.y = (input.gl_FragCoord.y * rhw) * dx_ViewCoords.y + dx_ViewCoords.w;\n"
expr_stmt|;
block|}
name|pixelHLSL
operator|+=
literal|"    gl_FragCoord.z = (input.gl_FragCoord.z * rhw) * dx_DepthFront.x + dx_DepthFront.y;\n"
literal|"    gl_FragCoord.w = rhw;\n"
expr_stmt|;
block|}
if|if
condition|(
name|usesPointCoord
operator|&&
name|shaderModel
operator|>=
literal|3
condition|)
block|{
name|pixelHLSL
operator|+=
literal|"    gl_PointCoord.x = input.gl_PointCoord.x;\n"
expr_stmt|;
name|pixelHLSL
operator|+=
literal|"    gl_PointCoord.y = 1.0 - input.gl_PointCoord.y;\n"
expr_stmt|;
block|}
if|if
condition|(
name|fragmentShader
operator|->
name|mUsesFrontFacing
condition|)
block|{
if|if
condition|(
name|shaderModel
operator|<=
literal|3
condition|)
block|{
name|pixelHLSL
operator|+=
literal|"    gl_FrontFacing = (vFace * dx_DepthFront.z>= 0.0);\n"
expr_stmt|;
block|}
else|else
block|{
name|pixelHLSL
operator|+=
literal|"    gl_FrontFacing = isFrontFace;\n"
expr_stmt|;
block|}
block|}
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|PackedVarying
argument_list|>
modifier|&
name|fragmentVaryings
init|=
name|fragmentShader
operator|->
name|getVaryings
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|varyingIndex
init|=
literal|0
init|;
name|varyingIndex
operator|<
name|fragmentVaryings
operator|.
name|size
argument_list|()
condition|;
name|varyingIndex
operator|++
control|)
block|{
specifier|const
name|PackedVarying
modifier|&
name|varying
init|=
name|fragmentVaryings
index|[
name|varyingIndex
index|]
decl_stmt|;
if|if
condition|(
name|varying
operator|.
name|registerAssigned
argument_list|()
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|varying
operator|.
name|isBuiltIn
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|elementIndex
init|=
literal|0
init|;
name|elementIndex
operator|<
name|varying
operator|.
name|elementCount
argument_list|()
condition|;
name|elementIndex
operator|++
control|)
block|{
name|GLenum
name|transposedType
init|=
name|TransposeMatrixType
argument_list|(
name|varying
operator|.
name|type
argument_list|)
decl_stmt|;
name|int
name|variableRows
init|=
operator|(
name|varying
operator|.
name|isStruct
argument_list|()
condition|?
literal|1
else|:
name|VariableRowCount
argument_list|(
name|transposedType
argument_list|)
operator|)
decl_stmt|;
for|for
control|(
name|int
name|row
init|=
literal|0
init|;
name|row
operator|<
name|variableRows
condition|;
name|row
operator|++
control|)
block|{
name|std
operator|::
name|string
name|n
init|=
name|Str
argument_list|(
name|varying
operator|.
name|registerIndex
operator|+
name|varying
operator|.
name|columnIndex
operator|*
name|mRenderer
operator|->
name|getRendererCaps
argument_list|()
operator|.
name|maxVaryingVectors
operator|+
name|elementIndex
operator|*
name|variableRows
operator|+
name|row
argument_list|)
decl_stmt|;
name|pixelHLSL
operator|+=
literal|"    _"
operator|+
name|varying
operator|.
name|name
expr_stmt|;
if|if
condition|(
name|varying
operator|.
name|isArray
argument_list|()
condition|)
block|{
name|pixelHLSL
operator|+=
name|ArrayString
argument_list|(
name|elementIndex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|variableRows
operator|>
literal|1
condition|)
block|{
name|pixelHLSL
operator|+=
name|ArrayString
argument_list|(
name|row
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|varying
operator|.
name|isStruct
argument_list|()
condition|)
block|{
name|pixelHLSL
operator|+=
literal|" = input.v"
operator|+
name|n
operator|+
literal|";\n"
expr_stmt|;
break|break;
block|}
else|else
block|{
switch|switch
condition|(
name|VariableColumnCount
argument_list|(
name|transposedType
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|pixelHLSL
operator|+=
literal|" = input.v"
operator|+
name|n
operator|+
literal|".x;\n"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|pixelHLSL
operator|+=
literal|" = input.v"
operator|+
name|n
operator|+
literal|".xy;\n"
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|pixelHLSL
operator|+=
literal|" = input.v"
operator|+
name|n
operator|+
literal|".xyz;\n"
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|pixelHLSL
operator|+=
literal|" = input.v"
operator|+
name|n
operator|+
literal|";\n"
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|varying
operator|.
name|isBuiltIn
argument_list|()
operator|||
operator|!
name|varying
operator|.
name|staticUse
argument_list|)
expr_stmt|;
block|}
block|}
name|pixelHLSL
operator|+=
literal|"\n"
literal|"    gl_main();\n"
literal|"\n"
literal|"    return generateOutput();\n"
literal|"}\n"
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|defineOutputVariables
name|void
name|DynamicHLSL
operator|::
name|defineOutputVariables
parameter_list|(
name|rx
operator|::
name|ShaderD3D
modifier|*
name|fragmentShader
parameter_list|,
name|std
operator|::
name|map
argument_list|<
name|int
argument_list|,
name|VariableLocation
argument_list|>
modifier|*
name|programOutputVars
parameter_list|)
specifier|const
block|{
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|Attribute
argument_list|>
modifier|&
name|shaderOutputVars
init|=
name|fragmentShader
operator|->
name|getActiveOutputVariables
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|outputVariableIndex
init|=
literal|0
init|;
name|outputVariableIndex
operator|<
name|shaderOutputVars
operator|.
name|size
argument_list|()
condition|;
name|outputVariableIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|Attribute
modifier|&
name|outputVariable
init|=
name|shaderOutputVars
index|[
name|outputVariableIndex
index|]
decl_stmt|;
specifier|const
name|int
name|baseLocation
init|=
name|outputVariable
operator|.
name|location
operator|==
operator|-
literal|1
condition|?
literal|0
else|:
name|outputVariable
operator|.
name|location
decl_stmt|;
name|ASSERT
argument_list|(
name|outputVariable
operator|.
name|staticUse
argument_list|)
expr_stmt|;
if|if
condition|(
name|outputVariable
operator|.
name|arraySize
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|elementIndex
init|=
literal|0
init|;
name|elementIndex
operator|<
name|outputVariable
operator|.
name|arraySize
condition|;
name|elementIndex
operator|++
control|)
block|{
specifier|const
name|int
name|location
init|=
name|baseLocation
operator|+
name|elementIndex
decl_stmt|;
name|ASSERT
argument_list|(
name|programOutputVars
operator|->
name|count
argument_list|(
name|location
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
operator|*
name|programOutputVars
operator|)
index|[
name|location
index|]
operator|=
name|VariableLocation
argument_list|(
name|outputVariable
operator|.
name|name
argument_list|,
name|elementIndex
argument_list|,
name|outputVariableIndex
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|programOutputVars
operator|->
name|count
argument_list|(
name|baseLocation
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
operator|*
name|programOutputVars
operator|)
index|[
name|baseLocation
index|]
operator|=
name|VariableLocation
argument_list|(
name|outputVariable
operator|.
name|name
argument_list|,
name|GL_INVALID_INDEX
argument_list|,
name|outputVariableIndex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|generateGeometryShaderHLSL
name|std
operator|::
name|string
name|DynamicHLSL
operator|::
name|generateGeometryShaderHLSL
parameter_list|(
name|int
name|registers
parameter_list|,
name|rx
operator|::
name|ShaderD3D
modifier|*
name|fragmentShader
parameter_list|,
name|rx
operator|::
name|ShaderD3D
modifier|*
name|vertexShader
parameter_list|)
specifier|const
block|{
comment|// for now we only handle point sprite emulation
name|ASSERT
argument_list|(
name|vertexShader
operator|->
name|mUsesPointSize
operator|&&
name|mRenderer
operator|->
name|getMajorShaderModel
argument_list|()
operator|>=
literal|4
argument_list|)
expr_stmt|;
return|return
name|generatePointSpriteHLSL
argument_list|(
name|registers
argument_list|,
name|fragmentShader
argument_list|,
name|vertexShader
argument_list|)
return|;
block|}
DECL|function|generatePointSpriteHLSL
name|std
operator|::
name|string
name|DynamicHLSL
operator|::
name|generatePointSpriteHLSL
parameter_list|(
name|int
name|registers
parameter_list|,
name|rx
operator|::
name|ShaderD3D
modifier|*
name|fragmentShader
parameter_list|,
name|rx
operator|::
name|ShaderD3D
modifier|*
name|vertexShader
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|registers
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vertexShader
operator|->
name|mUsesPointSize
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mRenderer
operator|->
name|getMajorShaderModel
argument_list|()
operator|>=
literal|4
argument_list|)
expr_stmt|;
name|std
operator|::
name|string
name|geomHLSL
decl_stmt|;
specifier|const
name|SemanticInfo
modifier|&
name|inSemantics
init|=
name|getSemanticInfo
argument_list|(
name|registers
argument_list|,
name|fragmentShader
operator|->
name|mUsesFragCoord
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|const
name|SemanticInfo
modifier|&
name|outSemantics
init|=
name|getSemanticInfo
argument_list|(
name|registers
argument_list|,
name|fragmentShader
operator|->
name|mUsesFragCoord
argument_list|,
name|fragmentShader
operator|->
name|mUsesPointCoord
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|std
operator|::
name|string
name|varyingHLSL
init|=
name|generateVaryingHLSL
argument_list|(
name|vertexShader
argument_list|)
decl_stmt|;
name|std
operator|::
name|string
name|inLinkHLSL
init|=
name|generateVaryingLinkHLSL
argument_list|(
name|inSemantics
argument_list|,
name|varyingHLSL
argument_list|)
decl_stmt|;
name|std
operator|::
name|string
name|outLinkHLSL
init|=
name|generateVaryingLinkHLSL
argument_list|(
name|outSemantics
argument_list|,
name|varyingHLSL
argument_list|)
decl_stmt|;
comment|// TODO(geofflang): use context's caps
name|geomHLSL
operator|+=
literal|"uniform float4 dx_ViewCoords : register(c1);\n"
literal|"\n"
literal|"struct GS_INPUT\n"
operator|+
name|inLinkHLSL
operator|+
literal|"\n"
operator|+
literal|"struct GS_OUTPUT\n"
operator|+
name|outLinkHLSL
operator|+
literal|"\n"
operator|+
literal|"\n"
literal|"static float2 pointSpriteCorners[] = \n"
literal|"{\n"
literal|"    float2( 0.5f, -0.5f),\n"
literal|"    float2( 0.5f,  0.5f),\n"
literal|"    float2(-0.5f, -0.5f),\n"
literal|"    float2(-0.5f,  0.5f)\n"
literal|"};\n"
literal|"\n"
literal|"static float2 pointSpriteTexcoords[] = \n"
literal|"{\n"
literal|"    float2(1.0f, 1.0f),\n"
literal|"    float2(1.0f, 0.0f),\n"
literal|"    float2(0.0f, 1.0f),\n"
literal|"    float2(0.0f, 0.0f)\n"
literal|"};\n"
literal|"\n"
literal|"static float minPointSize = "
operator|+
name|Str
argument_list|(
name|mRenderer
operator|->
name|getRendererCaps
argument_list|()
operator|.
name|minAliasedPointSize
argument_list|)
operator|+
literal|".0f;\n"
literal|"static float maxPointSize = "
operator|+
name|Str
argument_list|(
name|mRenderer
operator|->
name|getRendererCaps
argument_list|()
operator|.
name|maxAliasedPointSize
argument_list|)
operator|+
literal|".0f;\n"
literal|"\n"
literal|"[maxvertexcount(4)]\n"
literal|"void main(point GS_INPUT input[1], inout TriangleStream<GS_OUTPUT> outStream)\n"
literal|"{\n"
literal|"    GS_OUTPUT output = (GS_OUTPUT)0;\n"
literal|"    output.gl_Position = input[0].gl_Position;\n"
expr_stmt|;
literal|"    output.gl_PointSize = input[0].gl_PointSize;\n"
expr_stmt|;
for|for
control|(
name|int
name|r
init|=
literal|0
init|;
name|r
operator|<
name|registers
condition|;
name|r
operator|++
control|)
block|{
name|geomHLSL
operator|+=
literal|"    output.v"
operator|+
name|Str
argument_list|(
name|r
argument_list|)
operator|+
literal|" = input[0].v"
operator|+
name|Str
argument_list|(
name|r
argument_list|)
operator|+
literal|";\n"
expr_stmt|;
block|}
if|if
condition|(
name|fragmentShader
operator|->
name|mUsesFragCoord
condition|)
block|{
name|geomHLSL
operator|+=
literal|"    output.gl_FragCoord = input[0].gl_FragCoord;\n"
expr_stmt|;
block|}
name|geomHLSL
operator|+=
literal|"    \n"
literal|"    float gl_PointSize = clamp(input[0].gl_PointSize, minPointSize, maxPointSize);\n"
literal|"    float4 dx_Position = input[0].dx_Position;\n"
literal|"    float2 viewportScale = float2(1.0f / dx_ViewCoords.x, 1.0f / dx_ViewCoords.y) * dx_Position.w;\n"
expr_stmt|;
for|for
control|(
name|int
name|corner
init|=
literal|0
init|;
name|corner
operator|<
literal|4
condition|;
name|corner
operator|++
control|)
block|{
name|geomHLSL
operator|+=
literal|"    \n"
literal|"    output.dx_Position = dx_Position + float4(pointSpriteCorners["
operator|+
name|Str
argument_list|(
name|corner
argument_list|)
operator|+
literal|"] * viewportScale * gl_PointSize, 0.0f, 0.0f);\n"
expr_stmt|;
if|if
condition|(
name|fragmentShader
operator|->
name|mUsesPointCoord
condition|)
block|{
name|geomHLSL
operator|+=
literal|"    output.gl_PointCoord = pointSpriteTexcoords["
operator|+
name|Str
argument_list|(
name|corner
argument_list|)
operator|+
literal|"];\n"
expr_stmt|;
block|}
name|geomHLSL
operator|+=
literal|"    outStream.Append(output);\n"
expr_stmt|;
block|}
name|geomHLSL
operator|+=
literal|"    \n"
literal|"    outStream.RestartStrip();\n"
literal|"}\n"
expr_stmt|;
return|return
name|geomHLSL
return|;
block|}
comment|// This method needs to match OutputHLSL::decorate
DECL|function|decorateVariable
name|std
operator|::
name|string
name|DynamicHLSL
operator|::
name|decorateVariable
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|,
literal|"gl_"
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
literal|"_"
operator|+
name|name
return|;
block|}
return|return
name|name
return|;
block|}
DECL|function|generateAttributeConversionHLSL
name|std
operator|::
name|string
name|DynamicHLSL
operator|::
name|generateAttributeConversionHLSL
parameter_list|(
specifier|const
name|VertexFormat
modifier|&
name|vertexFormat
parameter_list|,
specifier|const
name|sh
operator|::
name|ShaderVariable
modifier|&
name|shaderAttrib
parameter_list|)
specifier|const
block|{
name|std
operator|::
name|string
name|attribString
init|=
literal|"input."
operator|+
name|decorateVariable
argument_list|(
name|shaderAttrib
operator|.
name|name
argument_list|)
decl_stmt|;
comment|// Matrix
if|if
condition|(
name|IsMatrixType
argument_list|(
name|shaderAttrib
operator|.
name|type
argument_list|)
condition|)
block|{
return|return
literal|"transpose("
operator|+
name|attribString
operator|+
literal|")"
return|;
block|}
name|GLenum
name|shaderComponentType
init|=
name|VariableComponentType
argument_list|(
name|shaderAttrib
operator|.
name|type
argument_list|)
decl_stmt|;
name|int
name|shaderComponentCount
init|=
name|VariableComponentCount
argument_list|(
name|shaderAttrib
operator|.
name|type
argument_list|)
decl_stmt|;
comment|// Perform integer to float conversion (if necessary)
name|bool
name|requiresTypeConversion
init|=
operator|(
name|shaderComponentType
operator|==
name|GL_FLOAT
operator|&&
name|vertexFormat
operator|.
name|mType
operator|!=
name|GL_FLOAT
operator|)
decl_stmt|;
if|if
condition|(
name|requiresTypeConversion
condition|)
block|{
comment|// TODO: normalization for 32-bit integer formats
name|ASSERT
argument_list|(
operator|!
name|vertexFormat
operator|.
name|mNormalized
operator|&&
operator|!
name|vertexFormat
operator|.
name|mPureInteger
argument_list|)
expr_stmt|;
return|return
literal|"float"
operator|+
name|Str
argument_list|(
name|shaderComponentCount
argument_list|)
operator|+
literal|"("
operator|+
name|attribString
operator|+
literal|")"
return|;
block|}
comment|// No conversion necessary
return|return
name|attribString
return|;
block|}
DECL|function|getInputLayoutSignature
name|void
name|DynamicHLSL
operator|::
name|getInputLayoutSignature
parameter_list|(
specifier|const
name|VertexFormat
name|inputLayout
index|[]
parameter_list|,
name|GLenum
name|signature
index|[]
parameter_list|)
specifier|const
block|{
for|for
control|(
name|size_t
name|inputIndex
init|=
literal|0
init|;
name|inputIndex
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|inputIndex
operator|++
control|)
block|{
specifier|const
name|VertexFormat
modifier|&
name|vertexFormat
init|=
name|inputLayout
index|[
name|inputIndex
index|]
decl_stmt|;
if|if
condition|(
name|vertexFormat
operator|.
name|mType
operator|==
name|GL_NONE
condition|)
block|{
name|signature
index|[
name|inputIndex
index|]
operator|=
name|GL_NONE
expr_stmt|;
block|}
else|else
block|{
name|bool
name|gpuConverted
init|=
operator|(
operator|(
name|mRenderer
operator|->
name|getVertexConversionType
argument_list|(
name|vertexFormat
argument_list|)
operator|&
name|rx
operator|::
name|VERTEX_CONVERT_GPU
operator|)
operator|!=
literal|0
operator|)
decl_stmt|;
name|signature
index|[
name|inputIndex
index|]
operator|=
operator|(
name|gpuConverted
condition|?
name|GL_TRUE
else|:
name|GL_FALSE
operator|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_namespace
end_unit
