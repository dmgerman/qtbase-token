begin_unit
begin_include
include|#
directive|include
file|"precompiled.h"
end_include
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright 2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// TextureD3D.cpp: Implementations of the Texture interfaces shared betweeen the D3D backends.
end_comment
begin_include
include|#
directive|include
file|"common/mathutil.h"
end_include
begin_include
include|#
directive|include
file|"common/utilities.h"
end_include
begin_include
include|#
directive|include
file|"libEGL/Surface.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Buffer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Framebuffer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/main.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/formatutils.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/BufferImpl.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/RenderTarget.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/Renderer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/ImageD3D.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/TextureD3D.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/TextureStorage.h"
end_include
begin_namespace
DECL|namespace|rx
namespace|namespace
name|rx
block|{
DECL|function|IsMipmapFiltered
name|bool
name|IsMipmapFiltered
parameter_list|(
specifier|const
name|gl
operator|::
name|SamplerState
modifier|&
name|samplerState
parameter_list|)
block|{
switch|switch
condition|(
name|samplerState
operator|.
name|minFilter
condition|)
block|{
case|case
name|GL_NEAREST
case|:
case|case
name|GL_LINEAR
case|:
return|return
literal|false
return|;
case|case
name|GL_NEAREST_MIPMAP_NEAREST
case|:
case|case
name|GL_LINEAR_MIPMAP_NEAREST
case|:
case|case
name|GL_NEAREST_MIPMAP_LINEAR
case|:
case|case
name|GL_LINEAR_MIPMAP_LINEAR
case|:
return|return
literal|true
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|IsRenderTargetUsage
name|bool
name|IsRenderTargetUsage
parameter_list|(
name|GLenum
name|usage
parameter_list|)
block|{
return|return
operator|(
name|usage
operator|==
name|GL_FRAMEBUFFER_ATTACHMENT_ANGLE
operator|)
return|;
block|}
DECL|function|TextureD3D
name|TextureD3D
operator|::
name|TextureD3D
parameter_list|(
name|Renderer
modifier|*
name|renderer
parameter_list|)
member_init_list|:
name|mRenderer
argument_list|(
name|renderer
argument_list|)
member_init_list|,
name|mUsage
argument_list|(
name|GL_NONE
argument_list|)
member_init_list|,
name|mDirtyImages
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|mImmutable
argument_list|(
literal|false
argument_list|)
block|{ }
DECL|function|~TextureD3D
name|TextureD3D
operator|::
name|~
name|TextureD3D
parameter_list|()
block|{ }
DECL|function|getBaseLevelWidth
name|GLint
name|TextureD3D
operator|::
name|getBaseLevelWidth
parameter_list|()
specifier|const
block|{
specifier|const
name|Image
modifier|*
name|baseImage
init|=
name|getBaseLevelImage
argument_list|()
decl_stmt|;
return|return
operator|(
name|baseImage
condition|?
name|baseImage
operator|->
name|getWidth
argument_list|()
else|:
literal|0
operator|)
return|;
block|}
DECL|function|getBaseLevelHeight
name|GLint
name|TextureD3D
operator|::
name|getBaseLevelHeight
parameter_list|()
specifier|const
block|{
specifier|const
name|Image
modifier|*
name|baseImage
init|=
name|getBaseLevelImage
argument_list|()
decl_stmt|;
return|return
operator|(
name|baseImage
condition|?
name|baseImage
operator|->
name|getHeight
argument_list|()
else|:
literal|0
operator|)
return|;
block|}
DECL|function|getBaseLevelDepth
name|GLint
name|TextureD3D
operator|::
name|getBaseLevelDepth
parameter_list|()
specifier|const
block|{
specifier|const
name|Image
modifier|*
name|baseImage
init|=
name|getBaseLevelImage
argument_list|()
decl_stmt|;
return|return
operator|(
name|baseImage
condition|?
name|baseImage
operator|->
name|getDepth
argument_list|()
else|:
literal|0
operator|)
return|;
block|}
comment|// Note: "base level image" is loosely defined to be any image from the base level,
comment|// where in the base of 2D array textures and cube maps there are several. Don't use
comment|// the base level image for anything except querying texture format and size.
DECL|function|getBaseLevelInternalFormat
name|GLenum
name|TextureD3D
operator|::
name|getBaseLevelInternalFormat
parameter_list|()
specifier|const
block|{
specifier|const
name|Image
modifier|*
name|baseImage
init|=
name|getBaseLevelImage
argument_list|()
decl_stmt|;
return|return
operator|(
name|baseImage
condition|?
name|baseImage
operator|->
name|getInternalFormat
argument_list|()
else|:
name|GL_NONE
operator|)
return|;
block|}
DECL|function|setImage
name|void
name|TextureD3D
operator|::
name|setImage
parameter_list|(
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|,
name|Image
modifier|*
name|image
parameter_list|)
block|{
comment|// No-op
if|if
condition|(
name|image
operator|->
name|getWidth
argument_list|()
operator|==
literal|0
operator|||
name|image
operator|->
name|getHeight
argument_list|()
operator|==
literal|0
operator|||
name|image
operator|->
name|getDepth
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return;
block|}
comment|// We no longer need the "GLenum format" parameter to TexImage to determine what data format "pixels" contains.
comment|// From our image internal format we know how many channels to expect, and "type" gives the format of pixel's components.
specifier|const
name|void
modifier|*
name|pixelData
init|=
name|pixels
decl_stmt|;
if|if
condition|(
name|unpack
operator|.
name|pixelBuffer
operator|.
name|id
argument_list|()
operator|!=
literal|0
condition|)
block|{
comment|// Do a CPU readback here, if we have an unpack buffer bound and the fast GPU path is not supported
name|gl
operator|::
name|Buffer
modifier|*
name|pixelBuffer
init|=
name|unpack
operator|.
name|pixelBuffer
operator|.
name|get
argument_list|()
decl_stmt|;
name|ptrdiff_t
name|offset
init|=
cast|reinterpret_cast
argument_list|<
name|ptrdiff_t
argument_list|>
argument_list|(
name|pixels
argument_list|)
decl_stmt|;
comment|// TODO: setImage/subImage is the only place outside of renderer that asks for a buffers raw data.
comment|// This functionality should be moved into renderer and the getData method of BufferImpl removed.
specifier|const
name|void
modifier|*
name|bufferData
init|=
name|pixelBuffer
operator|->
name|getImplementation
argument_list|()
operator|->
name|getData
argument_list|()
decl_stmt|;
name|pixelData
operator|=
cast|static_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|bufferData
argument_list|)
operator|+
name|offset
expr_stmt|;
block|}
if|if
condition|(
name|pixelData
operator|!=
name|NULL
condition|)
block|{
name|image
operator|->
name|loadData
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|image
operator|->
name|getWidth
argument_list|()
argument_list|,
name|image
operator|->
name|getHeight
argument_list|()
argument_list|,
name|image
operator|->
name|getDepth
argument_list|()
argument_list|,
name|unpack
operator|.
name|alignment
argument_list|,
name|type
argument_list|,
name|pixelData
argument_list|)
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|subImage
name|bool
name|TextureD3D
operator|::
name|subImage
parameter_list|(
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLint
name|zoffset
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|depth
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|,
name|Image
modifier|*
name|image
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|pixelData
init|=
name|pixels
decl_stmt|;
comment|// CPU readback& copy where direct GPU copy is not supported
if|if
condition|(
name|unpack
operator|.
name|pixelBuffer
operator|.
name|id
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|gl
operator|::
name|Buffer
modifier|*
name|pixelBuffer
init|=
name|unpack
operator|.
name|pixelBuffer
operator|.
name|get
argument_list|()
decl_stmt|;
name|unsigned
name|int
name|offset
init|=
cast|reinterpret_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|pixels
argument_list|)
decl_stmt|;
comment|// TODO: setImage/subImage is the only place outside of renderer that asks for a buffers raw data.
comment|// This functionality should be moved into renderer and the getData method of BufferImpl removed.
specifier|const
name|void
modifier|*
name|bufferData
init|=
name|pixelBuffer
operator|->
name|getImplementation
argument_list|()
operator|->
name|getData
argument_list|()
decl_stmt|;
name|pixelData
operator|=
cast|static_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|bufferData
argument_list|)
operator|+
name|offset
expr_stmt|;
block|}
if|if
condition|(
name|pixelData
operator|!=
name|NULL
condition|)
block|{
name|image
operator|->
name|loadData
argument_list|(
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|zoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|,
name|unpack
operator|.
name|alignment
argument_list|,
name|type
argument_list|,
name|pixelData
argument_list|)
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|setCompressedImage
name|void
name|TextureD3D
operator|::
name|setCompressedImage
parameter_list|(
name|GLsizei
name|imageSize
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|,
name|Image
modifier|*
name|image
parameter_list|)
block|{
if|if
condition|(
name|pixels
operator|!=
name|NULL
condition|)
block|{
name|image
operator|->
name|loadCompressedData
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|image
operator|->
name|getWidth
argument_list|()
argument_list|,
name|image
operator|->
name|getHeight
argument_list|()
argument_list|,
name|image
operator|->
name|getDepth
argument_list|()
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|subImageCompressed
name|bool
name|TextureD3D
operator|::
name|subImageCompressed
parameter_list|(
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLint
name|zoffset
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|depth
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLsizei
name|imageSize
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|,
name|Image
modifier|*
name|image
parameter_list|)
block|{
if|if
condition|(
name|pixels
operator|!=
name|NULL
condition|)
block|{
name|image
operator|->
name|loadCompressedData
argument_list|(
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|zoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|isFastUnpackable
name|bool
name|TextureD3D
operator|::
name|isFastUnpackable
parameter_list|(
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
name|GLenum
name|sizedInternalFormat
parameter_list|)
block|{
return|return
name|unpack
operator|.
name|pixelBuffer
operator|.
name|id
argument_list|()
operator|!=
literal|0
operator|&&
name|mRenderer
operator|->
name|supportsFastCopyBufferToTexture
argument_list|(
name|sizedInternalFormat
argument_list|)
return|;
block|}
DECL|function|fastUnpackPixels
name|bool
name|TextureD3D
operator|::
name|fastUnpackPixels
parameter_list|(
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|,
specifier|const
name|gl
operator|::
name|Box
modifier|&
name|destArea
parameter_list|,
name|GLenum
name|sizedInternalFormat
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|RenderTarget
modifier|*
name|destRenderTarget
parameter_list|)
block|{
if|if
condition|(
name|destArea
operator|.
name|width
operator|<=
literal|0
operator|&&
name|destArea
operator|.
name|height
operator|<=
literal|0
operator|&&
name|destArea
operator|.
name|depth
operator|<=
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// In order to perform the fast copy through the shader, we must have the right format, and be able
comment|// to create a render target.
name|ASSERT
argument_list|(
name|mRenderer
operator|->
name|supportsFastCopyBufferToTexture
argument_list|(
name|sizedInternalFormat
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned
name|int
name|offset
init|=
cast|reinterpret_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|pixels
argument_list|)
decl_stmt|;
return|return
name|mRenderer
operator|->
name|fastCopyBufferToTexture
argument_list|(
name|unpack
argument_list|,
name|offset
argument_list|,
name|destRenderTarget
argument_list|,
name|sizedInternalFormat
argument_list|,
name|type
argument_list|,
name|destArea
argument_list|)
return|;
block|}
DECL|function|creationLevels
name|GLint
name|TextureD3D
operator|::
name|creationLevels
parameter_list|(
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|depth
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|(
name|gl
operator|::
name|isPow2
argument_list|(
name|width
argument_list|)
operator|&&
name|gl
operator|::
name|isPow2
argument_list|(
name|height
argument_list|)
operator|&&
name|gl
operator|::
name|isPow2
argument_list|(
name|depth
argument_list|)
operator|)
operator|||
name|mRenderer
operator|->
name|getRendererExtensions
argument_list|()
operator|.
name|textureNPOT
condition|)
block|{
comment|// Maximum number of levels
return|return
name|gl
operator|::
name|log2
argument_list|(
name|std
operator|::
name|max
argument_list|(
name|std
operator|::
name|max
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
argument_list|,
name|depth
argument_list|)
argument_list|)
operator|+
literal|1
return|;
block|}
else|else
block|{
comment|// OpenGL ES 2.0 without GL_OES_texture_npot does not permit NPOT mipmaps.
return|return
literal|1
return|;
block|}
block|}
DECL|function|mipLevels
name|int
name|TextureD3D
operator|::
name|mipLevels
parameter_list|()
specifier|const
block|{
return|return
name|gl
operator|::
name|log2
argument_list|(
name|std
operator|::
name|max
argument_list|(
name|std
operator|::
name|max
argument_list|(
name|getBaseLevelWidth
argument_list|()
argument_list|,
name|getBaseLevelHeight
argument_list|()
argument_list|)
argument_list|,
name|getBaseLevelDepth
argument_list|()
argument_list|)
argument_list|)
operator|+
literal|1
return|;
block|}
DECL|function|TextureD3D_2D
name|TextureD3D_2D
operator|::
name|TextureD3D_2D
parameter_list|(
name|Renderer
modifier|*
name|renderer
parameter_list|)
member_init_list|:
name|TextureD3D
argument_list|(
name|renderer
argument_list|)
member_init_list|,
name|Texture2DImpl
argument_list|()
member_init_list|,
name|mTexStorage
argument_list|(
name|NULL
argument_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
operator|++
name|i
control|)
block|{
name|mImageArray
index|[
name|i
index|]
operator|=
name|ImageD3D
operator|::
name|makeImageD3D
argument_list|(
name|renderer
operator|->
name|createImage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|~TextureD3D_2D
name|TextureD3D_2D
operator|::
name|~
name|TextureD3D_2D
parameter_list|()
block|{
name|SafeDelete
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
operator|++
name|i
control|)
block|{
operator|delete
name|mImageArray
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
DECL|function|makeTextureD3D_2D
name|TextureD3D_2D
modifier|*
name|TextureD3D_2D
operator|::
name|makeTextureD3D_2D
parameter_list|(
name|Texture2DImpl
modifier|*
name|texture
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|HAS_DYNAMIC_TYPE
argument_list|(
name|TextureD3D_2D
operator|*
argument_list|,
name|texture
argument_list|)
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|TextureD3D_2D
operator|*
argument_list|>
argument_list|(
name|texture
argument_list|)
return|;
block|}
DECL|function|getNativeTexture
name|TextureStorageInterface
modifier|*
name|TextureD3D_2D
operator|::
name|getNativeTexture
parameter_list|()
block|{
comment|// ensure the underlying texture is created
name|initializeStorage
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|TextureStorageInterface
modifier|*
name|storage
init|=
name|getBaseLevelStorage
argument_list|()
decl_stmt|;
if|if
condition|(
name|storage
condition|)
block|{
name|updateStorage
argument_list|()
expr_stmt|;
block|}
return|return
name|storage
return|;
block|}
DECL|function|getImage
name|Image
modifier|*
name|TextureD3D_2D
operator|::
name|getImage
parameter_list|(
name|int
name|level
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
argument_list|)
expr_stmt|;
return|return
name|mImageArray
index|[
name|level
index|]
return|;
block|}
DECL|function|setUsage
name|void
name|TextureD3D_2D
operator|::
name|setUsage
parameter_list|(
name|GLenum
name|usage
parameter_list|)
block|{
name|mUsage
operator|=
name|usage
expr_stmt|;
block|}
DECL|function|resetDirty
name|void
name|TextureD3D_2D
operator|::
name|resetDirty
parameter_list|()
block|{
name|mDirtyImages
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|getWidth
name|GLsizei
name|TextureD3D_2D
operator|::
name|getWidth
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
return|return
name|mImageArray
index|[
name|level
index|]
operator|->
name|getWidth
argument_list|()
return|;
else|else
return|return
literal|0
return|;
block|}
DECL|function|getHeight
name|GLsizei
name|TextureD3D_2D
operator|::
name|getHeight
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
return|return
name|mImageArray
index|[
name|level
index|]
operator|->
name|getHeight
argument_list|()
return|;
else|else
return|return
literal|0
return|;
block|}
DECL|function|getInternalFormat
name|GLenum
name|TextureD3D_2D
operator|::
name|getInternalFormat
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
return|return
name|mImageArray
index|[
name|level
index|]
operator|->
name|getInternalFormat
argument_list|()
return|;
else|else
return|return
name|GL_NONE
return|;
block|}
DECL|function|getActualFormat
name|GLenum
name|TextureD3D_2D
operator|::
name|getActualFormat
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
return|return
name|mImageArray
index|[
name|level
index|]
operator|->
name|getActualFormat
argument_list|()
return|;
else|else
return|return
name|GL_NONE
return|;
block|}
DECL|function|isDepth
name|bool
name|TextureD3D_2D
operator|::
name|isDepth
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
return|return
name|gl
operator|::
name|GetDepthBits
argument_list|(
name|getInternalFormat
argument_list|(
name|level
argument_list|)
argument_list|)
operator|>
literal|0
return|;
block|}
DECL|function|setImage
name|void
name|TextureD3D_2D
operator|::
name|setImage
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|internalFormat
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
name|GLenum
name|sizedInternalFormat
init|=
name|gl
operator|::
name|IsSizedInternalFormat
argument_list|(
name|internalFormat
argument_list|)
condition|?
name|internalFormat
else|:
name|gl
operator|::
name|GetSizedInternalFormat
argument_list|(
name|format
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|bool
name|fastUnpacked
init|=
literal|false
decl_stmt|;
comment|// Attempt a fast gpu copy of the pixel data to the surface
if|if
condition|(
name|isFastUnpackable
argument_list|(
name|unpack
argument_list|,
name|sizedInternalFormat
argument_list|)
operator|&&
name|isLevelComplete
argument_list|(
name|level
argument_list|)
condition|)
block|{
comment|// Will try to create RT storage if it does not exist
name|RenderTarget
modifier|*
name|destRenderTarget
init|=
name|getRenderTarget
argument_list|(
name|level
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Box
name|destArea
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|getWidth
argument_list|(
name|level
argument_list|)
argument_list|,
name|getHeight
argument_list|(
name|level
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|destRenderTarget
operator|&&
name|fastUnpackPixels
argument_list|(
name|unpack
argument_list|,
name|pixels
argument_list|,
name|destArea
argument_list|,
name|sizedInternalFormat
argument_list|,
name|type
argument_list|,
name|destRenderTarget
argument_list|)
condition|)
block|{
comment|// Ensure we don't overwrite our newly initialized data
name|mImageArray
index|[
name|level
index|]
operator|->
name|markClean
argument_list|()
expr_stmt|;
name|fastUnpacked
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|fastUnpacked
condition|)
block|{
name|TextureD3D
operator|::
name|setImage
argument_list|(
name|unpack
argument_list|,
name|type
argument_list|,
name|pixels
argument_list|,
name|mImageArray
index|[
name|level
index|]
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|setCompressedImage
name|void
name|TextureD3D_2D
operator|::
name|setCompressedImage
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|imageSize
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
name|TextureD3D
operator|::
name|setCompressedImage
argument_list|(
name|imageSize
argument_list|,
name|pixels
argument_list|,
name|mImageArray
index|[
name|level
index|]
argument_list|)
expr_stmt|;
block|}
DECL|function|subImage
name|void
name|TextureD3D_2D
operator|::
name|subImage
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
name|bool
name|fastUnpacked
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|isFastUnpackable
argument_list|(
name|unpack
argument_list|,
name|getInternalFormat
argument_list|(
name|level
argument_list|)
argument_list|)
operator|&&
name|isLevelComplete
argument_list|(
name|level
argument_list|)
condition|)
block|{
name|RenderTarget
modifier|*
name|renderTarget
init|=
name|getRenderTarget
argument_list|(
name|level
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Box
name|destArea
argument_list|(
name|xoffset
argument_list|,
name|yoffset
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|renderTarget
operator|&&
name|fastUnpackPixels
argument_list|(
name|unpack
argument_list|,
name|pixels
argument_list|,
name|destArea
argument_list|,
name|getInternalFormat
argument_list|(
name|level
argument_list|)
argument_list|,
name|type
argument_list|,
name|renderTarget
argument_list|)
condition|)
block|{
comment|// Ensure we don't overwrite our newly initialized data
name|mImageArray
index|[
name|level
index|]
operator|->
name|markClean
argument_list|()
expr_stmt|;
name|fastUnpacked
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|fastUnpacked
operator|&&
name|TextureD3D
operator|::
name|subImage
argument_list|(
name|xoffset
argument_list|,
name|yoffset
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|1
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|unpack
argument_list|,
name|pixels
argument_list|,
name|mImageArray
index|[
name|level
index|]
argument_list|)
condition|)
block|{
name|commitRect
argument_list|(
name|level
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|subImageCompressed
name|void
name|TextureD3D_2D
operator|::
name|subImageCompressed
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLsizei
name|imageSize
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
if|if
condition|(
name|TextureD3D
operator|::
name|subImageCompressed
argument_list|(
name|xoffset
argument_list|,
name|yoffset
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|1
argument_list|,
name|format
argument_list|,
name|imageSize
argument_list|,
name|pixels
argument_list|,
name|mImageArray
index|[
name|level
index|]
argument_list|)
condition|)
block|{
name|commitRect
argument_list|(
name|level
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|copyImage
name|void
name|TextureD3D_2D
operator|::
name|copyImage
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|gl
operator|::
name|Framebuffer
modifier|*
name|source
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mImageArray
index|[
name|level
index|]
operator|->
name|isRenderableFormat
argument_list|()
condition|)
block|{
name|mImageArray
index|[
name|level
index|]
operator|->
name|copy
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|ensureRenderTarget
argument_list|()
expr_stmt|;
name|mImageArray
index|[
name|level
index|]
operator|->
name|markClean
argument_list|()
expr_stmt|;
if|if
condition|(
name|width
operator|!=
literal|0
operator|&&
name|height
operator|!=
literal|0
operator|&&
name|isValidLevel
argument_list|(
name|level
argument_list|)
condition|)
block|{
name|gl
operator|::
name|Rectangle
name|sourceRect
decl_stmt|;
name|sourceRect
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|sourceRect
operator|.
name|width
operator|=
name|width
expr_stmt|;
name|sourceRect
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|sourceRect
operator|.
name|height
operator|=
name|height
expr_stmt|;
name|mRenderer
operator|->
name|copyImage
argument_list|(
name|source
argument_list|,
name|sourceRect
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|mTexStorage
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|copySubImage
name|void
name|TextureD3D_2D
operator|::
name|copySubImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLint
name|zoffset
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|gl
operator|::
name|Framebuffer
modifier|*
name|source
parameter_list|)
block|{
comment|// can only make our texture storage to a render target if level 0 is defined (with a width& height) and
comment|// the current level we're copying to is defined (with appropriate format, width& height)
name|bool
name|canCreateRenderTarget
init|=
name|isLevelComplete
argument_list|(
name|level
argument_list|)
operator|&&
name|isLevelComplete
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mImageArray
index|[
name|level
index|]
operator|->
name|isRenderableFormat
argument_list|()
operator|||
operator|(
operator|!
name|mTexStorage
operator|&&
operator|!
name|canCreateRenderTarget
operator|)
condition|)
block|{
name|mImageArray
index|[
name|level
index|]
operator|->
name|copy
argument_list|(
name|xoffset
argument_list|,
name|yoffset
argument_list|,
literal|0
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|ensureRenderTarget
argument_list|()
expr_stmt|;
if|if
condition|(
name|isValidLevel
argument_list|(
name|level
argument_list|)
condition|)
block|{
name|updateStorageLevel
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|gl
operator|::
name|Rectangle
name|sourceRect
decl_stmt|;
name|sourceRect
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|sourceRect
operator|.
name|width
operator|=
name|width
expr_stmt|;
name|sourceRect
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|sourceRect
operator|.
name|height
operator|=
name|height
expr_stmt|;
name|mRenderer
operator|->
name|copyImage
argument_list|(
name|source
argument_list|,
name|sourceRect
argument_list|,
name|gl
operator|::
name|GetFormat
argument_list|(
name|getBaseLevelInternalFormat
argument_list|()
argument_list|)
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|mTexStorage
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|storage
name|void
name|TextureD3D_2D
operator|::
name|storage
parameter_list|(
name|GLsizei
name|levels
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|levels
condition|;
name|level
operator|++
control|)
block|{
name|GLsizei
name|levelWidth
init|=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|width
operator|>>
name|level
argument_list|)
decl_stmt|;
name|GLsizei
name|levelHeight
init|=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|height
operator|>>
name|level
argument_list|)
decl_stmt|;
name|mImageArray
index|[
name|level
index|]
operator|->
name|redefine
argument_list|(
name|mRenderer
argument_list|,
name|GL_TEXTURE_2D
argument_list|,
name|internalformat
argument_list|,
name|levelWidth
argument_list|,
name|levelHeight
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|level
init|=
name|levels
init|;
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|level
operator|++
control|)
block|{
name|mImageArray
index|[
name|level
index|]
operator|->
name|redefine
argument_list|(
name|mRenderer
argument_list|,
name|GL_TEXTURE_2D
argument_list|,
name|GL_NONE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|mImmutable
operator|=
literal|true
expr_stmt|;
name|setCompleteTexStorage
argument_list|(
operator|new
name|TextureStorageInterface2D
argument_list|(
name|mRenderer
argument_list|,
name|internalformat
argument_list|,
name|IsRenderTargetUsage
argument_list|(
name|mUsage
argument_list|)
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|levels
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Tests for 2D texture sampling completeness. [OpenGL ES 2.0.24] section 3.8.2 page 85.
DECL|function|isSamplerComplete
name|bool
name|TextureD3D_2D
operator|::
name|isSamplerComplete
parameter_list|(
specifier|const
name|gl
operator|::
name|SamplerState
modifier|&
name|samplerState
parameter_list|)
specifier|const
block|{
name|GLsizei
name|width
init|=
name|getBaseLevelWidth
argument_list|()
decl_stmt|;
name|GLsizei
name|height
init|=
name|getBaseLevelHeight
argument_list|()
decl_stmt|;
if|if
condition|(
name|width
operator|<=
literal|0
operator|||
name|height
operator|<=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|mRenderer
operator|->
name|getRendererTextureCaps
argument_list|()
operator|.
name|get
argument_list|(
name|getInternalFormat
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|filterable
condition|)
block|{
if|if
condition|(
name|samplerState
operator|.
name|magFilter
operator|!=
name|GL_NEAREST
operator|||
operator|(
name|samplerState
operator|.
name|minFilter
operator|!=
name|GL_NEAREST
operator|&&
name|samplerState
operator|.
name|minFilter
operator|!=
name|GL_NEAREST_MIPMAP_NEAREST
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|// TODO(geofflang): use context's extensions
name|bool
name|npotSupport
init|=
name|mRenderer
operator|->
name|getRendererExtensions
argument_list|()
operator|.
name|textureNPOT
decl_stmt|;
if|if
condition|(
operator|!
name|npotSupport
condition|)
block|{
if|if
condition|(
operator|(
name|samplerState
operator|.
name|wrapS
operator|!=
name|GL_CLAMP_TO_EDGE
operator|&&
operator|!
name|gl
operator|::
name|isPow2
argument_list|(
name|width
argument_list|)
operator|)
operator|||
operator|(
name|samplerState
operator|.
name|wrapT
operator|!=
name|GL_CLAMP_TO_EDGE
operator|&&
operator|!
name|gl
operator|::
name|isPow2
argument_list|(
name|height
argument_list|)
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|IsMipmapFiltered
argument_list|(
name|samplerState
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|npotSupport
condition|)
block|{
if|if
condition|(
operator|!
name|gl
operator|::
name|isPow2
argument_list|(
name|width
argument_list|)
operator|||
operator|!
name|gl
operator|::
name|isPow2
argument_list|(
name|height
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
operator|!
name|isMipmapComplete
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|// OpenGLES 3.0.2 spec section 3.8.13 states that a texture is not mipmap complete if:
comment|// The internalformat specified for the texture arrays is a sized internal depth or
comment|// depth and stencil format (see table 3.13), the value of TEXTURE_COMPARE_-
comment|// MODE is NONE, and either the magnification filter is not NEAREST or the mini-
comment|// fication filter is neither NEAREST nor NEAREST_MIPMAP_NEAREST.
if|if
condition|(
name|gl
operator|::
name|GetDepthBits
argument_list|(
name|getInternalFormat
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|>
literal|0
operator|&&
name|mRenderer
operator|->
name|getCurrentClientVersion
argument_list|()
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|samplerState
operator|.
name|compareMode
operator|==
name|GL_NONE
condition|)
block|{
if|if
condition|(
operator|(
name|samplerState
operator|.
name|minFilter
operator|!=
name|GL_NEAREST
operator|&&
name|samplerState
operator|.
name|minFilter
operator|!=
name|GL_NEAREST_MIPMAP_NEAREST
operator|)
operator|||
name|samplerState
operator|.
name|magFilter
operator|!=
name|GL_NEAREST
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|bindTexImage
name|void
name|TextureD3D_2D
operator|::
name|bindTexImage
parameter_list|(
name|egl
operator|::
name|Surface
modifier|*
name|surface
parameter_list|)
block|{
name|GLenum
name|internalformat
init|=
name|surface
operator|->
name|getFormat
argument_list|()
decl_stmt|;
name|mImageArray
index|[
literal|0
index|]
operator|->
name|redefine
argument_list|(
name|mRenderer
argument_list|,
name|GL_TEXTURE_2D
argument_list|,
name|internalformat
argument_list|,
name|surface
operator|->
name|getWidth
argument_list|()
argument_list|,
name|surface
operator|->
name|getHeight
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|mTexStorage
condition|)
block|{
name|SafeDelete
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
block|}
name|mTexStorage
operator|=
operator|new
name|TextureStorageInterface2D
argument_list|(
name|mRenderer
argument_list|,
name|surface
operator|->
name|getSwapChain
argument_list|()
argument_list|)
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|releaseTexImage
name|void
name|TextureD3D_2D
operator|::
name|releaseTexImage
parameter_list|()
block|{
if|if
condition|(
name|mTexStorage
condition|)
block|{
name|SafeDelete
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|i
operator|++
control|)
block|{
name|mImageArray
index|[
name|i
index|]
operator|->
name|redefine
argument_list|(
name|mRenderer
argument_list|,
name|GL_TEXTURE_2D
argument_list|,
name|GL_NONE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|generateMipmaps
name|void
name|TextureD3D_2D
operator|::
name|generateMipmaps
parameter_list|()
block|{
name|int
name|levelCount
init|=
name|mipLevels
argument_list|()
decl_stmt|;
if|if
condition|(
name|mTexStorage
operator|&&
name|mTexStorage
operator|->
name|isRenderTarget
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<
name|levelCount
condition|;
name|level
operator|++
control|)
block|{
name|mTexStorage
operator|->
name|generateMipmap
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|mImageArray
index|[
name|level
index|]
operator|->
name|markClean
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<
name|levelCount
condition|;
name|level
operator|++
control|)
block|{
name|mRenderer
operator|->
name|generateMipmap
argument_list|(
name|mImageArray
index|[
name|level
index|]
argument_list|,
name|mImageArray
index|[
name|level
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|getRenderTargetSerial
name|unsigned
name|int
name|TextureD3D_2D
operator|::
name|getRenderTargetSerial
parameter_list|(
name|GLint
name|level
parameter_list|)
block|{
return|return
operator|(
name|ensureRenderTarget
argument_list|()
condition|?
name|mTexStorage
operator|->
name|getRenderTargetSerial
argument_list|(
name|level
argument_list|)
else|:
literal|0
operator|)
return|;
block|}
DECL|function|getRenderTarget
name|RenderTarget
modifier|*
name|TextureD3D_2D
operator|::
name|getRenderTarget
parameter_list|(
name|GLint
name|level
parameter_list|)
block|{
comment|// ensure the underlying texture is created
if|if
condition|(
operator|!
name|ensureRenderTarget
argument_list|()
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|updateStorageLevel
argument_list|(
name|level
argument_list|)
expr_stmt|;
comment|// ensure this is NOT a depth texture
if|if
condition|(
name|isDepth
argument_list|(
name|level
argument_list|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
name|mTexStorage
operator|->
name|getRenderTarget
argument_list|(
name|level
argument_list|)
return|;
block|}
DECL|function|getDepthSencil
name|RenderTarget
modifier|*
name|TextureD3D_2D
operator|::
name|getDepthSencil
parameter_list|(
name|GLint
name|level
parameter_list|)
block|{
comment|// ensure the underlying texture is created
if|if
condition|(
operator|!
name|ensureRenderTarget
argument_list|()
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|updateStorageLevel
argument_list|(
name|level
argument_list|)
expr_stmt|;
comment|// ensure this is actually a depth texture
if|if
condition|(
operator|!
name|isDepth
argument_list|(
name|level
argument_list|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
name|mTexStorage
operator|->
name|getRenderTarget
argument_list|(
name|level
argument_list|)
return|;
block|}
comment|// Tests for 2D texture (mipmap) completeness. [OpenGL ES 2.0.24] section 3.7.10 page 81.
DECL|function|isMipmapComplete
name|bool
name|TextureD3D_2D
operator|::
name|isMipmapComplete
parameter_list|()
specifier|const
block|{
name|int
name|levelCount
init|=
name|mipLevels
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|levelCount
condition|;
name|level
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isLevelComplete
argument_list|(
name|level
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|isValidLevel
name|bool
name|TextureD3D_2D
operator|::
name|isValidLevel
parameter_list|(
name|int
name|level
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|mTexStorage
condition|?
operator|(
name|level
operator|>=
literal|0
operator|&&
name|level
operator|<
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
operator|)
else|:
literal|false
operator|)
return|;
block|}
DECL|function|isLevelComplete
name|bool
name|TextureD3D_2D
operator|::
name|isLevelComplete
parameter_list|(
name|int
name|level
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isImmutable
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
specifier|const
name|Image
modifier|*
name|baseImage
init|=
name|getBaseLevelImage
argument_list|()
decl_stmt|;
name|GLsizei
name|width
init|=
name|baseImage
operator|->
name|getWidth
argument_list|()
decl_stmt|;
name|GLsizei
name|height
init|=
name|baseImage
operator|->
name|getHeight
argument_list|()
decl_stmt|;
if|if
condition|(
name|width
operator|<=
literal|0
operator|||
name|height
operator|<=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// The base image level is complete if the width and height are positive
if|if
condition|(
name|level
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
name|ASSERT
argument_list|(
name|level
operator|>=
literal|1
operator|&&
name|level
operator|<=
operator|(
name|int
operator|)
name|ArraySize
argument_list|(
name|mImageArray
argument_list|)
operator|&&
name|mImageArray
index|[
name|level
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ImageD3D
modifier|*
name|image
init|=
name|mImageArray
index|[
name|level
index|]
decl_stmt|;
if|if
condition|(
name|image
operator|->
name|getInternalFormat
argument_list|()
operator|!=
name|baseImage
operator|->
name|getInternalFormat
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|image
operator|->
name|getWidth
argument_list|()
operator|!=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|width
operator|>>
name|level
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|image
operator|->
name|getHeight
argument_list|()
operator|!=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|height
operator|>>
name|level
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|// Constructs a native texture resource from the texture images
DECL|function|initializeStorage
name|void
name|TextureD3D_2D
operator|::
name|initializeStorage
parameter_list|(
name|bool
name|renderTarget
parameter_list|)
block|{
comment|// Only initialize the first time this texture is used as a render target or shader resource
if|if
condition|(
name|mTexStorage
condition|)
block|{
return|return;
block|}
comment|// do not attempt to create storage for nonexistant data
if|if
condition|(
operator|!
name|isLevelComplete
argument_list|(
literal|0
argument_list|)
condition|)
block|{
return|return;
block|}
name|bool
name|createRenderTarget
init|=
operator|(
name|renderTarget
operator|||
name|IsRenderTargetUsage
argument_list|(
name|mUsage
argument_list|)
operator|)
decl_stmt|;
name|setCompleteTexStorage
argument_list|(
name|createCompleteStorage
argument_list|(
name|createRenderTarget
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
comment|// flush image data to the storage
name|updateStorage
argument_list|()
expr_stmt|;
block|}
DECL|function|createCompleteStorage
name|TextureStorageInterface2D
modifier|*
name|TextureD3D_2D
operator|::
name|createCompleteStorage
parameter_list|(
name|bool
name|renderTarget
parameter_list|)
specifier|const
block|{
name|GLsizei
name|width
init|=
name|getBaseLevelWidth
argument_list|()
decl_stmt|;
name|GLsizei
name|height
init|=
name|getBaseLevelHeight
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|width
operator|>
literal|0
operator|&&
name|height
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|// use existing storage level count, when previously specified by TexStorage*D
name|GLint
name|levels
init|=
operator|(
name|mTexStorage
condition|?
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
else|:
name|creationLevels
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
literal|1
argument_list|)
operator|)
decl_stmt|;
return|return
operator|new
name|TextureStorageInterface2D
argument_list|(
name|mRenderer
argument_list|,
name|getBaseLevelInternalFormat
argument_list|()
argument_list|,
name|renderTarget
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|levels
argument_list|)
return|;
block|}
DECL|function|setCompleteTexStorage
name|void
name|TextureD3D_2D
operator|::
name|setCompleteTexStorage
parameter_list|(
name|TextureStorageInterface2D
modifier|*
name|newCompleteTexStorage
parameter_list|)
block|{
name|SafeDelete
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
name|mTexStorage
operator|=
name|newCompleteTexStorage
expr_stmt|;
if|if
condition|(
name|mTexStorage
operator|&&
name|mTexStorage
operator|->
name|isManaged
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
condition|;
name|level
operator|++
control|)
block|{
name|mImageArray
index|[
name|level
index|]
operator|->
name|setManagedSurface
argument_list|(
name|mTexStorage
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
block|}
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|updateStorage
name|void
name|TextureD3D_2D
operator|::
name|updateStorage
parameter_list|()
block|{
name|ASSERT
argument_list|(
name|mTexStorage
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|GLint
name|storageLevels
init|=
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|storageLevels
condition|;
name|level
operator|++
control|)
block|{
if|if
condition|(
name|mImageArray
index|[
name|level
index|]
operator|->
name|isDirty
argument_list|()
operator|&&
name|isLevelComplete
argument_list|(
name|level
argument_list|)
condition|)
block|{
name|updateStorageLevel
argument_list|(
name|level
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|ensureRenderTarget
name|bool
name|TextureD3D_2D
operator|::
name|ensureRenderTarget
parameter_list|()
block|{
name|initializeStorage
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|getBaseLevelWidth
argument_list|()
operator|>
literal|0
operator|&&
name|getBaseLevelHeight
argument_list|()
operator|>
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mTexStorage
operator|->
name|isRenderTarget
argument_list|()
condition|)
block|{
name|TextureStorageInterface2D
modifier|*
name|newRenderTargetStorage
init|=
name|createCompleteStorage
argument_list|(
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mRenderer
operator|->
name|copyToRenderTarget
argument_list|(
name|newRenderTargetStorage
argument_list|,
name|mTexStorage
argument_list|)
condition|)
block|{
operator|delete
name|newRenderTargetStorage
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|setCompleteTexStorage
argument_list|(
name|newRenderTargetStorage
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|mTexStorage
operator|&&
name|mTexStorage
operator|->
name|isRenderTarget
argument_list|()
operator|)
return|;
block|}
DECL|function|getBaseLevelStorage
name|TextureStorageInterface
modifier|*
name|TextureD3D_2D
operator|::
name|getBaseLevelStorage
parameter_list|()
block|{
return|return
name|mTexStorage
return|;
block|}
DECL|function|getBaseLevelImage
specifier|const
name|ImageD3D
modifier|*
name|TextureD3D_2D
operator|::
name|getBaseLevelImage
parameter_list|()
specifier|const
block|{
return|return
name|mImageArray
index|[
literal|0
index|]
return|;
block|}
DECL|function|updateStorageLevel
name|void
name|TextureD3D_2D
operator|::
name|updateStorageLevel
parameter_list|(
name|int
name|level
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|level
operator|<=
operator|(
name|int
operator|)
name|ArraySize
argument_list|(
name|mImageArray
argument_list|)
operator|&&
name|mImageArray
index|[
name|level
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|isLevelComplete
argument_list|(
name|level
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mImageArray
index|[
name|level
index|]
operator|->
name|isDirty
argument_list|()
condition|)
block|{
name|commitRect
argument_list|(
name|level
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|getWidth
argument_list|(
name|level
argument_list|)
argument_list|,
name|getHeight
argument_list|(
name|level
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|redefineImage
name|void
name|TextureD3D_2D
operator|::
name|redefineImage
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
comment|// If there currently is a corresponding storage texture image, it has these parameters
specifier|const
name|int
name|storageWidth
init|=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|getBaseLevelWidth
argument_list|()
operator|>>
name|level
argument_list|)
decl_stmt|;
specifier|const
name|int
name|storageHeight
init|=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|getBaseLevelHeight
argument_list|()
operator|>>
name|level
argument_list|)
decl_stmt|;
specifier|const
name|GLenum
name|storageFormat
init|=
name|getBaseLevelInternalFormat
argument_list|()
decl_stmt|;
name|mImageArray
index|[
name|level
index|]
operator|->
name|redefine
argument_list|(
name|mRenderer
argument_list|,
name|GL_TEXTURE_2D
argument_list|,
name|internalformat
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|1
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|mTexStorage
condition|)
block|{
specifier|const
name|int
name|storageLevels
init|=
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|level
operator|>=
name|storageLevels
operator|&&
name|storageLevels
operator|!=
literal|0
operator|)
operator|||
name|width
operator|!=
name|storageWidth
operator|||
name|height
operator|!=
name|storageHeight
operator|||
name|internalformat
operator|!=
name|storageFormat
condition|)
comment|// Discard mismatched storage
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|i
operator|++
control|)
block|{
name|mImageArray
index|[
name|i
index|]
operator|->
name|markDirty
argument_list|()
expr_stmt|;
block|}
name|SafeDelete
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
DECL|function|commitRect
name|void
name|TextureD3D_2D
operator|::
name|commitRect
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
if|if
condition|(
name|isValidLevel
argument_list|(
name|level
argument_list|)
condition|)
block|{
name|ImageD3D
modifier|*
name|image
init|=
name|mImageArray
index|[
name|level
index|]
decl_stmt|;
if|if
condition|(
name|image
operator|->
name|copyToStorage
argument_list|(
name|mTexStorage
argument_list|,
name|level
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
condition|)
block|{
name|image
operator|->
name|markClean
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|function|TextureD3D_Cube
name|TextureD3D_Cube
operator|::
name|TextureD3D_Cube
parameter_list|(
name|Renderer
modifier|*
name|renderer
parameter_list|)
member_init_list|:
name|TextureCubeImpl
argument_list|()
member_init_list|,
name|TextureD3D
argument_list|(
name|renderer
argument_list|)
member_init_list|,
name|mTexStorage
argument_list|(
name|NULL
argument_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
operator|++
name|j
control|)
block|{
name|mImageArray
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|ImageD3D
operator|::
name|makeImageD3D
argument_list|(
name|renderer
operator|->
name|createImage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|~TextureD3D_Cube
name|TextureD3D_Cube
operator|::
name|~
name|TextureD3D_Cube
parameter_list|()
block|{
name|SafeDelete
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
operator|++
name|j
control|)
block|{
name|SafeDelete
argument_list|(
name|mImageArray
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|makeTextureD3D_Cube
name|TextureD3D_Cube
modifier|*
name|TextureD3D_Cube
operator|::
name|makeTextureD3D_Cube
parameter_list|(
name|TextureCubeImpl
modifier|*
name|texture
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|HAS_DYNAMIC_TYPE
argument_list|(
name|TextureD3D_Cube
operator|*
argument_list|,
name|texture
argument_list|)
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|TextureD3D_Cube
operator|*
argument_list|>
argument_list|(
name|texture
argument_list|)
return|;
block|}
DECL|function|getNativeTexture
name|TextureStorageInterface
modifier|*
name|TextureD3D_Cube
operator|::
name|getNativeTexture
parameter_list|()
block|{
comment|// ensure the underlying texture is created
name|initializeStorage
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|TextureStorageInterface
modifier|*
name|storage
init|=
name|getBaseLevelStorage
argument_list|()
decl_stmt|;
if|if
condition|(
name|storage
condition|)
block|{
name|updateStorage
argument_list|()
expr_stmt|;
block|}
return|return
name|storage
return|;
block|}
DECL|function|getImage
name|Image
modifier|*
name|TextureD3D_Cube
operator|::
name|getImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|int
name|level
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
argument_list|)
expr_stmt|;
return|return
name|mImageArray
index|[
name|targetToIndex
argument_list|(
name|target
argument_list|)
index|]
index|[
name|level
index|]
return|;
block|}
DECL|function|setUsage
name|void
name|TextureD3D_Cube
operator|::
name|setUsage
parameter_list|(
name|GLenum
name|usage
parameter_list|)
block|{
name|mUsage
operator|=
name|usage
expr_stmt|;
block|}
DECL|function|resetDirty
name|void
name|TextureD3D_Cube
operator|::
name|resetDirty
parameter_list|()
block|{
name|mDirtyImages
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|getInternalFormat
name|GLenum
name|TextureD3D_Cube
operator|::
name|getInternalFormat
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
return|return
name|mImageArray
index|[
name|targetToIndex
argument_list|(
name|target
argument_list|)
index|]
index|[
name|level
index|]
operator|->
name|getInternalFormat
argument_list|()
return|;
else|else
return|return
name|GL_NONE
return|;
block|}
DECL|function|isDepth
name|bool
name|TextureD3D_Cube
operator|::
name|isDepth
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|)
specifier|const
block|{
return|return
name|gl
operator|::
name|GetDepthBits
argument_list|(
name|getInternalFormat
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
argument_list|)
operator|>
literal|0
return|;
block|}
DECL|function|setImage
name|void
name|TextureD3D_Cube
operator|::
name|setImage
parameter_list|(
name|int
name|faceIndex
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|internalFormat
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
name|GLenum
name|sizedInternalFormat
init|=
name|gl
operator|::
name|IsSizedInternalFormat
argument_list|(
name|internalFormat
argument_list|)
condition|?
name|internalFormat
else|:
name|gl
operator|::
name|GetSizedInternalFormat
argument_list|(
name|format
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|redefineImage
argument_list|(
name|faceIndex
argument_list|,
name|level
argument_list|,
name|sizedInternalFormat
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|TextureD3D
operator|::
name|setImage
argument_list|(
name|unpack
argument_list|,
name|type
argument_list|,
name|pixels
argument_list|,
name|mImageArray
index|[
name|faceIndex
index|]
index|[
name|level
index|]
argument_list|)
expr_stmt|;
block|}
DECL|function|setCompressedImage
name|void
name|TextureD3D_Cube
operator|::
name|setCompressedImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|imageSize
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
comment|// compressed formats don't have separate sized internal formats-- we can just use the compressed format directly
name|int
name|faceIndex
init|=
name|targetToIndex
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|redefineImage
argument_list|(
name|faceIndex
argument_list|,
name|level
argument_list|,
name|format
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|TextureD3D
operator|::
name|setCompressedImage
argument_list|(
name|imageSize
argument_list|,
name|pixels
argument_list|,
name|mImageArray
index|[
name|faceIndex
index|]
index|[
name|level
index|]
argument_list|)
expr_stmt|;
block|}
DECL|function|subImage
name|void
name|TextureD3D_Cube
operator|::
name|subImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
name|int
name|faceIndex
init|=
name|targetToIndex
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|TextureD3D
operator|::
name|subImage
argument_list|(
name|xoffset
argument_list|,
name|yoffset
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|1
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|unpack
argument_list|,
name|pixels
argument_list|,
name|mImageArray
index|[
name|faceIndex
index|]
index|[
name|level
index|]
argument_list|)
condition|)
block|{
name|commitRect
argument_list|(
name|faceIndex
argument_list|,
name|level
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|subImageCompressed
name|void
name|TextureD3D_Cube
operator|::
name|subImageCompressed
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLsizei
name|imageSize
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
name|int
name|faceIndex
init|=
name|targetToIndex
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|TextureD3D
operator|::
name|subImageCompressed
argument_list|(
name|xoffset
argument_list|,
name|yoffset
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|1
argument_list|,
name|format
argument_list|,
name|imageSize
argument_list|,
name|pixels
argument_list|,
name|mImageArray
index|[
name|faceIndex
index|]
index|[
name|level
index|]
argument_list|)
condition|)
block|{
name|commitRect
argument_list|(
name|faceIndex
argument_list|,
name|level
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|copyImage
name|void
name|TextureD3D_Cube
operator|::
name|copyImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|gl
operator|::
name|Framebuffer
modifier|*
name|source
parameter_list|)
block|{
name|int
name|faceIndex
init|=
name|targetToIndex
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|GLenum
name|sizedInternalFormat
init|=
name|gl
operator|::
name|IsSizedInternalFormat
argument_list|(
name|format
argument_list|)
condition|?
name|format
else|:
name|gl
operator|::
name|GetSizedInternalFormat
argument_list|(
name|format
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|)
decl_stmt|;
name|redefineImage
argument_list|(
name|faceIndex
argument_list|,
name|level
argument_list|,
name|sizedInternalFormat
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mImageArray
index|[
name|faceIndex
index|]
index|[
name|level
index|]
operator|->
name|isRenderableFormat
argument_list|()
condition|)
block|{
name|mImageArray
index|[
name|faceIndex
index|]
index|[
name|level
index|]
operator|->
name|copy
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|ensureRenderTarget
argument_list|()
expr_stmt|;
name|mImageArray
index|[
name|faceIndex
index|]
index|[
name|level
index|]
operator|->
name|markClean
argument_list|()
expr_stmt|;
name|ASSERT
argument_list|(
name|width
operator|==
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|>
literal|0
operator|&&
name|isValidFaceLevel
argument_list|(
name|faceIndex
argument_list|,
name|level
argument_list|)
condition|)
block|{
name|gl
operator|::
name|Rectangle
name|sourceRect
decl_stmt|;
name|sourceRect
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|sourceRect
operator|.
name|width
operator|=
name|width
expr_stmt|;
name|sourceRect
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|sourceRect
operator|.
name|height
operator|=
name|height
expr_stmt|;
name|mRenderer
operator|->
name|copyImage
argument_list|(
name|source
argument_list|,
name|sourceRect
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|mTexStorage
argument_list|,
name|target
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|copySubImage
name|void
name|TextureD3D_Cube
operator|::
name|copySubImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLint
name|zoffset
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|gl
operator|::
name|Framebuffer
modifier|*
name|source
parameter_list|)
block|{
name|int
name|faceIndex
init|=
name|targetToIndex
argument_list|(
name|target
argument_list|)
decl_stmt|;
comment|// We can only make our texture storage to a render target if the level we're copying *to* is complete
comment|// and the base level is cube-complete. The base level must be cube complete (common case) because we cannot
comment|// rely on the "getBaseLevel*" methods reliably otherwise.
name|bool
name|canCreateRenderTarget
init|=
name|isFaceLevelComplete
argument_list|(
name|faceIndex
argument_list|,
name|level
argument_list|)
operator|&&
name|isCubeComplete
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|mImageArray
index|[
name|faceIndex
index|]
index|[
name|level
index|]
operator|->
name|isRenderableFormat
argument_list|()
operator|||
operator|(
operator|!
name|mTexStorage
operator|&&
operator|!
name|canCreateRenderTarget
operator|)
condition|)
block|{
name|mImageArray
index|[
name|faceIndex
index|]
index|[
name|level
index|]
operator|->
name|copy
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|ensureRenderTarget
argument_list|()
expr_stmt|;
if|if
condition|(
name|isValidFaceLevel
argument_list|(
name|faceIndex
argument_list|,
name|level
argument_list|)
condition|)
block|{
name|updateStorageFaceLevel
argument_list|(
name|faceIndex
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|gl
operator|::
name|Rectangle
name|sourceRect
decl_stmt|;
name|sourceRect
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|sourceRect
operator|.
name|width
operator|=
name|width
expr_stmt|;
name|sourceRect
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|sourceRect
operator|.
name|height
operator|=
name|height
expr_stmt|;
name|mRenderer
operator|->
name|copyImage
argument_list|(
name|source
argument_list|,
name|sourceRect
argument_list|,
name|gl
operator|::
name|GetFormat
argument_list|(
name|getBaseLevelInternalFormat
argument_list|()
argument_list|)
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|mTexStorage
argument_list|,
name|target
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|storage
name|void
name|TextureD3D_Cube
operator|::
name|storage
parameter_list|(
name|GLsizei
name|levels
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|GLsizei
name|size
parameter_list|)
block|{
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|levels
condition|;
name|level
operator|++
control|)
block|{
name|GLsizei
name|mipSize
init|=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|size
operator|>>
name|level
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|faceIndex
init|=
literal|0
init|;
name|faceIndex
operator|<
literal|6
condition|;
name|faceIndex
operator|++
control|)
block|{
name|mImageArray
index|[
name|faceIndex
index|]
index|[
name|level
index|]
operator|->
name|redefine
argument_list|(
name|mRenderer
argument_list|,
name|GL_TEXTURE_CUBE_MAP
argument_list|,
name|internalformat
argument_list|,
name|mipSize
argument_list|,
name|mipSize
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|level
init|=
name|levels
init|;
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|level
operator|++
control|)
block|{
for|for
control|(
name|int
name|faceIndex
init|=
literal|0
init|;
name|faceIndex
operator|<
literal|6
condition|;
name|faceIndex
operator|++
control|)
block|{
name|mImageArray
index|[
name|faceIndex
index|]
index|[
name|level
index|]
operator|->
name|redefine
argument_list|(
name|mRenderer
argument_list|,
name|GL_TEXTURE_CUBE_MAP
argument_list|,
name|GL_NONE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
name|mImmutable
operator|=
literal|true
expr_stmt|;
name|setCompleteTexStorage
argument_list|(
operator|new
name|TextureStorageInterfaceCube
argument_list|(
name|mRenderer
argument_list|,
name|internalformat
argument_list|,
name|IsRenderTargetUsage
argument_list|(
name|mUsage
argument_list|)
argument_list|,
name|size
argument_list|,
name|levels
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|isSamplerComplete
name|bool
name|TextureD3D_Cube
operator|::
name|isSamplerComplete
parameter_list|(
specifier|const
name|gl
operator|::
name|SamplerState
modifier|&
name|samplerState
parameter_list|)
specifier|const
block|{
name|int
name|size
init|=
name|getBaseLevelWidth
argument_list|()
decl_stmt|;
name|bool
name|mipmapping
init|=
name|IsMipmapFiltered
argument_list|(
name|samplerState
argument_list|)
decl_stmt|;
comment|// TODO(geofflang): use context's texture caps
if|if
condition|(
operator|!
name|mRenderer
operator|->
name|getRendererTextureCaps
argument_list|()
operator|.
name|get
argument_list|(
name|getInternalFormat
argument_list|(
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|.
name|filterable
condition|)
block|{
if|if
condition|(
name|samplerState
operator|.
name|magFilter
operator|!=
name|GL_NEAREST
operator|||
operator|(
name|samplerState
operator|.
name|minFilter
operator|!=
name|GL_NEAREST
operator|&&
name|samplerState
operator|.
name|minFilter
operator|!=
name|GL_NEAREST_MIPMAP_NEAREST
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|// TODO(geofflang): use context's extensions
if|if
condition|(
operator|!
name|gl
operator|::
name|isPow2
argument_list|(
name|size
argument_list|)
operator|&&
operator|!
name|mRenderer
operator|->
name|getRendererExtensions
argument_list|()
operator|.
name|textureNPOT
condition|)
block|{
if|if
condition|(
name|samplerState
operator|.
name|wrapS
operator|!=
name|GL_CLAMP_TO_EDGE
operator|||
name|samplerState
operator|.
name|wrapT
operator|!=
name|GL_CLAMP_TO_EDGE
operator|||
name|mipmapping
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
operator|!
name|mipmapping
condition|)
block|{
if|if
condition|(
operator|!
name|isCubeComplete
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|isMipmapCubeComplete
argument_list|()
condition|)
comment|// Also tests for isCubeComplete()
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|// Tests for cube texture completeness. [OpenGL ES 2.0.24] section 3.7.10 page 81.
DECL|function|isCubeComplete
name|bool
name|TextureD3D_Cube
operator|::
name|isCubeComplete
parameter_list|()
specifier|const
block|{
name|int
name|baseWidth
init|=
name|getBaseLevelWidth
argument_list|()
decl_stmt|;
name|int
name|baseHeight
init|=
name|getBaseLevelHeight
argument_list|()
decl_stmt|;
name|GLenum
name|baseFormat
init|=
name|getBaseLevelInternalFormat
argument_list|()
decl_stmt|;
if|if
condition|(
name|baseWidth
operator|<=
literal|0
operator|||
name|baseWidth
operator|!=
name|baseHeight
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|faceIndex
init|=
literal|1
init|;
name|faceIndex
operator|<
literal|6
condition|;
name|faceIndex
operator|++
control|)
block|{
specifier|const
name|ImageD3D
modifier|&
name|faceBaseImage
init|=
operator|*
name|mImageArray
index|[
name|faceIndex
index|]
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|faceBaseImage
operator|.
name|getWidth
argument_list|()
operator|!=
name|baseWidth
operator|||
name|faceBaseImage
operator|.
name|getHeight
argument_list|()
operator|!=
name|baseHeight
operator|||
name|faceBaseImage
operator|.
name|getInternalFormat
argument_list|()
operator|!=
name|baseFormat
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|generateMipmaps
name|void
name|TextureD3D_Cube
operator|::
name|generateMipmaps
parameter_list|()
block|{
comment|// Purge array levels 1 through q and reset them to represent the generated mipmap levels.
name|int
name|levelCount
init|=
name|mipLevels
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|faceIndex
init|=
literal|0
init|;
name|faceIndex
operator|<
literal|6
condition|;
name|faceIndex
operator|++
control|)
block|{
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<
name|levelCount
condition|;
name|level
operator|++
control|)
block|{
name|int
name|faceLevelSize
init|=
operator|(
name|std
operator|::
name|max
argument_list|(
name|mImageArray
index|[
name|faceIndex
index|]
index|[
literal|0
index|]
operator|->
name|getWidth
argument_list|()
operator|>>
name|level
argument_list|,
literal|1
argument_list|)
operator|)
decl_stmt|;
name|redefineImage
argument_list|(
name|faceIndex
argument_list|,
name|level
argument_list|,
name|mImageArray
index|[
name|faceIndex
index|]
index|[
literal|0
index|]
operator|->
name|getInternalFormat
argument_list|()
argument_list|,
name|faceLevelSize
argument_list|,
name|faceLevelSize
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mTexStorage
operator|&&
name|mTexStorage
operator|->
name|isRenderTarget
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|faceIndex
init|=
literal|0
init|;
name|faceIndex
operator|<
literal|6
condition|;
name|faceIndex
operator|++
control|)
block|{
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<
name|levelCount
condition|;
name|level
operator|++
control|)
block|{
name|mTexStorage
operator|->
name|generateMipmap
argument_list|(
name|faceIndex
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|mImageArray
index|[
name|faceIndex
index|]
index|[
name|level
index|]
operator|->
name|markClean
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|faceIndex
init|=
literal|0
init|;
name|faceIndex
operator|<
literal|6
condition|;
name|faceIndex
operator|++
control|)
block|{
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<
name|levelCount
condition|;
name|level
operator|++
control|)
block|{
name|mRenderer
operator|->
name|generateMipmap
argument_list|(
name|mImageArray
index|[
name|faceIndex
index|]
index|[
name|level
index|]
argument_list|,
name|mImageArray
index|[
name|faceIndex
index|]
index|[
name|level
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|function|getRenderTargetSerial
name|unsigned
name|int
name|TextureD3D_Cube
operator|::
name|getRenderTargetSerial
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|)
block|{
return|return
operator|(
name|ensureRenderTarget
argument_list|()
condition|?
name|mTexStorage
operator|->
name|getRenderTargetSerial
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
else|:
literal|0
operator|)
return|;
block|}
DECL|function|getRenderTarget
name|RenderTarget
modifier|*
name|TextureD3D_Cube
operator|::
name|getRenderTarget
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|gl
operator|::
name|IsCubemapTextureTarget
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
comment|// ensure the underlying texture is created
if|if
condition|(
operator|!
name|ensureRenderTarget
argument_list|()
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|updateStorageFaceLevel
argument_list|(
name|targetToIndex
argument_list|(
name|target
argument_list|)
argument_list|,
name|level
argument_list|)
expr_stmt|;
comment|// ensure this is NOT a depth texture
if|if
condition|(
name|isDepth
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
name|mTexStorage
operator|->
name|getRenderTarget
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
return|;
block|}
DECL|function|getDepthStencil
name|RenderTarget
modifier|*
name|TextureD3D_Cube
operator|::
name|getDepthStencil
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|gl
operator|::
name|IsCubemapTextureTarget
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
comment|// ensure the underlying texture is created
if|if
condition|(
operator|!
name|ensureRenderTarget
argument_list|()
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|updateStorageFaceLevel
argument_list|(
name|targetToIndex
argument_list|(
name|target
argument_list|)
argument_list|,
name|level
argument_list|)
expr_stmt|;
comment|// ensure this is a depth texture
if|if
condition|(
operator|!
name|isDepth
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
name|mTexStorage
operator|->
name|getRenderTarget
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
return|;
block|}
DECL|function|targetToIndex
name|int
name|TextureD3D_Cube
operator|::
name|targetToIndex
parameter_list|(
name|GLenum
name|target
parameter_list|)
block|{
name|META_ASSERT
argument_list|(
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_X
operator|-
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
operator|==
literal|1
argument_list|)
expr_stmt|;
name|META_ASSERT
argument_list|(
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Y
operator|-
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
operator|==
literal|2
argument_list|)
expr_stmt|;
name|META_ASSERT
argument_list|(
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
operator|-
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
operator|==
literal|3
argument_list|)
expr_stmt|;
name|META_ASSERT
argument_list|(
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Z
operator|-
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
operator|==
literal|4
argument_list|)
expr_stmt|;
name|META_ASSERT
argument_list|(
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
operator|-
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
operator|==
literal|5
argument_list|)
expr_stmt|;
return|return
name|target
operator|-
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
return|;
block|}
DECL|function|initializeStorage
name|void
name|TextureD3D_Cube
operator|::
name|initializeStorage
parameter_list|(
name|bool
name|renderTarget
parameter_list|)
block|{
comment|// Only initialize the first time this texture is used as a render target or shader resource
if|if
condition|(
name|mTexStorage
condition|)
block|{
return|return;
block|}
comment|// do not attempt to create storage for nonexistant data
if|if
condition|(
operator|!
name|isFaceLevelComplete
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
return|return;
block|}
name|bool
name|createRenderTarget
init|=
operator|(
name|renderTarget
operator|||
name|IsRenderTargetUsage
argument_list|(
name|mUsage
argument_list|)
operator|)
decl_stmt|;
name|setCompleteTexStorage
argument_list|(
name|createCompleteStorage
argument_list|(
name|createRenderTarget
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
comment|// flush image data to the storage
name|updateStorage
argument_list|()
expr_stmt|;
block|}
DECL|function|createCompleteStorage
name|TextureStorageInterfaceCube
modifier|*
name|TextureD3D_Cube
operator|::
name|createCompleteStorage
parameter_list|(
name|bool
name|renderTarget
parameter_list|)
specifier|const
block|{
name|GLsizei
name|size
init|=
name|getBaseLevelWidth
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|// use existing storage level count, when previously specified by TexStorage*D
name|GLint
name|levels
init|=
operator|(
name|mTexStorage
condition|?
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
else|:
name|creationLevels
argument_list|(
name|size
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
operator|)
decl_stmt|;
return|return
operator|new
name|TextureStorageInterfaceCube
argument_list|(
name|mRenderer
argument_list|,
name|getBaseLevelInternalFormat
argument_list|()
argument_list|,
name|renderTarget
argument_list|,
name|size
argument_list|,
name|levels
argument_list|)
return|;
block|}
DECL|function|setCompleteTexStorage
name|void
name|TextureD3D_Cube
operator|::
name|setCompleteTexStorage
parameter_list|(
name|TextureStorageInterfaceCube
modifier|*
name|newCompleteTexStorage
parameter_list|)
block|{
name|SafeDelete
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
name|mTexStorage
operator|=
name|newCompleteTexStorage
expr_stmt|;
if|if
condition|(
name|mTexStorage
operator|&&
name|mTexStorage
operator|->
name|isManaged
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|faceIndex
init|=
literal|0
init|;
name|faceIndex
operator|<
literal|6
condition|;
name|faceIndex
operator|++
control|)
block|{
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
condition|;
name|level
operator|++
control|)
block|{
name|mImageArray
index|[
name|faceIndex
index|]
index|[
name|level
index|]
operator|->
name|setManagedSurface
argument_list|(
name|mTexStorage
argument_list|,
name|faceIndex
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|updateStorage
name|void
name|TextureD3D_Cube
operator|::
name|updateStorage
parameter_list|()
block|{
name|ASSERT
argument_list|(
name|mTexStorage
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|GLint
name|storageLevels
init|=
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|face
init|=
literal|0
init|;
name|face
operator|<
literal|6
condition|;
name|face
operator|++
control|)
block|{
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|storageLevels
condition|;
name|level
operator|++
control|)
block|{
if|if
condition|(
name|mImageArray
index|[
name|face
index|]
index|[
name|level
index|]
operator|->
name|isDirty
argument_list|()
operator|&&
name|isFaceLevelComplete
argument_list|(
name|face
argument_list|,
name|level
argument_list|)
condition|)
block|{
name|updateStorageFaceLevel
argument_list|(
name|face
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|function|ensureRenderTarget
name|bool
name|TextureD3D_Cube
operator|::
name|ensureRenderTarget
parameter_list|()
block|{
name|initializeStorage
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|getBaseLevelWidth
argument_list|()
operator|>
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mTexStorage
operator|->
name|isRenderTarget
argument_list|()
condition|)
block|{
name|TextureStorageInterfaceCube
modifier|*
name|newRenderTargetStorage
init|=
name|createCompleteStorage
argument_list|(
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mRenderer
operator|->
name|copyToRenderTarget
argument_list|(
name|newRenderTargetStorage
argument_list|,
name|mTexStorage
argument_list|)
condition|)
block|{
operator|delete
name|newRenderTargetStorage
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|setCompleteTexStorage
argument_list|(
name|newRenderTargetStorage
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|mTexStorage
operator|&&
name|mTexStorage
operator|->
name|isRenderTarget
argument_list|()
operator|)
return|;
block|}
DECL|function|getBaseLevelStorage
name|TextureStorageInterface
modifier|*
name|TextureD3D_Cube
operator|::
name|getBaseLevelStorage
parameter_list|()
block|{
return|return
name|mTexStorage
return|;
block|}
DECL|function|getBaseLevelImage
specifier|const
name|ImageD3D
modifier|*
name|TextureD3D_Cube
operator|::
name|getBaseLevelImage
parameter_list|()
specifier|const
block|{
comment|// Note: if we are not cube-complete, there is no single base level image that can describe all
comment|// cube faces, so this method is only well-defined for a cube-complete base level.
return|return
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
return|;
block|}
DECL|function|isMipmapCubeComplete
name|bool
name|TextureD3D_Cube
operator|::
name|isMipmapCubeComplete
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isImmutable
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|isCubeComplete
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|levelCount
init|=
name|mipLevels
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|face
init|=
literal|0
init|;
name|face
operator|<
literal|6
condition|;
name|face
operator|++
control|)
block|{
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<
name|levelCount
condition|;
name|level
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isFaceLevelComplete
argument_list|(
name|face
argument_list|,
name|level
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|isValidFaceLevel
name|bool
name|TextureD3D_Cube
operator|::
name|isValidFaceLevel
parameter_list|(
name|int
name|faceIndex
parameter_list|,
name|int
name|level
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|mTexStorage
condition|?
operator|(
name|level
operator|>=
literal|0
operator|&&
name|level
operator|<
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
operator|)
else|:
literal|0
operator|)
return|;
block|}
DECL|function|isFaceLevelComplete
name|bool
name|TextureD3D_Cube
operator|::
name|isFaceLevelComplete
parameter_list|(
name|int
name|faceIndex
parameter_list|,
name|int
name|level
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|level
operator|>=
literal|0
operator|&&
name|faceIndex
operator|<
literal|6
operator|&&
name|level
operator|<
operator|(
name|int
operator|)
name|ArraySize
argument_list|(
name|mImageArray
index|[
name|faceIndex
index|]
argument_list|)
operator|&&
name|mImageArray
index|[
name|faceIndex
index|]
index|[
name|level
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isImmutable
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
name|int
name|baseSize
init|=
name|getBaseLevelWidth
argument_list|()
decl_stmt|;
if|if
condition|(
name|baseSize
operator|<=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// "isCubeComplete" checks for base level completeness and we must call that
comment|// to determine if any face at level 0 is complete. We omit that check here
comment|// to avoid re-checking cube-completeness for every face at level 0.
if|if
condition|(
name|level
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// Check that non-zero levels are consistent with the base level.
specifier|const
name|ImageD3D
modifier|*
name|faceLevelImage
init|=
name|mImageArray
index|[
name|faceIndex
index|]
index|[
name|level
index|]
decl_stmt|;
if|if
condition|(
name|faceLevelImage
operator|->
name|getInternalFormat
argument_list|()
operator|!=
name|getBaseLevelInternalFormat
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|faceLevelImage
operator|->
name|getWidth
argument_list|()
operator|!=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|baseSize
operator|>>
name|level
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|updateStorageFaceLevel
name|void
name|TextureD3D_Cube
operator|::
name|updateStorageFaceLevel
parameter_list|(
name|int
name|faceIndex
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|level
operator|>=
literal|0
operator|&&
name|faceIndex
operator|<
literal|6
operator|&&
name|level
operator|<
operator|(
name|int
operator|)
name|ArraySize
argument_list|(
name|mImageArray
index|[
name|faceIndex
index|]
argument_list|)
operator|&&
name|mImageArray
index|[
name|faceIndex
index|]
index|[
name|level
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ImageD3D
modifier|*
name|image
init|=
name|mImageArray
index|[
name|faceIndex
index|]
index|[
name|level
index|]
decl_stmt|;
if|if
condition|(
name|image
operator|->
name|isDirty
argument_list|()
condition|)
block|{
name|commitRect
argument_list|(
name|faceIndex
argument_list|,
name|level
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|image
operator|->
name|getWidth
argument_list|()
argument_list|,
name|image
operator|->
name|getHeight
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|redefineImage
name|void
name|TextureD3D_Cube
operator|::
name|redefineImage
parameter_list|(
name|int
name|faceIndex
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
comment|// If there currently is a corresponding storage texture image, it has these parameters
specifier|const
name|int
name|storageWidth
init|=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|getBaseLevelWidth
argument_list|()
operator|>>
name|level
argument_list|)
decl_stmt|;
specifier|const
name|int
name|storageHeight
init|=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|getBaseLevelHeight
argument_list|()
operator|>>
name|level
argument_list|)
decl_stmt|;
specifier|const
name|GLenum
name|storageFormat
init|=
name|getBaseLevelInternalFormat
argument_list|()
decl_stmt|;
name|mImageArray
index|[
name|faceIndex
index|]
index|[
name|level
index|]
operator|->
name|redefine
argument_list|(
name|mRenderer
argument_list|,
name|GL_TEXTURE_CUBE_MAP
argument_list|,
name|internalformat
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|1
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|mTexStorage
condition|)
block|{
specifier|const
name|int
name|storageLevels
init|=
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|level
operator|>=
name|storageLevels
operator|&&
name|storageLevels
operator|!=
literal|0
operator|)
operator|||
name|width
operator|!=
name|storageWidth
operator|||
name|height
operator|!=
name|storageHeight
operator|||
name|internalformat
operator|!=
name|storageFormat
condition|)
comment|// Discard mismatched storage
block|{
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|level
operator|++
control|)
block|{
for|for
control|(
name|int
name|faceIndex
init|=
literal|0
init|;
name|faceIndex
operator|<
literal|6
condition|;
name|faceIndex
operator|++
control|)
block|{
name|mImageArray
index|[
name|faceIndex
index|]
index|[
name|level
index|]
operator|->
name|markDirty
argument_list|()
expr_stmt|;
block|}
block|}
name|SafeDelete
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
DECL|function|commitRect
name|void
name|TextureD3D_Cube
operator|::
name|commitRect
parameter_list|(
name|int
name|faceIndex
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
if|if
condition|(
name|isValidFaceLevel
argument_list|(
name|faceIndex
argument_list|,
name|level
argument_list|)
condition|)
block|{
name|ImageD3D
modifier|*
name|image
init|=
name|mImageArray
index|[
name|faceIndex
index|]
index|[
name|level
index|]
decl_stmt|;
if|if
condition|(
name|image
operator|->
name|copyToStorage
argument_list|(
name|mTexStorage
argument_list|,
name|faceIndex
argument_list|,
name|level
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
condition|)
name|image
operator|->
name|markClean
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|TextureD3D_3D
name|TextureD3D_3D
operator|::
name|TextureD3D_3D
parameter_list|(
name|Renderer
modifier|*
name|renderer
parameter_list|)
member_init_list|:
name|Texture3DImpl
argument_list|()
member_init_list|,
name|TextureD3D
argument_list|(
name|renderer
argument_list|)
member_init_list|,
name|mTexStorage
argument_list|(
name|NULL
argument_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
operator|++
name|i
control|)
block|{
name|mImageArray
index|[
name|i
index|]
operator|=
name|ImageD3D
operator|::
name|makeImageD3D
argument_list|(
name|renderer
operator|->
name|createImage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|~TextureD3D_3D
name|TextureD3D_3D
operator|::
name|~
name|TextureD3D_3D
parameter_list|()
block|{
name|SafeDelete
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
operator|++
name|i
control|)
block|{
operator|delete
name|mImageArray
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
DECL|function|makeTextureD3D_3D
name|TextureD3D_3D
modifier|*
name|TextureD3D_3D
operator|::
name|makeTextureD3D_3D
parameter_list|(
name|Texture3DImpl
modifier|*
name|texture
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|HAS_DYNAMIC_TYPE
argument_list|(
name|TextureD3D_3D
operator|*
argument_list|,
name|texture
argument_list|)
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|TextureD3D_3D
operator|*
argument_list|>
argument_list|(
name|texture
argument_list|)
return|;
block|}
DECL|function|getNativeTexture
name|TextureStorageInterface
modifier|*
name|TextureD3D_3D
operator|::
name|getNativeTexture
parameter_list|()
block|{
comment|// ensure the underlying texture is created
name|initializeStorage
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|TextureStorageInterface
modifier|*
name|storage
init|=
name|getBaseLevelStorage
argument_list|()
decl_stmt|;
if|if
condition|(
name|storage
condition|)
block|{
name|updateStorage
argument_list|()
expr_stmt|;
block|}
return|return
name|storage
return|;
block|}
DECL|function|getImage
name|Image
modifier|*
name|TextureD3D_3D
operator|::
name|getImage
parameter_list|(
name|int
name|level
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
argument_list|)
expr_stmt|;
return|return
name|mImageArray
index|[
name|level
index|]
return|;
block|}
DECL|function|setUsage
name|void
name|TextureD3D_3D
operator|::
name|setUsage
parameter_list|(
name|GLenum
name|usage
parameter_list|)
block|{
name|mUsage
operator|=
name|usage
expr_stmt|;
block|}
DECL|function|resetDirty
name|void
name|TextureD3D_3D
operator|::
name|resetDirty
parameter_list|()
block|{
name|mDirtyImages
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|getWidth
name|GLsizei
name|TextureD3D_3D
operator|::
name|getWidth
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
return|return
name|mImageArray
index|[
name|level
index|]
operator|->
name|getWidth
argument_list|()
return|;
else|else
return|return
literal|0
return|;
block|}
DECL|function|getHeight
name|GLsizei
name|TextureD3D_3D
operator|::
name|getHeight
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
return|return
name|mImageArray
index|[
name|level
index|]
operator|->
name|getHeight
argument_list|()
return|;
else|else
return|return
literal|0
return|;
block|}
DECL|function|getDepth
name|GLsizei
name|TextureD3D_3D
operator|::
name|getDepth
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
return|return
name|mImageArray
index|[
name|level
index|]
operator|->
name|getDepth
argument_list|()
return|;
else|else
return|return
literal|0
return|;
block|}
DECL|function|getInternalFormat
name|GLenum
name|TextureD3D_3D
operator|::
name|getInternalFormat
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
return|return
name|mImageArray
index|[
name|level
index|]
operator|->
name|getInternalFormat
argument_list|()
return|;
else|else
return|return
name|GL_NONE
return|;
block|}
DECL|function|isDepth
name|bool
name|TextureD3D_3D
operator|::
name|isDepth
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
return|return
name|gl
operator|::
name|GetDepthBits
argument_list|(
name|getInternalFormat
argument_list|(
name|level
argument_list|)
argument_list|)
operator|>
literal|0
return|;
block|}
DECL|function|setImage
name|void
name|TextureD3D_3D
operator|::
name|setImage
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|depth
parameter_list|,
name|GLenum
name|internalFormat
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
name|GLenum
name|sizedInternalFormat
init|=
name|gl
operator|::
name|IsSizedInternalFormat
argument_list|(
name|internalFormat
argument_list|)
condition|?
name|internalFormat
else|:
name|gl
operator|::
name|GetSizedInternalFormat
argument_list|(
name|format
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|redefineImage
argument_list|(
name|level
argument_list|,
name|sizedInternalFormat
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|bool
name|fastUnpacked
init|=
literal|false
decl_stmt|;
comment|// Attempt a fast gpu copy of the pixel data to the surface if the app bound an unpack buffer
if|if
condition|(
name|isFastUnpackable
argument_list|(
name|unpack
argument_list|,
name|sizedInternalFormat
argument_list|)
condition|)
block|{
comment|// Will try to create RT storage if it does not exist
name|RenderTarget
modifier|*
name|destRenderTarget
init|=
name|getRenderTarget
argument_list|(
name|level
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Box
name|destArea
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|getWidth
argument_list|(
name|level
argument_list|)
argument_list|,
name|getHeight
argument_list|(
name|level
argument_list|)
argument_list|,
name|getDepth
argument_list|(
name|level
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|destRenderTarget
operator|&&
name|fastUnpackPixels
argument_list|(
name|unpack
argument_list|,
name|pixels
argument_list|,
name|destArea
argument_list|,
name|sizedInternalFormat
argument_list|,
name|type
argument_list|,
name|destRenderTarget
argument_list|)
condition|)
block|{
comment|// Ensure we don't overwrite our newly initialized data
name|mImageArray
index|[
name|level
index|]
operator|->
name|markClean
argument_list|()
expr_stmt|;
name|fastUnpacked
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|fastUnpacked
condition|)
block|{
name|TextureD3D
operator|::
name|setImage
argument_list|(
name|unpack
argument_list|,
name|type
argument_list|,
name|pixels
argument_list|,
name|mImageArray
index|[
name|level
index|]
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|setCompressedImage
name|void
name|TextureD3D_3D
operator|::
name|setCompressedImage
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|depth
parameter_list|,
name|GLsizei
name|imageSize
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
comment|// compressed formats don't have separate sized internal formats-- we can just use the compressed format directly
name|redefineImage
argument_list|(
name|level
argument_list|,
name|format
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|TextureD3D
operator|::
name|setCompressedImage
argument_list|(
name|imageSize
argument_list|,
name|pixels
argument_list|,
name|mImageArray
index|[
name|level
index|]
argument_list|)
expr_stmt|;
block|}
DECL|function|subImage
name|void
name|TextureD3D_3D
operator|::
name|subImage
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLint
name|zoffset
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|depth
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
name|bool
name|fastUnpacked
init|=
literal|false
decl_stmt|;
comment|// Attempt a fast gpu copy of the pixel data to the surface if the app bound an unpack buffer
if|if
condition|(
name|isFastUnpackable
argument_list|(
name|unpack
argument_list|,
name|getInternalFormat
argument_list|(
name|level
argument_list|)
argument_list|)
condition|)
block|{
name|RenderTarget
modifier|*
name|destRenderTarget
init|=
name|getRenderTarget
argument_list|(
name|level
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Box
name|destArea
argument_list|(
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|zoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|)
decl_stmt|;
if|if
condition|(
name|destRenderTarget
operator|&&
name|fastUnpackPixels
argument_list|(
name|unpack
argument_list|,
name|pixels
argument_list|,
name|destArea
argument_list|,
name|getInternalFormat
argument_list|(
name|level
argument_list|)
argument_list|,
name|type
argument_list|,
name|destRenderTarget
argument_list|)
condition|)
block|{
comment|// Ensure we don't overwrite our newly initialized data
name|mImageArray
index|[
name|level
index|]
operator|->
name|markClean
argument_list|()
expr_stmt|;
name|fastUnpacked
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|fastUnpacked
operator|&&
name|TextureD3D
operator|::
name|subImage
argument_list|(
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|zoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|unpack
argument_list|,
name|pixels
argument_list|,
name|mImageArray
index|[
name|level
index|]
argument_list|)
condition|)
block|{
name|commitRect
argument_list|(
name|level
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|zoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|subImageCompressed
name|void
name|TextureD3D_3D
operator|::
name|subImageCompressed
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLint
name|zoffset
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|depth
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLsizei
name|imageSize
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
if|if
condition|(
name|TextureD3D
operator|::
name|subImageCompressed
argument_list|(
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|zoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|,
name|format
argument_list|,
name|imageSize
argument_list|,
name|pixels
argument_list|,
name|mImageArray
index|[
name|level
index|]
argument_list|)
condition|)
block|{
name|commitRect
argument_list|(
name|level
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|zoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|copySubImage
name|void
name|TextureD3D_3D
operator|::
name|copySubImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLint
name|zoffset
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|gl
operator|::
name|Framebuffer
modifier|*
name|source
parameter_list|)
block|{
comment|// can only make our texture storage to a render target if level 0 is defined (with a width& height) and
comment|// the current level we're copying to is defined (with appropriate format, width& height)
name|bool
name|canCreateRenderTarget
init|=
name|isLevelComplete
argument_list|(
name|level
argument_list|)
operator|&&
name|isLevelComplete
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mImageArray
index|[
name|level
index|]
operator|->
name|isRenderableFormat
argument_list|()
operator|||
operator|(
operator|!
name|mTexStorage
operator|&&
operator|!
name|canCreateRenderTarget
operator|)
condition|)
block|{
name|mImageArray
index|[
name|level
index|]
operator|->
name|copy
argument_list|(
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|zoffset
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|ensureRenderTarget
argument_list|()
expr_stmt|;
if|if
condition|(
name|isValidLevel
argument_list|(
name|level
argument_list|)
condition|)
block|{
name|updateStorageLevel
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|gl
operator|::
name|Rectangle
name|sourceRect
decl_stmt|;
name|sourceRect
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|sourceRect
operator|.
name|width
operator|=
name|width
expr_stmt|;
name|sourceRect
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|sourceRect
operator|.
name|height
operator|=
name|height
expr_stmt|;
name|mRenderer
operator|->
name|copyImage
argument_list|(
name|source
argument_list|,
name|sourceRect
argument_list|,
name|gl
operator|::
name|GetFormat
argument_list|(
name|getBaseLevelInternalFormat
argument_list|()
argument_list|)
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|zoffset
argument_list|,
name|mTexStorage
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|storage
name|void
name|TextureD3D_3D
operator|::
name|storage
parameter_list|(
name|GLsizei
name|levels
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|depth
parameter_list|)
block|{
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|levels
condition|;
name|level
operator|++
control|)
block|{
name|GLsizei
name|levelWidth
init|=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|width
operator|>>
name|level
argument_list|)
decl_stmt|;
name|GLsizei
name|levelHeight
init|=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|height
operator|>>
name|level
argument_list|)
decl_stmt|;
name|GLsizei
name|levelDepth
init|=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|depth
operator|>>
name|level
argument_list|)
decl_stmt|;
name|mImageArray
index|[
name|level
index|]
operator|->
name|redefine
argument_list|(
name|mRenderer
argument_list|,
name|GL_TEXTURE_3D
argument_list|,
name|internalformat
argument_list|,
name|levelWidth
argument_list|,
name|levelHeight
argument_list|,
name|levelDepth
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|level
init|=
name|levels
init|;
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|level
operator|++
control|)
block|{
name|mImageArray
index|[
name|level
index|]
operator|->
name|redefine
argument_list|(
name|mRenderer
argument_list|,
name|GL_TEXTURE_3D
argument_list|,
name|GL_NONE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|mImmutable
operator|=
literal|true
expr_stmt|;
name|setCompleteTexStorage
argument_list|(
operator|new
name|TextureStorageInterface3D
argument_list|(
name|mRenderer
argument_list|,
name|internalformat
argument_list|,
name|IsRenderTargetUsage
argument_list|(
name|mUsage
argument_list|)
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|,
name|levels
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|isSamplerComplete
name|bool
name|TextureD3D_3D
operator|::
name|isSamplerComplete
parameter_list|(
specifier|const
name|gl
operator|::
name|SamplerState
modifier|&
name|samplerState
parameter_list|)
specifier|const
block|{
name|GLsizei
name|width
init|=
name|getBaseLevelWidth
argument_list|()
decl_stmt|;
name|GLsizei
name|height
init|=
name|getBaseLevelHeight
argument_list|()
decl_stmt|;
name|GLsizei
name|depth
init|=
name|getBaseLevelDepth
argument_list|()
decl_stmt|;
if|if
condition|(
name|width
operator|<=
literal|0
operator|||
name|height
operator|<=
literal|0
operator|||
name|depth
operator|<=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// TODO(geofflang): use context's texture caps
if|if
condition|(
operator|!
name|mRenderer
operator|->
name|getRendererTextureCaps
argument_list|()
operator|.
name|get
argument_list|(
name|getInternalFormat
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|filterable
condition|)
block|{
if|if
condition|(
name|samplerState
operator|.
name|magFilter
operator|!=
name|GL_NEAREST
operator|||
operator|(
name|samplerState
operator|.
name|minFilter
operator|!=
name|GL_NEAREST
operator|&&
name|samplerState
operator|.
name|minFilter
operator|!=
name|GL_NEAREST_MIPMAP_NEAREST
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|IsMipmapFiltered
argument_list|(
name|samplerState
argument_list|)
operator|&&
operator|!
name|isMipmapComplete
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|isMipmapComplete
name|bool
name|TextureD3D_3D
operator|::
name|isMipmapComplete
parameter_list|()
specifier|const
block|{
name|int
name|levelCount
init|=
name|mipLevels
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|levelCount
condition|;
name|level
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isLevelComplete
argument_list|(
name|level
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|generateMipmaps
name|void
name|TextureD3D_3D
operator|::
name|generateMipmaps
parameter_list|()
block|{
comment|// Purge array levels 1 through q and reset them to represent the generated mipmap levels.
name|int
name|levelCount
init|=
name|mipLevels
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<
name|levelCount
condition|;
name|level
operator|++
control|)
block|{
name|redefineImage
argument_list|(
name|level
argument_list|,
name|getBaseLevelInternalFormat
argument_list|()
argument_list|,
name|std
operator|::
name|max
argument_list|(
name|getBaseLevelWidth
argument_list|()
operator|>>
name|level
argument_list|,
literal|1
argument_list|)
argument_list|,
name|std
operator|::
name|max
argument_list|(
name|getBaseLevelHeight
argument_list|()
operator|>>
name|level
argument_list|,
literal|1
argument_list|)
argument_list|,
name|std
operator|::
name|max
argument_list|(
name|getBaseLevelDepth
argument_list|()
operator|>>
name|level
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mTexStorage
operator|&&
name|mTexStorage
operator|->
name|isRenderTarget
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<
name|levelCount
condition|;
name|level
operator|++
control|)
block|{
name|mTexStorage
operator|->
name|generateMipmap
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|mImageArray
index|[
name|level
index|]
operator|->
name|markClean
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<
name|levelCount
condition|;
name|level
operator|++
control|)
block|{
name|mRenderer
operator|->
name|generateMipmap
argument_list|(
name|mImageArray
index|[
name|level
index|]
argument_list|,
name|mImageArray
index|[
name|level
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|getRenderTargetSerial
name|unsigned
name|int
name|TextureD3D_3D
operator|::
name|getRenderTargetSerial
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLint
name|layer
parameter_list|)
block|{
return|return
operator|(
name|ensureRenderTarget
argument_list|()
condition|?
name|mTexStorage
operator|->
name|getRenderTargetSerial
argument_list|(
name|level
argument_list|,
name|layer
argument_list|)
else|:
literal|0
operator|)
return|;
block|}
DECL|function|getRenderTarget
name|RenderTarget
modifier|*
name|TextureD3D_3D
operator|::
name|getRenderTarget
parameter_list|(
name|GLint
name|level
parameter_list|)
block|{
comment|// ensure the underlying texture is created
if|if
condition|(
operator|!
name|ensureRenderTarget
argument_list|()
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|updateStorageLevel
argument_list|(
name|level
argument_list|)
expr_stmt|;
comment|// ensure this is NOT a depth texture
if|if
condition|(
name|isDepth
argument_list|(
name|level
argument_list|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
name|mTexStorage
operator|->
name|getRenderTarget
argument_list|(
name|level
argument_list|)
return|;
block|}
DECL|function|getRenderTarget
name|RenderTarget
modifier|*
name|TextureD3D_3D
operator|::
name|getRenderTarget
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLint
name|layer
parameter_list|)
block|{
comment|// ensure the underlying texture is created
if|if
condition|(
operator|!
name|ensureRenderTarget
argument_list|()
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|updateStorage
argument_list|()
expr_stmt|;
comment|// ensure this is NOT a depth texture
if|if
condition|(
name|isDepth
argument_list|(
name|level
argument_list|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
name|mTexStorage
operator|->
name|getRenderTarget
argument_list|(
name|level
argument_list|,
name|layer
argument_list|)
return|;
block|}
DECL|function|getDepthStencil
name|RenderTarget
modifier|*
name|TextureD3D_3D
operator|::
name|getDepthStencil
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLint
name|layer
parameter_list|)
block|{
comment|// ensure the underlying texture is created
if|if
condition|(
operator|!
name|ensureRenderTarget
argument_list|()
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|updateStorageLevel
argument_list|(
name|level
argument_list|)
expr_stmt|;
comment|// ensure this is a depth texture
if|if
condition|(
operator|!
name|isDepth
argument_list|(
name|level
argument_list|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
name|mTexStorage
operator|->
name|getRenderTarget
argument_list|(
name|level
argument_list|,
name|layer
argument_list|)
return|;
block|}
DECL|function|initializeStorage
name|void
name|TextureD3D_3D
operator|::
name|initializeStorage
parameter_list|(
name|bool
name|renderTarget
parameter_list|)
block|{
comment|// Only initialize the first time this texture is used as a render target or shader resource
if|if
condition|(
name|mTexStorage
condition|)
block|{
return|return;
block|}
comment|// do not attempt to create storage for nonexistant data
if|if
condition|(
operator|!
name|isLevelComplete
argument_list|(
literal|0
argument_list|)
condition|)
block|{
return|return;
block|}
name|bool
name|createRenderTarget
init|=
operator|(
name|renderTarget
operator|||
name|mUsage
operator|==
name|GL_FRAMEBUFFER_ATTACHMENT_ANGLE
operator|)
decl_stmt|;
name|setCompleteTexStorage
argument_list|(
name|createCompleteStorage
argument_list|(
name|createRenderTarget
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
comment|// flush image data to the storage
name|updateStorage
argument_list|()
expr_stmt|;
block|}
DECL|function|createCompleteStorage
name|TextureStorageInterface3D
modifier|*
name|TextureD3D_3D
operator|::
name|createCompleteStorage
parameter_list|(
name|bool
name|renderTarget
parameter_list|)
specifier|const
block|{
name|GLsizei
name|width
init|=
name|getBaseLevelWidth
argument_list|()
decl_stmt|;
name|GLsizei
name|height
init|=
name|getBaseLevelHeight
argument_list|()
decl_stmt|;
name|GLsizei
name|depth
init|=
name|getBaseLevelDepth
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|width
operator|>
literal|0
operator|&&
name|height
operator|>
literal|0
operator|&&
name|depth
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|// use existing storage level count, when previously specified by TexStorage*D
name|GLint
name|levels
init|=
operator|(
name|mTexStorage
condition|?
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
else|:
name|creationLevels
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|)
operator|)
decl_stmt|;
return|return
operator|new
name|TextureStorageInterface3D
argument_list|(
name|mRenderer
argument_list|,
name|getBaseLevelInternalFormat
argument_list|()
argument_list|,
name|renderTarget
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|,
name|levels
argument_list|)
return|;
block|}
DECL|function|setCompleteTexStorage
name|void
name|TextureD3D_3D
operator|::
name|setCompleteTexStorage
parameter_list|(
name|TextureStorageInterface3D
modifier|*
name|newCompleteTexStorage
parameter_list|)
block|{
name|SafeDelete
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
name|mTexStorage
operator|=
name|newCompleteTexStorage
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
comment|// We do not support managed 3D storage, as that is D3D9/ES2-only
name|ASSERT
argument_list|(
operator|!
name|mTexStorage
operator|->
name|isManaged
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|function|updateStorage
name|void
name|TextureD3D_3D
operator|::
name|updateStorage
parameter_list|()
block|{
name|ASSERT
argument_list|(
name|mTexStorage
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|GLint
name|storageLevels
init|=
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|storageLevels
condition|;
name|level
operator|++
control|)
block|{
if|if
condition|(
name|mImageArray
index|[
name|level
index|]
operator|->
name|isDirty
argument_list|()
operator|&&
name|isLevelComplete
argument_list|(
name|level
argument_list|)
condition|)
block|{
name|updateStorageLevel
argument_list|(
name|level
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|ensureRenderTarget
name|bool
name|TextureD3D_3D
operator|::
name|ensureRenderTarget
parameter_list|()
block|{
name|initializeStorage
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|getBaseLevelWidth
argument_list|()
operator|>
literal|0
operator|&&
name|getBaseLevelHeight
argument_list|()
operator|>
literal|0
operator|&&
name|getBaseLevelDepth
argument_list|()
operator|>
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mTexStorage
operator|->
name|isRenderTarget
argument_list|()
condition|)
block|{
name|TextureStorageInterface3D
modifier|*
name|newRenderTargetStorage
init|=
name|createCompleteStorage
argument_list|(
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mRenderer
operator|->
name|copyToRenderTarget
argument_list|(
name|newRenderTargetStorage
argument_list|,
name|mTexStorage
argument_list|)
condition|)
block|{
operator|delete
name|newRenderTargetStorage
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|setCompleteTexStorage
argument_list|(
name|newRenderTargetStorage
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|mTexStorage
operator|&&
name|mTexStorage
operator|->
name|isRenderTarget
argument_list|()
operator|)
return|;
block|}
DECL|function|getBaseLevelStorage
name|TextureStorageInterface
modifier|*
name|TextureD3D_3D
operator|::
name|getBaseLevelStorage
parameter_list|()
block|{
return|return
name|mTexStorage
return|;
block|}
DECL|function|getBaseLevelImage
specifier|const
name|ImageD3D
modifier|*
name|TextureD3D_3D
operator|::
name|getBaseLevelImage
parameter_list|()
specifier|const
block|{
return|return
name|mImageArray
index|[
literal|0
index|]
return|;
block|}
DECL|function|isValidLevel
name|bool
name|TextureD3D_3D
operator|::
name|isValidLevel
parameter_list|(
name|int
name|level
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|mTexStorage
condition|?
operator|(
name|level
operator|>=
literal|0
operator|&&
name|level
operator|<
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
operator|)
else|:
literal|0
operator|)
return|;
block|}
DECL|function|isLevelComplete
name|bool
name|TextureD3D_3D
operator|::
name|isLevelComplete
parameter_list|(
name|int
name|level
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|level
operator|>=
literal|0
operator|&&
name|level
operator|<
operator|(
name|int
operator|)
name|ArraySize
argument_list|(
name|mImageArray
argument_list|)
operator|&&
name|mImageArray
index|[
name|level
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isImmutable
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
name|GLsizei
name|width
init|=
name|getBaseLevelWidth
argument_list|()
decl_stmt|;
name|GLsizei
name|height
init|=
name|getBaseLevelHeight
argument_list|()
decl_stmt|;
name|GLsizei
name|depth
init|=
name|getBaseLevelDepth
argument_list|()
decl_stmt|;
if|if
condition|(
name|width
operator|<=
literal|0
operator|||
name|height
operator|<=
literal|0
operator|||
name|depth
operator|<=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|level
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
name|ImageD3D
modifier|*
name|levelImage
init|=
name|mImageArray
index|[
name|level
index|]
decl_stmt|;
if|if
condition|(
name|levelImage
operator|->
name|getInternalFormat
argument_list|()
operator|!=
name|getBaseLevelInternalFormat
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|levelImage
operator|->
name|getWidth
argument_list|()
operator|!=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|width
operator|>>
name|level
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|levelImage
operator|->
name|getHeight
argument_list|()
operator|!=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|height
operator|>>
name|level
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|levelImage
operator|->
name|getDepth
argument_list|()
operator|!=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|depth
operator|>>
name|level
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|updateStorageLevel
name|void
name|TextureD3D_3D
operator|::
name|updateStorageLevel
parameter_list|(
name|int
name|level
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|level
operator|>=
literal|0
operator|&&
name|level
operator|<
operator|(
name|int
operator|)
name|ArraySize
argument_list|(
name|mImageArray
argument_list|)
operator|&&
name|mImageArray
index|[
name|level
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|isLevelComplete
argument_list|(
name|level
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mImageArray
index|[
name|level
index|]
operator|->
name|isDirty
argument_list|()
condition|)
block|{
name|commitRect
argument_list|(
name|level
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|getWidth
argument_list|(
name|level
argument_list|)
argument_list|,
name|getHeight
argument_list|(
name|level
argument_list|)
argument_list|,
name|getDepth
argument_list|(
name|level
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|redefineImage
name|void
name|TextureD3D_3D
operator|::
name|redefineImage
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|depth
parameter_list|)
block|{
comment|// If there currently is a corresponding storage texture image, it has these parameters
specifier|const
name|int
name|storageWidth
init|=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|getBaseLevelWidth
argument_list|()
operator|>>
name|level
argument_list|)
decl_stmt|;
specifier|const
name|int
name|storageHeight
init|=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|getBaseLevelHeight
argument_list|()
operator|>>
name|level
argument_list|)
decl_stmt|;
specifier|const
name|int
name|storageDepth
init|=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|getBaseLevelDepth
argument_list|()
operator|>>
name|level
argument_list|)
decl_stmt|;
specifier|const
name|GLenum
name|storageFormat
init|=
name|getBaseLevelInternalFormat
argument_list|()
decl_stmt|;
name|mImageArray
index|[
name|level
index|]
operator|->
name|redefine
argument_list|(
name|mRenderer
argument_list|,
name|GL_TEXTURE_3D
argument_list|,
name|internalformat
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|mTexStorage
condition|)
block|{
specifier|const
name|int
name|storageLevels
init|=
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|level
operator|>=
name|storageLevels
operator|&&
name|storageLevels
operator|!=
literal|0
operator|)
operator|||
name|width
operator|!=
name|storageWidth
operator|||
name|height
operator|!=
name|storageHeight
operator|||
name|depth
operator|!=
name|storageDepth
operator|||
name|internalformat
operator|!=
name|storageFormat
condition|)
comment|// Discard mismatched storage
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|i
operator|++
control|)
block|{
name|mImageArray
index|[
name|i
index|]
operator|->
name|markDirty
argument_list|()
expr_stmt|;
block|}
name|SafeDelete
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
DECL|function|commitRect
name|void
name|TextureD3D_3D
operator|::
name|commitRect
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLint
name|zoffset
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|depth
parameter_list|)
block|{
if|if
condition|(
name|isValidLevel
argument_list|(
name|level
argument_list|)
condition|)
block|{
name|ImageD3D
modifier|*
name|image
init|=
name|mImageArray
index|[
name|level
index|]
decl_stmt|;
if|if
condition|(
name|image
operator|->
name|copyToStorage
argument_list|(
name|mTexStorage
argument_list|,
name|level
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|zoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|)
condition|)
block|{
name|image
operator|->
name|markClean
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|function|TextureD3D_2DArray
name|TextureD3D_2DArray
operator|::
name|TextureD3D_2DArray
parameter_list|(
name|Renderer
modifier|*
name|renderer
parameter_list|)
member_init_list|:
name|Texture2DArrayImpl
argument_list|()
member_init_list|,
name|TextureD3D
argument_list|(
name|renderer
argument_list|)
member_init_list|,
name|mTexStorage
argument_list|(
name|NULL
argument_list|)
block|{
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
operator|++
name|level
control|)
block|{
name|mLayerCounts
index|[
name|level
index|]
operator|=
literal|0
expr_stmt|;
name|mImageArray
index|[
name|level
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
DECL|function|~TextureD3D_2DArray
name|TextureD3D_2DArray
operator|::
name|~
name|TextureD3D_2DArray
parameter_list|()
block|{
name|SafeDelete
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
name|deleteImages
argument_list|()
expr_stmt|;
block|}
DECL|function|makeTextureD3D_2DArray
name|TextureD3D_2DArray
modifier|*
name|TextureD3D_2DArray
operator|::
name|makeTextureD3D_2DArray
parameter_list|(
name|Texture2DArrayImpl
modifier|*
name|texture
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|HAS_DYNAMIC_TYPE
argument_list|(
name|TextureD3D_2DArray
operator|*
argument_list|,
name|texture
argument_list|)
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|TextureD3D_2DArray
operator|*
argument_list|>
argument_list|(
name|texture
argument_list|)
return|;
block|}
DECL|function|getNativeTexture
name|TextureStorageInterface
modifier|*
name|TextureD3D_2DArray
operator|::
name|getNativeTexture
parameter_list|()
block|{
comment|// ensure the underlying texture is created
name|initializeStorage
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|TextureStorageInterface
modifier|*
name|storage
init|=
name|getBaseLevelStorage
argument_list|()
decl_stmt|;
if|if
condition|(
name|storage
condition|)
block|{
name|updateStorage
argument_list|()
expr_stmt|;
block|}
return|return
name|storage
return|;
block|}
DECL|function|getImage
name|Image
modifier|*
name|TextureD3D_2DArray
operator|::
name|getImage
parameter_list|(
name|int
name|level
parameter_list|,
name|int
name|layer
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|layer
operator|<
name|mLayerCounts
index|[
name|level
index|]
argument_list|)
expr_stmt|;
return|return
name|mImageArray
index|[
name|level
index|]
index|[
name|layer
index|]
return|;
block|}
DECL|function|getLayerCount
name|GLsizei
name|TextureD3D_2DArray
operator|::
name|getLayerCount
parameter_list|(
name|int
name|level
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
argument_list|)
expr_stmt|;
return|return
name|mLayerCounts
index|[
name|level
index|]
return|;
block|}
DECL|function|setUsage
name|void
name|TextureD3D_2DArray
operator|::
name|setUsage
parameter_list|(
name|GLenum
name|usage
parameter_list|)
block|{
name|mUsage
operator|=
name|usage
expr_stmt|;
block|}
DECL|function|resetDirty
name|void
name|TextureD3D_2DArray
operator|::
name|resetDirty
parameter_list|()
block|{
name|mDirtyImages
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|getWidth
name|GLsizei
name|TextureD3D_2DArray
operator|::
name|getWidth
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|level
argument_list|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
operator|&&
name|mLayerCounts
index|[
name|level
index|]
argument_list|>
literal|0
operator|)
condition|?
name|mImageArray
index|[
name|level
index|]
index|[
literal|0
index|]
operator|->
name|getWidth
argument_list|()
else|:
literal|0
return|;
block|}
DECL|function|getHeight
name|GLsizei
name|TextureD3D_2DArray
operator|::
name|getHeight
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|level
argument_list|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
operator|&&
name|mLayerCounts
index|[
name|level
index|]
argument_list|>
literal|0
operator|)
condition|?
name|mImageArray
index|[
name|level
index|]
index|[
literal|0
index|]
operator|->
name|getHeight
argument_list|()
else|:
literal|0
return|;
block|}
DECL|function|getLayers
name|GLsizei
name|TextureD3D_2DArray
operator|::
name|getLayers
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
operator|)
condition|?
name|mLayerCounts
index|[
name|level
index|]
else|:
literal|0
return|;
block|}
DECL|function|getInternalFormat
name|GLenum
name|TextureD3D_2DArray
operator|::
name|getInternalFormat
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|level
argument_list|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
operator|&&
name|mLayerCounts
index|[
name|level
index|]
argument_list|>
literal|0
operator|)
condition|?
name|mImageArray
index|[
name|level
index|]
index|[
literal|0
index|]
operator|->
name|getInternalFormat
argument_list|()
else|:
name|GL_NONE
return|;
block|}
DECL|function|isDepth
name|bool
name|TextureD3D_2DArray
operator|::
name|isDepth
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
return|return
name|gl
operator|::
name|GetDepthBits
argument_list|(
name|getInternalFormat
argument_list|(
name|level
argument_list|)
argument_list|)
operator|>
literal|0
return|;
block|}
DECL|function|setImage
name|void
name|TextureD3D_2DArray
operator|::
name|setImage
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|depth
parameter_list|,
name|GLenum
name|internalFormat
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
name|GLenum
name|sizedInternalFormat
init|=
name|gl
operator|::
name|IsSizedInternalFormat
argument_list|(
name|internalFormat
argument_list|)
condition|?
name|internalFormat
else|:
name|gl
operator|::
name|GetSizedInternalFormat
argument_list|(
name|format
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|redefineImage
argument_list|(
name|level
argument_list|,
name|sizedInternalFormat
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|GLsizei
name|inputDepthPitch
init|=
name|gl
operator|::
name|GetDepthPitch
argument_list|(
name|sizedInternalFormat
argument_list|,
name|type
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|unpack
operator|.
name|alignment
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|depth
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|void
modifier|*
name|layerPixels
init|=
name|pixels
condition|?
operator|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|pixels
argument_list|)
operator|+
operator|(
name|inputDepthPitch
operator|*
name|i
operator|)
operator|)
else|:
name|NULL
decl_stmt|;
name|TextureD3D
operator|::
name|setImage
argument_list|(
name|unpack
argument_list|,
name|type
argument_list|,
name|layerPixels
argument_list|,
name|mImageArray
index|[
name|level
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|setCompressedImage
name|void
name|TextureD3D_2DArray
operator|::
name|setCompressedImage
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|depth
parameter_list|,
name|GLsizei
name|imageSize
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
comment|// compressed formats don't have separate sized internal formats-- we can just use the compressed format directly
name|redefineImage
argument_list|(
name|level
argument_list|,
name|format
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|GLsizei
name|inputDepthPitch
init|=
name|gl
operator|::
name|GetDepthPitch
argument_list|(
name|format
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|depth
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|void
modifier|*
name|layerPixels
init|=
name|pixels
condition|?
operator|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|pixels
argument_list|)
operator|+
operator|(
name|inputDepthPitch
operator|*
name|i
operator|)
operator|)
else|:
name|NULL
decl_stmt|;
name|TextureD3D
operator|::
name|setCompressedImage
argument_list|(
name|imageSize
argument_list|,
name|layerPixels
argument_list|,
name|mImageArray
index|[
name|level
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|subImage
name|void
name|TextureD3D_2DArray
operator|::
name|subImage
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLint
name|zoffset
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|depth
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
name|GLenum
name|internalformat
init|=
name|getInternalFormat
argument_list|(
name|level
argument_list|)
decl_stmt|;
name|GLsizei
name|inputDepthPitch
init|=
name|gl
operator|::
name|GetDepthPitch
argument_list|(
name|internalformat
argument_list|,
name|type
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|unpack
operator|.
name|alignment
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|depth
condition|;
name|i
operator|++
control|)
block|{
name|int
name|layer
init|=
name|zoffset
operator|+
name|i
decl_stmt|;
specifier|const
name|void
modifier|*
name|layerPixels
init|=
name|pixels
condition|?
operator|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|pixels
argument_list|)
operator|+
operator|(
name|inputDepthPitch
operator|*
name|i
operator|)
operator|)
else|:
name|NULL
decl_stmt|;
if|if
condition|(
name|TextureD3D
operator|::
name|subImage
argument_list|(
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|zoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|1
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|unpack
argument_list|,
name|layerPixels
argument_list|,
name|mImageArray
index|[
name|level
index|]
index|[
name|layer
index|]
argument_list|)
condition|)
block|{
name|commitRect
argument_list|(
name|level
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|layer
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|subImageCompressed
name|void
name|TextureD3D_2DArray
operator|::
name|subImageCompressed
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLint
name|zoffset
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|depth
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLsizei
name|imageSize
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
name|GLsizei
name|inputDepthPitch
init|=
name|gl
operator|::
name|GetDepthPitch
argument_list|(
name|format
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|depth
condition|;
name|i
operator|++
control|)
block|{
name|int
name|layer
init|=
name|zoffset
operator|+
name|i
decl_stmt|;
specifier|const
name|void
modifier|*
name|layerPixels
init|=
name|pixels
condition|?
operator|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|pixels
argument_list|)
operator|+
operator|(
name|inputDepthPitch
operator|*
name|i
operator|)
operator|)
else|:
name|NULL
decl_stmt|;
if|if
condition|(
name|TextureD3D
operator|::
name|subImageCompressed
argument_list|(
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|zoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|1
argument_list|,
name|format
argument_list|,
name|imageSize
argument_list|,
name|layerPixels
argument_list|,
name|mImageArray
index|[
name|level
index|]
index|[
name|layer
index|]
argument_list|)
condition|)
block|{
name|commitRect
argument_list|(
name|level
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|layer
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|copySubImage
name|void
name|TextureD3D_2DArray
operator|::
name|copySubImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLint
name|zoffset
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|gl
operator|::
name|Framebuffer
modifier|*
name|source
parameter_list|)
block|{
comment|// can only make our texture storage to a render target if level 0 is defined (with a width& height) and
comment|// the current level we're copying to is defined (with appropriate format, width& height)
name|bool
name|canCreateRenderTarget
init|=
name|isLevelComplete
argument_list|(
name|level
argument_list|)
operator|&&
name|isLevelComplete
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mImageArray
index|[
name|level
index|]
index|[
literal|0
index|]
operator|->
name|isRenderableFormat
argument_list|()
operator|||
operator|(
operator|!
name|mTexStorage
operator|&&
operator|!
name|canCreateRenderTarget
operator|)
condition|)
block|{
name|mImageArray
index|[
name|level
index|]
index|[
name|zoffset
index|]
operator|->
name|copy
argument_list|(
name|xoffset
argument_list|,
name|yoffset
argument_list|,
literal|0
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|ensureRenderTarget
argument_list|()
expr_stmt|;
if|if
condition|(
name|isValidLevel
argument_list|(
name|level
argument_list|)
condition|)
block|{
name|updateStorageLevel
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|gl
operator|::
name|Rectangle
name|sourceRect
decl_stmt|;
name|sourceRect
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|sourceRect
operator|.
name|width
operator|=
name|width
expr_stmt|;
name|sourceRect
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|sourceRect
operator|.
name|height
operator|=
name|height
expr_stmt|;
name|mRenderer
operator|->
name|copyImage
argument_list|(
name|source
argument_list|,
name|sourceRect
argument_list|,
name|gl
operator|::
name|GetFormat
argument_list|(
name|getInternalFormat
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|zoffset
argument_list|,
name|mTexStorage
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|storage
name|void
name|TextureD3D_2DArray
operator|::
name|storage
parameter_list|(
name|GLsizei
name|levels
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|depth
parameter_list|)
block|{
name|deleteImages
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|level
operator|++
control|)
block|{
name|GLsizei
name|levelWidth
init|=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|width
operator|>>
name|level
argument_list|)
decl_stmt|;
name|GLsizei
name|levelHeight
init|=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|height
operator|>>
name|level
argument_list|)
decl_stmt|;
name|mLayerCounts
index|[
name|level
index|]
operator|=
operator|(
name|level
operator|<
name|levels
condition|?
name|depth
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|mLayerCounts
index|[
name|level
index|]
operator|>
literal|0
condition|)
block|{
comment|// Create new images for this level
name|mImageArray
index|[
name|level
index|]
operator|=
operator|new
name|ImageD3D
operator|*
index|[
name|mLayerCounts
index|[
name|level
index|]
index|]
expr_stmt|;
for|for
control|(
name|int
name|layer
init|=
literal|0
init|;
name|layer
operator|<
name|mLayerCounts
index|[
name|level
index|]
condition|;
name|layer
operator|++
control|)
block|{
name|mImageArray
index|[
name|level
index|]
index|[
name|layer
index|]
operator|=
name|ImageD3D
operator|::
name|makeImageD3D
argument_list|(
name|mRenderer
operator|->
name|createImage
argument_list|()
argument_list|)
expr_stmt|;
name|mImageArray
index|[
name|level
index|]
index|[
name|layer
index|]
operator|->
name|redefine
argument_list|(
name|mRenderer
argument_list|,
name|GL_TEXTURE_2D_ARRAY
argument_list|,
name|internalformat
argument_list|,
name|levelWidth
argument_list|,
name|levelHeight
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|mImmutable
operator|=
literal|true
expr_stmt|;
name|setCompleteTexStorage
argument_list|(
operator|new
name|TextureStorageInterface2DArray
argument_list|(
name|mRenderer
argument_list|,
name|internalformat
argument_list|,
name|IsRenderTargetUsage
argument_list|(
name|mUsage
argument_list|)
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|,
name|levels
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|isSamplerComplete
name|bool
name|TextureD3D_2DArray
operator|::
name|isSamplerComplete
parameter_list|(
specifier|const
name|gl
operator|::
name|SamplerState
modifier|&
name|samplerState
parameter_list|)
specifier|const
block|{
name|GLsizei
name|width
init|=
name|getBaseLevelWidth
argument_list|()
decl_stmt|;
name|GLsizei
name|height
init|=
name|getBaseLevelHeight
argument_list|()
decl_stmt|;
name|GLsizei
name|depth
init|=
name|getLayers
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|width
operator|<=
literal|0
operator|||
name|height
operator|<=
literal|0
operator|||
name|depth
operator|<=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// TODO(geofflang): use context's texture caps
if|if
condition|(
operator|!
name|mRenderer
operator|->
name|getRendererTextureCaps
argument_list|()
operator|.
name|get
argument_list|(
name|getBaseLevelInternalFormat
argument_list|()
argument_list|)
operator|.
name|filterable
condition|)
block|{
if|if
condition|(
name|samplerState
operator|.
name|magFilter
operator|!=
name|GL_NEAREST
operator|||
operator|(
name|samplerState
operator|.
name|minFilter
operator|!=
name|GL_NEAREST
operator|&&
name|samplerState
operator|.
name|minFilter
operator|!=
name|GL_NEAREST_MIPMAP_NEAREST
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|IsMipmapFiltered
argument_list|(
name|samplerState
argument_list|)
operator|&&
operator|!
name|isMipmapComplete
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|isMipmapComplete
name|bool
name|TextureD3D_2DArray
operator|::
name|isMipmapComplete
parameter_list|()
specifier|const
block|{
name|int
name|levelCount
init|=
name|mipLevels
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<
name|levelCount
condition|;
name|level
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isLevelComplete
argument_list|(
name|level
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|generateMipmaps
name|void
name|TextureD3D_2DArray
operator|::
name|generateMipmaps
parameter_list|()
block|{
name|int
name|baseWidth
init|=
name|getBaseLevelWidth
argument_list|()
decl_stmt|;
name|int
name|baseHeight
init|=
name|getBaseLevelHeight
argument_list|()
decl_stmt|;
name|int
name|baseDepth
init|=
name|getBaseLevelDepth
argument_list|()
decl_stmt|;
name|GLenum
name|baseFormat
init|=
name|getBaseLevelInternalFormat
argument_list|()
decl_stmt|;
comment|// Purge array levels 1 through q and reset them to represent the generated mipmap levels.
name|int
name|levelCount
init|=
name|mipLevels
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<
name|levelCount
condition|;
name|level
operator|++
control|)
block|{
name|redefineImage
argument_list|(
name|level
argument_list|,
name|baseFormat
argument_list|,
name|std
operator|::
name|max
argument_list|(
name|baseWidth
operator|>>
name|level
argument_list|,
literal|1
argument_list|)
argument_list|,
name|std
operator|::
name|max
argument_list|(
name|baseHeight
operator|>>
name|level
argument_list|,
literal|1
argument_list|)
argument_list|,
name|baseDepth
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mTexStorage
operator|&&
name|mTexStorage
operator|->
name|isRenderTarget
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<
name|levelCount
condition|;
name|level
operator|++
control|)
block|{
name|mTexStorage
operator|->
name|generateMipmap
argument_list|(
name|level
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|layer
init|=
literal|0
init|;
name|layer
operator|<
name|mLayerCounts
index|[
name|level
index|]
condition|;
name|layer
operator|++
control|)
block|{
name|mImageArray
index|[
name|level
index|]
index|[
name|layer
index|]
operator|->
name|markClean
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<
name|levelCount
condition|;
name|level
operator|++
control|)
block|{
for|for
control|(
name|int
name|layer
init|=
literal|0
init|;
name|layer
operator|<
name|mLayerCounts
index|[
name|level
index|]
condition|;
name|layer
operator|++
control|)
block|{
name|mRenderer
operator|->
name|generateMipmap
argument_list|(
name|mImageArray
index|[
name|level
index|]
index|[
name|layer
index|]
argument_list|,
name|mImageArray
index|[
name|level
operator|-
literal|1
index|]
index|[
name|layer
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|function|getRenderTargetSerial
name|unsigned
name|int
name|TextureD3D_2DArray
operator|::
name|getRenderTargetSerial
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLint
name|layer
parameter_list|)
block|{
return|return
operator|(
name|ensureRenderTarget
argument_list|()
condition|?
name|mTexStorage
operator|->
name|getRenderTargetSerial
argument_list|(
name|level
argument_list|,
name|layer
argument_list|)
else|:
literal|0
operator|)
return|;
block|}
DECL|function|getRenderTarget
name|RenderTarget
modifier|*
name|TextureD3D_2DArray
operator|::
name|getRenderTarget
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLint
name|layer
parameter_list|)
block|{
comment|// ensure the underlying texture is created
if|if
condition|(
operator|!
name|ensureRenderTarget
argument_list|()
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|updateStorageLevel
argument_list|(
name|level
argument_list|)
expr_stmt|;
comment|// ensure this is NOT a depth texture
if|if
condition|(
name|isDepth
argument_list|(
name|level
argument_list|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
name|mTexStorage
operator|->
name|getRenderTarget
argument_list|(
name|level
argument_list|,
name|layer
argument_list|)
return|;
block|}
DECL|function|getDepthStencil
name|RenderTarget
modifier|*
name|TextureD3D_2DArray
operator|::
name|getDepthStencil
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLint
name|layer
parameter_list|)
block|{
comment|// ensure the underlying texture is created
if|if
condition|(
operator|!
name|ensureRenderTarget
argument_list|()
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|updateStorageLevel
argument_list|(
name|level
argument_list|)
expr_stmt|;
comment|// ensure this is a depth texture
if|if
condition|(
operator|!
name|isDepth
argument_list|(
name|level
argument_list|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
name|mTexStorage
operator|->
name|getRenderTarget
argument_list|(
name|level
argument_list|,
name|layer
argument_list|)
return|;
block|}
DECL|function|initializeStorage
name|void
name|TextureD3D_2DArray
operator|::
name|initializeStorage
parameter_list|(
name|bool
name|renderTarget
parameter_list|)
block|{
comment|// Only initialize the first time this texture is used as a render target or shader resource
if|if
condition|(
name|mTexStorage
condition|)
block|{
return|return;
block|}
comment|// do not attempt to create storage for nonexistant data
if|if
condition|(
operator|!
name|isLevelComplete
argument_list|(
literal|0
argument_list|)
condition|)
block|{
return|return;
block|}
name|bool
name|createRenderTarget
init|=
operator|(
name|renderTarget
operator|||
name|mUsage
operator|==
name|GL_FRAMEBUFFER_ATTACHMENT_ANGLE
operator|)
decl_stmt|;
name|setCompleteTexStorage
argument_list|(
name|createCompleteStorage
argument_list|(
name|createRenderTarget
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
comment|// flush image data to the storage
name|updateStorage
argument_list|()
expr_stmt|;
block|}
DECL|function|createCompleteStorage
name|TextureStorageInterface2DArray
modifier|*
name|TextureD3D_2DArray
operator|::
name|createCompleteStorage
parameter_list|(
name|bool
name|renderTarget
parameter_list|)
specifier|const
block|{
name|GLsizei
name|width
init|=
name|getBaseLevelWidth
argument_list|()
decl_stmt|;
name|GLsizei
name|height
init|=
name|getBaseLevelHeight
argument_list|()
decl_stmt|;
name|GLsizei
name|depth
init|=
name|getLayers
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|width
operator|>
literal|0
operator|&&
name|height
operator|>
literal|0
operator|&&
name|depth
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|// use existing storage level count, when previously specified by TexStorage*D
name|GLint
name|levels
init|=
operator|(
name|mTexStorage
condition|?
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
else|:
name|creationLevels
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
literal|1
argument_list|)
operator|)
decl_stmt|;
return|return
operator|new
name|TextureStorageInterface2DArray
argument_list|(
name|mRenderer
argument_list|,
name|getBaseLevelInternalFormat
argument_list|()
argument_list|,
name|renderTarget
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|,
name|levels
argument_list|)
return|;
block|}
DECL|function|setCompleteTexStorage
name|void
name|TextureD3D_2DArray
operator|::
name|setCompleteTexStorage
parameter_list|(
name|TextureStorageInterface2DArray
modifier|*
name|newCompleteTexStorage
parameter_list|)
block|{
name|SafeDelete
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
name|mTexStorage
operator|=
name|newCompleteTexStorage
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
comment|// We do not support managed 2D array storage, as managed storage is ES2/D3D9 only
name|ASSERT
argument_list|(
operator|!
name|mTexStorage
operator|->
name|isManaged
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|function|updateStorage
name|void
name|TextureD3D_2DArray
operator|::
name|updateStorage
parameter_list|()
block|{
name|ASSERT
argument_list|(
name|mTexStorage
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|GLint
name|storageLevels
init|=
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|storageLevels
condition|;
name|level
operator|++
control|)
block|{
if|if
condition|(
name|isLevelComplete
argument_list|(
name|level
argument_list|)
condition|)
block|{
name|updateStorageLevel
argument_list|(
name|level
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|ensureRenderTarget
name|bool
name|TextureD3D_2DArray
operator|::
name|ensureRenderTarget
parameter_list|()
block|{
name|initializeStorage
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|getBaseLevelWidth
argument_list|()
operator|>
literal|0
operator|&&
name|getBaseLevelHeight
argument_list|()
operator|>
literal|0
operator|&&
name|getLayers
argument_list|(
literal|0
argument_list|)
operator|>
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mTexStorage
operator|->
name|isRenderTarget
argument_list|()
condition|)
block|{
name|TextureStorageInterface2DArray
modifier|*
name|newRenderTargetStorage
init|=
name|createCompleteStorage
argument_list|(
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mRenderer
operator|->
name|copyToRenderTarget
argument_list|(
name|newRenderTargetStorage
argument_list|,
name|mTexStorage
argument_list|)
condition|)
block|{
operator|delete
name|newRenderTargetStorage
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|setCompleteTexStorage
argument_list|(
name|newRenderTargetStorage
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|mTexStorage
operator|&&
name|mTexStorage
operator|->
name|isRenderTarget
argument_list|()
operator|)
return|;
block|}
DECL|function|getBaseLevelImage
specifier|const
name|ImageD3D
modifier|*
name|TextureD3D_2DArray
operator|::
name|getBaseLevelImage
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|mLayerCounts
index|[
literal|0
index|]
operator|>
literal|0
condition|?
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
else|:
name|NULL
operator|)
return|;
block|}
DECL|function|getBaseLevelStorage
name|TextureStorageInterface
modifier|*
name|TextureD3D_2DArray
operator|::
name|getBaseLevelStorage
parameter_list|()
block|{
return|return
name|mTexStorage
return|;
block|}
DECL|function|isValidLevel
name|bool
name|TextureD3D_2DArray
operator|::
name|isValidLevel
parameter_list|(
name|int
name|level
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|mTexStorage
condition|?
operator|(
name|level
operator|>=
literal|0
operator|&&
name|level
operator|<
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
operator|)
else|:
literal|0
operator|)
return|;
block|}
DECL|function|isLevelComplete
name|bool
name|TextureD3D_2DArray
operator|::
name|isLevelComplete
parameter_list|(
name|int
name|level
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|level
operator|>=
literal|0
operator|&&
name|level
operator|<
operator|(
name|int
operator|)
name|ArraySize
argument_list|(
name|mImageArray
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isImmutable
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
name|GLsizei
name|width
init|=
name|getBaseLevelWidth
argument_list|()
decl_stmt|;
name|GLsizei
name|height
init|=
name|getBaseLevelHeight
argument_list|()
decl_stmt|;
name|GLsizei
name|layers
init|=
name|getLayers
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|width
operator|<=
literal|0
operator|||
name|height
operator|<=
literal|0
operator|||
name|layers
operator|<=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|level
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|getInternalFormat
argument_list|(
name|level
argument_list|)
operator|!=
name|getInternalFormat
argument_list|(
literal|0
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|getWidth
argument_list|(
name|level
argument_list|)
operator|!=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|width
operator|>>
name|level
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|getHeight
argument_list|(
name|level
argument_list|)
operator|!=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|height
operator|>>
name|level
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|getLayers
argument_list|(
name|level
argument_list|)
operator|!=
name|layers
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|updateStorageLevel
name|void
name|TextureD3D_2DArray
operator|::
name|updateStorageLevel
parameter_list|(
name|int
name|level
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|level
operator|>=
literal|0
operator|&&
name|level
operator|<
operator|(
name|int
operator|)
name|ArraySize
argument_list|(
name|mLayerCounts
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|isLevelComplete
argument_list|(
name|level
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|layer
init|=
literal|0
init|;
name|layer
operator|<
name|mLayerCounts
index|[
name|level
index|]
condition|;
name|layer
operator|++
control|)
block|{
name|ASSERT
argument_list|(
name|mImageArray
index|[
name|level
index|]
operator|!=
name|NULL
operator|&&
name|mImageArray
index|[
name|level
index|]
index|[
name|layer
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mImageArray
index|[
name|level
index|]
index|[
name|layer
index|]
operator|->
name|isDirty
argument_list|()
condition|)
block|{
name|commitRect
argument_list|(
name|level
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|layer
argument_list|,
name|getWidth
argument_list|(
name|level
argument_list|)
argument_list|,
name|getHeight
argument_list|(
name|level
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|deleteImages
name|void
name|TextureD3D_2DArray
operator|::
name|deleteImages
parameter_list|()
block|{
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
operator|++
name|level
control|)
block|{
for|for
control|(
name|int
name|layer
init|=
literal|0
init|;
name|layer
operator|<
name|mLayerCounts
index|[
name|level
index|]
condition|;
operator|++
name|layer
control|)
block|{
operator|delete
name|mImageArray
index|[
name|level
index|]
index|[
name|layer
index|]
expr_stmt|;
block|}
operator|delete
index|[]
name|mImageArray
index|[
name|level
index|]
expr_stmt|;
name|mImageArray
index|[
name|level
index|]
operator|=
name|NULL
expr_stmt|;
name|mLayerCounts
index|[
name|level
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
DECL|function|redefineImage
name|void
name|TextureD3D_2DArray
operator|::
name|redefineImage
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|depth
parameter_list|)
block|{
comment|// If there currently is a corresponding storage texture image, it has these parameters
specifier|const
name|int
name|storageWidth
init|=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|getBaseLevelWidth
argument_list|()
operator|>>
name|level
argument_list|)
decl_stmt|;
specifier|const
name|int
name|storageHeight
init|=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|getBaseLevelHeight
argument_list|()
operator|>>
name|level
argument_list|)
decl_stmt|;
specifier|const
name|int
name|storageDepth
init|=
name|getLayers
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|const
name|GLenum
name|storageFormat
init|=
name|getBaseLevelInternalFormat
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|layer
init|=
literal|0
init|;
name|layer
operator|<
name|mLayerCounts
index|[
name|level
index|]
condition|;
name|layer
operator|++
control|)
block|{
operator|delete
name|mImageArray
index|[
name|level
index|]
index|[
name|layer
index|]
expr_stmt|;
block|}
operator|delete
index|[]
name|mImageArray
index|[
name|level
index|]
expr_stmt|;
name|mImageArray
index|[
name|level
index|]
operator|=
name|NULL
expr_stmt|;
name|mLayerCounts
index|[
name|level
index|]
operator|=
name|depth
expr_stmt|;
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
block|{
name|mImageArray
index|[
name|level
index|]
operator|=
operator|new
name|ImageD3D
operator|*
index|[
name|depth
index|]
operator|(
operator|)
expr_stmt|;
for|for
control|(
name|int
name|layer
init|=
literal|0
init|;
name|layer
operator|<
name|mLayerCounts
index|[
name|level
index|]
condition|;
name|layer
operator|++
control|)
block|{
name|mImageArray
index|[
name|level
index|]
index|[
name|layer
index|]
operator|=
name|ImageD3D
operator|::
name|makeImageD3D
argument_list|(
name|mRenderer
operator|->
name|createImage
argument_list|()
argument_list|)
expr_stmt|;
name|mImageArray
index|[
name|level
index|]
index|[
name|layer
index|]
operator|->
name|redefine
argument_list|(
name|mRenderer
argument_list|,
name|GL_TEXTURE_2D_ARRAY
argument_list|,
name|internalformat
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|1
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mTexStorage
condition|)
block|{
specifier|const
name|int
name|storageLevels
init|=
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|level
operator|>=
name|storageLevels
operator|&&
name|storageLevels
operator|!=
literal|0
operator|)
operator|||
name|width
operator|!=
name|storageWidth
operator|||
name|height
operator|!=
name|storageHeight
operator|||
name|depth
operator|!=
name|storageDepth
operator|||
name|internalformat
operator|!=
name|storageFormat
condition|)
comment|// Discard mismatched storage
block|{
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|level
operator|++
control|)
block|{
for|for
control|(
name|int
name|layer
init|=
literal|0
init|;
name|layer
operator|<
name|mLayerCounts
index|[
name|level
index|]
condition|;
name|layer
operator|++
control|)
block|{
name|mImageArray
index|[
name|level
index|]
index|[
name|layer
index|]
operator|->
name|markDirty
argument_list|()
expr_stmt|;
block|}
block|}
operator|delete
name|mTexStorage
expr_stmt|;
name|mTexStorage
operator|=
name|NULL
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
DECL|function|commitRect
name|void
name|TextureD3D_2DArray
operator|::
name|commitRect
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLint
name|layerTarget
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
if|if
condition|(
name|isValidLevel
argument_list|(
name|level
argument_list|)
operator|&&
name|layerTarget
operator|<
name|getLayers
argument_list|(
name|level
argument_list|)
condition|)
block|{
name|ImageD3D
modifier|*
name|image
init|=
name|mImageArray
index|[
name|level
index|]
index|[
name|layerTarget
index|]
decl_stmt|;
if|if
condition|(
name|image
operator|->
name|copyToStorage
argument_list|(
name|mTexStorage
argument_list|,
name|level
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|layerTarget
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
condition|)
block|{
name|image
operator|->
name|markClean
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_namespace
end_unit
