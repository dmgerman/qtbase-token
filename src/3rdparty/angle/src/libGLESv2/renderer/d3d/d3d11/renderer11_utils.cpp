begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2012-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// renderer11_utils.cpp: Conversion functions and other utility routines
end_comment
begin_comment
comment|// specific to the D3D11 renderer.
end_comment
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/d3d11/renderer11_utils.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/d3d11/formatutils11.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/d3d11/RenderTarget11.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/Workarounds.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/ProgramBinary.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Framebuffer.h"
end_include
begin_include
include|#
directive|include
file|"common/debug.h"
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|D3D_FL9_1_DEFAULT_MAX_ANISOTROPY
end_ifndef
begin_define
DECL|macro|D3D_FL9_1_DEFAULT_MAX_ANISOTROPY
define|#
directive|define
name|D3D_FL9_1_DEFAULT_MAX_ANISOTROPY
value|2
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D_FL9_1_SIMULTANEOUS_RENDER_TARGET_COUNT
end_ifndef
begin_define
DECL|macro|D3D_FL9_1_SIMULTANEOUS_RENDER_TARGET_COUNT
define|#
directive|define
name|D3D_FL9_1_SIMULTANEOUS_RENDER_TARGET_COUNT
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D_FL9_3_SIMULTANEOUS_RENDER_TARGET_COUNT
end_ifndef
begin_define
DECL|macro|D3D_FL9_3_SIMULTANEOUS_RENDER_TARGET_COUNT
define|#
directive|define
name|D3D_FL9_3_SIMULTANEOUS_RENDER_TARGET_COUNT
value|4
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D_FL9_1_IA_PRIMITIVE_MAX_COUNT
end_ifndef
begin_define
DECL|macro|D3D_FL9_1_IA_PRIMITIVE_MAX_COUNT
define|#
directive|define
name|D3D_FL9_1_IA_PRIMITIVE_MAX_COUNT
value|65535
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D_FL9_2_IA_PRIMITIVE_MAX_COUNT
end_ifndef
begin_define
DECL|macro|D3D_FL9_2_IA_PRIMITIVE_MAX_COUNT
define|#
directive|define
name|D3D_FL9_2_IA_PRIMITIVE_MAX_COUNT
value|1048575
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D_FL9_1_REQ_TEXTURECUBE_DIMENSION
end_ifndef
begin_define
DECL|macro|D3D_FL9_1_REQ_TEXTURECUBE_DIMENSION
define|#
directive|define
name|D3D_FL9_1_REQ_TEXTURECUBE_DIMENSION
value|512
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D_FL9_3_REQ_TEXTURECUBE_DIMENSION
end_ifndef
begin_define
DECL|macro|D3D_FL9_3_REQ_TEXTURECUBE_DIMENSION
define|#
directive|define
name|D3D_FL9_3_REQ_TEXTURECUBE_DIMENSION
value|4096
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D_FL9_1_REQ_TEXTURE2D_U_OR_V_DIMENSION
end_ifndef
begin_define
DECL|macro|D3D_FL9_1_REQ_TEXTURE2D_U_OR_V_DIMENSION
define|#
directive|define
name|D3D_FL9_1_REQ_TEXTURE2D_U_OR_V_DIMENSION
value|2048
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D_FL9_1_REQ_TEXTURE3D_U_V_OR_W_DIMENSION
end_ifndef
begin_define
DECL|macro|D3D_FL9_1_REQ_TEXTURE3D_U_V_OR_W_DIMENSION
define|#
directive|define
name|D3D_FL9_1_REQ_TEXTURE3D_U_V_OR_W_DIMENSION
value|256
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D_FL9_3_REQ_TEXTURE2D_U_OR_V_DIMENSION
end_ifndef
begin_define
DECL|macro|D3D_FL9_3_REQ_TEXTURE2D_U_OR_V_DIMENSION
define|#
directive|define
name|D3D_FL9_3_REQ_TEXTURE2D_U_OR_V_DIMENSION
value|4096
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D11_REQ_TEXTURECUBE_DIMENSION
end_ifndef
begin_define
DECL|macro|D3D11_REQ_TEXTURECUBE_DIMENSION
define|#
directive|define
name|D3D11_REQ_TEXTURECUBE_DIMENSION
value|16384
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D11_REQ_TEXTURE2D_ARRAY_AXIS_DIMENSION
end_ifndef
begin_define
DECL|macro|D3D11_REQ_TEXTURE2D_ARRAY_AXIS_DIMENSION
define|#
directive|define
name|D3D11_REQ_TEXTURE2D_ARRAY_AXIS_DIMENSION
value|2048
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D11_REQ_TEXTURE3D_U_V_OR_W_DIMENSION
end_ifndef
begin_define
DECL|macro|D3D11_REQ_TEXTURE3D_U_V_OR_W_DIMENSION
define|#
directive|define
name|D3D11_REQ_TEXTURE3D_U_V_OR_W_DIMENSION
value|2048
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D11_REQ_DRAWINDEXED_INDEX_COUNT_2_TO_EXP
end_ifndef
begin_define
DECL|macro|D3D11_REQ_DRAWINDEXED_INDEX_COUNT_2_TO_EXP
define|#
directive|define
name|D3D11_REQ_DRAWINDEXED_INDEX_COUNT_2_TO_EXP
value|32
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D11_REQ_DRAW_VERTEX_COUNT_2_TO_EXP
end_ifndef
begin_define
DECL|macro|D3D11_REQ_DRAW_VERTEX_COUNT_2_TO_EXP
define|#
directive|define
name|D3D11_REQ_DRAW_VERTEX_COUNT_2_TO_EXP
value|32
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D10_1_STANDARD_VERTEX_ELEMENT_COUNT
end_ifndef
begin_define
DECL|macro|D3D10_1_STANDARD_VERTEX_ELEMENT_COUNT
define|#
directive|define
name|D3D10_1_STANDARD_VERTEX_ELEMENT_COUNT
value|32
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D11_STANDARD_VERTEX_ELEMENT_COUNT
end_ifndef
begin_define
DECL|macro|D3D11_STANDARD_VERTEX_ELEMENT_COUNT
define|#
directive|define
name|D3D11_STANDARD_VERTEX_ELEMENT_COUNT
value|32
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D10_1_SO_BUFFER_SLOT_COUNT
end_ifndef
begin_define
DECL|macro|D3D10_1_SO_BUFFER_SLOT_COUNT
define|#
directive|define
name|D3D10_1_SO_BUFFER_SLOT_COUNT
value|4
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D11_SO_BUFFER_SLOT_COUNT
end_ifndef
begin_define
DECL|macro|D3D11_SO_BUFFER_SLOT_COUNT
define|#
directive|define
name|D3D11_SO_BUFFER_SLOT_COUNT
value|4
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT
end_ifndef
begin_define
DECL|macro|D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT
define|#
directive|define
name|D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT
value|14
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT
end_ifndef
begin_define
DECL|macro|D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT
define|#
directive|define
name|D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT
value|16
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D11_COMMONSHADER_TEXEL_OFFSET_MAX_NEGATIVE
end_ifndef
begin_define
DECL|macro|D3D11_COMMONSHADER_TEXEL_OFFSET_MAX_NEGATIVE
define|#
directive|define
name|D3D11_COMMONSHADER_TEXEL_OFFSET_MAX_NEGATIVE
value|-8
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D11_COMMONSHADER_TEXEL_OFFSET_MAX_POSITIVE
end_ifndef
begin_define
DECL|macro|D3D11_COMMONSHADER_TEXEL_OFFSET_MAX_POSITIVE
define|#
directive|define
name|D3D11_COMMONSHADER_TEXEL_OFFSET_MAX_POSITIVE
value|7
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D11_REQ_CONSTANT_BUFFER_ELEMENT_COUNT
end_ifndef
begin_define
DECL|macro|D3D11_REQ_CONSTANT_BUFFER_ELEMENT_COUNT
define|#
directive|define
name|D3D11_REQ_CONSTANT_BUFFER_ELEMENT_COUNT
value|4096
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D11_PS_INPUT_REGISTER_COUNT
end_ifndef
begin_define
DECL|macro|D3D11_PS_INPUT_REGISTER_COUNT
define|#
directive|define
name|D3D11_PS_INPUT_REGISTER_COUNT
value|32
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D10_1_VS_OUTPUT_REGISTER_COUNT
end_ifndef
begin_define
DECL|macro|D3D10_1_VS_OUTPUT_REGISTER_COUNT
define|#
directive|define
name|D3D10_1_VS_OUTPUT_REGISTER_COUNT
value|32
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_namespace
DECL|namespace|rx
namespace|namespace
name|rx
block|{
DECL|namespace|gl_d3d11
namespace|namespace
name|gl_d3d11
block|{
DECL|function|ConvertBlendFunc
name|D3D11_BLEND
name|ConvertBlendFunc
parameter_list|(
name|GLenum
name|glBlend
parameter_list|,
name|bool
name|isAlpha
parameter_list|)
block|{
name|D3D11_BLEND
name|d3dBlend
init|=
name|D3D11_BLEND_ZERO
decl_stmt|;
switch|switch
condition|(
name|glBlend
condition|)
block|{
case|case
name|GL_ZERO
case|:
name|d3dBlend
operator|=
name|D3D11_BLEND_ZERO
expr_stmt|;
break|break;
case|case
name|GL_ONE
case|:
name|d3dBlend
operator|=
name|D3D11_BLEND_ONE
expr_stmt|;
break|break;
case|case
name|GL_SRC_COLOR
case|:
name|d3dBlend
operator|=
operator|(
name|isAlpha
condition|?
name|D3D11_BLEND_SRC_ALPHA
else|:
name|D3D11_BLEND_SRC_COLOR
operator|)
expr_stmt|;
break|break;
case|case
name|GL_ONE_MINUS_SRC_COLOR
case|:
name|d3dBlend
operator|=
operator|(
name|isAlpha
condition|?
name|D3D11_BLEND_INV_SRC_ALPHA
else|:
name|D3D11_BLEND_INV_SRC_COLOR
operator|)
expr_stmt|;
break|break;
case|case
name|GL_DST_COLOR
case|:
name|d3dBlend
operator|=
operator|(
name|isAlpha
condition|?
name|D3D11_BLEND_DEST_ALPHA
else|:
name|D3D11_BLEND_DEST_COLOR
operator|)
expr_stmt|;
break|break;
case|case
name|GL_ONE_MINUS_DST_COLOR
case|:
name|d3dBlend
operator|=
operator|(
name|isAlpha
condition|?
name|D3D11_BLEND_INV_DEST_ALPHA
else|:
name|D3D11_BLEND_INV_DEST_COLOR
operator|)
expr_stmt|;
break|break;
case|case
name|GL_SRC_ALPHA
case|:
name|d3dBlend
operator|=
name|D3D11_BLEND_SRC_ALPHA
expr_stmt|;
break|break;
case|case
name|GL_ONE_MINUS_SRC_ALPHA
case|:
name|d3dBlend
operator|=
name|D3D11_BLEND_INV_SRC_ALPHA
expr_stmt|;
break|break;
case|case
name|GL_DST_ALPHA
case|:
name|d3dBlend
operator|=
name|D3D11_BLEND_DEST_ALPHA
expr_stmt|;
break|break;
case|case
name|GL_ONE_MINUS_DST_ALPHA
case|:
name|d3dBlend
operator|=
name|D3D11_BLEND_INV_DEST_ALPHA
expr_stmt|;
break|break;
case|case
name|GL_CONSTANT_COLOR
case|:
name|d3dBlend
operator|=
name|D3D11_BLEND_BLEND_FACTOR
expr_stmt|;
break|break;
case|case
name|GL_ONE_MINUS_CONSTANT_COLOR
case|:
name|d3dBlend
operator|=
name|D3D11_BLEND_INV_BLEND_FACTOR
expr_stmt|;
break|break;
case|case
name|GL_CONSTANT_ALPHA
case|:
name|d3dBlend
operator|=
name|D3D11_BLEND_BLEND_FACTOR
expr_stmt|;
break|break;
case|case
name|GL_ONE_MINUS_CONSTANT_ALPHA
case|:
name|d3dBlend
operator|=
name|D3D11_BLEND_INV_BLEND_FACTOR
expr_stmt|;
break|break;
case|case
name|GL_SRC_ALPHA_SATURATE
case|:
name|d3dBlend
operator|=
name|D3D11_BLEND_SRC_ALPHA_SAT
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
name|d3dBlend
return|;
block|}
DECL|function|ConvertBlendOp
name|D3D11_BLEND_OP
name|ConvertBlendOp
parameter_list|(
name|GLenum
name|glBlendOp
parameter_list|)
block|{
name|D3D11_BLEND_OP
name|d3dBlendOp
init|=
name|D3D11_BLEND_OP_ADD
decl_stmt|;
switch|switch
condition|(
name|glBlendOp
condition|)
block|{
case|case
name|GL_FUNC_ADD
case|:
name|d3dBlendOp
operator|=
name|D3D11_BLEND_OP_ADD
expr_stmt|;
break|break;
case|case
name|GL_FUNC_SUBTRACT
case|:
name|d3dBlendOp
operator|=
name|D3D11_BLEND_OP_SUBTRACT
expr_stmt|;
break|break;
case|case
name|GL_FUNC_REVERSE_SUBTRACT
case|:
name|d3dBlendOp
operator|=
name|D3D11_BLEND_OP_REV_SUBTRACT
expr_stmt|;
break|break;
case|case
name|GL_MIN
case|:
name|d3dBlendOp
operator|=
name|D3D11_BLEND_OP_MIN
expr_stmt|;
break|break;
case|case
name|GL_MAX
case|:
name|d3dBlendOp
operator|=
name|D3D11_BLEND_OP_MAX
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
name|d3dBlendOp
return|;
block|}
DECL|function|ConvertColorMask
name|UINT8
name|ConvertColorMask
parameter_list|(
name|bool
name|red
parameter_list|,
name|bool
name|green
parameter_list|,
name|bool
name|blue
parameter_list|,
name|bool
name|alpha
parameter_list|)
block|{
name|UINT8
name|mask
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|red
condition|)
block|{
name|mask
operator||=
name|D3D11_COLOR_WRITE_ENABLE_RED
expr_stmt|;
block|}
if|if
condition|(
name|green
condition|)
block|{
name|mask
operator||=
name|D3D11_COLOR_WRITE_ENABLE_GREEN
expr_stmt|;
block|}
if|if
condition|(
name|blue
condition|)
block|{
name|mask
operator||=
name|D3D11_COLOR_WRITE_ENABLE_BLUE
expr_stmt|;
block|}
if|if
condition|(
name|alpha
condition|)
block|{
name|mask
operator||=
name|D3D11_COLOR_WRITE_ENABLE_ALPHA
expr_stmt|;
block|}
return|return
name|mask
return|;
block|}
DECL|function|ConvertCullMode
name|D3D11_CULL_MODE
name|ConvertCullMode
parameter_list|(
name|bool
name|cullEnabled
parameter_list|,
name|GLenum
name|cullMode
parameter_list|)
block|{
name|D3D11_CULL_MODE
name|cull
init|=
name|D3D11_CULL_NONE
decl_stmt|;
if|if
condition|(
name|cullEnabled
condition|)
block|{
switch|switch
condition|(
name|cullMode
condition|)
block|{
case|case
name|GL_FRONT
case|:
name|cull
operator|=
name|D3D11_CULL_FRONT
expr_stmt|;
break|break;
case|case
name|GL_BACK
case|:
name|cull
operator|=
name|D3D11_CULL_BACK
expr_stmt|;
break|break;
case|case
name|GL_FRONT_AND_BACK
case|:
name|cull
operator|=
name|D3D11_CULL_NONE
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|cull
operator|=
name|D3D11_CULL_NONE
expr_stmt|;
block|}
return|return
name|cull
return|;
block|}
DECL|function|ConvertComparison
name|D3D11_COMPARISON_FUNC
name|ConvertComparison
parameter_list|(
name|GLenum
name|comparison
parameter_list|)
block|{
name|D3D11_COMPARISON_FUNC
name|d3dComp
init|=
name|D3D11_COMPARISON_NEVER
decl_stmt|;
switch|switch
condition|(
name|comparison
condition|)
block|{
case|case
name|GL_NEVER
case|:
name|d3dComp
operator|=
name|D3D11_COMPARISON_NEVER
expr_stmt|;
break|break;
case|case
name|GL_ALWAYS
case|:
name|d3dComp
operator|=
name|D3D11_COMPARISON_ALWAYS
expr_stmt|;
break|break;
case|case
name|GL_LESS
case|:
name|d3dComp
operator|=
name|D3D11_COMPARISON_LESS
expr_stmt|;
break|break;
case|case
name|GL_LEQUAL
case|:
name|d3dComp
operator|=
name|D3D11_COMPARISON_LESS_EQUAL
expr_stmt|;
break|break;
case|case
name|GL_EQUAL
case|:
name|d3dComp
operator|=
name|D3D11_COMPARISON_EQUAL
expr_stmt|;
break|break;
case|case
name|GL_GREATER
case|:
name|d3dComp
operator|=
name|D3D11_COMPARISON_GREATER
expr_stmt|;
break|break;
case|case
name|GL_GEQUAL
case|:
name|d3dComp
operator|=
name|D3D11_COMPARISON_GREATER_EQUAL
expr_stmt|;
break|break;
case|case
name|GL_NOTEQUAL
case|:
name|d3dComp
operator|=
name|D3D11_COMPARISON_NOT_EQUAL
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
name|d3dComp
return|;
block|}
DECL|function|ConvertDepthMask
name|D3D11_DEPTH_WRITE_MASK
name|ConvertDepthMask
parameter_list|(
name|bool
name|depthWriteEnabled
parameter_list|)
block|{
return|return
name|depthWriteEnabled
condition|?
name|D3D11_DEPTH_WRITE_MASK_ALL
else|:
name|D3D11_DEPTH_WRITE_MASK_ZERO
return|;
block|}
DECL|function|ConvertStencilMask
name|UINT8
name|ConvertStencilMask
parameter_list|(
name|GLuint
name|stencilmask
parameter_list|)
block|{
return|return
cast|static_cast
argument_list|<
name|UINT8
argument_list|>
argument_list|(
name|stencilmask
argument_list|)
return|;
block|}
DECL|function|ConvertStencilOp
name|D3D11_STENCIL_OP
name|ConvertStencilOp
parameter_list|(
name|GLenum
name|stencilOp
parameter_list|)
block|{
name|D3D11_STENCIL_OP
name|d3dStencilOp
init|=
name|D3D11_STENCIL_OP_KEEP
decl_stmt|;
switch|switch
condition|(
name|stencilOp
condition|)
block|{
case|case
name|GL_ZERO
case|:
name|d3dStencilOp
operator|=
name|D3D11_STENCIL_OP_ZERO
expr_stmt|;
break|break;
case|case
name|GL_KEEP
case|:
name|d3dStencilOp
operator|=
name|D3D11_STENCIL_OP_KEEP
expr_stmt|;
break|break;
case|case
name|GL_REPLACE
case|:
name|d3dStencilOp
operator|=
name|D3D11_STENCIL_OP_REPLACE
expr_stmt|;
break|break;
case|case
name|GL_INCR
case|:
name|d3dStencilOp
operator|=
name|D3D11_STENCIL_OP_INCR_SAT
expr_stmt|;
break|break;
case|case
name|GL_DECR
case|:
name|d3dStencilOp
operator|=
name|D3D11_STENCIL_OP_DECR_SAT
expr_stmt|;
break|break;
case|case
name|GL_INVERT
case|:
name|d3dStencilOp
operator|=
name|D3D11_STENCIL_OP_INVERT
expr_stmt|;
break|break;
case|case
name|GL_INCR_WRAP
case|:
name|d3dStencilOp
operator|=
name|D3D11_STENCIL_OP_INCR
expr_stmt|;
break|break;
case|case
name|GL_DECR_WRAP
case|:
name|d3dStencilOp
operator|=
name|D3D11_STENCIL_OP_DECR
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
name|d3dStencilOp
return|;
block|}
DECL|function|ConvertFilter
name|D3D11_FILTER
name|ConvertFilter
parameter_list|(
name|GLenum
name|minFilter
parameter_list|,
name|GLenum
name|magFilter
parameter_list|,
name|float
name|maxAnisotropy
parameter_list|,
name|GLenum
name|comparisonMode
parameter_list|)
block|{
name|bool
name|comparison
init|=
name|comparisonMode
operator|!=
name|GL_NONE
decl_stmt|;
if|if
condition|(
name|maxAnisotropy
operator|>
literal|1.0f
condition|)
block|{
return|return
name|D3D11_ENCODE_ANISOTROPIC_FILTER
argument_list|(
cast|static_cast
argument_list|<
name|D3D11_COMPARISON_FUNC
argument_list|>
argument_list|(
name|comparison
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|D3D11_FILTER_TYPE
name|dxMin
init|=
name|D3D11_FILTER_TYPE_POINT
decl_stmt|;
name|D3D11_FILTER_TYPE
name|dxMip
init|=
name|D3D11_FILTER_TYPE_POINT
decl_stmt|;
switch|switch
condition|(
name|minFilter
condition|)
block|{
case|case
name|GL_NEAREST
case|:
name|dxMin
operator|=
name|D3D11_FILTER_TYPE_POINT
expr_stmt|;
name|dxMip
operator|=
name|D3D11_FILTER_TYPE_POINT
expr_stmt|;
break|break;
case|case
name|GL_LINEAR
case|:
name|dxMin
operator|=
name|D3D11_FILTER_TYPE_LINEAR
expr_stmt|;
name|dxMip
operator|=
name|D3D11_FILTER_TYPE_POINT
expr_stmt|;
break|break;
case|case
name|GL_NEAREST_MIPMAP_NEAREST
case|:
name|dxMin
operator|=
name|D3D11_FILTER_TYPE_POINT
expr_stmt|;
name|dxMip
operator|=
name|D3D11_FILTER_TYPE_POINT
expr_stmt|;
break|break;
case|case
name|GL_LINEAR_MIPMAP_NEAREST
case|:
name|dxMin
operator|=
name|D3D11_FILTER_TYPE_LINEAR
expr_stmt|;
name|dxMip
operator|=
name|D3D11_FILTER_TYPE_POINT
expr_stmt|;
break|break;
case|case
name|GL_NEAREST_MIPMAP_LINEAR
case|:
name|dxMin
operator|=
name|D3D11_FILTER_TYPE_POINT
expr_stmt|;
name|dxMip
operator|=
name|D3D11_FILTER_TYPE_LINEAR
expr_stmt|;
break|break;
case|case
name|GL_LINEAR_MIPMAP_LINEAR
case|:
name|dxMin
operator|=
name|D3D11_FILTER_TYPE_LINEAR
expr_stmt|;
name|dxMip
operator|=
name|D3D11_FILTER_TYPE_LINEAR
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
name|D3D11_FILTER_TYPE
name|dxMag
init|=
name|D3D11_FILTER_TYPE_POINT
decl_stmt|;
switch|switch
condition|(
name|magFilter
condition|)
block|{
case|case
name|GL_NEAREST
case|:
name|dxMag
operator|=
name|D3D11_FILTER_TYPE_POINT
expr_stmt|;
break|break;
case|case
name|GL_LINEAR
case|:
name|dxMag
operator|=
name|D3D11_FILTER_TYPE_LINEAR
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
name|D3D11_ENCODE_BASIC_FILTER
argument_list|(
name|dxMin
argument_list|,
name|dxMag
argument_list|,
name|dxMip
argument_list|,
cast|static_cast
argument_list|<
name|D3D11_COMPARISON_FUNC
argument_list|>
argument_list|(
name|comparison
argument_list|)
argument_list|)
return|;
block|}
block|}
DECL|function|ConvertTextureWrap
name|D3D11_TEXTURE_ADDRESS_MODE
name|ConvertTextureWrap
parameter_list|(
name|GLenum
name|wrap
parameter_list|)
block|{
switch|switch
condition|(
name|wrap
condition|)
block|{
case|case
name|GL_REPEAT
case|:
return|return
name|D3D11_TEXTURE_ADDRESS_WRAP
return|;
case|case
name|GL_CLAMP_TO_EDGE
case|:
return|return
name|D3D11_TEXTURE_ADDRESS_CLAMP
return|;
case|case
name|GL_MIRRORED_REPEAT
case|:
return|return
name|D3D11_TEXTURE_ADDRESS_MIRROR
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
name|D3D11_TEXTURE_ADDRESS_WRAP
return|;
block|}
DECL|function|ConvertQueryType
name|D3D11_QUERY
name|ConvertQueryType
parameter_list|(
name|GLenum
name|queryType
parameter_list|)
block|{
switch|switch
condition|(
name|queryType
condition|)
block|{
case|case
name|GL_ANY_SAMPLES_PASSED_EXT
case|:
case|case
name|GL_ANY_SAMPLES_PASSED_CONSERVATIVE_EXT
case|:
return|return
name|D3D11_QUERY_OCCLUSION
return|;
case|case
name|GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN
case|:
return|return
name|D3D11_QUERY_SO_STATISTICS
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|D3D11_QUERY_EVENT
return|;
block|}
block|}
block|}
DECL|namespace|d3d11_gl
namespace|namespace
name|d3d11_gl
block|{
DECL|function|GenerateTextureFormatCaps
specifier|static
name|gl
operator|::
name|TextureCaps
name|GenerateTextureFormatCaps
parameter_list|(
name|GLenum
name|internalFormat
parameter_list|,
name|ID3D11Device
modifier|*
name|device
parameter_list|)
block|{
name|gl
operator|::
name|TextureCaps
name|textureCaps
decl_stmt|;
specifier|const
name|d3d11
operator|::
name|TextureFormat
modifier|&
name|formatInfo
init|=
name|d3d11
operator|::
name|GetTextureFormatInfo
argument_list|(
name|internalFormat
argument_list|)
decl_stmt|;
name|UINT
name|formatSupport
decl_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|device
operator|->
name|CheckFormatSupport
argument_list|(
name|formatInfo
operator|.
name|texFormat
argument_list|,
operator|&
name|formatSupport
argument_list|)
argument_list|)
condition|)
block|{
specifier|const
name|gl
operator|::
name|InternalFormat
modifier|&
name|formatInfo
init|=
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|internalFormat
argument_list|)
decl_stmt|;
if|if
condition|(
name|formatInfo
operator|.
name|depthBits
operator|>
literal|0
operator|||
name|formatInfo
operator|.
name|stencilBits
operator|>
literal|0
condition|)
block|{
name|textureCaps
operator|.
name|texturable
operator|=
operator|(
operator|(
name|formatSupport
operator|&
name|D3D11_FORMAT_SUPPORT_TEXTURE2D
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|textureCaps
operator|.
name|texturable
operator|=
operator|(
operator|(
name|formatSupport
operator|&
name|D3D11_FORMAT_SUPPORT_TEXTURE2D
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|formatSupport
operator|&
name|D3D11_FORMAT_SUPPORT_TEXTURECUBE
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|formatSupport
operator|&
name|D3D11_FORMAT_SUPPORT_TEXTURE3D
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|device
operator|->
name|CheckFormatSupport
argument_list|(
name|formatInfo
operator|.
name|renderFormat
argument_list|,
operator|&
name|formatSupport
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|formatSupport
operator|&
name|D3D11_FORMAT_SUPPORT_MULTISAMPLE_RENDERTARGET
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
for|for
control|(
name|size_t
name|sampleCount
init|=
literal|1
init|;
name|sampleCount
operator|<=
name|D3D11_MAX_MULTISAMPLE_SAMPLE_COUNT
condition|;
name|sampleCount
operator|++
control|)
block|{
name|UINT
name|qualityCount
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|device
operator|->
name|CheckMultisampleQualityLevels
argument_list|(
name|formatInfo
operator|.
name|renderFormat
argument_list|,
name|sampleCount
argument_list|,
operator|&
name|qualityCount
argument_list|)
argument_list|)
operator|&&
name|qualityCount
operator|>
literal|0
condition|)
block|{
name|textureCaps
operator|.
name|sampleCounts
operator|.
name|insert
argument_list|(
name|sampleCount
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|textureCaps
operator|.
name|filterable
operator|=
name|SUCCEEDED
argument_list|(
name|device
operator|->
name|CheckFormatSupport
argument_list|(
name|formatInfo
operator|.
name|srvFormat
argument_list|,
operator|&
name|formatSupport
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|formatSupport
operator|&
name|D3D11_FORMAT_SUPPORT_SHADER_SAMPLE
operator|)
operator|)
operator|!=
literal|0
expr_stmt|;
name|textureCaps
operator|.
name|renderable
operator|=
operator|(
name|SUCCEEDED
argument_list|(
name|device
operator|->
name|CheckFormatSupport
argument_list|(
name|formatInfo
operator|.
name|rtvFormat
argument_list|,
operator|&
name|formatSupport
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|formatSupport
operator|&
name|D3D11_FORMAT_SUPPORT_RENDER_TARGET
operator|)
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|SUCCEEDED
argument_list|(
name|device
operator|->
name|CheckFormatSupport
argument_list|(
name|formatInfo
operator|.
name|dsvFormat
argument_list|,
operator|&
name|formatSupport
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|formatSupport
operator|&
name|D3D11_FORMAT_SUPPORT_DEPTH_STENCIL
operator|)
operator|!=
literal|0
operator|)
operator|)
expr_stmt|;
return|return
name|textureCaps
return|;
block|}
DECL|function|GetNPOTTextureSupport
specifier|static
name|bool
name|GetNPOTTextureSupport
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
operator|(
name|_MSC_VER
operator|>=
literal|1800
operator|)
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
endif|#
directive|endif
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
literal|true
return|;
comment|// From http://msdn.microsoft.com/en-us/library/windows/desktop/ff476876.aspx
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|true
return|;
comment|// Provided that mipmaps& wrap modes are not used
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|GetMaximumAnisotropy
specifier|static
name|float
name|GetMaximumAnisotropy
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
operator|(
name|_MSC_VER
operator|>=
literal|1800
operator|)
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
endif|#
directive|endif
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_MAX_MAXANISOTROPY
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_MAX_MAXANISOTROPY
return|;
comment|// From http://msdn.microsoft.com/en-us/library/windows/desktop/ff476876.aspx
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
return|return
literal|16
return|;
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
name|D3D_FL9_1_DEFAULT_MAX_ANISOTROPY
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetOcclusionQuerySupport
specifier|static
name|bool
name|GetOcclusionQuerySupport
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
operator|(
name|_MSC_VER
operator|>=
literal|1800
operator|)
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
endif|#
directive|endif
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
literal|true
return|;
comment|// From http://msdn.microsoft.com/en-us/library/windows/desktop/ff476150.aspx ID3D11Device::CreateQuery
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
return|return
literal|true
return|;
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|false
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|GetEventQuerySupport
specifier|static
name|bool
name|GetEventQuerySupport
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
comment|// From http://msdn.microsoft.com/en-us/library/windows/desktop/ff476150.aspx ID3D11Device::CreateQuery
switch|switch
condition|(
name|featureLevel
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
operator|(
name|_MSC_VER
operator|>=
literal|1800
operator|)
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
endif|#
directive|endif
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|true
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|GetInstancingSupport
specifier|static
name|bool
name|GetInstancingSupport
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
comment|// From http://msdn.microsoft.com/en-us/library/windows/desktop/ff476150.aspx ID3D11Device::CreateInputLayout
switch|switch
condition|(
name|featureLevel
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
operator|(
name|_MSC_VER
operator|>=
literal|1800
operator|)
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
endif|#
directive|endif
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
return|return
literal|true
return|;
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|false
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|GetDerivativeInstructionSupport
specifier|static
name|bool
name|GetDerivativeInstructionSupport
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
comment|// http://msdn.microsoft.com/en-us/library/windows/desktop/bb509588.aspx states that shader model
comment|// ps_2_x is required for the ddx (and other derivative functions).
comment|// http://msdn.microsoft.com/en-us/library/windows/desktop/ff476876.aspx states that feature level
comment|// 9.3 supports shader model ps_2_x.
switch|switch
condition|(
name|featureLevel
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
operator|(
name|_MSC_VER
operator|>=
literal|1800
operator|)
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
endif|#
directive|endif
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
return|return
literal|true
return|;
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|false
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|GetMaximumSimultaneousRenderTargets
specifier|static
name|size_t
name|GetMaximumSimultaneousRenderTargets
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
comment|// From http://msdn.microsoft.com/en-us/library/windows/desktop/ff476150.aspx ID3D11Device::CreateInputLayout
switch|switch
condition|(
name|featureLevel
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
operator|(
name|_MSC_VER
operator|>=
literal|1800
operator|)
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
endif|#
directive|endif
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_SIMULTANEOUS_RENDER_TARGET_COUNT
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_SIMULTANEOUS_RENDER_TARGET_COUNT
return|;
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
return|return
name|D3D_FL9_3_SIMULTANEOUS_RENDER_TARGET_COUNT
return|;
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
name|D3D_FL9_1_SIMULTANEOUS_RENDER_TARGET_COUNT
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMaximum2DTextureSize
specifier|static
name|size_t
name|GetMaximum2DTextureSize
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
operator|(
name|_MSC_VER
operator|>=
literal|1800
operator|)
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
endif|#
directive|endif
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_REQ_TEXTURE2D_U_OR_V_DIMENSION
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_REQ_TEXTURE2D_U_OR_V_DIMENSION
return|;
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
return|return
name|D3D_FL9_3_REQ_TEXTURE2D_U_OR_V_DIMENSION
return|;
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
name|D3D_FL9_1_REQ_TEXTURE2D_U_OR_V_DIMENSION
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMaximumCubeMapTextureSize
specifier|static
name|size_t
name|GetMaximumCubeMapTextureSize
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
operator|(
name|_MSC_VER
operator|>=
literal|1800
operator|)
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
endif|#
directive|endif
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_REQ_TEXTURECUBE_DIMENSION
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_REQ_TEXTURECUBE_DIMENSION
return|;
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
return|return
name|D3D_FL9_3_REQ_TEXTURECUBE_DIMENSION
return|;
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
name|D3D_FL9_1_REQ_TEXTURECUBE_DIMENSION
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMaximum2DTextureArraySize
specifier|static
name|size_t
name|GetMaximum2DTextureArraySize
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
operator|(
name|_MSC_VER
operator|>=
literal|1800
operator|)
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
endif|#
directive|endif
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_REQ_TEXTURE2D_ARRAY_AXIS_DIMENSION
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_REQ_TEXTURE2D_ARRAY_AXIS_DIMENSION
return|;
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|0
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMaximum3DTextureSize
specifier|static
name|size_t
name|GetMaximum3DTextureSize
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
operator|(
name|_MSC_VER
operator|>=
literal|1800
operator|)
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
endif|#
directive|endif
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_REQ_TEXTURE3D_U_V_OR_W_DIMENSION
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_REQ_TEXTURE3D_U_V_OR_W_DIMENSION
return|;
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
name|D3D_FL9_1_REQ_TEXTURE3D_U_V_OR_W_DIMENSION
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMaximumViewportSize
specifier|static
name|size_t
name|GetMaximumViewportSize
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
operator|(
name|_MSC_VER
operator|>=
literal|1800
operator|)
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
endif|#
directive|endif
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_VIEWPORT_BOUNDS_MAX
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_VIEWPORT_BOUNDS_MAX
return|;
comment|// No constants for D3D9 viewport size limits, use the maximum texture sizes
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
return|return
name|D3D_FL9_3_REQ_TEXTURE2D_U_OR_V_DIMENSION
return|;
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
name|D3D_FL9_1_REQ_TEXTURE2D_U_OR_V_DIMENSION
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMaximumDrawIndexedIndexCount
specifier|static
name|size_t
name|GetMaximumDrawIndexedIndexCount
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
comment|// D3D11 allows up to 2^32 elements, but we report max signed int for convenience since that's what's
comment|// returned from glGetInteger
name|META_ASSERT
argument_list|(
name|D3D11_REQ_DRAWINDEXED_INDEX_COUNT_2_TO_EXP
operator|==
literal|32
argument_list|)
expr_stmt|;
name|META_ASSERT
argument_list|(
name|D3D10_REQ_DRAWINDEXED_INDEX_COUNT_2_TO_EXP
operator|==
literal|32
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|featureLevel
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
operator|(
name|_MSC_VER
operator|>=
literal|1800
operator|)
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
endif|#
directive|endif
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|std
operator|::
name|numeric_limits
argument_list|<
name|GLint
argument_list|>
operator|::
name|max
argument_list|()
return|;
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
return|return
name|D3D_FL9_2_IA_PRIMITIVE_MAX_COUNT
return|;
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
name|D3D_FL9_1_IA_PRIMITIVE_MAX_COUNT
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMaximumDrawVertexCount
specifier|static
name|size_t
name|GetMaximumDrawVertexCount
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
comment|// D3D11 allows up to 2^32 elements, but we report max signed int for convenience since that's what's
comment|// returned from glGetInteger
name|META_ASSERT
argument_list|(
name|D3D11_REQ_DRAW_VERTEX_COUNT_2_TO_EXP
operator|==
literal|32
argument_list|)
expr_stmt|;
name|META_ASSERT
argument_list|(
name|D3D10_REQ_DRAW_VERTEX_COUNT_2_TO_EXP
operator|==
literal|32
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|featureLevel
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
operator|(
name|_MSC_VER
operator|>=
literal|1800
operator|)
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
endif|#
directive|endif
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|std
operator|::
name|numeric_limits
argument_list|<
name|GLint
argument_list|>
operator|::
name|max
argument_list|()
return|;
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
return|return
name|D3D_FL9_2_IA_PRIMITIVE_MAX_COUNT
return|;
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
name|D3D_FL9_1_IA_PRIMITIVE_MAX_COUNT
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMaximumVertexInputSlots
specifier|static
name|size_t
name|GetMaximumVertexInputSlots
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
operator|(
name|_MSC_VER
operator|>=
literal|1800
operator|)
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
endif|#
directive|endif
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_STANDARD_VERTEX_ELEMENT_COUNT
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
return|return
name|D3D10_1_STANDARD_VERTEX_ELEMENT_COUNT
return|;
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_STANDARD_VERTEX_ELEMENT_COUNT
return|;
comment|// From http://http://msdn.microsoft.com/en-us/library/windows/desktop/ff476876.aspx "Max Input Slots"
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|16
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMaximumVertexUniformVectors
specifier|static
name|size_t
name|GetMaximumVertexUniformVectors
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
comment|// TODO(geofflang): Remove hard-coded limit once the gl-uniform-arrays test can pass
switch|switch
condition|(
name|featureLevel
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
operator|(
name|_MSC_VER
operator|>=
literal|1800
operator|)
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
endif|#
directive|endif
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
literal|1024
return|;
comment|// D3D11_REQ_CONSTANT_BUFFER_ELEMENT_COUNT;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
literal|1024
return|;
comment|// D3D10_REQ_CONSTANT_BUFFER_ELEMENT_COUNT;
comment|// From http://msdn.microsoft.com/en-us/library/windows/desktop/ff476149.aspx ID3D11DeviceContext::VSSetConstantBuffers
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|255
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetReservedVertexUniformBuffers
specifier|static
name|size_t
name|GetReservedVertexUniformBuffers
parameter_list|()
block|{
comment|// Reserve one buffer for the application uniforms, and one for driver uniforms
return|return
literal|2
return|;
block|}
DECL|function|GetMaximumVertexUniformBlocks
specifier|static
name|size_t
name|GetMaximumVertexUniformBlocks
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
operator|(
name|_MSC_VER
operator|>=
literal|1800
operator|)
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
endif|#
directive|endif
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT
operator|-
name|GetReservedVertexUniformBuffers
argument_list|()
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT
operator|-
name|GetReservedVertexUniformBuffers
argument_list|()
return|;
comment|// Uniform blocks not supported in D3D9 feature levels
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|0
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetReservedVertexOutputVectors
specifier|static
name|size_t
name|GetReservedVertexOutputVectors
parameter_list|()
block|{
comment|// We potentially reserve varyings for gl_Position, dx_Position, gl_FragCoord and gl_PointSize
return|return
literal|4
return|;
block|}
DECL|function|GetMaximumVertexOutputVectors
specifier|static
name|size_t
name|GetMaximumVertexOutputVectors
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
name|META_ASSERT
argument_list|(
name|gl
operator|::
name|IMPLEMENTATION_MAX_VARYING_VECTORS
operator|==
name|D3D11_VS_OUTPUT_REGISTER_COUNT
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|featureLevel
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
operator|(
name|_MSC_VER
operator|>=
literal|1800
operator|)
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
endif|#
directive|endif
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_VS_OUTPUT_REGISTER_COUNT
operator|-
name|GetReservedVertexOutputVectors
argument_list|()
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
return|return
name|D3D10_1_VS_OUTPUT_REGISTER_COUNT
operator|-
name|GetReservedVertexOutputVectors
argument_list|()
return|;
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_VS_OUTPUT_REGISTER_COUNT
operator|-
name|GetReservedVertexOutputVectors
argument_list|()
return|;
comment|// Use D3D9 SM3 and SM2 limits
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
return|return
literal|10
operator|-
name|GetReservedVertexOutputVectors
argument_list|()
return|;
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|8
operator|-
name|GetReservedVertexOutputVectors
argument_list|()
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMaximumVertexTextureUnits
specifier|static
name|size_t
name|GetMaximumVertexTextureUnits
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
operator|(
name|_MSC_VER
operator|>=
literal|1800
operator|)
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
endif|#
directive|endif
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_COMMONSHADER_SAMPLER_SLOT_COUNT
return|;
comment|// Vertex textures not supported in D3D9 feature levels according to
comment|// http://msdn.microsoft.com/en-us/library/windows/desktop/ff476149.aspx
comment|// ID3D11DeviceContext::VSSetSamplers and ID3D11DeviceContext::VSSetShaderResources
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|0
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMaximumPixelUniformVectors
specifier|static
name|size_t
name|GetMaximumPixelUniformVectors
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
comment|// TODO(geofflang): Remove hard-coded limit once the gl-uniform-arrays test can pass
switch|switch
condition|(
name|featureLevel
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
operator|(
name|_MSC_VER
operator|>=
literal|1800
operator|)
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
endif|#
directive|endif
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
literal|1024
return|;
comment|// D3D11_REQ_CONSTANT_BUFFER_ELEMENT_COUNT;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
literal|1024
return|;
comment|// D3D10_REQ_CONSTANT_BUFFER_ELEMENT_COUNT;
comment|// From http://msdn.microsoft.com/en-us/library/windows/desktop/ff476149.aspx ID3D11DeviceContext::PSSetConstantBuffers
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|32
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetReservedPixelUniformBuffers
specifier|static
name|size_t
name|GetReservedPixelUniformBuffers
parameter_list|()
block|{
comment|// Reserve one buffer for the application uniforms, and one for driver uniforms
return|return
literal|2
return|;
block|}
DECL|function|GetMaximumPixelUniformBlocks
specifier|static
name|size_t
name|GetMaximumPixelUniformBlocks
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
operator|(
name|_MSC_VER
operator|>=
literal|1800
operator|)
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
endif|#
directive|endif
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT
operator|-
name|GetReservedPixelUniformBuffers
argument_list|()
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT
operator|-
name|GetReservedPixelUniformBuffers
argument_list|()
return|;
comment|// Uniform blocks not supported in D3D9 feature levels
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|0
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMaximumPixelInputVectors
specifier|static
name|size_t
name|GetMaximumPixelInputVectors
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
operator|(
name|_MSC_VER
operator|>=
literal|1800
operator|)
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
endif|#
directive|endif
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_PS_INPUT_REGISTER_COUNT
operator|-
name|GetReservedVertexOutputVectors
argument_list|()
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_PS_INPUT_REGISTER_COUNT
operator|-
name|GetReservedVertexOutputVectors
argument_list|()
return|;
comment|// Use D3D9 SM3 and SM2 limits
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
return|return
literal|10
operator|-
name|GetReservedVertexOutputVectors
argument_list|()
return|;
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|8
operator|-
name|GetReservedVertexOutputVectors
argument_list|()
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMaximumPixelTextureUnits
specifier|static
name|size_t
name|GetMaximumPixelTextureUnits
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
operator|(
name|_MSC_VER
operator|>=
literal|1800
operator|)
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
endif|#
directive|endif
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_COMMONSHADER_SAMPLER_SLOT_COUNT
return|;
comment|// http://msdn.microsoft.com/en-us/library/windows/desktop/ff476149.aspx ID3D11DeviceContext::PSSetShaderResources
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|16
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMinimumTexelOffset
specifier|static
name|int
name|GetMinimumTexelOffset
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
operator|(
name|_MSC_VER
operator|>=
literal|1800
operator|)
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
endif|#
directive|endif
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_COMMONSHADER_TEXEL_OFFSET_MAX_NEGATIVE
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_COMMONSHADER_TEXEL_OFFSET_MAX_NEGATIVE
return|;
comment|// Sampling functions with offsets are not available below shader model 4.0.
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|0
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMaximumTexelOffset
specifier|static
name|int
name|GetMaximumTexelOffset
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
operator|(
name|_MSC_VER
operator|>=
literal|1800
operator|)
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
endif|#
directive|endif
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_COMMONSHADER_TEXEL_OFFSET_MAX_POSITIVE
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D11_COMMONSHADER_TEXEL_OFFSET_MAX_POSITIVE
return|;
comment|// Sampling functions with offsets are not available below shader model 4.0.
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|0
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMaximumConstantBufferSize
specifier|static
name|size_t
name|GetMaximumConstantBufferSize
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
comment|// Returns a size_t despite the limit being a GLuint64 because size_t is the maximum size of
comment|// any buffer that could be allocated.
specifier|const
name|size_t
name|bytesPerComponent
init|=
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|float
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|featureLevel
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
operator|(
name|_MSC_VER
operator|>=
literal|1800
operator|)
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
endif|#
directive|endif
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_REQ_CONSTANT_BUFFER_ELEMENT_COUNT
operator|*
name|bytesPerComponent
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_REQ_CONSTANT_BUFFER_ELEMENT_COUNT
operator|*
name|bytesPerComponent
return|;
comment|// Limits from http://msdn.microsoft.com/en-us/library/windows/desktop/ff476501.aspx remarks section
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|4096
operator|*
name|bytesPerComponent
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMaximumStreamOutputBuffers
specifier|static
name|size_t
name|GetMaximumStreamOutputBuffers
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
operator|(
name|_MSC_VER
operator|>=
literal|1800
operator|)
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
endif|#
directive|endif
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_SO_BUFFER_SLOT_COUNT
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
return|return
name|D3D10_1_SO_BUFFER_SLOT_COUNT
return|;
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_SO_BUFFER_SLOT_COUNT
return|;
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|0
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMaximumStreamOutputInterleavedComponents
specifier|static
name|size_t
name|GetMaximumStreamOutputInterleavedComponents
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
operator|(
name|_MSC_VER
operator|>=
literal|1800
operator|)
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
endif|#
directive|endif
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|GetMaximumVertexOutputVectors
argument_list|(
name|featureLevel
argument_list|)
operator|*
literal|4
return|;
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|0
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMaximumStreamOutputSeparateComponents
specifier|static
name|size_t
name|GetMaximumStreamOutputSeparateComponents
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
operator|(
name|_MSC_VER
operator|>=
literal|1800
operator|)
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
endif|#
directive|endif
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|GetMaximumStreamOutputInterleavedComponents
argument_list|(
name|featureLevel
argument_list|)
operator|/
name|GetMaximumStreamOutputBuffers
argument_list|(
name|featureLevel
argument_list|)
return|;
comment|// D3D 10 and 10.1 only allow one output per output slot if an output slot other than zero is used.
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
literal|4
return|;
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|0
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GenerateCaps
name|void
name|GenerateCaps
parameter_list|(
name|ID3D11Device
modifier|*
name|device
parameter_list|,
name|gl
operator|::
name|Caps
modifier|*
name|caps
parameter_list|,
name|gl
operator|::
name|TextureCapsMap
modifier|*
name|textureCapsMap
parameter_list|,
name|gl
operator|::
name|Extensions
modifier|*
name|extensions
parameter_list|)
block|{
name|GLuint
name|maxSamples
init|=
literal|0
decl_stmt|;
specifier|const
name|gl
operator|::
name|FormatSet
modifier|&
name|allFormats
init|=
name|gl
operator|::
name|GetAllSizedInternalFormats
argument_list|()
decl_stmt|;
for|for
control|(
name|gl
operator|::
name|FormatSet
operator|::
name|const_iterator
name|internalFormat
init|=
name|allFormats
operator|.
name|begin
argument_list|()
init|;
name|internalFormat
operator|!=
name|allFormats
operator|.
name|end
argument_list|()
condition|;
operator|++
name|internalFormat
control|)
block|{
name|gl
operator|::
name|TextureCaps
name|textureCaps
init|=
name|GenerateTextureFormatCaps
argument_list|(
operator|*
name|internalFormat
argument_list|,
name|device
argument_list|)
decl_stmt|;
name|textureCapsMap
operator|->
name|insert
argument_list|(
operator|*
name|internalFormat
argument_list|,
name|textureCaps
argument_list|)
expr_stmt|;
name|maxSamples
operator|=
name|std
operator|::
name|max
argument_list|(
name|maxSamples
argument_list|,
name|textureCaps
operator|.
name|getMaxSamples
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
operator|*
name|internalFormat
argument_list|)
operator|.
name|compressed
condition|)
block|{
name|caps
operator|->
name|compressedTextureFormats
operator|.
name|push_back
argument_list|(
operator|*
name|internalFormat
argument_list|)
expr_stmt|;
block|}
block|}
name|D3D_FEATURE_LEVEL
name|featureLevel
init|=
name|device
operator|->
name|GetFeatureLevel
argument_list|()
decl_stmt|;
comment|// GL core feature limits
name|caps
operator|->
name|maxElementIndex
operator|=
expr|static_cast
operator|<
name|GLint64
operator|>
operator|(
name|std
operator|::
name|numeric_limits
argument_list|<
name|unsigned
name|int
argument_list|>
operator|::
name|max
argument_list|()
operator|)
expr_stmt|;
name|caps
operator|->
name|max3DTextureSize
operator|=
name|GetMaximum3DTextureSize
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
name|caps
operator|->
name|max2DTextureSize
operator|=
name|GetMaximum2DTextureSize
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
name|caps
operator|->
name|maxCubeMapTextureSize
operator|=
name|GetMaximumCubeMapTextureSize
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
name|caps
operator|->
name|maxArrayTextureLayers
operator|=
name|GetMaximum2DTextureArraySize
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
comment|// Unimplemented, set to minimum required
name|caps
operator|->
name|maxLODBias
operator|=
literal|2.0f
expr_stmt|;
comment|// No specific limits on render target size, maximum 2D texture size is equivalent
name|caps
operator|->
name|maxRenderbufferSize
operator|=
name|caps
operator|->
name|max2DTextureSize
expr_stmt|;
comment|// Maximum draw buffers and color attachments are the same, max color attachments could eventually be
comment|// increased to 16
name|caps
operator|->
name|maxDrawBuffers
operator|=
name|GetMaximumSimultaneousRenderTargets
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
name|caps
operator|->
name|maxColorAttachments
operator|=
name|GetMaximumSimultaneousRenderTargets
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
comment|// D3D11 has the same limit for viewport width and height
name|caps
operator|->
name|maxViewportWidth
operator|=
name|GetMaximumViewportSize
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
name|caps
operator|->
name|maxViewportHeight
operator|=
name|caps
operator|->
name|maxViewportWidth
expr_stmt|;
comment|// Choose a reasonable maximum, enforced in the shader.
name|caps
operator|->
name|minAliasedPointSize
operator|=
literal|1.0f
expr_stmt|;
name|caps
operator|->
name|maxAliasedPointSize
operator|=
literal|1024.0f
expr_stmt|;
comment|// Wide lines not supported
name|caps
operator|->
name|minAliasedLineWidth
operator|=
literal|1.0f
expr_stmt|;
name|caps
operator|->
name|maxAliasedLineWidth
operator|=
literal|1.0f
expr_stmt|;
comment|// Primitive count limits
name|caps
operator|->
name|maxElementsIndices
operator|=
name|GetMaximumDrawIndexedIndexCount
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
name|caps
operator|->
name|maxElementsVertices
operator|=
name|GetMaximumDrawVertexCount
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
comment|// Program and shader binary formats (no supported shader binary formats)
name|caps
operator|->
name|programBinaryFormats
operator|.
name|push_back
argument_list|(
name|GL_PROGRAM_BINARY_ANGLE
argument_list|)
expr_stmt|;
comment|// We do not wait for server fence objects internally, so report a max timeout of zero.
name|caps
operator|->
name|maxServerWaitTimeout
operator|=
literal|0
expr_stmt|;
comment|// Vertex shader limits
name|caps
operator|->
name|maxVertexAttributes
operator|=
name|GetMaximumVertexInputSlots
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
name|caps
operator|->
name|maxVertexUniformComponents
operator|=
name|GetMaximumVertexUniformVectors
argument_list|(
name|featureLevel
argument_list|)
operator|*
literal|4
expr_stmt|;
name|caps
operator|->
name|maxVertexUniformVectors
operator|=
name|GetMaximumVertexUniformVectors
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
name|caps
operator|->
name|maxVertexUniformBlocks
operator|=
name|GetMaximumVertexUniformBlocks
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
name|caps
operator|->
name|maxVertexOutputComponents
operator|=
name|GetMaximumVertexOutputVectors
argument_list|(
name|featureLevel
argument_list|)
operator|*
literal|4
expr_stmt|;
name|caps
operator|->
name|maxVertexTextureImageUnits
operator|=
name|GetMaximumVertexTextureUnits
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
comment|// Fragment shader limits
name|caps
operator|->
name|maxFragmentUniformComponents
operator|=
name|GetMaximumPixelUniformVectors
argument_list|(
name|featureLevel
argument_list|)
operator|*
literal|4
expr_stmt|;
name|caps
operator|->
name|maxFragmentUniformVectors
operator|=
name|GetMaximumPixelUniformVectors
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
name|caps
operator|->
name|maxFragmentUniformBlocks
operator|=
name|GetMaximumPixelUniformBlocks
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
name|caps
operator|->
name|maxFragmentInputComponents
operator|=
name|GetMaximumPixelInputVectors
argument_list|(
name|featureLevel
argument_list|)
operator|*
literal|4
expr_stmt|;
name|caps
operator|->
name|maxTextureImageUnits
operator|=
name|GetMaximumPixelTextureUnits
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
name|caps
operator|->
name|minProgramTexelOffset
operator|=
name|GetMinimumTexelOffset
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
name|caps
operator|->
name|maxProgramTexelOffset
operator|=
name|GetMaximumTexelOffset
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
comment|// Aggregate shader limits
name|caps
operator|->
name|maxUniformBufferBindings
operator|=
name|caps
operator|->
name|maxVertexUniformBlocks
operator|+
name|caps
operator|->
name|maxFragmentUniformBlocks
expr_stmt|;
name|caps
operator|->
name|maxUniformBlockSize
operator|=
name|GetMaximumConstantBufferSize
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
comment|// Setting a large alignment forces uniform buffers to bind with zero offset
name|caps
operator|->
name|uniformBufferOffsetAlignment
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|std
operator|::
name|numeric_limits
argument_list|<
name|GLint
argument_list|>
operator|::
name|max
argument_list|()
argument_list|)
expr_stmt|;
name|caps
operator|->
name|maxCombinedUniformBlocks
operator|=
name|caps
operator|->
name|maxVertexUniformBlocks
operator|+
name|caps
operator|->
name|maxFragmentUniformBlocks
expr_stmt|;
name|caps
operator|->
name|maxCombinedVertexUniformComponents
operator|=
operator|(
cast|static_cast
argument_list|<
name|GLint64
argument_list|>
argument_list|(
name|caps
operator|->
name|maxVertexUniformBlocks
argument_list|)
operator|*
cast|static_cast
argument_list|<
name|GLint64
argument_list|>
argument_list|(
name|caps
operator|->
name|maxUniformBlockSize
operator|/
literal|4
argument_list|)
operator|)
operator|+
cast|static_cast
argument_list|<
name|GLint64
argument_list|>
argument_list|(
name|caps
operator|->
name|maxVertexUniformComponents
argument_list|)
expr_stmt|;
name|caps
operator|->
name|maxCombinedFragmentUniformComponents
operator|=
operator|(
cast|static_cast
argument_list|<
name|GLint64
argument_list|>
argument_list|(
name|caps
operator|->
name|maxFragmentUniformBlocks
argument_list|)
operator|*
cast|static_cast
argument_list|<
name|GLint64
argument_list|>
argument_list|(
name|caps
operator|->
name|maxUniformBlockSize
operator|/
literal|4
argument_list|)
operator|)
operator|+
cast|static_cast
argument_list|<
name|GLint64
argument_list|>
argument_list|(
name|caps
operator|->
name|maxFragmentUniformComponents
argument_list|)
expr_stmt|;
name|caps
operator|->
name|maxVaryingComponents
operator|=
name|GetMaximumVertexOutputVectors
argument_list|(
name|featureLevel
argument_list|)
operator|*
literal|4
expr_stmt|;
name|caps
operator|->
name|maxVaryingVectors
operator|=
name|GetMaximumVertexOutputVectors
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
name|caps
operator|->
name|maxCombinedTextureImageUnits
operator|=
name|caps
operator|->
name|maxVertexTextureImageUnits
operator|+
name|caps
operator|->
name|maxTextureImageUnits
expr_stmt|;
comment|// Transform feedback limits
name|caps
operator|->
name|maxTransformFeedbackInterleavedComponents
operator|=
name|GetMaximumStreamOutputInterleavedComponents
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
name|caps
operator|->
name|maxTransformFeedbackSeparateAttributes
operator|=
name|GetMaximumStreamOutputBuffers
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
name|caps
operator|->
name|maxTransformFeedbackSeparateComponents
operator|=
name|GetMaximumStreamOutputSeparateComponents
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
comment|// GL extension support
name|extensions
operator|->
name|setTextureExtensionSupport
argument_list|(
operator|*
name|textureCapsMap
argument_list|)
expr_stmt|;
name|extensions
operator|->
name|elementIndexUint
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|packedDepthStencil
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|getProgramBinary
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|rgb8rgba8
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|readFormatBGRA
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|pixelBufferObject
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|mapBuffer
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|mapBufferRange
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|textureNPOT
operator|=
name|GetNPOTTextureSupport
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
name|extensions
operator|->
name|drawBuffers
operator|=
name|GetMaximumSimultaneousRenderTargets
argument_list|(
name|featureLevel
argument_list|)
operator|>
literal|1
expr_stmt|;
name|extensions
operator|->
name|textureStorage
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|textureFilterAnisotropic
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|maxTextureAnisotropy
operator|=
name|GetMaximumAnisotropy
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
name|extensions
operator|->
name|occlusionQueryBoolean
operator|=
name|GetOcclusionQuerySupport
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
name|extensions
operator|->
name|fence
operator|=
name|GetEventQuerySupport
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
name|extensions
operator|->
name|timerQuery
operator|=
literal|false
expr_stmt|;
comment|// Unimplemented
name|extensions
operator|->
name|robustness
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|blendMinMax
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|framebufferBlit
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|framebufferMultisample
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|maxSamples
operator|=
name|maxSamples
expr_stmt|;
name|extensions
operator|->
name|instancedArrays
operator|=
name|GetInstancingSupport
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
name|extensions
operator|->
name|packReverseRowOrder
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|standardDerivatives
operator|=
name|GetDerivativeInstructionSupport
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
name|extensions
operator|->
name|shaderTextureLOD
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|fragDepth
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|textureUsage
operator|=
literal|true
expr_stmt|;
comment|// This could be false since it has no effect in D3D11
name|extensions
operator|->
name|translatedShaderSource
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|namespace|d3d11
namespace|namespace
name|d3d11
block|{
DECL|function|MakeValidSize
name|void
name|MakeValidSize
parameter_list|(
name|bool
name|isImage
parameter_list|,
name|DXGI_FORMAT
name|format
parameter_list|,
name|GLsizei
modifier|*
name|requestWidth
parameter_list|,
name|GLsizei
modifier|*
name|requestHeight
parameter_list|,
name|int
modifier|*
name|levelOffset
parameter_list|)
block|{
specifier|const
name|DXGIFormat
modifier|&
name|dxgiFormatInfo
init|=
name|d3d11
operator|::
name|GetDXGIFormatInfo
argument_list|(
name|format
argument_list|)
decl_stmt|;
name|int
name|upsampleCount
init|=
literal|0
decl_stmt|;
comment|// Don't expand the size of full textures that are at least (blockWidth x blockHeight) already.
if|if
condition|(
name|isImage
operator|||
operator|*
name|requestWidth
operator|<
cast|static_cast
argument_list|<
name|GLsizei
argument_list|>
argument_list|(
name|dxgiFormatInfo
operator|.
name|blockWidth
argument_list|)
operator|||
operator|*
name|requestHeight
operator|<
cast|static_cast
argument_list|<
name|GLsizei
argument_list|>
argument_list|(
name|dxgiFormatInfo
operator|.
name|blockHeight
argument_list|)
condition|)
block|{
while|while
condition|(
operator|*
name|requestWidth
operator|%
name|dxgiFormatInfo
operator|.
name|blockWidth
operator|!=
literal|0
operator|||
operator|*
name|requestHeight
operator|%
name|dxgiFormatInfo
operator|.
name|blockHeight
operator|!=
literal|0
condition|)
block|{
operator|*
name|requestWidth
operator|<<=
literal|1
expr_stmt|;
operator|*
name|requestHeight
operator|<<=
literal|1
expr_stmt|;
name|upsampleCount
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|levelOffset
operator|=
name|upsampleCount
expr_stmt|;
block|}
DECL|function|GenerateInitialTextureData
name|void
name|GenerateInitialTextureData
parameter_list|(
name|GLint
name|internalFormat
parameter_list|,
name|GLuint
name|width
parameter_list|,
name|GLuint
name|height
parameter_list|,
name|GLuint
name|depth
parameter_list|,
name|GLuint
name|mipLevels
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|D3D11_SUBRESOURCE_DATA
argument_list|>
modifier|*
name|outSubresourceData
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|std
operator|::
name|vector
argument_list|<
name|BYTE
argument_list|>
argument_list|>
modifier|*
name|outData
parameter_list|)
block|{
specifier|const
name|d3d11
operator|::
name|TextureFormat
modifier|&
name|d3dFormatInfo
init|=
name|d3d11
operator|::
name|GetTextureFormatInfo
argument_list|(
name|internalFormat
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|d3dFormatInfo
operator|.
name|dataInitializerFunction
operator|!=
name|NULL
argument_list|)
expr_stmt|;
specifier|const
name|d3d11
operator|::
name|DXGIFormat
modifier|&
name|dxgiFormatInfo
init|=
name|d3d11
operator|::
name|GetDXGIFormatInfo
argument_list|(
name|d3dFormatInfo
operator|.
name|texFormat
argument_list|)
decl_stmt|;
name|outSubresourceData
operator|->
name|resize
argument_list|(
name|mipLevels
argument_list|)
expr_stmt|;
name|outData
operator|->
name|resize
argument_list|(
name|mipLevels
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mipLevels
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|mipWidth
init|=
name|std
operator|::
name|max
argument_list|(
name|width
operator|>>
name|i
argument_list|,
literal|1U
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|mipHeight
init|=
name|std
operator|::
name|max
argument_list|(
name|height
operator|>>
name|i
argument_list|,
literal|1U
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|mipDepth
init|=
name|std
operator|::
name|max
argument_list|(
name|depth
operator|>>
name|i
argument_list|,
literal|1U
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|rowWidth
init|=
name|dxgiFormatInfo
operator|.
name|pixelBytes
operator|*
name|mipWidth
decl_stmt|;
name|unsigned
name|int
name|imageSize
init|=
name|rowWidth
operator|*
name|height
decl_stmt|;
name|outData
operator|->
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|resize
argument_list|(
name|rowWidth
operator|*
name|mipHeight
operator|*
name|mipDepth
argument_list|)
expr_stmt|;
name|d3dFormatInfo
operator|.
name|dataInitializerFunction
argument_list|(
name|mipWidth
argument_list|,
name|mipHeight
argument_list|,
name|mipDepth
argument_list|,
name|outData
operator|->
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|data
argument_list|()
argument_list|,
name|rowWidth
argument_list|,
name|imageSize
argument_list|)
expr_stmt|;
name|outSubresourceData
operator|->
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|pSysMem
operator|=
name|outData
operator|->
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|data
argument_list|()
expr_stmt|;
name|outSubresourceData
operator|->
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|SysMemPitch
operator|=
name|rowWidth
expr_stmt|;
name|outSubresourceData
operator|->
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|SysMemSlicePitch
operator|=
name|imageSize
expr_stmt|;
block|}
block|}
DECL|function|SetPositionTexCoordVertex
name|void
name|SetPositionTexCoordVertex
parameter_list|(
name|PositionTexCoordVertex
modifier|*
name|vertex
parameter_list|,
name|float
name|x
parameter_list|,
name|float
name|y
parameter_list|,
name|float
name|u
parameter_list|,
name|float
name|v
parameter_list|)
block|{
name|vertex
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|vertex
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|vertex
operator|->
name|u
operator|=
name|u
expr_stmt|;
name|vertex
operator|->
name|v
operator|=
name|v
expr_stmt|;
block|}
DECL|function|SetPositionLayerTexCoord3DVertex
name|void
name|SetPositionLayerTexCoord3DVertex
parameter_list|(
name|PositionLayerTexCoord3DVertex
modifier|*
name|vertex
parameter_list|,
name|float
name|x
parameter_list|,
name|float
name|y
parameter_list|,
name|unsigned
name|int
name|layer
parameter_list|,
name|float
name|u
parameter_list|,
name|float
name|v
parameter_list|,
name|float
name|s
parameter_list|)
block|{
name|vertex
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|vertex
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|vertex
operator|->
name|l
operator|=
name|layer
expr_stmt|;
name|vertex
operator|->
name|u
operator|=
name|u
expr_stmt|;
name|vertex
operator|->
name|v
operator|=
name|v
expr_stmt|;
name|vertex
operator|->
name|s
operator|=
name|s
expr_stmt|;
block|}
DECL|function|SetDebugName
name|HRESULT
name|SetDebugName
parameter_list|(
name|ID3D11DeviceChild
modifier|*
name|resource
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_DEBUG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__MINGW32__
argument_list|)
return|return
name|resource
operator|->
name|SetPrivateData
argument_list|(
name|WKPDID_D3DDebugObjectName
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
else|#
directive|else
return|return
name|S_OK
return|;
endif|#
directive|endif
block|}
DECL|function|GetAttachmentRenderTarget
name|gl
operator|::
name|Error
name|GetAttachmentRenderTarget
parameter_list|(
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|attachment
parameter_list|,
name|RenderTarget11
modifier|*
modifier|*
name|outRT
parameter_list|)
block|{
name|RenderTarget
modifier|*
name|renderTarget
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|rx
operator|::
name|GetAttachmentRenderTarget
argument_list|(
name|attachment
argument_list|,
operator|&
name|renderTarget
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
operator|*
name|outRT
operator|=
name|RenderTarget11
operator|::
name|makeRenderTarget11
argument_list|(
name|renderTarget
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|GenerateWorkarounds
name|Workarounds
name|GenerateWorkarounds
parameter_list|()
block|{
name|Workarounds
name|workarounds
decl_stmt|;
name|workarounds
operator|.
name|mrtPerfWorkaround
operator|=
literal|true
expr_stmt|;
name|workarounds
operator|.
name|setDataFasterThanImageUpload
operator|=
literal|true
expr_stmt|;
return|return
name|workarounds
return|;
block|}
block|}
block|}
end_namespace
end_unit
