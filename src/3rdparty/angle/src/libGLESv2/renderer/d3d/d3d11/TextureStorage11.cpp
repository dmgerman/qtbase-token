begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2012-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// TextureStorage11.cpp: Implements the abstract rx::TextureStorage11 class and its concrete derived
end_comment
begin_comment
comment|// classes TextureStorage11_2D and TextureStorage11_Cube, which act as the interface to the D3D11 texture.
end_comment
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/d3d11/TextureStorage11.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/d3d11/Renderer11.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/d3d11/RenderTarget11.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/d3d11/SwapChain11.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/d3d11/renderer11_utils.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/d3d11/Blit11.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/d3d11/formatutils11.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/d3d11/Image11.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/TextureD3D.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/main.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/ImageIndex.h"
end_include
begin_include
include|#
directive|include
file|"common/utilities.h"
end_include
begin_namespace
DECL|namespace|rx
namespace|namespace
name|rx
block|{
DECL|function|SwizzleCacheValue
name|TextureStorage11
operator|::
name|SwizzleCacheValue
operator|::
name|SwizzleCacheValue
parameter_list|()
member_init_list|:
name|swizzleRed
argument_list|(
name|GL_NONE
argument_list|)
member_init_list|,
name|swizzleGreen
argument_list|(
name|GL_NONE
argument_list|)
member_init_list|,
name|swizzleBlue
argument_list|(
name|GL_NONE
argument_list|)
member_init_list|,
name|swizzleAlpha
argument_list|(
name|GL_NONE
argument_list|)
block|{ }
DECL|function|SwizzleCacheValue
name|TextureStorage11
operator|::
name|SwizzleCacheValue
operator|::
name|SwizzleCacheValue
parameter_list|(
name|GLenum
name|red
parameter_list|,
name|GLenum
name|green
parameter_list|,
name|GLenum
name|blue
parameter_list|,
name|GLenum
name|alpha
parameter_list|)
member_init_list|:
name|swizzleRed
argument_list|(
name|red
argument_list|)
member_init_list|,
name|swizzleGreen
argument_list|(
name|green
argument_list|)
member_init_list|,
name|swizzleBlue
argument_list|(
name|blue
argument_list|)
member_init_list|,
name|swizzleAlpha
argument_list|(
name|alpha
argument_list|)
block|{ }
DECL|function|operator ==
name|bool
name|TextureStorage11
operator|::
name|SwizzleCacheValue
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|SwizzleCacheValue
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
name|swizzleRed
operator|==
name|other
operator|.
name|swizzleRed
operator|&&
name|swizzleGreen
operator|==
name|other
operator|.
name|swizzleGreen
operator|&&
name|swizzleBlue
operator|==
name|other
operator|.
name|swizzleBlue
operator|&&
name|swizzleAlpha
operator|==
name|other
operator|.
name|swizzleAlpha
return|;
block|}
DECL|function|operator !=
name|bool
name|TextureStorage11
operator|::
name|SwizzleCacheValue
operator|::
name|operator
name|!=
parameter_list|(
specifier|const
name|SwizzleCacheValue
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|other
operator|)
return|;
block|}
DECL|function|SRVKey
name|TextureStorage11
operator|::
name|SRVKey
operator|::
name|SRVKey
parameter_list|(
name|int
name|baseLevel
parameter_list|,
name|int
name|mipLevels
parameter_list|,
name|bool
name|swizzle
parameter_list|)
member_init_list|:
name|baseLevel
argument_list|(
name|baseLevel
argument_list|)
member_init_list|,
name|mipLevels
argument_list|(
name|mipLevels
argument_list|)
member_init_list|,
name|swizzle
argument_list|(
name|swizzle
argument_list|)
block|{ }
DECL|function|operator ==
name|bool
name|TextureStorage11
operator|::
name|SRVKey
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|SRVKey
modifier|&
name|rhs
parameter_list|)
specifier|const
block|{
return|return
name|baseLevel
operator|==
name|rhs
operator|.
name|baseLevel
operator|&&
name|mipLevels
operator|==
name|rhs
operator|.
name|mipLevels
operator|&&
name|swizzle
operator|==
name|rhs
operator|.
name|swizzle
return|;
block|}
DECL|function|~SRVCache
name|TextureStorage11
operator|::
name|SRVCache
operator|::
name|~
name|SRVCache
parameter_list|()
block|{
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cache
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|SafeRelease
argument_list|(
name|cache
index|[
name|i
index|]
operator|.
name|srv
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|find
name|ID3D11ShaderResourceView
modifier|*
name|TextureStorage11
operator|::
name|SRVCache
operator|::
name|find
parameter_list|(
specifier|const
name|SRVKey
modifier|&
name|key
parameter_list|)
specifier|const
block|{
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cache
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cache
index|[
name|i
index|]
operator|.
name|key
operator|==
name|key
condition|)
block|{
return|return
name|cache
index|[
name|i
index|]
operator|.
name|srv
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
DECL|function|add
name|ID3D11ShaderResourceView
modifier|*
name|TextureStorage11
operator|::
name|SRVCache
operator|::
name|add
parameter_list|(
specifier|const
name|SRVKey
modifier|&
name|key
parameter_list|,
name|ID3D11ShaderResourceView
modifier|*
name|srv
parameter_list|)
block|{
name|SRVPair
name|pair
init|=
block|{
name|key
block|,
name|srv
block|}
decl_stmt|;
name|cache
operator|.
name|push_back
argument_list|(
name|pair
argument_list|)
expr_stmt|;
return|return
name|srv
return|;
block|}
DECL|function|TextureStorage11
name|TextureStorage11
operator|::
name|TextureStorage11
parameter_list|(
name|Renderer
modifier|*
name|renderer
parameter_list|,
name|UINT
name|bindFlags
parameter_list|)
member_init_list|:
name|mBindFlags
argument_list|(
name|bindFlags
argument_list|)
member_init_list|,
name|mTopLevel
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mMipLevels
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mTextureFormat
argument_list|(
name|DXGI_FORMAT_UNKNOWN
argument_list|)
member_init_list|,
name|mShaderResourceFormat
argument_list|(
name|DXGI_FORMAT_UNKNOWN
argument_list|)
member_init_list|,
name|mRenderTargetFormat
argument_list|(
name|DXGI_FORMAT_UNKNOWN
argument_list|)
member_init_list|,
name|mDepthStencilFormat
argument_list|(
name|DXGI_FORMAT_UNKNOWN
argument_list|)
member_init_list|,
name|mTextureWidth
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mTextureHeight
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mTextureDepth
argument_list|(
literal|0
argument_list|)
block|{
name|mRenderer
operator|=
name|Renderer11
operator|::
name|makeRenderer11
argument_list|(
name|renderer
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|i
operator|++
control|)
block|{
name|mLevelSRVs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
DECL|function|~TextureStorage11
name|TextureStorage11
operator|::
name|~
name|TextureStorage11
parameter_list|()
block|{
for|for
control|(
name|unsigned
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|level
operator|++
control|)
block|{
name|SafeRelease
argument_list|(
name|mLevelSRVs
index|[
name|level
index|]
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|makeTextureStorage11
name|TextureStorage11
modifier|*
name|TextureStorage11
operator|::
name|makeTextureStorage11
parameter_list|(
name|TextureStorage
modifier|*
name|storage
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|HAS_DYNAMIC_TYPE
argument_list|(
name|TextureStorage11
operator|*
argument_list|,
name|storage
argument_list|)
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|TextureStorage11
operator|*
argument_list|>
argument_list|(
name|storage
argument_list|)
return|;
block|}
DECL|function|GetTextureBindFlags
name|DWORD
name|TextureStorage11
operator|::
name|GetTextureBindFlags
parameter_list|(
name|GLenum
name|internalFormat
parameter_list|,
name|bool
name|renderTarget
parameter_list|)
block|{
name|UINT
name|bindFlags
init|=
literal|0
decl_stmt|;
specifier|const
name|d3d11
operator|::
name|TextureFormat
modifier|&
name|formatInfo
init|=
name|d3d11
operator|::
name|GetTextureFormatInfo
argument_list|(
name|internalFormat
argument_list|)
decl_stmt|;
if|if
condition|(
name|formatInfo
operator|.
name|srvFormat
operator|!=
name|DXGI_FORMAT_UNKNOWN
condition|)
block|{
name|bindFlags
operator||=
name|D3D11_BIND_SHADER_RESOURCE
expr_stmt|;
block|}
if|if
condition|(
name|formatInfo
operator|.
name|dsvFormat
operator|!=
name|DXGI_FORMAT_UNKNOWN
condition|)
block|{
name|bindFlags
operator||=
name|D3D11_BIND_DEPTH_STENCIL
expr_stmt|;
block|}
if|if
condition|(
name|formatInfo
operator|.
name|rtvFormat
operator|!=
name|DXGI_FORMAT_UNKNOWN
operator|&&
name|renderTarget
condition|)
block|{
name|bindFlags
operator||=
name|D3D11_BIND_RENDER_TARGET
expr_stmt|;
block|}
return|return
name|bindFlags
return|;
block|}
DECL|function|getBindFlags
name|UINT
name|TextureStorage11
operator|::
name|getBindFlags
parameter_list|()
specifier|const
block|{
return|return
name|mBindFlags
return|;
block|}
DECL|function|getTopLevel
name|int
name|TextureStorage11
operator|::
name|getTopLevel
parameter_list|()
specifier|const
block|{
return|return
name|mTopLevel
return|;
block|}
DECL|function|isRenderTarget
name|bool
name|TextureStorage11
operator|::
name|isRenderTarget
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|mBindFlags
operator|&
operator|(
name|D3D11_BIND_RENDER_TARGET
operator||
name|D3D11_BIND_DEPTH_STENCIL
operator|)
operator|)
operator|!=
literal|0
return|;
block|}
DECL|function|isManaged
name|bool
name|TextureStorage11
operator|::
name|isManaged
parameter_list|()
specifier|const
block|{
return|return
literal|false
return|;
block|}
DECL|function|getLevelCount
name|int
name|TextureStorage11
operator|::
name|getLevelCount
parameter_list|()
specifier|const
block|{
return|return
name|mMipLevels
operator|-
name|mTopLevel
return|;
block|}
DECL|function|getLevelWidth
name|int
name|TextureStorage11
operator|::
name|getLevelWidth
parameter_list|(
name|int
name|mipLevel
parameter_list|)
specifier|const
block|{
return|return
name|std
operator|::
name|max
argument_list|(
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|mTextureWidth
argument_list|)
operator|>>
name|mipLevel
argument_list|,
literal|1
argument_list|)
return|;
block|}
DECL|function|getLevelHeight
name|int
name|TextureStorage11
operator|::
name|getLevelHeight
parameter_list|(
name|int
name|mipLevel
parameter_list|)
specifier|const
block|{
return|return
name|std
operator|::
name|max
argument_list|(
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|mTextureHeight
argument_list|)
operator|>>
name|mipLevel
argument_list|,
literal|1
argument_list|)
return|;
block|}
DECL|function|getLevelDepth
name|int
name|TextureStorage11
operator|::
name|getLevelDepth
parameter_list|(
name|int
name|mipLevel
parameter_list|)
specifier|const
block|{
return|return
name|std
operator|::
name|max
argument_list|(
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|mTextureDepth
argument_list|)
operator|>>
name|mipLevel
argument_list|,
literal|1
argument_list|)
return|;
block|}
DECL|function|getSubresourceIndex
name|UINT
name|TextureStorage11
operator|::
name|getSubresourceIndex
parameter_list|(
name|int
name|mipLevel
parameter_list|,
name|int
name|layerTarget
parameter_list|)
specifier|const
block|{
name|UINT
name|index
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|getResource
argument_list|()
condition|)
block|{
name|index
operator|=
name|D3D11CalcSubresource
argument_list|(
name|mipLevel
argument_list|,
name|layerTarget
argument_list|,
name|mMipLevels
argument_list|)
expr_stmt|;
block|}
return|return
name|index
return|;
block|}
DECL|function|getSRV
name|ID3D11ShaderResourceView
modifier|*
name|TextureStorage11
operator|::
name|getSRV
parameter_list|(
specifier|const
name|gl
operator|::
name|SamplerState
modifier|&
name|samplerState
parameter_list|)
block|{
name|bool
name|swizzleRequired
init|=
name|samplerState
operator|.
name|swizzleRequired
argument_list|()
decl_stmt|;
name|bool
name|mipmapping
init|=
name|gl
operator|::
name|IsMipmapFiltered
argument_list|(
name|samplerState
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|mipLevels
init|=
name|mipmapping
condition|?
operator|(
name|samplerState
operator|.
name|maxLevel
operator|-
name|samplerState
operator|.
name|baseLevel
operator|)
else|:
literal|1
decl_stmt|;
comment|// Make sure there's 'mipLevels' mipmap levels below the base level (offset by the top level,  which corresponds to GL level 0)
name|mipLevels
operator|=
name|std
operator|::
name|min
argument_list|(
name|mipLevels
argument_list|,
name|mMipLevels
operator|-
name|mTopLevel
operator|-
name|samplerState
operator|.
name|baseLevel
argument_list|)
expr_stmt|;
if|if
condition|(
name|swizzleRequired
condition|)
block|{
name|verifySwizzleExists
argument_list|(
name|samplerState
operator|.
name|swizzleRed
argument_list|,
name|samplerState
operator|.
name|swizzleGreen
argument_list|,
name|samplerState
operator|.
name|swizzleBlue
argument_list|,
name|samplerState
operator|.
name|swizzleAlpha
argument_list|)
expr_stmt|;
block|}
name|SRVKey
name|key
argument_list|(
name|samplerState
operator|.
name|baseLevel
argument_list|,
name|mipLevels
argument_list|,
name|swizzleRequired
argument_list|)
decl_stmt|;
name|ID3D11ShaderResourceView
modifier|*
name|srv
init|=
name|srvCache
operator|.
name|find
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|srv
condition|)
block|{
return|return
name|srv
return|;
block|}
name|DXGI_FORMAT
name|format
init|=
operator|(
name|swizzleRequired
condition|?
name|mSwizzleShaderResourceFormat
else|:
name|mShaderResourceFormat
operator|)
decl_stmt|;
name|ID3D11Resource
modifier|*
name|texture
init|=
name|swizzleRequired
condition|?
name|getSwizzleTexture
argument_list|()
else|:
name|getResource
argument_list|()
decl_stmt|;
name|srv
operator|=
name|createSRV
argument_list|(
name|samplerState
operator|.
name|baseLevel
argument_list|,
name|mipLevels
argument_list|,
name|format
argument_list|,
name|texture
argument_list|)
expr_stmt|;
return|return
name|srvCache
operator|.
name|add
argument_list|(
name|key
argument_list|,
name|srv
argument_list|)
return|;
block|}
DECL|function|getSRVLevel
name|ID3D11ShaderResourceView
modifier|*
name|TextureStorage11
operator|::
name|getSRVLevel
parameter_list|(
name|int
name|mipLevel
parameter_list|)
block|{
if|if
condition|(
name|mipLevel
operator|>=
literal|0
operator|&&
name|mipLevel
operator|<
name|getLevelCount
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|mLevelSRVs
index|[
name|mipLevel
index|]
condition|)
block|{
name|mLevelSRVs
index|[
name|mipLevel
index|]
operator|=
name|createSRV
argument_list|(
name|mipLevel
argument_list|,
literal|1
argument_list|,
name|mShaderResourceFormat
argument_list|,
name|getResource
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|mLevelSRVs
index|[
name|mipLevel
index|]
return|;
block|}
else|else
block|{
return|return
name|NULL
return|;
block|}
block|}
DECL|function|generateSwizzles
name|gl
operator|::
name|Error
name|TextureStorage11
operator|::
name|generateSwizzles
parameter_list|(
name|GLenum
name|swizzleRed
parameter_list|,
name|GLenum
name|swizzleGreen
parameter_list|,
name|GLenum
name|swizzleBlue
parameter_list|,
name|GLenum
name|swizzleAlpha
parameter_list|)
block|{
name|SwizzleCacheValue
name|swizzleTarget
argument_list|(
name|swizzleRed
argument_list|,
name|swizzleGreen
argument_list|,
name|swizzleBlue
argument_list|,
name|swizzleAlpha
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|getLevelCount
argument_list|()
condition|;
name|level
operator|++
control|)
block|{
comment|// Check if the swizzle for this level is out of date
if|if
condition|(
name|mSwizzleCache
index|[
name|level
index|]
operator|!=
name|swizzleTarget
condition|)
block|{
comment|// Need to re-render the swizzle for this level
name|ID3D11ShaderResourceView
modifier|*
name|sourceSRV
init|=
name|getSRVLevel
argument_list|(
name|level
argument_list|)
decl_stmt|;
name|ID3D11RenderTargetView
modifier|*
name|destRTV
init|=
name|getSwizzleRenderTarget
argument_list|(
name|level
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Extents
name|size
argument_list|(
name|getLevelWidth
argument_list|(
name|level
argument_list|)
argument_list|,
name|getLevelHeight
argument_list|(
name|level
argument_list|)
argument_list|,
name|getLevelDepth
argument_list|(
name|level
argument_list|)
argument_list|)
decl_stmt|;
name|Blit11
modifier|*
name|blitter
init|=
name|mRenderer
operator|->
name|getBlitter
argument_list|()
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|blitter
operator|->
name|swizzleTexture
argument_list|(
name|sourceSRV
argument_list|,
name|destRTV
argument_list|,
name|size
argument_list|,
name|swizzleRed
argument_list|,
name|swizzleGreen
argument_list|,
name|swizzleBlue
argument_list|,
name|swizzleAlpha
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|mSwizzleCache
index|[
name|level
index|]
operator|=
name|swizzleTarget
expr_stmt|;
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|invalidateSwizzleCacheLevel
name|void
name|TextureStorage11
operator|::
name|invalidateSwizzleCacheLevel
parameter_list|(
name|int
name|mipLevel
parameter_list|)
block|{
if|if
condition|(
name|mipLevel
operator|>=
literal|0
operator|&&
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|mipLevel
argument_list|)
operator|<
name|ArraySize
argument_list|(
name|mSwizzleCache
argument_list|)
condition|)
block|{
comment|// The default constructor of SwizzleCacheValue has GL_NONE for all channels which is not a
comment|// valid swizzle combination
name|mSwizzleCache
index|[
name|mipLevel
index|]
operator|=
name|SwizzleCacheValue
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|invalidateSwizzleCache
name|void
name|TextureStorage11
operator|::
name|invalidateSwizzleCache
parameter_list|()
block|{
for|for
control|(
name|unsigned
name|int
name|mipLevel
init|=
literal|0
init|;
name|mipLevel
operator|<
name|ArraySize
argument_list|(
name|mSwizzleCache
argument_list|)
condition|;
name|mipLevel
operator|++
control|)
block|{
name|invalidateSwizzleCacheLevel
argument_list|(
name|mipLevel
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|updateSubresourceLevel
name|bool
name|TextureStorage11
operator|::
name|updateSubresourceLevel
parameter_list|(
name|ID3D11Resource
modifier|*
name|srcTexture
parameter_list|,
name|unsigned
name|int
name|sourceSubresource
parameter_list|,
name|int
name|level
parameter_list|,
name|int
name|layerTarget
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLint
name|zoffset
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|depth
parameter_list|)
block|{
if|if
condition|(
name|srcTexture
condition|)
block|{
name|invalidateSwizzleCacheLevel
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|gl
operator|::
name|Extents
name|texSize
argument_list|(
name|getLevelWidth
argument_list|(
name|level
argument_list|)
argument_list|,
name|getLevelHeight
argument_list|(
name|level
argument_list|)
argument_list|,
name|getLevelDepth
argument_list|(
name|level
argument_list|)
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Box
name|copyArea
argument_list|(
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|zoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|)
decl_stmt|;
name|bool
name|fullCopy
init|=
name|copyArea
operator|.
name|x
operator|==
literal|0
operator|&&
name|copyArea
operator|.
name|y
operator|==
literal|0
operator|&&
name|copyArea
operator|.
name|z
operator|==
literal|0
operator|&&
name|copyArea
operator|.
name|width
operator|==
name|texSize
operator|.
name|width
operator|&&
name|copyArea
operator|.
name|height
operator|==
name|texSize
operator|.
name|height
operator|&&
name|copyArea
operator|.
name|depth
operator|==
name|texSize
operator|.
name|depth
decl_stmt|;
name|ID3D11Resource
modifier|*
name|dstTexture
init|=
name|getResource
argument_list|()
decl_stmt|;
name|unsigned
name|int
name|dstSubresource
init|=
name|getSubresourceIndex
argument_list|(
name|level
operator|+
name|mTopLevel
argument_list|,
name|layerTarget
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|dstTexture
argument_list|)
expr_stmt|;
specifier|const
name|d3d11
operator|::
name|DXGIFormat
modifier|&
name|dxgiFormatInfo
init|=
name|d3d11
operator|::
name|GetDXGIFormatInfo
argument_list|(
name|mTextureFormat
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fullCopy
operator|&&
operator|(
name|dxgiFormatInfo
operator|.
name|depthBits
operator|>
literal|0
operator|||
name|dxgiFormatInfo
operator|.
name|stencilBits
operator|>
literal|0
operator|)
condition|)
block|{
comment|// CopySubresourceRegion cannot copy partial depth stencils, use the blitter instead
name|Blit11
modifier|*
name|blitter
init|=
name|mRenderer
operator|->
name|getBlitter
argument_list|()
decl_stmt|;
return|return
name|blitter
operator|->
name|copyDepthStencil
argument_list|(
name|srcTexture
argument_list|,
name|sourceSubresource
argument_list|,
name|copyArea
argument_list|,
name|texSize
argument_list|,
name|dstTexture
argument_list|,
name|dstSubresource
argument_list|,
name|copyArea
argument_list|,
name|texSize
argument_list|,
name|NULL
argument_list|)
return|;
block|}
else|else
block|{
specifier|const
name|d3d11
operator|::
name|DXGIFormat
modifier|&
name|dxgiFormatInfo
init|=
name|d3d11
operator|::
name|GetDXGIFormatInfo
argument_list|(
name|mTextureFormat
argument_list|)
decl_stmt|;
name|D3D11_BOX
name|srcBox
decl_stmt|;
name|srcBox
operator|.
name|left
operator|=
name|copyArea
operator|.
name|x
expr_stmt|;
name|srcBox
operator|.
name|top
operator|=
name|copyArea
operator|.
name|y
expr_stmt|;
name|srcBox
operator|.
name|right
operator|=
name|copyArea
operator|.
name|x
operator|+
name|roundUp
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|width
argument_list|,
name|dxgiFormatInfo
operator|.
name|blockWidth
argument_list|)
expr_stmt|;
name|srcBox
operator|.
name|bottom
operator|=
name|copyArea
operator|.
name|y
operator|+
name|roundUp
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|height
argument_list|,
name|dxgiFormatInfo
operator|.
name|blockHeight
argument_list|)
expr_stmt|;
name|srcBox
operator|.
name|front
operator|=
name|copyArea
operator|.
name|z
expr_stmt|;
name|srcBox
operator|.
name|back
operator|=
name|copyArea
operator|.
name|z
operator|+
name|copyArea
operator|.
name|depth
expr_stmt|;
name|ID3D11DeviceContext
modifier|*
name|context
init|=
name|mRenderer
operator|->
name|getDeviceContext
argument_list|()
decl_stmt|;
name|context
operator|->
name|CopySubresourceRegion
argument_list|(
name|dstTexture
argument_list|,
name|dstSubresource
argument_list|,
name|copyArea
operator|.
name|x
argument_list|,
name|copyArea
operator|.
name|y
argument_list|,
name|copyArea
operator|.
name|z
argument_list|,
name|srcTexture
argument_list|,
name|sourceSubresource
argument_list|,
name|fullCopy
condition|?
name|NULL
else|:
operator|&
name|srcBox
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|function|copySubresourceLevel
name|bool
name|TextureStorage11
operator|::
name|copySubresourceLevel
parameter_list|(
name|ID3D11Resource
modifier|*
name|dstTexture
parameter_list|,
name|unsigned
name|int
name|dstSubresource
parameter_list|,
name|int
name|level
parameter_list|,
name|int
name|layerTarget
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLint
name|zoffset
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|depth
parameter_list|)
block|{
if|if
condition|(
name|dstTexture
condition|)
block|{
name|ID3D11Resource
modifier|*
name|srcTexture
init|=
name|getResource
argument_list|()
decl_stmt|;
name|unsigned
name|int
name|srcSubresource
init|=
name|getSubresourceIndex
argument_list|(
name|level
operator|+
name|mTopLevel
argument_list|,
name|layerTarget
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|srcTexture
argument_list|)
expr_stmt|;
name|ID3D11DeviceContext
modifier|*
name|context
init|=
name|mRenderer
operator|->
name|getDeviceContext
argument_list|()
decl_stmt|;
name|context
operator|->
name|CopySubresourceRegion
argument_list|(
name|dstTexture
argument_list|,
name|dstSubresource
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|zoffset
argument_list|,
name|srcTexture
argument_list|,
name|srcSubresource
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|function|generateMipmapLayer
name|void
name|TextureStorage11
operator|::
name|generateMipmapLayer
parameter_list|(
name|RenderTarget11
modifier|*
name|source
parameter_list|,
name|RenderTarget11
modifier|*
name|dest
parameter_list|)
block|{
if|if
condition|(
name|source
operator|&&
name|dest
condition|)
block|{
name|ID3D11ShaderResourceView
modifier|*
name|sourceSRV
init|=
name|source
operator|->
name|getShaderResourceView
argument_list|()
decl_stmt|;
name|ID3D11RenderTargetView
modifier|*
name|destRTV
init|=
name|dest
operator|->
name|getRenderTargetView
argument_list|()
decl_stmt|;
if|if
condition|(
name|sourceSRV
operator|&&
name|destRTV
condition|)
block|{
name|gl
operator|::
name|Box
name|sourceArea
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|source
operator|->
name|getWidth
argument_list|()
argument_list|,
name|source
operator|->
name|getHeight
argument_list|()
argument_list|,
name|source
operator|->
name|getDepth
argument_list|()
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Extents
name|sourceSize
argument_list|(
name|source
operator|->
name|getWidth
argument_list|()
argument_list|,
name|source
operator|->
name|getHeight
argument_list|()
argument_list|,
name|source
operator|->
name|getDepth
argument_list|()
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Box
name|destArea
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dest
operator|->
name|getWidth
argument_list|()
argument_list|,
name|dest
operator|->
name|getHeight
argument_list|()
argument_list|,
name|dest
operator|->
name|getDepth
argument_list|()
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Extents
name|destSize
argument_list|(
name|dest
operator|->
name|getWidth
argument_list|()
argument_list|,
name|dest
operator|->
name|getHeight
argument_list|()
argument_list|,
name|dest
operator|->
name|getDepth
argument_list|()
argument_list|)
decl_stmt|;
name|Blit11
modifier|*
name|blitter
init|=
name|mRenderer
operator|->
name|getBlitter
argument_list|()
decl_stmt|;
name|blitter
operator|->
name|copyTexture
argument_list|(
name|sourceSRV
argument_list|,
name|sourceArea
argument_list|,
name|sourceSize
argument_list|,
name|destRTV
argument_list|,
name|destArea
argument_list|,
name|destSize
argument_list|,
name|NULL
argument_list|,
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|source
operator|->
name|getInternalFormat
argument_list|()
argument_list|)
operator|.
name|format
argument_list|,
name|GL_LINEAR
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|verifySwizzleExists
name|void
name|TextureStorage11
operator|::
name|verifySwizzleExists
parameter_list|(
name|GLenum
name|swizzleRed
parameter_list|,
name|GLenum
name|swizzleGreen
parameter_list|,
name|GLenum
name|swizzleBlue
parameter_list|,
name|GLenum
name|swizzleAlpha
parameter_list|)
block|{
name|SwizzleCacheValue
name|swizzleTarget
argument_list|(
name|swizzleRed
argument_list|,
name|swizzleGreen
argument_list|,
name|swizzleBlue
argument_list|,
name|swizzleAlpha
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|mMipLevels
condition|;
name|level
operator|++
control|)
block|{
name|ASSERT
argument_list|(
name|mSwizzleCache
index|[
name|level
index|]
operator|==
name|swizzleTarget
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|TextureStorage11_2D
name|TextureStorage11_2D
operator|::
name|TextureStorage11_2D
parameter_list|(
name|Renderer
modifier|*
name|renderer
parameter_list|,
name|SwapChain11
modifier|*
name|swapchain
parameter_list|)
member_init_list|:
name|TextureStorage11
argument_list|(
name|renderer
argument_list|,
name|D3D11_BIND_RENDER_TARGET
operator||
name|D3D11_BIND_SHADER_RESOURCE
argument_list|)
member_init_list|,
name|mTexture
argument_list|(
name|swapchain
operator|->
name|getOffscreenTexture
argument_list|()
argument_list|)
member_init_list|,
name|mSwizzleTexture
argument_list|(
name|NULL
argument_list|)
block|{
name|mTexture
operator|->
name|AddRef
argument_list|()
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|i
operator|++
control|)
block|{
name|mAssociatedImages
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|mRenderTarget
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|mSwizzleRenderTargets
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|D3D11_TEXTURE2D_DESC
name|texDesc
decl_stmt|;
name|mTexture
operator|->
name|GetDesc
argument_list|(
operator|&
name|texDesc
argument_list|)
expr_stmt|;
name|mMipLevels
operator|=
name|texDesc
operator|.
name|MipLevels
expr_stmt|;
name|mTextureFormat
operator|=
name|texDesc
operator|.
name|Format
expr_stmt|;
name|mTextureWidth
operator|=
name|texDesc
operator|.
name|Width
expr_stmt|;
name|mTextureHeight
operator|=
name|texDesc
operator|.
name|Height
expr_stmt|;
name|mTextureDepth
operator|=
literal|1
expr_stmt|;
name|ID3D11ShaderResourceView
modifier|*
name|srv
init|=
name|swapchain
operator|->
name|getRenderTargetShaderResource
argument_list|()
decl_stmt|;
name|D3D11_SHADER_RESOURCE_VIEW_DESC
name|srvDesc
decl_stmt|;
name|srv
operator|->
name|GetDesc
argument_list|(
operator|&
name|srvDesc
argument_list|)
expr_stmt|;
name|mShaderResourceFormat
operator|=
name|srvDesc
operator|.
name|Format
expr_stmt|;
name|ID3D11RenderTargetView
modifier|*
name|offscreenRTV
init|=
name|swapchain
operator|->
name|getRenderTarget
argument_list|()
decl_stmt|;
name|D3D11_RENDER_TARGET_VIEW_DESC
name|rtvDesc
decl_stmt|;
name|offscreenRTV
operator|->
name|GetDesc
argument_list|(
operator|&
name|rtvDesc
argument_list|)
expr_stmt|;
name|mRenderTargetFormat
operator|=
name|rtvDesc
operator|.
name|Format
expr_stmt|;
specifier|const
name|d3d11
operator|::
name|DXGIFormat
modifier|&
name|dxgiFormatInfo
init|=
name|d3d11
operator|::
name|GetDXGIFormatInfo
argument_list|(
name|mTextureFormat
argument_list|)
decl_stmt|;
specifier|const
name|d3d11
operator|::
name|TextureFormat
modifier|&
name|formatInfo
init|=
name|d3d11
operator|::
name|GetTextureFormatInfo
argument_list|(
name|dxgiFormatInfo
operator|.
name|internalFormat
argument_list|)
decl_stmt|;
name|mSwizzleTextureFormat
operator|=
name|formatInfo
operator|.
name|swizzleTexFormat
expr_stmt|;
name|mSwizzleShaderResourceFormat
operator|=
name|formatInfo
operator|.
name|swizzleSRVFormat
expr_stmt|;
name|mSwizzleRenderTargetFormat
operator|=
name|formatInfo
operator|.
name|swizzleRTVFormat
expr_stmt|;
name|mDepthStencilFormat
operator|=
name|DXGI_FORMAT_UNKNOWN
expr_stmt|;
name|initializeSerials
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|function|TextureStorage11_2D
name|TextureStorage11_2D
operator|::
name|TextureStorage11_2D
parameter_list|(
name|Renderer
modifier|*
name|renderer
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|bool
name|renderTarget
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|int
name|levels
parameter_list|)
member_init_list|:
name|TextureStorage11
argument_list|(
name|renderer
argument_list|,
name|GetTextureBindFlags
argument_list|(
name|internalformat
argument_list|,
name|renderTarget
argument_list|)
argument_list|)
member_init_list|,
name|mTexture
argument_list|(
name|NULL
argument_list|)
member_init_list|,
name|mSwizzleTexture
argument_list|(
name|NULL
argument_list|)
block|{
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|i
operator|++
control|)
block|{
name|mAssociatedImages
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|mRenderTarget
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|mSwizzleRenderTargets
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
specifier|const
name|d3d11
operator|::
name|TextureFormat
modifier|&
name|formatInfo
init|=
name|d3d11
operator|::
name|GetTextureFormatInfo
argument_list|(
name|internalformat
argument_list|)
decl_stmt|;
name|mTextureFormat
operator|=
name|formatInfo
operator|.
name|texFormat
expr_stmt|;
name|mShaderResourceFormat
operator|=
name|formatInfo
operator|.
name|srvFormat
expr_stmt|;
name|mDepthStencilFormat
operator|=
name|formatInfo
operator|.
name|dsvFormat
expr_stmt|;
name|mRenderTargetFormat
operator|=
name|formatInfo
operator|.
name|rtvFormat
expr_stmt|;
name|mSwizzleTextureFormat
operator|=
name|formatInfo
operator|.
name|swizzleTexFormat
expr_stmt|;
name|mSwizzleShaderResourceFormat
operator|=
name|formatInfo
operator|.
name|swizzleSRVFormat
expr_stmt|;
name|mSwizzleRenderTargetFormat
operator|=
name|formatInfo
operator|.
name|swizzleRTVFormat
expr_stmt|;
comment|// if the width or height is not positive this should be treated as an incomplete texture
comment|// we handle that here by skipping the d3d texture creation
if|if
condition|(
name|width
operator|>
literal|0
operator|&&
name|height
operator|>
literal|0
condition|)
block|{
comment|// adjust size if needed for compressed textures
name|d3d11
operator|::
name|MakeValidSize
argument_list|(
literal|false
argument_list|,
name|mTextureFormat
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|height
argument_list|,
operator|&
name|mTopLevel
argument_list|)
expr_stmt|;
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|D3D11_TEXTURE2D_DESC
name|desc
decl_stmt|;
name|desc
operator|.
name|Width
operator|=
name|width
expr_stmt|;
comment|// Compressed texture size constraints?
name|desc
operator|.
name|Height
operator|=
name|height
expr_stmt|;
name|desc
operator|.
name|MipLevels
operator|=
name|desc
operator|.
name|MipLevels
operator|=
name|mRenderer
operator|->
name|isLevel9
argument_list|()
condition|?
literal|1
else|:
operator|(
operator|(
name|levels
operator|>
literal|0
operator|)
condition|?
operator|(
name|mTopLevel
operator|+
name|levels
operator|)
else|:
literal|0
operator|)
expr_stmt|;
name|desc
operator|.
name|ArraySize
operator|=
literal|1
expr_stmt|;
name|desc
operator|.
name|Format
operator|=
name|mTextureFormat
expr_stmt|;
name|desc
operator|.
name|SampleDesc
operator|.
name|Count
operator|=
literal|1
expr_stmt|;
name|desc
operator|.
name|SampleDesc
operator|.
name|Quality
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|Usage
operator|=
name|D3D11_USAGE_DEFAULT
expr_stmt|;
name|desc
operator|.
name|BindFlags
operator|=
name|getBindFlags
argument_list|()
expr_stmt|;
name|desc
operator|.
name|CPUAccessFlags
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateTexture2D
argument_list|(
operator|&
name|desc
argument_list|,
name|NULL
argument_list|,
operator|&
name|mTexture
argument_list|)
decl_stmt|;
comment|// this can happen from windows TDR
if|if
condition|(
name|d3d11
operator|::
name|isDeviceLostError
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|mRenderer
operator|->
name|notifyDeviceLost
argument_list|()
expr_stmt|;
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|result
operator|==
name|E_OUTOFMEMORY
argument_list|)
expr_stmt|;
name|ERR
argument_list|(
literal|"Creating image failed."
argument_list|)
expr_stmt|;
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mTexture
operator|->
name|GetDesc
argument_list|(
operator|&
name|desc
argument_list|)
expr_stmt|;
name|mMipLevels
operator|=
name|desc
operator|.
name|MipLevels
expr_stmt|;
name|mTextureWidth
operator|=
name|desc
operator|.
name|Width
expr_stmt|;
name|mTextureHeight
operator|=
name|desc
operator|.
name|Height
expr_stmt|;
name|mTextureDepth
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|initializeSerials
argument_list|(
name|getLevelCount
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|function|~TextureStorage11_2D
name|TextureStorage11_2D
operator|::
name|~
name|TextureStorage11_2D
parameter_list|()
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mAssociatedImages
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|bool
name|imageAssociationCorrect
init|=
name|mAssociatedImages
index|[
name|i
index|]
operator|->
name|isAssociatedStorageValid
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|imageAssociationCorrect
argument_list|)
expr_stmt|;
if|if
condition|(
name|imageAssociationCorrect
condition|)
block|{
comment|// We must let the Images recover their data before we delete it from the TextureStorage.
name|mAssociatedImages
index|[
name|i
index|]
operator|->
name|recoverFromAssociatedStorage
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|SafeRelease
argument_list|(
name|mTexture
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mSwizzleTexture
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|i
operator|++
control|)
block|{
name|SafeDelete
argument_list|(
name|mRenderTarget
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mSwizzleRenderTargets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|makeTextureStorage11_2D
name|TextureStorage11_2D
modifier|*
name|TextureStorage11_2D
operator|::
name|makeTextureStorage11_2D
parameter_list|(
name|TextureStorage
modifier|*
name|storage
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|HAS_DYNAMIC_TYPE
argument_list|(
name|TextureStorage11_2D
operator|*
argument_list|,
name|storage
argument_list|)
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|TextureStorage11_2D
operator|*
argument_list|>
argument_list|(
name|storage
argument_list|)
return|;
block|}
DECL|function|associateImage
name|void
name|TextureStorage11_2D
operator|::
name|associateImage
parameter_list|(
name|Image11
modifier|*
name|image
parameter_list|,
name|int
name|level
parameter_list|,
name|int
name|layerTarget
parameter_list|)
block|{
name|ASSERT
argument_list|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
block|{
name|mAssociatedImages
index|[
name|level
index|]
operator|=
name|image
expr_stmt|;
block|}
block|}
DECL|function|isAssociatedImageValid
name|bool
name|TextureStorage11_2D
operator|::
name|isAssociatedImageValid
parameter_list|(
name|int
name|level
parameter_list|,
name|int
name|layerTarget
parameter_list|,
name|Image11
modifier|*
name|expectedImage
parameter_list|)
block|{
if|if
condition|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
block|{
comment|// This validation check should never return false. It means the Image/TextureStorage association is broken.
name|bool
name|retValue
init|=
operator|(
name|mAssociatedImages
index|[
name|level
index|]
operator|==
name|expectedImage
operator|)
decl_stmt|;
name|ASSERT
argument_list|(
name|retValue
argument_list|)
expr_stmt|;
return|return
name|retValue
return|;
block|}
return|return
literal|false
return|;
block|}
comment|// disassociateImage allows an Image to end its association with a Storage.
DECL|function|disassociateImage
name|void
name|TextureStorage11_2D
operator|::
name|disassociateImage
parameter_list|(
name|int
name|level
parameter_list|,
name|int
name|layerTarget
parameter_list|,
name|Image11
modifier|*
name|expectedImage
parameter_list|)
block|{
name|ASSERT
argument_list|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
block|{
name|ASSERT
argument_list|(
name|mAssociatedImages
index|[
name|level
index|]
operator|==
name|expectedImage
argument_list|)
expr_stmt|;
if|if
condition|(
name|mAssociatedImages
index|[
name|level
index|]
operator|==
name|expectedImage
condition|)
block|{
name|mAssociatedImages
index|[
name|level
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
comment|// releaseAssociatedImage prepares the Storage for a new Image association. It lets the old Image recover its data before ending the association.
DECL|function|releaseAssociatedImage
name|void
name|TextureStorage11_2D
operator|::
name|releaseAssociatedImage
parameter_list|(
name|int
name|level
parameter_list|,
name|int
name|layerTarget
parameter_list|,
name|Image11
modifier|*
name|incomingImage
parameter_list|)
block|{
name|ASSERT
argument_list|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
block|{
comment|// No need to let the old Image recover its data, if it is also the incoming Image.
if|if
condition|(
name|mAssociatedImages
index|[
name|level
index|]
operator|!=
name|NULL
operator|&&
name|mAssociatedImages
index|[
name|level
index|]
operator|!=
name|incomingImage
condition|)
block|{
comment|// Ensure that the Image is still associated with this TextureStorage. This should be true.
name|bool
name|imageAssociationCorrect
init|=
name|mAssociatedImages
index|[
name|level
index|]
operator|->
name|isAssociatedStorageValid
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|imageAssociationCorrect
argument_list|)
expr_stmt|;
if|if
condition|(
name|imageAssociationCorrect
condition|)
block|{
comment|// Force the image to recover from storage before its data is overwritten.
comment|// This will reset mAssociatedImages[level] to NULL too.
name|mAssociatedImages
index|[
name|level
index|]
operator|->
name|recoverFromAssociatedStorage
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|function|getResource
name|ID3D11Resource
modifier|*
name|TextureStorage11_2D
operator|::
name|getResource
parameter_list|()
specifier|const
block|{
return|return
name|mTexture
return|;
block|}
DECL|function|getRenderTarget
name|RenderTarget
modifier|*
name|TextureStorage11_2D
operator|::
name|getRenderTarget
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|)
block|{
name|ASSERT
argument_list|(
operator|!
name|index
operator|.
name|hasLayer
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|level
init|=
name|index
operator|.
name|mipIndex
decl_stmt|;
if|if
condition|(
name|level
operator|>=
literal|0
operator|&&
name|level
operator|<
name|getLevelCount
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|mRenderTarget
index|[
name|level
index|]
condition|)
block|{
name|ID3D11ShaderResourceView
modifier|*
name|srv
init|=
name|getSRVLevel
argument_list|(
name|level
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|srv
condition|)
block|{
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|mRenderTargetFormat
operator|!=
name|DXGI_FORMAT_UNKNOWN
condition|)
block|{
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|D3D11_RENDER_TARGET_VIEW_DESC
name|rtvDesc
decl_stmt|;
name|rtvDesc
operator|.
name|Format
operator|=
name|mRenderTargetFormat
expr_stmt|;
name|rtvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_RTV_DIMENSION_TEXTURE2D
expr_stmt|;
name|rtvDesc
operator|.
name|Texture2D
operator|.
name|MipSlice
operator|=
name|mTopLevel
operator|+
name|level
expr_stmt|;
name|ID3D11RenderTargetView
modifier|*
name|rtv
decl_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateRenderTargetView
argument_list|(
name|mTexture
argument_list|,
operator|&
name|rtvDesc
argument_list|,
operator|&
name|rtv
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|E_OUTOFMEMORY
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
cast|static_cast
argument_list|<
name|RenderTarget
operator|*
argument_list|>
argument_list|(
name|NULL
argument_list|)
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|mRenderTarget
index|[
name|level
index|]
operator|=
operator|new
name|RenderTarget11
argument_list|(
name|mRenderer
argument_list|,
name|rtv
argument_list|,
name|mTexture
argument_list|,
name|srv
argument_list|,
name|getLevelWidth
argument_list|(
name|level
argument_list|)
argument_list|,
name|getLevelHeight
argument_list|(
name|level
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// RenderTarget will take ownership of these resources
name|SafeRelease
argument_list|(
name|rtv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mDepthStencilFormat
operator|!=
name|DXGI_FORMAT_UNKNOWN
condition|)
block|{
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|D3D11_DEPTH_STENCIL_VIEW_DESC
name|dsvDesc
decl_stmt|;
name|dsvDesc
operator|.
name|Format
operator|=
name|mDepthStencilFormat
expr_stmt|;
name|dsvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_DSV_DIMENSION_TEXTURE2D
expr_stmt|;
name|dsvDesc
operator|.
name|Texture2D
operator|.
name|MipSlice
operator|=
name|mTopLevel
operator|+
name|level
expr_stmt|;
name|dsvDesc
operator|.
name|Flags
operator|=
literal|0
expr_stmt|;
name|ID3D11DepthStencilView
modifier|*
name|dsv
decl_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateDepthStencilView
argument_list|(
name|mTexture
argument_list|,
operator|&
name|dsvDesc
argument_list|,
operator|&
name|dsv
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|E_OUTOFMEMORY
condition|)
block|{
name|SafeRelease
argument_list|(
name|srv
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
cast|static_cast
argument_list|<
name|RenderTarget
operator|*
argument_list|>
argument_list|(
name|NULL
argument_list|)
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|mRenderTarget
index|[
name|level
index|]
operator|=
operator|new
name|RenderTarget11
argument_list|(
name|mRenderer
argument_list|,
name|dsv
argument_list|,
name|mTexture
argument_list|,
name|srv
argument_list|,
name|getLevelWidth
argument_list|(
name|level
argument_list|)
argument_list|,
name|getLevelHeight
argument_list|(
name|level
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// RenderTarget will take ownership of these resources
name|SafeRelease
argument_list|(
name|dsv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|mRenderTarget
index|[
name|level
index|]
return|;
block|}
else|else
block|{
return|return
name|NULL
return|;
block|}
block|}
DECL|function|createSRV
name|ID3D11ShaderResourceView
modifier|*
name|TextureStorage11_2D
operator|::
name|createSRV
parameter_list|(
name|int
name|baseLevel
parameter_list|,
name|int
name|mipLevels
parameter_list|,
name|DXGI_FORMAT
name|format
parameter_list|,
name|ID3D11Resource
modifier|*
name|texture
parameter_list|)
block|{
name|D3D11_SHADER_RESOURCE_VIEW_DESC
name|srvDesc
decl_stmt|;
name|srvDesc
operator|.
name|Format
operator|=
name|format
expr_stmt|;
name|srvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_SRV_DIMENSION_TEXTURE2D
expr_stmt|;
name|srvDesc
operator|.
name|Texture2D
operator|.
name|MostDetailedMip
operator|=
name|mTopLevel
operator|+
name|baseLevel
expr_stmt|;
name|srvDesc
operator|.
name|Texture2D
operator|.
name|MipLevels
operator|=
name|mipLevels
expr_stmt|;
name|ID3D11ShaderResourceView
modifier|*
name|SRV
init|=
name|NULL
decl_stmt|;
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateShaderResourceView
argument_list|(
name|texture
argument_list|,
operator|&
name|srvDesc
argument_list|,
operator|&
name|SRV
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|E_OUTOFMEMORY
condition|)
block|{
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SRV
return|;
block|}
DECL|function|generateMipmaps
name|void
name|TextureStorage11_2D
operator|::
name|generateMipmaps
parameter_list|()
block|{
comment|// Base level must already be defined
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<
name|getLevelCount
argument_list|()
condition|;
name|level
operator|++
control|)
block|{
name|invalidateSwizzleCacheLevel
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|gl
operator|::
name|ImageIndex
name|srcIndex
init|=
name|gl
operator|::
name|ImageIndex
operator|::
name|Make2D
argument_list|(
name|level
operator|-
literal|1
argument_list|)
decl_stmt|;
name|gl
operator|::
name|ImageIndex
name|destIndex
init|=
name|gl
operator|::
name|ImageIndex
operator|::
name|Make2D
argument_list|(
name|level
argument_list|)
decl_stmt|;
name|RenderTarget11
modifier|*
name|source
init|=
name|RenderTarget11
operator|::
name|makeRenderTarget11
argument_list|(
name|getRenderTarget
argument_list|(
name|srcIndex
argument_list|)
argument_list|)
decl_stmt|;
name|RenderTarget11
modifier|*
name|dest
init|=
name|RenderTarget11
operator|::
name|makeRenderTarget11
argument_list|(
name|getRenderTarget
argument_list|(
name|destIndex
argument_list|)
argument_list|)
decl_stmt|;
name|generateMipmapLayer
argument_list|(
name|source
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|getSwizzleTexture
name|ID3D11Resource
modifier|*
name|TextureStorage11_2D
operator|::
name|getSwizzleTexture
parameter_list|()
block|{
if|if
condition|(
operator|!
name|mSwizzleTexture
condition|)
block|{
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|D3D11_TEXTURE2D_DESC
name|desc
decl_stmt|;
name|desc
operator|.
name|Width
operator|=
name|mTextureWidth
expr_stmt|;
name|desc
operator|.
name|Height
operator|=
name|mTextureHeight
expr_stmt|;
name|desc
operator|.
name|MipLevels
operator|=
name|mMipLevels
expr_stmt|;
name|desc
operator|.
name|ArraySize
operator|=
literal|1
expr_stmt|;
name|desc
operator|.
name|Format
operator|=
name|mSwizzleTextureFormat
expr_stmt|;
name|desc
operator|.
name|SampleDesc
operator|.
name|Count
operator|=
literal|1
expr_stmt|;
name|desc
operator|.
name|SampleDesc
operator|.
name|Quality
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|Usage
operator|=
name|D3D11_USAGE_DEFAULT
expr_stmt|;
name|desc
operator|.
name|BindFlags
operator|=
name|D3D11_BIND_SHADER_RESOURCE
operator||
name|D3D11_BIND_RENDER_TARGET
expr_stmt|;
name|desc
operator|.
name|CPUAccessFlags
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateTexture2D
argument_list|(
operator|&
name|desc
argument_list|,
name|NULL
argument_list|,
operator|&
name|mSwizzleTexture
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|E_OUTOFMEMORY
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
cast|static_cast
argument_list|<
name|ID3D11Texture2D
operator|*
argument_list|>
argument_list|(
name|NULL
argument_list|)
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|mSwizzleTexture
return|;
block|}
DECL|function|getSwizzleRenderTarget
name|ID3D11RenderTargetView
modifier|*
name|TextureStorage11_2D
operator|::
name|getSwizzleRenderTarget
parameter_list|(
name|int
name|mipLevel
parameter_list|)
block|{
if|if
condition|(
name|mipLevel
operator|>=
literal|0
operator|&&
name|mipLevel
operator|<
name|getLevelCount
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|mSwizzleRenderTargets
index|[
name|mipLevel
index|]
condition|)
block|{
name|ID3D11Resource
modifier|*
name|swizzleTexture
init|=
name|getSwizzleTexture
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|swizzleTexture
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|D3D11_RENDER_TARGET_VIEW_DESC
name|rtvDesc
decl_stmt|;
name|rtvDesc
operator|.
name|Format
operator|=
name|mSwizzleRenderTargetFormat
expr_stmt|;
name|rtvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_RTV_DIMENSION_TEXTURE2D
expr_stmt|;
name|rtvDesc
operator|.
name|Texture2D
operator|.
name|MipSlice
operator|=
name|mTopLevel
operator|+
name|mipLevel
expr_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateRenderTargetView
argument_list|(
name|mSwizzleTexture
argument_list|,
operator|&
name|rtvDesc
argument_list|,
operator|&
name|mSwizzleRenderTargets
index|[
name|mipLevel
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|E_OUTOFMEMORY
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
cast|static_cast
argument_list|<
name|ID3D11RenderTargetView
operator|*
argument_list|>
argument_list|(
name|NULL
argument_list|)
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|mSwizzleRenderTargets
index|[
name|mipLevel
index|]
return|;
block|}
else|else
block|{
return|return
name|NULL
return|;
block|}
block|}
DECL|function|TextureStorage11_Cube
name|TextureStorage11_Cube
operator|::
name|TextureStorage11_Cube
parameter_list|(
name|Renderer
modifier|*
name|renderer
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|bool
name|renderTarget
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|levels
parameter_list|)
member_init_list|:
name|TextureStorage11
argument_list|(
name|renderer
argument_list|,
name|GetTextureBindFlags
argument_list|(
name|internalformat
argument_list|,
name|renderTarget
argument_list|)
argument_list|)
block|{
name|mTexture
operator|=
name|NULL
expr_stmt|;
name|mSwizzleTexture
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|level
operator|++
control|)
block|{
name|mSwizzleRenderTargets
index|[
name|level
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|face
init|=
literal|0
init|;
name|face
operator|<
literal|6
condition|;
name|face
operator|++
control|)
block|{
name|mAssociatedImages
index|[
name|face
index|]
index|[
name|level
index|]
operator|=
name|NULL
expr_stmt|;
name|mRenderTarget
index|[
name|face
index|]
index|[
name|level
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
specifier|const
name|d3d11
operator|::
name|TextureFormat
modifier|&
name|formatInfo
init|=
name|d3d11
operator|::
name|GetTextureFormatInfo
argument_list|(
name|internalformat
argument_list|)
decl_stmt|;
name|mTextureFormat
operator|=
name|formatInfo
operator|.
name|texFormat
expr_stmt|;
name|mShaderResourceFormat
operator|=
name|formatInfo
operator|.
name|srvFormat
expr_stmt|;
name|mDepthStencilFormat
operator|=
name|formatInfo
operator|.
name|dsvFormat
expr_stmt|;
name|mRenderTargetFormat
operator|=
name|formatInfo
operator|.
name|rtvFormat
expr_stmt|;
name|mSwizzleTextureFormat
operator|=
name|formatInfo
operator|.
name|swizzleTexFormat
expr_stmt|;
name|mSwizzleShaderResourceFormat
operator|=
name|formatInfo
operator|.
name|swizzleSRVFormat
expr_stmt|;
name|mSwizzleRenderTargetFormat
operator|=
name|formatInfo
operator|.
name|swizzleRTVFormat
expr_stmt|;
comment|// if the size is not positive this should be treated as an incomplete texture
comment|// we handle that here by skipping the d3d texture creation
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
comment|// adjust size if needed for compressed textures
name|int
name|height
init|=
name|size
decl_stmt|;
name|d3d11
operator|::
name|MakeValidSize
argument_list|(
literal|false
argument_list|,
name|mTextureFormat
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|height
argument_list|,
operator|&
name|mTopLevel
argument_list|)
expr_stmt|;
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|D3D11_TEXTURE2D_DESC
name|desc
decl_stmt|;
name|desc
operator|.
name|Width
operator|=
name|size
expr_stmt|;
name|desc
operator|.
name|Height
operator|=
name|size
expr_stmt|;
name|desc
operator|.
name|MipLevels
operator|=
operator|(
operator|(
name|levels
operator|>
literal|0
operator|)
condition|?
operator|(
name|mTopLevel
operator|+
name|levels
operator|)
else|:
literal|0
operator|)
expr_stmt|;
name|desc
operator|.
name|ArraySize
operator|=
literal|6
expr_stmt|;
name|desc
operator|.
name|Format
operator|=
name|mTextureFormat
expr_stmt|;
name|desc
operator|.
name|SampleDesc
operator|.
name|Count
operator|=
literal|1
expr_stmt|;
name|desc
operator|.
name|SampleDesc
operator|.
name|Quality
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|Usage
operator|=
name|D3D11_USAGE_DEFAULT
expr_stmt|;
name|desc
operator|.
name|BindFlags
operator|=
name|getBindFlags
argument_list|()
expr_stmt|;
name|desc
operator|.
name|CPUAccessFlags
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|MiscFlags
operator|=
name|D3D11_RESOURCE_MISC_TEXTURECUBE
expr_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateTexture2D
argument_list|(
operator|&
name|desc
argument_list|,
name|NULL
argument_list|,
operator|&
name|mTexture
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|result
operator|==
name|E_OUTOFMEMORY
argument_list|)
expr_stmt|;
name|ERR
argument_list|(
literal|"Creating image failed."
argument_list|)
expr_stmt|;
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mTexture
operator|->
name|GetDesc
argument_list|(
operator|&
name|desc
argument_list|)
expr_stmt|;
name|mMipLevels
operator|=
name|desc
operator|.
name|MipLevels
expr_stmt|;
name|mTextureWidth
operator|=
name|desc
operator|.
name|Width
expr_stmt|;
name|mTextureHeight
operator|=
name|desc
operator|.
name|Height
expr_stmt|;
name|mTextureDepth
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|initializeSerials
argument_list|(
name|getLevelCount
argument_list|()
operator|*
literal|6
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
DECL|function|~TextureStorage11_Cube
name|TextureStorage11_Cube
operator|::
name|~
name|TextureStorage11_Cube
parameter_list|()
block|{
for|for
control|(
name|unsigned
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|level
operator|++
control|)
block|{
for|for
control|(
name|unsigned
name|int
name|face
init|=
literal|0
init|;
name|face
operator|<
literal|6
condition|;
name|face
operator|++
control|)
block|{
if|if
condition|(
name|mAssociatedImages
index|[
name|face
index|]
index|[
name|level
index|]
operator|!=
name|NULL
condition|)
block|{
name|bool
name|imageAssociationCorrect
init|=
name|mAssociatedImages
index|[
name|face
index|]
index|[
name|level
index|]
operator|->
name|isAssociatedStorageValid
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|imageAssociationCorrect
argument_list|)
expr_stmt|;
if|if
condition|(
name|imageAssociationCorrect
condition|)
block|{
comment|// We must let the Images recover their data before we delete it from the TextureStorage.
name|mAssociatedImages
index|[
name|face
index|]
index|[
name|level
index|]
operator|->
name|recoverFromAssociatedStorage
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
name|SafeRelease
argument_list|(
name|mTexture
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mSwizzleTexture
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|level
operator|++
control|)
block|{
name|SafeRelease
argument_list|(
name|mSwizzleRenderTargets
index|[
name|level
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|face
init|=
literal|0
init|;
name|face
operator|<
literal|6
condition|;
name|face
operator|++
control|)
block|{
name|SafeDelete
argument_list|(
name|mRenderTarget
index|[
name|face
index|]
index|[
name|level
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|makeTextureStorage11_Cube
name|TextureStorage11_Cube
modifier|*
name|TextureStorage11_Cube
operator|::
name|makeTextureStorage11_Cube
parameter_list|(
name|TextureStorage
modifier|*
name|storage
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|HAS_DYNAMIC_TYPE
argument_list|(
name|TextureStorage11_Cube
operator|*
argument_list|,
name|storage
argument_list|)
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|TextureStorage11_Cube
operator|*
argument_list|>
argument_list|(
name|storage
argument_list|)
return|;
block|}
DECL|function|associateImage
name|void
name|TextureStorage11_Cube
operator|::
name|associateImage
parameter_list|(
name|Image11
modifier|*
name|image
parameter_list|,
name|int
name|level
parameter_list|,
name|int
name|layerTarget
parameter_list|)
block|{
name|ASSERT
argument_list|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
literal|0
operator|<=
name|layerTarget
operator|&&
name|layerTarget
operator|<
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
block|{
if|if
condition|(
literal|0
operator|<=
name|layerTarget
operator|&&
name|layerTarget
operator|<
literal|6
condition|)
block|{
name|mAssociatedImages
index|[
name|layerTarget
index|]
index|[
name|level
index|]
operator|=
name|image
expr_stmt|;
block|}
block|}
block|}
DECL|function|isAssociatedImageValid
name|bool
name|TextureStorage11_Cube
operator|::
name|isAssociatedImageValid
parameter_list|(
name|int
name|level
parameter_list|,
name|int
name|layerTarget
parameter_list|,
name|Image11
modifier|*
name|expectedImage
parameter_list|)
block|{
if|if
condition|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
block|{
if|if
condition|(
literal|0
operator|<=
name|layerTarget
operator|&&
name|layerTarget
operator|<
literal|6
condition|)
block|{
comment|// This validation check should never return false. It means the Image/TextureStorage association is broken.
name|bool
name|retValue
init|=
operator|(
name|mAssociatedImages
index|[
name|layerTarget
index|]
index|[
name|level
index|]
operator|==
name|expectedImage
operator|)
decl_stmt|;
name|ASSERT
argument_list|(
name|retValue
argument_list|)
expr_stmt|;
return|return
name|retValue
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|// disassociateImage allows an Image to end its association with a Storage.
DECL|function|disassociateImage
name|void
name|TextureStorage11_Cube
operator|::
name|disassociateImage
parameter_list|(
name|int
name|level
parameter_list|,
name|int
name|layerTarget
parameter_list|,
name|Image11
modifier|*
name|expectedImage
parameter_list|)
block|{
name|ASSERT
argument_list|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
literal|0
operator|<=
name|layerTarget
operator|&&
name|layerTarget
operator|<
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
block|{
if|if
condition|(
literal|0
operator|<=
name|layerTarget
operator|&&
name|layerTarget
operator|<
literal|6
condition|)
block|{
name|ASSERT
argument_list|(
name|mAssociatedImages
index|[
name|layerTarget
index|]
index|[
name|level
index|]
operator|==
name|expectedImage
argument_list|)
expr_stmt|;
if|if
condition|(
name|mAssociatedImages
index|[
name|layerTarget
index|]
index|[
name|level
index|]
operator|==
name|expectedImage
condition|)
block|{
name|mAssociatedImages
index|[
name|layerTarget
index|]
index|[
name|level
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// releaseAssociatedImage prepares the Storage for a new Image association. It lets the old Image recover its data before ending the association.
DECL|function|releaseAssociatedImage
name|void
name|TextureStorage11_Cube
operator|::
name|releaseAssociatedImage
parameter_list|(
name|int
name|level
parameter_list|,
name|int
name|layerTarget
parameter_list|,
name|Image11
modifier|*
name|incomingImage
parameter_list|)
block|{
name|ASSERT
argument_list|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
literal|0
operator|<=
name|layerTarget
operator|&&
name|layerTarget
operator|<
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
operator|)
condition|)
block|{
if|if
condition|(
literal|0
operator|<=
name|layerTarget
operator|&&
name|layerTarget
operator|<
literal|6
condition|)
block|{
comment|// No need to let the old Image recover its data, if it is also the incoming Image.
if|if
condition|(
name|mAssociatedImages
index|[
name|layerTarget
index|]
index|[
name|level
index|]
operator|!=
name|NULL
operator|&&
name|mAssociatedImages
index|[
name|layerTarget
index|]
index|[
name|level
index|]
operator|!=
name|incomingImage
condition|)
block|{
comment|// Ensure that the Image is still associated with this TextureStorage. This should be true.
name|bool
name|imageAssociationCorrect
init|=
name|mAssociatedImages
index|[
name|layerTarget
index|]
index|[
name|level
index|]
operator|->
name|isAssociatedStorageValid
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|imageAssociationCorrect
argument_list|)
expr_stmt|;
if|if
condition|(
name|imageAssociationCorrect
condition|)
block|{
comment|// Force the image to recover from storage before its data is overwritten.
comment|// This will reset mAssociatedImages[level] to NULL too.
name|mAssociatedImages
index|[
name|layerTarget
index|]
index|[
name|level
index|]
operator|->
name|recoverFromAssociatedStorage
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|function|getResource
name|ID3D11Resource
modifier|*
name|TextureStorage11_Cube
operator|::
name|getResource
parameter_list|()
specifier|const
block|{
return|return
name|mTexture
return|;
block|}
DECL|function|getRenderTarget
name|RenderTarget
modifier|*
name|TextureStorage11_Cube
operator|::
name|getRenderTarget
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|)
block|{
name|int
name|faceIndex
init|=
name|index
operator|.
name|layerIndex
decl_stmt|;
name|int
name|level
init|=
name|index
operator|.
name|mipIndex
decl_stmt|;
if|if
condition|(
name|level
operator|>=
literal|0
operator|&&
name|level
operator|<
name|getLevelCount
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|mRenderTarget
index|[
name|faceIndex
index|]
index|[
name|level
index|]
condition|)
block|{
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|HRESULT
name|result
decl_stmt|;
name|D3D11_SHADER_RESOURCE_VIEW_DESC
name|srvDesc
decl_stmt|;
name|srvDesc
operator|.
name|Format
operator|=
name|mShaderResourceFormat
expr_stmt|;
name|srvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_SRV_DIMENSION_TEXTURE2DARRAY
expr_stmt|;
comment|// Will be used with Texture2D sampler, not TextureCube
name|srvDesc
operator|.
name|Texture2DArray
operator|.
name|MostDetailedMip
operator|=
name|mTopLevel
operator|+
name|level
expr_stmt|;
name|srvDesc
operator|.
name|Texture2DArray
operator|.
name|MipLevels
operator|=
literal|1
expr_stmt|;
name|srvDesc
operator|.
name|Texture2DArray
operator|.
name|FirstArraySlice
operator|=
name|faceIndex
expr_stmt|;
name|srvDesc
operator|.
name|Texture2DArray
operator|.
name|ArraySize
operator|=
literal|1
expr_stmt|;
name|ID3D11ShaderResourceView
modifier|*
name|srv
decl_stmt|;
name|result
operator|=
name|device
operator|->
name|CreateShaderResourceView
argument_list|(
name|mTexture
argument_list|,
operator|&
name|srvDesc
argument_list|,
operator|&
name|srv
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|E_OUTOFMEMORY
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
cast|static_cast
argument_list|<
name|RenderTarget
operator|*
argument_list|>
argument_list|(
name|NULL
argument_list|)
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mRenderTargetFormat
operator|!=
name|DXGI_FORMAT_UNKNOWN
condition|)
block|{
name|D3D11_RENDER_TARGET_VIEW_DESC
name|rtvDesc
decl_stmt|;
name|rtvDesc
operator|.
name|Format
operator|=
name|mRenderTargetFormat
expr_stmt|;
name|rtvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_RTV_DIMENSION_TEXTURE2DARRAY
expr_stmt|;
name|rtvDesc
operator|.
name|Texture2DArray
operator|.
name|MipSlice
operator|=
name|mTopLevel
operator|+
name|level
expr_stmt|;
name|rtvDesc
operator|.
name|Texture2DArray
operator|.
name|FirstArraySlice
operator|=
name|faceIndex
expr_stmt|;
name|rtvDesc
operator|.
name|Texture2DArray
operator|.
name|ArraySize
operator|=
literal|1
expr_stmt|;
name|ID3D11RenderTargetView
modifier|*
name|rtv
decl_stmt|;
name|result
operator|=
name|device
operator|->
name|CreateRenderTargetView
argument_list|(
name|mTexture
argument_list|,
operator|&
name|rtvDesc
argument_list|,
operator|&
name|rtv
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|E_OUTOFMEMORY
condition|)
block|{
name|SafeRelease
argument_list|(
name|srv
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
cast|static_cast
argument_list|<
name|RenderTarget
operator|*
argument_list|>
argument_list|(
name|NULL
argument_list|)
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|mRenderTarget
index|[
name|faceIndex
index|]
index|[
name|level
index|]
operator|=
operator|new
name|RenderTarget11
argument_list|(
name|mRenderer
argument_list|,
name|rtv
argument_list|,
name|mTexture
argument_list|,
name|srv
argument_list|,
name|getLevelWidth
argument_list|(
name|level
argument_list|)
argument_list|,
name|getLevelHeight
argument_list|(
name|level
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// RenderTarget will take ownership of these resources
name|SafeRelease
argument_list|(
name|rtv
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|srv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mDepthStencilFormat
operator|!=
name|DXGI_FORMAT_UNKNOWN
condition|)
block|{
name|D3D11_DEPTH_STENCIL_VIEW_DESC
name|dsvDesc
decl_stmt|;
name|dsvDesc
operator|.
name|Format
operator|=
name|mDepthStencilFormat
expr_stmt|;
name|dsvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_DSV_DIMENSION_TEXTURE2DARRAY
expr_stmt|;
name|dsvDesc
operator|.
name|Flags
operator|=
literal|0
expr_stmt|;
name|dsvDesc
operator|.
name|Texture2DArray
operator|.
name|MipSlice
operator|=
name|mTopLevel
operator|+
name|level
expr_stmt|;
name|dsvDesc
operator|.
name|Texture2DArray
operator|.
name|FirstArraySlice
operator|=
name|faceIndex
expr_stmt|;
name|dsvDesc
operator|.
name|Texture2DArray
operator|.
name|ArraySize
operator|=
literal|1
expr_stmt|;
name|ID3D11DepthStencilView
modifier|*
name|dsv
decl_stmt|;
name|result
operator|=
name|device
operator|->
name|CreateDepthStencilView
argument_list|(
name|mTexture
argument_list|,
operator|&
name|dsvDesc
argument_list|,
operator|&
name|dsv
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|E_OUTOFMEMORY
condition|)
block|{
name|SafeRelease
argument_list|(
name|srv
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
cast|static_cast
argument_list|<
name|RenderTarget
operator|*
argument_list|>
argument_list|(
name|NULL
argument_list|)
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|mRenderTarget
index|[
name|faceIndex
index|]
index|[
name|level
index|]
operator|=
operator|new
name|RenderTarget11
argument_list|(
name|mRenderer
argument_list|,
name|dsv
argument_list|,
name|mTexture
argument_list|,
name|srv
argument_list|,
name|getLevelWidth
argument_list|(
name|level
argument_list|)
argument_list|,
name|getLevelHeight
argument_list|(
name|level
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// RenderTarget will take ownership of these resources
name|SafeRelease
argument_list|(
name|dsv
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|srv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|mRenderTarget
index|[
name|faceIndex
index|]
index|[
name|level
index|]
return|;
block|}
else|else
block|{
return|return
name|NULL
return|;
block|}
block|}
DECL|function|createSRV
name|ID3D11ShaderResourceView
modifier|*
name|TextureStorage11_Cube
operator|::
name|createSRV
parameter_list|(
name|int
name|baseLevel
parameter_list|,
name|int
name|mipLevels
parameter_list|,
name|DXGI_FORMAT
name|format
parameter_list|,
name|ID3D11Resource
modifier|*
name|texture
parameter_list|)
block|{
name|D3D11_SHADER_RESOURCE_VIEW_DESC
name|srvDesc
decl_stmt|;
name|srvDesc
operator|.
name|Format
operator|=
name|format
expr_stmt|;
comment|// Unnormalized integer cube maps are not supported by DX11; we emulate them as an array of six 2D textures
specifier|const
name|d3d11
operator|::
name|DXGIFormat
modifier|&
name|dxgiFormatInfo
init|=
name|d3d11
operator|::
name|GetDXGIFormatInfo
argument_list|(
name|format
argument_list|)
decl_stmt|;
if|if
condition|(
name|dxgiFormatInfo
operator|.
name|componentType
operator|==
name|GL_INT
operator|||
name|dxgiFormatInfo
operator|.
name|componentType
operator|==
name|GL_UNSIGNED_INT
condition|)
block|{
name|srvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_SRV_DIMENSION_TEXTURE2DARRAY
expr_stmt|;
name|srvDesc
operator|.
name|Texture2DArray
operator|.
name|MostDetailedMip
operator|=
name|mTopLevel
operator|+
name|baseLevel
expr_stmt|;
name|srvDesc
operator|.
name|Texture2DArray
operator|.
name|MipLevels
operator|=
literal|1
expr_stmt|;
name|srvDesc
operator|.
name|Texture2DArray
operator|.
name|FirstArraySlice
operator|=
literal|0
expr_stmt|;
name|srvDesc
operator|.
name|Texture2DArray
operator|.
name|ArraySize
operator|=
literal|6
expr_stmt|;
block|}
else|else
block|{
name|srvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_SRV_DIMENSION_TEXTURECUBE
expr_stmt|;
name|srvDesc
operator|.
name|TextureCube
operator|.
name|MipLevels
operator|=
name|mipLevels
expr_stmt|;
name|srvDesc
operator|.
name|TextureCube
operator|.
name|MostDetailedMip
operator|=
name|mTopLevel
operator|+
name|baseLevel
expr_stmt|;
block|}
name|ID3D11ShaderResourceView
modifier|*
name|SRV
init|=
name|NULL
decl_stmt|;
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateShaderResourceView
argument_list|(
name|texture
argument_list|,
operator|&
name|srvDesc
argument_list|,
operator|&
name|SRV
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|E_OUTOFMEMORY
condition|)
block|{
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SRV
return|;
block|}
DECL|function|generateMipmaps
name|void
name|TextureStorage11_Cube
operator|::
name|generateMipmaps
parameter_list|()
block|{
comment|// Base level must already be defined
for|for
control|(
name|int
name|faceIndex
init|=
literal|0
init|;
name|faceIndex
operator|<
literal|6
condition|;
name|faceIndex
operator|++
control|)
block|{
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<
name|getLevelCount
argument_list|()
condition|;
name|level
operator|++
control|)
block|{
name|invalidateSwizzleCacheLevel
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|gl
operator|::
name|ImageIndex
name|srcIndex
init|=
name|gl
operator|::
name|ImageIndex
operator|::
name|MakeCube
argument_list|(
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
operator|+
name|faceIndex
argument_list|,
name|level
operator|-
literal|1
argument_list|)
decl_stmt|;
name|gl
operator|::
name|ImageIndex
name|destIndex
init|=
name|gl
operator|::
name|ImageIndex
operator|::
name|MakeCube
argument_list|(
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
operator|+
name|faceIndex
argument_list|,
name|level
argument_list|)
decl_stmt|;
name|RenderTarget11
modifier|*
name|source
init|=
name|RenderTarget11
operator|::
name|makeRenderTarget11
argument_list|(
name|getRenderTarget
argument_list|(
name|srcIndex
argument_list|)
argument_list|)
decl_stmt|;
name|RenderTarget11
modifier|*
name|dest
init|=
name|RenderTarget11
operator|::
name|makeRenderTarget11
argument_list|(
name|getRenderTarget
argument_list|(
name|destIndex
argument_list|)
argument_list|)
decl_stmt|;
name|generateMipmapLayer
argument_list|(
name|source
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|getSwizzleTexture
name|ID3D11Resource
modifier|*
name|TextureStorage11_Cube
operator|::
name|getSwizzleTexture
parameter_list|()
block|{
if|if
condition|(
operator|!
name|mSwizzleTexture
condition|)
block|{
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|D3D11_TEXTURE2D_DESC
name|desc
decl_stmt|;
name|desc
operator|.
name|Width
operator|=
name|mTextureWidth
expr_stmt|;
name|desc
operator|.
name|Height
operator|=
name|mTextureHeight
expr_stmt|;
name|desc
operator|.
name|MipLevels
operator|=
name|mMipLevels
expr_stmt|;
name|desc
operator|.
name|ArraySize
operator|=
literal|6
expr_stmt|;
name|desc
operator|.
name|Format
operator|=
name|mSwizzleTextureFormat
expr_stmt|;
name|desc
operator|.
name|SampleDesc
operator|.
name|Count
operator|=
literal|1
expr_stmt|;
name|desc
operator|.
name|SampleDesc
operator|.
name|Quality
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|Usage
operator|=
name|D3D11_USAGE_DEFAULT
expr_stmt|;
name|desc
operator|.
name|BindFlags
operator|=
name|D3D11_BIND_SHADER_RESOURCE
operator||
name|D3D11_BIND_RENDER_TARGET
expr_stmt|;
name|desc
operator|.
name|CPUAccessFlags
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|MiscFlags
operator|=
name|D3D11_RESOURCE_MISC_TEXTURECUBE
expr_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateTexture2D
argument_list|(
operator|&
name|desc
argument_list|,
name|NULL
argument_list|,
operator|&
name|mSwizzleTexture
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|E_OUTOFMEMORY
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
cast|static_cast
argument_list|<
name|ID3D11Texture2D
operator|*
argument_list|>
argument_list|(
name|NULL
argument_list|)
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|mSwizzleTexture
return|;
block|}
DECL|function|getSwizzleRenderTarget
name|ID3D11RenderTargetView
modifier|*
name|TextureStorage11_Cube
operator|::
name|getSwizzleRenderTarget
parameter_list|(
name|int
name|mipLevel
parameter_list|)
block|{
if|if
condition|(
name|mipLevel
operator|>=
literal|0
operator|&&
name|mipLevel
operator|<
name|getLevelCount
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|mSwizzleRenderTargets
index|[
name|mipLevel
index|]
condition|)
block|{
name|ID3D11Resource
modifier|*
name|swizzleTexture
init|=
name|getSwizzleTexture
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|swizzleTexture
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|D3D11_RENDER_TARGET_VIEW_DESC
name|rtvDesc
decl_stmt|;
name|rtvDesc
operator|.
name|Format
operator|=
name|mSwizzleRenderTargetFormat
expr_stmt|;
name|rtvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_RTV_DIMENSION_TEXTURE2DARRAY
expr_stmt|;
name|rtvDesc
operator|.
name|Texture2DArray
operator|.
name|MipSlice
operator|=
name|mTopLevel
operator|+
name|mipLevel
expr_stmt|;
name|rtvDesc
operator|.
name|Texture2DArray
operator|.
name|FirstArraySlice
operator|=
literal|0
expr_stmt|;
name|rtvDesc
operator|.
name|Texture2DArray
operator|.
name|ArraySize
operator|=
literal|6
expr_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateRenderTargetView
argument_list|(
name|mSwizzleTexture
argument_list|,
operator|&
name|rtvDesc
argument_list|,
operator|&
name|mSwizzleRenderTargets
index|[
name|mipLevel
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|E_OUTOFMEMORY
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
cast|static_cast
argument_list|<
name|ID3D11RenderTargetView
operator|*
argument_list|>
argument_list|(
name|NULL
argument_list|)
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|mSwizzleRenderTargets
index|[
name|mipLevel
index|]
return|;
block|}
else|else
block|{
return|return
name|NULL
return|;
block|}
block|}
DECL|function|TextureStorage11_3D
name|TextureStorage11_3D
operator|::
name|TextureStorage11_3D
parameter_list|(
name|Renderer
modifier|*
name|renderer
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|bool
name|renderTarget
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|depth
parameter_list|,
name|int
name|levels
parameter_list|)
member_init_list|:
name|TextureStorage11
argument_list|(
name|renderer
argument_list|,
name|GetTextureBindFlags
argument_list|(
name|internalformat
argument_list|,
name|renderTarget
argument_list|)
argument_list|)
block|{
name|mTexture
operator|=
name|NULL
expr_stmt|;
name|mSwizzleTexture
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|i
operator|++
control|)
block|{
name|mAssociatedImages
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|mLevelRenderTargets
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|mSwizzleRenderTargets
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
specifier|const
name|d3d11
operator|::
name|TextureFormat
modifier|&
name|formatInfo
init|=
name|d3d11
operator|::
name|GetTextureFormatInfo
argument_list|(
name|internalformat
argument_list|)
decl_stmt|;
name|mTextureFormat
operator|=
name|formatInfo
operator|.
name|texFormat
expr_stmt|;
name|mShaderResourceFormat
operator|=
name|formatInfo
operator|.
name|srvFormat
expr_stmt|;
name|mDepthStencilFormat
operator|=
name|formatInfo
operator|.
name|dsvFormat
expr_stmt|;
name|mRenderTargetFormat
operator|=
name|formatInfo
operator|.
name|rtvFormat
expr_stmt|;
name|mSwizzleTextureFormat
operator|=
name|formatInfo
operator|.
name|swizzleTexFormat
expr_stmt|;
name|mSwizzleShaderResourceFormat
operator|=
name|formatInfo
operator|.
name|swizzleSRVFormat
expr_stmt|;
name|mSwizzleRenderTargetFormat
operator|=
name|formatInfo
operator|.
name|swizzleRTVFormat
expr_stmt|;
comment|// If the width, height or depth are not positive this should be treated as an incomplete texture
comment|// we handle that here by skipping the d3d texture creation
if|if
condition|(
name|width
operator|>
literal|0
operator|&&
name|height
operator|>
literal|0
operator|&&
name|depth
operator|>
literal|0
condition|)
block|{
comment|// adjust size if needed for compressed textures
name|d3d11
operator|::
name|MakeValidSize
argument_list|(
literal|false
argument_list|,
name|mTextureFormat
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|height
argument_list|,
operator|&
name|mTopLevel
argument_list|)
expr_stmt|;
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|D3D11_TEXTURE3D_DESC
name|desc
decl_stmt|;
name|desc
operator|.
name|Width
operator|=
name|width
expr_stmt|;
name|desc
operator|.
name|Height
operator|=
name|height
expr_stmt|;
name|desc
operator|.
name|Depth
operator|=
name|depth
expr_stmt|;
name|desc
operator|.
name|MipLevels
operator|=
operator|(
operator|(
name|levels
operator|>
literal|0
operator|)
condition|?
operator|(
name|mTopLevel
operator|+
name|levels
operator|)
else|:
literal|0
operator|)
expr_stmt|;
name|desc
operator|.
name|Format
operator|=
name|mTextureFormat
expr_stmt|;
name|desc
operator|.
name|Usage
operator|=
name|D3D11_USAGE_DEFAULT
expr_stmt|;
name|desc
operator|.
name|BindFlags
operator|=
name|getBindFlags
argument_list|()
expr_stmt|;
name|desc
operator|.
name|CPUAccessFlags
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateTexture3D
argument_list|(
operator|&
name|desc
argument_list|,
name|NULL
argument_list|,
operator|&
name|mTexture
argument_list|)
decl_stmt|;
comment|// this can happen from windows TDR
if|if
condition|(
name|d3d11
operator|::
name|isDeviceLostError
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|mRenderer
operator|->
name|notifyDeviceLost
argument_list|()
expr_stmt|;
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|result
operator|==
name|E_OUTOFMEMORY
argument_list|)
expr_stmt|;
name|ERR
argument_list|(
literal|"Creating image failed."
argument_list|)
expr_stmt|;
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mTexture
operator|->
name|GetDesc
argument_list|(
operator|&
name|desc
argument_list|)
expr_stmt|;
name|mMipLevels
operator|=
name|desc
operator|.
name|MipLevels
expr_stmt|;
name|mTextureWidth
operator|=
name|desc
operator|.
name|Width
expr_stmt|;
name|mTextureHeight
operator|=
name|desc
operator|.
name|Height
expr_stmt|;
name|mTextureDepth
operator|=
name|desc
operator|.
name|Depth
expr_stmt|;
block|}
block|}
name|initializeSerials
argument_list|(
name|getLevelCount
argument_list|()
operator|*
name|depth
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
DECL|function|~TextureStorage11_3D
name|TextureStorage11_3D
operator|::
name|~
name|TextureStorage11_3D
parameter_list|()
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mAssociatedImages
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|bool
name|imageAssociationCorrect
init|=
name|mAssociatedImages
index|[
name|i
index|]
operator|->
name|isAssociatedStorageValid
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|imageAssociationCorrect
argument_list|)
expr_stmt|;
if|if
condition|(
name|imageAssociationCorrect
condition|)
block|{
comment|// We must let the Images recover their data before we delete it from the TextureStorage.
name|mAssociatedImages
index|[
name|i
index|]
operator|->
name|recoverFromAssociatedStorage
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|SafeRelease
argument_list|(
name|mTexture
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mSwizzleTexture
argument_list|)
expr_stmt|;
for|for
control|(
name|RenderTargetMap
operator|::
name|iterator
name|i
init|=
name|mLevelLayerRenderTargets
operator|.
name|begin
argument_list|()
init|;
name|i
operator|!=
name|mLevelLayerRenderTargets
operator|.
name|end
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|SafeDelete
argument_list|(
name|i
operator|->
name|second
argument_list|)
expr_stmt|;
block|}
name|mLevelLayerRenderTargets
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|i
operator|++
control|)
block|{
name|SafeDelete
argument_list|(
name|mLevelRenderTargets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mSwizzleRenderTargets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|makeTextureStorage11_3D
name|TextureStorage11_3D
modifier|*
name|TextureStorage11_3D
operator|::
name|makeTextureStorage11_3D
parameter_list|(
name|TextureStorage
modifier|*
name|storage
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|HAS_DYNAMIC_TYPE
argument_list|(
name|TextureStorage11_3D
operator|*
argument_list|,
name|storage
argument_list|)
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|TextureStorage11_3D
operator|*
argument_list|>
argument_list|(
name|storage
argument_list|)
return|;
block|}
DECL|function|associateImage
name|void
name|TextureStorage11_3D
operator|::
name|associateImage
parameter_list|(
name|Image11
modifier|*
name|image
parameter_list|,
name|int
name|level
parameter_list|,
name|int
name|layerTarget
parameter_list|)
block|{
name|ASSERT
argument_list|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
block|{
name|mAssociatedImages
index|[
name|level
index|]
operator|=
name|image
expr_stmt|;
block|}
block|}
DECL|function|isAssociatedImageValid
name|bool
name|TextureStorage11_3D
operator|::
name|isAssociatedImageValid
parameter_list|(
name|int
name|level
parameter_list|,
name|int
name|layerTarget
parameter_list|,
name|Image11
modifier|*
name|expectedImage
parameter_list|)
block|{
if|if
condition|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
block|{
comment|// This validation check should never return false. It means the Image/TextureStorage association is broken.
name|bool
name|retValue
init|=
operator|(
name|mAssociatedImages
index|[
name|level
index|]
operator|==
name|expectedImage
operator|)
decl_stmt|;
name|ASSERT
argument_list|(
name|retValue
argument_list|)
expr_stmt|;
return|return
name|retValue
return|;
block|}
return|return
literal|false
return|;
block|}
comment|// disassociateImage allows an Image to end its association with a Storage.
DECL|function|disassociateImage
name|void
name|TextureStorage11_3D
operator|::
name|disassociateImage
parameter_list|(
name|int
name|level
parameter_list|,
name|int
name|layerTarget
parameter_list|,
name|Image11
modifier|*
name|expectedImage
parameter_list|)
block|{
name|ASSERT
argument_list|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
block|{
name|ASSERT
argument_list|(
name|mAssociatedImages
index|[
name|level
index|]
operator|==
name|expectedImage
argument_list|)
expr_stmt|;
if|if
condition|(
name|mAssociatedImages
index|[
name|level
index|]
operator|==
name|expectedImage
condition|)
block|{
name|mAssociatedImages
index|[
name|level
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
comment|// releaseAssociatedImage prepares the Storage for a new Image association. It lets the old Image recover its data before ending the association.
DECL|function|releaseAssociatedImage
name|void
name|TextureStorage11_3D
operator|::
name|releaseAssociatedImage
parameter_list|(
name|int
name|level
parameter_list|,
name|int
name|layerTarget
parameter_list|,
name|Image11
modifier|*
name|incomingImage
parameter_list|)
block|{
name|ASSERT
argument_list|(
operator|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
block|{
comment|// No need to let the old Image recover its data, if it is also the incoming Image.
if|if
condition|(
name|mAssociatedImages
index|[
name|level
index|]
operator|!=
name|NULL
operator|&&
name|mAssociatedImages
index|[
name|level
index|]
operator|!=
name|incomingImage
condition|)
block|{
comment|// Ensure that the Image is still associated with this TextureStorage. This should be true.
name|bool
name|imageAssociationCorrect
init|=
name|mAssociatedImages
index|[
name|level
index|]
operator|->
name|isAssociatedStorageValid
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|imageAssociationCorrect
argument_list|)
expr_stmt|;
if|if
condition|(
name|imageAssociationCorrect
condition|)
block|{
comment|// Force the image to recover from storage before its data is overwritten.
comment|// This will reset mAssociatedImages[level] to NULL too.
name|mAssociatedImages
index|[
name|level
index|]
operator|->
name|recoverFromAssociatedStorage
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|function|getResource
name|ID3D11Resource
modifier|*
name|TextureStorage11_3D
operator|::
name|getResource
parameter_list|()
specifier|const
block|{
return|return
name|mTexture
return|;
block|}
DECL|function|createSRV
name|ID3D11ShaderResourceView
modifier|*
name|TextureStorage11_3D
operator|::
name|createSRV
parameter_list|(
name|int
name|baseLevel
parameter_list|,
name|int
name|mipLevels
parameter_list|,
name|DXGI_FORMAT
name|format
parameter_list|,
name|ID3D11Resource
modifier|*
name|texture
parameter_list|)
block|{
name|D3D11_SHADER_RESOURCE_VIEW_DESC
name|srvDesc
decl_stmt|;
name|srvDesc
operator|.
name|Format
operator|=
name|format
expr_stmt|;
name|srvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_SRV_DIMENSION_TEXTURE3D
expr_stmt|;
name|srvDesc
operator|.
name|Texture3D
operator|.
name|MostDetailedMip
operator|=
name|baseLevel
expr_stmt|;
name|srvDesc
operator|.
name|Texture3D
operator|.
name|MipLevels
operator|=
name|mipLevels
expr_stmt|;
name|ID3D11ShaderResourceView
modifier|*
name|SRV
init|=
name|NULL
decl_stmt|;
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateShaderResourceView
argument_list|(
name|texture
argument_list|,
operator|&
name|srvDesc
argument_list|,
operator|&
name|SRV
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|E_OUTOFMEMORY
condition|)
block|{
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SRV
return|;
block|}
DECL|function|getRenderTarget
name|RenderTarget
modifier|*
name|TextureStorage11_3D
operator|::
name|getRenderTarget
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|)
block|{
name|int
name|mipLevel
init|=
name|index
operator|.
name|mipIndex
decl_stmt|;
if|if
condition|(
name|mipLevel
operator|>=
literal|0
operator|&&
name|mipLevel
operator|<
name|getLevelCount
argument_list|()
condition|)
block|{
name|ASSERT
argument_list|(
name|mRenderTargetFormat
operator|!=
name|DXGI_FORMAT_UNKNOWN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|index
operator|.
name|hasLayer
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|mLevelRenderTargets
index|[
name|mipLevel
index|]
condition|)
block|{
name|ID3D11ShaderResourceView
modifier|*
name|srv
init|=
name|getSRVLevel
argument_list|(
name|mipLevel
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|srv
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|D3D11_RENDER_TARGET_VIEW_DESC
name|rtvDesc
decl_stmt|;
name|rtvDesc
operator|.
name|Format
operator|=
name|mRenderTargetFormat
expr_stmt|;
name|rtvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_RTV_DIMENSION_TEXTURE3D
expr_stmt|;
name|rtvDesc
operator|.
name|Texture3D
operator|.
name|MipSlice
operator|=
name|mTopLevel
operator|+
name|mipLevel
expr_stmt|;
name|rtvDesc
operator|.
name|Texture3D
operator|.
name|FirstWSlice
operator|=
literal|0
expr_stmt|;
name|rtvDesc
operator|.
name|Texture3D
operator|.
name|WSize
operator|=
operator|-
literal|1
expr_stmt|;
name|ID3D11RenderTargetView
modifier|*
name|rtv
decl_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateRenderTargetView
argument_list|(
name|mTexture
argument_list|,
operator|&
name|rtvDesc
argument_list|,
operator|&
name|rtv
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|E_OUTOFMEMORY
condition|)
block|{
name|SafeRelease
argument_list|(
name|srv
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
cast|static_cast
argument_list|<
name|RenderTarget
operator|*
argument_list|>
argument_list|(
name|NULL
argument_list|)
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|mLevelRenderTargets
index|[
name|mipLevel
index|]
operator|=
operator|new
name|RenderTarget11
argument_list|(
name|mRenderer
argument_list|,
name|rtv
argument_list|,
name|mTexture
argument_list|,
name|srv
argument_list|,
name|getLevelWidth
argument_list|(
name|mipLevel
argument_list|)
argument_list|,
name|getLevelHeight
argument_list|(
name|mipLevel
argument_list|)
argument_list|,
name|getLevelDepth
argument_list|(
name|mipLevel
argument_list|)
argument_list|)
expr_stmt|;
comment|// RenderTarget will take ownership of these resources
name|SafeRelease
argument_list|(
name|rtv
argument_list|)
expr_stmt|;
block|}
return|return
name|mLevelRenderTargets
index|[
name|mipLevel
index|]
return|;
block|}
else|else
block|{
name|int
name|layer
init|=
name|index
operator|.
name|layerIndex
decl_stmt|;
name|LevelLayerKey
name|key
argument_list|(
name|mipLevel
argument_list|,
name|layer
argument_list|)
decl_stmt|;
if|if
condition|(
name|mLevelLayerRenderTargets
operator|.
name|find
argument_list|(
name|key
argument_list|)
operator|==
name|mLevelLayerRenderTargets
operator|.
name|end
argument_list|()
condition|)
block|{
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|HRESULT
name|result
decl_stmt|;
comment|// TODO, what kind of SRV is expected here?
name|ID3D11ShaderResourceView
modifier|*
name|srv
init|=
name|NULL
decl_stmt|;
name|D3D11_RENDER_TARGET_VIEW_DESC
name|rtvDesc
decl_stmt|;
name|rtvDesc
operator|.
name|Format
operator|=
name|mRenderTargetFormat
expr_stmt|;
name|rtvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_RTV_DIMENSION_TEXTURE3D
expr_stmt|;
name|rtvDesc
operator|.
name|Texture3D
operator|.
name|MipSlice
operator|=
name|mTopLevel
operator|+
name|mipLevel
expr_stmt|;
name|rtvDesc
operator|.
name|Texture3D
operator|.
name|FirstWSlice
operator|=
name|layer
expr_stmt|;
name|rtvDesc
operator|.
name|Texture3D
operator|.
name|WSize
operator|=
literal|1
expr_stmt|;
name|ID3D11RenderTargetView
modifier|*
name|rtv
decl_stmt|;
name|result
operator|=
name|device
operator|->
name|CreateRenderTargetView
argument_list|(
name|mTexture
argument_list|,
operator|&
name|rtvDesc
argument_list|,
operator|&
name|rtv
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|E_OUTOFMEMORY
condition|)
block|{
name|SafeRelease
argument_list|(
name|srv
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
cast|static_cast
argument_list|<
name|RenderTarget
operator|*
argument_list|>
argument_list|(
name|NULL
argument_list|)
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|mLevelLayerRenderTargets
index|[
name|key
index|]
operator|=
operator|new
name|RenderTarget11
argument_list|(
name|mRenderer
argument_list|,
name|rtv
argument_list|,
name|mTexture
argument_list|,
name|srv
argument_list|,
name|getLevelWidth
argument_list|(
name|mipLevel
argument_list|)
argument_list|,
name|getLevelHeight
argument_list|(
name|mipLevel
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// RenderTarget will take ownership of these resources
name|SafeRelease
argument_list|(
name|rtv
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|srv
argument_list|)
expr_stmt|;
block|}
return|return
name|mLevelLayerRenderTargets
index|[
name|key
index|]
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
DECL|function|generateMipmaps
name|void
name|TextureStorage11_3D
operator|::
name|generateMipmaps
parameter_list|()
block|{
comment|// Base level must already be defined
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<
name|getLevelCount
argument_list|()
condition|;
name|level
operator|++
control|)
block|{
name|invalidateSwizzleCacheLevel
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|gl
operator|::
name|ImageIndex
name|srcIndex
init|=
name|gl
operator|::
name|ImageIndex
operator|::
name|Make3D
argument_list|(
name|level
operator|-
literal|1
argument_list|)
decl_stmt|;
name|gl
operator|::
name|ImageIndex
name|destIndex
init|=
name|gl
operator|::
name|ImageIndex
operator|::
name|Make3D
argument_list|(
name|level
argument_list|)
decl_stmt|;
name|RenderTarget11
modifier|*
name|source
init|=
name|RenderTarget11
operator|::
name|makeRenderTarget11
argument_list|(
name|getRenderTarget
argument_list|(
name|srcIndex
argument_list|)
argument_list|)
decl_stmt|;
name|RenderTarget11
modifier|*
name|dest
init|=
name|RenderTarget11
operator|::
name|makeRenderTarget11
argument_list|(
name|getRenderTarget
argument_list|(
name|destIndex
argument_list|)
argument_list|)
decl_stmt|;
name|generateMipmapLayer
argument_list|(
name|source
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|getSwizzleTexture
name|ID3D11Resource
modifier|*
name|TextureStorage11_3D
operator|::
name|getSwizzleTexture
parameter_list|()
block|{
if|if
condition|(
operator|!
name|mSwizzleTexture
condition|)
block|{
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|D3D11_TEXTURE3D_DESC
name|desc
decl_stmt|;
name|desc
operator|.
name|Width
operator|=
name|mTextureWidth
expr_stmt|;
name|desc
operator|.
name|Height
operator|=
name|mTextureHeight
expr_stmt|;
name|desc
operator|.
name|Depth
operator|=
name|mTextureDepth
expr_stmt|;
name|desc
operator|.
name|MipLevels
operator|=
name|mMipLevels
expr_stmt|;
name|desc
operator|.
name|Format
operator|=
name|mSwizzleTextureFormat
expr_stmt|;
name|desc
operator|.
name|Usage
operator|=
name|D3D11_USAGE_DEFAULT
expr_stmt|;
name|desc
operator|.
name|BindFlags
operator|=
name|D3D11_BIND_SHADER_RESOURCE
operator||
name|D3D11_BIND_RENDER_TARGET
expr_stmt|;
name|desc
operator|.
name|CPUAccessFlags
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateTexture3D
argument_list|(
operator|&
name|desc
argument_list|,
name|NULL
argument_list|,
operator|&
name|mSwizzleTexture
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|E_OUTOFMEMORY
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
cast|static_cast
argument_list|<
name|ID3D11Texture3D
operator|*
argument_list|>
argument_list|(
name|NULL
argument_list|)
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|mSwizzleTexture
return|;
block|}
DECL|function|getSwizzleRenderTarget
name|ID3D11RenderTargetView
modifier|*
name|TextureStorage11_3D
operator|::
name|getSwizzleRenderTarget
parameter_list|(
name|int
name|mipLevel
parameter_list|)
block|{
if|if
condition|(
name|mipLevel
operator|>=
literal|0
operator|&&
name|mipLevel
operator|<
name|getLevelCount
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|mSwizzleRenderTargets
index|[
name|mipLevel
index|]
condition|)
block|{
name|ID3D11Resource
modifier|*
name|swizzleTexture
init|=
name|getSwizzleTexture
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|swizzleTexture
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|D3D11_RENDER_TARGET_VIEW_DESC
name|rtvDesc
decl_stmt|;
name|rtvDesc
operator|.
name|Format
operator|=
name|mSwizzleRenderTargetFormat
expr_stmt|;
name|rtvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_RTV_DIMENSION_TEXTURE3D
expr_stmt|;
name|rtvDesc
operator|.
name|Texture3D
operator|.
name|MipSlice
operator|=
name|mTopLevel
operator|+
name|mipLevel
expr_stmt|;
name|rtvDesc
operator|.
name|Texture3D
operator|.
name|FirstWSlice
operator|=
literal|0
expr_stmt|;
name|rtvDesc
operator|.
name|Texture3D
operator|.
name|WSize
operator|=
operator|-
literal|1
expr_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateRenderTargetView
argument_list|(
name|mSwizzleTexture
argument_list|,
operator|&
name|rtvDesc
argument_list|,
operator|&
name|mSwizzleRenderTargets
index|[
name|mipLevel
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|E_OUTOFMEMORY
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
cast|static_cast
argument_list|<
name|ID3D11RenderTargetView
operator|*
argument_list|>
argument_list|(
name|NULL
argument_list|)
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|mSwizzleRenderTargets
index|[
name|mipLevel
index|]
return|;
block|}
else|else
block|{
return|return
name|NULL
return|;
block|}
block|}
DECL|function|TextureStorage11_2DArray
name|TextureStorage11_2DArray
operator|::
name|TextureStorage11_2DArray
parameter_list|(
name|Renderer
modifier|*
name|renderer
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|bool
name|renderTarget
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|depth
parameter_list|,
name|int
name|levels
parameter_list|)
member_init_list|:
name|TextureStorage11
argument_list|(
name|renderer
argument_list|,
name|GetTextureBindFlags
argument_list|(
name|internalformat
argument_list|,
name|renderTarget
argument_list|)
argument_list|)
block|{
name|mTexture
operator|=
name|NULL
expr_stmt|;
name|mSwizzleTexture
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|level
operator|++
control|)
block|{
name|mSwizzleRenderTargets
index|[
name|level
index|]
operator|=
name|NULL
expr_stmt|;
block|}
specifier|const
name|d3d11
operator|::
name|TextureFormat
modifier|&
name|formatInfo
init|=
name|d3d11
operator|::
name|GetTextureFormatInfo
argument_list|(
name|internalformat
argument_list|)
decl_stmt|;
name|mTextureFormat
operator|=
name|formatInfo
operator|.
name|texFormat
expr_stmt|;
name|mShaderResourceFormat
operator|=
name|formatInfo
operator|.
name|srvFormat
expr_stmt|;
name|mDepthStencilFormat
operator|=
name|formatInfo
operator|.
name|dsvFormat
expr_stmt|;
name|mRenderTargetFormat
operator|=
name|formatInfo
operator|.
name|rtvFormat
expr_stmt|;
name|mSwizzleTextureFormat
operator|=
name|formatInfo
operator|.
name|swizzleTexFormat
expr_stmt|;
name|mSwizzleShaderResourceFormat
operator|=
name|formatInfo
operator|.
name|swizzleSRVFormat
expr_stmt|;
name|mSwizzleRenderTargetFormat
operator|=
name|formatInfo
operator|.
name|swizzleRTVFormat
expr_stmt|;
comment|// if the width, height or depth is not positive this should be treated as an incomplete texture
comment|// we handle that here by skipping the d3d texture creation
if|if
condition|(
name|width
operator|>
literal|0
operator|&&
name|height
operator|>
literal|0
operator|&&
name|depth
operator|>
literal|0
condition|)
block|{
comment|// adjust size if needed for compressed textures
name|d3d11
operator|::
name|MakeValidSize
argument_list|(
literal|false
argument_list|,
name|mTextureFormat
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|height
argument_list|,
operator|&
name|mTopLevel
argument_list|)
expr_stmt|;
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|D3D11_TEXTURE2D_DESC
name|desc
decl_stmt|;
name|desc
operator|.
name|Width
operator|=
name|width
expr_stmt|;
name|desc
operator|.
name|Height
operator|=
name|height
expr_stmt|;
name|desc
operator|.
name|MipLevels
operator|=
operator|(
operator|(
name|levels
operator|>
literal|0
operator|)
condition|?
operator|(
name|mTopLevel
operator|+
name|levels
operator|)
else|:
literal|0
operator|)
expr_stmt|;
name|desc
operator|.
name|ArraySize
operator|=
name|depth
expr_stmt|;
name|desc
operator|.
name|Format
operator|=
name|mTextureFormat
expr_stmt|;
name|desc
operator|.
name|SampleDesc
operator|.
name|Count
operator|=
literal|1
expr_stmt|;
name|desc
operator|.
name|SampleDesc
operator|.
name|Quality
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|Usage
operator|=
name|D3D11_USAGE_DEFAULT
expr_stmt|;
name|desc
operator|.
name|BindFlags
operator|=
name|getBindFlags
argument_list|()
expr_stmt|;
name|desc
operator|.
name|CPUAccessFlags
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateTexture2D
argument_list|(
operator|&
name|desc
argument_list|,
name|NULL
argument_list|,
operator|&
name|mTexture
argument_list|)
decl_stmt|;
comment|// this can happen from windows TDR
if|if
condition|(
name|d3d11
operator|::
name|isDeviceLostError
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|mRenderer
operator|->
name|notifyDeviceLost
argument_list|()
expr_stmt|;
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|result
operator|==
name|E_OUTOFMEMORY
argument_list|)
expr_stmt|;
name|ERR
argument_list|(
literal|"Creating image failed."
argument_list|)
expr_stmt|;
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mTexture
operator|->
name|GetDesc
argument_list|(
operator|&
name|desc
argument_list|)
expr_stmt|;
name|mMipLevels
operator|=
name|desc
operator|.
name|MipLevels
expr_stmt|;
name|mTextureWidth
operator|=
name|desc
operator|.
name|Width
expr_stmt|;
name|mTextureHeight
operator|=
name|desc
operator|.
name|Height
expr_stmt|;
name|mTextureDepth
operator|=
name|desc
operator|.
name|ArraySize
expr_stmt|;
block|}
block|}
name|initializeSerials
argument_list|(
name|getLevelCount
argument_list|()
operator|*
name|depth
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
DECL|function|~TextureStorage11_2DArray
name|TextureStorage11_2DArray
operator|::
name|~
name|TextureStorage11_2DArray
parameter_list|()
block|{
for|for
control|(
name|ImageMap
operator|::
name|iterator
name|i
init|=
name|mAssociatedImages
operator|.
name|begin
argument_list|()
init|;
name|i
operator|!=
name|mAssociatedImages
operator|.
name|end
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|bool
name|imageAssociationCorrect
init|=
name|i
operator|->
name|second
operator|->
name|isAssociatedStorageValid
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|imageAssociationCorrect
argument_list|)
expr_stmt|;
if|if
condition|(
name|imageAssociationCorrect
condition|)
block|{
comment|// We must let the Images recover their data before we delete it from the TextureStorage.
name|i
operator|->
name|second
operator|->
name|recoverFromAssociatedStorage
argument_list|()
expr_stmt|;
block|}
block|}
name|mAssociatedImages
operator|.
name|clear
argument_list|()
expr_stmt|;
name|SafeRelease
argument_list|(
name|mTexture
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mSwizzleTexture
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|level
operator|++
control|)
block|{
name|SafeRelease
argument_list|(
name|mSwizzleRenderTargets
index|[
name|level
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|RenderTargetMap
operator|::
name|iterator
name|i
init|=
name|mRenderTargets
operator|.
name|begin
argument_list|()
init|;
name|i
operator|!=
name|mRenderTargets
operator|.
name|end
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|SafeDelete
argument_list|(
name|i
operator|->
name|second
argument_list|)
expr_stmt|;
block|}
name|mRenderTargets
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|function|makeTextureStorage11_2DArray
name|TextureStorage11_2DArray
modifier|*
name|TextureStorage11_2DArray
operator|::
name|makeTextureStorage11_2DArray
parameter_list|(
name|TextureStorage
modifier|*
name|storage
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|HAS_DYNAMIC_TYPE
argument_list|(
name|TextureStorage11_2DArray
operator|*
argument_list|,
name|storage
argument_list|)
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|TextureStorage11_2DArray
operator|*
argument_list|>
argument_list|(
name|storage
argument_list|)
return|;
block|}
DECL|function|associateImage
name|void
name|TextureStorage11_2DArray
operator|::
name|associateImage
parameter_list|(
name|Image11
modifier|*
name|image
parameter_list|,
name|int
name|level
parameter_list|,
name|int
name|layerTarget
parameter_list|)
block|{
name|ASSERT
argument_list|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|getLevelCount
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|getLevelCount
argument_list|()
condition|)
block|{
name|LevelLayerKey
name|key
argument_list|(
name|level
argument_list|,
name|layerTarget
argument_list|)
decl_stmt|;
name|mAssociatedImages
index|[
name|key
index|]
operator|=
name|image
expr_stmt|;
block|}
block|}
DECL|function|isAssociatedImageValid
name|bool
name|TextureStorage11_2DArray
operator|::
name|isAssociatedImageValid
parameter_list|(
name|int
name|level
parameter_list|,
name|int
name|layerTarget
parameter_list|,
name|Image11
modifier|*
name|expectedImage
parameter_list|)
block|{
name|LevelLayerKey
name|key
argument_list|(
name|level
argument_list|,
name|layerTarget
argument_list|)
decl_stmt|;
comment|// This validation check should never return false. It means the Image/TextureStorage association is broken.
name|bool
name|retValue
init|=
operator|(
name|mAssociatedImages
operator|.
name|find
argument_list|(
name|key
argument_list|)
operator|!=
name|mAssociatedImages
operator|.
name|end
argument_list|()
operator|&&
operator|(
name|mAssociatedImages
index|[
name|key
index|]
operator|==
name|expectedImage
operator|)
operator|)
decl_stmt|;
name|ASSERT
argument_list|(
name|retValue
argument_list|)
expr_stmt|;
return|return
name|retValue
return|;
block|}
comment|// disassociateImage allows an Image to end its association with a Storage.
DECL|function|disassociateImage
name|void
name|TextureStorage11_2DArray
operator|::
name|disassociateImage
parameter_list|(
name|int
name|level
parameter_list|,
name|int
name|layerTarget
parameter_list|,
name|Image11
modifier|*
name|expectedImage
parameter_list|)
block|{
name|LevelLayerKey
name|key
argument_list|(
name|level
argument_list|,
name|layerTarget
argument_list|)
decl_stmt|;
name|bool
name|imageAssociationCorrect
init|=
operator|(
name|mAssociatedImages
operator|.
name|find
argument_list|(
name|key
argument_list|)
operator|!=
name|mAssociatedImages
operator|.
name|end
argument_list|()
operator|&&
operator|(
name|mAssociatedImages
index|[
name|key
index|]
operator|==
name|expectedImage
operator|)
operator|)
decl_stmt|;
name|ASSERT
argument_list|(
name|imageAssociationCorrect
argument_list|)
expr_stmt|;
if|if
condition|(
name|imageAssociationCorrect
condition|)
block|{
name|mAssociatedImages
index|[
name|key
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|// releaseAssociatedImage prepares the Storage for a new Image association. It lets the old Image recover its data before ending the association.
DECL|function|releaseAssociatedImage
name|void
name|TextureStorage11_2DArray
operator|::
name|releaseAssociatedImage
parameter_list|(
name|int
name|level
parameter_list|,
name|int
name|layerTarget
parameter_list|,
name|Image11
modifier|*
name|incomingImage
parameter_list|)
block|{
name|LevelLayerKey
name|key
argument_list|(
name|level
argument_list|,
name|layerTarget
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|mAssociatedImages
operator|.
name|find
argument_list|(
name|key
argument_list|)
operator|!=
name|mAssociatedImages
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|mAssociatedImages
operator|.
name|find
argument_list|(
name|key
argument_list|)
operator|!=
name|mAssociatedImages
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|mAssociatedImages
index|[
name|key
index|]
operator|!=
name|NULL
operator|&&
name|mAssociatedImages
index|[
name|key
index|]
operator|!=
name|incomingImage
condition|)
block|{
comment|// Ensure that the Image is still associated with this TextureStorage. This should be true.
name|bool
name|imageAssociationCorrect
init|=
name|mAssociatedImages
index|[
name|key
index|]
operator|->
name|isAssociatedStorageValid
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|imageAssociationCorrect
argument_list|)
expr_stmt|;
if|if
condition|(
name|imageAssociationCorrect
condition|)
block|{
comment|// Force the image to recover from storage before its data is overwritten.
comment|// This will reset mAssociatedImages[level] to NULL too.
name|mAssociatedImages
index|[
name|key
index|]
operator|->
name|recoverFromAssociatedStorage
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|function|getResource
name|ID3D11Resource
modifier|*
name|TextureStorage11_2DArray
operator|::
name|getResource
parameter_list|()
specifier|const
block|{
return|return
name|mTexture
return|;
block|}
DECL|function|createSRV
name|ID3D11ShaderResourceView
modifier|*
name|TextureStorage11_2DArray
operator|::
name|createSRV
parameter_list|(
name|int
name|baseLevel
parameter_list|,
name|int
name|mipLevels
parameter_list|,
name|DXGI_FORMAT
name|format
parameter_list|,
name|ID3D11Resource
modifier|*
name|texture
parameter_list|)
block|{
name|D3D11_SHADER_RESOURCE_VIEW_DESC
name|srvDesc
decl_stmt|;
name|srvDesc
operator|.
name|Format
operator|=
name|format
expr_stmt|;
name|srvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_SRV_DIMENSION_TEXTURE2DARRAY
expr_stmt|;
name|srvDesc
operator|.
name|Texture2DArray
operator|.
name|MostDetailedMip
operator|=
name|mTopLevel
operator|+
name|baseLevel
expr_stmt|;
name|srvDesc
operator|.
name|Texture2DArray
operator|.
name|MipLevels
operator|=
name|mipLevels
expr_stmt|;
name|srvDesc
operator|.
name|Texture2DArray
operator|.
name|FirstArraySlice
operator|=
literal|0
expr_stmt|;
name|srvDesc
operator|.
name|Texture2DArray
operator|.
name|ArraySize
operator|=
name|mTextureDepth
expr_stmt|;
name|ID3D11ShaderResourceView
modifier|*
name|SRV
init|=
name|NULL
decl_stmt|;
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateShaderResourceView
argument_list|(
name|texture
argument_list|,
operator|&
name|srvDesc
argument_list|,
operator|&
name|SRV
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|E_OUTOFMEMORY
condition|)
block|{
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SRV
return|;
block|}
DECL|function|getRenderTarget
name|RenderTarget
modifier|*
name|TextureStorage11_2DArray
operator|::
name|getRenderTarget
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|index
operator|.
name|hasLayer
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|mipLevel
init|=
name|index
operator|.
name|mipIndex
decl_stmt|;
name|int
name|layer
init|=
name|index
operator|.
name|layerIndex
decl_stmt|;
if|if
condition|(
name|mipLevel
operator|>=
literal|0
operator|&&
name|mipLevel
operator|<
name|getLevelCount
argument_list|()
condition|)
block|{
name|LevelLayerKey
name|key
argument_list|(
name|mipLevel
argument_list|,
name|layer
argument_list|)
decl_stmt|;
if|if
condition|(
name|mRenderTargets
operator|.
name|find
argument_list|(
name|key
argument_list|)
operator|==
name|mRenderTargets
operator|.
name|end
argument_list|()
condition|)
block|{
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|HRESULT
name|result
decl_stmt|;
name|D3D11_SHADER_RESOURCE_VIEW_DESC
name|srvDesc
decl_stmt|;
name|srvDesc
operator|.
name|Format
operator|=
name|mShaderResourceFormat
expr_stmt|;
name|srvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_SRV_DIMENSION_TEXTURE2DARRAY
expr_stmt|;
name|srvDesc
operator|.
name|Texture2DArray
operator|.
name|MostDetailedMip
operator|=
name|mTopLevel
operator|+
name|mipLevel
expr_stmt|;
name|srvDesc
operator|.
name|Texture2DArray
operator|.
name|MipLevels
operator|=
literal|1
expr_stmt|;
name|srvDesc
operator|.
name|Texture2DArray
operator|.
name|FirstArraySlice
operator|=
name|layer
expr_stmt|;
name|srvDesc
operator|.
name|Texture2DArray
operator|.
name|ArraySize
operator|=
literal|1
expr_stmt|;
name|ID3D11ShaderResourceView
modifier|*
name|srv
decl_stmt|;
name|result
operator|=
name|device
operator|->
name|CreateShaderResourceView
argument_list|(
name|mTexture
argument_list|,
operator|&
name|srvDesc
argument_list|,
operator|&
name|srv
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|E_OUTOFMEMORY
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
cast|static_cast
argument_list|<
name|RenderTarget
operator|*
argument_list|>
argument_list|(
name|NULL
argument_list|)
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mRenderTargetFormat
operator|!=
name|DXGI_FORMAT_UNKNOWN
condition|)
block|{
name|D3D11_RENDER_TARGET_VIEW_DESC
name|rtvDesc
decl_stmt|;
name|rtvDesc
operator|.
name|Format
operator|=
name|mRenderTargetFormat
expr_stmt|;
name|rtvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_RTV_DIMENSION_TEXTURE2DARRAY
expr_stmt|;
name|rtvDesc
operator|.
name|Texture2DArray
operator|.
name|MipSlice
operator|=
name|mTopLevel
operator|+
name|mipLevel
expr_stmt|;
name|rtvDesc
operator|.
name|Texture2DArray
operator|.
name|FirstArraySlice
operator|=
name|layer
expr_stmt|;
name|rtvDesc
operator|.
name|Texture2DArray
operator|.
name|ArraySize
operator|=
literal|1
expr_stmt|;
name|ID3D11RenderTargetView
modifier|*
name|rtv
decl_stmt|;
name|result
operator|=
name|device
operator|->
name|CreateRenderTargetView
argument_list|(
name|mTexture
argument_list|,
operator|&
name|rtvDesc
argument_list|,
operator|&
name|rtv
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|E_OUTOFMEMORY
condition|)
block|{
name|SafeRelease
argument_list|(
name|srv
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
cast|static_cast
argument_list|<
name|RenderTarget
operator|*
argument_list|>
argument_list|(
name|NULL
argument_list|)
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|mRenderTargets
index|[
name|key
index|]
operator|=
operator|new
name|RenderTarget11
argument_list|(
name|mRenderer
argument_list|,
name|rtv
argument_list|,
name|mTexture
argument_list|,
name|srv
argument_list|,
name|getLevelWidth
argument_list|(
name|mipLevel
argument_list|)
argument_list|,
name|getLevelHeight
argument_list|(
name|mipLevel
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// RenderTarget will take ownership of these resources
name|SafeRelease
argument_list|(
name|rtv
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|srv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|mRenderTargets
index|[
name|key
index|]
return|;
block|}
else|else
block|{
return|return
name|NULL
return|;
block|}
block|}
DECL|function|generateMipmaps
name|void
name|TextureStorage11_2DArray
operator|::
name|generateMipmaps
parameter_list|()
block|{
comment|// Base level must already be defined
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|getLevelCount
argument_list|()
condition|;
name|level
operator|++
control|)
block|{
name|invalidateSwizzleCacheLevel
argument_list|(
name|level
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|layer
init|=
literal|0
init|;
name|layer
operator|<
name|mTextureDepth
condition|;
name|layer
operator|++
control|)
block|{
name|gl
operator|::
name|ImageIndex
name|sourceIndex
init|=
name|gl
operator|::
name|ImageIndex
operator|::
name|Make2DArray
argument_list|(
name|level
operator|-
literal|1
argument_list|,
name|layer
argument_list|)
decl_stmt|;
name|gl
operator|::
name|ImageIndex
name|destIndex
init|=
name|gl
operator|::
name|ImageIndex
operator|::
name|Make2DArray
argument_list|(
name|level
argument_list|,
name|layer
argument_list|)
decl_stmt|;
name|RenderTarget11
modifier|*
name|source
init|=
name|RenderTarget11
operator|::
name|makeRenderTarget11
argument_list|(
name|getRenderTarget
argument_list|(
name|sourceIndex
argument_list|)
argument_list|)
decl_stmt|;
name|RenderTarget11
modifier|*
name|dest
init|=
name|RenderTarget11
operator|::
name|makeRenderTarget11
argument_list|(
name|getRenderTarget
argument_list|(
name|destIndex
argument_list|)
argument_list|)
decl_stmt|;
name|generateMipmapLayer
argument_list|(
name|source
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|getSwizzleTexture
name|ID3D11Resource
modifier|*
name|TextureStorage11_2DArray
operator|::
name|getSwizzleTexture
parameter_list|()
block|{
if|if
condition|(
operator|!
name|mSwizzleTexture
condition|)
block|{
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|D3D11_TEXTURE2D_DESC
name|desc
decl_stmt|;
name|desc
operator|.
name|Width
operator|=
name|mTextureWidth
expr_stmt|;
name|desc
operator|.
name|Height
operator|=
name|mTextureHeight
expr_stmt|;
name|desc
operator|.
name|MipLevels
operator|=
name|mMipLevels
expr_stmt|;
name|desc
operator|.
name|ArraySize
operator|=
name|mTextureDepth
expr_stmt|;
name|desc
operator|.
name|Format
operator|=
name|mSwizzleTextureFormat
expr_stmt|;
name|desc
operator|.
name|SampleDesc
operator|.
name|Count
operator|=
literal|1
expr_stmt|;
name|desc
operator|.
name|SampleDesc
operator|.
name|Quality
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|Usage
operator|=
name|D3D11_USAGE_DEFAULT
expr_stmt|;
name|desc
operator|.
name|BindFlags
operator|=
name|D3D11_BIND_SHADER_RESOURCE
operator||
name|D3D11_BIND_RENDER_TARGET
expr_stmt|;
name|desc
operator|.
name|CPUAccessFlags
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateTexture2D
argument_list|(
operator|&
name|desc
argument_list|,
name|NULL
argument_list|,
operator|&
name|mSwizzleTexture
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|E_OUTOFMEMORY
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
cast|static_cast
argument_list|<
name|ID3D11Texture2D
operator|*
argument_list|>
argument_list|(
name|NULL
argument_list|)
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|mSwizzleTexture
return|;
block|}
DECL|function|getSwizzleRenderTarget
name|ID3D11RenderTargetView
modifier|*
name|TextureStorage11_2DArray
operator|::
name|getSwizzleRenderTarget
parameter_list|(
name|int
name|mipLevel
parameter_list|)
block|{
if|if
condition|(
name|mipLevel
operator|>=
literal|0
operator|&&
name|mipLevel
operator|<
name|getLevelCount
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|mSwizzleRenderTargets
index|[
name|mipLevel
index|]
condition|)
block|{
name|ID3D11Resource
modifier|*
name|swizzleTexture
init|=
name|getSwizzleTexture
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|swizzleTexture
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|D3D11_RENDER_TARGET_VIEW_DESC
name|rtvDesc
decl_stmt|;
name|rtvDesc
operator|.
name|Format
operator|=
name|mSwizzleRenderTargetFormat
expr_stmt|;
name|rtvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_RTV_DIMENSION_TEXTURE2DARRAY
expr_stmt|;
name|rtvDesc
operator|.
name|Texture2DArray
operator|.
name|MipSlice
operator|=
name|mTopLevel
operator|+
name|mipLevel
expr_stmt|;
name|rtvDesc
operator|.
name|Texture2DArray
operator|.
name|FirstArraySlice
operator|=
literal|0
expr_stmt|;
name|rtvDesc
operator|.
name|Texture2DArray
operator|.
name|ArraySize
operator|=
name|mTextureDepth
expr_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateRenderTargetView
argument_list|(
name|mSwizzleTexture
argument_list|,
operator|&
name|rtvDesc
argument_list|,
operator|&
name|mSwizzleRenderTargets
index|[
name|mipLevel
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|E_OUTOFMEMORY
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
cast|static_cast
argument_list|<
name|ID3D11RenderTargetView
operator|*
argument_list|>
argument_list|(
name|NULL
argument_list|)
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|mSwizzleRenderTargets
index|[
name|mipLevel
index|]
return|;
block|}
else|else
block|{
return|return
name|NULL
return|;
block|}
block|}
block|}
end_namespace
end_unit
