begin_unit
begin_include
include|#
directive|include
file|"precompiled.h"
end_include
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2012-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Renderer11.cpp: Implements a back-end specific class for the D3D11 renderer.
end_comment
begin_include
include|#
directive|include
file|"libGLESv2/main.h"
end_include
begin_include
include|#
directive|include
file|"common/utilities.h"
end_include
begin_include
include|#
directive|include
file|"common/platform.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Buffer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/FramebufferAttachment.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/ProgramBinary.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Framebuffer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/TextureD3D.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/d3d11/Renderer11.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/d3d11/RenderTarget11.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/d3d11/renderer11_utils.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/d3d11/formatutils11.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/d3d11/ShaderExecutable11.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/d3d11/SwapChain11.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/d3d11/Image11.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/d3d11/VertexBuffer11.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/d3d11/IndexBuffer11.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/d3d11/Buffer11.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/VertexDataManager.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/IndexDataManager.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/d3d11/TextureStorage11.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/d3d11/Query11.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/d3d11/Fence11.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/d3d11/Blit11.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/d3d11/Clear11.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/d3d11/PixelTransfer11.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/d3d11/VertexArray11.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/d3d11/Buffer11.h"
end_include
begin_include
include|#
directive|include
file|"libEGL/Display.h"
end_include
begin_comment
comment|// Enable ANGLE_SKIP_DXGI_1_2_CHECK if there is not a possibility of using cross-process
end_comment
begin_comment
comment|// HWNDs or the Windows 7 Platform Update (KB2670838) is expected to be installed.
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|ANGLE_SKIP_DXGI_1_2_CHECK
end_ifndef
begin_define
DECL|macro|ANGLE_SKIP_DXGI_1_2_CHECK
define|#
directive|define
name|ANGLE_SKIP_DXGI_1_2_CHECK
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|_DEBUG
end_ifdef
begin_comment
comment|// this flag enables suppressing some spurious warnings that pop up in certain WebGL samples
end_comment
begin_comment
comment|// and conformance tests. to enable all warnings, remove this define.
end_comment
begin_define
DECL|macro|ANGLE_SUPPRESS_D3D11_HAZARD_WARNINGS
define|#
directive|define
name|ANGLE_SUPPRESS_D3D11_HAZARD_WARNINGS
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D11_PS_INPUT_REGISTER_COUNT
end_ifndef
begin_define
DECL|macro|D3D11_PS_INPUT_REGISTER_COUNT
define|#
directive|define
name|D3D11_PS_INPUT_REGISTER_COUNT
value|32
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D10_1_VS_OUTPUT_REGISTER_COUNT
end_ifndef
begin_define
DECL|macro|D3D10_1_VS_OUTPUT_REGISTER_COUNT
define|#
directive|define
name|D3D10_1_VS_OUTPUT_REGISTER_COUNT
value|32
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT
end_ifndef
begin_define
DECL|macro|D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT
define|#
directive|define
name|D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT
value|14
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D11_SO_BUFFER_SLOT_COUNT
end_ifndef
begin_define
DECL|macro|D3D11_SO_BUFFER_SLOT_COUNT
define|#
directive|define
name|D3D11_SO_BUFFER_SLOT_COUNT
value|4
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D10_1_SO_BUFFER_SLOT_COUNT
end_ifndef
begin_define
DECL|macro|D3D10_1_SO_BUFFER_SLOT_COUNT
define|#
directive|define
name|D3D10_1_SO_BUFFER_SLOT_COUNT
value|4
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D11_REQ_CONSTANT_BUFFER_ELEMENT_COUNT
end_ifndef
begin_define
DECL|macro|D3D11_REQ_CONSTANT_BUFFER_ELEMENT_COUNT
define|#
directive|define
name|D3D11_REQ_CONSTANT_BUFFER_ELEMENT_COUNT
value|4096
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D11_REQ_DRAWINDEXED_INDEX_COUNT_2_TO_EXP
end_ifndef
begin_define
DECL|macro|D3D11_REQ_DRAWINDEXED_INDEX_COUNT_2_TO_EXP
define|#
directive|define
name|D3D11_REQ_DRAWINDEXED_INDEX_COUNT_2_TO_EXP
value|32
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D11_REQ_DRAW_VERTEX_COUNT_2_TO_EXP
end_ifndef
begin_define
DECL|macro|D3D11_REQ_DRAW_VERTEX_COUNT_2_TO_EXP
define|#
directive|define
name|D3D11_REQ_DRAW_VERTEX_COUNT_2_TO_EXP
value|32
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_namespace
DECL|namespace|rx
namespace|namespace
name|rx
block|{
DECL|member|RenderTargetFormats
specifier|static
specifier|const
name|DXGI_FORMAT
name|RenderTargetFormats
index|[]
init|=
block|{
name|DXGI_FORMAT_B8G8R8A8_UNORM
block|,
name|DXGI_FORMAT_R8G8B8A8_UNORM
block|}
decl_stmt|;
DECL|member|DepthStencilFormats
specifier|static
specifier|const
name|DXGI_FORMAT
name|DepthStencilFormats
index|[]
init|=
block|{
name|DXGI_FORMAT_UNKNOWN
block|,
name|DXGI_FORMAT_D24_UNORM_S8_UINT
block|,
name|DXGI_FORMAT_D16_UNORM
block|}
decl_stmt|;
enum|enum
block|{
DECL|enumerator|MAX_TEXTURE_IMAGE_UNITS_VTF_SM4
name|MAX_TEXTURE_IMAGE_UNITS_VTF_SM4
init|=
literal|16
block|}
enum|;
DECL|function|Renderer11
name|Renderer11
operator|::
name|Renderer11
parameter_list|(
name|egl
operator|::
name|Display
modifier|*
name|display
parameter_list|,
name|EGLNativeDisplayType
name|hDc
parameter_list|,
name|EGLint
name|requestedDisplay
parameter_list|)
member_init_list|:
name|Renderer
argument_list|(
name|display
argument_list|)
member_init_list|,
name|mDc
argument_list|(
name|hDc
argument_list|)
member_init_list|,
name|mRequestedDisplay
argument_list|(
name|requestedDisplay
argument_list|)
block|{
name|mVertexDataManager
operator|=
name|NULL
expr_stmt|;
name|mIndexDataManager
operator|=
name|NULL
expr_stmt|;
name|mLineLoopIB
operator|=
name|NULL
expr_stmt|;
name|mTriangleFanIB
operator|=
name|NULL
expr_stmt|;
name|mBlit
operator|=
name|NULL
expr_stmt|;
name|mPixelTransfer
operator|=
name|NULL
expr_stmt|;
name|mClear
operator|=
name|NULL
expr_stmt|;
name|mSyncQuery
operator|=
name|NULL
expr_stmt|;
name|mD3d11Module
operator|=
name|NULL
expr_stmt|;
name|mDxgiModule
operator|=
name|NULL
expr_stmt|;
name|mDeviceLost
operator|=
literal|false
expr_stmt|;
name|mMaxSupportedSamples
operator|=
literal|0
expr_stmt|;
name|mDevice
operator|=
name|NULL
expr_stmt|;
name|mDeviceContext
operator|=
name|NULL
expr_stmt|;
name|mDxgiAdapter
operator|=
name|NULL
expr_stmt|;
name|mDxgiFactory
operator|=
name|NULL
expr_stmt|;
name|mDriverConstantBufferVS
operator|=
name|NULL
expr_stmt|;
name|mDriverConstantBufferPS
operator|=
name|NULL
expr_stmt|;
name|mAppliedVertexShader
operator|=
name|NULL
expr_stmt|;
name|mAppliedGeometryShader
operator|=
name|NULL
expr_stmt|;
name|mCurPointGeometryShader
operator|=
name|NULL
expr_stmt|;
name|mAppliedPixelShader
operator|=
name|NULL
expr_stmt|;
block|}
DECL|function|~Renderer11
name|Renderer11
operator|::
name|~
name|Renderer11
parameter_list|()
block|{
name|release
argument_list|()
expr_stmt|;
block|}
DECL|function|makeRenderer11
name|Renderer11
modifier|*
name|Renderer11
operator|::
name|makeRenderer11
parameter_list|(
name|Renderer
modifier|*
name|renderer
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|HAS_DYNAMIC_TYPE
argument_list|(
name|rx
operator|::
name|Renderer11
operator|*
argument_list|,
name|renderer
argument_list|)
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|rx
operator|::
name|Renderer11
operator|*
argument_list|>
argument_list|(
name|renderer
argument_list|)
return|;
block|}
ifndef|#
directive|ifndef
name|__d3d11_1_h__
DECL|macro|D3D11_MESSAGE_ID_DEVICE_DRAW_RENDERTARGETVIEW_NOT_SET
define|#
directive|define
name|D3D11_MESSAGE_ID_DEVICE_DRAW_RENDERTARGETVIEW_NOT_SET
value|((D3D11_MESSAGE_ID)3146081)
endif|#
directive|endif
DECL|function|initialize
name|EGLint
name|Renderer11
operator|::
name|initialize
parameter_list|()
block|{
if|if
condition|(
operator|!
name|mCompiler
operator|.
name|initialize
argument_list|()
condition|)
block|{
return|return
name|EGL_NOT_INITIALIZED
return|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ANGLE_PLATFORM_WINRT
argument_list|)
name|mDxgiModule
operator|=
name|LoadLibrary
argument_list|(
name|TEXT
argument_list|(
literal|"dxgi.dll"
argument_list|)
argument_list|)
expr_stmt|;
name|mD3d11Module
operator|=
name|LoadLibrary
argument_list|(
name|TEXT
argument_list|(
literal|"d3d11.dll"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mD3d11Module
operator|==
name|NULL
operator|||
name|mDxgiModule
operator|==
name|NULL
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not load D3D11 or DXGI library - aborting!\n"
argument_list|)
expr_stmt|;
return|return
name|EGL_NOT_INITIALIZED
return|;
block|}
comment|// create the D3D11 device
name|ASSERT
argument_list|(
name|mDevice
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|PFN_D3D11_CREATE_DEVICE
name|D3D11CreateDevice
init|=
operator|(
name|PFN_D3D11_CREATE_DEVICE
operator|)
name|GetProcAddress
argument_list|(
name|mD3d11Module
argument_list|,
literal|"D3D11CreateDevice"
argument_list|)
decl_stmt|;
if|if
condition|(
name|D3D11CreateDevice
operator|==
name|NULL
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not retrieve D3D11CreateDevice address - aborting!\n"
argument_list|)
expr_stmt|;
return|return
name|EGL_NOT_INITIALIZED
return|;
block|}
endif|#
directive|endif
name|D3D_FEATURE_LEVEL
name|featureLevels
index|[]
init|=
block|{
name|D3D_FEATURE_LEVEL_11_0
block|,
name|D3D_FEATURE_LEVEL_10_1
block|,
name|D3D_FEATURE_LEVEL_10_0
block|,
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ANGLE_ENABLE_D3D9
argument_list|)
name|D3D_FEATURE_LEVEL_9_3
block|,
name|D3D_FEATURE_LEVEL_9_2
block|,
name|D3D_FEATURE_LEVEL_9_1
block|,
endif|#
directive|endif
block|}
decl_stmt|;
name|D3D_DRIVER_TYPE
name|driverType
init|=
name|D3D_DRIVER_TYPE_HARDWARE
decl_stmt|;
if|if
condition|(
name|mRequestedDisplay
operator|==
name|EGL_PLATFORM_ANGLE_TYPE_D3D11_WARP_ANGLE
condition|)
block|{
name|driverType
operator|=
name|D3D_DRIVER_TYPE_WARP
expr_stmt|;
block|}
name|HRESULT
name|result
init|=
name|S_OK
decl_stmt|;
ifdef|#
directive|ifdef
name|_DEBUG
name|result
operator|=
name|D3D11CreateDevice
argument_list|(
name|NULL
argument_list|,
name|driverType
argument_list|,
name|NULL
argument_list|,
name|D3D11_CREATE_DEVICE_DEBUG
argument_list|,
name|featureLevels
argument_list|,
name|ArraySize
argument_list|(
name|featureLevels
argument_list|)
argument_list|,
name|D3D11_SDK_VERSION
argument_list|,
operator|&
name|mDevice
argument_list|,
operator|&
name|mFeatureLevel
argument_list|,
operator|&
name|mDeviceContext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mDevice
operator|||
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed creating Debug D3D11 device - falling back to release runtime.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mDevice
operator|||
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
endif|#
directive|endif
block|{
name|result
operator|=
name|D3D11CreateDevice
argument_list|(
name|NULL
argument_list|,
name|driverType
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|featureLevels
argument_list|,
name|ArraySize
argument_list|(
name|featureLevels
argument_list|)
argument_list|,
name|D3D11_SDK_VERSION
argument_list|,
operator|&
name|mDevice
argument_list|,
operator|&
name|mFeatureLevel
argument_list|,
operator|&
name|mDeviceContext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mDevice
operator|||
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not create D3D11 device - aborting!\n"
argument_list|)
expr_stmt|;
return|return
name|EGL_NOT_INITIALIZED
return|;
comment|// Cleanup done by destructor through glDestroyRenderer
block|}
block|}
if|#
directive|if
operator|!
name|ANGLE_SKIP_DXGI_1_2_CHECK
operator|&&
operator|!
name|defined
argument_list|(
name|ANGLE_PLATFORM_WINRT
argument_list|)
comment|// In order to create a swap chain for an HWND owned by another process, DXGI 1.2 is required.
comment|// The easiest way to check is to query for a IDXGIDevice2.
name|bool
name|requireDXGI1_2
init|=
literal|false
decl_stmt|;
name|HWND
name|hwnd
init|=
name|WindowFromDC
argument_list|(
name|mDc
argument_list|)
decl_stmt|;
if|if
condition|(
name|hwnd
condition|)
block|{
name|DWORD
name|currentProcessId
init|=
name|GetCurrentProcessId
argument_list|()
decl_stmt|;
name|DWORD
name|wndProcessId
decl_stmt|;
name|GetWindowThreadProcessId
argument_list|(
name|hwnd
argument_list|,
operator|&
name|wndProcessId
argument_list|)
expr_stmt|;
name|requireDXGI1_2
operator|=
operator|(
name|currentProcessId
operator|!=
name|wndProcessId
operator|)
expr_stmt|;
block|}
else|else
block|{
name|requireDXGI1_2
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|requireDXGI1_2
condition|)
block|{
name|IDXGIDevice2
modifier|*
name|dxgiDevice2
init|=
name|NULL
decl_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|QueryInterface
argument_list|(
name|__uuidof
argument_list|(
name|IDXGIDevice2
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dxgiDevice2
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"DXGI 1.2 required to present to HWNDs owned by another process.\n"
argument_list|)
expr_stmt|;
return|return
name|EGL_NOT_INITIALIZED
return|;
block|}
name|SafeRelease
argument_list|(
name|dxgiDevice2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ANGLE_PLATFORM_WINRT
argument_list|)
name|IDXGIDevice
modifier|*
name|dxgiDevice
init|=
name|NULL
decl_stmt|;
else|#
directive|else
name|IDXGIDevice1
modifier|*
name|dxgiDevice
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
name|result
operator|=
name|mDevice
operator|->
name|QueryInterface
argument_list|(
name|IID_PPV_ARGS
argument_list|(
operator|&
name|dxgiDevice
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not query DXGI device - aborting!\n"
argument_list|)
expr_stmt|;
return|return
name|EGL_NOT_INITIALIZED
return|;
block|}
name|result
operator|=
name|dxgiDevice
operator|->
name|GetParent
argument_list|(
name|__uuidof
argument_list|(
name|IDXGIAdapter
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|mDxgiAdapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not retrieve DXGI adapter - aborting!\n"
argument_list|)
expr_stmt|;
return|return
name|EGL_NOT_INITIALIZED
return|;
block|}
name|SafeRelease
argument_list|(
name|dxgiDevice
argument_list|)
expr_stmt|;
name|mDxgiAdapter
operator|->
name|GetDesc
argument_list|(
operator|&
name|mAdapterDescription
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|mDescription
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mDescription
argument_list|)
argument_list|)
expr_stmt|;
name|wcstombs
argument_list|(
name|mDescription
argument_list|,
name|mAdapterDescription
operator|.
name|Description
argument_list|,
sizeof|sizeof
argument_list|(
name|mDescription
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|mDxgiAdapter
operator|->
name|GetParent
argument_list|(
name|__uuidof
argument_list|(
name|IDXGIFactory
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|mDxgiFactory
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mDxgiFactory
operator|||
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not create DXGI factory - aborting!\n"
argument_list|)
expr_stmt|;
return|return
name|EGL_NOT_INITIALIZED
return|;
block|}
comment|// Disable some spurious D3D11 debug warnings to prevent them from flooding the output log
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__MINGW32__
argument_list|)
operator|&&
name|defined
argument_list|(
name|ANGLE_SUPPRESS_D3D11_HAZARD_WARNINGS
argument_list|)
operator|&&
name|defined
argument_list|(
name|_DEBUG
argument_list|)
name|ID3D11InfoQueue
modifier|*
name|infoQueue
decl_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|QueryInterface
argument_list|(
name|__uuidof
argument_list|(
name|ID3D11InfoQueue
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|infoQueue
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|D3D11_MESSAGE_ID
name|hideMessages
index|[]
init|=
block|{
name|D3D11_MESSAGE_ID_DEVICE_DRAW_RENDERTARGETVIEW_NOT_SET
block|}
decl_stmt|;
name|D3D11_INFO_QUEUE_FILTER
name|filter
init|=
block|{
literal|0
block|}
decl_stmt|;
name|filter
operator|.
name|DenyList
operator|.
name|NumIDs
operator|=
name|ArraySize
argument_list|(
name|hideMessages
argument_list|)
expr_stmt|;
name|filter
operator|.
name|DenyList
operator|.
name|pIDList
operator|=
name|hideMessages
expr_stmt|;
name|infoQueue
operator|->
name|AddStorageFilterEntries
argument_list|(
operator|&
name|filter
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|infoQueue
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|mMaxSupportedSamples
operator|=
literal|0
expr_stmt|;
specifier|const
name|d3d11
operator|::
name|DXGIFormatSet
modifier|&
name|dxgiFormats
init|=
name|d3d11
operator|::
name|GetAllUsedDXGIFormats
argument_list|()
decl_stmt|;
for|for
control|(
name|d3d11
operator|::
name|DXGIFormatSet
operator|::
name|const_iterator
name|i
init|=
name|dxgiFormats
operator|.
name|begin
argument_list|()
init|;
name|i
operator|!=
name|dxgiFormats
operator|.
name|end
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|MultisampleSupportInfo
name|support
init|=
name|getMultisampleSupportInfo
argument_list|(
operator|*
name|i
argument_list|)
decl_stmt|;
name|mMultisampleSupportMap
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
operator|*
name|i
argument_list|,
name|support
argument_list|)
argument_list|)
expr_stmt|;
name|mMaxSupportedSamples
operator|=
name|std
operator|::
name|max
argument_list|(
name|mMaxSupportedSamples
argument_list|,
name|support
operator|.
name|maxSupportedSamples
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ANGLE_PLATFORM_WINRT
argument_list|)
specifier|static
name|wchar_t
modifier|*
name|qt_d3dcreate_multihreaded_var
init|=
name|_wgetenv
argument_list|(
literal|L"QT_D3DCREATE_MULTITHREADED"
argument_list|)
decl_stmt|;
if|if
condition|(
name|qt_d3dcreate_multihreaded_var
operator|&&
name|wcsstr
argument_list|(
name|qt_d3dcreate_multihreaded_var
argument_list|,
literal|L"1"
argument_list|)
condition|)
block|{
name|ID3D10Multithread
modifier|*
name|multithread
decl_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|QueryInterface
argument_list|(
name|IID_PPV_ARGS
argument_list|(
operator|&
name|multithread
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|multithread
operator|->
name|SetMultithreadProtected
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|multithread
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|initializeDevice
argument_list|()
expr_stmt|;
return|return
name|EGL_SUCCESS
return|;
block|}
comment|// do any one-time device initialization
comment|// NOTE: this is also needed after a device lost/reset
comment|// to reset the scene status and ensure the default states are reset.
DECL|function|initializeDevice
name|void
name|Renderer11
operator|::
name|initializeDevice
parameter_list|()
block|{
name|mStateCache
operator|.
name|initialize
argument_list|(
name|mDevice
argument_list|)
expr_stmt|;
name|mInputLayoutCache
operator|.
name|initialize
argument_list|(
name|mDevice
argument_list|,
name|mDeviceContext
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|mVertexDataManager
operator|&&
operator|!
name|mIndexDataManager
argument_list|)
expr_stmt|;
name|mVertexDataManager
operator|=
operator|new
name|VertexDataManager
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|mIndexDataManager
operator|=
operator|new
name|IndexDataManager
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|mBlit
argument_list|)
expr_stmt|;
name|mBlit
operator|=
operator|new
name|Blit11
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|mClear
argument_list|)
expr_stmt|;
name|mClear
operator|=
operator|new
name|Clear11
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|mPixelTransfer
argument_list|)
expr_stmt|;
name|mPixelTransfer
operator|=
operator|new
name|PixelTransfer11
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|markAllStateDirty
argument_list|()
expr_stmt|;
block|}
DECL|function|generateConfigs
name|int
name|Renderer11
operator|::
name|generateConfigs
parameter_list|(
name|ConfigDesc
modifier|*
modifier|*
name|configDescList
parameter_list|)
block|{
name|unsigned
name|int
name|numRenderFormats
init|=
name|ArraySize
argument_list|(
name|RenderTargetFormats
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|numDepthFormats
init|=
name|ArraySize
argument_list|(
name|DepthStencilFormats
argument_list|)
decl_stmt|;
operator|(
operator|*
name|configDescList
operator|)
operator|=
operator|new
name|ConfigDesc
index|[
name|numRenderFormats
operator|*
name|numDepthFormats
index|]
expr_stmt|;
name|int
name|numConfigs
init|=
literal|0
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|formatIndex
init|=
literal|0
init|;
name|formatIndex
operator|<
name|numRenderFormats
condition|;
name|formatIndex
operator|++
control|)
block|{
for|for
control|(
name|unsigned
name|int
name|depthStencilIndex
init|=
literal|0
init|;
name|depthStencilIndex
operator|<
name|numDepthFormats
condition|;
name|depthStencilIndex
operator|++
control|)
block|{
name|DXGI_FORMAT
name|renderTargetFormat
init|=
name|RenderTargetFormats
index|[
name|formatIndex
index|]
decl_stmt|;
name|UINT
name|formatSupport
init|=
literal|0
decl_stmt|;
name|HRESULT
name|result
init|=
name|mDevice
operator|->
name|CheckFormatSupport
argument_list|(
name|renderTargetFormat
argument_list|,
operator|&
name|formatSupport
argument_list|)
decl_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
operator|&&
operator|(
name|formatSupport
operator|&
name|D3D11_FORMAT_SUPPORT_RENDER_TARGET
operator|)
condition|)
block|{
name|DXGI_FORMAT
name|depthStencilFormat
init|=
name|DepthStencilFormats
index|[
name|depthStencilIndex
index|]
decl_stmt|;
name|bool
name|depthStencilFormatOK
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|depthStencilFormat
operator|!=
name|DXGI_FORMAT_UNKNOWN
condition|)
block|{
name|UINT
name|depthStencilSupport
init|=
literal|0
decl_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|CheckFormatSupport
argument_list|(
name|depthStencilFormat
argument_list|,
operator|&
name|depthStencilSupport
argument_list|)
expr_stmt|;
name|depthStencilFormatOK
operator|=
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
operator|&&
operator|(
name|depthStencilSupport
operator|&
name|D3D11_FORMAT_SUPPORT_DEPTH_STENCIL
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|depthStencilFormatOK
condition|)
block|{
name|ConfigDesc
name|newConfig
decl_stmt|;
name|newConfig
operator|.
name|renderTargetFormat
operator|=
name|d3d11_gl
operator|::
name|GetInternalFormat
argument_list|(
name|renderTargetFormat
argument_list|)
expr_stmt|;
name|newConfig
operator|.
name|depthStencilFormat
operator|=
name|d3d11_gl
operator|::
name|GetInternalFormat
argument_list|(
name|depthStencilFormat
argument_list|)
expr_stmt|;
name|newConfig
operator|.
name|multiSample
operator|=
literal|0
expr_stmt|;
comment|// FIXME: enumerate multi-sampling
name|newConfig
operator|.
name|fastConfig
operator|=
literal|true
expr_stmt|;
comment|// Assume all DX11 format conversions to be fast
name|newConfig
operator|.
name|es3Capable
operator|=
literal|true
expr_stmt|;
operator|(
operator|*
name|configDescList
operator|)
index|[
name|numConfigs
operator|++
index|]
operator|=
name|newConfig
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|numConfigs
return|;
block|}
DECL|function|deleteConfigs
name|void
name|Renderer11
operator|::
name|deleteConfigs
parameter_list|(
name|ConfigDesc
modifier|*
name|configDescList
parameter_list|)
block|{
operator|delete
index|[]
operator|(
name|configDescList
operator|)
expr_stmt|;
block|}
DECL|function|sync
name|void
name|Renderer11
operator|::
name|sync
parameter_list|(
name|bool
name|block
parameter_list|)
block|{
if|if
condition|(
name|block
condition|)
block|{
name|HRESULT
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|mSyncQuery
condition|)
block|{
name|D3D11_QUERY_DESC
name|queryDesc
decl_stmt|;
name|queryDesc
operator|.
name|Query
operator|=
name|D3D11_QUERY_EVENT
expr_stmt|;
name|queryDesc
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|CreateQuery
argument_list|(
operator|&
name|queryDesc
argument_list|,
operator|&
name|mSyncQuery
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mDeviceContext
operator|->
name|End
argument_list|(
name|mSyncQuery
argument_list|)
expr_stmt|;
name|mDeviceContext
operator|->
name|Flush
argument_list|()
expr_stmt|;
do|do
block|{
name|result
operator|=
name|mDeviceContext
operator|->
name|GetData
argument_list|(
name|mSyncQuery
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|D3D11_ASYNC_GETDATA_DONOTFLUSH
argument_list|)
expr_stmt|;
comment|// Keep polling, but allow other threads to do something useful first
name|Sleep
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|testDeviceLost
argument_list|(
literal|true
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
do|while
condition|(
name|result
operator|==
name|S_FALSE
condition|)
do|;
block|}
else|else
block|{
name|mDeviceContext
operator|->
name|Flush
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|createSwapChain
name|SwapChain
modifier|*
name|Renderer11
operator|::
name|createSwapChain
parameter_list|(
name|EGLNativeWindowType
name|window
parameter_list|,
name|HANDLE
name|shareHandle
parameter_list|,
name|GLenum
name|backBufferFormat
parameter_list|,
name|GLenum
name|depthBufferFormat
parameter_list|)
block|{
return|return
operator|new
name|rx
operator|::
name|SwapChain11
argument_list|(
name|this
argument_list|,
name|window
argument_list|,
name|shareHandle
argument_list|,
name|backBufferFormat
argument_list|,
name|depthBufferFormat
argument_list|)
return|;
block|}
DECL|function|generateSwizzle
name|void
name|Renderer11
operator|::
name|generateSwizzle
parameter_list|(
name|gl
operator|::
name|Texture
modifier|*
name|texture
parameter_list|)
block|{
if|if
condition|(
name|texture
condition|)
block|{
name|TextureStorageInterface
modifier|*
name|texStorage
init|=
name|texture
operator|->
name|getNativeTexture
argument_list|()
decl_stmt|;
if|if
condition|(
name|texStorage
condition|)
block|{
name|TextureStorage11
modifier|*
name|storage11
init|=
name|TextureStorage11
operator|::
name|makeTextureStorage11
argument_list|(
name|texStorage
operator|->
name|getStorageInstance
argument_list|()
argument_list|)
decl_stmt|;
name|storage11
operator|->
name|generateSwizzles
argument_list|(
name|texture
operator|->
name|getSamplerState
argument_list|()
operator|.
name|swizzleRed
argument_list|,
name|texture
operator|->
name|getSamplerState
argument_list|()
operator|.
name|swizzleGreen
argument_list|,
name|texture
operator|->
name|getSamplerState
argument_list|()
operator|.
name|swizzleBlue
argument_list|,
name|texture
operator|->
name|getSamplerState
argument_list|()
operator|.
name|swizzleAlpha
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|setSamplerState
name|void
name|Renderer11
operator|::
name|setSamplerState
parameter_list|(
name|gl
operator|::
name|SamplerType
name|type
parameter_list|,
name|int
name|index
parameter_list|,
specifier|const
name|gl
operator|::
name|SamplerState
modifier|&
name|samplerState
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|gl
operator|::
name|SAMPLER_PIXEL
condition|)
block|{
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|gl
operator|::
name|MAX_TEXTURE_IMAGE_UNITS
condition|)
block|{
name|ERR
argument_list|(
literal|"Pixel shader sampler index %i is not valid."
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mForceSetPixelSamplerStates
index|[
name|index
index|]
operator|||
name|memcmp
argument_list|(
operator|&
name|samplerState
argument_list|,
operator|&
name|mCurPixelSamplerStates
index|[
name|index
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|gl
operator|::
name|SamplerState
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ID3D11SamplerState
modifier|*
name|dxSamplerState
init|=
name|mStateCache
operator|.
name|getSamplerState
argument_list|(
name|samplerState
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dxSamplerState
condition|)
block|{
name|ERR
argument_list|(
literal|"NULL sampler state returned by RenderStateCache::getSamplerState, setting the default"
literal|"sampler state for pixel shaders at slot %i."
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
name|mDeviceContext
operator|->
name|PSSetSamplers
argument_list|(
name|index
argument_list|,
literal|1
argument_list|,
operator|&
name|dxSamplerState
argument_list|)
expr_stmt|;
name|mCurPixelSamplerStates
index|[
name|index
index|]
operator|=
name|samplerState
expr_stmt|;
block|}
name|mForceSetPixelSamplerStates
index|[
name|index
index|]
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|gl
operator|::
name|SAMPLER_VERTEX
condition|)
block|{
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
operator|(
name|int
operator|)
name|getMaxVertexTextureImageUnits
argument_list|()
condition|)
block|{
name|ERR
argument_list|(
literal|"Vertex shader sampler index %i is not valid."
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mForceSetVertexSamplerStates
index|[
name|index
index|]
operator|||
name|memcmp
argument_list|(
operator|&
name|samplerState
argument_list|,
operator|&
name|mCurVertexSamplerStates
index|[
name|index
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|gl
operator|::
name|SamplerState
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ID3D11SamplerState
modifier|*
name|dxSamplerState
init|=
name|mStateCache
operator|.
name|getSamplerState
argument_list|(
name|samplerState
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dxSamplerState
condition|)
block|{
name|ERR
argument_list|(
literal|"NULL sampler state returned by RenderStateCache::getSamplerState, setting the default"
literal|"sampler state for vertex shaders at slot %i."
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
name|mDeviceContext
operator|->
name|VSSetSamplers
argument_list|(
name|index
argument_list|,
literal|1
argument_list|,
operator|&
name|dxSamplerState
argument_list|)
expr_stmt|;
name|mCurVertexSamplerStates
index|[
name|index
index|]
operator|=
name|samplerState
expr_stmt|;
block|}
name|mForceSetVertexSamplerStates
index|[
name|index
index|]
operator|=
literal|false
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
DECL|function|setTexture
name|void
name|Renderer11
operator|::
name|setTexture
parameter_list|(
name|gl
operator|::
name|SamplerType
name|type
parameter_list|,
name|int
name|index
parameter_list|,
name|gl
operator|::
name|Texture
modifier|*
name|texture
parameter_list|)
block|{
name|ID3D11ShaderResourceView
modifier|*
name|textureSRV
init|=
name|NULL
decl_stmt|;
name|bool
name|forceSetTexture
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|texture
condition|)
block|{
name|TextureStorageInterface
modifier|*
name|texStorage
init|=
name|texture
operator|->
name|getNativeTexture
argument_list|()
decl_stmt|;
if|if
condition|(
name|texStorage
condition|)
block|{
name|TextureStorage11
modifier|*
name|storage11
init|=
name|TextureStorage11
operator|::
name|makeTextureStorage11
argument_list|(
name|texStorage
operator|->
name|getStorageInstance
argument_list|()
argument_list|)
decl_stmt|;
name|gl
operator|::
name|SamplerState
name|samplerState
decl_stmt|;
name|texture
operator|->
name|getSamplerStateWithNativeOffset
argument_list|(
operator|&
name|samplerState
argument_list|)
expr_stmt|;
name|textureSRV
operator|=
name|storage11
operator|->
name|getSRV
argument_list|(
name|samplerState
argument_list|)
expr_stmt|;
block|}
comment|// If we get NULL back from getSRV here, something went wrong in the texture class and we're unexpectedly
comment|// missing the shader resource view
name|ASSERT
argument_list|(
name|textureSRV
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|forceSetTexture
operator|=
name|texture
operator|->
name|hasDirtyImages
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|gl
operator|::
name|SAMPLER_PIXEL
condition|)
block|{
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|gl
operator|::
name|MAX_TEXTURE_IMAGE_UNITS
condition|)
block|{
name|ERR
argument_list|(
literal|"Pixel shader sampler index %i is not valid."
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|forceSetTexture
operator|||
name|mCurPixelSRVs
index|[
name|index
index|]
operator|!=
name|textureSRV
condition|)
block|{
name|mDeviceContext
operator|->
name|PSSetShaderResources
argument_list|(
name|index
argument_list|,
literal|1
argument_list|,
operator|&
name|textureSRV
argument_list|)
expr_stmt|;
block|}
name|mCurPixelSRVs
index|[
name|index
index|]
operator|=
name|textureSRV
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|gl
operator|::
name|SAMPLER_VERTEX
condition|)
block|{
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
operator|(
name|int
operator|)
name|getMaxVertexTextureImageUnits
argument_list|()
condition|)
block|{
name|ERR
argument_list|(
literal|"Vertex shader sampler index %i is not valid."
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|forceSetTexture
operator|||
name|mCurVertexSRVs
index|[
name|index
index|]
operator|!=
name|textureSRV
condition|)
block|{
name|mDeviceContext
operator|->
name|VSSetShaderResources
argument_list|(
name|index
argument_list|,
literal|1
argument_list|,
operator|&
name|textureSRV
argument_list|)
expr_stmt|;
block|}
name|mCurVertexSRVs
index|[
name|index
index|]
operator|=
name|textureSRV
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
DECL|function|setUniformBuffers
name|bool
name|Renderer11
operator|::
name|setUniformBuffers
parameter_list|(
specifier|const
name|gl
operator|::
name|Buffer
modifier|*
name|vertexUniformBuffers
index|[]
parameter_list|,
specifier|const
name|gl
operator|::
name|Buffer
modifier|*
name|fragmentUniformBuffers
index|[]
parameter_list|)
block|{
for|for
control|(
name|unsigned
name|int
name|uniformBufferIndex
init|=
literal|0
init|;
name|uniformBufferIndex
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_VERTEX_SHADER_UNIFORM_BUFFERS
condition|;
name|uniformBufferIndex
operator|++
control|)
block|{
specifier|const
name|gl
operator|::
name|Buffer
modifier|*
name|uniformBuffer
init|=
name|vertexUniformBuffers
index|[
name|uniformBufferIndex
index|]
decl_stmt|;
if|if
condition|(
name|uniformBuffer
condition|)
block|{
name|Buffer11
modifier|*
name|bufferStorage
init|=
name|Buffer11
operator|::
name|makeBuffer11
argument_list|(
name|uniformBuffer
operator|->
name|getImplementation
argument_list|()
argument_list|)
decl_stmt|;
name|ID3D11Buffer
modifier|*
name|constantBuffer
init|=
name|bufferStorage
operator|->
name|getBuffer
argument_list|(
name|BUFFER_USAGE_UNIFORM
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|constantBuffer
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|mCurrentConstantBufferVS
index|[
name|uniformBufferIndex
index|]
operator|!=
name|bufferStorage
operator|->
name|getSerial
argument_list|()
condition|)
block|{
name|mDeviceContext
operator|->
name|VSSetConstantBuffers
argument_list|(
name|getReservedVertexUniformBuffers
argument_list|()
operator|+
name|uniformBufferIndex
argument_list|,
literal|1
argument_list|,
operator|&
name|constantBuffer
argument_list|)
expr_stmt|;
name|mCurrentConstantBufferVS
index|[
name|uniformBufferIndex
index|]
operator|=
name|bufferStorage
operator|->
name|getSerial
argument_list|()
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|unsigned
name|int
name|uniformBufferIndex
init|=
literal|0
init|;
name|uniformBufferIndex
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_FRAGMENT_SHADER_UNIFORM_BUFFERS
condition|;
name|uniformBufferIndex
operator|++
control|)
block|{
specifier|const
name|gl
operator|::
name|Buffer
modifier|*
name|uniformBuffer
init|=
name|fragmentUniformBuffers
index|[
name|uniformBufferIndex
index|]
decl_stmt|;
if|if
condition|(
name|uniformBuffer
condition|)
block|{
name|Buffer11
modifier|*
name|bufferStorage
init|=
name|Buffer11
operator|::
name|makeBuffer11
argument_list|(
name|uniformBuffer
operator|->
name|getImplementation
argument_list|()
argument_list|)
decl_stmt|;
name|ID3D11Buffer
modifier|*
name|constantBuffer
init|=
name|bufferStorage
operator|->
name|getBuffer
argument_list|(
name|BUFFER_USAGE_UNIFORM
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|constantBuffer
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|mCurrentConstantBufferPS
index|[
name|uniformBufferIndex
index|]
operator|!=
name|bufferStorage
operator|->
name|getSerial
argument_list|()
condition|)
block|{
name|mDeviceContext
operator|->
name|PSSetConstantBuffers
argument_list|(
name|getReservedFragmentUniformBuffers
argument_list|()
operator|+
name|uniformBufferIndex
argument_list|,
literal|1
argument_list|,
operator|&
name|constantBuffer
argument_list|)
expr_stmt|;
name|mCurrentConstantBufferPS
index|[
name|uniformBufferIndex
index|]
operator|=
name|bufferStorage
operator|->
name|getSerial
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|setRasterizerState
name|void
name|Renderer11
operator|::
name|setRasterizerState
parameter_list|(
specifier|const
name|gl
operator|::
name|RasterizerState
modifier|&
name|rasterState
parameter_list|)
block|{
if|if
condition|(
name|mForceSetRasterState
operator|||
name|memcmp
argument_list|(
operator|&
name|rasterState
argument_list|,
operator|&
name|mCurRasterState
argument_list|,
sizeof|sizeof
argument_list|(
name|gl
operator|::
name|RasterizerState
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ID3D11RasterizerState
modifier|*
name|dxRasterState
init|=
name|mStateCache
operator|.
name|getRasterizerState
argument_list|(
name|rasterState
argument_list|,
name|mScissorEnabled
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dxRasterState
condition|)
block|{
name|ERR
argument_list|(
literal|"NULL rasterizer state returned by RenderStateCache::getRasterizerState, setting the default"
literal|"rasterizer state."
argument_list|)
expr_stmt|;
block|}
name|mDeviceContext
operator|->
name|RSSetState
argument_list|(
name|dxRasterState
argument_list|)
expr_stmt|;
name|mCurRasterState
operator|=
name|rasterState
expr_stmt|;
block|}
name|mForceSetRasterState
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|setBlendState
name|void
name|Renderer11
operator|::
name|setBlendState
parameter_list|(
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
parameter_list|,
specifier|const
name|gl
operator|::
name|BlendState
modifier|&
name|blendState
parameter_list|,
specifier|const
name|gl
operator|::
name|ColorF
modifier|&
name|blendColor
parameter_list|,
name|unsigned
name|int
name|sampleMask
parameter_list|)
block|{
if|if
condition|(
name|mForceSetBlendState
operator|||
name|memcmp
argument_list|(
operator|&
name|blendState
argument_list|,
operator|&
name|mCurBlendState
argument_list|,
sizeof|sizeof
argument_list|(
name|gl
operator|::
name|BlendState
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|memcmp
argument_list|(
operator|&
name|blendColor
argument_list|,
operator|&
name|mCurBlendColor
argument_list|,
sizeof|sizeof
argument_list|(
name|gl
operator|::
name|ColorF
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|sampleMask
operator|!=
name|mCurSampleMask
condition|)
block|{
name|ID3D11BlendState
modifier|*
name|dxBlendState
init|=
name|mStateCache
operator|.
name|getBlendState
argument_list|(
name|framebuffer
argument_list|,
name|blendState
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dxBlendState
condition|)
block|{
name|ERR
argument_list|(
literal|"NULL blend state returned by RenderStateCache::getBlendState, setting the default "
literal|"blend state."
argument_list|)
expr_stmt|;
block|}
name|float
name|blendColors
index|[
literal|4
index|]
init|=
block|{
literal|0.0f
block|}
decl_stmt|;
if|if
condition|(
name|blendState
operator|.
name|sourceBlendRGB
operator|!=
name|GL_CONSTANT_ALPHA
operator|&&
name|blendState
operator|.
name|sourceBlendRGB
operator|!=
name|GL_ONE_MINUS_CONSTANT_ALPHA
operator|&&
name|blendState
operator|.
name|destBlendRGB
operator|!=
name|GL_CONSTANT_ALPHA
operator|&&
name|blendState
operator|.
name|destBlendRGB
operator|!=
name|GL_ONE_MINUS_CONSTANT_ALPHA
condition|)
block|{
name|blendColors
index|[
literal|0
index|]
operator|=
name|blendColor
operator|.
name|red
expr_stmt|;
name|blendColors
index|[
literal|1
index|]
operator|=
name|blendColor
operator|.
name|green
expr_stmt|;
name|blendColors
index|[
literal|2
index|]
operator|=
name|blendColor
operator|.
name|blue
expr_stmt|;
name|blendColors
index|[
literal|3
index|]
operator|=
name|blendColor
operator|.
name|alpha
expr_stmt|;
block|}
else|else
block|{
name|blendColors
index|[
literal|0
index|]
operator|=
name|blendColor
operator|.
name|alpha
expr_stmt|;
name|blendColors
index|[
literal|1
index|]
operator|=
name|blendColor
operator|.
name|alpha
expr_stmt|;
name|blendColors
index|[
literal|2
index|]
operator|=
name|blendColor
operator|.
name|alpha
expr_stmt|;
name|blendColors
index|[
literal|3
index|]
operator|=
name|blendColor
operator|.
name|alpha
expr_stmt|;
block|}
name|mDeviceContext
operator|->
name|OMSetBlendState
argument_list|(
name|dxBlendState
argument_list|,
name|blendColors
argument_list|,
name|sampleMask
argument_list|)
expr_stmt|;
name|mCurBlendState
operator|=
name|blendState
expr_stmt|;
name|mCurBlendColor
operator|=
name|blendColor
expr_stmt|;
name|mCurSampleMask
operator|=
name|sampleMask
expr_stmt|;
block|}
name|mForceSetBlendState
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|setDepthStencilState
name|void
name|Renderer11
operator|::
name|setDepthStencilState
parameter_list|(
specifier|const
name|gl
operator|::
name|DepthStencilState
modifier|&
name|depthStencilState
parameter_list|,
name|int
name|stencilRef
parameter_list|,
name|int
name|stencilBackRef
parameter_list|,
name|bool
name|frontFaceCCW
parameter_list|)
block|{
if|if
condition|(
name|mForceSetDepthStencilState
operator|||
name|memcmp
argument_list|(
operator|&
name|depthStencilState
argument_list|,
operator|&
name|mCurDepthStencilState
argument_list|,
sizeof|sizeof
argument_list|(
name|gl
operator|::
name|DepthStencilState
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|stencilRef
operator|!=
name|mCurStencilRef
operator|||
name|stencilBackRef
operator|!=
name|mCurStencilBackRef
condition|)
block|{
name|ASSERT
argument_list|(
name|depthStencilState
operator|.
name|stencilWritemask
operator|==
name|depthStencilState
operator|.
name|stencilBackWritemask
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|stencilRef
operator|==
name|stencilBackRef
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|depthStencilState
operator|.
name|stencilMask
operator|==
name|depthStencilState
operator|.
name|stencilBackMask
argument_list|)
expr_stmt|;
name|ID3D11DepthStencilState
modifier|*
name|dxDepthStencilState
init|=
name|mStateCache
operator|.
name|getDepthStencilState
argument_list|(
name|depthStencilState
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dxDepthStencilState
condition|)
block|{
name|ERR
argument_list|(
literal|"NULL depth stencil state returned by RenderStateCache::getDepthStencilState, "
literal|"setting the default depth stencil state."
argument_list|)
expr_stmt|;
block|}
comment|// Max D3D11 stencil reference value is 0xFF, corresponding to the max 8 bits in a stencil buffer
comment|// GL specifies we should clamp the ref value to the nearest bit depth when doing stencil ops
name|META_ASSERT
argument_list|(
name|D3D11_DEFAULT_STENCIL_READ_MASK
operator|==
literal|0xFF
argument_list|)
expr_stmt|;
name|META_ASSERT
argument_list|(
name|D3D11_DEFAULT_STENCIL_WRITE_MASK
operator|==
literal|0xFF
argument_list|)
expr_stmt|;
name|UINT
name|dxStencilRef
init|=
name|std
operator|::
name|min
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|stencilRef
argument_list|,
literal|0xFFu
argument_list|)
decl_stmt|;
name|mDeviceContext
operator|->
name|OMSetDepthStencilState
argument_list|(
name|dxDepthStencilState
argument_list|,
name|dxStencilRef
argument_list|)
expr_stmt|;
name|mCurDepthStencilState
operator|=
name|depthStencilState
expr_stmt|;
name|mCurStencilRef
operator|=
name|stencilRef
expr_stmt|;
name|mCurStencilBackRef
operator|=
name|stencilBackRef
expr_stmt|;
block|}
name|mForceSetDepthStencilState
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|setScissorRectangle
name|void
name|Renderer11
operator|::
name|setScissorRectangle
parameter_list|(
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|scissor
parameter_list|,
name|bool
name|enabled
parameter_list|)
block|{
if|if
condition|(
name|mForceSetScissor
operator|||
name|memcmp
argument_list|(
operator|&
name|scissor
argument_list|,
operator|&
name|mCurScissor
argument_list|,
sizeof|sizeof
argument_list|(
name|gl
operator|::
name|Rectangle
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|enabled
operator|!=
name|mScissorEnabled
condition|)
block|{
if|if
condition|(
name|enabled
condition|)
block|{
name|D3D11_RECT
name|rect
decl_stmt|;
name|rect
operator|.
name|left
operator|=
name|std
operator|::
name|max
argument_list|(
literal|0
argument_list|,
name|scissor
operator|.
name|x
argument_list|)
expr_stmt|;
name|rect
operator|.
name|top
operator|=
name|std
operator|::
name|max
argument_list|(
literal|0
argument_list|,
name|scissor
operator|.
name|y
argument_list|)
expr_stmt|;
name|rect
operator|.
name|right
operator|=
name|scissor
operator|.
name|x
operator|+
name|std
operator|::
name|max
argument_list|(
literal|0
argument_list|,
name|scissor
operator|.
name|width
argument_list|)
expr_stmt|;
name|rect
operator|.
name|bottom
operator|=
name|scissor
operator|.
name|y
operator|+
name|std
operator|::
name|max
argument_list|(
literal|0
argument_list|,
name|scissor
operator|.
name|height
argument_list|)
expr_stmt|;
name|mDeviceContext
operator|->
name|RSSetScissorRects
argument_list|(
literal|1
argument_list|,
operator|&
name|rect
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|enabled
operator|!=
name|mScissorEnabled
condition|)
block|{
name|mForceSetRasterState
operator|=
literal|true
expr_stmt|;
block|}
name|mCurScissor
operator|=
name|scissor
expr_stmt|;
name|mScissorEnabled
operator|=
name|enabled
expr_stmt|;
block|}
name|mForceSetScissor
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|setViewport
name|bool
name|Renderer11
operator|::
name|setViewport
parameter_list|(
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|viewport
parameter_list|,
name|float
name|zNear
parameter_list|,
name|float
name|zFar
parameter_list|,
name|GLenum
name|drawMode
parameter_list|,
name|GLenum
name|frontFace
parameter_list|,
name|bool
name|ignoreViewport
parameter_list|)
block|{
name|gl
operator|::
name|Rectangle
name|actualViewport
init|=
name|viewport
decl_stmt|;
name|float
name|actualZNear
init|=
name|gl
operator|::
name|clamp01
argument_list|(
name|zNear
argument_list|)
decl_stmt|;
name|float
name|actualZFar
init|=
name|gl
operator|::
name|clamp01
argument_list|(
name|zFar
argument_list|)
decl_stmt|;
if|if
condition|(
name|ignoreViewport
condition|)
block|{
name|actualViewport
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|actualViewport
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|actualViewport
operator|.
name|width
operator|=
name|mRenderTargetDesc
operator|.
name|width
expr_stmt|;
name|actualViewport
operator|.
name|height
operator|=
name|mRenderTargetDesc
operator|.
name|height
expr_stmt|;
name|actualZNear
operator|=
literal|0.0f
expr_stmt|;
name|actualZFar
operator|=
literal|1.0f
expr_stmt|;
block|}
specifier|const
name|gl
operator|::
name|Caps
modifier|&
name|caps
init|=
name|getRendererCaps
argument_list|()
decl_stmt|;
comment|// Clamp width and height first to the gl maximum, then clamp further if we extend past the D3D maximum bounds
name|D3D11_VIEWPORT
name|dxViewport
decl_stmt|;
name|dxViewport
operator|.
name|TopLeftX
operator|=
name|gl
operator|::
name|clamp
argument_list|(
name|actualViewport
operator|.
name|x
argument_list|,
operator|-
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|caps
operator|.
name|maxViewportWidth
argument_list|)
argument_list|,
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|caps
operator|.
name|maxViewportWidth
argument_list|)
argument_list|)
expr_stmt|;
name|dxViewport
operator|.
name|TopLeftY
operator|=
name|gl
operator|::
name|clamp
argument_list|(
name|actualViewport
operator|.
name|y
argument_list|,
operator|-
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|caps
operator|.
name|maxViewportHeight
argument_list|)
argument_list|,
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|caps
operator|.
name|maxViewportHeight
argument_list|)
argument_list|)
expr_stmt|;
name|dxViewport
operator|.
name|Width
operator|=
name|gl
operator|::
name|clamp
argument_list|(
name|actualViewport
operator|.
name|width
argument_list|,
literal|0
argument_list|,
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|caps
operator|.
name|maxViewportWidth
operator|-
name|dxViewport
operator|.
name|TopLeftX
argument_list|)
argument_list|)
expr_stmt|;
name|dxViewport
operator|.
name|Height
operator|=
name|gl
operator|::
name|clamp
argument_list|(
name|actualViewport
operator|.
name|height
argument_list|,
literal|0
argument_list|,
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|caps
operator|.
name|maxViewportHeight
operator|-
name|dxViewport
operator|.
name|TopLeftY
argument_list|)
argument_list|)
expr_stmt|;
name|dxViewport
operator|.
name|MinDepth
operator|=
name|actualZNear
expr_stmt|;
name|dxViewport
operator|.
name|MaxDepth
operator|=
name|actualZFar
expr_stmt|;
if|if
condition|(
name|dxViewport
operator|.
name|Width
operator|<=
literal|0
operator|||
name|dxViewport
operator|.
name|Height
operator|<=
literal|0
condition|)
block|{
return|return
literal|false
return|;
comment|// Nothing to render
block|}
name|bool
name|viewportChanged
init|=
name|mForceSetViewport
operator|||
name|memcmp
argument_list|(
operator|&
name|actualViewport
argument_list|,
operator|&
name|mCurViewport
argument_list|,
sizeof|sizeof
argument_list|(
name|gl
operator|::
name|Rectangle
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|actualZNear
operator|!=
name|mCurNear
operator|||
name|actualZFar
operator|!=
name|mCurFar
decl_stmt|;
if|if
condition|(
name|viewportChanged
condition|)
block|{
name|mDeviceContext
operator|->
name|RSSetViewports
argument_list|(
literal|1
argument_list|,
operator|&
name|dxViewport
argument_list|)
expr_stmt|;
name|mCurViewport
operator|=
name|actualViewport
expr_stmt|;
name|mCurNear
operator|=
name|actualZNear
expr_stmt|;
name|mCurFar
operator|=
name|actualZFar
expr_stmt|;
name|mPixelConstants
operator|.
name|viewCoords
index|[
literal|0
index|]
operator|=
name|actualViewport
operator|.
name|width
operator|*
literal|0.5f
expr_stmt|;
name|mPixelConstants
operator|.
name|viewCoords
index|[
literal|1
index|]
operator|=
name|actualViewport
operator|.
name|height
operator|*
literal|0.5f
expr_stmt|;
name|mPixelConstants
operator|.
name|viewCoords
index|[
literal|2
index|]
operator|=
name|actualViewport
operator|.
name|x
operator|+
operator|(
name|actualViewport
operator|.
name|width
operator|*
literal|0.5f
operator|)
expr_stmt|;
name|mPixelConstants
operator|.
name|viewCoords
index|[
literal|3
index|]
operator|=
name|actualViewport
operator|.
name|y
operator|+
operator|(
name|actualViewport
operator|.
name|height
operator|*
literal|0.5f
operator|)
expr_stmt|;
name|mPixelConstants
operator|.
name|depthFront
index|[
literal|0
index|]
operator|=
operator|(
name|actualZFar
operator|-
name|actualZNear
operator|)
operator|*
literal|0.5f
expr_stmt|;
name|mPixelConstants
operator|.
name|depthFront
index|[
literal|1
index|]
operator|=
operator|(
name|actualZNear
operator|+
name|actualZFar
operator|)
operator|*
literal|0.5f
expr_stmt|;
name|mVertexConstants
operator|.
name|depthRange
index|[
literal|0
index|]
operator|=
name|actualZNear
expr_stmt|;
name|mVertexConstants
operator|.
name|depthRange
index|[
literal|1
index|]
operator|=
name|actualZFar
expr_stmt|;
name|mVertexConstants
operator|.
name|depthRange
index|[
literal|2
index|]
operator|=
name|actualZFar
operator|-
name|actualZNear
expr_stmt|;
name|mPixelConstants
operator|.
name|depthRange
index|[
literal|0
index|]
operator|=
name|actualZNear
expr_stmt|;
name|mPixelConstants
operator|.
name|depthRange
index|[
literal|1
index|]
operator|=
name|actualZFar
expr_stmt|;
name|mPixelConstants
operator|.
name|depthRange
index|[
literal|2
index|]
operator|=
name|actualZFar
operator|-
name|actualZNear
expr_stmt|;
block|}
name|mForceSetViewport
operator|=
literal|false
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|applyPrimitiveType
name|bool
name|Renderer11
operator|::
name|applyPrimitiveType
parameter_list|(
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|)
block|{
name|D3D11_PRIMITIVE_TOPOLOGY
name|primitiveTopology
init|=
name|D3D_PRIMITIVE_TOPOLOGY_UNDEFINED
decl_stmt|;
name|GLsizei
name|minCount
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|GL_POINTS
case|:
name|primitiveTopology
operator|=
name|D3D11_PRIMITIVE_TOPOLOGY_POINTLIST
expr_stmt|;
name|minCount
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|GL_LINES
case|:
name|primitiveTopology
operator|=
name|D3D_PRIMITIVE_TOPOLOGY_LINELIST
expr_stmt|;
name|minCount
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|GL_LINE_LOOP
case|:
name|primitiveTopology
operator|=
name|D3D_PRIMITIVE_TOPOLOGY_LINESTRIP
expr_stmt|;
name|minCount
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|GL_LINE_STRIP
case|:
name|primitiveTopology
operator|=
name|D3D_PRIMITIVE_TOPOLOGY_LINESTRIP
expr_stmt|;
name|minCount
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|GL_TRIANGLES
case|:
name|primitiveTopology
operator|=
name|D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST
expr_stmt|;
name|minCount
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|GL_TRIANGLE_STRIP
case|:
name|primitiveTopology
operator|=
name|D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP
expr_stmt|;
name|minCount
operator|=
literal|3
expr_stmt|;
break|break;
comment|// emulate fans via rewriting index buffer
case|case
name|GL_TRIANGLE_FAN
case|:
name|primitiveTopology
operator|=
name|D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST
expr_stmt|;
name|minCount
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|primitiveTopology
operator|!=
name|mCurrentPrimitiveTopology
condition|)
block|{
name|mDeviceContext
operator|->
name|IASetPrimitiveTopology
argument_list|(
name|primitiveTopology
argument_list|)
expr_stmt|;
name|mCurrentPrimitiveTopology
operator|=
name|primitiveTopology
expr_stmt|;
block|}
return|return
name|count
operator|>=
name|minCount
return|;
block|}
DECL|function|applyRenderTarget
name|bool
name|Renderer11
operator|::
name|applyRenderTarget
parameter_list|(
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
parameter_list|)
block|{
comment|// Get the color render buffer and serial
comment|// Also extract the render target dimensions and view
name|unsigned
name|int
name|renderTargetWidth
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|renderTargetHeight
init|=
literal|0
decl_stmt|;
name|GLenum
name|renderTargetFormat
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|renderTargetSerials
index|[
name|gl
operator|::
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|ID3D11RenderTargetView
modifier|*
name|framebufferRTVs
index|[
name|gl
operator|::
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
index|]
init|=
block|{
name|NULL
block|}
decl_stmt|;
name|bool
name|missingColorRenderTarget
init|=
literal|true
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|colorAttachment
init|=
literal|0
init|;
name|colorAttachment
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
condition|;
name|colorAttachment
operator|++
control|)
block|{
specifier|const
name|GLenum
name|drawBufferState
init|=
name|framebuffer
operator|->
name|getDrawBufferState
argument_list|(
name|colorAttachment
argument_list|)
decl_stmt|;
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|colorbuffer
init|=
name|framebuffer
operator|->
name|getColorbuffer
argument_list|(
name|colorAttachment
argument_list|)
decl_stmt|;
if|if
condition|(
name|colorbuffer
operator|&&
name|drawBufferState
operator|!=
name|GL_NONE
condition|)
block|{
comment|// the draw buffer must be either "none", "back" for the default buffer or the same index as this color (in order)
name|ASSERT
argument_list|(
name|drawBufferState
operator|==
name|GL_BACK
operator|||
name|drawBufferState
operator|==
operator|(
name|GL_COLOR_ATTACHMENT0_EXT
operator|+
name|colorAttachment
operator|)
argument_list|)
expr_stmt|;
comment|// check for zero-sized default framebuffer, which is a special case.
comment|// in this case we do not wish to modify any state and just silently return false.
comment|// this will not report any gl error but will cause the calling method to return.
if|if
condition|(
name|colorbuffer
operator|->
name|getWidth
argument_list|()
operator|==
literal|0
operator|||
name|colorbuffer
operator|->
name|getHeight
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|renderTargetSerials
index|[
name|colorAttachment
index|]
operator|=
name|colorbuffer
operator|->
name|getSerial
argument_list|()
expr_stmt|;
comment|// Extract the render target dimensions and view
name|RenderTarget11
modifier|*
name|renderTarget
init|=
name|RenderTarget11
operator|::
name|makeRenderTarget11
argument_list|(
name|colorbuffer
operator|->
name|getRenderTarget
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|renderTarget
condition|)
block|{
name|ERR
argument_list|(
literal|"render target pointer unexpectedly null."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|framebufferRTVs
index|[
name|colorAttachment
index|]
operator|=
name|renderTarget
operator|->
name|getRenderTargetView
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|framebufferRTVs
index|[
name|colorAttachment
index|]
condition|)
block|{
name|ERR
argument_list|(
literal|"render target view pointer unexpectedly null."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|missingColorRenderTarget
condition|)
block|{
name|renderTargetWidth
operator|=
name|colorbuffer
operator|->
name|getWidth
argument_list|()
expr_stmt|;
name|renderTargetHeight
operator|=
name|colorbuffer
operator|->
name|getHeight
argument_list|()
expr_stmt|;
name|renderTargetFormat
operator|=
name|colorbuffer
operator|->
name|getActualFormat
argument_list|()
expr_stmt|;
name|missingColorRenderTarget
operator|=
literal|false
expr_stmt|;
block|}
comment|// TODO: Detect if this color buffer is already bound as a texture and unbind it first to prevent
comment|//       D3D11 warnings.
block|}
block|}
comment|// Get the depth stencil render buffer and serials
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|depthStencil
init|=
name|framebuffer
operator|->
name|getDepthbuffer
argument_list|()
decl_stmt|;
name|unsigned
name|int
name|depthbufferSerial
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|stencilbufferSerial
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|depthStencil
condition|)
block|{
name|depthbufferSerial
operator|=
name|depthStencil
operator|->
name|getSerial
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|framebuffer
operator|->
name|getStencilbuffer
argument_list|()
condition|)
block|{
name|depthStencil
operator|=
name|framebuffer
operator|->
name|getStencilbuffer
argument_list|()
expr_stmt|;
name|stencilbufferSerial
operator|=
name|depthStencil
operator|->
name|getSerial
argument_list|()
expr_stmt|;
block|}
name|ID3D11DepthStencilView
modifier|*
name|framebufferDSV
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|depthStencil
condition|)
block|{
name|RenderTarget11
modifier|*
name|depthStencilRenderTarget
init|=
name|RenderTarget11
operator|::
name|makeRenderTarget11
argument_list|(
name|depthStencil
operator|->
name|getDepthStencil
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|depthStencilRenderTarget
condition|)
block|{
name|ERR
argument_list|(
literal|"render target pointer unexpectedly null."
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|framebufferRTVs
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|framebufferDSV
operator|=
name|depthStencilRenderTarget
operator|->
name|getDepthStencilView
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|framebufferDSV
condition|)
block|{
name|ERR
argument_list|(
literal|"depth stencil view pointer unexpectedly null."
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|framebufferRTVs
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// If there is no render buffer, the width, height and format values come from
comment|// the depth stencil
if|if
condition|(
name|missingColorRenderTarget
condition|)
block|{
name|renderTargetWidth
operator|=
name|depthStencil
operator|->
name|getWidth
argument_list|()
expr_stmt|;
name|renderTargetHeight
operator|=
name|depthStencil
operator|->
name|getHeight
argument_list|()
expr_stmt|;
name|renderTargetFormat
operator|=
name|depthStencil
operator|->
name|getActualFormat
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Apply the render target and depth stencil
if|if
condition|(
operator|!
name|mRenderTargetDescInitialized
operator|||
operator|!
name|mDepthStencilInitialized
operator|||
name|memcmp
argument_list|(
name|renderTargetSerials
argument_list|,
name|mAppliedRenderTargetSerials
argument_list|,
sizeof|sizeof
argument_list|(
name|renderTargetSerials
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|depthbufferSerial
operator|!=
name|mAppliedDepthbufferSerial
operator|||
name|stencilbufferSerial
operator|!=
name|mAppliedStencilbufferSerial
condition|)
block|{
name|mDeviceContext
operator|->
name|OMSetRenderTargets
argument_list|(
name|getRendererCaps
argument_list|()
operator|.
name|maxDrawBuffers
argument_list|,
name|framebufferRTVs
argument_list|,
name|framebufferDSV
argument_list|)
expr_stmt|;
name|mRenderTargetDesc
operator|.
name|width
operator|=
name|renderTargetWidth
expr_stmt|;
name|mRenderTargetDesc
operator|.
name|height
operator|=
name|renderTargetHeight
expr_stmt|;
name|mRenderTargetDesc
operator|.
name|format
operator|=
name|renderTargetFormat
expr_stmt|;
name|mForceSetViewport
operator|=
literal|true
expr_stmt|;
name|mForceSetScissor
operator|=
literal|true
expr_stmt|;
name|mForceSetBlendState
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|mDepthStencilInitialized
condition|)
block|{
name|mForceSetRasterState
operator|=
literal|true
expr_stmt|;
block|}
for|for
control|(
name|unsigned
name|int
name|rtIndex
init|=
literal|0
init|;
name|rtIndex
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
condition|;
name|rtIndex
operator|++
control|)
block|{
name|mAppliedRenderTargetSerials
index|[
name|rtIndex
index|]
operator|=
name|renderTargetSerials
index|[
name|rtIndex
index|]
expr_stmt|;
block|}
name|mAppliedDepthbufferSerial
operator|=
name|depthbufferSerial
expr_stmt|;
name|mAppliedStencilbufferSerial
operator|=
name|stencilbufferSerial
expr_stmt|;
name|mRenderTargetDescInitialized
operator|=
literal|true
expr_stmt|;
name|mDepthStencilInitialized
operator|=
literal|true
expr_stmt|;
block|}
name|invalidateFramebufferSwizzles
argument_list|(
name|framebuffer
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|applyVertexBuffer
name|GLenum
name|Renderer11
operator|::
name|applyVertexBuffer
parameter_list|(
name|gl
operator|::
name|ProgramBinary
modifier|*
name|programBinary
parameter_list|,
specifier|const
name|gl
operator|::
name|VertexAttribute
name|vertexAttributes
index|[]
parameter_list|,
specifier|const
name|gl
operator|::
name|VertexAttribCurrentValueData
name|currentValues
index|[]
parameter_list|,
name|GLint
name|first
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLsizei
name|instances
parameter_list|)
block|{
name|TranslatedAttribute
name|attributes
index|[
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
index|]
decl_stmt|;
name|GLenum
name|err
init|=
name|mVertexDataManager
operator|->
name|prepareVertexData
argument_list|(
name|vertexAttributes
argument_list|,
name|currentValues
argument_list|,
name|programBinary
argument_list|,
name|first
argument_list|,
name|count
argument_list|,
name|attributes
argument_list|,
name|instances
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|!=
name|GL_NO_ERROR
condition|)
block|{
return|return
name|err
return|;
block|}
return|return
name|mInputLayoutCache
operator|.
name|applyVertexBuffers
argument_list|(
name|attributes
argument_list|,
name|programBinary
argument_list|)
return|;
block|}
DECL|function|applyIndexBuffer
name|GLenum
name|Renderer11
operator|::
name|applyIndexBuffer
parameter_list|(
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|gl
operator|::
name|Buffer
modifier|*
name|elementArrayBuffer
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|TranslatedIndexData
modifier|*
name|indexInfo
parameter_list|)
block|{
name|GLenum
name|err
init|=
name|mIndexDataManager
operator|->
name|prepareIndexData
argument_list|(
name|type
argument_list|,
name|count
argument_list|,
name|elementArrayBuffer
argument_list|,
name|indices
argument_list|,
name|indexInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|==
name|GL_NO_ERROR
condition|)
block|{
name|IndexBuffer11
modifier|*
name|indexBuffer
init|=
name|IndexBuffer11
operator|::
name|makeIndexBuffer11
argument_list|(
name|indexInfo
operator|->
name|indexBuffer
argument_list|)
decl_stmt|;
name|ID3D11Buffer
modifier|*
name|buffer
init|=
name|NULL
decl_stmt|;
name|DXGI_FORMAT
name|bufferFormat
init|=
name|indexBuffer
operator|->
name|getIndexFormat
argument_list|()
decl_stmt|;
if|if
condition|(
name|indexInfo
operator|->
name|storage
condition|)
block|{
name|Buffer11
modifier|*
name|storage
init|=
name|Buffer11
operator|::
name|makeBuffer11
argument_list|(
name|indexInfo
operator|->
name|storage
argument_list|)
decl_stmt|;
name|buffer
operator|=
name|storage
operator|->
name|getBuffer
argument_list|(
name|BUFFER_USAGE_INDEX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buffer
operator|=
name|indexBuffer
operator|->
name|getBuffer
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|buffer
operator|!=
name|mAppliedIB
operator|||
name|bufferFormat
operator|!=
name|mAppliedIBFormat
operator|||
name|indexInfo
operator|->
name|startOffset
operator|!=
name|mAppliedIBOffset
condition|)
block|{
name|mDeviceContext
operator|->
name|IASetIndexBuffer
argument_list|(
name|buffer
argument_list|,
name|bufferFormat
argument_list|,
name|indexInfo
operator|->
name|startOffset
argument_list|)
expr_stmt|;
name|mAppliedIB
operator|=
name|buffer
expr_stmt|;
name|mAppliedIBFormat
operator|=
name|bufferFormat
expr_stmt|;
name|mAppliedIBOffset
operator|=
name|indexInfo
operator|->
name|startOffset
expr_stmt|;
block|}
block|}
return|return
name|err
return|;
block|}
DECL|function|applyTransformFeedbackBuffers
name|void
name|Renderer11
operator|::
name|applyTransformFeedbackBuffers
parameter_list|(
name|gl
operator|::
name|Buffer
modifier|*
name|transformFeedbackBuffers
index|[]
parameter_list|,
name|GLintptr
name|offsets
index|[]
parameter_list|)
block|{
name|ID3D11Buffer
modifier|*
name|d3dBuffers
index|[
name|gl
operator|::
name|IMPLEMENTATION_MAX_TRANSFORM_FEEDBACK_BUFFERS
index|]
decl_stmt|;
name|UINT
name|d3dOffsets
index|[
name|gl
operator|::
name|IMPLEMENTATION_MAX_TRANSFORM_FEEDBACK_BUFFERS
index|]
decl_stmt|;
name|bool
name|requiresUpdate
init|=
literal|false
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TRANSFORM_FEEDBACK_BUFFERS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|transformFeedbackBuffers
index|[
name|i
index|]
condition|)
block|{
name|Buffer11
modifier|*
name|storage
init|=
name|Buffer11
operator|::
name|makeBuffer11
argument_list|(
name|transformFeedbackBuffers
index|[
name|i
index|]
operator|->
name|getImplementation
argument_list|()
argument_list|)
decl_stmt|;
name|ID3D11Buffer
modifier|*
name|buffer
init|=
name|storage
operator|->
name|getBuffer
argument_list|(
name|BUFFER_USAGE_VERTEX_OR_TRANSFORM_FEEDBACK
argument_list|)
decl_stmt|;
name|d3dBuffers
index|[
name|i
index|]
operator|=
name|buffer
expr_stmt|;
name|d3dOffsets
index|[
name|i
index|]
operator|=
operator|(
name|mAppliedTFBuffers
index|[
name|i
index|]
operator|!=
name|buffer
operator|)
condition|?
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|offsets
index|[
name|i
index|]
argument_list|)
else|:
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|d3dBuffers
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|d3dOffsets
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|d3dBuffers
index|[
name|i
index|]
operator|!=
name|mAppliedTFBuffers
index|[
name|i
index|]
operator|||
name|offsets
index|[
name|i
index|]
operator|!=
name|mAppliedTFOffsets
index|[
name|i
index|]
condition|)
block|{
name|requiresUpdate
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|requiresUpdate
condition|)
block|{
name|mDeviceContext
operator|->
name|SOSetTargets
argument_list|(
name|ArraySize
argument_list|(
name|d3dBuffers
argument_list|)
argument_list|,
name|d3dBuffers
argument_list|,
name|d3dOffsets
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TRANSFORM_FEEDBACK_BUFFERS
condition|;
name|i
operator|++
control|)
block|{
name|mAppliedTFBuffers
index|[
name|i
index|]
operator|=
name|d3dBuffers
index|[
name|i
index|]
expr_stmt|;
name|mAppliedTFOffsets
index|[
name|i
index|]
operator|=
name|offsets
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
DECL|function|drawArrays
name|void
name|Renderer11
operator|::
name|drawArrays
parameter_list|(
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLsizei
name|instances
parameter_list|,
name|bool
name|transformFeedbackActive
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|==
name|GL_POINTS
operator|&&
name|transformFeedbackActive
condition|)
block|{
comment|// Since point sprites are generated with a geometry shader, too many vertices will
comment|// be written if transform feedback is active.  To work around this, draw only the points
comment|// with the stream out shader and no pixel shader to feed the stream out buffers and then
comment|// draw again with the point sprite geometry shader to rasterize the point sprites.
name|mDeviceContext
operator|->
name|PSSetShader
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|instances
operator|>
literal|0
condition|)
block|{
name|mDeviceContext
operator|->
name|DrawInstanced
argument_list|(
name|count
argument_list|,
name|instances
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mDeviceContext
operator|->
name|Draw
argument_list|(
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mDeviceContext
operator|->
name|GSSetShader
argument_list|(
name|mCurPointGeometryShader
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mDeviceContext
operator|->
name|PSSetShader
argument_list|(
name|mAppliedPixelShader
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|instances
operator|>
literal|0
condition|)
block|{
name|mDeviceContext
operator|->
name|DrawInstanced
argument_list|(
name|count
argument_list|,
name|instances
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mDeviceContext
operator|->
name|Draw
argument_list|(
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mDeviceContext
operator|->
name|GSSetShader
argument_list|(
name|mAppliedGeometryShader
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|GL_LINE_LOOP
condition|)
block|{
name|drawLineLoop
argument_list|(
name|count
argument_list|,
name|GL_NONE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|GL_TRIANGLE_FAN
condition|)
block|{
name|drawTriangleFan
argument_list|(
name|count
argument_list|,
name|GL_NONE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|instances
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instances
operator|>
literal|0
condition|)
block|{
name|mDeviceContext
operator|->
name|DrawInstanced
argument_list|(
name|count
argument_list|,
name|instances
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mDeviceContext
operator|->
name|Draw
argument_list|(
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|drawElements
name|void
name|Renderer11
operator|::
name|drawElements
parameter_list|(
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|gl
operator|::
name|Buffer
modifier|*
name|elementArrayBuffer
parameter_list|,
specifier|const
name|TranslatedIndexData
modifier|&
name|indexInfo
parameter_list|,
name|GLsizei
name|instances
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|==
name|GL_LINE_LOOP
condition|)
block|{
name|drawLineLoop
argument_list|(
name|count
argument_list|,
name|type
argument_list|,
name|indices
argument_list|,
name|indexInfo
operator|.
name|minIndex
argument_list|,
name|elementArrayBuffer
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|GL_TRIANGLE_FAN
condition|)
block|{
name|drawTriangleFan
argument_list|(
name|count
argument_list|,
name|type
argument_list|,
name|indices
argument_list|,
name|indexInfo
operator|.
name|minIndex
argument_list|,
name|elementArrayBuffer
argument_list|,
name|instances
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instances
operator|>
literal|0
condition|)
block|{
name|mDeviceContext
operator|->
name|DrawIndexedInstanced
argument_list|(
name|count
argument_list|,
name|instances
argument_list|,
literal|0
argument_list|,
operator|-
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|indexInfo
operator|.
name|minIndex
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mDeviceContext
operator|->
name|DrawIndexed
argument_list|(
name|count
argument_list|,
literal|0
argument_list|,
operator|-
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|indexInfo
operator|.
name|minIndex
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|fillLineLoopIndices
specifier|static
name|void
name|fillLineLoopIndices
parameter_list|(
name|GLenum
name|type
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|T
modifier|*
name|data
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_NONE
case|:
comment|// Non-indexed draw
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
name|data
index|[
name|count
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_BYTE
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLubyte
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
index|]
expr_stmt|;
block|}
name|data
index|[
name|count
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLubyte
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_SHORT
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLushort
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
index|]
expr_stmt|;
block|}
name|data
index|[
name|count
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLushort
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_INT
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLuint
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
index|]
expr_stmt|;
block|}
name|data
index|[
name|count
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLuint
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|fillTriangleFanIndices
specifier|static
name|void
name|fillTriangleFanIndices
parameter_list|(
name|GLenum
name|type
parameter_list|,
name|unsigned
name|int
name|numTris
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|T
modifier|*
name|data
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_NONE
case|:
comment|// Non-indexed draw
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numTris
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
operator|*
literal|3
operator|+
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|data
index|[
name|i
operator|*
literal|3
operator|+
literal|1
index|]
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|data
index|[
name|i
operator|*
literal|3
operator|+
literal|2
index|]
operator|=
name|i
operator|+
literal|2
expr_stmt|;
block|}
break|break;
case|case
name|GL_UNSIGNED_BYTE
case|:
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numTris
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
operator|*
literal|3
operator|+
literal|0
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLubyte
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
name|data
index|[
name|i
operator|*
literal|3
operator|+
literal|1
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLubyte
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|data
index|[
name|i
operator|*
literal|3
operator|+
literal|2
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLubyte
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
block|}
break|break;
case|case
name|GL_UNSIGNED_SHORT
case|:
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numTris
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
operator|*
literal|3
operator|+
literal|0
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLushort
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
name|data
index|[
name|i
operator|*
literal|3
operator|+
literal|1
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLushort
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|data
index|[
name|i
operator|*
literal|3
operator|+
literal|2
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLushort
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
block|}
break|break;
case|case
name|GL_UNSIGNED_INT
case|:
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numTris
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
operator|*
literal|3
operator|+
literal|0
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLuint
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
name|data
index|[
name|i
operator|*
literal|3
operator|+
literal|1
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLuint
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|data
index|[
name|i
operator|*
literal|3
operator|+
literal|2
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLuint
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
block|}
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|drawLineLoop
name|void
name|Renderer11
operator|::
name|drawLineLoop
parameter_list|(
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|int
name|minIndex
parameter_list|,
name|gl
operator|::
name|Buffer
modifier|*
name|elementArrayBuffer
parameter_list|)
block|{
comment|// Get the raw indices for an indexed draw
if|if
condition|(
name|type
operator|!=
name|GL_NONE
operator|&&
name|elementArrayBuffer
condition|)
block|{
name|gl
operator|::
name|Buffer
modifier|*
name|indexBuffer
init|=
name|elementArrayBuffer
decl_stmt|;
name|BufferImpl
modifier|*
name|storage
init|=
name|indexBuffer
operator|->
name|getImplementation
argument_list|()
decl_stmt|;
name|intptr_t
name|offset
init|=
cast|reinterpret_cast
argument_list|<
name|intptr_t
argument_list|>
argument_list|(
name|indices
argument_list|)
decl_stmt|;
name|indices
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLubyte
operator|*
argument_list|>
argument_list|(
name|storage
operator|->
name|getData
argument_list|()
argument_list|)
operator|+
name|offset
expr_stmt|;
block|}
comment|// TODO: some level 9 hardware supports 32-bit indices; test and store support instead
specifier|const
name|int
name|indexType
init|=
name|isLevel9
argument_list|()
condition|?
name|GL_UNSIGNED_SHORT
else|:
name|GL_UNSIGNED_INT
decl_stmt|;
if|if
condition|(
operator|!
name|mLineLoopIB
condition|)
block|{
name|mLineLoopIB
operator|=
operator|new
name|StreamingIndexBufferInterface
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mLineLoopIB
operator|->
name|reserveBufferSpace
argument_list|(
name|INITIAL_INDEX_BUFFER_SIZE
argument_list|,
name|indexType
argument_list|)
condition|)
block|{
operator|delete
name|mLineLoopIB
expr_stmt|;
name|mLineLoopIB
operator|=
name|NULL
expr_stmt|;
name|ERR
argument_list|(
literal|"Could not create a 32-bit looping index buffer for GL_LINE_LOOP."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
comment|// Checked by Renderer11::applyPrimitiveType
name|ASSERT
argument_list|(
name|count
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|int
name|indexTypeSize
init|=
name|indexType
operator|==
name|GL_UNSIGNED_SHORT
condition|?
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
else|:
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
decl_stmt|;
if|if
condition|(
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|count
argument_list|)
operator|+
literal|1
operator|>
operator|(
name|std
operator|::
name|numeric_limits
argument_list|<
name|unsigned
name|int
argument_list|>
operator|::
name|max
argument_list|()
operator|/
name|indexTypeSize
operator|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not create a 32-bit looping index buffer for GL_LINE_LOOP, too many indices required."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
specifier|const
name|unsigned
name|int
name|spaceNeeded
init|=
operator|(
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|count
argument_list|)
operator|+
literal|1
operator|)
operator|*
name|indexTypeSize
decl_stmt|;
if|if
condition|(
operator|!
name|mLineLoopIB
operator|->
name|reserveBufferSpace
argument_list|(
name|spaceNeeded
argument_list|,
name|indexType
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not reserve enough space in looping index buffer for GL_LINE_LOOP."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
name|void
modifier|*
name|mappedMemory
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
if|if
condition|(
operator|!
name|mLineLoopIB
operator|->
name|mapBuffer
argument_list|(
name|spaceNeeded
argument_list|,
operator|&
name|mappedMemory
argument_list|,
operator|&
name|offset
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not map index buffer for GL_LINE_LOOP."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
if|if
condition|(
name|indexType
operator|==
name|GL_UNSIGNED_SHORT
condition|)
name|fillLineLoopIndices
argument_list|(
name|type
argument_list|,
name|count
argument_list|,
name|indices
argument_list|,
cast|reinterpret_cast
argument_list|<
name|unsigned
name|short
operator|*
argument_list|>
argument_list|(
name|mappedMemory
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fillLineLoopIndices
argument_list|(
name|type
argument_list|,
name|count
argument_list|,
name|indices
argument_list|,
cast|reinterpret_cast
argument_list|<
name|unsigned
name|int
operator|*
argument_list|>
argument_list|(
name|mappedMemory
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned
name|int
name|indexBufferOffset
init|=
name|offset
decl_stmt|;
if|if
condition|(
operator|!
name|mLineLoopIB
operator|->
name|unmapBuffer
argument_list|()
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not unmap index buffer for GL_LINE_LOOP."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
name|IndexBuffer11
modifier|*
name|indexBuffer
init|=
name|IndexBuffer11
operator|::
name|makeIndexBuffer11
argument_list|(
name|mLineLoopIB
operator|->
name|getIndexBuffer
argument_list|()
argument_list|)
decl_stmt|;
name|ID3D11Buffer
modifier|*
name|d3dIndexBuffer
init|=
name|indexBuffer
operator|->
name|getBuffer
argument_list|()
decl_stmt|;
name|DXGI_FORMAT
name|indexFormat
init|=
name|indexBuffer
operator|->
name|getIndexFormat
argument_list|()
decl_stmt|;
if|if
condition|(
name|mAppliedIB
operator|!=
name|d3dIndexBuffer
operator|||
name|mAppliedIBFormat
operator|!=
name|indexFormat
operator|||
name|mAppliedIBOffset
operator|!=
name|indexBufferOffset
condition|)
block|{
name|mDeviceContext
operator|->
name|IASetIndexBuffer
argument_list|(
name|indexBuffer
operator|->
name|getBuffer
argument_list|()
argument_list|,
name|indexBuffer
operator|->
name|getIndexFormat
argument_list|()
argument_list|,
name|indexBufferOffset
argument_list|)
expr_stmt|;
name|mAppliedIB
operator|=
name|d3dIndexBuffer
expr_stmt|;
name|mAppliedIBFormat
operator|=
name|indexFormat
expr_stmt|;
name|mAppliedIBOffset
operator|=
name|indexBufferOffset
expr_stmt|;
block|}
name|mDeviceContext
operator|->
name|DrawIndexed
argument_list|(
name|count
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
operator|-
name|minIndex
argument_list|)
expr_stmt|;
block|}
DECL|function|drawTriangleFan
name|void
name|Renderer11
operator|::
name|drawTriangleFan
parameter_list|(
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|int
name|minIndex
parameter_list|,
name|gl
operator|::
name|Buffer
modifier|*
name|elementArrayBuffer
parameter_list|,
name|int
name|instances
parameter_list|)
block|{
comment|// Get the raw indices for an indexed draw
if|if
condition|(
name|type
operator|!=
name|GL_NONE
operator|&&
name|elementArrayBuffer
condition|)
block|{
name|gl
operator|::
name|Buffer
modifier|*
name|indexBuffer
init|=
name|elementArrayBuffer
decl_stmt|;
name|BufferImpl
modifier|*
name|storage
init|=
name|indexBuffer
operator|->
name|getImplementation
argument_list|()
decl_stmt|;
name|intptr_t
name|offset
init|=
cast|reinterpret_cast
argument_list|<
name|intptr_t
argument_list|>
argument_list|(
name|indices
argument_list|)
decl_stmt|;
name|indices
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLubyte
operator|*
argument_list|>
argument_list|(
name|storage
operator|->
name|getData
argument_list|()
argument_list|)
operator|+
name|offset
expr_stmt|;
block|}
specifier|const
name|int
name|indexType
init|=
name|isLevel9
argument_list|()
condition|?
name|GL_UNSIGNED_SHORT
else|:
name|GL_UNSIGNED_INT
decl_stmt|;
if|if
condition|(
operator|!
name|mTriangleFanIB
condition|)
block|{
name|mTriangleFanIB
operator|=
operator|new
name|StreamingIndexBufferInterface
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mTriangleFanIB
operator|->
name|reserveBufferSpace
argument_list|(
name|INITIAL_INDEX_BUFFER_SIZE
argument_list|,
name|indexType
argument_list|)
condition|)
block|{
operator|delete
name|mTriangleFanIB
expr_stmt|;
name|mTriangleFanIB
operator|=
name|NULL
expr_stmt|;
name|ERR
argument_list|(
literal|"Could not create a scratch index buffer for GL_TRIANGLE_FAN."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
comment|// Checked by Renderer11::applyPrimitiveType
name|ASSERT
argument_list|(
name|count
operator|>=
literal|3
argument_list|)
expr_stmt|;
specifier|const
name|unsigned
name|int
name|numTris
init|=
name|count
operator|-
literal|2
decl_stmt|;
name|int
name|indexTypeSize
init|=
name|indexType
operator|==
name|GL_UNSIGNED_SHORT
condition|?
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
else|:
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
decl_stmt|;
if|if
condition|(
name|numTris
operator|>
operator|(
name|std
operator|::
name|numeric_limits
argument_list|<
name|unsigned
name|int
argument_list|>
operator|::
name|max
argument_list|()
operator|/
operator|(
name|indexTypeSize
operator|*
literal|3
operator|)
operator|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not create a scratch index buffer for GL_TRIANGLE_FAN, too many indices required."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
specifier|const
name|unsigned
name|int
name|spaceNeeded
init|=
operator|(
name|numTris
operator|*
literal|3
operator|)
operator|*
name|indexTypeSize
decl_stmt|;
if|if
condition|(
operator|!
name|mTriangleFanIB
operator|->
name|reserveBufferSpace
argument_list|(
name|spaceNeeded
argument_list|,
name|indexType
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not reserve enough space in scratch index buffer for GL_TRIANGLE_FAN."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
name|void
modifier|*
name|mappedMemory
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
if|if
condition|(
operator|!
name|mTriangleFanIB
operator|->
name|mapBuffer
argument_list|(
name|spaceNeeded
argument_list|,
operator|&
name|mappedMemory
argument_list|,
operator|&
name|offset
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not map scratch index buffer for GL_TRIANGLE_FAN."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
if|if
condition|(
name|indexType
operator|==
name|GL_UNSIGNED_SHORT
condition|)
name|fillTriangleFanIndices
argument_list|(
name|type
argument_list|,
name|numTris
argument_list|,
name|indices
argument_list|,
cast|reinterpret_cast
argument_list|<
name|unsigned
name|short
operator|*
argument_list|>
argument_list|(
name|mappedMemory
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fillTriangleFanIndices
argument_list|(
name|type
argument_list|,
name|numTris
argument_list|,
name|indices
argument_list|,
cast|reinterpret_cast
argument_list|<
name|unsigned
name|int
operator|*
argument_list|>
argument_list|(
name|mappedMemory
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned
name|int
name|indexBufferOffset
init|=
name|offset
decl_stmt|;
if|if
condition|(
operator|!
name|mTriangleFanIB
operator|->
name|unmapBuffer
argument_list|()
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not unmap scratch index buffer for GL_TRIANGLE_FAN."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
name|IndexBuffer11
modifier|*
name|indexBuffer
init|=
name|IndexBuffer11
operator|::
name|makeIndexBuffer11
argument_list|(
name|mTriangleFanIB
operator|->
name|getIndexBuffer
argument_list|()
argument_list|)
decl_stmt|;
name|ID3D11Buffer
modifier|*
name|d3dIndexBuffer
init|=
name|indexBuffer
operator|->
name|getBuffer
argument_list|()
decl_stmt|;
name|DXGI_FORMAT
name|indexFormat
init|=
name|indexBuffer
operator|->
name|getIndexFormat
argument_list|()
decl_stmt|;
if|if
condition|(
name|mAppliedIB
operator|!=
name|d3dIndexBuffer
operator|||
name|mAppliedIBFormat
operator|!=
name|indexFormat
operator|||
name|mAppliedIBOffset
operator|!=
name|indexBufferOffset
condition|)
block|{
name|mDeviceContext
operator|->
name|IASetIndexBuffer
argument_list|(
name|indexBuffer
operator|->
name|getBuffer
argument_list|()
argument_list|,
name|indexBuffer
operator|->
name|getIndexFormat
argument_list|()
argument_list|,
name|indexBufferOffset
argument_list|)
expr_stmt|;
name|mAppliedIB
operator|=
name|d3dIndexBuffer
expr_stmt|;
name|mAppliedIBFormat
operator|=
name|indexFormat
expr_stmt|;
name|mAppliedIBOffset
operator|=
name|indexBufferOffset
expr_stmt|;
block|}
if|if
condition|(
name|instances
operator|>
literal|0
condition|)
block|{
name|mDeviceContext
operator|->
name|DrawIndexedInstanced
argument_list|(
name|numTris
operator|*
literal|3
argument_list|,
name|instances
argument_list|,
literal|0
argument_list|,
operator|-
name|minIndex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mDeviceContext
operator|->
name|DrawIndexed
argument_list|(
name|numTris
operator|*
literal|3
argument_list|,
literal|0
argument_list|,
operator|-
name|minIndex
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|applyShaders
name|void
name|Renderer11
operator|::
name|applyShaders
parameter_list|(
name|gl
operator|::
name|ProgramBinary
modifier|*
name|programBinary
parameter_list|,
specifier|const
name|gl
operator|::
name|VertexFormat
name|inputLayout
index|[]
parameter_list|,
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
parameter_list|,
name|bool
name|rasterizerDiscard
parameter_list|,
name|bool
name|transformFeedbackActive
parameter_list|)
block|{
name|ShaderExecutable
modifier|*
name|vertexExe
init|=
name|programBinary
operator|->
name|getVertexExecutableForInputLayout
argument_list|(
name|inputLayout
argument_list|)
decl_stmt|;
name|ShaderExecutable
modifier|*
name|pixelExe
init|=
name|programBinary
operator|->
name|getPixelExecutableForFramebuffer
argument_list|(
name|framebuffer
argument_list|)
decl_stmt|;
name|ShaderExecutable
modifier|*
name|geometryExe
init|=
name|programBinary
operator|->
name|getGeometryExecutable
argument_list|()
decl_stmt|;
name|ID3D11VertexShader
modifier|*
name|vertexShader
init|=
operator|(
name|vertexExe
condition|?
name|ShaderExecutable11
operator|::
name|makeShaderExecutable11
argument_list|(
name|vertexExe
argument_list|)
operator|->
name|getVertexShader
argument_list|()
else|:
name|NULL
operator|)
decl_stmt|;
name|ID3D11PixelShader
modifier|*
name|pixelShader
init|=
name|NULL
decl_stmt|;
comment|// Skip pixel shader if we're doing rasterizer discard.
if|if
condition|(
operator|!
name|rasterizerDiscard
condition|)
block|{
name|pixelShader
operator|=
operator|(
name|pixelExe
condition|?
name|ShaderExecutable11
operator|::
name|makeShaderExecutable11
argument_list|(
name|pixelExe
argument_list|)
operator|->
name|getPixelShader
argument_list|()
else|:
name|NULL
operator|)
expr_stmt|;
block|}
name|ID3D11GeometryShader
modifier|*
name|geometryShader
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|transformFeedbackActive
condition|)
block|{
name|geometryShader
operator|=
operator|(
name|vertexExe
condition|?
name|ShaderExecutable11
operator|::
name|makeShaderExecutable11
argument_list|(
name|vertexExe
argument_list|)
operator|->
name|getStreamOutShader
argument_list|()
else|:
name|NULL
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mCurRasterState
operator|.
name|pointDrawMode
condition|)
block|{
name|geometryShader
operator|=
operator|(
name|geometryExe
condition|?
name|ShaderExecutable11
operator|::
name|makeShaderExecutable11
argument_list|(
name|geometryExe
argument_list|)
operator|->
name|getGeometryShader
argument_list|()
else|:
name|NULL
operator|)
expr_stmt|;
block|}
name|bool
name|dirtyUniforms
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|vertexShader
operator|!=
name|mAppliedVertexShader
condition|)
block|{
name|mDeviceContext
operator|->
name|VSSetShader
argument_list|(
name|vertexShader
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mAppliedVertexShader
operator|=
name|vertexShader
expr_stmt|;
name|dirtyUniforms
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|geometryShader
operator|!=
name|mAppliedGeometryShader
condition|)
block|{
name|mDeviceContext
operator|->
name|GSSetShader
argument_list|(
name|geometryShader
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mAppliedGeometryShader
operator|=
name|geometryShader
expr_stmt|;
name|dirtyUniforms
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|geometryExe
operator|&&
name|mCurRasterState
operator|.
name|pointDrawMode
condition|)
block|{
name|mCurPointGeometryShader
operator|=
name|ShaderExecutable11
operator|::
name|makeShaderExecutable11
argument_list|(
name|geometryExe
argument_list|)
operator|->
name|getGeometryShader
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|mCurPointGeometryShader
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pixelShader
operator|!=
name|mAppliedPixelShader
condition|)
block|{
name|mDeviceContext
operator|->
name|PSSetShader
argument_list|(
name|pixelShader
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mAppliedPixelShader
operator|=
name|pixelShader
expr_stmt|;
name|dirtyUniforms
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|dirtyUniforms
condition|)
block|{
name|programBinary
operator|->
name|dirtyAllUniforms
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|applyUniforms
name|void
name|Renderer11
operator|::
name|applyUniforms
parameter_list|(
specifier|const
name|gl
operator|::
name|ProgramBinary
modifier|&
name|programBinary
parameter_list|)
block|{
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|gl
operator|::
name|LinkedUniform
operator|*
argument_list|>
modifier|&
name|uniformArray
init|=
name|programBinary
operator|.
name|getUniforms
argument_list|()
decl_stmt|;
name|unsigned
name|int
name|totalRegisterCountVS
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|totalRegisterCountPS
init|=
literal|0
decl_stmt|;
name|bool
name|vertexUniformsDirty
init|=
literal|false
decl_stmt|;
name|bool
name|pixelUniformsDirty
init|=
literal|false
decl_stmt|;
for|for
control|(
name|size_t
name|uniformIndex
init|=
literal|0
init|;
name|uniformIndex
operator|<
name|uniformArray
operator|.
name|size
argument_list|()
condition|;
name|uniformIndex
operator|++
control|)
block|{
specifier|const
name|gl
operator|::
name|LinkedUniform
modifier|&
name|uniform
init|=
operator|*
name|uniformArray
index|[
name|uniformIndex
index|]
decl_stmt|;
if|if
condition|(
name|uniform
operator|.
name|isReferencedByVertexShader
argument_list|()
operator|&&
operator|!
name|uniform
operator|.
name|isSampler
argument_list|()
condition|)
block|{
name|totalRegisterCountVS
operator|+=
name|uniform
operator|.
name|registerCount
expr_stmt|;
name|vertexUniformsDirty
operator|=
operator|(
name|vertexUniformsDirty
operator|||
name|uniform
operator|.
name|dirty
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|uniform
operator|.
name|isReferencedByFragmentShader
argument_list|()
operator|&&
operator|!
name|uniform
operator|.
name|isSampler
argument_list|()
condition|)
block|{
name|totalRegisterCountPS
operator|+=
name|uniform
operator|.
name|registerCount
expr_stmt|;
name|pixelUniformsDirty
operator|=
operator|(
name|pixelUniformsDirty
operator|||
name|uniform
operator|.
name|dirty
operator|)
expr_stmt|;
block|}
block|}
specifier|const
name|UniformStorage11
modifier|*
name|vertexUniformStorage
init|=
name|UniformStorage11
operator|::
name|makeUniformStorage11
argument_list|(
operator|&
name|programBinary
operator|.
name|getVertexUniformStorage
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|UniformStorage11
modifier|*
name|fragmentUniformStorage
init|=
name|UniformStorage11
operator|::
name|makeUniformStorage11
argument_list|(
operator|&
name|programBinary
operator|.
name|getFragmentUniformStorage
argument_list|()
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|vertexUniformStorage
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|fragmentUniformStorage
argument_list|)
expr_stmt|;
name|ID3D11Buffer
modifier|*
name|vertexConstantBuffer
init|=
name|vertexUniformStorage
operator|->
name|getConstantBuffer
argument_list|()
decl_stmt|;
name|ID3D11Buffer
modifier|*
name|pixelConstantBuffer
init|=
name|fragmentUniformStorage
operator|->
name|getConstantBuffer
argument_list|()
decl_stmt|;
name|float
argument_list|(
operator|*
name|mapVS
argument_list|)
index|[
literal|4
index|]
operator|=
name|NULL
expr_stmt|;
name|float
argument_list|(
operator|*
name|mapPS
argument_list|)
index|[
literal|4
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|totalRegisterCountVS
operator|>
literal|0
operator|&&
name|vertexUniformsDirty
condition|)
block|{
name|D3D11_MAPPED_SUBRESOURCE
name|map
init|=
block|{
literal|0
block|}
decl_stmt|;
name|HRESULT
name|result
init|=
name|mDeviceContext
operator|->
name|Map
argument_list|(
name|vertexConstantBuffer
argument_list|,
literal|0
argument_list|,
name|D3D11_MAP_WRITE_DISCARD
argument_list|,
literal|0
argument_list|,
operator|&
name|map
argument_list|)
decl_stmt|;
name|UNUSED_ASSERTION_VARIABLE
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|mapVS
operator|=
operator|(
name|float
argument_list|(
operator|*
argument_list|)
index|[
literal|4
index|]
operator|)
name|map
operator|.
name|pData
expr_stmt|;
block|}
if|if
condition|(
name|totalRegisterCountPS
operator|>
literal|0
operator|&&
name|pixelUniformsDirty
condition|)
block|{
name|D3D11_MAPPED_SUBRESOURCE
name|map
init|=
block|{
literal|0
block|}
decl_stmt|;
name|HRESULT
name|result
init|=
name|mDeviceContext
operator|->
name|Map
argument_list|(
name|pixelConstantBuffer
argument_list|,
literal|0
argument_list|,
name|D3D11_MAP_WRITE_DISCARD
argument_list|,
literal|0
argument_list|,
operator|&
name|map
argument_list|)
decl_stmt|;
name|UNUSED_ASSERTION_VARIABLE
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|mapPS
operator|=
operator|(
name|float
argument_list|(
operator|*
argument_list|)
index|[
literal|4
index|]
operator|)
name|map
operator|.
name|pData
expr_stmt|;
block|}
for|for
control|(
name|size_t
name|uniformIndex
init|=
literal|0
init|;
name|uniformIndex
operator|<
name|uniformArray
operator|.
name|size
argument_list|()
condition|;
name|uniformIndex
operator|++
control|)
block|{
name|gl
operator|::
name|LinkedUniform
modifier|*
name|uniform
init|=
name|uniformArray
index|[
name|uniformIndex
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|uniform
operator|->
name|isSampler
argument_list|()
condition|)
block|{
name|unsigned
name|int
name|componentCount
init|=
operator|(
literal|4
operator|-
name|uniform
operator|->
name|registerElement
operator|)
decl_stmt|;
comment|// we assume that uniforms from structs are arranged in struct order in our uniforms list. otherwise we would
comment|// overwrite previously written regions of memory.
if|if
condition|(
name|uniform
operator|->
name|isReferencedByVertexShader
argument_list|()
operator|&&
name|mapVS
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|mapVS
index|[
name|uniform
operator|->
name|vsRegisterIndex
index|]
index|[
name|uniform
operator|->
name|registerElement
index|]
argument_list|,
name|uniform
operator|->
name|data
argument_list|,
name|uniform
operator|->
name|registerCount
operator|*
sizeof|sizeof
argument_list|(
name|float
argument_list|)
operator|*
name|componentCount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uniform
operator|->
name|isReferencedByFragmentShader
argument_list|()
operator|&&
name|mapPS
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|mapPS
index|[
name|uniform
operator|->
name|psRegisterIndex
index|]
index|[
name|uniform
operator|->
name|registerElement
index|]
argument_list|,
name|uniform
operator|->
name|data
argument_list|,
name|uniform
operator|->
name|registerCount
operator|*
sizeof|sizeof
argument_list|(
name|float
argument_list|)
operator|*
name|componentCount
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|mapVS
condition|)
block|{
name|mDeviceContext
operator|->
name|Unmap
argument_list|(
name|vertexConstantBuffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mapPS
condition|)
block|{
name|mDeviceContext
operator|->
name|Unmap
argument_list|(
name|pixelConstantBuffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mCurrentVertexConstantBuffer
operator|!=
name|vertexConstantBuffer
condition|)
block|{
name|mDeviceContext
operator|->
name|VSSetConstantBuffers
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|vertexConstantBuffer
argument_list|)
expr_stmt|;
name|mCurrentVertexConstantBuffer
operator|=
name|vertexConstantBuffer
expr_stmt|;
block|}
if|if
condition|(
name|mCurrentPixelConstantBuffer
operator|!=
name|pixelConstantBuffer
condition|)
block|{
name|mDeviceContext
operator|->
name|PSSetConstantBuffers
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|pixelConstantBuffer
argument_list|)
expr_stmt|;
name|mCurrentPixelConstantBuffer
operator|=
name|pixelConstantBuffer
expr_stmt|;
block|}
comment|// Driver uniforms
if|if
condition|(
operator|!
name|mDriverConstantBufferVS
condition|)
block|{
name|D3D11_BUFFER_DESC
name|constantBufferDescription
init|=
block|{
literal|0
block|}
decl_stmt|;
name|constantBufferDescription
operator|.
name|ByteWidth
operator|=
sizeof|sizeof
argument_list|(
name|dx_VertexConstants
argument_list|)
expr_stmt|;
name|constantBufferDescription
operator|.
name|Usage
operator|=
name|D3D11_USAGE_DEFAULT
expr_stmt|;
name|constantBufferDescription
operator|.
name|BindFlags
operator|=
name|D3D11_BIND_CONSTANT_BUFFER
expr_stmt|;
name|constantBufferDescription
operator|.
name|CPUAccessFlags
operator|=
literal|0
expr_stmt|;
name|constantBufferDescription
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|constantBufferDescription
operator|.
name|StructureByteStride
operator|=
literal|0
expr_stmt|;
name|HRESULT
name|result
init|=
name|mDevice
operator|->
name|CreateBuffer
argument_list|(
operator|&
name|constantBufferDescription
argument_list|,
name|NULL
argument_list|,
operator|&
name|mDriverConstantBufferVS
argument_list|)
decl_stmt|;
name|UNUSED_ASSERTION_VARIABLE
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|mDeviceContext
operator|->
name|VSSetConstantBuffers
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
operator|&
name|mDriverConstantBufferVS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mDriverConstantBufferPS
condition|)
block|{
name|D3D11_BUFFER_DESC
name|constantBufferDescription
init|=
block|{
literal|0
block|}
decl_stmt|;
name|constantBufferDescription
operator|.
name|ByteWidth
operator|=
sizeof|sizeof
argument_list|(
name|dx_PixelConstants
argument_list|)
expr_stmt|;
name|constantBufferDescription
operator|.
name|Usage
operator|=
name|D3D11_USAGE_DEFAULT
expr_stmt|;
name|constantBufferDescription
operator|.
name|BindFlags
operator|=
name|D3D11_BIND_CONSTANT_BUFFER
expr_stmt|;
name|constantBufferDescription
operator|.
name|CPUAccessFlags
operator|=
literal|0
expr_stmt|;
name|constantBufferDescription
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|constantBufferDescription
operator|.
name|StructureByteStride
operator|=
literal|0
expr_stmt|;
name|HRESULT
name|result
init|=
name|mDevice
operator|->
name|CreateBuffer
argument_list|(
operator|&
name|constantBufferDescription
argument_list|,
name|NULL
argument_list|,
operator|&
name|mDriverConstantBufferPS
argument_list|)
decl_stmt|;
name|UNUSED_ASSERTION_VARIABLE
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|mDeviceContext
operator|->
name|PSSetConstantBuffers
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
operator|&
name|mDriverConstantBufferPS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|mVertexConstants
argument_list|,
operator|&
name|mAppliedVertexConstants
argument_list|,
sizeof|sizeof
argument_list|(
name|dx_VertexConstants
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mDeviceContext
operator|->
name|UpdateSubresource
argument_list|(
name|mDriverConstantBufferVS
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|mVertexConstants
argument_list|,
literal|16
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|mAppliedVertexConstants
argument_list|,
operator|&
name|mVertexConstants
argument_list|,
sizeof|sizeof
argument_list|(
name|dx_VertexConstants
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|mPixelConstants
argument_list|,
operator|&
name|mAppliedPixelConstants
argument_list|,
sizeof|sizeof
argument_list|(
name|dx_PixelConstants
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mDeviceContext
operator|->
name|UpdateSubresource
argument_list|(
name|mDriverConstantBufferPS
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|mPixelConstants
argument_list|,
literal|16
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|mAppliedPixelConstants
argument_list|,
operator|&
name|mPixelConstants
argument_list|,
sizeof|sizeof
argument_list|(
name|dx_PixelConstants
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// needed for the point sprite geometry shader
if|if
condition|(
name|mFeatureLevel
operator|>=
name|D3D_FEATURE_LEVEL_10_0
operator|&&
name|mCurrentGeometryConstantBuffer
operator|!=
name|mDriverConstantBufferPS
condition|)
block|{
name|mDeviceContext
operator|->
name|GSSetConstantBuffers
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|mDriverConstantBufferPS
argument_list|)
expr_stmt|;
name|mCurrentGeometryConstantBuffer
operator|=
name|mDriverConstantBufferPS
expr_stmt|;
block|}
block|}
DECL|function|clear
name|void
name|Renderer11
operator|::
name|clear
parameter_list|(
specifier|const
name|gl
operator|::
name|ClearParameters
modifier|&
name|clearParams
parameter_list|,
name|gl
operator|::
name|Framebuffer
modifier|*
name|frameBuffer
parameter_list|)
block|{
name|mClear
operator|->
name|clearFramebuffer
argument_list|(
name|clearParams
argument_list|,
name|frameBuffer
argument_list|)
expr_stmt|;
name|invalidateFramebufferSwizzles
argument_list|(
name|frameBuffer
argument_list|)
expr_stmt|;
block|}
DECL|function|markAllStateDirty
name|void
name|Renderer11
operator|::
name|markAllStateDirty
parameter_list|()
block|{
for|for
control|(
name|unsigned
name|int
name|rtIndex
init|=
literal|0
init|;
name|rtIndex
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
condition|;
name|rtIndex
operator|++
control|)
block|{
name|mAppliedRenderTargetSerials
index|[
name|rtIndex
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|mAppliedDepthbufferSerial
operator|=
literal|0
expr_stmt|;
name|mAppliedStencilbufferSerial
operator|=
literal|0
expr_stmt|;
name|mDepthStencilInitialized
operator|=
literal|false
expr_stmt|;
name|mRenderTargetDescInitialized
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_VERTEX_TEXTURE_IMAGE_UNITS
condition|;
name|i
operator|++
control|)
block|{
name|mForceSetVertexSamplerStates
index|[
name|i
index|]
operator|=
literal|true
expr_stmt|;
name|mCurVertexSRVs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|MAX_TEXTURE_IMAGE_UNITS
condition|;
name|i
operator|++
control|)
block|{
name|mForceSetPixelSamplerStates
index|[
name|i
index|]
operator|=
literal|true
expr_stmt|;
name|mCurPixelSRVs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|mForceSetBlendState
operator|=
literal|true
expr_stmt|;
name|mForceSetRasterState
operator|=
literal|true
expr_stmt|;
name|mForceSetDepthStencilState
operator|=
literal|true
expr_stmt|;
name|mForceSetScissor
operator|=
literal|true
expr_stmt|;
name|mForceSetViewport
operator|=
literal|true
expr_stmt|;
name|mAppliedIB
operator|=
name|NULL
expr_stmt|;
name|mAppliedIBFormat
operator|=
name|DXGI_FORMAT_UNKNOWN
expr_stmt|;
name|mAppliedIBOffset
operator|=
literal|0
expr_stmt|;
name|mAppliedVertexShader
operator|=
name|NULL
expr_stmt|;
name|mAppliedGeometryShader
operator|=
name|NULL
expr_stmt|;
name|mCurPointGeometryShader
operator|=
name|NULL
expr_stmt|;
name|mAppliedPixelShader
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TRANSFORM_FEEDBACK_BUFFERS
condition|;
name|i
operator|++
control|)
block|{
name|mAppliedTFBuffers
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|mAppliedTFOffsets
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|mAppliedVertexConstants
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dx_VertexConstants
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|mAppliedPixelConstants
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dx_PixelConstants
argument_list|)
argument_list|)
expr_stmt|;
name|mInputLayoutCache
operator|.
name|markDirty
argument_list|()
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_VERTEX_SHADER_UNIFORM_BUFFERS
condition|;
name|i
operator|++
control|)
block|{
name|mCurrentConstantBufferVS
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|mCurrentConstantBufferPS
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|mCurrentVertexConstantBuffer
operator|=
name|NULL
expr_stmt|;
name|mCurrentPixelConstantBuffer
operator|=
name|NULL
expr_stmt|;
name|mCurrentGeometryConstantBuffer
operator|=
name|NULL
expr_stmt|;
name|mCurrentPrimitiveTopology
operator|=
name|D3D_PRIMITIVE_TOPOLOGY_UNDEFINED
expr_stmt|;
block|}
DECL|function|releaseDeviceResources
name|void
name|Renderer11
operator|::
name|releaseDeviceResources
parameter_list|()
block|{
name|mStateCache
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mInputLayoutCache
operator|.
name|clear
argument_list|()
expr_stmt|;
name|SafeDelete
argument_list|(
name|mVertexDataManager
argument_list|)
expr_stmt|;
name|SafeDelete
argument_list|(
name|mIndexDataManager
argument_list|)
expr_stmt|;
name|SafeDelete
argument_list|(
name|mLineLoopIB
argument_list|)
expr_stmt|;
name|SafeDelete
argument_list|(
name|mTriangleFanIB
argument_list|)
expr_stmt|;
name|SafeDelete
argument_list|(
name|mBlit
argument_list|)
expr_stmt|;
name|SafeDelete
argument_list|(
name|mClear
argument_list|)
expr_stmt|;
name|SafeDelete
argument_list|(
name|mPixelTransfer
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mDriverConstantBufferVS
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mDriverConstantBufferPS
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mSyncQuery
argument_list|)
expr_stmt|;
block|}
DECL|function|notifyDeviceLost
name|void
name|Renderer11
operator|::
name|notifyDeviceLost
parameter_list|()
block|{
name|mDeviceLost
operator|=
literal|true
expr_stmt|;
name|mDisplay
operator|->
name|notifyDeviceLost
argument_list|()
expr_stmt|;
block|}
DECL|function|isDeviceLost
name|bool
name|Renderer11
operator|::
name|isDeviceLost
parameter_list|()
block|{
return|return
name|mDeviceLost
return|;
block|}
comment|// set notify to true to broadcast a message to all contexts of the device loss
DECL|function|testDeviceLost
name|bool
name|Renderer11
operator|::
name|testDeviceLost
parameter_list|(
name|bool
name|notify
parameter_list|)
block|{
name|bool
name|isLost
init|=
literal|false
decl_stmt|;
comment|// GetRemovedReason is used to test if the device is removed
name|HRESULT
name|result
init|=
name|mDevice
operator|->
name|GetDeviceRemovedReason
argument_list|()
decl_stmt|;
name|isLost
operator|=
name|d3d11
operator|::
name|isDeviceLostError
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|isLost
condition|)
block|{
comment|// Log error if this is a new device lost event
if|if
condition|(
name|mDeviceLost
operator|==
literal|false
condition|)
block|{
name|ERR
argument_list|(
literal|"The D3D11 device was removed: 0x%08X"
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
comment|// ensure we note the device loss --
comment|// we'll probably get this done again by notifyDeviceLost
comment|// but best to remember it!
comment|// Note that we don't want to clear the device loss status here
comment|// -- this needs to be done by resetDevice
name|mDeviceLost
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|notify
condition|)
block|{
name|notifyDeviceLost
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|isLost
return|;
block|}
DECL|function|testDeviceResettable
name|bool
name|Renderer11
operator|::
name|testDeviceResettable
parameter_list|()
block|{
comment|// determine if the device is resettable by creating a dummy device
name|PFN_D3D11_CREATE_DEVICE
name|D3D11CreateDevice
init|=
operator|(
name|PFN_D3D11_CREATE_DEVICE
operator|)
name|GetProcAddress
argument_list|(
name|mD3d11Module
argument_list|,
literal|"D3D11CreateDevice"
argument_list|)
decl_stmt|;
if|if
condition|(
name|D3D11CreateDevice
operator|==
name|NULL
condition|)
block|{
return|return
literal|false
return|;
block|}
name|D3D_FEATURE_LEVEL
name|featureLevels
index|[]
init|=
block|{
name|D3D_FEATURE_LEVEL_11_0
block|,
name|D3D_FEATURE_LEVEL_10_1
block|,
name|D3D_FEATURE_LEVEL_10_0
block|,
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ANGLE_ENABLE_D3D9
argument_list|)
name|D3D_FEATURE_LEVEL_9_3
block|,
name|D3D_FEATURE_LEVEL_9_2
block|,
name|D3D_FEATURE_LEVEL_9_1
block|,
endif|#
directive|endif
block|}
decl_stmt|;
name|ID3D11Device
modifier|*
name|dummyDevice
decl_stmt|;
name|D3D_FEATURE_LEVEL
name|dummyFeatureLevel
decl_stmt|;
name|ID3D11DeviceContext
modifier|*
name|dummyContext
decl_stmt|;
name|HRESULT
name|result
init|=
name|D3D11CreateDevice
argument_list|(
name|NULL
argument_list|,
name|D3D_DRIVER_TYPE_HARDWARE
argument_list|,
name|NULL
argument_list|,
if|#
directive|if
name|defined
argument_list|(
name|_DEBUG
argument_list|)
name|D3D11_CREATE_DEVICE_DEBUG
argument_list|,
else|#
directive|else
literal|0
argument_list|,
endif|#
directive|endif
name|featureLevels
argument_list|,
name|ArraySize
argument_list|(
name|featureLevels
argument_list|)
argument_list|,
name|D3D11_SDK_VERSION
argument_list|,
operator|&
name|dummyDevice
argument_list|,
operator|&
name|dummyFeatureLevel
argument_list|,
operator|&
name|dummyContext
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mDevice
operator|||
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|SafeRelease
argument_list|(
name|dummyContext
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|dummyDevice
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|release
name|void
name|Renderer11
operator|::
name|release
parameter_list|()
block|{
name|releaseDeviceResources
argument_list|()
expr_stmt|;
name|SafeRelease
argument_list|(
name|mDxgiFactory
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mDxgiAdapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|mDeviceContext
condition|)
block|{
name|mDeviceContext
operator|->
name|ClearState
argument_list|()
expr_stmt|;
name|mDeviceContext
operator|->
name|Flush
argument_list|()
expr_stmt|;
name|SafeRelease
argument_list|(
name|mDeviceContext
argument_list|)
expr_stmt|;
block|}
name|SafeRelease
argument_list|(
name|mDevice
argument_list|)
expr_stmt|;
if|if
condition|(
name|mD3d11Module
condition|)
block|{
name|FreeLibrary
argument_list|(
name|mD3d11Module
argument_list|)
expr_stmt|;
name|mD3d11Module
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mDxgiModule
condition|)
block|{
name|FreeLibrary
argument_list|(
name|mDxgiModule
argument_list|)
expr_stmt|;
name|mDxgiModule
operator|=
name|NULL
expr_stmt|;
block|}
name|mCompiler
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
DECL|function|resetDevice
name|bool
name|Renderer11
operator|::
name|resetDevice
parameter_list|()
block|{
comment|// recreate everything
name|release
argument_list|()
expr_stmt|;
name|EGLint
name|result
init|=
name|initialize
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
operator|!=
name|EGL_SUCCESS
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not reinitialize D3D11 device: %08X"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|mDeviceLost
operator|=
literal|false
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|getAdapterVendor
name|DWORD
name|Renderer11
operator|::
name|getAdapterVendor
parameter_list|()
specifier|const
block|{
return|return
name|mAdapterDescription
operator|.
name|VendorId
return|;
block|}
DECL|function|getRendererDescription
name|std
operator|::
name|string
name|Renderer11
operator|::
name|getRendererDescription
parameter_list|()
specifier|const
block|{
name|std
operator|::
name|ostringstream
name|rendererString
decl_stmt|;
name|rendererString
operator|<<
name|mDescription
expr_stmt|;
name|rendererString
operator|<<
literal|" Direct3D11"
expr_stmt|;
name|rendererString
operator|<<
literal|" vs_"
operator|<<
name|getMajorShaderModel
argument_list|()
operator|<<
literal|"_"
operator|<<
name|getMinorShaderModel
argument_list|()
expr_stmt|;
name|rendererString
operator|<<
literal|" ps_"
operator|<<
name|getMajorShaderModel
argument_list|()
operator|<<
literal|"_"
operator|<<
name|getMinorShaderModel
argument_list|()
expr_stmt|;
return|return
name|rendererString
operator|.
name|str
argument_list|()
return|;
block|}
DECL|function|getAdapterIdentifier
name|GUID
name|Renderer11
operator|::
name|getAdapterIdentifier
parameter_list|()
specifier|const
block|{
comment|// Use the adapter LUID as our adapter ID
comment|// This number is local to a machine is only guaranteed to be unique between restarts
name|META_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|LUID
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|GUID
argument_list|)
argument_list|)
expr_stmt|;
name|GUID
name|adapterId
init|=
block|{
literal|0
block|}
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|adapterId
argument_list|,
operator|&
name|mAdapterDescription
operator|.
name|AdapterLuid
argument_list|,
sizeof|sizeof
argument_list|(
name|LUID
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|adapterId
return|;
block|}
DECL|function|getMaxVertexTextureImageUnits
name|unsigned
name|int
name|Renderer11
operator|::
name|getMaxVertexTextureImageUnits
parameter_list|()
specifier|const
block|{
name|META_ASSERT
argument_list|(
name|MAX_TEXTURE_IMAGE_UNITS_VTF_SM4
operator|<=
name|gl
operator|::
name|IMPLEMENTATION_MAX_VERTEX_TEXTURE_IMAGE_UNITS
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mFeatureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|MAX_TEXTURE_IMAGE_UNITS_VTF_SM4
return|;
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|0
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|getMaxCombinedTextureImageUnits
name|unsigned
name|int
name|Renderer11
operator|::
name|getMaxCombinedTextureImageUnits
parameter_list|()
specifier|const
block|{
return|return
name|gl
operator|::
name|MAX_TEXTURE_IMAGE_UNITS
operator|+
name|getMaxVertexTextureImageUnits
argument_list|()
return|;
block|}
DECL|function|getReservedVertexUniformVectors
name|unsigned
name|int
name|Renderer11
operator|::
name|getReservedVertexUniformVectors
parameter_list|()
specifier|const
block|{
return|return
literal|0
return|;
comment|// Driver uniforms are stored in a separate constant buffer
block|}
DECL|function|getReservedFragmentUniformVectors
name|unsigned
name|int
name|Renderer11
operator|::
name|getReservedFragmentUniformVectors
parameter_list|()
specifier|const
block|{
return|return
literal|0
return|;
comment|// Driver uniforms are stored in a separate constant buffer
block|}
DECL|function|getMaxVertexUniformVectors
name|unsigned
name|int
name|Renderer11
operator|::
name|getMaxVertexUniformVectors
parameter_list|()
specifier|const
block|{
name|META_ASSERT
argument_list|(
name|MAX_VERTEX_UNIFORM_VECTORS_D3D11
operator|<=
name|D3D10_REQ_CONSTANT_BUFFER_ELEMENT_COUNT
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mFeatureLevel
operator|>=
name|D3D_FEATURE_LEVEL_9_1
argument_list|)
expr_stmt|;
return|return
name|MAX_VERTEX_UNIFORM_VECTORS_D3D11
return|;
block|}
DECL|function|getMaxFragmentUniformVectors
name|unsigned
name|int
name|Renderer11
operator|::
name|getMaxFragmentUniformVectors
parameter_list|()
specifier|const
block|{
name|META_ASSERT
argument_list|(
name|MAX_FRAGMENT_UNIFORM_VECTORS_D3D11
operator|<=
name|D3D10_REQ_CONSTANT_BUFFER_ELEMENT_COUNT
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mFeatureLevel
operator|>=
name|D3D_FEATURE_LEVEL_9_1
argument_list|)
expr_stmt|;
return|return
name|MAX_FRAGMENT_UNIFORM_VECTORS_D3D11
return|;
block|}
DECL|function|getMaxVaryingVectors
name|unsigned
name|int
name|Renderer11
operator|::
name|getMaxVaryingVectors
parameter_list|()
specifier|const
block|{
name|META_ASSERT
argument_list|(
name|gl
operator|::
name|IMPLEMENTATION_MAX_VARYING_VECTORS
operator|==
name|D3D11_VS_OUTPUT_REGISTER_COUNT
argument_list|)
expr_stmt|;
name|META_ASSERT
argument_list|(
name|D3D11_VS_OUTPUT_REGISTER_COUNT
operator|<=
name|D3D11_PS_INPUT_REGISTER_COUNT
argument_list|)
expr_stmt|;
name|META_ASSERT
argument_list|(
name|D3D10_VS_OUTPUT_REGISTER_COUNT
operator|<=
name|D3D10_PS_INPUT_REGISTER_COUNT
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mFeatureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_VS_OUTPUT_REGISTER_COUNT
operator|-
name|getReservedVaryings
argument_list|()
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
return|return
name|D3D10_1_VS_OUTPUT_REGISTER_COUNT
operator|-
name|getReservedVaryings
argument_list|()
return|;
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_VS_OUTPUT_REGISTER_COUNT
operator|-
name|getReservedVaryings
argument_list|()
return|;
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
return|return
literal|10
operator|-
name|getReservedVaryings
argument_list|()
return|;
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|8
operator|-
name|getReservedVaryings
argument_list|()
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|getMaxVertexShaderUniformBuffers
name|unsigned
name|int
name|Renderer11
operator|::
name|getMaxVertexShaderUniformBuffers
parameter_list|()
specifier|const
block|{
name|META_ASSERT
argument_list|(
name|gl
operator|::
name|IMPLEMENTATION_MAX_VERTEX_SHADER_UNIFORM_BUFFERS
operator|>=
name|D3D10_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT
operator|&&
name|gl
operator|::
name|IMPLEMENTATION_MAX_VERTEX_SHADER_UNIFORM_BUFFERS
operator|>=
name|D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mFeatureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT
operator|-
name|getReservedVertexUniformBuffers
argument_list|()
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT
operator|-
name|getReservedVertexUniformBuffers
argument_list|()
return|;
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|0
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|getMaxFragmentShaderUniformBuffers
name|unsigned
name|int
name|Renderer11
operator|::
name|getMaxFragmentShaderUniformBuffers
parameter_list|()
specifier|const
block|{
name|META_ASSERT
argument_list|(
name|gl
operator|::
name|IMPLEMENTATION_MAX_FRAGMENT_SHADER_UNIFORM_BUFFERS
operator|>=
name|D3D10_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT
operator|&&
name|gl
operator|::
name|IMPLEMENTATION_MAX_FRAGMENT_SHADER_UNIFORM_BUFFERS
operator|>=
name|D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mFeatureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT
operator|-
name|getReservedFragmentUniformBuffers
argument_list|()
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT
operator|-
name|getReservedFragmentUniformBuffers
argument_list|()
return|;
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|0
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|getReservedVertexUniformBuffers
name|unsigned
name|int
name|Renderer11
operator|::
name|getReservedVertexUniformBuffers
parameter_list|()
specifier|const
block|{
comment|// we reserve one buffer for the application uniforms, and one for driver uniforms
return|return
literal|2
return|;
block|}
DECL|function|getReservedFragmentUniformBuffers
name|unsigned
name|int
name|Renderer11
operator|::
name|getReservedFragmentUniformBuffers
parameter_list|()
specifier|const
block|{
comment|// we reserve one buffer for the application uniforms, and one for driver uniforms
return|return
literal|2
return|;
block|}
DECL|function|getReservedVaryings
name|unsigned
name|int
name|Renderer11
operator|::
name|getReservedVaryings
parameter_list|()
specifier|const
block|{
comment|// We potentially reserve varyings for gl_Position, dx_Position, gl_FragCoord and gl_PointSize
return|return
literal|4
return|;
block|}
DECL|function|getMaxTransformFeedbackBuffers
name|unsigned
name|int
name|Renderer11
operator|::
name|getMaxTransformFeedbackBuffers
parameter_list|()
specifier|const
block|{
name|META_ASSERT
argument_list|(
name|gl
operator|::
name|IMPLEMENTATION_MAX_TRANSFORM_FEEDBACK_BUFFERS
operator|>=
name|D3D11_SO_BUFFER_SLOT_COUNT
operator|&&
name|gl
operator|::
name|IMPLEMENTATION_MAX_TRANSFORM_FEEDBACK_BUFFERS
operator|>=
name|D3D10_SO_BUFFER_SLOT_COUNT
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mFeatureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_SO_BUFFER_SLOT_COUNT
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
return|return
name|D3D10_1_SO_BUFFER_SLOT_COUNT
return|;
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_SO_BUFFER_SLOT_COUNT
return|;
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|0
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|getMaxTransformFeedbackSeparateComponents
name|unsigned
name|int
name|Renderer11
operator|::
name|getMaxTransformFeedbackSeparateComponents
parameter_list|()
specifier|const
block|{
switch|switch
condition|(
name|mFeatureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|getMaxTransformFeedbackInterleavedComponents
argument_list|()
operator|/
name|getMaxTransformFeedbackBuffers
argument_list|()
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
comment|// D3D 10 and 10.1 only allow one output per output slot if an output slot other than zero
comment|// is used.
return|return
literal|4
return|;
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|0
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|getMaxTransformFeedbackInterleavedComponents
name|unsigned
name|int
name|Renderer11
operator|::
name|getMaxTransformFeedbackInterleavedComponents
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|getMaxVaryingVectors
argument_list|()
operator|*
literal|4
operator|)
return|;
block|}
DECL|function|getMaxUniformBufferSize
name|unsigned
name|int
name|Renderer11
operator|::
name|getMaxUniformBufferSize
parameter_list|()
specifier|const
block|{
comment|// Each component is a 4-element vector of 4-byte units (floats)
specifier|const
name|unsigned
name|int
name|bytesPerComponent
init|=
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|float
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|mFeatureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_REQ_CONSTANT_BUFFER_ELEMENT_COUNT
operator|*
name|bytesPerComponent
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_REQ_CONSTANT_BUFFER_ELEMENT_COUNT
operator|*
name|bytesPerComponent
return|;
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|0
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|getShareHandleSupport
name|bool
name|Renderer11
operator|::
name|getShareHandleSupport
parameter_list|()
specifier|const
block|{
comment|// We only currently support share handles with BGRA surfaces, because
comment|// chrome needs BGRA. Once chrome fixes this, we should always support them.
comment|// PIX doesn't seem to support using share handles, so disable them.
return|return
name|getRendererExtensions
argument_list|()
operator|.
name|textureFormatBGRA8888
operator|&&
operator|!
name|gl
operator|::
name|perfActive
argument_list|()
return|;
block|}
DECL|function|getPostSubBufferSupport
name|bool
name|Renderer11
operator|::
name|getPostSubBufferSupport
parameter_list|()
specifier|const
block|{
comment|// D3D11 does not support present with dirty rectangles until D3D11.1 and DXGI 1.2.
return|return
literal|false
return|;
block|}
DECL|function|getMaxRecommendedElementsIndices
name|int
name|Renderer11
operator|::
name|getMaxRecommendedElementsIndices
parameter_list|()
specifier|const
block|{
name|META_ASSERT
argument_list|(
name|D3D11_REQ_DRAWINDEXED_INDEX_COUNT_2_TO_EXP
operator|==
literal|32
argument_list|)
expr_stmt|;
name|META_ASSERT
argument_list|(
name|D3D10_REQ_DRAWINDEXED_INDEX_COUNT_2_TO_EXP
operator|==
literal|32
argument_list|)
expr_stmt|;
comment|// D3D11 allows up to 2^32 elements, but we report max signed int for convenience.
return|return
name|std
operator|::
name|numeric_limits
argument_list|<
name|GLint
argument_list|>
operator|::
name|max
argument_list|()
return|;
block|}
DECL|function|getMaxRecommendedElementsVertices
name|int
name|Renderer11
operator|::
name|getMaxRecommendedElementsVertices
parameter_list|()
specifier|const
block|{
name|META_ASSERT
argument_list|(
name|D3D11_REQ_DRAW_VERTEX_COUNT_2_TO_EXP
operator|==
literal|32
argument_list|)
expr_stmt|;
name|META_ASSERT
argument_list|(
name|D3D10_REQ_DRAW_VERTEX_COUNT_2_TO_EXP
operator|==
literal|32
argument_list|)
expr_stmt|;
comment|// D3D11 allows up to 2^32 elements, but we report max signed int for convenience.
return|return
name|std
operator|::
name|numeric_limits
argument_list|<
name|GLint
argument_list|>
operator|::
name|max
argument_list|()
return|;
block|}
DECL|function|getSRGBTextureSupport
name|bool
name|Renderer11
operator|::
name|getSRGBTextureSupport
parameter_list|()
specifier|const
block|{
return|return
literal|true
return|;
block|}
DECL|function|getMajorShaderModel
name|int
name|Renderer11
operator|::
name|getMajorShaderModel
parameter_list|()
specifier|const
block|{
switch|switch
condition|(
name|mFeatureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_SHADER_MAJOR_VERSION
return|;
comment|// 5
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
return|return
name|D3D10_1_SHADER_MAJOR_VERSION
return|;
comment|// 4
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
name|D3D10_SHADER_MAJOR_VERSION
return|;
comment|// 4
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|getMinorShaderModel
name|int
name|Renderer11
operator|::
name|getMinorShaderModel
parameter_list|()
specifier|const
block|{
switch|switch
condition|(
name|mFeatureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_SHADER_MINOR_VERSION
return|;
comment|// 0
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
return|return
name|D3D10_1_SHADER_MINOR_VERSION
return|;
comment|// 1
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
name|D3D10_SHADER_MINOR_VERSION
return|;
comment|// 0
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|getMinSwapInterval
name|int
name|Renderer11
operator|::
name|getMinSwapInterval
parameter_list|()
specifier|const
block|{
return|return
literal|0
return|;
block|}
DECL|function|getMaxSwapInterval
name|int
name|Renderer11
operator|::
name|getMaxSwapInterval
parameter_list|()
specifier|const
block|{
return|return
literal|4
return|;
block|}
DECL|function|getMaxSupportedSamples
name|int
name|Renderer11
operator|::
name|getMaxSupportedSamples
parameter_list|()
specifier|const
block|{
return|return
name|mMaxSupportedSamples
return|;
block|}
DECL|function|getMaxSupportedFormatSamples
name|GLsizei
name|Renderer11
operator|::
name|getMaxSupportedFormatSamples
parameter_list|(
name|GLenum
name|internalFormat
parameter_list|)
specifier|const
block|{
name|DXGI_FORMAT
name|format
init|=
name|gl_d3d11
operator|::
name|GetRenderableFormat
argument_list|(
name|internalFormat
argument_list|)
decl_stmt|;
name|MultisampleSupportMap
operator|::
name|const_iterator
name|iter
init|=
name|mMultisampleSupportMap
operator|.
name|find
argument_list|(
name|format
argument_list|)
decl_stmt|;
return|return
operator|(
name|iter
operator|!=
name|mMultisampleSupportMap
operator|.
name|end
argument_list|()
operator|)
condition|?
name|iter
operator|->
name|second
operator|.
name|maxSupportedSamples
else|:
literal|0
return|;
block|}
DECL|function|getNumSampleCounts
name|GLsizei
name|Renderer11
operator|::
name|getNumSampleCounts
parameter_list|(
name|GLenum
name|internalFormat
parameter_list|)
specifier|const
block|{
name|unsigned
name|int
name|numCounts
init|=
literal|0
decl_stmt|;
comment|// D3D11 supports multisampling for signed and unsigned format, but ES 3.0 does not
name|GLenum
name|componentType
init|=
name|gl
operator|::
name|GetComponentType
argument_list|(
name|internalFormat
argument_list|)
decl_stmt|;
if|if
condition|(
name|componentType
operator|!=
name|GL_INT
operator|&&
name|componentType
operator|!=
name|GL_UNSIGNED_INT
condition|)
block|{
name|DXGI_FORMAT
name|format
init|=
name|gl_d3d11
operator|::
name|GetRenderableFormat
argument_list|(
name|internalFormat
argument_list|)
decl_stmt|;
name|MultisampleSupportMap
operator|::
name|const_iterator
name|iter
init|=
name|mMultisampleSupportMap
operator|.
name|find
argument_list|(
name|format
argument_list|)
decl_stmt|;
if|if
condition|(
name|iter
operator|!=
name|mMultisampleSupportMap
operator|.
name|end
argument_list|()
condition|)
block|{
specifier|const
name|MultisampleSupportInfo
modifier|&
name|info
init|=
name|iter
operator|->
name|second
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|D3D11_MAX_MULTISAMPLE_SAMPLE_COUNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|info
operator|.
name|qualityLevels
index|[
name|i
index|]
operator|>
literal|0
condition|)
block|{
name|numCounts
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|numCounts
return|;
block|}
DECL|function|getSampleCounts
name|void
name|Renderer11
operator|::
name|getSampleCounts
parameter_list|(
name|GLenum
name|internalFormat
parameter_list|,
name|GLsizei
name|bufSize
parameter_list|,
name|GLint
modifier|*
name|params
parameter_list|)
specifier|const
block|{
comment|// D3D11 supports multisampling for signed and unsigned format, but ES 3.0 does not
name|GLenum
name|componentType
init|=
name|gl
operator|::
name|GetComponentType
argument_list|(
name|internalFormat
argument_list|)
decl_stmt|;
if|if
condition|(
name|componentType
operator|==
name|GL_INT
operator|||
name|componentType
operator|==
name|GL_UNSIGNED_INT
condition|)
block|{
return|return;
block|}
name|DXGI_FORMAT
name|format
init|=
name|gl_d3d11
operator|::
name|GetRenderableFormat
argument_list|(
name|internalFormat
argument_list|)
decl_stmt|;
name|MultisampleSupportMap
operator|::
name|const_iterator
name|iter
init|=
name|mMultisampleSupportMap
operator|.
name|find
argument_list|(
name|format
argument_list|)
decl_stmt|;
if|if
condition|(
name|iter
operator|!=
name|mMultisampleSupportMap
operator|.
name|end
argument_list|()
condition|)
block|{
specifier|const
name|MultisampleSupportInfo
modifier|&
name|info
init|=
name|iter
operator|->
name|second
decl_stmt|;
name|int
name|bufPos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|D3D11_MAX_MULTISAMPLE_SAMPLE_COUNT
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
operator|&&
name|bufPos
operator|<
name|bufSize
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|info
operator|.
name|qualityLevels
index|[
name|i
index|]
operator|>
literal|0
condition|)
block|{
name|params
index|[
name|bufPos
operator|++
index|]
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|function|getNearestSupportedSamples
name|int
name|Renderer11
operator|::
name|getNearestSupportedSamples
parameter_list|(
name|DXGI_FORMAT
name|format
parameter_list|,
name|unsigned
name|int
name|requested
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|requested
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|MultisampleSupportMap
operator|::
name|const_iterator
name|iter
init|=
name|mMultisampleSupportMap
operator|.
name|find
argument_list|(
name|format
argument_list|)
decl_stmt|;
if|if
condition|(
name|iter
operator|!=
name|mMultisampleSupportMap
operator|.
name|end
argument_list|()
condition|)
block|{
specifier|const
name|MultisampleSupportInfo
modifier|&
name|info
init|=
name|iter
operator|->
name|second
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
name|requested
operator|-
literal|1
init|;
name|i
operator|<
name|D3D11_MAX_MULTISAMPLE_SAMPLE_COUNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|info
operator|.
name|qualityLevels
index|[
name|i
index|]
operator|>
literal|0
condition|)
block|{
return|return
name|i
operator|+
literal|1
return|;
block|}
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
DECL|function|copyToRenderTarget
name|bool
name|Renderer11
operator|::
name|copyToRenderTarget
parameter_list|(
name|TextureStorageInterface2D
modifier|*
name|dest
parameter_list|,
name|TextureStorageInterface2D
modifier|*
name|source
parameter_list|)
block|{
if|if
condition|(
name|source
operator|&&
name|dest
condition|)
block|{
name|TextureStorage11_2D
modifier|*
name|source11
init|=
name|TextureStorage11_2D
operator|::
name|makeTextureStorage11_2D
argument_list|(
name|source
operator|->
name|getStorageInstance
argument_list|()
argument_list|)
decl_stmt|;
name|TextureStorage11_2D
modifier|*
name|dest11
init|=
name|TextureStorage11_2D
operator|::
name|makeTextureStorage11_2D
argument_list|(
name|dest
operator|->
name|getStorageInstance
argument_list|()
argument_list|)
decl_stmt|;
name|mDeviceContext
operator|->
name|CopyResource
argument_list|(
name|dest11
operator|->
name|getResource
argument_list|()
argument_list|,
name|source11
operator|->
name|getResource
argument_list|()
argument_list|)
expr_stmt|;
name|dest11
operator|->
name|invalidateSwizzleCache
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|function|copyToRenderTarget
name|bool
name|Renderer11
operator|::
name|copyToRenderTarget
parameter_list|(
name|TextureStorageInterfaceCube
modifier|*
name|dest
parameter_list|,
name|TextureStorageInterfaceCube
modifier|*
name|source
parameter_list|)
block|{
if|if
condition|(
name|source
operator|&&
name|dest
condition|)
block|{
name|TextureStorage11_Cube
modifier|*
name|source11
init|=
name|TextureStorage11_Cube
operator|::
name|makeTextureStorage11_Cube
argument_list|(
name|source
operator|->
name|getStorageInstance
argument_list|()
argument_list|)
decl_stmt|;
name|TextureStorage11_Cube
modifier|*
name|dest11
init|=
name|TextureStorage11_Cube
operator|::
name|makeTextureStorage11_Cube
argument_list|(
name|dest
operator|->
name|getStorageInstance
argument_list|()
argument_list|)
decl_stmt|;
name|mDeviceContext
operator|->
name|CopyResource
argument_list|(
name|dest11
operator|->
name|getResource
argument_list|()
argument_list|,
name|source11
operator|->
name|getResource
argument_list|()
argument_list|)
expr_stmt|;
name|dest11
operator|->
name|invalidateSwizzleCache
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|function|copyToRenderTarget
name|bool
name|Renderer11
operator|::
name|copyToRenderTarget
parameter_list|(
name|TextureStorageInterface3D
modifier|*
name|dest
parameter_list|,
name|TextureStorageInterface3D
modifier|*
name|source
parameter_list|)
block|{
if|if
condition|(
name|source
operator|&&
name|dest
condition|)
block|{
name|TextureStorage11_3D
modifier|*
name|source11
init|=
name|TextureStorage11_3D
operator|::
name|makeTextureStorage11_3D
argument_list|(
name|source
operator|->
name|getStorageInstance
argument_list|()
argument_list|)
decl_stmt|;
name|TextureStorage11_3D
modifier|*
name|dest11
init|=
name|TextureStorage11_3D
operator|::
name|makeTextureStorage11_3D
argument_list|(
name|dest
operator|->
name|getStorageInstance
argument_list|()
argument_list|)
decl_stmt|;
name|mDeviceContext
operator|->
name|CopyResource
argument_list|(
name|dest11
operator|->
name|getResource
argument_list|()
argument_list|,
name|source11
operator|->
name|getResource
argument_list|()
argument_list|)
expr_stmt|;
name|dest11
operator|->
name|invalidateSwizzleCache
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|function|copyToRenderTarget
name|bool
name|Renderer11
operator|::
name|copyToRenderTarget
parameter_list|(
name|TextureStorageInterface2DArray
modifier|*
name|dest
parameter_list|,
name|TextureStorageInterface2DArray
modifier|*
name|source
parameter_list|)
block|{
if|if
condition|(
name|source
operator|&&
name|dest
condition|)
block|{
name|TextureStorage11_2DArray
modifier|*
name|source11
init|=
name|TextureStorage11_2DArray
operator|::
name|makeTextureStorage11_2DArray
argument_list|(
name|source
operator|->
name|getStorageInstance
argument_list|()
argument_list|)
decl_stmt|;
name|TextureStorage11_2DArray
modifier|*
name|dest11
init|=
name|TextureStorage11_2DArray
operator|::
name|makeTextureStorage11_2DArray
argument_list|(
name|dest
operator|->
name|getStorageInstance
argument_list|()
argument_list|)
decl_stmt|;
name|mDeviceContext
operator|->
name|CopyResource
argument_list|(
name|dest11
operator|->
name|getResource
argument_list|()
argument_list|,
name|source11
operator|->
name|getResource
argument_list|()
argument_list|)
expr_stmt|;
name|dest11
operator|->
name|invalidateSwizzleCache
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|function|copyImage
name|bool
name|Renderer11
operator|::
name|copyImage
parameter_list|(
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|sourceRect
parameter_list|,
name|GLenum
name|destFormat
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|TextureStorageInterface2D
modifier|*
name|storage
parameter_list|,
name|GLint
name|level
parameter_list|)
block|{
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|colorbuffer
init|=
name|framebuffer
operator|->
name|getReadColorbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|colorbuffer
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the color buffer from the frame buffer."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|RenderTarget11
modifier|*
name|sourceRenderTarget
init|=
name|RenderTarget11
operator|::
name|makeRenderTarget11
argument_list|(
name|colorbuffer
operator|->
name|getRenderTarget
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sourceRenderTarget
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the render target from the frame buffer."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|ID3D11ShaderResourceView
modifier|*
name|source
init|=
name|sourceRenderTarget
operator|->
name|getShaderResourceView
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|source
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the render target view from the render target."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|TextureStorage11_2D
modifier|*
name|storage11
init|=
name|TextureStorage11_2D
operator|::
name|makeTextureStorage11_2D
argument_list|(
name|storage
operator|->
name|getStorageInstance
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|storage11
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the texture storage from the destination."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|RenderTarget11
modifier|*
name|destRenderTarget
init|=
name|RenderTarget11
operator|::
name|makeRenderTarget11
argument_list|(
name|storage11
operator|->
name|getRenderTarget
argument_list|(
name|level
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|destRenderTarget
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the render target from the destination storage."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|ID3D11RenderTargetView
modifier|*
name|dest
init|=
name|destRenderTarget
operator|->
name|getRenderTargetView
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|dest
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the render target view from the destination render target."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|gl
operator|::
name|Box
name|sourceArea
argument_list|(
name|sourceRect
operator|.
name|x
argument_list|,
name|sourceRect
operator|.
name|y
argument_list|,
literal|0
argument_list|,
name|sourceRect
operator|.
name|width
argument_list|,
name|sourceRect
operator|.
name|height
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Extents
name|sourceSize
argument_list|(
name|sourceRenderTarget
operator|->
name|getWidth
argument_list|()
argument_list|,
name|sourceRenderTarget
operator|->
name|getHeight
argument_list|()
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Box
name|destArea
argument_list|(
name|xoffset
argument_list|,
name|yoffset
argument_list|,
literal|0
argument_list|,
name|sourceRect
operator|.
name|width
argument_list|,
name|sourceRect
operator|.
name|height
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Extents
name|destSize
argument_list|(
name|destRenderTarget
operator|->
name|getWidth
argument_list|()
argument_list|,
name|destRenderTarget
operator|->
name|getHeight
argument_list|()
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|// Use nearest filtering because source and destination are the same size for the direct
comment|// copy
name|bool
name|ret
init|=
name|mBlit
operator|->
name|copyTexture
argument_list|(
name|source
argument_list|,
name|sourceArea
argument_list|,
name|sourceSize
argument_list|,
name|dest
argument_list|,
name|destArea
argument_list|,
name|destSize
argument_list|,
name|NULL
argument_list|,
name|destFormat
argument_list|,
name|GL_NEAREST
argument_list|)
decl_stmt|;
name|storage11
operator|->
name|invalidateSwizzleCacheLevel
argument_list|(
name|level
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
DECL|function|copyImage
name|bool
name|Renderer11
operator|::
name|copyImage
parameter_list|(
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|sourceRect
parameter_list|,
name|GLenum
name|destFormat
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|TextureStorageInterfaceCube
modifier|*
name|storage
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|)
block|{
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|colorbuffer
init|=
name|framebuffer
operator|->
name|getReadColorbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|colorbuffer
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the color buffer from the frame buffer."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|RenderTarget11
modifier|*
name|sourceRenderTarget
init|=
name|RenderTarget11
operator|::
name|makeRenderTarget11
argument_list|(
name|colorbuffer
operator|->
name|getRenderTarget
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sourceRenderTarget
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the render target from the frame buffer."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|ID3D11ShaderResourceView
modifier|*
name|source
init|=
name|sourceRenderTarget
operator|->
name|getShaderResourceView
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|source
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the render target view from the render target."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|TextureStorage11_Cube
modifier|*
name|storage11
init|=
name|TextureStorage11_Cube
operator|::
name|makeTextureStorage11_Cube
argument_list|(
name|storage
operator|->
name|getStorageInstance
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|storage11
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the texture storage from the destination."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|RenderTarget11
modifier|*
name|destRenderTarget
init|=
name|RenderTarget11
operator|::
name|makeRenderTarget11
argument_list|(
name|storage11
operator|->
name|getRenderTargetFace
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|destRenderTarget
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the render target from the destination storage."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|ID3D11RenderTargetView
modifier|*
name|dest
init|=
name|destRenderTarget
operator|->
name|getRenderTargetView
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|dest
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the render target view from the destination render target."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|gl
operator|::
name|Box
name|sourceArea
argument_list|(
name|sourceRect
operator|.
name|x
argument_list|,
name|sourceRect
operator|.
name|y
argument_list|,
literal|0
argument_list|,
name|sourceRect
operator|.
name|width
argument_list|,
name|sourceRect
operator|.
name|height
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Extents
name|sourceSize
argument_list|(
name|sourceRenderTarget
operator|->
name|getWidth
argument_list|()
argument_list|,
name|sourceRenderTarget
operator|->
name|getHeight
argument_list|()
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Box
name|destArea
argument_list|(
name|xoffset
argument_list|,
name|yoffset
argument_list|,
literal|0
argument_list|,
name|sourceRect
operator|.
name|width
argument_list|,
name|sourceRect
operator|.
name|height
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Extents
name|destSize
argument_list|(
name|destRenderTarget
operator|->
name|getWidth
argument_list|()
argument_list|,
name|destRenderTarget
operator|->
name|getHeight
argument_list|()
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|// Use nearest filtering because source and destination are the same size for the direct
comment|// copy
name|bool
name|ret
init|=
name|mBlit
operator|->
name|copyTexture
argument_list|(
name|source
argument_list|,
name|sourceArea
argument_list|,
name|sourceSize
argument_list|,
name|dest
argument_list|,
name|destArea
argument_list|,
name|destSize
argument_list|,
name|NULL
argument_list|,
name|destFormat
argument_list|,
name|GL_NEAREST
argument_list|)
decl_stmt|;
name|storage11
operator|->
name|invalidateSwizzleCacheLevel
argument_list|(
name|level
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
DECL|function|copyImage
name|bool
name|Renderer11
operator|::
name|copyImage
parameter_list|(
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|sourceRect
parameter_list|,
name|GLenum
name|destFormat
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLint
name|zOffset
parameter_list|,
name|TextureStorageInterface3D
modifier|*
name|storage
parameter_list|,
name|GLint
name|level
parameter_list|)
block|{
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|colorbuffer
init|=
name|framebuffer
operator|->
name|getReadColorbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|colorbuffer
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the color buffer from the frame buffer."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|RenderTarget11
modifier|*
name|sourceRenderTarget
init|=
name|RenderTarget11
operator|::
name|makeRenderTarget11
argument_list|(
name|colorbuffer
operator|->
name|getRenderTarget
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sourceRenderTarget
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the render target from the frame buffer."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|ID3D11ShaderResourceView
modifier|*
name|source
init|=
name|sourceRenderTarget
operator|->
name|getShaderResourceView
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|source
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the render target view from the render target."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|TextureStorage11_3D
modifier|*
name|storage11
init|=
name|TextureStorage11_3D
operator|::
name|makeTextureStorage11_3D
argument_list|(
name|storage
operator|->
name|getStorageInstance
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|storage11
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the texture storage from the destination."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|RenderTarget11
modifier|*
name|destRenderTarget
init|=
name|RenderTarget11
operator|::
name|makeRenderTarget11
argument_list|(
name|storage11
operator|->
name|getRenderTargetLayer
argument_list|(
name|level
argument_list|,
name|zOffset
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|destRenderTarget
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the render target from the destination storage."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|ID3D11RenderTargetView
modifier|*
name|dest
init|=
name|destRenderTarget
operator|->
name|getRenderTargetView
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|dest
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the render target view from the destination render target."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|gl
operator|::
name|Box
name|sourceArea
argument_list|(
name|sourceRect
operator|.
name|x
argument_list|,
name|sourceRect
operator|.
name|y
argument_list|,
literal|0
argument_list|,
name|sourceRect
operator|.
name|width
argument_list|,
name|sourceRect
operator|.
name|height
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Extents
name|sourceSize
argument_list|(
name|sourceRenderTarget
operator|->
name|getWidth
argument_list|()
argument_list|,
name|sourceRenderTarget
operator|->
name|getHeight
argument_list|()
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Box
name|destArea
argument_list|(
name|xoffset
argument_list|,
name|yoffset
argument_list|,
literal|0
argument_list|,
name|sourceRect
operator|.
name|width
argument_list|,
name|sourceRect
operator|.
name|height
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Extents
name|destSize
argument_list|(
name|destRenderTarget
operator|->
name|getWidth
argument_list|()
argument_list|,
name|destRenderTarget
operator|->
name|getHeight
argument_list|()
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|// Use nearest filtering because source and destination are the same size for the direct
comment|// copy
name|bool
name|ret
init|=
name|mBlit
operator|->
name|copyTexture
argument_list|(
name|source
argument_list|,
name|sourceArea
argument_list|,
name|sourceSize
argument_list|,
name|dest
argument_list|,
name|destArea
argument_list|,
name|destSize
argument_list|,
name|NULL
argument_list|,
name|destFormat
argument_list|,
name|GL_NEAREST
argument_list|)
decl_stmt|;
name|storage11
operator|->
name|invalidateSwizzleCacheLevel
argument_list|(
name|level
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
DECL|function|copyImage
name|bool
name|Renderer11
operator|::
name|copyImage
parameter_list|(
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|sourceRect
parameter_list|,
name|GLenum
name|destFormat
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLint
name|zOffset
parameter_list|,
name|TextureStorageInterface2DArray
modifier|*
name|storage
parameter_list|,
name|GLint
name|level
parameter_list|)
block|{
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|colorbuffer
init|=
name|framebuffer
operator|->
name|getReadColorbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|colorbuffer
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the color buffer from the frame buffer."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|RenderTarget11
modifier|*
name|sourceRenderTarget
init|=
name|RenderTarget11
operator|::
name|makeRenderTarget11
argument_list|(
name|colorbuffer
operator|->
name|getRenderTarget
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sourceRenderTarget
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the render target from the frame buffer."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|ID3D11ShaderResourceView
modifier|*
name|source
init|=
name|sourceRenderTarget
operator|->
name|getShaderResourceView
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|source
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the render target view from the render target."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|TextureStorage11_2DArray
modifier|*
name|storage11
init|=
name|TextureStorage11_2DArray
operator|::
name|makeTextureStorage11_2DArray
argument_list|(
name|storage
operator|->
name|getStorageInstance
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|storage11
condition|)
block|{
name|SafeRelease
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|ERR
argument_list|(
literal|"Failed to retrieve the texture storage from the destination."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|RenderTarget11
modifier|*
name|destRenderTarget
init|=
name|RenderTarget11
operator|::
name|makeRenderTarget11
argument_list|(
name|storage11
operator|->
name|getRenderTargetLayer
argument_list|(
name|level
argument_list|,
name|zOffset
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|destRenderTarget
condition|)
block|{
name|SafeRelease
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|ERR
argument_list|(
literal|"Failed to retrieve the render target from the destination storage."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|ID3D11RenderTargetView
modifier|*
name|dest
init|=
name|destRenderTarget
operator|->
name|getRenderTargetView
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|dest
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the render target view from the destination render target."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|gl
operator|::
name|Box
name|sourceArea
argument_list|(
name|sourceRect
operator|.
name|x
argument_list|,
name|sourceRect
operator|.
name|y
argument_list|,
literal|0
argument_list|,
name|sourceRect
operator|.
name|width
argument_list|,
name|sourceRect
operator|.
name|height
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Extents
name|sourceSize
argument_list|(
name|sourceRenderTarget
operator|->
name|getWidth
argument_list|()
argument_list|,
name|sourceRenderTarget
operator|->
name|getHeight
argument_list|()
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Box
name|destArea
argument_list|(
name|xoffset
argument_list|,
name|yoffset
argument_list|,
literal|0
argument_list|,
name|sourceRect
operator|.
name|width
argument_list|,
name|sourceRect
operator|.
name|height
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Extents
name|destSize
argument_list|(
name|destRenderTarget
operator|->
name|getWidth
argument_list|()
argument_list|,
name|destRenderTarget
operator|->
name|getHeight
argument_list|()
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|// Use nearest filtering because source and destination are the same size for the direct
comment|// copy
name|bool
name|ret
init|=
name|mBlit
operator|->
name|copyTexture
argument_list|(
name|source
argument_list|,
name|sourceArea
argument_list|,
name|sourceSize
argument_list|,
name|dest
argument_list|,
name|destArea
argument_list|,
name|destSize
argument_list|,
name|NULL
argument_list|,
name|destFormat
argument_list|,
name|GL_NEAREST
argument_list|)
decl_stmt|;
name|storage11
operator|->
name|invalidateSwizzleCacheLevel
argument_list|(
name|level
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
DECL|function|unapplyRenderTargets
name|void
name|Renderer11
operator|::
name|unapplyRenderTargets
parameter_list|()
block|{
name|setOneTimeRenderTarget
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
DECL|function|setOneTimeRenderTarget
name|void
name|Renderer11
operator|::
name|setOneTimeRenderTarget
parameter_list|(
name|ID3D11RenderTargetView
modifier|*
name|renderTargetView
parameter_list|)
block|{
name|ID3D11RenderTargetView
modifier|*
name|rtvArray
index|[
name|gl
operator|::
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
index|]
init|=
block|{
name|NULL
block|}
decl_stmt|;
name|rtvArray
index|[
literal|0
index|]
operator|=
name|renderTargetView
expr_stmt|;
name|mDeviceContext
operator|->
name|OMSetRenderTargets
argument_list|(
name|getRendererCaps
argument_list|()
operator|.
name|maxDrawBuffers
argument_list|,
name|rtvArray
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|// Do not preserve the serial for this one-time-use render target
for|for
control|(
name|unsigned
name|int
name|rtIndex
init|=
literal|0
init|;
name|rtIndex
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
condition|;
name|rtIndex
operator|++
control|)
block|{
name|mAppliedRenderTargetSerials
index|[
name|rtIndex
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
DECL|function|createRenderTarget
name|RenderTarget
modifier|*
name|Renderer11
operator|::
name|createRenderTarget
parameter_list|(
name|SwapChain
modifier|*
name|swapChain
parameter_list|,
name|bool
name|depth
parameter_list|)
block|{
name|SwapChain11
modifier|*
name|swapChain11
init|=
name|SwapChain11
operator|::
name|makeSwapChain11
argument_list|(
name|swapChain
argument_list|)
decl_stmt|;
name|RenderTarget11
modifier|*
name|renderTarget
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|depth
condition|)
block|{
comment|// Note: depth stencil may be NULL for 0 sized surfaces
name|renderTarget
operator|=
operator|new
name|RenderTarget11
argument_list|(
name|this
argument_list|,
name|swapChain11
operator|->
name|getDepthStencil
argument_list|()
argument_list|,
name|swapChain11
operator|->
name|getDepthStencilTexture
argument_list|()
argument_list|,
name|swapChain11
operator|->
name|getDepthStencilShaderResource
argument_list|()
argument_list|,
name|swapChain11
operator|->
name|getWidth
argument_list|()
argument_list|,
name|swapChain11
operator|->
name|getHeight
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Note: render target may be NULL for 0 sized surfaces
name|renderTarget
operator|=
operator|new
name|RenderTarget11
argument_list|(
name|this
argument_list|,
name|swapChain11
operator|->
name|getRenderTarget
argument_list|()
argument_list|,
name|swapChain11
operator|->
name|getOffscreenTexture
argument_list|()
argument_list|,
name|swapChain11
operator|->
name|getRenderTargetShaderResource
argument_list|()
argument_list|,
name|swapChain11
operator|->
name|getWidth
argument_list|()
argument_list|,
name|swapChain11
operator|->
name|getHeight
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|renderTarget
return|;
block|}
DECL|function|createRenderTarget
name|RenderTarget
modifier|*
name|Renderer11
operator|::
name|createRenderTarget
parameter_list|(
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLsizei
name|samples
parameter_list|)
block|{
name|RenderTarget11
modifier|*
name|renderTarget
init|=
operator|new
name|RenderTarget11
argument_list|(
name|this
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|samples
argument_list|)
decl_stmt|;
return|return
name|renderTarget
return|;
block|}
DECL|function|loadExecutable
name|ShaderExecutable
modifier|*
name|Renderer11
operator|::
name|loadExecutable
parameter_list|(
specifier|const
name|void
modifier|*
name|function
parameter_list|,
name|size_t
name|length
parameter_list|,
name|rx
operator|::
name|ShaderType
name|type
parameter_list|,
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|gl
operator|::
name|LinkedVarying
argument_list|>
modifier|&
name|transformFeedbackVaryings
parameter_list|,
name|bool
name|separatedOutputBuffers
parameter_list|)
block|{
name|ShaderExecutable11
modifier|*
name|executable
init|=
name|NULL
decl_stmt|;
name|HRESULT
name|result
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|rx
operator|::
name|SHADER_VERTEX
case|:
block|{
name|ID3D11VertexShader
modifier|*
name|vertexShader
init|=
name|NULL
decl_stmt|;
name|ID3D11GeometryShader
modifier|*
name|streamOutShader
init|=
name|NULL
decl_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|CreateVertexShader
argument_list|(
name|function
argument_list|,
name|length
argument_list|,
name|NULL
argument_list|,
operator|&
name|vertexShader
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|transformFeedbackVaryings
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|std
operator|::
name|vector
argument_list|<
name|D3D11_SO_DECLARATION_ENTRY
argument_list|>
name|soDeclaration
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|transformFeedbackVaryings
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|gl
operator|::
name|LinkedVarying
modifier|&
name|varying
init|=
name|transformFeedbackVaryings
index|[
name|i
index|]
decl_stmt|;
name|GLenum
name|transposedType
init|=
name|gl
operator|::
name|TransposeMatrixType
argument_list|(
name|varying
operator|.
name|type
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|j
init|=
literal|0
init|;
name|j
operator|<
name|varying
operator|.
name|semanticIndexCount
condition|;
name|j
operator|++
control|)
block|{
name|D3D11_SO_DECLARATION_ENTRY
name|entry
init|=
block|{
literal|0
block|}
decl_stmt|;
name|entry
operator|.
name|Stream
operator|=
literal|0
expr_stmt|;
name|entry
operator|.
name|SemanticName
operator|=
name|varying
operator|.
name|semanticName
operator|.
name|c_str
argument_list|()
expr_stmt|;
name|entry
operator|.
name|SemanticIndex
operator|=
name|varying
operator|.
name|semanticIndex
operator|+
name|j
expr_stmt|;
name|entry
operator|.
name|StartComponent
operator|=
literal|0
expr_stmt|;
name|entry
operator|.
name|ComponentCount
operator|=
name|gl
operator|::
name|VariableColumnCount
argument_list|(
name|transposedType
argument_list|)
expr_stmt|;
name|entry
operator|.
name|OutputSlot
operator|=
operator|(
name|separatedOutputBuffers
condition|?
name|i
else|:
literal|0
operator|)
expr_stmt|;
name|soDeclaration
operator|.
name|push_back
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
name|result
operator|=
name|mDevice
operator|->
name|CreateGeometryShaderWithStreamOutput
argument_list|(
name|function
argument_list|,
name|length
argument_list|,
name|soDeclaration
operator|.
name|data
argument_list|()
argument_list|,
name|soDeclaration
operator|.
name|size
argument_list|()
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|streamOutShader
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vertexShader
condition|)
block|{
name|executable
operator|=
operator|new
name|ShaderExecutable11
argument_list|(
name|function
argument_list|,
name|length
argument_list|,
name|vertexShader
argument_list|,
name|streamOutShader
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|rx
operator|::
name|SHADER_PIXEL
case|:
block|{
name|ID3D11PixelShader
modifier|*
name|pixelShader
init|=
name|NULL
decl_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|CreatePixelShader
argument_list|(
name|function
argument_list|,
name|length
argument_list|,
name|NULL
argument_list|,
operator|&
name|pixelShader
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pixelShader
condition|)
block|{
name|executable
operator|=
operator|new
name|ShaderExecutable11
argument_list|(
name|function
argument_list|,
name|length
argument_list|,
name|pixelShader
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|rx
operator|::
name|SHADER_GEOMETRY
case|:
block|{
name|ID3D11GeometryShader
modifier|*
name|geometryShader
init|=
name|NULL
decl_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|CreateGeometryShader
argument_list|(
name|function
argument_list|,
name|length
argument_list|,
name|NULL
argument_list|,
operator|&
name|geometryShader
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|geometryShader
condition|)
block|{
name|executable
operator|=
operator|new
name|ShaderExecutable11
argument_list|(
name|function
argument_list|,
name|length
argument_list|,
name|geometryShader
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
name|executable
return|;
block|}
DECL|function|compileToExecutable
name|ShaderExecutable
modifier|*
name|Renderer11
operator|::
name|compileToExecutable
parameter_list|(
name|gl
operator|::
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|char
modifier|*
name|shaderHLSL
parameter_list|,
name|rx
operator|::
name|ShaderType
name|type
parameter_list|,
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|gl
operator|::
name|LinkedVarying
argument_list|>
modifier|&
name|transformFeedbackVaryings
parameter_list|,
name|bool
name|separatedOutputBuffers
parameter_list|,
name|D3DWorkaroundType
name|workaround
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|profileType
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|rx
operator|::
name|SHADER_VERTEX
case|:
name|profileType
operator|=
literal|"vs"
expr_stmt|;
break|break;
case|case
name|rx
operator|::
name|SHADER_PIXEL
case|:
name|profileType
operator|=
literal|"ps"
expr_stmt|;
break|break;
case|case
name|rx
operator|::
name|SHADER_GEOMETRY
case|:
name|profileType
operator|=
literal|"gs"
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
specifier|const
name|char
modifier|*
name|profileVersion
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|mFeatureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
name|profileVersion
operator|=
literal|"5_0"
expr_stmt|;
break|break;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
name|profileVersion
operator|=
literal|"4_1"
expr_stmt|;
break|break;
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
name|profileVersion
operator|=
literal|"4_0"
expr_stmt|;
break|break;
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
name|profileVersion
operator|=
literal|"4_0_level_9_3"
expr_stmt|;
break|break;
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
name|profileVersion
operator|=
literal|"4_0_level_9_2"
expr_stmt|;
break|break;
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
name|profileVersion
operator|=
literal|"4_0_level_9_1"
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|char
name|profile
index|[
literal|32
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|profile
argument_list|,
name|ArraySize
argument_list|(
name|profile
argument_list|)
argument_list|,
literal|"%s_%s"
argument_list|,
name|profileType
argument_list|,
name|profileVersion
argument_list|)
expr_stmt|;
name|UINT
name|flags
init|=
name|D3DCOMPILE_OPTIMIZATION_LEVEL0
decl_stmt|;
if|if
condition|(
name|gl
operator|::
name|perfActive
argument_list|()
condition|)
block|{
ifndef|#
directive|ifndef
name|NDEBUG
name|flags
operator|=
name|D3DCOMPILE_SKIP_OPTIMIZATION
expr_stmt|;
endif|#
directive|endif
name|flags
operator||=
name|D3DCOMPILE_DEBUG
expr_stmt|;
name|std
operator|::
name|string
name|sourcePath
init|=
name|getTempPath
argument_list|()
decl_stmt|;
name|std
operator|::
name|string
name|sourceText
init|=
name|std
operator|::
name|string
argument_list|(
literal|"#line 2 \""
argument_list|)
operator|+
name|sourcePath
operator|+
name|std
operator|::
name|string
argument_list|(
literal|"\"\n\n"
argument_list|)
operator|+
name|std
operator|::
name|string
argument_list|(
name|shaderHLSL
argument_list|)
decl_stmt|;
name|writeFile
argument_list|(
name|sourcePath
operator|.
name|c_str
argument_list|()
argument_list|,
name|sourceText
operator|.
name|c_str
argument_list|()
argument_list|,
name|sourceText
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Sometimes D3DCompile will fail with the default compilation flags for complicated shaders when it would otherwise pass with alternative options.
comment|// Try the default flags first and if compilation fails, try some alternatives.
specifier|const
name|UINT
name|extraFlags
index|[]
init|=
block|{
name|flags
block|,
name|flags
operator||
name|D3DCOMPILE_SKIP_VALIDATION
block|,
name|flags
operator||
name|D3DCOMPILE_SKIP_OPTIMIZATION
block|}
decl_stmt|;
specifier|const
specifier|static
name|char
modifier|*
name|extraFlagNames
index|[]
init|=
block|{
literal|"default"
block|,
literal|"skip validation"
block|,
literal|"skip optimization"
block|}
decl_stmt|;
name|int
name|attempts
init|=
name|ArraySize
argument_list|(
name|extraFlags
argument_list|)
decl_stmt|;
name|ID3DBlob
modifier|*
name|binary
init|=
operator|(
name|ID3DBlob
operator|*
operator|)
name|mCompiler
operator|.
name|compileToBinary
argument_list|(
name|infoLog
argument_list|,
name|shaderHLSL
argument_list|,
name|profile
argument_list|,
name|extraFlags
argument_list|,
name|extraFlagNames
argument_list|,
name|attempts
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|binary
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|ShaderExecutable
modifier|*
name|executable
init|=
name|loadExecutable
argument_list|(
operator|(
name|DWORD
operator|*
operator|)
name|binary
operator|->
name|GetBufferPointer
argument_list|()
argument_list|,
name|binary
operator|->
name|GetBufferSize
argument_list|()
argument_list|,
name|type
argument_list|,
name|transformFeedbackVaryings
argument_list|,
name|separatedOutputBuffers
argument_list|)
decl_stmt|;
name|SafeRelease
argument_list|(
name|binary
argument_list|)
expr_stmt|;
return|return
name|executable
return|;
block|}
DECL|function|createUniformStorage
name|rx
operator|::
name|UniformStorage
modifier|*
name|Renderer11
operator|::
name|createUniformStorage
parameter_list|(
name|size_t
name|storageSize
parameter_list|)
block|{
return|return
operator|new
name|UniformStorage11
argument_list|(
name|this
argument_list|,
name|storageSize
argument_list|)
return|;
block|}
DECL|function|createVertexBuffer
name|VertexBuffer
modifier|*
name|Renderer11
operator|::
name|createVertexBuffer
parameter_list|()
block|{
return|return
operator|new
name|VertexBuffer11
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|function|createIndexBuffer
name|IndexBuffer
modifier|*
name|Renderer11
operator|::
name|createIndexBuffer
parameter_list|()
block|{
return|return
operator|new
name|IndexBuffer11
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|function|createBuffer
name|BufferImpl
modifier|*
name|Renderer11
operator|::
name|createBuffer
parameter_list|()
block|{
return|return
operator|new
name|Buffer11
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|function|createVertexArray
name|VertexArrayImpl
modifier|*
name|Renderer11
operator|::
name|createVertexArray
parameter_list|()
block|{
return|return
operator|new
name|VertexArray11
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|function|createQuery
name|QueryImpl
modifier|*
name|Renderer11
operator|::
name|createQuery
parameter_list|(
name|GLenum
name|type
parameter_list|)
block|{
return|return
operator|new
name|Query11
argument_list|(
name|this
argument_list|,
name|type
argument_list|)
return|;
block|}
DECL|function|createFence
name|FenceImpl
modifier|*
name|Renderer11
operator|::
name|createFence
parameter_list|()
block|{
return|return
operator|new
name|Fence11
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|function|supportsFastCopyBufferToTexture
name|bool
name|Renderer11
operator|::
name|supportsFastCopyBufferToTexture
parameter_list|(
name|GLenum
name|internalFormat
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|getRendererExtensions
argument_list|()
operator|.
name|pixelBufferObject
argument_list|)
expr_stmt|;
comment|// sRGB formats do not work with D3D11 buffer SRVs
if|if
condition|(
name|gl
operator|::
name|GetColorEncoding
argument_list|(
name|internalFormat
argument_list|)
operator|==
name|GL_SRGB
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// We cannot support direct copies to non-color-renderable formats
if|if
condition|(
name|gl_d3d11
operator|::
name|GetRTVFormat
argument_list|(
name|internalFormat
argument_list|)
operator|!=
name|DXGI_FORMAT_UNKNOWN
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// We skip all 3-channel formats since sometimes format support is missing
if|if
condition|(
name|gl
operator|::
name|GetComponentCount
argument_list|(
name|internalFormat
argument_list|)
operator|==
literal|3
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// We don't support formats which we can't represent without conversion
if|if
condition|(
name|getNativeTextureFormat
argument_list|(
name|internalFormat
argument_list|)
operator|!=
name|internalFormat
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|fastCopyBufferToTexture
name|bool
name|Renderer11
operator|::
name|fastCopyBufferToTexture
parameter_list|(
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
name|unsigned
name|int
name|offset
parameter_list|,
name|RenderTarget
modifier|*
name|destRenderTarget
parameter_list|,
name|GLenum
name|destinationFormat
parameter_list|,
name|GLenum
name|sourcePixelsType
parameter_list|,
specifier|const
name|gl
operator|::
name|Box
modifier|&
name|destArea
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|supportsFastCopyBufferToTexture
argument_list|(
name|destinationFormat
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|mPixelTransfer
operator|->
name|copyBufferToTexture
argument_list|(
name|unpack
argument_list|,
name|offset
argument_list|,
name|destRenderTarget
argument_list|,
name|destinationFormat
argument_list|,
name|sourcePixelsType
argument_list|,
name|destArea
argument_list|)
return|;
block|}
DECL|function|getRenderTargetResource
name|bool
name|Renderer11
operator|::
name|getRenderTargetResource
parameter_list|(
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|colorbuffer
parameter_list|,
name|unsigned
name|int
modifier|*
name|subresourceIndex
parameter_list|,
name|ID3D11Texture2D
modifier|*
modifier|*
name|resource
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|colorbuffer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|RenderTarget11
modifier|*
name|renderTarget
init|=
name|RenderTarget11
operator|::
name|makeRenderTarget11
argument_list|(
name|colorbuffer
operator|->
name|getRenderTarget
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|renderTarget
condition|)
block|{
operator|*
name|subresourceIndex
operator|=
name|renderTarget
operator|->
name|getSubresourceIndex
argument_list|()
expr_stmt|;
name|ID3D11RenderTargetView
modifier|*
name|colorBufferRTV
init|=
name|renderTarget
operator|->
name|getRenderTargetView
argument_list|()
decl_stmt|;
if|if
condition|(
name|colorBufferRTV
condition|)
block|{
name|ID3D11Resource
modifier|*
name|textureResource
init|=
name|NULL
decl_stmt|;
name|colorBufferRTV
operator|->
name|GetResource
argument_list|(
operator|&
name|textureResource
argument_list|)
expr_stmt|;
if|if
condition|(
name|textureResource
condition|)
block|{
name|HRESULT
name|result
init|=
name|textureResource
operator|->
name|QueryInterface
argument_list|(
name|__uuidof
argument_list|(
name|ID3D11Texture2D
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
name|resource
argument_list|)
decl_stmt|;
name|SafeRelease
argument_list|(
name|textureResource
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
name|ERR
argument_list|(
literal|"Failed to extract the ID3D11Texture2D from the render target resource, "
literal|"HRESULT: 0x%X."
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|function|blitRect
name|bool
name|Renderer11
operator|::
name|blitRect
parameter_list|(
name|gl
operator|::
name|Framebuffer
modifier|*
name|readTarget
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|readRect
parameter_list|,
name|gl
operator|::
name|Framebuffer
modifier|*
name|drawTarget
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|drawRect
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|*
name|scissor
parameter_list|,
name|bool
name|blitRenderTarget
parameter_list|,
name|bool
name|blitDepth
parameter_list|,
name|bool
name|blitStencil
parameter_list|,
name|GLenum
name|filter
parameter_list|)
block|{
if|if
condition|(
name|blitRenderTarget
condition|)
block|{
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|readBuffer
init|=
name|readTarget
operator|->
name|getReadColorbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|readBuffer
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the read buffer from the read framebuffer."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|RenderTarget
modifier|*
name|readRenderTarget
init|=
name|readBuffer
operator|->
name|getRenderTarget
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|colorAttachment
init|=
literal|0
init|;
name|colorAttachment
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
condition|;
name|colorAttachment
operator|++
control|)
block|{
if|if
condition|(
name|drawTarget
operator|->
name|isEnabledColorAttachment
argument_list|(
name|colorAttachment
argument_list|)
condition|)
block|{
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|drawBuffer
init|=
name|drawTarget
operator|->
name|getColorbuffer
argument_list|(
name|colorAttachment
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|drawBuffer
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the draw buffer from the draw framebuffer."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|RenderTarget
modifier|*
name|drawRenderTarget
init|=
name|drawBuffer
operator|->
name|getRenderTarget
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|blitRenderbufferRect
argument_list|(
name|readRect
argument_list|,
name|drawRect
argument_list|,
name|readRenderTarget
argument_list|,
name|drawRenderTarget
argument_list|,
name|filter
argument_list|,
name|scissor
argument_list|,
name|blitRenderTarget
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|blitDepth
operator|||
name|blitStencil
condition|)
block|{
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|readBuffer
init|=
name|readTarget
operator|->
name|getDepthOrStencilbuffer
argument_list|()
decl_stmt|;
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|drawBuffer
init|=
name|drawTarget
operator|->
name|getDepthOrStencilbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|readBuffer
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the read depth-stencil buffer from the read framebuffer."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|drawBuffer
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the draw depth-stencil buffer from the draw framebuffer."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|RenderTarget
modifier|*
name|readRenderTarget
init|=
name|readBuffer
operator|->
name|getDepthStencil
argument_list|()
decl_stmt|;
name|RenderTarget
modifier|*
name|drawRenderTarget
init|=
name|drawBuffer
operator|->
name|getDepthStencil
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|blitRenderbufferRect
argument_list|(
name|readRect
argument_list|,
name|drawRect
argument_list|,
name|readRenderTarget
argument_list|,
name|drawRenderTarget
argument_list|,
name|filter
argument_list|,
name|scissor
argument_list|,
literal|false
argument_list|,
name|blitDepth
argument_list|,
name|blitStencil
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
name|invalidateFramebufferSwizzles
argument_list|(
name|drawTarget
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|readPixels
name|void
name|Renderer11
operator|::
name|readPixels
parameter_list|(
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLuint
name|outputPitch
parameter_list|,
specifier|const
name|gl
operator|::
name|PixelPackState
modifier|&
name|pack
parameter_list|,
name|void
modifier|*
name|pixels
parameter_list|)
block|{
name|ID3D11Texture2D
modifier|*
name|colorBufferTexture
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|subresourceIndex
init|=
literal|0
decl_stmt|;
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|colorbuffer
init|=
name|framebuffer
operator|->
name|getReadColorbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|colorbuffer
operator|&&
name|getRenderTargetResource
argument_list|(
name|colorbuffer
argument_list|,
operator|&
name|subresourceIndex
argument_list|,
operator|&
name|colorBufferTexture
argument_list|)
condition|)
block|{
name|gl
operator|::
name|Rectangle
name|area
decl_stmt|;
name|area
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|area
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|area
operator|.
name|width
operator|=
name|width
expr_stmt|;
name|area
operator|.
name|height
operator|=
name|height
expr_stmt|;
if|if
condition|(
name|pack
operator|.
name|pixelBuffer
operator|.
name|get
argument_list|()
operator|!=
name|NULL
condition|)
block|{
name|rx
operator|::
name|Buffer11
modifier|*
name|packBufferStorage
init|=
name|Buffer11
operator|::
name|makeBuffer11
argument_list|(
name|pack
operator|.
name|pixelBuffer
operator|.
name|get
argument_list|()
operator|->
name|getImplementation
argument_list|()
argument_list|)
decl_stmt|;
name|PackPixelsParams
name|packParams
argument_list|(
name|area
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|outputPitch
argument_list|,
name|pack
argument_list|,
cast|reinterpret_cast
argument_list|<
name|ptrdiff_t
argument_list|>
argument_list|(
name|pixels
argument_list|)
argument_list|)
decl_stmt|;
name|packBufferStorage
operator|->
name|packPixels
argument_list|(
name|colorBufferTexture
argument_list|,
name|subresourceIndex
argument_list|,
name|packParams
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|readTextureData
argument_list|(
name|colorBufferTexture
argument_list|,
name|subresourceIndex
argument_list|,
name|area
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|outputPitch
argument_list|,
name|pack
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
block|}
name|SafeRelease
argument_list|(
name|colorBufferTexture
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|createImage
name|Image
modifier|*
name|Renderer11
operator|::
name|createImage
parameter_list|()
block|{
return|return
operator|new
name|Image11
argument_list|()
return|;
block|}
DECL|function|generateMipmap
name|void
name|Renderer11
operator|::
name|generateMipmap
parameter_list|(
name|Image
modifier|*
name|dest
parameter_list|,
name|Image
modifier|*
name|src
parameter_list|)
block|{
name|Image11
modifier|*
name|dest11
init|=
name|Image11
operator|::
name|makeImage11
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|Image11
modifier|*
name|src11
init|=
name|Image11
operator|::
name|makeImage11
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|Image11
operator|::
name|generateMipmap
argument_list|(
name|dest11
argument_list|,
name|src11
argument_list|)
expr_stmt|;
block|}
DECL|function|createTextureStorage2D
name|TextureStorage
modifier|*
name|Renderer11
operator|::
name|createTextureStorage2D
parameter_list|(
name|SwapChain
modifier|*
name|swapChain
parameter_list|)
block|{
name|SwapChain11
modifier|*
name|swapChain11
init|=
name|SwapChain11
operator|::
name|makeSwapChain11
argument_list|(
name|swapChain
argument_list|)
decl_stmt|;
return|return
operator|new
name|TextureStorage11_2D
argument_list|(
name|this
argument_list|,
name|swapChain11
argument_list|)
return|;
block|}
DECL|function|createTextureStorage2D
name|TextureStorage
modifier|*
name|Renderer11
operator|::
name|createTextureStorage2D
parameter_list|(
name|GLenum
name|internalformat
parameter_list|,
name|bool
name|renderTarget
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|int
name|levels
parameter_list|)
block|{
return|return
operator|new
name|TextureStorage11_2D
argument_list|(
name|this
argument_list|,
name|internalformat
argument_list|,
name|renderTarget
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|levels
argument_list|)
return|;
block|}
DECL|function|createTextureStorageCube
name|TextureStorage
modifier|*
name|Renderer11
operator|::
name|createTextureStorageCube
parameter_list|(
name|GLenum
name|internalformat
parameter_list|,
name|bool
name|renderTarget
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|levels
parameter_list|)
block|{
return|return
operator|new
name|TextureStorage11_Cube
argument_list|(
name|this
argument_list|,
name|internalformat
argument_list|,
name|renderTarget
argument_list|,
name|size
argument_list|,
name|levels
argument_list|)
return|;
block|}
DECL|function|createTextureStorage3D
name|TextureStorage
modifier|*
name|Renderer11
operator|::
name|createTextureStorage3D
parameter_list|(
name|GLenum
name|internalformat
parameter_list|,
name|bool
name|renderTarget
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|depth
parameter_list|,
name|int
name|levels
parameter_list|)
block|{
return|return
operator|new
name|TextureStorage11_3D
argument_list|(
name|this
argument_list|,
name|internalformat
argument_list|,
name|renderTarget
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|,
name|levels
argument_list|)
return|;
block|}
DECL|function|createTextureStorage2DArray
name|TextureStorage
modifier|*
name|Renderer11
operator|::
name|createTextureStorage2DArray
parameter_list|(
name|GLenum
name|internalformat
parameter_list|,
name|bool
name|renderTarget
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|depth
parameter_list|,
name|int
name|levels
parameter_list|)
block|{
return|return
operator|new
name|TextureStorage11_2DArray
argument_list|(
name|this
argument_list|,
name|internalformat
argument_list|,
name|renderTarget
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|,
name|levels
argument_list|)
return|;
block|}
DECL|function|createTexture2D
name|Texture2DImpl
modifier|*
name|Renderer11
operator|::
name|createTexture2D
parameter_list|()
block|{
return|return
operator|new
name|TextureD3D_2D
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|function|createTextureCube
name|TextureCubeImpl
modifier|*
name|Renderer11
operator|::
name|createTextureCube
parameter_list|()
block|{
return|return
operator|new
name|TextureD3D_Cube
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|function|createTexture3D
name|Texture3DImpl
modifier|*
name|Renderer11
operator|::
name|createTexture3D
parameter_list|()
block|{
return|return
operator|new
name|TextureD3D_3D
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|function|createTexture2DArray
name|Texture2DArrayImpl
modifier|*
name|Renderer11
operator|::
name|createTexture2DArray
parameter_list|()
block|{
return|return
operator|new
name|TextureD3D_2DArray
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|function|readTextureData
name|void
name|Renderer11
operator|::
name|readTextureData
parameter_list|(
name|ID3D11Texture2D
modifier|*
name|texture
parameter_list|,
name|unsigned
name|int
name|subResource
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|area
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLuint
name|outputPitch
parameter_list|,
specifier|const
name|gl
operator|::
name|PixelPackState
modifier|&
name|pack
parameter_list|,
name|void
modifier|*
name|pixels
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|area
operator|.
name|width
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|area
operator|.
name|height
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|D3D11_TEXTURE2D_DESC
name|textureDesc
decl_stmt|;
name|texture
operator|->
name|GetDesc
argument_list|(
operator|&
name|textureDesc
argument_list|)
expr_stmt|;
comment|// Clamp read region to the defined texture boundaries, preventing out of bounds reads
comment|// and reads of uninitialized data.
name|gl
operator|::
name|Rectangle
name|safeArea
decl_stmt|;
name|safeArea
operator|.
name|x
operator|=
name|gl
operator|::
name|clamp
argument_list|(
name|area
operator|.
name|x
argument_list|,
literal|0
argument_list|,
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|textureDesc
operator|.
name|Width
argument_list|)
argument_list|)
expr_stmt|;
name|safeArea
operator|.
name|y
operator|=
name|gl
operator|::
name|clamp
argument_list|(
name|area
operator|.
name|y
argument_list|,
literal|0
argument_list|,
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|textureDesc
operator|.
name|Height
argument_list|)
argument_list|)
expr_stmt|;
name|safeArea
operator|.
name|width
operator|=
name|gl
operator|::
name|clamp
argument_list|(
name|area
operator|.
name|width
operator|+
name|std
operator|::
name|min
argument_list|(
name|area
operator|.
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|textureDesc
operator|.
name|Width
argument_list|)
operator|-
name|safeArea
operator|.
name|x
argument_list|)
expr_stmt|;
name|safeArea
operator|.
name|height
operator|=
name|gl
operator|::
name|clamp
argument_list|(
name|area
operator|.
name|height
operator|+
name|std
operator|::
name|min
argument_list|(
name|area
operator|.
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|textureDesc
operator|.
name|Height
argument_list|)
operator|-
name|safeArea
operator|.
name|y
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|safeArea
operator|.
name|x
operator|>=
literal|0
operator|&&
name|safeArea
operator|.
name|y
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|safeArea
operator|.
name|x
operator|+
name|safeArea
operator|.
name|width
operator|<=
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|textureDesc
operator|.
name|Width
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|safeArea
operator|.
name|y
operator|+
name|safeArea
operator|.
name|height
operator|<=
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|textureDesc
operator|.
name|Height
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|safeArea
operator|.
name|width
operator|==
literal|0
operator|||
name|safeArea
operator|.
name|height
operator|==
literal|0
condition|)
block|{
comment|// no work to do
return|return;
block|}
name|D3D11_TEXTURE2D_DESC
name|stagingDesc
decl_stmt|;
name|stagingDesc
operator|.
name|Width
operator|=
name|safeArea
operator|.
name|width
expr_stmt|;
name|stagingDesc
operator|.
name|Height
operator|=
name|safeArea
operator|.
name|height
expr_stmt|;
name|stagingDesc
operator|.
name|MipLevels
operator|=
literal|1
expr_stmt|;
name|stagingDesc
operator|.
name|ArraySize
operator|=
literal|1
expr_stmt|;
name|stagingDesc
operator|.
name|Format
operator|=
name|textureDesc
operator|.
name|Format
expr_stmt|;
name|stagingDesc
operator|.
name|SampleDesc
operator|.
name|Count
operator|=
literal|1
expr_stmt|;
name|stagingDesc
operator|.
name|SampleDesc
operator|.
name|Quality
operator|=
literal|0
expr_stmt|;
name|stagingDesc
operator|.
name|Usage
operator|=
name|D3D11_USAGE_STAGING
expr_stmt|;
name|stagingDesc
operator|.
name|BindFlags
operator|=
literal|0
expr_stmt|;
name|stagingDesc
operator|.
name|CPUAccessFlags
operator|=
name|D3D11_CPU_ACCESS_READ
expr_stmt|;
name|stagingDesc
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|ID3D11Texture2D
modifier|*
name|stagingTex
init|=
name|NULL
decl_stmt|;
name|HRESULT
name|result
init|=
name|mDevice
operator|->
name|CreateTexture2D
argument_list|(
operator|&
name|stagingDesc
argument_list|,
name|NULL
argument_list|,
operator|&
name|stagingTex
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to create staging texture for readPixels, HRESULT: 0x%X."
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
name|ID3D11Texture2D
modifier|*
name|srcTex
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|textureDesc
operator|.
name|SampleDesc
operator|.
name|Count
operator|>
literal|1
condition|)
block|{
name|D3D11_TEXTURE2D_DESC
name|resolveDesc
decl_stmt|;
name|resolveDesc
operator|.
name|Width
operator|=
name|textureDesc
operator|.
name|Width
expr_stmt|;
name|resolveDesc
operator|.
name|Height
operator|=
name|textureDesc
operator|.
name|Height
expr_stmt|;
name|resolveDesc
operator|.
name|MipLevels
operator|=
literal|1
expr_stmt|;
name|resolveDesc
operator|.
name|ArraySize
operator|=
literal|1
expr_stmt|;
name|resolveDesc
operator|.
name|Format
operator|=
name|textureDesc
operator|.
name|Format
expr_stmt|;
name|resolveDesc
operator|.
name|SampleDesc
operator|.
name|Count
operator|=
literal|1
expr_stmt|;
name|resolveDesc
operator|.
name|SampleDesc
operator|.
name|Quality
operator|=
literal|0
expr_stmt|;
name|resolveDesc
operator|.
name|Usage
operator|=
name|D3D11_USAGE_DEFAULT
expr_stmt|;
name|resolveDesc
operator|.
name|BindFlags
operator|=
literal|0
expr_stmt|;
name|resolveDesc
operator|.
name|CPUAccessFlags
operator|=
literal|0
expr_stmt|;
name|resolveDesc
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|CreateTexture2D
argument_list|(
operator|&
name|resolveDesc
argument_list|,
name|NULL
argument_list|,
operator|&
name|srcTex
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to create resolve texture for readPixels, HRESULT: 0x%X."
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|stagingTex
argument_list|)
expr_stmt|;
return|return;
block|}
name|mDeviceContext
operator|->
name|ResolveSubresource
argument_list|(
name|srcTex
argument_list|,
literal|0
argument_list|,
name|texture
argument_list|,
name|subResource
argument_list|,
name|textureDesc
operator|.
name|Format
argument_list|)
expr_stmt|;
name|subResource
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|srcTex
operator|=
name|texture
expr_stmt|;
name|srcTex
operator|->
name|AddRef
argument_list|()
expr_stmt|;
block|}
name|D3D11_BOX
name|srcBox
decl_stmt|;
name|srcBox
operator|.
name|left
operator|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|safeArea
operator|.
name|x
argument_list|)
expr_stmt|;
name|srcBox
operator|.
name|right
operator|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|safeArea
operator|.
name|x
operator|+
name|safeArea
operator|.
name|width
argument_list|)
expr_stmt|;
name|srcBox
operator|.
name|top
operator|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|safeArea
operator|.
name|y
argument_list|)
expr_stmt|;
name|srcBox
operator|.
name|bottom
operator|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|safeArea
operator|.
name|y
operator|+
name|safeArea
operator|.
name|height
argument_list|)
expr_stmt|;
name|srcBox
operator|.
name|front
operator|=
literal|0
expr_stmt|;
name|srcBox
operator|.
name|back
operator|=
literal|1
expr_stmt|;
name|mDeviceContext
operator|->
name|CopySubresourceRegion
argument_list|(
name|stagingTex
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|srcTex
argument_list|,
name|subResource
argument_list|,
operator|&
name|srcBox
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|srcTex
argument_list|)
expr_stmt|;
name|PackPixelsParams
name|packParams
argument_list|(
name|safeArea
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|outputPitch
argument_list|,
name|pack
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|packPixels
argument_list|(
name|stagingTex
argument_list|,
name|packParams
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|stagingTex
argument_list|)
expr_stmt|;
block|}
DECL|function|packPixels
name|void
name|Renderer11
operator|::
name|packPixels
parameter_list|(
name|ID3D11Texture2D
modifier|*
name|readTexture
parameter_list|,
specifier|const
name|PackPixelsParams
modifier|&
name|params
parameter_list|,
name|void
modifier|*
name|pixelsOut
parameter_list|)
block|{
name|D3D11_TEXTURE2D_DESC
name|textureDesc
decl_stmt|;
name|readTexture
operator|->
name|GetDesc
argument_list|(
operator|&
name|textureDesc
argument_list|)
expr_stmt|;
name|D3D11_MAPPED_SUBRESOURCE
name|mapping
decl_stmt|;
name|HRESULT
name|hr
init|=
name|mDeviceContext
operator|->
name|Map
argument_list|(
name|readTexture
argument_list|,
literal|0
argument_list|,
name|D3D11_MAP_READ
argument_list|,
literal|0
argument_list|,
operator|&
name|mapping
argument_list|)
decl_stmt|;
name|UNUSED_ASSERTION_VARIABLE
argument_list|(
name|hr
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|hr
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned
name|char
modifier|*
name|source
decl_stmt|;
name|int
name|inputPitch
decl_stmt|;
if|if
condition|(
name|params
operator|.
name|pack
operator|.
name|reverseRowOrder
condition|)
block|{
name|source
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|mapping
operator|.
name|pData
argument_list|)
operator|+
name|mapping
operator|.
name|RowPitch
operator|*
operator|(
name|params
operator|.
name|area
operator|.
name|height
operator|-
literal|1
operator|)
expr_stmt|;
name|inputPitch
operator|=
operator|-
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|mapping
operator|.
name|RowPitch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|source
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|mapping
operator|.
name|pData
argument_list|)
expr_stmt|;
name|inputPitch
operator|=
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|mapping
operator|.
name|RowPitch
argument_list|)
expr_stmt|;
block|}
name|GLenum
name|sourceInternalFormat
init|=
name|d3d11_gl
operator|::
name|GetInternalFormat
argument_list|(
name|textureDesc
operator|.
name|Format
argument_list|)
decl_stmt|;
name|GLenum
name|sourceFormat
init|=
name|gl
operator|::
name|GetFormat
argument_list|(
name|sourceInternalFormat
argument_list|)
decl_stmt|;
name|GLenum
name|sourceType
init|=
name|gl
operator|::
name|GetType
argument_list|(
name|sourceInternalFormat
argument_list|)
decl_stmt|;
name|GLuint
name|sourcePixelSize
init|=
name|gl
operator|::
name|GetPixelBytes
argument_list|(
name|sourceInternalFormat
argument_list|)
decl_stmt|;
if|if
condition|(
name|sourceFormat
operator|==
name|params
operator|.
name|format
operator|&&
name|sourceType
operator|==
name|params
operator|.
name|type
condition|)
block|{
name|unsigned
name|char
modifier|*
name|dest
init|=
cast|static_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|pixelsOut
argument_list|)
operator|+
name|params
operator|.
name|offset
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|params
operator|.
name|area
operator|.
name|height
condition|;
name|y
operator|++
control|)
block|{
name|memcpy
argument_list|(
name|dest
operator|+
name|y
operator|*
name|params
operator|.
name|outputPitch
argument_list|,
name|source
operator|+
name|y
operator|*
name|inputPitch
argument_list|,
name|params
operator|.
name|area
operator|.
name|width
operator|*
name|sourcePixelSize
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|GLenum
name|destInternalFormat
init|=
name|gl
operator|::
name|GetSizedInternalFormat
argument_list|(
name|params
operator|.
name|format
argument_list|,
name|params
operator|.
name|type
argument_list|)
decl_stmt|;
name|GLuint
name|destPixelSize
init|=
name|gl
operator|::
name|GetPixelBytes
argument_list|(
name|destInternalFormat
argument_list|)
decl_stmt|;
name|ColorCopyFunction
name|fastCopyFunc
init|=
name|d3d11
operator|::
name|GetFastCopyFunction
argument_list|(
name|textureDesc
operator|.
name|Format
argument_list|,
name|params
operator|.
name|format
argument_list|,
name|params
operator|.
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|fastCopyFunc
condition|)
block|{
comment|// Fast copy is possible through some special function
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|params
operator|.
name|area
operator|.
name|height
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|params
operator|.
name|area
operator|.
name|width
condition|;
name|x
operator|++
control|)
block|{
name|void
modifier|*
name|dest
init|=
cast|static_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|pixelsOut
argument_list|)
operator|+
name|params
operator|.
name|offset
operator|+
name|y
operator|*
name|params
operator|.
name|outputPitch
operator|+
name|x
operator|*
name|destPixelSize
decl_stmt|;
name|void
modifier|*
name|src
init|=
cast|static_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|source
argument_list|)
operator|+
name|y
operator|*
name|inputPitch
operator|+
name|x
operator|*
name|sourcePixelSize
decl_stmt|;
name|fastCopyFunc
argument_list|(
name|src
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|ColorReadFunction
name|readFunc
init|=
name|d3d11
operator|::
name|GetColorReadFunction
argument_list|(
name|textureDesc
operator|.
name|Format
argument_list|)
decl_stmt|;
name|ColorWriteFunction
name|writeFunc
init|=
name|gl
operator|::
name|GetColorWriteFunction
argument_list|(
name|params
operator|.
name|format
argument_list|,
name|params
operator|.
name|type
argument_list|)
decl_stmt|;
name|unsigned
name|char
name|temp
index|[
literal|16
index|]
decl_stmt|;
comment|// Maximum size of any Color<T> type used.
name|META_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|gl
operator|::
name|ColorF
argument_list|)
operator|&&
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|gl
operator|::
name|ColorUI
argument_list|)
operator|&&
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|gl
operator|::
name|ColorI
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|params
operator|.
name|area
operator|.
name|height
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|params
operator|.
name|area
operator|.
name|width
condition|;
name|x
operator|++
control|)
block|{
name|void
modifier|*
name|dest
init|=
cast|static_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|pixelsOut
argument_list|)
operator|+
name|params
operator|.
name|offset
operator|+
name|y
operator|*
name|params
operator|.
name|outputPitch
operator|+
name|x
operator|*
name|destPixelSize
decl_stmt|;
name|void
modifier|*
name|src
init|=
cast|static_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|source
argument_list|)
operator|+
name|y
operator|*
name|inputPitch
operator|+
name|x
operator|*
name|sourcePixelSize
decl_stmt|;
comment|// readFunc and writeFunc will be using the same type of color, CopyTexImage
comment|// will not allow the copy otherwise.
name|readFunc
argument_list|(
name|src
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|writeFunc
argument_list|(
name|temp
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|mDeviceContext
operator|->
name|Unmap
argument_list|(
name|readTexture
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
DECL|function|blitRenderbufferRect
name|bool
name|Renderer11
operator|::
name|blitRenderbufferRect
parameter_list|(
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|readRect
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|drawRect
parameter_list|,
name|RenderTarget
modifier|*
name|readRenderTarget
parameter_list|,
name|RenderTarget
modifier|*
name|drawRenderTarget
parameter_list|,
name|GLenum
name|filter
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|*
name|scissor
parameter_list|,
name|bool
name|colorBlit
parameter_list|,
name|bool
name|depthBlit
parameter_list|,
name|bool
name|stencilBlit
parameter_list|)
block|{
comment|// Since blitRenderbufferRect is called for each render buffer that needs to be blitted,
comment|// it should never be the case that both color and depth/stencil need to be blitted at
comment|// at the same time.
name|ASSERT
argument_list|(
name|colorBlit
operator|!=
operator|(
name|depthBlit
operator|||
name|stencilBlit
operator|)
argument_list|)
expr_stmt|;
name|bool
name|result
init|=
literal|true
decl_stmt|;
name|RenderTarget11
modifier|*
name|drawRenderTarget11
init|=
name|RenderTarget11
operator|::
name|makeRenderTarget11
argument_list|(
name|drawRenderTarget
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|drawRenderTarget
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the draw render target from the draw framebuffer."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|ID3D11Resource
modifier|*
name|drawTexture
init|=
name|drawRenderTarget11
operator|->
name|getTexture
argument_list|()
decl_stmt|;
name|unsigned
name|int
name|drawSubresource
init|=
name|drawRenderTarget11
operator|->
name|getSubresourceIndex
argument_list|()
decl_stmt|;
name|ID3D11RenderTargetView
modifier|*
name|drawRTV
init|=
name|drawRenderTarget11
operator|->
name|getRenderTargetView
argument_list|()
decl_stmt|;
name|ID3D11DepthStencilView
modifier|*
name|drawDSV
init|=
name|drawRenderTarget11
operator|->
name|getDepthStencilView
argument_list|()
decl_stmt|;
name|RenderTarget11
modifier|*
name|readRenderTarget11
init|=
name|RenderTarget11
operator|::
name|makeRenderTarget11
argument_list|(
name|readRenderTarget
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|readRenderTarget
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the read render target from the read framebuffer."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|ID3D11Resource
modifier|*
name|readTexture
init|=
name|NULL
decl_stmt|;
name|ID3D11ShaderResourceView
modifier|*
name|readSRV
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|readSubresource
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|readRenderTarget
operator|->
name|getSamples
argument_list|()
operator|>
literal|0
condition|)
block|{
name|ID3D11Resource
modifier|*
name|unresolvedResource
init|=
name|readRenderTarget11
operator|->
name|getTexture
argument_list|()
decl_stmt|;
name|ID3D11Texture2D
modifier|*
name|unresolvedTexture
init|=
name|d3d11
operator|::
name|DynamicCastComObject
argument_list|<
name|ID3D11Texture2D
argument_list|>
argument_list|(
name|unresolvedResource
argument_list|)
decl_stmt|;
if|if
condition|(
name|unresolvedTexture
condition|)
block|{
name|readTexture
operator|=
name|resolveMultisampledTexture
argument_list|(
name|unresolvedTexture
argument_list|,
name|readRenderTarget11
operator|->
name|getSubresourceIndex
argument_list|()
argument_list|)
expr_stmt|;
name|readSubresource
operator|=
literal|0
expr_stmt|;
name|SafeRelease
argument_list|(
name|unresolvedTexture
argument_list|)
expr_stmt|;
name|HRESULT
name|hresult
init|=
name|mDevice
operator|->
name|CreateShaderResourceView
argument_list|(
name|readTexture
argument_list|,
name|NULL
argument_list|,
operator|&
name|readSRV
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|hresult
argument_list|)
condition|)
block|{
name|SafeRelease
argument_list|(
name|readTexture
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
block|}
else|else
block|{
name|readTexture
operator|=
name|readRenderTarget11
operator|->
name|getTexture
argument_list|()
expr_stmt|;
name|readTexture
operator|->
name|AddRef
argument_list|()
expr_stmt|;
name|readSubresource
operator|=
name|readRenderTarget11
operator|->
name|getSubresourceIndex
argument_list|()
expr_stmt|;
name|readSRV
operator|=
name|readRenderTarget11
operator|->
name|getShaderResourceView
argument_list|()
expr_stmt|;
name|readSRV
operator|->
name|AddRef
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|readTexture
operator|||
operator|!
name|readSRV
condition|)
block|{
name|SafeRelease
argument_list|(
name|readTexture
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|readSRV
argument_list|)
expr_stmt|;
name|ERR
argument_list|(
literal|"Failed to retrieve the read render target view from the read render target."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|gl
operator|::
name|Extents
name|readSize
argument_list|(
name|readRenderTarget
operator|->
name|getWidth
argument_list|()
argument_list|,
name|readRenderTarget
operator|->
name|getHeight
argument_list|()
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Extents
name|drawSize
argument_list|(
name|drawRenderTarget
operator|->
name|getWidth
argument_list|()
argument_list|,
name|drawRenderTarget
operator|->
name|getHeight
argument_list|()
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|bool
name|scissorNeeded
init|=
name|scissor
operator|&&
name|gl
operator|::
name|ClipRectangle
argument_list|(
name|drawRect
argument_list|,
operator|*
name|scissor
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|bool
name|wholeBufferCopy
init|=
operator|!
name|scissorNeeded
operator|&&
name|readRect
operator|.
name|x
operator|==
literal|0
operator|&&
name|readRect
operator|.
name|width
operator|==
name|readSize
operator|.
name|width
operator|&&
name|readRect
operator|.
name|y
operator|==
literal|0
operator|&&
name|readRect
operator|.
name|height
operator|==
name|readSize
operator|.
name|height
operator|&&
name|drawRect
operator|.
name|x
operator|==
literal|0
operator|&&
name|drawRect
operator|.
name|width
operator|==
name|drawSize
operator|.
name|width
operator|&&
name|drawRect
operator|.
name|y
operator|==
literal|0
operator|&&
name|drawRect
operator|.
name|height
operator|==
name|drawSize
operator|.
name|height
decl_stmt|;
name|bool
name|stretchRequired
init|=
name|readRect
operator|.
name|width
operator|!=
name|drawRect
operator|.
name|width
operator|||
name|readRect
operator|.
name|height
operator|!=
name|drawRect
operator|.
name|height
decl_stmt|;
name|bool
name|flipRequired
init|=
name|readRect
operator|.
name|width
operator|<
literal|0
operator|||
name|readRect
operator|.
name|height
operator|<
literal|0
operator|||
name|drawRect
operator|.
name|width
operator|<
literal|0
operator|||
name|drawRect
operator|.
name|height
operator|<
literal|0
decl_stmt|;
name|bool
name|outOfBounds
init|=
name|readRect
operator|.
name|x
argument_list|<
literal|0
operator|||
name|readRect
operator|.
name|x
operator|+
name|readRect
operator|.
name|width
argument_list|>
name|readSize
operator|.
name|width
operator|||
name|readRect
operator|.
name|y
argument_list|<
literal|0
operator|||
name|readRect
operator|.
name|y
operator|+
name|readRect
operator|.
name|height
argument_list|>
name|readSize
operator|.
name|height
operator|||
name|drawRect
operator|.
name|x
argument_list|<
literal|0
operator|||
name|drawRect
operator|.
name|x
operator|+
name|drawRect
operator|.
name|width
argument_list|>
name|drawSize
operator|.
name|width
operator|||
name|drawRect
operator|.
name|y
argument_list|<
literal|0
operator|||
name|drawRect
operator|.
name|y
operator|+
name|drawRect
operator|.
name|height
argument_list|>
name|drawSize
operator|.
name|height
decl_stmt|;
name|bool
name|hasDepth
init|=
name|gl
operator|::
name|GetDepthBits
argument_list|(
name|drawRenderTarget11
operator|->
name|getActualFormat
argument_list|()
argument_list|)
operator|>
literal|0
decl_stmt|;
name|bool
name|hasStencil
init|=
name|gl
operator|::
name|GetStencilBits
argument_list|(
name|drawRenderTarget11
operator|->
name|getActualFormat
argument_list|()
argument_list|)
operator|>
literal|0
decl_stmt|;
name|bool
name|partialDSBlit
init|=
operator|(
name|hasDepth
operator|&&
name|depthBlit
operator|)
operator|!=
operator|(
name|hasStencil
operator|&&
name|stencilBlit
operator|)
decl_stmt|;
if|if
condition|(
name|readRenderTarget11
operator|->
name|getActualFormat
argument_list|()
operator|==
name|drawRenderTarget
operator|->
name|getActualFormat
argument_list|()
operator|&&
operator|!
name|stretchRequired
operator|&&
operator|!
name|outOfBounds
operator|&&
operator|!
name|flipRequired
operator|&&
operator|!
name|partialDSBlit
operator|&&
operator|(
operator|!
operator|(
name|depthBlit
operator|||
name|stencilBlit
operator|)
operator|||
name|wholeBufferCopy
operator|)
condition|)
block|{
name|UINT
name|dstX
init|=
name|drawRect
operator|.
name|x
decl_stmt|;
name|UINT
name|dstY
init|=
name|drawRect
operator|.
name|y
decl_stmt|;
name|D3D11_BOX
name|readBox
decl_stmt|;
name|readBox
operator|.
name|left
operator|=
name|readRect
operator|.
name|x
expr_stmt|;
name|readBox
operator|.
name|right
operator|=
name|readRect
operator|.
name|x
operator|+
name|readRect
operator|.
name|width
expr_stmt|;
name|readBox
operator|.
name|top
operator|=
name|readRect
operator|.
name|y
expr_stmt|;
name|readBox
operator|.
name|bottom
operator|=
name|readRect
operator|.
name|y
operator|+
name|readRect
operator|.
name|height
expr_stmt|;
name|readBox
operator|.
name|front
operator|=
literal|0
expr_stmt|;
name|readBox
operator|.
name|back
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|scissorNeeded
condition|)
block|{
comment|// drawRect is guaranteed to have positive width and height because stretchRequired is false.
name|ASSERT
argument_list|(
name|drawRect
operator|.
name|width
operator|>=
literal|0
operator|||
name|drawRect
operator|.
name|height
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|drawRect
operator|.
name|x
operator|<
name|scissor
operator|->
name|x
condition|)
block|{
name|dstX
operator|=
name|scissor
operator|->
name|x
expr_stmt|;
name|readBox
operator|.
name|left
operator|+=
operator|(
name|scissor
operator|->
name|x
operator|-
name|drawRect
operator|.
name|x
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|drawRect
operator|.
name|y
operator|<
name|scissor
operator|->
name|y
condition|)
block|{
name|dstY
operator|=
name|scissor
operator|->
name|y
expr_stmt|;
name|readBox
operator|.
name|top
operator|+=
operator|(
name|scissor
operator|->
name|y
operator|-
name|drawRect
operator|.
name|y
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|drawRect
operator|.
name|x
operator|+
name|drawRect
operator|.
name|width
operator|>
name|scissor
operator|->
name|x
operator|+
name|scissor
operator|->
name|width
condition|)
block|{
name|readBox
operator|.
name|right
operator|-=
operator|(
operator|(
name|drawRect
operator|.
name|x
operator|+
name|drawRect
operator|.
name|width
operator|)
operator|-
operator|(
name|scissor
operator|->
name|x
operator|+
name|scissor
operator|->
name|width
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|drawRect
operator|.
name|y
operator|+
name|drawRect
operator|.
name|height
operator|>
name|scissor
operator|->
name|y
operator|+
name|scissor
operator|->
name|height
condition|)
block|{
name|readBox
operator|.
name|bottom
operator|-=
operator|(
operator|(
name|drawRect
operator|.
name|y
operator|+
name|drawRect
operator|.
name|height
operator|)
operator|-
operator|(
name|scissor
operator|->
name|y
operator|+
name|scissor
operator|->
name|height
operator|)
operator|)
expr_stmt|;
block|}
block|}
comment|// D3D11 needs depth-stencil CopySubresourceRegions to have a NULL pSrcBox
comment|// We also require complete framebuffer copies for depth-stencil blit.
name|D3D11_BOX
modifier|*
name|pSrcBox
init|=
name|wholeBufferCopy
condition|?
name|NULL
else|:
operator|&
name|readBox
decl_stmt|;
name|mDeviceContext
operator|->
name|CopySubresourceRegion
argument_list|(
name|drawTexture
argument_list|,
name|drawSubresource
argument_list|,
name|dstX
argument_list|,
name|dstY
argument_list|,
literal|0
argument_list|,
name|readTexture
argument_list|,
name|readSubresource
argument_list|,
name|pSrcBox
argument_list|)
expr_stmt|;
name|result
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|gl
operator|::
name|Box
name|readArea
argument_list|(
name|readRect
operator|.
name|x
argument_list|,
name|readRect
operator|.
name|y
argument_list|,
literal|0
argument_list|,
name|readRect
operator|.
name|width
argument_list|,
name|readRect
operator|.
name|height
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Box
name|drawArea
argument_list|(
name|drawRect
operator|.
name|x
argument_list|,
name|drawRect
operator|.
name|y
argument_list|,
literal|0
argument_list|,
name|drawRect
operator|.
name|width
argument_list|,
name|drawRect
operator|.
name|height
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|depthBlit
operator|&&
name|stencilBlit
condition|)
block|{
name|result
operator|=
name|mBlit
operator|->
name|copyDepthStencil
argument_list|(
name|readTexture
argument_list|,
name|readSubresource
argument_list|,
name|readArea
argument_list|,
name|readSize
argument_list|,
name|drawTexture
argument_list|,
name|drawSubresource
argument_list|,
name|drawArea
argument_list|,
name|drawSize
argument_list|,
name|scissor
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|depthBlit
condition|)
block|{
name|result
operator|=
name|mBlit
operator|->
name|copyDepth
argument_list|(
name|readSRV
argument_list|,
name|readArea
argument_list|,
name|readSize
argument_list|,
name|drawDSV
argument_list|,
name|drawArea
argument_list|,
name|drawSize
argument_list|,
name|scissor
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stencilBlit
condition|)
block|{
name|result
operator|=
name|mBlit
operator|->
name|copyStencil
argument_list|(
name|readTexture
argument_list|,
name|readSubresource
argument_list|,
name|readArea
argument_list|,
name|readSize
argument_list|,
name|drawTexture
argument_list|,
name|drawSubresource
argument_list|,
name|drawArea
argument_list|,
name|drawSize
argument_list|,
name|scissor
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|GLenum
name|format
init|=
name|gl
operator|::
name|GetFormat
argument_list|(
name|drawRenderTarget
operator|->
name|getInternalFormat
argument_list|()
argument_list|)
decl_stmt|;
name|result
operator|=
name|mBlit
operator|->
name|copyTexture
argument_list|(
name|readSRV
argument_list|,
name|readArea
argument_list|,
name|readSize
argument_list|,
name|drawRTV
argument_list|,
name|drawArea
argument_list|,
name|drawSize
argument_list|,
name|scissor
argument_list|,
name|format
argument_list|,
name|filter
argument_list|)
expr_stmt|;
block|}
block|}
name|SafeRelease
argument_list|(
name|readTexture
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|readSRV
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
DECL|function|resolveMultisampledTexture
name|ID3D11Texture2D
modifier|*
name|Renderer11
operator|::
name|resolveMultisampledTexture
parameter_list|(
name|ID3D11Texture2D
modifier|*
name|source
parameter_list|,
name|unsigned
name|int
name|subresource
parameter_list|)
block|{
name|D3D11_TEXTURE2D_DESC
name|textureDesc
decl_stmt|;
name|source
operator|->
name|GetDesc
argument_list|(
operator|&
name|textureDesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|textureDesc
operator|.
name|SampleDesc
operator|.
name|Count
operator|>
literal|1
condition|)
block|{
name|D3D11_TEXTURE2D_DESC
name|resolveDesc
decl_stmt|;
name|resolveDesc
operator|.
name|Width
operator|=
name|textureDesc
operator|.
name|Width
expr_stmt|;
name|resolveDesc
operator|.
name|Height
operator|=
name|textureDesc
operator|.
name|Height
expr_stmt|;
name|resolveDesc
operator|.
name|MipLevels
operator|=
literal|1
expr_stmt|;
name|resolveDesc
operator|.
name|ArraySize
operator|=
literal|1
expr_stmt|;
name|resolveDesc
operator|.
name|Format
operator|=
name|textureDesc
operator|.
name|Format
expr_stmt|;
name|resolveDesc
operator|.
name|SampleDesc
operator|.
name|Count
operator|=
literal|1
expr_stmt|;
name|resolveDesc
operator|.
name|SampleDesc
operator|.
name|Quality
operator|=
literal|0
expr_stmt|;
name|resolveDesc
operator|.
name|Usage
operator|=
name|textureDesc
operator|.
name|Usage
expr_stmt|;
name|resolveDesc
operator|.
name|BindFlags
operator|=
name|textureDesc
operator|.
name|BindFlags
expr_stmt|;
name|resolveDesc
operator|.
name|CPUAccessFlags
operator|=
literal|0
expr_stmt|;
name|resolveDesc
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|ID3D11Texture2D
modifier|*
name|resolveTexture
init|=
name|NULL
decl_stmt|;
name|HRESULT
name|result
init|=
name|mDevice
operator|->
name|CreateTexture2D
argument_list|(
operator|&
name|resolveDesc
argument_list|,
name|NULL
argument_list|,
operator|&
name|resolveTexture
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to create a multisample resolve texture, HRESULT: 0x%X."
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|mDeviceContext
operator|->
name|ResolveSubresource
argument_list|(
name|resolveTexture
argument_list|,
literal|0
argument_list|,
name|source
argument_list|,
name|subresource
argument_list|,
name|textureDesc
operator|.
name|Format
argument_list|)
expr_stmt|;
return|return
name|resolveTexture
return|;
block|}
else|else
block|{
name|source
operator|->
name|AddRef
argument_list|()
expr_stmt|;
return|return
name|source
return|;
block|}
block|}
DECL|function|invalidateFBOAttachmentSwizzles
name|void
name|Renderer11
operator|::
name|invalidateFBOAttachmentSwizzles
parameter_list|(
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|attachment
parameter_list|,
name|int
name|mipLevel
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|attachment
operator|->
name|isTexture
argument_list|()
argument_list|)
expr_stmt|;
name|TextureStorage
modifier|*
name|texStorage
init|=
name|attachment
operator|->
name|getTextureStorage
argument_list|()
decl_stmt|;
if|if
condition|(
name|texStorage
condition|)
block|{
name|TextureStorage11
modifier|*
name|texStorage11
init|=
name|TextureStorage11
operator|::
name|makeTextureStorage11
argument_list|(
name|texStorage
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|texStorage11
condition|)
block|{
name|ERR
argument_list|(
literal|"texture storage pointer unexpectedly null."
argument_list|)
expr_stmt|;
return|return;
block|}
name|texStorage11
operator|->
name|invalidateSwizzleCacheLevel
argument_list|(
name|mipLevel
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|invalidateFramebufferSwizzles
name|void
name|Renderer11
operator|::
name|invalidateFramebufferSwizzles
parameter_list|(
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
parameter_list|)
block|{
for|for
control|(
name|unsigned
name|int
name|colorAttachment
init|=
literal|0
init|;
name|colorAttachment
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
condition|;
name|colorAttachment
operator|++
control|)
block|{
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|attachment
init|=
name|framebuffer
operator|->
name|getColorbuffer
argument_list|(
name|colorAttachment
argument_list|)
decl_stmt|;
if|if
condition|(
name|attachment
operator|&&
name|attachment
operator|->
name|isTexture
argument_list|()
condition|)
block|{
name|invalidateFBOAttachmentSwizzles
argument_list|(
name|attachment
argument_list|,
name|attachment
operator|->
name|mipLevel
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|depthAttachment
init|=
name|framebuffer
operator|->
name|getDepthbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|depthAttachment
operator|&&
name|depthAttachment
operator|->
name|isTexture
argument_list|()
condition|)
block|{
name|invalidateFBOAttachmentSwizzles
argument_list|(
name|depthAttachment
argument_list|,
name|depthAttachment
operator|->
name|mipLevel
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|stencilAttachment
init|=
name|framebuffer
operator|->
name|getStencilbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|stencilAttachment
operator|&&
name|stencilAttachment
operator|->
name|isTexture
argument_list|()
condition|)
block|{
name|invalidateFBOAttachmentSwizzles
argument_list|(
name|stencilAttachment
argument_list|,
name|stencilAttachment
operator|->
name|mipLevel
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|getLUID
name|bool
name|Renderer11
operator|::
name|getLUID
parameter_list|(
name|LUID
modifier|*
name|adapterLuid
parameter_list|)
specifier|const
block|{
name|adapterLuid
operator|->
name|HighPart
operator|=
literal|0
expr_stmt|;
name|adapterLuid
operator|->
name|LowPart
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|mDxgiAdapter
condition|)
block|{
return|return
literal|false
return|;
block|}
name|DXGI_ADAPTER_DESC
name|adapterDesc
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|mDxgiAdapter
operator|->
name|GetDesc
argument_list|(
operator|&
name|adapterDesc
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
operator|*
name|adapterLuid
operator|=
name|adapterDesc
operator|.
name|AdapterLuid
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|getNativeTextureFormat
name|GLenum
name|Renderer11
operator|::
name|getNativeTextureFormat
parameter_list|(
name|GLenum
name|internalFormat
parameter_list|)
specifier|const
block|{
return|return
name|d3d11_gl
operator|::
name|GetInternalFormat
argument_list|(
name|gl_d3d11
operator|::
name|GetTexFormat
argument_list|(
name|internalFormat
argument_list|)
argument_list|)
return|;
block|}
DECL|function|getVertexConversionType
name|rx
operator|::
name|VertexConversionType
name|Renderer11
operator|::
name|getVertexConversionType
parameter_list|(
specifier|const
name|gl
operator|::
name|VertexFormat
modifier|&
name|vertexFormat
parameter_list|)
specifier|const
block|{
return|return
name|gl_d3d11
operator|::
name|GetVertexConversionType
argument_list|(
name|vertexFormat
argument_list|)
return|;
block|}
DECL|function|getVertexComponentType
name|GLenum
name|Renderer11
operator|::
name|getVertexComponentType
parameter_list|(
specifier|const
name|gl
operator|::
name|VertexFormat
modifier|&
name|vertexFormat
parameter_list|)
specifier|const
block|{
return|return
name|d3d11
operator|::
name|GetComponentType
argument_list|(
name|gl_d3d11
operator|::
name|GetNativeVertexFormat
argument_list|(
name|vertexFormat
argument_list|)
argument_list|)
return|;
block|}
DECL|function|getMultisampleSupportInfo
name|Renderer11
operator|::
name|MultisampleSupportInfo
name|Renderer11
operator|::
name|getMultisampleSupportInfo
parameter_list|(
name|DXGI_FORMAT
name|format
parameter_list|)
block|{
name|MultisampleSupportInfo
name|supportInfo
init|=
block|{
literal|0
block|}
decl_stmt|;
name|UINT
name|formatSupport
decl_stmt|;
name|HRESULT
name|result
decl_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|CheckFormatSupport
argument_list|(
name|format
argument_list|,
operator|&
name|formatSupport
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
operator|&&
operator|(
name|formatSupport
operator|&
name|D3D11_FORMAT_SUPPORT_MULTISAMPLE_RENDERTARGET
operator|)
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|D3D11_MAX_MULTISAMPLE_SAMPLE_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|=
name|mDevice
operator|->
name|CheckMultisampleQualityLevels
argument_list|(
name|format
argument_list|,
name|i
argument_list|,
operator|&
name|supportInfo
operator|.
name|qualityLevels
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
operator|&&
name|supportInfo
operator|.
name|qualityLevels
index|[
name|i
operator|-
literal|1
index|]
operator|>
literal|0
condition|)
block|{
name|supportInfo
operator|.
name|maxSupportedSamples
operator|=
name|std
operator|::
name|max
argument_list|(
name|supportInfo
operator|.
name|maxSupportedSamples
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|supportInfo
operator|.
name|qualityLevels
index|[
name|i
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
return|return
name|supportInfo
return|;
block|}
DECL|function|generateCaps
name|void
name|Renderer11
operator|::
name|generateCaps
parameter_list|(
name|gl
operator|::
name|Caps
modifier|*
name|outCaps
parameter_list|,
name|gl
operator|::
name|TextureCapsMap
modifier|*
name|outTextureCaps
parameter_list|,
name|gl
operator|::
name|Extensions
modifier|*
name|outExtensions
parameter_list|)
specifier|const
block|{
name|d3d11_gl
operator|::
name|GenerateCaps
argument_list|(
name|mDevice
argument_list|,
name|outCaps
argument_list|,
name|outTextureCaps
argument_list|,
name|outExtensions
argument_list|)
expr_stmt|;
block|}
block|}
end_namespace
end_unit
