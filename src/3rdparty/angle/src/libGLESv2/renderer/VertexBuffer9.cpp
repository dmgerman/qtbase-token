begin_unit
begin_include
include|#
directive|include
file|"precompiled.h"
end_include
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2012 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// VertexBuffer9.cpp: Defines the D3D9 VertexBuffer implementation.
end_comment
begin_include
include|#
directive|include
file|"libGLESv2/renderer/VertexBuffer9.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/vertexconversion.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/BufferStorage.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Context.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/Renderer9.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Buffer.h"
end_include
begin_namespace
DECL|namespace|rx
namespace|namespace
name|rx
block|{
DECL|member|mTranslationsInitialized
name|bool
name|VertexBuffer9
operator|::
name|mTranslationsInitialized
init|=
literal|false
decl_stmt|;
DECL|member|mFormatConverters
name|VertexBuffer9
operator|::
name|FormatConverter
name|VertexBuffer9
operator|::
name|mFormatConverters
index|[
name|NUM_GL_VERTEX_ATTRIB_TYPES
index|]
index|[
literal|2
index|]
index|[
literal|4
index|]
decl_stmt|;
DECL|function|VertexBuffer9
name|VertexBuffer9
operator|::
name|VertexBuffer9
parameter_list|(
name|rx
operator|::
name|Renderer9
modifier|*
specifier|const
name|renderer
parameter_list|)
member_init_list|:
name|mRenderer
argument_list|(
name|renderer
argument_list|)
block|{
name|mVertexBuffer
operator|=
name|NULL
expr_stmt|;
name|mBufferSize
operator|=
literal|0
expr_stmt|;
name|mDynamicUsage
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|mTranslationsInitialized
condition|)
block|{
name|initializeTranslations
argument_list|(
name|renderer
operator|->
name|getCapsDeclTypes
argument_list|()
argument_list|)
expr_stmt|;
name|mTranslationsInitialized
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|~VertexBuffer9
name|VertexBuffer9
operator|::
name|~
name|VertexBuffer9
parameter_list|()
block|{
if|if
condition|(
name|mVertexBuffer
condition|)
block|{
name|mVertexBuffer
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mVertexBuffer
operator|=
name|NULL
expr_stmt|;
block|}
block|}
DECL|function|initialize
name|bool
name|VertexBuffer9
operator|::
name|initialize
parameter_list|(
name|unsigned
name|int
name|size
parameter_list|,
name|bool
name|dynamicUsage
parameter_list|)
block|{
if|if
condition|(
name|mVertexBuffer
condition|)
block|{
name|mVertexBuffer
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mVertexBuffer
operator|=
name|NULL
expr_stmt|;
block|}
name|updateSerial
argument_list|()
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|DWORD
name|flags
init|=
name|D3DUSAGE_WRITEONLY
decl_stmt|;
if|if
condition|(
name|dynamicUsage
condition|)
block|{
name|flags
operator||=
name|D3DUSAGE_DYNAMIC
expr_stmt|;
block|}
name|HRESULT
name|result
init|=
name|mRenderer
operator|->
name|createVertexBuffer
argument_list|(
name|size
argument_list|,
name|flags
argument_list|,
operator|&
name|mVertexBuffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Out of memory allocating a vertex buffer of size %lu."
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|mBufferSize
operator|=
name|size
expr_stmt|;
name|mDynamicUsage
operator|=
name|dynamicUsage
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|makeVertexBuffer9
name|VertexBuffer9
modifier|*
name|VertexBuffer9
operator|::
name|makeVertexBuffer9
parameter_list|(
name|VertexBuffer
modifier|*
name|vertexBuffer
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|HAS_DYNAMIC_TYPE
argument_list|(
name|VertexBuffer9
operator|*
argument_list|,
name|vertexBuffer
argument_list|)
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|VertexBuffer9
operator|*
argument_list|>
argument_list|(
name|vertexBuffer
argument_list|)
return|;
block|}
DECL|function|storeVertexAttributes
name|bool
name|VertexBuffer9
operator|::
name|storeVertexAttributes
parameter_list|(
specifier|const
name|gl
operator|::
name|VertexAttribute
modifier|&
name|attrib
parameter_list|,
name|GLint
name|start
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLsizei
name|instances
parameter_list|,
name|unsigned
name|int
name|offset
parameter_list|)
block|{
if|if
condition|(
name|mVertexBuffer
condition|)
block|{
name|gl
operator|::
name|Buffer
modifier|*
name|buffer
init|=
name|attrib
operator|.
name|mBoundBuffer
operator|.
name|get
argument_list|()
decl_stmt|;
name|int
name|inputStride
init|=
name|attrib
operator|.
name|stride
argument_list|()
decl_stmt|;
name|int
name|elementSize
init|=
name|attrib
operator|.
name|typeSize
argument_list|()
decl_stmt|;
specifier|const
name|FormatConverter
modifier|&
name|converter
init|=
name|formatConverter
argument_list|(
name|attrib
argument_list|)
decl_stmt|;
name|DWORD
name|lockFlags
init|=
name|mDynamicUsage
condition|?
name|D3DLOCK_NOOVERWRITE
else|:
literal|0
decl_stmt|;
name|void
modifier|*
name|mapPtr
init|=
name|NULL
decl_stmt|;
name|HRESULT
name|result
init|=
name|mVertexBuffer
operator|->
name|Lock
argument_list|(
name|offset
argument_list|,
name|spaceRequired
argument_list|(
name|attrib
argument_list|,
name|count
argument_list|,
name|instances
argument_list|)
argument_list|,
operator|&
name|mapPtr
argument_list|,
name|lockFlags
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Lock failed with error 0x%08x"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|char
modifier|*
name|input
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|buffer
condition|)
block|{
name|BufferStorage
modifier|*
name|storage
init|=
name|buffer
operator|->
name|getStorage
argument_list|()
decl_stmt|;
name|input
operator|=
cast|static_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|storage
operator|->
name|getData
argument_list|()
argument_list|)
operator|+
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|attrib
operator|.
name|mOffset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|input
operator|=
cast|static_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|attrib
operator|.
name|mPointer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|instances
operator|==
literal|0
operator|||
name|attrib
operator|.
name|mDivisor
operator|==
literal|0
condition|)
block|{
name|input
operator|+=
name|inputStride
operator|*
name|start
expr_stmt|;
block|}
if|if
condition|(
name|converter
operator|.
name|identity
operator|&&
name|inputStride
operator|==
name|elementSize
condition|)
block|{
name|memcpy
argument_list|(
name|mapPtr
argument_list|,
name|input
argument_list|,
name|count
operator|*
name|inputStride
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|converter
operator|.
name|convertArray
argument_list|(
name|input
argument_list|,
name|inputStride
argument_list|,
name|count
argument_list|,
name|mapPtr
argument_list|)
expr_stmt|;
block|}
name|mVertexBuffer
operator|->
name|Unlock
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|ERR
argument_list|(
literal|"Vertex buffer not initialized."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|storeRawData
name|bool
name|VertexBuffer9
operator|::
name|storeRawData
parameter_list|(
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
name|unsigned
name|int
name|offset
parameter_list|)
block|{
if|if
condition|(
name|mVertexBuffer
condition|)
block|{
name|DWORD
name|lockFlags
init|=
name|mDynamicUsage
condition|?
name|D3DLOCK_NOOVERWRITE
else|:
literal|0
decl_stmt|;
name|void
modifier|*
name|mapPtr
init|=
name|NULL
decl_stmt|;
name|HRESULT
name|result
init|=
name|mVertexBuffer
operator|->
name|Lock
argument_list|(
name|offset
argument_list|,
name|size
argument_list|,
operator|&
name|mapPtr
argument_list|,
name|lockFlags
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Lock failed with error 0x%08x"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|memcpy
argument_list|(
name|mapPtr
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|mVertexBuffer
operator|->
name|Unlock
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|ERR
argument_list|(
literal|"Vertex buffer not initialized."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|getSpaceRequired
name|unsigned
name|int
name|VertexBuffer9
operator|::
name|getSpaceRequired
parameter_list|(
specifier|const
name|gl
operator|::
name|VertexAttribute
modifier|&
name|attrib
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLsizei
name|instances
parameter_list|)
specifier|const
block|{
return|return
name|spaceRequired
argument_list|(
name|attrib
argument_list|,
name|count
argument_list|,
name|instances
argument_list|)
return|;
block|}
DECL|function|requiresConversion
name|bool
name|VertexBuffer9
operator|::
name|requiresConversion
parameter_list|(
specifier|const
name|gl
operator|::
name|VertexAttribute
modifier|&
name|attrib
parameter_list|)
specifier|const
block|{
return|return
name|formatConverter
argument_list|(
name|attrib
argument_list|)
operator|.
name|identity
return|;
block|}
DECL|function|getVertexSize
name|unsigned
name|int
name|VertexBuffer9
operator|::
name|getVertexSize
parameter_list|(
specifier|const
name|gl
operator|::
name|VertexAttribute
modifier|&
name|attrib
parameter_list|)
specifier|const
block|{
return|return
name|spaceRequired
argument_list|(
name|attrib
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
return|;
block|}
DECL|function|getDeclType
name|D3DDECLTYPE
name|VertexBuffer9
operator|::
name|getDeclType
parameter_list|(
specifier|const
name|gl
operator|::
name|VertexAttribute
modifier|&
name|attrib
parameter_list|)
specifier|const
block|{
return|return
name|formatConverter
argument_list|(
name|attrib
argument_list|)
operator|.
name|d3dDeclType
return|;
block|}
DECL|function|getBufferSize
name|unsigned
name|int
name|VertexBuffer9
operator|::
name|getBufferSize
parameter_list|()
specifier|const
block|{
return|return
name|mBufferSize
return|;
block|}
DECL|function|setBufferSize
name|bool
name|VertexBuffer9
operator|::
name|setBufferSize
parameter_list|(
name|unsigned
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|>
name|mBufferSize
condition|)
block|{
return|return
name|initialize
argument_list|(
name|size
argument_list|,
name|mDynamicUsage
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|true
return|;
block|}
block|}
DECL|function|discard
name|bool
name|VertexBuffer9
operator|::
name|discard
parameter_list|()
block|{
if|if
condition|(
name|mVertexBuffer
condition|)
block|{
name|void
modifier|*
name|dummy
decl_stmt|;
name|HRESULT
name|result
decl_stmt|;
name|result
operator|=
name|mVertexBuffer
operator|->
name|Lock
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|dummy
argument_list|,
name|D3DLOCK_DISCARD
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Discard lock failed with error 0x%08x"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|result
operator|=
name|mVertexBuffer
operator|->
name|Unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Discard unlock failed with error 0x%08x"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
else|else
block|{
name|ERR
argument_list|(
literal|"Vertex buffer not initialized."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|getBuffer
name|IDirect3DVertexBuffer9
modifier|*
name|VertexBuffer9
operator|::
name|getBuffer
parameter_list|()
specifier|const
block|{
return|return
name|mVertexBuffer
return|;
block|}
comment|// Mapping from OpenGL-ES vertex attrib type to D3D decl type:
comment|//
comment|// BYTE                 SHORT (Cast)
comment|// BYTE-norm            FLOAT (Normalize) (can't be exactly represented as SHORT-norm)
comment|// UNSIGNED_BYTE        UBYTE4 (Identity) or SHORT (Cast)
comment|// UNSIGNED_BYTE-norm   UBYTE4N (Identity) or FLOAT (Normalize)
comment|// SHORT                SHORT (Identity)
comment|// SHORT-norm           SHORT-norm (Identity) or FLOAT (Normalize)
comment|// UNSIGNED_SHORT       FLOAT (Cast)
comment|// UNSIGNED_SHORT-norm  USHORT-norm (Identity) or FLOAT (Normalize)
comment|// FIXED (not in WebGL) FLOAT (FixedToFloat)
comment|// FLOAT                FLOAT (Identity)
comment|// GLToCType maps from GL type (as GLenum) to the C typedef.
DECL|struct|GLToCType
template|template
parameter_list|<
name|GLenum
name|GLType
parameter_list|>
struct|struct
name|GLToCType
block|{
block|}
struct|;
DECL|struct|GLToCType
DECL|typedef|type
template|template
parameter_list|<>
struct|struct
name|GLToCType
argument_list|<
name|GL_BYTE
argument_list|>
block|{
typedef|typedef
name|GLbyte
name|type
typedef|;
block|}
struct|;
DECL|struct|GLToCType
DECL|typedef|type
template|template
parameter_list|<>
struct|struct
name|GLToCType
argument_list|<
name|GL_UNSIGNED_BYTE
argument_list|>
block|{
typedef|typedef
name|GLubyte
name|type
typedef|;
block|}
struct|;
DECL|struct|GLToCType
DECL|typedef|type
template|template
parameter_list|<>
struct|struct
name|GLToCType
argument_list|<
name|GL_SHORT
argument_list|>
block|{
typedef|typedef
name|GLshort
name|type
typedef|;
block|}
struct|;
DECL|struct|GLToCType
DECL|typedef|type
template|template
parameter_list|<>
struct|struct
name|GLToCType
argument_list|<
name|GL_UNSIGNED_SHORT
argument_list|>
block|{
typedef|typedef
name|GLushort
name|type
typedef|;
block|}
struct|;
DECL|struct|GLToCType
DECL|typedef|type
template|template
parameter_list|<>
struct|struct
name|GLToCType
argument_list|<
name|GL_FIXED
argument_list|>
block|{
typedef|typedef
name|GLuint
name|type
typedef|;
block|}
struct|;
DECL|struct|GLToCType
DECL|typedef|type
template|template
parameter_list|<>
struct|struct
name|GLToCType
argument_list|<
name|GL_FLOAT
argument_list|>
block|{
typedef|typedef
name|GLfloat
name|type
typedef|;
block|}
struct|;
comment|// This differs from D3DDECLTYPE in that it is unsized. (Size expansion is applied last.)
DECL|enum|D3DVertexType
enum|enum
name|D3DVertexType
block|{
DECL|enumerator|D3DVT_FLOAT
name|D3DVT_FLOAT
block|,
DECL|enumerator|D3DVT_SHORT
name|D3DVT_SHORT
block|,
DECL|enumerator|D3DVT_SHORT_NORM
name|D3DVT_SHORT_NORM
block|,
DECL|enumerator|D3DVT_UBYTE
name|D3DVT_UBYTE
block|,
DECL|enumerator|D3DVT_UBYTE_NORM
name|D3DVT_UBYTE_NORM
block|,
DECL|enumerator|D3DVT_USHORT_NORM
name|D3DVT_USHORT_NORM
block|}
enum|;
comment|// D3DToCType maps from D3D vertex type (as enum D3DVertexType) to the corresponding C type.
DECL|struct|D3DToCType
template|template
parameter_list|<
name|unsigned
name|int
name|D3DType
parameter_list|>
struct|struct
name|D3DToCType
block|{
block|}
struct|;
DECL|struct|D3DToCType
DECL|typedef|type
template|template
parameter_list|<>
struct|struct
name|D3DToCType
argument_list|<
name|D3DVT_FLOAT
argument_list|>
block|{
typedef|typedef
name|float
name|type
typedef|;
block|}
struct|;
DECL|struct|D3DToCType
DECL|typedef|type
template|template
parameter_list|<>
struct|struct
name|D3DToCType
argument_list|<
name|D3DVT_SHORT
argument_list|>
block|{
typedef|typedef
name|short
name|type
typedef|;
block|}
struct|;
DECL|struct|D3DToCType
DECL|typedef|type
template|template
parameter_list|<>
struct|struct
name|D3DToCType
argument_list|<
name|D3DVT_SHORT_NORM
argument_list|>
block|{
typedef|typedef
name|short
name|type
typedef|;
block|}
struct|;
DECL|struct|D3DToCType
DECL|typedef|type
template|template
parameter_list|<>
struct|struct
name|D3DToCType
argument_list|<
name|D3DVT_UBYTE
argument_list|>
block|{
typedef|typedef
name|unsigned
name|char
name|type
typedef|;
block|}
struct|;
DECL|struct|D3DToCType
DECL|typedef|type
template|template
parameter_list|<>
struct|struct
name|D3DToCType
argument_list|<
name|D3DVT_UBYTE_NORM
argument_list|>
block|{
typedef|typedef
name|unsigned
name|char
name|type
typedef|;
block|}
struct|;
DECL|struct|D3DToCType
DECL|typedef|type
template|template
parameter_list|<>
struct|struct
name|D3DToCType
argument_list|<
name|D3DVT_USHORT_NORM
argument_list|>
block|{
typedef|typedef
name|unsigned
name|short
name|type
typedef|;
block|}
struct|;
comment|// Encode the type/size combinations that D3D permits. For each type/size it expands to a widener that will provide the appropriate final size.
DECL|struct|WidenRule
template|template
parameter_list|<
name|unsigned
name|int
name|type
parameter_list|,
name|int
name|size
parameter_list|>
struct|struct
name|WidenRule
block|{
block|}
struct|;
DECL|struct|WidenRule
template|template
parameter_list|<
name|int
name|size
parameter_list|>
struct|struct
name|WidenRule
argument_list|<
name|D3DVT_FLOAT
argument_list|,
name|size
argument_list|>
super|:
name|NoWiden
argument_list|<
name|size
argument_list|>
block|{
block|}
struct|;
DECL|struct|WidenRule
template|template
parameter_list|<
name|int
name|size
parameter_list|>
struct|struct
name|WidenRule
argument_list|<
name|D3DVT_SHORT
argument_list|,
name|size
argument_list|>
super|:
name|WidenToEven
argument_list|<
name|size
argument_list|>
block|{
block|}
struct|;
DECL|struct|WidenRule
template|template
parameter_list|<
name|int
name|size
parameter_list|>
struct|struct
name|WidenRule
argument_list|<
name|D3DVT_SHORT_NORM
argument_list|,
name|size
argument_list|>
super|:
name|WidenToEven
argument_list|<
name|size
argument_list|>
block|{
block|}
struct|;
DECL|struct|WidenRule
template|template
parameter_list|<
name|int
name|size
parameter_list|>
struct|struct
name|WidenRule
argument_list|<
name|D3DVT_UBYTE
argument_list|,
name|size
argument_list|>
super|:
name|WidenToFour
argument_list|<
name|size
argument_list|>
block|{
block|}
struct|;
DECL|struct|WidenRule
template|template
parameter_list|<
name|int
name|size
parameter_list|>
struct|struct
name|WidenRule
argument_list|<
name|D3DVT_UBYTE_NORM
argument_list|,
name|size
argument_list|>
super|:
name|WidenToFour
argument_list|<
name|size
argument_list|>
block|{
block|}
struct|;
DECL|struct|WidenRule
template|template
parameter_list|<
name|int
name|size
parameter_list|>
struct|struct
name|WidenRule
argument_list|<
name|D3DVT_USHORT_NORM
argument_list|,
name|size
argument_list|>
super|:
name|WidenToEven
argument_list|<
name|size
argument_list|>
block|{
block|}
struct|;
comment|// VertexTypeFlags encodes the D3DCAPS9::DeclType flag and vertex declaration flag for each D3D vertex type& size combination.
DECL|struct|VertexTypeFlags
template|template
parameter_list|<
name|unsigned
name|int
name|d3dtype
parameter_list|,
name|int
name|size
parameter_list|>
struct|struct
name|VertexTypeFlags
block|{
block|}
struct|;
template|template
parameter_list|<
name|unsigned
name|int
name|_capflag
parameter_list|,
name|unsigned
name|int
name|_declflag
parameter_list|>
struct|struct
DECL|struct|VertexTypeFlagsHelper
name|VertexTypeFlagsHelper
block|{
DECL|enumerator|capflag
enum|enum
block|{
name|capflag
init|=
name|_capflag
block|}
enum|;
DECL|enumerator|declflag
enum|enum
block|{
name|declflag
init|=
name|_declflag
block|}
enum|;
block|}
struct|;
DECL|struct|VertexTypeFlags
template|template
parameter_list|<>
struct|struct
name|VertexTypeFlags
argument_list|<
name|D3DVT_FLOAT
argument_list|,
literal|1
argument_list|>
super|:
name|VertexTypeFlagsHelper
argument_list|<
literal|0
argument_list|,
name|D3DDECLTYPE_FLOAT1
argument_list|>
block|{
block|}
struct|;
DECL|struct|VertexTypeFlags
template|template
parameter_list|<>
struct|struct
name|VertexTypeFlags
argument_list|<
name|D3DVT_FLOAT
argument_list|,
literal|2
argument_list|>
super|:
name|VertexTypeFlagsHelper
argument_list|<
literal|0
argument_list|,
name|D3DDECLTYPE_FLOAT2
argument_list|>
block|{
block|}
struct|;
DECL|struct|VertexTypeFlags
template|template
parameter_list|<>
struct|struct
name|VertexTypeFlags
argument_list|<
name|D3DVT_FLOAT
argument_list|,
literal|3
argument_list|>
super|:
name|VertexTypeFlagsHelper
argument_list|<
literal|0
argument_list|,
name|D3DDECLTYPE_FLOAT3
argument_list|>
block|{
block|}
struct|;
DECL|struct|VertexTypeFlags
template|template
parameter_list|<>
struct|struct
name|VertexTypeFlags
argument_list|<
name|D3DVT_FLOAT
argument_list|,
literal|4
argument_list|>
super|:
name|VertexTypeFlagsHelper
argument_list|<
literal|0
argument_list|,
name|D3DDECLTYPE_FLOAT4
argument_list|>
block|{
block|}
struct|;
DECL|struct|VertexTypeFlags
template|template
parameter_list|<>
struct|struct
name|VertexTypeFlags
argument_list|<
name|D3DVT_SHORT
argument_list|,
literal|2
argument_list|>
super|:
name|VertexTypeFlagsHelper
argument_list|<
literal|0
argument_list|,
name|D3DDECLTYPE_SHORT2
argument_list|>
block|{
block|}
struct|;
DECL|struct|VertexTypeFlags
template|template
parameter_list|<>
struct|struct
name|VertexTypeFlags
argument_list|<
name|D3DVT_SHORT
argument_list|,
literal|4
argument_list|>
super|:
name|VertexTypeFlagsHelper
argument_list|<
literal|0
argument_list|,
name|D3DDECLTYPE_SHORT4
argument_list|>
block|{
block|}
struct|;
DECL|struct|VertexTypeFlags
template|template
parameter_list|<>
struct|struct
name|VertexTypeFlags
argument_list|<
name|D3DVT_SHORT_NORM
argument_list|,
literal|2
argument_list|>
super|:
name|VertexTypeFlagsHelper
argument_list|<
name|D3DDTCAPS_SHORT2N
argument_list|,
name|D3DDECLTYPE_SHORT2N
argument_list|>
block|{
block|}
struct|;
DECL|struct|VertexTypeFlags
template|template
parameter_list|<>
struct|struct
name|VertexTypeFlags
argument_list|<
name|D3DVT_SHORT_NORM
argument_list|,
literal|4
argument_list|>
super|:
name|VertexTypeFlagsHelper
argument_list|<
name|D3DDTCAPS_SHORT4N
argument_list|,
name|D3DDECLTYPE_SHORT4N
argument_list|>
block|{
block|}
struct|;
DECL|struct|VertexTypeFlags
template|template
parameter_list|<>
struct|struct
name|VertexTypeFlags
argument_list|<
name|D3DVT_UBYTE
argument_list|,
literal|4
argument_list|>
super|:
name|VertexTypeFlagsHelper
argument_list|<
name|D3DDTCAPS_UBYTE4
argument_list|,
name|D3DDECLTYPE_UBYTE4
argument_list|>
block|{
block|}
struct|;
DECL|struct|VertexTypeFlags
template|template
parameter_list|<>
struct|struct
name|VertexTypeFlags
argument_list|<
name|D3DVT_UBYTE_NORM
argument_list|,
literal|4
argument_list|>
super|:
name|VertexTypeFlagsHelper
argument_list|<
name|D3DDTCAPS_UBYTE4N
argument_list|,
name|D3DDECLTYPE_UBYTE4N
argument_list|>
block|{
block|}
struct|;
DECL|struct|VertexTypeFlags
template|template
parameter_list|<>
struct|struct
name|VertexTypeFlags
argument_list|<
name|D3DVT_USHORT_NORM
argument_list|,
literal|2
argument_list|>
super|:
name|VertexTypeFlagsHelper
argument_list|<
name|D3DDTCAPS_USHORT2N
argument_list|,
name|D3DDECLTYPE_USHORT2N
argument_list|>
block|{
block|}
struct|;
DECL|struct|VertexTypeFlags
template|template
parameter_list|<>
struct|struct
name|VertexTypeFlags
argument_list|<
name|D3DVT_USHORT_NORM
argument_list|,
literal|4
argument_list|>
super|:
name|VertexTypeFlagsHelper
argument_list|<
name|D3DDTCAPS_USHORT4N
argument_list|,
name|D3DDECLTYPE_USHORT4N
argument_list|>
block|{
block|}
struct|;
comment|// VertexTypeMapping maps GL type& normalized flag to preferred and fallback D3D vertex types (as D3DVertexType enums).
DECL|struct|VertexTypeMapping
template|template
parameter_list|<
name|GLenum
name|GLtype
parameter_list|,
name|bool
name|normalized
parameter_list|>
struct|struct
name|VertexTypeMapping
block|{
block|}
struct|;
template|template
parameter_list|<
name|D3DVertexType
name|Preferred
parameter_list|,
name|D3DVertexType
name|Fallback
init|=
name|Preferred
parameter_list|>
struct|struct
DECL|struct|VertexTypeMappingBase
name|VertexTypeMappingBase
block|{
DECL|enumerator|preferred
enum|enum
block|{
name|preferred
init|=
name|Preferred
block|}
enum|;
DECL|enumerator|fallback
enum|enum
block|{
name|fallback
init|=
name|Fallback
block|}
enum|;
block|}
struct|;
DECL|struct|VertexTypeMapping
template|template
parameter_list|<>
struct|struct
name|VertexTypeMapping
argument_list|<
name|GL_BYTE
argument_list|,
literal|false
argument_list|>
super|:
name|VertexTypeMappingBase
argument_list|<
name|D3DVT_SHORT
argument_list|>
block|{
block|}
struct|;
comment|// Cast
DECL|struct|VertexTypeMapping
template|template
parameter_list|<>
struct|struct
name|VertexTypeMapping
argument_list|<
name|GL_BYTE
argument_list|,
literal|true
argument_list|>
super|:
name|VertexTypeMappingBase
argument_list|<
name|D3DVT_FLOAT
argument_list|>
block|{
block|}
struct|;
comment|// Normalize
DECL|struct|VertexTypeMapping
template|template
parameter_list|<>
struct|struct
name|VertexTypeMapping
argument_list|<
name|GL_UNSIGNED_BYTE
argument_list|,
literal|false
argument_list|>
super|:
name|VertexTypeMappingBase
argument_list|<
name|D3DVT_UBYTE
argument_list|,
name|D3DVT_FLOAT
argument_list|>
block|{
block|}
struct|;
comment|// Identity, Cast
DECL|struct|VertexTypeMapping
template|template
parameter_list|<>
struct|struct
name|VertexTypeMapping
argument_list|<
name|GL_UNSIGNED_BYTE
argument_list|,
literal|true
argument_list|>
super|:
name|VertexTypeMappingBase
argument_list|<
name|D3DVT_UBYTE_NORM
argument_list|,
name|D3DVT_FLOAT
argument_list|>
block|{
block|}
struct|;
comment|// Identity, Normalize
DECL|struct|VertexTypeMapping
template|template
parameter_list|<>
struct|struct
name|VertexTypeMapping
argument_list|<
name|GL_SHORT
argument_list|,
literal|false
argument_list|>
super|:
name|VertexTypeMappingBase
argument_list|<
name|D3DVT_SHORT
argument_list|>
block|{
block|}
struct|;
comment|// Identity
DECL|struct|VertexTypeMapping
template|template
parameter_list|<>
struct|struct
name|VertexTypeMapping
argument_list|<
name|GL_SHORT
argument_list|,
literal|true
argument_list|>
super|:
name|VertexTypeMappingBase
argument_list|<
name|D3DVT_SHORT_NORM
argument_list|,
name|D3DVT_FLOAT
argument_list|>
block|{
block|}
struct|;
comment|// Cast, Normalize
DECL|struct|VertexTypeMapping
template|template
parameter_list|<>
struct|struct
name|VertexTypeMapping
argument_list|<
name|GL_UNSIGNED_SHORT
argument_list|,
literal|false
argument_list|>
super|:
name|VertexTypeMappingBase
argument_list|<
name|D3DVT_FLOAT
argument_list|>
block|{
block|}
struct|;
comment|// Cast
DECL|struct|VertexTypeMapping
template|template
parameter_list|<>
struct|struct
name|VertexTypeMapping
argument_list|<
name|GL_UNSIGNED_SHORT
argument_list|,
literal|true
argument_list|>
super|:
name|VertexTypeMappingBase
argument_list|<
name|D3DVT_USHORT_NORM
argument_list|,
name|D3DVT_FLOAT
argument_list|>
block|{
block|}
struct|;
comment|// Cast, Normalize
DECL|struct|VertexTypeMapping
template|template
parameter_list|<
name|bool
name|normalized
parameter_list|>
struct|struct
name|VertexTypeMapping
argument_list|<
name|GL_FIXED
argument_list|,
name|normalized
argument_list|>
super|:
name|VertexTypeMappingBase
argument_list|<
name|D3DVT_FLOAT
argument_list|>
block|{
block|}
struct|;
comment|// FixedToFloat
DECL|struct|VertexTypeMapping
template|template
parameter_list|<
name|bool
name|normalized
parameter_list|>
struct|struct
name|VertexTypeMapping
argument_list|<
name|GL_FLOAT
argument_list|,
name|normalized
argument_list|>
super|:
name|VertexTypeMappingBase
argument_list|<
name|D3DVT_FLOAT
argument_list|>
block|{
block|}
struct|;
comment|// Identity
comment|// Given a GL type& norm flag and a D3D type, ConversionRule provides the type conversion rule (Cast, Normalize, Identity, FixedToFloat).
comment|// The conversion rules themselves are defined in vertexconversion.h.
comment|// Almost all cases are covered by Cast (including those that are actually Identity since Cast<T,T> knows it's an identity mapping).
template|template
parameter_list|<
name|GLenum
name|fromType
parameter_list|,
name|bool
name|normalized
parameter_list|,
name|unsigned
name|int
name|toType
parameter_list|>
struct|struct
DECL|struct|ConversionRule
name|ConversionRule
super|:
name|Cast
argument_list|<
typename|typename
name|GLToCType
argument_list|<
name|fromType
argument_list|>
operator|::
name|type
argument_list|,
typename|typename
name|D3DToCType
argument_list|<
name|toType
argument_list|>
operator|::
name|type
argument_list|>
block|{
block|}
struct|;
comment|// All conversions from normalized types to float use the Normalize operator.
DECL|struct|ConversionRule
template|template
parameter_list|<
name|GLenum
name|fromType
parameter_list|>
struct|struct
name|ConversionRule
argument_list|<
name|fromType
argument_list|,
literal|true
argument_list|,
name|D3DVT_FLOAT
argument_list|>
super|:
name|Normalize
argument_list|<
typename|typename
name|GLToCType
argument_list|<
name|fromType
argument_list|>
operator|::
name|type
argument_list|>
block|{
block|}
struct|;
comment|// Use a full specialization for this so that it preferentially matches ahead of the generic normalize-to-float rules.
DECL|struct|ConversionRule
template|template
parameter_list|<>
struct|struct
name|ConversionRule
argument_list|<
name|GL_FIXED
argument_list|,
literal|true
argument_list|,
name|D3DVT_FLOAT
argument_list|>
super|:
name|FixedToFloat
argument_list|<
name|GLint
argument_list|,
literal|16
argument_list|>
block|{
block|}
struct|;
DECL|struct|ConversionRule
template|template
parameter_list|<>
struct|struct
name|ConversionRule
argument_list|<
name|GL_FIXED
argument_list|,
literal|false
argument_list|,
name|D3DVT_FLOAT
argument_list|>
super|:
name|FixedToFloat
argument_list|<
name|GLint
argument_list|,
literal|16
argument_list|>
block|{
block|}
struct|;
comment|// A 2-stage construction is used for DefaultVertexValues because float must use SimpleDefaultValues (i.e. 0/1)
comment|// whether it is normalized or not.
DECL|struct|DefaultVertexValuesStage2
template|template
parameter_list|<
name|class
name|T
parameter_list|,
name|bool
name|normalized
parameter_list|>
struct|struct
name|DefaultVertexValuesStage2
block|{
block|}
struct|;
DECL|struct|DefaultVertexValuesStage2
template|template
parameter_list|<
name|class
name|T
parameter_list|>
struct|struct
name|DefaultVertexValuesStage2
argument_list|<
name|T
argument_list|,
literal|true
argument_list|>
super|:
name|NormalizedDefaultValues
argument_list|<
name|T
argument_list|>
block|{
block|}
struct|;
DECL|struct|DefaultVertexValuesStage2
template|template
parameter_list|<
name|class
name|T
parameter_list|>
struct|struct
name|DefaultVertexValuesStage2
argument_list|<
name|T
argument_list|,
literal|false
argument_list|>
super|:
name|SimpleDefaultValues
argument_list|<
name|T
argument_list|>
block|{
block|}
struct|;
comment|// Work out the default value rule for a D3D type (expressed as the C type) and
DECL|struct|DefaultVertexValues
template|template
parameter_list|<
name|class
name|T
parameter_list|,
name|bool
name|normalized
parameter_list|>
struct|struct
name|DefaultVertexValues
super|:
name|DefaultVertexValuesStage2
argument_list|<
name|T
argument_list|,
name|normalized
argument_list|>
block|{
block|}
struct|;
DECL|struct|DefaultVertexValues
template|template
parameter_list|<
name|bool
name|normalized
parameter_list|>
struct|struct
name|DefaultVertexValues
argument_list|<
name|float
argument_list|,
name|normalized
argument_list|>
super|:
name|SimpleDefaultValues
argument_list|<
name|float
argument_list|>
block|{
block|}
struct|;
comment|// Policy rules for use with Converter, to choose whether to use the preferred or fallback conversion.
comment|// The fallback conversion produces an output that all D3D9 devices must support.
DECL|struct|UsePreferred
DECL|enumerator|type
template|template
parameter_list|<
name|class
name|T
parameter_list|>
struct|struct
name|UsePreferred
block|{
enum|enum
block|{
name|type
init|=
name|T
operator|::
name|preferred
block|}
enum|;
block|}
struct|;
DECL|struct|UseFallback
DECL|enumerator|type
template|template
parameter_list|<
name|class
name|T
parameter_list|>
struct|struct
name|UseFallback
block|{
enum|enum
block|{
name|type
init|=
name|T
operator|::
name|fallback
block|}
enum|;
block|}
struct|;
comment|// Converter ties it all together. Given an OpenGL type/norm/size and choice of preferred/fallback conversion,
comment|// it provides all the members of the appropriate VertexDataConverter, the D3DCAPS9::DeclTypes flag in cap flag
comment|// and the D3DDECLTYPE member needed for the vertex declaration in declflag.
template|template
parameter_list|<
name|GLenum
name|fromType
parameter_list|,
name|bool
name|normalized
parameter_list|,
name|int
name|size
parameter_list|,
template|template
parameter_list|<
name|class
name|T
parameter_list|>
name|class
name|PreferenceRule
parameter_list|>
struct|struct
DECL|struct|Converter
name|Converter
super|:
name|VertexDataConverter
argument_list|<
typename|typename
name|GLToCType
argument_list|<
name|fromType
argument_list|>
operator|::
name|type
argument_list|,
name|WidenRule
argument_list|<
name|PreferenceRule
argument_list|<
name|VertexTypeMapping
argument_list|<
name|fromType
argument_list|,
name|normalized
argument_list|>
argument_list|>
operator|::
name|type
argument_list|,
name|size
argument_list|>
argument_list|,
name|ConversionRule
argument_list|<
name|fromType
argument_list|,
name|normalized
argument_list|,
name|PreferenceRule
argument_list|<
name|VertexTypeMapping
argument_list|<
name|fromType
argument_list|,
name|normalized
argument_list|>
argument_list|>
operator|::
name|type
argument_list|>
argument_list|,
name|DefaultVertexValues
argument_list|<
typename|typename
name|D3DToCType
argument_list|<
name|PreferenceRule
argument_list|<
name|VertexTypeMapping
argument_list|<
name|fromType
argument_list|,
name|normalized
argument_list|>
argument_list|>
operator|::
name|type
argument_list|>
operator|::
name|type
argument_list|,
name|normalized
argument_list|>
argument_list|>
block|{
private|private:
DECL|enumerator|d3dtype
enum|enum
block|{
name|d3dtype
init|=
name|PreferenceRule
argument_list|<
name|VertexTypeMapping
argument_list|<
name|fromType
argument_list|,
name|normalized
argument_list|>
argument_list|>
operator|::
name|type
block|}
enum|;
DECL|enumerator|d3dsize
enum|enum
block|{
name|d3dsize
init|=
name|WidenRule
argument_list|<
name|d3dtype
argument_list|,
name|size
argument_list|>
operator|::
name|finalWidth
block|}
enum|;
public|public:
DECL|enumerator|capflag
enum|enum
block|{
name|capflag
init|=
name|VertexTypeFlags
argument_list|<
name|d3dtype
argument_list|,
name|d3dsize
argument_list|>
operator|::
name|capflag
block|}
enum|;
DECL|enumerator|declflag
enum|enum
block|{
name|declflag
init|=
name|VertexTypeFlags
argument_list|<
name|d3dtype
argument_list|,
name|d3dsize
argument_list|>
operator|::
name|declflag
block|}
enum|;
block|}
struct|;
comment|// Initialize a TranslationInfo
DECL|macro|TRANSLATION
define|#
directive|define
name|TRANSLATION
parameter_list|(
name|type
parameter_list|,
name|norm
parameter_list|,
name|size
parameter_list|,
name|preferred
parameter_list|)
define|\
value|{                                                                               \         Converter<type, norm, size, preferred>::identity,                           \         Converter<type, norm, size, preferred>::finalSize,                          \         Converter<type, norm, size, preferred>::convertArray,                       \         static_cast<D3DDECLTYPE>(Converter<type, norm, size, preferred>::declflag)  \     }
DECL|macro|TRANSLATION_FOR_TYPE_NORM_SIZE
define|#
directive|define
name|TRANSLATION_FOR_TYPE_NORM_SIZE
parameter_list|(
name|type
parameter_list|,
name|norm
parameter_list|,
name|size
parameter_list|)
define|\
value|{                                                       \         Converter<type, norm, size, UsePreferred>::capflag, \         TRANSLATION(type, norm, size, UsePreferred),        \         TRANSLATION(type, norm, size, UseFallback)          \     }
DECL|macro|TRANSLATIONS_FOR_TYPE
define|#
directive|define
name|TRANSLATIONS_FOR_TYPE
parameter_list|(
name|type
parameter_list|)
define|\
value|{                                                                                                                                                                                                       \         { TRANSLATION_FOR_TYPE_NORM_SIZE(type, false, 1), TRANSLATION_FOR_TYPE_NORM_SIZE(type, false, 2), TRANSLATION_FOR_TYPE_NORM_SIZE(type, false, 3), TRANSLATION_FOR_TYPE_NORM_SIZE(type, false, 4) }, \         { TRANSLATION_FOR_TYPE_NORM_SIZE(type, true, 1), TRANSLATION_FOR_TYPE_NORM_SIZE(type, true, 2), TRANSLATION_FOR_TYPE_NORM_SIZE(type, true, 3), TRANSLATION_FOR_TYPE_NORM_SIZE(type, true, 4) },     \     }
DECL|macro|TRANSLATIONS_FOR_TYPE_NO_NORM
define|#
directive|define
name|TRANSLATIONS_FOR_TYPE_NO_NORM
parameter_list|(
name|type
parameter_list|)
define|\
value|{                                                                                                                                                                                                       \         { TRANSLATION_FOR_TYPE_NORM_SIZE(type, false, 1), TRANSLATION_FOR_TYPE_NORM_SIZE(type, false, 2), TRANSLATION_FOR_TYPE_NORM_SIZE(type, false, 3), TRANSLATION_FOR_TYPE_NORM_SIZE(type, false, 4) }, \         { TRANSLATION_FOR_TYPE_NORM_SIZE(type, false, 1), TRANSLATION_FOR_TYPE_NORM_SIZE(type, false, 2), TRANSLATION_FOR_TYPE_NORM_SIZE(type, false, 3), TRANSLATION_FOR_TYPE_NORM_SIZE(type, false, 4) }, \     }
DECL|member|mPossibleTranslations
specifier|const
name|VertexBuffer9
operator|::
name|TranslationDescription
name|VertexBuffer9
operator|::
name|mPossibleTranslations
index|[
name|NUM_GL_VERTEX_ATTRIB_TYPES
index|]
index|[
literal|2
index|]
index|[
literal|4
index|]
init|=
comment|// [GL types as enumerated by typeIndex()][normalized][size-1]
block|{
name|TRANSLATIONS_FOR_TYPE
argument_list|(
name|GL_BYTE
argument_list|)
block|,
name|TRANSLATIONS_FOR_TYPE
argument_list|(
name|GL_UNSIGNED_BYTE
argument_list|)
block|,
name|TRANSLATIONS_FOR_TYPE
argument_list|(
name|GL_SHORT
argument_list|)
block|,
name|TRANSLATIONS_FOR_TYPE
argument_list|(
name|GL_UNSIGNED_SHORT
argument_list|)
block|,
name|TRANSLATIONS_FOR_TYPE_NO_NORM
argument_list|(
name|GL_FIXED
argument_list|)
block|,
name|TRANSLATIONS_FOR_TYPE_NO_NORM
argument_list|(
argument|GL_FLOAT
argument_list|)
block|}
decl_stmt|;
DECL|function|initializeTranslations
name|void
name|VertexBuffer9
operator|::
name|initializeTranslations
parameter_list|(
name|DWORD
name|declTypes
parameter_list|)
block|{
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_GL_VERTEX_ATTRIB_TYPES
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|unsigned
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|unsigned
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
literal|4
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|mPossibleTranslations
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|.
name|capsFlag
operator|==
literal|0
operator|||
operator|(
name|declTypes
operator|&
name|mPossibleTranslations
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|.
name|capsFlag
operator|)
operator|!=
literal|0
condition|)
block|{
name|mFormatConverters
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|=
name|mPossibleTranslations
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|.
name|preferredConversion
expr_stmt|;
block|}
else|else
block|{
name|mFormatConverters
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|=
name|mPossibleTranslations
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|.
name|fallbackConversion
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|function|typeIndex
name|unsigned
name|int
name|VertexBuffer9
operator|::
name|typeIndex
parameter_list|(
name|GLenum
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_BYTE
case|:
return|return
literal|0
return|;
case|case
name|GL_UNSIGNED_BYTE
case|:
return|return
literal|1
return|;
case|case
name|GL_SHORT
case|:
return|return
literal|2
return|;
case|case
name|GL_UNSIGNED_SHORT
case|:
return|return
literal|3
return|;
case|case
name|GL_FIXED
case|:
return|return
literal|4
return|;
case|case
name|GL_FLOAT
case|:
return|return
literal|5
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|5
return|;
block|}
block|}
DECL|function|formatConverter
specifier|const
name|VertexBuffer9
operator|::
name|FormatConverter
modifier|&
name|VertexBuffer9
operator|::
name|formatConverter
parameter_list|(
specifier|const
name|gl
operator|::
name|VertexAttribute
modifier|&
name|attribute
parameter_list|)
block|{
return|return
name|mFormatConverters
index|[
name|typeIndex
argument_list|(
name|attribute
operator|.
name|mType
argument_list|)
index|]
index|[
name|attribute
operator|.
name|mNormalized
index|]
index|[
name|attribute
operator|.
name|mSize
operator|-
literal|1
index|]
return|;
block|}
DECL|function|spaceRequired
name|unsigned
name|int
name|VertexBuffer9
operator|::
name|spaceRequired
parameter_list|(
specifier|const
name|gl
operator|::
name|VertexAttribute
modifier|&
name|attrib
parameter_list|,
name|std
operator|::
name|size_t
name|count
parameter_list|,
name|GLsizei
name|instances
parameter_list|)
block|{
name|unsigned
name|int
name|elementSize
init|=
name|formatConverter
argument_list|(
name|attrib
argument_list|)
operator|.
name|outputElementSize
decl_stmt|;
if|if
condition|(
name|instances
operator|==
literal|0
operator|||
name|attrib
operator|.
name|mDivisor
operator|==
literal|0
condition|)
block|{
return|return
name|elementSize
operator|*
name|count
return|;
block|}
else|else
block|{
return|return
name|elementSize
operator|*
operator|(
operator|(
name|instances
operator|+
name|attrib
operator|.
name|mDivisor
operator|-
literal|1
operator|)
operator|/
name|attrib
operator|.
name|mDivisor
operator|)
return|;
block|}
block|}
block|}
end_namespace
end_unit
