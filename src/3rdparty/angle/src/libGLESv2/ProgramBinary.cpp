begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Program.cpp: Implements the gl::Program class. Implements GL program objects
end_comment
begin_comment
comment|// and related functionality. [OpenGL ES 2.0.24] section 2.10.3 page 28.
end_comment
begin_include
include|#
directive|include
file|"libGLESv2/BinaryStream.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/ProgramBinary.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Framebuffer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/FramebufferAttachment.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Renderbuffer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/ShaderExecutable.h"
end_include
begin_include
include|#
directive|include
file|"common/debug.h"
end_include
begin_include
include|#
directive|include
file|"common/version.h"
end_include
begin_include
include|#
directive|include
file|"common/utilities.h"
end_include
begin_include
include|#
directive|include
file|"common/platform.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/main.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Shader.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Program.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/ProgramImpl.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/ShaderD3D.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Context.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Buffer.h"
end_include
begin_include
include|#
directive|include
file|"common/blocklayout.h"
end_include
begin_include
include|#
directive|include
file|"common/features.h"
end_include
begin_namespace
DECL|namespace|gl
namespace|namespace
name|gl
block|{
namespace|namespace
block|{
DECL|function|ParseAndStripArrayIndex
name|unsigned
name|int
name|ParseAndStripArrayIndex
parameter_list|(
name|std
operator|::
name|string
modifier|*
name|name
parameter_list|)
block|{
name|unsigned
name|int
name|subscript
init|=
name|GL_INVALID_INDEX
decl_stmt|;
comment|// Strip any trailing array operator and retrieve the subscript
name|size_t
name|open
init|=
name|name
operator|->
name|find_last_of
argument_list|(
literal|'['
argument_list|)
decl_stmt|;
name|size_t
name|close
init|=
name|name
operator|->
name|find_last_of
argument_list|(
literal|']'
argument_list|)
decl_stmt|;
if|if
condition|(
name|open
operator|!=
name|std
operator|::
name|string
operator|::
name|npos
operator|&&
name|close
operator|==
name|name
operator|->
name|length
argument_list|()
operator|-
literal|1
condition|)
block|{
name|subscript
operator|=
name|atoi
argument_list|(
name|name
operator|->
name|substr
argument_list|(
name|open
operator|+
literal|1
argument_list|)
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|name
operator|->
name|erase
argument_list|(
name|open
argument_list|)
expr_stmt|;
block|}
return|return
name|subscript
return|;
block|}
block|}
DECL|function|VariableLocation
name|VariableLocation
operator|::
name|VariableLocation
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|name
parameter_list|,
name|unsigned
name|int
name|element
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|)
member_init_list|:
name|name
argument_list|(
name|name
argument_list|)
member_init_list|,
name|element
argument_list|(
name|element
argument_list|)
member_init_list|,
name|index
argument_list|(
name|index
argument_list|)
block|{ }
DECL|function|LinkedVarying
name|LinkedVarying
operator|::
name|LinkedVarying
parameter_list|()
block|{ }
DECL|function|LinkedVarying
name|LinkedVarying
operator|::
name|LinkedVarying
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|name
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLsizei
name|size
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|semanticName
parameter_list|,
name|unsigned
name|int
name|semanticIndex
parameter_list|,
name|unsigned
name|int
name|semanticIndexCount
parameter_list|)
member_init_list|:
name|name
argument_list|(
name|name
argument_list|)
member_init_list|,
name|type
argument_list|(
name|type
argument_list|)
member_init_list|,
name|size
argument_list|(
name|size
argument_list|)
member_init_list|,
name|semanticName
argument_list|(
name|semanticName
argument_list|)
member_init_list|,
name|semanticIndex
argument_list|(
name|semanticIndex
argument_list|)
member_init_list|,
name|semanticIndexCount
argument_list|(
name|semanticIndexCount
argument_list|)
block|{ }
DECL|function|LinkResult
name|LinkResult
operator|::
name|LinkResult
parameter_list|(
name|bool
name|linkSuccess
parameter_list|,
specifier|const
name|Error
modifier|&
name|error
parameter_list|)
member_init_list|:
name|linkSuccess
argument_list|(
name|linkSuccess
argument_list|)
member_init_list|,
name|error
argument_list|(
name|error
argument_list|)
block|{ }
DECL|member|mCurrentSerial
name|unsigned
name|int
name|ProgramBinary
operator|::
name|mCurrentSerial
init|=
literal|1
decl_stmt|;
DECL|function|ProgramBinary
name|ProgramBinary
operator|::
name|ProgramBinary
parameter_list|(
name|rx
operator|::
name|ProgramImpl
modifier|*
name|impl
parameter_list|)
member_init_list|:
name|RefCountObject
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mProgram
argument_list|(
name|impl
argument_list|)
member_init_list|,
name|mValidated
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mSerial
argument_list|(
name|issueSerial
argument_list|()
argument_list|)
block|{
name|ASSERT
argument_list|(
name|impl
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|index
operator|++
control|)
block|{
name|mSemanticIndex
index|[
name|index
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
DECL|function|~ProgramBinary
name|ProgramBinary
operator|::
name|~
name|ProgramBinary
parameter_list|()
block|{
name|reset
argument_list|()
expr_stmt|;
name|SafeDelete
argument_list|(
name|mProgram
argument_list|)
expr_stmt|;
block|}
DECL|function|getSerial
name|unsigned
name|int
name|ProgramBinary
operator|::
name|getSerial
parameter_list|()
specifier|const
block|{
return|return
name|mSerial
return|;
block|}
DECL|function|issueSerial
name|unsigned
name|int
name|ProgramBinary
operator|::
name|issueSerial
parameter_list|()
block|{
return|return
name|mCurrentSerial
operator|++
return|;
block|}
DECL|function|getAttributeLocation
name|GLuint
name|ProgramBinary
operator|::
name|getAttributeLocation
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
condition|)
block|{
for|for
control|(
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|mLinkedAttribute
index|[
name|index
index|]
operator|.
name|name
operator|==
name|std
operator|::
name|string
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
name|index
return|;
block|}
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
DECL|function|getSemanticIndex
name|int
name|ProgramBinary
operator|::
name|getSemanticIndex
parameter_list|(
name|int
name|attributeIndex
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|attributeIndex
operator|>=
literal|0
operator|&&
name|attributeIndex
operator|<
name|MAX_VERTEX_ATTRIBS
argument_list|)
expr_stmt|;
return|return
name|mSemanticIndex
index|[
name|attributeIndex
index|]
return|;
block|}
comment|// Returns one more than the highest sampler index used.
DECL|function|getUsedSamplerRange
name|GLint
name|ProgramBinary
operator|::
name|getUsedSamplerRange
parameter_list|(
name|SamplerType
name|type
parameter_list|)
block|{
return|return
name|mProgram
operator|->
name|getUsedSamplerRange
argument_list|(
name|type
argument_list|)
return|;
block|}
DECL|function|usesPointSize
name|bool
name|ProgramBinary
operator|::
name|usesPointSize
parameter_list|()
specifier|const
block|{
return|return
name|mProgram
operator|->
name|usesPointSize
argument_list|()
return|;
block|}
DECL|function|getSamplerMapping
name|GLint
name|ProgramBinary
operator|::
name|getSamplerMapping
parameter_list|(
name|SamplerType
name|type
parameter_list|,
name|unsigned
name|int
name|samplerIndex
parameter_list|,
specifier|const
name|Caps
modifier|&
name|caps
parameter_list|)
block|{
return|return
name|mProgram
operator|->
name|getSamplerMapping
argument_list|(
name|type
argument_list|,
name|samplerIndex
argument_list|,
name|caps
argument_list|)
return|;
block|}
DECL|function|getSamplerTextureType
name|GLenum
name|ProgramBinary
operator|::
name|getSamplerTextureType
parameter_list|(
name|SamplerType
name|type
parameter_list|,
name|unsigned
name|int
name|samplerIndex
parameter_list|)
block|{
return|return
name|mProgram
operator|->
name|getSamplerTextureType
argument_list|(
name|type
argument_list|,
name|samplerIndex
argument_list|)
return|;
block|}
DECL|function|getUniformLocation
name|GLint
name|ProgramBinary
operator|::
name|getUniformLocation
parameter_list|(
name|std
operator|::
name|string
name|name
parameter_list|)
block|{
return|return
name|mProgram
operator|->
name|getUniformLocation
argument_list|(
name|name
argument_list|)
return|;
block|}
DECL|function|getUniformIndex
name|GLuint
name|ProgramBinary
operator|::
name|getUniformIndex
parameter_list|(
name|std
operator|::
name|string
name|name
parameter_list|)
block|{
return|return
name|mProgram
operator|->
name|getUniformIndex
argument_list|(
name|name
argument_list|)
return|;
block|}
DECL|function|getUniformBlockIndex
name|GLuint
name|ProgramBinary
operator|::
name|getUniformBlockIndex
parameter_list|(
name|std
operator|::
name|string
name|name
parameter_list|)
block|{
return|return
name|mProgram
operator|->
name|getUniformBlockIndex
argument_list|(
name|name
argument_list|)
return|;
block|}
DECL|function|getUniformBlockByIndex
name|UniformBlock
modifier|*
name|ProgramBinary
operator|::
name|getUniformBlockByIndex
parameter_list|(
name|GLuint
name|blockIndex
parameter_list|)
block|{
return|return
name|mProgram
operator|->
name|getUniformBlockByIndex
argument_list|(
name|blockIndex
argument_list|)
return|;
block|}
DECL|function|getFragDataLocation
name|GLint
name|ProgramBinary
operator|::
name|getFragDataLocation
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
specifier|const
block|{
name|std
operator|::
name|string
name|baseName
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|arrayIndex
decl_stmt|;
name|arrayIndex
operator|=
name|ParseAndStripArrayIndex
argument_list|(
operator|&
name|baseName
argument_list|)
expr_stmt|;
for|for
control|(
name|auto
name|locationIt
init|=
name|mOutputVariables
operator|.
name|begin
argument_list|()
init|;
name|locationIt
operator|!=
name|mOutputVariables
operator|.
name|end
argument_list|()
condition|;
name|locationIt
operator|++
control|)
block|{
specifier|const
name|VariableLocation
modifier|&
name|outputVariable
init|=
name|locationIt
operator|->
name|second
decl_stmt|;
if|if
condition|(
name|outputVariable
operator|.
name|name
operator|==
name|baseName
operator|&&
operator|(
name|arrayIndex
operator|==
name|GL_INVALID_INDEX
operator|||
name|arrayIndex
operator|==
name|outputVariable
operator|.
name|element
operator|)
condition|)
block|{
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|locationIt
operator|->
name|first
argument_list|)
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
DECL|function|getTransformFeedbackVaryingCount
name|size_t
name|ProgramBinary
operator|::
name|getTransformFeedbackVaryingCount
parameter_list|()
specifier|const
block|{
return|return
name|mProgram
operator|->
name|getTransformFeedbackLinkedVaryings
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
DECL|function|getTransformFeedbackVarying
specifier|const
name|LinkedVarying
modifier|&
name|ProgramBinary
operator|::
name|getTransformFeedbackVarying
parameter_list|(
name|size_t
name|idx
parameter_list|)
specifier|const
block|{
return|return
name|mProgram
operator|->
name|getTransformFeedbackLinkedVaryings
argument_list|()
index|[
name|idx
index|]
return|;
block|}
DECL|function|getTransformFeedbackBufferMode
name|GLenum
name|ProgramBinary
operator|::
name|getTransformFeedbackBufferMode
parameter_list|()
specifier|const
block|{
return|return
name|mProgram
operator|->
name|getTransformFeedbackBufferMode
argument_list|()
return|;
block|}
DECL|function|setUniform1fv
name|void
name|ProgramBinary
operator|::
name|setUniform1fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniform1fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform2fv
name|void
name|ProgramBinary
operator|::
name|setUniform2fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniform2fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform3fv
name|void
name|ProgramBinary
operator|::
name|setUniform3fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniform3fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform4fv
name|void
name|ProgramBinary
operator|::
name|setUniform4fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniform4fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform1iv
name|void
name|ProgramBinary
operator|::
name|setUniform1iv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniform1iv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform2iv
name|void
name|ProgramBinary
operator|::
name|setUniform2iv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniform2iv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform3iv
name|void
name|ProgramBinary
operator|::
name|setUniform3iv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniform3iv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform4iv
name|void
name|ProgramBinary
operator|::
name|setUniform4iv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniform4iv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform1uiv
name|void
name|ProgramBinary
operator|::
name|setUniform1uiv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniform1uiv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform2uiv
name|void
name|ProgramBinary
operator|::
name|setUniform2uiv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniform2uiv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform3uiv
name|void
name|ProgramBinary
operator|::
name|setUniform3uiv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniform3uiv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform4uiv
name|void
name|ProgramBinary
operator|::
name|setUniform4uiv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniform4uiv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix2fv
name|void
name|ProgramBinary
operator|::
name|setUniformMatrix2fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniformMatrix2fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix3fv
name|void
name|ProgramBinary
operator|::
name|setUniformMatrix3fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniformMatrix3fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix4fv
name|void
name|ProgramBinary
operator|::
name|setUniformMatrix4fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniformMatrix4fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix2x3fv
name|void
name|ProgramBinary
operator|::
name|setUniformMatrix2x3fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniformMatrix2x3fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix2x4fv
name|void
name|ProgramBinary
operator|::
name|setUniformMatrix2x4fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniformMatrix2x4fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix3x2fv
name|void
name|ProgramBinary
operator|::
name|setUniformMatrix3x2fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniformMatrix3x2fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix3x4fv
name|void
name|ProgramBinary
operator|::
name|setUniformMatrix3x4fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniformMatrix3x4fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix4x2fv
name|void
name|ProgramBinary
operator|::
name|setUniformMatrix4x2fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniformMatrix4x2fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix4x3fv
name|void
name|ProgramBinary
operator|::
name|setUniformMatrix4x3fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniformMatrix4x3fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|getUniformfv
name|void
name|ProgramBinary
operator|::
name|getUniformfv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|getUniformfv
argument_list|(
name|location
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|getUniformiv
name|void
name|ProgramBinary
operator|::
name|getUniformiv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|getUniformiv
argument_list|(
name|location
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|getUniformuiv
name|void
name|ProgramBinary
operator|::
name|getUniformuiv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLuint
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|getUniformuiv
argument_list|(
name|location
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|updateSamplerMapping
name|void
name|ProgramBinary
operator|::
name|updateSamplerMapping
parameter_list|()
block|{
return|return
name|mProgram
operator|->
name|updateSamplerMapping
argument_list|()
return|;
block|}
comment|// Applies all the uniforms set for this program object to the renderer
DECL|function|applyUniforms
name|Error
name|ProgramBinary
operator|::
name|applyUniforms
parameter_list|()
block|{
return|return
name|mProgram
operator|->
name|applyUniforms
argument_list|()
return|;
block|}
DECL|function|applyUniformBuffers
name|Error
name|ProgramBinary
operator|::
name|applyUniformBuffers
parameter_list|(
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|gl
operator|::
name|Buffer
operator|*
argument_list|>
name|boundBuffers
parameter_list|,
specifier|const
name|Caps
modifier|&
name|caps
parameter_list|)
block|{
return|return
name|mProgram
operator|->
name|applyUniformBuffers
argument_list|(
name|boundBuffers
argument_list|,
name|caps
argument_list|)
return|;
block|}
DECL|function|linkVaryings
name|bool
name|ProgramBinary
operator|::
name|linkVaryings
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
name|Shader
modifier|*
name|fragmentShader
parameter_list|,
name|Shader
modifier|*
name|vertexShader
parameter_list|)
block|{
name|std
operator|::
name|vector
argument_list|<
name|PackedVarying
argument_list|>
modifier|&
name|fragmentVaryings
init|=
name|fragmentShader
operator|->
name|getVaryings
argument_list|()
decl_stmt|;
name|std
operator|::
name|vector
argument_list|<
name|PackedVarying
argument_list|>
modifier|&
name|vertexVaryings
init|=
name|vertexShader
operator|->
name|getVaryings
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|fragVaryingIndex
init|=
literal|0
init|;
name|fragVaryingIndex
operator|<
name|fragmentVaryings
operator|.
name|size
argument_list|()
condition|;
name|fragVaryingIndex
operator|++
control|)
block|{
name|PackedVarying
modifier|*
name|input
init|=
operator|&
name|fragmentVaryings
index|[
name|fragVaryingIndex
index|]
decl_stmt|;
name|bool
name|matched
init|=
literal|false
decl_stmt|;
comment|// Built-in varyings obey special rules
if|if
condition|(
name|input
operator|->
name|isBuiltIn
argument_list|()
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|size_t
name|vertVaryingIndex
init|=
literal|0
init|;
name|vertVaryingIndex
operator|<
name|vertexVaryings
operator|.
name|size
argument_list|()
condition|;
name|vertVaryingIndex
operator|++
control|)
block|{
name|PackedVarying
modifier|*
name|output
init|=
operator|&
name|vertexVaryings
index|[
name|vertVaryingIndex
index|]
decl_stmt|;
if|if
condition|(
name|output
operator|->
name|name
operator|==
name|input
operator|->
name|name
condition|)
block|{
if|if
condition|(
operator|!
name|linkValidateVaryings
argument_list|(
name|infoLog
argument_list|,
name|output
operator|->
name|name
argument_list|,
operator|*
name|input
argument_list|,
operator|*
name|output
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|output
operator|->
name|registerIndex
operator|=
name|input
operator|->
name|registerIndex
expr_stmt|;
name|output
operator|->
name|columnIndex
operator|=
name|input
operator|->
name|columnIndex
expr_stmt|;
name|matched
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
comment|// We permit unmatched, unreferenced varyings
if|if
condition|(
operator|!
name|matched
operator|&&
name|input
operator|->
name|staticUse
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Fragment varying %s does not match any vertex varying"
argument_list|,
name|input
operator|->
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|load
name|LinkResult
name|ProgramBinary
operator|::
name|load
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
name|GLenum
name|binaryFormat
parameter_list|,
specifier|const
name|void
modifier|*
name|binary
parameter_list|,
name|GLsizei
name|length
parameter_list|)
block|{
if|#
directive|if
name|ANGLE_PROGRAM_BINARY_LOAD
operator|==
name|ANGLE_DISABLED
return|return
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
else|#
directive|else
name|ASSERT
argument_list|(
name|binaryFormat
operator|==
name|mProgram
operator|->
name|getBinaryFormat
argument_list|()
argument_list|)
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
name|BinaryInputStream
name|stream
argument_list|(
name|binary
argument_list|,
name|length
argument_list|)
decl_stmt|;
name|GLenum
name|format
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|GLenum
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|format
operator|!=
name|mProgram
operator|->
name|getBinaryFormat
argument_list|()
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Invalid program binary format."
argument_list|)
expr_stmt|;
return|return
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
name|int
name|majorVersion
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|int
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|minorVersion
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|int
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|majorVersion
operator|!=
name|ANGLE_MAJOR_VERSION
operator|||
name|minorVersion
operator|!=
name|ANGLE_MINOR_VERSION
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Invalid program binary version."
argument_list|)
expr_stmt|;
return|return
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
name|unsigned
name|char
name|commitString
index|[
name|ANGLE_COMMIT_HASH_SIZE
index|]
decl_stmt|;
name|stream
operator|.
name|readBytes
argument_list|(
name|commitString
argument_list|,
name|ANGLE_COMMIT_HASH_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|commitString
argument_list|,
name|ANGLE_COMMIT_HASH
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
operator|*
name|ANGLE_COMMIT_HASH_SIZE
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Invalid program binary version."
argument_list|)
expr_stmt|;
return|return
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
name|int
name|compileFlags
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|int
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|compileFlags
operator|!=
name|ANGLE_COMPILE_OPTIMIZATION_LEVEL
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Mismatched compilation flags."
argument_list|)
expr_stmt|;
return|return
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
operator|++
name|i
control|)
block|{
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|mLinkedAttribute
index|[
name|i
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readString
argument_list|(
operator|&
name|mLinkedAttribute
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|mProgram
operator|->
name|getShaderAttributes
argument_list|()
index|[
name|i
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readString
argument_list|(
operator|&
name|mProgram
operator|->
name|getShaderAttributes
argument_list|()
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|mSemanticIndex
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|initAttributesByLayout
argument_list|()
expr_stmt|;
name|LinkResult
name|result
init|=
name|mProgram
operator|->
name|load
argument_list|(
name|infoLog
argument_list|,
operator|&
name|stream
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|.
name|error
operator|.
name|isError
argument_list|()
operator|||
operator|!
name|result
operator|.
name|linkSuccess
condition|)
block|{
return|return
name|result
return|;
block|}
return|return
name|LinkResult
argument_list|(
literal|true
argument_list|,
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
comment|// #if ANGLE_PROGRAM_BINARY_LOAD == ANGLE_ENABLED
block|}
DECL|function|save
name|Error
name|ProgramBinary
operator|::
name|save
parameter_list|(
name|GLenum
modifier|*
name|binaryFormat
parameter_list|,
name|void
modifier|*
name|binary
parameter_list|,
name|GLsizei
name|bufSize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|)
block|{
if|if
condition|(
name|binaryFormat
condition|)
block|{
operator|*
name|binaryFormat
operator|=
name|mProgram
operator|->
name|getBinaryFormat
argument_list|()
expr_stmt|;
block|}
name|BinaryOutputStream
name|stream
decl_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|mProgram
operator|->
name|getBinaryFormat
argument_list|()
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|ANGLE_MAJOR_VERSION
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|ANGLE_MINOR_VERSION
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeBytes
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|ANGLE_COMMIT_HASH
argument_list|)
argument_list|,
name|ANGLE_COMMIT_HASH_SIZE
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|ANGLE_COMPILE_OPTIMIZATION_LEVEL
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
operator|++
name|i
control|)
block|{
name|stream
operator|.
name|writeInt
argument_list|(
name|mLinkedAttribute
index|[
name|i
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeString
argument_list|(
name|mLinkedAttribute
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|mProgram
operator|->
name|getShaderAttributes
argument_list|()
index|[
name|i
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeString
argument_list|(
name|mProgram
operator|->
name|getShaderAttributes
argument_list|()
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|mSemanticIndex
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|mProgram
operator|->
name|save
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
name|GLsizei
name|streamLength
init|=
name|stream
operator|.
name|length
argument_list|()
decl_stmt|;
specifier|const
name|void
modifier|*
name|streamData
init|=
name|stream
operator|.
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
name|streamLength
operator|>
name|bufSize
condition|)
block|{
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
literal|0
expr_stmt|;
block|}
comment|// TODO: This should be moved to the validation layer but computing the size of the binary before saving
comment|// it causes the save to happen twice.  It may be possible to write the binary to a separate buffer, validate
comment|// sizes and then copy it.
return|return
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
name|binary
condition|)
block|{
name|char
modifier|*
name|ptr
init|=
operator|(
name|char
operator|*
operator|)
name|binary
decl_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
name|streamData
argument_list|,
name|streamLength
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|streamLength
expr_stmt|;
name|ASSERT
argument_list|(
name|ptr
operator|-
name|streamLength
operator|==
name|binary
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
name|streamLength
expr_stmt|;
block|}
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|getLength
name|GLint
name|ProgramBinary
operator|::
name|getLength
parameter_list|()
block|{
name|GLint
name|length
decl_stmt|;
name|Error
name|error
init|=
name|save
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|INT_MAX
argument_list|,
operator|&
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|length
return|;
block|}
DECL|function|link
name|LinkResult
name|ProgramBinary
operator|::
name|link
parameter_list|(
specifier|const
name|Data
modifier|&
name|data
parameter_list|,
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|AttributeBindings
modifier|&
name|attributeBindings
parameter_list|,
name|Shader
modifier|*
name|fragmentShader
parameter_list|,
name|Shader
modifier|*
name|vertexShader
parameter_list|,
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|std
operator|::
name|string
argument_list|>
modifier|&
name|transformFeedbackVaryings
parameter_list|,
name|GLenum
name|transformFeedbackBufferMode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|fragmentShader
operator|||
operator|!
name|fragmentShader
operator|->
name|isCompiled
argument_list|()
condition|)
block|{
return|return
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|fragmentShader
operator|->
name|getType
argument_list|()
operator|==
name|GL_FRAGMENT_SHADER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vertexShader
operator|||
operator|!
name|vertexShader
operator|->
name|isCompiled
argument_list|()
condition|)
block|{
return|return
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|vertexShader
operator|->
name|getType
argument_list|()
operator|==
name|GL_VERTEX_SHADER
argument_list|)
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
name|int
name|registers
decl_stmt|;
name|std
operator|::
name|vector
argument_list|<
name|LinkedVarying
argument_list|>
name|linkedVaryings
decl_stmt|;
name|LinkResult
name|result
init|=
name|mProgram
operator|->
name|link
argument_list|(
name|data
argument_list|,
name|infoLog
argument_list|,
name|fragmentShader
argument_list|,
name|vertexShader
argument_list|,
name|transformFeedbackVaryings
argument_list|,
name|transformFeedbackBufferMode
argument_list|,
operator|&
name|registers
argument_list|,
operator|&
name|linkedVaryings
argument_list|,
operator|&
name|mOutputVariables
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|.
name|error
operator|.
name|isError
argument_list|()
operator|||
operator|!
name|result
operator|.
name|linkSuccess
condition|)
block|{
return|return
name|result
return|;
block|}
if|if
condition|(
operator|!
name|linkAttributes
argument_list|(
name|infoLog
argument_list|,
name|attributeBindings
argument_list|,
name|vertexShader
argument_list|)
condition|)
block|{
return|return
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|mProgram
operator|->
name|linkUniforms
argument_list|(
name|infoLog
argument_list|,
operator|*
name|vertexShader
argument_list|,
operator|*
name|fragmentShader
argument_list|,
operator|*
name|data
operator|.
name|caps
argument_list|)
condition|)
block|{
return|return
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|linkUniformBlocks
argument_list|(
name|infoLog
argument_list|,
operator|*
name|vertexShader
argument_list|,
operator|*
name|fragmentShader
argument_list|,
operator|*
name|data
operator|.
name|caps
argument_list|)
condition|)
block|{
return|return
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|gatherTransformFeedbackLinkedVaryings
argument_list|(
name|infoLog
argument_list|,
name|linkedVaryings
argument_list|,
name|transformFeedbackVaryings
argument_list|,
name|transformFeedbackBufferMode
argument_list|,
operator|&
name|mProgram
operator|->
name|getTransformFeedbackLinkedVaryings
argument_list|()
argument_list|,
operator|*
name|data
operator|.
name|caps
argument_list|)
condition|)
block|{
return|return
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
comment|// TODO: The concept of "executables" is D3D only, and as such this belongs in ProgramD3D. It must be called,
comment|// however, last in this function, so it can't simply be moved to ProgramD3D::link without further shuffling.
name|result
operator|=
name|mProgram
operator|->
name|compileProgramExecutables
argument_list|(
name|infoLog
argument_list|,
name|fragmentShader
argument_list|,
name|vertexShader
argument_list|,
name|registers
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|error
operator|.
name|isError
argument_list|()
operator|||
operator|!
name|result
operator|.
name|linkSuccess
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Failed to create D3D shaders."
argument_list|)
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
return|return
name|LinkResult
argument_list|(
literal|true
argument_list|,
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
DECL|function|linkUniformBlocks
name|bool
name|ProgramBinary
operator|::
name|linkUniformBlocks
parameter_list|(
name|gl
operator|::
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|gl
operator|::
name|Shader
modifier|&
name|vertexShader
parameter_list|,
specifier|const
name|gl
operator|::
name|Shader
modifier|&
name|fragmentShader
parameter_list|,
specifier|const
name|gl
operator|::
name|Caps
modifier|&
name|caps
parameter_list|)
block|{
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|InterfaceBlock
argument_list|>
modifier|&
name|vertexInterfaceBlocks
init|=
name|vertexShader
operator|.
name|getInterfaceBlocks
argument_list|()
decl_stmt|;
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|InterfaceBlock
argument_list|>
modifier|&
name|fragmentInterfaceBlocks
init|=
name|fragmentShader
operator|.
name|getInterfaceBlocks
argument_list|()
decl_stmt|;
comment|// Check that interface blocks defined in the vertex and fragment shaders are identical
typedef|typedef
name|std
operator|::
name|map
argument_list|<
name|std
operator|::
name|string
argument_list|,
specifier|const
name|sh
operator|::
name|InterfaceBlock
operator|*
argument_list|>
name|UniformBlockMap
typedef|;
name|UniformBlockMap
name|linkedUniformBlocks
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|blockIndex
init|=
literal|0
init|;
name|blockIndex
operator|<
name|vertexInterfaceBlocks
operator|.
name|size
argument_list|()
condition|;
name|blockIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|InterfaceBlock
modifier|&
name|vertexInterfaceBlock
init|=
name|vertexInterfaceBlocks
index|[
name|blockIndex
index|]
decl_stmt|;
name|linkedUniformBlocks
index|[
name|vertexInterfaceBlock
operator|.
name|name
index|]
operator|=
operator|&
name|vertexInterfaceBlock
expr_stmt|;
block|}
for|for
control|(
name|unsigned
name|int
name|blockIndex
init|=
literal|0
init|;
name|blockIndex
operator|<
name|fragmentInterfaceBlocks
operator|.
name|size
argument_list|()
condition|;
name|blockIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|InterfaceBlock
modifier|&
name|fragmentInterfaceBlock
init|=
name|fragmentInterfaceBlocks
index|[
name|blockIndex
index|]
decl_stmt|;
name|UniformBlockMap
operator|::
name|const_iterator
name|entry
init|=
name|linkedUniformBlocks
operator|.
name|find
argument_list|(
name|fragmentInterfaceBlock
operator|.
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
name|linkedUniformBlocks
operator|.
name|end
argument_list|()
condition|)
block|{
specifier|const
name|sh
operator|::
name|InterfaceBlock
modifier|&
name|vertexInterfaceBlock
init|=
operator|*
name|entry
operator|->
name|second
decl_stmt|;
if|if
condition|(
operator|!
name|areMatchingInterfaceBlocks
argument_list|(
name|infoLog
argument_list|,
name|vertexInterfaceBlock
argument_list|,
name|fragmentInterfaceBlock
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
for|for
control|(
name|unsigned
name|int
name|blockIndex
init|=
literal|0
init|;
name|blockIndex
operator|<
name|vertexInterfaceBlocks
operator|.
name|size
argument_list|()
condition|;
name|blockIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|InterfaceBlock
modifier|&
name|interfaceBlock
init|=
name|vertexInterfaceBlocks
index|[
name|blockIndex
index|]
decl_stmt|;
comment|// Note: shared and std140 layouts are always considered active
if|if
condition|(
name|interfaceBlock
operator|.
name|staticUse
operator|||
name|interfaceBlock
operator|.
name|layout
operator|!=
name|sh
operator|::
name|BLOCKLAYOUT_PACKED
condition|)
block|{
if|if
condition|(
operator|!
name|mProgram
operator|->
name|defineUniformBlock
argument_list|(
name|infoLog
argument_list|,
name|vertexShader
argument_list|,
name|interfaceBlock
argument_list|,
name|caps
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
for|for
control|(
name|unsigned
name|int
name|blockIndex
init|=
literal|0
init|;
name|blockIndex
operator|<
name|fragmentInterfaceBlocks
operator|.
name|size
argument_list|()
condition|;
name|blockIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|InterfaceBlock
modifier|&
name|interfaceBlock
init|=
name|fragmentInterfaceBlocks
index|[
name|blockIndex
index|]
decl_stmt|;
comment|// Note: shared and std140 layouts are always considered active
if|if
condition|(
name|interfaceBlock
operator|.
name|staticUse
operator|||
name|interfaceBlock
operator|.
name|layout
operator|!=
name|sh
operator|::
name|BLOCKLAYOUT_PACKED
condition|)
block|{
if|if
condition|(
operator|!
name|mProgram
operator|->
name|defineUniformBlock
argument_list|(
name|infoLog
argument_list|,
name|fragmentShader
argument_list|,
name|interfaceBlock
argument_list|,
name|caps
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|areMatchingInterfaceBlocks
name|bool
name|ProgramBinary
operator|::
name|areMatchingInterfaceBlocks
parameter_list|(
name|gl
operator|::
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|sh
operator|::
name|InterfaceBlock
modifier|&
name|vertexInterfaceBlock
parameter_list|,
specifier|const
name|sh
operator|::
name|InterfaceBlock
modifier|&
name|fragmentInterfaceBlock
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|blockName
init|=
name|vertexInterfaceBlock
operator|.
name|name
operator|.
name|c_str
argument_list|()
decl_stmt|;
comment|// validate blocks for the same member types
if|if
condition|(
name|vertexInterfaceBlock
operator|.
name|fields
operator|.
name|size
argument_list|()
operator|!=
name|fragmentInterfaceBlock
operator|.
name|fields
operator|.
name|size
argument_list|()
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Types for interface block '%s' differ between vertex and fragment shaders"
argument_list|,
name|blockName
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|vertexInterfaceBlock
operator|.
name|arraySize
operator|!=
name|fragmentInterfaceBlock
operator|.
name|arraySize
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Array sizes differ for interface block '%s' between vertex and fragment shaders"
argument_list|,
name|blockName
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|vertexInterfaceBlock
operator|.
name|layout
operator|!=
name|fragmentInterfaceBlock
operator|.
name|layout
operator|||
name|vertexInterfaceBlock
operator|.
name|isRowMajorLayout
operator|!=
name|fragmentInterfaceBlock
operator|.
name|isRowMajorLayout
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Layout qualifiers differ for interface block '%s' between vertex and fragment shaders"
argument_list|,
name|blockName
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|unsigned
name|int
name|numBlockMembers
init|=
name|vertexInterfaceBlock
operator|.
name|fields
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|blockMemberIndex
init|=
literal|0
init|;
name|blockMemberIndex
operator|<
name|numBlockMembers
condition|;
name|blockMemberIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|InterfaceBlockField
modifier|&
name|vertexMember
init|=
name|vertexInterfaceBlock
operator|.
name|fields
index|[
name|blockMemberIndex
index|]
decl_stmt|;
specifier|const
name|sh
operator|::
name|InterfaceBlockField
modifier|&
name|fragmentMember
init|=
name|fragmentInterfaceBlock
operator|.
name|fields
index|[
name|blockMemberIndex
index|]
decl_stmt|;
if|if
condition|(
name|vertexMember
operator|.
name|name
operator|!=
name|fragmentMember
operator|.
name|name
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Name mismatch for field %d of interface block '%s': (in vertex: '%s', in fragment: '%s')"
argument_list|,
name|blockMemberIndex
argument_list|,
name|blockName
argument_list|,
name|vertexMember
operator|.
name|name
operator|.
name|c_str
argument_list|()
argument_list|,
name|fragmentMember
operator|.
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|std
operator|::
name|string
name|memberName
init|=
literal|"interface block '"
operator|+
name|vertexInterfaceBlock
operator|.
name|name
operator|+
literal|"' member '"
operator|+
name|vertexMember
operator|.
name|name
operator|+
literal|"'"
decl_stmt|;
if|if
condition|(
operator|!
name|gl
operator|::
name|ProgramBinary
operator|::
name|linkValidateInterfaceBlockFields
argument_list|(
name|infoLog
argument_list|,
name|memberName
argument_list|,
name|vertexMember
argument_list|,
name|fragmentMember
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|// Determines the mapping between GL attributes and Direct3D 9 vertex stream usage indices
DECL|function|linkAttributes
name|bool
name|ProgramBinary
operator|::
name|linkAttributes
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|AttributeBindings
modifier|&
name|attributeBindings
parameter_list|,
specifier|const
name|Shader
modifier|*
name|vertexShader
parameter_list|)
block|{
specifier|const
name|rx
operator|::
name|ShaderD3D
modifier|*
name|vertexShaderD3D
init|=
name|rx
operator|::
name|ShaderD3D
operator|::
name|makeShaderD3D
argument_list|(
name|vertexShader
operator|->
name|getImplementation
argument_list|()
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|usedLocations
init|=
literal|0
decl_stmt|;
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|Attribute
argument_list|>
modifier|&
name|shaderAttributes
init|=
name|vertexShader
operator|->
name|getActiveAttributes
argument_list|()
decl_stmt|;
comment|// Link attributes that have a binding location
for|for
control|(
name|unsigned
name|int
name|attributeIndex
init|=
literal|0
init|;
name|attributeIndex
operator|<
name|shaderAttributes
operator|.
name|size
argument_list|()
condition|;
name|attributeIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|Attribute
modifier|&
name|attribute
init|=
name|shaderAttributes
index|[
name|attributeIndex
index|]
decl_stmt|;
name|ASSERT
argument_list|(
name|attribute
operator|.
name|staticUse
argument_list|)
expr_stmt|;
specifier|const
name|int
name|location
init|=
name|attribute
operator|.
name|location
operator|==
operator|-
literal|1
condition|?
name|attributeBindings
operator|.
name|getAttributeBinding
argument_list|(
name|attribute
operator|.
name|name
argument_list|)
else|:
name|attribute
operator|.
name|location
decl_stmt|;
name|mProgram
operator|->
name|getShaderAttributes
argument_list|()
index|[
name|attributeIndex
index|]
operator|=
name|attribute
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
comment|// Set by glBindAttribLocation or by location layout qualifier
block|{
specifier|const
name|int
name|rows
init|=
name|VariableRegisterCount
argument_list|(
name|attribute
operator|.
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|rows
operator|+
name|location
operator|>
name|MAX_VERTEX_ATTRIBS
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Active attribute (%s) at location %d is too big to fit"
argument_list|,
name|attribute
operator|.
name|name
operator|.
name|c_str
argument_list|()
argument_list|,
name|location
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|row
init|=
literal|0
init|;
name|row
operator|<
name|rows
condition|;
name|row
operator|++
control|)
block|{
specifier|const
name|int
name|rowLocation
init|=
name|location
operator|+
name|row
decl_stmt|;
name|sh
operator|::
name|ShaderVariable
modifier|&
name|linkedAttribute
init|=
name|mLinkedAttribute
index|[
name|rowLocation
index|]
decl_stmt|;
comment|// In GLSL 3.00, attribute aliasing produces a link error
comment|// In GLSL 1.00, attribute aliasing is allowed
if|if
condition|(
name|mProgram
operator|->
name|getShaderVersion
argument_list|()
operator|>=
literal|300
condition|)
block|{
if|if
condition|(
operator|!
name|linkedAttribute
operator|.
name|name
operator|.
name|empty
argument_list|()
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Attribute '%s' aliases attribute '%s' at location %d"
argument_list|,
name|attribute
operator|.
name|name
operator|.
name|c_str
argument_list|()
argument_list|,
name|linkedAttribute
operator|.
name|name
operator|.
name|c_str
argument_list|()
argument_list|,
name|rowLocation
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|linkedAttribute
operator|=
name|attribute
expr_stmt|;
name|usedLocations
operator||=
literal|1
operator|<<
name|rowLocation
expr_stmt|;
block|}
block|}
block|}
comment|// Link attributes that don't have a binding location
for|for
control|(
name|unsigned
name|int
name|attributeIndex
init|=
literal|0
init|;
name|attributeIndex
operator|<
name|shaderAttributes
operator|.
name|size
argument_list|()
condition|;
name|attributeIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|Attribute
modifier|&
name|attribute
init|=
name|shaderAttributes
index|[
name|attributeIndex
index|]
decl_stmt|;
name|ASSERT
argument_list|(
name|attribute
operator|.
name|staticUse
argument_list|)
expr_stmt|;
specifier|const
name|int
name|location
init|=
name|attribute
operator|.
name|location
operator|==
operator|-
literal|1
condition|?
name|attributeBindings
operator|.
name|getAttributeBinding
argument_list|(
name|attribute
operator|.
name|name
argument_list|)
else|:
name|attribute
operator|.
name|location
decl_stmt|;
if|if
condition|(
name|location
operator|==
operator|-
literal|1
condition|)
comment|// Not set by glBindAttribLocation or by location layout qualifier
block|{
name|int
name|rows
init|=
name|VariableRegisterCount
argument_list|(
name|attribute
operator|.
name|type
argument_list|)
decl_stmt|;
name|int
name|availableIndex
init|=
name|AllocateFirstFreeBits
argument_list|(
operator|&
name|usedLocations
argument_list|,
name|rows
argument_list|,
name|MAX_VERTEX_ATTRIBS
argument_list|)
decl_stmt|;
if|if
condition|(
name|availableIndex
operator|==
operator|-
literal|1
operator|||
name|availableIndex
operator|+
name|rows
operator|>
name|MAX_VERTEX_ATTRIBS
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Too many active attributes (%s)"
argument_list|,
name|attribute
operator|.
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
comment|// Fail to link
block|}
name|mLinkedAttribute
index|[
name|availableIndex
index|]
operator|=
name|attribute
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|attributeIndex
init|=
literal|0
init|;
name|attributeIndex
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
control|)
block|{
name|int
name|index
init|=
name|vertexShaderD3D
operator|->
name|getSemanticIndex
argument_list|(
name|mLinkedAttribute
index|[
name|attributeIndex
index|]
operator|.
name|name
argument_list|)
decl_stmt|;
name|int
name|rows
init|=
name|VariableRegisterCount
argument_list|(
name|mLinkedAttribute
index|[
name|attributeIndex
index|]
operator|.
name|type
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|r
init|=
literal|0
init|;
name|r
operator|<
name|rows
condition|;
name|r
operator|++
control|)
block|{
name|mSemanticIndex
index|[
name|attributeIndex
operator|++
index|]
operator|=
name|index
operator|++
expr_stmt|;
block|}
block|}
name|initAttributesByLayout
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|linkValidateVariablesBase
name|bool
name|ProgramBinary
operator|::
name|linkValidateVariablesBase
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|variableName
parameter_list|,
specifier|const
name|sh
operator|::
name|ShaderVariable
modifier|&
name|vertexVariable
parameter_list|,
specifier|const
name|sh
operator|::
name|ShaderVariable
modifier|&
name|fragmentVariable
parameter_list|,
name|bool
name|validatePrecision
parameter_list|)
block|{
if|if
condition|(
name|vertexVariable
operator|.
name|type
operator|!=
name|fragmentVariable
operator|.
name|type
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Types for %s differ between vertex and fragment shaders"
argument_list|,
name|variableName
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|vertexVariable
operator|.
name|arraySize
operator|!=
name|fragmentVariable
operator|.
name|arraySize
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Array sizes for %s differ between vertex and fragment shaders"
argument_list|,
name|variableName
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|validatePrecision
operator|&&
name|vertexVariable
operator|.
name|precision
operator|!=
name|fragmentVariable
operator|.
name|precision
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Precisions for %s differ between vertex and fragment shaders"
argument_list|,
name|variableName
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|vertexVariable
operator|.
name|fields
operator|.
name|size
argument_list|()
operator|!=
name|fragmentVariable
operator|.
name|fields
operator|.
name|size
argument_list|()
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Structure lengths for %s differ between vertex and fragment shaders"
argument_list|,
name|variableName
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|unsigned
name|int
name|numMembers
init|=
name|vertexVariable
operator|.
name|fields
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|memberIndex
init|=
literal|0
init|;
name|memberIndex
operator|<
name|numMembers
condition|;
name|memberIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|ShaderVariable
modifier|&
name|vertexMember
init|=
name|vertexVariable
operator|.
name|fields
index|[
name|memberIndex
index|]
decl_stmt|;
specifier|const
name|sh
operator|::
name|ShaderVariable
modifier|&
name|fragmentMember
init|=
name|fragmentVariable
operator|.
name|fields
index|[
name|memberIndex
index|]
decl_stmt|;
if|if
condition|(
name|vertexMember
operator|.
name|name
operator|!=
name|fragmentMember
operator|.
name|name
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Name mismatch for field '%d' of %s: (in vertex: '%s', in fragment: '%s')"
argument_list|,
name|memberIndex
argument_list|,
name|variableName
operator|.
name|c_str
argument_list|()
argument_list|,
name|vertexMember
operator|.
name|name
operator|.
name|c_str
argument_list|()
argument_list|,
name|fragmentMember
operator|.
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|std
operator|::
name|string
name|memberName
init|=
name|variableName
operator|.
name|substr
argument_list|(
literal|0
argument_list|,
name|variableName
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|+
literal|"."
operator|+
name|vertexMember
operator|.
name|name
operator|+
literal|"'"
decl_stmt|;
if|if
condition|(
operator|!
name|linkValidateVariablesBase
argument_list|(
name|infoLog
argument_list|,
name|vertexMember
operator|.
name|name
argument_list|,
name|vertexMember
argument_list|,
name|fragmentMember
argument_list|,
name|validatePrecision
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|linkValidateUniforms
name|bool
name|ProgramBinary
operator|::
name|linkValidateUniforms
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|uniformName
parameter_list|,
specifier|const
name|sh
operator|::
name|Uniform
modifier|&
name|vertexUniform
parameter_list|,
specifier|const
name|sh
operator|::
name|Uniform
modifier|&
name|fragmentUniform
parameter_list|)
block|{
if|if
condition|(
operator|!
name|linkValidateVariablesBase
argument_list|(
name|infoLog
argument_list|,
name|uniformName
argument_list|,
name|vertexUniform
argument_list|,
name|fragmentUniform
argument_list|,
literal|true
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|linkValidateVaryings
name|bool
name|ProgramBinary
operator|::
name|linkValidateVaryings
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|varyingName
parameter_list|,
specifier|const
name|sh
operator|::
name|Varying
modifier|&
name|vertexVarying
parameter_list|,
specifier|const
name|sh
operator|::
name|Varying
modifier|&
name|fragmentVarying
parameter_list|)
block|{
if|if
condition|(
operator|!
name|linkValidateVariablesBase
argument_list|(
name|infoLog
argument_list|,
name|varyingName
argument_list|,
name|vertexVarying
argument_list|,
name|fragmentVarying
argument_list|,
literal|false
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|vertexVarying
operator|.
name|interpolation
operator|!=
name|fragmentVarying
operator|.
name|interpolation
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Interpolation types for %s differ between vertex and fragment shaders"
argument_list|,
name|varyingName
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|linkValidateInterfaceBlockFields
name|bool
name|ProgramBinary
operator|::
name|linkValidateInterfaceBlockFields
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|uniformName
parameter_list|,
specifier|const
name|sh
operator|::
name|InterfaceBlockField
modifier|&
name|vertexUniform
parameter_list|,
specifier|const
name|sh
operator|::
name|InterfaceBlockField
modifier|&
name|fragmentUniform
parameter_list|)
block|{
if|if
condition|(
operator|!
name|linkValidateVariablesBase
argument_list|(
name|infoLog
argument_list|,
name|uniformName
argument_list|,
name|vertexUniform
argument_list|,
name|fragmentUniform
argument_list|,
literal|true
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|vertexUniform
operator|.
name|isRowMajorLayout
operator|!=
name|fragmentUniform
operator|.
name|isRowMajorLayout
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Matrix packings for %s differ between vertex and fragment shaders"
argument_list|,
name|uniformName
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|gatherTransformFeedbackLinkedVaryings
name|bool
name|ProgramBinary
operator|::
name|gatherTransformFeedbackLinkedVaryings
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|LinkedVarying
argument_list|>
modifier|&
name|linkedVaryings
parameter_list|,
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|std
operator|::
name|string
argument_list|>
modifier|&
name|transformFeedbackVaryingNames
parameter_list|,
name|GLenum
name|transformFeedbackBufferMode
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|LinkedVarying
argument_list|>
modifier|*
name|outTransformFeedbackLinkedVaryings
parameter_list|,
specifier|const
name|Caps
modifier|&
name|caps
parameter_list|)
specifier|const
block|{
name|size_t
name|totalComponents
init|=
literal|0
decl_stmt|;
comment|// Gather the linked varyings that are used for transform feedback, they should all exist.
name|outTransformFeedbackLinkedVaryings
operator|->
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|transformFeedbackVaryingNames
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|bool
name|found
init|=
literal|false
decl_stmt|;
for|for
control|(
name|size_t
name|j
init|=
literal|0
init|;
name|j
operator|<
name|linkedVaryings
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|transformFeedbackVaryingNames
index|[
name|i
index|]
operator|==
name|linkedVaryings
index|[
name|j
index|]
operator|.
name|name
condition|)
block|{
for|for
control|(
name|size_t
name|k
init|=
literal|0
init|;
name|k
operator|<
name|outTransformFeedbackLinkedVaryings
operator|->
name|size
argument_list|()
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|outTransformFeedbackLinkedVaryings
operator|->
name|at
argument_list|(
name|k
argument_list|)
operator|.
name|name
operator|==
name|linkedVaryings
index|[
name|j
index|]
operator|.
name|name
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Two transform feedback varyings specify the same output variable (%s)."
argument_list|,
name|linkedVaryings
index|[
name|j
index|]
operator|.
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|size_t
name|componentCount
init|=
name|linkedVaryings
index|[
name|j
index|]
operator|.
name|semanticIndexCount
operator|*
literal|4
decl_stmt|;
if|if
condition|(
name|transformFeedbackBufferMode
operator|==
name|GL_SEPARATE_ATTRIBS
operator|&&
name|componentCount
operator|>
name|caps
operator|.
name|maxTransformFeedbackSeparateComponents
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Transform feedback varying's %s components (%u) exceed the maximum separate components (%u)."
argument_list|,
name|linkedVaryings
index|[
name|j
index|]
operator|.
name|name
operator|.
name|c_str
argument_list|()
argument_list|,
name|componentCount
argument_list|,
name|caps
operator|.
name|maxTransformFeedbackSeparateComponents
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|totalComponents
operator|+=
name|componentCount
expr_stmt|;
name|outTransformFeedbackLinkedVaryings
operator|->
name|push_back
argument_list|(
name|linkedVaryings
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
comment|// All transform feedback varyings are expected to exist since packVaryings checks for them.
name|ASSERT
argument_list|(
name|found
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|transformFeedbackBufferMode
operator|==
name|GL_INTERLEAVED_ATTRIBS
operator|&&
name|totalComponents
operator|>
name|caps
operator|.
name|maxTransformFeedbackInterleavedComponents
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Transform feedback varying total components (%u) exceed the maximum interleaved components (%u)."
argument_list|,
name|totalComponents
argument_list|,
name|caps
operator|.
name|maxTransformFeedbackInterleavedComponents
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|isValidated
name|bool
name|ProgramBinary
operator|::
name|isValidated
parameter_list|()
specifier|const
block|{
return|return
name|mValidated
return|;
block|}
DECL|function|getActiveAttribute
name|void
name|ProgramBinary
operator|::
name|getActiveAttribute
parameter_list|(
name|GLuint
name|index
parameter_list|,
name|GLsizei
name|bufsize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|,
name|GLint
modifier|*
name|size
parameter_list|,
name|GLenum
modifier|*
name|type
parameter_list|,
name|GLchar
modifier|*
name|name
parameter_list|)
specifier|const
block|{
comment|// Skip over inactive attributes
name|unsigned
name|int
name|activeAttribute
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|attribute
decl_stmt|;
for|for
control|(
name|attribute
operator|=
literal|0
init|;
name|attribute
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|attribute
operator|++
control|)
block|{
if|if
condition|(
name|mLinkedAttribute
index|[
name|attribute
index|]
operator|.
name|name
operator|.
name|empty
argument_list|()
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|activeAttribute
operator|==
name|index
condition|)
block|{
break|break;
block|}
name|activeAttribute
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bufsize
operator|>
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|string
init|=
name|mLinkedAttribute
index|[
name|attribute
index|]
operator|.
name|name
operator|.
name|c_str
argument_list|()
decl_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
name|string
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|name
index|[
name|bufsize
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|size
operator|=
literal|1
expr_stmt|;
comment|// Always a single 'type' instance
operator|*
name|type
operator|=
name|mLinkedAttribute
index|[
name|attribute
index|]
operator|.
name|type
expr_stmt|;
block|}
DECL|function|getActiveAttributeCount
name|GLint
name|ProgramBinary
operator|::
name|getActiveAttributeCount
parameter_list|()
specifier|const
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|attributeIndex
init|=
literal|0
init|;
name|attributeIndex
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|attributeIndex
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|mLinkedAttribute
index|[
name|attributeIndex
index|]
operator|.
name|name
operator|.
name|empty
argument_list|()
condition|)
block|{
name|count
operator|++
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
DECL|function|getActiveAttributeMaxLength
name|GLint
name|ProgramBinary
operator|::
name|getActiveAttributeMaxLength
parameter_list|()
specifier|const
block|{
name|int
name|maxLength
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|attributeIndex
init|=
literal|0
init|;
name|attributeIndex
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|attributeIndex
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|mLinkedAttribute
index|[
name|attributeIndex
index|]
operator|.
name|name
operator|.
name|empty
argument_list|()
condition|)
block|{
name|maxLength
operator|=
name|std
operator|::
name|max
argument_list|(
call|(
name|int
call|)
argument_list|(
name|mLinkedAttribute
index|[
name|attributeIndex
index|]
operator|.
name|name
operator|.
name|length
argument_list|()
operator|+
literal|1
argument_list|)
argument_list|,
name|maxLength
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|maxLength
return|;
block|}
DECL|function|getActiveUniform
name|void
name|ProgramBinary
operator|::
name|getActiveUniform
parameter_list|(
name|GLuint
name|index
parameter_list|,
name|GLsizei
name|bufsize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|,
name|GLint
modifier|*
name|size
parameter_list|,
name|GLenum
modifier|*
name|type
parameter_list|,
name|GLchar
modifier|*
name|name
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|index
operator|<
name|mProgram
operator|->
name|getUniforms
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// index must be smaller than getActiveUniformCount()
if|if
condition|(
name|bufsize
operator|>
literal|0
condition|)
block|{
name|std
operator|::
name|string
name|string
init|=
name|mProgram
operator|->
name|getUniforms
argument_list|()
index|[
name|index
index|]
operator|->
name|name
decl_stmt|;
if|if
condition|(
name|mProgram
operator|->
name|getUniforms
argument_list|()
index|[
name|index
index|]
operator|->
name|isArray
argument_list|()
condition|)
block|{
name|string
operator|+=
literal|"[0]"
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|name
argument_list|,
name|string
operator|.
name|c_str
argument_list|()
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|name
index|[
name|bufsize
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|size
operator|=
name|mProgram
operator|->
name|getUniforms
argument_list|()
index|[
name|index
index|]
operator|->
name|elementCount
argument_list|()
expr_stmt|;
operator|*
name|type
operator|=
name|mProgram
operator|->
name|getUniforms
argument_list|()
index|[
name|index
index|]
operator|->
name|type
expr_stmt|;
block|}
DECL|function|getActiveUniformCount
name|GLint
name|ProgramBinary
operator|::
name|getActiveUniformCount
parameter_list|()
specifier|const
block|{
return|return
name|mProgram
operator|->
name|getUniforms
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
DECL|function|getActiveUniformMaxLength
name|GLint
name|ProgramBinary
operator|::
name|getActiveUniformMaxLength
parameter_list|()
specifier|const
block|{
name|int
name|maxLength
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|numUniforms
init|=
name|mProgram
operator|->
name|getUniforms
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|uniformIndex
init|=
literal|0
init|;
name|uniformIndex
operator|<
name|numUniforms
condition|;
name|uniformIndex
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|mProgram
operator|->
name|getUniforms
argument_list|()
index|[
name|uniformIndex
index|]
operator|->
name|name
operator|.
name|empty
argument_list|()
condition|)
block|{
name|int
name|length
init|=
call|(
name|int
call|)
argument_list|(
name|mProgram
operator|->
name|getUniforms
argument_list|()
index|[
name|uniformIndex
index|]
operator|->
name|name
operator|.
name|length
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|mProgram
operator|->
name|getUniforms
argument_list|()
index|[
name|uniformIndex
index|]
operator|->
name|isArray
argument_list|()
condition|)
block|{
name|length
operator|+=
literal|3
expr_stmt|;
comment|// Counting in "[0]".
block|}
name|maxLength
operator|=
name|std
operator|::
name|max
argument_list|(
name|length
argument_list|,
name|maxLength
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|maxLength
return|;
block|}
DECL|function|getActiveUniformi
name|GLint
name|ProgramBinary
operator|::
name|getActiveUniformi
parameter_list|(
name|GLuint
name|index
parameter_list|,
name|GLenum
name|pname
parameter_list|)
specifier|const
block|{
specifier|const
name|gl
operator|::
name|LinkedUniform
modifier|&
name|uniform
init|=
operator|*
name|mProgram
operator|->
name|getUniforms
argument_list|()
index|[
name|index
index|]
decl_stmt|;
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_UNIFORM_TYPE
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniform
operator|.
name|type
argument_list|)
return|;
case|case
name|GL_UNIFORM_SIZE
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniform
operator|.
name|elementCount
argument_list|()
argument_list|)
return|;
case|case
name|GL_UNIFORM_NAME_LENGTH
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniform
operator|.
name|name
operator|.
name|size
argument_list|()
operator|+
literal|1
operator|+
operator|(
name|uniform
operator|.
name|isArray
argument_list|()
condition|?
literal|3
else|:
literal|0
operator|)
argument_list|)
return|;
case|case
name|GL_UNIFORM_BLOCK_INDEX
case|:
return|return
name|uniform
operator|.
name|blockIndex
return|;
case|case
name|GL_UNIFORM_OFFSET
case|:
return|return
name|uniform
operator|.
name|blockInfo
operator|.
name|offset
return|;
case|case
name|GL_UNIFORM_ARRAY_STRIDE
case|:
return|return
name|uniform
operator|.
name|blockInfo
operator|.
name|arrayStride
return|;
case|case
name|GL_UNIFORM_MATRIX_STRIDE
case|:
return|return
name|uniform
operator|.
name|blockInfo
operator|.
name|matrixStride
return|;
case|case
name|GL_UNIFORM_IS_ROW_MAJOR
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniform
operator|.
name|blockInfo
operator|.
name|isRowMajorMatrix
argument_list|)
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
DECL|function|isValidUniformLocation
name|bool
name|ProgramBinary
operator|::
name|isValidUniformLocation
parameter_list|(
name|GLint
name|location
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|rx
operator|::
name|IsIntegerCastSafe
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|mProgram
operator|->
name|getUniformIndices
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|location
operator|>=
literal|0
operator|&&
name|location
operator|<
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|mProgram
operator|->
name|getUniformIndices
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
operator|)
return|;
block|}
DECL|function|getUniformByLocation
name|LinkedUniform
modifier|*
name|ProgramBinary
operator|::
name|getUniformByLocation
parameter_list|(
name|GLint
name|location
parameter_list|)
specifier|const
block|{
return|return
name|mProgram
operator|->
name|getUniformByLocation
argument_list|(
name|location
argument_list|)
return|;
block|}
DECL|function|getUniformByName
name|LinkedUniform
modifier|*
name|ProgramBinary
operator|::
name|getUniformByName
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|name
parameter_list|)
specifier|const
block|{
return|return
name|mProgram
operator|->
name|getUniformByName
argument_list|(
name|name
argument_list|)
return|;
block|}
DECL|function|getActiveUniformBlockName
name|void
name|ProgramBinary
operator|::
name|getActiveUniformBlockName
parameter_list|(
name|GLuint
name|uniformBlockIndex
parameter_list|,
name|GLsizei
name|bufSize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|,
name|GLchar
modifier|*
name|uniformBlockName
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|uniformBlockIndex
operator|<
name|mProgram
operator|->
name|getUniformBlocks
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// index must be smaller than getActiveUniformBlockCount()
specifier|const
name|UniformBlock
modifier|&
name|uniformBlock
init|=
operator|*
name|mProgram
operator|->
name|getUniformBlocks
argument_list|()
index|[
name|uniformBlockIndex
index|]
decl_stmt|;
if|if
condition|(
name|bufSize
operator|>
literal|0
condition|)
block|{
name|std
operator|::
name|string
name|string
init|=
name|uniformBlock
operator|.
name|name
decl_stmt|;
if|if
condition|(
name|uniformBlock
operator|.
name|isArrayElement
argument_list|()
condition|)
block|{
name|string
operator|+=
name|ArrayString
argument_list|(
name|uniformBlock
operator|.
name|elementIndex
argument_list|)
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|uniformBlockName
argument_list|,
name|string
operator|.
name|c_str
argument_list|()
argument_list|,
name|bufSize
argument_list|)
expr_stmt|;
name|uniformBlockName
index|[
name|bufSize
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
name|strlen
argument_list|(
name|uniformBlockName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|getActiveUniformBlockiv
name|void
name|ProgramBinary
operator|::
name|getActiveUniformBlockiv
parameter_list|(
name|GLuint
name|uniformBlockIndex
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLint
modifier|*
name|params
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|uniformBlockIndex
operator|<
name|mProgram
operator|->
name|getUniformBlocks
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// index must be smaller than getActiveUniformBlockCount()
specifier|const
name|UniformBlock
modifier|&
name|uniformBlock
init|=
operator|*
name|mProgram
operator|->
name|getUniformBlocks
argument_list|()
index|[
name|uniformBlockIndex
index|]
decl_stmt|;
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_UNIFORM_BLOCK_DATA_SIZE
case|:
operator|*
name|params
operator|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniformBlock
operator|.
name|dataSize
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_UNIFORM_BLOCK_NAME_LENGTH
case|:
operator|*
name|params
operator|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniformBlock
operator|.
name|name
operator|.
name|size
argument_list|()
operator|+
literal|1
operator|+
operator|(
name|uniformBlock
operator|.
name|isArrayElement
argument_list|()
condition|?
literal|3
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS
case|:
operator|*
name|params
operator|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniformBlock
operator|.
name|memberUniformIndexes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES
case|:
block|{
for|for
control|(
name|unsigned
name|int
name|blockMemberIndex
init|=
literal|0
init|;
name|blockMemberIndex
operator|<
name|uniformBlock
operator|.
name|memberUniformIndexes
operator|.
name|size
argument_list|()
condition|;
name|blockMemberIndex
operator|++
control|)
block|{
name|params
index|[
name|blockMemberIndex
index|]
operator|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniformBlock
operator|.
name|memberUniformIndexes
index|[
name|blockMemberIndex
index|]
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER
case|:
operator|*
name|params
operator|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniformBlock
operator|.
name|isReferencedByVertexShader
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER
case|:
operator|*
name|params
operator|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniformBlock
operator|.
name|isReferencedByFragmentShader
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|getActiveUniformBlockCount
name|GLuint
name|ProgramBinary
operator|::
name|getActiveUniformBlockCount
parameter_list|()
specifier|const
block|{
return|return
name|mProgram
operator|->
name|getUniformBlocks
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
DECL|function|getActiveUniformBlockMaxLength
name|GLuint
name|ProgramBinary
operator|::
name|getActiveUniformBlockMaxLength
parameter_list|()
specifier|const
block|{
name|unsigned
name|int
name|maxLength
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|numUniformBlocks
init|=
name|mProgram
operator|->
name|getUniformBlocks
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|uniformBlockIndex
init|=
literal|0
init|;
name|uniformBlockIndex
operator|<
name|numUniformBlocks
condition|;
name|uniformBlockIndex
operator|++
control|)
block|{
specifier|const
name|UniformBlock
modifier|&
name|uniformBlock
init|=
operator|*
name|mProgram
operator|->
name|getUniformBlocks
argument_list|()
index|[
name|uniformBlockIndex
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|uniformBlock
operator|.
name|name
operator|.
name|empty
argument_list|()
condition|)
block|{
specifier|const
name|unsigned
name|int
name|length
init|=
name|uniformBlock
operator|.
name|name
operator|.
name|length
argument_list|()
operator|+
literal|1
decl_stmt|;
comment|// Counting in "[0]".
specifier|const
name|unsigned
name|int
name|arrayLength
init|=
operator|(
name|uniformBlock
operator|.
name|isArrayElement
argument_list|()
condition|?
literal|3
else|:
literal|0
operator|)
decl_stmt|;
name|maxLength
operator|=
name|std
operator|::
name|max
argument_list|(
name|length
operator|+
name|arrayLength
argument_list|,
name|maxLength
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|maxLength
return|;
block|}
DECL|function|validate
name|void
name|ProgramBinary
operator|::
name|validate
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|Caps
modifier|&
name|caps
parameter_list|)
block|{
name|applyUniforms
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|validateSamplers
argument_list|(
operator|&
name|infoLog
argument_list|,
name|caps
argument_list|)
condition|)
block|{
name|mValidated
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|mValidated
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|validateSamplers
name|bool
name|ProgramBinary
operator|::
name|validateSamplers
parameter_list|(
name|InfoLog
modifier|*
name|infoLog
parameter_list|,
specifier|const
name|Caps
modifier|&
name|caps
parameter_list|)
block|{
return|return
name|mProgram
operator|->
name|validateSamplers
argument_list|(
name|infoLog
argument_list|,
name|caps
argument_list|)
return|;
block|}
DECL|struct|AttributeSorter
struct|struct
name|AttributeSorter
block|{
DECL|function|AttributeSorter
name|AttributeSorter
argument_list|(
argument|const int (&semanticIndices)[MAX_VERTEX_ATTRIBS]
argument_list|)
public|:
name|originalIndices
parameter_list|(
name|semanticIndices
parameter_list|)
block|{     }
DECL|function|operator ()
name|bool
name|operator
name|()
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
if|if
condition|(
name|originalIndices
index|[
name|a
index|]
operator|==
operator|-
literal|1
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|originalIndices
index|[
name|b
index|]
operator|==
operator|-
literal|1
condition|)
return|return
literal|true
return|;
return|return
operator|(
name|originalIndices
index|[
name|a
index|]
operator|<
name|originalIndices
index|[
name|b
index|]
operator|)
return|;
block|}
DECL|member|originalIndices
specifier|const
name|int
argument_list|(
operator|&
name|originalIndices
argument_list|)
index|[
name|MAX_VERTEX_ATTRIBS
index|]
expr_stmt|;
block|}
struct|;
DECL|function|initAttributesByLayout
name|void
name|ProgramBinary
operator|::
name|initAttributesByLayout
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|i
operator|++
control|)
block|{
name|mAttributesByLayout
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
name|std
operator|::
name|sort
argument_list|(
operator|&
name|mAttributesByLayout
index|[
literal|0
index|]
argument_list|,
operator|&
name|mAttributesByLayout
index|[
name|MAX_VERTEX_ATTRIBS
index|]
argument_list|,
name|AttributeSorter
argument_list|(
name|mSemanticIndex
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|sortAttributesByLayout
name|void
name|ProgramBinary
operator|::
name|sortAttributesByLayout
parameter_list|(
name|rx
operator|::
name|TranslatedAttribute
name|attributes
index|[
name|MAX_VERTEX_ATTRIBS
index|]
parameter_list|,
name|int
name|sortedSemanticIndices
index|[
name|MAX_VERTEX_ATTRIBS
index|]
parameter_list|)
specifier|const
block|{
name|rx
operator|::
name|TranslatedAttribute
name|oldTranslatedAttributes
index|[
name|MAX_VERTEX_ATTRIBS
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|i
operator|++
control|)
block|{
name|oldTranslatedAttributes
index|[
name|i
index|]
operator|=
name|attributes
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|i
operator|++
control|)
block|{
name|int
name|oldIndex
init|=
name|mAttributesByLayout
index|[
name|i
index|]
decl_stmt|;
name|sortedSemanticIndices
index|[
name|i
index|]
operator|=
name|oldIndex
expr_stmt|;
name|attributes
index|[
name|i
index|]
operator|=
name|oldTranslatedAttributes
index|[
name|oldIndex
index|]
expr_stmt|;
block|}
block|}
DECL|function|reset
name|void
name|ProgramBinary
operator|::
name|reset
parameter_list|()
block|{
name|mOutputVariables
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mProgram
operator|->
name|reset
argument_list|()
expr_stmt|;
name|mValidated
operator|=
literal|false
expr_stmt|;
block|}
block|}
end_namespace
end_unit
