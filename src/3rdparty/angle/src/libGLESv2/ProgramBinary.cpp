begin_unit
begin_include
include|#
directive|include
file|"precompiled.h"
end_include
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2013 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Program.cpp: Implements the gl::Program class. Implements GL program objects
end_comment
begin_comment
comment|// and related functionality. [OpenGL ES 2.0.24] section 2.10.3 page 28.
end_comment
begin_include
include|#
directive|include
file|"libGLESv2/BinaryStream.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/ProgramBinary.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/ShaderExecutable.h"
end_include
begin_include
include|#
directive|include
file|"common/debug.h"
end_include
begin_include
include|#
directive|include
file|"common/version.h"
end_include
begin_include
include|#
directive|include
file|"utilities.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/main.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Shader.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Program.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/Renderer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/VertexDataManager.h"
end_include
begin_undef
DECL|macro|near
undef|#
directive|undef
name|near
end_undef
begin_undef
DECL|macro|far
undef|#
directive|undef
name|far
end_undef
begin_namespace
DECL|namespace|gl
namespace|namespace
name|gl
block|{
DECL|function|str
name|std
operator|::
name|string
name|str
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|char
name|buffer
index|[
literal|20
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
DECL|function|UniformLocation
name|UniformLocation
operator|::
name|UniformLocation
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|name
parameter_list|,
name|unsigned
name|int
name|element
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|)
member_init_list|:
name|name
argument_list|(
name|name
argument_list|)
member_init_list|,
name|element
argument_list|(
name|element
argument_list|)
member_init_list|,
name|index
argument_list|(
name|index
argument_list|)
block|{ }
DECL|member|mCurrentSerial
name|unsigned
name|int
name|ProgramBinary
operator|::
name|mCurrentSerial
init|=
literal|1
decl_stmt|;
DECL|function|ProgramBinary
name|ProgramBinary
operator|::
name|ProgramBinary
parameter_list|(
name|rx
operator|::
name|Renderer
modifier|*
name|renderer
parameter_list|)
member_init_list|:
name|mRenderer
argument_list|(
name|renderer
argument_list|)
member_init_list|,
name|RefCountObject
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mSerial
argument_list|(
name|issueSerial
argument_list|()
argument_list|)
block|{
name|mPixelExecutable
operator|=
name|NULL
expr_stmt|;
name|mVertexExecutable
operator|=
name|NULL
expr_stmt|;
name|mGeometryExecutable
operator|=
name|NULL
expr_stmt|;
name|mValidated
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|index
operator|++
control|)
block|{
name|mSemanticIndex
index|[
name|index
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
for|for
control|(
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
name|MAX_TEXTURE_IMAGE_UNITS
condition|;
name|index
operator|++
control|)
block|{
name|mSamplersPS
index|[
name|index
index|]
operator|.
name|active
operator|=
literal|false
expr_stmt|;
block|}
for|for
control|(
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
name|IMPLEMENTATION_MAX_VERTEX_TEXTURE_IMAGE_UNITS
condition|;
name|index
operator|++
control|)
block|{
name|mSamplersVS
index|[
name|index
index|]
operator|.
name|active
operator|=
literal|false
expr_stmt|;
block|}
name|mUsedVertexSamplerRange
operator|=
literal|0
expr_stmt|;
name|mUsedPixelSamplerRange
operator|=
literal|0
expr_stmt|;
name|mUsesPointSize
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|~ProgramBinary
name|ProgramBinary
operator|::
name|~
name|ProgramBinary
parameter_list|()
block|{
operator|delete
name|mPixelExecutable
expr_stmt|;
name|mPixelExecutable
operator|=
name|NULL
expr_stmt|;
operator|delete
name|mVertexExecutable
expr_stmt|;
name|mVertexExecutable
operator|=
name|NULL
expr_stmt|;
operator|delete
name|mGeometryExecutable
expr_stmt|;
name|mGeometryExecutable
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|!
name|mUniforms
operator|.
name|empty
argument_list|()
condition|)
block|{
operator|delete
name|mUniforms
operator|.
name|back
argument_list|()
expr_stmt|;
name|mUniforms
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|getSerial
name|unsigned
name|int
name|ProgramBinary
operator|::
name|getSerial
parameter_list|()
specifier|const
block|{
return|return
name|mSerial
return|;
block|}
DECL|function|issueSerial
name|unsigned
name|int
name|ProgramBinary
operator|::
name|issueSerial
parameter_list|()
block|{
return|return
name|mCurrentSerial
operator|++
return|;
block|}
DECL|function|getPixelExecutable
name|rx
operator|::
name|ShaderExecutable
modifier|*
name|ProgramBinary
operator|::
name|getPixelExecutable
parameter_list|()
block|{
return|return
name|mPixelExecutable
return|;
block|}
DECL|function|getVertexExecutable
name|rx
operator|::
name|ShaderExecutable
modifier|*
name|ProgramBinary
operator|::
name|getVertexExecutable
parameter_list|()
block|{
return|return
name|mVertexExecutable
return|;
block|}
DECL|function|getGeometryExecutable
name|rx
operator|::
name|ShaderExecutable
modifier|*
name|ProgramBinary
operator|::
name|getGeometryExecutable
parameter_list|()
block|{
return|return
name|mGeometryExecutable
return|;
block|}
DECL|function|getAttributeLocation
name|GLuint
name|ProgramBinary
operator|::
name|getAttributeLocation
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
condition|)
block|{
for|for
control|(
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|mLinkedAttribute
index|[
name|index
index|]
operator|.
name|name
operator|==
name|std
operator|::
name|string
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
name|index
return|;
block|}
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
DECL|function|getSemanticIndex
name|int
name|ProgramBinary
operator|::
name|getSemanticIndex
parameter_list|(
name|int
name|attributeIndex
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|attributeIndex
operator|>=
literal|0
operator|&&
name|attributeIndex
operator|<
name|MAX_VERTEX_ATTRIBS
argument_list|)
expr_stmt|;
return|return
name|mSemanticIndex
index|[
name|attributeIndex
index|]
return|;
block|}
comment|// Returns one more than the highest sampler index used.
DECL|function|getUsedSamplerRange
name|GLint
name|ProgramBinary
operator|::
name|getUsedSamplerRange
parameter_list|(
name|SamplerType
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SAMPLER_PIXEL
case|:
return|return
name|mUsedPixelSamplerRange
return|;
case|case
name|SAMPLER_VERTEX
case|:
return|return
name|mUsedVertexSamplerRange
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|usesPointSize
name|bool
name|ProgramBinary
operator|::
name|usesPointSize
parameter_list|()
specifier|const
block|{
return|return
name|mUsesPointSize
return|;
block|}
DECL|function|usesPointSpriteEmulation
name|bool
name|ProgramBinary
operator|::
name|usesPointSpriteEmulation
parameter_list|()
specifier|const
block|{
return|return
name|mUsesPointSize
operator|&&
name|mRenderer
operator|->
name|getMajorShaderModel
argument_list|()
operator|>=
literal|4
return|;
block|}
DECL|function|usesGeometryShader
name|bool
name|ProgramBinary
operator|::
name|usesGeometryShader
parameter_list|()
specifier|const
block|{
return|return
name|usesPointSpriteEmulation
argument_list|()
return|;
block|}
comment|// Returns the index of the texture image unit (0-19) corresponding to a Direct3D 9 sampler
comment|// index (0-15 for the pixel shader and 0-3 for the vertex shader).
DECL|function|getSamplerMapping
name|GLint
name|ProgramBinary
operator|::
name|getSamplerMapping
parameter_list|(
name|SamplerType
name|type
parameter_list|,
name|unsigned
name|int
name|samplerIndex
parameter_list|)
block|{
name|GLint
name|logicalTextureUnit
init|=
operator|-
literal|1
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SAMPLER_PIXEL
case|:
name|ASSERT
argument_list|(
name|samplerIndex
operator|<
sizeof|sizeof
argument_list|(
name|mSamplersPS
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mSamplersPS
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mSamplersPS
index|[
name|samplerIndex
index|]
operator|.
name|active
condition|)
block|{
name|logicalTextureUnit
operator|=
name|mSamplersPS
index|[
name|samplerIndex
index|]
operator|.
name|logicalTextureUnit
expr_stmt|;
block|}
break|break;
case|case
name|SAMPLER_VERTEX
case|:
name|ASSERT
argument_list|(
name|samplerIndex
operator|<
sizeof|sizeof
argument_list|(
name|mSamplersVS
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mSamplersVS
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mSamplersVS
index|[
name|samplerIndex
index|]
operator|.
name|active
condition|)
block|{
name|logicalTextureUnit
operator|=
name|mSamplersVS
index|[
name|samplerIndex
index|]
operator|.
name|logicalTextureUnit
expr_stmt|;
block|}
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|logicalTextureUnit
operator|>=
literal|0
operator|&&
name|logicalTextureUnit
operator|<
operator|(
name|GLint
operator|)
name|mRenderer
operator|->
name|getMaxCombinedTextureImageUnits
argument_list|()
condition|)
block|{
return|return
name|logicalTextureUnit
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|// Returns the texture type for a given Direct3D 9 sampler type and
comment|// index (0-15 for the pixel shader and 0-3 for the vertex shader).
DECL|function|getSamplerTextureType
name|TextureType
name|ProgramBinary
operator|::
name|getSamplerTextureType
parameter_list|(
name|SamplerType
name|type
parameter_list|,
name|unsigned
name|int
name|samplerIndex
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SAMPLER_PIXEL
case|:
name|ASSERT
argument_list|(
name|samplerIndex
operator|<
sizeof|sizeof
argument_list|(
name|mSamplersPS
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mSamplersPS
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mSamplersPS
index|[
name|samplerIndex
index|]
operator|.
name|active
argument_list|)
expr_stmt|;
return|return
name|mSamplersPS
index|[
name|samplerIndex
index|]
operator|.
name|textureType
return|;
case|case
name|SAMPLER_VERTEX
case|:
name|ASSERT
argument_list|(
name|samplerIndex
operator|<
sizeof|sizeof
argument_list|(
name|mSamplersVS
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mSamplersVS
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mSamplersVS
index|[
name|samplerIndex
index|]
operator|.
name|active
argument_list|)
expr_stmt|;
return|return
name|mSamplersVS
index|[
name|samplerIndex
index|]
operator|.
name|textureType
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
name|TEXTURE_2D
return|;
block|}
DECL|function|getUniformLocation
name|GLint
name|ProgramBinary
operator|::
name|getUniformLocation
parameter_list|(
name|std
operator|::
name|string
name|name
parameter_list|)
block|{
name|unsigned
name|int
name|subscript
init|=
literal|0
decl_stmt|;
comment|// Strip any trailing array operator and retrieve the subscript
name|size_t
name|open
init|=
name|name
operator|.
name|find_last_of
argument_list|(
literal|'['
argument_list|)
decl_stmt|;
name|size_t
name|close
init|=
name|name
operator|.
name|find_last_of
argument_list|(
literal|']'
argument_list|)
decl_stmt|;
if|if
condition|(
name|open
operator|!=
name|std
operator|::
name|string
operator|::
name|npos
operator|&&
name|close
operator|==
name|name
operator|.
name|length
argument_list|()
operator|-
literal|1
condition|)
block|{
name|subscript
operator|=
name|atoi
argument_list|(
name|name
operator|.
name|substr
argument_list|(
name|open
operator|+
literal|1
argument_list|)
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|name
operator|.
name|erase
argument_list|(
name|open
argument_list|)
expr_stmt|;
block|}
name|unsigned
name|int
name|numUniforms
init|=
name|mUniformIndex
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|location
init|=
literal|0
init|;
name|location
operator|<
name|numUniforms
condition|;
name|location
operator|++
control|)
block|{
if|if
condition|(
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|name
operator|==
name|name
operator|&&
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|==
name|subscript
condition|)
block|{
return|return
name|location
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
DECL|function|setUniform1fv
name|bool
name|ProgramBinary
operator|::
name|setUniform1fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
name|location
operator|<
literal|0
operator|||
name|location
operator|>=
operator|(
name|int
operator|)
name|mUniformIndex
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Uniform
modifier|*
name|targetUniform
init|=
name|mUniforms
index|[
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|index
index|]
decl_stmt|;
name|targetUniform
operator|->
name|dirty
operator|=
literal|true
expr_stmt|;
name|int
name|elementCount
init|=
name|targetUniform
operator|->
name|elementCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|elementCount
operator|==
literal|1
operator|&&
name|count
operator|>
literal|1
condition|)
return|return
literal|false
return|;
comment|// attempting to write an array to a non-array uniform is an INVALID_OPERATION
name|count
operator|=
name|std
operator|::
name|min
argument_list|(
name|elementCount
operator|-
operator|(
name|int
operator|)
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|GL_FLOAT
condition|)
block|{
name|GLfloat
modifier|*
name|target
init|=
operator|(
name|GLfloat
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|target
index|[
literal|0
index|]
operator|=
name|v
index|[
literal|0
index|]
expr_stmt|;
name|target
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|target
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|target
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|target
operator|+=
literal|4
expr_stmt|;
name|v
operator|+=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|GL_BOOL
condition|)
block|{
name|GLint
modifier|*
name|boolParams
init|=
operator|(
name|GLint
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|boolParams
index|[
literal|0
index|]
operator|=
operator|(
name|v
index|[
literal|0
index|]
operator|==
literal|0.0f
operator|)
condition|?
name|GL_FALSE
else|:
name|GL_TRUE
expr_stmt|;
name|boolParams
index|[
literal|1
index|]
operator|=
name|GL_FALSE
expr_stmt|;
name|boolParams
index|[
literal|2
index|]
operator|=
name|GL_FALSE
expr_stmt|;
name|boolParams
index|[
literal|3
index|]
operator|=
name|GL_FALSE
expr_stmt|;
name|boolParams
operator|+=
literal|4
expr_stmt|;
name|v
operator|+=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|setUniform2fv
name|bool
name|ProgramBinary
operator|::
name|setUniform2fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
name|location
operator|<
literal|0
operator|||
name|location
operator|>=
operator|(
name|int
operator|)
name|mUniformIndex
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Uniform
modifier|*
name|targetUniform
init|=
name|mUniforms
index|[
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|index
index|]
decl_stmt|;
name|targetUniform
operator|->
name|dirty
operator|=
literal|true
expr_stmt|;
name|int
name|elementCount
init|=
name|targetUniform
operator|->
name|elementCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|elementCount
operator|==
literal|1
operator|&&
name|count
operator|>
literal|1
condition|)
return|return
literal|false
return|;
comment|// attempting to write an array to a non-array uniform is an INVALID_OPERATION
name|count
operator|=
name|std
operator|::
name|min
argument_list|(
name|elementCount
operator|-
operator|(
name|int
operator|)
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|GL_FLOAT_VEC2
condition|)
block|{
name|GLfloat
modifier|*
name|target
init|=
operator|(
name|GLfloat
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|target
index|[
literal|0
index|]
operator|=
name|v
index|[
literal|0
index|]
expr_stmt|;
name|target
index|[
literal|1
index|]
operator|=
name|v
index|[
literal|1
index|]
expr_stmt|;
name|target
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|target
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|target
operator|+=
literal|4
expr_stmt|;
name|v
operator|+=
literal|2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|GL_BOOL_VEC2
condition|)
block|{
name|GLint
modifier|*
name|boolParams
init|=
operator|(
name|GLint
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|boolParams
index|[
literal|0
index|]
operator|=
operator|(
name|v
index|[
literal|0
index|]
operator|==
literal|0.0f
operator|)
condition|?
name|GL_FALSE
else|:
name|GL_TRUE
expr_stmt|;
name|boolParams
index|[
literal|1
index|]
operator|=
operator|(
name|v
index|[
literal|1
index|]
operator|==
literal|0.0f
operator|)
condition|?
name|GL_FALSE
else|:
name|GL_TRUE
expr_stmt|;
name|boolParams
index|[
literal|2
index|]
operator|=
name|GL_FALSE
expr_stmt|;
name|boolParams
index|[
literal|3
index|]
operator|=
name|GL_FALSE
expr_stmt|;
name|boolParams
operator|+=
literal|4
expr_stmt|;
name|v
operator|+=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|setUniform3fv
name|bool
name|ProgramBinary
operator|::
name|setUniform3fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
name|location
operator|<
literal|0
operator|||
name|location
operator|>=
operator|(
name|int
operator|)
name|mUniformIndex
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Uniform
modifier|*
name|targetUniform
init|=
name|mUniforms
index|[
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|index
index|]
decl_stmt|;
name|targetUniform
operator|->
name|dirty
operator|=
literal|true
expr_stmt|;
name|int
name|elementCount
init|=
name|targetUniform
operator|->
name|elementCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|elementCount
operator|==
literal|1
operator|&&
name|count
operator|>
literal|1
condition|)
return|return
literal|false
return|;
comment|// attempting to write an array to a non-array uniform is an INVALID_OPERATION
name|count
operator|=
name|std
operator|::
name|min
argument_list|(
name|elementCount
operator|-
operator|(
name|int
operator|)
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|GL_FLOAT_VEC3
condition|)
block|{
name|GLfloat
modifier|*
name|target
init|=
operator|(
name|GLfloat
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|target
index|[
literal|0
index|]
operator|=
name|v
index|[
literal|0
index|]
expr_stmt|;
name|target
index|[
literal|1
index|]
operator|=
name|v
index|[
literal|1
index|]
expr_stmt|;
name|target
index|[
literal|2
index|]
operator|=
name|v
index|[
literal|2
index|]
expr_stmt|;
name|target
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|target
operator|+=
literal|4
expr_stmt|;
name|v
operator|+=
literal|3
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|GL_BOOL_VEC3
condition|)
block|{
name|GLint
modifier|*
name|boolParams
init|=
operator|(
name|GLint
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|boolParams
index|[
literal|0
index|]
operator|=
operator|(
name|v
index|[
literal|0
index|]
operator|==
literal|0.0f
operator|)
condition|?
name|GL_FALSE
else|:
name|GL_TRUE
expr_stmt|;
name|boolParams
index|[
literal|1
index|]
operator|=
operator|(
name|v
index|[
literal|1
index|]
operator|==
literal|0.0f
operator|)
condition|?
name|GL_FALSE
else|:
name|GL_TRUE
expr_stmt|;
name|boolParams
index|[
literal|2
index|]
operator|=
operator|(
name|v
index|[
literal|2
index|]
operator|==
literal|0.0f
operator|)
condition|?
name|GL_FALSE
else|:
name|GL_TRUE
expr_stmt|;
name|boolParams
index|[
literal|3
index|]
operator|=
name|GL_FALSE
expr_stmt|;
name|boolParams
operator|+=
literal|4
expr_stmt|;
name|v
operator|+=
literal|3
expr_stmt|;
block|}
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|setUniform4fv
name|bool
name|ProgramBinary
operator|::
name|setUniform4fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
name|location
operator|<
literal|0
operator|||
name|location
operator|>=
operator|(
name|int
operator|)
name|mUniformIndex
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Uniform
modifier|*
name|targetUniform
init|=
name|mUniforms
index|[
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|index
index|]
decl_stmt|;
name|targetUniform
operator|->
name|dirty
operator|=
literal|true
expr_stmt|;
name|int
name|elementCount
init|=
name|targetUniform
operator|->
name|elementCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|elementCount
operator|==
literal|1
operator|&&
name|count
operator|>
literal|1
condition|)
return|return
literal|false
return|;
comment|// attempting to write an array to a non-array uniform is an INVALID_OPERATION
name|count
operator|=
name|std
operator|::
name|min
argument_list|(
name|elementCount
operator|-
operator|(
name|int
operator|)
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|GL_FLOAT_VEC4
condition|)
block|{
name|GLfloat
modifier|*
name|target
init|=
operator|(
name|GLfloat
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|target
index|[
literal|0
index|]
operator|=
name|v
index|[
literal|0
index|]
expr_stmt|;
name|target
index|[
literal|1
index|]
operator|=
name|v
index|[
literal|1
index|]
expr_stmt|;
name|target
index|[
literal|2
index|]
operator|=
name|v
index|[
literal|2
index|]
expr_stmt|;
name|target
index|[
literal|3
index|]
operator|=
name|v
index|[
literal|3
index|]
expr_stmt|;
name|target
operator|+=
literal|4
expr_stmt|;
name|v
operator|+=
literal|4
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|GL_BOOL_VEC4
condition|)
block|{
name|GLint
modifier|*
name|boolParams
init|=
operator|(
name|GLint
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|boolParams
index|[
literal|0
index|]
operator|=
operator|(
name|v
index|[
literal|0
index|]
operator|==
literal|0.0f
operator|)
condition|?
name|GL_FALSE
else|:
name|GL_TRUE
expr_stmt|;
name|boolParams
index|[
literal|1
index|]
operator|=
operator|(
name|v
index|[
literal|1
index|]
operator|==
literal|0.0f
operator|)
condition|?
name|GL_FALSE
else|:
name|GL_TRUE
expr_stmt|;
name|boolParams
index|[
literal|2
index|]
operator|=
operator|(
name|v
index|[
literal|2
index|]
operator|==
literal|0.0f
operator|)
condition|?
name|GL_FALSE
else|:
name|GL_TRUE
expr_stmt|;
name|boolParams
index|[
literal|3
index|]
operator|=
operator|(
name|v
index|[
literal|3
index|]
operator|==
literal|0.0f
operator|)
condition|?
name|GL_FALSE
else|:
name|GL_TRUE
expr_stmt|;
name|boolParams
operator|+=
literal|4
expr_stmt|;
name|v
operator|+=
literal|4
expr_stmt|;
block|}
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
template|template
parameter_list|<
name|typename
name|T
parameter_list|,
name|int
name|targetWidth
parameter_list|,
name|int
name|targetHeight
parameter_list|,
name|int
name|srcWidth
parameter_list|,
name|int
name|srcHeight
parameter_list|>
DECL|function|transposeMatrix
name|void
name|transposeMatrix
parameter_list|(
name|T
modifier|*
name|target
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
name|int
name|copyWidth
init|=
name|std
operator|::
name|min
argument_list|(
name|targetWidth
argument_list|,
name|srcWidth
argument_list|)
decl_stmt|;
name|int
name|copyHeight
init|=
name|std
operator|::
name|min
argument_list|(
name|targetHeight
argument_list|,
name|srcHeight
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|copyWidth
condition|;
name|x
operator|++
control|)
block|{
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|copyHeight
condition|;
name|y
operator|++
control|)
block|{
name|target
index|[
name|x
operator|*
name|targetWidth
operator|+
name|y
index|]
operator|=
operator|(
name|T
operator|)
name|value
index|[
name|y
operator|*
name|srcWidth
operator|+
name|x
index|]
expr_stmt|;
block|}
block|}
comment|// clear unfilled right side
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|copyHeight
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
name|srcWidth
init|;
name|x
operator|<
name|targetWidth
condition|;
name|x
operator|++
control|)
block|{
name|target
index|[
name|y
operator|*
name|targetWidth
operator|+
name|x
index|]
operator|=
operator|(
name|T
operator|)
literal|0
expr_stmt|;
block|}
block|}
comment|// clear unfilled bottom.
for|for
control|(
name|int
name|y
init|=
name|srcHeight
init|;
name|y
operator|<
name|targetHeight
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|targetWidth
condition|;
name|x
operator|++
control|)
block|{
name|target
index|[
name|y
operator|*
name|targetWidth
operator|+
name|x
index|]
operator|=
operator|(
name|T
operator|)
literal|0
expr_stmt|;
block|}
block|}
block|}
DECL|function|setUniformMatrix2fv
name|bool
name|ProgramBinary
operator|::
name|setUniformMatrix2fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
name|location
operator|<
literal|0
operator|||
name|location
operator|>=
operator|(
name|int
operator|)
name|mUniformIndex
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Uniform
modifier|*
name|targetUniform
init|=
name|mUniforms
index|[
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|index
index|]
decl_stmt|;
name|targetUniform
operator|->
name|dirty
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|!=
name|GL_FLOAT_MAT2
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|elementCount
init|=
name|targetUniform
operator|->
name|elementCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|elementCount
operator|==
literal|1
operator|&&
name|count
operator|>
literal|1
condition|)
return|return
literal|false
return|;
comment|// attempting to write an array to a non-array uniform is an INVALID_OPERATION
name|count
operator|=
name|std
operator|::
name|min
argument_list|(
name|elementCount
operator|-
operator|(
name|int
operator|)
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|GLfloat
modifier|*
name|target
init|=
operator|(
name|GLfloat
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|8
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|transposeMatrix
argument_list|<
name|GLfloat
argument_list|,
literal|4
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|>
argument_list|(
name|target
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|target
operator|+=
literal|8
expr_stmt|;
name|value
operator|+=
literal|4
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|setUniformMatrix3fv
name|bool
name|ProgramBinary
operator|::
name|setUniformMatrix3fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
name|location
operator|<
literal|0
operator|||
name|location
operator|>=
operator|(
name|int
operator|)
name|mUniformIndex
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Uniform
modifier|*
name|targetUniform
init|=
name|mUniforms
index|[
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|index
index|]
decl_stmt|;
name|targetUniform
operator|->
name|dirty
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|!=
name|GL_FLOAT_MAT3
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|elementCount
init|=
name|targetUniform
operator|->
name|elementCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|elementCount
operator|==
literal|1
operator|&&
name|count
operator|>
literal|1
condition|)
return|return
literal|false
return|;
comment|// attempting to write an array to a non-array uniform is an INVALID_OPERATION
name|count
operator|=
name|std
operator|::
name|min
argument_list|(
name|elementCount
operator|-
operator|(
name|int
operator|)
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|GLfloat
modifier|*
name|target
init|=
operator|(
name|GLfloat
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|12
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|transposeMatrix
argument_list|<
name|GLfloat
argument_list|,
literal|4
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|>
argument_list|(
name|target
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|target
operator|+=
literal|12
expr_stmt|;
name|value
operator|+=
literal|9
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|setUniformMatrix4fv
name|bool
name|ProgramBinary
operator|::
name|setUniformMatrix4fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
name|location
operator|<
literal|0
operator|||
name|location
operator|>=
operator|(
name|int
operator|)
name|mUniformIndex
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Uniform
modifier|*
name|targetUniform
init|=
name|mUniforms
index|[
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|index
index|]
decl_stmt|;
name|targetUniform
operator|->
name|dirty
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|!=
name|GL_FLOAT_MAT4
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|elementCount
init|=
name|targetUniform
operator|->
name|elementCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|elementCount
operator|==
literal|1
operator|&&
name|count
operator|>
literal|1
condition|)
return|return
literal|false
return|;
comment|// attempting to write an array to a non-array uniform is an INVALID_OPERATION
name|count
operator|=
name|std
operator|::
name|min
argument_list|(
name|elementCount
operator|-
operator|(
name|int
operator|)
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|GLfloat
modifier|*
name|target
init|=
operator|(
name|GLfloat
operator|*
operator|)
operator|(
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
sizeof|sizeof
argument_list|(
name|GLfloat
argument_list|)
operator|*
literal|16
operator|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|transposeMatrix
argument_list|<
name|GLfloat
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|>
argument_list|(
name|target
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|target
operator|+=
literal|16
expr_stmt|;
name|value
operator|+=
literal|16
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|setUniform1iv
name|bool
name|ProgramBinary
operator|::
name|setUniform1iv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
name|location
operator|<
literal|0
operator|||
name|location
operator|>=
operator|(
name|int
operator|)
name|mUniformIndex
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Uniform
modifier|*
name|targetUniform
init|=
name|mUniforms
index|[
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|index
index|]
decl_stmt|;
name|targetUniform
operator|->
name|dirty
operator|=
literal|true
expr_stmt|;
name|int
name|elementCount
init|=
name|targetUniform
operator|->
name|elementCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|elementCount
operator|==
literal|1
operator|&&
name|count
operator|>
literal|1
condition|)
return|return
literal|false
return|;
comment|// attempting to write an array to a non-array uniform is an INVALID_OPERATION
name|count
operator|=
name|std
operator|::
name|min
argument_list|(
name|elementCount
operator|-
operator|(
name|int
operator|)
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|GL_INT
operator|||
name|targetUniform
operator|->
name|type
operator|==
name|GL_SAMPLER_2D
operator|||
name|targetUniform
operator|->
name|type
operator|==
name|GL_SAMPLER_CUBE
condition|)
block|{
name|GLint
modifier|*
name|target
init|=
operator|(
name|GLint
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|target
index|[
literal|0
index|]
operator|=
name|v
index|[
literal|0
index|]
expr_stmt|;
name|target
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|target
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|target
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|target
operator|+=
literal|4
expr_stmt|;
name|v
operator|+=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|GL_BOOL
condition|)
block|{
name|GLint
modifier|*
name|boolParams
init|=
operator|(
name|GLint
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|boolParams
index|[
literal|0
index|]
operator|=
operator|(
name|v
index|[
literal|0
index|]
operator|==
literal|0
operator|)
condition|?
name|GL_FALSE
else|:
name|GL_TRUE
expr_stmt|;
name|boolParams
index|[
literal|1
index|]
operator|=
name|GL_FALSE
expr_stmt|;
name|boolParams
index|[
literal|2
index|]
operator|=
name|GL_FALSE
expr_stmt|;
name|boolParams
index|[
literal|3
index|]
operator|=
name|GL_FALSE
expr_stmt|;
name|boolParams
operator|+=
literal|4
expr_stmt|;
name|v
operator|+=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|setUniform2iv
name|bool
name|ProgramBinary
operator|::
name|setUniform2iv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
name|location
operator|<
literal|0
operator|||
name|location
operator|>=
operator|(
name|int
operator|)
name|mUniformIndex
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Uniform
modifier|*
name|targetUniform
init|=
name|mUniforms
index|[
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|index
index|]
decl_stmt|;
name|targetUniform
operator|->
name|dirty
operator|=
literal|true
expr_stmt|;
name|int
name|elementCount
init|=
name|targetUniform
operator|->
name|elementCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|elementCount
operator|==
literal|1
operator|&&
name|count
operator|>
literal|1
condition|)
return|return
literal|false
return|;
comment|// attempting to write an array to a non-array uniform is an INVALID_OPERATION
name|count
operator|=
name|std
operator|::
name|min
argument_list|(
name|elementCount
operator|-
operator|(
name|int
operator|)
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|GL_INT_VEC2
condition|)
block|{
name|GLint
modifier|*
name|target
init|=
operator|(
name|GLint
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|target
index|[
literal|0
index|]
operator|=
name|v
index|[
literal|0
index|]
expr_stmt|;
name|target
index|[
literal|1
index|]
operator|=
name|v
index|[
literal|1
index|]
expr_stmt|;
name|target
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|target
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|target
operator|+=
literal|4
expr_stmt|;
name|v
operator|+=
literal|2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|GL_BOOL_VEC2
condition|)
block|{
name|GLint
modifier|*
name|boolParams
init|=
operator|(
name|GLint
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|boolParams
index|[
literal|0
index|]
operator|=
operator|(
name|v
index|[
literal|0
index|]
operator|==
literal|0
operator|)
condition|?
name|GL_FALSE
else|:
name|GL_TRUE
expr_stmt|;
name|boolParams
index|[
literal|1
index|]
operator|=
operator|(
name|v
index|[
literal|1
index|]
operator|==
literal|0
operator|)
condition|?
name|GL_FALSE
else|:
name|GL_TRUE
expr_stmt|;
name|boolParams
index|[
literal|2
index|]
operator|=
name|GL_FALSE
expr_stmt|;
name|boolParams
index|[
literal|3
index|]
operator|=
name|GL_FALSE
expr_stmt|;
name|boolParams
operator|+=
literal|4
expr_stmt|;
name|v
operator|+=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|setUniform3iv
name|bool
name|ProgramBinary
operator|::
name|setUniform3iv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
name|location
operator|<
literal|0
operator|||
name|location
operator|>=
operator|(
name|int
operator|)
name|mUniformIndex
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Uniform
modifier|*
name|targetUniform
init|=
name|mUniforms
index|[
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|index
index|]
decl_stmt|;
name|targetUniform
operator|->
name|dirty
operator|=
literal|true
expr_stmt|;
name|int
name|elementCount
init|=
name|targetUniform
operator|->
name|elementCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|elementCount
operator|==
literal|1
operator|&&
name|count
operator|>
literal|1
condition|)
return|return
literal|false
return|;
comment|// attempting to write an array to a non-array uniform is an INVALID_OPERATION
name|count
operator|=
name|std
operator|::
name|min
argument_list|(
name|elementCount
operator|-
operator|(
name|int
operator|)
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|GL_INT_VEC3
condition|)
block|{
name|GLint
modifier|*
name|target
init|=
operator|(
name|GLint
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|target
index|[
literal|0
index|]
operator|=
name|v
index|[
literal|0
index|]
expr_stmt|;
name|target
index|[
literal|1
index|]
operator|=
name|v
index|[
literal|1
index|]
expr_stmt|;
name|target
index|[
literal|2
index|]
operator|=
name|v
index|[
literal|2
index|]
expr_stmt|;
name|target
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|target
operator|+=
literal|4
expr_stmt|;
name|v
operator|+=
literal|3
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|GL_BOOL_VEC3
condition|)
block|{
name|GLint
modifier|*
name|boolParams
init|=
operator|(
name|GLint
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|boolParams
index|[
literal|0
index|]
operator|=
operator|(
name|v
index|[
literal|0
index|]
operator|==
literal|0
operator|)
condition|?
name|GL_FALSE
else|:
name|GL_TRUE
expr_stmt|;
name|boolParams
index|[
literal|1
index|]
operator|=
operator|(
name|v
index|[
literal|1
index|]
operator|==
literal|0
operator|)
condition|?
name|GL_FALSE
else|:
name|GL_TRUE
expr_stmt|;
name|boolParams
index|[
literal|2
index|]
operator|=
operator|(
name|v
index|[
literal|2
index|]
operator|==
literal|0
operator|)
condition|?
name|GL_FALSE
else|:
name|GL_TRUE
expr_stmt|;
name|boolParams
index|[
literal|3
index|]
operator|=
name|GL_FALSE
expr_stmt|;
name|boolParams
operator|+=
literal|4
expr_stmt|;
name|v
operator|+=
literal|3
expr_stmt|;
block|}
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|setUniform4iv
name|bool
name|ProgramBinary
operator|::
name|setUniform4iv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
name|location
operator|<
literal|0
operator|||
name|location
operator|>=
operator|(
name|int
operator|)
name|mUniformIndex
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Uniform
modifier|*
name|targetUniform
init|=
name|mUniforms
index|[
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|index
index|]
decl_stmt|;
name|targetUniform
operator|->
name|dirty
operator|=
literal|true
expr_stmt|;
name|int
name|elementCount
init|=
name|targetUniform
operator|->
name|elementCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|elementCount
operator|==
literal|1
operator|&&
name|count
operator|>
literal|1
condition|)
return|return
literal|false
return|;
comment|// attempting to write an array to a non-array uniform is an INVALID_OPERATION
name|count
operator|=
name|std
operator|::
name|min
argument_list|(
name|elementCount
operator|-
operator|(
name|int
operator|)
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|GL_INT_VEC4
condition|)
block|{
name|GLint
modifier|*
name|target
init|=
operator|(
name|GLint
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|target
index|[
literal|0
index|]
operator|=
name|v
index|[
literal|0
index|]
expr_stmt|;
name|target
index|[
literal|1
index|]
operator|=
name|v
index|[
literal|1
index|]
expr_stmt|;
name|target
index|[
literal|2
index|]
operator|=
name|v
index|[
literal|2
index|]
expr_stmt|;
name|target
index|[
literal|3
index|]
operator|=
name|v
index|[
literal|3
index|]
expr_stmt|;
name|target
operator|+=
literal|4
expr_stmt|;
name|v
operator|+=
literal|4
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|GL_BOOL_VEC4
condition|)
block|{
name|GLint
modifier|*
name|boolParams
init|=
operator|(
name|GLint
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|boolParams
index|[
literal|0
index|]
operator|=
operator|(
name|v
index|[
literal|0
index|]
operator|==
literal|0
operator|)
condition|?
name|GL_FALSE
else|:
name|GL_TRUE
expr_stmt|;
name|boolParams
index|[
literal|1
index|]
operator|=
operator|(
name|v
index|[
literal|1
index|]
operator|==
literal|0
operator|)
condition|?
name|GL_FALSE
else|:
name|GL_TRUE
expr_stmt|;
name|boolParams
index|[
literal|2
index|]
operator|=
operator|(
name|v
index|[
literal|2
index|]
operator|==
literal|0
operator|)
condition|?
name|GL_FALSE
else|:
name|GL_TRUE
expr_stmt|;
name|boolParams
index|[
literal|3
index|]
operator|=
operator|(
name|v
index|[
literal|3
index|]
operator|==
literal|0
operator|)
condition|?
name|GL_FALSE
else|:
name|GL_TRUE
expr_stmt|;
name|boolParams
operator|+=
literal|4
expr_stmt|;
name|v
operator|+=
literal|4
expr_stmt|;
block|}
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|getUniformfv
name|bool
name|ProgramBinary
operator|::
name|getUniformfv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
modifier|*
name|bufSize
parameter_list|,
name|GLfloat
modifier|*
name|params
parameter_list|)
block|{
if|if
condition|(
name|location
operator|<
literal|0
operator|||
name|location
operator|>=
operator|(
name|int
operator|)
name|mUniformIndex
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Uniform
modifier|*
name|targetUniform
init|=
name|mUniforms
index|[
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|index
index|]
decl_stmt|;
comment|// sized queries -- ensure the provided buffer is large enough
if|if
condition|(
name|bufSize
condition|)
block|{
name|int
name|requiredBytes
init|=
name|UniformExternalSize
argument_list|(
name|targetUniform
operator|->
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|bufSize
operator|<
name|requiredBytes
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
switch|switch
condition|(
name|targetUniform
operator|->
name|type
condition|)
block|{
case|case
name|GL_FLOAT_MAT2
case|:
name|transposeMatrix
argument_list|<
name|GLfloat
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|4
argument_list|,
literal|2
argument_list|>
argument_list|(
name|params
argument_list|,
operator|(
name|GLfloat
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_FLOAT_MAT3
case|:
name|transposeMatrix
argument_list|<
name|GLfloat
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|3
argument_list|>
argument_list|(
name|params
argument_list|,
operator|(
name|GLfloat
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|12
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_FLOAT_MAT4
case|:
name|transposeMatrix
argument_list|<
name|GLfloat
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|>
argument_list|(
name|params
argument_list|,
operator|(
name|GLfloat
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|16
argument_list|)
expr_stmt|;
break|break;
default|default:
block|{
name|unsigned
name|int
name|size
init|=
name|UniformComponentCount
argument_list|(
name|targetUniform
operator|->
name|type
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|UniformComponentType
argument_list|(
name|targetUniform
operator|->
name|type
argument_list|)
condition|)
block|{
case|case
name|GL_BOOL
case|:
block|{
name|GLint
modifier|*
name|boolParams
init|=
operator|(
name|GLint
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|params
index|[
name|i
index|]
operator|=
operator|(
name|boolParams
index|[
name|i
index|]
operator|==
name|GL_FALSE
operator|)
condition|?
literal|0.0f
else|:
literal|1.0f
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GL_FLOAT
case|:
name|memcpy
argument_list|(
name|params
argument_list|,
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|GLfloat
argument_list|)
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|GLfloat
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_INT
case|:
block|{
name|GLint
modifier|*
name|intParams
init|=
operator|(
name|GLint
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|params
index|[
name|i
index|]
operator|=
operator|(
name|float
operator|)
name|intParams
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|getUniformiv
name|bool
name|ProgramBinary
operator|::
name|getUniformiv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
modifier|*
name|bufSize
parameter_list|,
name|GLint
modifier|*
name|params
parameter_list|)
block|{
if|if
condition|(
name|location
operator|<
literal|0
operator|||
name|location
operator|>=
operator|(
name|int
operator|)
name|mUniformIndex
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Uniform
modifier|*
name|targetUniform
init|=
name|mUniforms
index|[
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|index
index|]
decl_stmt|;
comment|// sized queries -- ensure the provided buffer is large enough
if|if
condition|(
name|bufSize
condition|)
block|{
name|int
name|requiredBytes
init|=
name|UniformExternalSize
argument_list|(
name|targetUniform
operator|->
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|bufSize
operator|<
name|requiredBytes
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
switch|switch
condition|(
name|targetUniform
operator|->
name|type
condition|)
block|{
case|case
name|GL_FLOAT_MAT2
case|:
name|transposeMatrix
argument_list|<
name|GLint
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|4
argument_list|,
literal|2
argument_list|>
argument_list|(
name|params
argument_list|,
operator|(
name|GLfloat
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_FLOAT_MAT3
case|:
name|transposeMatrix
argument_list|<
name|GLint
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|3
argument_list|>
argument_list|(
name|params
argument_list|,
operator|(
name|GLfloat
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|12
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_FLOAT_MAT4
case|:
name|transposeMatrix
argument_list|<
name|GLint
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|>
argument_list|(
name|params
argument_list|,
operator|(
name|GLfloat
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|16
argument_list|)
expr_stmt|;
break|break;
default|default:
block|{
name|unsigned
name|int
name|size
init|=
name|VariableColumnCount
argument_list|(
name|targetUniform
operator|->
name|type
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|UniformComponentType
argument_list|(
name|targetUniform
operator|->
name|type
argument_list|)
condition|)
block|{
case|case
name|GL_BOOL
case|:
block|{
name|GLint
modifier|*
name|boolParams
init|=
operator|(
name|GLint
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|params
index|[
name|i
index|]
operator|=
name|boolParams
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GL_FLOAT
case|:
block|{
name|GLfloat
modifier|*
name|floatParams
init|=
operator|(
name|GLfloat
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|params
index|[
name|i
index|]
operator|=
operator|(
name|GLint
operator|)
name|floatParams
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GL_INT
case|:
name|memcpy
argument_list|(
name|params
argument_list|,
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|GLint
argument_list|)
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|GLint
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|dirtyAllUniforms
name|void
name|ProgramBinary
operator|::
name|dirtyAllUniforms
parameter_list|()
block|{
name|unsigned
name|int
name|numUniforms
init|=
name|mUniforms
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
name|numUniforms
condition|;
name|index
operator|++
control|)
block|{
name|mUniforms
index|[
name|index
index|]
operator|->
name|dirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// Applies all the uniforms set for this program object to the renderer
DECL|function|applyUniforms
name|void
name|ProgramBinary
operator|::
name|applyUniforms
parameter_list|()
block|{
comment|// Retrieve sampler uniform values
for|for
control|(
name|std
operator|::
name|vector
argument_list|<
name|Uniform
operator|*
argument_list|>
operator|::
name|iterator
name|ub
init|=
name|mUniforms
operator|.
name|begin
argument_list|()
init|,
name|ue
init|=
name|mUniforms
operator|.
name|end
argument_list|()
init|;
name|ub
operator|!=
name|ue
condition|;
operator|++
name|ub
control|)
block|{
name|Uniform
modifier|*
name|targetUniform
init|=
operator|*
name|ub
decl_stmt|;
if|if
condition|(
name|targetUniform
operator|->
name|dirty
condition|)
block|{
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|GL_SAMPLER_2D
operator|||
name|targetUniform
operator|->
name|type
operator|==
name|GL_SAMPLER_CUBE
condition|)
block|{
name|int
name|count
init|=
name|targetUniform
operator|->
name|elementCount
argument_list|()
decl_stmt|;
name|GLint
argument_list|(
operator|*
name|v
argument_list|)
index|[
literal|4
index|]
operator|=
operator|(
name|GLint
argument_list|(
operator|*
argument_list|)
index|[
literal|4
index|]
operator|)
name|targetUniform
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|targetUniform
operator|->
name|psRegisterIndex
operator|>=
literal|0
condition|)
block|{
name|unsigned
name|int
name|firstIndex
init|=
name|targetUniform
operator|->
name|psRegisterIndex
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|samplerIndex
init|=
name|firstIndex
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|samplerIndex
operator|<
name|MAX_TEXTURE_IMAGE_UNITS
condition|)
block|{
name|ASSERT
argument_list|(
name|mSamplersPS
index|[
name|samplerIndex
index|]
operator|.
name|active
argument_list|)
expr_stmt|;
name|mSamplersPS
index|[
name|samplerIndex
index|]
operator|.
name|logicalTextureUnit
operator|=
name|v
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|targetUniform
operator|->
name|vsRegisterIndex
operator|>=
literal|0
condition|)
block|{
name|unsigned
name|int
name|firstIndex
init|=
name|targetUniform
operator|->
name|vsRegisterIndex
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|samplerIndex
init|=
name|firstIndex
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|samplerIndex
operator|<
name|IMPLEMENTATION_MAX_VERTEX_TEXTURE_IMAGE_UNITS
condition|)
block|{
name|ASSERT
argument_list|(
name|mSamplersVS
index|[
name|samplerIndex
index|]
operator|.
name|active
argument_list|)
expr_stmt|;
name|mSamplersVS
index|[
name|samplerIndex
index|]
operator|.
name|logicalTextureUnit
operator|=
name|v
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
name|mRenderer
operator|->
name|applyUniforms
argument_list|(
name|this
argument_list|,
operator|&
name|mUniforms
argument_list|)
expr_stmt|;
block|}
comment|// Packs varyings into generic varying registers, using the algorithm from [OpenGL ES Shading Language 1.00 rev. 17] appendix A section 7 page 111
comment|// Returns the number of used varying registers, or -1 if unsuccesful
DECL|function|packVaryings
name|int
name|ProgramBinary
operator|::
name|packVaryings
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|Varying
modifier|*
name|packing
index|[]
index|[
literal|4
index|]
parameter_list|,
name|FragmentShader
modifier|*
name|fragmentShader
parameter_list|)
block|{
specifier|const
name|int
name|maxVaryingVectors
init|=
name|mRenderer
operator|->
name|getMaxVaryingVectors
argument_list|()
decl_stmt|;
name|fragmentShader
operator|->
name|resetVaryingsRegisterAssignment
argument_list|()
expr_stmt|;
for|for
control|(
name|VaryingList
operator|::
name|iterator
name|varying
init|=
name|fragmentShader
operator|->
name|mVaryings
operator|.
name|begin
argument_list|()
init|;
name|varying
operator|!=
name|fragmentShader
operator|->
name|mVaryings
operator|.
name|end
argument_list|()
condition|;
name|varying
operator|++
control|)
block|{
name|int
name|n
init|=
name|VariableRowCount
argument_list|(
name|varying
operator|->
name|type
argument_list|)
operator|*
name|varying
operator|->
name|size
decl_stmt|;
name|int
name|m
init|=
name|VariableColumnCount
argument_list|(
name|varying
operator|->
name|type
argument_list|)
decl_stmt|;
name|bool
name|success
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|m
operator|==
literal|2
operator|||
name|m
operator|==
literal|3
operator|||
name|m
operator|==
literal|4
condition|)
block|{
for|for
control|(
name|int
name|r
init|=
literal|0
init|;
name|r
operator|<=
name|maxVaryingVectors
operator|-
name|n
operator|&&
operator|!
name|success
condition|;
name|r
operator|++
control|)
block|{
name|bool
name|available
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|n
operator|&&
name|available
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|m
operator|&&
name|available
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|packing
index|[
name|r
operator|+
name|y
index|]
index|[
name|x
index|]
condition|)
block|{
name|available
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|available
condition|)
block|{
name|varying
operator|->
name|reg
operator|=
name|r
expr_stmt|;
name|varying
operator|->
name|col
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|n
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|m
condition|;
name|x
operator|++
control|)
block|{
name|packing
index|[
name|r
operator|+
name|y
index|]
index|[
name|x
index|]
operator|=
operator|&
operator|*
name|varying
expr_stmt|;
block|}
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|success
operator|&&
name|m
operator|==
literal|2
condition|)
block|{
for|for
control|(
name|int
name|r
init|=
name|maxVaryingVectors
operator|-
name|n
init|;
name|r
operator|>=
literal|0
operator|&&
operator|!
name|success
condition|;
name|r
operator|--
control|)
block|{
name|bool
name|available
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|n
operator|&&
name|available
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|2
init|;
name|x
operator|<
literal|4
operator|&&
name|available
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|packing
index|[
name|r
operator|+
name|y
index|]
index|[
name|x
index|]
condition|)
block|{
name|available
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|available
condition|)
block|{
name|varying
operator|->
name|reg
operator|=
name|r
expr_stmt|;
name|varying
operator|->
name|col
operator|=
literal|2
expr_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|n
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|2
init|;
name|x
operator|<
literal|4
condition|;
name|x
operator|++
control|)
block|{
name|packing
index|[
name|r
operator|+
name|y
index|]
index|[
name|x
index|]
operator|=
operator|&
operator|*
name|varying
expr_stmt|;
block|}
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|m
operator|==
literal|1
condition|)
block|{
name|int
name|space
index|[
literal|4
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|maxVaryingVectors
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
literal|4
condition|;
name|x
operator|++
control|)
block|{
name|space
index|[
name|x
index|]
operator|+=
name|packing
index|[
name|y
index|]
index|[
name|x
index|]
condition|?
literal|0
else|:
literal|1
expr_stmt|;
block|}
block|}
name|int
name|column
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
literal|4
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|space
index|[
name|x
index|]
operator|>=
name|n
operator|&&
name|space
index|[
name|x
index|]
operator|<
name|space
index|[
name|column
index|]
condition|)
block|{
name|column
operator|=
name|x
expr_stmt|;
block|}
block|}
if|if
condition|(
name|space
index|[
name|column
index|]
operator|>=
name|n
condition|)
block|{
for|for
control|(
name|int
name|r
init|=
literal|0
init|;
name|r
operator|<
name|maxVaryingVectors
condition|;
name|r
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|packing
index|[
name|r
index|]
index|[
name|column
index|]
condition|)
block|{
name|varying
operator|->
name|reg
operator|=
name|r
expr_stmt|;
for|for
control|(
name|int
name|y
init|=
name|r
init|;
name|y
operator|<
name|r
operator|+
name|n
condition|;
name|y
operator|++
control|)
block|{
name|packing
index|[
name|y
index|]
index|[
name|column
index|]
operator|=
operator|&
operator|*
name|varying
expr_stmt|;
block|}
break|break;
block|}
block|}
name|varying
operator|->
name|col
operator|=
name|column
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Could not pack varying %s"
argument_list|,
name|varying
operator|->
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|// Return the number of used registers
name|int
name|registers
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|r
init|=
literal|0
init|;
name|r
operator|<
name|maxVaryingVectors
condition|;
name|r
operator|++
control|)
block|{
if|if
condition|(
name|packing
index|[
name|r
index|]
index|[
literal|0
index|]
operator|||
name|packing
index|[
name|r
index|]
index|[
literal|1
index|]
operator|||
name|packing
index|[
name|r
index|]
index|[
literal|2
index|]
operator|||
name|packing
index|[
name|r
index|]
index|[
literal|3
index|]
condition|)
block|{
name|registers
operator|++
expr_stmt|;
block|}
block|}
return|return
name|registers
return|;
block|}
DECL|function|linkVaryings
name|bool
name|ProgramBinary
operator|::
name|linkVaryings
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
name|int
name|registers
parameter_list|,
specifier|const
name|Varying
modifier|*
name|packing
index|[]
index|[
literal|4
index|]
parameter_list|,
name|std
operator|::
name|string
modifier|&
name|pixelHLSL
parameter_list|,
name|std
operator|::
name|string
modifier|&
name|vertexHLSL
parameter_list|,
name|FragmentShader
modifier|*
name|fragmentShader
parameter_list|,
name|VertexShader
modifier|*
name|vertexShader
parameter_list|)
block|{
if|if
condition|(
name|pixelHLSL
operator|.
name|empty
argument_list|()
operator|||
name|vertexHLSL
operator|.
name|empty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|bool
name|usesMRT
init|=
name|fragmentShader
operator|->
name|mUsesMultipleRenderTargets
decl_stmt|;
name|bool
name|usesFragColor
init|=
name|fragmentShader
operator|->
name|mUsesFragColor
decl_stmt|;
name|bool
name|usesFragData
init|=
name|fragmentShader
operator|->
name|mUsesFragData
decl_stmt|;
if|if
condition|(
name|usesMRT
operator|&&
name|usesFragColor
operator|&&
name|usesFragData
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Cannot use both gl_FragColor and gl_FragData in the same fragment shader."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Write the HLSL input/output declarations
specifier|const
name|int
name|shaderModel
init|=
name|mRenderer
operator|->
name|getMajorShaderModel
argument_list|()
decl_stmt|;
specifier|const
name|int
name|maxVaryingVectors
init|=
name|mRenderer
operator|->
name|getMaxVaryingVectors
argument_list|()
decl_stmt|;
specifier|const
name|int
name|registersNeeded
init|=
name|registers
operator|+
operator|(
name|fragmentShader
operator|->
name|mUsesFragCoord
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
name|fragmentShader
operator|->
name|mUsesPointCoord
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|registersNeeded
operator|>
name|maxVaryingVectors
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"No varying registers left to support gl_FragCoord/gl_PointCoord"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|vertexShader
operator|->
name|resetVaryingsRegisterAssignment
argument_list|()
expr_stmt|;
for|for
control|(
name|VaryingList
operator|::
name|iterator
name|input
init|=
name|fragmentShader
operator|->
name|mVaryings
operator|.
name|begin
argument_list|()
init|;
name|input
operator|!=
name|fragmentShader
operator|->
name|mVaryings
operator|.
name|end
argument_list|()
condition|;
name|input
operator|++
control|)
block|{
name|bool
name|matched
init|=
literal|false
decl_stmt|;
for|for
control|(
name|VaryingList
operator|::
name|iterator
name|output
init|=
name|vertexShader
operator|->
name|mVaryings
operator|.
name|begin
argument_list|()
init|;
name|output
operator|!=
name|vertexShader
operator|->
name|mVaryings
operator|.
name|end
argument_list|()
condition|;
name|output
operator|++
control|)
block|{
if|if
condition|(
name|output
operator|->
name|name
operator|==
name|input
operator|->
name|name
condition|)
block|{
if|if
condition|(
name|output
operator|->
name|type
operator|!=
name|input
operator|->
name|type
operator|||
name|output
operator|->
name|size
operator|!=
name|input
operator|->
name|size
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Type of vertex varying %s does not match that of the fragment varying"
argument_list|,
name|output
operator|->
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|output
operator|->
name|reg
operator|=
name|input
operator|->
name|reg
expr_stmt|;
name|output
operator|->
name|col
operator|=
name|input
operator|->
name|col
expr_stmt|;
name|matched
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|matched
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Fragment varying %s does not match any vertex varying"
argument_list|,
name|input
operator|->
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|mUsesPointSize
operator|=
name|vertexShader
operator|->
name|mUsesPointSize
expr_stmt|;
name|std
operator|::
name|string
name|varyingSemantic
init|=
operator|(
name|mUsesPointSize
operator|&&
name|shaderModel
operator|==
literal|3
operator|)
condition|?
literal|"COLOR"
else|:
literal|"TEXCOORD"
decl_stmt|;
name|std
operator|::
name|string
name|targetSemantic
init|=
operator|(
name|shaderModel
operator|>=
literal|4
operator|)
condition|?
literal|"SV_Target"
else|:
literal|"COLOR"
decl_stmt|;
name|std
operator|::
name|string
name|positionSemantic
init|=
operator|(
name|shaderModel
operator|>=
literal|4
operator|)
condition|?
literal|"SV_Position"
else|:
literal|"POSITION"
decl_stmt|;
specifier|const
name|unsigned
name|int
name|renderTargetCount
init|=
name|usesMRT
condition|?
name|mRenderer
operator|->
name|getMaxRenderTargets
argument_list|()
else|:
literal|1
decl_stmt|;
comment|// special varyings that use reserved registers
name|int
name|reservedRegisterIndex
init|=
name|registers
decl_stmt|;
name|std
operator|::
name|string
name|fragCoordSemantic
decl_stmt|;
name|std
operator|::
name|string
name|pointCoordSemantic
decl_stmt|;
if|if
condition|(
name|fragmentShader
operator|->
name|mUsesFragCoord
condition|)
block|{
name|fragCoordSemantic
operator|=
name|varyingSemantic
operator|+
name|str
argument_list|(
name|reservedRegisterIndex
operator|++
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fragmentShader
operator|->
name|mUsesPointCoord
condition|)
block|{
comment|// Shader model 3 uses a special TEXCOORD semantic for point sprite texcoords.
comment|// In DX11 we compute this in the GS.
if|if
condition|(
name|shaderModel
operator|==
literal|3
condition|)
block|{
name|pointCoordSemantic
operator|=
literal|"TEXCOORD0"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shaderModel
operator|>=
literal|4
condition|)
block|{
name|pointCoordSemantic
operator|=
name|varyingSemantic
operator|+
name|str
argument_list|(
name|reservedRegisterIndex
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
name|vertexHLSL
operator|+=
literal|"struct VS_INPUT\n"
literal|"{\n"
expr_stmt|;
name|int
name|semanticIndex
init|=
literal|0
decl_stmt|;
for|for
control|(
name|AttributeArray
operator|::
name|iterator
name|attribute
init|=
name|vertexShader
operator|->
name|mAttributes
operator|.
name|begin
argument_list|()
init|;
name|attribute
operator|!=
name|vertexShader
operator|->
name|mAttributes
operator|.
name|end
argument_list|()
condition|;
name|attribute
operator|++
control|)
block|{
switch|switch
condition|(
name|attribute
operator|->
name|type
condition|)
block|{
case|case
name|GL_FLOAT
case|:
name|vertexHLSL
operator|+=
literal|"    float "
expr_stmt|;
break|break;
case|case
name|GL_FLOAT_VEC2
case|:
name|vertexHLSL
operator|+=
literal|"    float2 "
expr_stmt|;
break|break;
case|case
name|GL_FLOAT_VEC3
case|:
name|vertexHLSL
operator|+=
literal|"    float3 "
expr_stmt|;
break|break;
case|case
name|GL_FLOAT_VEC4
case|:
name|vertexHLSL
operator|+=
literal|"    float4 "
expr_stmt|;
break|break;
case|case
name|GL_FLOAT_MAT2
case|:
name|vertexHLSL
operator|+=
literal|"    float2x2 "
expr_stmt|;
break|break;
case|case
name|GL_FLOAT_MAT3
case|:
name|vertexHLSL
operator|+=
literal|"    float3x3 "
expr_stmt|;
break|break;
case|case
name|GL_FLOAT_MAT4
case|:
name|vertexHLSL
operator|+=
literal|"    float4x4 "
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
name|vertexHLSL
operator|+=
name|decorateAttribute
argument_list|(
name|attribute
operator|->
name|name
argument_list|)
operator|+
literal|" : TEXCOORD"
operator|+
name|str
argument_list|(
name|semanticIndex
argument_list|)
operator|+
literal|";\n"
expr_stmt|;
name|semanticIndex
operator|+=
name|VariableRowCount
argument_list|(
name|attribute
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
name|vertexHLSL
operator|+=
literal|"};\n"
literal|"\n"
literal|"struct VS_OUTPUT\n"
literal|"{\n"
expr_stmt|;
if|if
condition|(
name|shaderModel
operator|<
literal|4
condition|)
block|{
name|vertexHLSL
operator|+=
literal|"    float4 gl_Position : "
operator|+
name|positionSemantic
operator|+
literal|";\n"
expr_stmt|;
block|}
for|for
control|(
name|int
name|r
init|=
literal|0
init|;
name|r
operator|<
name|registers
condition|;
name|r
operator|++
control|)
block|{
name|int
name|registerSize
init|=
name|packing
index|[
name|r
index|]
index|[
literal|3
index|]
condition|?
literal|4
else|:
operator|(
name|packing
index|[
name|r
index|]
index|[
literal|2
index|]
condition|?
literal|3
else|:
operator|(
name|packing
index|[
name|r
index|]
index|[
literal|1
index|]
condition|?
literal|2
else|:
literal|1
operator|)
operator|)
decl_stmt|;
name|vertexHLSL
operator|+=
literal|"    float"
operator|+
name|str
argument_list|(
name|registerSize
argument_list|)
operator|+
literal|" v"
operator|+
name|str
argument_list|(
name|r
argument_list|)
operator|+
literal|" : "
operator|+
name|varyingSemantic
operator|+
name|str
argument_list|(
name|r
argument_list|)
operator|+
literal|";\n"
expr_stmt|;
block|}
if|if
condition|(
name|fragmentShader
operator|->
name|mUsesFragCoord
condition|)
block|{
name|vertexHLSL
operator|+=
literal|"    float4 gl_FragCoord : "
operator|+
name|fragCoordSemantic
operator|+
literal|";\n"
expr_stmt|;
block|}
if|if
condition|(
name|vertexShader
operator|->
name|mUsesPointSize
operator|&&
name|shaderModel
operator|>=
literal|3
condition|)
block|{
name|vertexHLSL
operator|+=
literal|"    float gl_PointSize : PSIZE;\n"
expr_stmt|;
block|}
if|if
condition|(
name|shaderModel
operator|>=
literal|4
condition|)
block|{
name|vertexHLSL
operator|+=
literal|"    float4 gl_Position : "
operator|+
name|positionSemantic
operator|+
literal|";\n"
expr_stmt|;
block|}
name|vertexHLSL
operator|+=
literal|"};\n"
literal|"\n"
literal|"VS_OUTPUT main(VS_INPUT input)\n"
literal|"{\n"
expr_stmt|;
for|for
control|(
name|AttributeArray
operator|::
name|iterator
name|attribute
init|=
name|vertexShader
operator|->
name|mAttributes
operator|.
name|begin
argument_list|()
init|;
name|attribute
operator|!=
name|vertexShader
operator|->
name|mAttributes
operator|.
name|end
argument_list|()
condition|;
name|attribute
operator|++
control|)
block|{
name|vertexHLSL
operator|+=
literal|"    "
operator|+
name|decorateAttribute
argument_list|(
name|attribute
operator|->
name|name
argument_list|)
operator|+
literal|" = "
expr_stmt|;
if|if
condition|(
name|VariableRowCount
argument_list|(
name|attribute
operator|->
name|type
argument_list|)
operator|>
literal|1
condition|)
comment|// Matrix
block|{
name|vertexHLSL
operator|+=
literal|"transpose"
expr_stmt|;
block|}
name|vertexHLSL
operator|+=
literal|"(input."
operator|+
name|decorateAttribute
argument_list|(
name|attribute
operator|->
name|name
argument_list|)
operator|+
literal|");\n"
expr_stmt|;
block|}
if|if
condition|(
name|shaderModel
operator|>=
literal|4
condition|)
block|{
name|vertexHLSL
operator|+=
literal|"\n"
literal|"    gl_main();\n"
literal|"\n"
literal|"    VS_OUTPUT output;\n"
literal|"    output.gl_Position.x = gl_Position.x;\n"
literal|"    output.gl_Position.y = -gl_Position.y;\n"
literal|"    output.gl_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\n"
literal|"    output.gl_Position.w = gl_Position.w;\n"
expr_stmt|;
block|}
else|else
block|{
name|vertexHLSL
operator|+=
literal|"\n"
literal|"    gl_main();\n"
literal|"\n"
literal|"    VS_OUTPUT output;\n"
literal|"    output.gl_Position.x = gl_Position.x * dx_ViewAdjust.z + dx_ViewAdjust.x * gl_Position.w;\n"
literal|"    output.gl_Position.y = -(gl_Position.y * dx_ViewAdjust.w + dx_ViewAdjust.y * gl_Position.w);\n"
literal|"    output.gl_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\n"
literal|"    output.gl_Position.w = gl_Position.w;\n"
expr_stmt|;
block|}
if|if
condition|(
name|vertexShader
operator|->
name|mUsesPointSize
operator|&&
name|shaderModel
operator|>=
literal|3
condition|)
block|{
name|vertexHLSL
operator|+=
literal|"    output.gl_PointSize = gl_PointSize;\n"
expr_stmt|;
block|}
if|if
condition|(
name|fragmentShader
operator|->
name|mUsesFragCoord
condition|)
block|{
name|vertexHLSL
operator|+=
literal|"    output.gl_FragCoord = gl_Position;\n"
expr_stmt|;
block|}
for|for
control|(
name|VaryingList
operator|::
name|iterator
name|varying
init|=
name|vertexShader
operator|->
name|mVaryings
operator|.
name|begin
argument_list|()
init|;
name|varying
operator|!=
name|vertexShader
operator|->
name|mVaryings
operator|.
name|end
argument_list|()
condition|;
name|varying
operator|++
control|)
block|{
if|if
condition|(
name|varying
operator|->
name|reg
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|varying
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|int
name|rows
init|=
name|VariableRowCount
argument_list|(
name|varying
operator|->
name|type
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|rows
condition|;
name|j
operator|++
control|)
block|{
name|int
name|r
init|=
name|varying
operator|->
name|reg
operator|+
name|i
operator|*
name|rows
operator|+
name|j
decl_stmt|;
name|vertexHLSL
operator|+=
literal|"    output.v"
operator|+
name|str
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|bool
name|sharedRegister
init|=
literal|false
decl_stmt|;
comment|// Register used by multiple varyings
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
literal|4
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|packing
index|[
name|r
index|]
index|[
name|x
index|]
operator|&&
name|packing
index|[
name|r
index|]
index|[
name|x
index|]
operator|!=
name|packing
index|[
name|r
index|]
index|[
literal|0
index|]
condition|)
block|{
name|sharedRegister
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|sharedRegister
condition|)
block|{
name|vertexHLSL
operator|+=
literal|"."
expr_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
literal|4
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|packing
index|[
name|r
index|]
index|[
name|x
index|]
operator|==
operator|&
operator|*
name|varying
condition|)
block|{
switch|switch
condition|(
name|x
condition|)
block|{
case|case
literal|0
case|:
name|vertexHLSL
operator|+=
literal|"x"
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|vertexHLSL
operator|+=
literal|"y"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|vertexHLSL
operator|+=
literal|"z"
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|vertexHLSL
operator|+=
literal|"w"
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
name|vertexHLSL
operator|+=
literal|" = "
operator|+
name|varying
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|varying
operator|->
name|array
condition|)
block|{
name|vertexHLSL
operator|+=
literal|"["
operator|+
name|str
argument_list|(
name|i
argument_list|)
operator|+
literal|"]"
expr_stmt|;
block|}
if|if
condition|(
name|rows
operator|>
literal|1
condition|)
block|{
name|vertexHLSL
operator|+=
literal|"["
operator|+
name|str
argument_list|(
name|j
argument_list|)
operator|+
literal|"]"
expr_stmt|;
block|}
name|vertexHLSL
operator|+=
literal|";\n"
expr_stmt|;
block|}
block|}
block|}
block|}
name|vertexHLSL
operator|+=
literal|"\n"
literal|"    return output;\n"
literal|"}\n"
expr_stmt|;
name|pixelHLSL
operator|+=
literal|"struct PS_INPUT\n"
literal|"{\n"
expr_stmt|;
for|for
control|(
name|VaryingList
operator|::
name|iterator
name|varying
init|=
name|fragmentShader
operator|->
name|mVaryings
operator|.
name|begin
argument_list|()
init|;
name|varying
operator|!=
name|fragmentShader
operator|->
name|mVaryings
operator|.
name|end
argument_list|()
condition|;
name|varying
operator|++
control|)
block|{
if|if
condition|(
name|varying
operator|->
name|reg
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|varying
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|int
name|rows
init|=
name|VariableRowCount
argument_list|(
name|varying
operator|->
name|type
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|rows
condition|;
name|j
operator|++
control|)
block|{
name|std
operator|::
name|string
name|n
init|=
name|str
argument_list|(
name|varying
operator|->
name|reg
operator|+
name|i
operator|*
name|rows
operator|+
name|j
argument_list|)
decl_stmt|;
name|pixelHLSL
operator|+=
literal|"    float"
operator|+
name|str
argument_list|(
name|VariableColumnCount
argument_list|(
name|varying
operator|->
name|type
argument_list|)
argument_list|)
operator|+
literal|" v"
operator|+
name|n
operator|+
literal|" : "
operator|+
name|varyingSemantic
operator|+
name|n
operator|+
literal|";\n"
expr_stmt|;
block|}
block|}
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fragmentShader
operator|->
name|mUsesFragCoord
condition|)
block|{
name|pixelHLSL
operator|+=
literal|"    float4 gl_FragCoord : "
operator|+
name|fragCoordSemantic
operator|+
literal|";\n"
expr_stmt|;
block|}
if|if
condition|(
name|fragmentShader
operator|->
name|mUsesPointCoord
operator|&&
name|shaderModel
operator|>=
literal|3
condition|)
block|{
name|pixelHLSL
operator|+=
literal|"    float2 gl_PointCoord : "
operator|+
name|pointCoordSemantic
operator|+
literal|";\n"
expr_stmt|;
block|}
comment|// Must consume the PSIZE element if the geometry shader is not active
comment|// We won't know if we use a GS until we draw
if|if
condition|(
name|vertexShader
operator|->
name|mUsesPointSize
operator|&&
name|shaderModel
operator|>=
literal|4
condition|)
block|{
name|pixelHLSL
operator|+=
literal|"    float gl_PointSize : PSIZE;\n"
expr_stmt|;
block|}
if|if
condition|(
name|fragmentShader
operator|->
name|mUsesFragCoord
condition|)
block|{
if|if
condition|(
name|shaderModel
operator|>=
literal|4
condition|)
block|{
name|pixelHLSL
operator|+=
literal|"    float4 dx_VPos : SV_Position;\n"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shaderModel
operator|>=
literal|3
condition|)
block|{
name|pixelHLSL
operator|+=
literal|"    float2 dx_VPos : VPOS;\n"
expr_stmt|;
block|}
block|}
name|pixelHLSL
operator|+=
literal|"};\n"
literal|"\n"
literal|"struct PS_OUTPUT\n"
literal|"{\n"
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|renderTargetCount
condition|;
name|i
operator|++
control|)
block|{
name|pixelHLSL
operator|+=
literal|"    float4 gl_Color"
operator|+
name|str
argument_list|(
name|i
argument_list|)
operator|+
literal|" : "
operator|+
name|targetSemantic
operator|+
name|str
argument_list|(
name|i
argument_list|)
operator|+
literal|";\n"
expr_stmt|;
block|}
name|pixelHLSL
operator|+=
literal|"};\n"
literal|"\n"
expr_stmt|;
if|if
condition|(
name|fragmentShader
operator|->
name|mUsesFrontFacing
condition|)
block|{
if|if
condition|(
name|shaderModel
operator|>=
literal|4
condition|)
block|{
name|pixelHLSL
operator|+=
literal|"PS_OUTPUT main(PS_INPUT input, bool isFrontFace : SV_IsFrontFace)\n"
literal|"{\n"
expr_stmt|;
block|}
else|else
block|{
name|pixelHLSL
operator|+=
literal|"PS_OUTPUT main(PS_INPUT input, float vFace : VFACE)\n"
literal|"{\n"
expr_stmt|;
block|}
block|}
else|else
block|{
name|pixelHLSL
operator|+=
literal|"PS_OUTPUT main(PS_INPUT input)\n"
literal|"{\n"
expr_stmt|;
block|}
if|if
condition|(
name|fragmentShader
operator|->
name|mUsesFragCoord
condition|)
block|{
name|pixelHLSL
operator|+=
literal|"    float rhw = 1.0 / input.gl_FragCoord.w;\n"
expr_stmt|;
if|if
condition|(
name|shaderModel
operator|>=
literal|4
condition|)
block|{
name|pixelHLSL
operator|+=
literal|"    gl_FragCoord.x = input.dx_VPos.x;\n"
literal|"    gl_FragCoord.y = input.dx_VPos.y;\n"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shaderModel
operator|>=
literal|3
condition|)
block|{
name|pixelHLSL
operator|+=
literal|"    gl_FragCoord.x = input.dx_VPos.x + 0.5;\n"
literal|"    gl_FragCoord.y = input.dx_VPos.y + 0.5;\n"
expr_stmt|;
block|}
else|else
block|{
comment|// dx_ViewCoords contains the viewport width/2, height/2, center.x and center.y. See Renderer::setViewport()
name|pixelHLSL
operator|+=
literal|"    gl_FragCoord.x = (input.gl_FragCoord.x * rhw) * dx_ViewCoords.x + dx_ViewCoords.z;\n"
literal|"    gl_FragCoord.y = (input.gl_FragCoord.y * rhw) * dx_ViewCoords.y + dx_ViewCoords.w;\n"
expr_stmt|;
block|}
name|pixelHLSL
operator|+=
literal|"    gl_FragCoord.z = (input.gl_FragCoord.z * rhw) * dx_DepthFront.x + dx_DepthFront.y;\n"
literal|"    gl_FragCoord.w = rhw;\n"
expr_stmt|;
block|}
if|if
condition|(
name|fragmentShader
operator|->
name|mUsesPointCoord
operator|&&
name|shaderModel
operator|>=
literal|3
condition|)
block|{
name|pixelHLSL
operator|+=
literal|"    gl_PointCoord.x = input.gl_PointCoord.x;\n"
expr_stmt|;
name|pixelHLSL
operator|+=
literal|"    gl_PointCoord.y = 1.0 - input.gl_PointCoord.y;\n"
expr_stmt|;
block|}
if|if
condition|(
name|fragmentShader
operator|->
name|mUsesFrontFacing
condition|)
block|{
if|if
condition|(
name|shaderModel
operator|<=
literal|3
condition|)
block|{
name|pixelHLSL
operator|+=
literal|"    gl_FrontFacing = (vFace * dx_DepthFront.z>= 0.0);\n"
expr_stmt|;
block|}
else|else
block|{
name|pixelHLSL
operator|+=
literal|"    gl_FrontFacing = isFrontFace;\n"
expr_stmt|;
block|}
block|}
for|for
control|(
name|VaryingList
operator|::
name|iterator
name|varying
init|=
name|fragmentShader
operator|->
name|mVaryings
operator|.
name|begin
argument_list|()
init|;
name|varying
operator|!=
name|fragmentShader
operator|->
name|mVaryings
operator|.
name|end
argument_list|()
condition|;
name|varying
operator|++
control|)
block|{
if|if
condition|(
name|varying
operator|->
name|reg
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|varying
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|int
name|rows
init|=
name|VariableRowCount
argument_list|(
name|varying
operator|->
name|type
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|rows
condition|;
name|j
operator|++
control|)
block|{
name|std
operator|::
name|string
name|n
init|=
name|str
argument_list|(
name|varying
operator|->
name|reg
operator|+
name|i
operator|*
name|rows
operator|+
name|j
argument_list|)
decl_stmt|;
name|pixelHLSL
operator|+=
literal|"    "
operator|+
name|varying
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|varying
operator|->
name|array
condition|)
block|{
name|pixelHLSL
operator|+=
literal|"["
operator|+
name|str
argument_list|(
name|i
argument_list|)
operator|+
literal|"]"
expr_stmt|;
block|}
if|if
condition|(
name|rows
operator|>
literal|1
condition|)
block|{
name|pixelHLSL
operator|+=
literal|"["
operator|+
name|str
argument_list|(
name|j
argument_list|)
operator|+
literal|"]"
expr_stmt|;
block|}
switch|switch
condition|(
name|VariableColumnCount
argument_list|(
name|varying
operator|->
name|type
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|pixelHLSL
operator|+=
literal|" = input.v"
operator|+
name|n
operator|+
literal|".x;\n"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|pixelHLSL
operator|+=
literal|" = input.v"
operator|+
name|n
operator|+
literal|".xy;\n"
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|pixelHLSL
operator|+=
literal|" = input.v"
operator|+
name|n
operator|+
literal|".xyz;\n"
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|pixelHLSL
operator|+=
literal|" = input.v"
operator|+
name|n
operator|+
literal|";\n"
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
name|pixelHLSL
operator|+=
literal|"\n"
literal|"    gl_main();\n"
literal|"\n"
literal|"    PS_OUTPUT output;\n"
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|renderTargetCount
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|sourceColor
init|=
name|fragmentShader
operator|->
name|mUsesFragData
condition|?
name|i
else|:
literal|0
decl_stmt|;
name|pixelHLSL
operator|+=
literal|"    output.gl_Color"
operator|+
name|str
argument_list|(
name|i
argument_list|)
operator|+
literal|" = gl_Color["
operator|+
name|str
argument_list|(
name|sourceColor
argument_list|)
operator|+
literal|"];\n"
expr_stmt|;
block|}
name|pixelHLSL
operator|+=
literal|"\n"
literal|"    return output;\n"
literal|"}\n"
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|load
name|bool
name|ProgramBinary
operator|::
name|load
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|void
modifier|*
name|binary
parameter_list|,
name|GLsizei
name|length
parameter_list|)
block|{
name|BinaryInputStream
name|stream
argument_list|(
name|binary
argument_list|,
name|length
argument_list|)
decl_stmt|;
name|int
name|format
init|=
literal|0
decl_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
operator|!=
name|GL_PROGRAM_BINARY_ANGLE
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Invalid program binary format."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|int
name|version
init|=
literal|0
decl_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|!=
name|VERSION_DWORD
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Invalid program binary version."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
operator|++
name|i
control|)
block|{
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mLinkedAttribute
index|[
name|i
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|std
operator|::
name|string
name|name
decl_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|name
argument_list|)
expr_stmt|;
name|mLinkedAttribute
index|[
name|i
index|]
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mSemanticIndex
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_TEXTURE_IMAGE_UNITS
condition|;
operator|++
name|i
control|)
block|{
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|active
argument_list|)
expr_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|logicalTextureUnit
argument_list|)
expr_stmt|;
name|int
name|textureType
decl_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|textureType
argument_list|)
expr_stmt|;
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|textureType
operator|=
operator|(
name|TextureType
operator|)
name|textureType
expr_stmt|;
block|}
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|IMPLEMENTATION_MAX_VERTEX_TEXTURE_IMAGE_UNITS
condition|;
operator|++
name|i
control|)
block|{
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|active
argument_list|)
expr_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|logicalTextureUnit
argument_list|)
expr_stmt|;
name|int
name|textureType
decl_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|textureType
argument_list|)
expr_stmt|;
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|textureType
operator|=
operator|(
name|TextureType
operator|)
name|textureType
expr_stmt|;
block|}
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mUsedVertexSamplerRange
argument_list|)
expr_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mUsedPixelSamplerRange
argument_list|)
expr_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mUsesPointSize
argument_list|)
expr_stmt|;
name|size_t
name|size
decl_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
operator|.
name|error
argument_list|()
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Invalid program binary."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|mUniforms
operator|.
name|resize
argument_list|(
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
name|GLenum
name|type
decl_stmt|;
name|GLenum
name|precision
decl_stmt|;
name|std
operator|::
name|string
name|name
decl_stmt|;
name|unsigned
name|int
name|arraySize
decl_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|type
argument_list|)
expr_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|precision
argument_list|)
expr_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|name
argument_list|)
expr_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|arraySize
argument_list|)
expr_stmt|;
name|mUniforms
index|[
name|i
index|]
operator|=
operator|new
name|Uniform
argument_list|(
name|type
argument_list|,
name|precision
argument_list|,
name|name
argument_list|,
name|arraySize
argument_list|)
expr_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mUniforms
index|[
name|i
index|]
operator|->
name|psRegisterIndex
argument_list|)
expr_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mUniforms
index|[
name|i
index|]
operator|->
name|vsRegisterIndex
argument_list|)
expr_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mUniforms
index|[
name|i
index|]
operator|->
name|registerCount
argument_list|)
expr_stmt|;
block|}
name|stream
operator|.
name|read
argument_list|(
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
operator|.
name|error
argument_list|()
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Invalid program binary."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|mUniformIndex
operator|.
name|resize
argument_list|(
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mUniformIndex
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mUniformIndex
index|[
name|i
index|]
operator|.
name|element
argument_list|)
expr_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mUniformIndex
index|[
name|i
index|]
operator|.
name|index
argument_list|)
expr_stmt|;
block|}
name|unsigned
name|int
name|pixelShaderSize
decl_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|pixelShaderSize
argument_list|)
expr_stmt|;
name|unsigned
name|int
name|vertexShaderSize
decl_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|vertexShaderSize
argument_list|)
expr_stmt|;
name|unsigned
name|int
name|geometryShaderSize
decl_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|geometryShaderSize
argument_list|)
expr_stmt|;
specifier|const
name|char
modifier|*
name|ptr
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|binary
operator|+
name|stream
operator|.
name|offset
argument_list|()
decl_stmt|;
specifier|const
name|GUID
modifier|*
name|binaryIdentifier
init|=
operator|(
specifier|const
name|GUID
operator|*
operator|)
name|ptr
decl_stmt|;
name|ptr
operator|+=
sizeof|sizeof
argument_list|(
name|GUID
argument_list|)
expr_stmt|;
name|GUID
name|identifier
init|=
name|mRenderer
operator|->
name|getAdapterIdentifier
argument_list|()
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|identifier
argument_list|,
name|binaryIdentifier
argument_list|,
sizeof|sizeof
argument_list|(
name|GUID
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Invalid program binary."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|char
modifier|*
name|pixelShaderFunction
init|=
name|ptr
decl_stmt|;
name|ptr
operator|+=
name|pixelShaderSize
expr_stmt|;
specifier|const
name|char
modifier|*
name|vertexShaderFunction
init|=
name|ptr
decl_stmt|;
name|ptr
operator|+=
name|vertexShaderSize
expr_stmt|;
specifier|const
name|char
modifier|*
name|geometryShaderFunction
init|=
name|geometryShaderSize
operator|>
literal|0
condition|?
name|ptr
else|:
name|NULL
decl_stmt|;
name|ptr
operator|+=
name|geometryShaderSize
expr_stmt|;
name|mPixelExecutable
operator|=
name|mRenderer
operator|->
name|loadExecutable
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|DWORD
operator|*
argument_list|>
argument_list|(
name|pixelShaderFunction
argument_list|)
argument_list|,
name|pixelShaderSize
argument_list|,
name|rx
operator|::
name|SHADER_PIXEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mPixelExecutable
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Could not create pixel shader."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|mVertexExecutable
operator|=
name|mRenderer
operator|->
name|loadExecutable
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|DWORD
operator|*
argument_list|>
argument_list|(
name|vertexShaderFunction
argument_list|)
argument_list|,
name|vertexShaderSize
argument_list|,
name|rx
operator|::
name|SHADER_VERTEX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mVertexExecutable
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Could not create vertex shader."
argument_list|)
expr_stmt|;
operator|delete
name|mPixelExecutable
expr_stmt|;
name|mPixelExecutable
operator|=
name|NULL
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|geometryShaderFunction
operator|!=
name|NULL
operator|&&
name|geometryShaderSize
operator|>
literal|0
condition|)
block|{
name|mGeometryExecutable
operator|=
name|mRenderer
operator|->
name|loadExecutable
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|DWORD
operator|*
argument_list|>
argument_list|(
name|geometryShaderFunction
argument_list|)
argument_list|,
name|geometryShaderSize
argument_list|,
name|rx
operator|::
name|SHADER_GEOMETRY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mGeometryExecutable
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Could not create geometry shader."
argument_list|)
expr_stmt|;
operator|delete
name|mPixelExecutable
expr_stmt|;
name|mPixelExecutable
operator|=
name|NULL
expr_stmt|;
operator|delete
name|mVertexExecutable
expr_stmt|;
name|mVertexExecutable
operator|=
name|NULL
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
name|mGeometryExecutable
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|save
name|bool
name|ProgramBinary
operator|::
name|save
parameter_list|(
name|void
modifier|*
name|binary
parameter_list|,
name|GLsizei
name|bufSize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|)
block|{
name|BinaryOutputStream
name|stream
decl_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|GL_PROGRAM_BINARY_ANGLE
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|VERSION_DWORD
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
operator|++
name|i
control|)
block|{
name|stream
operator|.
name|write
argument_list|(
name|mLinkedAttribute
index|[
name|i
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mLinkedAttribute
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mSemanticIndex
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_TEXTURE_IMAGE_UNITS
condition|;
operator|++
name|i
control|)
block|{
name|stream
operator|.
name|write
argument_list|(
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|active
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|logicalTextureUnit
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
operator|(
name|int
operator|)
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|textureType
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|IMPLEMENTATION_MAX_VERTEX_TEXTURE_IMAGE_UNITS
condition|;
operator|++
name|i
control|)
block|{
name|stream
operator|.
name|write
argument_list|(
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|active
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|logicalTextureUnit
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
operator|(
name|int
operator|)
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|textureType
argument_list|)
expr_stmt|;
block|}
name|stream
operator|.
name|write
argument_list|(
name|mUsedVertexSamplerRange
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mUsedPixelSamplerRange
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mUsesPointSize
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mUniforms
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mUniforms
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|stream
operator|.
name|write
argument_list|(
name|mUniforms
index|[
name|i
index|]
operator|->
name|type
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mUniforms
index|[
name|i
index|]
operator|->
name|precision
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mUniforms
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mUniforms
index|[
name|i
index|]
operator|->
name|arraySize
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mUniforms
index|[
name|i
index|]
operator|->
name|psRegisterIndex
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mUniforms
index|[
name|i
index|]
operator|->
name|vsRegisterIndex
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mUniforms
index|[
name|i
index|]
operator|->
name|registerCount
argument_list|)
expr_stmt|;
block|}
name|stream
operator|.
name|write
argument_list|(
name|mUniformIndex
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mUniformIndex
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|stream
operator|.
name|write
argument_list|(
name|mUniformIndex
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mUniformIndex
index|[
name|i
index|]
operator|.
name|element
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mUniformIndex
index|[
name|i
index|]
operator|.
name|index
argument_list|)
expr_stmt|;
block|}
name|UINT
name|pixelShaderSize
init|=
name|mPixelExecutable
operator|->
name|getLength
argument_list|()
decl_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|pixelShaderSize
argument_list|)
expr_stmt|;
name|UINT
name|vertexShaderSize
init|=
name|mVertexExecutable
operator|->
name|getLength
argument_list|()
decl_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|vertexShaderSize
argument_list|)
expr_stmt|;
name|UINT
name|geometryShaderSize
init|=
operator|(
name|mGeometryExecutable
operator|!=
name|NULL
operator|)
condition|?
name|mGeometryExecutable
operator|->
name|getLength
argument_list|()
else|:
literal|0
decl_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|geometryShaderSize
argument_list|)
expr_stmt|;
name|GUID
name|identifier
init|=
name|mRenderer
operator|->
name|getAdapterIdentifier
argument_list|()
decl_stmt|;
name|GLsizei
name|streamLength
init|=
name|stream
operator|.
name|length
argument_list|()
decl_stmt|;
specifier|const
name|void
modifier|*
name|streamData
init|=
name|stream
operator|.
name|data
argument_list|()
decl_stmt|;
name|GLsizei
name|totalLength
init|=
name|streamLength
operator|+
sizeof|sizeof
argument_list|(
name|GUID
argument_list|)
operator|+
name|pixelShaderSize
operator|+
name|vertexShaderSize
operator|+
name|geometryShaderSize
decl_stmt|;
if|if
condition|(
name|totalLength
operator|>
name|bufSize
condition|)
block|{
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
if|if
condition|(
name|binary
condition|)
block|{
name|char
modifier|*
name|ptr
init|=
operator|(
name|char
operator|*
operator|)
name|binary
decl_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
name|streamData
argument_list|,
name|streamLength
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|streamLength
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
operator|&
name|identifier
argument_list|,
sizeof|sizeof
argument_list|(
name|GUID
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|+=
sizeof|sizeof
argument_list|(
name|GUID
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
name|mPixelExecutable
operator|->
name|getFunction
argument_list|()
argument_list|,
name|pixelShaderSize
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|pixelShaderSize
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
name|mVertexExecutable
operator|->
name|getFunction
argument_list|()
argument_list|,
name|vertexShaderSize
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|vertexShaderSize
expr_stmt|;
if|if
condition|(
name|mGeometryExecutable
operator|!=
name|NULL
operator|&&
name|geometryShaderSize
operator|>
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|ptr
argument_list|,
name|mGeometryExecutable
operator|->
name|getFunction
argument_list|()
argument_list|,
name|geometryShaderSize
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|geometryShaderSize
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|ptr
operator|-
name|totalLength
operator|==
name|binary
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
name|totalLength
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|getLength
name|GLint
name|ProgramBinary
operator|::
name|getLength
parameter_list|()
block|{
name|GLint
name|length
decl_stmt|;
if|if
condition|(
name|save
argument_list|(
name|NULL
argument_list|,
name|INT_MAX
argument_list|,
operator|&
name|length
argument_list|)
condition|)
block|{
return|return
name|length
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
DECL|function|link
name|bool
name|ProgramBinary
operator|::
name|link
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|AttributeBindings
modifier|&
name|attributeBindings
parameter_list|,
name|FragmentShader
modifier|*
name|fragmentShader
parameter_list|,
name|VertexShader
modifier|*
name|vertexShader
parameter_list|)
block|{
if|if
condition|(
operator|!
name|fragmentShader
operator|||
operator|!
name|fragmentShader
operator|->
name|isCompiled
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|vertexShader
operator|||
operator|!
name|vertexShader
operator|->
name|isCompiled
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|std
operator|::
name|string
name|pixelHLSL
init|=
name|fragmentShader
operator|->
name|getHLSL
argument_list|()
decl_stmt|;
name|std
operator|::
name|string
name|vertexHLSL
init|=
name|vertexShader
operator|->
name|getHLSL
argument_list|()
decl_stmt|;
comment|// Map the varyings to the register file
specifier|const
name|Varying
modifier|*
name|packing
index|[
name|IMPLEMENTATION_MAX_VARYING_VECTORS
index|]
index|[
literal|4
index|]
init|=
block|{
name|NULL
block|}
decl_stmt|;
name|int
name|registers
init|=
name|packVaryings
argument_list|(
name|infoLog
argument_list|,
name|packing
argument_list|,
name|fragmentShader
argument_list|)
decl_stmt|;
if|if
condition|(
name|registers
operator|<
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|linkVaryings
argument_list|(
name|infoLog
argument_list|,
name|registers
argument_list|,
name|packing
argument_list|,
name|pixelHLSL
argument_list|,
name|vertexHLSL
argument_list|,
name|fragmentShader
argument_list|,
name|vertexShader
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|bool
name|success
init|=
literal|true
decl_stmt|;
name|mVertexExecutable
operator|=
name|mRenderer
operator|->
name|compileToExecutable
argument_list|(
name|infoLog
argument_list|,
name|vertexHLSL
operator|.
name|c_str
argument_list|()
argument_list|,
name|rx
operator|::
name|SHADER_VERTEX
argument_list|)
expr_stmt|;
name|mPixelExecutable
operator|=
name|mRenderer
operator|->
name|compileToExecutable
argument_list|(
name|infoLog
argument_list|,
name|pixelHLSL
operator|.
name|c_str
argument_list|()
argument_list|,
name|rx
operator|::
name|SHADER_PIXEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|usesGeometryShader
argument_list|()
condition|)
block|{
name|std
operator|::
name|string
name|geometryHLSL
init|=
name|generateGeometryShaderHLSL
argument_list|(
name|registers
argument_list|,
name|packing
argument_list|,
name|fragmentShader
argument_list|,
name|vertexShader
argument_list|)
decl_stmt|;
name|mGeometryExecutable
operator|=
name|mRenderer
operator|->
name|compileToExecutable
argument_list|(
name|infoLog
argument_list|,
name|geometryHLSL
operator|.
name|c_str
argument_list|()
argument_list|,
name|rx
operator|::
name|SHADER_GEOMETRY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mVertexExecutable
operator|||
operator|!
name|mPixelExecutable
operator|||
operator|(
name|usesGeometryShader
argument_list|()
operator|&&
operator|!
name|mGeometryExecutable
operator|)
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Failed to create D3D shaders."
argument_list|)
expr_stmt|;
name|success
operator|=
literal|false
expr_stmt|;
operator|delete
name|mVertexExecutable
expr_stmt|;
name|mVertexExecutable
operator|=
name|NULL
expr_stmt|;
operator|delete
name|mPixelExecutable
expr_stmt|;
name|mPixelExecutable
operator|=
name|NULL
expr_stmt|;
operator|delete
name|mGeometryExecutable
expr_stmt|;
name|mGeometryExecutable
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|linkAttributes
argument_list|(
name|infoLog
argument_list|,
name|attributeBindings
argument_list|,
name|fragmentShader
argument_list|,
name|vertexShader
argument_list|)
condition|)
block|{
name|success
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|linkUniforms
argument_list|(
name|infoLog
argument_list|,
name|vertexShader
operator|->
name|getUniforms
argument_list|()
argument_list|,
name|fragmentShader
operator|->
name|getUniforms
argument_list|()
argument_list|)
condition|)
block|{
name|success
operator|=
literal|false
expr_stmt|;
block|}
return|return
name|success
return|;
block|}
comment|// Determines the mapping between GL attributes and Direct3D 9 vertex stream usage indices
DECL|function|linkAttributes
name|bool
name|ProgramBinary
operator|::
name|linkAttributes
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|AttributeBindings
modifier|&
name|attributeBindings
parameter_list|,
name|FragmentShader
modifier|*
name|fragmentShader
parameter_list|,
name|VertexShader
modifier|*
name|vertexShader
parameter_list|)
block|{
name|unsigned
name|int
name|usedLocations
init|=
literal|0
decl_stmt|;
comment|// Link attributes that have a binding location
for|for
control|(
name|AttributeArray
operator|::
name|iterator
name|attribute
init|=
name|vertexShader
operator|->
name|mAttributes
operator|.
name|begin
argument_list|()
init|;
name|attribute
operator|!=
name|vertexShader
operator|->
name|mAttributes
operator|.
name|end
argument_list|()
condition|;
name|attribute
operator|++
control|)
block|{
name|int
name|location
init|=
name|attributeBindings
operator|.
name|getAttributeBinding
argument_list|(
name|attribute
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
comment|// Set by glBindAttribLocation
block|{
if|if
condition|(
operator|!
name|mLinkedAttribute
index|[
name|location
index|]
operator|.
name|name
operator|.
name|empty
argument_list|()
condition|)
block|{
comment|// Multiple active attributes bound to the same location; not an error
block|}
name|mLinkedAttribute
index|[
name|location
index|]
operator|=
operator|*
name|attribute
expr_stmt|;
name|int
name|rows
init|=
name|VariableRowCount
argument_list|(
name|attribute
operator|->
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|rows
operator|+
name|location
operator|>
name|MAX_VERTEX_ATTRIBS
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Active attribute (%s) at location %d is too big to fit"
argument_list|,
name|attribute
operator|->
name|name
operator|.
name|c_str
argument_list|()
argument_list|,
name|location
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rows
condition|;
name|i
operator|++
control|)
block|{
name|usedLocations
operator||=
literal|1
operator|<<
operator|(
name|location
operator|+
name|i
operator|)
expr_stmt|;
block|}
block|}
block|}
comment|// Link attributes that don't have a binding location
for|for
control|(
name|AttributeArray
operator|::
name|iterator
name|attribute
init|=
name|vertexShader
operator|->
name|mAttributes
operator|.
name|begin
argument_list|()
init|;
name|attribute
operator|!=
name|vertexShader
operator|->
name|mAttributes
operator|.
name|end
argument_list|()
condition|;
name|attribute
operator|++
control|)
block|{
name|int
name|location
init|=
name|attributeBindings
operator|.
name|getAttributeBinding
argument_list|(
name|attribute
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|location
operator|==
operator|-
literal|1
condition|)
comment|// Not set by glBindAttribLocation
block|{
name|int
name|rows
init|=
name|VariableRowCount
argument_list|(
name|attribute
operator|->
name|type
argument_list|)
decl_stmt|;
name|int
name|availableIndex
init|=
name|AllocateFirstFreeBits
argument_list|(
operator|&
name|usedLocations
argument_list|,
name|rows
argument_list|,
name|MAX_VERTEX_ATTRIBS
argument_list|)
decl_stmt|;
if|if
condition|(
name|availableIndex
operator|==
operator|-
literal|1
operator|||
name|availableIndex
operator|+
name|rows
operator|>
name|MAX_VERTEX_ATTRIBS
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Too many active attributes (%s)"
argument_list|,
name|attribute
operator|->
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
comment|// Fail to link
block|}
name|mLinkedAttribute
index|[
name|availableIndex
index|]
operator|=
operator|*
name|attribute
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|attributeIndex
init|=
literal|0
init|;
name|attributeIndex
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
control|)
block|{
name|int
name|index
init|=
name|vertexShader
operator|->
name|getSemanticIndex
argument_list|(
name|mLinkedAttribute
index|[
name|attributeIndex
index|]
operator|.
name|name
argument_list|)
decl_stmt|;
name|int
name|rows
init|=
name|std
operator|::
name|max
argument_list|(
name|VariableRowCount
argument_list|(
name|mLinkedAttribute
index|[
name|attributeIndex
index|]
operator|.
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|r
init|=
literal|0
init|;
name|r
operator|<
name|rows
condition|;
name|r
operator|++
control|)
block|{
name|mSemanticIndex
index|[
name|attributeIndex
operator|++
index|]
operator|=
name|index
operator|++
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|linkUniforms
name|bool
name|ProgramBinary
operator|::
name|linkUniforms
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|sh
operator|::
name|ActiveUniforms
modifier|&
name|vertexUniforms
parameter_list|,
specifier|const
name|sh
operator|::
name|ActiveUniforms
modifier|&
name|fragmentUniforms
parameter_list|)
block|{
for|for
control|(
name|sh
operator|::
name|ActiveUniforms
operator|::
name|const_iterator
name|uniform
init|=
name|vertexUniforms
operator|.
name|begin
argument_list|()
init|;
name|uniform
operator|!=
name|vertexUniforms
operator|.
name|end
argument_list|()
condition|;
name|uniform
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|defineUniform
argument_list|(
name|GL_VERTEX_SHADER
argument_list|,
operator|*
name|uniform
argument_list|,
name|infoLog
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
for|for
control|(
name|sh
operator|::
name|ActiveUniforms
operator|::
name|const_iterator
name|uniform
init|=
name|fragmentUniforms
operator|.
name|begin
argument_list|()
init|;
name|uniform
operator|!=
name|fragmentUniforms
operator|.
name|end
argument_list|()
condition|;
name|uniform
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|defineUniform
argument_list|(
name|GL_FRAGMENT_SHADER
argument_list|,
operator|*
name|uniform
argument_list|,
name|infoLog
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|defineUniform
name|bool
name|ProgramBinary
operator|::
name|defineUniform
parameter_list|(
name|GLenum
name|shader
parameter_list|,
specifier|const
name|sh
operator|::
name|Uniform
modifier|&
name|constant
parameter_list|,
name|InfoLog
modifier|&
name|infoLog
parameter_list|)
block|{
if|if
condition|(
name|constant
operator|.
name|type
operator|==
name|GL_SAMPLER_2D
operator|||
name|constant
operator|.
name|type
operator|==
name|GL_SAMPLER_CUBE
condition|)
block|{
name|unsigned
name|int
name|samplerIndex
init|=
name|constant
operator|.
name|registerIndex
decl_stmt|;
do|do
block|{
if|if
condition|(
name|shader
operator|==
name|GL_VERTEX_SHADER
condition|)
block|{
if|if
condition|(
name|samplerIndex
operator|<
name|mRenderer
operator|->
name|getMaxVertexTextureImageUnits
argument_list|()
condition|)
block|{
name|mSamplersVS
index|[
name|samplerIndex
index|]
operator|.
name|active
operator|=
literal|true
expr_stmt|;
name|mSamplersVS
index|[
name|samplerIndex
index|]
operator|.
name|textureType
operator|=
operator|(
name|constant
operator|.
name|type
operator|==
name|GL_SAMPLER_CUBE
operator|)
condition|?
name|TEXTURE_CUBE
else|:
name|TEXTURE_2D
expr_stmt|;
name|mSamplersVS
index|[
name|samplerIndex
index|]
operator|.
name|logicalTextureUnit
operator|=
literal|0
expr_stmt|;
name|mUsedVertexSamplerRange
operator|=
name|std
operator|::
name|max
argument_list|(
name|samplerIndex
operator|+
literal|1
argument_list|,
name|mUsedVertexSamplerRange
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Vertex shader sampler count exceeds the maximum vertex texture units (%d)."
argument_list|,
name|mRenderer
operator|->
name|getMaxVertexTextureImageUnits
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|shader
operator|==
name|GL_FRAGMENT_SHADER
condition|)
block|{
if|if
condition|(
name|samplerIndex
operator|<
name|MAX_TEXTURE_IMAGE_UNITS
condition|)
block|{
name|mSamplersPS
index|[
name|samplerIndex
index|]
operator|.
name|active
operator|=
literal|true
expr_stmt|;
name|mSamplersPS
index|[
name|samplerIndex
index|]
operator|.
name|textureType
operator|=
operator|(
name|constant
operator|.
name|type
operator|==
name|GL_SAMPLER_CUBE
operator|)
condition|?
name|TEXTURE_CUBE
else|:
name|TEXTURE_2D
expr_stmt|;
name|mSamplersPS
index|[
name|samplerIndex
index|]
operator|.
name|logicalTextureUnit
operator|=
literal|0
expr_stmt|;
name|mUsedPixelSamplerRange
operator|=
name|std
operator|::
name|max
argument_list|(
name|samplerIndex
operator|+
literal|1
argument_list|,
name|mUsedPixelSamplerRange
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Pixel shader sampler count exceeds MAX_TEXTURE_IMAGE_UNITS (%d)."
argument_list|,
name|MAX_TEXTURE_IMAGE_UNITS
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
name|samplerIndex
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|samplerIndex
operator|<
name|constant
operator|.
name|registerIndex
operator|+
name|constant
operator|.
name|arraySize
condition|)
do|;
block|}
name|Uniform
modifier|*
name|uniform
init|=
name|NULL
decl_stmt|;
name|GLint
name|location
init|=
name|getUniformLocation
argument_list|(
name|constant
operator|.
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|location
operator|>=
literal|0
condition|)
comment|// Previously defined, type and precision must match
block|{
name|uniform
operator|=
name|mUniforms
index|[
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|index
index|]
expr_stmt|;
if|if
condition|(
name|uniform
operator|->
name|type
operator|!=
name|constant
operator|.
name|type
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Types for uniform %s do not match between the vertex and fragment shader"
argument_list|,
name|uniform
operator|->
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|uniform
operator|->
name|precision
operator|!=
name|constant
operator|.
name|precision
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Precisions for uniform %s do not match between the vertex and fragment shader"
argument_list|,
name|uniform
operator|->
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
name|uniform
operator|=
operator|new
name|Uniform
argument_list|(
name|constant
operator|.
name|type
argument_list|,
name|constant
operator|.
name|precision
argument_list|,
name|constant
operator|.
name|name
argument_list|,
name|constant
operator|.
name|arraySize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|uniform
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|shader
operator|==
name|GL_FRAGMENT_SHADER
condition|)
block|{
name|uniform
operator|->
name|psRegisterIndex
operator|=
name|constant
operator|.
name|registerIndex
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shader
operator|==
name|GL_VERTEX_SHADER
condition|)
block|{
name|uniform
operator|->
name|vsRegisterIndex
operator|=
name|constant
operator|.
name|registerIndex
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
if|if
condition|(
name|location
operator|>=
literal|0
condition|)
block|{
return|return
name|uniform
operator|->
name|type
operator|==
name|constant
operator|.
name|type
return|;
block|}
name|mUniforms
operator|.
name|push_back
argument_list|(
name|uniform
argument_list|)
expr_stmt|;
name|unsigned
name|int
name|uniformIndex
init|=
name|mUniforms
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|uniform
operator|->
name|elementCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|mUniformIndex
operator|.
name|push_back
argument_list|(
name|UniformLocation
argument_list|(
name|constant
operator|.
name|name
argument_list|,
name|i
argument_list|,
name|uniformIndex
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shader
operator|==
name|GL_VERTEX_SHADER
condition|)
block|{
if|if
condition|(
name|constant
operator|.
name|registerIndex
operator|+
name|uniform
operator|->
name|registerCount
operator|>
name|mRenderer
operator|->
name|getReservedVertexUniformVectors
argument_list|()
operator|+
name|mRenderer
operator|->
name|getMaxVertexUniformVectors
argument_list|()
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Vertex shader active uniforms exceed GL_MAX_VERTEX_UNIFORM_VECTORS (%u)"
argument_list|,
name|mRenderer
operator|->
name|getMaxVertexUniformVectors
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|shader
operator|==
name|GL_FRAGMENT_SHADER
condition|)
block|{
if|if
condition|(
name|constant
operator|.
name|registerIndex
operator|+
name|uniform
operator|->
name|registerCount
operator|>
name|mRenderer
operator|->
name|getReservedFragmentUniformVectors
argument_list|()
operator|+
name|mRenderer
operator|->
name|getMaxFragmentUniformVectors
argument_list|()
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Fragment shader active uniforms exceed GL_MAX_FRAGMENT_UNIFORM_VECTORS (%u)"
argument_list|,
name|mRenderer
operator|->
name|getMaxFragmentUniformVectors
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|generateGeometryShaderHLSL
name|std
operator|::
name|string
name|ProgramBinary
operator|::
name|generateGeometryShaderHLSL
parameter_list|(
name|int
name|registers
parameter_list|,
specifier|const
name|Varying
modifier|*
name|packing
index|[]
index|[
literal|4
index|]
parameter_list|,
name|FragmentShader
modifier|*
name|fragmentShader
parameter_list|,
name|VertexShader
modifier|*
name|vertexShader
parameter_list|)
specifier|const
block|{
comment|// for now we only handle point sprite emulation
name|ASSERT
argument_list|(
name|usesPointSpriteEmulation
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|generatePointSpriteHLSL
argument_list|(
name|registers
argument_list|,
name|packing
argument_list|,
name|fragmentShader
argument_list|,
name|vertexShader
argument_list|)
return|;
block|}
DECL|function|generatePointSpriteHLSL
name|std
operator|::
name|string
name|ProgramBinary
operator|::
name|generatePointSpriteHLSL
parameter_list|(
name|int
name|registers
parameter_list|,
specifier|const
name|Varying
modifier|*
name|packing
index|[]
index|[
literal|4
index|]
parameter_list|,
name|FragmentShader
modifier|*
name|fragmentShader
parameter_list|,
name|VertexShader
modifier|*
name|vertexShader
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|registers
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vertexShader
operator|->
name|mUsesPointSize
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mRenderer
operator|->
name|getMajorShaderModel
argument_list|()
operator|>=
literal|4
argument_list|)
expr_stmt|;
name|std
operator|::
name|string
name|geomHLSL
decl_stmt|;
name|std
operator|::
name|string
name|varyingSemantic
init|=
literal|"TEXCOORD"
decl_stmt|;
name|std
operator|::
name|string
name|fragCoordSemantic
decl_stmt|;
name|std
operator|::
name|string
name|pointCoordSemantic
decl_stmt|;
name|int
name|reservedRegisterIndex
init|=
name|registers
decl_stmt|;
if|if
condition|(
name|fragmentShader
operator|->
name|mUsesFragCoord
condition|)
block|{
name|fragCoordSemantic
operator|=
name|varyingSemantic
operator|+
name|str
argument_list|(
name|reservedRegisterIndex
operator|++
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fragmentShader
operator|->
name|mUsesPointCoord
condition|)
block|{
name|pointCoordSemantic
operator|=
name|varyingSemantic
operator|+
name|str
argument_list|(
name|reservedRegisterIndex
operator|++
argument_list|)
expr_stmt|;
block|}
name|geomHLSL
operator|+=
literal|"uniform float4 dx_ViewCoords : register(c1);\n"
literal|"\n"
literal|"struct GS_INPUT\n"
literal|"{\n"
expr_stmt|;
for|for
control|(
name|int
name|r
init|=
literal|0
init|;
name|r
operator|<
name|registers
condition|;
name|r
operator|++
control|)
block|{
name|int
name|registerSize
init|=
name|packing
index|[
name|r
index|]
index|[
literal|3
index|]
condition|?
literal|4
else|:
operator|(
name|packing
index|[
name|r
index|]
index|[
literal|2
index|]
condition|?
literal|3
else|:
operator|(
name|packing
index|[
name|r
index|]
index|[
literal|1
index|]
condition|?
literal|2
else|:
literal|1
operator|)
operator|)
decl_stmt|;
name|geomHLSL
operator|+=
literal|"    float"
operator|+
name|str
argument_list|(
name|registerSize
argument_list|)
operator|+
literal|" v"
operator|+
name|str
argument_list|(
name|r
argument_list|)
operator|+
literal|" : "
operator|+
name|varyingSemantic
operator|+
name|str
argument_list|(
name|r
argument_list|)
operator|+
literal|";\n"
expr_stmt|;
block|}
if|if
condition|(
name|fragmentShader
operator|->
name|mUsesFragCoord
condition|)
block|{
name|geomHLSL
operator|+=
literal|"    float4 gl_FragCoord : "
operator|+
name|fragCoordSemantic
operator|+
literal|";\n"
expr_stmt|;
block|}
name|geomHLSL
operator|+=
literal|"    float gl_PointSize : PSIZE;\n"
literal|"    float4 gl_Position : SV_Position;\n"
literal|"};\n"
literal|"\n"
literal|"struct GS_OUTPUT\n"
literal|"{\n"
expr_stmt|;
for|for
control|(
name|int
name|r
init|=
literal|0
init|;
name|r
operator|<
name|registers
condition|;
name|r
operator|++
control|)
block|{
name|int
name|registerSize
init|=
name|packing
index|[
name|r
index|]
index|[
literal|3
index|]
condition|?
literal|4
else|:
operator|(
name|packing
index|[
name|r
index|]
index|[
literal|2
index|]
condition|?
literal|3
else|:
operator|(
name|packing
index|[
name|r
index|]
index|[
literal|1
index|]
condition|?
literal|2
else|:
literal|1
operator|)
operator|)
decl_stmt|;
name|geomHLSL
operator|+=
literal|"    float"
operator|+
name|str
argument_list|(
name|registerSize
argument_list|)
operator|+
literal|" v"
operator|+
name|str
argument_list|(
name|r
argument_list|)
operator|+
literal|" : "
operator|+
name|varyingSemantic
operator|+
name|str
argument_list|(
name|r
argument_list|)
operator|+
literal|";\n"
expr_stmt|;
block|}
if|if
condition|(
name|fragmentShader
operator|->
name|mUsesFragCoord
condition|)
block|{
name|geomHLSL
operator|+=
literal|"    float4 gl_FragCoord : "
operator|+
name|fragCoordSemantic
operator|+
literal|";\n"
expr_stmt|;
block|}
if|if
condition|(
name|fragmentShader
operator|->
name|mUsesPointCoord
condition|)
block|{
name|geomHLSL
operator|+=
literal|"    float2 gl_PointCoord : "
operator|+
name|pointCoordSemantic
operator|+
literal|";\n"
expr_stmt|;
block|}
name|geomHLSL
operator|+=
literal|"    float gl_PointSize : PSIZE;\n"
literal|"    float4 gl_Position : SV_Position;\n"
literal|"};\n"
literal|"\n"
literal|"static float2 pointSpriteCorners[] = \n"
literal|"{\n"
literal|"    float2( 0.5f, -0.5f),\n"
literal|"    float2( 0.5f,  0.5f),\n"
literal|"    float2(-0.5f, -0.5f),\n"
literal|"    float2(-0.5f,  0.5f)\n"
literal|"};\n"
literal|"\n"
literal|"static float2 pointSpriteTexcoords[] = \n"
literal|"{\n"
literal|"    float2(1.0f, 1.0f),\n"
literal|"    float2(1.0f, 0.0f),\n"
literal|"    float2(0.0f, 1.0f),\n"
literal|"    float2(0.0f, 0.0f)\n"
literal|"};\n"
literal|"\n"
literal|"static float minPointSize = "
operator|+
name|str
argument_list|(
name|ALIASED_POINT_SIZE_RANGE_MIN
argument_list|)
operator|+
literal|".0f;\n"
literal|"static float maxPointSize = "
operator|+
name|str
argument_list|(
name|mRenderer
operator|->
name|getMaxPointSize
argument_list|()
argument_list|)
operator|+
literal|".0f;\n"
literal|"\n"
literal|"[maxvertexcount(4)]\n"
literal|"void main(point GS_INPUT input[1], inout TriangleStream<GS_OUTPUT> outStream)\n"
literal|"{\n"
literal|"    GS_OUTPUT output = (GS_OUTPUT)0;\n"
literal|"    output.gl_PointSize = input[0].gl_PointSize;\n"
expr_stmt|;
for|for
control|(
name|int
name|r
init|=
literal|0
init|;
name|r
operator|<
name|registers
condition|;
name|r
operator|++
control|)
block|{
name|geomHLSL
operator|+=
literal|"    output.v"
operator|+
name|str
argument_list|(
name|r
argument_list|)
operator|+
literal|" = input[0].v"
operator|+
name|str
argument_list|(
name|r
argument_list|)
operator|+
literal|";\n"
expr_stmt|;
block|}
if|if
condition|(
name|fragmentShader
operator|->
name|mUsesFragCoord
condition|)
block|{
name|geomHLSL
operator|+=
literal|"    output.gl_FragCoord = input[0].gl_FragCoord;\n"
expr_stmt|;
block|}
name|geomHLSL
operator|+=
literal|"    \n"
literal|"    float gl_PointSize = clamp(input[0].gl_PointSize, minPointSize, maxPointSize);\n"
literal|"    float4 gl_Position = input[0].gl_Position;\n"
literal|"    float2 viewportScale = float2(1.0f / dx_ViewCoords.x, 1.0f / dx_ViewCoords.y) * gl_Position.w;\n"
expr_stmt|;
for|for
control|(
name|int
name|corner
init|=
literal|0
init|;
name|corner
operator|<
literal|4
condition|;
name|corner
operator|++
control|)
block|{
name|geomHLSL
operator|+=
literal|"    \n"
literal|"    output.gl_Position = gl_Position + float4(pointSpriteCorners["
operator|+
name|str
argument_list|(
name|corner
argument_list|)
operator|+
literal|"] * viewportScale * gl_PointSize, 0.0f, 0.0f);\n"
expr_stmt|;
if|if
condition|(
name|fragmentShader
operator|->
name|mUsesPointCoord
condition|)
block|{
name|geomHLSL
operator|+=
literal|"    output.gl_PointCoord = pointSpriteTexcoords["
operator|+
name|str
argument_list|(
name|corner
argument_list|)
operator|+
literal|"];\n"
expr_stmt|;
block|}
name|geomHLSL
operator|+=
literal|"    outStream.Append(output);\n"
expr_stmt|;
block|}
name|geomHLSL
operator|+=
literal|"    \n"
literal|"    outStream.RestartStrip();\n"
literal|"}\n"
expr_stmt|;
return|return
name|geomHLSL
return|;
block|}
comment|// This method needs to match OutputHLSL::decorate
DECL|function|decorateAttribute
name|std
operator|::
name|string
name|ProgramBinary
operator|::
name|decorateAttribute
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|,
literal|"gl_"
argument_list|)
operator|!=
literal|0
operator|&&
name|name
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|,
literal|"dx_"
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
literal|"_"
operator|+
name|name
return|;
block|}
return|return
name|name
return|;
block|}
DECL|function|isValidated
name|bool
name|ProgramBinary
operator|::
name|isValidated
parameter_list|()
specifier|const
block|{
return|return
name|mValidated
return|;
block|}
DECL|function|getActiveAttribute
name|void
name|ProgramBinary
operator|::
name|getActiveAttribute
parameter_list|(
name|GLuint
name|index
parameter_list|,
name|GLsizei
name|bufsize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|,
name|GLint
modifier|*
name|size
parameter_list|,
name|GLenum
modifier|*
name|type
parameter_list|,
name|GLchar
modifier|*
name|name
parameter_list|)
specifier|const
block|{
comment|// Skip over inactive attributes
name|unsigned
name|int
name|activeAttribute
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|attribute
decl_stmt|;
for|for
control|(
name|attribute
operator|=
literal|0
init|;
name|attribute
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|attribute
operator|++
control|)
block|{
if|if
condition|(
name|mLinkedAttribute
index|[
name|attribute
index|]
operator|.
name|name
operator|.
name|empty
argument_list|()
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|activeAttribute
operator|==
name|index
condition|)
block|{
break|break;
block|}
name|activeAttribute
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bufsize
operator|>
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|string
init|=
name|mLinkedAttribute
index|[
name|attribute
index|]
operator|.
name|name
operator|.
name|c_str
argument_list|()
decl_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
name|string
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|name
index|[
name|bufsize
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|size
operator|=
literal|1
expr_stmt|;
comment|// Always a single 'type' instance
operator|*
name|type
operator|=
name|mLinkedAttribute
index|[
name|attribute
index|]
operator|.
name|type
expr_stmt|;
block|}
DECL|function|getActiveAttributeCount
name|GLint
name|ProgramBinary
operator|::
name|getActiveAttributeCount
parameter_list|()
specifier|const
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|attributeIndex
init|=
literal|0
init|;
name|attributeIndex
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|attributeIndex
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|mLinkedAttribute
index|[
name|attributeIndex
index|]
operator|.
name|name
operator|.
name|empty
argument_list|()
condition|)
block|{
name|count
operator|++
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
DECL|function|getActiveAttributeMaxLength
name|GLint
name|ProgramBinary
operator|::
name|getActiveAttributeMaxLength
parameter_list|()
specifier|const
block|{
name|int
name|maxLength
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|attributeIndex
init|=
literal|0
init|;
name|attributeIndex
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|attributeIndex
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|mLinkedAttribute
index|[
name|attributeIndex
index|]
operator|.
name|name
operator|.
name|empty
argument_list|()
condition|)
block|{
name|maxLength
operator|=
name|std
operator|::
name|max
argument_list|(
call|(
name|int
call|)
argument_list|(
name|mLinkedAttribute
index|[
name|attributeIndex
index|]
operator|.
name|name
operator|.
name|length
argument_list|()
operator|+
literal|1
argument_list|)
argument_list|,
name|maxLength
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|maxLength
return|;
block|}
DECL|function|getActiveUniform
name|void
name|ProgramBinary
operator|::
name|getActiveUniform
parameter_list|(
name|GLuint
name|index
parameter_list|,
name|GLsizei
name|bufsize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|,
name|GLint
modifier|*
name|size
parameter_list|,
name|GLenum
modifier|*
name|type
parameter_list|,
name|GLchar
modifier|*
name|name
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|index
operator|<
name|mUniforms
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// index must be smaller than getActiveUniformCount()
if|if
condition|(
name|bufsize
operator|>
literal|0
condition|)
block|{
name|std
operator|::
name|string
name|string
init|=
name|mUniforms
index|[
name|index
index|]
operator|->
name|name
decl_stmt|;
if|if
condition|(
name|mUniforms
index|[
name|index
index|]
operator|->
name|isArray
argument_list|()
condition|)
block|{
name|string
operator|+=
literal|"[0]"
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|name
argument_list|,
name|string
operator|.
name|c_str
argument_list|()
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|name
index|[
name|bufsize
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|size
operator|=
name|mUniforms
index|[
name|index
index|]
operator|->
name|elementCount
argument_list|()
expr_stmt|;
operator|*
name|type
operator|=
name|mUniforms
index|[
name|index
index|]
operator|->
name|type
expr_stmt|;
block|}
DECL|function|getActiveUniformCount
name|GLint
name|ProgramBinary
operator|::
name|getActiveUniformCount
parameter_list|()
specifier|const
block|{
return|return
name|mUniforms
operator|.
name|size
argument_list|()
return|;
block|}
DECL|function|getActiveUniformMaxLength
name|GLint
name|ProgramBinary
operator|::
name|getActiveUniformMaxLength
parameter_list|()
specifier|const
block|{
name|int
name|maxLength
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|numUniforms
init|=
name|mUniforms
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|uniformIndex
init|=
literal|0
init|;
name|uniformIndex
operator|<
name|numUniforms
condition|;
name|uniformIndex
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|mUniforms
index|[
name|uniformIndex
index|]
operator|->
name|name
operator|.
name|empty
argument_list|()
condition|)
block|{
name|int
name|length
init|=
call|(
name|int
call|)
argument_list|(
name|mUniforms
index|[
name|uniformIndex
index|]
operator|->
name|name
operator|.
name|length
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|mUniforms
index|[
name|uniformIndex
index|]
operator|->
name|isArray
argument_list|()
condition|)
block|{
name|length
operator|+=
literal|3
expr_stmt|;
comment|// Counting in "[0]".
block|}
name|maxLength
operator|=
name|std
operator|::
name|max
argument_list|(
name|length
argument_list|,
name|maxLength
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|maxLength
return|;
block|}
DECL|function|validate
name|void
name|ProgramBinary
operator|::
name|validate
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|)
block|{
name|applyUniforms
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|validateSamplers
argument_list|(
operator|&
name|infoLog
argument_list|)
condition|)
block|{
name|mValidated
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|mValidated
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|validateSamplers
name|bool
name|ProgramBinary
operator|::
name|validateSamplers
parameter_list|(
name|InfoLog
modifier|*
name|infoLog
parameter_list|)
block|{
comment|// if any two active samplers in a program are of different types, but refer to the same
comment|// texture image unit, and this is the current program, then ValidateProgram will fail, and
comment|// DrawArrays and DrawElements will issue the INVALID_OPERATION error.
specifier|const
name|unsigned
name|int
name|maxCombinedTextureImageUnits
init|=
name|mRenderer
operator|->
name|getMaxCombinedTextureImageUnits
argument_list|()
decl_stmt|;
name|TextureType
name|textureUnitType
index|[
name|IMPLEMENTATION_MAX_COMBINED_TEXTURE_IMAGE_UNITS
index|]
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|IMPLEMENTATION_MAX_COMBINED_TEXTURE_IMAGE_UNITS
condition|;
operator|++
name|i
control|)
block|{
name|textureUnitType
index|[
name|i
index|]
operator|=
name|TEXTURE_UNKNOWN
expr_stmt|;
block|}
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mUsedPixelSamplerRange
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|active
condition|)
block|{
name|unsigned
name|int
name|unit
init|=
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|logicalTextureUnit
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|maxCombinedTextureImageUnits
condition|)
block|{
if|if
condition|(
name|infoLog
condition|)
block|{
name|infoLog
operator|->
name|append
argument_list|(
literal|"Sampler uniform (%d) exceeds IMPLEMENTATION_MAX_COMBINED_TEXTURE_IMAGE_UNITS (%d)"
argument_list|,
name|unit
argument_list|,
name|maxCombinedTextureImageUnits
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
if|if
condition|(
name|textureUnitType
index|[
name|unit
index|]
operator|!=
name|TEXTURE_UNKNOWN
condition|)
block|{
if|if
condition|(
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|textureType
operator|!=
name|textureUnitType
index|[
name|unit
index|]
condition|)
block|{
if|if
condition|(
name|infoLog
condition|)
block|{
name|infoLog
operator|->
name|append
argument_list|(
literal|"Samplers of conflicting types refer to the same texture image unit (%d)."
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
name|textureUnitType
index|[
name|unit
index|]
operator|=
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|textureType
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mUsedVertexSamplerRange
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|active
condition|)
block|{
name|unsigned
name|int
name|unit
init|=
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|logicalTextureUnit
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|maxCombinedTextureImageUnits
condition|)
block|{
if|if
condition|(
name|infoLog
condition|)
block|{
name|infoLog
operator|->
name|append
argument_list|(
literal|"Sampler uniform (%d) exceeds IMPLEMENTATION_MAX_COMBINED_TEXTURE_IMAGE_UNITS (%d)"
argument_list|,
name|unit
argument_list|,
name|maxCombinedTextureImageUnits
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
if|if
condition|(
name|textureUnitType
index|[
name|unit
index|]
operator|!=
name|TEXTURE_UNKNOWN
condition|)
block|{
if|if
condition|(
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|textureType
operator|!=
name|textureUnitType
index|[
name|unit
index|]
condition|)
block|{
if|if
condition|(
name|infoLog
condition|)
block|{
name|infoLog
operator|->
name|append
argument_list|(
literal|"Samplers of conflicting types refer to the same texture image unit (%d)."
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
name|textureUnitType
index|[
name|unit
index|]
operator|=
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|textureType
expr_stmt|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|Sampler
name|ProgramBinary
operator|::
name|Sampler
operator|::
name|Sampler
parameter_list|()
member_init_list|:
name|active
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|logicalTextureUnit
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|textureType
argument_list|(
name|TEXTURE_2D
argument_list|)
block|{ }
DECL|struct|AttributeSorter
struct|struct
name|AttributeSorter
block|{
DECL|function|AttributeSorter
name|AttributeSorter
argument_list|(
argument|const int (&semanticIndices)[MAX_VERTEX_ATTRIBS]
argument_list|)
public|:
name|originalIndices
parameter_list|(
name|semanticIndices
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|i
operator|++
control|)
block|{
name|indices
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
name|std
operator|::
name|sort
argument_list|(
operator|&
name|indices
index|[
literal|0
index|]
argument_list|,
operator|&
name|indices
index|[
name|MAX_VERTEX_ATTRIBS
index|]
argument_list|,
operator|*
name|this
argument_list|)
expr_stmt|;
block|}
DECL|function|operator ()
name|bool
name|operator
name|()
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|originalIndices
index|[
name|a
index|]
operator|==
operator|-
literal|1
condition|?
literal|false
else|:
name|originalIndices
index|[
name|a
index|]
operator|<
name|originalIndices
index|[
name|b
index|]
return|;
block|}
DECL|member|indices
name|int
name|indices
index|[
name|MAX_VERTEX_ATTRIBS
index|]
decl_stmt|;
DECL|member|originalIndices
specifier|const
name|int
argument_list|(
operator|&
name|originalIndices
argument_list|)
index|[
name|MAX_VERTEX_ATTRIBS
index|]
expr_stmt|;
block|}
struct|;
DECL|function|sortAttributesByLayout
name|void
name|ProgramBinary
operator|::
name|sortAttributesByLayout
parameter_list|(
name|rx
operator|::
name|TranslatedAttribute
name|attributes
index|[
name|MAX_VERTEX_ATTRIBS
index|]
parameter_list|,
name|int
name|sortedSemanticIndices
index|[
name|MAX_VERTEX_ATTRIBS
index|]
parameter_list|)
specifier|const
block|{
name|AttributeSorter
name|sorter
argument_list|(
name|mSemanticIndex
argument_list|)
decl_stmt|;
name|int
name|oldIndices
index|[
name|MAX_VERTEX_ATTRIBS
index|]
decl_stmt|;
name|rx
operator|::
name|TranslatedAttribute
name|oldTranslatedAttributes
index|[
name|MAX_VERTEX_ATTRIBS
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|i
operator|++
control|)
block|{
name|oldIndices
index|[
name|i
index|]
operator|=
name|mSemanticIndex
index|[
name|i
index|]
expr_stmt|;
name|oldTranslatedAttributes
index|[
name|i
index|]
operator|=
name|attributes
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|i
operator|++
control|)
block|{
name|int
name|oldIndex
init|=
name|sorter
operator|.
name|indices
index|[
name|i
index|]
decl_stmt|;
name|sortedSemanticIndices
index|[
name|i
index|]
operator|=
name|oldIndices
index|[
name|oldIndex
index|]
expr_stmt|;
name|attributes
index|[
name|i
index|]
operator|=
name|oldTranslatedAttributes
index|[
name|oldIndex
index|]
expr_stmt|;
block|}
block|}
block|}
end_namespace
end_unit
