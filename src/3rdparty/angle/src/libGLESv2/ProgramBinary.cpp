begin_unit
begin_include
include|#
directive|include
file|"precompiled.h"
end_include
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Program.cpp: Implements the gl::Program class. Implements GL program objects
end_comment
begin_comment
comment|// and related functionality. [OpenGL ES 2.0.24] section 2.10.3 page 28.
end_comment
begin_include
include|#
directive|include
file|"libGLESv2/BinaryStream.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/ProgramBinary.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Framebuffer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Renderbuffer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/ShaderExecutable.h"
end_include
begin_include
include|#
directive|include
file|"common/debug.h"
end_include
begin_include
include|#
directive|include
file|"common/version.h"
end_include
begin_include
include|#
directive|include
file|"common/utilities.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/main.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Shader.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Program.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/Renderer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/VertexDataManager.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Context.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Buffer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/DynamicHLSL.h"
end_include
begin_include
include|#
directive|include
file|"common/blocklayout.h"
end_include
begin_undef
DECL|macro|near
undef|#
directive|undef
name|near
end_undef
begin_undef
DECL|macro|far
undef|#
directive|undef
name|far
end_undef
begin_namespace
DECL|namespace|gl
namespace|namespace
name|gl
block|{
namespace|namespace
block|{
DECL|function|GetTextureType
name|TextureType
name|GetTextureType
parameter_list|(
name|GLenum
name|samplerType
parameter_list|)
block|{
switch|switch
condition|(
name|samplerType
condition|)
block|{
case|case
name|GL_SAMPLER_2D
case|:
case|case
name|GL_INT_SAMPLER_2D
case|:
case|case
name|GL_UNSIGNED_INT_SAMPLER_2D
case|:
case|case
name|GL_SAMPLER_2D_SHADOW
case|:
return|return
name|TEXTURE_2D
return|;
case|case
name|GL_SAMPLER_3D
case|:
case|case
name|GL_INT_SAMPLER_3D
case|:
case|case
name|GL_UNSIGNED_INT_SAMPLER_3D
case|:
return|return
name|TEXTURE_3D
return|;
case|case
name|GL_SAMPLER_CUBE
case|:
case|case
name|GL_SAMPLER_CUBE_SHADOW
case|:
return|return
name|TEXTURE_CUBE
return|;
case|case
name|GL_INT_SAMPLER_CUBE
case|:
case|case
name|GL_UNSIGNED_INT_SAMPLER_CUBE
case|:
return|return
name|TEXTURE_CUBE
return|;
case|case
name|GL_SAMPLER_2D_ARRAY
case|:
case|case
name|GL_INT_SAMPLER_2D_ARRAY
case|:
case|case
name|GL_UNSIGNED_INT_SAMPLER_2D_ARRAY
case|:
case|case
name|GL_SAMPLER_2D_ARRAY_SHADOW
case|:
return|return
name|TEXTURE_2D_ARRAY
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
name|TEXTURE_2D
return|;
block|}
DECL|function|ParseAndStripArrayIndex
name|unsigned
name|int
name|ParseAndStripArrayIndex
parameter_list|(
name|std
operator|::
name|string
modifier|*
name|name
parameter_list|)
block|{
name|unsigned
name|int
name|subscript
init|=
name|GL_INVALID_INDEX
decl_stmt|;
comment|// Strip any trailing array operator and retrieve the subscript
name|size_t
name|open
init|=
name|name
operator|->
name|find_last_of
argument_list|(
literal|'['
argument_list|)
decl_stmt|;
name|size_t
name|close
init|=
name|name
operator|->
name|find_last_of
argument_list|(
literal|']'
argument_list|)
decl_stmt|;
if|if
condition|(
name|open
operator|!=
name|std
operator|::
name|string
operator|::
name|npos
operator|&&
name|close
operator|==
name|name
operator|->
name|length
argument_list|()
operator|-
literal|1
condition|)
block|{
name|subscript
operator|=
name|atoi
argument_list|(
name|name
operator|->
name|substr
argument_list|(
name|open
operator|+
literal|1
argument_list|)
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|name
operator|->
name|erase
argument_list|(
name|open
argument_list|)
expr_stmt|;
block|}
return|return
name|subscript
return|;
block|}
DECL|function|GetInputLayoutFromShader
name|void
name|GetInputLayoutFromShader
parameter_list|(
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|Attribute
argument_list|>
modifier|&
name|shaderAttributes
parameter_list|,
name|VertexFormat
name|inputLayout
index|[
name|MAX_VERTEX_ATTRIBS
index|]
parameter_list|)
block|{
name|size_t
name|layoutIndex
init|=
literal|0
decl_stmt|;
for|for
control|(
name|size_t
name|attributeIndex
init|=
literal|0
init|;
name|attributeIndex
operator|<
name|shaderAttributes
operator|.
name|size
argument_list|()
condition|;
name|attributeIndex
operator|++
control|)
block|{
name|ASSERT
argument_list|(
name|layoutIndex
operator|<
name|MAX_VERTEX_ATTRIBS
argument_list|)
expr_stmt|;
specifier|const
name|sh
operator|::
name|Attribute
modifier|&
name|shaderAttr
init|=
name|shaderAttributes
index|[
name|attributeIndex
index|]
decl_stmt|;
if|if
condition|(
name|shaderAttr
operator|.
name|type
operator|!=
name|GL_NONE
condition|)
block|{
name|GLenum
name|transposedType
init|=
name|TransposeMatrixType
argument_list|(
name|shaderAttr
operator|.
name|type
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|rowIndex
init|=
literal|0
init|;
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|rowIndex
argument_list|)
operator|<
name|VariableRowCount
argument_list|(
name|transposedType
argument_list|)
condition|;
name|rowIndex
operator|++
operator|,
name|layoutIndex
operator|++
control|)
block|{
name|VertexFormat
modifier|*
name|defaultFormat
init|=
operator|&
name|inputLayout
index|[
name|layoutIndex
index|]
decl_stmt|;
name|defaultFormat
operator|->
name|mType
operator|=
name|VariableComponentType
argument_list|(
name|transposedType
argument_list|)
expr_stmt|;
name|defaultFormat
operator|->
name|mNormalized
operator|=
literal|false
expr_stmt|;
name|defaultFormat
operator|->
name|mPureInteger
operator|=
operator|(
name|defaultFormat
operator|->
name|mType
operator|!=
name|GL_FLOAT
operator|)
expr_stmt|;
comment|// note: inputs can not be bool
name|defaultFormat
operator|->
name|mComponents
operator|=
name|VariableColumnCount
argument_list|(
name|transposedType
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|function|VariableLocation
name|VariableLocation
operator|::
name|VariableLocation
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|name
parameter_list|,
name|unsigned
name|int
name|element
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|)
member_init_list|:
name|name
argument_list|(
name|name
argument_list|)
member_init_list|,
name|element
argument_list|(
name|element
argument_list|)
member_init_list|,
name|index
argument_list|(
name|index
argument_list|)
block|{ }
DECL|function|VertexExecutable
name|ProgramBinary
operator|::
name|VertexExecutable
operator|::
name|VertexExecutable
parameter_list|(
specifier|const
name|VertexFormat
name|inputLayout
index|[]
parameter_list|,
specifier|const
name|GLenum
name|signature
index|[]
parameter_list|,
name|rx
operator|::
name|ShaderExecutable
modifier|*
name|shaderExecutable
parameter_list|)
member_init_list|:
name|mShaderExecutable
argument_list|(
name|shaderExecutable
argument_list|)
block|{
for|for
control|(
name|size_t
name|attributeIndex
init|=
literal|0
init|;
name|attributeIndex
operator|<
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
condition|;
name|attributeIndex
operator|++
control|)
block|{
name|mInputs
index|[
name|attributeIndex
index|]
operator|=
name|inputLayout
index|[
name|attributeIndex
index|]
expr_stmt|;
name|mSignature
index|[
name|attributeIndex
index|]
operator|=
name|signature
index|[
name|attributeIndex
index|]
expr_stmt|;
block|}
block|}
DECL|function|~VertexExecutable
name|ProgramBinary
operator|::
name|VertexExecutable
operator|::
name|~
name|VertexExecutable
parameter_list|()
block|{
name|SafeDelete
argument_list|(
name|mShaderExecutable
argument_list|)
expr_stmt|;
block|}
DECL|function|matchesSignature
name|bool
name|ProgramBinary
operator|::
name|VertexExecutable
operator|::
name|matchesSignature
parameter_list|(
specifier|const
name|GLenum
name|signature
index|[]
parameter_list|)
specifier|const
block|{
for|for
control|(
name|size_t
name|attributeIndex
init|=
literal|0
init|;
name|attributeIndex
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|attributeIndex
operator|++
control|)
block|{
if|if
condition|(
name|mSignature
index|[
name|attributeIndex
index|]
operator|!=
name|signature
index|[
name|attributeIndex
index|]
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|PixelExecutable
name|ProgramBinary
operator|::
name|PixelExecutable
operator|::
name|PixelExecutable
parameter_list|(
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|GLenum
argument_list|>
modifier|&
name|outputSignature
parameter_list|,
name|rx
operator|::
name|ShaderExecutable
modifier|*
name|shaderExecutable
parameter_list|)
member_init_list|:
name|mOutputSignature
argument_list|(
name|outputSignature
argument_list|)
member_init_list|,
name|mShaderExecutable
argument_list|(
name|shaderExecutable
argument_list|)
block|{ }
DECL|function|~PixelExecutable
name|ProgramBinary
operator|::
name|PixelExecutable
operator|::
name|~
name|PixelExecutable
parameter_list|()
block|{
name|SafeDelete
argument_list|(
name|mShaderExecutable
argument_list|)
expr_stmt|;
block|}
DECL|function|LinkedVarying
name|LinkedVarying
operator|::
name|LinkedVarying
parameter_list|()
block|{ }
DECL|function|LinkedVarying
name|LinkedVarying
operator|::
name|LinkedVarying
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|name
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLsizei
name|size
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|semanticName
parameter_list|,
name|unsigned
name|int
name|semanticIndex
parameter_list|,
name|unsigned
name|int
name|semanticIndexCount
parameter_list|)
member_init_list|:
name|name
argument_list|(
name|name
argument_list|)
member_init_list|,
name|type
argument_list|(
name|type
argument_list|)
member_init_list|,
name|size
argument_list|(
name|size
argument_list|)
member_init_list|,
name|semanticName
argument_list|(
name|semanticName
argument_list|)
member_init_list|,
name|semanticIndex
argument_list|(
name|semanticIndex
argument_list|)
member_init_list|,
name|semanticIndexCount
argument_list|(
name|semanticIndexCount
argument_list|)
block|{ }
DECL|member|mCurrentSerial
name|unsigned
name|int
name|ProgramBinary
operator|::
name|mCurrentSerial
init|=
literal|1
decl_stmt|;
DECL|function|ProgramBinary
name|ProgramBinary
operator|::
name|ProgramBinary
parameter_list|(
name|rx
operator|::
name|Renderer
modifier|*
name|renderer
parameter_list|)
member_init_list|:
name|RefCountObject
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mRenderer
argument_list|(
name|renderer
argument_list|)
member_init_list|,
name|mDynamicHLSL
argument_list|(
name|NULL
argument_list|)
member_init_list|,
name|mVertexWorkarounds
argument_list|(
name|rx
operator|::
name|ANGLE_D3D_WORKAROUND_NONE
argument_list|)
member_init_list|,
name|mPixelWorkarounds
argument_list|(
name|rx
operator|::
name|ANGLE_D3D_WORKAROUND_NONE
argument_list|)
member_init_list|,
name|mGeometryExecutable
argument_list|(
name|NULL
argument_list|)
member_init_list|,
name|mUsedVertexSamplerRange
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mUsedPixelSamplerRange
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mUsesPointSize
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mShaderVersion
argument_list|(
literal|100
argument_list|)
member_init_list|,
name|mDirtySamplerMapping
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|mVertexUniformStorage
argument_list|(
name|NULL
argument_list|)
member_init_list|,
name|mFragmentUniformStorage
argument_list|(
name|NULL
argument_list|)
member_init_list|,
name|mValidated
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mSerial
argument_list|(
name|issueSerial
argument_list|()
argument_list|)
block|{
for|for
control|(
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|index
operator|++
control|)
block|{
name|mSemanticIndex
index|[
name|index
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
for|for
control|(
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
name|MAX_TEXTURE_IMAGE_UNITS
condition|;
name|index
operator|++
control|)
block|{
name|mSamplersPS
index|[
name|index
index|]
operator|.
name|active
operator|=
literal|false
expr_stmt|;
block|}
for|for
control|(
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
name|IMPLEMENTATION_MAX_VERTEX_TEXTURE_IMAGE_UNITS
condition|;
name|index
operator|++
control|)
block|{
name|mSamplersVS
index|[
name|index
index|]
operator|.
name|active
operator|=
literal|false
expr_stmt|;
block|}
name|mDynamicHLSL
operator|=
operator|new
name|DynamicHLSL
argument_list|(
name|renderer
argument_list|)
expr_stmt|;
block|}
DECL|function|~ProgramBinary
name|ProgramBinary
operator|::
name|~
name|ProgramBinary
parameter_list|()
block|{
name|reset
argument_list|()
expr_stmt|;
name|SafeDelete
argument_list|(
name|mDynamicHLSL
argument_list|)
expr_stmt|;
block|}
DECL|function|getSerial
name|unsigned
name|int
name|ProgramBinary
operator|::
name|getSerial
parameter_list|()
specifier|const
block|{
return|return
name|mSerial
return|;
block|}
DECL|function|getShaderVersion
name|int
name|ProgramBinary
operator|::
name|getShaderVersion
parameter_list|()
specifier|const
block|{
return|return
name|mShaderVersion
return|;
block|}
DECL|function|issueSerial
name|unsigned
name|int
name|ProgramBinary
operator|::
name|issueSerial
parameter_list|()
block|{
return|return
name|mCurrentSerial
operator|++
return|;
block|}
DECL|function|getPixelExecutableForFramebuffer
name|rx
operator|::
name|ShaderExecutable
modifier|*
name|ProgramBinary
operator|::
name|getPixelExecutableForFramebuffer
parameter_list|(
specifier|const
name|Framebuffer
modifier|*
name|fbo
parameter_list|)
block|{
name|std
operator|::
name|vector
argument_list|<
name|GLenum
argument_list|>
name|outputs
argument_list|(
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|outputIndex
init|=
literal|0
init|;
name|outputIndex
operator|<
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
condition|;
name|outputIndex
operator|++
control|)
block|{
if|if
condition|(
name|fbo
operator|->
name|getColorbuffer
argument_list|(
name|outputIndex
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|// Always output floats for now
name|outputs
index|[
name|outputIndex
index|]
operator|=
name|GL_FLOAT
expr_stmt|;
block|}
else|else
block|{
name|outputs
index|[
name|outputIndex
index|]
operator|=
name|GL_NONE
expr_stmt|;
block|}
block|}
return|return
name|getPixelExecutableForOutputLayout
argument_list|(
name|outputs
argument_list|)
return|;
block|}
DECL|function|getPixelExecutableForOutputLayout
name|rx
operator|::
name|ShaderExecutable
modifier|*
name|ProgramBinary
operator|::
name|getPixelExecutableForOutputLayout
parameter_list|(
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|GLenum
argument_list|>
modifier|&
name|outputSignature
parameter_list|)
block|{
for|for
control|(
name|size_t
name|executableIndex
init|=
literal|0
init|;
name|executableIndex
operator|<
name|mPixelExecutables
operator|.
name|size
argument_list|()
condition|;
name|executableIndex
operator|++
control|)
block|{
if|if
condition|(
name|mPixelExecutables
index|[
name|executableIndex
index|]
operator|->
name|matchesSignature
argument_list|(
name|outputSignature
argument_list|)
condition|)
block|{
return|return
name|mPixelExecutables
index|[
name|executableIndex
index|]
operator|->
name|shaderExecutable
argument_list|()
return|;
block|}
block|}
name|std
operator|::
name|string
name|finalPixelHLSL
init|=
name|mDynamicHLSL
operator|->
name|generatePixelShaderForOutputSignature
argument_list|(
name|mPixelHLSL
argument_list|,
name|mPixelShaderKey
argument_list|,
name|mUsesFragDepth
argument_list|,
name|outputSignature
argument_list|)
decl_stmt|;
comment|// Generate new pixel executable
name|InfoLog
name|tempInfoLog
decl_stmt|;
name|rx
operator|::
name|ShaderExecutable
modifier|*
name|pixelExecutable
init|=
name|mRenderer
operator|->
name|compileToExecutable
argument_list|(
name|tempInfoLog
argument_list|,
name|finalPixelHLSL
operator|.
name|c_str
argument_list|()
argument_list|,
name|rx
operator|::
name|SHADER_PIXEL
argument_list|,
name|mTransformFeedbackLinkedVaryings
argument_list|,
operator|(
name|mTransformFeedbackBufferMode
operator|==
name|GL_SEPARATE_ATTRIBS
operator|)
argument_list|,
name|mPixelWorkarounds
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|pixelExecutable
condition|)
block|{
name|std
operator|::
name|vector
argument_list|<
name|char
argument_list|>
name|tempCharBuffer
argument_list|(
name|tempInfoLog
operator|.
name|getLength
argument_list|()
operator|+
literal|3
argument_list|)
decl_stmt|;
name|tempInfoLog
operator|.
name|getLog
argument_list|(
name|tempInfoLog
operator|.
name|getLength
argument_list|()
argument_list|,
name|NULL
argument_list|,
operator|&
name|tempCharBuffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ERR
argument_list|(
literal|"Error compiling dynamic pixel executable:\n%s\n"
argument_list|,
operator|&
name|tempCharBuffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mPixelExecutables
operator|.
name|push_back
argument_list|(
operator|new
name|PixelExecutable
argument_list|(
name|outputSignature
argument_list|,
name|pixelExecutable
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|pixelExecutable
return|;
block|}
DECL|function|getVertexExecutableForInputLayout
name|rx
operator|::
name|ShaderExecutable
modifier|*
name|ProgramBinary
operator|::
name|getVertexExecutableForInputLayout
parameter_list|(
specifier|const
name|VertexFormat
name|inputLayout
index|[
name|MAX_VERTEX_ATTRIBS
index|]
parameter_list|)
block|{
name|GLenum
name|signature
index|[
name|MAX_VERTEX_ATTRIBS
index|]
decl_stmt|;
name|mDynamicHLSL
operator|->
name|getInputLayoutSignature
argument_list|(
name|inputLayout
argument_list|,
name|signature
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|executableIndex
init|=
literal|0
init|;
name|executableIndex
operator|<
name|mVertexExecutables
operator|.
name|size
argument_list|()
condition|;
name|executableIndex
operator|++
control|)
block|{
if|if
condition|(
name|mVertexExecutables
index|[
name|executableIndex
index|]
operator|->
name|matchesSignature
argument_list|(
name|signature
argument_list|)
condition|)
block|{
return|return
name|mVertexExecutables
index|[
name|executableIndex
index|]
operator|->
name|shaderExecutable
argument_list|()
return|;
block|}
block|}
comment|// Generate new dynamic layout with attribute conversions
name|std
operator|::
name|string
name|finalVertexHLSL
init|=
name|mDynamicHLSL
operator|->
name|generateVertexShaderForInputLayout
argument_list|(
name|mVertexHLSL
argument_list|,
name|inputLayout
argument_list|,
name|mShaderAttributes
argument_list|)
decl_stmt|;
comment|// Generate new vertex executable
name|InfoLog
name|tempInfoLog
decl_stmt|;
name|rx
operator|::
name|ShaderExecutable
modifier|*
name|vertexExecutable
init|=
name|mRenderer
operator|->
name|compileToExecutable
argument_list|(
name|tempInfoLog
argument_list|,
name|finalVertexHLSL
operator|.
name|c_str
argument_list|()
argument_list|,
name|rx
operator|::
name|SHADER_VERTEX
argument_list|,
name|mTransformFeedbackLinkedVaryings
argument_list|,
operator|(
name|mTransformFeedbackBufferMode
operator|==
name|GL_SEPARATE_ATTRIBS
operator|)
argument_list|,
name|mVertexWorkarounds
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|vertexExecutable
condition|)
block|{
name|std
operator|::
name|vector
argument_list|<
name|char
argument_list|>
name|tempCharBuffer
argument_list|(
name|tempInfoLog
operator|.
name|getLength
argument_list|()
operator|+
literal|3
argument_list|)
decl_stmt|;
name|tempInfoLog
operator|.
name|getLog
argument_list|(
name|tempInfoLog
operator|.
name|getLength
argument_list|()
argument_list|,
name|NULL
argument_list|,
operator|&
name|tempCharBuffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ERR
argument_list|(
literal|"Error compiling dynamic vertex executable:\n%s\n"
argument_list|,
operator|&
name|tempCharBuffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mVertexExecutables
operator|.
name|push_back
argument_list|(
operator|new
name|VertexExecutable
argument_list|(
name|inputLayout
argument_list|,
name|signature
argument_list|,
name|vertexExecutable
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|vertexExecutable
return|;
block|}
DECL|function|getGeometryExecutable
name|rx
operator|::
name|ShaderExecutable
modifier|*
name|ProgramBinary
operator|::
name|getGeometryExecutable
parameter_list|()
specifier|const
block|{
return|return
name|mGeometryExecutable
return|;
block|}
DECL|function|getAttributeLocation
name|GLuint
name|ProgramBinary
operator|::
name|getAttributeLocation
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
condition|)
block|{
for|for
control|(
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|mLinkedAttribute
index|[
name|index
index|]
operator|.
name|name
operator|==
name|std
operator|::
name|string
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
name|index
return|;
block|}
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
DECL|function|getSemanticIndex
name|int
name|ProgramBinary
operator|::
name|getSemanticIndex
parameter_list|(
name|int
name|attributeIndex
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|attributeIndex
operator|>=
literal|0
operator|&&
name|attributeIndex
operator|<
name|MAX_VERTEX_ATTRIBS
argument_list|)
expr_stmt|;
return|return
name|mSemanticIndex
index|[
name|attributeIndex
index|]
return|;
block|}
comment|// Returns one more than the highest sampler index used.
DECL|function|getUsedSamplerRange
name|GLint
name|ProgramBinary
operator|::
name|getUsedSamplerRange
parameter_list|(
name|SamplerType
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SAMPLER_PIXEL
case|:
return|return
name|mUsedPixelSamplerRange
return|;
case|case
name|SAMPLER_VERTEX
case|:
return|return
name|mUsedVertexSamplerRange
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|usesPointSize
name|bool
name|ProgramBinary
operator|::
name|usesPointSize
parameter_list|()
specifier|const
block|{
return|return
name|mUsesPointSize
return|;
block|}
DECL|function|usesPointSpriteEmulation
name|bool
name|ProgramBinary
operator|::
name|usesPointSpriteEmulation
parameter_list|()
specifier|const
block|{
return|return
name|mUsesPointSize
operator|&&
name|mRenderer
operator|->
name|getMajorShaderModel
argument_list|()
operator|>=
literal|4
return|;
block|}
DECL|function|usesGeometryShader
name|bool
name|ProgramBinary
operator|::
name|usesGeometryShader
parameter_list|()
specifier|const
block|{
return|return
name|usesPointSpriteEmulation
argument_list|()
return|;
block|}
comment|// Returns the index of the texture image unit (0-19) corresponding to a Direct3D 9 sampler
comment|// index (0-15 for the pixel shader and 0-3 for the vertex shader).
DECL|function|getSamplerMapping
name|GLint
name|ProgramBinary
operator|::
name|getSamplerMapping
parameter_list|(
name|SamplerType
name|type
parameter_list|,
name|unsigned
name|int
name|samplerIndex
parameter_list|)
block|{
name|GLint
name|logicalTextureUnit
init|=
operator|-
literal|1
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SAMPLER_PIXEL
case|:
name|ASSERT
argument_list|(
name|samplerIndex
operator|<
name|ArraySize
argument_list|(
name|mSamplersPS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mSamplersPS
index|[
name|samplerIndex
index|]
operator|.
name|active
condition|)
block|{
name|logicalTextureUnit
operator|=
name|mSamplersPS
index|[
name|samplerIndex
index|]
operator|.
name|logicalTextureUnit
expr_stmt|;
block|}
break|break;
case|case
name|SAMPLER_VERTEX
case|:
name|ASSERT
argument_list|(
name|samplerIndex
operator|<
name|ArraySize
argument_list|(
name|mSamplersVS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mSamplersVS
index|[
name|samplerIndex
index|]
operator|.
name|active
condition|)
block|{
name|logicalTextureUnit
operator|=
name|mSamplersVS
index|[
name|samplerIndex
index|]
operator|.
name|logicalTextureUnit
expr_stmt|;
block|}
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|logicalTextureUnit
operator|>=
literal|0
operator|&&
name|logicalTextureUnit
operator|<
operator|(
name|GLint
operator|)
name|mRenderer
operator|->
name|getMaxCombinedTextureImageUnits
argument_list|()
condition|)
block|{
return|return
name|logicalTextureUnit
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|// Returns the texture type for a given Direct3D 9 sampler type and
comment|// index (0-15 for the pixel shader and 0-3 for the vertex shader).
DECL|function|getSamplerTextureType
name|TextureType
name|ProgramBinary
operator|::
name|getSamplerTextureType
parameter_list|(
name|SamplerType
name|type
parameter_list|,
name|unsigned
name|int
name|samplerIndex
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SAMPLER_PIXEL
case|:
name|ASSERT
argument_list|(
name|samplerIndex
operator|<
name|ArraySize
argument_list|(
name|mSamplersPS
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mSamplersPS
index|[
name|samplerIndex
index|]
operator|.
name|active
argument_list|)
expr_stmt|;
return|return
name|mSamplersPS
index|[
name|samplerIndex
index|]
operator|.
name|textureType
return|;
case|case
name|SAMPLER_VERTEX
case|:
name|ASSERT
argument_list|(
name|samplerIndex
operator|<
name|ArraySize
argument_list|(
name|mSamplersVS
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mSamplersVS
index|[
name|samplerIndex
index|]
operator|.
name|active
argument_list|)
expr_stmt|;
return|return
name|mSamplersVS
index|[
name|samplerIndex
index|]
operator|.
name|textureType
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
name|TEXTURE_2D
return|;
block|}
DECL|function|getUniformLocation
name|GLint
name|ProgramBinary
operator|::
name|getUniformLocation
parameter_list|(
name|std
operator|::
name|string
name|name
parameter_list|)
block|{
name|unsigned
name|int
name|subscript
init|=
name|ParseAndStripArrayIndex
argument_list|(
operator|&
name|name
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|numUniforms
init|=
name|mUniformIndex
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|location
init|=
literal|0
init|;
name|location
operator|<
name|numUniforms
condition|;
name|location
operator|++
control|)
block|{
if|if
condition|(
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|name
operator|==
name|name
condition|)
block|{
specifier|const
name|int
name|index
init|=
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|index
decl_stmt|;
specifier|const
name|bool
name|isArray
init|=
name|mUniforms
index|[
name|index
index|]
operator|->
name|isArray
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|isArray
operator|&&
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|==
name|subscript
operator|)
operator|||
operator|(
name|subscript
operator|==
name|GL_INVALID_INDEX
operator|)
condition|)
block|{
return|return
name|location
return|;
block|}
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
DECL|function|getUniformIndex
name|GLuint
name|ProgramBinary
operator|::
name|getUniformIndex
parameter_list|(
name|std
operator|::
name|string
name|name
parameter_list|)
block|{
name|unsigned
name|int
name|subscript
init|=
name|ParseAndStripArrayIndex
argument_list|(
operator|&
name|name
argument_list|)
decl_stmt|;
comment|// The app is not allowed to specify array indices other than 0 for arrays of basic types
if|if
condition|(
name|subscript
operator|!=
literal|0
operator|&&
name|subscript
operator|!=
name|GL_INVALID_INDEX
condition|)
block|{
return|return
name|GL_INVALID_INDEX
return|;
block|}
name|unsigned
name|int
name|numUniforms
init|=
name|mUniforms
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
name|numUniforms
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|mUniforms
index|[
name|index
index|]
operator|->
name|name
operator|==
name|name
condition|)
block|{
if|if
condition|(
name|mUniforms
index|[
name|index
index|]
operator|->
name|isArray
argument_list|()
operator|||
name|subscript
operator|==
name|GL_INVALID_INDEX
condition|)
block|{
return|return
name|index
return|;
block|}
block|}
block|}
return|return
name|GL_INVALID_INDEX
return|;
block|}
DECL|function|getUniformBlockIndex
name|GLuint
name|ProgramBinary
operator|::
name|getUniformBlockIndex
parameter_list|(
name|std
operator|::
name|string
name|name
parameter_list|)
block|{
name|unsigned
name|int
name|subscript
init|=
name|ParseAndStripArrayIndex
argument_list|(
operator|&
name|name
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|numUniformBlocks
init|=
name|mUniformBlocks
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|blockIndex
init|=
literal|0
init|;
name|blockIndex
operator|<
name|numUniformBlocks
condition|;
name|blockIndex
operator|++
control|)
block|{
specifier|const
name|UniformBlock
modifier|&
name|uniformBlock
init|=
operator|*
name|mUniformBlocks
index|[
name|blockIndex
index|]
decl_stmt|;
if|if
condition|(
name|uniformBlock
operator|.
name|name
operator|==
name|name
condition|)
block|{
specifier|const
name|bool
name|arrayElementZero
init|=
operator|(
name|subscript
operator|==
name|GL_INVALID_INDEX
operator|&&
name|uniformBlock
operator|.
name|elementIndex
operator|==
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|subscript
operator|==
name|uniformBlock
operator|.
name|elementIndex
operator|||
name|arrayElementZero
condition|)
block|{
return|return
name|blockIndex
return|;
block|}
block|}
block|}
return|return
name|GL_INVALID_INDEX
return|;
block|}
DECL|function|getUniformBlockByIndex
name|UniformBlock
modifier|*
name|ProgramBinary
operator|::
name|getUniformBlockByIndex
parameter_list|(
name|GLuint
name|blockIndex
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|blockIndex
operator|<
name|mUniformBlocks
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|mUniformBlocks
index|[
name|blockIndex
index|]
return|;
block|}
DECL|function|getFragDataLocation
name|GLint
name|ProgramBinary
operator|::
name|getFragDataLocation
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
specifier|const
block|{
name|std
operator|::
name|string
name|baseName
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|arrayIndex
decl_stmt|;
name|arrayIndex
operator|=
name|ParseAndStripArrayIndex
argument_list|(
operator|&
name|baseName
argument_list|)
expr_stmt|;
for|for
control|(
name|auto
name|locationIt
init|=
name|mOutputVariables
operator|.
name|begin
argument_list|()
init|;
name|locationIt
operator|!=
name|mOutputVariables
operator|.
name|end
argument_list|()
condition|;
name|locationIt
operator|++
control|)
block|{
specifier|const
name|VariableLocation
modifier|&
name|outputVariable
init|=
name|locationIt
operator|->
name|second
decl_stmt|;
if|if
condition|(
name|outputVariable
operator|.
name|name
operator|==
name|baseName
operator|&&
operator|(
name|arrayIndex
operator|==
name|GL_INVALID_INDEX
operator|||
name|arrayIndex
operator|==
name|outputVariable
operator|.
name|element
operator|)
condition|)
block|{
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|locationIt
operator|->
name|first
argument_list|)
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
DECL|function|getTransformFeedbackVaryingCount
name|size_t
name|ProgramBinary
operator|::
name|getTransformFeedbackVaryingCount
parameter_list|()
specifier|const
block|{
return|return
name|mTransformFeedbackLinkedVaryings
operator|.
name|size
argument_list|()
return|;
block|}
DECL|function|getTransformFeedbackVarying
specifier|const
name|LinkedVarying
modifier|&
name|ProgramBinary
operator|::
name|getTransformFeedbackVarying
parameter_list|(
name|size_t
name|idx
parameter_list|)
specifier|const
block|{
return|return
name|mTransformFeedbackLinkedVaryings
index|[
name|idx
index|]
return|;
block|}
DECL|function|getTransformFeedbackBufferMode
name|GLenum
name|ProgramBinary
operator|::
name|getTransformFeedbackBufferMode
parameter_list|()
specifier|const
block|{
return|return
name|mTransformFeedbackBufferMode
return|;
block|}
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|SetIfDirty
specifier|static
specifier|inline
name|void
name|SetIfDirty
parameter_list|(
name|T
modifier|*
name|dest
parameter_list|,
specifier|const
name|T
modifier|&
name|source
parameter_list|,
name|bool
modifier|*
name|dirtyFlag
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|dest
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dirtyFlag
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|dirtyFlag
operator|=
operator|*
name|dirtyFlag
operator|||
operator|(
name|memcmp
argument_list|(
name|dest
argument_list|,
operator|&
name|source
argument_list|,
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
operator|*
name|dest
operator|=
name|source
expr_stmt|;
block|}
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|setUniform
name|void
name|ProgramBinary
operator|::
name|setUniform
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|T
modifier|*
name|v
parameter_list|,
name|GLenum
name|targetUniformType
parameter_list|)
block|{
specifier|const
name|int
name|components
init|=
name|VariableComponentCount
argument_list|(
name|targetUniformType
argument_list|)
decl_stmt|;
specifier|const
name|GLenum
name|targetBoolType
init|=
name|VariableBoolVectorType
argument_list|(
name|targetUniformType
argument_list|)
decl_stmt|;
name|LinkedUniform
modifier|*
name|targetUniform
init|=
name|getUniformByLocation
argument_list|(
name|location
argument_list|)
decl_stmt|;
name|int
name|elementCount
init|=
name|targetUniform
operator|->
name|elementCount
argument_list|()
decl_stmt|;
name|count
operator|=
name|std
operator|::
name|min
argument_list|(
name|elementCount
operator|-
operator|(
name|int
operator|)
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|targetUniformType
condition|)
block|{
name|T
modifier|*
name|target
init|=
operator|(
name|T
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|components
condition|;
name|c
operator|++
control|)
block|{
name|SetIfDirty
argument_list|(
name|target
operator|+
name|c
argument_list|,
name|v
index|[
name|c
index|]
argument_list|,
operator|&
name|targetUniform
operator|->
name|dirty
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|c
init|=
name|components
init|;
name|c
operator|<
literal|4
condition|;
name|c
operator|++
control|)
block|{
name|SetIfDirty
argument_list|(
name|target
operator|+
name|c
argument_list|,
name|T
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|targetUniform
operator|->
name|dirty
argument_list|)
expr_stmt|;
block|}
name|target
operator|+=
literal|4
expr_stmt|;
name|v
operator|+=
name|components
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|targetBoolType
condition|)
block|{
name|GLint
modifier|*
name|boolParams
init|=
operator|(
name|GLint
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|components
condition|;
name|c
operator|++
control|)
block|{
name|SetIfDirty
argument_list|(
name|boolParams
operator|+
name|c
argument_list|,
operator|(
name|v
index|[
name|c
index|]
operator|==
cast|static_cast
argument_list|<
name|T
argument_list|>
argument_list|(
literal|0
argument_list|)
operator|)
condition|?
name|GL_FALSE
else|:
name|GL_TRUE
argument_list|,
operator|&
name|targetUniform
operator|->
name|dirty
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|c
init|=
name|components
init|;
name|c
operator|<
literal|4
condition|;
name|c
operator|++
control|)
block|{
name|SetIfDirty
argument_list|(
name|boolParams
operator|+
name|c
argument_list|,
name|GL_FALSE
argument_list|,
operator|&
name|targetUniform
operator|->
name|dirty
argument_list|)
expr_stmt|;
block|}
name|boolParams
operator|+=
literal|4
expr_stmt|;
name|v
operator|+=
name|components
expr_stmt|;
block|}
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
DECL|function|setUniform1fv
name|void
name|ProgramBinary
operator|::
name|setUniform1fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|setUniform
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|,
name|GL_FLOAT
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform2fv
name|void
name|ProgramBinary
operator|::
name|setUniform2fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|setUniform
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|,
name|GL_FLOAT_VEC2
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform3fv
name|void
name|ProgramBinary
operator|::
name|setUniform3fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|setUniform
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|,
name|GL_FLOAT_VEC3
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform4fv
name|void
name|ProgramBinary
operator|::
name|setUniform4fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|setUniform
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|,
name|GL_FLOAT_VEC4
argument_list|)
expr_stmt|;
block|}
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|transposeMatrix
name|bool
name|transposeMatrix
parameter_list|(
name|T
modifier|*
name|target
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|,
name|int
name|targetWidth
parameter_list|,
name|int
name|targetHeight
parameter_list|,
name|int
name|srcWidth
parameter_list|,
name|int
name|srcHeight
parameter_list|)
block|{
name|bool
name|dirty
init|=
literal|false
decl_stmt|;
name|int
name|copyWidth
init|=
name|std
operator|::
name|min
argument_list|(
name|targetHeight
argument_list|,
name|srcWidth
argument_list|)
decl_stmt|;
name|int
name|copyHeight
init|=
name|std
operator|::
name|min
argument_list|(
name|targetWidth
argument_list|,
name|srcHeight
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|copyWidth
condition|;
name|x
operator|++
control|)
block|{
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|copyHeight
condition|;
name|y
operator|++
control|)
block|{
name|SetIfDirty
argument_list|(
name|target
operator|+
operator|(
name|x
operator|*
name|targetWidth
operator|+
name|y
operator|)
argument_list|,
cast|static_cast
argument_list|<
name|T
argument_list|>
argument_list|(
name|value
index|[
name|y
operator|*
name|srcWidth
operator|+
name|x
index|]
argument_list|)
argument_list|,
operator|&
name|dirty
argument_list|)
expr_stmt|;
block|}
block|}
comment|// clear unfilled right side
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|copyWidth
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
name|copyHeight
init|;
name|x
operator|<
name|targetWidth
condition|;
name|x
operator|++
control|)
block|{
name|SetIfDirty
argument_list|(
name|target
operator|+
operator|(
name|y
operator|*
name|targetWidth
operator|+
name|x
operator|)
argument_list|,
cast|static_cast
argument_list|<
name|T
argument_list|>
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|dirty
argument_list|)
expr_stmt|;
block|}
block|}
comment|// clear unfilled bottom.
for|for
control|(
name|int
name|y
init|=
name|copyWidth
init|;
name|y
operator|<
name|targetHeight
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|targetWidth
condition|;
name|x
operator|++
control|)
block|{
name|SetIfDirty
argument_list|(
name|target
operator|+
operator|(
name|y
operator|*
name|targetWidth
operator|+
name|x
operator|)
argument_list|,
cast|static_cast
argument_list|<
name|T
argument_list|>
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|dirty
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|dirty
return|;
block|}
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|expandMatrix
name|bool
name|expandMatrix
parameter_list|(
name|T
modifier|*
name|target
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|,
name|int
name|targetWidth
parameter_list|,
name|int
name|targetHeight
parameter_list|,
name|int
name|srcWidth
parameter_list|,
name|int
name|srcHeight
parameter_list|)
block|{
name|bool
name|dirty
init|=
literal|false
decl_stmt|;
name|int
name|copyWidth
init|=
name|std
operator|::
name|min
argument_list|(
name|targetWidth
argument_list|,
name|srcWidth
argument_list|)
decl_stmt|;
name|int
name|copyHeight
init|=
name|std
operator|::
name|min
argument_list|(
name|targetHeight
argument_list|,
name|srcHeight
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|copyHeight
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|copyWidth
condition|;
name|x
operator|++
control|)
block|{
name|SetIfDirty
argument_list|(
name|target
operator|+
operator|(
name|y
operator|*
name|targetWidth
operator|+
name|x
operator|)
argument_list|,
cast|static_cast
argument_list|<
name|T
argument_list|>
argument_list|(
name|value
index|[
name|y
operator|*
name|srcWidth
operator|+
name|x
index|]
argument_list|)
argument_list|,
operator|&
name|dirty
argument_list|)
expr_stmt|;
block|}
block|}
comment|// clear unfilled right side
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|copyHeight
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
name|copyWidth
init|;
name|x
operator|<
name|targetWidth
condition|;
name|x
operator|++
control|)
block|{
name|SetIfDirty
argument_list|(
name|target
operator|+
operator|(
name|y
operator|*
name|targetWidth
operator|+
name|x
operator|)
argument_list|,
cast|static_cast
argument_list|<
name|T
argument_list|>
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|dirty
argument_list|)
expr_stmt|;
block|}
block|}
comment|// clear unfilled bottom.
for|for
control|(
name|int
name|y
init|=
name|copyHeight
init|;
name|y
operator|<
name|targetHeight
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|targetWidth
condition|;
name|x
operator|++
control|)
block|{
name|SetIfDirty
argument_list|(
name|target
operator|+
operator|(
name|y
operator|*
name|targetWidth
operator|+
name|x
operator|)
argument_list|,
cast|static_cast
argument_list|<
name|T
argument_list|>
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|dirty
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|dirty
return|;
block|}
template|template
parameter_list|<
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|>
DECL|function|setUniformMatrixfv
name|void
name|ProgramBinary
operator|::
name|setUniformMatrixfv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|,
name|GLenum
name|targetUniformType
parameter_list|)
block|{
name|LinkedUniform
modifier|*
name|targetUniform
init|=
name|getUniformByLocation
argument_list|(
name|location
argument_list|)
decl_stmt|;
name|int
name|elementCount
init|=
name|targetUniform
operator|->
name|elementCount
argument_list|()
decl_stmt|;
name|count
operator|=
name|std
operator|::
name|min
argument_list|(
name|elementCount
operator|-
operator|(
name|int
operator|)
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
argument_list|,
name|count
argument_list|)
expr_stmt|;
specifier|const
name|unsigned
name|int
name|targetMatrixStride
init|=
operator|(
literal|4
operator|*
name|rows
operator|)
decl_stmt|;
name|GLfloat
modifier|*
name|target
init|=
operator|(
name|GLfloat
operator|*
operator|)
operator|(
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
sizeof|sizeof
argument_list|(
name|GLfloat
argument_list|)
operator|*
name|targetMatrixStride
operator|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|// Internally store matrices as transposed versions to accomodate HLSL matrix indexing
if|if
condition|(
name|transpose
operator|==
name|GL_FALSE
condition|)
block|{
name|targetUniform
operator|->
name|dirty
operator|=
name|transposeMatrix
argument_list|<
name|GLfloat
argument_list|>
argument_list|(
name|target
argument_list|,
name|value
argument_list|,
literal|4
argument_list|,
name|rows
argument_list|,
name|rows
argument_list|,
name|cols
argument_list|)
operator|||
name|targetUniform
operator|->
name|dirty
expr_stmt|;
block|}
else|else
block|{
name|targetUniform
operator|->
name|dirty
operator|=
name|expandMatrix
argument_list|<
name|GLfloat
argument_list|>
argument_list|(
name|target
argument_list|,
name|value
argument_list|,
literal|4
argument_list|,
name|rows
argument_list|,
name|cols
argument_list|,
name|rows
argument_list|)
operator|||
name|targetUniform
operator|->
name|dirty
expr_stmt|;
block|}
name|target
operator|+=
name|targetMatrixStride
expr_stmt|;
name|value
operator|+=
name|cols
operator|*
name|rows
expr_stmt|;
block|}
block|}
DECL|function|setUniformMatrix2fv
name|void
name|ProgramBinary
operator|::
name|setUniformMatrix2fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
name|setUniformMatrixfv
argument_list|<
literal|2
argument_list|,
literal|2
argument_list|>
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|value
argument_list|,
name|GL_FLOAT_MAT2
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix3fv
name|void
name|ProgramBinary
operator|::
name|setUniformMatrix3fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
name|setUniformMatrixfv
argument_list|<
literal|3
argument_list|,
literal|3
argument_list|>
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|value
argument_list|,
name|GL_FLOAT_MAT3
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix4fv
name|void
name|ProgramBinary
operator|::
name|setUniformMatrix4fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
name|setUniformMatrixfv
argument_list|<
literal|4
argument_list|,
literal|4
argument_list|>
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|value
argument_list|,
name|GL_FLOAT_MAT4
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix2x3fv
name|void
name|ProgramBinary
operator|::
name|setUniformMatrix2x3fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
name|setUniformMatrixfv
argument_list|<
literal|2
argument_list|,
literal|3
argument_list|>
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|value
argument_list|,
name|GL_FLOAT_MAT2x3
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix3x2fv
name|void
name|ProgramBinary
operator|::
name|setUniformMatrix3x2fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
name|setUniformMatrixfv
argument_list|<
literal|3
argument_list|,
literal|2
argument_list|>
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|value
argument_list|,
name|GL_FLOAT_MAT3x2
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix2x4fv
name|void
name|ProgramBinary
operator|::
name|setUniformMatrix2x4fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
name|setUniformMatrixfv
argument_list|<
literal|2
argument_list|,
literal|4
argument_list|>
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|value
argument_list|,
name|GL_FLOAT_MAT2x4
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix4x2fv
name|void
name|ProgramBinary
operator|::
name|setUniformMatrix4x2fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
name|setUniformMatrixfv
argument_list|<
literal|4
argument_list|,
literal|2
argument_list|>
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|value
argument_list|,
name|GL_FLOAT_MAT4x2
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix3x4fv
name|void
name|ProgramBinary
operator|::
name|setUniformMatrix3x4fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
name|setUniformMatrixfv
argument_list|<
literal|3
argument_list|,
literal|4
argument_list|>
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|value
argument_list|,
name|GL_FLOAT_MAT3x4
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix4x3fv
name|void
name|ProgramBinary
operator|::
name|setUniformMatrix4x3fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
name|setUniformMatrixfv
argument_list|<
literal|4
argument_list|,
literal|3
argument_list|>
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|value
argument_list|,
name|GL_FLOAT_MAT4x3
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform1iv
name|void
name|ProgramBinary
operator|::
name|setUniform1iv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|LinkedUniform
modifier|*
name|targetUniform
init|=
name|mUniforms
index|[
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|index
index|]
decl_stmt|;
name|int
name|elementCount
init|=
name|targetUniform
operator|->
name|elementCount
argument_list|()
decl_stmt|;
name|count
operator|=
name|std
operator|::
name|min
argument_list|(
name|elementCount
operator|-
operator|(
name|int
operator|)
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|GL_INT
operator|||
name|IsSampler
argument_list|(
name|targetUniform
operator|->
name|type
argument_list|)
condition|)
block|{
name|GLint
modifier|*
name|target
init|=
operator|(
name|GLint
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|SetIfDirty
argument_list|(
name|target
operator|+
literal|0
argument_list|,
name|v
index|[
literal|0
index|]
argument_list|,
operator|&
name|targetUniform
operator|->
name|dirty
argument_list|)
expr_stmt|;
name|SetIfDirty
argument_list|(
name|target
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|targetUniform
operator|->
name|dirty
argument_list|)
expr_stmt|;
name|SetIfDirty
argument_list|(
name|target
operator|+
literal|2
argument_list|,
literal|0
argument_list|,
operator|&
name|targetUniform
operator|->
name|dirty
argument_list|)
expr_stmt|;
name|SetIfDirty
argument_list|(
name|target
operator|+
literal|3
argument_list|,
literal|0
argument_list|,
operator|&
name|targetUniform
operator|->
name|dirty
argument_list|)
expr_stmt|;
name|target
operator|+=
literal|4
expr_stmt|;
name|v
operator|+=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|GL_BOOL
condition|)
block|{
name|GLint
modifier|*
name|boolParams
init|=
operator|(
name|GLint
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|SetIfDirty
argument_list|(
name|boolParams
operator|+
literal|0
argument_list|,
operator|(
name|v
index|[
literal|0
index|]
operator|==
literal|0
operator|)
condition|?
name|GL_FALSE
else|:
name|GL_TRUE
argument_list|,
operator|&
name|targetUniform
operator|->
name|dirty
argument_list|)
expr_stmt|;
name|SetIfDirty
argument_list|(
name|boolParams
operator|+
literal|1
argument_list|,
name|GL_FALSE
argument_list|,
operator|&
name|targetUniform
operator|->
name|dirty
argument_list|)
expr_stmt|;
name|SetIfDirty
argument_list|(
name|boolParams
operator|+
literal|2
argument_list|,
name|GL_FALSE
argument_list|,
operator|&
name|targetUniform
operator|->
name|dirty
argument_list|)
expr_stmt|;
name|SetIfDirty
argument_list|(
name|boolParams
operator|+
literal|3
argument_list|,
name|GL_FALSE
argument_list|,
operator|&
name|targetUniform
operator|->
name|dirty
argument_list|)
expr_stmt|;
name|boolParams
operator|+=
literal|4
expr_stmt|;
name|v
operator|+=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
comment|// Set a special flag if we change a sampler uniform
if|if
condition|(
name|IsSampler
argument_list|(
name|targetUniform
operator|->
name|type
argument_list|)
operator|&&
operator|(
name|memcmp
argument_list|(
name|targetUniform
operator|->
name|data
argument_list|,
name|v
argument_list|,
sizeof|sizeof
argument_list|(
name|GLint
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|mDirtySamplerMapping
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|setUniform2iv
name|void
name|ProgramBinary
operator|::
name|setUniform2iv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|setUniform
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|,
name|GL_INT_VEC2
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform3iv
name|void
name|ProgramBinary
operator|::
name|setUniform3iv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|setUniform
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|,
name|GL_INT_VEC3
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform4iv
name|void
name|ProgramBinary
operator|::
name|setUniform4iv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|setUniform
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|,
name|GL_INT_VEC4
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform1uiv
name|void
name|ProgramBinary
operator|::
name|setUniform1uiv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|v
parameter_list|)
block|{
name|setUniform
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|,
name|GL_UNSIGNED_INT
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform2uiv
name|void
name|ProgramBinary
operator|::
name|setUniform2uiv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|v
parameter_list|)
block|{
name|setUniform
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|,
name|GL_UNSIGNED_INT_VEC2
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform3uiv
name|void
name|ProgramBinary
operator|::
name|setUniform3uiv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|v
parameter_list|)
block|{
name|setUniform
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|,
name|GL_UNSIGNED_INT_VEC3
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform4uiv
name|void
name|ProgramBinary
operator|::
name|setUniform4uiv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|v
parameter_list|)
block|{
name|setUniform
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|,
name|GL_UNSIGNED_INT_VEC4
argument_list|)
expr_stmt|;
block|}
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|getUniformv
name|bool
name|ProgramBinary
operator|::
name|getUniformv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
modifier|*
name|bufSize
parameter_list|,
name|T
modifier|*
name|params
parameter_list|,
name|GLenum
name|uniformType
parameter_list|)
block|{
name|LinkedUniform
modifier|*
name|targetUniform
init|=
name|mUniforms
index|[
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|index
index|]
decl_stmt|;
comment|// sized queries -- ensure the provided buffer is large enough
if|if
condition|(
name|bufSize
condition|)
block|{
name|int
name|requiredBytes
init|=
name|VariableExternalSize
argument_list|(
name|targetUniform
operator|->
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|bufSize
operator|<
name|requiredBytes
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|IsMatrixType
argument_list|(
name|targetUniform
operator|->
name|type
argument_list|)
condition|)
block|{
specifier|const
name|int
name|rows
init|=
name|VariableRowCount
argument_list|(
name|targetUniform
operator|->
name|type
argument_list|)
decl_stmt|;
specifier|const
name|int
name|cols
init|=
name|VariableColumnCount
argument_list|(
name|targetUniform
operator|->
name|type
argument_list|)
decl_stmt|;
name|transposeMatrix
argument_list|(
name|params
argument_list|,
operator|(
name|GLfloat
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
operator|*
name|rows
argument_list|,
name|rows
argument_list|,
name|cols
argument_list|,
literal|4
argument_list|,
name|rows
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uniformType
operator|==
name|VariableComponentType
argument_list|(
name|targetUniform
operator|->
name|type
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|size
init|=
name|VariableComponentCount
argument_list|(
name|targetUniform
operator|->
name|type
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|params
argument_list|,
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|size
init|=
name|VariableComponentCount
argument_list|(
name|targetUniform
operator|->
name|type
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|VariableComponentType
argument_list|(
name|targetUniform
operator|->
name|type
argument_list|)
condition|)
block|{
case|case
name|GL_BOOL
case|:
block|{
name|GLint
modifier|*
name|boolParams
init|=
operator|(
name|GLint
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|params
index|[
name|i
index|]
operator|=
operator|(
name|boolParams
index|[
name|i
index|]
operator|==
name|GL_FALSE
operator|)
condition|?
cast|static_cast
argument_list|<
name|T
argument_list|>
argument_list|(
literal|0
argument_list|)
else|:
cast|static_cast
argument_list|<
name|T
argument_list|>
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GL_FLOAT
case|:
block|{
name|GLfloat
modifier|*
name|floatParams
init|=
operator|(
name|GLfloat
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|params
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
name|T
argument_list|>
argument_list|(
name|floatParams
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GL_INT
case|:
block|{
name|GLint
modifier|*
name|intParams
init|=
operator|(
name|GLint
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|params
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
name|T
argument_list|>
argument_list|(
name|intParams
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GL_UNSIGNED_INT
case|:
block|{
name|GLuint
modifier|*
name|uintParams
init|=
operator|(
name|GLuint
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|params
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
name|T
argument_list|>
argument_list|(
name|uintParams
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|getUniformfv
name|bool
name|ProgramBinary
operator|::
name|getUniformfv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
modifier|*
name|bufSize
parameter_list|,
name|GLfloat
modifier|*
name|params
parameter_list|)
block|{
return|return
name|getUniformv
argument_list|(
name|location
argument_list|,
name|bufSize
argument_list|,
name|params
argument_list|,
name|GL_FLOAT
argument_list|)
return|;
block|}
DECL|function|getUniformiv
name|bool
name|ProgramBinary
operator|::
name|getUniformiv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
modifier|*
name|bufSize
parameter_list|,
name|GLint
modifier|*
name|params
parameter_list|)
block|{
return|return
name|getUniformv
argument_list|(
name|location
argument_list|,
name|bufSize
argument_list|,
name|params
argument_list|,
name|GL_INT
argument_list|)
return|;
block|}
DECL|function|getUniformuiv
name|bool
name|ProgramBinary
operator|::
name|getUniformuiv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
modifier|*
name|bufSize
parameter_list|,
name|GLuint
modifier|*
name|params
parameter_list|)
block|{
return|return
name|getUniformv
argument_list|(
name|location
argument_list|,
name|bufSize
argument_list|,
name|params
argument_list|,
name|GL_UNSIGNED_INT
argument_list|)
return|;
block|}
DECL|function|dirtyAllUniforms
name|void
name|ProgramBinary
operator|::
name|dirtyAllUniforms
parameter_list|()
block|{
name|unsigned
name|int
name|numUniforms
init|=
name|mUniforms
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
name|numUniforms
condition|;
name|index
operator|++
control|)
block|{
name|mUniforms
index|[
name|index
index|]
operator|->
name|dirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|updateSamplerMapping
name|void
name|ProgramBinary
operator|::
name|updateSamplerMapping
parameter_list|()
block|{
if|if
condition|(
operator|!
name|mDirtySamplerMapping
condition|)
block|{
return|return;
block|}
name|mDirtySamplerMapping
operator|=
literal|false
expr_stmt|;
comment|// Retrieve sampler uniform values
for|for
control|(
name|size_t
name|uniformIndex
init|=
literal|0
init|;
name|uniformIndex
operator|<
name|mUniforms
operator|.
name|size
argument_list|()
condition|;
name|uniformIndex
operator|++
control|)
block|{
name|LinkedUniform
modifier|*
name|targetUniform
init|=
name|mUniforms
index|[
name|uniformIndex
index|]
decl_stmt|;
if|if
condition|(
name|targetUniform
operator|->
name|dirty
condition|)
block|{
if|if
condition|(
name|IsSampler
argument_list|(
name|targetUniform
operator|->
name|type
argument_list|)
condition|)
block|{
name|int
name|count
init|=
name|targetUniform
operator|->
name|elementCount
argument_list|()
decl_stmt|;
name|GLint
argument_list|(
operator|*
name|v
argument_list|)
index|[
literal|4
index|]
operator|=
expr|reinterpret_cast
operator|<
name|GLint
argument_list|(
operator|*
argument_list|)
index|[
literal|4
index|]
operator|>
operator|(
name|targetUniform
operator|->
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|targetUniform
operator|->
name|isReferencedByFragmentShader
argument_list|()
condition|)
block|{
name|unsigned
name|int
name|firstIndex
init|=
name|targetUniform
operator|->
name|psRegisterIndex
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|samplerIndex
init|=
name|firstIndex
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|samplerIndex
operator|<
name|MAX_TEXTURE_IMAGE_UNITS
condition|)
block|{
name|ASSERT
argument_list|(
name|mSamplersPS
index|[
name|samplerIndex
index|]
operator|.
name|active
argument_list|)
expr_stmt|;
name|mSamplersPS
index|[
name|samplerIndex
index|]
operator|.
name|logicalTextureUnit
operator|=
name|v
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|targetUniform
operator|->
name|isReferencedByVertexShader
argument_list|()
condition|)
block|{
name|unsigned
name|int
name|firstIndex
init|=
name|targetUniform
operator|->
name|vsRegisterIndex
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|samplerIndex
init|=
name|firstIndex
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|samplerIndex
operator|<
name|IMPLEMENTATION_MAX_VERTEX_TEXTURE_IMAGE_UNITS
condition|)
block|{
name|ASSERT
argument_list|(
name|mSamplersVS
index|[
name|samplerIndex
index|]
operator|.
name|active
argument_list|)
expr_stmt|;
name|mSamplersVS
index|[
name|samplerIndex
index|]
operator|.
name|logicalTextureUnit
operator|=
name|v
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
comment|// Applies all the uniforms set for this program object to the renderer
DECL|function|applyUniforms
name|void
name|ProgramBinary
operator|::
name|applyUniforms
parameter_list|()
block|{
name|updateSamplerMapping
argument_list|()
expr_stmt|;
name|mRenderer
operator|->
name|applyUniforms
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|uniformIndex
init|=
literal|0
init|;
name|uniformIndex
operator|<
name|mUniforms
operator|.
name|size
argument_list|()
condition|;
name|uniformIndex
operator|++
control|)
block|{
name|mUniforms
index|[
name|uniformIndex
index|]
operator|->
name|dirty
operator|=
literal|false
expr_stmt|;
block|}
block|}
DECL|function|applyUniformBuffers
name|bool
name|ProgramBinary
operator|::
name|applyUniformBuffers
parameter_list|(
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|gl
operator|::
name|Buffer
operator|*
argument_list|>
name|boundBuffers
parameter_list|)
block|{
specifier|const
name|gl
operator|::
name|Buffer
modifier|*
name|vertexUniformBuffers
index|[
name|gl
operator|::
name|IMPLEMENTATION_MAX_VERTEX_SHADER_UNIFORM_BUFFERS
index|]
init|=
block|{
name|NULL
block|}
decl_stmt|;
specifier|const
name|gl
operator|::
name|Buffer
modifier|*
name|fragmentUniformBuffers
index|[
name|gl
operator|::
name|IMPLEMENTATION_MAX_FRAGMENT_SHADER_UNIFORM_BUFFERS
index|]
init|=
block|{
name|NULL
block|}
decl_stmt|;
specifier|const
name|unsigned
name|int
name|reservedBuffersInVS
init|=
name|mRenderer
operator|->
name|getReservedVertexUniformBuffers
argument_list|()
decl_stmt|;
specifier|const
name|unsigned
name|int
name|reservedBuffersInFS
init|=
name|mRenderer
operator|->
name|getReservedFragmentUniformBuffers
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|boundBuffers
operator|.
name|size
argument_list|()
operator|==
name|mUniformBlocks
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|uniformBlockIndex
init|=
literal|0
init|;
name|uniformBlockIndex
operator|<
name|mUniformBlocks
operator|.
name|size
argument_list|()
condition|;
name|uniformBlockIndex
operator|++
control|)
block|{
name|UniformBlock
modifier|*
name|uniformBlock
init|=
name|getUniformBlockByIndex
argument_list|(
name|uniformBlockIndex
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Buffer
modifier|*
name|uniformBuffer
init|=
name|boundBuffers
index|[
name|uniformBlockIndex
index|]
decl_stmt|;
name|ASSERT
argument_list|(
name|uniformBlock
operator|&&
name|uniformBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|uniformBuffer
operator|->
name|getSize
argument_list|()
operator|<
name|uniformBlock
operator|->
name|dataSize
condition|)
block|{
comment|// undefined behaviour
return|return
literal|false
return|;
block|}
name|ASSERT
argument_list|(
name|uniformBlock
operator|->
name|isReferencedByVertexShader
argument_list|()
operator|||
name|uniformBlock
operator|->
name|isReferencedByFragmentShader
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|uniformBlock
operator|->
name|isReferencedByVertexShader
argument_list|()
condition|)
block|{
name|unsigned
name|int
name|registerIndex
init|=
name|uniformBlock
operator|->
name|vsRegisterIndex
operator|-
name|reservedBuffersInVS
decl_stmt|;
name|ASSERT
argument_list|(
name|vertexUniformBuffers
index|[
name|registerIndex
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|registerIndex
operator|<
name|mRenderer
operator|->
name|getMaxVertexShaderUniformBuffers
argument_list|()
argument_list|)
expr_stmt|;
name|vertexUniformBuffers
index|[
name|registerIndex
index|]
operator|=
name|uniformBuffer
expr_stmt|;
block|}
if|if
condition|(
name|uniformBlock
operator|->
name|isReferencedByFragmentShader
argument_list|()
condition|)
block|{
name|unsigned
name|int
name|registerIndex
init|=
name|uniformBlock
operator|->
name|psRegisterIndex
operator|-
name|reservedBuffersInFS
decl_stmt|;
name|ASSERT
argument_list|(
name|fragmentUniformBuffers
index|[
name|registerIndex
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|registerIndex
operator|<
name|mRenderer
operator|->
name|getMaxFragmentShaderUniformBuffers
argument_list|()
argument_list|)
expr_stmt|;
name|fragmentUniformBuffers
index|[
name|registerIndex
index|]
operator|=
name|uniformBuffer
expr_stmt|;
block|}
block|}
return|return
name|mRenderer
operator|->
name|setUniformBuffers
argument_list|(
name|vertexUniformBuffers
argument_list|,
name|fragmentUniformBuffers
argument_list|)
return|;
block|}
DECL|function|linkVaryings
name|bool
name|ProgramBinary
operator|::
name|linkVaryings
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
name|FragmentShader
modifier|*
name|fragmentShader
parameter_list|,
name|VertexShader
modifier|*
name|vertexShader
parameter_list|)
block|{
name|std
operator|::
name|vector
argument_list|<
name|PackedVarying
argument_list|>
modifier|&
name|fragmentVaryings
init|=
name|fragmentShader
operator|->
name|getVaryings
argument_list|()
decl_stmt|;
name|std
operator|::
name|vector
argument_list|<
name|PackedVarying
argument_list|>
modifier|&
name|vertexVaryings
init|=
name|vertexShader
operator|->
name|getVaryings
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|fragVaryingIndex
init|=
literal|0
init|;
name|fragVaryingIndex
operator|<
name|fragmentVaryings
operator|.
name|size
argument_list|()
condition|;
name|fragVaryingIndex
operator|++
control|)
block|{
name|PackedVarying
modifier|*
name|input
init|=
operator|&
name|fragmentVaryings
index|[
name|fragVaryingIndex
index|]
decl_stmt|;
name|bool
name|matched
init|=
literal|false
decl_stmt|;
for|for
control|(
name|size_t
name|vertVaryingIndex
init|=
literal|0
init|;
name|vertVaryingIndex
operator|<
name|vertexVaryings
operator|.
name|size
argument_list|()
condition|;
name|vertVaryingIndex
operator|++
control|)
block|{
name|PackedVarying
modifier|*
name|output
init|=
operator|&
name|vertexVaryings
index|[
name|vertVaryingIndex
index|]
decl_stmt|;
if|if
condition|(
name|output
operator|->
name|name
operator|==
name|input
operator|->
name|name
condition|)
block|{
if|if
condition|(
operator|!
name|linkValidateVariables
argument_list|(
name|infoLog
argument_list|,
name|output
operator|->
name|name
argument_list|,
operator|*
name|input
argument_list|,
operator|*
name|output
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|output
operator|->
name|registerIndex
operator|=
name|input
operator|->
name|registerIndex
expr_stmt|;
name|matched
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|matched
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Fragment varying %s does not match any vertex varying"
argument_list|,
name|input
operator|->
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|load
name|bool
name|ProgramBinary
operator|::
name|load
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|void
modifier|*
name|binary
parameter_list|,
name|GLsizei
name|length
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ANGLE_DISABLE_PROGRAM_BINARY_LOAD
return|return
literal|false
return|;
else|#
directive|else
name|reset
argument_list|()
expr_stmt|;
name|BinaryInputStream
name|stream
argument_list|(
name|binary
argument_list|,
name|length
argument_list|)
decl_stmt|;
name|int
name|format
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|int
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|format
operator|!=
name|GL_PROGRAM_BINARY_ANGLE
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Invalid program binary format."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|int
name|majorVersion
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|int
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|minorVersion
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|int
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|majorVersion
operator|!=
name|ANGLE_MAJOR_VERSION
operator|||
name|minorVersion
operator|!=
name|ANGLE_MINOR_VERSION
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Invalid program binary version."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|unsigned
name|char
name|commitString
index|[
name|ANGLE_COMMIT_HASH_SIZE
index|]
decl_stmt|;
name|stream
operator|.
name|readBytes
argument_list|(
name|commitString
argument_list|,
name|ANGLE_COMMIT_HASH_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|commitString
argument_list|,
name|ANGLE_COMMIT_HASH
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
operator|*
name|ANGLE_COMMIT_HASH_SIZE
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Invalid program binary version."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|int
name|compileFlags
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|int
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|compileFlags
operator|!=
name|ANGLE_COMPILE_OPTIMIZATION_LEVEL
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Mismatched compilation flags."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
operator|++
name|i
control|)
block|{
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|mLinkedAttribute
index|[
name|i
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readString
argument_list|(
operator|&
name|mLinkedAttribute
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|mShaderAttributes
index|[
name|i
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readString
argument_list|(
operator|&
name|mShaderAttributes
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|mSemanticIndex
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|initAttributesByLayout
argument_list|()
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_TEXTURE_IMAGE_UNITS
condition|;
operator|++
name|i
control|)
block|{
name|stream
operator|.
name|readBool
argument_list|(
operator|&
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|active
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|logicalTextureUnit
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|textureType
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|IMPLEMENTATION_MAX_VERTEX_TEXTURE_IMAGE_UNITS
condition|;
operator|++
name|i
control|)
block|{
name|stream
operator|.
name|readBool
argument_list|(
operator|&
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|active
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|logicalTextureUnit
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|textureType
argument_list|)
expr_stmt|;
block|}
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|mUsedVertexSamplerRange
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|mUsedPixelSamplerRange
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readBool
argument_list|(
operator|&
name|mUsesPointSize
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|mShaderVersion
argument_list|)
expr_stmt|;
specifier|const
name|unsigned
name|int
name|uniformCount
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|stream
operator|.
name|error
argument_list|()
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Invalid program binary."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|mUniforms
operator|.
name|resize
argument_list|(
name|uniformCount
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|uniformIndex
init|=
literal|0
init|;
name|uniformIndex
operator|<
name|uniformCount
condition|;
name|uniformIndex
operator|++
control|)
block|{
name|GLenum
name|type
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|GLenum
argument_list|>
argument_list|()
decl_stmt|;
name|GLenum
name|precision
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|GLenum
argument_list|>
argument_list|()
decl_stmt|;
name|std
operator|::
name|string
name|name
init|=
name|stream
operator|.
name|readString
argument_list|()
decl_stmt|;
name|unsigned
name|int
name|arraySize
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|blockIndex
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|int
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|offset
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|int
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|arrayStride
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|int
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|matrixStride
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|int
argument_list|>
argument_list|()
decl_stmt|;
name|bool
name|isRowMajorMatrix
init|=
name|stream
operator|.
name|readBool
argument_list|()
decl_stmt|;
specifier|const
name|sh
operator|::
name|BlockMemberInfo
name|blockInfo
argument_list|(
name|offset
argument_list|,
name|arrayStride
argument_list|,
name|matrixStride
argument_list|,
name|isRowMajorMatrix
argument_list|)
decl_stmt|;
name|LinkedUniform
modifier|*
name|uniform
init|=
operator|new
name|LinkedUniform
argument_list|(
name|type
argument_list|,
name|precision
argument_list|,
name|name
argument_list|,
name|arraySize
argument_list|,
name|blockIndex
argument_list|,
name|blockInfo
argument_list|)
decl_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|uniform
operator|->
name|psRegisterIndex
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|uniform
operator|->
name|vsRegisterIndex
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|uniform
operator|->
name|registerCount
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|uniform
operator|->
name|registerElement
argument_list|)
expr_stmt|;
name|mUniforms
index|[
name|uniformIndex
index|]
operator|=
name|uniform
expr_stmt|;
block|}
name|unsigned
name|int
name|uniformBlockCount
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|stream
operator|.
name|error
argument_list|()
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Invalid program binary."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|mUniformBlocks
operator|.
name|resize
argument_list|(
name|uniformBlockCount
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|uniformBlockIndex
init|=
literal|0
init|;
name|uniformBlockIndex
operator|<
name|uniformBlockCount
condition|;
operator|++
name|uniformBlockIndex
control|)
block|{
name|std
operator|::
name|string
name|name
init|=
name|stream
operator|.
name|readString
argument_list|()
decl_stmt|;
name|unsigned
name|int
name|elementIndex
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
name|unsigned
name|int
name|dataSize
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
name|UniformBlock
modifier|*
name|uniformBlock
init|=
operator|new
name|UniformBlock
argument_list|(
name|name
argument_list|,
name|elementIndex
argument_list|,
name|dataSize
argument_list|)
decl_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|uniformBlock
operator|->
name|psRegisterIndex
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|uniformBlock
operator|->
name|vsRegisterIndex
argument_list|)
expr_stmt|;
name|unsigned
name|int
name|numMembers
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
name|uniformBlock
operator|->
name|memberUniformIndexes
operator|.
name|resize
argument_list|(
name|numMembers
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|blockMemberIndex
init|=
literal|0
init|;
name|blockMemberIndex
operator|<
name|numMembers
condition|;
name|blockMemberIndex
operator|++
control|)
block|{
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|uniformBlock
operator|->
name|memberUniformIndexes
index|[
name|blockMemberIndex
index|]
argument_list|)
expr_stmt|;
block|}
name|mUniformBlocks
index|[
name|uniformBlockIndex
index|]
operator|=
name|uniformBlock
expr_stmt|;
block|}
specifier|const
name|unsigned
name|int
name|uniformIndexCount
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|stream
operator|.
name|error
argument_list|()
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Invalid program binary."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|mUniformIndex
operator|.
name|resize
argument_list|(
name|uniformIndexCount
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|uniformIndexIndex
init|=
literal|0
init|;
name|uniformIndexIndex
operator|<
name|uniformIndexCount
condition|;
name|uniformIndexIndex
operator|++
control|)
block|{
name|stream
operator|.
name|readString
argument_list|(
operator|&
name|mUniformIndex
index|[
name|uniformIndexIndex
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|mUniformIndex
index|[
name|uniformIndexIndex
index|]
operator|.
name|element
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|mUniformIndex
index|[
name|uniformIndexIndex
index|]
operator|.
name|index
argument_list|)
expr_stmt|;
block|}
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|mTransformFeedbackBufferMode
argument_list|)
expr_stmt|;
specifier|const
name|unsigned
name|int
name|transformFeedbackVaryingCount
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
name|mTransformFeedbackLinkedVaryings
operator|.
name|resize
argument_list|(
name|transformFeedbackVaryingCount
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|varyingIndex
init|=
literal|0
init|;
name|varyingIndex
operator|<
name|transformFeedbackVaryingCount
condition|;
name|varyingIndex
operator|++
control|)
block|{
name|LinkedVarying
modifier|&
name|varying
init|=
name|mTransformFeedbackLinkedVaryings
index|[
name|varyingIndex
index|]
decl_stmt|;
name|stream
operator|.
name|readString
argument_list|(
operator|&
name|varying
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|varying
operator|.
name|type
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|varying
operator|.
name|size
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readString
argument_list|(
operator|&
name|varying
operator|.
name|semanticName
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|varying
operator|.
name|semanticIndex
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|varying
operator|.
name|semanticIndexCount
argument_list|)
expr_stmt|;
block|}
name|stream
operator|.
name|readString
argument_list|(
operator|&
name|mVertexHLSL
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|mVertexWorkarounds
argument_list|)
expr_stmt|;
specifier|const
name|unsigned
name|int
name|vertexShaderCount
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|vertexShaderIndex
init|=
literal|0
init|;
name|vertexShaderIndex
operator|<
name|vertexShaderCount
condition|;
name|vertexShaderIndex
operator|++
control|)
block|{
name|VertexFormat
name|inputLayout
index|[
name|MAX_VERTEX_ATTRIBS
index|]
decl_stmt|;
for|for
control|(
name|size_t
name|inputIndex
init|=
literal|0
init|;
name|inputIndex
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|inputIndex
operator|++
control|)
block|{
name|VertexFormat
modifier|*
name|vertexInput
init|=
operator|&
name|inputLayout
index|[
name|inputIndex
index|]
decl_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|vertexInput
operator|->
name|mType
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|vertexInput
operator|->
name|mNormalized
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|vertexInput
operator|->
name|mComponents
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readBool
argument_list|(
operator|&
name|vertexInput
operator|->
name|mPureInteger
argument_list|)
expr_stmt|;
block|}
name|unsigned
name|int
name|vertexShaderSize
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|vertexShaderFunction
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|binary
argument_list|)
operator|+
name|stream
operator|.
name|offset
argument_list|()
decl_stmt|;
name|rx
operator|::
name|ShaderExecutable
modifier|*
name|shaderExecutable
init|=
name|mRenderer
operator|->
name|loadExecutable
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|DWORD
operator|*
argument_list|>
argument_list|(
name|vertexShaderFunction
argument_list|)
argument_list|,
name|vertexShaderSize
argument_list|,
name|rx
operator|::
name|SHADER_VERTEX
argument_list|,
name|mTransformFeedbackLinkedVaryings
argument_list|,
operator|(
name|mTransformFeedbackBufferMode
operator|==
name|GL_SEPARATE_ATTRIBS
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|shaderExecutable
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Could not create vertex shader."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// generated converted input layout
name|GLenum
name|signature
index|[
name|MAX_VERTEX_ATTRIBS
index|]
decl_stmt|;
name|mDynamicHLSL
operator|->
name|getInputLayoutSignature
argument_list|(
name|inputLayout
argument_list|,
name|signature
argument_list|)
expr_stmt|;
comment|// add new binary
name|mVertexExecutables
operator|.
name|push_back
argument_list|(
operator|new
name|VertexExecutable
argument_list|(
name|inputLayout
argument_list|,
name|signature
argument_list|,
name|shaderExecutable
argument_list|)
argument_list|)
expr_stmt|;
name|stream
operator|.
name|skip
argument_list|(
name|vertexShaderSize
argument_list|)
expr_stmt|;
block|}
name|stream
operator|.
name|readString
argument_list|(
operator|&
name|mPixelHLSL
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|mPixelWorkarounds
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readBool
argument_list|(
operator|&
name|mUsesFragDepth
argument_list|)
expr_stmt|;
specifier|const
name|size_t
name|pixelShaderKeySize
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
name|mPixelShaderKey
operator|.
name|resize
argument_list|(
name|pixelShaderKeySize
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|pixelShaderKeyIndex
init|=
literal|0
init|;
name|pixelShaderKeyIndex
operator|<
name|pixelShaderKeySize
condition|;
name|pixelShaderKeyIndex
operator|++
control|)
block|{
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|mPixelShaderKey
index|[
name|pixelShaderKeyIndex
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readString
argument_list|(
operator|&
name|mPixelShaderKey
index|[
name|pixelShaderKeyIndex
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readString
argument_list|(
operator|&
name|mPixelShaderKey
index|[
name|pixelShaderKeyIndex
index|]
operator|.
name|source
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|mPixelShaderKey
index|[
name|pixelShaderKeyIndex
index|]
operator|.
name|outputIndex
argument_list|)
expr_stmt|;
block|}
specifier|const
name|size_t
name|pixelShaderCount
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|pixelShaderIndex
init|=
literal|0
init|;
name|pixelShaderIndex
operator|<
name|pixelShaderCount
condition|;
name|pixelShaderIndex
operator|++
control|)
block|{
specifier|const
name|size_t
name|outputCount
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
name|std
operator|::
name|vector
argument_list|<
name|GLenum
argument_list|>
name|outputs
argument_list|(
name|outputCount
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|outputIndex
init|=
literal|0
init|;
name|outputIndex
operator|<
name|outputCount
condition|;
name|outputIndex
operator|++
control|)
block|{
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|outputs
index|[
name|outputIndex
index|]
argument_list|)
expr_stmt|;
block|}
specifier|const
name|size_t
name|pixelShaderSize
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|pixelShaderFunction
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|binary
argument_list|)
operator|+
name|stream
operator|.
name|offset
argument_list|()
decl_stmt|;
name|rx
operator|::
name|ShaderExecutable
modifier|*
name|shaderExecutable
init|=
name|mRenderer
operator|->
name|loadExecutable
argument_list|(
name|pixelShaderFunction
argument_list|,
name|pixelShaderSize
argument_list|,
name|rx
operator|::
name|SHADER_PIXEL
argument_list|,
name|mTransformFeedbackLinkedVaryings
argument_list|,
operator|(
name|mTransformFeedbackBufferMode
operator|==
name|GL_SEPARATE_ATTRIBS
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|shaderExecutable
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Could not create pixel shader."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// add new binary
name|mPixelExecutables
operator|.
name|push_back
argument_list|(
operator|new
name|PixelExecutable
argument_list|(
name|outputs
argument_list|,
name|shaderExecutable
argument_list|)
argument_list|)
expr_stmt|;
name|stream
operator|.
name|skip
argument_list|(
name|pixelShaderSize
argument_list|)
expr_stmt|;
block|}
name|unsigned
name|int
name|geometryShaderSize
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|geometryShaderSize
operator|>
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|geometryShaderFunction
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|binary
operator|+
name|stream
operator|.
name|offset
argument_list|()
decl_stmt|;
name|mGeometryExecutable
operator|=
name|mRenderer
operator|->
name|loadExecutable
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|DWORD
operator|*
argument_list|>
argument_list|(
name|geometryShaderFunction
argument_list|)
argument_list|,
name|geometryShaderSize
argument_list|,
name|rx
operator|::
name|SHADER_GEOMETRY
argument_list|,
name|mTransformFeedbackLinkedVaryings
argument_list|,
operator|(
name|mTransformFeedbackBufferMode
operator|==
name|GL_SEPARATE_ATTRIBS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mGeometryExecutable
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Could not create geometry shader."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|stream
operator|.
name|skip
argument_list|(
name|geometryShaderSize
argument_list|)
expr_stmt|;
block|}
specifier|const
name|char
modifier|*
name|ptr
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|binary
operator|+
name|stream
operator|.
name|offset
argument_list|()
decl_stmt|;
specifier|const
name|GUID
modifier|*
name|binaryIdentifier
init|=
operator|(
specifier|const
name|GUID
operator|*
operator|)
name|ptr
decl_stmt|;
name|ptr
operator|+=
sizeof|sizeof
argument_list|(
name|GUID
argument_list|)
expr_stmt|;
name|GUID
name|identifier
init|=
name|mRenderer
operator|->
name|getAdapterIdentifier
argument_list|()
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|identifier
argument_list|,
name|binaryIdentifier
argument_list|,
sizeof|sizeof
argument_list|(
name|GUID
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Invalid program binary."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|initializeUniformStorage
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
endif|#
directive|endif
comment|// #ifdef ANGLE_DISABLE_PROGRAM_BINARY_LOAD
block|}
DECL|function|save
name|bool
name|ProgramBinary
operator|::
name|save
parameter_list|(
name|void
modifier|*
name|binary
parameter_list|,
name|GLsizei
name|bufSize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|)
block|{
name|BinaryOutputStream
name|stream
decl_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|GL_PROGRAM_BINARY_ANGLE
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|ANGLE_MAJOR_VERSION
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|ANGLE_MINOR_VERSION
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeBytes
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|ANGLE_COMMIT_HASH
argument_list|)
argument_list|,
name|ANGLE_COMMIT_HASH_SIZE
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|ANGLE_COMPILE_OPTIMIZATION_LEVEL
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
operator|++
name|i
control|)
block|{
name|stream
operator|.
name|writeInt
argument_list|(
name|mLinkedAttribute
index|[
name|i
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeString
argument_list|(
name|mLinkedAttribute
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|mShaderAttributes
index|[
name|i
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeString
argument_list|(
name|mShaderAttributes
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|mSemanticIndex
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_TEXTURE_IMAGE_UNITS
condition|;
operator|++
name|i
control|)
block|{
name|stream
operator|.
name|writeInt
argument_list|(
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|active
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|logicalTextureUnit
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|textureType
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|IMPLEMENTATION_MAX_VERTEX_TEXTURE_IMAGE_UNITS
condition|;
operator|++
name|i
control|)
block|{
name|stream
operator|.
name|writeInt
argument_list|(
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|active
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|logicalTextureUnit
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|textureType
argument_list|)
expr_stmt|;
block|}
name|stream
operator|.
name|writeInt
argument_list|(
name|mUsedVertexSamplerRange
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|mUsedPixelSamplerRange
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|mUsesPointSize
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|mShaderVersion
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|mUniforms
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|uniformIndex
init|=
literal|0
init|;
name|uniformIndex
operator|<
name|mUniforms
operator|.
name|size
argument_list|()
condition|;
operator|++
name|uniformIndex
control|)
block|{
specifier|const
name|LinkedUniform
modifier|&
name|uniform
init|=
operator|*
name|mUniforms
index|[
name|uniformIndex
index|]
decl_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|uniform
operator|.
name|type
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|uniform
operator|.
name|precision
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeString
argument_list|(
name|uniform
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|uniform
operator|.
name|arraySize
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|uniform
operator|.
name|blockIndex
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|uniform
operator|.
name|blockInfo
operator|.
name|offset
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|uniform
operator|.
name|blockInfo
operator|.
name|arrayStride
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|uniform
operator|.
name|blockInfo
operator|.
name|matrixStride
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|uniform
operator|.
name|blockInfo
operator|.
name|isRowMajorMatrix
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|uniform
operator|.
name|psRegisterIndex
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|uniform
operator|.
name|vsRegisterIndex
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|uniform
operator|.
name|registerCount
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|uniform
operator|.
name|registerElement
argument_list|)
expr_stmt|;
block|}
name|stream
operator|.
name|writeInt
argument_list|(
name|mUniformBlocks
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|uniformBlockIndex
init|=
literal|0
init|;
name|uniformBlockIndex
operator|<
name|mUniformBlocks
operator|.
name|size
argument_list|()
condition|;
operator|++
name|uniformBlockIndex
control|)
block|{
specifier|const
name|UniformBlock
modifier|&
name|uniformBlock
init|=
operator|*
name|mUniformBlocks
index|[
name|uniformBlockIndex
index|]
decl_stmt|;
name|stream
operator|.
name|writeString
argument_list|(
name|uniformBlock
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|uniformBlock
operator|.
name|elementIndex
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|uniformBlock
operator|.
name|dataSize
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|uniformBlock
operator|.
name|memberUniformIndexes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|blockMemberIndex
init|=
literal|0
init|;
name|blockMemberIndex
operator|<
name|uniformBlock
operator|.
name|memberUniformIndexes
operator|.
name|size
argument_list|()
condition|;
name|blockMemberIndex
operator|++
control|)
block|{
name|stream
operator|.
name|writeInt
argument_list|(
name|uniformBlock
operator|.
name|memberUniformIndexes
index|[
name|blockMemberIndex
index|]
argument_list|)
expr_stmt|;
block|}
name|stream
operator|.
name|writeInt
argument_list|(
name|uniformBlock
operator|.
name|psRegisterIndex
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|uniformBlock
operator|.
name|vsRegisterIndex
argument_list|)
expr_stmt|;
block|}
name|stream
operator|.
name|writeInt
argument_list|(
name|mUniformIndex
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mUniformIndex
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|stream
operator|.
name|writeString
argument_list|(
name|mUniformIndex
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|mUniformIndex
index|[
name|i
index|]
operator|.
name|element
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|mUniformIndex
index|[
name|i
index|]
operator|.
name|index
argument_list|)
expr_stmt|;
block|}
name|stream
operator|.
name|writeInt
argument_list|(
name|mTransformFeedbackBufferMode
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|mTransformFeedbackLinkedVaryings
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mTransformFeedbackLinkedVaryings
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|LinkedVarying
modifier|&
name|varying
init|=
name|mTransformFeedbackLinkedVaryings
index|[
name|i
index|]
decl_stmt|;
name|stream
operator|.
name|writeString
argument_list|(
name|varying
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|varying
operator|.
name|type
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|varying
operator|.
name|size
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeString
argument_list|(
name|varying
operator|.
name|semanticName
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|varying
operator|.
name|semanticIndex
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|varying
operator|.
name|semanticIndexCount
argument_list|)
expr_stmt|;
block|}
name|stream
operator|.
name|writeString
argument_list|(
name|mVertexHLSL
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|mVertexWorkarounds
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|mVertexExecutables
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|vertexExecutableIndex
init|=
literal|0
init|;
name|vertexExecutableIndex
operator|<
name|mVertexExecutables
operator|.
name|size
argument_list|()
condition|;
name|vertexExecutableIndex
operator|++
control|)
block|{
name|VertexExecutable
modifier|*
name|vertexExecutable
init|=
name|mVertexExecutables
index|[
name|vertexExecutableIndex
index|]
decl_stmt|;
for|for
control|(
name|size_t
name|inputIndex
init|=
literal|0
init|;
name|inputIndex
operator|<
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
condition|;
name|inputIndex
operator|++
control|)
block|{
specifier|const
name|VertexFormat
modifier|&
name|vertexInput
init|=
name|vertexExecutable
operator|->
name|inputs
argument_list|()
index|[
name|inputIndex
index|]
decl_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|vertexInput
operator|.
name|mType
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|vertexInput
operator|.
name|mNormalized
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|vertexInput
operator|.
name|mComponents
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|vertexInput
operator|.
name|mPureInteger
argument_list|)
expr_stmt|;
block|}
name|size_t
name|vertexShaderSize
init|=
name|vertexExecutable
operator|->
name|shaderExecutable
argument_list|()
operator|->
name|getLength
argument_list|()
decl_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|vertexShaderSize
argument_list|)
expr_stmt|;
specifier|const
name|uint8_t
modifier|*
name|vertexBlob
init|=
name|vertexExecutable
operator|->
name|shaderExecutable
argument_list|()
operator|->
name|getFunction
argument_list|()
decl_stmt|;
name|stream
operator|.
name|writeBytes
argument_list|(
name|vertexBlob
argument_list|,
name|vertexShaderSize
argument_list|)
expr_stmt|;
block|}
name|stream
operator|.
name|writeString
argument_list|(
name|mPixelHLSL
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|mPixelWorkarounds
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|mUsesFragDepth
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|mPixelShaderKey
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|pixelShaderKeyIndex
init|=
literal|0
init|;
name|pixelShaderKeyIndex
operator|<
name|mPixelShaderKey
operator|.
name|size
argument_list|()
condition|;
name|pixelShaderKeyIndex
operator|++
control|)
block|{
specifier|const
name|PixelShaderOuputVariable
modifier|&
name|variable
init|=
name|mPixelShaderKey
index|[
name|pixelShaderKeyIndex
index|]
decl_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|variable
operator|.
name|type
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeString
argument_list|(
name|variable
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeString
argument_list|(
name|variable
operator|.
name|source
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|variable
operator|.
name|outputIndex
argument_list|)
expr_stmt|;
block|}
name|stream
operator|.
name|writeInt
argument_list|(
name|mPixelExecutables
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|pixelExecutableIndex
init|=
literal|0
init|;
name|pixelExecutableIndex
operator|<
name|mPixelExecutables
operator|.
name|size
argument_list|()
condition|;
name|pixelExecutableIndex
operator|++
control|)
block|{
name|PixelExecutable
modifier|*
name|pixelExecutable
init|=
name|mPixelExecutables
index|[
name|pixelExecutableIndex
index|]
decl_stmt|;
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|GLenum
argument_list|>
name|outputs
init|=
name|pixelExecutable
operator|->
name|outputSignature
argument_list|()
decl_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|outputs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|outputIndex
init|=
literal|0
init|;
name|outputIndex
operator|<
name|outputs
operator|.
name|size
argument_list|()
condition|;
name|outputIndex
operator|++
control|)
block|{
name|stream
operator|.
name|writeInt
argument_list|(
name|outputs
index|[
name|outputIndex
index|]
argument_list|)
expr_stmt|;
block|}
name|size_t
name|pixelShaderSize
init|=
name|pixelExecutable
operator|->
name|shaderExecutable
argument_list|()
operator|->
name|getLength
argument_list|()
decl_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|pixelShaderSize
argument_list|)
expr_stmt|;
specifier|const
name|uint8_t
modifier|*
name|pixelBlob
init|=
name|pixelExecutable
operator|->
name|shaderExecutable
argument_list|()
operator|->
name|getFunction
argument_list|()
decl_stmt|;
name|stream
operator|.
name|writeBytes
argument_list|(
name|pixelBlob
argument_list|,
name|pixelShaderSize
argument_list|)
expr_stmt|;
block|}
name|size_t
name|geometryShaderSize
init|=
operator|(
name|mGeometryExecutable
operator|!=
name|NULL
operator|)
condition|?
name|mGeometryExecutable
operator|->
name|getLength
argument_list|()
else|:
literal|0
decl_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|geometryShaderSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|mGeometryExecutable
operator|!=
name|NULL
operator|&&
name|geometryShaderSize
operator|>
literal|0
condition|)
block|{
specifier|const
name|uint8_t
modifier|*
name|geometryBlob
init|=
name|mGeometryExecutable
operator|->
name|getFunction
argument_list|()
decl_stmt|;
name|stream
operator|.
name|writeBytes
argument_list|(
name|geometryBlob
argument_list|,
name|geometryShaderSize
argument_list|)
expr_stmt|;
block|}
name|GUID
name|identifier
init|=
name|mRenderer
operator|->
name|getAdapterIdentifier
argument_list|()
decl_stmt|;
name|GLsizei
name|streamLength
init|=
name|stream
operator|.
name|length
argument_list|()
decl_stmt|;
specifier|const
name|void
modifier|*
name|streamData
init|=
name|stream
operator|.
name|data
argument_list|()
decl_stmt|;
name|GLsizei
name|totalLength
init|=
name|streamLength
operator|+
sizeof|sizeof
argument_list|(
name|GUID
argument_list|)
decl_stmt|;
if|if
condition|(
name|totalLength
operator|>
name|bufSize
condition|)
block|{
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
if|if
condition|(
name|binary
condition|)
block|{
name|char
modifier|*
name|ptr
init|=
operator|(
name|char
operator|*
operator|)
name|binary
decl_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
name|streamData
argument_list|,
name|streamLength
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|streamLength
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
operator|&
name|identifier
argument_list|,
sizeof|sizeof
argument_list|(
name|GUID
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|+=
sizeof|sizeof
argument_list|(
name|GUID
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ptr
operator|-
name|totalLength
operator|==
name|binary
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
name|totalLength
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|getLength
name|GLint
name|ProgramBinary
operator|::
name|getLength
parameter_list|()
block|{
name|GLint
name|length
decl_stmt|;
if|if
condition|(
name|save
argument_list|(
name|NULL
argument_list|,
name|INT_MAX
argument_list|,
operator|&
name|length
argument_list|)
condition|)
block|{
return|return
name|length
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
DECL|function|link
name|bool
name|ProgramBinary
operator|::
name|link
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|AttributeBindings
modifier|&
name|attributeBindings
parameter_list|,
name|FragmentShader
modifier|*
name|fragmentShader
parameter_list|,
name|VertexShader
modifier|*
name|vertexShader
parameter_list|,
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|std
operator|::
name|string
argument_list|>
modifier|&
name|transformFeedbackVaryings
parameter_list|,
name|GLenum
name|transformFeedbackBufferMode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|fragmentShader
operator|||
operator|!
name|fragmentShader
operator|->
name|isCompiled
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|vertexShader
operator|||
operator|!
name|vertexShader
operator|->
name|isCompiled
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|reset
argument_list|()
expr_stmt|;
name|mTransformFeedbackBufferMode
operator|=
name|transformFeedbackBufferMode
expr_stmt|;
name|mShaderVersion
operator|=
name|vertexShader
operator|->
name|getShaderVersion
argument_list|()
expr_stmt|;
name|mPixelHLSL
operator|=
name|fragmentShader
operator|->
name|getHLSL
argument_list|()
expr_stmt|;
name|mPixelWorkarounds
operator|=
name|fragmentShader
operator|->
name|getD3DWorkarounds
argument_list|()
expr_stmt|;
name|mVertexHLSL
operator|=
name|vertexShader
operator|->
name|getHLSL
argument_list|()
expr_stmt|;
name|mVertexWorkarounds
operator|=
name|vertexShader
operator|->
name|getD3DWorkarounds
argument_list|()
expr_stmt|;
comment|// Map the varyings to the register file
name|VaryingPacking
name|packing
init|=
block|{
name|NULL
block|}
decl_stmt|;
name|int
name|registers
init|=
name|mDynamicHLSL
operator|->
name|packVaryings
argument_list|(
name|infoLog
argument_list|,
name|packing
argument_list|,
name|fragmentShader
argument_list|,
name|vertexShader
argument_list|,
name|transformFeedbackVaryings
argument_list|)
decl_stmt|;
if|if
condition|(
name|registers
operator|<
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|linkVaryings
argument_list|(
name|infoLog
argument_list|,
name|fragmentShader
argument_list|,
name|vertexShader
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|mUsesPointSize
operator|=
name|vertexShader
operator|->
name|usesPointSize
argument_list|()
expr_stmt|;
name|std
operator|::
name|vector
argument_list|<
name|LinkedVarying
argument_list|>
name|linkedVaryings
decl_stmt|;
if|if
condition|(
operator|!
name|mDynamicHLSL
operator|->
name|generateShaderLinkHLSL
argument_list|(
name|infoLog
argument_list|,
name|registers
argument_list|,
name|packing
argument_list|,
name|mPixelHLSL
argument_list|,
name|mVertexHLSL
argument_list|,
name|fragmentShader
argument_list|,
name|vertexShader
argument_list|,
name|transformFeedbackVaryings
argument_list|,
operator|&
name|linkedVaryings
argument_list|,
operator|&
name|mOutputVariables
argument_list|,
operator|&
name|mPixelShaderKey
argument_list|,
operator|&
name|mUsesFragDepth
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|bool
name|success
init|=
literal|true
decl_stmt|;
if|if
condition|(
operator|!
name|linkAttributes
argument_list|(
name|infoLog
argument_list|,
name|attributeBindings
argument_list|,
name|fragmentShader
argument_list|,
name|vertexShader
argument_list|)
condition|)
block|{
name|success
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|linkUniforms
argument_list|(
name|infoLog
argument_list|,
operator|*
name|vertexShader
argument_list|,
operator|*
name|fragmentShader
argument_list|)
condition|)
block|{
name|success
operator|=
literal|false
expr_stmt|;
block|}
comment|// special case for gl_DepthRange, the only built-in uniform (also a struct)
if|if
condition|(
name|vertexShader
operator|->
name|usesDepthRange
argument_list|()
operator|||
name|fragmentShader
operator|->
name|usesDepthRange
argument_list|()
condition|)
block|{
specifier|const
name|sh
operator|::
name|BlockMemberInfo
modifier|&
name|defaultInfo
init|=
name|sh
operator|::
name|BlockMemberInfo
operator|::
name|getDefaultBlockInfo
argument_list|()
decl_stmt|;
name|mUniforms
operator|.
name|push_back
argument_list|(
operator|new
name|LinkedUniform
argument_list|(
name|GL_FLOAT
argument_list|,
name|GL_HIGH_FLOAT
argument_list|,
literal|"gl_DepthRange.near"
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|defaultInfo
argument_list|)
argument_list|)
expr_stmt|;
name|mUniforms
operator|.
name|push_back
argument_list|(
operator|new
name|LinkedUniform
argument_list|(
name|GL_FLOAT
argument_list|,
name|GL_HIGH_FLOAT
argument_list|,
literal|"gl_DepthRange.far"
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|defaultInfo
argument_list|)
argument_list|)
expr_stmt|;
name|mUniforms
operator|.
name|push_back
argument_list|(
operator|new
name|LinkedUniform
argument_list|(
name|GL_FLOAT
argument_list|,
name|GL_HIGH_FLOAT
argument_list|,
literal|"gl_DepthRange.diff"
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|defaultInfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|linkUniformBlocks
argument_list|(
name|infoLog
argument_list|,
operator|*
name|vertexShader
argument_list|,
operator|*
name|fragmentShader
argument_list|)
condition|)
block|{
name|success
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|gatherTransformFeedbackLinkedVaryings
argument_list|(
name|infoLog
argument_list|,
name|linkedVaryings
argument_list|,
name|transformFeedbackVaryings
argument_list|,
name|transformFeedbackBufferMode
argument_list|,
operator|&
name|mTransformFeedbackLinkedVaryings
argument_list|)
condition|)
block|{
name|success
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
name|VertexFormat
name|defaultInputLayout
index|[
name|MAX_VERTEX_ATTRIBS
index|]
decl_stmt|;
name|GetInputLayoutFromShader
argument_list|(
name|vertexShader
operator|->
name|activeAttributes
argument_list|()
argument_list|,
name|defaultInputLayout
argument_list|)
expr_stmt|;
name|rx
operator|::
name|ShaderExecutable
modifier|*
name|defaultVertexExecutable
init|=
name|getVertexExecutableForInputLayout
argument_list|(
name|defaultInputLayout
argument_list|)
decl_stmt|;
name|std
operator|::
name|vector
argument_list|<
name|GLenum
argument_list|>
name|defaultPixelOutput
argument_list|(
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|defaultPixelOutput
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|defaultPixelOutput
index|[
name|i
index|]
operator|=
operator|(
name|i
operator|==
literal|0
operator|)
condition|?
name|GL_FLOAT
else|:
name|GL_NONE
expr_stmt|;
block|}
name|rx
operator|::
name|ShaderExecutable
modifier|*
name|defaultPixelExecutable
init|=
name|getPixelExecutableForOutputLayout
argument_list|(
name|defaultPixelOutput
argument_list|)
decl_stmt|;
if|if
condition|(
name|usesGeometryShader
argument_list|()
condition|)
block|{
name|std
operator|::
name|string
name|geometryHLSL
init|=
name|mDynamicHLSL
operator|->
name|generateGeometryShaderHLSL
argument_list|(
name|registers
argument_list|,
name|fragmentShader
argument_list|,
name|vertexShader
argument_list|)
decl_stmt|;
name|mGeometryExecutable
operator|=
name|mRenderer
operator|->
name|compileToExecutable
argument_list|(
name|infoLog
argument_list|,
name|geometryHLSL
operator|.
name|c_str
argument_list|()
argument_list|,
name|rx
operator|::
name|SHADER_GEOMETRY
argument_list|,
name|mTransformFeedbackLinkedVaryings
argument_list|,
operator|(
name|mTransformFeedbackBufferMode
operator|==
name|GL_SEPARATE_ATTRIBS
operator|)
argument_list|,
name|rx
operator|::
name|ANGLE_D3D_WORKAROUND_NONE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|defaultVertexExecutable
operator|||
operator|!
name|defaultPixelExecutable
operator|||
operator|(
name|usesGeometryShader
argument_list|()
operator|&&
operator|!
name|mGeometryExecutable
operator|)
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Failed to create D3D shaders."
argument_list|)
expr_stmt|;
name|success
operator|=
literal|false
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|success
return|;
block|}
comment|// Determines the mapping between GL attributes and Direct3D 9 vertex stream usage indices
DECL|function|linkAttributes
name|bool
name|ProgramBinary
operator|::
name|linkAttributes
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|AttributeBindings
modifier|&
name|attributeBindings
parameter_list|,
name|FragmentShader
modifier|*
name|fragmentShader
parameter_list|,
name|VertexShader
modifier|*
name|vertexShader
parameter_list|)
block|{
name|unsigned
name|int
name|usedLocations
init|=
literal|0
decl_stmt|;
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|Attribute
argument_list|>
modifier|&
name|activeAttributes
init|=
name|vertexShader
operator|->
name|activeAttributes
argument_list|()
decl_stmt|;
comment|// Link attributes that have a binding location
for|for
control|(
name|unsigned
name|int
name|attributeIndex
init|=
literal|0
init|;
name|attributeIndex
operator|<
name|activeAttributes
operator|.
name|size
argument_list|()
condition|;
name|attributeIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|Attribute
modifier|&
name|attribute
init|=
name|activeAttributes
index|[
name|attributeIndex
index|]
decl_stmt|;
specifier|const
name|int
name|location
init|=
name|attribute
operator|.
name|location
operator|==
operator|-
literal|1
condition|?
name|attributeBindings
operator|.
name|getAttributeBinding
argument_list|(
name|attribute
operator|.
name|name
argument_list|)
else|:
name|attribute
operator|.
name|location
decl_stmt|;
name|mShaderAttributes
index|[
name|attributeIndex
index|]
operator|=
name|attribute
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
comment|// Set by glBindAttribLocation or by location layout qualifier
block|{
specifier|const
name|int
name|rows
init|=
name|VariableRegisterCount
argument_list|(
name|attribute
operator|.
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|rows
operator|+
name|location
operator|>
name|MAX_VERTEX_ATTRIBS
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Active attribute (%s) at location %d is too big to fit"
argument_list|,
name|attribute
operator|.
name|name
operator|.
name|c_str
argument_list|()
argument_list|,
name|location
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|row
init|=
literal|0
init|;
name|row
operator|<
name|rows
condition|;
name|row
operator|++
control|)
block|{
specifier|const
name|int
name|rowLocation
init|=
name|location
operator|+
name|row
decl_stmt|;
name|sh
operator|::
name|ShaderVariable
modifier|&
name|linkedAttribute
init|=
name|mLinkedAttribute
index|[
name|rowLocation
index|]
decl_stmt|;
comment|// In GLSL 3.00, attribute aliasing produces a link error
comment|// In GLSL 1.00, attribute aliasing is allowed
if|if
condition|(
name|mShaderVersion
operator|>=
literal|300
condition|)
block|{
if|if
condition|(
operator|!
name|linkedAttribute
operator|.
name|name
operator|.
name|empty
argument_list|()
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Attribute '%s' aliases attribute '%s' at location %d"
argument_list|,
name|attribute
operator|.
name|name
operator|.
name|c_str
argument_list|()
argument_list|,
name|linkedAttribute
operator|.
name|name
operator|.
name|c_str
argument_list|()
argument_list|,
name|rowLocation
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|linkedAttribute
operator|=
name|attribute
expr_stmt|;
name|usedLocations
operator||=
literal|1
operator|<<
name|rowLocation
expr_stmt|;
block|}
block|}
block|}
comment|// Link attributes that don't have a binding location
for|for
control|(
name|unsigned
name|int
name|attributeIndex
init|=
literal|0
init|;
name|attributeIndex
operator|<
name|activeAttributes
operator|.
name|size
argument_list|()
condition|;
name|attributeIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|Attribute
modifier|&
name|attribute
init|=
name|activeAttributes
index|[
name|attributeIndex
index|]
decl_stmt|;
specifier|const
name|int
name|location
init|=
name|attribute
operator|.
name|location
operator|==
operator|-
literal|1
condition|?
name|attributeBindings
operator|.
name|getAttributeBinding
argument_list|(
name|attribute
operator|.
name|name
argument_list|)
else|:
name|attribute
operator|.
name|location
decl_stmt|;
if|if
condition|(
name|location
operator|==
operator|-
literal|1
condition|)
comment|// Not set by glBindAttribLocation or by location layout qualifier
block|{
name|int
name|rows
init|=
name|VariableRegisterCount
argument_list|(
name|attribute
operator|.
name|type
argument_list|)
decl_stmt|;
name|int
name|availableIndex
init|=
name|AllocateFirstFreeBits
argument_list|(
operator|&
name|usedLocations
argument_list|,
name|rows
argument_list|,
name|MAX_VERTEX_ATTRIBS
argument_list|)
decl_stmt|;
if|if
condition|(
name|availableIndex
operator|==
operator|-
literal|1
operator|||
name|availableIndex
operator|+
name|rows
operator|>
name|MAX_VERTEX_ATTRIBS
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Too many active attributes (%s)"
argument_list|,
name|attribute
operator|.
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
comment|// Fail to link
block|}
name|mLinkedAttribute
index|[
name|availableIndex
index|]
operator|=
name|attribute
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|attributeIndex
init|=
literal|0
init|;
name|attributeIndex
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
control|)
block|{
name|int
name|index
init|=
name|vertexShader
operator|->
name|getSemanticIndex
argument_list|(
name|mLinkedAttribute
index|[
name|attributeIndex
index|]
operator|.
name|name
argument_list|)
decl_stmt|;
name|int
name|rows
init|=
name|VariableRegisterCount
argument_list|(
name|mLinkedAttribute
index|[
name|attributeIndex
index|]
operator|.
name|type
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|r
init|=
literal|0
init|;
name|r
operator|<
name|rows
condition|;
name|r
operator|++
control|)
block|{
name|mSemanticIndex
index|[
name|attributeIndex
operator|++
index|]
operator|=
name|index
operator|++
expr_stmt|;
block|}
block|}
name|initAttributesByLayout
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|linkValidateVariablesBase
name|bool
name|ProgramBinary
operator|::
name|linkValidateVariablesBase
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|variableName
parameter_list|,
specifier|const
name|sh
operator|::
name|ShaderVariable
modifier|&
name|vertexVariable
parameter_list|,
specifier|const
name|sh
operator|::
name|ShaderVariable
modifier|&
name|fragmentVariable
parameter_list|,
name|bool
name|validatePrecision
parameter_list|)
block|{
if|if
condition|(
name|vertexVariable
operator|.
name|type
operator|!=
name|fragmentVariable
operator|.
name|type
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Types for %s differ between vertex and fragment shaders"
argument_list|,
name|variableName
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|vertexVariable
operator|.
name|arraySize
operator|!=
name|fragmentVariable
operator|.
name|arraySize
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Array sizes for %s differ between vertex and fragment shaders"
argument_list|,
name|variableName
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|validatePrecision
operator|&&
name|vertexVariable
operator|.
name|precision
operator|!=
name|fragmentVariable
operator|.
name|precision
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Precisions for %s differ between vertex and fragment shaders"
argument_list|,
name|variableName
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
template|template
parameter_list|<
name|class
name|ShaderVarType
parameter_list|>
DECL|function|linkValidateFields
name|bool
name|ProgramBinary
operator|::
name|linkValidateFields
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|varName
parameter_list|,
specifier|const
name|ShaderVarType
modifier|&
name|vertexVar
parameter_list|,
specifier|const
name|ShaderVarType
modifier|&
name|fragmentVar
parameter_list|)
block|{
if|if
condition|(
name|vertexVar
operator|.
name|fields
operator|.
name|size
argument_list|()
operator|!=
name|fragmentVar
operator|.
name|fields
operator|.
name|size
argument_list|()
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Structure lengths for %s differ between vertex and fragment shaders"
argument_list|,
name|varName
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|unsigned
name|int
name|numMembers
init|=
name|vertexVar
operator|.
name|fields
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|memberIndex
init|=
literal|0
init|;
name|memberIndex
operator|<
name|numMembers
condition|;
name|memberIndex
operator|++
control|)
block|{
specifier|const
name|ShaderVarType
modifier|&
name|vertexMember
init|=
name|vertexVar
operator|.
name|fields
index|[
name|memberIndex
index|]
decl_stmt|;
specifier|const
name|ShaderVarType
modifier|&
name|fragmentMember
init|=
name|fragmentVar
operator|.
name|fields
index|[
name|memberIndex
index|]
decl_stmt|;
if|if
condition|(
name|vertexMember
operator|.
name|name
operator|!=
name|fragmentMember
operator|.
name|name
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Name mismatch for field '%d' of %s: (in vertex: '%s', in fragment: '%s')"
argument_list|,
name|memberIndex
argument_list|,
name|varName
operator|.
name|c_str
argument_list|()
argument_list|,
name|vertexMember
operator|.
name|name
operator|.
name|c_str
argument_list|()
argument_list|,
name|fragmentMember
operator|.
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|std
operator|::
name|string
name|memberName
init|=
name|varName
operator|.
name|substr
argument_list|(
literal|0
argument_list|,
name|varName
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|+
literal|"."
operator|+
name|vertexVar
operator|.
name|name
operator|+
literal|"'"
decl_stmt|;
if|if
condition|(
operator|!
name|linkValidateVariables
argument_list|(
name|infoLog
argument_list|,
name|memberName
argument_list|,
name|vertexMember
argument_list|,
name|fragmentMember
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|linkValidateVariables
name|bool
name|ProgramBinary
operator|::
name|linkValidateVariables
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|uniformName
parameter_list|,
specifier|const
name|sh
operator|::
name|Uniform
modifier|&
name|vertexUniform
parameter_list|,
specifier|const
name|sh
operator|::
name|Uniform
modifier|&
name|fragmentUniform
parameter_list|)
block|{
if|if
condition|(
operator|!
name|linkValidateVariablesBase
argument_list|(
name|infoLog
argument_list|,
name|uniformName
argument_list|,
name|vertexUniform
argument_list|,
name|fragmentUniform
argument_list|,
literal|true
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|linkValidateFields
argument_list|<
name|sh
operator|::
name|Uniform
argument_list|>
argument_list|(
name|infoLog
argument_list|,
name|uniformName
argument_list|,
name|vertexUniform
argument_list|,
name|fragmentUniform
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|linkValidateVariables
name|bool
name|ProgramBinary
operator|::
name|linkValidateVariables
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|varyingName
parameter_list|,
specifier|const
name|sh
operator|::
name|Varying
modifier|&
name|vertexVarying
parameter_list|,
specifier|const
name|sh
operator|::
name|Varying
modifier|&
name|fragmentVarying
parameter_list|)
block|{
if|if
condition|(
operator|!
name|linkValidateVariablesBase
argument_list|(
name|infoLog
argument_list|,
name|varyingName
argument_list|,
name|vertexVarying
argument_list|,
name|fragmentVarying
argument_list|,
literal|false
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|vertexVarying
operator|.
name|interpolation
operator|!=
name|fragmentVarying
operator|.
name|interpolation
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Interpolation types for %s differ between vertex and fragment shaders"
argument_list|,
name|varyingName
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|linkValidateFields
argument_list|<
name|sh
operator|::
name|Varying
argument_list|>
argument_list|(
name|infoLog
argument_list|,
name|varyingName
argument_list|,
name|vertexVarying
argument_list|,
name|fragmentVarying
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|linkValidateVariables
name|bool
name|ProgramBinary
operator|::
name|linkValidateVariables
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|uniformName
parameter_list|,
specifier|const
name|sh
operator|::
name|InterfaceBlockField
modifier|&
name|vertexUniform
parameter_list|,
specifier|const
name|sh
operator|::
name|InterfaceBlockField
modifier|&
name|fragmentUniform
parameter_list|)
block|{
if|if
condition|(
operator|!
name|linkValidateVariablesBase
argument_list|(
name|infoLog
argument_list|,
name|uniformName
argument_list|,
name|vertexUniform
argument_list|,
name|fragmentUniform
argument_list|,
literal|true
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|vertexUniform
operator|.
name|isRowMajorMatrix
operator|!=
name|fragmentUniform
operator|.
name|isRowMajorMatrix
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Matrix packings for %s differ between vertex and fragment shaders"
argument_list|,
name|uniformName
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|linkValidateFields
argument_list|<
name|sh
operator|::
name|InterfaceBlockField
argument_list|>
argument_list|(
name|infoLog
argument_list|,
name|uniformName
argument_list|,
name|vertexUniform
argument_list|,
name|fragmentUniform
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|linkUniforms
name|bool
name|ProgramBinary
operator|::
name|linkUniforms
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|VertexShader
modifier|&
name|vertexShader
parameter_list|,
specifier|const
name|FragmentShader
modifier|&
name|fragmentShader
parameter_list|)
block|{
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|Uniform
argument_list|>
modifier|&
name|vertexUniforms
init|=
name|vertexShader
operator|.
name|getUniforms
argument_list|()
decl_stmt|;
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|Uniform
argument_list|>
modifier|&
name|fragmentUniforms
init|=
name|fragmentShader
operator|.
name|getUniforms
argument_list|()
decl_stmt|;
comment|// Check that uniforms defined in the vertex and fragment shaders are identical
typedef|typedef
name|std
operator|::
name|map
argument_list|<
name|std
operator|::
name|string
argument_list|,
specifier|const
name|sh
operator|::
name|Uniform
operator|*
argument_list|>
name|UniformMap
typedef|;
name|UniformMap
name|linkedUniforms
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|vertexUniformIndex
init|=
literal|0
init|;
name|vertexUniformIndex
operator|<
name|vertexUniforms
operator|.
name|size
argument_list|()
condition|;
name|vertexUniformIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|Uniform
modifier|&
name|vertexUniform
init|=
name|vertexUniforms
index|[
name|vertexUniformIndex
index|]
decl_stmt|;
name|linkedUniforms
index|[
name|vertexUniform
operator|.
name|name
index|]
operator|=
operator|&
name|vertexUniform
expr_stmt|;
block|}
for|for
control|(
name|unsigned
name|int
name|fragmentUniformIndex
init|=
literal|0
init|;
name|fragmentUniformIndex
operator|<
name|fragmentUniforms
operator|.
name|size
argument_list|()
condition|;
name|fragmentUniformIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|Uniform
modifier|&
name|fragmentUniform
init|=
name|fragmentUniforms
index|[
name|fragmentUniformIndex
index|]
decl_stmt|;
name|UniformMap
operator|::
name|const_iterator
name|entry
init|=
name|linkedUniforms
operator|.
name|find
argument_list|(
name|fragmentUniform
operator|.
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
name|linkedUniforms
operator|.
name|end
argument_list|()
condition|)
block|{
specifier|const
name|sh
operator|::
name|Uniform
modifier|&
name|vertexUniform
init|=
operator|*
name|entry
operator|->
name|second
decl_stmt|;
specifier|const
name|std
operator|::
name|string
modifier|&
name|uniformName
init|=
literal|"uniform '"
operator|+
name|vertexUniform
operator|.
name|name
operator|+
literal|"'"
decl_stmt|;
if|if
condition|(
operator|!
name|linkValidateVariables
argument_list|(
name|infoLog
argument_list|,
name|uniformName
argument_list|,
name|vertexUniform
argument_list|,
name|fragmentUniform
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
for|for
control|(
name|unsigned
name|int
name|uniformIndex
init|=
literal|0
init|;
name|uniformIndex
operator|<
name|vertexUniforms
operator|.
name|size
argument_list|()
condition|;
name|uniformIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|Uniform
modifier|&
name|uniform
init|=
name|vertexUniforms
index|[
name|uniformIndex
index|]
decl_stmt|;
name|defineUniformBase
argument_list|(
name|GL_VERTEX_SHADER
argument_list|,
name|uniform
argument_list|,
name|vertexShader
operator|.
name|getUniformRegister
argument_list|(
name|uniform
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|unsigned
name|int
name|uniformIndex
init|=
literal|0
init|;
name|uniformIndex
operator|<
name|fragmentUniforms
operator|.
name|size
argument_list|()
condition|;
name|uniformIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|Uniform
modifier|&
name|uniform
init|=
name|fragmentUniforms
index|[
name|uniformIndex
index|]
decl_stmt|;
name|defineUniformBase
argument_list|(
name|GL_FRAGMENT_SHADER
argument_list|,
name|uniform
argument_list|,
name|fragmentShader
operator|.
name|getUniformRegister
argument_list|(
name|uniform
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|indexUniforms
argument_list|(
name|infoLog
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|initializeUniformStorage
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|defineUniformBase
name|void
name|ProgramBinary
operator|::
name|defineUniformBase
parameter_list|(
name|GLenum
name|shader
parameter_list|,
specifier|const
name|sh
operator|::
name|Uniform
modifier|&
name|uniform
parameter_list|,
name|unsigned
name|int
name|uniformRegister
parameter_list|)
block|{
name|ShShaderOutput
name|outputType
init|=
name|Shader
operator|::
name|getCompilerOutputType
argument_list|(
name|shader
argument_list|)
decl_stmt|;
name|sh
operator|::
name|HLSLBlockEncoder
name|encoder
argument_list|(
name|sh
operator|::
name|HLSLBlockEncoder
operator|::
name|GetStrategyFor
argument_list|(
name|outputType
argument_list|)
argument_list|)
decl_stmt|;
name|encoder
operator|.
name|skipRegisters
argument_list|(
name|uniformRegister
argument_list|)
expr_stmt|;
name|defineUniform
argument_list|(
name|shader
argument_list|,
name|uniform
argument_list|,
name|uniform
operator|.
name|name
argument_list|,
operator|&
name|encoder
argument_list|)
expr_stmt|;
block|}
DECL|function|defineUniform
name|void
name|ProgramBinary
operator|::
name|defineUniform
parameter_list|(
name|GLenum
name|shader
parameter_list|,
specifier|const
name|sh
operator|::
name|Uniform
modifier|&
name|uniform
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|fullName
parameter_list|,
name|sh
operator|::
name|HLSLBlockEncoder
modifier|*
name|encoder
parameter_list|)
block|{
if|if
condition|(
name|uniform
operator|.
name|isStruct
argument_list|()
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|elementIndex
init|=
literal|0
init|;
name|elementIndex
operator|<
name|uniform
operator|.
name|elementCount
argument_list|()
condition|;
name|elementIndex
operator|++
control|)
block|{
specifier|const
name|std
operator|::
name|string
modifier|&
name|elementString
init|=
operator|(
name|uniform
operator|.
name|isArray
argument_list|()
condition|?
name|ArrayString
argument_list|(
name|elementIndex
argument_list|)
else|:
literal|""
operator|)
decl_stmt|;
name|encoder
operator|->
name|enterAggregateType
argument_list|()
expr_stmt|;
for|for
control|(
name|size_t
name|fieldIndex
init|=
literal|0
init|;
name|fieldIndex
operator|<
name|uniform
operator|.
name|fields
operator|.
name|size
argument_list|()
condition|;
name|fieldIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|Uniform
modifier|&
name|field
init|=
name|uniform
operator|.
name|fields
index|[
name|fieldIndex
index|]
decl_stmt|;
specifier|const
name|std
operator|::
name|string
modifier|&
name|fieldFullName
init|=
operator|(
name|fullName
operator|+
name|elementString
operator|+
literal|"."
operator|+
name|field
operator|.
name|name
operator|)
decl_stmt|;
name|defineUniform
argument_list|(
name|shader
argument_list|,
name|field
argument_list|,
name|fieldFullName
argument_list|,
name|encoder
argument_list|)
expr_stmt|;
block|}
name|encoder
operator|->
name|exitAggregateType
argument_list|()
expr_stmt|;
block|}
block|}
else|else
comment|// Not a struct
block|{
comment|// Arrays are treated as aggregate types
if|if
condition|(
name|uniform
operator|.
name|isArray
argument_list|()
condition|)
block|{
name|encoder
operator|->
name|enterAggregateType
argument_list|()
expr_stmt|;
block|}
name|LinkedUniform
modifier|*
name|linkedUniform
init|=
name|getUniformByName
argument_list|(
name|fullName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|linkedUniform
condition|)
block|{
name|linkedUniform
operator|=
operator|new
name|LinkedUniform
argument_list|(
name|uniform
operator|.
name|type
argument_list|,
name|uniform
operator|.
name|precision
argument_list|,
name|fullName
argument_list|,
name|uniform
operator|.
name|arraySize
argument_list|,
operator|-
literal|1
argument_list|,
name|sh
operator|::
name|BlockMemberInfo
operator|::
name|getDefaultBlockInfo
argument_list|()
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|linkedUniform
argument_list|)
expr_stmt|;
name|linkedUniform
operator|->
name|registerElement
operator|=
name|encoder
operator|->
name|getCurrentElement
argument_list|()
expr_stmt|;
name|mUniforms
operator|.
name|push_back
argument_list|(
name|linkedUniform
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|linkedUniform
operator|->
name|registerElement
operator|==
name|encoder
operator|->
name|getCurrentElement
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|shader
operator|==
name|GL_FRAGMENT_SHADER
condition|)
block|{
name|linkedUniform
operator|->
name|psRegisterIndex
operator|=
name|encoder
operator|->
name|getCurrentRegister
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shader
operator|==
name|GL_VERTEX_SHADER
condition|)
block|{
name|linkedUniform
operator|->
name|vsRegisterIndex
operator|=
name|encoder
operator|->
name|getCurrentRegister
argument_list|()
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
comment|// Advance the uniform offset, to track registers allocation for structs
name|encoder
operator|->
name|encodeType
argument_list|(
name|uniform
operator|.
name|type
argument_list|,
name|uniform
operator|.
name|arraySize
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Arrays are treated as aggregate types
if|if
condition|(
name|uniform
operator|.
name|isArray
argument_list|()
condition|)
block|{
name|encoder
operator|->
name|exitAggregateType
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|function|indexSamplerUniform
name|bool
name|ProgramBinary
operator|::
name|indexSamplerUniform
parameter_list|(
specifier|const
name|LinkedUniform
modifier|&
name|uniform
parameter_list|,
name|InfoLog
modifier|&
name|infoLog
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|IsSampler
argument_list|(
name|uniform
operator|.
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|uniform
operator|.
name|vsRegisterIndex
operator|!=
name|GL_INVALID_INDEX
operator|||
name|uniform
operator|.
name|psRegisterIndex
operator|!=
name|GL_INVALID_INDEX
argument_list|)
expr_stmt|;
if|if
condition|(
name|uniform
operator|.
name|vsRegisterIndex
operator|!=
name|GL_INVALID_INDEX
condition|)
block|{
if|if
condition|(
operator|!
name|assignSamplers
argument_list|(
name|uniform
operator|.
name|vsRegisterIndex
argument_list|,
name|uniform
operator|.
name|type
argument_list|,
name|uniform
operator|.
name|arraySize
argument_list|,
name|mSamplersVS
argument_list|,
operator|&
name|mUsedVertexSamplerRange
argument_list|,
name|mRenderer
operator|->
name|getMaxVertexTextureImageUnits
argument_list|()
argument_list|)
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Vertex shader sampler count exceeds the maximum vertex texture units (%d)."
argument_list|,
name|mRenderer
operator|->
name|getMaxVertexTextureImageUnits
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|unsigned
name|int
name|maxVertexVectors
init|=
name|mRenderer
operator|->
name|getReservedVertexUniformVectors
argument_list|()
operator|+
name|mRenderer
operator|->
name|getMaxVertexUniformVectors
argument_list|()
decl_stmt|;
if|if
condition|(
name|uniform
operator|.
name|vsRegisterIndex
operator|+
name|uniform
operator|.
name|registerCount
operator|>
name|maxVertexVectors
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Vertex shader active uniforms exceed GL_MAX_VERTEX_UNIFORM_VECTORS (%u)"
argument_list|,
name|mRenderer
operator|->
name|getMaxVertexUniformVectors
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|uniform
operator|.
name|psRegisterIndex
operator|!=
name|GL_INVALID_INDEX
condition|)
block|{
if|if
condition|(
operator|!
name|assignSamplers
argument_list|(
name|uniform
operator|.
name|psRegisterIndex
argument_list|,
name|uniform
operator|.
name|type
argument_list|,
name|uniform
operator|.
name|arraySize
argument_list|,
name|mSamplersPS
argument_list|,
operator|&
name|mUsedPixelSamplerRange
argument_list|,
name|MAX_TEXTURE_IMAGE_UNITS
argument_list|)
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Pixel shader sampler count exceeds MAX_TEXTURE_IMAGE_UNITS (%d)."
argument_list|,
name|MAX_TEXTURE_IMAGE_UNITS
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|unsigned
name|int
name|maxFragmentVectors
init|=
name|mRenderer
operator|->
name|getReservedFragmentUniformVectors
argument_list|()
operator|+
name|mRenderer
operator|->
name|getMaxFragmentUniformVectors
argument_list|()
decl_stmt|;
if|if
condition|(
name|uniform
operator|.
name|psRegisterIndex
operator|+
name|uniform
operator|.
name|registerCount
operator|>
name|maxFragmentVectors
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Fragment shader active uniforms exceed GL_MAX_FRAGMENT_UNIFORM_VECTORS (%u)"
argument_list|,
name|mRenderer
operator|->
name|getMaxFragmentUniformVectors
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|indexUniforms
name|bool
name|ProgramBinary
operator|::
name|indexUniforms
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|)
block|{
for|for
control|(
name|size_t
name|uniformIndex
init|=
literal|0
init|;
name|uniformIndex
operator|<
name|mUniforms
operator|.
name|size
argument_list|()
condition|;
name|uniformIndex
operator|++
control|)
block|{
specifier|const
name|LinkedUniform
modifier|&
name|uniform
init|=
operator|*
name|mUniforms
index|[
name|uniformIndex
index|]
decl_stmt|;
if|if
condition|(
name|IsSampler
argument_list|(
name|uniform
operator|.
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|indexSamplerUniform
argument_list|(
name|uniform
argument_list|,
name|infoLog
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
for|for
control|(
name|unsigned
name|int
name|arrayElementIndex
init|=
literal|0
init|;
name|arrayElementIndex
operator|<
name|uniform
operator|.
name|elementCount
argument_list|()
condition|;
name|arrayElementIndex
operator|++
control|)
block|{
name|mUniformIndex
operator|.
name|push_back
argument_list|(
name|VariableLocation
argument_list|(
name|uniform
operator|.
name|name
argument_list|,
name|arrayElementIndex
argument_list|,
name|uniformIndex
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|assignSamplers
name|bool
name|ProgramBinary
operator|::
name|assignSamplers
parameter_list|(
name|unsigned
name|int
name|startSamplerIndex
parameter_list|,
name|GLenum
name|samplerType
parameter_list|,
name|unsigned
name|int
name|samplerCount
parameter_list|,
name|Sampler
modifier|*
name|outArray
parameter_list|,
name|GLuint
modifier|*
name|usedRange
parameter_list|,
name|unsigned
name|int
name|limit
parameter_list|)
block|{
name|unsigned
name|int
name|samplerIndex
init|=
name|startSamplerIndex
decl_stmt|;
do|do
block|{
if|if
condition|(
name|samplerIndex
operator|<
name|limit
condition|)
block|{
name|outArray
index|[
name|samplerIndex
index|]
operator|.
name|active
operator|=
literal|true
expr_stmt|;
name|outArray
index|[
name|samplerIndex
index|]
operator|.
name|textureType
operator|=
name|GetTextureType
argument_list|(
name|samplerType
argument_list|)
expr_stmt|;
name|outArray
index|[
name|samplerIndex
index|]
operator|.
name|logicalTextureUnit
operator|=
literal|0
expr_stmt|;
operator|*
name|usedRange
operator|=
name|std
operator|::
name|max
argument_list|(
name|samplerIndex
operator|+
literal|1
argument_list|,
operator|*
name|usedRange
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
name|samplerIndex
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|samplerIndex
operator|<
name|startSamplerIndex
operator|+
name|samplerCount
condition|)
do|;
return|return
literal|true
return|;
block|}
DECL|function|areMatchingInterfaceBlocks
name|bool
name|ProgramBinary
operator|::
name|areMatchingInterfaceBlocks
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|sh
operator|::
name|InterfaceBlock
modifier|&
name|vertexInterfaceBlock
parameter_list|,
specifier|const
name|sh
operator|::
name|InterfaceBlock
modifier|&
name|fragmentInterfaceBlock
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|blockName
init|=
name|vertexInterfaceBlock
operator|.
name|name
operator|.
name|c_str
argument_list|()
decl_stmt|;
comment|// validate blocks for the same member types
if|if
condition|(
name|vertexInterfaceBlock
operator|.
name|fields
operator|.
name|size
argument_list|()
operator|!=
name|fragmentInterfaceBlock
operator|.
name|fields
operator|.
name|size
argument_list|()
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Types for interface block '%s' differ between vertex and fragment shaders"
argument_list|,
name|blockName
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|vertexInterfaceBlock
operator|.
name|arraySize
operator|!=
name|fragmentInterfaceBlock
operator|.
name|arraySize
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Array sizes differ for interface block '%s' between vertex and fragment shaders"
argument_list|,
name|blockName
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|vertexInterfaceBlock
operator|.
name|layout
operator|!=
name|fragmentInterfaceBlock
operator|.
name|layout
operator|||
name|vertexInterfaceBlock
operator|.
name|isRowMajorLayout
operator|!=
name|fragmentInterfaceBlock
operator|.
name|isRowMajorLayout
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Layout qualifiers differ for interface block '%s' between vertex and fragment shaders"
argument_list|,
name|blockName
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|unsigned
name|int
name|numBlockMembers
init|=
name|vertexInterfaceBlock
operator|.
name|fields
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|blockMemberIndex
init|=
literal|0
init|;
name|blockMemberIndex
operator|<
name|numBlockMembers
condition|;
name|blockMemberIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|InterfaceBlockField
modifier|&
name|vertexMember
init|=
name|vertexInterfaceBlock
operator|.
name|fields
index|[
name|blockMemberIndex
index|]
decl_stmt|;
specifier|const
name|sh
operator|::
name|InterfaceBlockField
modifier|&
name|fragmentMember
init|=
name|fragmentInterfaceBlock
operator|.
name|fields
index|[
name|blockMemberIndex
index|]
decl_stmt|;
if|if
condition|(
name|vertexMember
operator|.
name|name
operator|!=
name|fragmentMember
operator|.
name|name
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Name mismatch for field %d of interface block '%s': (in vertex: '%s', in fragment: '%s')"
argument_list|,
name|blockMemberIndex
argument_list|,
name|blockName
argument_list|,
name|vertexMember
operator|.
name|name
operator|.
name|c_str
argument_list|()
argument_list|,
name|fragmentMember
operator|.
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|std
operator|::
name|string
name|uniformName
init|=
literal|"interface block '"
operator|+
name|vertexInterfaceBlock
operator|.
name|name
operator|+
literal|"' member '"
operator|+
name|vertexMember
operator|.
name|name
operator|+
literal|"'"
decl_stmt|;
if|if
condition|(
operator|!
name|linkValidateVariables
argument_list|(
name|infoLog
argument_list|,
name|uniformName
argument_list|,
name|vertexMember
argument_list|,
name|fragmentMember
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|linkUniformBlocks
name|bool
name|ProgramBinary
operator|::
name|linkUniformBlocks
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|VertexShader
modifier|&
name|vertexShader
parameter_list|,
specifier|const
name|FragmentShader
modifier|&
name|fragmentShader
parameter_list|)
block|{
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|InterfaceBlock
argument_list|>
modifier|&
name|vertexInterfaceBlocks
init|=
name|vertexShader
operator|.
name|getInterfaceBlocks
argument_list|()
decl_stmt|;
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|InterfaceBlock
argument_list|>
modifier|&
name|fragmentInterfaceBlocks
init|=
name|fragmentShader
operator|.
name|getInterfaceBlocks
argument_list|()
decl_stmt|;
comment|// Check that interface blocks defined in the vertex and fragment shaders are identical
typedef|typedef
name|std
operator|::
name|map
argument_list|<
name|std
operator|::
name|string
argument_list|,
specifier|const
name|sh
operator|::
name|InterfaceBlock
operator|*
argument_list|>
name|UniformBlockMap
typedef|;
name|UniformBlockMap
name|linkedUniformBlocks
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|blockIndex
init|=
literal|0
init|;
name|blockIndex
operator|<
name|vertexInterfaceBlocks
operator|.
name|size
argument_list|()
condition|;
name|blockIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|InterfaceBlock
modifier|&
name|vertexInterfaceBlock
init|=
name|vertexInterfaceBlocks
index|[
name|blockIndex
index|]
decl_stmt|;
name|linkedUniformBlocks
index|[
name|vertexInterfaceBlock
operator|.
name|name
index|]
operator|=
operator|&
name|vertexInterfaceBlock
expr_stmt|;
block|}
for|for
control|(
name|unsigned
name|int
name|blockIndex
init|=
literal|0
init|;
name|blockIndex
operator|<
name|fragmentInterfaceBlocks
operator|.
name|size
argument_list|()
condition|;
name|blockIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|InterfaceBlock
modifier|&
name|fragmentInterfaceBlock
init|=
name|fragmentInterfaceBlocks
index|[
name|blockIndex
index|]
decl_stmt|;
name|UniformBlockMap
operator|::
name|const_iterator
name|entry
init|=
name|linkedUniformBlocks
operator|.
name|find
argument_list|(
name|fragmentInterfaceBlock
operator|.
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
name|linkedUniformBlocks
operator|.
name|end
argument_list|()
condition|)
block|{
specifier|const
name|sh
operator|::
name|InterfaceBlock
modifier|&
name|vertexInterfaceBlock
init|=
operator|*
name|entry
operator|->
name|second
decl_stmt|;
if|if
condition|(
operator|!
name|areMatchingInterfaceBlocks
argument_list|(
name|infoLog
argument_list|,
name|vertexInterfaceBlock
argument_list|,
name|fragmentInterfaceBlock
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
for|for
control|(
name|unsigned
name|int
name|blockIndex
init|=
literal|0
init|;
name|blockIndex
operator|<
name|vertexInterfaceBlocks
operator|.
name|size
argument_list|()
condition|;
name|blockIndex
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|defineUniformBlock
argument_list|(
name|infoLog
argument_list|,
name|vertexShader
argument_list|,
name|vertexInterfaceBlocks
index|[
name|blockIndex
index|]
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
for|for
control|(
name|unsigned
name|int
name|blockIndex
init|=
literal|0
init|;
name|blockIndex
operator|<
name|fragmentInterfaceBlocks
operator|.
name|size
argument_list|()
condition|;
name|blockIndex
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|defineUniformBlock
argument_list|(
name|infoLog
argument_list|,
name|fragmentShader
argument_list|,
name|fragmentInterfaceBlocks
index|[
name|blockIndex
index|]
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|gatherTransformFeedbackLinkedVaryings
name|bool
name|ProgramBinary
operator|::
name|gatherTransformFeedbackLinkedVaryings
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|LinkedVarying
argument_list|>
modifier|&
name|linkedVaryings
parameter_list|,
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|std
operator|::
name|string
argument_list|>
modifier|&
name|transformFeedbackVaryingNames
parameter_list|,
name|GLenum
name|transformFeedbackBufferMode
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|LinkedVarying
argument_list|>
modifier|*
name|outTransformFeedbackLinkedVaryings
parameter_list|)
specifier|const
block|{
name|size_t
name|totalComponents
init|=
literal|0
decl_stmt|;
specifier|const
name|size_t
name|maxSeparateComponents
init|=
name|mRenderer
operator|->
name|getMaxTransformFeedbackSeparateComponents
argument_list|()
decl_stmt|;
specifier|const
name|size_t
name|maxInterleavedComponents
init|=
name|mRenderer
operator|->
name|getMaxTransformFeedbackInterleavedComponents
argument_list|()
decl_stmt|;
comment|// Gather the linked varyings that are used for transform feedback, they should all exist.
name|outTransformFeedbackLinkedVaryings
operator|->
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|transformFeedbackVaryingNames
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|bool
name|found
init|=
literal|false
decl_stmt|;
for|for
control|(
name|size_t
name|j
init|=
literal|0
init|;
name|j
operator|<
name|linkedVaryings
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|transformFeedbackVaryingNames
index|[
name|i
index|]
operator|==
name|linkedVaryings
index|[
name|j
index|]
operator|.
name|name
condition|)
block|{
for|for
control|(
name|size_t
name|k
init|=
literal|0
init|;
name|k
operator|<
name|outTransformFeedbackLinkedVaryings
operator|->
name|size
argument_list|()
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|outTransformFeedbackLinkedVaryings
operator|->
name|at
argument_list|(
name|k
argument_list|)
operator|.
name|name
operator|==
name|linkedVaryings
index|[
name|j
index|]
operator|.
name|name
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Two transform feedback varyings specify the same output variable (%s)."
argument_list|,
name|linkedVaryings
index|[
name|j
index|]
operator|.
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|size_t
name|componentCount
init|=
name|linkedVaryings
index|[
name|j
index|]
operator|.
name|semanticIndexCount
operator|*
literal|4
decl_stmt|;
if|if
condition|(
name|transformFeedbackBufferMode
operator|==
name|GL_SEPARATE_ATTRIBS
operator|&&
name|componentCount
operator|>
name|maxSeparateComponents
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Transform feedback varying's %s components (%u) exceed the maximum separate components (%u)."
argument_list|,
name|linkedVaryings
index|[
name|j
index|]
operator|.
name|name
operator|.
name|c_str
argument_list|()
argument_list|,
name|componentCount
argument_list|,
name|maxSeparateComponents
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|totalComponents
operator|+=
name|componentCount
expr_stmt|;
name|outTransformFeedbackLinkedVaryings
operator|->
name|push_back
argument_list|(
name|linkedVaryings
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
comment|// All transform feedback varyings are expected to exist since packVaryings checks for them.
name|ASSERT
argument_list|(
name|found
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|transformFeedbackBufferMode
operator|==
name|GL_INTERLEAVED_ATTRIBS
operator|&&
name|totalComponents
operator|>
name|maxInterleavedComponents
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Transform feedback varying total components (%u) exceed the maximum interleaved components (%u)."
argument_list|,
name|totalComponents
argument_list|,
name|maxInterleavedComponents
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|defineUniformBlockMembers
name|void
name|ProgramBinary
operator|::
name|defineUniformBlockMembers
parameter_list|(
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|InterfaceBlockField
argument_list|>
modifier|&
name|fields
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|prefix
parameter_list|,
name|int
name|blockIndex
parameter_list|,
name|sh
operator|::
name|BlockLayoutEncoder
modifier|*
name|encoder
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|unsigned
name|int
argument_list|>
modifier|*
name|blockUniformIndexes
parameter_list|)
block|{
for|for
control|(
name|unsigned
name|int
name|uniformIndex
init|=
literal|0
init|;
name|uniformIndex
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|uniformIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|InterfaceBlockField
modifier|&
name|field
init|=
name|fields
index|[
name|uniformIndex
index|]
decl_stmt|;
specifier|const
name|std
operator|::
name|string
modifier|&
name|fieldName
init|=
operator|(
name|prefix
operator|.
name|empty
argument_list|()
condition|?
name|field
operator|.
name|name
else|:
name|prefix
operator|+
literal|"."
operator|+
name|field
operator|.
name|name
operator|)
decl_stmt|;
if|if
condition|(
name|field
operator|.
name|isStruct
argument_list|()
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|arrayElement
init|=
literal|0
init|;
name|arrayElement
operator|<
name|field
operator|.
name|elementCount
argument_list|()
condition|;
name|arrayElement
operator|++
control|)
block|{
name|encoder
operator|->
name|enterAggregateType
argument_list|()
expr_stmt|;
specifier|const
name|std
operator|::
name|string
name|uniformElementName
init|=
name|fieldName
operator|+
operator|(
name|field
operator|.
name|isArray
argument_list|()
condition|?
name|ArrayString
argument_list|(
name|arrayElement
argument_list|)
else|:
literal|""
operator|)
decl_stmt|;
name|defineUniformBlockMembers
argument_list|(
name|field
operator|.
name|fields
argument_list|,
name|uniformElementName
argument_list|,
name|blockIndex
argument_list|,
name|encoder
argument_list|,
name|blockUniformIndexes
argument_list|)
expr_stmt|;
name|encoder
operator|->
name|exitAggregateType
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|sh
operator|::
name|BlockMemberInfo
name|memberInfo
init|=
name|encoder
operator|->
name|encodeInterfaceBlockField
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|LinkedUniform
modifier|*
name|newUniform
init|=
operator|new
name|LinkedUniform
argument_list|(
name|field
operator|.
name|type
argument_list|,
name|field
operator|.
name|precision
argument_list|,
name|fieldName
argument_list|,
name|field
operator|.
name|arraySize
argument_list|,
name|blockIndex
argument_list|,
name|memberInfo
argument_list|)
decl_stmt|;
comment|// add to uniform list, but not index, since uniform block uniforms have no location
name|blockUniformIndexes
operator|->
name|push_back
argument_list|(
name|mUniforms
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|mUniforms
operator|.
name|push_back
argument_list|(
name|newUniform
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|defineUniformBlock
name|bool
name|ProgramBinary
operator|::
name|defineUniformBlock
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|Shader
modifier|&
name|shader
parameter_list|,
specifier|const
name|sh
operator|::
name|InterfaceBlock
modifier|&
name|interfaceBlock
parameter_list|)
block|{
comment|// create uniform block entries if they do not exist
if|if
condition|(
name|getUniformBlockIndex
argument_list|(
name|interfaceBlock
operator|.
name|name
argument_list|)
operator|==
name|GL_INVALID_INDEX
condition|)
block|{
name|std
operator|::
name|vector
argument_list|<
name|unsigned
name|int
argument_list|>
name|blockUniformIndexes
decl_stmt|;
specifier|const
name|unsigned
name|int
name|blockIndex
init|=
name|mUniformBlocks
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// define member uniforms
name|sh
operator|::
name|BlockLayoutEncoder
modifier|*
name|encoder
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|interfaceBlock
operator|.
name|layout
operator|==
name|sh
operator|::
name|BLOCKLAYOUT_STANDARD
condition|)
block|{
name|encoder
operator|=
operator|new
name|sh
operator|::
name|Std140BlockEncoder
expr_stmt|;
block|}
else|else
block|{
name|encoder
operator|=
operator|new
name|sh
operator|::
name|HLSLBlockEncoder
argument_list|(
name|sh
operator|::
name|HLSLBlockEncoder
operator|::
name|ENCODE_PACKED
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
name|defineUniformBlockMembers
argument_list|(
name|interfaceBlock
operator|.
name|fields
argument_list|,
literal|""
argument_list|,
name|blockIndex
argument_list|,
name|encoder
argument_list|,
operator|&
name|blockUniformIndexes
argument_list|)
expr_stmt|;
name|size_t
name|dataSize
init|=
name|encoder
operator|->
name|getBlockSize
argument_list|()
decl_stmt|;
comment|// create all the uniform blocks
if|if
condition|(
name|interfaceBlock
operator|.
name|arraySize
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|uniformBlockElement
init|=
literal|0
init|;
name|uniformBlockElement
operator|<
name|interfaceBlock
operator|.
name|arraySize
condition|;
name|uniformBlockElement
operator|++
control|)
block|{
name|UniformBlock
modifier|*
name|newUniformBlock
init|=
operator|new
name|UniformBlock
argument_list|(
name|interfaceBlock
operator|.
name|name
argument_list|,
name|uniformBlockElement
argument_list|,
name|dataSize
argument_list|)
decl_stmt|;
name|newUniformBlock
operator|->
name|memberUniformIndexes
operator|=
name|blockUniformIndexes
expr_stmt|;
name|mUniformBlocks
operator|.
name|push_back
argument_list|(
name|newUniformBlock
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|UniformBlock
modifier|*
name|newUniformBlock
init|=
operator|new
name|UniformBlock
argument_list|(
name|interfaceBlock
operator|.
name|name
argument_list|,
name|GL_INVALID_INDEX
argument_list|,
name|dataSize
argument_list|)
decl_stmt|;
name|newUniformBlock
operator|->
name|memberUniformIndexes
operator|=
name|blockUniformIndexes
expr_stmt|;
name|mUniformBlocks
operator|.
name|push_back
argument_list|(
name|newUniformBlock
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Assign registers to the uniform blocks
specifier|const
name|GLuint
name|blockIndex
init|=
name|getUniformBlockIndex
argument_list|(
name|interfaceBlock
operator|.
name|name
argument_list|)
decl_stmt|;
specifier|const
name|unsigned
name|int
name|elementCount
init|=
name|std
operator|::
name|max
argument_list|(
literal|1u
argument_list|,
name|interfaceBlock
operator|.
name|arraySize
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|blockIndex
operator|!=
name|GL_INVALID_INDEX
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|blockIndex
operator|+
name|elementCount
operator|<=
name|mUniformBlocks
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|unsigned
name|int
name|interfaceBlockRegister
init|=
name|shader
operator|.
name|getInterfaceBlockRegister
argument_list|(
name|interfaceBlock
operator|.
name|name
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|uniformBlockElement
init|=
literal|0
init|;
name|uniformBlockElement
operator|<
name|elementCount
condition|;
name|uniformBlockElement
operator|++
control|)
block|{
name|UniformBlock
modifier|*
name|uniformBlock
init|=
name|mUniformBlocks
index|[
name|blockIndex
operator|+
name|uniformBlockElement
index|]
decl_stmt|;
name|ASSERT
argument_list|(
name|uniformBlock
operator|->
name|name
operator|==
name|interfaceBlock
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|assignUniformBlockRegister
argument_list|(
name|infoLog
argument_list|,
name|uniformBlock
argument_list|,
name|shader
operator|.
name|getType
argument_list|()
argument_list|,
name|interfaceBlockRegister
operator|+
name|uniformBlockElement
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|assignUniformBlockRegister
name|bool
name|ProgramBinary
operator|::
name|assignUniformBlockRegister
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
name|UniformBlock
modifier|*
name|uniformBlock
parameter_list|,
name|GLenum
name|shader
parameter_list|,
name|unsigned
name|int
name|registerIndex
parameter_list|)
block|{
if|if
condition|(
name|shader
operator|==
name|GL_VERTEX_SHADER
condition|)
block|{
name|uniformBlock
operator|->
name|vsRegisterIndex
operator|=
name|registerIndex
expr_stmt|;
name|unsigned
name|int
name|maximumBlocks
init|=
name|mRenderer
operator|->
name|getMaxVertexShaderUniformBuffers
argument_list|()
decl_stmt|;
if|if
condition|(
name|registerIndex
operator|-
name|mRenderer
operator|->
name|getReservedVertexUniformBuffers
argument_list|()
operator|>=
name|maximumBlocks
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Vertex shader uniform block count exceed GL_MAX_VERTEX_UNIFORM_BLOCKS (%u)"
argument_list|,
name|maximumBlocks
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|shader
operator|==
name|GL_FRAGMENT_SHADER
condition|)
block|{
name|uniformBlock
operator|->
name|psRegisterIndex
operator|=
name|registerIndex
expr_stmt|;
name|unsigned
name|int
name|maximumBlocks
init|=
name|mRenderer
operator|->
name|getMaxFragmentShaderUniformBuffers
argument_list|()
decl_stmt|;
if|if
condition|(
name|registerIndex
operator|-
name|mRenderer
operator|->
name|getReservedFragmentUniformBuffers
argument_list|()
operator|>=
name|maximumBlocks
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Fragment shader uniform block count exceed GL_MAX_FRAGMENT_UNIFORM_BLOCKS (%u)"
argument_list|,
name|maximumBlocks
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|isValidated
name|bool
name|ProgramBinary
operator|::
name|isValidated
parameter_list|()
specifier|const
block|{
return|return
name|mValidated
return|;
block|}
DECL|function|getActiveAttribute
name|void
name|ProgramBinary
operator|::
name|getActiveAttribute
parameter_list|(
name|GLuint
name|index
parameter_list|,
name|GLsizei
name|bufsize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|,
name|GLint
modifier|*
name|size
parameter_list|,
name|GLenum
modifier|*
name|type
parameter_list|,
name|GLchar
modifier|*
name|name
parameter_list|)
specifier|const
block|{
comment|// Skip over inactive attributes
name|unsigned
name|int
name|activeAttribute
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|attribute
decl_stmt|;
for|for
control|(
name|attribute
operator|=
literal|0
init|;
name|attribute
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|attribute
operator|++
control|)
block|{
if|if
condition|(
name|mLinkedAttribute
index|[
name|attribute
index|]
operator|.
name|name
operator|.
name|empty
argument_list|()
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|activeAttribute
operator|==
name|index
condition|)
block|{
break|break;
block|}
name|activeAttribute
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bufsize
operator|>
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|string
init|=
name|mLinkedAttribute
index|[
name|attribute
index|]
operator|.
name|name
operator|.
name|c_str
argument_list|()
decl_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
name|string
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|name
index|[
name|bufsize
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|size
operator|=
literal|1
expr_stmt|;
comment|// Always a single 'type' instance
operator|*
name|type
operator|=
name|mLinkedAttribute
index|[
name|attribute
index|]
operator|.
name|type
expr_stmt|;
block|}
DECL|function|getActiveAttributeCount
name|GLint
name|ProgramBinary
operator|::
name|getActiveAttributeCount
parameter_list|()
specifier|const
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|attributeIndex
init|=
literal|0
init|;
name|attributeIndex
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|attributeIndex
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|mLinkedAttribute
index|[
name|attributeIndex
index|]
operator|.
name|name
operator|.
name|empty
argument_list|()
condition|)
block|{
name|count
operator|++
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
DECL|function|getActiveAttributeMaxLength
name|GLint
name|ProgramBinary
operator|::
name|getActiveAttributeMaxLength
parameter_list|()
specifier|const
block|{
name|int
name|maxLength
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|attributeIndex
init|=
literal|0
init|;
name|attributeIndex
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|attributeIndex
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|mLinkedAttribute
index|[
name|attributeIndex
index|]
operator|.
name|name
operator|.
name|empty
argument_list|()
condition|)
block|{
name|maxLength
operator|=
name|std
operator|::
name|max
argument_list|(
call|(
name|int
call|)
argument_list|(
name|mLinkedAttribute
index|[
name|attributeIndex
index|]
operator|.
name|name
operator|.
name|length
argument_list|()
operator|+
literal|1
argument_list|)
argument_list|,
name|maxLength
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|maxLength
return|;
block|}
DECL|function|getActiveUniform
name|void
name|ProgramBinary
operator|::
name|getActiveUniform
parameter_list|(
name|GLuint
name|index
parameter_list|,
name|GLsizei
name|bufsize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|,
name|GLint
modifier|*
name|size
parameter_list|,
name|GLenum
modifier|*
name|type
parameter_list|,
name|GLchar
modifier|*
name|name
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|index
operator|<
name|mUniforms
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// index must be smaller than getActiveUniformCount()
if|if
condition|(
name|bufsize
operator|>
literal|0
condition|)
block|{
name|std
operator|::
name|string
name|string
init|=
name|mUniforms
index|[
name|index
index|]
operator|->
name|name
decl_stmt|;
if|if
condition|(
name|mUniforms
index|[
name|index
index|]
operator|->
name|isArray
argument_list|()
condition|)
block|{
name|string
operator|+=
literal|"[0]"
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|name
argument_list|,
name|string
operator|.
name|c_str
argument_list|()
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|name
index|[
name|bufsize
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|size
operator|=
name|mUniforms
index|[
name|index
index|]
operator|->
name|elementCount
argument_list|()
expr_stmt|;
operator|*
name|type
operator|=
name|mUniforms
index|[
name|index
index|]
operator|->
name|type
expr_stmt|;
block|}
DECL|function|getActiveUniformCount
name|GLint
name|ProgramBinary
operator|::
name|getActiveUniformCount
parameter_list|()
specifier|const
block|{
return|return
name|mUniforms
operator|.
name|size
argument_list|()
return|;
block|}
DECL|function|getActiveUniformMaxLength
name|GLint
name|ProgramBinary
operator|::
name|getActiveUniformMaxLength
parameter_list|()
specifier|const
block|{
name|int
name|maxLength
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|numUniforms
init|=
name|mUniforms
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|uniformIndex
init|=
literal|0
init|;
name|uniformIndex
operator|<
name|numUniforms
condition|;
name|uniformIndex
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|mUniforms
index|[
name|uniformIndex
index|]
operator|->
name|name
operator|.
name|empty
argument_list|()
condition|)
block|{
name|int
name|length
init|=
call|(
name|int
call|)
argument_list|(
name|mUniforms
index|[
name|uniformIndex
index|]
operator|->
name|name
operator|.
name|length
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|mUniforms
index|[
name|uniformIndex
index|]
operator|->
name|isArray
argument_list|()
condition|)
block|{
name|length
operator|+=
literal|3
expr_stmt|;
comment|// Counting in "[0]".
block|}
name|maxLength
operator|=
name|std
operator|::
name|max
argument_list|(
name|length
argument_list|,
name|maxLength
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|maxLength
return|;
block|}
DECL|function|getActiveUniformi
name|GLint
name|ProgramBinary
operator|::
name|getActiveUniformi
parameter_list|(
name|GLuint
name|index
parameter_list|,
name|GLenum
name|pname
parameter_list|)
specifier|const
block|{
specifier|const
name|gl
operator|::
name|LinkedUniform
modifier|&
name|uniform
init|=
operator|*
name|mUniforms
index|[
name|index
index|]
decl_stmt|;
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_UNIFORM_TYPE
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniform
operator|.
name|type
argument_list|)
return|;
case|case
name|GL_UNIFORM_SIZE
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniform
operator|.
name|elementCount
argument_list|()
argument_list|)
return|;
case|case
name|GL_UNIFORM_NAME_LENGTH
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniform
operator|.
name|name
operator|.
name|size
argument_list|()
operator|+
literal|1
operator|+
operator|(
name|uniform
operator|.
name|isArray
argument_list|()
condition|?
literal|3
else|:
literal|0
operator|)
argument_list|)
return|;
case|case
name|GL_UNIFORM_BLOCK_INDEX
case|:
return|return
name|uniform
operator|.
name|blockIndex
return|;
case|case
name|GL_UNIFORM_OFFSET
case|:
return|return
name|uniform
operator|.
name|blockInfo
operator|.
name|offset
return|;
case|case
name|GL_UNIFORM_ARRAY_STRIDE
case|:
return|return
name|uniform
operator|.
name|blockInfo
operator|.
name|arrayStride
return|;
case|case
name|GL_UNIFORM_MATRIX_STRIDE
case|:
return|return
name|uniform
operator|.
name|blockInfo
operator|.
name|matrixStride
return|;
case|case
name|GL_UNIFORM_IS_ROW_MAJOR
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniform
operator|.
name|blockInfo
operator|.
name|isRowMajorMatrix
argument_list|)
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
DECL|function|isValidUniformLocation
name|bool
name|ProgramBinary
operator|::
name|isValidUniformLocation
parameter_list|(
name|GLint
name|location
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|rx
operator|::
name|IsIntegerCastSafe
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|mUniformIndex
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|location
operator|>=
literal|0
operator|&&
name|location
operator|<
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|mUniformIndex
operator|.
name|size
argument_list|()
argument_list|)
operator|)
return|;
block|}
DECL|function|getUniformByLocation
name|LinkedUniform
modifier|*
name|ProgramBinary
operator|::
name|getUniformByLocation
parameter_list|(
name|GLint
name|location
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|location
operator|>=
literal|0
operator|&&
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|location
argument_list|)
operator|<
name|mUniformIndex
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|mUniforms
index|[
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|index
index|]
return|;
block|}
DECL|function|getUniformByName
name|LinkedUniform
modifier|*
name|ProgramBinary
operator|::
name|getUniformByName
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|name
parameter_list|)
specifier|const
block|{
for|for
control|(
name|size_t
name|uniformIndex
init|=
literal|0
init|;
name|uniformIndex
operator|<
name|mUniforms
operator|.
name|size
argument_list|()
condition|;
name|uniformIndex
operator|++
control|)
block|{
if|if
condition|(
name|mUniforms
index|[
name|uniformIndex
index|]
operator|->
name|name
operator|==
name|name
condition|)
block|{
return|return
name|mUniforms
index|[
name|uniformIndex
index|]
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
DECL|function|getActiveUniformBlockName
name|void
name|ProgramBinary
operator|::
name|getActiveUniformBlockName
parameter_list|(
name|GLuint
name|uniformBlockIndex
parameter_list|,
name|GLsizei
name|bufSize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|,
name|GLchar
modifier|*
name|uniformBlockName
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|uniformBlockIndex
operator|<
name|mUniformBlocks
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// index must be smaller than getActiveUniformBlockCount()
specifier|const
name|UniformBlock
modifier|&
name|uniformBlock
init|=
operator|*
name|mUniformBlocks
index|[
name|uniformBlockIndex
index|]
decl_stmt|;
if|if
condition|(
name|bufSize
operator|>
literal|0
condition|)
block|{
name|std
operator|::
name|string
name|string
init|=
name|uniformBlock
operator|.
name|name
decl_stmt|;
if|if
condition|(
name|uniformBlock
operator|.
name|isArrayElement
argument_list|()
condition|)
block|{
name|string
operator|+=
name|ArrayString
argument_list|(
name|uniformBlock
operator|.
name|elementIndex
argument_list|)
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|uniformBlockName
argument_list|,
name|string
operator|.
name|c_str
argument_list|()
argument_list|,
name|bufSize
argument_list|)
expr_stmt|;
name|uniformBlockName
index|[
name|bufSize
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
name|strlen
argument_list|(
name|uniformBlockName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|getActiveUniformBlockiv
name|void
name|ProgramBinary
operator|::
name|getActiveUniformBlockiv
parameter_list|(
name|GLuint
name|uniformBlockIndex
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLint
modifier|*
name|params
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|uniformBlockIndex
operator|<
name|mUniformBlocks
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// index must be smaller than getActiveUniformBlockCount()
specifier|const
name|UniformBlock
modifier|&
name|uniformBlock
init|=
operator|*
name|mUniformBlocks
index|[
name|uniformBlockIndex
index|]
decl_stmt|;
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_UNIFORM_BLOCK_DATA_SIZE
case|:
operator|*
name|params
operator|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniformBlock
operator|.
name|dataSize
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_UNIFORM_BLOCK_NAME_LENGTH
case|:
operator|*
name|params
operator|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniformBlock
operator|.
name|name
operator|.
name|size
argument_list|()
operator|+
literal|1
operator|+
operator|(
name|uniformBlock
operator|.
name|isArrayElement
argument_list|()
condition|?
literal|3
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS
case|:
operator|*
name|params
operator|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniformBlock
operator|.
name|memberUniformIndexes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES
case|:
block|{
for|for
control|(
name|unsigned
name|int
name|blockMemberIndex
init|=
literal|0
init|;
name|blockMemberIndex
operator|<
name|uniformBlock
operator|.
name|memberUniformIndexes
operator|.
name|size
argument_list|()
condition|;
name|blockMemberIndex
operator|++
control|)
block|{
name|params
index|[
name|blockMemberIndex
index|]
operator|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniformBlock
operator|.
name|memberUniformIndexes
index|[
name|blockMemberIndex
index|]
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER
case|:
operator|*
name|params
operator|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniformBlock
operator|.
name|isReferencedByVertexShader
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER
case|:
operator|*
name|params
operator|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniformBlock
operator|.
name|isReferencedByFragmentShader
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|getActiveUniformBlockCount
name|GLuint
name|ProgramBinary
operator|::
name|getActiveUniformBlockCount
parameter_list|()
specifier|const
block|{
return|return
name|mUniformBlocks
operator|.
name|size
argument_list|()
return|;
block|}
DECL|function|getActiveUniformBlockMaxLength
name|GLuint
name|ProgramBinary
operator|::
name|getActiveUniformBlockMaxLength
parameter_list|()
specifier|const
block|{
name|unsigned
name|int
name|maxLength
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|numUniformBlocks
init|=
name|mUniformBlocks
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|uniformBlockIndex
init|=
literal|0
init|;
name|uniformBlockIndex
operator|<
name|numUniformBlocks
condition|;
name|uniformBlockIndex
operator|++
control|)
block|{
specifier|const
name|UniformBlock
modifier|&
name|uniformBlock
init|=
operator|*
name|mUniformBlocks
index|[
name|uniformBlockIndex
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|uniformBlock
operator|.
name|name
operator|.
name|empty
argument_list|()
condition|)
block|{
specifier|const
name|unsigned
name|int
name|length
init|=
name|uniformBlock
operator|.
name|name
operator|.
name|length
argument_list|()
operator|+
literal|1
decl_stmt|;
comment|// Counting in "[0]".
specifier|const
name|unsigned
name|int
name|arrayLength
init|=
operator|(
name|uniformBlock
operator|.
name|isArrayElement
argument_list|()
condition|?
literal|3
else|:
literal|0
operator|)
decl_stmt|;
name|maxLength
operator|=
name|std
operator|::
name|max
argument_list|(
name|length
operator|+
name|arrayLength
argument_list|,
name|maxLength
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|maxLength
return|;
block|}
DECL|function|validate
name|void
name|ProgramBinary
operator|::
name|validate
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|)
block|{
name|applyUniforms
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|validateSamplers
argument_list|(
operator|&
name|infoLog
argument_list|)
condition|)
block|{
name|mValidated
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|mValidated
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|validateSamplers
name|bool
name|ProgramBinary
operator|::
name|validateSamplers
parameter_list|(
name|InfoLog
modifier|*
name|infoLog
parameter_list|)
block|{
comment|// if any two active samplers in a program are of different types, but refer to the same
comment|// texture image unit, and this is the current program, then ValidateProgram will fail, and
comment|// DrawArrays and DrawElements will issue the INVALID_OPERATION error.
name|updateSamplerMapping
argument_list|()
expr_stmt|;
specifier|const
name|unsigned
name|int
name|maxCombinedTextureImageUnits
init|=
name|mRenderer
operator|->
name|getMaxCombinedTextureImageUnits
argument_list|()
decl_stmt|;
name|TextureType
name|textureUnitType
index|[
name|IMPLEMENTATION_MAX_COMBINED_TEXTURE_IMAGE_UNITS
index|]
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|IMPLEMENTATION_MAX_COMBINED_TEXTURE_IMAGE_UNITS
condition|;
operator|++
name|i
control|)
block|{
name|textureUnitType
index|[
name|i
index|]
operator|=
name|TEXTURE_UNKNOWN
expr_stmt|;
block|}
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mUsedPixelSamplerRange
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|active
condition|)
block|{
name|unsigned
name|int
name|unit
init|=
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|logicalTextureUnit
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|maxCombinedTextureImageUnits
condition|)
block|{
if|if
condition|(
name|infoLog
condition|)
block|{
name|infoLog
operator|->
name|append
argument_list|(
literal|"Sampler uniform (%d) exceeds IMPLEMENTATION_MAX_COMBINED_TEXTURE_IMAGE_UNITS (%d)"
argument_list|,
name|unit
argument_list|,
name|maxCombinedTextureImageUnits
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
if|if
condition|(
name|textureUnitType
index|[
name|unit
index|]
operator|!=
name|TEXTURE_UNKNOWN
condition|)
block|{
if|if
condition|(
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|textureType
operator|!=
name|textureUnitType
index|[
name|unit
index|]
condition|)
block|{
if|if
condition|(
name|infoLog
condition|)
block|{
name|infoLog
operator|->
name|append
argument_list|(
literal|"Samplers of conflicting types refer to the same texture image unit (%d)."
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
name|textureUnitType
index|[
name|unit
index|]
operator|=
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|textureType
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mUsedVertexSamplerRange
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|active
condition|)
block|{
name|unsigned
name|int
name|unit
init|=
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|logicalTextureUnit
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|maxCombinedTextureImageUnits
condition|)
block|{
if|if
condition|(
name|infoLog
condition|)
block|{
name|infoLog
operator|->
name|append
argument_list|(
literal|"Sampler uniform (%d) exceeds IMPLEMENTATION_MAX_COMBINED_TEXTURE_IMAGE_UNITS (%d)"
argument_list|,
name|unit
argument_list|,
name|maxCombinedTextureImageUnits
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
if|if
condition|(
name|textureUnitType
index|[
name|unit
index|]
operator|!=
name|TEXTURE_UNKNOWN
condition|)
block|{
if|if
condition|(
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|textureType
operator|!=
name|textureUnitType
index|[
name|unit
index|]
condition|)
block|{
if|if
condition|(
name|infoLog
condition|)
block|{
name|infoLog
operator|->
name|append
argument_list|(
literal|"Samplers of conflicting types refer to the same texture image unit (%d)."
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
name|textureUnitType
index|[
name|unit
index|]
operator|=
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|textureType
expr_stmt|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|Sampler
name|ProgramBinary
operator|::
name|Sampler
operator|::
name|Sampler
parameter_list|()
member_init_list|:
name|active
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|logicalTextureUnit
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|textureType
argument_list|(
name|TEXTURE_2D
argument_list|)
block|{ }
DECL|struct|AttributeSorter
struct|struct
name|AttributeSorter
block|{
DECL|function|AttributeSorter
name|AttributeSorter
argument_list|(
argument|const int (&semanticIndices)[MAX_VERTEX_ATTRIBS]
argument_list|)
public|:
name|originalIndices
parameter_list|(
name|semanticIndices
parameter_list|)
block|{     }
DECL|function|operator ()
name|bool
name|operator
name|()
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
if|if
condition|(
name|originalIndices
index|[
name|a
index|]
operator|==
operator|-
literal|1
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|originalIndices
index|[
name|b
index|]
operator|==
operator|-
literal|1
condition|)
return|return
literal|true
return|;
return|return
operator|(
name|originalIndices
index|[
name|a
index|]
operator|<
name|originalIndices
index|[
name|b
index|]
operator|)
return|;
block|}
DECL|member|originalIndices
specifier|const
name|int
argument_list|(
operator|&
name|originalIndices
argument_list|)
index|[
name|MAX_VERTEX_ATTRIBS
index|]
expr_stmt|;
block|}
struct|;
DECL|function|initAttributesByLayout
name|void
name|ProgramBinary
operator|::
name|initAttributesByLayout
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|i
operator|++
control|)
block|{
name|mAttributesByLayout
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
name|std
operator|::
name|sort
argument_list|(
operator|&
name|mAttributesByLayout
index|[
literal|0
index|]
argument_list|,
operator|&
name|mAttributesByLayout
index|[
name|MAX_VERTEX_ATTRIBS
index|]
argument_list|,
name|AttributeSorter
argument_list|(
name|mSemanticIndex
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|sortAttributesByLayout
name|void
name|ProgramBinary
operator|::
name|sortAttributesByLayout
parameter_list|(
name|rx
operator|::
name|TranslatedAttribute
name|attributes
index|[
name|MAX_VERTEX_ATTRIBS
index|]
parameter_list|,
name|int
name|sortedSemanticIndices
index|[
name|MAX_VERTEX_ATTRIBS
index|]
parameter_list|)
specifier|const
block|{
name|rx
operator|::
name|TranslatedAttribute
name|oldTranslatedAttributes
index|[
name|MAX_VERTEX_ATTRIBS
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|i
operator|++
control|)
block|{
name|oldTranslatedAttributes
index|[
name|i
index|]
operator|=
name|attributes
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|i
operator|++
control|)
block|{
name|int
name|oldIndex
init|=
name|mAttributesByLayout
index|[
name|i
index|]
decl_stmt|;
name|sortedSemanticIndices
index|[
name|i
index|]
operator|=
name|oldIndex
expr_stmt|;
name|attributes
index|[
name|i
index|]
operator|=
name|oldTranslatedAttributes
index|[
name|oldIndex
index|]
expr_stmt|;
block|}
block|}
DECL|function|initializeUniformStorage
name|void
name|ProgramBinary
operator|::
name|initializeUniformStorage
parameter_list|()
block|{
comment|// Compute total default block size
name|unsigned
name|int
name|vertexRegisters
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|fragmentRegisters
init|=
literal|0
decl_stmt|;
for|for
control|(
name|size_t
name|uniformIndex
init|=
literal|0
init|;
name|uniformIndex
operator|<
name|mUniforms
operator|.
name|size
argument_list|()
condition|;
name|uniformIndex
operator|++
control|)
block|{
specifier|const
name|LinkedUniform
modifier|&
name|uniform
init|=
operator|*
name|mUniforms
index|[
name|uniformIndex
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|IsSampler
argument_list|(
name|uniform
operator|.
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|uniform
operator|.
name|isReferencedByVertexShader
argument_list|()
condition|)
block|{
name|vertexRegisters
operator|=
name|std
operator|::
name|max
argument_list|(
name|vertexRegisters
argument_list|,
name|uniform
operator|.
name|vsRegisterIndex
operator|+
name|uniform
operator|.
name|registerCount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uniform
operator|.
name|isReferencedByFragmentShader
argument_list|()
condition|)
block|{
name|fragmentRegisters
operator|=
name|std
operator|::
name|max
argument_list|(
name|fragmentRegisters
argument_list|,
name|uniform
operator|.
name|psRegisterIndex
operator|+
name|uniform
operator|.
name|registerCount
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|mVertexUniformStorage
operator|=
name|mRenderer
operator|->
name|createUniformStorage
argument_list|(
name|vertexRegisters
operator|*
literal|16u
argument_list|)
expr_stmt|;
name|mFragmentUniformStorage
operator|=
name|mRenderer
operator|->
name|createUniformStorage
argument_list|(
name|fragmentRegisters
operator|*
literal|16u
argument_list|)
expr_stmt|;
block|}
DECL|function|reset
name|void
name|ProgramBinary
operator|::
name|reset
parameter_list|()
block|{
name|mVertexHLSL
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mVertexWorkarounds
operator|=
name|rx
operator|::
name|ANGLE_D3D_WORKAROUND_NONE
expr_stmt|;
name|SafeDeleteContainer
argument_list|(
name|mVertexExecutables
argument_list|)
expr_stmt|;
name|mPixelHLSL
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mPixelWorkarounds
operator|=
name|rx
operator|::
name|ANGLE_D3D_WORKAROUND_NONE
expr_stmt|;
name|mUsesFragDepth
operator|=
literal|false
expr_stmt|;
name|mPixelShaderKey
operator|.
name|clear
argument_list|()
expr_stmt|;
name|SafeDeleteContainer
argument_list|(
name|mPixelExecutables
argument_list|)
expr_stmt|;
name|SafeDelete
argument_list|(
name|mGeometryExecutable
argument_list|)
expr_stmt|;
name|mTransformFeedbackBufferMode
operator|=
name|GL_NONE
expr_stmt|;
name|mTransformFeedbackLinkedVaryings
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ArraySize
argument_list|(
name|mSamplersPS
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|mSamplersPS
index|[
name|i
index|]
operator|=
name|Sampler
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ArraySize
argument_list|(
name|mSamplersVS
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|mSamplersVS
index|[
name|i
index|]
operator|=
name|Sampler
argument_list|()
expr_stmt|;
block|}
name|mUsedVertexSamplerRange
operator|=
literal|0
expr_stmt|;
name|mUsedPixelSamplerRange
operator|=
literal|0
expr_stmt|;
name|mUsesPointSize
operator|=
literal|false
expr_stmt|;
name|mShaderVersion
operator|=
literal|0
expr_stmt|;
name|mDirtySamplerMapping
operator|=
literal|true
expr_stmt|;
name|SafeDeleteContainer
argument_list|(
name|mUniforms
argument_list|)
expr_stmt|;
name|SafeDeleteContainer
argument_list|(
name|mUniformBlocks
argument_list|)
expr_stmt|;
name|mUniformIndex
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mOutputVariables
operator|.
name|clear
argument_list|()
expr_stmt|;
name|SafeDelete
argument_list|(
name|mVertexUniformStorage
argument_list|)
expr_stmt|;
name|SafeDelete
argument_list|(
name|mFragmentUniformStorage
argument_list|)
expr_stmt|;
name|mValidated
operator|=
literal|false
expr_stmt|;
block|}
block|}
end_namespace
end_unit
