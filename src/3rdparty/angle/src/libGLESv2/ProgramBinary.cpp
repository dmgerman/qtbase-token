begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2012 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Program.cpp: Implements the gl::Program class. Implements GL program objects
end_comment
begin_comment
comment|// and related functionality. [OpenGL ES 2.0.24] section 2.10.3 page 28.
end_comment
begin_include
include|#
directive|include
file|"libGLESv2/BinaryStream.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Program.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/ProgramBinary.h"
end_include
begin_include
include|#
directive|include
file|"common/debug.h"
end_include
begin_include
include|#
directive|include
file|"common/version.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/main.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Shader.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/utilities.h"
end_include
begin_include
include|#
directive|include
file|<string>
end_include
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ANGLE_COMPILE_OPTIMIZATION_LEVEL
argument_list|)
end_if
begin_define
DECL|macro|ANGLE_COMPILE_OPTIMIZATION_LEVEL
define|#
directive|define
name|ANGLE_COMPILE_OPTIMIZATION_LEVEL
value|D3DCOMPILE_OPTIMIZATION_LEVEL3
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_namespace
DECL|namespace|gl
namespace|namespace
name|gl
block|{
DECL|function|str
name|std
operator|::
name|string
name|str
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|char
name|buffer
index|[
literal|20
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
DECL|function|Uniform
name|Uniform
operator|::
name|Uniform
parameter_list|(
name|GLenum
name|type
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|_name
parameter_list|,
name|unsigned
name|int
name|arraySize
parameter_list|)
member_init_list|:
name|type
argument_list|(
name|type
argument_list|)
member_init_list|,
name|_name
argument_list|(
name|_name
argument_list|)
member_init_list|,
name|name
argument_list|(
name|ProgramBinary
operator|::
name|undecorateUniform
argument_list|(
name|_name
argument_list|)
argument_list|)
member_init_list|,
name|arraySize
argument_list|(
name|arraySize
argument_list|)
block|{
name|int
name|bytes
init|=
name|UniformInternalSize
argument_list|(
name|type
argument_list|)
operator|*
name|arraySize
decl_stmt|;
name|data
operator|=
operator|new
name|unsigned
name|char
index|[
name|bytes
index|]
expr_stmt|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|dirty
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|~Uniform
name|Uniform
operator|::
name|~
name|Uniform
parameter_list|()
block|{
operator|delete
index|[]
name|data
expr_stmt|;
block|}
DECL|function|isArray
name|bool
name|Uniform
operator|::
name|isArray
parameter_list|()
block|{
name|size_t
name|dot
init|=
name|_name
operator|.
name|find_last_of
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
if|if
condition|(
name|dot
operator|==
name|std
operator|::
name|string
operator|::
name|npos
condition|)
name|dot
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|_name
operator|.
name|compare
argument_list|(
name|dot
operator|+
literal|1
argument_list|,
name|dot
operator|+
literal|4
argument_list|,
literal|"ar_"
argument_list|)
operator|==
literal|0
return|;
block|}
DECL|function|UniformLocation
name|UniformLocation
operator|::
name|UniformLocation
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|_name
parameter_list|,
name|unsigned
name|int
name|element
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|)
member_init_list|:
name|name
argument_list|(
name|ProgramBinary
operator|::
name|undecorateUniform
argument_list|(
name|_name
argument_list|)
argument_list|)
member_init_list|,
name|element
argument_list|(
name|element
argument_list|)
member_init_list|,
name|index
argument_list|(
name|index
argument_list|)
block|{ }
DECL|member|mCurrentSerial
name|unsigned
name|int
name|ProgramBinary
operator|::
name|mCurrentSerial
init|=
literal|1
decl_stmt|;
DECL|function|ProgramBinary
name|ProgramBinary
operator|::
name|ProgramBinary
parameter_list|()
member_init_list|:
name|RefCountObject
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mSerial
argument_list|(
name|issueSerial
argument_list|()
argument_list|)
block|{
name|mDevice
operator|=
name|getDevice
argument_list|()
expr_stmt|;
name|mPixelExecutable
operator|=
name|NULL
expr_stmt|;
name|mVertexExecutable
operator|=
name|NULL
expr_stmt|;
name|mConstantTablePS
operator|=
name|NULL
expr_stmt|;
name|mConstantTableVS
operator|=
name|NULL
expr_stmt|;
name|mValidated
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|index
operator|++
control|)
block|{
name|mSemanticIndex
index|[
name|index
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
for|for
control|(
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
name|MAX_TEXTURE_IMAGE_UNITS
condition|;
name|index
operator|++
control|)
block|{
name|mSamplersPS
index|[
name|index
index|]
operator|.
name|active
operator|=
literal|false
expr_stmt|;
block|}
for|for
control|(
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
name|MAX_VERTEX_TEXTURE_IMAGE_UNITS_VTF
condition|;
name|index
operator|++
control|)
block|{
name|mSamplersVS
index|[
name|index
index|]
operator|.
name|active
operator|=
literal|false
expr_stmt|;
block|}
name|mUsedVertexSamplerRange
operator|=
literal|0
expr_stmt|;
name|mUsedPixelSamplerRange
operator|=
literal|0
expr_stmt|;
name|mDxDepthRangeLocation
operator|=
operator|-
literal|1
expr_stmt|;
name|mDxDepthLocation
operator|=
operator|-
literal|1
expr_stmt|;
name|mDxCoordLocation
operator|=
operator|-
literal|1
expr_stmt|;
name|mDxHalfPixelSizeLocation
operator|=
operator|-
literal|1
expr_stmt|;
name|mDxFrontCCWLocation
operator|=
operator|-
literal|1
expr_stmt|;
name|mDxPointsOrLinesLocation
operator|=
operator|-
literal|1
expr_stmt|;
block|}
DECL|function|~ProgramBinary
name|ProgramBinary
operator|::
name|~
name|ProgramBinary
parameter_list|()
block|{
if|if
condition|(
name|mPixelExecutable
condition|)
block|{
name|mPixelExecutable
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|mVertexExecutable
condition|)
block|{
name|mVertexExecutable
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
operator|delete
name|mConstantTablePS
expr_stmt|;
operator|delete
name|mConstantTableVS
expr_stmt|;
while|while
condition|(
operator|!
name|mUniforms
operator|.
name|empty
argument_list|()
condition|)
block|{
operator|delete
name|mUniforms
operator|.
name|back
argument_list|()
expr_stmt|;
name|mUniforms
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|getSerial
name|unsigned
name|int
name|ProgramBinary
operator|::
name|getSerial
parameter_list|()
specifier|const
block|{
return|return
name|mSerial
return|;
block|}
DECL|function|issueSerial
name|unsigned
name|int
name|ProgramBinary
operator|::
name|issueSerial
parameter_list|()
block|{
return|return
name|mCurrentSerial
operator|++
return|;
block|}
DECL|function|getPixelShader
name|IDirect3DPixelShader9
modifier|*
name|ProgramBinary
operator|::
name|getPixelShader
parameter_list|()
block|{
return|return
name|mPixelExecutable
return|;
block|}
DECL|function|getVertexShader
name|IDirect3DVertexShader9
modifier|*
name|ProgramBinary
operator|::
name|getVertexShader
parameter_list|()
block|{
return|return
name|mVertexExecutable
return|;
block|}
DECL|function|getAttributeLocation
name|GLuint
name|ProgramBinary
operator|::
name|getAttributeLocation
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
condition|)
block|{
for|for
control|(
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|mLinkedAttribute
index|[
name|index
index|]
operator|.
name|name
operator|==
name|std
operator|::
name|string
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
name|index
return|;
block|}
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
DECL|function|getSemanticIndex
name|int
name|ProgramBinary
operator|::
name|getSemanticIndex
parameter_list|(
name|int
name|attributeIndex
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|attributeIndex
operator|>=
literal|0
operator|&&
name|attributeIndex
operator|<
name|MAX_VERTEX_ATTRIBS
argument_list|)
expr_stmt|;
return|return
name|mSemanticIndex
index|[
name|attributeIndex
index|]
return|;
block|}
comment|// Returns one more than the highest sampler index used.
DECL|function|getUsedSamplerRange
name|GLint
name|ProgramBinary
operator|::
name|getUsedSamplerRange
parameter_list|(
name|SamplerType
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SAMPLER_PIXEL
case|:
return|return
name|mUsedPixelSamplerRange
return|;
case|case
name|SAMPLER_VERTEX
case|:
return|return
name|mUsedVertexSamplerRange
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|usesPointSize
name|bool
name|ProgramBinary
operator|::
name|usesPointSize
parameter_list|()
specifier|const
block|{
return|return
name|mUsesPointSize
return|;
block|}
comment|// Returns the index of the texture image unit (0-19) corresponding to a Direct3D 9 sampler
comment|// index (0-15 for the pixel shader and 0-3 for the vertex shader).
DECL|function|getSamplerMapping
name|GLint
name|ProgramBinary
operator|::
name|getSamplerMapping
parameter_list|(
name|SamplerType
name|type
parameter_list|,
name|unsigned
name|int
name|samplerIndex
parameter_list|)
block|{
name|GLint
name|logicalTextureUnit
init|=
operator|-
literal|1
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SAMPLER_PIXEL
case|:
name|ASSERT
argument_list|(
name|samplerIndex
operator|<
sizeof|sizeof
argument_list|(
name|mSamplersPS
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mSamplersPS
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mSamplersPS
index|[
name|samplerIndex
index|]
operator|.
name|active
condition|)
block|{
name|logicalTextureUnit
operator|=
name|mSamplersPS
index|[
name|samplerIndex
index|]
operator|.
name|logicalTextureUnit
expr_stmt|;
block|}
break|break;
case|case
name|SAMPLER_VERTEX
case|:
name|ASSERT
argument_list|(
name|samplerIndex
operator|<
sizeof|sizeof
argument_list|(
name|mSamplersVS
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mSamplersVS
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mSamplersVS
index|[
name|samplerIndex
index|]
operator|.
name|active
condition|)
block|{
name|logicalTextureUnit
operator|=
name|mSamplersVS
index|[
name|samplerIndex
index|]
operator|.
name|logicalTextureUnit
expr_stmt|;
block|}
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|logicalTextureUnit
operator|>=
literal|0
operator|&&
name|logicalTextureUnit
operator|<
operator|(
name|GLint
operator|)
name|getContext
argument_list|()
operator|->
name|getMaximumCombinedTextureImageUnits
argument_list|()
condition|)
block|{
return|return
name|logicalTextureUnit
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|// Returns the texture type for a given Direct3D 9 sampler type and
comment|// index (0-15 for the pixel shader and 0-3 for the vertex shader).
DECL|function|getSamplerTextureType
name|TextureType
name|ProgramBinary
operator|::
name|getSamplerTextureType
parameter_list|(
name|SamplerType
name|type
parameter_list|,
name|unsigned
name|int
name|samplerIndex
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SAMPLER_PIXEL
case|:
name|ASSERT
argument_list|(
name|samplerIndex
operator|<
sizeof|sizeof
argument_list|(
name|mSamplersPS
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mSamplersPS
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mSamplersPS
index|[
name|samplerIndex
index|]
operator|.
name|active
argument_list|)
expr_stmt|;
return|return
name|mSamplersPS
index|[
name|samplerIndex
index|]
operator|.
name|textureType
return|;
case|case
name|SAMPLER_VERTEX
case|:
name|ASSERT
argument_list|(
name|samplerIndex
operator|<
sizeof|sizeof
argument_list|(
name|mSamplersVS
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mSamplersVS
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mSamplersVS
index|[
name|samplerIndex
index|]
operator|.
name|active
argument_list|)
expr_stmt|;
return|return
name|mSamplersVS
index|[
name|samplerIndex
index|]
operator|.
name|textureType
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
name|TEXTURE_2D
return|;
block|}
DECL|function|getUniformLocation
name|GLint
name|ProgramBinary
operator|::
name|getUniformLocation
parameter_list|(
name|std
operator|::
name|string
name|name
parameter_list|)
block|{
name|unsigned
name|int
name|subscript
init|=
literal|0
decl_stmt|;
comment|// Strip any trailing array operator and retrieve the subscript
name|size_t
name|open
init|=
name|name
operator|.
name|find_last_of
argument_list|(
literal|'['
argument_list|)
decl_stmt|;
name|size_t
name|close
init|=
name|name
operator|.
name|find_last_of
argument_list|(
literal|']'
argument_list|)
decl_stmt|;
if|if
condition|(
name|open
operator|!=
name|std
operator|::
name|string
operator|::
name|npos
operator|&&
name|close
operator|==
name|name
operator|.
name|length
argument_list|()
operator|-
literal|1
condition|)
block|{
name|subscript
operator|=
name|atoi
argument_list|(
name|name
operator|.
name|substr
argument_list|(
name|open
operator|+
literal|1
argument_list|)
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|name
operator|.
name|erase
argument_list|(
name|open
argument_list|)
expr_stmt|;
block|}
name|unsigned
name|int
name|numUniforms
init|=
name|mUniformIndex
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|location
init|=
literal|0
init|;
name|location
operator|<
name|numUniforms
condition|;
name|location
operator|++
control|)
block|{
if|if
condition|(
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|name
operator|==
name|name
operator|&&
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|==
name|subscript
condition|)
block|{
return|return
name|location
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
DECL|function|setUniform1fv
name|bool
name|ProgramBinary
operator|::
name|setUniform1fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
name|location
operator|<
literal|0
operator|||
name|location
operator|>=
operator|(
name|int
operator|)
name|mUniformIndex
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Uniform
modifier|*
name|targetUniform
init|=
name|mUniforms
index|[
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|index
index|]
decl_stmt|;
name|targetUniform
operator|->
name|dirty
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|GL_FLOAT
condition|)
block|{
name|int
name|arraySize
init|=
name|targetUniform
operator|->
name|arraySize
decl_stmt|;
if|if
condition|(
name|arraySize
operator|==
literal|1
operator|&&
name|count
operator|>
literal|1
condition|)
return|return
literal|false
return|;
comment|// attempting to write an array to a non-array uniform is an INVALID_OPERATION
name|count
operator|=
name|std
operator|::
name|min
argument_list|(
name|arraySize
operator|-
operator|(
name|int
operator|)
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|GLfloat
modifier|*
name|target
init|=
operator|(
name|GLfloat
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|target
index|[
literal|0
index|]
operator|=
name|v
index|[
literal|0
index|]
expr_stmt|;
name|target
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|target
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|target
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|target
operator|+=
literal|4
expr_stmt|;
name|v
operator|+=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|GL_BOOL
condition|)
block|{
name|int
name|arraySize
init|=
name|targetUniform
operator|->
name|arraySize
decl_stmt|;
if|if
condition|(
name|arraySize
operator|==
literal|1
operator|&&
name|count
operator|>
literal|1
condition|)
return|return
literal|false
return|;
comment|// attempting to write an array to a non-array uniform is an INVALID_OPERATION
name|count
operator|=
name|std
operator|::
name|min
argument_list|(
name|arraySize
operator|-
operator|(
name|int
operator|)
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|GLboolean
modifier|*
name|boolParams
init|=
operator|(
name|GLboolean
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|v
index|[
name|i
index|]
operator|==
literal|0.0f
condition|)
block|{
name|boolParams
index|[
name|i
index|]
operator|=
name|GL_FALSE
expr_stmt|;
block|}
else|else
block|{
name|boolParams
index|[
name|i
index|]
operator|=
name|GL_TRUE
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|setUniform2fv
name|bool
name|ProgramBinary
operator|::
name|setUniform2fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
name|location
operator|<
literal|0
operator|||
name|location
operator|>=
operator|(
name|int
operator|)
name|mUniformIndex
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Uniform
modifier|*
name|targetUniform
init|=
name|mUniforms
index|[
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|index
index|]
decl_stmt|;
name|targetUniform
operator|->
name|dirty
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|GL_FLOAT_VEC2
condition|)
block|{
name|int
name|arraySize
init|=
name|targetUniform
operator|->
name|arraySize
decl_stmt|;
if|if
condition|(
name|arraySize
operator|==
literal|1
operator|&&
name|count
operator|>
literal|1
condition|)
return|return
literal|false
return|;
comment|// attempting to write an array to a non-array uniform is an INVALID_OPERATION
name|count
operator|=
name|std
operator|::
name|min
argument_list|(
name|arraySize
operator|-
operator|(
name|int
operator|)
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|GLfloat
modifier|*
name|target
init|=
operator|(
name|GLfloat
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|target
index|[
literal|0
index|]
operator|=
name|v
index|[
literal|0
index|]
expr_stmt|;
name|target
index|[
literal|1
index|]
operator|=
name|v
index|[
literal|1
index|]
expr_stmt|;
name|target
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|target
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|target
operator|+=
literal|4
expr_stmt|;
name|v
operator|+=
literal|2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|GL_BOOL_VEC2
condition|)
block|{
name|int
name|arraySize
init|=
name|targetUniform
operator|->
name|arraySize
decl_stmt|;
if|if
condition|(
name|arraySize
operator|==
literal|1
operator|&&
name|count
operator|>
literal|1
condition|)
return|return
literal|false
return|;
comment|// attempting to write an array to a non-array uniform is an INVALID_OPERATION
name|count
operator|=
name|std
operator|::
name|min
argument_list|(
name|arraySize
operator|-
operator|(
name|int
operator|)
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|GLboolean
modifier|*
name|boolParams
init|=
operator|(
name|GLboolean
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|2
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
operator|*
literal|2
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|v
index|[
name|i
index|]
operator|==
literal|0.0f
condition|)
block|{
name|boolParams
index|[
name|i
index|]
operator|=
name|GL_FALSE
expr_stmt|;
block|}
else|else
block|{
name|boolParams
index|[
name|i
index|]
operator|=
name|GL_TRUE
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|setUniform3fv
name|bool
name|ProgramBinary
operator|::
name|setUniform3fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
name|location
operator|<
literal|0
operator|||
name|location
operator|>=
operator|(
name|int
operator|)
name|mUniformIndex
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Uniform
modifier|*
name|targetUniform
init|=
name|mUniforms
index|[
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|index
index|]
decl_stmt|;
name|targetUniform
operator|->
name|dirty
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|GL_FLOAT_VEC3
condition|)
block|{
name|int
name|arraySize
init|=
name|targetUniform
operator|->
name|arraySize
decl_stmt|;
if|if
condition|(
name|arraySize
operator|==
literal|1
operator|&&
name|count
operator|>
literal|1
condition|)
return|return
literal|false
return|;
comment|// attempting to write an array to a non-array uniform is an INVALID_OPERATION
name|count
operator|=
name|std
operator|::
name|min
argument_list|(
name|arraySize
operator|-
operator|(
name|int
operator|)
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|GLfloat
modifier|*
name|target
init|=
operator|(
name|GLfloat
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|target
index|[
literal|0
index|]
operator|=
name|v
index|[
literal|0
index|]
expr_stmt|;
name|target
index|[
literal|1
index|]
operator|=
name|v
index|[
literal|1
index|]
expr_stmt|;
name|target
index|[
literal|2
index|]
operator|=
name|v
index|[
literal|2
index|]
expr_stmt|;
name|target
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|target
operator|+=
literal|4
expr_stmt|;
name|v
operator|+=
literal|3
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|GL_BOOL_VEC3
condition|)
block|{
name|int
name|arraySize
init|=
name|targetUniform
operator|->
name|arraySize
decl_stmt|;
if|if
condition|(
name|arraySize
operator|==
literal|1
operator|&&
name|count
operator|>
literal|1
condition|)
return|return
literal|false
return|;
comment|// attempting to write an array to a non-array uniform is an INVALID_OPERATION
name|count
operator|=
name|std
operator|::
name|min
argument_list|(
name|arraySize
operator|-
operator|(
name|int
operator|)
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|GLboolean
modifier|*
name|boolParams
init|=
operator|(
name|GLboolean
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|3
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
operator|*
literal|3
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|v
index|[
name|i
index|]
operator|==
literal|0.0f
condition|)
block|{
name|boolParams
index|[
name|i
index|]
operator|=
name|GL_FALSE
expr_stmt|;
block|}
else|else
block|{
name|boolParams
index|[
name|i
index|]
operator|=
name|GL_TRUE
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|setUniform4fv
name|bool
name|ProgramBinary
operator|::
name|setUniform4fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
name|location
operator|<
literal|0
operator|||
name|location
operator|>=
operator|(
name|int
operator|)
name|mUniformIndex
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Uniform
modifier|*
name|targetUniform
init|=
name|mUniforms
index|[
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|index
index|]
decl_stmt|;
name|targetUniform
operator|->
name|dirty
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|GL_FLOAT_VEC4
condition|)
block|{
name|int
name|arraySize
init|=
name|targetUniform
operator|->
name|arraySize
decl_stmt|;
if|if
condition|(
name|arraySize
operator|==
literal|1
operator|&&
name|count
operator|>
literal|1
condition|)
return|return
literal|false
return|;
comment|// attempting to write an array to a non-array uniform is an INVALID_OPERATION
name|count
operator|=
name|std
operator|::
name|min
argument_list|(
name|arraySize
operator|-
operator|(
name|int
operator|)
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
sizeof|sizeof
argument_list|(
name|GLfloat
argument_list|)
operator|*
literal|4
argument_list|,
name|v
argument_list|,
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|GLfloat
argument_list|)
operator|*
name|count
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|GL_BOOL_VEC4
condition|)
block|{
name|int
name|arraySize
init|=
name|targetUniform
operator|->
name|arraySize
decl_stmt|;
if|if
condition|(
name|arraySize
operator|==
literal|1
operator|&&
name|count
operator|>
literal|1
condition|)
return|return
literal|false
return|;
comment|// attempting to write an array to a non-array uniform is an INVALID_OPERATION
name|count
operator|=
name|std
operator|::
name|min
argument_list|(
name|arraySize
operator|-
operator|(
name|int
operator|)
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|GLboolean
modifier|*
name|boolParams
init|=
operator|(
name|GLboolean
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
operator|*
literal|4
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|v
index|[
name|i
index|]
operator|==
literal|0.0f
condition|)
block|{
name|boolParams
index|[
name|i
index|]
operator|=
name|GL_FALSE
expr_stmt|;
block|}
else|else
block|{
name|boolParams
index|[
name|i
index|]
operator|=
name|GL_TRUE
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
template|template
parameter_list|<
name|typename
name|T
parameter_list|,
name|int
name|targetWidth
parameter_list|,
name|int
name|targetHeight
parameter_list|,
name|int
name|srcWidth
parameter_list|,
name|int
name|srcHeight
parameter_list|>
DECL|function|transposeMatrix
name|void
name|transposeMatrix
parameter_list|(
name|T
modifier|*
name|target
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
name|int
name|copyWidth
init|=
name|std
operator|::
name|min
argument_list|(
name|targetWidth
argument_list|,
name|srcWidth
argument_list|)
decl_stmt|;
name|int
name|copyHeight
init|=
name|std
operator|::
name|min
argument_list|(
name|targetHeight
argument_list|,
name|srcHeight
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|copyWidth
condition|;
name|x
operator|++
control|)
block|{
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|copyHeight
condition|;
name|y
operator|++
control|)
block|{
name|target
index|[
name|x
operator|*
name|targetWidth
operator|+
name|y
index|]
operator|=
operator|(
name|T
operator|)
name|value
index|[
name|y
operator|*
name|srcWidth
operator|+
name|x
index|]
expr_stmt|;
block|}
block|}
comment|// clear unfilled right side
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|copyHeight
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
name|srcWidth
init|;
name|x
operator|<
name|targetWidth
condition|;
name|x
operator|++
control|)
block|{
name|target
index|[
name|y
operator|*
name|targetWidth
operator|+
name|x
index|]
operator|=
operator|(
name|T
operator|)
literal|0
expr_stmt|;
block|}
block|}
comment|// clear unfilled bottom.
for|for
control|(
name|int
name|y
init|=
name|srcHeight
init|;
name|y
operator|<
name|targetHeight
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|targetWidth
condition|;
name|x
operator|++
control|)
block|{
name|target
index|[
name|y
operator|*
name|targetWidth
operator|+
name|x
index|]
operator|=
operator|(
name|T
operator|)
literal|0
expr_stmt|;
block|}
block|}
block|}
DECL|function|setUniformMatrix2fv
name|bool
name|ProgramBinary
operator|::
name|setUniformMatrix2fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
name|location
operator|<
literal|0
operator|||
name|location
operator|>=
operator|(
name|int
operator|)
name|mUniformIndex
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Uniform
modifier|*
name|targetUniform
init|=
name|mUniforms
index|[
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|index
index|]
decl_stmt|;
name|targetUniform
operator|->
name|dirty
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|!=
name|GL_FLOAT_MAT2
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|arraySize
init|=
name|targetUniform
operator|->
name|arraySize
decl_stmt|;
if|if
condition|(
name|arraySize
operator|==
literal|1
operator|&&
name|count
operator|>
literal|1
condition|)
return|return
literal|false
return|;
comment|// attempting to write an array to a non-array uniform is an INVALID_OPERATION
name|count
operator|=
name|std
operator|::
name|min
argument_list|(
name|arraySize
operator|-
operator|(
name|int
operator|)
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|GLfloat
modifier|*
name|target
init|=
operator|(
name|GLfloat
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|8
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|transposeMatrix
argument_list|<
name|GLfloat
argument_list|,
literal|4
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|>
argument_list|(
name|target
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|target
operator|+=
literal|8
expr_stmt|;
name|value
operator|+=
literal|4
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|setUniformMatrix3fv
name|bool
name|ProgramBinary
operator|::
name|setUniformMatrix3fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
name|location
operator|<
literal|0
operator|||
name|location
operator|>=
operator|(
name|int
operator|)
name|mUniformIndex
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Uniform
modifier|*
name|targetUniform
init|=
name|mUniforms
index|[
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|index
index|]
decl_stmt|;
name|targetUniform
operator|->
name|dirty
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|!=
name|GL_FLOAT_MAT3
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|arraySize
init|=
name|targetUniform
operator|->
name|arraySize
decl_stmt|;
if|if
condition|(
name|arraySize
operator|==
literal|1
operator|&&
name|count
operator|>
literal|1
condition|)
return|return
literal|false
return|;
comment|// attempting to write an array to a non-array uniform is an INVALID_OPERATION
name|count
operator|=
name|std
operator|::
name|min
argument_list|(
name|arraySize
operator|-
operator|(
name|int
operator|)
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|GLfloat
modifier|*
name|target
init|=
operator|(
name|GLfloat
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|12
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|transposeMatrix
argument_list|<
name|GLfloat
argument_list|,
literal|4
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|>
argument_list|(
name|target
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|target
operator|+=
literal|12
expr_stmt|;
name|value
operator|+=
literal|9
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|setUniformMatrix4fv
name|bool
name|ProgramBinary
operator|::
name|setUniformMatrix4fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
name|location
operator|<
literal|0
operator|||
name|location
operator|>=
operator|(
name|int
operator|)
name|mUniformIndex
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Uniform
modifier|*
name|targetUniform
init|=
name|mUniforms
index|[
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|index
index|]
decl_stmt|;
name|targetUniform
operator|->
name|dirty
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|!=
name|GL_FLOAT_MAT4
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|arraySize
init|=
name|targetUniform
operator|->
name|arraySize
decl_stmt|;
if|if
condition|(
name|arraySize
operator|==
literal|1
operator|&&
name|count
operator|>
literal|1
condition|)
return|return
literal|false
return|;
comment|// attempting to write an array to a non-array uniform is an INVALID_OPERATION
name|count
operator|=
name|std
operator|::
name|min
argument_list|(
name|arraySize
operator|-
operator|(
name|int
operator|)
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|GLfloat
modifier|*
name|target
init|=
operator|(
name|GLfloat
operator|*
operator|)
operator|(
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
sizeof|sizeof
argument_list|(
name|GLfloat
argument_list|)
operator|*
literal|16
operator|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|transposeMatrix
argument_list|<
name|GLfloat
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|>
argument_list|(
name|target
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|target
operator|+=
literal|16
expr_stmt|;
name|value
operator|+=
literal|16
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|setUniform1iv
name|bool
name|ProgramBinary
operator|::
name|setUniform1iv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
name|location
operator|<
literal|0
operator|||
name|location
operator|>=
operator|(
name|int
operator|)
name|mUniformIndex
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Uniform
modifier|*
name|targetUniform
init|=
name|mUniforms
index|[
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|index
index|]
decl_stmt|;
name|targetUniform
operator|->
name|dirty
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|GL_INT
operator|||
name|targetUniform
operator|->
name|type
operator|==
name|GL_SAMPLER_2D
operator|||
name|targetUniform
operator|->
name|type
operator|==
name|GL_SAMPLER_CUBE
condition|)
block|{
name|int
name|arraySize
init|=
name|targetUniform
operator|->
name|arraySize
decl_stmt|;
if|if
condition|(
name|arraySize
operator|==
literal|1
operator|&&
name|count
operator|>
literal|1
condition|)
return|return
literal|false
return|;
comment|// attempting to write an array to a non-array uniform is an INVALID_OPERATION
name|count
operator|=
name|std
operator|::
name|min
argument_list|(
name|arraySize
operator|-
operator|(
name|int
operator|)
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
sizeof|sizeof
argument_list|(
name|GLint
argument_list|)
argument_list|,
name|v
argument_list|,
sizeof|sizeof
argument_list|(
name|GLint
argument_list|)
operator|*
name|count
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|GL_BOOL
condition|)
block|{
name|int
name|arraySize
init|=
name|targetUniform
operator|->
name|arraySize
decl_stmt|;
if|if
condition|(
name|arraySize
operator|==
literal|1
operator|&&
name|count
operator|>
literal|1
condition|)
return|return
literal|false
return|;
comment|// attempting to write an array to a non-array uniform is an INVALID_OPERATION
name|count
operator|=
name|std
operator|::
name|min
argument_list|(
name|arraySize
operator|-
operator|(
name|int
operator|)
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|GLboolean
modifier|*
name|boolParams
init|=
operator|(
name|GLboolean
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|v
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|boolParams
index|[
name|i
index|]
operator|=
name|GL_FALSE
expr_stmt|;
block|}
else|else
block|{
name|boolParams
index|[
name|i
index|]
operator|=
name|GL_TRUE
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|setUniform2iv
name|bool
name|ProgramBinary
operator|::
name|setUniform2iv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
name|location
operator|<
literal|0
operator|||
name|location
operator|>=
operator|(
name|int
operator|)
name|mUniformIndex
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Uniform
modifier|*
name|targetUniform
init|=
name|mUniforms
index|[
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|index
index|]
decl_stmt|;
name|targetUniform
operator|->
name|dirty
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|GL_INT_VEC2
condition|)
block|{
name|int
name|arraySize
init|=
name|targetUniform
operator|->
name|arraySize
decl_stmt|;
if|if
condition|(
name|arraySize
operator|==
literal|1
operator|&&
name|count
operator|>
literal|1
condition|)
return|return
literal|false
return|;
comment|// attempting to write an array to a non-array uniform is an INVALID_OPERATION
name|count
operator|=
name|std
operator|::
name|min
argument_list|(
name|arraySize
operator|-
operator|(
name|int
operator|)
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
sizeof|sizeof
argument_list|(
name|GLint
argument_list|)
operator|*
literal|2
argument_list|,
name|v
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|GLint
argument_list|)
operator|*
name|count
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|GL_BOOL_VEC2
condition|)
block|{
name|int
name|arraySize
init|=
name|targetUniform
operator|->
name|arraySize
decl_stmt|;
if|if
condition|(
name|arraySize
operator|==
literal|1
operator|&&
name|count
operator|>
literal|1
condition|)
return|return
literal|false
return|;
comment|// attempting to write an array to a non-array uniform is an INVALID_OPERATION
name|count
operator|=
name|std
operator|::
name|min
argument_list|(
name|arraySize
operator|-
operator|(
name|int
operator|)
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|GLboolean
modifier|*
name|boolParams
init|=
operator|(
name|GLboolean
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|2
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
operator|*
literal|2
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|v
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|boolParams
index|[
name|i
index|]
operator|=
name|GL_FALSE
expr_stmt|;
block|}
else|else
block|{
name|boolParams
index|[
name|i
index|]
operator|=
name|GL_TRUE
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|setUniform3iv
name|bool
name|ProgramBinary
operator|::
name|setUniform3iv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
name|location
operator|<
literal|0
operator|||
name|location
operator|>=
operator|(
name|int
operator|)
name|mUniformIndex
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Uniform
modifier|*
name|targetUniform
init|=
name|mUniforms
index|[
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|index
index|]
decl_stmt|;
name|targetUniform
operator|->
name|dirty
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|GL_INT_VEC3
condition|)
block|{
name|int
name|arraySize
init|=
name|targetUniform
operator|->
name|arraySize
decl_stmt|;
if|if
condition|(
name|arraySize
operator|==
literal|1
operator|&&
name|count
operator|>
literal|1
condition|)
return|return
literal|false
return|;
comment|// attempting to write an array to a non-array uniform is an INVALID_OPERATION
name|count
operator|=
name|std
operator|::
name|min
argument_list|(
name|arraySize
operator|-
operator|(
name|int
operator|)
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
sizeof|sizeof
argument_list|(
name|GLint
argument_list|)
operator|*
literal|3
argument_list|,
name|v
argument_list|,
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|GLint
argument_list|)
operator|*
name|count
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|GL_BOOL_VEC3
condition|)
block|{
name|int
name|arraySize
init|=
name|targetUniform
operator|->
name|arraySize
decl_stmt|;
if|if
condition|(
name|arraySize
operator|==
literal|1
operator|&&
name|count
operator|>
literal|1
condition|)
return|return
literal|false
return|;
comment|// attempting to write an array to a non-array uniform is an INVALID_OPERATION
name|count
operator|=
name|std
operator|::
name|min
argument_list|(
name|arraySize
operator|-
operator|(
name|int
operator|)
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|GLboolean
modifier|*
name|boolParams
init|=
operator|(
name|GLboolean
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|3
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
operator|*
literal|3
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|v
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|boolParams
index|[
name|i
index|]
operator|=
name|GL_FALSE
expr_stmt|;
block|}
else|else
block|{
name|boolParams
index|[
name|i
index|]
operator|=
name|GL_TRUE
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|setUniform4iv
name|bool
name|ProgramBinary
operator|::
name|setUniform4iv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
name|location
operator|<
literal|0
operator|||
name|location
operator|>=
operator|(
name|int
operator|)
name|mUniformIndex
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Uniform
modifier|*
name|targetUniform
init|=
name|mUniforms
index|[
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|index
index|]
decl_stmt|;
name|targetUniform
operator|->
name|dirty
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|GL_INT_VEC4
condition|)
block|{
name|int
name|arraySize
init|=
name|targetUniform
operator|->
name|arraySize
decl_stmt|;
if|if
condition|(
name|arraySize
operator|==
literal|1
operator|&&
name|count
operator|>
literal|1
condition|)
return|return
literal|false
return|;
comment|// attempting to write an array to a non-array uniform is an INVALID_OPERATION
name|count
operator|=
name|std
operator|::
name|min
argument_list|(
name|arraySize
operator|-
operator|(
name|int
operator|)
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
sizeof|sizeof
argument_list|(
name|GLint
argument_list|)
operator|*
literal|4
argument_list|,
name|v
argument_list|,
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|GLint
argument_list|)
operator|*
name|count
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|GL_BOOL_VEC4
condition|)
block|{
name|int
name|arraySize
init|=
name|targetUniform
operator|->
name|arraySize
decl_stmt|;
if|if
condition|(
name|arraySize
operator|==
literal|1
operator|&&
name|count
operator|>
literal|1
condition|)
return|return
literal|false
return|;
comment|// attempting to write an array to a non-array uniform is an INVALID_OPERATION
name|count
operator|=
name|std
operator|::
name|min
argument_list|(
name|arraySize
operator|-
operator|(
name|int
operator|)
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|GLboolean
modifier|*
name|boolParams
init|=
operator|(
name|GLboolean
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
operator|*
literal|4
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|v
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|boolParams
index|[
name|i
index|]
operator|=
name|GL_FALSE
expr_stmt|;
block|}
else|else
block|{
name|boolParams
index|[
name|i
index|]
operator|=
name|GL_TRUE
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|getUniformfv
name|bool
name|ProgramBinary
operator|::
name|getUniformfv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
modifier|*
name|bufSize
parameter_list|,
name|GLfloat
modifier|*
name|params
parameter_list|)
block|{
if|if
condition|(
name|location
operator|<
literal|0
operator|||
name|location
operator|>=
operator|(
name|int
operator|)
name|mUniformIndex
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Uniform
modifier|*
name|targetUniform
init|=
name|mUniforms
index|[
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|index
index|]
decl_stmt|;
comment|// sized queries -- ensure the provided buffer is large enough
if|if
condition|(
name|bufSize
condition|)
block|{
name|int
name|requiredBytes
init|=
name|UniformExternalSize
argument_list|(
name|targetUniform
operator|->
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|bufSize
operator|<
name|requiredBytes
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
switch|switch
condition|(
name|targetUniform
operator|->
name|type
condition|)
block|{
case|case
name|GL_FLOAT_MAT2
case|:
name|transposeMatrix
argument_list|<
name|GLfloat
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|4
argument_list|,
literal|2
argument_list|>
argument_list|(
name|params
argument_list|,
operator|(
name|GLfloat
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_FLOAT_MAT3
case|:
name|transposeMatrix
argument_list|<
name|GLfloat
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|3
argument_list|>
argument_list|(
name|params
argument_list|,
operator|(
name|GLfloat
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|12
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_FLOAT_MAT4
case|:
name|transposeMatrix
argument_list|<
name|GLfloat
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|>
argument_list|(
name|params
argument_list|,
operator|(
name|GLfloat
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|16
argument_list|)
expr_stmt|;
break|break;
default|default:
block|{
name|unsigned
name|int
name|count
init|=
name|UniformExternalComponentCount
argument_list|(
name|targetUniform
operator|->
name|type
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|internalCount
init|=
name|UniformInternalComponentCount
argument_list|(
name|targetUniform
operator|->
name|type
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|UniformComponentType
argument_list|(
name|targetUniform
operator|->
name|type
argument_list|)
condition|)
block|{
case|case
name|GL_BOOL
case|:
block|{
name|GLboolean
modifier|*
name|boolParams
init|=
operator|(
name|GLboolean
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
name|internalCount
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|params
index|[
name|i
index|]
operator|=
operator|(
name|boolParams
index|[
name|i
index|]
operator|==
name|GL_FALSE
operator|)
condition|?
literal|0.0f
else|:
literal|1.0f
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GL_FLOAT
case|:
name|memcpy
argument_list|(
name|params
argument_list|,
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
name|internalCount
operator|*
sizeof|sizeof
argument_list|(
name|GLfloat
argument_list|)
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|GLfloat
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_INT
case|:
block|{
name|GLint
modifier|*
name|intParams
init|=
operator|(
name|GLint
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
name|internalCount
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|params
index|[
name|i
index|]
operator|=
operator|(
name|float
operator|)
name|intParams
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|getUniformiv
name|bool
name|ProgramBinary
operator|::
name|getUniformiv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
modifier|*
name|bufSize
parameter_list|,
name|GLint
modifier|*
name|params
parameter_list|)
block|{
if|if
condition|(
name|location
operator|<
literal|0
operator|||
name|location
operator|>=
operator|(
name|int
operator|)
name|mUniformIndex
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Uniform
modifier|*
name|targetUniform
init|=
name|mUniforms
index|[
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|index
index|]
decl_stmt|;
comment|// sized queries -- ensure the provided buffer is large enough
if|if
condition|(
name|bufSize
condition|)
block|{
name|int
name|requiredBytes
init|=
name|UniformExternalSize
argument_list|(
name|targetUniform
operator|->
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|bufSize
operator|<
name|requiredBytes
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
switch|switch
condition|(
name|targetUniform
operator|->
name|type
condition|)
block|{
case|case
name|GL_FLOAT_MAT2
case|:
block|{
name|transposeMatrix
argument_list|<
name|GLint
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|4
argument_list|,
literal|2
argument_list|>
argument_list|(
name|params
argument_list|,
operator|(
name|GLfloat
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|8
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|GL_FLOAT_MAT3
case|:
block|{
name|transposeMatrix
argument_list|<
name|GLint
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|3
argument_list|>
argument_list|(
name|params
argument_list|,
operator|(
name|GLfloat
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|12
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|GL_FLOAT_MAT4
case|:
block|{
name|transposeMatrix
argument_list|<
name|GLint
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|>
argument_list|(
name|params
argument_list|,
operator|(
name|GLfloat
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
literal|16
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
block|{
name|unsigned
name|int
name|count
init|=
name|UniformExternalComponentCount
argument_list|(
name|targetUniform
operator|->
name|type
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|internalCount
init|=
name|UniformInternalComponentCount
argument_list|(
name|targetUniform
operator|->
name|type
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|UniformComponentType
argument_list|(
name|targetUniform
operator|->
name|type
argument_list|)
condition|)
block|{
case|case
name|GL_BOOL
case|:
block|{
name|GLboolean
modifier|*
name|boolParams
init|=
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
name|internalCount
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|params
index|[
name|i
index|]
operator|=
operator|(
name|GLint
operator|)
name|boolParams
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GL_FLOAT
case|:
block|{
name|GLfloat
modifier|*
name|floatParams
init|=
operator|(
name|GLfloat
operator|*
operator|)
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
name|internalCount
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|params
index|[
name|i
index|]
operator|=
operator|(
name|GLint
operator|)
name|floatParams
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GL_INT
case|:
name|memcpy
argument_list|(
name|params
argument_list|,
name|targetUniform
operator|->
name|data
operator|+
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|element
operator|*
name|internalCount
operator|*
sizeof|sizeof
argument_list|(
name|GLint
argument_list|)
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|GLint
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|dirtyAllUniforms
name|void
name|ProgramBinary
operator|::
name|dirtyAllUniforms
parameter_list|()
block|{
name|unsigned
name|int
name|numUniforms
init|=
name|mUniforms
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
name|numUniforms
condition|;
name|index
operator|++
control|)
block|{
name|mUniforms
index|[
name|index
index|]
operator|->
name|dirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// Applies all the uniforms set for this program object to the Direct3D 9 device
DECL|function|applyUniforms
name|void
name|ProgramBinary
operator|::
name|applyUniforms
parameter_list|()
block|{
for|for
control|(
name|std
operator|::
name|vector
argument_list|<
name|Uniform
operator|*
argument_list|>
operator|::
name|iterator
name|ub
init|=
name|mUniforms
operator|.
name|begin
argument_list|()
init|,
name|ue
init|=
name|mUniforms
operator|.
name|end
argument_list|()
init|;
name|ub
operator|!=
name|ue
condition|;
operator|++
name|ub
control|)
block|{
name|Uniform
modifier|*
name|targetUniform
init|=
operator|*
name|ub
decl_stmt|;
if|if
condition|(
name|targetUniform
operator|->
name|dirty
condition|)
block|{
name|int
name|arraySize
init|=
name|targetUniform
operator|->
name|arraySize
decl_stmt|;
name|GLfloat
modifier|*
name|f
init|=
operator|(
name|GLfloat
operator|*
operator|)
name|targetUniform
operator|->
name|data
decl_stmt|;
name|GLint
modifier|*
name|i
init|=
operator|(
name|GLint
operator|*
operator|)
name|targetUniform
operator|->
name|data
decl_stmt|;
name|GLboolean
modifier|*
name|b
init|=
operator|(
name|GLboolean
operator|*
operator|)
name|targetUniform
operator|->
name|data
decl_stmt|;
switch|switch
condition|(
name|targetUniform
operator|->
name|type
condition|)
block|{
case|case
name|GL_BOOL
case|:
name|applyUniformnbv
argument_list|(
name|targetUniform
argument_list|,
name|arraySize
argument_list|,
literal|1
argument_list|,
name|b
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_BOOL_VEC2
case|:
name|applyUniformnbv
argument_list|(
name|targetUniform
argument_list|,
name|arraySize
argument_list|,
literal|2
argument_list|,
name|b
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_BOOL_VEC3
case|:
name|applyUniformnbv
argument_list|(
name|targetUniform
argument_list|,
name|arraySize
argument_list|,
literal|3
argument_list|,
name|b
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_BOOL_VEC4
case|:
name|applyUniformnbv
argument_list|(
name|targetUniform
argument_list|,
name|arraySize
argument_list|,
literal|4
argument_list|,
name|b
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_FLOAT
case|:
case|case
name|GL_FLOAT_VEC2
case|:
case|case
name|GL_FLOAT_VEC3
case|:
case|case
name|GL_FLOAT_VEC4
case|:
case|case
name|GL_FLOAT_MAT2
case|:
case|case
name|GL_FLOAT_MAT3
case|:
case|case
name|GL_FLOAT_MAT4
case|:
name|applyUniformnfv
argument_list|(
name|targetUniform
argument_list|,
name|f
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_SAMPLER_2D
case|:
case|case
name|GL_SAMPLER_CUBE
case|:
case|case
name|GL_INT
case|:
name|applyUniform1iv
argument_list|(
name|targetUniform
argument_list|,
name|arraySize
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_INT_VEC2
case|:
name|applyUniform2iv
argument_list|(
name|targetUniform
argument_list|,
name|arraySize
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_INT_VEC3
case|:
name|applyUniform3iv
argument_list|(
name|targetUniform
argument_list|,
name|arraySize
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_INT_VEC4
case|:
name|applyUniform4iv
argument_list|(
name|targetUniform
argument_list|,
name|arraySize
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
name|targetUniform
operator|->
name|dirty
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
comment|// Compiles the HLSL code of the attached shaders into executable binaries
DECL|function|compileToBinary
name|ID3D10Blob
modifier|*
name|ProgramBinary
operator|::
name|compileToBinary
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|char
modifier|*
name|hlsl
parameter_list|,
specifier|const
name|char
modifier|*
name|profile
parameter_list|,
name|D3DConstantTable
modifier|*
modifier|*
name|constantTable
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hlsl
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|DWORD
name|result
init|=
name|NOERROR
decl_stmt|;
name|UINT
name|flags
init|=
literal|0
decl_stmt|;
name|std
operator|::
name|string
name|sourceText
decl_stmt|;
if|if
condition|(
name|perfActive
argument_list|()
condition|)
block|{
name|flags
operator||=
name|D3DCOMPILE_DEBUG
expr_stmt|;
ifdef|#
directive|ifdef
name|NDEBUG
name|flags
operator||=
name|ANGLE_COMPILE_OPTIMIZATION_LEVEL
expr_stmt|;
else|#
directive|else
name|flags
operator||=
name|D3DCOMPILE_SKIP_OPTIMIZATION
expr_stmt|;
endif|#
directive|endif
name|std
operator|::
name|string
name|sourcePath
init|=
name|getTempPath
argument_list|()
decl_stmt|;
name|sourceText
operator|=
name|std
operator|::
name|string
argument_list|(
literal|"#line 2 \""
argument_list|)
operator|+
name|sourcePath
operator|+
name|std
operator|::
name|string
argument_list|(
literal|"\"\n\n"
argument_list|)
operator|+
name|std
operator|::
name|string
argument_list|(
name|hlsl
argument_list|)
expr_stmt|;
name|writeFile
argument_list|(
name|sourcePath
operator|.
name|c_str
argument_list|()
argument_list|,
name|sourceText
operator|.
name|c_str
argument_list|()
argument_list|,
name|sourceText
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|flags
operator||=
name|ANGLE_COMPILE_OPTIMIZATION_LEVEL
expr_stmt|;
name|sourceText
operator|=
name|hlsl
expr_stmt|;
block|}
comment|// Sometimes D3DCompile will fail with the default compilation flags for complicated shaders when it would otherwise pass with alternative options.
comment|// Try the default flags first and if compilation fails, try some alternatives.
specifier|const
specifier|static
name|UINT
name|extraFlags
index|[]
init|=
block|{
literal|0
block|,
name|D3DCOMPILE_AVOID_FLOW_CONTROL
block|,
name|D3DCOMPILE_PREFER_FLOW_CONTROL
block|}
decl_stmt|;
specifier|const
specifier|static
name|char
modifier|*
specifier|const
name|extraFlagNames
index|[]
init|=
block|{
literal|"default"
block|,
literal|"avoid flow control"
block|,
literal|"prefer flow control"
block|}
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|extraFlags
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|UINT
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|ID3D10Blob
modifier|*
name|errorMessage
init|=
name|NULL
decl_stmt|;
name|ID3D10Blob
modifier|*
name|binary
init|=
name|NULL
decl_stmt|;
name|result
operator|=
name|D3DCompile
argument_list|(
name|hlsl
argument_list|,
name|strlen
argument_list|(
name|hlsl
argument_list|)
argument_list|,
name|g_fakepath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|"main"
argument_list|,
name|profile
argument_list|,
name|flags
operator||
name|extraFlags
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
operator|&
name|binary
argument_list|,
operator|&
name|errorMessage
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorMessage
condition|)
block|{
specifier|const
name|char
modifier|*
name|message
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|errorMessage
operator|->
name|GetBufferPointer
argument_list|()
decl_stmt|;
name|infoLog
operator|.
name|appendSanitized
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
literal|"\n%s"
argument_list|,
name|hlsl
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
literal|"\n%s"
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|errorMessage
operator|->
name|Release
argument_list|()
expr_stmt|;
name|errorMessage
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|D3DConstantTable
modifier|*
name|table
init|=
operator|new
name|D3DConstantTable
argument_list|(
name|binary
operator|->
name|GetBufferPointer
argument_list|()
argument_list|,
name|binary
operator|->
name|GetBufferSize
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|table
operator|->
name|error
argument_list|()
condition|)
block|{
operator|delete
name|table
expr_stmt|;
name|binary
operator|->
name|Release
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|constantTable
operator|=
name|table
expr_stmt|;
return|return
name|binary
return|;
block|}
else|else
block|{
if|if
condition|(
name|result
operator|==
name|D3DERR_OUTOFVIDEOMEMORY
operator|||
name|result
operator|==
name|E_OUTOFMEMORY
condition|)
block|{
return|return
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
operator|(
name|ID3D10Blob
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
name|infoLog
operator|.
name|append
argument_list|(
literal|"Warning: D3D shader compilation failed with "
argument_list|)
expr_stmt|;
name|infoLog
operator|.
name|append
argument_list|(
name|extraFlagNames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|infoLog
operator|.
name|append
argument_list|(
literal|" flags."
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
sizeof|sizeof
argument_list|(
name|extraFlagNames
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|" Retrying with "
argument_list|)
expr_stmt|;
name|infoLog
operator|.
name|append
argument_list|(
name|extraFlagNames
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|infoLog
operator|.
name|append
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|NULL
return|;
block|}
comment|// Packs varyings into generic varying registers, using the algorithm from [OpenGL ES Shading Language 1.00 rev. 17] appendix A section 7 page 111
comment|// Returns the number of used varying registers, or -1 if unsuccesful
DECL|function|packVaryings
name|int
name|ProgramBinary
operator|::
name|packVaryings
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|Varying
modifier|*
name|packing
index|[]
index|[
literal|4
index|]
parameter_list|,
name|FragmentShader
modifier|*
name|fragmentShader
parameter_list|)
block|{
name|Context
modifier|*
name|context
init|=
name|getContext
argument_list|()
decl_stmt|;
specifier|const
name|int
name|maxVaryingVectors
init|=
name|context
operator|->
name|getMaximumVaryingVectors
argument_list|()
decl_stmt|;
for|for
control|(
name|VaryingList
operator|::
name|iterator
name|varying
init|=
name|fragmentShader
operator|->
name|mVaryings
operator|.
name|begin
argument_list|()
init|;
name|varying
operator|!=
name|fragmentShader
operator|->
name|mVaryings
operator|.
name|end
argument_list|()
condition|;
name|varying
operator|++
control|)
block|{
name|int
name|n
init|=
name|VariableRowCount
argument_list|(
name|varying
operator|->
name|type
argument_list|)
operator|*
name|varying
operator|->
name|size
decl_stmt|;
name|int
name|m
init|=
name|VariableColumnCount
argument_list|(
name|varying
operator|->
name|type
argument_list|)
decl_stmt|;
name|bool
name|success
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|m
operator|==
literal|2
operator|||
name|m
operator|==
literal|3
operator|||
name|m
operator|==
literal|4
condition|)
block|{
for|for
control|(
name|int
name|r
init|=
literal|0
init|;
name|r
operator|<=
name|maxVaryingVectors
operator|-
name|n
operator|&&
operator|!
name|success
condition|;
name|r
operator|++
control|)
block|{
name|bool
name|available
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|n
operator|&&
name|available
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|m
operator|&&
name|available
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|packing
index|[
name|r
operator|+
name|y
index|]
index|[
name|x
index|]
condition|)
block|{
name|available
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|available
condition|)
block|{
name|varying
operator|->
name|reg
operator|=
name|r
expr_stmt|;
name|varying
operator|->
name|col
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|n
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|m
condition|;
name|x
operator|++
control|)
block|{
name|packing
index|[
name|r
operator|+
name|y
index|]
index|[
name|x
index|]
operator|=
operator|&
operator|*
name|varying
expr_stmt|;
block|}
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|success
operator|&&
name|m
operator|==
literal|2
condition|)
block|{
for|for
control|(
name|int
name|r
init|=
name|maxVaryingVectors
operator|-
name|n
init|;
name|r
operator|>=
literal|0
operator|&&
operator|!
name|success
condition|;
name|r
operator|--
control|)
block|{
name|bool
name|available
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|n
operator|&&
name|available
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|2
init|;
name|x
operator|<
literal|4
operator|&&
name|available
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|packing
index|[
name|r
operator|+
name|y
index|]
index|[
name|x
index|]
condition|)
block|{
name|available
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|available
condition|)
block|{
name|varying
operator|->
name|reg
operator|=
name|r
expr_stmt|;
name|varying
operator|->
name|col
operator|=
literal|2
expr_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|n
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|2
init|;
name|x
operator|<
literal|4
condition|;
name|x
operator|++
control|)
block|{
name|packing
index|[
name|r
operator|+
name|y
index|]
index|[
name|x
index|]
operator|=
operator|&
operator|*
name|varying
expr_stmt|;
block|}
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|m
operator|==
literal|1
condition|)
block|{
name|int
name|space
index|[
literal|4
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|maxVaryingVectors
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
literal|4
condition|;
name|x
operator|++
control|)
block|{
name|space
index|[
name|x
index|]
operator|+=
name|packing
index|[
name|y
index|]
index|[
name|x
index|]
condition|?
literal|0
else|:
literal|1
expr_stmt|;
block|}
block|}
name|int
name|column
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
literal|4
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|space
index|[
name|x
index|]
operator|>=
name|n
operator|&&
name|space
index|[
name|x
index|]
operator|<
name|space
index|[
name|column
index|]
condition|)
block|{
name|column
operator|=
name|x
expr_stmt|;
block|}
block|}
if|if
condition|(
name|space
index|[
name|column
index|]
operator|>=
name|n
condition|)
block|{
for|for
control|(
name|int
name|r
init|=
literal|0
init|;
name|r
operator|<
name|maxVaryingVectors
condition|;
name|r
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|packing
index|[
name|r
index|]
index|[
name|column
index|]
condition|)
block|{
name|varying
operator|->
name|reg
operator|=
name|r
expr_stmt|;
for|for
control|(
name|int
name|y
init|=
name|r
init|;
name|y
operator|<
name|r
operator|+
name|n
condition|;
name|y
operator|++
control|)
block|{
name|packing
index|[
name|y
index|]
index|[
name|column
index|]
operator|=
operator|&
operator|*
name|varying
expr_stmt|;
block|}
break|break;
block|}
block|}
name|varying
operator|->
name|col
operator|=
name|column
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Could not pack varying %s"
argument_list|,
name|varying
operator|->
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|// Return the number of used registers
name|int
name|registers
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|r
init|=
literal|0
init|;
name|r
operator|<
name|maxVaryingVectors
condition|;
name|r
operator|++
control|)
block|{
if|if
condition|(
name|packing
index|[
name|r
index|]
index|[
literal|0
index|]
operator|||
name|packing
index|[
name|r
index|]
index|[
literal|1
index|]
operator|||
name|packing
index|[
name|r
index|]
index|[
literal|2
index|]
operator|||
name|packing
index|[
name|r
index|]
index|[
literal|3
index|]
condition|)
block|{
name|registers
operator|++
expr_stmt|;
block|}
block|}
return|return
name|registers
return|;
block|}
DECL|function|linkVaryings
name|bool
name|ProgramBinary
operator|::
name|linkVaryings
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
name|std
operator|::
name|string
modifier|&
name|pixelHLSL
parameter_list|,
name|std
operator|::
name|string
modifier|&
name|vertexHLSL
parameter_list|,
name|FragmentShader
modifier|*
name|fragmentShader
parameter_list|,
name|VertexShader
modifier|*
name|vertexShader
parameter_list|)
block|{
if|if
condition|(
name|pixelHLSL
operator|.
name|empty
argument_list|()
operator|||
name|vertexHLSL
operator|.
name|empty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Reset the varying register assignments
for|for
control|(
name|VaryingList
operator|::
name|iterator
name|fragVar
init|=
name|fragmentShader
operator|->
name|mVaryings
operator|.
name|begin
argument_list|()
init|;
name|fragVar
operator|!=
name|fragmentShader
operator|->
name|mVaryings
operator|.
name|end
argument_list|()
condition|;
name|fragVar
operator|++
control|)
block|{
name|fragVar
operator|->
name|reg
operator|=
operator|-
literal|1
expr_stmt|;
name|fragVar
operator|->
name|col
operator|=
operator|-
literal|1
expr_stmt|;
block|}
for|for
control|(
name|VaryingList
operator|::
name|iterator
name|vtxVar
init|=
name|vertexShader
operator|->
name|mVaryings
operator|.
name|begin
argument_list|()
init|;
name|vtxVar
operator|!=
name|vertexShader
operator|->
name|mVaryings
operator|.
name|end
argument_list|()
condition|;
name|vtxVar
operator|++
control|)
block|{
name|vtxVar
operator|->
name|reg
operator|=
operator|-
literal|1
expr_stmt|;
name|vtxVar
operator|->
name|col
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|// Map the varyings to the register file
specifier|const
name|Varying
modifier|*
name|packing
index|[
name|MAX_VARYING_VECTORS_SM3
index|]
index|[
literal|4
index|]
init|=
block|{
name|NULL
block|}
decl_stmt|;
name|int
name|registers
init|=
name|packVaryings
argument_list|(
name|infoLog
argument_list|,
name|packing
argument_list|,
name|fragmentShader
argument_list|)
decl_stmt|;
if|if
condition|(
name|registers
operator|<
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Write the HLSL input/output declarations
name|Context
modifier|*
name|context
init|=
name|getContext
argument_list|()
decl_stmt|;
specifier|const
name|bool
name|sm3
init|=
name|context
operator|->
name|supportsShaderModel3
argument_list|()
decl_stmt|;
specifier|const
name|int
name|maxVaryingVectors
init|=
name|context
operator|->
name|getMaximumVaryingVectors
argument_list|()
decl_stmt|;
if|if
condition|(
name|registers
operator|==
name|maxVaryingVectors
operator|&&
name|fragmentShader
operator|->
name|mUsesFragCoord
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"No varying registers left to support gl_FragCoord"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
for|for
control|(
name|VaryingList
operator|::
name|iterator
name|input
init|=
name|fragmentShader
operator|->
name|mVaryings
operator|.
name|begin
argument_list|()
init|;
name|input
operator|!=
name|fragmentShader
operator|->
name|mVaryings
operator|.
name|end
argument_list|()
condition|;
name|input
operator|++
control|)
block|{
name|bool
name|matched
init|=
literal|false
decl_stmt|;
for|for
control|(
name|VaryingList
operator|::
name|iterator
name|output
init|=
name|vertexShader
operator|->
name|mVaryings
operator|.
name|begin
argument_list|()
init|;
name|output
operator|!=
name|vertexShader
operator|->
name|mVaryings
operator|.
name|end
argument_list|()
condition|;
name|output
operator|++
control|)
block|{
if|if
condition|(
name|output
operator|->
name|name
operator|==
name|input
operator|->
name|name
condition|)
block|{
if|if
condition|(
name|output
operator|->
name|type
operator|!=
name|input
operator|->
name|type
operator|||
name|output
operator|->
name|size
operator|!=
name|input
operator|->
name|size
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Type of vertex varying %s does not match that of the fragment varying"
argument_list|,
name|output
operator|->
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|output
operator|->
name|reg
operator|=
name|input
operator|->
name|reg
expr_stmt|;
name|output
operator|->
name|col
operator|=
name|input
operator|->
name|col
expr_stmt|;
name|matched
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|matched
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Fragment varying %s does not match any vertex varying"
argument_list|,
name|input
operator|->
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|mUsesPointSize
operator|=
name|vertexShader
operator|->
name|mUsesPointSize
expr_stmt|;
name|std
operator|::
name|string
name|varyingSemantic
init|=
operator|(
name|mUsesPointSize
operator|&&
name|sm3
operator|)
condition|?
literal|"COLOR"
else|:
literal|"TEXCOORD"
decl_stmt|;
name|vertexHLSL
operator|+=
literal|"struct VS_INPUT\n"
literal|"{\n"
expr_stmt|;
name|int
name|semanticIndex
init|=
literal|0
decl_stmt|;
for|for
control|(
name|AttributeArray
operator|::
name|iterator
name|attribute
init|=
name|vertexShader
operator|->
name|mAttributes
operator|.
name|begin
argument_list|()
init|;
name|attribute
operator|!=
name|vertexShader
operator|->
name|mAttributes
operator|.
name|end
argument_list|()
condition|;
name|attribute
operator|++
control|)
block|{
switch|switch
condition|(
name|attribute
operator|->
name|type
condition|)
block|{
case|case
name|GL_FLOAT
case|:
name|vertexHLSL
operator|+=
literal|"    float "
expr_stmt|;
break|break;
case|case
name|GL_FLOAT_VEC2
case|:
name|vertexHLSL
operator|+=
literal|"    float2 "
expr_stmt|;
break|break;
case|case
name|GL_FLOAT_VEC3
case|:
name|vertexHLSL
operator|+=
literal|"    float3 "
expr_stmt|;
break|break;
case|case
name|GL_FLOAT_VEC4
case|:
name|vertexHLSL
operator|+=
literal|"    float4 "
expr_stmt|;
break|break;
case|case
name|GL_FLOAT_MAT2
case|:
name|vertexHLSL
operator|+=
literal|"    float2x2 "
expr_stmt|;
break|break;
case|case
name|GL_FLOAT_MAT3
case|:
name|vertexHLSL
operator|+=
literal|"    float3x3 "
expr_stmt|;
break|break;
case|case
name|GL_FLOAT_MAT4
case|:
name|vertexHLSL
operator|+=
literal|"    float4x4 "
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
name|vertexHLSL
operator|+=
name|decorateAttribute
argument_list|(
name|attribute
operator|->
name|name
argument_list|)
operator|+
literal|" : TEXCOORD"
operator|+
name|str
argument_list|(
name|semanticIndex
argument_list|)
operator|+
literal|";\n"
expr_stmt|;
name|semanticIndex
operator|+=
name|VariableRowCount
argument_list|(
name|attribute
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
name|vertexHLSL
operator|+=
literal|"};\n"
literal|"\n"
literal|"struct VS_OUTPUT\n"
literal|"{\n"
literal|"    float4 gl_Position : POSITION;\n"
expr_stmt|;
for|for
control|(
name|int
name|r
init|=
literal|0
init|;
name|r
operator|<
name|registers
condition|;
name|r
operator|++
control|)
block|{
name|int
name|registerSize
init|=
name|packing
index|[
name|r
index|]
index|[
literal|3
index|]
condition|?
literal|4
else|:
operator|(
name|packing
index|[
name|r
index|]
index|[
literal|2
index|]
condition|?
literal|3
else|:
operator|(
name|packing
index|[
name|r
index|]
index|[
literal|1
index|]
condition|?
literal|2
else|:
literal|1
operator|)
operator|)
decl_stmt|;
name|vertexHLSL
operator|+=
literal|"    float"
operator|+
name|str
argument_list|(
name|registerSize
argument_list|)
operator|+
literal|" v"
operator|+
name|str
argument_list|(
name|r
argument_list|)
operator|+
literal|" : "
operator|+
name|varyingSemantic
operator|+
name|str
argument_list|(
name|r
argument_list|)
operator|+
literal|";\n"
expr_stmt|;
block|}
if|if
condition|(
name|fragmentShader
operator|->
name|mUsesFragCoord
condition|)
block|{
name|vertexHLSL
operator|+=
literal|"    float4 gl_FragCoord : "
operator|+
name|varyingSemantic
operator|+
name|str
argument_list|(
name|registers
argument_list|)
operator|+
literal|";\n"
expr_stmt|;
block|}
if|if
condition|(
name|vertexShader
operator|->
name|mUsesPointSize
operator|&&
name|sm3
condition|)
block|{
name|vertexHLSL
operator|+=
literal|"    float gl_PointSize : PSIZE;\n"
expr_stmt|;
block|}
name|vertexHLSL
operator|+=
literal|"};\n"
literal|"\n"
literal|"VS_OUTPUT main(VS_INPUT input)\n"
literal|"{\n"
expr_stmt|;
for|for
control|(
name|AttributeArray
operator|::
name|iterator
name|attribute
init|=
name|vertexShader
operator|->
name|mAttributes
operator|.
name|begin
argument_list|()
init|;
name|attribute
operator|!=
name|vertexShader
operator|->
name|mAttributes
operator|.
name|end
argument_list|()
condition|;
name|attribute
operator|++
control|)
block|{
name|vertexHLSL
operator|+=
literal|"    "
operator|+
name|decorateAttribute
argument_list|(
name|attribute
operator|->
name|name
argument_list|)
operator|+
literal|" = "
expr_stmt|;
if|if
condition|(
name|VariableRowCount
argument_list|(
name|attribute
operator|->
name|type
argument_list|)
operator|>
literal|1
condition|)
comment|// Matrix
block|{
name|vertexHLSL
operator|+=
literal|"transpose"
expr_stmt|;
block|}
name|vertexHLSL
operator|+=
literal|"(input."
operator|+
name|decorateAttribute
argument_list|(
name|attribute
operator|->
name|name
argument_list|)
operator|+
literal|");\n"
expr_stmt|;
block|}
name|vertexHLSL
operator|+=
literal|"\n"
literal|"    gl_main();\n"
literal|"\n"
literal|"    VS_OUTPUT output;\n"
literal|"    output.gl_Position.x = gl_Position.x - dx_HalfPixelSize.x * gl_Position.w;\n"
literal|"    output.gl_Position.y = -(gl_Position.y + dx_HalfPixelSize.y * gl_Position.w);\n"
literal|"    output.gl_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\n"
literal|"    output.gl_Position.w = gl_Position.w;\n"
expr_stmt|;
if|if
condition|(
name|vertexShader
operator|->
name|mUsesPointSize
operator|&&
name|sm3
condition|)
block|{
name|vertexHLSL
operator|+=
literal|"    output.gl_PointSize = gl_PointSize;\n"
expr_stmt|;
block|}
if|if
condition|(
name|fragmentShader
operator|->
name|mUsesFragCoord
condition|)
block|{
name|vertexHLSL
operator|+=
literal|"    output.gl_FragCoord = gl_Position;\n"
expr_stmt|;
block|}
for|for
control|(
name|VaryingList
operator|::
name|iterator
name|varying
init|=
name|vertexShader
operator|->
name|mVaryings
operator|.
name|begin
argument_list|()
init|;
name|varying
operator|!=
name|vertexShader
operator|->
name|mVaryings
operator|.
name|end
argument_list|()
condition|;
name|varying
operator|++
control|)
block|{
if|if
condition|(
name|varying
operator|->
name|reg
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|varying
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|int
name|rows
init|=
name|VariableRowCount
argument_list|(
name|varying
operator|->
name|type
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|rows
condition|;
name|j
operator|++
control|)
block|{
name|int
name|r
init|=
name|varying
operator|->
name|reg
operator|+
name|i
operator|*
name|rows
operator|+
name|j
decl_stmt|;
name|vertexHLSL
operator|+=
literal|"    output.v"
operator|+
name|str
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|bool
name|sharedRegister
init|=
literal|false
decl_stmt|;
comment|// Register used by multiple varyings
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
literal|4
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|packing
index|[
name|r
index|]
index|[
name|x
index|]
operator|&&
name|packing
index|[
name|r
index|]
index|[
name|x
index|]
operator|!=
name|packing
index|[
name|r
index|]
index|[
literal|0
index|]
condition|)
block|{
name|sharedRegister
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|sharedRegister
condition|)
block|{
name|vertexHLSL
operator|+=
literal|"."
expr_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
literal|4
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|packing
index|[
name|r
index|]
index|[
name|x
index|]
operator|==
operator|&
operator|*
name|varying
condition|)
block|{
switch|switch
condition|(
name|x
condition|)
block|{
case|case
literal|0
case|:
name|vertexHLSL
operator|+=
literal|"x"
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|vertexHLSL
operator|+=
literal|"y"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|vertexHLSL
operator|+=
literal|"z"
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|vertexHLSL
operator|+=
literal|"w"
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
name|vertexHLSL
operator|+=
literal|" = "
operator|+
name|varying
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|varying
operator|->
name|array
condition|)
block|{
name|vertexHLSL
operator|+=
literal|"["
operator|+
name|str
argument_list|(
name|i
argument_list|)
operator|+
literal|"]"
expr_stmt|;
block|}
if|if
condition|(
name|rows
operator|>
literal|1
condition|)
block|{
name|vertexHLSL
operator|+=
literal|"["
operator|+
name|str
argument_list|(
name|j
argument_list|)
operator|+
literal|"]"
expr_stmt|;
block|}
name|vertexHLSL
operator|+=
literal|";\n"
expr_stmt|;
block|}
block|}
block|}
block|}
name|vertexHLSL
operator|+=
literal|"\n"
literal|"    return output;\n"
literal|"}\n"
expr_stmt|;
name|pixelHLSL
operator|+=
literal|"struct PS_INPUT\n"
literal|"{\n"
expr_stmt|;
for|for
control|(
name|VaryingList
operator|::
name|iterator
name|varying
init|=
name|fragmentShader
operator|->
name|mVaryings
operator|.
name|begin
argument_list|()
init|;
name|varying
operator|!=
name|fragmentShader
operator|->
name|mVaryings
operator|.
name|end
argument_list|()
condition|;
name|varying
operator|++
control|)
block|{
if|if
condition|(
name|varying
operator|->
name|reg
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|varying
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|int
name|rows
init|=
name|VariableRowCount
argument_list|(
name|varying
operator|->
name|type
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|rows
condition|;
name|j
operator|++
control|)
block|{
name|std
operator|::
name|string
name|n
init|=
name|str
argument_list|(
name|varying
operator|->
name|reg
operator|+
name|i
operator|*
name|rows
operator|+
name|j
argument_list|)
decl_stmt|;
name|pixelHLSL
operator|+=
literal|"    float4 v"
operator|+
name|n
operator|+
literal|" : "
operator|+
name|varyingSemantic
operator|+
name|n
operator|+
literal|";\n"
expr_stmt|;
block|}
block|}
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fragmentShader
operator|->
name|mUsesFragCoord
condition|)
block|{
name|pixelHLSL
operator|+=
literal|"    float4 gl_FragCoord : "
operator|+
name|varyingSemantic
operator|+
name|str
argument_list|(
name|registers
argument_list|)
operator|+
literal|";\n"
expr_stmt|;
if|if
condition|(
name|sm3
condition|)
block|{
name|pixelHLSL
operator|+=
literal|"    float2 dx_VPos : VPOS;\n"
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fragmentShader
operator|->
name|mUsesPointCoord
operator|&&
name|sm3
condition|)
block|{
name|pixelHLSL
operator|+=
literal|"    float2 gl_PointCoord : TEXCOORD0;\n"
expr_stmt|;
block|}
if|if
condition|(
name|fragmentShader
operator|->
name|mUsesFrontFacing
condition|)
block|{
name|pixelHLSL
operator|+=
literal|"    float vFace : VFACE;\n"
expr_stmt|;
block|}
name|pixelHLSL
operator|+=
literal|"};\n"
literal|"\n"
literal|"struct PS_OUTPUT\n"
literal|"{\n"
literal|"    float4 gl_Color[1] : COLOR;\n"
literal|"};\n"
literal|"\n"
literal|"PS_OUTPUT main(PS_INPUT input)\n"
literal|"{\n"
expr_stmt|;
if|if
condition|(
name|fragmentShader
operator|->
name|mUsesFragCoord
condition|)
block|{
name|pixelHLSL
operator|+=
literal|"    float rhw = 1.0 / input.gl_FragCoord.w;\n"
expr_stmt|;
if|if
condition|(
name|sm3
condition|)
block|{
name|pixelHLSL
operator|+=
literal|"    gl_FragCoord.x = input.dx_VPos.x + 0.5;\n"
literal|"    gl_FragCoord.y = input.dx_VPos.y + 0.5;\n"
expr_stmt|;
block|}
else|else
block|{
comment|// dx_Coord contains the viewport width/2, height/2, center.x and center.y. See Context::applyRenderTarget()
name|pixelHLSL
operator|+=
literal|"    gl_FragCoord.x = (input.gl_FragCoord.x * rhw) * dx_Coord.x + dx_Coord.z;\n"
literal|"    gl_FragCoord.y = (input.gl_FragCoord.y * rhw) * dx_Coord.y + dx_Coord.w;\n"
expr_stmt|;
block|}
name|pixelHLSL
operator|+=
literal|"    gl_FragCoord.z = (input.gl_FragCoord.z * rhw) * dx_Depth.x + dx_Depth.y;\n"
literal|"    gl_FragCoord.w = rhw;\n"
expr_stmt|;
block|}
if|if
condition|(
name|fragmentShader
operator|->
name|mUsesPointCoord
operator|&&
name|sm3
condition|)
block|{
name|pixelHLSL
operator|+=
literal|"    gl_PointCoord.x = input.gl_PointCoord.x;\n"
expr_stmt|;
name|pixelHLSL
operator|+=
literal|"    gl_PointCoord.y = 1.0 - input.gl_PointCoord.y;\n"
expr_stmt|;
block|}
if|if
condition|(
name|fragmentShader
operator|->
name|mUsesFrontFacing
condition|)
block|{
name|pixelHLSL
operator|+=
literal|"    gl_FrontFacing = dx_PointsOrLines || (dx_FrontCCW ? (input.vFace>= 0.0) : (input.vFace<= 0.0));\n"
expr_stmt|;
block|}
for|for
control|(
name|VaryingList
operator|::
name|iterator
name|varying
init|=
name|fragmentShader
operator|->
name|mVaryings
operator|.
name|begin
argument_list|()
init|;
name|varying
operator|!=
name|fragmentShader
operator|->
name|mVaryings
operator|.
name|end
argument_list|()
condition|;
name|varying
operator|++
control|)
block|{
if|if
condition|(
name|varying
operator|->
name|reg
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|varying
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|int
name|rows
init|=
name|VariableRowCount
argument_list|(
name|varying
operator|->
name|type
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|rows
condition|;
name|j
operator|++
control|)
block|{
name|std
operator|::
name|string
name|n
init|=
name|str
argument_list|(
name|varying
operator|->
name|reg
operator|+
name|i
operator|*
name|rows
operator|+
name|j
argument_list|)
decl_stmt|;
name|pixelHLSL
operator|+=
literal|"    "
operator|+
name|varying
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|varying
operator|->
name|array
condition|)
block|{
name|pixelHLSL
operator|+=
literal|"["
operator|+
name|str
argument_list|(
name|i
argument_list|)
operator|+
literal|"]"
expr_stmt|;
block|}
if|if
condition|(
name|rows
operator|>
literal|1
condition|)
block|{
name|pixelHLSL
operator|+=
literal|"["
operator|+
name|str
argument_list|(
name|j
argument_list|)
operator|+
literal|"]"
expr_stmt|;
block|}
name|pixelHLSL
operator|+=
literal|" = input.v"
operator|+
name|n
operator|+
literal|";\n"
expr_stmt|;
block|}
block|}
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
name|pixelHLSL
operator|+=
literal|"\n"
literal|"    gl_main();\n"
literal|"\n"
literal|"    PS_OUTPUT output;\n"
literal|"    output.gl_Color[0] = gl_Color[0];\n"
literal|"\n"
literal|"    return output;\n"
literal|"}\n"
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|load
name|bool
name|ProgramBinary
operator|::
name|load
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|void
modifier|*
name|binary
parameter_list|,
name|GLsizei
name|length
parameter_list|)
block|{
name|BinaryInputStream
name|stream
argument_list|(
name|binary
argument_list|,
name|length
argument_list|)
decl_stmt|;
name|int
name|format
init|=
literal|0
decl_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
operator|!=
name|GL_PROGRAM_BINARY_ANGLE
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Invalid program binary format."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|int
name|version
init|=
literal|0
decl_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|!=
name|BUILD_REVISION
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Invalid program binary version."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
operator|++
name|i
control|)
block|{
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mLinkedAttribute
index|[
name|i
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|std
operator|::
name|string
name|name
decl_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|name
argument_list|)
expr_stmt|;
name|mLinkedAttribute
index|[
name|i
index|]
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mSemanticIndex
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_TEXTURE_IMAGE_UNITS
condition|;
operator|++
name|i
control|)
block|{
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|active
argument_list|)
expr_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|logicalTextureUnit
argument_list|)
expr_stmt|;
name|int
name|textureType
decl_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|textureType
argument_list|)
expr_stmt|;
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|textureType
operator|=
operator|(
name|TextureType
operator|)
name|textureType
expr_stmt|;
block|}
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VERTEX_TEXTURE_IMAGE_UNITS_VTF
condition|;
operator|++
name|i
control|)
block|{
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|active
argument_list|)
expr_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|logicalTextureUnit
argument_list|)
expr_stmt|;
name|int
name|textureType
decl_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|textureType
argument_list|)
expr_stmt|;
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|textureType
operator|=
operator|(
name|TextureType
operator|)
name|textureType
expr_stmt|;
block|}
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mUsedVertexSamplerRange
argument_list|)
expr_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mUsedPixelSamplerRange
argument_list|)
expr_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
operator|.
name|error
argument_list|()
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Invalid program binary."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|mUniforms
operator|.
name|resize
argument_list|(
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
name|GLenum
name|type
decl_stmt|;
name|std
operator|::
name|string
name|_name
decl_stmt|;
name|unsigned
name|int
name|arraySize
decl_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|type
argument_list|)
expr_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|_name
argument_list|)
expr_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|arraySize
argument_list|)
expr_stmt|;
name|mUniforms
index|[
name|i
index|]
operator|=
operator|new
name|Uniform
argument_list|(
name|type
argument_list|,
name|_name
argument_list|,
name|arraySize
argument_list|)
expr_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mUniforms
index|[
name|i
index|]
operator|->
name|ps
operator|.
name|float4Index
argument_list|)
expr_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mUniforms
index|[
name|i
index|]
operator|->
name|ps
operator|.
name|samplerIndex
argument_list|)
expr_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mUniforms
index|[
name|i
index|]
operator|->
name|ps
operator|.
name|boolIndex
argument_list|)
expr_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mUniforms
index|[
name|i
index|]
operator|->
name|ps
operator|.
name|registerCount
argument_list|)
expr_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mUniforms
index|[
name|i
index|]
operator|->
name|vs
operator|.
name|float4Index
argument_list|)
expr_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mUniforms
index|[
name|i
index|]
operator|->
name|vs
operator|.
name|samplerIndex
argument_list|)
expr_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mUniforms
index|[
name|i
index|]
operator|->
name|vs
operator|.
name|boolIndex
argument_list|)
expr_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mUniforms
index|[
name|i
index|]
operator|->
name|vs
operator|.
name|registerCount
argument_list|)
expr_stmt|;
block|}
name|stream
operator|.
name|read
argument_list|(
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
operator|.
name|error
argument_list|()
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Invalid program binary."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|mUniformIndex
operator|.
name|resize
argument_list|(
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mUniformIndex
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mUniformIndex
index|[
name|i
index|]
operator|.
name|element
argument_list|)
expr_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mUniformIndex
index|[
name|i
index|]
operator|.
name|index
argument_list|)
expr_stmt|;
block|}
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mDxDepthRangeLocation
argument_list|)
expr_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mDxDepthLocation
argument_list|)
expr_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mDxCoordLocation
argument_list|)
expr_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mDxHalfPixelSizeLocation
argument_list|)
expr_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mDxFrontCCWLocation
argument_list|)
expr_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|mDxPointsOrLinesLocation
argument_list|)
expr_stmt|;
name|unsigned
name|int
name|pixelShaderSize
decl_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|pixelShaderSize
argument_list|)
expr_stmt|;
name|unsigned
name|int
name|vertexShaderSize
decl_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|&
name|vertexShaderSize
argument_list|)
expr_stmt|;
specifier|const
name|char
modifier|*
name|ptr
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|binary
operator|+
name|stream
operator|.
name|offset
argument_list|()
decl_stmt|;
specifier|const
name|D3DCAPS9
modifier|*
name|binaryIdentifier
init|=
operator|(
specifier|const
name|D3DCAPS9
operator|*
operator|)
name|ptr
decl_stmt|;
name|ptr
operator|+=
sizeof|sizeof
argument_list|(
name|GUID
argument_list|)
expr_stmt|;
name|D3DADAPTER_IDENTIFIER9
modifier|*
name|currentIdentifier
init|=
name|getDisplay
argument_list|()
operator|->
name|getAdapterIdentifier
argument_list|()
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|currentIdentifier
operator|->
name|DeviceIdentifier
argument_list|,
name|binaryIdentifier
argument_list|,
sizeof|sizeof
argument_list|(
name|GUID
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Invalid program binary."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|char
modifier|*
name|pixelShaderFunction
init|=
name|ptr
decl_stmt|;
name|ptr
operator|+=
name|pixelShaderSize
expr_stmt|;
specifier|const
name|char
modifier|*
name|vertexShaderFunction
init|=
name|ptr
decl_stmt|;
name|ptr
operator|+=
name|vertexShaderSize
expr_stmt|;
name|mPixelExecutable
operator|=
name|getDisplay
argument_list|()
operator|->
name|createPixelShader
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|DWORD
operator|*
argument_list|>
argument_list|(
name|pixelShaderFunction
argument_list|)
argument_list|,
name|pixelShaderSize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mPixelExecutable
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Could not create pixel shader."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|mVertexExecutable
operator|=
name|getDisplay
argument_list|()
operator|->
name|createVertexShader
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|DWORD
operator|*
argument_list|>
argument_list|(
name|vertexShaderFunction
argument_list|)
argument_list|,
name|vertexShaderSize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mVertexExecutable
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Could not create vertex shader."
argument_list|)
expr_stmt|;
name|mPixelExecutable
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mPixelExecutable
operator|=
name|NULL
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|save
name|bool
name|ProgramBinary
operator|::
name|save
parameter_list|(
name|void
modifier|*
name|binary
parameter_list|,
name|GLsizei
name|bufSize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|)
block|{
name|BinaryOutputStream
name|stream
decl_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|GL_PROGRAM_BINARY_ANGLE
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|BUILD_REVISION
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
operator|++
name|i
control|)
block|{
name|stream
operator|.
name|write
argument_list|(
name|mLinkedAttribute
index|[
name|i
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mLinkedAttribute
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mSemanticIndex
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_TEXTURE_IMAGE_UNITS
condition|;
operator|++
name|i
control|)
block|{
name|stream
operator|.
name|write
argument_list|(
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|active
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|logicalTextureUnit
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
operator|(
name|int
operator|)
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|textureType
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VERTEX_TEXTURE_IMAGE_UNITS_VTF
condition|;
operator|++
name|i
control|)
block|{
name|stream
operator|.
name|write
argument_list|(
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|active
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|logicalTextureUnit
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
operator|(
name|int
operator|)
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|textureType
argument_list|)
expr_stmt|;
block|}
name|stream
operator|.
name|write
argument_list|(
name|mUsedVertexSamplerRange
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mUsedPixelSamplerRange
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mUniforms
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mUniforms
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|stream
operator|.
name|write
argument_list|(
name|mUniforms
index|[
name|i
index|]
operator|->
name|type
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mUniforms
index|[
name|i
index|]
operator|->
name|_name
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mUniforms
index|[
name|i
index|]
operator|->
name|arraySize
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mUniforms
index|[
name|i
index|]
operator|->
name|ps
operator|.
name|float4Index
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mUniforms
index|[
name|i
index|]
operator|->
name|ps
operator|.
name|samplerIndex
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mUniforms
index|[
name|i
index|]
operator|->
name|ps
operator|.
name|boolIndex
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mUniforms
index|[
name|i
index|]
operator|->
name|ps
operator|.
name|registerCount
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mUniforms
index|[
name|i
index|]
operator|->
name|vs
operator|.
name|float4Index
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mUniforms
index|[
name|i
index|]
operator|->
name|vs
operator|.
name|samplerIndex
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mUniforms
index|[
name|i
index|]
operator|->
name|vs
operator|.
name|boolIndex
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mUniforms
index|[
name|i
index|]
operator|->
name|vs
operator|.
name|registerCount
argument_list|)
expr_stmt|;
block|}
name|stream
operator|.
name|write
argument_list|(
name|mUniformIndex
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mUniformIndex
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|stream
operator|.
name|write
argument_list|(
name|mUniformIndex
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mUniformIndex
index|[
name|i
index|]
operator|.
name|element
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mUniformIndex
index|[
name|i
index|]
operator|.
name|index
argument_list|)
expr_stmt|;
block|}
name|stream
operator|.
name|write
argument_list|(
name|mDxDepthRangeLocation
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mDxDepthLocation
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mDxCoordLocation
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mDxHalfPixelSizeLocation
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mDxFrontCCWLocation
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|mDxPointsOrLinesLocation
argument_list|)
expr_stmt|;
name|UINT
name|pixelShaderSize
decl_stmt|;
name|HRESULT
name|result
init|=
name|mPixelExecutable
operator|->
name|GetFunction
argument_list|(
name|NULL
argument_list|,
operator|&
name|pixelShaderSize
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|pixelShaderSize
argument_list|)
expr_stmt|;
name|UINT
name|vertexShaderSize
decl_stmt|;
name|result
operator|=
name|mVertexExecutable
operator|->
name|GetFunction
argument_list|(
name|NULL
argument_list|,
operator|&
name|vertexShaderSize
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|stream
operator|.
name|write
argument_list|(
name|vertexShaderSize
argument_list|)
expr_stmt|;
name|D3DADAPTER_IDENTIFIER9
modifier|*
name|identifier
init|=
name|getDisplay
argument_list|()
operator|->
name|getAdapterIdentifier
argument_list|()
decl_stmt|;
name|GLsizei
name|streamLength
init|=
name|stream
operator|.
name|length
argument_list|()
decl_stmt|;
specifier|const
name|void
modifier|*
name|streamData
init|=
name|stream
operator|.
name|data
argument_list|()
decl_stmt|;
name|GLsizei
name|totalLength
init|=
name|streamLength
operator|+
sizeof|sizeof
argument_list|(
name|GUID
argument_list|)
operator|+
name|pixelShaderSize
operator|+
name|vertexShaderSize
decl_stmt|;
if|if
condition|(
name|totalLength
operator|>
name|bufSize
condition|)
block|{
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
if|if
condition|(
name|binary
condition|)
block|{
name|char
modifier|*
name|ptr
init|=
operator|(
name|char
operator|*
operator|)
name|binary
decl_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
name|streamData
argument_list|,
name|streamLength
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|streamLength
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
operator|&
name|identifier
operator|->
name|DeviceIdentifier
argument_list|,
sizeof|sizeof
argument_list|(
name|GUID
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|+=
sizeof|sizeof
argument_list|(
name|GUID
argument_list|)
expr_stmt|;
name|result
operator|=
name|mPixelExecutable
operator|->
name|GetFunction
argument_list|(
name|ptr
argument_list|,
operator|&
name|pixelShaderSize
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|pixelShaderSize
expr_stmt|;
name|result
operator|=
name|mVertexExecutable
operator|->
name|GetFunction
argument_list|(
name|ptr
argument_list|,
operator|&
name|vertexShaderSize
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|vertexShaderSize
expr_stmt|;
name|ASSERT
argument_list|(
name|ptr
operator|-
name|totalLength
operator|==
name|binary
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
name|totalLength
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|getLength
name|GLint
name|ProgramBinary
operator|::
name|getLength
parameter_list|()
block|{
name|GLint
name|length
decl_stmt|;
if|if
condition|(
name|save
argument_list|(
name|NULL
argument_list|,
name|INT_MAX
argument_list|,
operator|&
name|length
argument_list|)
condition|)
block|{
return|return
name|length
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
DECL|function|link
name|bool
name|ProgramBinary
operator|::
name|link
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|AttributeBindings
modifier|&
name|attributeBindings
parameter_list|,
name|FragmentShader
modifier|*
name|fragmentShader
parameter_list|,
name|VertexShader
modifier|*
name|vertexShader
parameter_list|)
block|{
if|if
condition|(
operator|!
name|fragmentShader
operator|||
operator|!
name|fragmentShader
operator|->
name|isCompiled
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|vertexShader
operator|||
operator|!
name|vertexShader
operator|->
name|isCompiled
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|std
operator|::
name|string
name|pixelHLSL
init|=
name|fragmentShader
operator|->
name|getHLSL
argument_list|()
decl_stmt|;
name|std
operator|::
name|string
name|vertexHLSL
init|=
name|vertexShader
operator|->
name|getHLSL
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|linkVaryings
argument_list|(
name|infoLog
argument_list|,
name|pixelHLSL
argument_list|,
name|vertexHLSL
argument_list|,
name|fragmentShader
argument_list|,
name|vertexShader
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Context
modifier|*
name|context
init|=
name|getContext
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|vertexProfile
init|=
name|context
operator|->
name|supportsShaderModel3
argument_list|()
condition|?
literal|"vs_3_0"
else|:
literal|"vs_2_0"
decl_stmt|;
specifier|const
name|char
modifier|*
name|pixelProfile
init|=
name|context
operator|->
name|supportsShaderModel3
argument_list|()
condition|?
literal|"ps_3_0"
else|:
literal|"ps_2_0"
decl_stmt|;
name|ID3D10Blob
modifier|*
name|vertexBinary
init|=
name|compileToBinary
argument_list|(
name|infoLog
argument_list|,
name|vertexHLSL
operator|.
name|c_str
argument_list|()
argument_list|,
name|vertexProfile
argument_list|,
operator|&
name|mConstantTableVS
argument_list|)
decl_stmt|;
name|ID3D10Blob
modifier|*
name|pixelBinary
init|=
name|compileToBinary
argument_list|(
name|infoLog
argument_list|,
name|pixelHLSL
operator|.
name|c_str
argument_list|()
argument_list|,
name|pixelProfile
argument_list|,
operator|&
name|mConstantTablePS
argument_list|)
decl_stmt|;
if|if
condition|(
name|vertexBinary
operator|&&
name|pixelBinary
condition|)
block|{
name|mVertexExecutable
operator|=
name|getDisplay
argument_list|()
operator|->
name|createVertexShader
argument_list|(
operator|(
name|DWORD
operator|*
operator|)
name|vertexBinary
operator|->
name|GetBufferPointer
argument_list|()
argument_list|,
name|vertexBinary
operator|->
name|GetBufferSize
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mVertexExecutable
condition|)
block|{
return|return
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|mPixelExecutable
operator|=
name|getDisplay
argument_list|()
operator|->
name|createPixelShader
argument_list|(
operator|(
name|DWORD
operator|*
operator|)
name|pixelBinary
operator|->
name|GetBufferPointer
argument_list|()
argument_list|,
name|pixelBinary
operator|->
name|GetBufferSize
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mPixelExecutable
condition|)
block|{
name|mVertexExecutable
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mVertexExecutable
operator|=
name|NULL
expr_stmt|;
return|return
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|vertexBinary
operator|->
name|Release
argument_list|()
expr_stmt|;
name|pixelBinary
operator|->
name|Release
argument_list|()
expr_stmt|;
name|vertexBinary
operator|=
name|NULL
expr_stmt|;
name|pixelBinary
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|linkAttributes
argument_list|(
name|infoLog
argument_list|,
name|attributeBindings
argument_list|,
name|fragmentShader
argument_list|,
name|vertexShader
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|linkUniforms
argument_list|(
name|infoLog
argument_list|,
name|GL_FRAGMENT_SHADER
argument_list|,
name|mConstantTablePS
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|linkUniforms
argument_list|(
name|infoLog
argument_list|,
name|GL_VERTEX_SHADER
argument_list|,
name|mConstantTableVS
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// these uniforms are searched as already-decorated because gl_ and dx_
comment|// are reserved prefixes, and do not receive additional decoration
name|mDxDepthRangeLocation
operator|=
name|getUniformLocation
argument_list|(
literal|"dx_DepthRange"
argument_list|)
expr_stmt|;
name|mDxDepthLocation
operator|=
name|getUniformLocation
argument_list|(
literal|"dx_Depth"
argument_list|)
expr_stmt|;
name|mDxCoordLocation
operator|=
name|getUniformLocation
argument_list|(
literal|"dx_Coord"
argument_list|)
expr_stmt|;
name|mDxHalfPixelSizeLocation
operator|=
name|getUniformLocation
argument_list|(
literal|"dx_HalfPixelSize"
argument_list|)
expr_stmt|;
name|mDxFrontCCWLocation
operator|=
name|getUniformLocation
argument_list|(
literal|"dx_FrontCCW"
argument_list|)
expr_stmt|;
name|mDxPointsOrLinesLocation
operator|=
name|getUniformLocation
argument_list|(
literal|"dx_PointsOrLines"
argument_list|)
expr_stmt|;
name|context
operator|->
name|markDxUniformsDirty
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|// Determines the mapping between GL attributes and Direct3D 9 vertex stream usage indices
DECL|function|linkAttributes
name|bool
name|ProgramBinary
operator|::
name|linkAttributes
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|AttributeBindings
modifier|&
name|attributeBindings
parameter_list|,
name|FragmentShader
modifier|*
name|fragmentShader
parameter_list|,
name|VertexShader
modifier|*
name|vertexShader
parameter_list|)
block|{
name|unsigned
name|int
name|usedLocations
init|=
literal|0
decl_stmt|;
comment|// Link attributes that have a binding location
for|for
control|(
name|AttributeArray
operator|::
name|iterator
name|attribute
init|=
name|vertexShader
operator|->
name|mAttributes
operator|.
name|begin
argument_list|()
init|;
name|attribute
operator|!=
name|vertexShader
operator|->
name|mAttributes
operator|.
name|end
argument_list|()
condition|;
name|attribute
operator|++
control|)
block|{
name|int
name|location
init|=
name|attributeBindings
operator|.
name|getAttributeBinding
argument_list|(
name|attribute
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
comment|// Set by glBindAttribLocation
block|{
if|if
condition|(
operator|!
name|mLinkedAttribute
index|[
name|location
index|]
operator|.
name|name
operator|.
name|empty
argument_list|()
condition|)
block|{
comment|// Multiple active attributes bound to the same location; not an error
block|}
name|mLinkedAttribute
index|[
name|location
index|]
operator|=
operator|*
name|attribute
expr_stmt|;
name|int
name|rows
init|=
name|VariableRowCount
argument_list|(
name|attribute
operator|->
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|rows
operator|+
name|location
operator|>
name|MAX_VERTEX_ATTRIBS
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Active attribute (%s) at location %d is too big to fit"
argument_list|,
name|attribute
operator|->
name|name
operator|.
name|c_str
argument_list|()
argument_list|,
name|location
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rows
condition|;
name|i
operator|++
control|)
block|{
name|usedLocations
operator||=
literal|1
operator|<<
operator|(
name|location
operator|+
name|i
operator|)
expr_stmt|;
block|}
block|}
block|}
comment|// Link attributes that don't have a binding location
for|for
control|(
name|AttributeArray
operator|::
name|iterator
name|attribute
init|=
name|vertexShader
operator|->
name|mAttributes
operator|.
name|begin
argument_list|()
init|;
name|attribute
operator|!=
name|vertexShader
operator|->
name|mAttributes
operator|.
name|end
argument_list|()
condition|;
name|attribute
operator|++
control|)
block|{
name|int
name|location
init|=
name|attributeBindings
operator|.
name|getAttributeBinding
argument_list|(
name|attribute
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|location
operator|==
operator|-
literal|1
condition|)
comment|// Not set by glBindAttribLocation
block|{
name|int
name|rows
init|=
name|VariableRowCount
argument_list|(
name|attribute
operator|->
name|type
argument_list|)
decl_stmt|;
name|int
name|availableIndex
init|=
name|AllocateFirstFreeBits
argument_list|(
operator|&
name|usedLocations
argument_list|,
name|rows
argument_list|,
name|MAX_VERTEX_ATTRIBS
argument_list|)
decl_stmt|;
if|if
condition|(
name|availableIndex
operator|==
operator|-
literal|1
operator|||
name|availableIndex
operator|+
name|rows
operator|>
name|MAX_VERTEX_ATTRIBS
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Too many active attributes (%s)"
argument_list|,
name|attribute
operator|->
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
comment|// Fail to link
block|}
name|mLinkedAttribute
index|[
name|availableIndex
index|]
operator|=
operator|*
name|attribute
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|attributeIndex
init|=
literal|0
init|;
name|attributeIndex
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
control|)
block|{
name|int
name|index
init|=
name|vertexShader
operator|->
name|getSemanticIndex
argument_list|(
name|mLinkedAttribute
index|[
name|attributeIndex
index|]
operator|.
name|name
argument_list|)
decl_stmt|;
name|int
name|rows
init|=
name|std
operator|::
name|max
argument_list|(
name|VariableRowCount
argument_list|(
name|mLinkedAttribute
index|[
name|attributeIndex
index|]
operator|.
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|r
init|=
literal|0
init|;
name|r
operator|<
name|rows
condition|;
name|r
operator|++
control|)
block|{
name|mSemanticIndex
index|[
name|attributeIndex
operator|++
index|]
operator|=
name|index
operator|++
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|linkUniforms
name|bool
name|ProgramBinary
operator|::
name|linkUniforms
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
name|GLenum
name|shader
parameter_list|,
name|D3DConstantTable
modifier|*
name|constantTable
parameter_list|)
block|{
for|for
control|(
name|unsigned
name|int
name|constantIndex
init|=
literal|0
init|;
name|constantIndex
operator|<
name|constantTable
operator|->
name|constants
argument_list|()
condition|;
name|constantIndex
operator|++
control|)
block|{
specifier|const
name|D3DConstant
modifier|*
name|constant
init|=
name|constantTable
operator|->
name|getConstant
argument_list|(
name|constantIndex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|defineUniform
argument_list|(
name|infoLog
argument_list|,
name|shader
argument_list|,
name|constant
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|// Adds the description of a constant found in the binary shader to the list of uniforms
comment|// Returns true if succesful (uniform not already defined)
DECL|function|defineUniform
name|bool
name|ProgramBinary
operator|::
name|defineUniform
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
name|GLenum
name|shader
parameter_list|,
specifier|const
name|D3DConstant
modifier|*
name|constant
parameter_list|,
name|std
operator|::
name|string
name|name
parameter_list|)
block|{
if|if
condition|(
name|constant
operator|->
name|registerSet
operator|==
name|D3DConstant
operator|::
name|RS_SAMPLER
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|constant
operator|->
name|registerCount
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|D3DConstant
modifier|*
name|psConstant
init|=
name|mConstantTablePS
operator|->
name|getConstantByName
argument_list|(
name|constant
operator|->
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|D3DConstant
modifier|*
name|vsConstant
init|=
name|mConstantTableVS
operator|->
name|getConstantByName
argument_list|(
name|constant
operator|->
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|psConstant
condition|)
block|{
name|unsigned
name|int
name|samplerIndex
init|=
name|psConstant
operator|->
name|registerIndex
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|samplerIndex
operator|<
name|MAX_TEXTURE_IMAGE_UNITS
condition|)
block|{
name|mSamplersPS
index|[
name|samplerIndex
index|]
operator|.
name|active
operator|=
literal|true
expr_stmt|;
name|mSamplersPS
index|[
name|samplerIndex
index|]
operator|.
name|textureType
operator|=
operator|(
name|constant
operator|->
name|type
operator|==
name|D3DConstant
operator|::
name|PT_SAMPLERCUBE
operator|)
condition|?
name|TEXTURE_CUBE
else|:
name|TEXTURE_2D
expr_stmt|;
name|mSamplersPS
index|[
name|samplerIndex
index|]
operator|.
name|logicalTextureUnit
operator|=
literal|0
expr_stmt|;
name|mUsedPixelSamplerRange
operator|=
name|std
operator|::
name|max
argument_list|(
name|samplerIndex
operator|+
literal|1
argument_list|,
name|mUsedPixelSamplerRange
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Pixel shader sampler count exceeds MAX_TEXTURE_IMAGE_UNITS (%d)."
argument_list|,
name|MAX_TEXTURE_IMAGE_UNITS
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|vsConstant
condition|)
block|{
name|unsigned
name|int
name|samplerIndex
init|=
name|vsConstant
operator|->
name|registerIndex
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|samplerIndex
operator|<
name|getContext
argument_list|()
operator|->
name|getMaximumVertexTextureImageUnits
argument_list|()
condition|)
block|{
name|mSamplersVS
index|[
name|samplerIndex
index|]
operator|.
name|active
operator|=
literal|true
expr_stmt|;
name|mSamplersVS
index|[
name|samplerIndex
index|]
operator|.
name|textureType
operator|=
operator|(
name|constant
operator|->
name|type
operator|==
name|D3DConstant
operator|::
name|PT_SAMPLERCUBE
operator|)
condition|?
name|TEXTURE_CUBE
else|:
name|TEXTURE_2D
expr_stmt|;
name|mSamplersVS
index|[
name|samplerIndex
index|]
operator|.
name|logicalTextureUnit
operator|=
literal|0
expr_stmt|;
name|mUsedVertexSamplerRange
operator|=
name|std
operator|::
name|max
argument_list|(
name|samplerIndex
operator|+
literal|1
argument_list|,
name|mUsedVertexSamplerRange
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Vertex shader sampler count exceeds MAX_VERTEX_TEXTURE_IMAGE_UNITS (%d)."
argument_list|,
name|getContext
argument_list|()
operator|->
name|getMaximumVertexTextureImageUnits
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
block|}
switch|switch
condition|(
name|constant
operator|->
name|typeClass
condition|)
block|{
case|case
name|D3DConstant
operator|::
name|CLASS_STRUCT
case|:
block|{
for|for
control|(
name|unsigned
name|int
name|arrayIndex
init|=
literal|0
init|;
name|arrayIndex
operator|<
name|constant
operator|->
name|elements
condition|;
name|arrayIndex
operator|++
control|)
block|{
for|for
control|(
name|unsigned
name|int
name|field
init|=
literal|0
init|;
name|field
operator|<
name|constant
operator|->
name|structMembers
index|[
name|arrayIndex
index|]
operator|.
name|size
argument_list|()
condition|;
name|field
operator|++
control|)
block|{
specifier|const
name|D3DConstant
modifier|*
name|fieldConstant
init|=
name|constant
operator|->
name|structMembers
index|[
name|arrayIndex
index|]
index|[
name|field
index|]
decl_stmt|;
name|std
operator|::
name|string
name|structIndex
init|=
operator|(
name|constant
operator|->
name|elements
operator|>
literal|1
operator|)
condition|?
operator|(
literal|"["
operator|+
name|str
argument_list|(
name|arrayIndex
argument_list|)
operator|+
literal|"]"
operator|)
else|:
literal|""
decl_stmt|;
if|if
condition|(
operator|!
name|defineUniform
argument_list|(
name|infoLog
argument_list|,
name|shader
argument_list|,
name|fieldConstant
argument_list|,
name|name
operator|+
name|constant
operator|->
name|name
operator|+
name|structIndex
operator|+
literal|"."
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
case|case
name|D3DConstant
operator|::
name|CLASS_SCALAR
case|:
case|case
name|D3DConstant
operator|::
name|CLASS_VECTOR
case|:
case|case
name|D3DConstant
operator|::
name|CLASS_MATRIX_COLUMNS
case|:
case|case
name|D3DConstant
operator|::
name|CLASS_OBJECT
case|:
return|return
name|defineUniform
argument_list|(
name|shader
argument_list|,
name|constant
argument_list|,
name|name
operator|+
name|constant
operator|->
name|name
argument_list|)
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|defineUniform
name|bool
name|ProgramBinary
operator|::
name|defineUniform
parameter_list|(
name|GLenum
name|shader
parameter_list|,
specifier|const
name|D3DConstant
modifier|*
name|constant
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|_name
parameter_list|)
block|{
name|Uniform
modifier|*
name|uniform
init|=
name|createUniform
argument_list|(
name|constant
argument_list|,
name|_name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|uniform
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Check if already defined
name|GLint
name|location
init|=
name|getUniformLocation
argument_list|(
name|uniform
operator|->
name|name
argument_list|)
decl_stmt|;
name|GLenum
name|type
init|=
name|uniform
operator|->
name|type
decl_stmt|;
if|if
condition|(
name|location
operator|>=
literal|0
condition|)
block|{
operator|delete
name|uniform
expr_stmt|;
name|uniform
operator|=
name|mUniforms
index|[
name|mUniformIndex
index|[
name|location
index|]
operator|.
name|index
index|]
expr_stmt|;
block|}
if|if
condition|(
name|shader
operator|==
name|GL_FRAGMENT_SHADER
condition|)
name|uniform
operator|->
name|ps
operator|.
name|set
argument_list|(
name|constant
argument_list|)
expr_stmt|;
if|if
condition|(
name|shader
operator|==
name|GL_VERTEX_SHADER
condition|)
name|uniform
operator|->
name|vs
operator|.
name|set
argument_list|(
name|constant
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|>=
literal|0
condition|)
block|{
return|return
name|uniform
operator|->
name|type
operator|==
name|type
return|;
block|}
name|mUniforms
operator|.
name|push_back
argument_list|(
name|uniform
argument_list|)
expr_stmt|;
name|unsigned
name|int
name|uniformIndex
init|=
name|mUniforms
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|uniform
operator|->
name|arraySize
condition|;
operator|++
name|i
control|)
block|{
name|mUniformIndex
operator|.
name|push_back
argument_list|(
name|UniformLocation
argument_list|(
name|_name
argument_list|,
name|i
argument_list|,
name|uniformIndex
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|createUniform
name|Uniform
modifier|*
name|ProgramBinary
operator|::
name|createUniform
parameter_list|(
specifier|const
name|D3DConstant
modifier|*
name|constant
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|_name
parameter_list|)
block|{
if|if
condition|(
name|constant
operator|->
name|rows
operator|==
literal|1
condition|)
comment|// Vectors and scalars
block|{
switch|switch
condition|(
name|constant
operator|->
name|type
condition|)
block|{
case|case
name|D3DConstant
operator|::
name|PT_SAMPLER2D
case|:
switch|switch
condition|(
name|constant
operator|->
name|columns
condition|)
block|{
case|case
literal|1
case|:
return|return
operator|new
name|Uniform
argument_list|(
name|GL_SAMPLER_2D
argument_list|,
name|_name
argument_list|,
name|constant
operator|->
name|elements
argument_list|)
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|D3DConstant
operator|::
name|PT_SAMPLERCUBE
case|:
switch|switch
condition|(
name|constant
operator|->
name|columns
condition|)
block|{
case|case
literal|1
case|:
return|return
operator|new
name|Uniform
argument_list|(
name|GL_SAMPLER_CUBE
argument_list|,
name|_name
argument_list|,
name|constant
operator|->
name|elements
argument_list|)
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|D3DConstant
operator|::
name|PT_BOOL
case|:
switch|switch
condition|(
name|constant
operator|->
name|columns
condition|)
block|{
case|case
literal|1
case|:
return|return
operator|new
name|Uniform
argument_list|(
name|GL_BOOL
argument_list|,
name|_name
argument_list|,
name|constant
operator|->
name|elements
argument_list|)
return|;
case|case
literal|2
case|:
return|return
operator|new
name|Uniform
argument_list|(
name|GL_BOOL_VEC2
argument_list|,
name|_name
argument_list|,
name|constant
operator|->
name|elements
argument_list|)
return|;
case|case
literal|3
case|:
return|return
operator|new
name|Uniform
argument_list|(
name|GL_BOOL_VEC3
argument_list|,
name|_name
argument_list|,
name|constant
operator|->
name|elements
argument_list|)
return|;
case|case
literal|4
case|:
return|return
operator|new
name|Uniform
argument_list|(
name|GL_BOOL_VEC4
argument_list|,
name|_name
argument_list|,
name|constant
operator|->
name|elements
argument_list|)
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|D3DConstant
operator|::
name|PT_INT
case|:
switch|switch
condition|(
name|constant
operator|->
name|columns
condition|)
block|{
case|case
literal|1
case|:
return|return
operator|new
name|Uniform
argument_list|(
name|GL_INT
argument_list|,
name|_name
argument_list|,
name|constant
operator|->
name|elements
argument_list|)
return|;
case|case
literal|2
case|:
return|return
operator|new
name|Uniform
argument_list|(
name|GL_INT_VEC2
argument_list|,
name|_name
argument_list|,
name|constant
operator|->
name|elements
argument_list|)
return|;
case|case
literal|3
case|:
return|return
operator|new
name|Uniform
argument_list|(
name|GL_INT_VEC3
argument_list|,
name|_name
argument_list|,
name|constant
operator|->
name|elements
argument_list|)
return|;
case|case
literal|4
case|:
return|return
operator|new
name|Uniform
argument_list|(
name|GL_INT_VEC4
argument_list|,
name|_name
argument_list|,
name|constant
operator|->
name|elements
argument_list|)
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|D3DConstant
operator|::
name|PT_FLOAT
case|:
switch|switch
condition|(
name|constant
operator|->
name|columns
condition|)
block|{
case|case
literal|1
case|:
return|return
operator|new
name|Uniform
argument_list|(
name|GL_FLOAT
argument_list|,
name|_name
argument_list|,
name|constant
operator|->
name|elements
argument_list|)
return|;
case|case
literal|2
case|:
return|return
operator|new
name|Uniform
argument_list|(
name|GL_FLOAT_VEC2
argument_list|,
name|_name
argument_list|,
name|constant
operator|->
name|elements
argument_list|)
return|;
case|case
literal|3
case|:
return|return
operator|new
name|Uniform
argument_list|(
name|GL_FLOAT_VEC3
argument_list|,
name|_name
argument_list|,
name|constant
operator|->
name|elements
argument_list|)
return|;
case|case
literal|4
case|:
return|return
operator|new
name|Uniform
argument_list|(
name|GL_FLOAT_VEC4
argument_list|,
name|_name
argument_list|,
name|constant
operator|->
name|elements
argument_list|)
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|constant
operator|->
name|rows
operator|==
name|constant
operator|->
name|columns
condition|)
comment|// Square matrices
block|{
switch|switch
condition|(
name|constant
operator|->
name|type
condition|)
block|{
case|case
name|D3DConstant
operator|::
name|PT_FLOAT
case|:
switch|switch
condition|(
name|constant
operator|->
name|rows
condition|)
block|{
case|case
literal|2
case|:
return|return
operator|new
name|Uniform
argument_list|(
name|GL_FLOAT_MAT2
argument_list|,
name|_name
argument_list|,
name|constant
operator|->
name|elements
argument_list|)
return|;
case|case
literal|3
case|:
return|return
operator|new
name|Uniform
argument_list|(
name|GL_FLOAT_MAT3
argument_list|,
name|_name
argument_list|,
name|constant
operator|->
name|elements
argument_list|)
return|;
case|case
literal|4
case|:
return|return
operator|new
name|Uniform
argument_list|(
name|GL_FLOAT_MAT4
argument_list|,
name|_name
argument_list|,
name|constant
operator|->
name|elements
argument_list|)
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|// This method needs to match OutputHLSL::decorate
DECL|function|decorateAttribute
name|std
operator|::
name|string
name|ProgramBinary
operator|::
name|decorateAttribute
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|,
literal|"gl_"
argument_list|)
operator|!=
literal|0
operator|&&
name|name
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|,
literal|"dx_"
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
literal|"_"
operator|+
name|name
return|;
block|}
return|return
name|name
return|;
block|}
DECL|function|undecorateUniform
name|std
operator|::
name|string
name|ProgramBinary
operator|::
name|undecorateUniform
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|_name
parameter_list|)
block|{
name|std
operator|::
name|string
name|name
init|=
name|_name
decl_stmt|;
comment|// Remove any structure field decoration
name|size_t
name|pos
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|pos
operator|=
name|name
operator|.
name|find
argument_list|(
literal|"._"
argument_list|,
name|pos
argument_list|)
operator|)
operator|!=
name|std
operator|::
name|string
operator|::
name|npos
condition|)
block|{
name|name
operator|.
name|replace
argument_list|(
name|pos
argument_list|,
literal|2
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
block|}
comment|// Remove the leading decoration
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
condition|)
block|{
return|return
name|name
operator|.
name|substr
argument_list|(
literal|1
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|,
literal|"ar_"
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|name
operator|.
name|substr
argument_list|(
literal|3
argument_list|)
return|;
block|}
return|return
name|name
return|;
block|}
DECL|function|applyUniformnbv
name|void
name|ProgramBinary
operator|::
name|applyUniformnbv
parameter_list|(
name|Uniform
modifier|*
name|targetUniform
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|int
name|width
parameter_list|,
specifier|const
name|GLboolean
modifier|*
name|v
parameter_list|)
block|{
name|float
name|vector
index|[
name|D3D9_MAX_FLOAT_CONSTANTS
operator|*
literal|4
index|]
decl_stmt|;
name|BOOL
name|boolVector
index|[
name|D3D9_MAX_BOOL_CONSTANTS
index|]
decl_stmt|;
if|if
condition|(
name|targetUniform
operator|->
name|ps
operator|.
name|float4Index
operator|>=
literal|0
operator|||
name|targetUniform
operator|->
name|vs
operator|.
name|float4Index
operator|>=
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|count
operator|<=
name|D3D9_MAX_FLOAT_CONSTANTS
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|<
name|width
condition|)
block|{
name|vector
index|[
name|i
operator|*
literal|4
operator|+
name|j
index|]
operator|=
operator|(
name|v
index|[
name|i
operator|*
name|width
operator|+
name|j
index|]
operator|==
name|GL_FALSE
operator|)
condition|?
literal|0.0f
else|:
literal|1.0f
expr_stmt|;
block|}
else|else
block|{
name|vector
index|[
name|i
operator|*
literal|4
operator|+
name|j
index|]
operator|=
literal|0.0f
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|targetUniform
operator|->
name|ps
operator|.
name|boolIndex
operator|>=
literal|0
operator|||
name|targetUniform
operator|->
name|vs
operator|.
name|boolIndex
operator|>=
literal|0
condition|)
block|{
name|int
name|psCount
init|=
name|targetUniform
operator|->
name|ps
operator|.
name|boolIndex
operator|>=
literal|0
condition|?
name|targetUniform
operator|->
name|ps
operator|.
name|registerCount
else|:
literal|0
decl_stmt|;
name|int
name|vsCount
init|=
name|targetUniform
operator|->
name|vs
operator|.
name|boolIndex
operator|>=
literal|0
condition|?
name|targetUniform
operator|->
name|vs
operator|.
name|registerCount
else|:
literal|0
decl_stmt|;
name|int
name|copyCount
init|=
name|std
operator|::
name|min
argument_list|(
name|count
operator|*
name|width
argument_list|,
name|std
operator|::
name|max
argument_list|(
name|psCount
argument_list|,
name|vsCount
argument_list|)
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|copyCount
operator|<=
name|D3D9_MAX_BOOL_CONSTANTS
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|copyCount
condition|;
name|i
operator|++
control|)
block|{
name|boolVector
index|[
name|i
index|]
operator|=
name|v
index|[
name|i
index|]
operator|!=
name|GL_FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|targetUniform
operator|->
name|ps
operator|.
name|float4Index
operator|>=
literal|0
condition|)
block|{
name|mDevice
operator|->
name|SetPixelShaderConstantF
argument_list|(
name|targetUniform
operator|->
name|ps
operator|.
name|float4Index
argument_list|,
name|vector
argument_list|,
name|targetUniform
operator|->
name|ps
operator|.
name|registerCount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targetUniform
operator|->
name|ps
operator|.
name|boolIndex
operator|>=
literal|0
condition|)
block|{
name|mDevice
operator|->
name|SetPixelShaderConstantB
argument_list|(
name|targetUniform
operator|->
name|ps
operator|.
name|boolIndex
argument_list|,
name|boolVector
argument_list|,
name|targetUniform
operator|->
name|ps
operator|.
name|registerCount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targetUniform
operator|->
name|vs
operator|.
name|float4Index
operator|>=
literal|0
condition|)
block|{
name|mDevice
operator|->
name|SetVertexShaderConstantF
argument_list|(
name|targetUniform
operator|->
name|vs
operator|.
name|float4Index
argument_list|,
name|vector
argument_list|,
name|targetUniform
operator|->
name|vs
operator|.
name|registerCount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targetUniform
operator|->
name|vs
operator|.
name|boolIndex
operator|>=
literal|0
condition|)
block|{
name|mDevice
operator|->
name|SetVertexShaderConstantB
argument_list|(
name|targetUniform
operator|->
name|vs
operator|.
name|boolIndex
argument_list|,
name|boolVector
argument_list|,
name|targetUniform
operator|->
name|vs
operator|.
name|registerCount
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|applyUniformnfv
name|bool
name|ProgramBinary
operator|::
name|applyUniformnfv
parameter_list|(
name|Uniform
modifier|*
name|targetUniform
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
name|targetUniform
operator|->
name|ps
operator|.
name|registerCount
condition|)
block|{
name|mDevice
operator|->
name|SetPixelShaderConstantF
argument_list|(
name|targetUniform
operator|->
name|ps
operator|.
name|float4Index
argument_list|,
name|v
argument_list|,
name|targetUniform
operator|->
name|ps
operator|.
name|registerCount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targetUniform
operator|->
name|vs
operator|.
name|registerCount
condition|)
block|{
name|mDevice
operator|->
name|SetVertexShaderConstantF
argument_list|(
name|targetUniform
operator|->
name|vs
operator|.
name|float4Index
argument_list|,
name|v
argument_list|,
name|targetUniform
operator|->
name|vs
operator|.
name|registerCount
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|applyUniform1iv
name|bool
name|ProgramBinary
operator|::
name|applyUniform1iv
parameter_list|(
name|Uniform
modifier|*
name|targetUniform
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|count
operator|<=
name|D3D9_MAX_FLOAT_CONSTANTS
argument_list|)
expr_stmt|;
name|Vector4
name|vector
index|[
name|D3D9_MAX_FLOAT_CONSTANTS
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|vector
index|[
name|i
index|]
operator|=
name|Vector4
argument_list|(
operator|(
name|float
operator|)
name|v
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targetUniform
operator|->
name|ps
operator|.
name|registerCount
condition|)
block|{
if|if
condition|(
name|targetUniform
operator|->
name|ps
operator|.
name|samplerIndex
operator|>=
literal|0
condition|)
block|{
name|unsigned
name|int
name|firstIndex
init|=
name|targetUniform
operator|->
name|ps
operator|.
name|samplerIndex
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|samplerIndex
init|=
name|firstIndex
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|samplerIndex
operator|<
name|MAX_TEXTURE_IMAGE_UNITS
condition|)
block|{
name|ASSERT
argument_list|(
name|mSamplersPS
index|[
name|samplerIndex
index|]
operator|.
name|active
argument_list|)
expr_stmt|;
name|mSamplersPS
index|[
name|samplerIndex
index|]
operator|.
name|logicalTextureUnit
operator|=
name|v
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|targetUniform
operator|->
name|ps
operator|.
name|float4Index
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetPixelShaderConstantF
argument_list|(
name|targetUniform
operator|->
name|ps
operator|.
name|float4Index
argument_list|,
operator|(
specifier|const
name|float
operator|*
operator|)
name|vector
argument_list|,
name|targetUniform
operator|->
name|ps
operator|.
name|registerCount
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|targetUniform
operator|->
name|vs
operator|.
name|registerCount
condition|)
block|{
if|if
condition|(
name|targetUniform
operator|->
name|vs
operator|.
name|samplerIndex
operator|>=
literal|0
condition|)
block|{
name|unsigned
name|int
name|firstIndex
init|=
name|targetUniform
operator|->
name|vs
operator|.
name|samplerIndex
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|samplerIndex
init|=
name|firstIndex
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|samplerIndex
operator|<
name|MAX_VERTEX_TEXTURE_IMAGE_UNITS_VTF
condition|)
block|{
name|ASSERT
argument_list|(
name|mSamplersVS
index|[
name|samplerIndex
index|]
operator|.
name|active
argument_list|)
expr_stmt|;
name|mSamplersVS
index|[
name|samplerIndex
index|]
operator|.
name|logicalTextureUnit
operator|=
name|v
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|targetUniform
operator|->
name|vs
operator|.
name|float4Index
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetVertexShaderConstantF
argument_list|(
name|targetUniform
operator|->
name|vs
operator|.
name|float4Index
argument_list|,
operator|(
specifier|const
name|float
operator|*
operator|)
name|vector
argument_list|,
name|targetUniform
operator|->
name|vs
operator|.
name|registerCount
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|applyUniform2iv
name|bool
name|ProgramBinary
operator|::
name|applyUniform2iv
parameter_list|(
name|Uniform
modifier|*
name|targetUniform
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|count
operator|<=
name|D3D9_MAX_FLOAT_CONSTANTS
argument_list|)
expr_stmt|;
name|Vector4
name|vector
index|[
name|D3D9_MAX_FLOAT_CONSTANTS
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|vector
index|[
name|i
index|]
operator|=
name|Vector4
argument_list|(
operator|(
name|float
operator|)
name|v
index|[
literal|0
index|]
argument_list|,
operator|(
name|float
operator|)
name|v
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|v
operator|+=
literal|2
expr_stmt|;
block|}
name|applyUniformniv
argument_list|(
name|targetUniform
argument_list|,
name|count
argument_list|,
name|vector
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|applyUniform3iv
name|bool
name|ProgramBinary
operator|::
name|applyUniform3iv
parameter_list|(
name|Uniform
modifier|*
name|targetUniform
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|count
operator|<=
name|D3D9_MAX_FLOAT_CONSTANTS
argument_list|)
expr_stmt|;
name|Vector4
name|vector
index|[
name|D3D9_MAX_FLOAT_CONSTANTS
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|vector
index|[
name|i
index|]
operator|=
name|Vector4
argument_list|(
operator|(
name|float
operator|)
name|v
index|[
literal|0
index|]
argument_list|,
operator|(
name|float
operator|)
name|v
index|[
literal|1
index|]
argument_list|,
operator|(
name|float
operator|)
name|v
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|v
operator|+=
literal|3
expr_stmt|;
block|}
name|applyUniformniv
argument_list|(
name|targetUniform
argument_list|,
name|count
argument_list|,
name|vector
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|applyUniform4iv
name|bool
name|ProgramBinary
operator|::
name|applyUniform4iv
parameter_list|(
name|Uniform
modifier|*
name|targetUniform
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|count
operator|<=
name|D3D9_MAX_FLOAT_CONSTANTS
argument_list|)
expr_stmt|;
name|Vector4
name|vector
index|[
name|D3D9_MAX_FLOAT_CONSTANTS
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|vector
index|[
name|i
index|]
operator|=
name|Vector4
argument_list|(
operator|(
name|float
operator|)
name|v
index|[
literal|0
index|]
argument_list|,
operator|(
name|float
operator|)
name|v
index|[
literal|1
index|]
argument_list|,
operator|(
name|float
operator|)
name|v
index|[
literal|2
index|]
argument_list|,
operator|(
name|float
operator|)
name|v
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|v
operator|+=
literal|4
expr_stmt|;
block|}
name|applyUniformniv
argument_list|(
name|targetUniform
argument_list|,
name|count
argument_list|,
name|vector
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|applyUniformniv
name|void
name|ProgramBinary
operator|::
name|applyUniformniv
parameter_list|(
name|Uniform
modifier|*
name|targetUniform
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|Vector4
modifier|*
name|vector
parameter_list|)
block|{
if|if
condition|(
name|targetUniform
operator|->
name|ps
operator|.
name|registerCount
condition|)
block|{
name|ASSERT
argument_list|(
name|targetUniform
operator|->
name|ps
operator|.
name|float4Index
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetPixelShaderConstantF
argument_list|(
name|targetUniform
operator|->
name|ps
operator|.
name|float4Index
argument_list|,
operator|(
specifier|const
name|float
operator|*
operator|)
name|vector
argument_list|,
name|targetUniform
operator|->
name|ps
operator|.
name|registerCount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targetUniform
operator|->
name|vs
operator|.
name|registerCount
condition|)
block|{
name|ASSERT
argument_list|(
name|targetUniform
operator|->
name|vs
operator|.
name|float4Index
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetVertexShaderConstantF
argument_list|(
name|targetUniform
operator|->
name|vs
operator|.
name|float4Index
argument_list|,
operator|(
specifier|const
name|float
operator|*
operator|)
name|vector
argument_list|,
name|targetUniform
operator|->
name|vs
operator|.
name|registerCount
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|isValidated
name|bool
name|ProgramBinary
operator|::
name|isValidated
parameter_list|()
specifier|const
block|{
return|return
name|mValidated
return|;
block|}
DECL|function|getActiveAttribute
name|void
name|ProgramBinary
operator|::
name|getActiveAttribute
parameter_list|(
name|GLuint
name|index
parameter_list|,
name|GLsizei
name|bufsize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|,
name|GLint
modifier|*
name|size
parameter_list|,
name|GLenum
modifier|*
name|type
parameter_list|,
name|GLchar
modifier|*
name|name
parameter_list|)
block|{
comment|// Skip over inactive attributes
name|unsigned
name|int
name|activeAttribute
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|attribute
decl_stmt|;
for|for
control|(
name|attribute
operator|=
literal|0
init|;
name|attribute
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|attribute
operator|++
control|)
block|{
if|if
condition|(
name|mLinkedAttribute
index|[
name|attribute
index|]
operator|.
name|name
operator|.
name|empty
argument_list|()
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|activeAttribute
operator|==
name|index
condition|)
block|{
break|break;
block|}
name|activeAttribute
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bufsize
operator|>
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|string
init|=
name|mLinkedAttribute
index|[
name|attribute
index|]
operator|.
name|name
operator|.
name|c_str
argument_list|()
decl_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
name|string
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|name
index|[
name|bufsize
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|size
operator|=
literal|1
expr_stmt|;
comment|// Always a single 'type' instance
operator|*
name|type
operator|=
name|mLinkedAttribute
index|[
name|attribute
index|]
operator|.
name|type
expr_stmt|;
block|}
DECL|function|getActiveAttributeCount
name|GLint
name|ProgramBinary
operator|::
name|getActiveAttributeCount
parameter_list|()
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|attributeIndex
init|=
literal|0
init|;
name|attributeIndex
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|attributeIndex
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|mLinkedAttribute
index|[
name|attributeIndex
index|]
operator|.
name|name
operator|.
name|empty
argument_list|()
condition|)
block|{
name|count
operator|++
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
DECL|function|getActiveAttributeMaxLength
name|GLint
name|ProgramBinary
operator|::
name|getActiveAttributeMaxLength
parameter_list|()
block|{
name|int
name|maxLength
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|attributeIndex
init|=
literal|0
init|;
name|attributeIndex
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|attributeIndex
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|mLinkedAttribute
index|[
name|attributeIndex
index|]
operator|.
name|name
operator|.
name|empty
argument_list|()
condition|)
block|{
name|maxLength
operator|=
name|std
operator|::
name|max
argument_list|(
call|(
name|int
call|)
argument_list|(
name|mLinkedAttribute
index|[
name|attributeIndex
index|]
operator|.
name|name
operator|.
name|length
argument_list|()
operator|+
literal|1
argument_list|)
argument_list|,
name|maxLength
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|maxLength
return|;
block|}
DECL|function|getActiveUniform
name|void
name|ProgramBinary
operator|::
name|getActiveUniform
parameter_list|(
name|GLuint
name|index
parameter_list|,
name|GLsizei
name|bufsize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|,
name|GLint
modifier|*
name|size
parameter_list|,
name|GLenum
modifier|*
name|type
parameter_list|,
name|GLchar
modifier|*
name|name
parameter_list|)
block|{
comment|// Skip over internal uniforms
name|unsigned
name|int
name|activeUniform
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|uniform
decl_stmt|;
for|for
control|(
name|uniform
operator|=
literal|0
init|;
name|uniform
operator|<
name|mUniforms
operator|.
name|size
argument_list|()
condition|;
name|uniform
operator|++
control|)
block|{
if|if
condition|(
name|mUniforms
index|[
name|uniform
index|]
operator|->
name|name
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|,
literal|"dx_"
argument_list|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|activeUniform
operator|==
name|index
condition|)
block|{
break|break;
block|}
name|activeUniform
operator|++
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|uniform
operator|<
name|mUniforms
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// index must be smaller than getActiveUniformCount()
if|if
condition|(
name|bufsize
operator|>
literal|0
condition|)
block|{
name|std
operator|::
name|string
name|string
init|=
name|mUniforms
index|[
name|uniform
index|]
operator|->
name|name
decl_stmt|;
if|if
condition|(
name|mUniforms
index|[
name|uniform
index|]
operator|->
name|isArray
argument_list|()
condition|)
block|{
name|string
operator|+=
literal|"[0]"
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|name
argument_list|,
name|string
operator|.
name|c_str
argument_list|()
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|name
index|[
name|bufsize
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|size
operator|=
name|mUniforms
index|[
name|uniform
index|]
operator|->
name|arraySize
expr_stmt|;
operator|*
name|type
operator|=
name|mUniforms
index|[
name|uniform
index|]
operator|->
name|type
expr_stmt|;
block|}
DECL|function|getActiveUniformCount
name|GLint
name|ProgramBinary
operator|::
name|getActiveUniformCount
parameter_list|()
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|numUniforms
init|=
name|mUniforms
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|uniformIndex
init|=
literal|0
init|;
name|uniformIndex
operator|<
name|numUniforms
condition|;
name|uniformIndex
operator|++
control|)
block|{
if|if
condition|(
name|mUniforms
index|[
name|uniformIndex
index|]
operator|->
name|name
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|,
literal|"dx_"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|count
operator|++
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
DECL|function|getActiveUniformMaxLength
name|GLint
name|ProgramBinary
operator|::
name|getActiveUniformMaxLength
parameter_list|()
block|{
name|int
name|maxLength
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|numUniforms
init|=
name|mUniforms
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|uniformIndex
init|=
literal|0
init|;
name|uniformIndex
operator|<
name|numUniforms
condition|;
name|uniformIndex
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|mUniforms
index|[
name|uniformIndex
index|]
operator|->
name|name
operator|.
name|empty
argument_list|()
operator|&&
name|mUniforms
index|[
name|uniformIndex
index|]
operator|->
name|name
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|,
literal|"dx_"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|length
init|=
call|(
name|int
call|)
argument_list|(
name|mUniforms
index|[
name|uniformIndex
index|]
operator|->
name|name
operator|.
name|length
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|mUniforms
index|[
name|uniformIndex
index|]
operator|->
name|isArray
argument_list|()
condition|)
block|{
name|length
operator|+=
literal|3
expr_stmt|;
comment|// Counting in "[0]".
block|}
name|maxLength
operator|=
name|std
operator|::
name|max
argument_list|(
name|length
argument_list|,
name|maxLength
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|maxLength
return|;
block|}
DECL|function|validate
name|void
name|ProgramBinary
operator|::
name|validate
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|)
block|{
name|applyUniforms
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|validateSamplers
argument_list|(
operator|&
name|infoLog
argument_list|)
condition|)
block|{
name|mValidated
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|mValidated
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|validateSamplers
name|bool
name|ProgramBinary
operator|::
name|validateSamplers
parameter_list|(
name|InfoLog
modifier|*
name|infoLog
parameter_list|)
block|{
comment|// if any two active samplers in a program are of different types, but refer to the same
comment|// texture image unit, and this is the current program, then ValidateProgram will fail, and
comment|// DrawArrays and DrawElements will issue the INVALID_OPERATION error.
specifier|const
name|unsigned
name|int
name|maxCombinedTextureImageUnits
init|=
name|getContext
argument_list|()
operator|->
name|getMaximumCombinedTextureImageUnits
argument_list|()
decl_stmt|;
name|TextureType
name|textureUnitType
index|[
name|MAX_COMBINED_TEXTURE_IMAGE_UNITS_VTF
index|]
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_COMBINED_TEXTURE_IMAGE_UNITS_VTF
condition|;
operator|++
name|i
control|)
block|{
name|textureUnitType
index|[
name|i
index|]
operator|=
name|TEXTURE_UNKNOWN
expr_stmt|;
block|}
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mUsedPixelSamplerRange
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|active
condition|)
block|{
name|unsigned
name|int
name|unit
init|=
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|logicalTextureUnit
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|maxCombinedTextureImageUnits
condition|)
block|{
if|if
condition|(
name|infoLog
condition|)
block|{
name|infoLog
operator|->
name|append
argument_list|(
literal|"Sampler uniform (%d) exceeds MAX_COMBINED_TEXTURE_IMAGE_UNITS (%d)"
argument_list|,
name|unit
argument_list|,
name|maxCombinedTextureImageUnits
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
if|if
condition|(
name|textureUnitType
index|[
name|unit
index|]
operator|!=
name|TEXTURE_UNKNOWN
condition|)
block|{
if|if
condition|(
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|textureType
operator|!=
name|textureUnitType
index|[
name|unit
index|]
condition|)
block|{
if|if
condition|(
name|infoLog
condition|)
block|{
name|infoLog
operator|->
name|append
argument_list|(
literal|"Samplers of conflicting types refer to the same texture image unit (%d)."
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
name|textureUnitType
index|[
name|unit
index|]
operator|=
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|textureType
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mUsedVertexSamplerRange
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|active
condition|)
block|{
name|unsigned
name|int
name|unit
init|=
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|logicalTextureUnit
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|maxCombinedTextureImageUnits
condition|)
block|{
if|if
condition|(
name|infoLog
condition|)
block|{
name|infoLog
operator|->
name|append
argument_list|(
literal|"Sampler uniform (%d) exceeds MAX_COMBINED_TEXTURE_IMAGE_UNITS (%d)"
argument_list|,
name|unit
argument_list|,
name|maxCombinedTextureImageUnits
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
if|if
condition|(
name|textureUnitType
index|[
name|unit
index|]
operator|!=
name|TEXTURE_UNKNOWN
condition|)
block|{
if|if
condition|(
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|textureType
operator|!=
name|textureUnitType
index|[
name|unit
index|]
condition|)
block|{
if|if
condition|(
name|infoLog
condition|)
block|{
name|infoLog
operator|->
name|append
argument_list|(
literal|"Samplers of conflicting types refer to the same texture image unit (%d)."
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
name|textureUnitType
index|[
name|unit
index|]
operator|=
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|textureType
expr_stmt|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|getDxDepthRangeLocation
name|GLint
name|ProgramBinary
operator|::
name|getDxDepthRangeLocation
parameter_list|()
specifier|const
block|{
return|return
name|mDxDepthRangeLocation
return|;
block|}
DECL|function|getDxDepthLocation
name|GLint
name|ProgramBinary
operator|::
name|getDxDepthLocation
parameter_list|()
specifier|const
block|{
return|return
name|mDxDepthLocation
return|;
block|}
DECL|function|getDxCoordLocation
name|GLint
name|ProgramBinary
operator|::
name|getDxCoordLocation
parameter_list|()
specifier|const
block|{
return|return
name|mDxCoordLocation
return|;
block|}
DECL|function|getDxHalfPixelSizeLocation
name|GLint
name|ProgramBinary
operator|::
name|getDxHalfPixelSizeLocation
parameter_list|()
specifier|const
block|{
return|return
name|mDxHalfPixelSizeLocation
return|;
block|}
DECL|function|getDxFrontCCWLocation
name|GLint
name|ProgramBinary
operator|::
name|getDxFrontCCWLocation
parameter_list|()
specifier|const
block|{
return|return
name|mDxFrontCCWLocation
return|;
block|}
DECL|function|getDxPointsOrLinesLocation
name|GLint
name|ProgramBinary
operator|::
name|getDxPointsOrLinesLocation
parameter_list|()
specifier|const
block|{
return|return
name|mDxPointsOrLinesLocation
return|;
block|}
DECL|function|Sampler
name|ProgramBinary
operator|::
name|Sampler
operator|::
name|Sampler
parameter_list|()
member_init_list|:
name|active
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|logicalTextureUnit
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|textureType
argument_list|(
name|TEXTURE_2D
argument_list|)
block|{ }
block|}
end_namespace
end_unit
