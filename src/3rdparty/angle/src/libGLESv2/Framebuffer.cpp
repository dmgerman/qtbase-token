begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Framebuffer.cpp: Implements the gl::Framebuffer class. Implements GL framebuffer
end_comment
begin_comment
comment|// objects and related functionality. [OpenGL ES 2.0.24] section 4.4 page 105.
end_comment
begin_include
include|#
directive|include
file|"libGLESv2/Framebuffer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/main.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/formatutils.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Texture.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Context.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Renderbuffer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/FramebufferAttachment.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/Renderer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/RenderTarget.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/RenderbufferImpl.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/Workarounds.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/TextureD3D.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/RenderbufferD3D.h"
end_include
begin_include
include|#
directive|include
file|"common/utilities.h"
end_include
begin_namespace
DECL|namespace|rx
namespace|namespace
name|rx
block|{
comment|// TODO: Move these functions, and the D3D-specific header inclusions above,
comment|//       to FramebufferD3D.
DECL|function|GetAttachmentRenderTarget
name|gl
operator|::
name|Error
name|GetAttachmentRenderTarget
parameter_list|(
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|attachment
parameter_list|,
name|RenderTarget
modifier|*
modifier|*
name|outRT
parameter_list|)
block|{
if|if
condition|(
name|attachment
operator|->
name|isTexture
argument_list|()
condition|)
block|{
name|gl
operator|::
name|Texture
modifier|*
name|texture
init|=
name|attachment
operator|->
name|getTexture
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|texture
argument_list|)
expr_stmt|;
name|TextureD3D
modifier|*
name|textureD3D
init|=
name|TextureD3D
operator|::
name|makeTextureD3D
argument_list|(
name|texture
operator|->
name|getImplementation
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|*
name|index
init|=
name|attachment
operator|->
name|getTextureImageIndex
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|index
argument_list|)
expr_stmt|;
return|return
name|textureD3D
operator|->
name|getRenderTarget
argument_list|(
operator|*
name|index
argument_list|,
name|outRT
argument_list|)
return|;
block|}
else|else
block|{
name|gl
operator|::
name|Renderbuffer
modifier|*
name|renderbuffer
init|=
name|attachment
operator|->
name|getRenderbuffer
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|renderbuffer
argument_list|)
expr_stmt|;
name|RenderbufferD3D
modifier|*
name|renderbufferD3D
init|=
name|RenderbufferD3D
operator|::
name|makeRenderbufferD3D
argument_list|(
name|renderbuffer
operator|->
name|getImplementation
argument_list|()
argument_list|)
decl_stmt|;
operator|*
name|outRT
operator|=
name|renderbufferD3D
operator|->
name|getRenderTarget
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
block|}
comment|// Note: RenderTarget serials should ideally be in the RenderTargets themselves.
DECL|function|GetAttachmentSerial
name|unsigned
name|int
name|GetAttachmentSerial
parameter_list|(
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|attachment
parameter_list|)
block|{
if|if
condition|(
name|attachment
operator|->
name|isTexture
argument_list|()
condition|)
block|{
name|gl
operator|::
name|Texture
modifier|*
name|texture
init|=
name|attachment
operator|->
name|getTexture
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|texture
argument_list|)
expr_stmt|;
name|TextureD3D
modifier|*
name|textureD3D
init|=
name|TextureD3D
operator|::
name|makeTextureD3D
argument_list|(
name|texture
operator|->
name|getImplementation
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|*
name|index
init|=
name|attachment
operator|->
name|getTextureImageIndex
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|index
argument_list|)
expr_stmt|;
return|return
name|textureD3D
operator|->
name|getRenderTargetSerial
argument_list|(
operator|*
name|index
argument_list|)
return|;
block|}
name|gl
operator|::
name|Renderbuffer
modifier|*
name|renderbuffer
init|=
name|attachment
operator|->
name|getRenderbuffer
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|renderbuffer
argument_list|)
expr_stmt|;
name|RenderbufferD3D
modifier|*
name|renderbufferD3D
init|=
name|RenderbufferD3D
operator|::
name|makeRenderbufferD3D
argument_list|(
name|renderbuffer
operator|->
name|getImplementation
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|renderbufferD3D
operator|->
name|getRenderTargetSerial
argument_list|()
return|;
block|}
block|}
end_namespace
begin_namespace
DECL|namespace|gl
namespace|namespace
name|gl
block|{
DECL|function|Framebuffer
name|Framebuffer
operator|::
name|Framebuffer
parameter_list|(
name|GLuint
name|id
parameter_list|)
member_init_list|:
name|mId
argument_list|(
name|id
argument_list|)
member_init_list|,
name|mReadBufferState
argument_list|(
name|GL_COLOR_ATTACHMENT0_EXT
argument_list|)
member_init_list|,
name|mDepthbuffer
argument_list|(
name|NULL
argument_list|)
member_init_list|,
name|mStencilbuffer
argument_list|(
name|NULL
argument_list|)
block|{
for|for
control|(
name|unsigned
name|int
name|colorAttachment
init|=
literal|0
init|;
name|colorAttachment
operator|<
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
condition|;
name|colorAttachment
operator|++
control|)
block|{
name|mColorbuffers
index|[
name|colorAttachment
index|]
operator|=
name|NULL
expr_stmt|;
name|mDrawBufferStates
index|[
name|colorAttachment
index|]
operator|=
name|GL_NONE
expr_stmt|;
block|}
name|mDrawBufferStates
index|[
literal|0
index|]
operator|=
name|GL_COLOR_ATTACHMENT0_EXT
expr_stmt|;
block|}
DECL|function|~Framebuffer
name|Framebuffer
operator|::
name|~
name|Framebuffer
parameter_list|()
block|{
for|for
control|(
name|unsigned
name|int
name|colorAttachment
init|=
literal|0
init|;
name|colorAttachment
operator|<
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
condition|;
name|colorAttachment
operator|++
control|)
block|{
name|SafeDelete
argument_list|(
name|mColorbuffers
index|[
name|colorAttachment
index|]
argument_list|)
expr_stmt|;
block|}
name|SafeDelete
argument_list|(
name|mDepthbuffer
argument_list|)
expr_stmt|;
name|SafeDelete
argument_list|(
name|mStencilbuffer
argument_list|)
expr_stmt|;
block|}
DECL|function|detachTexture
name|void
name|Framebuffer
operator|::
name|detachTexture
parameter_list|(
name|GLuint
name|textureId
parameter_list|)
block|{
for|for
control|(
name|unsigned
name|int
name|colorAttachment
init|=
literal|0
init|;
name|colorAttachment
operator|<
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
condition|;
name|colorAttachment
operator|++
control|)
block|{
name|FramebufferAttachment
modifier|*
name|attachment
init|=
name|mColorbuffers
index|[
name|colorAttachment
index|]
decl_stmt|;
if|if
condition|(
name|attachment
operator|&&
name|attachment
operator|->
name|isTextureWithId
argument_list|(
name|textureId
argument_list|)
condition|)
block|{
name|SafeDelete
argument_list|(
name|mColorbuffers
index|[
name|colorAttachment
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mDepthbuffer
operator|&&
name|mDepthbuffer
operator|->
name|isTextureWithId
argument_list|(
name|textureId
argument_list|)
condition|)
block|{
name|SafeDelete
argument_list|(
name|mDepthbuffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mStencilbuffer
operator|&&
name|mStencilbuffer
operator|->
name|isTextureWithId
argument_list|(
name|textureId
argument_list|)
condition|)
block|{
name|SafeDelete
argument_list|(
name|mStencilbuffer
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|detachRenderbuffer
name|void
name|Framebuffer
operator|::
name|detachRenderbuffer
parameter_list|(
name|GLuint
name|renderbufferId
parameter_list|)
block|{
for|for
control|(
name|unsigned
name|int
name|colorAttachment
init|=
literal|0
init|;
name|colorAttachment
operator|<
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
condition|;
name|colorAttachment
operator|++
control|)
block|{
name|FramebufferAttachment
modifier|*
name|attachment
init|=
name|mColorbuffers
index|[
name|colorAttachment
index|]
decl_stmt|;
if|if
condition|(
name|attachment
operator|&&
name|attachment
operator|->
name|isRenderbufferWithId
argument_list|(
name|renderbufferId
argument_list|)
condition|)
block|{
name|SafeDelete
argument_list|(
name|mColorbuffers
index|[
name|colorAttachment
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mDepthbuffer
operator|&&
name|mDepthbuffer
operator|->
name|isRenderbufferWithId
argument_list|(
name|renderbufferId
argument_list|)
condition|)
block|{
name|SafeDelete
argument_list|(
name|mDepthbuffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mStencilbuffer
operator|&&
name|mStencilbuffer
operator|->
name|isRenderbufferWithId
argument_list|(
name|renderbufferId
argument_list|)
condition|)
block|{
name|SafeDelete
argument_list|(
name|mStencilbuffer
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|getColorbuffer
name|FramebufferAttachment
modifier|*
name|Framebuffer
operator|::
name|getColorbuffer
parameter_list|(
name|unsigned
name|int
name|colorAttachment
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|colorAttachment
operator|<
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
argument_list|)
expr_stmt|;
return|return
name|mColorbuffers
index|[
name|colorAttachment
index|]
return|;
block|}
DECL|function|getDepthbuffer
name|FramebufferAttachment
modifier|*
name|Framebuffer
operator|::
name|getDepthbuffer
parameter_list|()
specifier|const
block|{
return|return
name|mDepthbuffer
return|;
block|}
DECL|function|getStencilbuffer
name|FramebufferAttachment
modifier|*
name|Framebuffer
operator|::
name|getStencilbuffer
parameter_list|()
specifier|const
block|{
return|return
name|mStencilbuffer
return|;
block|}
DECL|function|getDepthStencilBuffer
name|FramebufferAttachment
modifier|*
name|Framebuffer
operator|::
name|getDepthStencilBuffer
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|hasValidDepthStencil
argument_list|()
condition|?
name|mDepthbuffer
else|:
name|NULL
operator|)
return|;
block|}
DECL|function|getDepthOrStencilbuffer
name|FramebufferAttachment
modifier|*
name|Framebuffer
operator|::
name|getDepthOrStencilbuffer
parameter_list|()
specifier|const
block|{
name|FramebufferAttachment
modifier|*
name|depthstencilbuffer
init|=
name|mDepthbuffer
decl_stmt|;
if|if
condition|(
operator|!
name|depthstencilbuffer
condition|)
block|{
name|depthstencilbuffer
operator|=
name|mStencilbuffer
expr_stmt|;
block|}
return|return
name|depthstencilbuffer
return|;
block|}
DECL|function|getReadColorbuffer
name|FramebufferAttachment
modifier|*
name|Framebuffer
operator|::
name|getReadColorbuffer
parameter_list|()
specifier|const
block|{
comment|// Will require more logic if glReadBuffers is supported
return|return
name|mColorbuffers
index|[
literal|0
index|]
return|;
block|}
DECL|function|getReadColorbufferType
name|GLenum
name|Framebuffer
operator|::
name|getReadColorbufferType
parameter_list|()
specifier|const
block|{
comment|// Will require more logic if glReadBuffers is supported
return|return
operator|(
name|mColorbuffers
index|[
literal|0
index|]
condition|?
name|mColorbuffers
index|[
literal|0
index|]
operator|->
name|type
argument_list|()
else|:
name|GL_NONE
operator|)
return|;
block|}
DECL|function|getFirstColorbuffer
name|FramebufferAttachment
modifier|*
name|Framebuffer
operator|::
name|getFirstColorbuffer
parameter_list|()
specifier|const
block|{
for|for
control|(
name|unsigned
name|int
name|colorAttachment
init|=
literal|0
init|;
name|colorAttachment
operator|<
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
condition|;
name|colorAttachment
operator|++
control|)
block|{
if|if
condition|(
name|mColorbuffers
index|[
name|colorAttachment
index|]
condition|)
block|{
return|return
name|mColorbuffers
index|[
name|colorAttachment
index|]
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
DECL|function|getAttachment
name|FramebufferAttachment
modifier|*
name|Framebuffer
operator|::
name|getAttachment
parameter_list|(
name|GLenum
name|attachment
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|attachment
operator|>=
name|GL_COLOR_ATTACHMENT0
operator|&&
name|attachment
operator|<=
name|GL_COLOR_ATTACHMENT15
condition|)
block|{
return|return
name|getColorbuffer
argument_list|(
name|attachment
operator|-
name|GL_COLOR_ATTACHMENT0
argument_list|)
return|;
block|}
else|else
block|{
switch|switch
condition|(
name|attachment
condition|)
block|{
case|case
name|GL_DEPTH_ATTACHMENT
case|:
return|return
name|getDepthbuffer
argument_list|()
return|;
case|case
name|GL_STENCIL_ATTACHMENT
case|:
return|return
name|getStencilbuffer
argument_list|()
return|;
case|case
name|GL_DEPTH_STENCIL_ATTACHMENT
case|:
return|return
name|getDepthStencilBuffer
argument_list|()
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
block|}
DECL|function|getDrawBufferState
name|GLenum
name|Framebuffer
operator|::
name|getDrawBufferState
parameter_list|(
name|unsigned
name|int
name|colorAttachment
parameter_list|)
specifier|const
block|{
return|return
name|mDrawBufferStates
index|[
name|colorAttachment
index|]
return|;
block|}
DECL|function|setDrawBufferState
name|void
name|Framebuffer
operator|::
name|setDrawBufferState
parameter_list|(
name|unsigned
name|int
name|colorAttachment
parameter_list|,
name|GLenum
name|drawBuffer
parameter_list|)
block|{
name|mDrawBufferStates
index|[
name|colorAttachment
index|]
operator|=
name|drawBuffer
expr_stmt|;
block|}
DECL|function|isEnabledColorAttachment
name|bool
name|Framebuffer
operator|::
name|isEnabledColorAttachment
parameter_list|(
name|unsigned
name|int
name|colorAttachment
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|mColorbuffers
index|[
name|colorAttachment
index|]
operator|&&
name|mDrawBufferStates
index|[
name|colorAttachment
index|]
operator|!=
name|GL_NONE
operator|)
return|;
block|}
DECL|function|hasEnabledColorAttachment
name|bool
name|Framebuffer
operator|::
name|hasEnabledColorAttachment
parameter_list|()
specifier|const
block|{
for|for
control|(
name|unsigned
name|int
name|colorAttachment
init|=
literal|0
init|;
name|colorAttachment
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
condition|;
name|colorAttachment
operator|++
control|)
block|{
if|if
condition|(
name|isEnabledColorAttachment
argument_list|(
name|colorAttachment
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|function|hasStencil
name|bool
name|Framebuffer
operator|::
name|hasStencil
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|mStencilbuffer
operator|&&
name|mStencilbuffer
operator|->
name|getStencilSize
argument_list|()
operator|>
literal|0
operator|)
return|;
block|}
DECL|function|usingExtendedDrawBuffers
name|bool
name|Framebuffer
operator|::
name|usingExtendedDrawBuffers
parameter_list|()
specifier|const
block|{
for|for
control|(
name|unsigned
name|int
name|colorAttachment
init|=
literal|1
init|;
name|colorAttachment
operator|<
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
condition|;
name|colorAttachment
operator|++
control|)
block|{
if|if
condition|(
name|isEnabledColorAttachment
argument_list|(
name|colorAttachment
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|function|completeness
name|GLenum
name|Framebuffer
operator|::
name|completeness
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|)
specifier|const
block|{
name|int
name|width
init|=
literal|0
decl_stmt|;
name|int
name|height
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|colorbufferSize
init|=
literal|0
decl_stmt|;
name|int
name|samples
init|=
operator|-
literal|1
decl_stmt|;
name|bool
name|missingAttachment
init|=
literal|true
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|colorAttachment
init|=
literal|0
init|;
name|colorAttachment
operator|<
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
condition|;
name|colorAttachment
operator|++
control|)
block|{
specifier|const
name|FramebufferAttachment
modifier|*
name|colorbuffer
init|=
name|mColorbuffers
index|[
name|colorAttachment
index|]
decl_stmt|;
if|if
condition|(
name|colorbuffer
condition|)
block|{
if|if
condition|(
name|colorbuffer
operator|->
name|getWidth
argument_list|()
operator|==
literal|0
operator|||
name|colorbuffer
operator|->
name|getHeight
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT
return|;
block|}
name|GLenum
name|internalformat
init|=
name|colorbuffer
operator|->
name|getInternalFormat
argument_list|()
decl_stmt|;
specifier|const
name|TextureCaps
modifier|&
name|formatCaps
init|=
name|data
operator|.
name|textureCaps
operator|->
name|get
argument_list|(
name|internalformat
argument_list|)
decl_stmt|;
specifier|const
name|InternalFormat
modifier|&
name|formatInfo
init|=
name|GetInternalFormatInfo
argument_list|(
name|internalformat
argument_list|)
decl_stmt|;
if|if
condition|(
name|colorbuffer
operator|->
name|isTexture
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|formatCaps
operator|.
name|renderable
condition|)
block|{
return|return
name|GL_FRAMEBUFFER_UNSUPPORTED
return|;
block|}
if|if
condition|(
name|formatInfo
operator|.
name|depthBits
operator|>
literal|0
operator|||
name|formatInfo
operator|.
name|stencilBits
operator|>
literal|0
condition|)
block|{
return|return
name|GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|formatCaps
operator|.
name|renderable
operator|||
name|formatInfo
operator|.
name|depthBits
operator|>
literal|0
operator|||
name|formatInfo
operator|.
name|stencilBits
operator|>
literal|0
condition|)
block|{
return|return
name|GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT
return|;
block|}
block|}
if|if
condition|(
operator|!
name|missingAttachment
condition|)
block|{
comment|// all color attachments must have the same width and height
if|if
condition|(
name|colorbuffer
operator|->
name|getWidth
argument_list|()
operator|!=
name|width
operator|||
name|colorbuffer
operator|->
name|getHeight
argument_list|()
operator|!=
name|height
condition|)
block|{
return|return
name|GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS
return|;
block|}
comment|// APPLE_framebuffer_multisample, which EXT_draw_buffers refers to, requires that
comment|// all color attachments have the same number of samples for the FBO to be complete.
if|if
condition|(
name|colorbuffer
operator|->
name|getSamples
argument_list|()
operator|!=
name|samples
condition|)
block|{
return|return
name|GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_EXT
return|;
block|}
comment|// in GLES 2.0, all color attachments attachments must have the same number of bitplanes
comment|// in GLES 3.0, there is no such restriction
if|if
condition|(
name|data
operator|.
name|clientVersion
operator|<
literal|3
condition|)
block|{
if|if
condition|(
name|formatInfo
operator|.
name|pixelBytes
operator|!=
name|colorbufferSize
condition|)
block|{
return|return
name|GL_FRAMEBUFFER_UNSUPPORTED
return|;
block|}
block|}
comment|// D3D11 does not allow for overlapping RenderTargetViews, so ensure uniqueness
for|for
control|(
name|unsigned
name|int
name|previousColorAttachment
init|=
literal|0
init|;
name|previousColorAttachment
operator|<
name|colorAttachment
condition|;
name|previousColorAttachment
operator|++
control|)
block|{
specifier|const
name|FramebufferAttachment
modifier|*
name|previousAttachment
init|=
name|mColorbuffers
index|[
name|previousColorAttachment
index|]
decl_stmt|;
if|if
condition|(
name|previousAttachment
operator|&&
operator|(
name|colorbuffer
operator|->
name|id
argument_list|()
operator|==
name|previousAttachment
operator|->
name|id
argument_list|()
operator|&&
name|colorbuffer
operator|->
name|type
argument_list|()
operator|==
name|previousAttachment
operator|->
name|type
argument_list|()
operator|)
condition|)
block|{
return|return
name|GL_FRAMEBUFFER_UNSUPPORTED
return|;
block|}
block|}
block|}
else|else
block|{
name|width
operator|=
name|colorbuffer
operator|->
name|getWidth
argument_list|()
expr_stmt|;
name|height
operator|=
name|colorbuffer
operator|->
name|getHeight
argument_list|()
expr_stmt|;
name|samples
operator|=
name|colorbuffer
operator|->
name|getSamples
argument_list|()
expr_stmt|;
name|colorbufferSize
operator|=
name|formatInfo
operator|.
name|pixelBytes
expr_stmt|;
name|missingAttachment
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|mDepthbuffer
condition|)
block|{
if|if
condition|(
name|mDepthbuffer
operator|->
name|getWidth
argument_list|()
operator|==
literal|0
operator|||
name|mDepthbuffer
operator|->
name|getHeight
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT
return|;
block|}
name|GLenum
name|internalformat
init|=
name|mDepthbuffer
operator|->
name|getInternalFormat
argument_list|()
decl_stmt|;
specifier|const
name|TextureCaps
modifier|&
name|formatCaps
init|=
name|data
operator|.
name|textureCaps
operator|->
name|get
argument_list|(
name|internalformat
argument_list|)
decl_stmt|;
specifier|const
name|InternalFormat
modifier|&
name|formatInfo
init|=
name|GetInternalFormatInfo
argument_list|(
name|internalformat
argument_list|)
decl_stmt|;
if|if
condition|(
name|mDepthbuffer
operator|->
name|isTexture
argument_list|()
condition|)
block|{
comment|// depth texture attachments require OES/ANGLE_depth_texture
if|if
condition|(
operator|!
name|data
operator|.
name|extensions
operator|->
name|depthTextures
condition|)
block|{
return|return
name|GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT
return|;
block|}
if|if
condition|(
operator|!
name|formatCaps
operator|.
name|renderable
condition|)
block|{
return|return
name|GL_FRAMEBUFFER_UNSUPPORTED
return|;
block|}
if|if
condition|(
name|formatInfo
operator|.
name|depthBits
operator|==
literal|0
condition|)
block|{
return|return
name|GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|formatCaps
operator|.
name|renderable
operator|||
name|formatInfo
operator|.
name|depthBits
operator|==
literal|0
condition|)
block|{
return|return
name|GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT
return|;
block|}
block|}
if|if
condition|(
name|missingAttachment
condition|)
block|{
name|width
operator|=
name|mDepthbuffer
operator|->
name|getWidth
argument_list|()
expr_stmt|;
name|height
operator|=
name|mDepthbuffer
operator|->
name|getHeight
argument_list|()
expr_stmt|;
name|samples
operator|=
name|mDepthbuffer
operator|->
name|getSamples
argument_list|()
expr_stmt|;
name|missingAttachment
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|width
operator|!=
name|mDepthbuffer
operator|->
name|getWidth
argument_list|()
operator|||
name|height
operator|!=
name|mDepthbuffer
operator|->
name|getHeight
argument_list|()
condition|)
block|{
return|return
name|GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS
return|;
block|}
elseif|else
if|if
condition|(
name|samples
operator|!=
name|mDepthbuffer
operator|->
name|getSamples
argument_list|()
condition|)
block|{
return|return
name|GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_ANGLE
return|;
block|}
block|}
if|if
condition|(
name|mStencilbuffer
condition|)
block|{
if|if
condition|(
name|mStencilbuffer
operator|->
name|getWidth
argument_list|()
operator|==
literal|0
operator|||
name|mStencilbuffer
operator|->
name|getHeight
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT
return|;
block|}
name|GLenum
name|internalformat
init|=
name|mStencilbuffer
operator|->
name|getInternalFormat
argument_list|()
decl_stmt|;
specifier|const
name|TextureCaps
modifier|&
name|formatCaps
init|=
name|data
operator|.
name|textureCaps
operator|->
name|get
argument_list|(
name|internalformat
argument_list|)
decl_stmt|;
specifier|const
name|InternalFormat
modifier|&
name|formatInfo
init|=
name|GetInternalFormatInfo
argument_list|(
name|internalformat
argument_list|)
decl_stmt|;
if|if
condition|(
name|mStencilbuffer
operator|->
name|isTexture
argument_list|()
condition|)
block|{
comment|// texture stencil attachments come along as part
comment|// of OES_packed_depth_stencil + OES/ANGLE_depth_texture
if|if
condition|(
operator|!
name|data
operator|.
name|extensions
operator|->
name|depthTextures
condition|)
block|{
return|return
name|GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT
return|;
block|}
if|if
condition|(
operator|!
name|formatCaps
operator|.
name|renderable
condition|)
block|{
return|return
name|GL_FRAMEBUFFER_UNSUPPORTED
return|;
block|}
if|if
condition|(
name|formatInfo
operator|.
name|stencilBits
operator|==
literal|0
condition|)
block|{
return|return
name|GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|formatCaps
operator|.
name|renderable
operator|||
name|formatInfo
operator|.
name|stencilBits
operator|==
literal|0
condition|)
block|{
return|return
name|GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT
return|;
block|}
block|}
if|if
condition|(
name|missingAttachment
condition|)
block|{
name|width
operator|=
name|mStencilbuffer
operator|->
name|getWidth
argument_list|()
expr_stmt|;
name|height
operator|=
name|mStencilbuffer
operator|->
name|getHeight
argument_list|()
expr_stmt|;
name|samples
operator|=
name|mStencilbuffer
operator|->
name|getSamples
argument_list|()
expr_stmt|;
name|missingAttachment
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|width
operator|!=
name|mStencilbuffer
operator|->
name|getWidth
argument_list|()
operator|||
name|height
operator|!=
name|mStencilbuffer
operator|->
name|getHeight
argument_list|()
condition|)
block|{
return|return
name|GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS
return|;
block|}
elseif|else
if|if
condition|(
name|samples
operator|!=
name|mStencilbuffer
operator|->
name|getSamples
argument_list|()
condition|)
block|{
return|return
name|GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_ANGLE
return|;
block|}
block|}
comment|// if we have both a depth and stencil buffer, they must refer to the same object
comment|// since we only support packed_depth_stencil and not separate depth and stencil
if|if
condition|(
name|mDepthbuffer
operator|&&
name|mStencilbuffer
operator|&&
operator|!
name|hasValidDepthStencil
argument_list|()
condition|)
block|{
return|return
name|GL_FRAMEBUFFER_UNSUPPORTED
return|;
block|}
comment|// we need to have at least one attachment to be complete
if|if
condition|(
name|missingAttachment
condition|)
block|{
return|return
name|GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT
return|;
block|}
return|return
name|GL_FRAMEBUFFER_COMPLETE
return|;
block|}
DECL|function|invalidate
name|Error
name|Framebuffer
operator|::
name|invalidate
parameter_list|(
specifier|const
name|Caps
modifier|&
name|caps
parameter_list|,
name|GLsizei
name|numAttachments
parameter_list|,
specifier|const
name|GLenum
modifier|*
name|attachments
parameter_list|)
block|{
name|GLuint
name|maxDimension
init|=
name|caps
operator|.
name|maxRenderbufferSize
decl_stmt|;
return|return
name|invalidateSub
argument_list|(
name|numAttachments
argument_list|,
name|attachments
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|maxDimension
argument_list|,
name|maxDimension
argument_list|)
return|;
block|}
DECL|function|invalidateSub
name|Error
name|Framebuffer
operator|::
name|invalidateSub
parameter_list|(
name|GLsizei
name|numAttachments
parameter_list|,
specifier|const
name|GLenum
modifier|*
name|attachments
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
for|for
control|(
name|GLsizei
name|attachIndex
init|=
literal|0
init|;
name|attachIndex
operator|<
name|numAttachments
condition|;
operator|++
name|attachIndex
control|)
block|{
name|GLenum
name|attachmentTarget
init|=
name|attachments
index|[
name|attachIndex
index|]
decl_stmt|;
name|FramebufferAttachment
modifier|*
name|attachment
init|=
operator|(
name|attachmentTarget
operator|==
name|GL_DEPTH_STENCIL_ATTACHMENT
operator|)
condition|?
name|getDepthOrStencilbuffer
argument_list|()
else|:
name|getAttachment
argument_list|(
name|attachmentTarget
argument_list|)
decl_stmt|;
if|if
condition|(
name|attachment
condition|)
block|{
name|rx
operator|::
name|RenderTarget
modifier|*
name|renderTarget
init|=
name|NULL
decl_stmt|;
name|Error
name|error
init|=
name|rx
operator|::
name|GetAttachmentRenderTarget
argument_list|(
name|attachment
argument_list|,
operator|&
name|renderTarget
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|renderTarget
operator|->
name|invalidate
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|DefaultFramebuffer
name|DefaultFramebuffer
operator|::
name|DefaultFramebuffer
parameter_list|(
name|rx
operator|::
name|RenderbufferImpl
modifier|*
name|colorbuffer
parameter_list|,
name|rx
operator|::
name|RenderbufferImpl
modifier|*
name|depthStencil
parameter_list|)
member_init_list|:
name|Framebuffer
argument_list|(
literal|0
argument_list|)
block|{
name|Renderbuffer
modifier|*
name|colorRenderbuffer
init|=
operator|new
name|Renderbuffer
argument_list|(
name|colorbuffer
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|mColorbuffers
index|[
literal|0
index|]
operator|=
operator|new
name|RenderbufferAttachment
argument_list|(
name|GL_BACK
argument_list|,
name|colorRenderbuffer
argument_list|)
expr_stmt|;
name|Renderbuffer
modifier|*
name|depthStencilBuffer
init|=
operator|new
name|Renderbuffer
argument_list|(
name|depthStencil
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|// Make a new attachment objects to ensure we do not double-delete
comment|// See angle issue 686
name|mDepthbuffer
operator|=
operator|(
name|depthStencilBuffer
operator|->
name|getDepthSize
argument_list|()
operator|!=
literal|0
condition|?
operator|new
name|RenderbufferAttachment
argument_list|(
name|GL_DEPTH_ATTACHMENT
argument_list|,
name|depthStencilBuffer
argument_list|)
else|:
name|NULL
operator|)
expr_stmt|;
name|mStencilbuffer
operator|=
operator|(
name|depthStencilBuffer
operator|->
name|getStencilSize
argument_list|()
operator|!=
literal|0
condition|?
operator|new
name|RenderbufferAttachment
argument_list|(
name|GL_STENCIL_ATTACHMENT
argument_list|,
name|depthStencilBuffer
argument_list|)
else|:
name|NULL
operator|)
expr_stmt|;
name|mDrawBufferStates
index|[
literal|0
index|]
operator|=
name|GL_BACK
expr_stmt|;
name|mReadBufferState
operator|=
name|GL_BACK
expr_stmt|;
block|}
DECL|function|getSamples
name|int
name|Framebuffer
operator|::
name|getSamples
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|completeness
argument_list|(
name|data
argument_list|)
operator|==
name|GL_FRAMEBUFFER_COMPLETE
condition|)
block|{
comment|// for a complete framebuffer, all attachments must have the same sample count
comment|// in this case return the first nonzero sample size
for|for
control|(
name|unsigned
name|int
name|colorAttachment
init|=
literal|0
init|;
name|colorAttachment
operator|<
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
condition|;
name|colorAttachment
operator|++
control|)
block|{
if|if
condition|(
name|mColorbuffers
index|[
name|colorAttachment
index|]
condition|)
block|{
return|return
name|mColorbuffers
index|[
name|colorAttachment
index|]
operator|->
name|getSamples
argument_list|()
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
DECL|function|hasValidDepthStencil
name|bool
name|Framebuffer
operator|::
name|hasValidDepthStencil
parameter_list|()
specifier|const
block|{
comment|// A valid depth-stencil attachment has the same resource bound to both the
comment|// depth and stencil attachment points.
return|return
operator|(
name|mDepthbuffer
operator|&&
name|mStencilbuffer
operator|&&
name|mDepthbuffer
operator|->
name|type
argument_list|()
operator|==
name|mStencilbuffer
operator|->
name|type
argument_list|()
operator|&&
name|mDepthbuffer
operator|->
name|id
argument_list|()
operator|==
name|mStencilbuffer
operator|->
name|id
argument_list|()
operator|)
return|;
block|}
DECL|function|getColorbuffersForRender
name|ColorbufferInfo
name|Framebuffer
operator|::
name|getColorbuffersForRender
parameter_list|(
specifier|const
name|rx
operator|::
name|Workarounds
modifier|&
name|workarounds
parameter_list|)
specifier|const
block|{
name|ColorbufferInfo
name|colorbuffersForRender
decl_stmt|;
for|for
control|(
name|size_t
name|colorAttachment
init|=
literal|0
init|;
name|colorAttachment
operator|<
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
condition|;
operator|++
name|colorAttachment
control|)
block|{
name|GLenum
name|drawBufferState
init|=
name|mDrawBufferStates
index|[
name|colorAttachment
index|]
decl_stmt|;
name|FramebufferAttachment
modifier|*
name|colorbuffer
init|=
name|mColorbuffers
index|[
name|colorAttachment
index|]
decl_stmt|;
if|if
condition|(
name|colorbuffer
operator|!=
name|NULL
operator|&&
name|drawBufferState
operator|!=
name|GL_NONE
condition|)
block|{
name|ASSERT
argument_list|(
name|drawBufferState
operator|==
name|GL_BACK
operator|||
name|drawBufferState
operator|==
operator|(
name|GL_COLOR_ATTACHMENT0_EXT
operator|+
name|colorAttachment
operator|)
argument_list|)
expr_stmt|;
name|colorbuffersForRender
operator|.
name|push_back
argument_list|(
name|colorbuffer
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|workarounds
operator|.
name|mrtPerfWorkaround
condition|)
block|{
name|colorbuffersForRender
operator|.
name|push_back
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|colorbuffersForRender
return|;
block|}
DECL|function|setTextureAttachment
name|void
name|Framebuffer
operator|::
name|setTextureAttachment
parameter_list|(
name|GLenum
name|attachment
parameter_list|,
name|Texture
modifier|*
name|texture
parameter_list|,
specifier|const
name|ImageIndex
modifier|&
name|imageIndex
parameter_list|)
block|{
name|setAttachment
argument_list|(
name|attachment
argument_list|,
operator|new
name|TextureAttachment
argument_list|(
name|attachment
argument_list|,
name|texture
argument_list|,
name|imageIndex
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|setRenderbufferAttachment
name|void
name|Framebuffer
operator|::
name|setRenderbufferAttachment
parameter_list|(
name|GLenum
name|attachment
parameter_list|,
name|Renderbuffer
modifier|*
name|renderbuffer
parameter_list|)
block|{
name|setAttachment
argument_list|(
name|attachment
argument_list|,
operator|new
name|RenderbufferAttachment
argument_list|(
name|attachment
argument_list|,
name|renderbuffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|setNULLAttachment
name|void
name|Framebuffer
operator|::
name|setNULLAttachment
parameter_list|(
name|GLenum
name|attachment
parameter_list|)
block|{
name|setAttachment
argument_list|(
name|attachment
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
DECL|function|setAttachment
name|void
name|Framebuffer
operator|::
name|setAttachment
parameter_list|(
name|GLenum
name|attachment
parameter_list|,
name|FramebufferAttachment
modifier|*
name|attachmentObj
parameter_list|)
block|{
if|if
condition|(
name|attachment
operator|>=
name|GL_COLOR_ATTACHMENT0
operator|&&
name|attachment
operator|<
operator|(
name|GL_COLOR_ATTACHMENT0
operator|+
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
operator|)
condition|)
block|{
name|size_t
name|colorAttachment
init|=
name|attachment
operator|-
name|GL_COLOR_ATTACHMENT0
decl_stmt|;
name|SafeDelete
argument_list|(
name|mColorbuffers
index|[
name|colorAttachment
index|]
argument_list|)
expr_stmt|;
name|mColorbuffers
index|[
name|colorAttachment
index|]
operator|=
name|attachmentObj
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|attachment
operator|==
name|GL_DEPTH_ATTACHMENT
condition|)
block|{
name|SafeDelete
argument_list|(
name|mDepthbuffer
argument_list|)
expr_stmt|;
name|mDepthbuffer
operator|=
name|attachmentObj
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|attachment
operator|==
name|GL_STENCIL_ATTACHMENT
condition|)
block|{
name|SafeDelete
argument_list|(
name|mStencilbuffer
argument_list|)
expr_stmt|;
name|mStencilbuffer
operator|=
name|attachmentObj
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|attachment
operator|==
name|GL_DEPTH_STENCIL_ATTACHMENT
condition|)
block|{
name|SafeDelete
argument_list|(
name|mDepthbuffer
argument_list|)
expr_stmt|;
name|SafeDelete
argument_list|(
name|mStencilbuffer
argument_list|)
expr_stmt|;
comment|// ensure this is a legitimate depth+stencil format
if|if
condition|(
name|attachmentObj
operator|&&
name|attachmentObj
operator|->
name|getDepthSize
argument_list|()
operator|>
literal|0
operator|&&
name|attachmentObj
operator|->
name|getStencilSize
argument_list|()
operator|>
literal|0
condition|)
block|{
name|mDepthbuffer
operator|=
name|attachmentObj
expr_stmt|;
comment|// Make a new attachment object to ensure we do not double-delete
comment|// See angle issue 686
if|if
condition|(
name|attachmentObj
operator|->
name|isTexture
argument_list|()
condition|)
block|{
name|mStencilbuffer
operator|=
operator|new
name|TextureAttachment
argument_list|(
name|GL_DEPTH_STENCIL_ATTACHMENT
argument_list|,
name|attachmentObj
operator|->
name|getTexture
argument_list|()
argument_list|,
operator|*
name|attachmentObj
operator|->
name|getTextureImageIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mStencilbuffer
operator|=
operator|new
name|RenderbufferAttachment
argument_list|(
name|GL_DEPTH_STENCIL_ATTACHMENT
argument_list|,
name|attachmentObj
operator|->
name|getRenderbuffer
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|completeness
name|GLenum
name|DefaultFramebuffer
operator|::
name|completeness
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
parameter_list|)
specifier|const
block|{
comment|// The default framebuffer *must* always be complete, though it may not be
comment|// subject to the same rules as application FBOs. ie, it could have 0x0 size.
return|return
name|GL_FRAMEBUFFER_COMPLETE
return|;
block|}
DECL|function|getAttachment
name|FramebufferAttachment
modifier|*
name|DefaultFramebuffer
operator|::
name|getAttachment
parameter_list|(
name|GLenum
name|attachment
parameter_list|)
specifier|const
block|{
switch|switch
condition|(
name|attachment
condition|)
block|{
case|case
name|GL_COLOR
case|:
case|case
name|GL_BACK
case|:
return|return
name|getColorbuffer
argument_list|(
literal|0
argument_list|)
return|;
case|case
name|GL_DEPTH
case|:
return|return
name|getDepthbuffer
argument_list|()
return|;
case|case
name|GL_STENCIL
case|:
return|return
name|getStencilbuffer
argument_list|()
return|;
case|case
name|GL_DEPTH_STENCIL
case|:
return|return
name|getDepthStencilBuffer
argument_list|()
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
block|}
end_namespace
end_unit
