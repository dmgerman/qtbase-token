begin_unit
begin_include
include|#
directive|include
file|"precompiled.h"
end_include
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2013 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// angletypes.h : Defines a variety of structures and enum types that are used throughout libGLESv2
end_comment
begin_include
include|#
directive|include
file|"libGLESv2/angletypes.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/ProgramBinary.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/VertexAttribute.h"
end_include
begin_namespace
DECL|namespace|gl
namespace|namespace
name|gl
block|{
DECL|function|SamplerState
name|SamplerState
operator|::
name|SamplerState
parameter_list|()
member_init_list|:
name|minFilter
argument_list|(
name|GL_NEAREST_MIPMAP_LINEAR
argument_list|)
member_init_list|,
name|magFilter
argument_list|(
name|GL_LINEAR
argument_list|)
member_init_list|,
name|wrapS
argument_list|(
name|GL_REPEAT
argument_list|)
member_init_list|,
name|wrapT
argument_list|(
name|GL_REPEAT
argument_list|)
member_init_list|,
name|wrapR
argument_list|(
name|GL_REPEAT
argument_list|)
member_init_list|,
name|maxAnisotropy
argument_list|(
literal|1.0f
argument_list|)
member_init_list|,
name|baseLevel
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|maxLevel
argument_list|(
literal|1000
argument_list|)
member_init_list|,
name|minLod
argument_list|(
operator|-
name|FLT_MAX
argument_list|)
member_init_list|,
name|maxLod
argument_list|(
name|FLT_MAX
argument_list|)
member_init_list|,
name|compareMode
argument_list|(
name|GL_NONE
argument_list|)
member_init_list|,
name|compareFunc
argument_list|(
name|GL_LEQUAL
argument_list|)
member_init_list|,
name|swizzleRed
argument_list|(
name|GL_RED
argument_list|)
member_init_list|,
name|swizzleGreen
argument_list|(
name|GL_GREEN
argument_list|)
member_init_list|,
name|swizzleBlue
argument_list|(
name|GL_BLUE
argument_list|)
member_init_list|,
name|swizzleAlpha
argument_list|(
name|GL_ALPHA
argument_list|)
block|{}
DECL|function|swizzleRequired
name|bool
name|SamplerState
operator|::
name|swizzleRequired
parameter_list|()
specifier|const
block|{
return|return
name|swizzleRed
operator|!=
name|GL_RED
operator|||
name|swizzleGreen
operator|!=
name|GL_GREEN
operator|||
name|swizzleBlue
operator|!=
name|GL_BLUE
operator|||
name|swizzleAlpha
operator|!=
name|GL_ALPHA
return|;
block|}
DECL|function|MinMax
specifier|static
name|void
name|MinMax
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|,
name|int
modifier|*
name|minimum
parameter_list|,
name|int
modifier|*
name|maximum
parameter_list|)
block|{
if|if
condition|(
name|a
operator|<
name|b
condition|)
block|{
operator|*
name|minimum
operator|=
name|a
expr_stmt|;
operator|*
name|maximum
operator|=
name|b
expr_stmt|;
block|}
else|else
block|{
operator|*
name|minimum
operator|=
name|b
expr_stmt|;
operator|*
name|maximum
operator|=
name|a
expr_stmt|;
block|}
block|}
DECL|function|ClipRectangle
name|bool
name|ClipRectangle
parameter_list|(
specifier|const
name|Rectangle
modifier|&
name|source
parameter_list|,
specifier|const
name|Rectangle
modifier|&
name|clip
parameter_list|,
name|Rectangle
modifier|*
name|intersection
parameter_list|)
block|{
name|int
name|minSourceX
decl_stmt|,
name|maxSourceX
decl_stmt|,
name|minSourceY
decl_stmt|,
name|maxSourceY
decl_stmt|;
name|MinMax
argument_list|(
name|source
operator|.
name|x
argument_list|,
name|source
operator|.
name|x
operator|+
name|source
operator|.
name|width
argument_list|,
operator|&
name|minSourceX
argument_list|,
operator|&
name|maxSourceX
argument_list|)
expr_stmt|;
name|MinMax
argument_list|(
name|source
operator|.
name|y
argument_list|,
name|source
operator|.
name|y
operator|+
name|source
operator|.
name|height
argument_list|,
operator|&
name|minSourceY
argument_list|,
operator|&
name|maxSourceY
argument_list|)
expr_stmt|;
name|int
name|minClipX
decl_stmt|,
name|maxClipX
decl_stmt|,
name|minClipY
decl_stmt|,
name|maxClipY
decl_stmt|;
name|MinMax
argument_list|(
name|clip
operator|.
name|x
argument_list|,
name|clip
operator|.
name|x
operator|+
name|clip
operator|.
name|width
argument_list|,
operator|&
name|minClipX
argument_list|,
operator|&
name|maxClipX
argument_list|)
expr_stmt|;
name|MinMax
argument_list|(
name|clip
operator|.
name|y
argument_list|,
name|clip
operator|.
name|y
operator|+
name|clip
operator|.
name|height
argument_list|,
operator|&
name|minClipY
argument_list|,
operator|&
name|maxClipY
argument_list|)
expr_stmt|;
if|if
condition|(
name|minSourceX
operator|>=
name|maxClipX
operator|||
name|maxSourceX
operator|<=
name|minClipX
operator|||
name|minSourceY
operator|>=
name|maxClipY
operator|||
name|maxSourceY
operator|<=
name|minClipY
condition|)
block|{
if|if
condition|(
name|intersection
condition|)
block|{
name|intersection
operator|->
name|x
operator|=
name|minSourceX
expr_stmt|;
name|intersection
operator|->
name|y
operator|=
name|maxSourceY
expr_stmt|;
name|intersection
operator|->
name|width
operator|=
name|maxSourceX
operator|-
name|minSourceX
expr_stmt|;
name|intersection
operator|->
name|height
operator|=
name|maxSourceY
operator|-
name|minSourceY
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
else|else
block|{
if|if
condition|(
name|intersection
condition|)
block|{
name|intersection
operator|->
name|x
operator|=
name|std
operator|::
name|max
argument_list|(
name|minSourceX
argument_list|,
name|minClipX
argument_list|)
expr_stmt|;
name|intersection
operator|->
name|y
operator|=
name|std
operator|::
name|max
argument_list|(
name|minSourceY
argument_list|,
name|minClipY
argument_list|)
expr_stmt|;
name|intersection
operator|->
name|width
operator|=
name|std
operator|::
name|min
argument_list|(
name|maxSourceX
argument_list|,
name|maxClipX
argument_list|)
operator|-
name|std
operator|::
name|max
argument_list|(
name|minSourceX
argument_list|,
name|minClipX
argument_list|)
expr_stmt|;
name|intersection
operator|->
name|height
operator|=
name|std
operator|::
name|min
argument_list|(
name|maxSourceY
argument_list|,
name|maxClipY
argument_list|)
operator|-
name|std
operator|::
name|max
argument_list|(
name|minSourceY
argument_list|,
name|minClipY
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
DECL|function|VertexFormat
name|VertexFormat
operator|::
name|VertexFormat
parameter_list|()
member_init_list|:
name|mType
argument_list|(
name|GL_NONE
argument_list|)
member_init_list|,
name|mNormalized
argument_list|(
name|GL_FALSE
argument_list|)
member_init_list|,
name|mComponents
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mPureInteger
argument_list|(
literal|false
argument_list|)
block|{}
DECL|function|VertexFormat
name|VertexFormat
operator|::
name|VertexFormat
parameter_list|(
name|GLenum
name|type
parameter_list|,
name|GLboolean
name|normalized
parameter_list|,
name|GLuint
name|components
parameter_list|,
name|bool
name|pureInteger
parameter_list|)
member_init_list|:
name|mType
argument_list|(
name|type
argument_list|)
member_init_list|,
name|mNormalized
argument_list|(
name|normalized
argument_list|)
member_init_list|,
name|mComponents
argument_list|(
name|components
argument_list|)
member_init_list|,
name|mPureInteger
argument_list|(
name|pureInteger
argument_list|)
block|{
comment|// Float data can not be normalized, so ignore the user setting
if|if
condition|(
name|mType
operator|==
name|GL_FLOAT
operator|||
name|mType
operator|==
name|GL_HALF_FLOAT
operator|||
name|mType
operator|==
name|GL_FIXED
condition|)
block|{
name|mNormalized
operator|=
name|GL_FALSE
expr_stmt|;
block|}
block|}
DECL|function|VertexFormat
name|VertexFormat
operator|::
name|VertexFormat
parameter_list|(
specifier|const
name|VertexAttribute
modifier|&
name|attrib
parameter_list|)
member_init_list|:
name|mType
argument_list|(
name|attrib
operator|.
name|type
argument_list|)
member_init_list|,
name|mNormalized
argument_list|(
name|attrib
operator|.
name|normalized
condition|?
name|GL_TRUE
else|:
name|GL_FALSE
argument_list|)
member_init_list|,
name|mComponents
argument_list|(
name|attrib
operator|.
name|size
argument_list|)
member_init_list|,
name|mPureInteger
argument_list|(
name|attrib
operator|.
name|pureInteger
argument_list|)
block|{
comment|// Ensure we aren't initializing a vertex format which should be using
comment|// the current-value type
name|ASSERT
argument_list|(
name|attrib
operator|.
name|enabled
argument_list|)
expr_stmt|;
comment|// Float data can not be normalized, so ignore the user setting
if|if
condition|(
name|mType
operator|==
name|GL_FLOAT
operator|||
name|mType
operator|==
name|GL_HALF_FLOAT
operator|||
name|mType
operator|==
name|GL_FIXED
condition|)
block|{
name|mNormalized
operator|=
name|GL_FALSE
expr_stmt|;
block|}
block|}
DECL|function|VertexFormat
name|VertexFormat
operator|::
name|VertexFormat
parameter_list|(
specifier|const
name|VertexAttribute
modifier|&
name|attrib
parameter_list|,
name|GLenum
name|currentValueType
parameter_list|)
member_init_list|:
name|mType
argument_list|(
name|attrib
operator|.
name|type
argument_list|)
member_init_list|,
name|mNormalized
argument_list|(
name|attrib
operator|.
name|normalized
condition|?
name|GL_TRUE
else|:
name|GL_FALSE
argument_list|)
member_init_list|,
name|mComponents
argument_list|(
name|attrib
operator|.
name|size
argument_list|)
member_init_list|,
name|mPureInteger
argument_list|(
name|attrib
operator|.
name|pureInteger
argument_list|)
block|{
if|if
condition|(
operator|!
name|attrib
operator|.
name|enabled
condition|)
block|{
name|mType
operator|=
name|currentValueType
expr_stmt|;
name|mNormalized
operator|=
name|GL_FALSE
expr_stmt|;
name|mComponents
operator|=
literal|4
expr_stmt|;
name|mPureInteger
operator|=
operator|(
name|currentValueType
operator|!=
name|GL_FLOAT
operator|)
expr_stmt|;
block|}
comment|// Float data can not be normalized, so ignore the user setting
if|if
condition|(
name|mType
operator|==
name|GL_FLOAT
operator|||
name|mType
operator|==
name|GL_HALF_FLOAT
operator|||
name|mType
operator|==
name|GL_FIXED
condition|)
block|{
name|mNormalized
operator|=
name|GL_FALSE
expr_stmt|;
block|}
block|}
DECL|function|GetInputLayout
name|void
name|VertexFormat
operator|::
name|GetInputLayout
parameter_list|(
name|VertexFormat
modifier|*
name|inputLayout
parameter_list|,
name|ProgramBinary
modifier|*
name|programBinary
parameter_list|,
specifier|const
name|VertexAttribute
modifier|*
name|attributes
parameter_list|,
specifier|const
name|gl
operator|::
name|VertexAttribCurrentValueData
modifier|*
name|currentValues
parameter_list|)
block|{
for|for
control|(
name|unsigned
name|int
name|attributeIndex
init|=
literal|0
init|;
name|attributeIndex
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|attributeIndex
operator|++
control|)
block|{
name|int
name|semanticIndex
init|=
name|programBinary
operator|->
name|getSemanticIndex
argument_list|(
name|attributeIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|semanticIndex
operator|!=
operator|-
literal|1
condition|)
block|{
name|inputLayout
index|[
name|semanticIndex
index|]
operator|=
name|VertexFormat
argument_list|(
name|attributes
index|[
name|attributeIndex
index|]
argument_list|,
name|currentValues
index|[
name|attributeIndex
index|]
operator|.
name|Type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|operator ==
name|bool
name|VertexFormat
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|VertexFormat
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|mType
operator|==
name|other
operator|.
name|mType
operator|&&
name|mComponents
operator|==
name|other
operator|.
name|mComponents
operator|&&
name|mNormalized
operator|==
name|other
operator|.
name|mNormalized
operator|&&
name|mPureInteger
operator|==
name|other
operator|.
name|mPureInteger
operator|)
return|;
block|}
DECL|function|operator !=
name|bool
name|VertexFormat
operator|::
name|operator
name|!=
parameter_list|(
specifier|const
name|VertexFormat
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|other
operator|)
return|;
block|}
DECL|function|operator <
name|bool
name|VertexFormat
operator|::
name|operator
name|<
parameter_list|(
specifier|const
name|VertexFormat
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|mType
operator|!=
name|other
operator|.
name|mType
condition|)
block|{
return|return
name|mType
operator|<
name|other
operator|.
name|mType
return|;
block|}
if|if
condition|(
name|mNormalized
operator|!=
name|other
operator|.
name|mNormalized
condition|)
block|{
return|return
name|mNormalized
operator|<
name|other
operator|.
name|mNormalized
return|;
block|}
if|if
condition|(
name|mComponents
operator|!=
name|other
operator|.
name|mComponents
condition|)
block|{
return|return
name|mComponents
operator|<
name|other
operator|.
name|mComponents
return|;
block|}
return|return
name|mPureInteger
operator|<
name|other
operator|.
name|mPureInteger
return|;
block|}
block|}
end_namespace
end_unit
