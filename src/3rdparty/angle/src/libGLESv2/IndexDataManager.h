begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2012 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// IndexDataManager.h: Defines the IndexDataManager, a class that
end_comment
begin_comment
comment|// runs the Buffer translation process for index buffers.
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|LIBGLESV2_INDEXDATAMANAGER_H_
end_ifndef
begin_define
DECL|macro|LIBGLESV2_INDEXDATAMANAGER_H_
define|#
directive|define
name|LIBGLESV2_INDEXDATAMANAGER_H_
end_define
begin_include
include|#
directive|include
file|<vector>
end_include
begin_include
include|#
directive|include
file|<cstddef>
end_include
begin_define
DECL|macro|GL_APICALL
define|#
directive|define
name|GL_APICALL
end_define
begin_include
include|#
directive|include
file|<GLES2/gl2.h>
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Context.h"
end_include
begin_macro
name|namespace
end_macro
begin_block
block|{
enum|enum
block|{
name|INITIAL_INDEX_BUFFER_SIZE
init|=
literal|4096
operator|*
expr|sizeof
operator|(
name|GLuint
operator|)
block|}
enum|;
block|}
end_block
begin_decl_stmt
name|namespace
name|gl
block|{
struct|struct
name|TranslatedIndexData
block|{
name|UINT
name|minIndex
decl_stmt|;
name|UINT
name|maxIndex
decl_stmt|;
name|UINT
name|startIndex
decl_stmt|;
name|IDirect3DIndexBuffer9
modifier|*
name|indexBuffer
decl_stmt|;
name|unsigned
name|int
name|serial
decl_stmt|;
block|}
struct|;
name|class
name|IndexBuffer
block|{
name|public
label|:
name|IndexBuffer
argument_list|(
argument|IDirect3DDevice9 *device
argument_list|,
argument|UINT size
argument_list|,
argument|D3DFORMAT format
argument_list|)
empty_stmt|;
name|virtual
operator|~
name|IndexBuffer
argument_list|()
expr_stmt|;
name|UINT
name|size
argument_list|()
specifier|const
block|{
return|return
name|mBufferSize
return|;
block|}
name|virtual
name|void
modifier|*
name|map
parameter_list|(
name|UINT
name|requiredSpace
parameter_list|,
name|UINT
modifier|*
name|offset
parameter_list|)
init|=
literal|0
function_decl|;
name|void
name|unmap
parameter_list|()
function_decl|;
name|virtual
name|void
name|reserveSpace
parameter_list|(
name|UINT
name|requiredSpace
parameter_list|,
name|GLenum
name|type
parameter_list|)
init|=
literal|0
function_decl|;
name|IDirect3DIndexBuffer9
operator|*
name|getBuffer
argument_list|()
specifier|const
expr_stmt|;
name|unsigned
name|int
name|getSerial
argument_list|()
specifier|const
expr_stmt|;
name|protected
label|:
name|IDirect3DDevice9
modifier|*
specifier|const
name|mDevice
decl_stmt|;
name|IDirect3DIndexBuffer9
modifier|*
name|mIndexBuffer
decl_stmt|;
name|UINT
name|mBufferSize
decl_stmt|;
name|unsigned
name|int
name|mSerial
decl_stmt|;
specifier|static
name|unsigned
name|int
name|issueSerial
parameter_list|()
function_decl|;
specifier|static
name|unsigned
name|int
name|mCurrentSerial
decl_stmt|;
name|private
label|:
name|DISALLOW_COPY_AND_ASSIGN
argument_list|(
name|IndexBuffer
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|class
name|StreamingIndexBuffer
range|:
name|public
name|IndexBuffer
block|{
name|public
operator|:
name|StreamingIndexBuffer
argument_list|(
argument|IDirect3DDevice9 *device
argument_list|,
argument|UINT initialSize
argument_list|,
argument|D3DFORMAT format
argument_list|)
block|;
operator|~
name|StreamingIndexBuffer
argument_list|()
block|;
name|virtual
name|void
operator|*
name|map
argument_list|(
argument|UINT requiredSpace
argument_list|,
argument|UINT *offset
argument_list|)
block|;
name|virtual
name|void
name|reserveSpace
argument_list|(
argument|UINT requiredSpace
argument_list|,
argument|GLenum type
argument_list|)
block|;
name|private
operator|:
name|UINT
name|mWritePosition
block|; }
decl_stmt|;
name|class
name|StaticIndexBuffer
range|:
name|public
name|IndexBuffer
block|{
name|public
operator|:
name|explicit
name|StaticIndexBuffer
argument_list|(
name|IDirect3DDevice9
operator|*
name|device
argument_list|)
block|;
operator|~
name|StaticIndexBuffer
argument_list|()
block|;
name|virtual
name|void
operator|*
name|map
argument_list|(
argument|UINT requiredSpace
argument_list|,
argument|UINT *offset
argument_list|)
block|;
name|virtual
name|void
name|reserveSpace
argument_list|(
argument|UINT requiredSpace
argument_list|,
argument|GLenum type
argument_list|)
block|;
name|bool
name|lookupType
argument_list|(
argument|GLenum type
argument_list|)
block|;
name|UINT
name|lookupRange
argument_list|(
argument|intptr_t offset
argument_list|,
argument|GLsizei count
argument_list|,
argument|UINT *minIndex
argument_list|,
argument|UINT *maxIndex
argument_list|)
block|;
comment|// Returns the offset into the index buffer, or -1 if not found
name|void
name|addRange
argument_list|(
argument|intptr_t offset
argument_list|,
argument|GLsizei count
argument_list|,
argument|UINT minIndex
argument_list|,
argument|UINT maxIndex
argument_list|,
argument|UINT streamOffset
argument_list|)
block|;
name|private
operator|:
name|GLenum
name|mCacheType
block|;          struct
name|IndexRange
block|{
name|intptr_t
name|offset
block|;
name|GLsizei
name|count
block|;
name|bool
name|operator
operator|<
operator|(
specifier|const
name|IndexRange
operator|&
name|rhs
operator|)
specifier|const
block|{
if|if
condition|(
name|offset
operator|!=
name|rhs
operator|.
name|offset
condition|)
block|{
return|return
name|offset
operator|<
name|rhs
operator|.
name|offset
return|;
block|}
if|if
condition|(
name|count
operator|!=
name|rhs
operator|.
name|count
condition|)
block|{
return|return
name|count
operator|<
name|rhs
operator|.
name|count
return|;
block|}
return|return
name|false
return|;
block|}
expr|}
block|;      struct
name|IndexResult
block|{
name|UINT
name|minIndex
block|;
name|UINT
name|maxIndex
block|;
name|UINT
name|streamOffset
block|;     }
block|;
name|std
operator|::
name|map
operator|<
name|IndexRange
block|,
name|IndexResult
operator|>
name|mCache
block|; }
block|;
name|class
name|IndexDataManager
block|{
name|public
operator|:
name|IndexDataManager
argument_list|(
name|Context
operator|*
name|context
argument_list|,
name|IDirect3DDevice9
operator|*
name|evice
argument_list|)
block|;
name|virtual
operator|~
name|IndexDataManager
argument_list|()
block|;
name|GLenum
name|prepareIndexData
argument_list|(
argument|GLenum type
argument_list|,
argument|GLsizei count
argument_list|,
argument|Buffer *arrayElementBuffer
argument_list|,
argument|const GLvoid *indices
argument_list|,
argument|TranslatedIndexData *translated
argument_list|)
block|;
name|StaticIndexBuffer
operator|*
name|getCountingIndices
argument_list|(
argument|GLsizei count
argument_list|)
block|;
name|private
operator|:
name|DISALLOW_COPY_AND_ASSIGN
argument_list|(
name|IndexDataManager
argument_list|)
block|;
name|std
operator|::
name|size_t
name|typeSize
argument_list|(
argument|GLenum type
argument_list|)
specifier|const
block|;
name|std
operator|::
name|size_t
name|indexSize
argument_list|(
argument|D3DFORMAT format
argument_list|)
specifier|const
block|;
name|IDirect3DDevice9
operator|*
specifier|const
name|mDevice
block|;
name|StreamingIndexBuffer
operator|*
name|mStreamingBufferShort
block|;
name|StreamingIndexBuffer
operator|*
name|mStreamingBufferInt
block|;
name|StaticIndexBuffer
operator|*
name|mCountingBuffer
block|; }
block|;  }
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// LIBGLESV2_INDEXDATAMANAGER_H_
end_comment
end_unit
