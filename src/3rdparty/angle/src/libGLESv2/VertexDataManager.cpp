begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2012 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// VertexDataManager.h: Defines the VertexDataManager, a class that
end_comment
begin_comment
comment|// runs the Buffer translation process.
end_comment
begin_include
include|#
directive|include
file|"libGLESv2/VertexDataManager.h"
end_include
begin_include
include|#
directive|include
file|"common/debug.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Buffer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Program.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/ProgramBinary.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/main.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/vertexconversion.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/IndexDataManager.h"
end_include
begin_namespace
namespace|namespace
block|{
DECL|enumerator|INITIAL_STREAM_BUFFER_SIZE
enum|enum
block|{
name|INITIAL_STREAM_BUFFER_SIZE
init|=
literal|1024
operator|*
literal|1024
block|}
enum|;
comment|// This has to be at least 4k or else it fails on ATI cards.
DECL|enumerator|CONSTANT_VERTEX_BUFFER_SIZE
enum|enum
block|{
name|CONSTANT_VERTEX_BUFFER_SIZE
init|=
literal|4096
block|}
enum|;
block|}
end_namespace
begin_namespace
DECL|namespace|gl
namespace|namespace
name|gl
block|{
DECL|member|mCurrentSerial
name|unsigned
name|int
name|VertexBuffer
operator|::
name|mCurrentSerial
init|=
literal|1
decl_stmt|;
DECL|function|elementsInBuffer
name|int
name|elementsInBuffer
parameter_list|(
specifier|const
name|VertexAttribute
modifier|&
name|attribute
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|stride
init|=
name|attribute
operator|.
name|stride
argument_list|()
decl_stmt|;
return|return
operator|(
name|size
operator|-
name|attribute
operator|.
name|mOffset
operator|%
name|stride
operator|+
operator|(
name|stride
operator|-
name|attribute
operator|.
name|typeSize
argument_list|()
operator|)
operator|)
operator|/
name|stride
return|;
block|}
DECL|function|VertexDataManager
name|VertexDataManager
operator|::
name|VertexDataManager
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|IDirect3DDevice9
modifier|*
name|device
parameter_list|)
member_init_list|:
name|mContext
argument_list|(
name|context
argument_list|)
member_init_list|,
name|mDevice
argument_list|(
name|device
argument_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|i
operator|++
control|)
block|{
name|mDirtyCurrentValue
index|[
name|i
index|]
operator|=
literal|true
expr_stmt|;
name|mCurrentValueBuffer
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|mCurrentValueOffsets
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
specifier|const
name|D3DCAPS9
modifier|&
name|caps
init|=
name|context
operator|->
name|getDeviceCaps
argument_list|()
decl_stmt|;
name|checkVertexCaps
argument_list|(
name|caps
operator|.
name|DeclTypes
argument_list|)
expr_stmt|;
name|mStreamingBuffer
operator|=
operator|new
name|StreamingVertexBuffer
argument_list|(
name|mDevice
argument_list|,
name|INITIAL_STREAM_BUFFER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mStreamingBuffer
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to allocate the streaming vertex buffer."
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|~VertexDataManager
name|VertexDataManager
operator|::
name|~
name|VertexDataManager
parameter_list|()
block|{
operator|delete
name|mStreamingBuffer
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|i
operator|++
control|)
block|{
operator|delete
name|mCurrentValueBuffer
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
DECL|function|writeAttributeData
name|std
operator|::
name|size_t
name|VertexDataManager
operator|::
name|writeAttributeData
parameter_list|(
name|ArrayVertexBuffer
modifier|*
name|vertexBuffer
parameter_list|,
name|GLint
name|start
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|VertexAttribute
modifier|&
name|attribute
parameter_list|,
name|GLsizei
name|instances
parameter_list|)
block|{
name|Buffer
modifier|*
name|buffer
init|=
name|attribute
operator|.
name|mBoundBuffer
operator|.
name|get
argument_list|()
decl_stmt|;
name|int
name|inputStride
init|=
name|attribute
operator|.
name|stride
argument_list|()
decl_stmt|;
name|int
name|elementSize
init|=
name|attribute
operator|.
name|typeSize
argument_list|()
decl_stmt|;
specifier|const
name|FormatConverter
modifier|&
name|converter
init|=
name|formatConverter
argument_list|(
name|attribute
argument_list|)
decl_stmt|;
name|std
operator|::
name|size_t
name|streamOffset
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|output
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|vertexBuffer
condition|)
block|{
name|output
operator|=
name|vertexBuffer
operator|->
name|map
argument_list|(
name|attribute
argument_list|,
name|spaceRequired
argument_list|(
name|attribute
argument_list|,
name|count
argument_list|,
name|instances
argument_list|)
argument_list|,
operator|&
name|streamOffset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|output
operator|==
name|NULL
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to map vertex buffer."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
specifier|const
name|char
modifier|*
name|input
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|buffer
condition|)
block|{
name|int
name|offset
init|=
name|attribute
operator|.
name|mOffset
decl_stmt|;
name|input
operator|=
cast|static_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|buffer
operator|->
name|data
argument_list|()
argument_list|)
operator|+
name|offset
expr_stmt|;
block|}
else|else
block|{
name|input
operator|=
cast|static_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|attribute
operator|.
name|mPointer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|instances
operator|==
literal|0
operator|||
name|attribute
operator|.
name|mDivisor
operator|==
literal|0
condition|)
block|{
name|input
operator|+=
name|inputStride
operator|*
name|start
expr_stmt|;
block|}
if|if
condition|(
name|converter
operator|.
name|identity
operator|&&
name|inputStride
operator|==
name|elementSize
condition|)
block|{
name|memcpy
argument_list|(
name|output
argument_list|,
name|input
argument_list|,
name|count
operator|*
name|inputStride
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|converter
operator|.
name|convertArray
argument_list|(
name|input
argument_list|,
name|inputStride
argument_list|,
name|count
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
name|vertexBuffer
operator|->
name|unmap
argument_list|()
expr_stmt|;
return|return
name|streamOffset
return|;
block|}
DECL|function|prepareVertexData
name|GLenum
name|VertexDataManager
operator|::
name|prepareVertexData
parameter_list|(
name|GLint
name|start
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|TranslatedAttribute
modifier|*
name|translated
parameter_list|,
name|GLsizei
name|instances
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mStreamingBuffer
condition|)
block|{
return|return
name|GL_OUT_OF_MEMORY
return|;
block|}
specifier|const
name|VertexAttributeArray
modifier|&
name|attribs
init|=
name|mContext
operator|->
name|getVertexAttributes
argument_list|()
decl_stmt|;
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|mContext
operator|->
name|getCurrentProgramBinary
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|attributeIndex
init|=
literal|0
init|;
name|attributeIndex
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|attributeIndex
operator|++
control|)
block|{
name|translated
index|[
name|attributeIndex
index|]
operator|.
name|active
operator|=
operator|(
name|programBinary
operator|->
name|getSemanticIndex
argument_list|(
name|attributeIndex
argument_list|)
operator|!=
operator|-
literal|1
operator|)
expr_stmt|;
block|}
comment|// Determine the required storage size per used buffer, and invalidate static buffers that don't contain matching attributes
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|translated
index|[
name|i
index|]
operator|.
name|active
operator|&&
name|attribs
index|[
name|i
index|]
operator|.
name|mArrayEnabled
condition|)
block|{
name|Buffer
modifier|*
name|buffer
init|=
name|attribs
index|[
name|i
index|]
operator|.
name|mBoundBuffer
operator|.
name|get
argument_list|()
decl_stmt|;
name|StaticVertexBuffer
modifier|*
name|staticBuffer
init|=
name|buffer
condition|?
name|buffer
operator|->
name|getStaticVertexBuffer
argument_list|()
else|:
name|NULL
decl_stmt|;
if|if
condition|(
name|staticBuffer
condition|)
block|{
if|if
condition|(
name|staticBuffer
operator|->
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|int
name|totalCount
init|=
name|elementsInBuffer
argument_list|(
name|attribs
index|[
name|i
index|]
argument_list|,
name|buffer
operator|->
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|staticBuffer
operator|->
name|addRequiredSpace
argument_list|(
name|spaceRequired
argument_list|(
name|attribs
index|[
name|i
index|]
argument_list|,
name|totalCount
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|staticBuffer
operator|->
name|lookupAttribute
argument_list|(
name|attribs
index|[
name|i
index|]
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|// This static buffer doesn't have matching attributes, so fall back to using the streaming buffer
comment|// Add the space of all previous attributes belonging to the invalidated static buffer to the streaming buffer
for|for
control|(
name|int
name|previous
init|=
literal|0
init|;
name|previous
operator|<
name|i
condition|;
name|previous
operator|++
control|)
block|{
if|if
condition|(
name|translated
index|[
name|previous
index|]
operator|.
name|active
operator|&&
name|attribs
index|[
name|previous
index|]
operator|.
name|mArrayEnabled
condition|)
block|{
name|Buffer
modifier|*
name|previousBuffer
init|=
name|attribs
index|[
name|previous
index|]
operator|.
name|mBoundBuffer
operator|.
name|get
argument_list|()
decl_stmt|;
name|StaticVertexBuffer
modifier|*
name|previousStaticBuffer
init|=
name|previousBuffer
condition|?
name|previousBuffer
operator|->
name|getStaticVertexBuffer
argument_list|()
else|:
name|NULL
decl_stmt|;
if|if
condition|(
name|staticBuffer
operator|==
name|previousStaticBuffer
condition|)
block|{
name|mStreamingBuffer
operator|->
name|addRequiredSpace
argument_list|(
name|spaceRequired
argument_list|(
name|attribs
index|[
name|previous
index|]
argument_list|,
name|count
argument_list|,
name|instances
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|mStreamingBuffer
operator|->
name|addRequiredSpace
argument_list|(
name|spaceRequired
argument_list|(
name|attribs
index|[
name|i
index|]
argument_list|,
name|count
argument_list|,
name|instances
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|invalidateStaticData
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|mStreamingBuffer
operator|->
name|addRequiredSpace
argument_list|(
name|spaceRequired
argument_list|(
name|attribs
index|[
name|i
index|]
argument_list|,
name|count
argument_list|,
name|instances
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Reserve the required space per used buffer
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|translated
index|[
name|i
index|]
operator|.
name|active
operator|&&
name|attribs
index|[
name|i
index|]
operator|.
name|mArrayEnabled
condition|)
block|{
name|Buffer
modifier|*
name|buffer
init|=
name|attribs
index|[
name|i
index|]
operator|.
name|mBoundBuffer
operator|.
name|get
argument_list|()
decl_stmt|;
name|ArrayVertexBuffer
modifier|*
name|staticBuffer
init|=
name|buffer
condition|?
name|buffer
operator|->
name|getStaticVertexBuffer
argument_list|()
else|:
name|NULL
decl_stmt|;
name|ArrayVertexBuffer
modifier|*
name|vertexBuffer
init|=
name|staticBuffer
condition|?
name|staticBuffer
else|:
name|mStreamingBuffer
decl_stmt|;
if|if
condition|(
name|vertexBuffer
condition|)
block|{
name|vertexBuffer
operator|->
name|reserveRequiredSpace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// Perform the vertex data translations
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|translated
index|[
name|i
index|]
operator|.
name|active
condition|)
block|{
if|if
condition|(
name|attribs
index|[
name|i
index|]
operator|.
name|mArrayEnabled
condition|)
block|{
name|Buffer
modifier|*
name|buffer
init|=
name|attribs
index|[
name|i
index|]
operator|.
name|mBoundBuffer
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|buffer
operator|&&
name|attribs
index|[
name|i
index|]
operator|.
name|mPointer
operator|==
name|NULL
condition|)
block|{
comment|// This is an application error that would normally result in a crash, but we catch it and return an error
name|ERR
argument_list|(
literal|"An enabled vertex array has no buffer and no pointer."
argument_list|)
expr_stmt|;
return|return
name|GL_INVALID_OPERATION
return|;
block|}
specifier|const
name|FormatConverter
modifier|&
name|converter
init|=
name|formatConverter
argument_list|(
name|attribs
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|StaticVertexBuffer
modifier|*
name|staticBuffer
init|=
name|buffer
condition|?
name|buffer
operator|->
name|getStaticVertexBuffer
argument_list|()
else|:
name|NULL
decl_stmt|;
name|ArrayVertexBuffer
modifier|*
name|vertexBuffer
init|=
name|staticBuffer
condition|?
name|staticBuffer
else|:
cast|static_cast
argument_list|<
name|ArrayVertexBuffer
operator|*
argument_list|>
argument_list|(
name|mStreamingBuffer
argument_list|)
decl_stmt|;
name|std
operator|::
name|size_t
name|streamOffset
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|staticBuffer
condition|)
block|{
name|streamOffset
operator|=
name|staticBuffer
operator|->
name|lookupAttribute
argument_list|(
name|attribs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|streamOffset
operator|==
operator|-
literal|1
condition|)
block|{
comment|// Convert the entire buffer
name|int
name|totalCount
init|=
name|elementsInBuffer
argument_list|(
name|attribs
index|[
name|i
index|]
argument_list|,
name|buffer
operator|->
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|startIndex
init|=
name|attribs
index|[
name|i
index|]
operator|.
name|mOffset
operator|/
name|attribs
index|[
name|i
index|]
operator|.
name|stride
argument_list|()
decl_stmt|;
name|streamOffset
operator|=
name|writeAttributeData
argument_list|(
name|staticBuffer
argument_list|,
operator|-
name|startIndex
argument_list|,
name|totalCount
argument_list|,
name|attribs
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|streamOffset
operator|!=
operator|-
literal|1
condition|)
block|{
name|streamOffset
operator|+=
operator|(
name|attribs
index|[
name|i
index|]
operator|.
name|mOffset
operator|/
name|attribs
index|[
name|i
index|]
operator|.
name|stride
argument_list|()
operator|)
operator|*
name|converter
operator|.
name|outputElementSize
expr_stmt|;
if|if
condition|(
name|instances
operator|==
literal|0
operator|||
name|attribs
index|[
name|i
index|]
operator|.
name|mDivisor
operator|==
literal|0
condition|)
block|{
name|streamOffset
operator|+=
name|start
operator|*
name|converter
operator|.
name|outputElementSize
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|streamOffset
operator|=
name|writeAttributeData
argument_list|(
name|mStreamingBuffer
argument_list|,
name|start
argument_list|,
name|count
argument_list|,
name|attribs
index|[
name|i
index|]
argument_list|,
name|instances
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|streamOffset
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|GL_OUT_OF_MEMORY
return|;
block|}
name|translated
index|[
name|i
index|]
operator|.
name|vertexBuffer
operator|=
name|vertexBuffer
operator|->
name|getBuffer
argument_list|()
expr_stmt|;
name|translated
index|[
name|i
index|]
operator|.
name|serial
operator|=
name|vertexBuffer
operator|->
name|getSerial
argument_list|()
expr_stmt|;
name|translated
index|[
name|i
index|]
operator|.
name|divisor
operator|=
name|attribs
index|[
name|i
index|]
operator|.
name|mDivisor
expr_stmt|;
name|translated
index|[
name|i
index|]
operator|.
name|type
operator|=
name|converter
operator|.
name|d3dDeclType
expr_stmt|;
name|translated
index|[
name|i
index|]
operator|.
name|stride
operator|=
name|converter
operator|.
name|outputElementSize
expr_stmt|;
name|translated
index|[
name|i
index|]
operator|.
name|offset
operator|=
name|streamOffset
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|mCurrentValueBuffer
index|[
name|i
index|]
condition|)
block|{
name|mCurrentValueBuffer
index|[
name|i
index|]
operator|=
operator|new
name|StreamingVertexBuffer
argument_list|(
name|mDevice
argument_list|,
name|CONSTANT_VERTEX_BUFFER_SIZE
argument_list|)
expr_stmt|;
block|}
name|StreamingVertexBuffer
modifier|*
name|buffer
init|=
name|mCurrentValueBuffer
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|mDirtyCurrentValue
index|[
name|i
index|]
condition|)
block|{
specifier|const
name|int
name|requiredSpace
init|=
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|float
argument_list|)
decl_stmt|;
name|buffer
operator|->
name|addRequiredSpace
argument_list|(
name|requiredSpace
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|reserveRequiredSpace
argument_list|()
expr_stmt|;
name|float
modifier|*
name|data
init|=
cast|static_cast
argument_list|<
name|float
operator|*
argument_list|>
argument_list|(
name|buffer
operator|->
name|map
argument_list|(
name|VertexAttribute
argument_list|()
argument_list|,
name|requiredSpace
argument_list|,
operator|&
name|mCurrentValueOffsets
index|[
name|i
index|]
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
condition|)
block|{
name|data
index|[
literal|0
index|]
operator|=
name|attribs
index|[
name|i
index|]
operator|.
name|mCurrentValue
index|[
literal|0
index|]
expr_stmt|;
name|data
index|[
literal|1
index|]
operator|=
name|attribs
index|[
name|i
index|]
operator|.
name|mCurrentValue
index|[
literal|1
index|]
expr_stmt|;
name|data
index|[
literal|2
index|]
operator|=
name|attribs
index|[
name|i
index|]
operator|.
name|mCurrentValue
index|[
literal|2
index|]
expr_stmt|;
name|data
index|[
literal|3
index|]
operator|=
name|attribs
index|[
name|i
index|]
operator|.
name|mCurrentValue
index|[
literal|3
index|]
expr_stmt|;
name|buffer
operator|->
name|unmap
argument_list|()
expr_stmt|;
name|mDirtyCurrentValue
index|[
name|i
index|]
operator|=
literal|false
expr_stmt|;
block|}
block|}
name|translated
index|[
name|i
index|]
operator|.
name|vertexBuffer
operator|=
name|mCurrentValueBuffer
index|[
name|i
index|]
operator|->
name|getBuffer
argument_list|()
expr_stmt|;
name|translated
index|[
name|i
index|]
operator|.
name|serial
operator|=
name|mCurrentValueBuffer
index|[
name|i
index|]
operator|->
name|getSerial
argument_list|()
expr_stmt|;
name|translated
index|[
name|i
index|]
operator|.
name|divisor
operator|=
literal|0
expr_stmt|;
name|translated
index|[
name|i
index|]
operator|.
name|type
operator|=
name|D3DDECLTYPE_FLOAT4
expr_stmt|;
name|translated
index|[
name|i
index|]
operator|.
name|stride
operator|=
literal|0
expr_stmt|;
name|translated
index|[
name|i
index|]
operator|.
name|offset
operator|=
name|mCurrentValueOffsets
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|translated
index|[
name|i
index|]
operator|.
name|active
operator|&&
name|attribs
index|[
name|i
index|]
operator|.
name|mArrayEnabled
condition|)
block|{
name|Buffer
modifier|*
name|buffer
init|=
name|attribs
index|[
name|i
index|]
operator|.
name|mBoundBuffer
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|buffer
condition|)
block|{
name|buffer
operator|->
name|promoteStaticUsage
argument_list|(
name|count
operator|*
name|attribs
index|[
name|i
index|]
operator|.
name|typeSize
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|GL_NO_ERROR
return|;
block|}
DECL|function|spaceRequired
name|std
operator|::
name|size_t
name|VertexDataManager
operator|::
name|spaceRequired
parameter_list|(
specifier|const
name|VertexAttribute
modifier|&
name|attrib
parameter_list|,
name|std
operator|::
name|size_t
name|count
parameter_list|,
name|GLsizei
name|instances
parameter_list|)
specifier|const
block|{
name|size_t
name|elementSize
init|=
name|formatConverter
argument_list|(
name|attrib
argument_list|)
operator|.
name|outputElementSize
decl_stmt|;
if|if
condition|(
name|instances
operator|==
literal|0
operator|||
name|attrib
operator|.
name|mDivisor
operator|==
literal|0
condition|)
block|{
return|return
name|elementSize
operator|*
name|count
return|;
block|}
else|else
block|{
return|return
name|elementSize
operator|*
operator|(
operator|(
name|instances
operator|+
name|attrib
operator|.
name|mDivisor
operator|-
literal|1
operator|)
operator|/
name|attrib
operator|.
name|mDivisor
operator|)
return|;
block|}
block|}
comment|// Mapping from OpenGL-ES vertex attrib type to D3D decl type:
comment|//
comment|// BYTE                 SHORT (Cast)
comment|// BYTE-norm            FLOAT (Normalize) (can't be exactly represented as SHORT-norm)
comment|// UNSIGNED_BYTE        UBYTE4 (Identity) or SHORT (Cast)
comment|// UNSIGNED_BYTE-norm   UBYTE4N (Identity) or FLOAT (Normalize)
comment|// SHORT                SHORT (Identity)
comment|// SHORT-norm           SHORT-norm (Identity) or FLOAT (Normalize)
comment|// UNSIGNED_SHORT       FLOAT (Cast)
comment|// UNSIGNED_SHORT-norm  USHORT-norm (Identity) or FLOAT (Normalize)
comment|// FIXED (not in WebGL) FLOAT (FixedToFloat)
comment|// FLOAT                FLOAT (Identity)
comment|// GLToCType maps from GL type (as GLenum) to the C typedef.
DECL|struct|GLToCType
template|template
parameter_list|<
name|GLenum
name|GLType
parameter_list|>
struct|struct
name|GLToCType
block|{
block|}
struct|;
DECL|struct|GLToCType
DECL|typedef|type
template|template
parameter_list|<>
struct|struct
name|GLToCType
argument_list|<
name|GL_BYTE
argument_list|>
block|{
typedef|typedef
name|GLbyte
name|type
typedef|;
block|}
struct|;
DECL|struct|GLToCType
DECL|typedef|type
template|template
parameter_list|<>
struct|struct
name|GLToCType
argument_list|<
name|GL_UNSIGNED_BYTE
argument_list|>
block|{
typedef|typedef
name|GLubyte
name|type
typedef|;
block|}
struct|;
DECL|struct|GLToCType
DECL|typedef|type
template|template
parameter_list|<>
struct|struct
name|GLToCType
argument_list|<
name|GL_SHORT
argument_list|>
block|{
typedef|typedef
name|GLshort
name|type
typedef|;
block|}
struct|;
DECL|struct|GLToCType
DECL|typedef|type
template|template
parameter_list|<>
struct|struct
name|GLToCType
argument_list|<
name|GL_UNSIGNED_SHORT
argument_list|>
block|{
typedef|typedef
name|GLushort
name|type
typedef|;
block|}
struct|;
DECL|struct|GLToCType
DECL|typedef|type
template|template
parameter_list|<>
struct|struct
name|GLToCType
argument_list|<
name|GL_FIXED
argument_list|>
block|{
typedef|typedef
name|GLuint
name|type
typedef|;
block|}
struct|;
DECL|struct|GLToCType
DECL|typedef|type
template|template
parameter_list|<>
struct|struct
name|GLToCType
argument_list|<
name|GL_FLOAT
argument_list|>
block|{
typedef|typedef
name|GLfloat
name|type
typedef|;
block|}
struct|;
comment|// This differs from D3DDECLTYPE in that it is unsized. (Size expansion is applied last.)
DECL|enum|D3DVertexType
enum|enum
name|D3DVertexType
block|{
DECL|enumerator|D3DVT_FLOAT
name|D3DVT_FLOAT
block|,
DECL|enumerator|D3DVT_SHORT
name|D3DVT_SHORT
block|,
DECL|enumerator|D3DVT_SHORT_NORM
name|D3DVT_SHORT_NORM
block|,
DECL|enumerator|D3DVT_UBYTE
name|D3DVT_UBYTE
block|,
DECL|enumerator|D3DVT_UBYTE_NORM
name|D3DVT_UBYTE_NORM
block|,
DECL|enumerator|D3DVT_USHORT_NORM
name|D3DVT_USHORT_NORM
block|}
enum|;
comment|// D3DToCType maps from D3D vertex type (as enum D3DVertexType) to the corresponding C type.
DECL|struct|D3DToCType
template|template
parameter_list|<
name|unsigned
name|int
name|D3DType
parameter_list|>
struct|struct
name|D3DToCType
block|{
block|}
struct|;
DECL|struct|D3DToCType
DECL|typedef|type
template|template
parameter_list|<>
struct|struct
name|D3DToCType
argument_list|<
name|D3DVT_FLOAT
argument_list|>
block|{
typedef|typedef
name|float
name|type
typedef|;
block|}
struct|;
DECL|struct|D3DToCType
DECL|typedef|type
template|template
parameter_list|<>
struct|struct
name|D3DToCType
argument_list|<
name|D3DVT_SHORT
argument_list|>
block|{
typedef|typedef
name|short
name|type
typedef|;
block|}
struct|;
DECL|struct|D3DToCType
DECL|typedef|type
template|template
parameter_list|<>
struct|struct
name|D3DToCType
argument_list|<
name|D3DVT_SHORT_NORM
argument_list|>
block|{
typedef|typedef
name|short
name|type
typedef|;
block|}
struct|;
DECL|struct|D3DToCType
DECL|typedef|type
template|template
parameter_list|<>
struct|struct
name|D3DToCType
argument_list|<
name|D3DVT_UBYTE
argument_list|>
block|{
typedef|typedef
name|unsigned
name|char
name|type
typedef|;
block|}
struct|;
DECL|struct|D3DToCType
DECL|typedef|type
template|template
parameter_list|<>
struct|struct
name|D3DToCType
argument_list|<
name|D3DVT_UBYTE_NORM
argument_list|>
block|{
typedef|typedef
name|unsigned
name|char
name|type
typedef|;
block|}
struct|;
DECL|struct|D3DToCType
DECL|typedef|type
template|template
parameter_list|<>
struct|struct
name|D3DToCType
argument_list|<
name|D3DVT_USHORT_NORM
argument_list|>
block|{
typedef|typedef
name|unsigned
name|short
name|type
typedef|;
block|}
struct|;
comment|// Encode the type/size combinations that D3D permits. For each type/size it expands to a widener that will provide the appropriate final size.
template|template
parameter_list|<
name|unsigned
name|int
name|type
parameter_list|,
name|int
name|size
parameter_list|>
struct|struct
DECL|struct|WidenRule
name|WidenRule
block|{
block|}
struct|;
DECL|struct|WidenRule
template|template
parameter_list|<
name|int
name|size
parameter_list|>
struct|struct
name|WidenRule
argument_list|<
name|D3DVT_FLOAT
argument_list|,
name|size
argument_list|>
super|:
name|gl
operator|::
name|NoWiden
argument_list|<
name|size
argument_list|>
block|{
block|}
struct|;
DECL|struct|WidenRule
template|template
parameter_list|<
name|int
name|size
parameter_list|>
struct|struct
name|WidenRule
argument_list|<
name|D3DVT_SHORT
argument_list|,
name|size
argument_list|>
super|:
name|gl
operator|::
name|WidenToEven
argument_list|<
name|size
argument_list|>
block|{
block|}
struct|;
DECL|struct|WidenRule
template|template
parameter_list|<
name|int
name|size
parameter_list|>
struct|struct
name|WidenRule
argument_list|<
name|D3DVT_SHORT_NORM
argument_list|,
name|size
argument_list|>
super|:
name|gl
operator|::
name|WidenToEven
argument_list|<
name|size
argument_list|>
block|{
block|}
struct|;
DECL|struct|WidenRule
template|template
parameter_list|<
name|int
name|size
parameter_list|>
struct|struct
name|WidenRule
argument_list|<
name|D3DVT_UBYTE
argument_list|,
name|size
argument_list|>
super|:
name|gl
operator|::
name|WidenToFour
argument_list|<
name|size
argument_list|>
block|{
block|}
struct|;
DECL|struct|WidenRule
template|template
parameter_list|<
name|int
name|size
parameter_list|>
struct|struct
name|WidenRule
argument_list|<
name|D3DVT_UBYTE_NORM
argument_list|,
name|size
argument_list|>
super|:
name|gl
operator|::
name|WidenToFour
argument_list|<
name|size
argument_list|>
block|{
block|}
struct|;
DECL|struct|WidenRule
template|template
parameter_list|<
name|int
name|size
parameter_list|>
struct|struct
name|WidenRule
argument_list|<
name|D3DVT_USHORT_NORM
argument_list|,
name|size
argument_list|>
super|:
name|gl
operator|::
name|WidenToEven
argument_list|<
name|size
argument_list|>
block|{
block|}
struct|;
comment|// VertexTypeFlags encodes the D3DCAPS9::DeclType flag and vertex declaration flag for each D3D vertex type& size combination.
template|template
parameter_list|<
name|unsigned
name|int
name|d3dtype
parameter_list|,
name|int
name|size
parameter_list|>
struct|struct
DECL|struct|VertexTypeFlags
name|VertexTypeFlags
block|{
block|}
struct|;
template|template
parameter_list|<
name|unsigned
name|int
name|_capflag
parameter_list|,
name|unsigned
name|int
name|_declflag
parameter_list|>
struct|struct
DECL|struct|VertexTypeFlagsHelper
name|VertexTypeFlagsHelper
block|{
DECL|enumerator|capflag
enum|enum
block|{
name|capflag
init|=
name|_capflag
block|}
enum|;
DECL|enumerator|declflag
enum|enum
block|{
name|declflag
init|=
name|_declflag
block|}
enum|;
block|}
struct|;
DECL|struct|VertexTypeFlags
template|template
parameter_list|<>
struct|struct
name|VertexTypeFlags
argument_list|<
name|D3DVT_FLOAT
argument_list|,
literal|1
argument_list|>
super|:
name|VertexTypeFlagsHelper
argument_list|<
literal|0
argument_list|,
name|D3DDECLTYPE_FLOAT1
argument_list|>
block|{
block|}
struct|;
DECL|struct|VertexTypeFlags
template|template
parameter_list|<>
struct|struct
name|VertexTypeFlags
argument_list|<
name|D3DVT_FLOAT
argument_list|,
literal|2
argument_list|>
super|:
name|VertexTypeFlagsHelper
argument_list|<
literal|0
argument_list|,
name|D3DDECLTYPE_FLOAT2
argument_list|>
block|{
block|}
struct|;
DECL|struct|VertexTypeFlags
template|template
parameter_list|<>
struct|struct
name|VertexTypeFlags
argument_list|<
name|D3DVT_FLOAT
argument_list|,
literal|3
argument_list|>
super|:
name|VertexTypeFlagsHelper
argument_list|<
literal|0
argument_list|,
name|D3DDECLTYPE_FLOAT3
argument_list|>
block|{
block|}
struct|;
DECL|struct|VertexTypeFlags
template|template
parameter_list|<>
struct|struct
name|VertexTypeFlags
argument_list|<
name|D3DVT_FLOAT
argument_list|,
literal|4
argument_list|>
super|:
name|VertexTypeFlagsHelper
argument_list|<
literal|0
argument_list|,
name|D3DDECLTYPE_FLOAT4
argument_list|>
block|{
block|}
struct|;
DECL|struct|VertexTypeFlags
template|template
parameter_list|<>
struct|struct
name|VertexTypeFlags
argument_list|<
name|D3DVT_SHORT
argument_list|,
literal|2
argument_list|>
super|:
name|VertexTypeFlagsHelper
argument_list|<
literal|0
argument_list|,
name|D3DDECLTYPE_SHORT2
argument_list|>
block|{
block|}
struct|;
DECL|struct|VertexTypeFlags
template|template
parameter_list|<>
struct|struct
name|VertexTypeFlags
argument_list|<
name|D3DVT_SHORT
argument_list|,
literal|4
argument_list|>
super|:
name|VertexTypeFlagsHelper
argument_list|<
literal|0
argument_list|,
name|D3DDECLTYPE_SHORT4
argument_list|>
block|{
block|}
struct|;
DECL|struct|VertexTypeFlags
template|template
parameter_list|<>
struct|struct
name|VertexTypeFlags
argument_list|<
name|D3DVT_SHORT_NORM
argument_list|,
literal|2
argument_list|>
super|:
name|VertexTypeFlagsHelper
argument_list|<
name|D3DDTCAPS_SHORT2N
argument_list|,
name|D3DDECLTYPE_SHORT2N
argument_list|>
block|{
block|}
struct|;
DECL|struct|VertexTypeFlags
template|template
parameter_list|<>
struct|struct
name|VertexTypeFlags
argument_list|<
name|D3DVT_SHORT_NORM
argument_list|,
literal|4
argument_list|>
super|:
name|VertexTypeFlagsHelper
argument_list|<
name|D3DDTCAPS_SHORT4N
argument_list|,
name|D3DDECLTYPE_SHORT4N
argument_list|>
block|{
block|}
struct|;
DECL|struct|VertexTypeFlags
template|template
parameter_list|<>
struct|struct
name|VertexTypeFlags
argument_list|<
name|D3DVT_UBYTE
argument_list|,
literal|4
argument_list|>
super|:
name|VertexTypeFlagsHelper
argument_list|<
name|D3DDTCAPS_UBYTE4
argument_list|,
name|D3DDECLTYPE_UBYTE4
argument_list|>
block|{
block|}
struct|;
DECL|struct|VertexTypeFlags
template|template
parameter_list|<>
struct|struct
name|VertexTypeFlags
argument_list|<
name|D3DVT_UBYTE_NORM
argument_list|,
literal|4
argument_list|>
super|:
name|VertexTypeFlagsHelper
argument_list|<
name|D3DDTCAPS_UBYTE4N
argument_list|,
name|D3DDECLTYPE_UBYTE4N
argument_list|>
block|{
block|}
struct|;
DECL|struct|VertexTypeFlags
template|template
parameter_list|<>
struct|struct
name|VertexTypeFlags
argument_list|<
name|D3DVT_USHORT_NORM
argument_list|,
literal|2
argument_list|>
super|:
name|VertexTypeFlagsHelper
argument_list|<
name|D3DDTCAPS_USHORT2N
argument_list|,
name|D3DDECLTYPE_USHORT2N
argument_list|>
block|{
block|}
struct|;
DECL|struct|VertexTypeFlags
template|template
parameter_list|<>
struct|struct
name|VertexTypeFlags
argument_list|<
name|D3DVT_USHORT_NORM
argument_list|,
literal|4
argument_list|>
super|:
name|VertexTypeFlagsHelper
argument_list|<
name|D3DDTCAPS_USHORT4N
argument_list|,
name|D3DDECLTYPE_USHORT4N
argument_list|>
block|{
block|}
struct|;
comment|// VertexTypeMapping maps GL type& normalized flag to preferred and fallback D3D vertex types (as D3DVertexType enums).
template|template
parameter_list|<
name|GLenum
name|GLtype
parameter_list|,
name|bool
name|normalized
parameter_list|>
struct|struct
DECL|struct|VertexTypeMapping
name|VertexTypeMapping
block|{
block|}
struct|;
template|template
parameter_list|<
name|D3DVertexType
name|Preferred
parameter_list|,
name|D3DVertexType
name|Fallback
init|=
name|Preferred
parameter_list|>
struct|struct
DECL|struct|VertexTypeMappingBase
name|VertexTypeMappingBase
block|{
DECL|enumerator|preferred
enum|enum
block|{
name|preferred
init|=
name|Preferred
block|}
enum|;
DECL|enumerator|fallback
enum|enum
block|{
name|fallback
init|=
name|Fallback
block|}
enum|;
block|}
struct|;
DECL|struct|VertexTypeMapping
template|template
parameter_list|<>
struct|struct
name|VertexTypeMapping
argument_list|<
name|GL_BYTE
argument_list|,
literal|false
argument_list|>
super|:
name|VertexTypeMappingBase
argument_list|<
name|D3DVT_SHORT
argument_list|>
block|{
block|}
struct|;
comment|// Cast
DECL|struct|VertexTypeMapping
template|template
parameter_list|<>
struct|struct
name|VertexTypeMapping
argument_list|<
name|GL_BYTE
argument_list|,
literal|true
argument_list|>
super|:
name|VertexTypeMappingBase
argument_list|<
name|D3DVT_FLOAT
argument_list|>
block|{
block|}
struct|;
comment|// Normalize
DECL|struct|VertexTypeMapping
template|template
parameter_list|<>
struct|struct
name|VertexTypeMapping
argument_list|<
name|GL_UNSIGNED_BYTE
argument_list|,
literal|false
argument_list|>
super|:
name|VertexTypeMappingBase
argument_list|<
name|D3DVT_UBYTE
argument_list|,
name|D3DVT_FLOAT
argument_list|>
block|{
block|}
struct|;
comment|// Identity, Cast
DECL|struct|VertexTypeMapping
template|template
parameter_list|<>
struct|struct
name|VertexTypeMapping
argument_list|<
name|GL_UNSIGNED_BYTE
argument_list|,
literal|true
argument_list|>
super|:
name|VertexTypeMappingBase
argument_list|<
name|D3DVT_UBYTE_NORM
argument_list|,
name|D3DVT_FLOAT
argument_list|>
block|{
block|}
struct|;
comment|// Identity, Normalize
DECL|struct|VertexTypeMapping
template|template
parameter_list|<>
struct|struct
name|VertexTypeMapping
argument_list|<
name|GL_SHORT
argument_list|,
literal|false
argument_list|>
super|:
name|VertexTypeMappingBase
argument_list|<
name|D3DVT_SHORT
argument_list|>
block|{
block|}
struct|;
comment|// Identity
DECL|struct|VertexTypeMapping
template|template
parameter_list|<>
struct|struct
name|VertexTypeMapping
argument_list|<
name|GL_SHORT
argument_list|,
literal|true
argument_list|>
super|:
name|VertexTypeMappingBase
argument_list|<
name|D3DVT_SHORT_NORM
argument_list|,
name|D3DVT_FLOAT
argument_list|>
block|{
block|}
struct|;
comment|// Cast, Normalize
DECL|struct|VertexTypeMapping
template|template
parameter_list|<>
struct|struct
name|VertexTypeMapping
argument_list|<
name|GL_UNSIGNED_SHORT
argument_list|,
literal|false
argument_list|>
super|:
name|VertexTypeMappingBase
argument_list|<
name|D3DVT_FLOAT
argument_list|>
block|{
block|}
struct|;
comment|// Cast
DECL|struct|VertexTypeMapping
template|template
parameter_list|<>
struct|struct
name|VertexTypeMapping
argument_list|<
name|GL_UNSIGNED_SHORT
argument_list|,
literal|true
argument_list|>
super|:
name|VertexTypeMappingBase
argument_list|<
name|D3DVT_USHORT_NORM
argument_list|,
name|D3DVT_FLOAT
argument_list|>
block|{
block|}
struct|;
comment|// Cast, Normalize
DECL|struct|VertexTypeMapping
template|template
parameter_list|<
name|bool
name|normalized
parameter_list|>
struct|struct
name|VertexTypeMapping
argument_list|<
name|GL_FIXED
argument_list|,
name|normalized
argument_list|>
super|:
name|VertexTypeMappingBase
argument_list|<
name|D3DVT_FLOAT
argument_list|>
block|{
block|}
struct|;
comment|// FixedToFloat
DECL|struct|VertexTypeMapping
template|template
parameter_list|<
name|bool
name|normalized
parameter_list|>
struct|struct
name|VertexTypeMapping
argument_list|<
name|GL_FLOAT
argument_list|,
name|normalized
argument_list|>
super|:
name|VertexTypeMappingBase
argument_list|<
name|D3DVT_FLOAT
argument_list|>
block|{
block|}
struct|;
comment|// Identity
comment|// Given a GL type& norm flag and a D3D type, ConversionRule provides the type conversion rule (Cast, Normalize, Identity, FixedToFloat).
comment|// The conversion rules themselves are defined in vertexconversion.h.
comment|// Almost all cases are covered by Cast (including those that are actually Identity since Cast<T,T> knows it's an identity mapping).
template|template
parameter_list|<
name|GLenum
name|fromType
parameter_list|,
name|bool
name|normalized
parameter_list|,
name|unsigned
name|int
name|toType
parameter_list|>
struct|struct
DECL|struct|ConversionRule
name|ConversionRule
super|:
name|gl
operator|::
name|Cast
argument_list|<
typename|typename
name|GLToCType
argument_list|<
name|fromType
argument_list|>
operator|::
name|type
argument_list|,
typename|typename
name|D3DToCType
argument_list|<
name|toType
argument_list|>
operator|::
name|type
argument_list|>
block|{
block|}
struct|;
comment|// All conversions from normalized types to float use the Normalize operator.
DECL|struct|ConversionRule
template|template
parameter_list|<
name|GLenum
name|fromType
parameter_list|>
struct|struct
name|ConversionRule
argument_list|<
name|fromType
argument_list|,
literal|true
argument_list|,
name|D3DVT_FLOAT
argument_list|>
super|:
name|gl
operator|::
name|Normalize
argument_list|<
typename|typename
name|GLToCType
argument_list|<
name|fromType
argument_list|>
operator|::
name|type
argument_list|>
block|{
block|}
struct|;
comment|// Use a full specialisation for this so that it preferentially matches ahead of the generic normalize-to-float rules.
DECL|struct|ConversionRule
template|template
parameter_list|<>
struct|struct
name|ConversionRule
argument_list|<
name|GL_FIXED
argument_list|,
literal|true
argument_list|,
name|D3DVT_FLOAT
argument_list|>
super|:
name|gl
operator|::
name|FixedToFloat
argument_list|<
name|GLint
argument_list|,
literal|16
argument_list|>
block|{
block|}
struct|;
DECL|struct|ConversionRule
template|template
parameter_list|<>
struct|struct
name|ConversionRule
argument_list|<
name|GL_FIXED
argument_list|,
literal|false
argument_list|,
name|D3DVT_FLOAT
argument_list|>
super|:
name|gl
operator|::
name|FixedToFloat
argument_list|<
name|GLint
argument_list|,
literal|16
argument_list|>
block|{
block|}
struct|;
comment|// A 2-stage construction is used for DefaultVertexValues because float must use SimpleDefaultValues (i.e. 0/1)
comment|// whether it is normalized or not.
template|template
parameter_list|<
name|class
name|T
parameter_list|,
name|bool
name|normalized
parameter_list|>
struct|struct
DECL|struct|DefaultVertexValuesStage2
name|DefaultVertexValuesStage2
block|{
block|}
struct|;
DECL|struct|DefaultVertexValuesStage2
template|template
parameter_list|<
name|class
name|T
parameter_list|>
struct|struct
name|DefaultVertexValuesStage2
argument_list|<
name|T
argument_list|,
literal|true
argument_list|>
super|:
name|gl
operator|::
name|NormalizedDefaultValues
argument_list|<
name|T
argument_list|>
block|{
block|}
struct|;
DECL|struct|DefaultVertexValuesStage2
template|template
parameter_list|<
name|class
name|T
parameter_list|>
struct|struct
name|DefaultVertexValuesStage2
argument_list|<
name|T
argument_list|,
literal|false
argument_list|>
super|:
name|gl
operator|::
name|SimpleDefaultValues
argument_list|<
name|T
argument_list|>
block|{
block|}
struct|;
comment|// Work out the default value rule for a D3D type (expressed as the C type) and
template|template
parameter_list|<
name|class
name|T
parameter_list|,
name|bool
name|normalized
parameter_list|>
struct|struct
DECL|struct|DefaultVertexValues
name|DefaultVertexValues
super|:
name|DefaultVertexValuesStage2
argument_list|<
name|T
argument_list|,
name|normalized
argument_list|>
block|{
block|}
struct|;
DECL|struct|DefaultVertexValues
template|template
parameter_list|<
name|bool
name|normalized
parameter_list|>
struct|struct
name|DefaultVertexValues
argument_list|<
name|float
argument_list|,
name|normalized
argument_list|>
super|:
name|gl
operator|::
name|SimpleDefaultValues
argument_list|<
name|float
argument_list|>
block|{
block|}
struct|;
comment|// Policy rules for use with Converter, to choose whether to use the preferred or fallback conversion.
comment|// The fallback conversion produces an output that all D3D9 devices must support.
DECL|struct|UsePreferred
DECL|enumerator|type
template|template
parameter_list|<
name|class
name|T
parameter_list|>
struct|struct
name|UsePreferred
block|{
enum|enum
block|{
name|type
init|=
name|T
operator|::
name|preferred
block|}
enum|;
block|}
struct|;
DECL|struct|UseFallback
DECL|enumerator|type
template|template
parameter_list|<
name|class
name|T
parameter_list|>
struct|struct
name|UseFallback
block|{
enum|enum
block|{
name|type
init|=
name|T
operator|::
name|fallback
block|}
enum|;
block|}
struct|;
comment|// Converter ties it all together. Given an OpenGL type/norm/size and choice of preferred/fallback conversion,
comment|// it provides all the members of the appropriate VertexDataConverter, the D3DCAPS9::DeclTypes flag in cap flag
comment|// and the D3DDECLTYPE member needed for the vertex declaration in declflag.
template|template
parameter_list|<
name|GLenum
name|fromType
parameter_list|,
name|bool
name|normalized
parameter_list|,
name|int
name|size
parameter_list|,
template|template
parameter_list|<
name|class
name|T
parameter_list|>
name|class
name|PreferenceRule
parameter_list|>
struct|struct
DECL|struct|Converter
name|Converter
super|:
name|gl
operator|::
name|VertexDataConverter
argument_list|<
typename|typename
name|GLToCType
argument_list|<
name|fromType
argument_list|>
operator|::
name|type
argument_list|,
name|WidenRule
argument_list|<
name|PreferenceRule
argument_list|<
name|VertexTypeMapping
argument_list|<
name|fromType
argument_list|,
name|normalized
argument_list|>
argument_list|>
operator|::
name|type
argument_list|,
name|size
argument_list|>
argument_list|,
name|ConversionRule
argument_list|<
name|fromType
argument_list|,
name|normalized
argument_list|,
name|PreferenceRule
argument_list|<
name|VertexTypeMapping
argument_list|<
name|fromType
argument_list|,
name|normalized
argument_list|>
argument_list|>
operator|::
name|type
argument_list|>
argument_list|,
name|DefaultVertexValues
argument_list|<
typename|typename
name|D3DToCType
argument_list|<
name|PreferenceRule
argument_list|<
name|VertexTypeMapping
argument_list|<
name|fromType
argument_list|,
name|normalized
argument_list|>
argument_list|>
operator|::
name|type
argument_list|>
operator|::
name|type
argument_list|,
name|normalized
argument_list|>
argument_list|>
block|{
private|private:
DECL|enumerator|d3dtype
enum|enum
block|{
name|d3dtype
init|=
name|PreferenceRule
argument_list|<
name|VertexTypeMapping
argument_list|<
name|fromType
argument_list|,
name|normalized
argument_list|>
argument_list|>
operator|::
name|type
block|}
enum|;
DECL|enumerator|d3dsize
enum|enum
block|{
name|d3dsize
init|=
name|WidenRule
argument_list|<
name|d3dtype
argument_list|,
name|size
argument_list|>
operator|::
name|finalWidth
block|}
enum|;
public|public:
DECL|enumerator|capflag
enum|enum
block|{
name|capflag
init|=
name|VertexTypeFlags
argument_list|<
name|d3dtype
argument_list|,
name|d3dsize
argument_list|>
operator|::
name|capflag
block|}
enum|;
DECL|enumerator|declflag
enum|enum
block|{
name|declflag
init|=
name|VertexTypeFlags
argument_list|<
name|d3dtype
argument_list|,
name|d3dsize
argument_list|>
operator|::
name|declflag
block|}
enum|;
block|}
struct|;
comment|// Initialise a TranslationInfo
DECL|macro|TRANSLATION
define|#
directive|define
name|TRANSLATION
parameter_list|(
name|type
parameter_list|,
name|norm
parameter_list|,
name|size
parameter_list|,
name|preferred
parameter_list|)
define|\
value|{                                                                               \         Converter<type, norm, size, preferred>::identity,                           \         Converter<type, norm, size, preferred>::finalSize,                          \         Converter<type, norm, size, preferred>::convertArray,                       \         static_cast<D3DDECLTYPE>(Converter<type, norm, size, preferred>::declflag)  \     }
DECL|macro|TRANSLATION_FOR_TYPE_NORM_SIZE
define|#
directive|define
name|TRANSLATION_FOR_TYPE_NORM_SIZE
parameter_list|(
name|type
parameter_list|,
name|norm
parameter_list|,
name|size
parameter_list|)
define|\
value|{                                                       \         Converter<type, norm, size, UsePreferred>::capflag, \         TRANSLATION(type, norm, size, UsePreferred),        \         TRANSLATION(type, norm, size, UseFallback)          \     }
DECL|macro|TRANSLATIONS_FOR_TYPE
define|#
directive|define
name|TRANSLATIONS_FOR_TYPE
parameter_list|(
name|type
parameter_list|)
define|\
value|{                                                                                                                                                                                                       \         { TRANSLATION_FOR_TYPE_NORM_SIZE(type, false, 1), TRANSLATION_FOR_TYPE_NORM_SIZE(type, false, 2), TRANSLATION_FOR_TYPE_NORM_SIZE(type, false, 3), TRANSLATION_FOR_TYPE_NORM_SIZE(type, false, 4) }, \         { TRANSLATION_FOR_TYPE_NORM_SIZE(type, true, 1), TRANSLATION_FOR_TYPE_NORM_SIZE(type, true, 2), TRANSLATION_FOR_TYPE_NORM_SIZE(type, true, 3), TRANSLATION_FOR_TYPE_NORM_SIZE(type, true, 4) },     \     }
DECL|macro|TRANSLATIONS_FOR_TYPE_NO_NORM
define|#
directive|define
name|TRANSLATIONS_FOR_TYPE_NO_NORM
parameter_list|(
name|type
parameter_list|)
define|\
value|{                                                                                                                                                                                                       \         { TRANSLATION_FOR_TYPE_NORM_SIZE(type, false, 1), TRANSLATION_FOR_TYPE_NORM_SIZE(type, false, 2), TRANSLATION_FOR_TYPE_NORM_SIZE(type, false, 3), TRANSLATION_FOR_TYPE_NORM_SIZE(type, false, 4) }, \         { TRANSLATION_FOR_TYPE_NORM_SIZE(type, false, 1), TRANSLATION_FOR_TYPE_NORM_SIZE(type, false, 2), TRANSLATION_FOR_TYPE_NORM_SIZE(type, false, 3), TRANSLATION_FOR_TYPE_NORM_SIZE(type, false, 4) }, \     }
DECL|member|mPossibleTranslations
specifier|const
name|VertexDataManager
operator|::
name|TranslationDescription
name|VertexDataManager
operator|::
name|mPossibleTranslations
index|[
name|NUM_GL_VERTEX_ATTRIB_TYPES
index|]
index|[
literal|2
index|]
index|[
literal|4
index|]
init|=
comment|// [GL types as enumerated by typeIndex()][normalized][size-1]
block|{
name|TRANSLATIONS_FOR_TYPE
argument_list|(
name|GL_BYTE
argument_list|)
block|,
name|TRANSLATIONS_FOR_TYPE
argument_list|(
name|GL_UNSIGNED_BYTE
argument_list|)
block|,
name|TRANSLATIONS_FOR_TYPE
argument_list|(
name|GL_SHORT
argument_list|)
block|,
name|TRANSLATIONS_FOR_TYPE
argument_list|(
name|GL_UNSIGNED_SHORT
argument_list|)
block|,
name|TRANSLATIONS_FOR_TYPE_NO_NORM
argument_list|(
name|GL_FIXED
argument_list|)
block|,
name|TRANSLATIONS_FOR_TYPE_NO_NORM
argument_list|(
argument|GL_FLOAT
argument_list|)
block|}
decl_stmt|;
DECL|function|checkVertexCaps
name|void
name|VertexDataManager
operator|::
name|checkVertexCaps
parameter_list|(
name|DWORD
name|declTypes
parameter_list|)
block|{
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_GL_VERTEX_ATTRIB_TYPES
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|unsigned
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|unsigned
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
literal|4
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|mPossibleTranslations
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|.
name|capsFlag
operator|==
literal|0
operator|||
operator|(
name|declTypes
operator|&
name|mPossibleTranslations
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|.
name|capsFlag
operator|)
operator|!=
literal|0
condition|)
block|{
name|mAttributeTypes
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|=
name|mPossibleTranslations
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|.
name|preferredConversion
expr_stmt|;
block|}
else|else
block|{
name|mAttributeTypes
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|=
name|mPossibleTranslations
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|.
name|fallbackConversion
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|// This is used to index mAttributeTypes and mPossibleTranslations.
DECL|function|typeIndex
name|unsigned
name|int
name|VertexDataManager
operator|::
name|typeIndex
parameter_list|(
name|GLenum
name|type
parameter_list|)
specifier|const
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_BYTE
case|:
return|return
literal|0
return|;
case|case
name|GL_UNSIGNED_BYTE
case|:
return|return
literal|1
return|;
case|case
name|GL_SHORT
case|:
return|return
literal|2
return|;
case|case
name|GL_UNSIGNED_SHORT
case|:
return|return
literal|3
return|;
case|case
name|GL_FIXED
case|:
return|return
literal|4
return|;
case|case
name|GL_FLOAT
case|:
return|return
literal|5
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|5
return|;
block|}
block|}
DECL|function|VertexBuffer
name|VertexBuffer
operator|::
name|VertexBuffer
parameter_list|(
name|IDirect3DDevice9
modifier|*
name|device
parameter_list|,
name|std
operator|::
name|size_t
name|size
parameter_list|,
name|DWORD
name|usageFlags
parameter_list|)
member_init_list|:
name|mDevice
argument_list|(
name|device
argument_list|)
member_init_list|,
name|mVertexBuffer
argument_list|(
name|NULL
argument_list|)
block|{
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|D3DPOOL
name|pool
init|=
name|getDisplay
argument_list|()
operator|->
name|getBufferPool
argument_list|(
name|usageFlags
argument_list|)
decl_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateVertexBuffer
argument_list|(
name|size
argument_list|,
name|usageFlags
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|,
operator|&
name|mVertexBuffer
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|mSerial
operator|=
name|issueSerial
argument_list|()
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Out of memory allocating a vertex buffer of size %lu."
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|~VertexBuffer
name|VertexBuffer
operator|::
name|~
name|VertexBuffer
parameter_list|()
block|{
if|if
condition|(
name|mVertexBuffer
condition|)
block|{
name|mVertexBuffer
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|unmap
name|void
name|VertexBuffer
operator|::
name|unmap
parameter_list|()
block|{
if|if
condition|(
name|mVertexBuffer
condition|)
block|{
name|mVertexBuffer
operator|->
name|Unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|getBuffer
name|IDirect3DVertexBuffer9
modifier|*
name|VertexBuffer
operator|::
name|getBuffer
parameter_list|()
specifier|const
block|{
return|return
name|mVertexBuffer
return|;
block|}
DECL|function|getSerial
name|unsigned
name|int
name|VertexBuffer
operator|::
name|getSerial
parameter_list|()
specifier|const
block|{
return|return
name|mSerial
return|;
block|}
DECL|function|issueSerial
name|unsigned
name|int
name|VertexBuffer
operator|::
name|issueSerial
parameter_list|()
block|{
return|return
name|mCurrentSerial
operator|++
return|;
block|}
DECL|function|ArrayVertexBuffer
name|ArrayVertexBuffer
operator|::
name|ArrayVertexBuffer
parameter_list|(
name|IDirect3DDevice9
modifier|*
name|device
parameter_list|,
name|std
operator|::
name|size_t
name|size
parameter_list|,
name|DWORD
name|usageFlags
parameter_list|)
member_init_list|:
name|VertexBuffer
argument_list|(
name|device
argument_list|,
name|size
argument_list|,
name|usageFlags
argument_list|)
block|{
name|mBufferSize
operator|=
name|size
expr_stmt|;
name|mWritePosition
operator|=
literal|0
expr_stmt|;
name|mRequiredSpace
operator|=
literal|0
expr_stmt|;
block|}
DECL|function|~ArrayVertexBuffer
name|ArrayVertexBuffer
operator|::
name|~
name|ArrayVertexBuffer
parameter_list|()
block|{ }
DECL|function|addRequiredSpace
name|void
name|ArrayVertexBuffer
operator|::
name|addRequiredSpace
parameter_list|(
name|UINT
name|requiredSpace
parameter_list|)
block|{
name|mRequiredSpace
operator|+=
name|requiredSpace
expr_stmt|;
block|}
DECL|function|StreamingVertexBuffer
name|StreamingVertexBuffer
operator|::
name|StreamingVertexBuffer
parameter_list|(
name|IDirect3DDevice9
modifier|*
name|device
parameter_list|,
name|std
operator|::
name|size_t
name|initialSize
parameter_list|)
member_init_list|:
name|ArrayVertexBuffer
argument_list|(
name|device
argument_list|,
name|initialSize
argument_list|,
name|D3DUSAGE_DYNAMIC
operator||
name|D3DUSAGE_WRITEONLY
argument_list|)
block|{ }
DECL|function|~StreamingVertexBuffer
name|StreamingVertexBuffer
operator|::
name|~
name|StreamingVertexBuffer
parameter_list|()
block|{ }
DECL|function|map
name|void
modifier|*
name|StreamingVertexBuffer
operator|::
name|map
parameter_list|(
specifier|const
name|VertexAttribute
modifier|&
name|attribute
parameter_list|,
name|std
operator|::
name|size_t
name|requiredSpace
parameter_list|,
name|std
operator|::
name|size_t
modifier|*
name|offset
parameter_list|)
block|{
name|void
modifier|*
name|mapPtr
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|mVertexBuffer
condition|)
block|{
name|HRESULT
name|result
init|=
name|mVertexBuffer
operator|->
name|Lock
argument_list|(
name|mWritePosition
argument_list|,
name|requiredSpace
argument_list|,
operator|&
name|mapPtr
argument_list|,
name|D3DLOCK_NOOVERWRITE
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Lock failed with error 0x%08x"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|offset
operator|=
name|mWritePosition
expr_stmt|;
name|mWritePosition
operator|+=
name|requiredSpace
expr_stmt|;
block|}
return|return
name|mapPtr
return|;
block|}
DECL|function|reserveRequiredSpace
name|void
name|StreamingVertexBuffer
operator|::
name|reserveRequiredSpace
parameter_list|()
block|{
if|if
condition|(
name|mRequiredSpace
operator|>
name|mBufferSize
condition|)
block|{
if|if
condition|(
name|mVertexBuffer
condition|)
block|{
name|mVertexBuffer
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mVertexBuffer
operator|=
name|NULL
expr_stmt|;
block|}
name|mBufferSize
operator|=
name|std
operator|::
name|max
argument_list|(
name|mRequiredSpace
argument_list|,
literal|3
operator|*
name|mBufferSize
operator|/
literal|2
argument_list|)
expr_stmt|;
comment|// 1.5 x mBufferSize is arbitrary and should be checked to see we don't have too many reallocations.
name|D3DPOOL
name|pool
init|=
name|getDisplay
argument_list|()
operator|->
name|getBufferPool
argument_list|(
name|D3DUSAGE_DYNAMIC
operator||
name|D3DUSAGE_WRITEONLY
argument_list|)
decl_stmt|;
name|HRESULT
name|result
init|=
name|mDevice
operator|->
name|CreateVertexBuffer
argument_list|(
name|mBufferSize
argument_list|,
name|D3DUSAGE_DYNAMIC
operator||
name|D3DUSAGE_WRITEONLY
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|,
operator|&
name|mVertexBuffer
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|mSerial
operator|=
name|issueSerial
argument_list|()
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Out of memory allocating a vertex buffer of size %lu."
argument_list|,
name|mBufferSize
argument_list|)
expr_stmt|;
block|}
name|mWritePosition
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mWritePosition
operator|+
name|mRequiredSpace
operator|>
name|mBufferSize
condition|)
comment|// Recycle
block|{
if|if
condition|(
name|mVertexBuffer
condition|)
block|{
name|void
modifier|*
name|dummy
decl_stmt|;
name|mVertexBuffer
operator|->
name|Lock
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|dummy
argument_list|,
name|D3DLOCK_DISCARD
argument_list|)
expr_stmt|;
name|mVertexBuffer
operator|->
name|Unlock
argument_list|()
expr_stmt|;
block|}
name|mWritePosition
operator|=
literal|0
expr_stmt|;
block|}
name|mRequiredSpace
operator|=
literal|0
expr_stmt|;
block|}
DECL|function|StaticVertexBuffer
name|StaticVertexBuffer
operator|::
name|StaticVertexBuffer
parameter_list|(
name|IDirect3DDevice9
modifier|*
name|device
parameter_list|)
member_init_list|:
name|ArrayVertexBuffer
argument_list|(
name|device
argument_list|,
literal|0
argument_list|,
name|D3DUSAGE_WRITEONLY
argument_list|)
block|{ }
DECL|function|~StaticVertexBuffer
name|StaticVertexBuffer
operator|::
name|~
name|StaticVertexBuffer
parameter_list|()
block|{ }
DECL|function|map
name|void
modifier|*
name|StaticVertexBuffer
operator|::
name|map
parameter_list|(
specifier|const
name|VertexAttribute
modifier|&
name|attribute
parameter_list|,
name|std
operator|::
name|size_t
name|requiredSpace
parameter_list|,
name|std
operator|::
name|size_t
modifier|*
name|streamOffset
parameter_list|)
block|{
name|void
modifier|*
name|mapPtr
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|mVertexBuffer
condition|)
block|{
name|HRESULT
name|result
init|=
name|mVertexBuffer
operator|->
name|Lock
argument_list|(
name|mWritePosition
argument_list|,
name|requiredSpace
argument_list|,
operator|&
name|mapPtr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Lock failed with error 0x%08x"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|int
name|attributeOffset
init|=
name|attribute
operator|.
name|mOffset
operator|%
name|attribute
operator|.
name|stride
argument_list|()
decl_stmt|;
name|VertexElement
name|element
init|=
block|{
name|attribute
operator|.
name|mType
block|,
name|attribute
operator|.
name|mSize
block|,
name|attribute
operator|.
name|stride
argument_list|()
block|,
name|attribute
operator|.
name|mNormalized
block|,
name|attributeOffset
block|,
name|mWritePosition
block|}
decl_stmt|;
name|mCache
operator|.
name|push_back
argument_list|(
name|element
argument_list|)
expr_stmt|;
operator|*
name|streamOffset
operator|=
name|mWritePosition
expr_stmt|;
name|mWritePosition
operator|+=
name|requiredSpace
expr_stmt|;
block|}
return|return
name|mapPtr
return|;
block|}
DECL|function|reserveRequiredSpace
name|void
name|StaticVertexBuffer
operator|::
name|reserveRequiredSpace
parameter_list|()
block|{
if|if
condition|(
operator|!
name|mVertexBuffer
operator|&&
name|mBufferSize
operator|==
literal|0
condition|)
block|{
name|D3DPOOL
name|pool
init|=
name|getDisplay
argument_list|()
operator|->
name|getBufferPool
argument_list|(
name|D3DUSAGE_WRITEONLY
argument_list|)
decl_stmt|;
name|HRESULT
name|result
init|=
name|mDevice
operator|->
name|CreateVertexBuffer
argument_list|(
name|mRequiredSpace
argument_list|,
name|D3DUSAGE_WRITEONLY
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|,
operator|&
name|mVertexBuffer
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|mSerial
operator|=
name|issueSerial
argument_list|()
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Out of memory allocating a vertex buffer of size %lu."
argument_list|,
name|mRequiredSpace
argument_list|)
expr_stmt|;
block|}
name|mBufferSize
operator|=
name|mRequiredSpace
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mVertexBuffer
operator|&&
name|mBufferSize
operator|>=
name|mRequiredSpace
condition|)
block|{
comment|// Already allocated
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
comment|// Static vertex buffers can't be resized
name|mRequiredSpace
operator|=
literal|0
expr_stmt|;
block|}
DECL|function|lookupAttribute
name|std
operator|::
name|size_t
name|StaticVertexBuffer
operator|::
name|lookupAttribute
parameter_list|(
specifier|const
name|VertexAttribute
modifier|&
name|attribute
parameter_list|)
block|{
for|for
control|(
name|unsigned
name|int
name|element
init|=
literal|0
init|;
name|element
operator|<
name|mCache
operator|.
name|size
argument_list|()
condition|;
name|element
operator|++
control|)
block|{
if|if
condition|(
name|mCache
index|[
name|element
index|]
operator|.
name|type
operator|==
name|attribute
operator|.
name|mType
operator|&&
name|mCache
index|[
name|element
index|]
operator|.
name|size
operator|==
name|attribute
operator|.
name|mSize
operator|&&
name|mCache
index|[
name|element
index|]
operator|.
name|stride
operator|==
name|attribute
operator|.
name|stride
argument_list|()
operator|&&
name|mCache
index|[
name|element
index|]
operator|.
name|normalized
operator|==
name|attribute
operator|.
name|mNormalized
condition|)
block|{
if|if
condition|(
name|mCache
index|[
name|element
index|]
operator|.
name|attributeOffset
operator|==
name|attribute
operator|.
name|mOffset
operator|%
name|attribute
operator|.
name|stride
argument_list|()
condition|)
block|{
return|return
name|mCache
index|[
name|element
index|]
operator|.
name|streamOffset
return|;
block|}
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
DECL|function|formatConverter
specifier|const
name|VertexDataManager
operator|::
name|FormatConverter
modifier|&
name|VertexDataManager
operator|::
name|formatConverter
parameter_list|(
specifier|const
name|VertexAttribute
modifier|&
name|attribute
parameter_list|)
specifier|const
block|{
return|return
name|mAttributeTypes
index|[
name|typeIndex
argument_list|(
name|attribute
operator|.
name|mType
argument_list|)
index|]
index|[
name|attribute
operator|.
name|mNormalized
index|]
index|[
name|attribute
operator|.
name|mSize
operator|-
literal|1
index|]
return|;
block|}
block|}
end_namespace
end_unit
