begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2012 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// mathutil.h: Math and bit manipulation functions.
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|LIBGLESV2_MATHUTIL_H_
end_ifndef
begin_define
DECL|macro|LIBGLESV2_MATHUTIL_H_
define|#
directive|define
name|LIBGLESV2_MATHUTIL_H_
end_define
begin_include
include|#
directive|include
file|"common/system.h"
end_include
begin_include
include|#
directive|include
file|"common/debug.h"
end_include
begin_decl_stmt
name|namespace
name|gl
block|{
struct|struct
name|Vector4
block|{
name|Vector4
argument_list|()
block|{}
name|Vector4
argument_list|(
argument|float x
argument_list|,
argument|float y
argument_list|,
argument|float z
argument_list|,
argument|float w
argument_list|)
block|:
name|x
argument_list|(
name|x
argument_list|)
operator|,
name|y
argument_list|(
name|y
argument_list|)
operator|,
name|z
argument_list|(
name|z
argument_list|)
operator|,
name|w
argument_list|(
argument|w
argument_list|)
block|{}
name|float
name|x
expr_stmt|;
name|float
name|y
decl_stmt|;
name|float
name|z
decl_stmt|;
name|float
name|w
decl_stmt|;
block|}
struct|;
specifier|inline
name|bool
name|isPow2
parameter_list|(
name|int
name|x
parameter_list|)
block|{
return|return
operator|(
name|x
operator|&
operator|(
name|x
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|x
operator|!=
literal|0
operator|)
return|;
block|}
specifier|inline
name|int
name|log2
parameter_list|(
name|int
name|x
parameter_list|)
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|x
operator|>>
name|r
operator|)
operator|>
literal|1
condition|)
name|r
operator|++
expr_stmt|;
return|return
name|r
return|;
block|}
specifier|inline
name|unsigned
name|int
name|ceilPow2
parameter_list|(
name|unsigned
name|int
name|x
parameter_list|)
block|{
if|if
condition|(
name|x
operator|!=
literal|0
condition|)
name|x
operator|--
expr_stmt|;
name|x
operator||=
name|x
operator|>>
literal|1
expr_stmt|;
name|x
operator||=
name|x
operator|>>
literal|2
expr_stmt|;
name|x
operator||=
name|x
operator|>>
literal|4
expr_stmt|;
name|x
operator||=
name|x
operator|>>
literal|8
expr_stmt|;
name|x
operator||=
name|x
operator|>>
literal|16
expr_stmt|;
name|x
operator|++
expr_stmt|;
return|return
name|x
return|;
block|}
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|MIN
operator|,
name|typename
name|MAX
operator|>
specifier|inline
name|T
name|clamp
argument_list|(
argument|T x
argument_list|,
argument|MIN min
argument_list|,
argument|MAX max
argument_list|)
block|{
comment|// Since NaNs fail all comparison tests, a NaN value will default to min
return|return
name|x
operator|>
name|min
operator|?
operator|(
name|x
operator|>
name|max
operator|?
name|max
operator|:
name|x
operator|)
operator|:
name|min
return|;
block|}
specifier|inline
name|float
name|clamp01
parameter_list|(
name|float
name|x
parameter_list|)
block|{
return|return
name|clamp
argument_list|(
name|x
argument_list|,
literal|0.0f
argument_list|,
literal|1.0f
argument_list|)
return|;
block|}
name|template
operator|<
specifier|const
name|int
name|n
operator|>
specifier|inline
name|unsigned
name|int
name|unorm
argument_list|(
argument|float x
argument_list|)
block|{
specifier|const
name|unsigned
name|int
name|max
operator|=
literal|0xFFFFFFFF
operator|>>
operator|(
literal|32
operator|-
name|n
operator|)
block|;
if|if
condition|(
name|x
operator|>
literal|1
condition|)
block|{
return|return
name|max
return|;
block|}
elseif|else
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
call|(
name|unsigned
name|int
call|)
argument_list|(
name|max
operator|*
name|x
operator|+
literal|0.5f
argument_list|)
return|;
block|}
block|}
specifier|inline
name|bool
name|supportsSSE2
argument_list|()
block|{
specifier|static
name|bool
name|checked
operator|=
name|false
block|;
specifier|static
name|bool
name|supports
operator|=
name|false
block|;
if|if
condition|(
name|checked
condition|)
block|{
return|return
name|supports
return|;
block|}
name|int
name|info
index|[
literal|4
index|]
decl_stmt|;
name|__cpuid
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
index|[
literal|0
index|]
operator|>=
literal|1
condition|)
block|{
name|__cpuid
argument_list|(
name|info
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|supports
operator|=
operator|(
name|info
index|[
literal|3
index|]
operator|>>
literal|26
operator|)
operator|&
literal|1
expr_stmt|;
block|}
name|checked
operator|=
name|true
expr_stmt|;
return|return
name|supports
return|;
block|}
end_decl_stmt
begin_function
specifier|inline
name|unsigned
name|short
name|float32ToFloat16
parameter_list|(
name|float
name|fp32
parameter_list|)
block|{
name|unsigned
name|int
name|fp32i
init|=
operator|(
name|unsigned
name|int
operator|&
operator|)
name|fp32
decl_stmt|;
name|unsigned
name|int
name|sign
init|=
operator|(
name|fp32i
operator|&
literal|0x80000000
operator|)
operator|>>
literal|16
decl_stmt|;
name|unsigned
name|int
name|abs
init|=
name|fp32i
operator|&
literal|0x7FFFFFFF
decl_stmt|;
if|if
condition|(
name|abs
operator|>
literal|0x47FFEFFF
condition|)
comment|// Infinity
block|{
return|return
name|sign
operator||
literal|0x7FFF
return|;
block|}
elseif|else
if|if
condition|(
name|abs
operator|<
literal|0x38800000
condition|)
comment|// Denormal
block|{
name|unsigned
name|int
name|mantissa
init|=
operator|(
name|abs
operator|&
literal|0x007FFFFF
operator|)
operator||
literal|0x00800000
decl_stmt|;
name|int
name|e
init|=
literal|113
operator|-
operator|(
name|abs
operator|>>
literal|23
operator|)
decl_stmt|;
if|if
condition|(
name|e
operator|<
literal|24
condition|)
block|{
name|abs
operator|=
name|mantissa
operator|>>
name|e
expr_stmt|;
block|}
else|else
block|{
name|abs
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|sign
operator||
operator|(
name|abs
operator|+
literal|0x00000FFF
operator|+
operator|(
operator|(
name|abs
operator|>>
literal|13
operator|)
operator|&
literal|1
operator|)
operator|)
operator|>>
literal|13
return|;
block|}
else|else
block|{
return|return
name|sign
operator||
operator|(
name|abs
operator|+
literal|0xC8000000
operator|+
literal|0x00000FFF
operator|+
operator|(
operator|(
name|abs
operator|>>
literal|13
operator|)
operator|&
literal|1
operator|)
operator|)
operator|>>
literal|13
return|;
block|}
block|}
end_function
begin_function_decl
name|float
name|float16ToFloat32
parameter_list|(
name|unsigned
name|short
name|h
parameter_list|)
function_decl|;
end_function_decl
begin_macro
unit|}  namespace
name|rx
end_macro
begin_block
block|{
struct|struct
name|Range
block|{
name|Range
argument_list|()
block|{}
name|Range
argument_list|(
argument|int lo
argument_list|,
argument|int hi
argument_list|)
block|:
name|start
argument_list|(
name|lo
argument_list|)
operator|,
name|end
argument_list|(
argument|hi
argument_list|)
block|{
name|ASSERT
argument_list|(
name|lo
operator|<=
name|hi
argument_list|)
block|; }
name|int
name|start
expr_stmt|;
name|int
name|end
decl_stmt|;
block|}
struct|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// LIBGLESV2_MATHUTIL_H_
end_comment
end_unit
