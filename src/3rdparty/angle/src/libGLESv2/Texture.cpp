begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2012 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Texture.cpp: Implements the gl::Texture class and its derived classes
end_comment
begin_comment
comment|// Texture2D and TextureCubeMap. Implements GL texture objects and related
end_comment
begin_comment
comment|// functionality. [OpenGL ES 2.0.24] section 3.7 page 63.
end_comment
begin_include
include|#
directive|include
file|"libGLESv2/Texture.h"
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_include
include|#
directive|include
file|"common/debug.h"
end_include
begin_include
include|#
directive|include
file|"libEGL/Display.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/main.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/mathutil.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/utilities.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Blit.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Framebuffer.h"
end_include
begin_namespace
DECL|namespace|gl
namespace|namespace
name|gl
block|{
DECL|member|mCurrentTextureSerial
name|unsigned
name|int
name|TextureStorage
operator|::
name|mCurrentTextureSerial
init|=
literal|1
decl_stmt|;
DECL|function|ConvertTextureInternalFormat
specifier|static
name|D3DFORMAT
name|ConvertTextureInternalFormat
parameter_list|(
name|GLint
name|internalformat
parameter_list|)
block|{
switch|switch
condition|(
name|internalformat
condition|)
block|{
case|case
name|GL_DEPTH_COMPONENT16
case|:
case|case
name|GL_DEPTH_COMPONENT32_OES
case|:
case|case
name|GL_DEPTH24_STENCIL8_OES
case|:
return|return
name|D3DFMT_INTZ
return|;
case|case
name|GL_COMPRESSED_RGB_S3TC_DXT1_EXT
case|:
case|case
name|GL_COMPRESSED_RGBA_S3TC_DXT1_EXT
case|:
return|return
name|D3DFMT_DXT1
return|;
case|case
name|GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE
case|:
return|return
name|D3DFMT_DXT3
return|;
case|case
name|GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE
case|:
return|return
name|D3DFMT_DXT5
return|;
case|case
name|GL_RGBA32F_EXT
case|:
case|case
name|GL_RGB32F_EXT
case|:
case|case
name|GL_ALPHA32F_EXT
case|:
case|case
name|GL_LUMINANCE32F_EXT
case|:
case|case
name|GL_LUMINANCE_ALPHA32F_EXT
case|:
return|return
name|D3DFMT_A32B32G32R32F
return|;
case|case
name|GL_RGBA16F_EXT
case|:
case|case
name|GL_RGB16F_EXT
case|:
case|case
name|GL_ALPHA16F_EXT
case|:
case|case
name|GL_LUMINANCE16F_EXT
case|:
case|case
name|GL_LUMINANCE_ALPHA16F_EXT
case|:
return|return
name|D3DFMT_A16B16G16R16F
return|;
case|case
name|GL_LUMINANCE8_EXT
case|:
if|if
condition|(
name|getContext
argument_list|()
operator|->
name|supportsLuminanceTextures
argument_list|()
condition|)
block|{
return|return
name|D3DFMT_L8
return|;
block|}
break|break;
case|case
name|GL_LUMINANCE8_ALPHA8_EXT
case|:
if|if
condition|(
name|getContext
argument_list|()
operator|->
name|supportsLuminanceAlphaTextures
argument_list|()
condition|)
block|{
return|return
name|D3DFMT_A8L8
return|;
block|}
break|break;
case|case
name|GL_RGB8_OES
case|:
case|case
name|GL_RGB565
case|:
return|return
name|D3DFMT_X8R8G8B8
return|;
block|}
return|return
name|D3DFMT_A8R8G8B8
return|;
block|}
DECL|function|IsTextureFormatRenderable
specifier|static
name|bool
name|IsTextureFormatRenderable
parameter_list|(
name|D3DFORMAT
name|format
parameter_list|)
block|{
if|if
condition|(
name|format
operator|==
name|D3DFMT_INTZ
condition|)
block|{
return|return
literal|true
return|;
block|}
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|D3DFMT_L8
case|:
case|case
name|D3DFMT_A8L8
case|:
case|case
name|D3DFMT_DXT1
case|:
case|case
name|D3DFMT_DXT3
case|:
case|case
name|D3DFMT_DXT5
case|:
return|return
literal|false
return|;
case|case
name|D3DFMT_A8R8G8B8
case|:
case|case
name|D3DFMT_X8R8G8B8
case|:
case|case
name|D3DFMT_A16B16G16R16F
case|:
case|case
name|D3DFMT_A32B32G32R32F
case|:
return|return
literal|true
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
DECL|function|GetTextureUsage
specifier|static
specifier|inline
name|DWORD
name|GetTextureUsage
parameter_list|(
name|D3DFORMAT
name|d3dfmt
parameter_list|,
name|GLenum
name|glusage
parameter_list|,
name|bool
name|forceRenderable
parameter_list|)
block|{
name|DWORD
name|d3dusage
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|d3dfmt
operator|==
name|D3DFMT_INTZ
condition|)
block|{
name|d3dusage
operator||=
name|D3DUSAGE_DEPTHSTENCIL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|forceRenderable
operator|||
operator|(
name|IsTextureFormatRenderable
argument_list|(
name|d3dfmt
argument_list|)
operator|&&
operator|(
name|glusage
operator|==
name|GL_FRAMEBUFFER_ATTACHMENT_ANGLE
operator|)
operator|)
condition|)
block|{
name|d3dusage
operator||=
name|D3DUSAGE_RENDERTARGET
expr_stmt|;
block|}
return|return
name|d3dusage
return|;
block|}
DECL|function|MakeValidSize
specifier|static
name|void
name|MakeValidSize
parameter_list|(
name|bool
name|isImage
parameter_list|,
name|bool
name|isCompressed
parameter_list|,
name|GLsizei
modifier|*
name|requestWidth
parameter_list|,
name|GLsizei
modifier|*
name|requestHeight
parameter_list|,
name|int
modifier|*
name|levelOffset
parameter_list|)
block|{
name|int
name|upsampleCount
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|isCompressed
condition|)
block|{
comment|// Don't expand the size of full textures that are at least 4x4
comment|// already.
if|if
condition|(
name|isImage
operator|||
operator|*
name|requestWidth
operator|<
literal|4
operator|||
operator|*
name|requestHeight
operator|<
literal|4
condition|)
block|{
while|while
condition|(
operator|*
name|requestWidth
operator|%
literal|4
operator|!=
literal|0
operator|||
operator|*
name|requestHeight
operator|%
literal|4
operator|!=
literal|0
condition|)
block|{
operator|*
name|requestWidth
operator|<<=
literal|1
expr_stmt|;
operator|*
name|requestHeight
operator|<<=
literal|1
expr_stmt|;
name|upsampleCount
operator|++
expr_stmt|;
block|}
block|}
block|}
operator|*
name|levelOffset
operator|=
name|upsampleCount
expr_stmt|;
block|}
DECL|function|CopyLockableSurfaces
specifier|static
name|void
name|CopyLockableSurfaces
parameter_list|(
name|IDirect3DSurface9
modifier|*
name|dest
parameter_list|,
name|IDirect3DSurface9
modifier|*
name|source
parameter_list|)
block|{
name|D3DLOCKED_RECT
name|sourceLock
init|=
block|{
literal|0
block|}
decl_stmt|;
name|D3DLOCKED_RECT
name|destLock
init|=
block|{
literal|0
block|}
decl_stmt|;
name|source
operator|->
name|LockRect
argument_list|(
operator|&
name|sourceLock
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dest
operator|->
name|LockRect
argument_list|(
operator|&
name|destLock
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sourceLock
operator|.
name|pBits
operator|&&
name|destLock
operator|.
name|pBits
condition|)
block|{
name|D3DSURFACE_DESC
name|desc
decl_stmt|;
name|source
operator|->
name|GetDesc
argument_list|(
operator|&
name|desc
argument_list|)
expr_stmt|;
name|int
name|rows
init|=
name|dx
operator|::
name|IsCompressedFormat
argument_list|(
name|desc
operator|.
name|Format
argument_list|)
condition|?
name|desc
operator|.
name|Height
operator|/
literal|4
else|:
name|desc
operator|.
name|Height
decl_stmt|;
name|int
name|bytes
init|=
name|dx
operator|::
name|ComputeRowSize
argument_list|(
name|desc
operator|.
name|Format
argument_list|,
name|desc
operator|.
name|Width
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|bytes
operator|<=
name|sourceLock
operator|.
name|Pitch
operator|&&
name|bytes
operator|<=
name|destLock
operator|.
name|Pitch
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rows
condition|;
name|i
operator|++
control|)
block|{
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|destLock
operator|.
name|pBits
operator|+
name|destLock
operator|.
name|Pitch
operator|*
name|i
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sourceLock
operator|.
name|pBits
operator|+
name|sourceLock
operator|.
name|Pitch
operator|*
name|i
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
name|source
operator|->
name|UnlockRect
argument_list|()
expr_stmt|;
name|dest
operator|->
name|UnlockRect
argument_list|()
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
DECL|function|Image
name|Image
operator|::
name|Image
parameter_list|()
block|{
name|mWidth
operator|=
literal|0
expr_stmt|;
name|mHeight
operator|=
literal|0
expr_stmt|;
name|mInternalFormat
operator|=
name|GL_NONE
expr_stmt|;
name|mSurface
operator|=
name|NULL
expr_stmt|;
name|mDirty
operator|=
literal|false
expr_stmt|;
name|mD3DPool
operator|=
name|D3DPOOL_SYSTEMMEM
expr_stmt|;
name|mD3DFormat
operator|=
name|D3DFMT_UNKNOWN
expr_stmt|;
block|}
DECL|function|~Image
name|Image
operator|::
name|~
name|Image
parameter_list|()
block|{
if|if
condition|(
name|mSurface
condition|)
block|{
name|mSurface
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|redefine
name|bool
name|Image
operator|::
name|redefine
parameter_list|(
name|GLint
name|internalformat
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|bool
name|forceRelease
parameter_list|)
block|{
if|if
condition|(
name|mWidth
operator|!=
name|width
operator|||
name|mHeight
operator|!=
name|height
operator|||
name|mInternalFormat
operator|!=
name|internalformat
operator|||
name|forceRelease
condition|)
block|{
name|mWidth
operator|=
name|width
expr_stmt|;
name|mHeight
operator|=
name|height
expr_stmt|;
name|mInternalFormat
operator|=
name|internalformat
expr_stmt|;
comment|// compute the d3d format that will be used
name|mD3DFormat
operator|=
name|ConvertTextureInternalFormat
argument_list|(
name|internalformat
argument_list|)
expr_stmt|;
if|if
condition|(
name|mSurface
condition|)
block|{
name|mSurface
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mSurface
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|function|createSurface
name|void
name|Image
operator|::
name|createSurface
parameter_list|()
block|{
if|if
condition|(
name|mSurface
condition|)
block|{
return|return;
block|}
name|IDirect3DTexture9
modifier|*
name|newTexture
init|=
name|NULL
decl_stmt|;
name|IDirect3DSurface9
modifier|*
name|newSurface
init|=
name|NULL
decl_stmt|;
specifier|const
name|D3DPOOL
name|poolToUse
init|=
name|D3DPOOL_SYSTEMMEM
decl_stmt|;
specifier|const
name|D3DFORMAT
name|d3dFormat
init|=
name|getD3DFormat
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|d3dFormat
operator|!=
name|D3DFMT_INTZ
argument_list|)
expr_stmt|;
comment|// We should never get here for depth textures
if|if
condition|(
name|mWidth
operator|!=
literal|0
operator|&&
name|mHeight
operator|!=
literal|0
condition|)
block|{
name|int
name|levelToFetch
init|=
literal|0
decl_stmt|;
name|GLsizei
name|requestWidth
init|=
name|mWidth
decl_stmt|;
name|GLsizei
name|requestHeight
init|=
name|mHeight
decl_stmt|;
name|MakeValidSize
argument_list|(
literal|true
argument_list|,
name|IsCompressed
argument_list|(
name|mInternalFormat
argument_list|)
argument_list|,
operator|&
name|requestWidth
argument_list|,
operator|&
name|requestHeight
argument_list|,
operator|&
name|levelToFetch
argument_list|)
expr_stmt|;
name|HRESULT
name|result
init|=
name|getDevice
argument_list|()
operator|->
name|CreateTexture
argument_list|(
name|requestWidth
argument_list|,
name|requestHeight
argument_list|,
name|levelToFetch
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
name|d3dFormat
argument_list|,
name|poolToUse
argument_list|,
operator|&
name|newTexture
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|result
operator|==
name|D3DERR_OUTOFVIDEOMEMORY
operator|||
name|result
operator|==
name|E_OUTOFMEMORY
argument_list|)
expr_stmt|;
name|ERR
argument_list|(
literal|"Creating image surface failed."
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
name|newTexture
operator|->
name|GetSurfaceLevel
argument_list|(
name|levelToFetch
argument_list|,
operator|&
name|newSurface
argument_list|)
expr_stmt|;
name|newTexture
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
name|mSurface
operator|=
name|newSurface
expr_stmt|;
name|mDirty
operator|=
literal|false
expr_stmt|;
name|mD3DPool
operator|=
name|poolToUse
expr_stmt|;
block|}
DECL|function|lock
name|HRESULT
name|Image
operator|::
name|lock
parameter_list|(
name|D3DLOCKED_RECT
modifier|*
name|lockedRect
parameter_list|,
specifier|const
name|RECT
modifier|*
name|rect
parameter_list|)
block|{
name|createSurface
argument_list|()
expr_stmt|;
name|HRESULT
name|result
init|=
name|D3DERR_INVALIDCALL
decl_stmt|;
if|if
condition|(
name|mSurface
condition|)
block|{
name|result
operator|=
name|mSurface
operator|->
name|LockRect
argument_list|(
name|lockedRect
argument_list|,
name|rect
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|mDirty
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|function|unlock
name|void
name|Image
operator|::
name|unlock
parameter_list|()
block|{
if|if
condition|(
name|mSurface
condition|)
block|{
name|HRESULT
name|result
init|=
name|mSurface
operator|->
name|UnlockRect
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|isRenderableFormat
name|bool
name|Image
operator|::
name|isRenderableFormat
parameter_list|()
specifier|const
block|{
return|return
name|IsTextureFormatRenderable
argument_list|(
name|getD3DFormat
argument_list|()
argument_list|)
return|;
block|}
DECL|function|getD3DFormat
name|D3DFORMAT
name|Image
operator|::
name|getD3DFormat
parameter_list|()
specifier|const
block|{
comment|// this should only happen if the image hasn't been redefined first
comment|// which would be a bug by the caller
name|ASSERT
argument_list|(
name|mD3DFormat
operator|!=
name|D3DFMT_UNKNOWN
argument_list|)
expr_stmt|;
return|return
name|mD3DFormat
return|;
block|}
DECL|function|getSurface
name|IDirect3DSurface9
modifier|*
name|Image
operator|::
name|getSurface
parameter_list|()
block|{
name|createSurface
argument_list|()
expr_stmt|;
return|return
name|mSurface
return|;
block|}
DECL|function|setManagedSurface
name|void
name|Image
operator|::
name|setManagedSurface
parameter_list|(
name|IDirect3DSurface9
modifier|*
name|surface
parameter_list|)
block|{
name|D3DSURFACE_DESC
name|desc
decl_stmt|;
name|surface
operator|->
name|GetDesc
argument_list|(
operator|&
name|desc
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|desc
operator|.
name|Pool
operator|==
name|D3DPOOL_MANAGED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GLsizei
operator|)
name|desc
operator|.
name|Width
operator|==
name|mWidth
operator|&&
operator|(
name|GLsizei
operator|)
name|desc
operator|.
name|Height
operator|==
name|mHeight
condition|)
block|{
if|if
condition|(
name|mSurface
condition|)
block|{
name|CopyLockableSurfaces
argument_list|(
name|surface
argument_list|,
name|mSurface
argument_list|)
expr_stmt|;
name|mSurface
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
name|mSurface
operator|=
name|surface
expr_stmt|;
name|mD3DPool
operator|=
name|desc
operator|.
name|Pool
expr_stmt|;
block|}
block|}
DECL|function|updateSurface
name|void
name|Image
operator|::
name|updateSurface
parameter_list|(
name|IDirect3DSurface9
modifier|*
name|destSurface
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
name|IDirect3DSurface9
modifier|*
name|sourceSurface
init|=
name|getSurface
argument_list|()
decl_stmt|;
if|if
condition|(
name|sourceSurface
operator|&&
name|sourceSurface
operator|!=
name|destSurface
condition|)
block|{
name|RECT
name|rect
decl_stmt|;
name|rect
operator|.
name|left
operator|=
name|xoffset
expr_stmt|;
name|rect
operator|.
name|top
operator|=
name|yoffset
expr_stmt|;
name|rect
operator|.
name|right
operator|=
name|xoffset
operator|+
name|width
expr_stmt|;
name|rect
operator|.
name|bottom
operator|=
name|yoffset
operator|+
name|height
expr_stmt|;
name|POINT
name|point
init|=
block|{
name|rect
operator|.
name|left
block|,
name|rect
operator|.
name|top
block|}
decl_stmt|;
if|if
condition|(
name|mD3DPool
operator|==
name|D3DPOOL_MANAGED
condition|)
block|{
name|D3DSURFACE_DESC
name|desc
decl_stmt|;
name|sourceSurface
operator|->
name|GetDesc
argument_list|(
operator|&
name|desc
argument_list|)
expr_stmt|;
name|IDirect3DSurface9
modifier|*
name|surf
init|=
literal|0
decl_stmt|;
name|HRESULT
name|result
init|=
name|getDevice
argument_list|()
operator|->
name|CreateOffscreenPlainSurface
argument_list|(
name|desc
operator|.
name|Width
argument_list|,
name|desc
operator|.
name|Height
argument_list|,
name|desc
operator|.
name|Format
argument_list|,
name|D3DPOOL_SYSTEMMEM
argument_list|,
operator|&
name|surf
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|CopyLockableSurfaces
argument_list|(
name|surf
argument_list|,
name|sourceSurface
argument_list|)
expr_stmt|;
name|result
operator|=
name|getDevice
argument_list|()
operator|->
name|UpdateSurface
argument_list|(
name|surf
argument_list|,
operator|&
name|rect
argument_list|,
name|destSurface
argument_list|,
operator|&
name|point
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|surf
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// UpdateSurface: source must be SYSTEMMEM, dest must be DEFAULT pools
name|HRESULT
name|result
init|=
name|getDevice
argument_list|()
operator|->
name|UpdateSurface
argument_list|(
name|sourceSurface
argument_list|,
operator|&
name|rect
argument_list|,
name|destSurface
argument_list|,
operator|&
name|point
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Store the pixel rectangle designated by xoffset,yoffset,width,height with pixels stored as format/type at input
comment|// into the target pixel rectangle.
DECL|function|loadData
name|void
name|Image
operator|::
name|loadData
parameter_list|(
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLint
name|unpackAlignment
parameter_list|,
specifier|const
name|void
modifier|*
name|input
parameter_list|)
block|{
name|RECT
name|lockRect
init|=
block|{
name|xoffset
block|,
name|yoffset
block|,
name|xoffset
operator|+
name|width
block|,
name|yoffset
operator|+
name|height
block|}
decl_stmt|;
name|D3DLOCKED_RECT
name|locked
decl_stmt|;
name|HRESULT
name|result
init|=
name|lock
argument_list|(
operator|&
name|locked
argument_list|,
operator|&
name|lockRect
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return;
block|}
name|GLsizei
name|inputPitch
init|=
name|ComputePitch
argument_list|(
name|width
argument_list|,
name|mInternalFormat
argument_list|,
name|unpackAlignment
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|mInternalFormat
condition|)
block|{
case|case
name|GL_ALPHA8_EXT
case|:
if|if
condition|(
name|supportsSSE2
argument_list|()
condition|)
block|{
name|loadAlphaDataSSE2
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|inputPitch
argument_list|,
name|input
argument_list|,
name|locked
operator|.
name|Pitch
argument_list|,
name|locked
operator|.
name|pBits
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|loadAlphaData
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|inputPitch
argument_list|,
name|input
argument_list|,
name|locked
operator|.
name|Pitch
argument_list|,
name|locked
operator|.
name|pBits
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|GL_LUMINANCE8_EXT
case|:
name|loadLuminanceData
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|inputPitch
argument_list|,
name|input
argument_list|,
name|locked
operator|.
name|Pitch
argument_list|,
name|locked
operator|.
name|pBits
argument_list|,
name|getD3DFormat
argument_list|()
operator|==
name|D3DFMT_L8
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_ALPHA32F_EXT
case|:
name|loadAlphaFloatData
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|inputPitch
argument_list|,
name|input
argument_list|,
name|locked
operator|.
name|Pitch
argument_list|,
name|locked
operator|.
name|pBits
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_LUMINANCE32F_EXT
case|:
name|loadLuminanceFloatData
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|inputPitch
argument_list|,
name|input
argument_list|,
name|locked
operator|.
name|Pitch
argument_list|,
name|locked
operator|.
name|pBits
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_ALPHA16F_EXT
case|:
name|loadAlphaHalfFloatData
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|inputPitch
argument_list|,
name|input
argument_list|,
name|locked
operator|.
name|Pitch
argument_list|,
name|locked
operator|.
name|pBits
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_LUMINANCE16F_EXT
case|:
name|loadLuminanceHalfFloatData
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|inputPitch
argument_list|,
name|input
argument_list|,
name|locked
operator|.
name|Pitch
argument_list|,
name|locked
operator|.
name|pBits
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_LUMINANCE8_ALPHA8_EXT
case|:
name|loadLuminanceAlphaData
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|inputPitch
argument_list|,
name|input
argument_list|,
name|locked
operator|.
name|Pitch
argument_list|,
name|locked
operator|.
name|pBits
argument_list|,
name|getD3DFormat
argument_list|()
operator|==
name|D3DFMT_A8L8
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_LUMINANCE_ALPHA32F_EXT
case|:
name|loadLuminanceAlphaFloatData
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|inputPitch
argument_list|,
name|input
argument_list|,
name|locked
operator|.
name|Pitch
argument_list|,
name|locked
operator|.
name|pBits
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_LUMINANCE_ALPHA16F_EXT
case|:
name|loadLuminanceAlphaHalfFloatData
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|inputPitch
argument_list|,
name|input
argument_list|,
name|locked
operator|.
name|Pitch
argument_list|,
name|locked
operator|.
name|pBits
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_RGB8_OES
case|:
name|loadRGBUByteData
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|inputPitch
argument_list|,
name|input
argument_list|,
name|locked
operator|.
name|Pitch
argument_list|,
name|locked
operator|.
name|pBits
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_RGB565
case|:
name|loadRGB565Data
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|inputPitch
argument_list|,
name|input
argument_list|,
name|locked
operator|.
name|Pitch
argument_list|,
name|locked
operator|.
name|pBits
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_RGBA8_OES
case|:
if|if
condition|(
name|supportsSSE2
argument_list|()
condition|)
block|{
name|loadRGBAUByteDataSSE2
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|inputPitch
argument_list|,
name|input
argument_list|,
name|locked
operator|.
name|Pitch
argument_list|,
name|locked
operator|.
name|pBits
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|loadRGBAUByteData
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|inputPitch
argument_list|,
name|input
argument_list|,
name|locked
operator|.
name|Pitch
argument_list|,
name|locked
operator|.
name|pBits
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|GL_RGBA4
case|:
name|loadRGBA4444Data
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|inputPitch
argument_list|,
name|input
argument_list|,
name|locked
operator|.
name|Pitch
argument_list|,
name|locked
operator|.
name|pBits
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_RGB5_A1
case|:
name|loadRGBA5551Data
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|inputPitch
argument_list|,
name|input
argument_list|,
name|locked
operator|.
name|Pitch
argument_list|,
name|locked
operator|.
name|pBits
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_BGRA8_EXT
case|:
name|loadBGRAData
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|inputPitch
argument_list|,
name|input
argument_list|,
name|locked
operator|.
name|Pitch
argument_list|,
name|locked
operator|.
name|pBits
argument_list|)
expr_stmt|;
break|break;
comment|// float textures are converted to RGBA, not BGRA, as they're stored that way in D3D
case|case
name|GL_RGB32F_EXT
case|:
name|loadRGBFloatData
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|inputPitch
argument_list|,
name|input
argument_list|,
name|locked
operator|.
name|Pitch
argument_list|,
name|locked
operator|.
name|pBits
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_RGB16F_EXT
case|:
name|loadRGBHalfFloatData
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|inputPitch
argument_list|,
name|input
argument_list|,
name|locked
operator|.
name|Pitch
argument_list|,
name|locked
operator|.
name|pBits
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_RGBA32F_EXT
case|:
name|loadRGBAFloatData
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|inputPitch
argument_list|,
name|input
argument_list|,
name|locked
operator|.
name|Pitch
argument_list|,
name|locked
operator|.
name|pBits
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_RGBA16F_EXT
case|:
name|loadRGBAHalfFloatData
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|inputPitch
argument_list|,
name|input
argument_list|,
name|locked
operator|.
name|Pitch
argument_list|,
name|locked
operator|.
name|pBits
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
name|unlock
argument_list|()
expr_stmt|;
block|}
DECL|function|loadAlphaData
name|void
name|Image
operator|::
name|loadAlphaData
parameter_list|(
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|int
name|inputPitch
parameter_list|,
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|outputPitch
parameter_list|,
name|void
modifier|*
name|output
parameter_list|)
specifier|const
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|source
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
modifier|*
name|dest
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
name|source
operator|=
cast|static_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|input
argument_list|)
operator|+
name|y
operator|*
name|inputPitch
expr_stmt|;
name|dest
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|output
argument_list|)
operator|+
name|y
operator|*
name|outputPitch
expr_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|3
index|]
operator|=
name|source
index|[
name|x
index|]
expr_stmt|;
block|}
block|}
block|}
DECL|function|loadAlphaFloatData
name|void
name|Image
operator|::
name|loadAlphaFloatData
parameter_list|(
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|int
name|inputPitch
parameter_list|,
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|outputPitch
parameter_list|,
name|void
modifier|*
name|output
parameter_list|)
specifier|const
block|{
specifier|const
name|float
modifier|*
name|source
init|=
name|NULL
decl_stmt|;
name|float
modifier|*
name|dest
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
name|source
operator|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|float
operator|*
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|input
argument_list|)
operator|+
name|y
operator|*
name|inputPitch
argument_list|)
expr_stmt|;
name|dest
operator|=
cast|reinterpret_cast
argument_list|<
name|float
operator|*
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|output
argument_list|)
operator|+
name|y
operator|*
name|outputPitch
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|3
index|]
operator|=
name|source
index|[
name|x
index|]
expr_stmt|;
block|}
block|}
block|}
DECL|function|loadAlphaHalfFloatData
name|void
name|Image
operator|::
name|loadAlphaHalfFloatData
parameter_list|(
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|int
name|inputPitch
parameter_list|,
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|outputPitch
parameter_list|,
name|void
modifier|*
name|output
parameter_list|)
specifier|const
block|{
specifier|const
name|unsigned
name|short
modifier|*
name|source
init|=
name|NULL
decl_stmt|;
name|unsigned
name|short
modifier|*
name|dest
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
name|source
operator|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|short
operator|*
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|input
argument_list|)
operator|+
name|y
operator|*
name|inputPitch
argument_list|)
expr_stmt|;
name|dest
operator|=
cast|reinterpret_cast
argument_list|<
name|unsigned
name|short
operator|*
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|output
argument_list|)
operator|+
name|y
operator|*
name|outputPitch
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|3
index|]
operator|=
name|source
index|[
name|x
index|]
expr_stmt|;
block|}
block|}
block|}
DECL|function|loadLuminanceData
name|void
name|Image
operator|::
name|loadLuminanceData
parameter_list|(
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|int
name|inputPitch
parameter_list|,
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|outputPitch
parameter_list|,
name|void
modifier|*
name|output
parameter_list|,
name|bool
name|native
parameter_list|)
specifier|const
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|source
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
modifier|*
name|dest
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
name|source
operator|=
cast|static_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|input
argument_list|)
operator|+
name|y
operator|*
name|inputPitch
expr_stmt|;
name|dest
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|output
argument_list|)
operator|+
name|y
operator|*
name|outputPitch
expr_stmt|;
if|if
condition|(
operator|!
name|native
condition|)
comment|// BGRA8 destination format
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|0
index|]
operator|=
name|source
index|[
name|x
index|]
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|1
index|]
operator|=
name|source
index|[
name|x
index|]
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|2
index|]
operator|=
name|source
index|[
name|x
index|]
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|3
index|]
operator|=
literal|0xFF
expr_stmt|;
block|}
block|}
else|else
comment|// L8 destination format
block|{
name|memcpy
argument_list|(
name|dest
argument_list|,
name|source
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|loadLuminanceFloatData
name|void
name|Image
operator|::
name|loadLuminanceFloatData
parameter_list|(
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|int
name|inputPitch
parameter_list|,
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|outputPitch
parameter_list|,
name|void
modifier|*
name|output
parameter_list|)
specifier|const
block|{
specifier|const
name|float
modifier|*
name|source
init|=
name|NULL
decl_stmt|;
name|float
modifier|*
name|dest
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
name|source
operator|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|float
operator|*
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|input
argument_list|)
operator|+
name|y
operator|*
name|inputPitch
argument_list|)
expr_stmt|;
name|dest
operator|=
cast|reinterpret_cast
argument_list|<
name|float
operator|*
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|output
argument_list|)
operator|+
name|y
operator|*
name|outputPitch
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|0
index|]
operator|=
name|source
index|[
name|x
index|]
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|1
index|]
operator|=
name|source
index|[
name|x
index|]
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|2
index|]
operator|=
name|source
index|[
name|x
index|]
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|3
index|]
operator|=
literal|1.0f
expr_stmt|;
block|}
block|}
block|}
DECL|function|loadLuminanceHalfFloatData
name|void
name|Image
operator|::
name|loadLuminanceHalfFloatData
parameter_list|(
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|int
name|inputPitch
parameter_list|,
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|outputPitch
parameter_list|,
name|void
modifier|*
name|output
parameter_list|)
specifier|const
block|{
specifier|const
name|unsigned
name|short
modifier|*
name|source
init|=
name|NULL
decl_stmt|;
name|unsigned
name|short
modifier|*
name|dest
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
name|source
operator|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|short
operator|*
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|input
argument_list|)
operator|+
name|y
operator|*
name|inputPitch
argument_list|)
expr_stmt|;
name|dest
operator|=
cast|reinterpret_cast
argument_list|<
name|unsigned
name|short
operator|*
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|output
argument_list|)
operator|+
name|y
operator|*
name|outputPitch
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|0
index|]
operator|=
name|source
index|[
name|x
index|]
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|1
index|]
operator|=
name|source
index|[
name|x
index|]
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|2
index|]
operator|=
name|source
index|[
name|x
index|]
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|3
index|]
operator|=
literal|0x3C00
expr_stmt|;
comment|// SEEEEEMMMMMMMMMM, S = 0, E = 15, M = 0: 16bit flpt representation of 1
block|}
block|}
block|}
DECL|function|loadLuminanceAlphaData
name|void
name|Image
operator|::
name|loadLuminanceAlphaData
parameter_list|(
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|int
name|inputPitch
parameter_list|,
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|outputPitch
parameter_list|,
name|void
modifier|*
name|output
parameter_list|,
name|bool
name|native
parameter_list|)
specifier|const
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|source
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
modifier|*
name|dest
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
name|source
operator|=
cast|static_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|input
argument_list|)
operator|+
name|y
operator|*
name|inputPitch
expr_stmt|;
name|dest
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|output
argument_list|)
operator|+
name|y
operator|*
name|outputPitch
expr_stmt|;
if|if
condition|(
operator|!
name|native
condition|)
comment|// BGRA8 destination format
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|0
index|]
operator|=
name|source
index|[
literal|2
operator|*
name|x
operator|+
literal|0
index|]
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|1
index|]
operator|=
name|source
index|[
literal|2
operator|*
name|x
operator|+
literal|0
index|]
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|2
index|]
operator|=
name|source
index|[
literal|2
operator|*
name|x
operator|+
literal|0
index|]
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|3
index|]
operator|=
name|source
index|[
literal|2
operator|*
name|x
operator|+
literal|1
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|memcpy
argument_list|(
name|dest
argument_list|,
name|source
argument_list|,
name|width
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|loadLuminanceAlphaFloatData
name|void
name|Image
operator|::
name|loadLuminanceAlphaFloatData
parameter_list|(
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|int
name|inputPitch
parameter_list|,
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|outputPitch
parameter_list|,
name|void
modifier|*
name|output
parameter_list|)
specifier|const
block|{
specifier|const
name|float
modifier|*
name|source
init|=
name|NULL
decl_stmt|;
name|float
modifier|*
name|dest
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
name|source
operator|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|float
operator|*
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|input
argument_list|)
operator|+
name|y
operator|*
name|inputPitch
argument_list|)
expr_stmt|;
name|dest
operator|=
cast|reinterpret_cast
argument_list|<
name|float
operator|*
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|output
argument_list|)
operator|+
name|y
operator|*
name|outputPitch
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|0
index|]
operator|=
name|source
index|[
literal|2
operator|*
name|x
operator|+
literal|0
index|]
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|1
index|]
operator|=
name|source
index|[
literal|2
operator|*
name|x
operator|+
literal|0
index|]
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|2
index|]
operator|=
name|source
index|[
literal|2
operator|*
name|x
operator|+
literal|0
index|]
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|3
index|]
operator|=
name|source
index|[
literal|2
operator|*
name|x
operator|+
literal|1
index|]
expr_stmt|;
block|}
block|}
block|}
DECL|function|loadLuminanceAlphaHalfFloatData
name|void
name|Image
operator|::
name|loadLuminanceAlphaHalfFloatData
parameter_list|(
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|int
name|inputPitch
parameter_list|,
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|outputPitch
parameter_list|,
name|void
modifier|*
name|output
parameter_list|)
specifier|const
block|{
specifier|const
name|unsigned
name|short
modifier|*
name|source
init|=
name|NULL
decl_stmt|;
name|unsigned
name|short
modifier|*
name|dest
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
name|source
operator|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|short
operator|*
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|input
argument_list|)
operator|+
name|y
operator|*
name|inputPitch
argument_list|)
expr_stmt|;
name|dest
operator|=
cast|reinterpret_cast
argument_list|<
name|unsigned
name|short
operator|*
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|output
argument_list|)
operator|+
name|y
operator|*
name|outputPitch
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|0
index|]
operator|=
name|source
index|[
literal|2
operator|*
name|x
operator|+
literal|0
index|]
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|1
index|]
operator|=
name|source
index|[
literal|2
operator|*
name|x
operator|+
literal|0
index|]
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|2
index|]
operator|=
name|source
index|[
literal|2
operator|*
name|x
operator|+
literal|0
index|]
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|3
index|]
operator|=
name|source
index|[
literal|2
operator|*
name|x
operator|+
literal|1
index|]
expr_stmt|;
block|}
block|}
block|}
DECL|function|loadRGBUByteData
name|void
name|Image
operator|::
name|loadRGBUByteData
parameter_list|(
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|int
name|inputPitch
parameter_list|,
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|outputPitch
parameter_list|,
name|void
modifier|*
name|output
parameter_list|)
specifier|const
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|source
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
modifier|*
name|dest
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
name|source
operator|=
cast|static_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|input
argument_list|)
operator|+
name|y
operator|*
name|inputPitch
expr_stmt|;
name|dest
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|output
argument_list|)
operator|+
name|y
operator|*
name|outputPitch
expr_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|0
index|]
operator|=
name|source
index|[
name|x
operator|*
literal|3
operator|+
literal|2
index|]
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|1
index|]
operator|=
name|source
index|[
name|x
operator|*
literal|3
operator|+
literal|1
index|]
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|2
index|]
operator|=
name|source
index|[
name|x
operator|*
literal|3
operator|+
literal|0
index|]
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|3
index|]
operator|=
literal|0xFF
expr_stmt|;
block|}
block|}
block|}
DECL|function|loadRGB565Data
name|void
name|Image
operator|::
name|loadRGB565Data
parameter_list|(
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|int
name|inputPitch
parameter_list|,
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|outputPitch
parameter_list|,
name|void
modifier|*
name|output
parameter_list|)
specifier|const
block|{
specifier|const
name|unsigned
name|short
modifier|*
name|source
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
modifier|*
name|dest
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
name|source
operator|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|short
operator|*
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|input
argument_list|)
operator|+
name|y
operator|*
name|inputPitch
argument_list|)
expr_stmt|;
name|dest
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|output
argument_list|)
operator|+
name|y
operator|*
name|outputPitch
expr_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
name|unsigned
name|short
name|rgba
init|=
name|source
index|[
name|x
index|]
decl_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|0
index|]
operator|=
operator|(
operator|(
name|rgba
operator|&
literal|0x001F
operator|)
operator|<<
literal|3
operator|)
operator||
operator|(
operator|(
name|rgba
operator|&
literal|0x001F
operator|)
operator|>>
literal|2
operator|)
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|1
index|]
operator|=
operator|(
operator|(
name|rgba
operator|&
literal|0x07E0
operator|)
operator|>>
literal|3
operator|)
operator||
operator|(
operator|(
name|rgba
operator|&
literal|0x07E0
operator|)
operator|>>
literal|9
operator|)
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|2
index|]
operator|=
operator|(
operator|(
name|rgba
operator|&
literal|0xF800
operator|)
operator|>>
literal|8
operator|)
operator||
operator|(
operator|(
name|rgba
operator|&
literal|0xF800
operator|)
operator|>>
literal|13
operator|)
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|3
index|]
operator|=
literal|0xFF
expr_stmt|;
block|}
block|}
block|}
DECL|function|loadRGBFloatData
name|void
name|Image
operator|::
name|loadRGBFloatData
parameter_list|(
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|int
name|inputPitch
parameter_list|,
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|outputPitch
parameter_list|,
name|void
modifier|*
name|output
parameter_list|)
specifier|const
block|{
specifier|const
name|float
modifier|*
name|source
init|=
name|NULL
decl_stmt|;
name|float
modifier|*
name|dest
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
name|source
operator|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|float
operator|*
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|input
argument_list|)
operator|+
name|y
operator|*
name|inputPitch
argument_list|)
expr_stmt|;
name|dest
operator|=
cast|reinterpret_cast
argument_list|<
name|float
operator|*
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|output
argument_list|)
operator|+
name|y
operator|*
name|outputPitch
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|0
index|]
operator|=
name|source
index|[
name|x
operator|*
literal|3
operator|+
literal|0
index|]
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|1
index|]
operator|=
name|source
index|[
name|x
operator|*
literal|3
operator|+
literal|1
index|]
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|2
index|]
operator|=
name|source
index|[
name|x
operator|*
literal|3
operator|+
literal|2
index|]
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|3
index|]
operator|=
literal|1.0f
expr_stmt|;
block|}
block|}
block|}
DECL|function|loadRGBHalfFloatData
name|void
name|Image
operator|::
name|loadRGBHalfFloatData
parameter_list|(
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|int
name|inputPitch
parameter_list|,
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|outputPitch
parameter_list|,
name|void
modifier|*
name|output
parameter_list|)
specifier|const
block|{
specifier|const
name|unsigned
name|short
modifier|*
name|source
init|=
name|NULL
decl_stmt|;
name|unsigned
name|short
modifier|*
name|dest
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
name|source
operator|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|short
operator|*
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|input
argument_list|)
operator|+
name|y
operator|*
name|inputPitch
argument_list|)
expr_stmt|;
name|dest
operator|=
cast|reinterpret_cast
argument_list|<
name|unsigned
name|short
operator|*
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|output
argument_list|)
operator|+
name|y
operator|*
name|outputPitch
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|0
index|]
operator|=
name|source
index|[
name|x
operator|*
literal|3
operator|+
literal|0
index|]
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|1
index|]
operator|=
name|source
index|[
name|x
operator|*
literal|3
operator|+
literal|1
index|]
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|2
index|]
operator|=
name|source
index|[
name|x
operator|*
literal|3
operator|+
literal|2
index|]
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|3
index|]
operator|=
literal|0x3C00
expr_stmt|;
comment|// SEEEEEMMMMMMMMMM, S = 0, E = 15, M = 0: 16bit flpt representation of 1
block|}
block|}
block|}
DECL|function|loadRGBAUByteData
name|void
name|Image
operator|::
name|loadRGBAUByteData
parameter_list|(
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|int
name|inputPitch
parameter_list|,
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|outputPitch
parameter_list|,
name|void
modifier|*
name|output
parameter_list|)
specifier|const
block|{
specifier|const
name|unsigned
name|int
modifier|*
name|source
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
modifier|*
name|dest
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
name|source
operator|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|int
operator|*
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|input
argument_list|)
operator|+
name|y
operator|*
name|inputPitch
argument_list|)
expr_stmt|;
name|dest
operator|=
cast|reinterpret_cast
argument_list|<
name|unsigned
name|int
operator|*
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|output
argument_list|)
operator|+
name|y
operator|*
name|outputPitch
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
name|unsigned
name|int
name|rgba
init|=
name|source
index|[
name|x
index|]
decl_stmt|;
name|dest
index|[
name|x
index|]
operator|=
operator|(
name|_rotl
argument_list|(
name|rgba
argument_list|,
literal|16
argument_list|)
operator|&
literal|0x00ff00ff
operator|)
operator||
operator|(
name|rgba
operator|&
literal|0xff00ff00
operator|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|loadRGBA4444Data
name|void
name|Image
operator|::
name|loadRGBA4444Data
parameter_list|(
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|int
name|inputPitch
parameter_list|,
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|outputPitch
parameter_list|,
name|void
modifier|*
name|output
parameter_list|)
specifier|const
block|{
specifier|const
name|unsigned
name|short
modifier|*
name|source
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
modifier|*
name|dest
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
name|source
operator|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|short
operator|*
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|input
argument_list|)
operator|+
name|y
operator|*
name|inputPitch
argument_list|)
expr_stmt|;
name|dest
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|output
argument_list|)
operator|+
name|y
operator|*
name|outputPitch
expr_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
name|unsigned
name|short
name|rgba
init|=
name|source
index|[
name|x
index|]
decl_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|0
index|]
operator|=
operator|(
operator|(
name|rgba
operator|&
literal|0x00F0
operator|)
operator|<<
literal|0
operator|)
operator||
operator|(
operator|(
name|rgba
operator|&
literal|0x00F0
operator|)
operator|>>
literal|4
operator|)
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|1
index|]
operator|=
operator|(
operator|(
name|rgba
operator|&
literal|0x0F00
operator|)
operator|>>
literal|4
operator|)
operator||
operator|(
operator|(
name|rgba
operator|&
literal|0x0F00
operator|)
operator|>>
literal|8
operator|)
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|2
index|]
operator|=
operator|(
operator|(
name|rgba
operator|&
literal|0xF000
operator|)
operator|>>
literal|8
operator|)
operator||
operator|(
operator|(
name|rgba
operator|&
literal|0xF000
operator|)
operator|>>
literal|12
operator|)
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|3
index|]
operator|=
operator|(
operator|(
name|rgba
operator|&
literal|0x000F
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|rgba
operator|&
literal|0x000F
operator|)
operator|>>
literal|0
operator|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|loadRGBA5551Data
name|void
name|Image
operator|::
name|loadRGBA5551Data
parameter_list|(
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|int
name|inputPitch
parameter_list|,
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|outputPitch
parameter_list|,
name|void
modifier|*
name|output
parameter_list|)
specifier|const
block|{
specifier|const
name|unsigned
name|short
modifier|*
name|source
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
modifier|*
name|dest
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
name|source
operator|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|short
operator|*
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|input
argument_list|)
operator|+
name|y
operator|*
name|inputPitch
argument_list|)
expr_stmt|;
name|dest
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|output
argument_list|)
operator|+
name|y
operator|*
name|outputPitch
expr_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
name|unsigned
name|short
name|rgba
init|=
name|source
index|[
name|x
index|]
decl_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|0
index|]
operator|=
operator|(
operator|(
name|rgba
operator|&
literal|0x003E
operator|)
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|rgba
operator|&
literal|0x003E
operator|)
operator|>>
literal|3
operator|)
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|1
index|]
operator|=
operator|(
operator|(
name|rgba
operator|&
literal|0x07C0
operator|)
operator|>>
literal|3
operator|)
operator||
operator|(
operator|(
name|rgba
operator|&
literal|0x07C0
operator|)
operator|>>
literal|8
operator|)
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|2
index|]
operator|=
operator|(
operator|(
name|rgba
operator|&
literal|0xF800
operator|)
operator|>>
literal|8
operator|)
operator||
operator|(
operator|(
name|rgba
operator|&
literal|0xF800
operator|)
operator|>>
literal|13
operator|)
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|x
operator|+
literal|3
index|]
operator|=
operator|(
name|rgba
operator|&
literal|0x0001
operator|)
condition|?
literal|0xFF
else|:
literal|0
expr_stmt|;
block|}
block|}
block|}
DECL|function|loadRGBAFloatData
name|void
name|Image
operator|::
name|loadRGBAFloatData
parameter_list|(
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|int
name|inputPitch
parameter_list|,
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|outputPitch
parameter_list|,
name|void
modifier|*
name|output
parameter_list|)
specifier|const
block|{
specifier|const
name|float
modifier|*
name|source
init|=
name|NULL
decl_stmt|;
name|float
modifier|*
name|dest
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
name|source
operator|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|float
operator|*
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|input
argument_list|)
operator|+
name|y
operator|*
name|inputPitch
argument_list|)
expr_stmt|;
name|dest
operator|=
cast|reinterpret_cast
argument_list|<
name|float
operator|*
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|output
argument_list|)
operator|+
name|y
operator|*
name|outputPitch
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dest
argument_list|,
name|source
argument_list|,
name|width
operator|*
literal|16
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|loadRGBAHalfFloatData
name|void
name|Image
operator|::
name|loadRGBAHalfFloatData
parameter_list|(
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|int
name|inputPitch
parameter_list|,
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|outputPitch
parameter_list|,
name|void
modifier|*
name|output
parameter_list|)
specifier|const
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|source
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
modifier|*
name|dest
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
name|source
operator|=
cast|static_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|input
argument_list|)
operator|+
name|y
operator|*
name|inputPitch
expr_stmt|;
name|dest
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|output
argument_list|)
operator|+
name|y
operator|*
name|outputPitch
expr_stmt|;
name|memcpy
argument_list|(
name|dest
argument_list|,
name|source
argument_list|,
name|width
operator|*
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|loadBGRAData
name|void
name|Image
operator|::
name|loadBGRAData
parameter_list|(
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|int
name|inputPitch
parameter_list|,
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|outputPitch
parameter_list|,
name|void
modifier|*
name|output
parameter_list|)
specifier|const
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|source
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
modifier|*
name|dest
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
name|source
operator|=
cast|static_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|input
argument_list|)
operator|+
name|y
operator|*
name|inputPitch
expr_stmt|;
name|dest
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|output
argument_list|)
operator|+
name|y
operator|*
name|outputPitch
expr_stmt|;
name|memcpy
argument_list|(
name|dest
argument_list|,
name|source
argument_list|,
name|width
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|loadCompressedData
name|void
name|Image
operator|::
name|loadCompressedData
parameter_list|(
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
specifier|const
name|void
modifier|*
name|input
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|xoffset
operator|%
literal|4
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|yoffset
operator|%
literal|4
operator|==
literal|0
argument_list|)
expr_stmt|;
name|RECT
name|lockRect
init|=
block|{
name|xoffset
block|,
name|yoffset
block|,
name|xoffset
operator|+
name|width
block|,
name|yoffset
operator|+
name|height
block|}
decl_stmt|;
name|D3DLOCKED_RECT
name|locked
decl_stmt|;
name|HRESULT
name|result
init|=
name|lock
argument_list|(
operator|&
name|locked
argument_list|,
operator|&
name|lockRect
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return;
block|}
name|GLsizei
name|inputSize
init|=
name|ComputeCompressedSize
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|mInternalFormat
argument_list|)
decl_stmt|;
name|GLsizei
name|inputPitch
init|=
name|ComputeCompressedPitch
argument_list|(
name|width
argument_list|,
name|mInternalFormat
argument_list|)
decl_stmt|;
name|int
name|rows
init|=
name|inputSize
operator|/
name|inputPitch
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rows
condition|;
operator|++
name|i
control|)
block|{
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|BYTE
operator|*
operator|)
name|locked
operator|.
name|pBits
operator|+
name|i
operator|*
name|locked
operator|.
name|Pitch
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|BYTE
operator|*
operator|)
name|input
operator|+
name|i
operator|*
name|inputPitch
operator|)
argument_list|,
name|inputPitch
argument_list|)
expr_stmt|;
block|}
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|// This implements glCopyTex[Sub]Image2D for non-renderable internal texture formats and incomplete textures
DECL|function|copy
name|void
name|Image
operator|::
name|copy
parameter_list|(
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|IDirect3DSurface9
modifier|*
name|renderTarget
parameter_list|)
block|{
name|IDirect3DDevice9
modifier|*
name|device
init|=
name|getDevice
argument_list|()
decl_stmt|;
name|IDirect3DSurface9
modifier|*
name|renderTargetData
init|=
name|NULL
decl_stmt|;
name|D3DSURFACE_DESC
name|description
decl_stmt|;
name|renderTarget
operator|->
name|GetDesc
argument_list|(
operator|&
name|description
argument_list|)
expr_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateOffscreenPlainSurface
argument_list|(
name|description
operator|.
name|Width
argument_list|,
name|description
operator|.
name|Height
argument_list|,
name|description
operator|.
name|Format
argument_list|,
name|D3DPOOL_SYSTEMMEM
argument_list|,
operator|&
name|renderTargetData
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not create matching destination surface."
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
name|result
operator|=
name|device
operator|->
name|GetRenderTargetData
argument_list|(
name|renderTarget
argument_list|,
name|renderTargetData
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"GetRenderTargetData unexpectedly failed."
argument_list|)
expr_stmt|;
name|renderTargetData
operator|->
name|Release
argument_list|()
expr_stmt|;
return|return
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
name|RECT
name|sourceRect
init|=
block|{
name|x
block|,
name|y
block|,
name|x
operator|+
name|width
block|,
name|y
operator|+
name|height
block|}
decl_stmt|;
name|RECT
name|destRect
init|=
block|{
name|xoffset
block|,
name|yoffset
block|,
name|xoffset
operator|+
name|width
block|,
name|yoffset
operator|+
name|height
block|}
decl_stmt|;
name|D3DLOCKED_RECT
name|sourceLock
init|=
block|{
literal|0
block|}
decl_stmt|;
name|result
operator|=
name|renderTargetData
operator|->
name|LockRect
argument_list|(
operator|&
name|sourceLock
argument_list|,
operator|&
name|sourceRect
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to lock the source surface (rectangle might be invalid)."
argument_list|)
expr_stmt|;
name|renderTargetData
operator|->
name|Release
argument_list|()
expr_stmt|;
return|return
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
name|D3DLOCKED_RECT
name|destLock
init|=
block|{
literal|0
block|}
decl_stmt|;
name|result
operator|=
name|lock
argument_list|(
operator|&
name|destLock
argument_list|,
operator|&
name|destRect
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to lock the destination surface (rectangle might be invalid)."
argument_list|)
expr_stmt|;
name|renderTargetData
operator|->
name|UnlockRect
argument_list|()
expr_stmt|;
name|renderTargetData
operator|->
name|Release
argument_list|()
expr_stmt|;
return|return
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
if|if
condition|(
name|destLock
operator|.
name|pBits
operator|&&
name|sourceLock
operator|.
name|pBits
condition|)
block|{
name|unsigned
name|char
modifier|*
name|source
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|sourceLock
operator|.
name|pBits
decl_stmt|;
name|unsigned
name|char
modifier|*
name|dest
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|destLock
operator|.
name|pBits
decl_stmt|;
switch|switch
condition|(
name|description
operator|.
name|Format
condition|)
block|{
case|case
name|D3DFMT_X8R8G8B8
case|:
case|case
name|D3DFMT_A8R8G8B8
case|:
switch|switch
condition|(
name|getD3DFormat
argument_list|()
condition|)
block|{
case|case
name|D3DFMT_X8R8G8B8
case|:
case|case
name|D3DFMT_A8R8G8B8
case|:
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
name|memcpy
argument_list|(
name|dest
argument_list|,
name|source
argument_list|,
literal|4
operator|*
name|width
argument_list|)
expr_stmt|;
name|source
operator|+=
name|sourceLock
operator|.
name|Pitch
expr_stmt|;
name|dest
operator|+=
name|destLock
operator|.
name|Pitch
expr_stmt|;
block|}
break|break;
case|case
name|D3DFMT_L8
case|:
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
name|dest
index|[
name|x
index|]
operator|=
name|source
index|[
name|x
operator|*
literal|4
operator|+
literal|2
index|]
expr_stmt|;
block|}
name|source
operator|+=
name|sourceLock
operator|.
name|Pitch
expr_stmt|;
name|dest
operator|+=
name|destLock
operator|.
name|Pitch
expr_stmt|;
block|}
break|break;
case|case
name|D3DFMT_A8L8
case|:
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
name|dest
index|[
name|x
operator|*
literal|2
operator|+
literal|0
index|]
operator|=
name|source
index|[
name|x
operator|*
literal|4
operator|+
literal|2
index|]
expr_stmt|;
name|dest
index|[
name|x
operator|*
literal|2
operator|+
literal|1
index|]
operator|=
name|source
index|[
name|x
operator|*
literal|4
operator|+
literal|3
index|]
expr_stmt|;
block|}
name|source
operator|+=
name|sourceLock
operator|.
name|Pitch
expr_stmt|;
name|dest
operator|+=
name|destLock
operator|.
name|Pitch
expr_stmt|;
block|}
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|D3DFMT_R5G6B5
case|:
switch|switch
condition|(
name|getD3DFormat
argument_list|()
condition|)
block|{
case|case
name|D3DFMT_X8R8G8B8
case|:
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
name|unsigned
name|short
name|rgb
init|=
operator|(
operator|(
name|unsigned
name|short
operator|*
operator|)
name|source
operator|)
index|[
name|x
index|]
decl_stmt|;
name|unsigned
name|char
name|red
init|=
operator|(
name|rgb
operator|&
literal|0xF800
operator|)
operator|>>
literal|8
decl_stmt|;
name|unsigned
name|char
name|green
init|=
operator|(
name|rgb
operator|&
literal|0x07E0
operator|)
operator|>>
literal|3
decl_stmt|;
name|unsigned
name|char
name|blue
init|=
operator|(
name|rgb
operator|&
literal|0x001F
operator|)
operator|<<
literal|3
decl_stmt|;
name|dest
index|[
name|x
operator|+
literal|0
index|]
operator|=
name|blue
operator||
operator|(
name|blue
operator|>>
literal|5
operator|)
expr_stmt|;
name|dest
index|[
name|x
operator|+
literal|1
index|]
operator|=
name|green
operator||
operator|(
name|green
operator|>>
literal|6
operator|)
expr_stmt|;
name|dest
index|[
name|x
operator|+
literal|2
index|]
operator|=
name|red
operator||
operator|(
name|red
operator|>>
literal|5
operator|)
expr_stmt|;
name|dest
index|[
name|x
operator|+
literal|3
index|]
operator|=
literal|0xFF
expr_stmt|;
block|}
name|source
operator|+=
name|sourceLock
operator|.
name|Pitch
expr_stmt|;
name|dest
operator|+=
name|destLock
operator|.
name|Pitch
expr_stmt|;
block|}
break|break;
case|case
name|D3DFMT_L8
case|:
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
name|unsigned
name|char
name|red
init|=
name|source
index|[
name|x
operator|*
literal|2
operator|+
literal|1
index|]
operator|&
literal|0xF8
decl_stmt|;
name|dest
index|[
name|x
index|]
operator|=
name|red
operator||
operator|(
name|red
operator|>>
literal|5
operator|)
expr_stmt|;
block|}
name|source
operator|+=
name|sourceLock
operator|.
name|Pitch
expr_stmt|;
name|dest
operator|+=
name|destLock
operator|.
name|Pitch
expr_stmt|;
block|}
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|D3DFMT_A1R5G5B5
case|:
switch|switch
condition|(
name|getD3DFormat
argument_list|()
condition|)
block|{
case|case
name|D3DFMT_X8R8G8B8
case|:
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
name|unsigned
name|short
name|argb
init|=
operator|(
operator|(
name|unsigned
name|short
operator|*
operator|)
name|source
operator|)
index|[
name|x
index|]
decl_stmt|;
name|unsigned
name|char
name|red
init|=
operator|(
name|argb
operator|&
literal|0x7C00
operator|)
operator|>>
literal|7
decl_stmt|;
name|unsigned
name|char
name|green
init|=
operator|(
name|argb
operator|&
literal|0x03E0
operator|)
operator|>>
literal|2
decl_stmt|;
name|unsigned
name|char
name|blue
init|=
operator|(
name|argb
operator|&
literal|0x001F
operator|)
operator|<<
literal|3
decl_stmt|;
name|dest
index|[
name|x
operator|+
literal|0
index|]
operator|=
name|blue
operator||
operator|(
name|blue
operator|>>
literal|5
operator|)
expr_stmt|;
name|dest
index|[
name|x
operator|+
literal|1
index|]
operator|=
name|green
operator||
operator|(
name|green
operator|>>
literal|5
operator|)
expr_stmt|;
name|dest
index|[
name|x
operator|+
literal|2
index|]
operator|=
name|red
operator||
operator|(
name|red
operator|>>
literal|5
operator|)
expr_stmt|;
name|dest
index|[
name|x
operator|+
literal|3
index|]
operator|=
literal|0xFF
expr_stmt|;
block|}
name|source
operator|+=
name|sourceLock
operator|.
name|Pitch
expr_stmt|;
name|dest
operator|+=
name|destLock
operator|.
name|Pitch
expr_stmt|;
block|}
break|break;
case|case
name|D3DFMT_A8R8G8B8
case|:
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
name|unsigned
name|short
name|argb
init|=
operator|(
operator|(
name|unsigned
name|short
operator|*
operator|)
name|source
operator|)
index|[
name|x
index|]
decl_stmt|;
name|unsigned
name|char
name|red
init|=
operator|(
name|argb
operator|&
literal|0x7C00
operator|)
operator|>>
literal|7
decl_stmt|;
name|unsigned
name|char
name|green
init|=
operator|(
name|argb
operator|&
literal|0x03E0
operator|)
operator|>>
literal|2
decl_stmt|;
name|unsigned
name|char
name|blue
init|=
operator|(
name|argb
operator|&
literal|0x001F
operator|)
operator|<<
literal|3
decl_stmt|;
name|unsigned
name|char
name|alpha
init|=
operator|(
name|signed
name|short
operator|)
name|argb
operator|>>
literal|15
decl_stmt|;
name|dest
index|[
name|x
operator|+
literal|0
index|]
operator|=
name|blue
operator||
operator|(
name|blue
operator|>>
literal|5
operator|)
expr_stmt|;
name|dest
index|[
name|x
operator|+
literal|1
index|]
operator|=
name|green
operator||
operator|(
name|green
operator|>>
literal|5
operator|)
expr_stmt|;
name|dest
index|[
name|x
operator|+
literal|2
index|]
operator|=
name|red
operator||
operator|(
name|red
operator|>>
literal|5
operator|)
expr_stmt|;
name|dest
index|[
name|x
operator|+
literal|3
index|]
operator|=
name|alpha
expr_stmt|;
block|}
name|source
operator|+=
name|sourceLock
operator|.
name|Pitch
expr_stmt|;
name|dest
operator|+=
name|destLock
operator|.
name|Pitch
expr_stmt|;
block|}
break|break;
case|case
name|D3DFMT_L8
case|:
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
name|unsigned
name|char
name|red
init|=
name|source
index|[
name|x
operator|*
literal|2
operator|+
literal|1
index|]
operator|&
literal|0x7C
decl_stmt|;
name|dest
index|[
name|x
index|]
operator|=
operator|(
name|red
operator|<<
literal|1
operator|)
operator||
operator|(
name|red
operator|>>
literal|4
operator|)
expr_stmt|;
block|}
name|source
operator|+=
name|sourceLock
operator|.
name|Pitch
expr_stmt|;
name|dest
operator|+=
name|destLock
operator|.
name|Pitch
expr_stmt|;
block|}
break|break;
case|case
name|D3DFMT_A8L8
case|:
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
name|unsigned
name|char
name|red
init|=
name|source
index|[
name|x
operator|*
literal|2
operator|+
literal|1
index|]
operator|&
literal|0x7C
decl_stmt|;
name|dest
index|[
name|x
operator|*
literal|2
operator|+
literal|0
index|]
operator|=
operator|(
name|red
operator|<<
literal|1
operator|)
operator||
operator|(
name|red
operator|>>
literal|4
operator|)
expr_stmt|;
name|dest
index|[
name|x
operator|*
literal|2
operator|+
literal|1
index|]
operator|=
operator|(
name|signed
name|char
operator|)
name|source
index|[
name|x
operator|*
literal|2
operator|+
literal|1
index|]
operator|>>
literal|7
expr_stmt|;
block|}
name|source
operator|+=
name|sourceLock
operator|.
name|Pitch
expr_stmt|;
name|dest
operator|+=
name|destLock
operator|.
name|Pitch
expr_stmt|;
block|}
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
name|unlock
argument_list|()
expr_stmt|;
name|renderTargetData
operator|->
name|UnlockRect
argument_list|()
expr_stmt|;
name|renderTargetData
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mDirty
operator|=
literal|true
expr_stmt|;
block|}
namespace|namespace
block|{
DECL|struct|L8
struct|struct
name|L8
block|{
DECL|member|L
name|unsigned
name|char
name|L
decl_stmt|;
DECL|function|average
specifier|static
name|void
name|average
parameter_list|(
name|L8
modifier|*
name|dst
parameter_list|,
specifier|const
name|L8
modifier|*
name|src1
parameter_list|,
specifier|const
name|L8
modifier|*
name|src2
parameter_list|)
block|{
name|dst
operator|->
name|L
operator|=
operator|(
operator|(
name|src1
operator|->
name|L
operator|^
name|src2
operator|->
name|L
operator|)
operator|>>
literal|1
operator|)
operator|+
operator|(
name|src1
operator|->
name|L
operator|&
name|src2
operator|->
name|L
operator|)
expr_stmt|;
block|}
block|}
struct|;
DECL|struct|A8L8
struct|struct
name|A8L8
block|{
DECL|member|L
name|unsigned
name|char
name|L
decl_stmt|;
DECL|member|A
name|unsigned
name|char
name|A
decl_stmt|;
DECL|function|average
specifier|static
name|void
name|average
parameter_list|(
name|A8L8
modifier|*
name|dst
parameter_list|,
specifier|const
name|A8L8
modifier|*
name|src1
parameter_list|,
specifier|const
name|A8L8
modifier|*
name|src2
parameter_list|)
block|{
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
name|dst
operator|=
operator|(
operator|(
operator|(
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
name|src1
operator|^
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
name|src2
operator|)
operator|&
literal|0xFEFE
operator|)
operator|>>
literal|1
operator|)
operator|+
operator|(
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
name|src1
operator|&
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
name|src2
operator|)
expr_stmt|;
block|}
block|}
struct|;
DECL|struct|A8R8G8B8
struct|struct
name|A8R8G8B8
block|{
DECL|member|B
name|unsigned
name|char
name|B
decl_stmt|;
DECL|member|G
name|unsigned
name|char
name|G
decl_stmt|;
DECL|member|R
name|unsigned
name|char
name|R
decl_stmt|;
DECL|member|A
name|unsigned
name|char
name|A
decl_stmt|;
DECL|function|average
specifier|static
name|void
name|average
parameter_list|(
name|A8R8G8B8
modifier|*
name|dst
parameter_list|,
specifier|const
name|A8R8G8B8
modifier|*
name|src1
parameter_list|,
specifier|const
name|A8R8G8B8
modifier|*
name|src2
parameter_list|)
block|{
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
name|dst
operator|=
operator|(
operator|(
operator|(
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
name|src1
operator|^
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
name|src2
operator|)
operator|&
literal|0xFEFEFEFE
operator|)
operator|>>
literal|1
operator|)
operator|+
operator|(
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
name|src1
operator|&
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
name|src2
operator|)
expr_stmt|;
block|}
block|}
struct|;
DECL|struct|A16B16G16R16F
struct|struct
name|A16B16G16R16F
block|{
DECL|member|R
name|unsigned
name|short
name|R
decl_stmt|;
DECL|member|G
name|unsigned
name|short
name|G
decl_stmt|;
DECL|member|B
name|unsigned
name|short
name|B
decl_stmt|;
DECL|member|A
name|unsigned
name|short
name|A
decl_stmt|;
DECL|function|average
specifier|static
name|void
name|average
parameter_list|(
name|A16B16G16R16F
modifier|*
name|dst
parameter_list|,
specifier|const
name|A16B16G16R16F
modifier|*
name|src1
parameter_list|,
specifier|const
name|A16B16G16R16F
modifier|*
name|src2
parameter_list|)
block|{
name|dst
operator|->
name|R
operator|=
name|float32ToFloat16
argument_list|(
operator|(
name|float16ToFloat32
argument_list|(
name|src1
operator|->
name|R
argument_list|)
operator|+
name|float16ToFloat32
argument_list|(
name|src2
operator|->
name|R
argument_list|)
operator|)
operator|*
literal|0.5f
argument_list|)
expr_stmt|;
name|dst
operator|->
name|G
operator|=
name|float32ToFloat16
argument_list|(
operator|(
name|float16ToFloat32
argument_list|(
name|src1
operator|->
name|G
argument_list|)
operator|+
name|float16ToFloat32
argument_list|(
name|src2
operator|->
name|G
argument_list|)
operator|)
operator|*
literal|0.5f
argument_list|)
expr_stmt|;
name|dst
operator|->
name|B
operator|=
name|float32ToFloat16
argument_list|(
operator|(
name|float16ToFloat32
argument_list|(
name|src1
operator|->
name|B
argument_list|)
operator|+
name|float16ToFloat32
argument_list|(
name|src2
operator|->
name|B
argument_list|)
operator|)
operator|*
literal|0.5f
argument_list|)
expr_stmt|;
name|dst
operator|->
name|A
operator|=
name|float32ToFloat16
argument_list|(
operator|(
name|float16ToFloat32
argument_list|(
name|src1
operator|->
name|A
argument_list|)
operator|+
name|float16ToFloat32
argument_list|(
name|src2
operator|->
name|A
argument_list|)
operator|)
operator|*
literal|0.5f
argument_list|)
expr_stmt|;
block|}
block|}
struct|;
DECL|struct|A32B32G32R32F
struct|struct
name|A32B32G32R32F
block|{
DECL|member|R
name|float
name|R
decl_stmt|;
DECL|member|G
name|float
name|G
decl_stmt|;
DECL|member|B
name|float
name|B
decl_stmt|;
DECL|member|A
name|float
name|A
decl_stmt|;
DECL|function|average
specifier|static
name|void
name|average
parameter_list|(
name|A32B32G32R32F
modifier|*
name|dst
parameter_list|,
specifier|const
name|A32B32G32R32F
modifier|*
name|src1
parameter_list|,
specifier|const
name|A32B32G32R32F
modifier|*
name|src2
parameter_list|)
block|{
name|dst
operator|->
name|R
operator|=
operator|(
name|src1
operator|->
name|R
operator|+
name|src2
operator|->
name|R
operator|)
operator|*
literal|0.5f
expr_stmt|;
name|dst
operator|->
name|G
operator|=
operator|(
name|src1
operator|->
name|G
operator|+
name|src2
operator|->
name|G
operator|)
operator|*
literal|0.5f
expr_stmt|;
name|dst
operator|->
name|B
operator|=
operator|(
name|src1
operator|->
name|B
operator|+
name|src2
operator|->
name|B
operator|)
operator|*
literal|0.5f
expr_stmt|;
name|dst
operator|->
name|A
operator|=
operator|(
name|src1
operator|->
name|A
operator|+
name|src2
operator|->
name|A
operator|)
operator|*
literal|0.5f
expr_stmt|;
block|}
block|}
struct|;
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|GenerateMip
name|void
name|GenerateMip
parameter_list|(
name|unsigned
name|int
name|sourceWidth
parameter_list|,
name|unsigned
name|int
name|sourceHeight
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sourceData
parameter_list|,
name|int
name|sourcePitch
parameter_list|,
name|unsigned
name|char
modifier|*
name|destData
parameter_list|,
name|int
name|destPitch
parameter_list|)
block|{
name|unsigned
name|int
name|mipWidth
init|=
name|std
operator|::
name|max
argument_list|(
literal|1U
argument_list|,
name|sourceWidth
operator|>>
literal|1
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|mipHeight
init|=
name|std
operator|::
name|max
argument_list|(
literal|1U
argument_list|,
name|sourceHeight
operator|>>
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|sourceHeight
operator|==
literal|1
condition|)
block|{
name|ASSERT
argument_list|(
name|sourceWidth
operator|!=
literal|1
argument_list|)
expr_stmt|;
specifier|const
name|T
modifier|*
name|src
init|=
operator|(
specifier|const
name|T
operator|*
operator|)
name|sourceData
decl_stmt|;
name|T
modifier|*
name|dst
init|=
operator|(
name|T
operator|*
operator|)
name|destData
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|mipWidth
condition|;
name|x
operator|++
control|)
block|{
name|T
operator|::
name|average
argument_list|(
operator|&
name|dst
index|[
name|x
index|]
argument_list|,
operator|&
name|src
index|[
name|x
operator|*
literal|2
index|]
argument_list|,
operator|&
name|src
index|[
name|x
operator|*
literal|2
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sourceWidth
operator|==
literal|1
condition|)
block|{
name|ASSERT
argument_list|(
name|sourceHeight
operator|!=
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|mipHeight
condition|;
name|y
operator|++
control|)
block|{
specifier|const
name|T
modifier|*
name|src0
init|=
operator|(
specifier|const
name|T
operator|*
operator|)
operator|(
name|sourceData
operator|+
name|y
operator|*
literal|2
operator|*
name|sourcePitch
operator|)
decl_stmt|;
specifier|const
name|T
modifier|*
name|src1
init|=
operator|(
specifier|const
name|T
operator|*
operator|)
operator|(
name|sourceData
operator|+
name|y
operator|*
literal|2
operator|*
name|sourcePitch
operator|+
name|sourcePitch
operator|)
decl_stmt|;
name|T
modifier|*
name|dst
init|=
operator|(
name|T
operator|*
operator|)
operator|(
name|destData
operator|+
name|y
operator|*
name|destPitch
operator|)
decl_stmt|;
name|T
operator|::
name|average
argument_list|(
name|dst
argument_list|,
name|src0
argument_list|,
name|src1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|unsigned
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|mipHeight
condition|;
name|y
operator|++
control|)
block|{
specifier|const
name|T
modifier|*
name|src0
init|=
operator|(
specifier|const
name|T
operator|*
operator|)
operator|(
name|sourceData
operator|+
name|y
operator|*
literal|2
operator|*
name|sourcePitch
operator|)
decl_stmt|;
specifier|const
name|T
modifier|*
name|src1
init|=
operator|(
specifier|const
name|T
operator|*
operator|)
operator|(
name|sourceData
operator|+
name|y
operator|*
literal|2
operator|*
name|sourcePitch
operator|+
name|sourcePitch
operator|)
decl_stmt|;
name|T
modifier|*
name|dst
init|=
operator|(
name|T
operator|*
operator|)
operator|(
name|destData
operator|+
name|y
operator|*
name|destPitch
operator|)
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|mipWidth
condition|;
name|x
operator|++
control|)
block|{
name|T
name|tmp0
decl_stmt|;
name|T
name|tmp1
decl_stmt|;
name|T
operator|::
name|average
argument_list|(
operator|&
name|tmp0
argument_list|,
operator|&
name|src0
index|[
name|x
operator|*
literal|2
index|]
argument_list|,
operator|&
name|src0
index|[
name|x
operator|*
literal|2
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|T
operator|::
name|average
argument_list|(
operator|&
name|tmp1
argument_list|,
operator|&
name|src1
index|[
name|x
operator|*
literal|2
index|]
argument_list|,
operator|&
name|src1
index|[
name|x
operator|*
literal|2
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|T
operator|::
name|average
argument_list|(
operator|&
name|dst
index|[
name|x
index|]
argument_list|,
operator|&
name|tmp0
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|function|GenerateMip
name|void
name|GenerateMip
parameter_list|(
name|IDirect3DSurface9
modifier|*
name|destSurface
parameter_list|,
name|IDirect3DSurface9
modifier|*
name|sourceSurface
parameter_list|)
block|{
name|D3DSURFACE_DESC
name|destDesc
decl_stmt|;
name|HRESULT
name|result
init|=
name|destSurface
operator|->
name|GetDesc
argument_list|(
operator|&
name|destDesc
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|D3DSURFACE_DESC
name|sourceDesc
decl_stmt|;
name|result
operator|=
name|sourceSurface
operator|->
name|GetDesc
argument_list|(
operator|&
name|sourceDesc
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|sourceDesc
operator|.
name|Format
operator|==
name|destDesc
operator|.
name|Format
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|sourceDesc
operator|.
name|Width
operator|==
literal|1
operator|||
name|sourceDesc
operator|.
name|Width
operator|/
literal|2
operator|==
name|destDesc
operator|.
name|Width
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|sourceDesc
operator|.
name|Height
operator|==
literal|1
operator|||
name|sourceDesc
operator|.
name|Height
operator|/
literal|2
operator|==
name|destDesc
operator|.
name|Height
argument_list|)
expr_stmt|;
name|D3DLOCKED_RECT
name|sourceLocked
init|=
block|{
literal|0
block|}
decl_stmt|;
name|result
operator|=
name|sourceSurface
operator|->
name|LockRect
argument_list|(
operator|&
name|sourceLocked
argument_list|,
name|NULL
argument_list|,
name|D3DLOCK_READONLY
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|D3DLOCKED_RECT
name|destLocked
init|=
block|{
literal|0
block|}
decl_stmt|;
name|result
operator|=
name|destSurface
operator|->
name|LockRect
argument_list|(
operator|&
name|destLocked
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|sourceData
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|sourceLocked
operator|.
name|pBits
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|destData
init|=
cast|reinterpret_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|destLocked
operator|.
name|pBits
argument_list|)
decl_stmt|;
if|if
condition|(
name|sourceData
operator|&&
name|destData
condition|)
block|{
switch|switch
condition|(
name|sourceDesc
operator|.
name|Format
condition|)
block|{
case|case
name|D3DFMT_L8
case|:
name|GenerateMip
argument_list|<
name|L8
argument_list|>
argument_list|(
name|sourceDesc
operator|.
name|Width
argument_list|,
name|sourceDesc
operator|.
name|Height
argument_list|,
name|sourceData
argument_list|,
name|sourceLocked
operator|.
name|Pitch
argument_list|,
name|destData
argument_list|,
name|destLocked
operator|.
name|Pitch
argument_list|)
expr_stmt|;
break|break;
case|case
name|D3DFMT_A8L8
case|:
name|GenerateMip
argument_list|<
name|A8L8
argument_list|>
argument_list|(
name|sourceDesc
operator|.
name|Width
argument_list|,
name|sourceDesc
operator|.
name|Height
argument_list|,
name|sourceData
argument_list|,
name|sourceLocked
operator|.
name|Pitch
argument_list|,
name|destData
argument_list|,
name|destLocked
operator|.
name|Pitch
argument_list|)
expr_stmt|;
break|break;
case|case
name|D3DFMT_A8R8G8B8
case|:
case|case
name|D3DFMT_X8R8G8B8
case|:
name|GenerateMip
argument_list|<
name|A8R8G8B8
argument_list|>
argument_list|(
name|sourceDesc
operator|.
name|Width
argument_list|,
name|sourceDesc
operator|.
name|Height
argument_list|,
name|sourceData
argument_list|,
name|sourceLocked
operator|.
name|Pitch
argument_list|,
name|destData
argument_list|,
name|destLocked
operator|.
name|Pitch
argument_list|)
expr_stmt|;
break|break;
case|case
name|D3DFMT_A16B16G16R16F
case|:
name|GenerateMip
argument_list|<
name|A16B16G16R16F
argument_list|>
argument_list|(
name|sourceDesc
operator|.
name|Width
argument_list|,
name|sourceDesc
operator|.
name|Height
argument_list|,
name|sourceData
argument_list|,
name|sourceLocked
operator|.
name|Pitch
argument_list|,
name|destData
argument_list|,
name|destLocked
operator|.
name|Pitch
argument_list|)
expr_stmt|;
break|break;
case|case
name|D3DFMT_A32B32G32R32F
case|:
name|GenerateMip
argument_list|<
name|A32B32G32R32F
argument_list|>
argument_list|(
name|sourceDesc
operator|.
name|Width
argument_list|,
name|sourceDesc
operator|.
name|Height
argument_list|,
name|sourceData
argument_list|,
name|sourceLocked
operator|.
name|Pitch
argument_list|,
name|destData
argument_list|,
name|destLocked
operator|.
name|Pitch
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
name|destSurface
operator|->
name|UnlockRect
argument_list|()
expr_stmt|;
name|sourceSurface
operator|->
name|UnlockRect
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|function|TextureStorage
name|TextureStorage
operator|::
name|TextureStorage
parameter_list|(
name|DWORD
name|usage
parameter_list|)
member_init_list|:
name|mD3DUsage
argument_list|(
name|usage
argument_list|)
member_init_list|,
name|mD3DPool
argument_list|(
name|getDisplay
argument_list|()
operator|->
name|getTexturePool
argument_list|(
name|usage
argument_list|)
argument_list|)
member_init_list|,
name|mTextureSerial
argument_list|(
name|issueTextureSerial
argument_list|()
argument_list|)
member_init_list|,
name|mLodOffset
argument_list|(
literal|0
argument_list|)
block|{ }
DECL|function|~TextureStorage
name|TextureStorage
operator|::
name|~
name|TextureStorage
parameter_list|()
block|{ }
DECL|function|isRenderTarget
name|bool
name|TextureStorage
operator|::
name|isRenderTarget
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|mD3DUsage
operator|&
operator|(
name|D3DUSAGE_RENDERTARGET
operator||
name|D3DUSAGE_DEPTHSTENCIL
operator|)
operator|)
operator|!=
literal|0
return|;
block|}
DECL|function|isManaged
name|bool
name|TextureStorage
operator|::
name|isManaged
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|mD3DPool
operator|==
name|D3DPOOL_MANAGED
operator|)
return|;
block|}
DECL|function|getPool
name|D3DPOOL
name|TextureStorage
operator|::
name|getPool
parameter_list|()
specifier|const
block|{
return|return
name|mD3DPool
return|;
block|}
DECL|function|getUsage
name|DWORD
name|TextureStorage
operator|::
name|getUsage
parameter_list|()
specifier|const
block|{
return|return
name|mD3DUsage
return|;
block|}
DECL|function|getTextureSerial
name|unsigned
name|int
name|TextureStorage
operator|::
name|getTextureSerial
parameter_list|()
specifier|const
block|{
return|return
name|mTextureSerial
return|;
block|}
DECL|function|issueTextureSerial
name|unsigned
name|int
name|TextureStorage
operator|::
name|issueTextureSerial
parameter_list|()
block|{
return|return
name|mCurrentTextureSerial
operator|++
return|;
block|}
DECL|function|getLodOffset
name|int
name|TextureStorage
operator|::
name|getLodOffset
parameter_list|()
specifier|const
block|{
return|return
name|mLodOffset
return|;
block|}
DECL|function|Texture
name|Texture
operator|::
name|Texture
parameter_list|(
name|GLuint
name|id
parameter_list|)
member_init_list|:
name|RefCountObject
argument_list|(
name|id
argument_list|)
block|{
name|mMinFilter
operator|=
name|GL_NEAREST_MIPMAP_LINEAR
expr_stmt|;
name|mMagFilter
operator|=
name|GL_LINEAR
expr_stmt|;
name|mWrapS
operator|=
name|GL_REPEAT
expr_stmt|;
name|mWrapT
operator|=
name|GL_REPEAT
expr_stmt|;
name|mDirtyParameters
operator|=
literal|true
expr_stmt|;
name|mUsage
operator|=
name|GL_NONE
expr_stmt|;
name|mMaxAnisotropy
operator|=
literal|1.0f
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
name|mImmutable
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|~Texture
name|Texture
operator|::
name|~
name|Texture
parameter_list|()
block|{ }
comment|// Returns true on successful filter state update (valid enum parameter)
DECL|function|setMinFilter
name|bool
name|Texture
operator|::
name|setMinFilter
parameter_list|(
name|GLenum
name|filter
parameter_list|)
block|{
switch|switch
condition|(
name|filter
condition|)
block|{
case|case
name|GL_NEAREST
case|:
case|case
name|GL_LINEAR
case|:
case|case
name|GL_NEAREST_MIPMAP_NEAREST
case|:
case|case
name|GL_LINEAR_MIPMAP_NEAREST
case|:
case|case
name|GL_NEAREST_MIPMAP_LINEAR
case|:
case|case
name|GL_LINEAR_MIPMAP_LINEAR
case|:
block|{
if|if
condition|(
name|mMinFilter
operator|!=
name|filter
condition|)
block|{
name|mMinFilter
operator|=
name|filter
expr_stmt|;
name|mDirtyParameters
operator|=
literal|true
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|// Returns true on successful filter state update (valid enum parameter)
DECL|function|setMagFilter
name|bool
name|Texture
operator|::
name|setMagFilter
parameter_list|(
name|GLenum
name|filter
parameter_list|)
block|{
switch|switch
condition|(
name|filter
condition|)
block|{
case|case
name|GL_NEAREST
case|:
case|case
name|GL_LINEAR
case|:
block|{
if|if
condition|(
name|mMagFilter
operator|!=
name|filter
condition|)
block|{
name|mMagFilter
operator|=
name|filter
expr_stmt|;
name|mDirtyParameters
operator|=
literal|true
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|// Returns true on successful wrap state update (valid enum parameter)
DECL|function|setWrapS
name|bool
name|Texture
operator|::
name|setWrapS
parameter_list|(
name|GLenum
name|wrap
parameter_list|)
block|{
switch|switch
condition|(
name|wrap
condition|)
block|{
case|case
name|GL_REPEAT
case|:
case|case
name|GL_CLAMP_TO_EDGE
case|:
case|case
name|GL_MIRRORED_REPEAT
case|:
block|{
if|if
condition|(
name|mWrapS
operator|!=
name|wrap
condition|)
block|{
name|mWrapS
operator|=
name|wrap
expr_stmt|;
name|mDirtyParameters
operator|=
literal|true
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|// Returns true on successful wrap state update (valid enum parameter)
DECL|function|setWrapT
name|bool
name|Texture
operator|::
name|setWrapT
parameter_list|(
name|GLenum
name|wrap
parameter_list|)
block|{
switch|switch
condition|(
name|wrap
condition|)
block|{
case|case
name|GL_REPEAT
case|:
case|case
name|GL_CLAMP_TO_EDGE
case|:
case|case
name|GL_MIRRORED_REPEAT
case|:
block|{
if|if
condition|(
name|mWrapT
operator|!=
name|wrap
condition|)
block|{
name|mWrapT
operator|=
name|wrap
expr_stmt|;
name|mDirtyParameters
operator|=
literal|true
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|// Returns true on successful max anisotropy update (valid anisotropy value)
DECL|function|setMaxAnisotropy
name|bool
name|Texture
operator|::
name|setMaxAnisotropy
parameter_list|(
name|float
name|textureMaxAnisotropy
parameter_list|,
name|float
name|contextMaxAnisotropy
parameter_list|)
block|{
name|textureMaxAnisotropy
operator|=
name|std
operator|::
name|min
argument_list|(
name|textureMaxAnisotropy
argument_list|,
name|contextMaxAnisotropy
argument_list|)
expr_stmt|;
if|if
condition|(
name|textureMaxAnisotropy
operator|<
literal|1.0f
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|mMaxAnisotropy
operator|!=
name|textureMaxAnisotropy
condition|)
block|{
name|mMaxAnisotropy
operator|=
name|textureMaxAnisotropy
expr_stmt|;
name|mDirtyParameters
operator|=
literal|true
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|// Returns true on successful usage state update (valid enum parameter)
DECL|function|setUsage
name|bool
name|Texture
operator|::
name|setUsage
parameter_list|(
name|GLenum
name|usage
parameter_list|)
block|{
switch|switch
condition|(
name|usage
condition|)
block|{
case|case
name|GL_NONE
case|:
case|case
name|GL_FRAMEBUFFER_ATTACHMENT_ANGLE
case|:
name|mUsage
operator|=
name|usage
expr_stmt|;
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
DECL|function|getMinFilter
name|GLenum
name|Texture
operator|::
name|getMinFilter
parameter_list|()
specifier|const
block|{
return|return
name|mMinFilter
return|;
block|}
DECL|function|getMagFilter
name|GLenum
name|Texture
operator|::
name|getMagFilter
parameter_list|()
specifier|const
block|{
return|return
name|mMagFilter
return|;
block|}
DECL|function|getWrapS
name|GLenum
name|Texture
operator|::
name|getWrapS
parameter_list|()
specifier|const
block|{
return|return
name|mWrapS
return|;
block|}
DECL|function|getWrapT
name|GLenum
name|Texture
operator|::
name|getWrapT
parameter_list|()
specifier|const
block|{
return|return
name|mWrapT
return|;
block|}
DECL|function|getMaxAnisotropy
name|float
name|Texture
operator|::
name|getMaxAnisotropy
parameter_list|()
specifier|const
block|{
return|return
name|mMaxAnisotropy
return|;
block|}
DECL|function|getUsage
name|GLenum
name|Texture
operator|::
name|getUsage
parameter_list|()
specifier|const
block|{
return|return
name|mUsage
return|;
block|}
DECL|function|setImage
name|void
name|Texture
operator|::
name|setImage
parameter_list|(
name|GLint
name|unpackAlignment
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|,
name|Image
modifier|*
name|image
parameter_list|)
block|{
if|if
condition|(
name|pixels
operator|!=
name|NULL
condition|)
block|{
name|image
operator|->
name|loadData
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|image
operator|->
name|getWidth
argument_list|()
argument_list|,
name|image
operator|->
name|getHeight
argument_list|()
argument_list|,
name|unpackAlignment
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|setCompressedImage
name|void
name|Texture
operator|::
name|setCompressedImage
parameter_list|(
name|GLsizei
name|imageSize
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|,
name|Image
modifier|*
name|image
parameter_list|)
block|{
if|if
condition|(
name|pixels
operator|!=
name|NULL
condition|)
block|{
name|image
operator|->
name|loadCompressedData
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|image
operator|->
name|getWidth
argument_list|()
argument_list|,
name|image
operator|->
name|getHeight
argument_list|()
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|subImage
name|bool
name|Texture
operator|::
name|subImage
parameter_list|(
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLint
name|unpackAlignment
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|,
name|Image
modifier|*
name|image
parameter_list|)
block|{
if|if
condition|(
name|pixels
operator|!=
name|NULL
condition|)
block|{
name|image
operator|->
name|loadData
argument_list|(
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|unpackAlignment
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|subImageCompressed
name|bool
name|Texture
operator|::
name|subImageCompressed
parameter_list|(
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLsizei
name|imageSize
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|,
name|Image
modifier|*
name|image
parameter_list|)
block|{
if|if
condition|(
name|pixels
operator|!=
name|NULL
condition|)
block|{
name|image
operator|->
name|loadCompressedData
argument_list|(
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|getTexture
name|IDirect3DBaseTexture9
modifier|*
name|Texture
operator|::
name|getTexture
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isSamplerComplete
argument_list|()
condition|)
block|{
return|return
name|NULL
return|;
block|}
comment|// ensure the underlying texture is created
if|if
condition|(
name|getStorage
argument_list|(
literal|false
argument_list|)
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|updateTexture
argument_list|()
expr_stmt|;
return|return
name|getBaseTexture
argument_list|()
return|;
block|}
DECL|function|hasDirtyParameters
name|bool
name|Texture
operator|::
name|hasDirtyParameters
parameter_list|()
specifier|const
block|{
return|return
name|mDirtyParameters
return|;
block|}
DECL|function|hasDirtyImages
name|bool
name|Texture
operator|::
name|hasDirtyImages
parameter_list|()
specifier|const
block|{
return|return
name|mDirtyImages
return|;
block|}
DECL|function|resetDirty
name|void
name|Texture
operator|::
name|resetDirty
parameter_list|()
block|{
name|mDirtyParameters
operator|=
literal|false
expr_stmt|;
name|mDirtyImages
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|getTextureSerial
name|unsigned
name|int
name|Texture
operator|::
name|getTextureSerial
parameter_list|()
block|{
name|TextureStorage
modifier|*
name|texture
init|=
name|getStorage
argument_list|(
literal|false
argument_list|)
decl_stmt|;
return|return
name|texture
condition|?
name|texture
operator|->
name|getTextureSerial
argument_list|()
else|:
literal|0
return|;
block|}
DECL|function|getRenderTargetSerial
name|unsigned
name|int
name|Texture
operator|::
name|getRenderTargetSerial
parameter_list|(
name|GLenum
name|target
parameter_list|)
block|{
name|TextureStorage
modifier|*
name|texture
init|=
name|getStorage
argument_list|(
literal|true
argument_list|)
decl_stmt|;
return|return
name|texture
condition|?
name|texture
operator|->
name|getRenderTargetSerial
argument_list|(
name|target
argument_list|)
else|:
literal|0
return|;
block|}
DECL|function|isImmutable
name|bool
name|Texture
operator|::
name|isImmutable
parameter_list|()
specifier|const
block|{
return|return
name|mImmutable
return|;
block|}
DECL|function|getLodOffset
name|int
name|Texture
operator|::
name|getLodOffset
parameter_list|()
block|{
name|TextureStorage
modifier|*
name|texture
init|=
name|getStorage
argument_list|(
literal|false
argument_list|)
decl_stmt|;
return|return
name|texture
condition|?
name|texture
operator|->
name|getLodOffset
argument_list|()
else|:
literal|0
return|;
block|}
DECL|function|creationLevels
name|GLint
name|Texture
operator|::
name|creationLevels
parameter_list|(
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|(
name|isPow2
argument_list|(
name|width
argument_list|)
operator|&&
name|isPow2
argument_list|(
name|height
argument_list|)
operator|)
operator|||
name|getContext
argument_list|()
operator|->
name|supportsNonPower2Texture
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
comment|// Maximum number of levels
block|}
else|else
block|{
comment|// OpenGL ES 2.0 without GL_OES_texture_npot does not permit NPOT mipmaps.
return|return
literal|1
return|;
block|}
block|}
DECL|function|creationLevels
name|GLint
name|Texture
operator|::
name|creationLevels
parameter_list|(
name|GLsizei
name|size
parameter_list|)
specifier|const
block|{
return|return
name|creationLevels
argument_list|(
name|size
argument_list|,
name|size
argument_list|)
return|;
block|}
DECL|function|levelCount
name|int
name|Texture
operator|::
name|levelCount
parameter_list|()
block|{
return|return
name|getBaseTexture
argument_list|()
condition|?
name|getBaseTexture
argument_list|()
operator|->
name|GetLevelCount
argument_list|()
operator|-
name|getLodOffset
argument_list|()
else|:
literal|0
return|;
block|}
DECL|function|getBlitter
name|Blit
modifier|*
name|Texture
operator|::
name|getBlitter
parameter_list|()
block|{
name|Context
modifier|*
name|context
init|=
name|getContext
argument_list|()
decl_stmt|;
return|return
name|context
operator|->
name|getBlitter
argument_list|()
return|;
block|}
DECL|function|copyToRenderTarget
name|bool
name|Texture
operator|::
name|copyToRenderTarget
parameter_list|(
name|IDirect3DSurface9
modifier|*
name|dest
parameter_list|,
name|IDirect3DSurface9
modifier|*
name|source
parameter_list|,
name|bool
name|fromManaged
parameter_list|)
block|{
if|if
condition|(
name|source
operator|&&
name|dest
condition|)
block|{
name|HRESULT
name|result
init|=
name|D3DERR_OUTOFVIDEOMEMORY
decl_stmt|;
if|if
condition|(
name|fromManaged
condition|)
block|{
name|D3DSURFACE_DESC
name|desc
decl_stmt|;
name|source
operator|->
name|GetDesc
argument_list|(
operator|&
name|desc
argument_list|)
expr_stmt|;
name|IDirect3DSurface9
modifier|*
name|surf
init|=
literal|0
decl_stmt|;
name|result
operator|=
name|getDevice
argument_list|()
operator|->
name|CreateOffscreenPlainSurface
argument_list|(
name|desc
operator|.
name|Width
argument_list|,
name|desc
operator|.
name|Height
argument_list|,
name|desc
operator|.
name|Format
argument_list|,
name|D3DPOOL_SYSTEMMEM
argument_list|,
operator|&
name|surf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|CopyLockableSurfaces
argument_list|(
name|surf
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|result
operator|=
name|getDevice
argument_list|()
operator|->
name|UpdateSurface
argument_list|(
name|surf
argument_list|,
name|NULL
argument_list|,
name|dest
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|surf
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|egl
operator|::
name|Display
modifier|*
name|display
init|=
name|getDisplay
argument_list|()
decl_stmt|;
name|IDirect3DDevice9
modifier|*
name|device
init|=
name|display
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|display
operator|->
name|endScene
argument_list|()
expr_stmt|;
name|result
operator|=
name|device
operator|->
name|StretchRect
argument_list|(
name|source
argument_list|,
name|NULL
argument_list|,
name|dest
argument_list|,
name|NULL
argument_list|,
name|D3DTEXF_NONE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|result
operator|==
name|D3DERR_OUTOFVIDEOMEMORY
operator|||
name|result
operator|==
name|E_OUTOFMEMORY
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|TextureStorage2D
name|TextureStorage2D
operator|::
name|TextureStorage2D
parameter_list|(
name|IDirect3DTexture9
modifier|*
name|surfaceTexture
parameter_list|)
member_init_list|:
name|TextureStorage
argument_list|(
name|D3DUSAGE_RENDERTARGET
argument_list|)
member_init_list|,
name|mRenderTargetSerial
argument_list|(
name|RenderbufferStorage
operator|::
name|issueSerial
argument_list|()
argument_list|)
block|{
name|mTexture
operator|=
name|surfaceTexture
expr_stmt|;
block|}
DECL|function|TextureStorage2D
name|TextureStorage2D
operator|::
name|TextureStorage2D
parameter_list|(
name|int
name|levels
parameter_list|,
name|D3DFORMAT
name|format
parameter_list|,
name|DWORD
name|usage
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|)
member_init_list|:
name|TextureStorage
argument_list|(
name|usage
argument_list|)
member_init_list|,
name|mRenderTargetSerial
argument_list|(
name|RenderbufferStorage
operator|::
name|issueSerial
argument_list|()
argument_list|)
block|{
name|mTexture
operator|=
name|NULL
expr_stmt|;
comment|// if the width or height is not positive this should be treated as an incomplete texture
comment|// we handle that here by skipping the d3d texture creation
if|if
condition|(
name|width
operator|>
literal|0
operator|&&
name|height
operator|>
literal|0
condition|)
block|{
name|IDirect3DDevice9
modifier|*
name|device
init|=
name|getDevice
argument_list|()
decl_stmt|;
name|MakeValidSize
argument_list|(
literal|false
argument_list|,
name|dx
operator|::
name|IsCompressedFormat
argument_list|(
name|format
argument_list|)
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|height
argument_list|,
operator|&
name|mLodOffset
argument_list|)
expr_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateTexture
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|levels
condition|?
name|levels
operator|+
name|mLodOffset
else|:
literal|0
argument_list|,
name|getUsage
argument_list|()
argument_list|,
name|format
argument_list|,
name|getPool
argument_list|()
argument_list|,
operator|&
name|mTexture
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|result
operator|==
name|D3DERR_OUTOFVIDEOMEMORY
operator|||
name|result
operator|==
name|E_OUTOFMEMORY
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|~TextureStorage2D
name|TextureStorage2D
operator|::
name|~
name|TextureStorage2D
parameter_list|()
block|{
if|if
condition|(
name|mTexture
condition|)
block|{
name|mTexture
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Increments refcount on surface.
comment|// caller must Release() the returned surface
DECL|function|getSurfaceLevel
name|IDirect3DSurface9
modifier|*
name|TextureStorage2D
operator|::
name|getSurfaceLevel
parameter_list|(
name|int
name|level
parameter_list|,
name|bool
name|dirty
parameter_list|)
block|{
name|IDirect3DSurface9
modifier|*
name|surface
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|mTexture
condition|)
block|{
name|HRESULT
name|result
init|=
name|mTexture
operator|->
name|GetSurfaceLevel
argument_list|(
name|level
operator|+
name|mLodOffset
argument_list|,
operator|&
name|surface
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
comment|// With managed textures the driver needs to be informed of updates to the lower mipmap levels
if|if
condition|(
name|level
operator|!=
literal|0
operator|&&
name|isManaged
argument_list|()
operator|&&
name|dirty
condition|)
block|{
name|mTexture
operator|->
name|AddDirtyRect
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|surface
return|;
block|}
DECL|function|getBaseTexture
name|IDirect3DBaseTexture9
modifier|*
name|TextureStorage2D
operator|::
name|getBaseTexture
parameter_list|()
specifier|const
block|{
return|return
name|mTexture
return|;
block|}
DECL|function|getRenderTargetSerial
name|unsigned
name|int
name|TextureStorage2D
operator|::
name|getRenderTargetSerial
parameter_list|(
name|GLenum
name|target
parameter_list|)
specifier|const
block|{
return|return
name|mRenderTargetSerial
return|;
block|}
DECL|function|Texture2D
name|Texture2D
operator|::
name|Texture2D
parameter_list|(
name|GLuint
name|id
parameter_list|)
member_init_list|:
name|Texture
argument_list|(
name|id
argument_list|)
block|{
name|mTexStorage
operator|=
name|NULL
expr_stmt|;
name|mSurface
operator|=
name|NULL
expr_stmt|;
name|mColorbufferProxy
operator|=
name|NULL
expr_stmt|;
name|mProxyRefs
operator|=
literal|0
expr_stmt|;
block|}
DECL|function|~Texture2D
name|Texture2D
operator|::
name|~
name|Texture2D
parameter_list|()
block|{
name|mColorbufferProxy
operator|=
name|NULL
expr_stmt|;
operator|delete
name|mTexStorage
expr_stmt|;
name|mTexStorage
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|mSurface
condition|)
block|{
name|mSurface
operator|->
name|setBoundTexture
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mSurface
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|// We need to maintain a count of references to renderbuffers acting as
comment|// proxies for this texture, so that we do not attempt to use a pointer
comment|// to a renderbuffer proxy which has been deleted.
DECL|function|addProxyRef
name|void
name|Texture2D
operator|::
name|addProxyRef
parameter_list|(
specifier|const
name|Renderbuffer
modifier|*
name|proxy
parameter_list|)
block|{
name|mProxyRefs
operator|++
expr_stmt|;
block|}
DECL|function|releaseProxy
name|void
name|Texture2D
operator|::
name|releaseProxy
parameter_list|(
specifier|const
name|Renderbuffer
modifier|*
name|proxy
parameter_list|)
block|{
if|if
condition|(
name|mProxyRefs
operator|>
literal|0
condition|)
name|mProxyRefs
operator|--
expr_stmt|;
if|if
condition|(
name|mProxyRefs
operator|==
literal|0
condition|)
name|mColorbufferProxy
operator|=
name|NULL
expr_stmt|;
block|}
DECL|function|getTarget
name|GLenum
name|Texture2D
operator|::
name|getTarget
parameter_list|()
specifier|const
block|{
return|return
name|GL_TEXTURE_2D
return|;
block|}
DECL|function|getWidth
name|GLsizei
name|Texture2D
operator|::
name|getWidth
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|level
operator|<
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
return|return
name|mImageArray
index|[
name|level
index|]
operator|.
name|getWidth
argument_list|()
return|;
else|else
return|return
literal|0
return|;
block|}
DECL|function|getHeight
name|GLsizei
name|Texture2D
operator|::
name|getHeight
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|level
operator|<
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
return|return
name|mImageArray
index|[
name|level
index|]
operator|.
name|getHeight
argument_list|()
return|;
else|else
return|return
literal|0
return|;
block|}
DECL|function|getInternalFormat
name|GLenum
name|Texture2D
operator|::
name|getInternalFormat
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|level
operator|<
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
return|return
name|mImageArray
index|[
name|level
index|]
operator|.
name|getInternalFormat
argument_list|()
return|;
else|else
return|return
name|GL_NONE
return|;
block|}
DECL|function|getD3DFormat
name|D3DFORMAT
name|Texture2D
operator|::
name|getD3DFormat
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|level
operator|<
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
return|return
name|mImageArray
index|[
name|level
index|]
operator|.
name|getD3DFormat
argument_list|()
return|;
else|else
return|return
name|D3DFMT_UNKNOWN
return|;
block|}
DECL|function|redefineImage
name|void
name|Texture2D
operator|::
name|redefineImage
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLint
name|internalformat
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
name|releaseTexImage
argument_list|()
expr_stmt|;
name|bool
name|redefined
init|=
name|mImageArray
index|[
name|level
index|]
operator|.
name|redefine
argument_list|(
name|internalformat
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|mTexStorage
operator|&&
name|redefined
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|i
operator|++
control|)
block|{
name|mImageArray
index|[
name|i
index|]
operator|.
name|markDirty
argument_list|()
expr_stmt|;
block|}
operator|delete
name|mTexStorage
expr_stmt|;
name|mTexStorage
operator|=
name|NULL
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|setImage
name|void
name|Texture2D
operator|::
name|setImage
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLint
name|unpackAlignment
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
name|GLint
name|internalformat
init|=
name|ConvertSizedInternalFormat
argument_list|(
name|format
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|redefineImage
argument_list|(
name|level
argument_list|,
name|internalformat
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|Texture
operator|::
name|setImage
argument_list|(
name|unpackAlignment
argument_list|,
name|pixels
argument_list|,
operator|&
name|mImageArray
index|[
name|level
index|]
argument_list|)
expr_stmt|;
block|}
DECL|function|bindTexImage
name|void
name|Texture2D
operator|::
name|bindTexImage
parameter_list|(
name|egl
operator|::
name|Surface
modifier|*
name|surface
parameter_list|)
block|{
name|releaseTexImage
argument_list|()
expr_stmt|;
name|GLint
name|internalformat
decl_stmt|;
switch|switch
condition|(
name|surface
operator|->
name|getFormat
argument_list|()
condition|)
block|{
case|case
name|D3DFMT_A8R8G8B8
case|:
name|internalformat
operator|=
name|GL_RGBA8_OES
expr_stmt|;
break|break;
case|case
name|D3DFMT_X8R8G8B8
case|:
name|internalformat
operator|=
name|GL_RGB8_OES
expr_stmt|;
break|break;
default|default:
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
return|return;
block|}
name|mImageArray
index|[
literal|0
index|]
operator|.
name|redefine
argument_list|(
name|internalformat
argument_list|,
name|surface
operator|->
name|getWidth
argument_list|()
argument_list|,
name|surface
operator|->
name|getHeight
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
operator|delete
name|mTexStorage
expr_stmt|;
name|mTexStorage
operator|=
operator|new
name|TextureStorage2D
argument_list|(
name|surface
operator|->
name|getOffscreenTexture
argument_list|()
argument_list|)
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
name|mSurface
operator|=
name|surface
expr_stmt|;
name|mSurface
operator|->
name|setBoundTexture
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
DECL|function|releaseTexImage
name|void
name|Texture2D
operator|::
name|releaseTexImage
parameter_list|()
block|{
if|if
condition|(
name|mSurface
condition|)
block|{
name|mSurface
operator|->
name|setBoundTexture
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mSurface
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|mTexStorage
condition|)
block|{
operator|delete
name|mTexStorage
expr_stmt|;
name|mTexStorage
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|i
operator|++
control|)
block|{
name|mImageArray
index|[
name|i
index|]
operator|.
name|redefine
argument_list|(
name|GL_RGBA8_OES
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|setCompressedImage
name|void
name|Texture2D
operator|::
name|setCompressedImage
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|imageSize
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
comment|// compressed formats don't have separate sized internal formats-- we can just use the compressed format directly
name|redefineImage
argument_list|(
name|level
argument_list|,
name|format
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|Texture
operator|::
name|setCompressedImage
argument_list|(
name|imageSize
argument_list|,
name|pixels
argument_list|,
operator|&
name|mImageArray
index|[
name|level
index|]
argument_list|)
expr_stmt|;
block|}
DECL|function|commitRect
name|void
name|Texture2D
operator|::
name|commitRect
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|mImageArray
index|[
name|level
index|]
operator|.
name|getSurface
argument_list|()
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|<
name|levelCount
argument_list|()
condition|)
block|{
name|IDirect3DSurface9
modifier|*
name|destLevel
init|=
name|mTexStorage
operator|->
name|getSurfaceLevel
argument_list|(
name|level
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|destLevel
condition|)
block|{
name|Image
modifier|*
name|image
init|=
operator|&
name|mImageArray
index|[
name|level
index|]
decl_stmt|;
name|image
operator|->
name|updateSurface
argument_list|(
name|destLevel
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|destLevel
operator|->
name|Release
argument_list|()
expr_stmt|;
name|image
operator|->
name|markClean
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|function|subImage
name|void
name|Texture2D
operator|::
name|subImage
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLint
name|unpackAlignment
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
if|if
condition|(
name|Texture
operator|::
name|subImage
argument_list|(
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|unpackAlignment
argument_list|,
name|pixels
argument_list|,
operator|&
name|mImageArray
index|[
name|level
index|]
argument_list|)
condition|)
block|{
name|commitRect
argument_list|(
name|level
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|subImageCompressed
name|void
name|Texture2D
operator|::
name|subImageCompressed
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLsizei
name|imageSize
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
if|if
condition|(
name|Texture
operator|::
name|subImageCompressed
argument_list|(
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|imageSize
argument_list|,
name|pixels
argument_list|,
operator|&
name|mImageArray
index|[
name|level
index|]
argument_list|)
condition|)
block|{
name|commitRect
argument_list|(
name|level
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|copyImage
name|void
name|Texture2D
operator|::
name|copyImage
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|Framebuffer
modifier|*
name|source
parameter_list|)
block|{
name|IDirect3DSurface9
modifier|*
name|renderTarget
init|=
name|source
operator|->
name|getRenderTarget
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|renderTarget
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the render target."
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
name|GLint
name|internalformat
init|=
name|ConvertSizedInternalFormat
argument_list|(
name|format
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|)
decl_stmt|;
name|redefineImage
argument_list|(
name|level
argument_list|,
name|internalformat
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mImageArray
index|[
name|level
index|]
operator|.
name|isRenderableFormat
argument_list|()
condition|)
block|{
name|mImageArray
index|[
name|level
index|]
operator|.
name|copy
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|renderTarget
argument_list|)
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|mTexStorage
operator|||
operator|!
name|mTexStorage
operator|->
name|isRenderTarget
argument_list|()
condition|)
block|{
name|convertToRenderTarget
argument_list|()
expr_stmt|;
block|}
name|mImageArray
index|[
name|level
index|]
operator|.
name|markClean
argument_list|()
expr_stmt|;
if|if
condition|(
name|width
operator|!=
literal|0
operator|&&
name|height
operator|!=
literal|0
operator|&&
name|level
operator|<
name|levelCount
argument_list|()
condition|)
block|{
name|RECT
name|sourceRect
decl_stmt|;
name|sourceRect
operator|.
name|left
operator|=
name|x
expr_stmt|;
name|sourceRect
operator|.
name|right
operator|=
name|x
operator|+
name|width
expr_stmt|;
name|sourceRect
operator|.
name|top
operator|=
name|y
expr_stmt|;
name|sourceRect
operator|.
name|bottom
operator|=
name|y
operator|+
name|height
expr_stmt|;
name|IDirect3DSurface9
modifier|*
name|dest
init|=
name|mTexStorage
operator|->
name|getSurfaceLevel
argument_list|(
name|level
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|dest
condition|)
block|{
name|getBlitter
argument_list|()
operator|->
name|copy
argument_list|(
name|renderTarget
argument_list|,
name|sourceRect
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|dest
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|renderTarget
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
DECL|function|copySubImage
name|void
name|Texture2D
operator|::
name|copySubImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|Framebuffer
modifier|*
name|source
parameter_list|)
block|{
if|if
condition|(
name|xoffset
operator|+
name|width
operator|>
name|mImageArray
index|[
name|level
index|]
operator|.
name|getWidth
argument_list|()
operator|||
name|yoffset
operator|+
name|height
operator|>
name|mImageArray
index|[
name|level
index|]
operator|.
name|getHeight
argument_list|()
condition|)
block|{
return|return
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|IDirect3DSurface9
modifier|*
name|renderTarget
init|=
name|source
operator|->
name|getRenderTarget
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|renderTarget
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the render target."
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|mImageArray
index|[
name|level
index|]
operator|.
name|isRenderableFormat
argument_list|()
operator|||
operator|(
operator|!
name|mTexStorage
operator|&&
operator|!
name|isSamplerComplete
argument_list|()
operator|)
condition|)
block|{
name|mImageArray
index|[
name|level
index|]
operator|.
name|copy
argument_list|(
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|renderTarget
argument_list|)
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|mTexStorage
operator|||
operator|!
name|mTexStorage
operator|->
name|isRenderTarget
argument_list|()
condition|)
block|{
name|convertToRenderTarget
argument_list|()
expr_stmt|;
block|}
name|updateTexture
argument_list|()
expr_stmt|;
if|if
condition|(
name|level
operator|<
name|levelCount
argument_list|()
condition|)
block|{
name|RECT
name|sourceRect
decl_stmt|;
name|sourceRect
operator|.
name|left
operator|=
name|x
expr_stmt|;
name|sourceRect
operator|.
name|right
operator|=
name|x
operator|+
name|width
expr_stmt|;
name|sourceRect
operator|.
name|top
operator|=
name|y
expr_stmt|;
name|sourceRect
operator|.
name|bottom
operator|=
name|y
operator|+
name|height
expr_stmt|;
name|IDirect3DSurface9
modifier|*
name|dest
init|=
name|mTexStorage
operator|->
name|getSurfaceLevel
argument_list|(
name|level
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|dest
condition|)
block|{
name|getBlitter
argument_list|()
operator|->
name|copy
argument_list|(
name|renderTarget
argument_list|,
name|sourceRect
argument_list|,
name|gl
operator|::
name|ExtractFormat
argument_list|(
name|mImageArray
index|[
literal|0
index|]
operator|.
name|getInternalFormat
argument_list|()
argument_list|)
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|dest
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|renderTarget
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
DECL|function|storage
name|void
name|Texture2D
operator|::
name|storage
parameter_list|(
name|GLsizei
name|levels
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
name|D3DFORMAT
name|d3dfmt
init|=
name|ConvertTextureInternalFormat
argument_list|(
name|internalformat
argument_list|)
decl_stmt|;
name|DWORD
name|d3dusage
init|=
name|GetTextureUsage
argument_list|(
name|d3dfmt
argument_list|,
name|mUsage
argument_list|,
literal|false
argument_list|)
decl_stmt|;
operator|delete
name|mTexStorage
expr_stmt|;
name|mTexStorage
operator|=
operator|new
name|TextureStorage2D
argument_list|(
name|levels
argument_list|,
name|d3dfmt
argument_list|,
name|d3dusage
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|mImmutable
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|levels
condition|;
name|level
operator|++
control|)
block|{
name|mImageArray
index|[
name|level
index|]
operator|.
name|redefine
argument_list|(
name|internalformat
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|width
operator|=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|width
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|height
operator|=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|height
operator|>>
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|level
init|=
name|levels
init|;
name|level
operator|<
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|level
operator|++
control|)
block|{
name|mImageArray
index|[
name|level
index|]
operator|.
name|redefine
argument_list|(
name|GL_NONE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mTexStorage
operator|->
name|isManaged
argument_list|()
condition|)
block|{
name|int
name|levels
init|=
name|levelCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|levels
condition|;
name|level
operator|++
control|)
block|{
name|IDirect3DSurface9
modifier|*
name|surface
init|=
name|mTexStorage
operator|->
name|getSurfaceLevel
argument_list|(
name|level
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|mImageArray
index|[
name|level
index|]
operator|.
name|setManagedSurface
argument_list|(
name|surface
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Tests for 2D texture sampling completeness. [OpenGL ES 2.0.24] section 3.8.2 page 85.
DECL|function|isSamplerComplete
name|bool
name|Texture2D
operator|::
name|isSamplerComplete
parameter_list|()
specifier|const
block|{
name|GLsizei
name|width
init|=
name|mImageArray
index|[
literal|0
index|]
operator|.
name|getWidth
argument_list|()
decl_stmt|;
name|GLsizei
name|height
init|=
name|mImageArray
index|[
literal|0
index|]
operator|.
name|getHeight
argument_list|()
decl_stmt|;
if|if
condition|(
name|width
operator|<=
literal|0
operator|||
name|height
operator|<=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|bool
name|mipmapping
init|=
literal|false
decl_stmt|;
switch|switch
condition|(
name|mMinFilter
condition|)
block|{
case|case
name|GL_NEAREST
case|:
case|case
name|GL_LINEAR
case|:
name|mipmapping
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|GL_NEAREST_MIPMAP_NEAREST
case|:
case|case
name|GL_LINEAR_MIPMAP_NEAREST
case|:
case|case
name|GL_NEAREST_MIPMAP_LINEAR
case|:
case|case
name|GL_LINEAR_MIPMAP_LINEAR
case|:
name|mipmapping
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|IsFloat32Format
argument_list|(
name|getInternalFormat
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|getContext
argument_list|()
operator|->
name|supportsFloat32LinearFilter
argument_list|()
operator|)
operator|||
operator|(
name|IsFloat16Format
argument_list|(
name|getInternalFormat
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|getContext
argument_list|()
operator|->
name|supportsFloat16LinearFilter
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|mMagFilter
operator|!=
name|GL_NEAREST
operator|||
operator|(
name|mMinFilter
operator|!=
name|GL_NEAREST
operator|&&
name|mMinFilter
operator|!=
name|GL_NEAREST_MIPMAP_NEAREST
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
name|bool
name|npotSupport
init|=
name|getContext
argument_list|()
operator|->
name|supportsNonPower2Texture
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|npotSupport
condition|)
block|{
if|if
condition|(
operator|(
name|getWrapS
argument_list|()
operator|!=
name|GL_CLAMP_TO_EDGE
operator|&&
operator|!
name|isPow2
argument_list|(
name|width
argument_list|)
operator|)
operator|||
operator|(
name|getWrapT
argument_list|()
operator|!=
name|GL_CLAMP_TO_EDGE
operator|&&
operator|!
name|isPow2
argument_list|(
name|height
argument_list|)
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|mipmapping
condition|)
block|{
if|if
condition|(
operator|!
name|npotSupport
condition|)
block|{
if|if
condition|(
operator|!
name|isPow2
argument_list|(
name|width
argument_list|)
operator|||
operator|!
name|isPow2
argument_list|(
name|height
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
operator|!
name|isMipmapComplete
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|// Tests for 2D texture (mipmap) completeness. [OpenGL ES 2.0.24] section 3.7.10 page 81.
DECL|function|isMipmapComplete
name|bool
name|Texture2D
operator|::
name|isMipmapComplete
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isImmutable
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
name|GLsizei
name|width
init|=
name|mImageArray
index|[
literal|0
index|]
operator|.
name|getWidth
argument_list|()
decl_stmt|;
name|GLsizei
name|height
init|=
name|mImageArray
index|[
literal|0
index|]
operator|.
name|getHeight
argument_list|()
decl_stmt|;
if|if
condition|(
name|width
operator|<=
literal|0
operator|||
name|height
operator|<=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|q
init|=
name|log2
argument_list|(
name|std
operator|::
name|max
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<=
name|q
condition|;
name|level
operator|++
control|)
block|{
if|if
condition|(
name|mImageArray
index|[
name|level
index|]
operator|.
name|getInternalFormat
argument_list|()
operator|!=
name|mImageArray
index|[
literal|0
index|]
operator|.
name|getInternalFormat
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|mImageArray
index|[
name|level
index|]
operator|.
name|getWidth
argument_list|()
operator|!=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|width
operator|>>
name|level
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|mImageArray
index|[
name|level
index|]
operator|.
name|getHeight
argument_list|()
operator|!=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|height
operator|>>
name|level
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|isCompressed
name|bool
name|Texture2D
operator|::
name|isCompressed
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
return|return
name|IsCompressed
argument_list|(
name|getInternalFormat
argument_list|(
name|level
argument_list|)
argument_list|)
return|;
block|}
DECL|function|isDepth
name|bool
name|Texture2D
operator|::
name|isDepth
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
return|return
name|IsDepthTexture
argument_list|(
name|getInternalFormat
argument_list|(
name|level
argument_list|)
argument_list|)
return|;
block|}
DECL|function|getBaseTexture
name|IDirect3DBaseTexture9
modifier|*
name|Texture2D
operator|::
name|getBaseTexture
parameter_list|()
specifier|const
block|{
return|return
name|mTexStorage
condition|?
name|mTexStorage
operator|->
name|getBaseTexture
argument_list|()
else|:
name|NULL
return|;
block|}
comment|// Constructs a Direct3D 9 texture resource from the texture images
DECL|function|createTexture
name|void
name|Texture2D
operator|::
name|createTexture
parameter_list|()
block|{
name|GLsizei
name|width
init|=
name|mImageArray
index|[
literal|0
index|]
operator|.
name|getWidth
argument_list|()
decl_stmt|;
name|GLsizei
name|height
init|=
name|mImageArray
index|[
literal|0
index|]
operator|.
name|getHeight
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|width
operator|>
literal|0
operator|&&
name|height
operator|>
literal|0
operator|)
condition|)
return|return;
comment|// do not attempt to create d3d textures for nonexistant data
name|GLint
name|levels
init|=
name|creationLevels
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
decl_stmt|;
name|D3DFORMAT
name|d3dfmt
init|=
name|mImageArray
index|[
literal|0
index|]
operator|.
name|getD3DFormat
argument_list|()
decl_stmt|;
name|DWORD
name|d3dusage
init|=
name|GetTextureUsage
argument_list|(
name|d3dfmt
argument_list|,
name|mUsage
argument_list|,
literal|false
argument_list|)
decl_stmt|;
operator|delete
name|mTexStorage
expr_stmt|;
name|mTexStorage
operator|=
operator|new
name|TextureStorage2D
argument_list|(
name|levels
argument_list|,
name|d3dfmt
argument_list|,
name|d3dusage
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|mTexStorage
operator|->
name|isManaged
argument_list|()
condition|)
block|{
name|int
name|levels
init|=
name|levelCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|levels
condition|;
name|level
operator|++
control|)
block|{
name|IDirect3DSurface9
modifier|*
name|surface
init|=
name|mTexStorage
operator|->
name|getSurfaceLevel
argument_list|(
name|level
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|mImageArray
index|[
name|level
index|]
operator|.
name|setManagedSurface
argument_list|(
name|surface
argument_list|)
expr_stmt|;
block|}
block|}
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|updateTexture
name|void
name|Texture2D
operator|::
name|updateTexture
parameter_list|()
block|{
name|int
name|levels
init|=
name|levelCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|levels
condition|;
name|level
operator|++
control|)
block|{
name|Image
modifier|*
name|image
init|=
operator|&
name|mImageArray
index|[
name|level
index|]
decl_stmt|;
if|if
condition|(
name|image
operator|->
name|isDirty
argument_list|()
condition|)
block|{
name|commitRect
argument_list|(
name|level
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|mImageArray
index|[
name|level
index|]
operator|.
name|getWidth
argument_list|()
argument_list|,
name|mImageArray
index|[
name|level
index|]
operator|.
name|getHeight
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|convertToRenderTarget
name|void
name|Texture2D
operator|::
name|convertToRenderTarget
parameter_list|()
block|{
name|TextureStorage2D
modifier|*
name|newTexStorage
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|mImageArray
index|[
literal|0
index|]
operator|.
name|getWidth
argument_list|()
operator|!=
literal|0
operator|&&
name|mImageArray
index|[
literal|0
index|]
operator|.
name|getHeight
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|GLsizei
name|width
init|=
name|mImageArray
index|[
literal|0
index|]
operator|.
name|getWidth
argument_list|()
decl_stmt|;
name|GLsizei
name|height
init|=
name|mImageArray
index|[
literal|0
index|]
operator|.
name|getHeight
argument_list|()
decl_stmt|;
name|GLint
name|levels
init|=
name|creationLevels
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
decl_stmt|;
name|D3DFORMAT
name|d3dfmt
init|=
name|mImageArray
index|[
literal|0
index|]
operator|.
name|getD3DFormat
argument_list|()
decl_stmt|;
name|DWORD
name|d3dusage
init|=
name|GetTextureUsage
argument_list|(
name|d3dfmt
argument_list|,
name|GL_FRAMEBUFFER_ATTACHMENT_ANGLE
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|newTexStorage
operator|=
operator|new
name|TextureStorage2D
argument_list|(
name|levels
argument_list|,
name|d3dfmt
argument_list|,
name|d3dusage
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|mTexStorage
operator|!=
name|NULL
condition|)
block|{
name|int
name|levels
init|=
name|levelCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|levels
condition|;
name|i
operator|++
control|)
block|{
name|IDirect3DSurface9
modifier|*
name|source
init|=
name|mTexStorage
operator|->
name|getSurfaceLevel
argument_list|(
name|i
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|IDirect3DSurface9
modifier|*
name|dest
init|=
name|newTexStorage
operator|->
name|getSurfaceLevel
argument_list|(
name|i
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|copyToRenderTarget
argument_list|(
name|dest
argument_list|,
name|source
argument_list|,
name|mTexStorage
operator|->
name|isManaged
argument_list|()
argument_list|)
condition|)
block|{
operator|delete
name|newTexStorage
expr_stmt|;
if|if
condition|(
name|source
condition|)
name|source
operator|->
name|Release
argument_list|()
expr_stmt|;
if|if
condition|(
name|dest
condition|)
name|dest
operator|->
name|Release
argument_list|()
expr_stmt|;
return|return
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
if|if
condition|(
name|source
condition|)
name|source
operator|->
name|Release
argument_list|()
expr_stmt|;
if|if
condition|(
name|dest
condition|)
name|dest
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
block|}
block|}
operator|delete
name|mTexStorage
expr_stmt|;
name|mTexStorage
operator|=
name|newTexStorage
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|generateMipmaps
name|void
name|Texture2D
operator|::
name|generateMipmaps
parameter_list|()
block|{
if|if
condition|(
operator|!
name|getContext
argument_list|()
operator|->
name|supportsNonPower2Texture
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|isPow2
argument_list|(
name|mImageArray
index|[
literal|0
index|]
operator|.
name|getWidth
argument_list|()
argument_list|)
operator|||
operator|!
name|isPow2
argument_list|(
name|mImageArray
index|[
literal|0
index|]
operator|.
name|getHeight
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
block|}
comment|// Purge array levels 1 through q and reset them to represent the generated mipmap levels.
name|unsigned
name|int
name|q
init|=
name|log2
argument_list|(
name|std
operator|::
name|max
argument_list|(
name|mImageArray
index|[
literal|0
index|]
operator|.
name|getWidth
argument_list|()
argument_list|,
name|mImageArray
index|[
literal|0
index|]
operator|.
name|getHeight
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|q
condition|;
name|i
operator|++
control|)
block|{
name|redefineImage
argument_list|(
name|i
argument_list|,
name|mImageArray
index|[
literal|0
index|]
operator|.
name|getInternalFormat
argument_list|()
argument_list|,
name|std
operator|::
name|max
argument_list|(
name|mImageArray
index|[
literal|0
index|]
operator|.
name|getWidth
argument_list|()
operator|>>
name|i
argument_list|,
literal|1
argument_list|)
argument_list|,
name|std
operator|::
name|max
argument_list|(
name|mImageArray
index|[
literal|0
index|]
operator|.
name|getHeight
argument_list|()
operator|>>
name|i
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mTexStorage
operator|&&
name|mTexStorage
operator|->
name|isRenderTarget
argument_list|()
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|q
condition|;
name|i
operator|++
control|)
block|{
name|IDirect3DSurface9
modifier|*
name|upper
init|=
name|mTexStorage
operator|->
name|getSurfaceLevel
argument_list|(
name|i
operator|-
literal|1
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|IDirect3DSurface9
modifier|*
name|lower
init|=
name|mTexStorage
operator|->
name|getSurfaceLevel
argument_list|(
name|i
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|upper
operator|!=
name|NULL
operator|&&
name|lower
operator|!=
name|NULL
condition|)
block|{
name|getBlitter
argument_list|()
operator|->
name|boxFilter
argument_list|(
name|upper
argument_list|,
name|lower
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|upper
operator|!=
name|NULL
condition|)
name|upper
operator|->
name|Release
argument_list|()
expr_stmt|;
if|if
condition|(
name|lower
operator|!=
name|NULL
condition|)
name|lower
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mImageArray
index|[
name|i
index|]
operator|.
name|markClean
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|q
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mImageArray
index|[
name|i
index|]
operator|.
name|getSurface
argument_list|()
operator|==
name|NULL
condition|)
block|{
return|return
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
name|GenerateMip
argument_list|(
name|mImageArray
index|[
name|i
index|]
operator|.
name|getSurface
argument_list|()
argument_list|,
name|mImageArray
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|getSurface
argument_list|()
argument_list|)
expr_stmt|;
name|mImageArray
index|[
name|i
index|]
operator|.
name|markDirty
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|function|getRenderbuffer
name|Renderbuffer
modifier|*
name|Texture2D
operator|::
name|getRenderbuffer
parameter_list|(
name|GLenum
name|target
parameter_list|)
block|{
if|if
condition|(
name|target
operator|!=
name|GL_TEXTURE_2D
condition|)
block|{
return|return
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
operator|(
name|Renderbuffer
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
if|if
condition|(
name|mColorbufferProxy
operator|==
name|NULL
condition|)
block|{
name|mColorbufferProxy
operator|=
operator|new
name|Renderbuffer
argument_list|(
name|id
argument_list|()
argument_list|,
operator|new
name|RenderbufferTexture2D
argument_list|(
name|this
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|mColorbufferProxy
return|;
block|}
comment|// Increments refcount on surface.
comment|// caller must Release() the returned surface
DECL|function|getRenderTarget
name|IDirect3DSurface9
modifier|*
name|Texture2D
operator|::
name|getRenderTarget
parameter_list|(
name|GLenum
name|target
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|GL_TEXTURE_2D
argument_list|)
expr_stmt|;
comment|// ensure the underlying texture is created
if|if
condition|(
name|getStorage
argument_list|(
literal|true
argument_list|)
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|updateTexture
argument_list|()
expr_stmt|;
comment|// ensure this is NOT a depth texture
if|if
condition|(
name|isDepth
argument_list|(
literal|0
argument_list|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
name|mTexStorage
operator|->
name|getSurfaceLevel
argument_list|(
literal|0
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|// Increments refcount on surface.
comment|// caller must Release() the returned surface
DECL|function|getDepthStencil
name|IDirect3DSurface9
modifier|*
name|Texture2D
operator|::
name|getDepthStencil
parameter_list|(
name|GLenum
name|target
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|GL_TEXTURE_2D
argument_list|)
expr_stmt|;
comment|// ensure the underlying texture is created
if|if
condition|(
name|getStorage
argument_list|(
literal|true
argument_list|)
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|updateTexture
argument_list|()
expr_stmt|;
comment|// ensure this is actually a depth texture
if|if
condition|(
operator|!
name|isDepth
argument_list|(
literal|0
argument_list|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
name|mTexStorage
operator|->
name|getSurfaceLevel
argument_list|(
literal|0
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|function|getStorage
name|TextureStorage
modifier|*
name|Texture2D
operator|::
name|getStorage
parameter_list|(
name|bool
name|renderTarget
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mTexStorage
operator|||
operator|(
name|renderTarget
operator|&&
operator|!
name|mTexStorage
operator|->
name|isRenderTarget
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|renderTarget
condition|)
block|{
name|convertToRenderTarget
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|createTexture
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|mTexStorage
return|;
block|}
DECL|function|TextureStorageCubeMap
name|TextureStorageCubeMap
operator|::
name|TextureStorageCubeMap
parameter_list|(
name|int
name|levels
parameter_list|,
name|D3DFORMAT
name|format
parameter_list|,
name|DWORD
name|usage
parameter_list|,
name|int
name|size
parameter_list|)
member_init_list|:
name|TextureStorage
argument_list|(
name|usage
argument_list|)
member_init_list|,
name|mFirstRenderTargetSerial
argument_list|(
name|RenderbufferStorage
operator|::
name|issueCubeSerials
argument_list|()
argument_list|)
block|{
name|mTexture
operator|=
name|NULL
expr_stmt|;
comment|// if the size is not positive this should be treated as an incomplete texture
comment|// we handle that here by skipping the d3d texture creation
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|IDirect3DDevice9
modifier|*
name|device
init|=
name|getDevice
argument_list|()
decl_stmt|;
name|int
name|height
init|=
name|size
decl_stmt|;
name|MakeValidSize
argument_list|(
literal|false
argument_list|,
name|dx
operator|::
name|IsCompressedFormat
argument_list|(
name|format
argument_list|)
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|height
argument_list|,
operator|&
name|mLodOffset
argument_list|)
expr_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateCubeTexture
argument_list|(
name|size
argument_list|,
name|levels
condition|?
name|levels
operator|+
name|mLodOffset
else|:
literal|0
argument_list|,
name|getUsage
argument_list|()
argument_list|,
name|format
argument_list|,
name|getPool
argument_list|()
argument_list|,
operator|&
name|mTexture
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|result
operator|==
name|D3DERR_OUTOFVIDEOMEMORY
operator|||
name|result
operator|==
name|E_OUTOFMEMORY
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|~TextureStorageCubeMap
name|TextureStorageCubeMap
operator|::
name|~
name|TextureStorageCubeMap
parameter_list|()
block|{
if|if
condition|(
name|mTexture
condition|)
block|{
name|mTexture
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Increments refcount on surface.
comment|// caller must Release() the returned surface
DECL|function|getCubeMapSurface
name|IDirect3DSurface9
modifier|*
name|TextureStorageCubeMap
operator|::
name|getCubeMapSurface
parameter_list|(
name|GLenum
name|faceTarget
parameter_list|,
name|int
name|level
parameter_list|,
name|bool
name|dirty
parameter_list|)
block|{
name|IDirect3DSurface9
modifier|*
name|surface
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|mTexture
condition|)
block|{
name|D3DCUBEMAP_FACES
name|face
init|=
name|es2dx
operator|::
name|ConvertCubeFace
argument_list|(
name|faceTarget
argument_list|)
decl_stmt|;
name|HRESULT
name|result
init|=
name|mTexture
operator|->
name|GetCubeMapSurface
argument_list|(
name|face
argument_list|,
name|level
operator|+
name|mLodOffset
argument_list|,
operator|&
name|surface
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
comment|// With managed textures the driver needs to be informed of updates to the lower mipmap levels
if|if
condition|(
name|level
operator|!=
literal|0
operator|&&
name|isManaged
argument_list|()
operator|&&
name|dirty
condition|)
block|{
name|mTexture
operator|->
name|AddDirtyRect
argument_list|(
name|face
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|surface
return|;
block|}
DECL|function|getBaseTexture
name|IDirect3DBaseTexture9
modifier|*
name|TextureStorageCubeMap
operator|::
name|getBaseTexture
parameter_list|()
specifier|const
block|{
return|return
name|mTexture
return|;
block|}
DECL|function|getRenderTargetSerial
name|unsigned
name|int
name|TextureStorageCubeMap
operator|::
name|getRenderTargetSerial
parameter_list|(
name|GLenum
name|target
parameter_list|)
specifier|const
block|{
return|return
name|mFirstRenderTargetSerial
operator|+
name|TextureCubeMap
operator|::
name|faceIndex
argument_list|(
name|target
argument_list|)
return|;
block|}
DECL|function|TextureCubeMap
name|TextureCubeMap
operator|::
name|TextureCubeMap
parameter_list|(
name|GLuint
name|id
parameter_list|)
member_init_list|:
name|Texture
argument_list|(
name|id
argument_list|)
block|{
name|mTexStorage
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|mFaceProxies
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|mFaceProxyRefs
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
DECL|function|~TextureCubeMap
name|TextureCubeMap
operator|::
name|~
name|TextureCubeMap
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|mFaceProxies
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
operator|delete
name|mTexStorage
expr_stmt|;
name|mTexStorage
operator|=
name|NULL
expr_stmt|;
block|}
comment|// We need to maintain a count of references to renderbuffers acting as
comment|// proxies for this texture, so that the texture is not deleted while
comment|// proxy references still exist. If the reference count drops to zero,
comment|// we set our proxy pointer NULL, so that a new attempt at referencing
comment|// will cause recreation.
DECL|function|addProxyRef
name|void
name|TextureCubeMap
operator|::
name|addProxyRef
parameter_list|(
specifier|const
name|Renderbuffer
modifier|*
name|proxy
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mFaceProxies
index|[
name|i
index|]
operator|==
name|proxy
condition|)
name|mFaceProxyRefs
index|[
name|i
index|]
operator|++
expr_stmt|;
block|}
block|}
DECL|function|releaseProxy
name|void
name|TextureCubeMap
operator|::
name|releaseProxy
parameter_list|(
specifier|const
name|Renderbuffer
modifier|*
name|proxy
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mFaceProxies
index|[
name|i
index|]
operator|==
name|proxy
condition|)
block|{
if|if
condition|(
name|mFaceProxyRefs
index|[
name|i
index|]
operator|>
literal|0
condition|)
name|mFaceProxyRefs
index|[
name|i
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|mFaceProxyRefs
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|mFaceProxies
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
DECL|function|getTarget
name|GLenum
name|TextureCubeMap
operator|::
name|getTarget
parameter_list|()
specifier|const
block|{
return|return
name|GL_TEXTURE_CUBE_MAP
return|;
block|}
DECL|function|getWidth
name|GLsizei
name|TextureCubeMap
operator|::
name|getWidth
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|level
operator|<
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
return|return
name|mImageArray
index|[
name|faceIndex
argument_list|(
name|target
argument_list|)
index|]
index|[
name|level
index|]
operator|.
name|getWidth
argument_list|()
return|;
else|else
return|return
literal|0
return|;
block|}
DECL|function|getHeight
name|GLsizei
name|TextureCubeMap
operator|::
name|getHeight
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|level
operator|<
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
return|return
name|mImageArray
index|[
name|faceIndex
argument_list|(
name|target
argument_list|)
index|]
index|[
name|level
index|]
operator|.
name|getHeight
argument_list|()
return|;
else|else
return|return
literal|0
return|;
block|}
DECL|function|getInternalFormat
name|GLenum
name|TextureCubeMap
operator|::
name|getInternalFormat
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|level
operator|<
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
return|return
name|mImageArray
index|[
name|faceIndex
argument_list|(
name|target
argument_list|)
index|]
index|[
name|level
index|]
operator|.
name|getInternalFormat
argument_list|()
return|;
else|else
return|return
name|GL_NONE
return|;
block|}
DECL|function|getD3DFormat
name|D3DFORMAT
name|TextureCubeMap
operator|::
name|getD3DFormat
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|level
operator|<
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
return|return
name|mImageArray
index|[
name|faceIndex
argument_list|(
name|target
argument_list|)
index|]
index|[
name|level
index|]
operator|.
name|getD3DFormat
argument_list|()
return|;
else|else
return|return
name|D3DFMT_UNKNOWN
return|;
block|}
DECL|function|setImagePosX
name|void
name|TextureCubeMap
operator|::
name|setImagePosX
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLint
name|unpackAlignment
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
name|setImage
argument_list|(
literal|0
argument_list|,
name|level
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|unpackAlignment
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
block|}
DECL|function|setImageNegX
name|void
name|TextureCubeMap
operator|::
name|setImageNegX
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLint
name|unpackAlignment
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
name|setImage
argument_list|(
literal|1
argument_list|,
name|level
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|unpackAlignment
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
block|}
DECL|function|setImagePosY
name|void
name|TextureCubeMap
operator|::
name|setImagePosY
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLint
name|unpackAlignment
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
name|setImage
argument_list|(
literal|2
argument_list|,
name|level
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|unpackAlignment
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
block|}
DECL|function|setImageNegY
name|void
name|TextureCubeMap
operator|::
name|setImageNegY
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLint
name|unpackAlignment
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
name|setImage
argument_list|(
literal|3
argument_list|,
name|level
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|unpackAlignment
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
block|}
DECL|function|setImagePosZ
name|void
name|TextureCubeMap
operator|::
name|setImagePosZ
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLint
name|unpackAlignment
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
name|setImage
argument_list|(
literal|4
argument_list|,
name|level
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|unpackAlignment
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
block|}
DECL|function|setImageNegZ
name|void
name|TextureCubeMap
operator|::
name|setImageNegZ
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLint
name|unpackAlignment
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
name|setImage
argument_list|(
literal|5
argument_list|,
name|level
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|unpackAlignment
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
block|}
DECL|function|setCompressedImage
name|void
name|TextureCubeMap
operator|::
name|setCompressedImage
parameter_list|(
name|GLenum
name|face
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|imageSize
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
comment|// compressed formats don't have separate sized internal formats-- we can just use the compressed format directly
name|redefineImage
argument_list|(
name|faceIndex
argument_list|(
name|face
argument_list|)
argument_list|,
name|level
argument_list|,
name|format
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|Texture
operator|::
name|setCompressedImage
argument_list|(
name|imageSize
argument_list|,
name|pixels
argument_list|,
operator|&
name|mImageArray
index|[
name|faceIndex
argument_list|(
name|face
argument_list|)
index|]
index|[
name|level
index|]
argument_list|)
expr_stmt|;
block|}
DECL|function|commitRect
name|void
name|TextureCubeMap
operator|::
name|commitRect
parameter_list|(
name|int
name|face
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|mImageArray
index|[
name|face
index|]
index|[
name|level
index|]
operator|.
name|getSurface
argument_list|()
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|<
name|levelCount
argument_list|()
condition|)
block|{
name|IDirect3DSurface9
modifier|*
name|destLevel
init|=
name|mTexStorage
operator|->
name|getCubeMapSurface
argument_list|(
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
operator|+
name|face
argument_list|,
name|level
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|destLevel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|destLevel
operator|!=
name|NULL
condition|)
block|{
name|Image
modifier|*
name|image
init|=
operator|&
name|mImageArray
index|[
name|face
index|]
index|[
name|level
index|]
decl_stmt|;
name|image
operator|->
name|updateSurface
argument_list|(
name|destLevel
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|destLevel
operator|->
name|Release
argument_list|()
expr_stmt|;
name|image
operator|->
name|markClean
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|function|subImage
name|void
name|TextureCubeMap
operator|::
name|subImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLint
name|unpackAlignment
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
if|if
condition|(
name|Texture
operator|::
name|subImage
argument_list|(
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|unpackAlignment
argument_list|,
name|pixels
argument_list|,
operator|&
name|mImageArray
index|[
name|faceIndex
argument_list|(
name|target
argument_list|)
index|]
index|[
name|level
index|]
argument_list|)
condition|)
block|{
name|commitRect
argument_list|(
name|faceIndex
argument_list|(
name|target
argument_list|)
argument_list|,
name|level
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|subImageCompressed
name|void
name|TextureCubeMap
operator|::
name|subImageCompressed
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLsizei
name|imageSize
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
if|if
condition|(
name|Texture
operator|::
name|subImageCompressed
argument_list|(
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|imageSize
argument_list|,
name|pixels
argument_list|,
operator|&
name|mImageArray
index|[
name|faceIndex
argument_list|(
name|target
argument_list|)
index|]
index|[
name|level
index|]
argument_list|)
condition|)
block|{
name|commitRect
argument_list|(
name|faceIndex
argument_list|(
name|target
argument_list|)
argument_list|,
name|level
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Tests for cube map sampling completeness. [OpenGL ES 2.0.24] section 3.8.2 page 86.
DECL|function|isSamplerComplete
name|bool
name|TextureCubeMap
operator|::
name|isSamplerComplete
parameter_list|()
specifier|const
block|{
name|int
name|size
init|=
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|.
name|getWidth
argument_list|()
decl_stmt|;
name|bool
name|mipmapping
decl_stmt|;
switch|switch
condition|(
name|mMinFilter
condition|)
block|{
case|case
name|GL_NEAREST
case|:
case|case
name|GL_LINEAR
case|:
name|mipmapping
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|GL_NEAREST_MIPMAP_NEAREST
case|:
case|case
name|GL_LINEAR_MIPMAP_NEAREST
case|:
case|case
name|GL_NEAREST_MIPMAP_LINEAR
case|:
case|case
name|GL_LINEAR_MIPMAP_LINEAR
case|:
name|mipmapping
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|(
name|gl
operator|::
name|ExtractType
argument_list|(
name|getInternalFormat
argument_list|(
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|GL_FLOAT
operator|&&
operator|!
name|getContext
argument_list|()
operator|->
name|supportsFloat32LinearFilter
argument_list|()
operator|)
operator|||
operator|(
name|gl
operator|::
name|ExtractType
argument_list|(
name|getInternalFormat
argument_list|(
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
argument_list|,
literal|0
argument_list|)
operator|==
name|GL_HALF_FLOAT_OES
argument_list|)
operator|&&
operator|!
name|getContext
argument_list|()
operator|->
name|supportsFloat16LinearFilter
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|mMagFilter
operator|!=
name|GL_NEAREST
operator|||
operator|(
name|mMinFilter
operator|!=
name|GL_NEAREST
operator|&&
name|mMinFilter
operator|!=
name|GL_NEAREST_MIPMAP_NEAREST
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
operator|!
name|isPow2
argument_list|(
name|size
argument_list|)
operator|&&
operator|!
name|getContext
argument_list|()
operator|->
name|supportsNonPower2Texture
argument_list|()
condition|)
block|{
if|if
condition|(
name|getWrapS
argument_list|()
operator|!=
name|GL_CLAMP_TO_EDGE
operator|||
name|getWrapT
argument_list|()
operator|!=
name|GL_CLAMP_TO_EDGE
operator|||
name|mipmapping
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
operator|!
name|mipmapping
condition|)
block|{
if|if
condition|(
operator|!
name|isCubeComplete
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|isMipmapCubeComplete
argument_list|()
condition|)
comment|// Also tests for isCubeComplete()
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|// Tests for cube texture completeness. [OpenGL ES 2.0.24] section 3.7.10 page 81.
DECL|function|isCubeComplete
name|bool
name|TextureCubeMap
operator|::
name|isCubeComplete
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|.
name|getWidth
argument_list|()
operator|<=
literal|0
operator|||
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|.
name|getHeight
argument_list|()
operator|!=
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|.
name|getWidth
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|unsigned
name|int
name|face
init|=
literal|1
init|;
name|face
operator|<
literal|6
condition|;
name|face
operator|++
control|)
block|{
if|if
condition|(
name|mImageArray
index|[
name|face
index|]
index|[
literal|0
index|]
operator|.
name|getWidth
argument_list|()
operator|!=
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|.
name|getWidth
argument_list|()
operator|||
name|mImageArray
index|[
name|face
index|]
index|[
literal|0
index|]
operator|.
name|getWidth
argument_list|()
operator|!=
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|.
name|getHeight
argument_list|()
operator|||
name|mImageArray
index|[
name|face
index|]
index|[
literal|0
index|]
operator|.
name|getInternalFormat
argument_list|()
operator|!=
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|.
name|getInternalFormat
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|isMipmapCubeComplete
name|bool
name|TextureCubeMap
operator|::
name|isMipmapCubeComplete
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isImmutable
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|isCubeComplete
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|GLsizei
name|size
init|=
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|.
name|getWidth
argument_list|()
decl_stmt|;
name|int
name|q
init|=
name|log2
argument_list|(
name|size
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|face
init|=
literal|0
init|;
name|face
operator|<
literal|6
condition|;
name|face
operator|++
control|)
block|{
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<=
name|q
condition|;
name|level
operator|++
control|)
block|{
if|if
condition|(
name|mImageArray
index|[
name|face
index|]
index|[
name|level
index|]
operator|.
name|getInternalFormat
argument_list|()
operator|!=
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|.
name|getInternalFormat
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|mImageArray
index|[
name|face
index|]
index|[
name|level
index|]
operator|.
name|getWidth
argument_list|()
operator|!=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|size
operator|>>
name|level
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|isCompressed
name|bool
name|TextureCubeMap
operator|::
name|isCompressed
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|)
specifier|const
block|{
return|return
name|IsCompressed
argument_list|(
name|getInternalFormat
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
argument_list|)
return|;
block|}
DECL|function|getBaseTexture
name|IDirect3DBaseTexture9
modifier|*
name|TextureCubeMap
operator|::
name|getBaseTexture
parameter_list|()
specifier|const
block|{
return|return
name|mTexStorage
condition|?
name|mTexStorage
operator|->
name|getBaseTexture
argument_list|()
else|:
name|NULL
return|;
block|}
comment|// Constructs a Direct3D 9 texture resource from the texture images, or returns an existing one
DECL|function|createTexture
name|void
name|TextureCubeMap
operator|::
name|createTexture
parameter_list|()
block|{
name|GLsizei
name|size
init|=
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|.
name|getWidth
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|size
operator|>
literal|0
operator|)
condition|)
return|return;
comment|// do not attempt to create d3d textures for nonexistant data
name|GLint
name|levels
init|=
name|creationLevels
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|D3DFORMAT
name|d3dfmt
init|=
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|.
name|getD3DFormat
argument_list|()
decl_stmt|;
name|DWORD
name|d3dusage
init|=
name|GetTextureUsage
argument_list|(
name|d3dfmt
argument_list|,
name|mUsage
argument_list|,
literal|false
argument_list|)
decl_stmt|;
operator|delete
name|mTexStorage
expr_stmt|;
name|mTexStorage
operator|=
operator|new
name|TextureStorageCubeMap
argument_list|(
name|levels
argument_list|,
name|d3dfmt
argument_list|,
name|d3dusage
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|mTexStorage
operator|->
name|isManaged
argument_list|()
condition|)
block|{
name|int
name|levels
init|=
name|levelCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|face
init|=
literal|0
init|;
name|face
operator|<
literal|6
condition|;
name|face
operator|++
control|)
block|{
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|levels
condition|;
name|level
operator|++
control|)
block|{
name|IDirect3DSurface9
modifier|*
name|surface
init|=
name|mTexStorage
operator|->
name|getCubeMapSurface
argument_list|(
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
operator|+
name|face
argument_list|,
name|level
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|mImageArray
index|[
name|face
index|]
index|[
name|level
index|]
operator|.
name|setManagedSurface
argument_list|(
name|surface
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|updateTexture
name|void
name|TextureCubeMap
operator|::
name|updateTexture
parameter_list|()
block|{
for|for
control|(
name|int
name|face
init|=
literal|0
init|;
name|face
operator|<
literal|6
condition|;
name|face
operator|++
control|)
block|{
name|int
name|levels
init|=
name|levelCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|levels
condition|;
name|level
operator|++
control|)
block|{
name|Image
modifier|*
name|image
init|=
operator|&
name|mImageArray
index|[
name|face
index|]
index|[
name|level
index|]
decl_stmt|;
if|if
condition|(
name|image
operator|->
name|isDirty
argument_list|()
condition|)
block|{
name|commitRect
argument_list|(
name|face
argument_list|,
name|level
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|image
operator|->
name|getWidth
argument_list|()
argument_list|,
name|image
operator|->
name|getHeight
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|function|convertToRenderTarget
name|void
name|TextureCubeMap
operator|::
name|convertToRenderTarget
parameter_list|()
block|{
name|TextureStorageCubeMap
modifier|*
name|newTexStorage
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|.
name|getWidth
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|GLsizei
name|size
init|=
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|.
name|getWidth
argument_list|()
decl_stmt|;
name|GLint
name|levels
init|=
name|creationLevels
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|D3DFORMAT
name|d3dfmt
init|=
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|.
name|getD3DFormat
argument_list|()
decl_stmt|;
name|DWORD
name|d3dusage
init|=
name|GetTextureUsage
argument_list|(
name|d3dfmt
argument_list|,
name|GL_FRAMEBUFFER_ATTACHMENT_ANGLE
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|newTexStorage
operator|=
operator|new
name|TextureStorageCubeMap
argument_list|(
name|levels
argument_list|,
name|d3dfmt
argument_list|,
name|d3dusage
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|mTexStorage
operator|!=
name|NULL
condition|)
block|{
name|int
name|levels
init|=
name|levelCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|f
init|=
literal|0
init|;
name|f
operator|<
literal|6
condition|;
name|f
operator|++
control|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|levels
condition|;
name|i
operator|++
control|)
block|{
name|IDirect3DSurface9
modifier|*
name|source
init|=
name|mTexStorage
operator|->
name|getCubeMapSurface
argument_list|(
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
operator|+
name|f
argument_list|,
name|i
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|IDirect3DSurface9
modifier|*
name|dest
init|=
name|newTexStorage
operator|->
name|getCubeMapSurface
argument_list|(
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
operator|+
name|f
argument_list|,
name|i
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|copyToRenderTarget
argument_list|(
name|dest
argument_list|,
name|source
argument_list|,
name|mTexStorage
operator|->
name|isManaged
argument_list|()
argument_list|)
condition|)
block|{
operator|delete
name|newTexStorage
expr_stmt|;
if|if
condition|(
name|source
condition|)
name|source
operator|->
name|Release
argument_list|()
expr_stmt|;
if|if
condition|(
name|dest
condition|)
name|dest
operator|->
name|Release
argument_list|()
expr_stmt|;
return|return
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
if|if
condition|(
name|source
condition|)
name|source
operator|->
name|Release
argument_list|()
expr_stmt|;
if|if
condition|(
name|dest
condition|)
name|dest
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
operator|delete
name|mTexStorage
expr_stmt|;
name|mTexStorage
operator|=
name|newTexStorage
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|setImage
name|void
name|TextureCubeMap
operator|::
name|setImage
parameter_list|(
name|int
name|faceIndex
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLint
name|unpackAlignment
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
name|GLint
name|internalformat
init|=
name|ConvertSizedInternalFormat
argument_list|(
name|format
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|redefineImage
argument_list|(
name|faceIndex
argument_list|,
name|level
argument_list|,
name|internalformat
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|Texture
operator|::
name|setImage
argument_list|(
name|unpackAlignment
argument_list|,
name|pixels
argument_list|,
operator|&
name|mImageArray
index|[
name|faceIndex
index|]
index|[
name|level
index|]
argument_list|)
expr_stmt|;
block|}
DECL|function|faceIndex
name|unsigned
name|int
name|TextureCubeMap
operator|::
name|faceIndex
parameter_list|(
name|GLenum
name|face
parameter_list|)
block|{
name|META_ASSERT
argument_list|(
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_X
operator|-
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
operator|==
literal|1
argument_list|)
expr_stmt|;
name|META_ASSERT
argument_list|(
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Y
operator|-
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
operator|==
literal|2
argument_list|)
expr_stmt|;
name|META_ASSERT
argument_list|(
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
operator|-
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
operator|==
literal|3
argument_list|)
expr_stmt|;
name|META_ASSERT
argument_list|(
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Z
operator|-
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
operator|==
literal|4
argument_list|)
expr_stmt|;
name|META_ASSERT
argument_list|(
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
operator|-
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
operator|==
literal|5
argument_list|)
expr_stmt|;
return|return
name|face
operator|-
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
return|;
block|}
DECL|function|redefineImage
name|void
name|TextureCubeMap
operator|::
name|redefineImage
parameter_list|(
name|int
name|face
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLint
name|internalformat
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
name|bool
name|redefined
init|=
name|mImageArray
index|[
name|face
index|]
index|[
name|level
index|]
operator|.
name|redefine
argument_list|(
name|internalformat
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|mTexStorage
operator|&&
name|redefined
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|int
name|f
init|=
literal|0
init|;
name|f
operator|<
literal|6
condition|;
name|f
operator|++
control|)
block|{
name|mImageArray
index|[
name|f
index|]
index|[
name|i
index|]
operator|.
name|markDirty
argument_list|()
expr_stmt|;
block|}
block|}
operator|delete
name|mTexStorage
expr_stmt|;
name|mTexStorage
operator|=
name|NULL
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|copyImage
name|void
name|TextureCubeMap
operator|::
name|copyImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|Framebuffer
modifier|*
name|source
parameter_list|)
block|{
name|IDirect3DSurface9
modifier|*
name|renderTarget
init|=
name|source
operator|->
name|getRenderTarget
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|renderTarget
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the render target."
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
name|unsigned
name|int
name|faceindex
init|=
name|faceIndex
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|GLint
name|internalformat
init|=
name|gl
operator|::
name|ConvertSizedInternalFormat
argument_list|(
name|format
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|)
decl_stmt|;
name|redefineImage
argument_list|(
name|faceindex
argument_list|,
name|level
argument_list|,
name|internalformat
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mImageArray
index|[
name|faceindex
index|]
index|[
name|level
index|]
operator|.
name|isRenderableFormat
argument_list|()
condition|)
block|{
name|mImageArray
index|[
name|faceindex
index|]
index|[
name|level
index|]
operator|.
name|copy
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|renderTarget
argument_list|)
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|mTexStorage
operator|||
operator|!
name|mTexStorage
operator|->
name|isRenderTarget
argument_list|()
condition|)
block|{
name|convertToRenderTarget
argument_list|()
expr_stmt|;
block|}
name|mImageArray
index|[
name|faceindex
index|]
index|[
name|level
index|]
operator|.
name|markClean
argument_list|()
expr_stmt|;
name|ASSERT
argument_list|(
name|width
operator|==
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|>
literal|0
operator|&&
name|level
operator|<
name|levelCount
argument_list|()
condition|)
block|{
name|RECT
name|sourceRect
decl_stmt|;
name|sourceRect
operator|.
name|left
operator|=
name|x
expr_stmt|;
name|sourceRect
operator|.
name|right
operator|=
name|x
operator|+
name|width
expr_stmt|;
name|sourceRect
operator|.
name|top
operator|=
name|y
expr_stmt|;
name|sourceRect
operator|.
name|bottom
operator|=
name|y
operator|+
name|height
expr_stmt|;
name|IDirect3DSurface9
modifier|*
name|dest
init|=
name|mTexStorage
operator|->
name|getCubeMapSurface
argument_list|(
name|target
argument_list|,
name|level
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|dest
condition|)
block|{
name|getBlitter
argument_list|()
operator|->
name|copy
argument_list|(
name|renderTarget
argument_list|,
name|sourceRect
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|dest
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|renderTarget
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
DECL|function|copySubImage
name|void
name|TextureCubeMap
operator|::
name|copySubImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|Framebuffer
modifier|*
name|source
parameter_list|)
block|{
name|GLsizei
name|size
init|=
name|mImageArray
index|[
name|faceIndex
argument_list|(
name|target
argument_list|)
index|]
index|[
name|level
index|]
operator|.
name|getWidth
argument_list|()
decl_stmt|;
if|if
condition|(
name|xoffset
operator|+
name|width
operator|>
name|size
operator|||
name|yoffset
operator|+
name|height
operator|>
name|size
condition|)
block|{
return|return
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|IDirect3DSurface9
modifier|*
name|renderTarget
init|=
name|source
operator|->
name|getRenderTarget
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|renderTarget
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to retrieve the render target."
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
name|unsigned
name|int
name|faceindex
init|=
name|faceIndex
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mImageArray
index|[
name|faceindex
index|]
index|[
name|level
index|]
operator|.
name|isRenderableFormat
argument_list|()
operator|||
operator|(
operator|!
name|mTexStorage
operator|&&
operator|!
name|isSamplerComplete
argument_list|()
operator|)
condition|)
block|{
name|mImageArray
index|[
name|faceindex
index|]
index|[
name|level
index|]
operator|.
name|copy
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|renderTarget
argument_list|)
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|mTexStorage
operator|||
operator|!
name|mTexStorage
operator|->
name|isRenderTarget
argument_list|()
condition|)
block|{
name|convertToRenderTarget
argument_list|()
expr_stmt|;
block|}
name|updateTexture
argument_list|()
expr_stmt|;
if|if
condition|(
name|level
operator|<
name|levelCount
argument_list|()
condition|)
block|{
name|RECT
name|sourceRect
decl_stmt|;
name|sourceRect
operator|.
name|left
operator|=
name|x
expr_stmt|;
name|sourceRect
operator|.
name|right
operator|=
name|x
operator|+
name|width
expr_stmt|;
name|sourceRect
operator|.
name|top
operator|=
name|y
expr_stmt|;
name|sourceRect
operator|.
name|bottom
operator|=
name|y
operator|+
name|height
expr_stmt|;
name|IDirect3DSurface9
modifier|*
name|dest
init|=
name|mTexStorage
operator|->
name|getCubeMapSurface
argument_list|(
name|target
argument_list|,
name|level
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|dest
condition|)
block|{
name|getBlitter
argument_list|()
operator|->
name|copy
argument_list|(
name|renderTarget
argument_list|,
name|sourceRect
argument_list|,
name|gl
operator|::
name|ExtractFormat
argument_list|(
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|.
name|getInternalFormat
argument_list|()
argument_list|)
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|dest
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|renderTarget
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
DECL|function|storage
name|void
name|TextureCubeMap
operator|::
name|storage
parameter_list|(
name|GLsizei
name|levels
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|GLsizei
name|size
parameter_list|)
block|{
name|D3DFORMAT
name|d3dfmt
init|=
name|ConvertTextureInternalFormat
argument_list|(
name|internalformat
argument_list|)
decl_stmt|;
name|DWORD
name|d3dusage
init|=
name|GetTextureUsage
argument_list|(
name|d3dfmt
argument_list|,
name|mUsage
argument_list|,
literal|false
argument_list|)
decl_stmt|;
operator|delete
name|mTexStorage
expr_stmt|;
name|mTexStorage
operator|=
operator|new
name|TextureStorageCubeMap
argument_list|(
name|levels
argument_list|,
name|d3dfmt
argument_list|,
name|d3dusage
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|mImmutable
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|levels
condition|;
name|level
operator|++
control|)
block|{
for|for
control|(
name|int
name|face
init|=
literal|0
init|;
name|face
operator|<
literal|6
condition|;
name|face
operator|++
control|)
block|{
name|mImageArray
index|[
name|face
index|]
index|[
name|level
index|]
operator|.
name|redefine
argument_list|(
name|internalformat
argument_list|,
name|size
argument_list|,
name|size
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|size
operator|=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|size
operator|>>
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|level
init|=
name|levels
init|;
name|level
operator|<
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|level
operator|++
control|)
block|{
for|for
control|(
name|int
name|face
init|=
literal|0
init|;
name|face
operator|<
literal|6
condition|;
name|face
operator|++
control|)
block|{
name|mImageArray
index|[
name|face
index|]
index|[
name|level
index|]
operator|.
name|redefine
argument_list|(
name|GL_NONE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mTexStorage
operator|->
name|isManaged
argument_list|()
condition|)
block|{
name|int
name|levels
init|=
name|levelCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|face
init|=
literal|0
init|;
name|face
operator|<
literal|6
condition|;
name|face
operator|++
control|)
block|{
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|levels
condition|;
name|level
operator|++
control|)
block|{
name|IDirect3DSurface9
modifier|*
name|surface
init|=
name|mTexStorage
operator|->
name|getCubeMapSurface
argument_list|(
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
operator|+
name|face
argument_list|,
name|level
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|mImageArray
index|[
name|face
index|]
index|[
name|level
index|]
operator|.
name|setManagedSurface
argument_list|(
name|surface
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|function|generateMipmaps
name|void
name|TextureCubeMap
operator|::
name|generateMipmaps
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isCubeComplete
argument_list|()
condition|)
block|{
return|return
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|getContext
argument_list|()
operator|->
name|supportsNonPower2Texture
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|isPow2
argument_list|(
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|.
name|getWidth
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
block|}
comment|// Purge array levels 1 through q and reset them to represent the generated mipmap levels.
name|unsigned
name|int
name|q
init|=
name|log2
argument_list|(
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|.
name|getWidth
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|f
init|=
literal|0
init|;
name|f
operator|<
literal|6
condition|;
name|f
operator|++
control|)
block|{
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|q
condition|;
name|i
operator|++
control|)
block|{
name|redefineImage
argument_list|(
name|f
argument_list|,
name|i
argument_list|,
name|mImageArray
index|[
name|f
index|]
index|[
literal|0
index|]
operator|.
name|getInternalFormat
argument_list|()
argument_list|,
name|std
operator|::
name|max
argument_list|(
name|mImageArray
index|[
name|f
index|]
index|[
literal|0
index|]
operator|.
name|getWidth
argument_list|()
operator|>>
name|i
argument_list|,
literal|1
argument_list|)
argument_list|,
name|std
operator|::
name|max
argument_list|(
name|mImageArray
index|[
name|f
index|]
index|[
literal|0
index|]
operator|.
name|getWidth
argument_list|()
operator|>>
name|i
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mTexStorage
operator|&&
name|mTexStorage
operator|->
name|isRenderTarget
argument_list|()
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|f
init|=
literal|0
init|;
name|f
operator|<
literal|6
condition|;
name|f
operator|++
control|)
block|{
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|q
condition|;
name|i
operator|++
control|)
block|{
name|IDirect3DSurface9
modifier|*
name|upper
init|=
name|mTexStorage
operator|->
name|getCubeMapSurface
argument_list|(
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
operator|+
name|f
argument_list|,
name|i
operator|-
literal|1
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|IDirect3DSurface9
modifier|*
name|lower
init|=
name|mTexStorage
operator|->
name|getCubeMapSurface
argument_list|(
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
operator|+
name|f
argument_list|,
name|i
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|upper
operator|!=
name|NULL
operator|&&
name|lower
operator|!=
name|NULL
condition|)
block|{
name|getBlitter
argument_list|()
operator|->
name|boxFilter
argument_list|(
name|upper
argument_list|,
name|lower
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|upper
operator|!=
name|NULL
condition|)
name|upper
operator|->
name|Release
argument_list|()
expr_stmt|;
if|if
condition|(
name|lower
operator|!=
name|NULL
condition|)
name|lower
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mImageArray
index|[
name|f
index|]
index|[
name|i
index|]
operator|.
name|markClean
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|unsigned
name|int
name|f
init|=
literal|0
init|;
name|f
operator|<
literal|6
condition|;
name|f
operator|++
control|)
block|{
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|q
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mImageArray
index|[
name|f
index|]
index|[
name|i
index|]
operator|.
name|getSurface
argument_list|()
operator|==
name|NULL
condition|)
block|{
return|return
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
name|GenerateMip
argument_list|(
name|mImageArray
index|[
name|f
index|]
index|[
name|i
index|]
operator|.
name|getSurface
argument_list|()
argument_list|,
name|mImageArray
index|[
name|f
index|]
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|getSurface
argument_list|()
argument_list|)
expr_stmt|;
name|mImageArray
index|[
name|f
index|]
index|[
name|i
index|]
operator|.
name|markDirty
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|function|getRenderbuffer
name|Renderbuffer
modifier|*
name|TextureCubeMap
operator|::
name|getRenderbuffer
parameter_list|(
name|GLenum
name|target
parameter_list|)
block|{
if|if
condition|(
operator|!
name|IsCubemapTextureTarget
argument_list|(
name|target
argument_list|)
condition|)
block|{
return|return
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
operator|(
name|Renderbuffer
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
name|unsigned
name|int
name|face
init|=
name|faceIndex
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|mFaceProxies
index|[
name|face
index|]
operator|==
name|NULL
condition|)
block|{
name|mFaceProxies
index|[
name|face
index|]
operator|=
operator|new
name|Renderbuffer
argument_list|(
name|id
argument_list|()
argument_list|,
operator|new
name|RenderbufferTextureCubeMap
argument_list|(
name|this
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|mFaceProxies
index|[
name|face
index|]
return|;
block|}
comment|// Increments refcount on surface.
comment|// caller must Release() the returned surface
DECL|function|getRenderTarget
name|IDirect3DSurface9
modifier|*
name|TextureCubeMap
operator|::
name|getRenderTarget
parameter_list|(
name|GLenum
name|target
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|IsCubemapTextureTarget
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
comment|// ensure the underlying texture is created
if|if
condition|(
name|getStorage
argument_list|(
literal|true
argument_list|)
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|updateTexture
argument_list|()
expr_stmt|;
return|return
name|mTexStorage
operator|->
name|getCubeMapSurface
argument_list|(
name|target
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|function|getStorage
name|TextureStorage
modifier|*
name|TextureCubeMap
operator|::
name|getStorage
parameter_list|(
name|bool
name|renderTarget
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mTexStorage
operator|||
operator|(
name|renderTarget
operator|&&
operator|!
name|mTexStorage
operator|->
name|isRenderTarget
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|renderTarget
condition|)
block|{
name|convertToRenderTarget
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|createTexture
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|mTexStorage
return|;
block|}
block|}
end_namespace
end_unit
