begin_unit
begin_include
include|#
directive|include
file|"precompiled.h"
end_include
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2013 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Texture.cpp: Implements the gl::Texture class and its derived classes
end_comment
begin_comment
comment|// Texture2D and TextureCubeMap. Implements GL texture objects and related
end_comment
begin_comment
comment|// functionality. [OpenGL ES 2.0.24] section 3.7 page 63.
end_comment
begin_include
include|#
directive|include
file|"libGLESv2/Texture.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/main.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/mathutil.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/utilities.h"
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|ANGLE_ENABLE_D3D11
argument_list|)
end_if
begin_define
DECL|macro|D3DFMT_UNKNOWN
define|#
directive|define
name|D3DFMT_UNKNOWN
value|DXGI_FORMAT_UNKNOWN
end_define
begin_else
else|#
directive|else
end_else
begin_include
include|#
directive|include
file|"libGLESv2/renderer/Blit.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"libGLESv2/Renderbuffer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/Image.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/Renderer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/TextureStorage.h"
end_include
begin_include
include|#
directive|include
file|"libEGL/Surface.h"
end_include
begin_namespace
DECL|namespace|gl
namespace|namespace
name|gl
block|{
DECL|function|Texture
name|Texture
operator|::
name|Texture
parameter_list|(
name|rx
operator|::
name|Renderer
modifier|*
name|renderer
parameter_list|,
name|GLuint
name|id
parameter_list|)
member_init_list|:
name|RefCountObject
argument_list|(
name|id
argument_list|)
block|{
name|mRenderer
operator|=
name|renderer
expr_stmt|;
name|mSamplerState
operator|.
name|minFilter
operator|=
name|GL_NEAREST_MIPMAP_LINEAR
expr_stmt|;
name|mSamplerState
operator|.
name|magFilter
operator|=
name|GL_LINEAR
expr_stmt|;
name|mSamplerState
operator|.
name|wrapS
operator|=
name|GL_REPEAT
expr_stmt|;
name|mSamplerState
operator|.
name|wrapT
operator|=
name|GL_REPEAT
expr_stmt|;
name|mSamplerState
operator|.
name|maxAnisotropy
operator|=
literal|1.0f
expr_stmt|;
name|mSamplerState
operator|.
name|lodOffset
operator|=
literal|0
expr_stmt|;
name|mUsage
operator|=
name|GL_NONE
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
name|mImmutable
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|~Texture
name|Texture
operator|::
name|~
name|Texture
parameter_list|()
block|{ }
comment|// Returns true on successful filter state update (valid enum parameter)
DECL|function|setMinFilter
name|bool
name|Texture
operator|::
name|setMinFilter
parameter_list|(
name|GLenum
name|filter
parameter_list|)
block|{
switch|switch
condition|(
name|filter
condition|)
block|{
case|case
name|GL_NEAREST
case|:
case|case
name|GL_LINEAR
case|:
case|case
name|GL_NEAREST_MIPMAP_NEAREST
case|:
case|case
name|GL_LINEAR_MIPMAP_NEAREST
case|:
case|case
name|GL_NEAREST_MIPMAP_LINEAR
case|:
case|case
name|GL_LINEAR_MIPMAP_LINEAR
case|:
name|mSamplerState
operator|.
name|minFilter
operator|=
name|filter
expr_stmt|;
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|// Returns true on successful filter state update (valid enum parameter)
DECL|function|setMagFilter
name|bool
name|Texture
operator|::
name|setMagFilter
parameter_list|(
name|GLenum
name|filter
parameter_list|)
block|{
switch|switch
condition|(
name|filter
condition|)
block|{
case|case
name|GL_NEAREST
case|:
case|case
name|GL_LINEAR
case|:
name|mSamplerState
operator|.
name|magFilter
operator|=
name|filter
expr_stmt|;
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|// Returns true on successful wrap state update (valid enum parameter)
DECL|function|setWrapS
name|bool
name|Texture
operator|::
name|setWrapS
parameter_list|(
name|GLenum
name|wrap
parameter_list|)
block|{
switch|switch
condition|(
name|wrap
condition|)
block|{
case|case
name|GL_REPEAT
case|:
case|case
name|GL_CLAMP_TO_EDGE
case|:
case|case
name|GL_MIRRORED_REPEAT
case|:
name|mSamplerState
operator|.
name|wrapS
operator|=
name|wrap
expr_stmt|;
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|// Returns true on successful wrap state update (valid enum parameter)
DECL|function|setWrapT
name|bool
name|Texture
operator|::
name|setWrapT
parameter_list|(
name|GLenum
name|wrap
parameter_list|)
block|{
switch|switch
condition|(
name|wrap
condition|)
block|{
case|case
name|GL_REPEAT
case|:
case|case
name|GL_CLAMP_TO_EDGE
case|:
case|case
name|GL_MIRRORED_REPEAT
case|:
name|mSamplerState
operator|.
name|wrapT
operator|=
name|wrap
expr_stmt|;
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|// Returns true on successful max anisotropy update (valid anisotropy value)
DECL|function|setMaxAnisotropy
name|bool
name|Texture
operator|::
name|setMaxAnisotropy
parameter_list|(
name|float
name|textureMaxAnisotropy
parameter_list|,
name|float
name|contextMaxAnisotropy
parameter_list|)
block|{
name|textureMaxAnisotropy
operator|=
name|std
operator|::
name|min
argument_list|(
name|textureMaxAnisotropy
argument_list|,
name|contextMaxAnisotropy
argument_list|)
expr_stmt|;
if|if
condition|(
name|textureMaxAnisotropy
operator|<
literal|1.0f
condition|)
block|{
return|return
literal|false
return|;
block|}
name|mSamplerState
operator|.
name|maxAnisotropy
operator|=
name|textureMaxAnisotropy
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// Returns true on successful usage state update (valid enum parameter)
DECL|function|setUsage
name|bool
name|Texture
operator|::
name|setUsage
parameter_list|(
name|GLenum
name|usage
parameter_list|)
block|{
switch|switch
condition|(
name|usage
condition|)
block|{
case|case
name|GL_NONE
case|:
case|case
name|GL_FRAMEBUFFER_ATTACHMENT_ANGLE
case|:
name|mUsage
operator|=
name|usage
expr_stmt|;
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
DECL|function|getMinFilter
name|GLenum
name|Texture
operator|::
name|getMinFilter
parameter_list|()
specifier|const
block|{
return|return
name|mSamplerState
operator|.
name|minFilter
return|;
block|}
DECL|function|getMagFilter
name|GLenum
name|Texture
operator|::
name|getMagFilter
parameter_list|()
specifier|const
block|{
return|return
name|mSamplerState
operator|.
name|magFilter
return|;
block|}
DECL|function|getWrapS
name|GLenum
name|Texture
operator|::
name|getWrapS
parameter_list|()
specifier|const
block|{
return|return
name|mSamplerState
operator|.
name|wrapS
return|;
block|}
DECL|function|getWrapT
name|GLenum
name|Texture
operator|::
name|getWrapT
parameter_list|()
specifier|const
block|{
return|return
name|mSamplerState
operator|.
name|wrapT
return|;
block|}
DECL|function|getMaxAnisotropy
name|float
name|Texture
operator|::
name|getMaxAnisotropy
parameter_list|()
specifier|const
block|{
return|return
name|mSamplerState
operator|.
name|maxAnisotropy
return|;
block|}
DECL|function|getLodOffset
name|int
name|Texture
operator|::
name|getLodOffset
parameter_list|()
block|{
name|rx
operator|::
name|TextureStorageInterface
modifier|*
name|texture
init|=
name|getStorage
argument_list|(
literal|false
argument_list|)
decl_stmt|;
return|return
name|texture
condition|?
name|texture
operator|->
name|getLodOffset
argument_list|()
else|:
literal|0
return|;
block|}
DECL|function|getSamplerState
name|void
name|Texture
operator|::
name|getSamplerState
parameter_list|(
name|SamplerState
modifier|*
name|sampler
parameter_list|)
block|{
operator|*
name|sampler
operator|=
name|mSamplerState
expr_stmt|;
name|sampler
operator|->
name|lodOffset
operator|=
name|getLodOffset
argument_list|()
expr_stmt|;
block|}
DECL|function|getUsage
name|GLenum
name|Texture
operator|::
name|getUsage
parameter_list|()
specifier|const
block|{
return|return
name|mUsage
return|;
block|}
DECL|function|isMipmapFiltered
name|bool
name|Texture
operator|::
name|isMipmapFiltered
parameter_list|()
specifier|const
block|{
switch|switch
condition|(
name|mSamplerState
operator|.
name|minFilter
condition|)
block|{
case|case
name|GL_NEAREST
case|:
case|case
name|GL_LINEAR
case|:
return|return
literal|false
return|;
case|case
name|GL_NEAREST_MIPMAP_NEAREST
case|:
case|case
name|GL_LINEAR_MIPMAP_NEAREST
case|:
case|case
name|GL_NEAREST_MIPMAP_LINEAR
case|:
case|case
name|GL_LINEAR_MIPMAP_LINEAR
case|:
return|return
literal|true
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|setImage
name|void
name|Texture
operator|::
name|setImage
parameter_list|(
name|GLint
name|unpackAlignment
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|,
name|rx
operator|::
name|Image
modifier|*
name|image
parameter_list|)
block|{
if|if
condition|(
name|pixels
operator|!=
name|NULL
condition|)
block|{
name|image
operator|->
name|loadData
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|image
operator|->
name|getWidth
argument_list|()
argument_list|,
name|image
operator|->
name|getHeight
argument_list|()
argument_list|,
name|unpackAlignment
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|setCompressedImage
name|void
name|Texture
operator|::
name|setCompressedImage
parameter_list|(
name|GLsizei
name|imageSize
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|,
name|rx
operator|::
name|Image
modifier|*
name|image
parameter_list|)
block|{
if|if
condition|(
name|pixels
operator|!=
name|NULL
condition|)
block|{
name|image
operator|->
name|loadCompressedData
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|image
operator|->
name|getWidth
argument_list|()
argument_list|,
name|image
operator|->
name|getHeight
argument_list|()
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|subImage
name|bool
name|Texture
operator|::
name|subImage
parameter_list|(
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLint
name|unpackAlignment
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|,
name|rx
operator|::
name|Image
modifier|*
name|image
parameter_list|)
block|{
if|if
condition|(
name|pixels
operator|!=
name|NULL
condition|)
block|{
name|image
operator|->
name|loadData
argument_list|(
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|unpackAlignment
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|subImageCompressed
name|bool
name|Texture
operator|::
name|subImageCompressed
parameter_list|(
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLsizei
name|imageSize
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|,
name|rx
operator|::
name|Image
modifier|*
name|image
parameter_list|)
block|{
if|if
condition|(
name|pixels
operator|!=
name|NULL
condition|)
block|{
name|image
operator|->
name|loadCompressedData
argument_list|(
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|getNativeTexture
name|rx
operator|::
name|TextureStorageInterface
modifier|*
name|Texture
operator|::
name|getNativeTexture
parameter_list|()
block|{
comment|// ensure the underlying texture is created
name|rx
operator|::
name|TextureStorageInterface
modifier|*
name|storage
init|=
name|getStorage
argument_list|(
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|storage
condition|)
block|{
name|updateTexture
argument_list|()
expr_stmt|;
block|}
return|return
name|storage
return|;
block|}
DECL|function|hasDirtyImages
name|bool
name|Texture
operator|::
name|hasDirtyImages
parameter_list|()
specifier|const
block|{
return|return
name|mDirtyImages
return|;
block|}
DECL|function|resetDirty
name|void
name|Texture
operator|::
name|resetDirty
parameter_list|()
block|{
name|mDirtyImages
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|getTextureSerial
name|unsigned
name|int
name|Texture
operator|::
name|getTextureSerial
parameter_list|()
block|{
name|rx
operator|::
name|TextureStorageInterface
modifier|*
name|texture
init|=
name|getStorage
argument_list|(
literal|false
argument_list|)
decl_stmt|;
return|return
name|texture
condition|?
name|texture
operator|->
name|getTextureSerial
argument_list|()
else|:
literal|0
return|;
block|}
DECL|function|getRenderTargetSerial
name|unsigned
name|int
name|Texture
operator|::
name|getRenderTargetSerial
parameter_list|(
name|GLenum
name|target
parameter_list|)
block|{
name|rx
operator|::
name|TextureStorageInterface
modifier|*
name|texture
init|=
name|getStorage
argument_list|(
literal|true
argument_list|)
decl_stmt|;
return|return
name|texture
condition|?
name|texture
operator|->
name|getRenderTargetSerial
argument_list|(
name|target
argument_list|)
else|:
literal|0
return|;
block|}
DECL|function|isImmutable
name|bool
name|Texture
operator|::
name|isImmutable
parameter_list|()
specifier|const
block|{
return|return
name|mImmutable
return|;
block|}
DECL|function|creationLevels
name|GLint
name|Texture
operator|::
name|creationLevels
parameter_list|(
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|(
name|isPow2
argument_list|(
name|width
argument_list|)
operator|&&
name|isPow2
argument_list|(
name|height
argument_list|)
operator|)
operator|||
name|mRenderer
operator|->
name|getNonPower2TextureSupport
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
comment|// Maximum number of levels
block|}
else|else
block|{
comment|// OpenGL ES 2.0 without GL_OES_texture_npot does not permit NPOT mipmaps.
return|return
literal|1
return|;
block|}
block|}
DECL|function|creationLevels
name|GLint
name|Texture
operator|::
name|creationLevels
parameter_list|(
name|GLsizei
name|size
parameter_list|)
specifier|const
block|{
return|return
name|creationLevels
argument_list|(
name|size
argument_list|,
name|size
argument_list|)
return|;
block|}
DECL|function|Texture2D
name|Texture2D
operator|::
name|Texture2D
parameter_list|(
name|rx
operator|::
name|Renderer
modifier|*
name|renderer
parameter_list|,
name|GLuint
name|id
parameter_list|)
member_init_list|:
name|Texture
argument_list|(
name|renderer
argument_list|,
name|id
argument_list|)
block|{
name|mTexStorage
operator|=
name|NULL
expr_stmt|;
name|mSurface
operator|=
name|NULL
expr_stmt|;
name|mColorbufferProxy
operator|=
name|NULL
expr_stmt|;
name|mProxyRefs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
operator|++
name|i
control|)
block|{
name|mImageArray
index|[
name|i
index|]
operator|=
name|renderer
operator|->
name|createImage
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|~Texture2D
name|Texture2D
operator|::
name|~
name|Texture2D
parameter_list|()
block|{
name|mColorbufferProxy
operator|=
name|NULL
expr_stmt|;
operator|delete
name|mTexStorage
expr_stmt|;
name|mTexStorage
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|mSurface
condition|)
block|{
name|mSurface
operator|->
name|setBoundTexture
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mSurface
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
operator|++
name|i
control|)
block|{
operator|delete
name|mImageArray
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
comment|// We need to maintain a count of references to renderbuffers acting as
comment|// proxies for this texture, so that we do not attempt to use a pointer
comment|// to a renderbuffer proxy which has been deleted.
DECL|function|addProxyRef
name|void
name|Texture2D
operator|::
name|addProxyRef
parameter_list|(
specifier|const
name|Renderbuffer
modifier|*
name|proxy
parameter_list|)
block|{
name|mProxyRefs
operator|++
expr_stmt|;
block|}
DECL|function|releaseProxy
name|void
name|Texture2D
operator|::
name|releaseProxy
parameter_list|(
specifier|const
name|Renderbuffer
modifier|*
name|proxy
parameter_list|)
block|{
if|if
condition|(
name|mProxyRefs
operator|>
literal|0
condition|)
name|mProxyRefs
operator|--
expr_stmt|;
if|if
condition|(
name|mProxyRefs
operator|==
literal|0
condition|)
name|mColorbufferProxy
operator|=
name|NULL
expr_stmt|;
block|}
DECL|function|getTarget
name|GLenum
name|Texture2D
operator|::
name|getTarget
parameter_list|()
specifier|const
block|{
return|return
name|GL_TEXTURE_2D
return|;
block|}
DECL|function|getWidth
name|GLsizei
name|Texture2D
operator|::
name|getWidth
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|level
operator|<
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
return|return
name|mImageArray
index|[
name|level
index|]
operator|->
name|getWidth
argument_list|()
return|;
else|else
return|return
literal|0
return|;
block|}
DECL|function|getHeight
name|GLsizei
name|Texture2D
operator|::
name|getHeight
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|level
operator|<
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
return|return
name|mImageArray
index|[
name|level
index|]
operator|->
name|getHeight
argument_list|()
return|;
else|else
return|return
literal|0
return|;
block|}
DECL|function|getInternalFormat
name|GLenum
name|Texture2D
operator|::
name|getInternalFormat
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|level
operator|<
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
return|return
name|mImageArray
index|[
name|level
index|]
operator|->
name|getInternalFormat
argument_list|()
return|;
else|else
return|return
name|GL_NONE
return|;
block|}
DECL|function|getActualFormat
name|GLenum
name|Texture2D
operator|::
name|getActualFormat
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|level
operator|<
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
return|return
name|mImageArray
index|[
name|level
index|]
operator|->
name|getActualFormat
argument_list|()
return|;
else|else
return|return
name|D3DFMT_UNKNOWN
return|;
block|}
DECL|function|redefineImage
name|void
name|Texture2D
operator|::
name|redefineImage
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLint
name|internalformat
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
name|releaseTexImage
argument_list|()
expr_stmt|;
comment|// If there currently is a corresponding storage texture image, it has these parameters
specifier|const
name|int
name|storageWidth
init|=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|mImageArray
index|[
literal|0
index|]
operator|->
name|getWidth
argument_list|()
operator|>>
name|level
argument_list|)
decl_stmt|;
specifier|const
name|int
name|storageHeight
init|=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|mImageArray
index|[
literal|0
index|]
operator|->
name|getHeight
argument_list|()
operator|>>
name|level
argument_list|)
decl_stmt|;
specifier|const
name|int
name|storageFormat
init|=
name|mImageArray
index|[
literal|0
index|]
operator|->
name|getInternalFormat
argument_list|()
decl_stmt|;
name|mImageArray
index|[
name|level
index|]
operator|->
name|redefine
argument_list|(
name|mRenderer
argument_list|,
name|internalformat
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|mTexStorage
condition|)
block|{
specifier|const
name|int
name|storageLevels
init|=
name|mTexStorage
operator|->
name|levelCount
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|level
operator|>=
name|storageLevels
operator|&&
name|storageLevels
operator|!=
literal|0
operator|)
operator|||
name|width
operator|!=
name|storageWidth
operator|||
name|height
operator|!=
name|storageHeight
operator|||
name|internalformat
operator|!=
name|storageFormat
condition|)
comment|// Discard mismatched storage
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|i
operator|++
control|)
block|{
name|mImageArray
index|[
name|i
index|]
operator|->
name|markDirty
argument_list|()
expr_stmt|;
block|}
operator|delete
name|mTexStorage
expr_stmt|;
name|mTexStorage
operator|=
name|NULL
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
DECL|function|setImage
name|void
name|Texture2D
operator|::
name|setImage
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLint
name|unpackAlignment
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
name|GLint
name|internalformat
init|=
name|ConvertSizedInternalFormat
argument_list|(
name|format
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|redefineImage
argument_list|(
name|level
argument_list|,
name|internalformat
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|Texture
operator|::
name|setImage
argument_list|(
name|unpackAlignment
argument_list|,
name|pixels
argument_list|,
name|mImageArray
index|[
name|level
index|]
argument_list|)
expr_stmt|;
block|}
DECL|function|bindTexImage
name|void
name|Texture2D
operator|::
name|bindTexImage
parameter_list|(
name|egl
operator|::
name|Surface
modifier|*
name|surface
parameter_list|)
block|{
name|releaseTexImage
argument_list|()
expr_stmt|;
name|GLint
name|internalformat
init|=
name|surface
operator|->
name|getFormat
argument_list|()
decl_stmt|;
name|mImageArray
index|[
literal|0
index|]
operator|->
name|redefine
argument_list|(
name|mRenderer
argument_list|,
name|internalformat
argument_list|,
name|surface
operator|->
name|getWidth
argument_list|()
argument_list|,
name|surface
operator|->
name|getHeight
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
operator|delete
name|mTexStorage
expr_stmt|;
name|mTexStorage
operator|=
operator|new
name|rx
operator|::
name|TextureStorageInterface2D
argument_list|(
name|mRenderer
argument_list|,
name|surface
operator|->
name|getSwapChain
argument_list|()
argument_list|)
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
name|mSurface
operator|=
name|surface
expr_stmt|;
name|mSurface
operator|->
name|setBoundTexture
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
DECL|function|releaseTexImage
name|void
name|Texture2D
operator|::
name|releaseTexImage
parameter_list|()
block|{
if|if
condition|(
name|mSurface
condition|)
block|{
name|mSurface
operator|->
name|setBoundTexture
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mSurface
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|mTexStorage
condition|)
block|{
operator|delete
name|mTexStorage
expr_stmt|;
name|mTexStorage
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|i
operator|++
control|)
block|{
name|mImageArray
index|[
name|i
index|]
operator|->
name|redefine
argument_list|(
name|mRenderer
argument_list|,
name|GL_NONE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|setCompressedImage
name|void
name|Texture2D
operator|::
name|setCompressedImage
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|imageSize
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
comment|// compressed formats don't have separate sized internal formats-- we can just use the compressed format directly
name|redefineImage
argument_list|(
name|level
argument_list|,
name|format
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|Texture
operator|::
name|setCompressedImage
argument_list|(
name|imageSize
argument_list|,
name|pixels
argument_list|,
name|mImageArray
index|[
name|level
index|]
argument_list|)
expr_stmt|;
block|}
DECL|function|commitRect
name|void
name|Texture2D
operator|::
name|commitRect
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
if|if
condition|(
name|level
operator|<
name|levelCount
argument_list|()
condition|)
block|{
name|rx
operator|::
name|Image
modifier|*
name|image
init|=
name|mImageArray
index|[
name|level
index|]
decl_stmt|;
if|if
condition|(
name|image
operator|->
name|updateSurface
argument_list|(
name|mTexStorage
argument_list|,
name|level
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
condition|)
block|{
name|image
operator|->
name|markClean
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|function|subImage
name|void
name|Texture2D
operator|::
name|subImage
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLint
name|unpackAlignment
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
if|if
condition|(
name|Texture
operator|::
name|subImage
argument_list|(
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|unpackAlignment
argument_list|,
name|pixels
argument_list|,
name|mImageArray
index|[
name|level
index|]
argument_list|)
condition|)
block|{
name|commitRect
argument_list|(
name|level
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|subImageCompressed
name|void
name|Texture2D
operator|::
name|subImageCompressed
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLsizei
name|imageSize
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
if|if
condition|(
name|Texture
operator|::
name|subImageCompressed
argument_list|(
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|imageSize
argument_list|,
name|pixels
argument_list|,
name|mImageArray
index|[
name|level
index|]
argument_list|)
condition|)
block|{
name|commitRect
argument_list|(
name|level
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|copyImage
name|void
name|Texture2D
operator|::
name|copyImage
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|Framebuffer
modifier|*
name|source
parameter_list|)
block|{
name|GLint
name|internalformat
init|=
name|ConvertSizedInternalFormat
argument_list|(
name|format
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|)
decl_stmt|;
name|redefineImage
argument_list|(
name|level
argument_list|,
name|internalformat
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mImageArray
index|[
name|level
index|]
operator|->
name|isRenderableFormat
argument_list|()
condition|)
block|{
name|mImageArray
index|[
name|level
index|]
operator|->
name|copy
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|mTexStorage
operator|||
operator|!
name|mTexStorage
operator|->
name|isRenderTarget
argument_list|()
condition|)
block|{
name|convertToRenderTarget
argument_list|()
expr_stmt|;
block|}
name|mImageArray
index|[
name|level
index|]
operator|->
name|markClean
argument_list|()
expr_stmt|;
if|if
condition|(
name|width
operator|!=
literal|0
operator|&&
name|height
operator|!=
literal|0
operator|&&
name|level
operator|<
name|levelCount
argument_list|()
condition|)
block|{
name|gl
operator|::
name|Rectangle
name|sourceRect
decl_stmt|;
name|sourceRect
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|sourceRect
operator|.
name|width
operator|=
name|width
expr_stmt|;
name|sourceRect
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|sourceRect
operator|.
name|height
operator|=
name|height
expr_stmt|;
name|mRenderer
operator|->
name|copyImage
argument_list|(
name|source
argument_list|,
name|sourceRect
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|mTexStorage
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|copySubImage
name|void
name|Texture2D
operator|::
name|copySubImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|Framebuffer
modifier|*
name|source
parameter_list|)
block|{
if|if
condition|(
name|xoffset
operator|+
name|width
operator|>
name|mImageArray
index|[
name|level
index|]
operator|->
name|getWidth
argument_list|()
operator|||
name|yoffset
operator|+
name|height
operator|>
name|mImageArray
index|[
name|level
index|]
operator|->
name|getHeight
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|mImageArray
index|[
name|level
index|]
operator|->
name|isRenderableFormat
argument_list|()
operator|||
operator|(
operator|!
name|mTexStorage
operator|&&
operator|!
name|isSamplerComplete
argument_list|()
operator|)
condition|)
block|{
name|mImageArray
index|[
name|level
index|]
operator|->
name|copy
argument_list|(
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|mTexStorage
operator|||
operator|!
name|mTexStorage
operator|->
name|isRenderTarget
argument_list|()
condition|)
block|{
name|convertToRenderTarget
argument_list|()
expr_stmt|;
block|}
name|updateTexture
argument_list|()
expr_stmt|;
if|if
condition|(
name|level
operator|<
name|levelCount
argument_list|()
condition|)
block|{
name|gl
operator|::
name|Rectangle
name|sourceRect
decl_stmt|;
name|sourceRect
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|sourceRect
operator|.
name|width
operator|=
name|width
expr_stmt|;
name|sourceRect
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|sourceRect
operator|.
name|height
operator|=
name|height
expr_stmt|;
name|mRenderer
operator|->
name|copyImage
argument_list|(
name|source
argument_list|,
name|sourceRect
argument_list|,
name|gl
operator|::
name|ExtractFormat
argument_list|(
name|mImageArray
index|[
literal|0
index|]
operator|->
name|getInternalFormat
argument_list|()
argument_list|)
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|mTexStorage
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|storage
name|void
name|Texture2D
operator|::
name|storage
parameter_list|(
name|GLsizei
name|levels
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
operator|delete
name|mTexStorage
expr_stmt|;
name|mTexStorage
operator|=
operator|new
name|rx
operator|::
name|TextureStorageInterface2D
argument_list|(
name|mRenderer
argument_list|,
name|levels
argument_list|,
name|internalformat
argument_list|,
name|mUsage
argument_list|,
literal|false
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|mImmutable
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|levels
condition|;
name|level
operator|++
control|)
block|{
name|mImageArray
index|[
name|level
index|]
operator|->
name|redefine
argument_list|(
name|mRenderer
argument_list|,
name|internalformat
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|width
operator|=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|width
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|height
operator|=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|height
operator|>>
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|level
init|=
name|levels
init|;
name|level
operator|<
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|level
operator|++
control|)
block|{
name|mImageArray
index|[
name|level
index|]
operator|->
name|redefine
argument_list|(
name|mRenderer
argument_list|,
name|GL_NONE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mTexStorage
operator|->
name|isManaged
argument_list|()
condition|)
block|{
name|int
name|levels
init|=
name|levelCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|levels
condition|;
name|level
operator|++
control|)
block|{
name|mImageArray
index|[
name|level
index|]
operator|->
name|setManagedSurface
argument_list|(
name|mTexStorage
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Tests for 2D texture sampling completeness. [OpenGL ES 2.0.24] section 3.8.2 page 85.
DECL|function|isSamplerComplete
name|bool
name|Texture2D
operator|::
name|isSamplerComplete
parameter_list|()
specifier|const
block|{
name|GLsizei
name|width
init|=
name|mImageArray
index|[
literal|0
index|]
operator|->
name|getWidth
argument_list|()
decl_stmt|;
name|GLsizei
name|height
init|=
name|mImageArray
index|[
literal|0
index|]
operator|->
name|getHeight
argument_list|()
decl_stmt|;
if|if
condition|(
name|width
operator|<=
literal|0
operator|||
name|height
operator|<=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|bool
name|mipmapping
init|=
name|isMipmapFiltered
argument_list|()
decl_stmt|;
name|bool
name|filtering
decl_stmt|,
name|renderable
decl_stmt|;
if|if
condition|(
operator|(
name|IsFloat32Format
argument_list|(
name|getInternalFormat
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|mRenderer
operator|->
name|getFloat32TextureSupport
argument_list|(
operator|&
name|filtering
argument_list|,
operator|&
name|renderable
argument_list|)
operator|)
operator|||
operator|(
name|IsFloat16Format
argument_list|(
name|getInternalFormat
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|mRenderer
operator|->
name|getFloat16TextureSupport
argument_list|(
operator|&
name|filtering
argument_list|,
operator|&
name|renderable
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|mSamplerState
operator|.
name|magFilter
operator|!=
name|GL_NEAREST
operator|||
operator|(
name|mSamplerState
operator|.
name|minFilter
operator|!=
name|GL_NEAREST
operator|&&
name|mSamplerState
operator|.
name|minFilter
operator|!=
name|GL_NEAREST_MIPMAP_NEAREST
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
name|bool
name|npotSupport
init|=
name|mRenderer
operator|->
name|getNonPower2TextureSupport
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|npotSupport
condition|)
block|{
if|if
condition|(
operator|(
name|mSamplerState
operator|.
name|wrapS
operator|!=
name|GL_CLAMP_TO_EDGE
operator|&&
operator|!
name|isPow2
argument_list|(
name|width
argument_list|)
operator|)
operator|||
operator|(
name|mSamplerState
operator|.
name|wrapT
operator|!=
name|GL_CLAMP_TO_EDGE
operator|&&
operator|!
name|isPow2
argument_list|(
name|height
argument_list|)
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|mipmapping
condition|)
block|{
if|if
condition|(
operator|!
name|npotSupport
condition|)
block|{
if|if
condition|(
operator|!
name|isPow2
argument_list|(
name|width
argument_list|)
operator|||
operator|!
name|isPow2
argument_list|(
name|height
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
operator|!
name|isMipmapComplete
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|// Tests for 2D texture (mipmap) completeness. [OpenGL ES 2.0.24] section 3.7.10 page 81.
DECL|function|isMipmapComplete
name|bool
name|Texture2D
operator|::
name|isMipmapComplete
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isImmutable
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
name|GLsizei
name|width
init|=
name|mImageArray
index|[
literal|0
index|]
operator|->
name|getWidth
argument_list|()
decl_stmt|;
name|GLsizei
name|height
init|=
name|mImageArray
index|[
literal|0
index|]
operator|->
name|getHeight
argument_list|()
decl_stmt|;
if|if
condition|(
name|width
operator|<=
literal|0
operator|||
name|height
operator|<=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|q
init|=
name|log2
argument_list|(
name|std
operator|::
name|max
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<=
name|q
condition|;
name|level
operator|++
control|)
block|{
if|if
condition|(
name|mImageArray
index|[
name|level
index|]
operator|->
name|getInternalFormat
argument_list|()
operator|!=
name|mImageArray
index|[
literal|0
index|]
operator|->
name|getInternalFormat
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|mImageArray
index|[
name|level
index|]
operator|->
name|getWidth
argument_list|()
operator|!=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|width
operator|>>
name|level
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|mImageArray
index|[
name|level
index|]
operator|->
name|getHeight
argument_list|()
operator|!=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|height
operator|>>
name|level
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|isCompressed
name|bool
name|Texture2D
operator|::
name|isCompressed
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
return|return
name|IsCompressed
argument_list|(
name|getInternalFormat
argument_list|(
name|level
argument_list|)
argument_list|)
return|;
block|}
DECL|function|isDepth
name|bool
name|Texture2D
operator|::
name|isDepth
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
return|return
name|IsDepthTexture
argument_list|(
name|getInternalFormat
argument_list|(
name|level
argument_list|)
argument_list|)
return|;
block|}
comment|// Constructs a native texture resource from the texture images
DECL|function|createTexture
name|void
name|Texture2D
operator|::
name|createTexture
parameter_list|()
block|{
name|GLsizei
name|width
init|=
name|mImageArray
index|[
literal|0
index|]
operator|->
name|getWidth
argument_list|()
decl_stmt|;
name|GLsizei
name|height
init|=
name|mImageArray
index|[
literal|0
index|]
operator|->
name|getHeight
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|width
operator|>
literal|0
operator|&&
name|height
operator|>
literal|0
operator|)
condition|)
return|return;
comment|// do not attempt to create native textures for nonexistant data
name|GLint
name|levels
init|=
name|creationLevels
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
decl_stmt|;
name|GLenum
name|internalformat
init|=
name|mImageArray
index|[
literal|0
index|]
operator|->
name|getInternalFormat
argument_list|()
decl_stmt|;
operator|delete
name|mTexStorage
expr_stmt|;
name|mTexStorage
operator|=
operator|new
name|rx
operator|::
name|TextureStorageInterface2D
argument_list|(
name|mRenderer
argument_list|,
name|levels
argument_list|,
name|internalformat
argument_list|,
name|mUsage
argument_list|,
literal|false
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|mTexStorage
operator|->
name|isManaged
argument_list|()
condition|)
block|{
name|int
name|levels
init|=
name|levelCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|levels
condition|;
name|level
operator|++
control|)
block|{
name|mImageArray
index|[
name|level
index|]
operator|->
name|setManagedSurface
argument_list|(
name|mTexStorage
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
block|}
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|updateTexture
name|void
name|Texture2D
operator|::
name|updateTexture
parameter_list|()
block|{
name|bool
name|mipmapping
init|=
operator|(
name|isMipmapFiltered
argument_list|()
operator|&&
name|isMipmapComplete
argument_list|()
operator|)
decl_stmt|;
name|int
name|levels
init|=
operator|(
name|mipmapping
condition|?
name|levelCount
argument_list|()
else|:
literal|1
operator|)
decl_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|levels
condition|;
name|level
operator|++
control|)
block|{
name|rx
operator|::
name|Image
modifier|*
name|image
init|=
name|mImageArray
index|[
name|level
index|]
decl_stmt|;
if|if
condition|(
name|image
operator|->
name|isDirty
argument_list|()
condition|)
block|{
name|commitRect
argument_list|(
name|level
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|mImageArray
index|[
name|level
index|]
operator|->
name|getWidth
argument_list|()
argument_list|,
name|mImageArray
index|[
name|level
index|]
operator|->
name|getHeight
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|convertToRenderTarget
name|void
name|Texture2D
operator|::
name|convertToRenderTarget
parameter_list|()
block|{
name|rx
operator|::
name|TextureStorageInterface2D
modifier|*
name|newTexStorage
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|mImageArray
index|[
literal|0
index|]
operator|->
name|getWidth
argument_list|()
operator|!=
literal|0
operator|&&
name|mImageArray
index|[
literal|0
index|]
operator|->
name|getHeight
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|GLsizei
name|width
init|=
name|mImageArray
index|[
literal|0
index|]
operator|->
name|getWidth
argument_list|()
decl_stmt|;
name|GLsizei
name|height
init|=
name|mImageArray
index|[
literal|0
index|]
operator|->
name|getHeight
argument_list|()
decl_stmt|;
name|GLint
name|levels
init|=
name|mTexStorage
operator|!=
name|NULL
condition|?
name|mTexStorage
operator|->
name|levelCount
argument_list|()
else|:
name|creationLevels
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
decl_stmt|;
name|GLenum
name|internalformat
init|=
name|mImageArray
index|[
literal|0
index|]
operator|->
name|getInternalFormat
argument_list|()
decl_stmt|;
name|newTexStorage
operator|=
operator|new
name|rx
operator|::
name|TextureStorageInterface2D
argument_list|(
name|mRenderer
argument_list|,
name|levels
argument_list|,
name|internalformat
argument_list|,
name|GL_FRAMEBUFFER_ATTACHMENT_ANGLE
argument_list|,
literal|true
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|mTexStorage
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|mRenderer
operator|->
name|copyToRenderTarget
argument_list|(
name|newTexStorage
argument_list|,
name|mTexStorage
argument_list|)
condition|)
block|{
operator|delete
name|newTexStorage
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
block|}
operator|delete
name|mTexStorage
expr_stmt|;
name|mTexStorage
operator|=
name|newTexStorage
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|generateMipmaps
name|void
name|Texture2D
operator|::
name|generateMipmaps
parameter_list|()
block|{
if|if
condition|(
operator|!
name|mRenderer
operator|->
name|getNonPower2TextureSupport
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|isPow2
argument_list|(
name|mImageArray
index|[
literal|0
index|]
operator|->
name|getWidth
argument_list|()
argument_list|)
operator|||
operator|!
name|isPow2
argument_list|(
name|mImageArray
index|[
literal|0
index|]
operator|->
name|getHeight
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
block|}
comment|// Purge array levels 1 through q and reset them to represent the generated mipmap levels.
name|unsigned
name|int
name|q
init|=
name|log2
argument_list|(
name|std
operator|::
name|max
argument_list|(
name|mImageArray
index|[
literal|0
index|]
operator|->
name|getWidth
argument_list|()
argument_list|,
name|mImageArray
index|[
literal|0
index|]
operator|->
name|getHeight
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|q
condition|;
name|i
operator|++
control|)
block|{
name|redefineImage
argument_list|(
name|i
argument_list|,
name|mImageArray
index|[
literal|0
index|]
operator|->
name|getInternalFormat
argument_list|()
argument_list|,
name|std
operator|::
name|max
argument_list|(
name|mImageArray
index|[
literal|0
index|]
operator|->
name|getWidth
argument_list|()
operator|>>
name|i
argument_list|,
literal|1
argument_list|)
argument_list|,
name|std
operator|::
name|max
argument_list|(
name|mImageArray
index|[
literal|0
index|]
operator|->
name|getHeight
argument_list|()
operator|>>
name|i
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mTexStorage
operator|&&
name|mTexStorage
operator|->
name|isRenderTarget
argument_list|()
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|q
condition|;
name|i
operator|++
control|)
block|{
name|mTexStorage
operator|->
name|generateMipmap
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|mImageArray
index|[
name|i
index|]
operator|->
name|markClean
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|q
condition|;
name|i
operator|++
control|)
block|{
name|mRenderer
operator|->
name|generateMipmap
argument_list|(
name|mImageArray
index|[
name|i
index|]
argument_list|,
name|mImageArray
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|getRenderbuffer
name|Renderbuffer
modifier|*
name|Texture2D
operator|::
name|getRenderbuffer
parameter_list|(
name|GLenum
name|target
parameter_list|)
block|{
if|if
condition|(
name|target
operator|!=
name|GL_TEXTURE_2D
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
operator|(
name|Renderbuffer
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
if|if
condition|(
name|mColorbufferProxy
operator|==
name|NULL
condition|)
block|{
name|mColorbufferProxy
operator|=
operator|new
name|Renderbuffer
argument_list|(
name|mRenderer
argument_list|,
name|id
argument_list|()
argument_list|,
operator|new
name|RenderbufferTexture2D
argument_list|(
name|this
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|mColorbufferProxy
return|;
block|}
DECL|function|getRenderTarget
name|rx
operator|::
name|RenderTarget
modifier|*
name|Texture2D
operator|::
name|getRenderTarget
parameter_list|(
name|GLenum
name|target
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|GL_TEXTURE_2D
argument_list|)
expr_stmt|;
comment|// ensure the underlying texture is created
if|if
condition|(
name|getStorage
argument_list|(
literal|true
argument_list|)
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|updateTexture
argument_list|()
expr_stmt|;
comment|// ensure this is NOT a depth texture
if|if
condition|(
name|isDepth
argument_list|(
literal|0
argument_list|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
name|mTexStorage
operator|->
name|getRenderTarget
argument_list|()
return|;
block|}
DECL|function|getDepthStencil
name|rx
operator|::
name|RenderTarget
modifier|*
name|Texture2D
operator|::
name|getDepthStencil
parameter_list|(
name|GLenum
name|target
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|GL_TEXTURE_2D
argument_list|)
expr_stmt|;
comment|// ensure the underlying texture is created
if|if
condition|(
name|getStorage
argument_list|(
literal|true
argument_list|)
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|updateTexture
argument_list|()
expr_stmt|;
comment|// ensure this is actually a depth texture
if|if
condition|(
operator|!
name|isDepth
argument_list|(
literal|0
argument_list|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
name|mTexStorage
operator|->
name|getRenderTarget
argument_list|()
return|;
block|}
DECL|function|levelCount
name|int
name|Texture2D
operator|::
name|levelCount
parameter_list|()
block|{
return|return
name|mTexStorage
condition|?
name|mTexStorage
operator|->
name|levelCount
argument_list|()
else|:
literal|0
return|;
block|}
DECL|function|getStorage
name|rx
operator|::
name|TextureStorageInterface
modifier|*
name|Texture2D
operator|::
name|getStorage
parameter_list|(
name|bool
name|renderTarget
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mTexStorage
operator|||
operator|(
name|renderTarget
operator|&&
operator|!
name|mTexStorage
operator|->
name|isRenderTarget
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|renderTarget
condition|)
block|{
name|convertToRenderTarget
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|createTexture
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|mTexStorage
return|;
block|}
DECL|function|TextureCubeMap
name|TextureCubeMap
operator|::
name|TextureCubeMap
parameter_list|(
name|rx
operator|::
name|Renderer
modifier|*
name|renderer
parameter_list|,
name|GLuint
name|id
parameter_list|)
member_init_list|:
name|Texture
argument_list|(
name|renderer
argument_list|,
name|id
argument_list|)
block|{
name|mTexStorage
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|mFaceProxies
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|mFaceProxyRefs
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
operator|++
name|j
control|)
block|{
name|mImageArray
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|renderer
operator|->
name|createImage
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|function|~TextureCubeMap
name|TextureCubeMap
operator|::
name|~
name|TextureCubeMap
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|mFaceProxies
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
operator|++
name|j
control|)
block|{
operator|delete
name|mImageArray
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
operator|delete
name|mTexStorage
expr_stmt|;
name|mTexStorage
operator|=
name|NULL
expr_stmt|;
block|}
comment|// We need to maintain a count of references to renderbuffers acting as
comment|// proxies for this texture, so that the texture is not deleted while
comment|// proxy references still exist. If the reference count drops to zero,
comment|// we set our proxy pointer NULL, so that a new attempt at referencing
comment|// will cause recreation.
DECL|function|addProxyRef
name|void
name|TextureCubeMap
operator|::
name|addProxyRef
parameter_list|(
specifier|const
name|Renderbuffer
modifier|*
name|proxy
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mFaceProxies
index|[
name|i
index|]
operator|==
name|proxy
condition|)
name|mFaceProxyRefs
index|[
name|i
index|]
operator|++
expr_stmt|;
block|}
block|}
DECL|function|releaseProxy
name|void
name|TextureCubeMap
operator|::
name|releaseProxy
parameter_list|(
specifier|const
name|Renderbuffer
modifier|*
name|proxy
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mFaceProxies
index|[
name|i
index|]
operator|==
name|proxy
condition|)
block|{
if|if
condition|(
name|mFaceProxyRefs
index|[
name|i
index|]
operator|>
literal|0
condition|)
name|mFaceProxyRefs
index|[
name|i
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|mFaceProxyRefs
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|mFaceProxies
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
DECL|function|getTarget
name|GLenum
name|TextureCubeMap
operator|::
name|getTarget
parameter_list|()
specifier|const
block|{
return|return
name|GL_TEXTURE_CUBE_MAP
return|;
block|}
DECL|function|getWidth
name|GLsizei
name|TextureCubeMap
operator|::
name|getWidth
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|level
operator|<
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
return|return
name|mImageArray
index|[
name|faceIndex
argument_list|(
name|target
argument_list|)
index|]
index|[
name|level
index|]
operator|->
name|getWidth
argument_list|()
return|;
else|else
return|return
literal|0
return|;
block|}
DECL|function|getHeight
name|GLsizei
name|TextureCubeMap
operator|::
name|getHeight
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|level
operator|<
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
return|return
name|mImageArray
index|[
name|faceIndex
argument_list|(
name|target
argument_list|)
index|]
index|[
name|level
index|]
operator|->
name|getHeight
argument_list|()
return|;
else|else
return|return
literal|0
return|;
block|}
DECL|function|getInternalFormat
name|GLenum
name|TextureCubeMap
operator|::
name|getInternalFormat
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|level
operator|<
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
return|return
name|mImageArray
index|[
name|faceIndex
argument_list|(
name|target
argument_list|)
index|]
index|[
name|level
index|]
operator|->
name|getInternalFormat
argument_list|()
return|;
else|else
return|return
name|GL_NONE
return|;
block|}
DECL|function|getActualFormat
name|GLenum
name|TextureCubeMap
operator|::
name|getActualFormat
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|level
operator|<
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
return|return
name|mImageArray
index|[
name|faceIndex
argument_list|(
name|target
argument_list|)
index|]
index|[
name|level
index|]
operator|->
name|getActualFormat
argument_list|()
return|;
else|else
return|return
name|D3DFMT_UNKNOWN
return|;
block|}
DECL|function|setImagePosX
name|void
name|TextureCubeMap
operator|::
name|setImagePosX
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLint
name|unpackAlignment
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
name|setImage
argument_list|(
literal|0
argument_list|,
name|level
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|unpackAlignment
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
block|}
DECL|function|setImageNegX
name|void
name|TextureCubeMap
operator|::
name|setImageNegX
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLint
name|unpackAlignment
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
name|setImage
argument_list|(
literal|1
argument_list|,
name|level
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|unpackAlignment
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
block|}
DECL|function|setImagePosY
name|void
name|TextureCubeMap
operator|::
name|setImagePosY
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLint
name|unpackAlignment
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
name|setImage
argument_list|(
literal|2
argument_list|,
name|level
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|unpackAlignment
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
block|}
DECL|function|setImageNegY
name|void
name|TextureCubeMap
operator|::
name|setImageNegY
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLint
name|unpackAlignment
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
name|setImage
argument_list|(
literal|3
argument_list|,
name|level
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|unpackAlignment
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
block|}
DECL|function|setImagePosZ
name|void
name|TextureCubeMap
operator|::
name|setImagePosZ
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLint
name|unpackAlignment
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
name|setImage
argument_list|(
literal|4
argument_list|,
name|level
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|unpackAlignment
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
block|}
DECL|function|setImageNegZ
name|void
name|TextureCubeMap
operator|::
name|setImageNegZ
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLint
name|unpackAlignment
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
name|setImage
argument_list|(
literal|5
argument_list|,
name|level
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|unpackAlignment
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
block|}
DECL|function|setCompressedImage
name|void
name|TextureCubeMap
operator|::
name|setCompressedImage
parameter_list|(
name|GLenum
name|face
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|imageSize
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
comment|// compressed formats don't have separate sized internal formats-- we can just use the compressed format directly
name|redefineImage
argument_list|(
name|faceIndex
argument_list|(
name|face
argument_list|)
argument_list|,
name|level
argument_list|,
name|format
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|Texture
operator|::
name|setCompressedImage
argument_list|(
name|imageSize
argument_list|,
name|pixels
argument_list|,
name|mImageArray
index|[
name|faceIndex
argument_list|(
name|face
argument_list|)
index|]
index|[
name|level
index|]
argument_list|)
expr_stmt|;
block|}
DECL|function|commitRect
name|void
name|TextureCubeMap
operator|::
name|commitRect
parameter_list|(
name|int
name|face
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
if|if
condition|(
name|level
operator|<
name|levelCount
argument_list|()
condition|)
block|{
name|rx
operator|::
name|Image
modifier|*
name|image
init|=
name|mImageArray
index|[
name|face
index|]
index|[
name|level
index|]
decl_stmt|;
if|if
condition|(
name|image
operator|->
name|updateSurface
argument_list|(
name|mTexStorage
argument_list|,
name|face
argument_list|,
name|level
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
condition|)
name|image
operator|->
name|markClean
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|subImage
name|void
name|TextureCubeMap
operator|::
name|subImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLint
name|unpackAlignment
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
if|if
condition|(
name|Texture
operator|::
name|subImage
argument_list|(
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|unpackAlignment
argument_list|,
name|pixels
argument_list|,
name|mImageArray
index|[
name|faceIndex
argument_list|(
name|target
argument_list|)
index|]
index|[
name|level
index|]
argument_list|)
condition|)
block|{
name|commitRect
argument_list|(
name|faceIndex
argument_list|(
name|target
argument_list|)
argument_list|,
name|level
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|subImageCompressed
name|void
name|TextureCubeMap
operator|::
name|subImageCompressed
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLsizei
name|imageSize
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
if|if
condition|(
name|Texture
operator|::
name|subImageCompressed
argument_list|(
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|imageSize
argument_list|,
name|pixels
argument_list|,
name|mImageArray
index|[
name|faceIndex
argument_list|(
name|target
argument_list|)
index|]
index|[
name|level
index|]
argument_list|)
condition|)
block|{
name|commitRect
argument_list|(
name|faceIndex
argument_list|(
name|target
argument_list|)
argument_list|,
name|level
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Tests for cube map sampling completeness. [OpenGL ES 2.0.24] section 3.8.2 page 86.
DECL|function|isSamplerComplete
name|bool
name|TextureCubeMap
operator|::
name|isSamplerComplete
parameter_list|()
specifier|const
block|{
name|int
name|size
init|=
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|getWidth
argument_list|()
decl_stmt|;
name|bool
name|mipmapping
init|=
name|isMipmapFiltered
argument_list|()
decl_stmt|;
name|bool
name|filtering
decl_stmt|,
name|renderable
decl_stmt|;
if|if
condition|(
operator|(
name|gl
operator|::
name|ExtractType
argument_list|(
name|getInternalFormat
argument_list|(
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|GL_FLOAT
operator|&&
operator|!
name|mRenderer
operator|->
name|getFloat32TextureSupport
argument_list|(
operator|&
name|filtering
argument_list|,
operator|&
name|renderable
argument_list|)
operator|)
operator|||
operator|(
name|gl
operator|::
name|ExtractType
argument_list|(
name|getInternalFormat
argument_list|(
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
argument_list|,
literal|0
argument_list|)
operator|==
name|GL_HALF_FLOAT_OES
argument_list|)
operator|&&
operator|!
name|mRenderer
operator|->
name|getFloat16TextureSupport
argument_list|(
operator|&
name|filtering
argument_list|,
operator|&
name|renderable
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|mSamplerState
operator|.
name|magFilter
operator|!=
name|GL_NEAREST
operator|||
operator|(
name|mSamplerState
operator|.
name|minFilter
operator|!=
name|GL_NEAREST
operator|&&
name|mSamplerState
operator|.
name|minFilter
operator|!=
name|GL_NEAREST_MIPMAP_NEAREST
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
operator|!
name|isPow2
argument_list|(
name|size
argument_list|)
operator|&&
operator|!
name|mRenderer
operator|->
name|getNonPower2TextureSupport
argument_list|()
condition|)
block|{
if|if
condition|(
name|mSamplerState
operator|.
name|wrapS
operator|!=
name|GL_CLAMP_TO_EDGE
operator|||
name|mSamplerState
operator|.
name|wrapT
operator|!=
name|GL_CLAMP_TO_EDGE
operator|||
name|mipmapping
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
operator|!
name|mipmapping
condition|)
block|{
if|if
condition|(
operator|!
name|isCubeComplete
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|isMipmapCubeComplete
argument_list|()
condition|)
comment|// Also tests for isCubeComplete()
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|// Tests for cube texture completeness. [OpenGL ES 2.0.24] section 3.7.10 page 81.
DECL|function|isCubeComplete
name|bool
name|TextureCubeMap
operator|::
name|isCubeComplete
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|getWidth
argument_list|()
operator|<=
literal|0
operator|||
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|getHeight
argument_list|()
operator|!=
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|getWidth
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|unsigned
name|int
name|face
init|=
literal|1
init|;
name|face
operator|<
literal|6
condition|;
name|face
operator|++
control|)
block|{
if|if
condition|(
name|mImageArray
index|[
name|face
index|]
index|[
literal|0
index|]
operator|->
name|getWidth
argument_list|()
operator|!=
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|getWidth
argument_list|()
operator|||
name|mImageArray
index|[
name|face
index|]
index|[
literal|0
index|]
operator|->
name|getWidth
argument_list|()
operator|!=
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|getHeight
argument_list|()
operator|||
name|mImageArray
index|[
name|face
index|]
index|[
literal|0
index|]
operator|->
name|getInternalFormat
argument_list|()
operator|!=
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|getInternalFormat
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|isMipmapCubeComplete
name|bool
name|TextureCubeMap
operator|::
name|isMipmapCubeComplete
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isImmutable
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|isCubeComplete
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|GLsizei
name|size
init|=
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|getWidth
argument_list|()
decl_stmt|;
name|int
name|q
init|=
name|log2
argument_list|(
name|size
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|face
init|=
literal|0
init|;
name|face
operator|<
literal|6
condition|;
name|face
operator|++
control|)
block|{
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<=
name|q
condition|;
name|level
operator|++
control|)
block|{
if|if
condition|(
name|mImageArray
index|[
name|face
index|]
index|[
name|level
index|]
operator|->
name|getInternalFormat
argument_list|()
operator|!=
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|getInternalFormat
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|mImageArray
index|[
name|face
index|]
index|[
name|level
index|]
operator|->
name|getWidth
argument_list|()
operator|!=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|size
operator|>>
name|level
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|isCompressed
name|bool
name|TextureCubeMap
operator|::
name|isCompressed
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|)
specifier|const
block|{
return|return
name|IsCompressed
argument_list|(
name|getInternalFormat
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
argument_list|)
return|;
block|}
comment|// Constructs a native texture resource from the texture images, or returns an existing one
DECL|function|createTexture
name|void
name|TextureCubeMap
operator|::
name|createTexture
parameter_list|()
block|{
name|GLsizei
name|size
init|=
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|getWidth
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|size
operator|>
literal|0
operator|)
condition|)
return|return;
comment|// do not attempt to create native textures for nonexistant data
name|GLint
name|levels
init|=
name|creationLevels
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|GLenum
name|internalformat
init|=
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|getInternalFormat
argument_list|()
decl_stmt|;
operator|delete
name|mTexStorage
expr_stmt|;
name|mTexStorage
operator|=
operator|new
name|rx
operator|::
name|TextureStorageInterfaceCube
argument_list|(
name|mRenderer
argument_list|,
name|levels
argument_list|,
name|internalformat
argument_list|,
name|mUsage
argument_list|,
literal|false
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|mTexStorage
operator|->
name|isManaged
argument_list|()
condition|)
block|{
name|int
name|levels
init|=
name|levelCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|face
init|=
literal|0
init|;
name|face
operator|<
literal|6
condition|;
name|face
operator|++
control|)
block|{
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|levels
condition|;
name|level
operator|++
control|)
block|{
name|mImageArray
index|[
name|face
index|]
index|[
name|level
index|]
operator|->
name|setManagedSurface
argument_list|(
name|mTexStorage
argument_list|,
name|face
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|updateTexture
name|void
name|TextureCubeMap
operator|::
name|updateTexture
parameter_list|()
block|{
name|bool
name|mipmapping
init|=
name|isMipmapFiltered
argument_list|()
operator|&&
name|isMipmapCubeComplete
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|face
init|=
literal|0
init|;
name|face
operator|<
literal|6
condition|;
name|face
operator|++
control|)
block|{
name|int
name|levels
init|=
operator|(
name|mipmapping
condition|?
name|levelCount
argument_list|()
else|:
literal|1
operator|)
decl_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|levels
condition|;
name|level
operator|++
control|)
block|{
name|rx
operator|::
name|Image
modifier|*
name|image
init|=
name|mImageArray
index|[
name|face
index|]
index|[
name|level
index|]
decl_stmt|;
if|if
condition|(
name|image
operator|->
name|isDirty
argument_list|()
condition|)
block|{
name|commitRect
argument_list|(
name|face
argument_list|,
name|level
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|image
operator|->
name|getWidth
argument_list|()
argument_list|,
name|image
operator|->
name|getHeight
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|function|convertToRenderTarget
name|void
name|TextureCubeMap
operator|::
name|convertToRenderTarget
parameter_list|()
block|{
name|rx
operator|::
name|TextureStorageInterfaceCube
modifier|*
name|newTexStorage
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|getWidth
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|GLsizei
name|size
init|=
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|getWidth
argument_list|()
decl_stmt|;
name|GLint
name|levels
init|=
name|mTexStorage
operator|!=
name|NULL
condition|?
name|mTexStorage
operator|->
name|levelCount
argument_list|()
else|:
name|creationLevels
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|GLenum
name|internalformat
init|=
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|getInternalFormat
argument_list|()
decl_stmt|;
name|newTexStorage
operator|=
operator|new
name|rx
operator|::
name|TextureStorageInterfaceCube
argument_list|(
name|mRenderer
argument_list|,
name|levels
argument_list|,
name|internalformat
argument_list|,
name|GL_FRAMEBUFFER_ATTACHMENT_ANGLE
argument_list|,
literal|true
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|mTexStorage
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|mRenderer
operator|->
name|copyToRenderTarget
argument_list|(
name|newTexStorage
argument_list|,
name|mTexStorage
argument_list|)
condition|)
block|{
operator|delete
name|newTexStorage
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
block|}
operator|delete
name|mTexStorage
expr_stmt|;
name|mTexStorage
operator|=
name|newTexStorage
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|setImage
name|void
name|TextureCubeMap
operator|::
name|setImage
parameter_list|(
name|int
name|faceIndex
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLint
name|unpackAlignment
parameter_list|,
specifier|const
name|void
modifier|*
name|pixels
parameter_list|)
block|{
name|GLint
name|internalformat
init|=
name|ConvertSizedInternalFormat
argument_list|(
name|format
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|redefineImage
argument_list|(
name|faceIndex
argument_list|,
name|level
argument_list|,
name|internalformat
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|Texture
operator|::
name|setImage
argument_list|(
name|unpackAlignment
argument_list|,
name|pixels
argument_list|,
name|mImageArray
index|[
name|faceIndex
index|]
index|[
name|level
index|]
argument_list|)
expr_stmt|;
block|}
DECL|function|faceIndex
name|unsigned
name|int
name|TextureCubeMap
operator|::
name|faceIndex
parameter_list|(
name|GLenum
name|face
parameter_list|)
block|{
name|META_ASSERT
argument_list|(
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_X
operator|-
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
operator|==
literal|1
argument_list|)
expr_stmt|;
name|META_ASSERT
argument_list|(
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Y
operator|-
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
operator|==
literal|2
argument_list|)
expr_stmt|;
name|META_ASSERT
argument_list|(
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
operator|-
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
operator|==
literal|3
argument_list|)
expr_stmt|;
name|META_ASSERT
argument_list|(
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Z
operator|-
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
operator|==
literal|4
argument_list|)
expr_stmt|;
name|META_ASSERT
argument_list|(
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
operator|-
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
operator|==
literal|5
argument_list|)
expr_stmt|;
return|return
name|face
operator|-
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
return|;
block|}
DECL|function|redefineImage
name|void
name|TextureCubeMap
operator|::
name|redefineImage
parameter_list|(
name|int
name|face
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLint
name|internalformat
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
comment|// If there currently is a corresponding storage texture image, it has these parameters
specifier|const
name|int
name|storageWidth
init|=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|getWidth
argument_list|()
operator|>>
name|level
argument_list|)
decl_stmt|;
specifier|const
name|int
name|storageHeight
init|=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|getHeight
argument_list|()
operator|>>
name|level
argument_list|)
decl_stmt|;
specifier|const
name|int
name|storageFormat
init|=
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|getInternalFormat
argument_list|()
decl_stmt|;
name|mImageArray
index|[
name|face
index|]
index|[
name|level
index|]
operator|->
name|redefine
argument_list|(
name|mRenderer
argument_list|,
name|internalformat
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|mTexStorage
condition|)
block|{
specifier|const
name|int
name|storageLevels
init|=
name|mTexStorage
operator|->
name|levelCount
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|level
operator|>=
name|storageLevels
operator|&&
name|storageLevels
operator|!=
literal|0
operator|)
operator|||
name|width
operator|!=
name|storageWidth
operator|||
name|height
operator|!=
name|storageHeight
operator|||
name|internalformat
operator|!=
name|storageFormat
condition|)
comment|// Discard mismatched storage
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|int
name|f
init|=
literal|0
init|;
name|f
operator|<
literal|6
condition|;
name|f
operator|++
control|)
block|{
name|mImageArray
index|[
name|f
index|]
index|[
name|i
index|]
operator|->
name|markDirty
argument_list|()
expr_stmt|;
block|}
block|}
operator|delete
name|mTexStorage
expr_stmt|;
name|mTexStorage
operator|=
name|NULL
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
DECL|function|copyImage
name|void
name|TextureCubeMap
operator|::
name|copyImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|Framebuffer
modifier|*
name|source
parameter_list|)
block|{
name|unsigned
name|int
name|faceindex
init|=
name|faceIndex
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|GLint
name|internalformat
init|=
name|gl
operator|::
name|ConvertSizedInternalFormat
argument_list|(
name|format
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|)
decl_stmt|;
name|redefineImage
argument_list|(
name|faceindex
argument_list|,
name|level
argument_list|,
name|internalformat
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mImageArray
index|[
name|faceindex
index|]
index|[
name|level
index|]
operator|->
name|isRenderableFormat
argument_list|()
condition|)
block|{
name|mImageArray
index|[
name|faceindex
index|]
index|[
name|level
index|]
operator|->
name|copy
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|mTexStorage
operator|||
operator|!
name|mTexStorage
operator|->
name|isRenderTarget
argument_list|()
condition|)
block|{
name|convertToRenderTarget
argument_list|()
expr_stmt|;
block|}
name|mImageArray
index|[
name|faceindex
index|]
index|[
name|level
index|]
operator|->
name|markClean
argument_list|()
expr_stmt|;
name|ASSERT
argument_list|(
name|width
operator|==
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|>
literal|0
operator|&&
name|level
operator|<
name|levelCount
argument_list|()
condition|)
block|{
name|gl
operator|::
name|Rectangle
name|sourceRect
decl_stmt|;
name|sourceRect
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|sourceRect
operator|.
name|width
operator|=
name|width
expr_stmt|;
name|sourceRect
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|sourceRect
operator|.
name|height
operator|=
name|height
expr_stmt|;
name|mRenderer
operator|->
name|copyImage
argument_list|(
name|source
argument_list|,
name|sourceRect
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|mTexStorage
argument_list|,
name|target
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|copySubImage
name|void
name|TextureCubeMap
operator|::
name|copySubImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|Framebuffer
modifier|*
name|source
parameter_list|)
block|{
name|GLsizei
name|size
init|=
name|mImageArray
index|[
name|faceIndex
argument_list|(
name|target
argument_list|)
index|]
index|[
name|level
index|]
operator|->
name|getWidth
argument_list|()
decl_stmt|;
if|if
condition|(
name|xoffset
operator|+
name|width
operator|>
name|size
operator|||
name|yoffset
operator|+
name|height
operator|>
name|size
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|unsigned
name|int
name|faceindex
init|=
name|faceIndex
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mImageArray
index|[
name|faceindex
index|]
index|[
name|level
index|]
operator|->
name|isRenderableFormat
argument_list|()
operator|||
operator|(
operator|!
name|mTexStorage
operator|&&
operator|!
name|isSamplerComplete
argument_list|()
operator|)
condition|)
block|{
name|mImageArray
index|[
name|faceindex
index|]
index|[
name|level
index|]
operator|->
name|copy
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|mTexStorage
operator|||
operator|!
name|mTexStorage
operator|->
name|isRenderTarget
argument_list|()
condition|)
block|{
name|convertToRenderTarget
argument_list|()
expr_stmt|;
block|}
name|updateTexture
argument_list|()
expr_stmt|;
if|if
condition|(
name|level
operator|<
name|levelCount
argument_list|()
condition|)
block|{
name|gl
operator|::
name|Rectangle
name|sourceRect
decl_stmt|;
name|sourceRect
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|sourceRect
operator|.
name|width
operator|=
name|width
expr_stmt|;
name|sourceRect
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|sourceRect
operator|.
name|height
operator|=
name|height
expr_stmt|;
name|mRenderer
operator|->
name|copyImage
argument_list|(
name|source
argument_list|,
name|sourceRect
argument_list|,
name|gl
operator|::
name|ExtractFormat
argument_list|(
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|getInternalFormat
argument_list|()
argument_list|)
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|mTexStorage
argument_list|,
name|target
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|storage
name|void
name|TextureCubeMap
operator|::
name|storage
parameter_list|(
name|GLsizei
name|levels
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|GLsizei
name|size
parameter_list|)
block|{
operator|delete
name|mTexStorage
expr_stmt|;
name|mTexStorage
operator|=
operator|new
name|rx
operator|::
name|TextureStorageInterfaceCube
argument_list|(
name|mRenderer
argument_list|,
name|levels
argument_list|,
name|internalformat
argument_list|,
name|mUsage
argument_list|,
literal|false
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|mImmutable
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|levels
condition|;
name|level
operator|++
control|)
block|{
for|for
control|(
name|int
name|face
init|=
literal|0
init|;
name|face
operator|<
literal|6
condition|;
name|face
operator|++
control|)
block|{
name|mImageArray
index|[
name|face
index|]
index|[
name|level
index|]
operator|->
name|redefine
argument_list|(
name|mRenderer
argument_list|,
name|internalformat
argument_list|,
name|size
argument_list|,
name|size
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|size
operator|=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|size
operator|>>
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|level
init|=
name|levels
init|;
name|level
operator|<
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|level
operator|++
control|)
block|{
for|for
control|(
name|int
name|face
init|=
literal|0
init|;
name|face
operator|<
literal|6
condition|;
name|face
operator|++
control|)
block|{
name|mImageArray
index|[
name|face
index|]
index|[
name|level
index|]
operator|->
name|redefine
argument_list|(
name|mRenderer
argument_list|,
name|GL_NONE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mTexStorage
operator|->
name|isManaged
argument_list|()
condition|)
block|{
name|int
name|levels
init|=
name|levelCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|face
init|=
literal|0
init|;
name|face
operator|<
literal|6
condition|;
name|face
operator|++
control|)
block|{
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|levels
condition|;
name|level
operator|++
control|)
block|{
name|mImageArray
index|[
name|face
index|]
index|[
name|level
index|]
operator|->
name|setManagedSurface
argument_list|(
name|mTexStorage
argument_list|,
name|face
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|function|generateMipmaps
name|void
name|TextureCubeMap
operator|::
name|generateMipmaps
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isCubeComplete
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|mRenderer
operator|->
name|getNonPower2TextureSupport
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|isPow2
argument_list|(
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|getWidth
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
block|}
comment|// Purge array levels 1 through q and reset them to represent the generated mipmap levels.
name|unsigned
name|int
name|q
init|=
name|log2
argument_list|(
name|mImageArray
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|getWidth
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|f
init|=
literal|0
init|;
name|f
operator|<
literal|6
condition|;
name|f
operator|++
control|)
block|{
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|q
condition|;
name|i
operator|++
control|)
block|{
name|redefineImage
argument_list|(
name|f
argument_list|,
name|i
argument_list|,
name|mImageArray
index|[
name|f
index|]
index|[
literal|0
index|]
operator|->
name|getInternalFormat
argument_list|()
argument_list|,
name|std
operator|::
name|max
argument_list|(
name|mImageArray
index|[
name|f
index|]
index|[
literal|0
index|]
operator|->
name|getWidth
argument_list|()
operator|>>
name|i
argument_list|,
literal|1
argument_list|)
argument_list|,
name|std
operator|::
name|max
argument_list|(
name|mImageArray
index|[
name|f
index|]
index|[
literal|0
index|]
operator|->
name|getWidth
argument_list|()
operator|>>
name|i
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mTexStorage
operator|&&
name|mTexStorage
operator|->
name|isRenderTarget
argument_list|()
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|f
init|=
literal|0
init|;
name|f
operator|<
literal|6
condition|;
name|f
operator|++
control|)
block|{
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|q
condition|;
name|i
operator|++
control|)
block|{
name|mTexStorage
operator|->
name|generateMipmap
argument_list|(
name|f
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|mImageArray
index|[
name|f
index|]
index|[
name|i
index|]
operator|->
name|markClean
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|unsigned
name|int
name|f
init|=
literal|0
init|;
name|f
operator|<
literal|6
condition|;
name|f
operator|++
control|)
block|{
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|q
condition|;
name|i
operator|++
control|)
block|{
name|mRenderer
operator|->
name|generateMipmap
argument_list|(
name|mImageArray
index|[
name|f
index|]
index|[
name|i
index|]
argument_list|,
name|mImageArray
index|[
name|f
index|]
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|function|getRenderbuffer
name|Renderbuffer
modifier|*
name|TextureCubeMap
operator|::
name|getRenderbuffer
parameter_list|(
name|GLenum
name|target
parameter_list|)
block|{
if|if
condition|(
operator|!
name|IsCubemapTextureTarget
argument_list|(
name|target
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
operator|(
name|Renderbuffer
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
name|unsigned
name|int
name|face
init|=
name|faceIndex
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|mFaceProxies
index|[
name|face
index|]
operator|==
name|NULL
condition|)
block|{
name|mFaceProxies
index|[
name|face
index|]
operator|=
operator|new
name|Renderbuffer
argument_list|(
name|mRenderer
argument_list|,
name|id
argument_list|()
argument_list|,
operator|new
name|RenderbufferTextureCubeMap
argument_list|(
name|this
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|mFaceProxies
index|[
name|face
index|]
return|;
block|}
DECL|function|getRenderTarget
name|rx
operator|::
name|RenderTarget
modifier|*
name|TextureCubeMap
operator|::
name|getRenderTarget
parameter_list|(
name|GLenum
name|target
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|IsCubemapTextureTarget
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
comment|// ensure the underlying texture is created
if|if
condition|(
name|getStorage
argument_list|(
literal|true
argument_list|)
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|updateTexture
argument_list|()
expr_stmt|;
return|return
name|mTexStorage
operator|->
name|getRenderTarget
argument_list|(
name|target
argument_list|)
return|;
block|}
DECL|function|levelCount
name|int
name|TextureCubeMap
operator|::
name|levelCount
parameter_list|()
block|{
return|return
name|mTexStorage
condition|?
name|mTexStorage
operator|->
name|levelCount
argument_list|()
operator|-
name|getLodOffset
argument_list|()
else|:
literal|0
return|;
block|}
DECL|function|getStorage
name|rx
operator|::
name|TextureStorageInterface
modifier|*
name|TextureCubeMap
operator|::
name|getStorage
parameter_list|(
name|bool
name|renderTarget
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mTexStorage
operator|||
operator|(
name|renderTarget
operator|&&
operator|!
name|mTexStorage
operator|->
name|isRenderTarget
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|renderTarget
condition|)
block|{
name|convertToRenderTarget
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|createTexture
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|mTexStorage
return|;
block|}
block|}
end_namespace
end_unit
