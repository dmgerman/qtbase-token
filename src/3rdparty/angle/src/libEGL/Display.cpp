begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2012 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Display.cpp: Implements the egl::Display class, representing the abstract
end_comment
begin_comment
comment|// display on which graphics are drawn. Implements EGLDisplay.
end_comment
begin_comment
comment|// [EGL 1.4] section 2.1.2 page 3.
end_comment
begin_include
include|#
directive|include
file|"libEGL/Display.h"
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_include
include|#
directive|include
file|<map>
end_include
begin_include
include|#
directive|include
file|<vector>
end_include
begin_include
include|#
directive|include
file|"common/debug.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/mathutil.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/utilities.h"
end_include
begin_include
include|#
directive|include
file|"libEGL/main.h"
end_include
begin_comment
comment|// Can also be enabled by defining FORCE_REF_RAST in the project's predefined macros
end_comment
begin_define
DECL|macro|REF_RAST
define|#
directive|define
name|REF_RAST
value|0
end_define
begin_comment
comment|// The "Debug This Pixel..." feature in PIX often fails when using the
end_comment
begin_comment
comment|// D3D9Ex interfaces.  In order to get debug pixel to work on a Vista/Win 7
end_comment
begin_comment
comment|// machine, define "ANGLE_ENABLE_D3D9EX=0" in your project file.
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ANGLE_ENABLE_D3D9EX
argument_list|)
end_if
begin_comment
comment|// Enables use of the IDirect3D9Ex interface, when available
end_comment
begin_define
DECL|macro|ANGLE_ENABLE_D3D9EX
define|#
directive|define
name|ANGLE_ENABLE_D3D9EX
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// !defined(ANGLE_ENABLE_D3D9EX)
end_comment
begin_namespace
DECL|namespace|egl
namespace|namespace
name|egl
block|{
namespace|namespace
block|{
DECL|typedef|DisplayMap
typedef|typedef
name|std
operator|::
name|map
argument_list|<
name|EGLNativeDisplayType
argument_list|,
name|Display
modifier|*
argument_list|>
name|DisplayMap
typedef|;
DECL|member|displays
name|DisplayMap
name|displays
decl_stmt|;
block|}
DECL|function|getDisplay
name|egl
operator|::
name|Display
modifier|*
name|Display
operator|::
name|getDisplay
parameter_list|(
name|EGLNativeDisplayType
name|displayId
parameter_list|)
block|{
if|if
condition|(
name|displays
operator|.
name|find
argument_list|(
name|displayId
argument_list|)
operator|!=
name|displays
operator|.
name|end
argument_list|()
condition|)
block|{
return|return
name|displays
index|[
name|displayId
index|]
return|;
block|}
name|egl
operator|::
name|Display
modifier|*
name|display
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|displayId
operator|==
name|EGL_DEFAULT_DISPLAY
condition|)
block|{
name|display
operator|=
operator|new
name|egl
operator|::
name|Display
argument_list|(
name|displayId
argument_list|,
operator|(
name|HDC
operator|)
name|NULL
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|displayId
operator|==
name|EGL_SOFTWARE_DISPLAY_ANGLE
condition|)
block|{
name|display
operator|=
operator|new
name|egl
operator|::
name|Display
argument_list|(
name|displayId
argument_list|,
operator|(
name|HDC
operator|)
name|NULL
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// FIXME: Check if displayId is a valid display device context
name|display
operator|=
operator|new
name|egl
operator|::
name|Display
argument_list|(
name|displayId
argument_list|,
operator|(
name|HDC
operator|)
name|displayId
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|displays
index|[
name|displayId
index|]
operator|=
name|display
expr_stmt|;
return|return
name|display
return|;
block|}
DECL|function|Display
name|Display
operator|::
name|Display
parameter_list|(
name|EGLNativeDisplayType
name|displayId
parameter_list|,
name|HDC
name|deviceContext
parameter_list|,
name|bool
name|software
parameter_list|)
member_init_list|:
name|mDc
argument_list|(
name|deviceContext
argument_list|)
block|{
name|mD3d9Module
operator|=
name|NULL
expr_stmt|;
name|mD3d9
operator|=
name|NULL
expr_stmt|;
name|mD3d9Ex
operator|=
name|NULL
expr_stmt|;
name|mDevice
operator|=
name|NULL
expr_stmt|;
name|mDeviceEx
operator|=
name|NULL
expr_stmt|;
name|mDeviceWindow
operator|=
name|NULL
expr_stmt|;
name|mAdapter
operator|=
name|D3DADAPTER_DEFAULT
expr_stmt|;
if|#
directive|if
name|REF_RAST
operator|==
literal|1
operator|||
name|defined
argument_list|(
name|FORCE_REF_RAST
argument_list|)
name|mDeviceType
operator|=
name|D3DDEVTYPE_REF
expr_stmt|;
else|#
directive|else
name|mDeviceType
operator|=
name|D3DDEVTYPE_HAL
expr_stmt|;
endif|#
directive|endif
name|mMinSwapInterval
operator|=
literal|1
expr_stmt|;
name|mMaxSwapInterval
operator|=
literal|1
expr_stmt|;
name|mSoftwareDevice
operator|=
name|software
expr_stmt|;
name|mDisplayId
operator|=
name|displayId
expr_stmt|;
name|mDeviceLost
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|~Display
name|Display
operator|::
name|~
name|Display
parameter_list|()
block|{
name|terminate
argument_list|()
expr_stmt|;
name|DisplayMap
operator|::
name|iterator
name|thisDisplay
init|=
name|displays
operator|.
name|find
argument_list|(
name|mDisplayId
argument_list|)
decl_stmt|;
if|if
condition|(
name|thisDisplay
operator|!=
name|displays
operator|.
name|end
argument_list|()
condition|)
block|{
name|displays
operator|.
name|erase
argument_list|(
name|thisDisplay
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|initialize
name|bool
name|Display
operator|::
name|initialize
parameter_list|()
block|{
if|if
condition|(
name|isInitialized
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|mSoftwareDevice
condition|)
block|{
name|mD3d9Module
operator|=
name|GetModuleHandle
argument_list|(
name|TEXT
argument_list|(
literal|"swiftshader_d3d9.dll"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mD3d9Module
operator|=
name|GetModuleHandle
argument_list|(
name|TEXT
argument_list|(
literal|"d3d9.dll"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mD3d9Module
operator|==
name|NULL
condition|)
block|{
name|terminate
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
typedef|typedef
name|HRESULT
function_decl|(
name|WINAPI
modifier|*
name|Direct3DCreate9ExFunc
function_decl|)
parameter_list|(
name|UINT
parameter_list|,
name|IDirect3D9Ex
modifier|*
modifier|*
parameter_list|)
function_decl|;
name|Direct3DCreate9ExFunc
name|Direct3DCreate9ExPtr
init|=
cast|reinterpret_cast
argument_list|<
name|Direct3DCreate9ExFunc
argument_list|>
argument_list|(
name|GetProcAddress
argument_list|(
name|mD3d9Module
argument_list|,
literal|"Direct3DCreate9Ex"
argument_list|)
argument_list|)
decl_stmt|;
comment|// Use Direct3D9Ex if available. Among other things, this version is less
comment|// inclined to report a lost context, for example when the user switches
comment|// desktop. Direct3D9Ex is available in Windows Vista and later if suitable drivers are available.
if|if
condition|(
name|ANGLE_ENABLE_D3D9EX
operator|&&
name|Direct3DCreate9ExPtr
operator|&&
name|SUCCEEDED
argument_list|(
name|Direct3DCreate9ExPtr
argument_list|(
name|D3D_SDK_VERSION
argument_list|,
operator|&
name|mD3d9Ex
argument_list|)
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|mD3d9Ex
argument_list|)
expr_stmt|;
name|mD3d9Ex
operator|->
name|QueryInterface
argument_list|(
name|IID_IDirect3D9
argument_list|,
cast|reinterpret_cast
argument_list|<
name|void
operator|*
operator|*
argument_list|>
argument_list|(
operator|&
name|mD3d9
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mD3d9
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mD3d9
operator|=
name|Direct3DCreate9
argument_list|(
name|D3D_SDK_VERSION
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mD3d9
condition|)
block|{
if|if
condition|(
name|mDc
operator|!=
name|NULL
condition|)
block|{
comment|//  UNIMPLEMENTED();   // FIXME: Determine which adapter index the device context corresponds to
block|}
name|HRESULT
name|result
decl_stmt|;
comment|// Give up on getting device caps after about one second.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
operator|++
name|i
control|)
block|{
name|result
operator|=
name|mD3d9
operator|->
name|GetDeviceCaps
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
operator|&
name|mDeviceCaps
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|D3DERR_NOTAVAILABLE
condition|)
block|{
name|Sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|// Give the driver some time to initialize/recover
block|}
elseif|else
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
comment|// D3DERR_OUTOFVIDEOMEMORY, E_OUTOFMEMORY, D3DERR_INVALIDDEVICE, or another error we can't recover from
block|{
name|terminate
argument_list|()
expr_stmt|;
return|return
name|error
argument_list|(
name|EGL_BAD_ALLOC
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|mDeviceCaps
operator|.
name|PixelShaderVersion
operator|<
name|D3DPS_VERSION
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|terminate
argument_list|()
expr_stmt|;
return|return
name|error
argument_list|(
name|EGL_NOT_INITIALIZED
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|// When DirectX9 is running with an older DirectX8 driver, a StretchRect from a regular texture to a render target texture is not supported.
comment|// This is required by Texture2D::convertToRenderTarget.
if|if
condition|(
operator|(
name|mDeviceCaps
operator|.
name|DevCaps2
operator|&
name|D3DDEVCAPS2_CAN_STRETCHRECT_FROM_TEXTURES
operator|)
operator|==
literal|0
condition|)
block|{
name|terminate
argument_list|()
expr_stmt|;
return|return
name|error
argument_list|(
name|EGL_NOT_INITIALIZED
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|mMinSwapInterval
operator|=
literal|4
expr_stmt|;
name|mMaxSwapInterval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mDeviceCaps
operator|.
name|PresentationIntervals
operator|&
name|D3DPRESENT_INTERVAL_IMMEDIATE
condition|)
block|{
name|mMinSwapInterval
operator|=
name|std
operator|::
name|min
argument_list|(
name|mMinSwapInterval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mMaxSwapInterval
operator|=
name|std
operator|::
name|max
argument_list|(
name|mMaxSwapInterval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mDeviceCaps
operator|.
name|PresentationIntervals
operator|&
name|D3DPRESENT_INTERVAL_ONE
condition|)
block|{
name|mMinSwapInterval
operator|=
name|std
operator|::
name|min
argument_list|(
name|mMinSwapInterval
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mMaxSwapInterval
operator|=
name|std
operator|::
name|max
argument_list|(
name|mMaxSwapInterval
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mDeviceCaps
operator|.
name|PresentationIntervals
operator|&
name|D3DPRESENT_INTERVAL_TWO
condition|)
block|{
name|mMinSwapInterval
operator|=
name|std
operator|::
name|min
argument_list|(
name|mMinSwapInterval
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|mMaxSwapInterval
operator|=
name|std
operator|::
name|max
argument_list|(
name|mMaxSwapInterval
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mDeviceCaps
operator|.
name|PresentationIntervals
operator|&
name|D3DPRESENT_INTERVAL_THREE
condition|)
block|{
name|mMinSwapInterval
operator|=
name|std
operator|::
name|min
argument_list|(
name|mMinSwapInterval
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|mMaxSwapInterval
operator|=
name|std
operator|::
name|max
argument_list|(
name|mMaxSwapInterval
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mDeviceCaps
operator|.
name|PresentationIntervals
operator|&
name|D3DPRESENT_INTERVAL_FOUR
condition|)
block|{
name|mMinSwapInterval
operator|=
name|std
operator|::
name|min
argument_list|(
name|mMinSwapInterval
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|mMaxSwapInterval
operator|=
name|std
operator|::
name|max
argument_list|(
name|mMaxSwapInterval
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|mD3d9
operator|->
name|GetAdapterIdentifier
argument_list|(
name|mAdapter
argument_list|,
literal|0
argument_list|,
operator|&
name|mAdapterIdentifier
argument_list|)
expr_stmt|;
comment|// ATI cards on XP have problems with non-power-of-two textures.
name|mSupportsNonPower2Textures
operator|=
operator|!
operator|(
name|mDeviceCaps
operator|.
name|TextureCaps
operator|&
name|D3DPTEXTURECAPS_POW2
operator|)
operator|&&
operator|!
operator|(
name|mDeviceCaps
operator|.
name|TextureCaps
operator|&
name|D3DPTEXTURECAPS_CUBEMAP_POW2
operator|)
operator|&&
operator|!
operator|(
name|mDeviceCaps
operator|.
name|TextureCaps
operator|&
name|D3DPTEXTURECAPS_NONPOW2CONDITIONAL
operator|)
operator|&&
operator|!
operator|(
name|getComparableOSVersion
argument_list|()
operator|<
name|versionWindowsVista
operator|&&
name|mAdapterIdentifier
operator|.
name|VendorId
operator|==
name|VENDOR_ID_AMD
operator|)
expr_stmt|;
specifier|const
name|D3DFORMAT
name|renderTargetFormats
index|[]
init|=
block|{
name|D3DFMT_A1R5G5B5
block|,
comment|//  D3DFMT_A2R10G10B10,   // The color_ramp conformance test uses ReadPixels with UNSIGNED_BYTE causing it to think that rendering skipped a colour value.
name|D3DFMT_A8R8G8B8
block|,
name|D3DFMT_R5G6B5
block|,
comment|//  D3DFMT_X1R5G5B5,      // Has no compatible OpenGL ES renderbuffer format
name|D3DFMT_X8R8G8B8
block|}
decl_stmt|;
specifier|const
name|D3DFORMAT
name|depthStencilFormats
index|[]
init|=
block|{
name|D3DFMT_UNKNOWN
block|,
comment|//  D3DFMT_D16_LOCKABLE,
name|D3DFMT_D32
block|,
comment|//  D3DFMT_D15S1,
name|D3DFMT_D24S8
block|,
name|D3DFMT_D24X8
block|,
comment|//  D3DFMT_D24X4S4,
name|D3DFMT_D16
block|,
comment|//  D3DFMT_D32F_LOCKABLE,
comment|//  D3DFMT_D24FS8
block|}
decl_stmt|;
name|D3DDISPLAYMODE
name|currentDisplayMode
decl_stmt|;
name|mD3d9
operator|->
name|GetAdapterDisplayMode
argument_list|(
name|mAdapter
argument_list|,
operator|&
name|currentDisplayMode
argument_list|)
expr_stmt|;
name|ConfigSet
name|configSet
decl_stmt|;
for|for
control|(
name|int
name|formatIndex
init|=
literal|0
init|;
name|formatIndex
operator|<
sizeof|sizeof
argument_list|(
name|renderTargetFormats
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|D3DFORMAT
argument_list|)
condition|;
name|formatIndex
operator|++
control|)
block|{
name|D3DFORMAT
name|renderTargetFormat
init|=
name|renderTargetFormats
index|[
name|formatIndex
index|]
decl_stmt|;
name|HRESULT
name|result
init|=
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
name|D3DUSAGE_RENDERTARGET
argument_list|,
name|D3DRTYPE_SURFACE
argument_list|,
name|renderTargetFormat
argument_list|)
decl_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
condition|)
block|{
for|for
control|(
name|int
name|depthStencilIndex
init|=
literal|0
init|;
name|depthStencilIndex
operator|<
sizeof|sizeof
argument_list|(
name|depthStencilFormats
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|D3DFORMAT
argument_list|)
condition|;
name|depthStencilIndex
operator|++
control|)
block|{
name|D3DFORMAT
name|depthStencilFormat
init|=
name|depthStencilFormats
index|[
name|depthStencilIndex
index|]
decl_stmt|;
name|HRESULT
name|result
init|=
name|D3D_OK
decl_stmt|;
if|if
condition|(
name|depthStencilFormat
operator|!=
name|D3DFMT_UNKNOWN
condition|)
block|{
name|result
operator|=
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
name|D3DUSAGE_DEPTHSTENCIL
argument_list|,
name|D3DRTYPE_SURFACE
argument_list|,
name|depthStencilFormat
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
condition|)
block|{
if|if
condition|(
name|depthStencilFormat
operator|!=
name|D3DFMT_UNKNOWN
condition|)
block|{
name|result
operator|=
name|mD3d9
operator|->
name|CheckDepthStencilMatch
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
name|renderTargetFormat
argument_list|,
name|depthStencilFormat
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
condition|)
block|{
comment|// FIXME: enumerate multi-sampling
name|configSet
operator|.
name|add
argument_list|(
name|currentDisplayMode
argument_list|,
name|mMinSwapInterval
argument_list|,
name|mMaxSwapInterval
argument_list|,
name|renderTargetFormat
argument_list|,
name|depthStencilFormat
argument_list|,
literal|0
argument_list|,
name|mDeviceCaps
operator|.
name|MaxTextureWidth
argument_list|,
name|mDeviceCaps
operator|.
name|MaxTextureHeight
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|// Give the sorted configs a unique ID and store them internally
name|EGLint
name|index
init|=
literal|1
decl_stmt|;
for|for
control|(
name|ConfigSet
operator|::
name|Iterator
name|config
init|=
name|configSet
operator|.
name|mSet
operator|.
name|begin
argument_list|()
init|;
name|config
operator|!=
name|configSet
operator|.
name|mSet
operator|.
name|end
argument_list|()
condition|;
name|config
operator|++
control|)
block|{
name|Config
name|configuration
init|=
operator|*
name|config
decl_stmt|;
name|configuration
operator|.
name|mConfigID
operator|=
name|index
expr_stmt|;
name|index
operator|++
expr_stmt|;
name|mConfigSet
operator|.
name|mSet
operator|.
name|insert
argument_list|(
name|configuration
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|isInitialized
argument_list|()
condition|)
block|{
name|terminate
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
name|initExtensionString
argument_list|()
expr_stmt|;
specifier|static
specifier|const
name|TCHAR
name|windowName
index|[]
init|=
name|TEXT
argument_list|(
literal|"AngleHiddenWindow"
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|TCHAR
name|className
index|[]
init|=
name|TEXT
argument_list|(
literal|"STATIC"
argument_list|)
decl_stmt|;
name|mDeviceWindow
operator|=
name|CreateWindowEx
argument_list|(
name|WS_EX_NOACTIVATE
argument_list|,
name|className
argument_list|,
name|windowName
argument_list|,
name|WS_DISABLED
operator||
name|WS_POPUP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|HWND_MESSAGE
argument_list|,
name|NULL
argument_list|,
name|GetModuleHandle
argument_list|(
name|NULL
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|createDevice
argument_list|()
condition|)
block|{
name|terminate
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
name|mVertexShaderCache
operator|.
name|initialize
argument_list|(
name|mDevice
argument_list|)
expr_stmt|;
name|mPixelShaderCache
operator|.
name|initialize
argument_list|(
name|mDevice
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|terminate
name|void
name|Display
operator|::
name|terminate
parameter_list|()
block|{
while|while
condition|(
operator|!
name|mSurfaceSet
operator|.
name|empty
argument_list|()
condition|)
block|{
name|destroySurface
argument_list|(
operator|*
name|mSurfaceSet
operator|.
name|begin
argument_list|()
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|mContextSet
operator|.
name|empty
argument_list|()
condition|)
block|{
name|destroyContext
argument_list|(
operator|*
name|mContextSet
operator|.
name|begin
argument_list|()
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|mEventQueryPool
operator|.
name|empty
argument_list|()
condition|)
block|{
name|mEventQueryPool
operator|.
name|back
argument_list|()
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mEventQueryPool
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
name|mVertexShaderCache
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mPixelShaderCache
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|mDevice
condition|)
block|{
comment|// If the device is lost, reset it first to prevent leaving the driver in an unstable state
if|if
condition|(
name|testDeviceLost
argument_list|()
condition|)
block|{
name|resetDevice
argument_list|()
expr_stmt|;
block|}
name|mDevice
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mDevice
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mDeviceEx
condition|)
block|{
name|mDeviceEx
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mDeviceEx
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mD3d9
condition|)
block|{
name|mD3d9
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mD3d9
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mDeviceWindow
condition|)
block|{
name|DestroyWindow
argument_list|(
name|mDeviceWindow
argument_list|)
expr_stmt|;
name|mDeviceWindow
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mD3d9Ex
condition|)
block|{
name|mD3d9Ex
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mD3d9Ex
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mD3d9Module
condition|)
block|{
name|mD3d9Module
operator|=
name|NULL
expr_stmt|;
block|}
block|}
DECL|function|startScene
name|void
name|Display
operator|::
name|startScene
parameter_list|()
block|{
if|if
condition|(
operator|!
name|mSceneStarted
condition|)
block|{
name|long
name|result
init|=
name|mDevice
operator|->
name|BeginScene
argument_list|()
decl_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
condition|)
block|{
comment|// This is defensive checking against the device being
comment|// lost at unexpected times.
name|mSceneStarted
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
DECL|function|endScene
name|void
name|Display
operator|::
name|endScene
parameter_list|()
block|{
if|if
condition|(
name|mSceneStarted
condition|)
block|{
comment|// EndScene can fail if the device was lost, for example due
comment|// to a TDR during a draw call.
name|mDevice
operator|->
name|EndScene
argument_list|()
expr_stmt|;
name|mSceneStarted
operator|=
literal|false
expr_stmt|;
block|}
block|}
DECL|function|getConfigs
name|bool
name|Display
operator|::
name|getConfigs
parameter_list|(
name|EGLConfig
modifier|*
name|configs
parameter_list|,
specifier|const
name|EGLint
modifier|*
name|attribList
parameter_list|,
name|EGLint
name|configSize
parameter_list|,
name|EGLint
modifier|*
name|numConfig
parameter_list|)
block|{
return|return
name|mConfigSet
operator|.
name|getConfigs
argument_list|(
name|configs
argument_list|,
name|attribList
argument_list|,
name|configSize
argument_list|,
name|numConfig
argument_list|)
return|;
block|}
DECL|function|getConfigAttrib
name|bool
name|Display
operator|::
name|getConfigAttrib
parameter_list|(
name|EGLConfig
name|config
parameter_list|,
name|EGLint
name|attribute
parameter_list|,
name|EGLint
modifier|*
name|value
parameter_list|)
block|{
specifier|const
name|egl
operator|::
name|Config
modifier|*
name|configuration
init|=
name|mConfigSet
operator|.
name|get
argument_list|(
name|config
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|attribute
condition|)
block|{
case|case
name|EGL_BUFFER_SIZE
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mBufferSize
expr_stmt|;
break|break;
case|case
name|EGL_ALPHA_SIZE
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mAlphaSize
expr_stmt|;
break|break;
case|case
name|EGL_BLUE_SIZE
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mBlueSize
expr_stmt|;
break|break;
case|case
name|EGL_GREEN_SIZE
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mGreenSize
expr_stmt|;
break|break;
case|case
name|EGL_RED_SIZE
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mRedSize
expr_stmt|;
break|break;
case|case
name|EGL_DEPTH_SIZE
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mDepthSize
expr_stmt|;
break|break;
case|case
name|EGL_STENCIL_SIZE
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mStencilSize
expr_stmt|;
break|break;
case|case
name|EGL_CONFIG_CAVEAT
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mConfigCaveat
expr_stmt|;
break|break;
case|case
name|EGL_CONFIG_ID
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mConfigID
expr_stmt|;
break|break;
case|case
name|EGL_LEVEL
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mLevel
expr_stmt|;
break|break;
case|case
name|EGL_NATIVE_RENDERABLE
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mNativeRenderable
expr_stmt|;
break|break;
case|case
name|EGL_NATIVE_VISUAL_TYPE
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mNativeVisualType
expr_stmt|;
break|break;
case|case
name|EGL_SAMPLES
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mSamples
expr_stmt|;
break|break;
case|case
name|EGL_SAMPLE_BUFFERS
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mSampleBuffers
expr_stmt|;
break|break;
case|case
name|EGL_SURFACE_TYPE
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mSurfaceType
expr_stmt|;
break|break;
case|case
name|EGL_TRANSPARENT_TYPE
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mTransparentType
expr_stmt|;
break|break;
case|case
name|EGL_TRANSPARENT_BLUE_VALUE
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mTransparentBlueValue
expr_stmt|;
break|break;
case|case
name|EGL_TRANSPARENT_GREEN_VALUE
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mTransparentGreenValue
expr_stmt|;
break|break;
case|case
name|EGL_TRANSPARENT_RED_VALUE
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mTransparentRedValue
expr_stmt|;
break|break;
case|case
name|EGL_BIND_TO_TEXTURE_RGB
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mBindToTextureRGB
expr_stmt|;
break|break;
case|case
name|EGL_BIND_TO_TEXTURE_RGBA
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mBindToTextureRGBA
expr_stmt|;
break|break;
case|case
name|EGL_MIN_SWAP_INTERVAL
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mMinSwapInterval
expr_stmt|;
break|break;
case|case
name|EGL_MAX_SWAP_INTERVAL
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mMaxSwapInterval
expr_stmt|;
break|break;
case|case
name|EGL_LUMINANCE_SIZE
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mLuminanceSize
expr_stmt|;
break|break;
case|case
name|EGL_ALPHA_MASK_SIZE
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mAlphaMaskSize
expr_stmt|;
break|break;
case|case
name|EGL_COLOR_BUFFER_TYPE
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mColorBufferType
expr_stmt|;
break|break;
case|case
name|EGL_RENDERABLE_TYPE
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mRenderableType
expr_stmt|;
break|break;
case|case
name|EGL_MATCH_NATIVE_PIXMAP
case|:
operator|*
name|value
operator|=
literal|false
expr_stmt|;
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
break|break;
case|case
name|EGL_CONFORMANT
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mConformant
expr_stmt|;
break|break;
case|case
name|EGL_MAX_PBUFFER_WIDTH
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mMaxPBufferWidth
expr_stmt|;
break|break;
case|case
name|EGL_MAX_PBUFFER_HEIGHT
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mMaxPBufferHeight
expr_stmt|;
break|break;
case|case
name|EGL_MAX_PBUFFER_PIXELS
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mMaxPBufferPixels
expr_stmt|;
break|break;
default|default:
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|createDevice
name|bool
name|Display
operator|::
name|createDevice
parameter_list|()
block|{
name|D3DPRESENT_PARAMETERS
name|presentParameters
init|=
name|getDefaultPresentParameters
argument_list|()
decl_stmt|;
name|DWORD
name|behaviorFlags
init|=
name|D3DCREATE_FPU_PRESERVE
operator||
name|D3DCREATE_NOWINDOWCHANGES
decl_stmt|;
name|HRESULT
name|result
init|=
name|mD3d9
operator|->
name|CreateDevice
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|mDeviceWindow
argument_list|,
name|behaviorFlags
operator||
name|D3DCREATE_HARDWARE_VERTEXPROCESSING
operator||
name|D3DCREATE_PUREDEVICE
argument_list|,
operator|&
name|presentParameters
argument_list|,
operator|&
name|mDevice
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|D3DERR_OUTOFVIDEOMEMORY
operator|||
name|result
operator|==
name|E_OUTOFMEMORY
operator|||
name|result
operator|==
name|D3DERR_DEVICELOST
condition|)
block|{
return|return
name|error
argument_list|(
name|EGL_BAD_ALLOC
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|result
operator|=
name|mD3d9
operator|->
name|CreateDevice
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|mDeviceWindow
argument_list|,
name|behaviorFlags
operator||
name|D3DCREATE_SOFTWARE_VERTEXPROCESSING
argument_list|,
operator|&
name|presentParameters
argument_list|,
operator|&
name|mDevice
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|result
operator|==
name|D3DERR_OUTOFVIDEOMEMORY
operator|||
name|result
operator|==
name|E_OUTOFMEMORY
operator|||
name|result
operator|==
name|D3DERR_NOTAVAILABLE
operator|||
name|result
operator|==
name|D3DERR_DEVICELOST
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
name|EGL_BAD_ALLOC
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|mD3d9Ex
condition|)
block|{
name|result
operator|=
name|mDevice
operator|->
name|QueryInterface
argument_list|(
name|IID_IDirect3DDevice9Ex
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|mDeviceEx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|initializeDevice
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// do any one-time device initialization
comment|// NOTE: this is also needed after a device lost/reset
comment|// to reset the scene status and ensure the default states are reset.
DECL|function|initializeDevice
name|void
name|Display
operator|::
name|initializeDevice
parameter_list|()
block|{
comment|// Permanent non-default states
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_POINTSPRITEENABLE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_LASTPIXEL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mDeviceCaps
operator|.
name|PixelShaderVersion
operator|>=
name|D3DPS_VERSION
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_POINTSIZE_MAX
argument_list|,
operator|(
name|DWORD
operator|&
operator|)
name|mDeviceCaps
operator|.
name|MaxPointSize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_POINTSIZE_MAX
argument_list|,
literal|0x3F800000
argument_list|)
expr_stmt|;
comment|// 1.0f
block|}
name|mSceneStarted
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|resetDevice
name|bool
name|Display
operator|::
name|resetDevice
parameter_list|()
block|{
name|D3DPRESENT_PARAMETERS
name|presentParameters
init|=
name|getDefaultPresentParameters
argument_list|()
decl_stmt|;
name|HRESULT
name|result
init|=
name|D3D_OK
decl_stmt|;
name|bool
name|lost
init|=
name|testDeviceLost
argument_list|()
decl_stmt|;
name|int
name|attempts
init|=
literal|3
decl_stmt|;
while|while
condition|(
name|lost
operator|&&
name|attempts
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|mDeviceEx
condition|)
block|{
name|Sleep
argument_list|(
literal|500
argument_list|)
expr_stmt|;
comment|// Give the graphics driver some CPU time
name|result
operator|=
name|mDeviceEx
operator|->
name|ResetEx
argument_list|(
operator|&
name|presentParameters
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|mDevice
operator|->
name|TestCooperativeLevel
argument_list|()
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|D3DERR_DEVICELOST
condition|)
block|{
name|Sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|// Give the graphics driver some CPU time
name|result
operator|=
name|mDevice
operator|->
name|TestCooperativeLevel
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|D3DERR_DEVICENOTRESET
condition|)
block|{
name|result
operator|=
name|mDevice
operator|->
name|Reset
argument_list|(
operator|&
name|presentParameters
argument_list|)
expr_stmt|;
block|}
block|}
name|lost
operator|=
name|testDeviceLost
argument_list|()
expr_stmt|;
name|attempts
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Reset/ResetEx failed multiple times: 0x%08X"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
name|EGL_BAD_ALLOC
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|// reset device defaults
name|initializeDevice
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|createWindowSurface
name|EGLSurface
name|Display
operator|::
name|createWindowSurface
parameter_list|(
name|HWND
name|window
parameter_list|,
name|EGLConfig
name|config
parameter_list|,
specifier|const
name|EGLint
modifier|*
name|attribList
parameter_list|)
block|{
specifier|const
name|Config
modifier|*
name|configuration
init|=
name|mConfigSet
operator|.
name|get
argument_list|(
name|config
argument_list|)
decl_stmt|;
name|EGLint
name|postSubBufferSupported
init|=
name|EGL_FALSE
decl_stmt|;
if|if
condition|(
name|attribList
condition|)
block|{
while|while
condition|(
operator|*
name|attribList
operator|!=
name|EGL_NONE
condition|)
block|{
switch|switch
condition|(
name|attribList
index|[
literal|0
index|]
condition|)
block|{
case|case
name|EGL_RENDER_BUFFER
case|:
switch|switch
condition|(
name|attribList
index|[
literal|1
index|]
condition|)
block|{
case|case
name|EGL_BACK_BUFFER
case|:
break|break;
case|case
name|EGL_SINGLE_BUFFER
case|:
return|return
name|error
argument_list|(
name|EGL_BAD_MATCH
argument_list|,
name|EGL_NO_SURFACE
argument_list|)
return|;
comment|// Rendering directly to front buffer not supported
default|default:
return|return
name|error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|,
name|EGL_NO_SURFACE
argument_list|)
return|;
block|}
break|break;
case|case
name|EGL_POST_SUB_BUFFER_SUPPORTED_NV
case|:
name|postSubBufferSupported
operator|=
name|attribList
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|EGL_VG_COLORSPACE
case|:
return|return
name|error
argument_list|(
name|EGL_BAD_MATCH
argument_list|,
name|EGL_NO_SURFACE
argument_list|)
return|;
case|case
name|EGL_VG_ALPHA_FORMAT
case|:
return|return
name|error
argument_list|(
name|EGL_BAD_MATCH
argument_list|,
name|EGL_NO_SURFACE
argument_list|)
return|;
default|default:
return|return
name|error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|,
name|EGL_NO_SURFACE
argument_list|)
return|;
block|}
name|attribList
operator|+=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hasExistingWindowSurface
argument_list|(
name|window
argument_list|)
condition|)
block|{
return|return
name|error
argument_list|(
name|EGL_BAD_ALLOC
argument_list|,
name|EGL_NO_SURFACE
argument_list|)
return|;
block|}
if|if
condition|(
name|testDeviceLost
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|restoreLostDevice
argument_list|()
condition|)
return|return
name|EGL_NO_SURFACE
return|;
block|}
name|Surface
modifier|*
name|surface
init|=
operator|new
name|Surface
argument_list|(
name|this
argument_list|,
name|configuration
argument_list|,
name|window
argument_list|,
name|postSubBufferSupported
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|surface
operator|->
name|initialize
argument_list|()
condition|)
block|{
operator|delete
name|surface
expr_stmt|;
return|return
name|EGL_NO_SURFACE
return|;
block|}
name|mSurfaceSet
operator|.
name|insert
argument_list|(
name|surface
argument_list|)
expr_stmt|;
return|return
name|success
argument_list|(
name|surface
argument_list|)
return|;
block|}
DECL|function|createOffscreenSurface
name|EGLSurface
name|Display
operator|::
name|createOffscreenSurface
parameter_list|(
name|EGLConfig
name|config
parameter_list|,
name|HANDLE
name|shareHandle
parameter_list|,
specifier|const
name|EGLint
modifier|*
name|attribList
parameter_list|)
block|{
name|EGLint
name|width
init|=
literal|0
decl_stmt|,
name|height
init|=
literal|0
decl_stmt|;
name|EGLenum
name|textureFormat
init|=
name|EGL_NO_TEXTURE
decl_stmt|;
name|EGLenum
name|textureTarget
init|=
name|EGL_NO_TEXTURE
decl_stmt|;
specifier|const
name|Config
modifier|*
name|configuration
init|=
name|mConfigSet
operator|.
name|get
argument_list|(
name|config
argument_list|)
decl_stmt|;
if|if
condition|(
name|attribList
condition|)
block|{
while|while
condition|(
operator|*
name|attribList
operator|!=
name|EGL_NONE
condition|)
block|{
switch|switch
condition|(
name|attribList
index|[
literal|0
index|]
condition|)
block|{
case|case
name|EGL_WIDTH
case|:
name|width
operator|=
name|attribList
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|EGL_HEIGHT
case|:
name|height
operator|=
name|attribList
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|EGL_LARGEST_PBUFFER
case|:
if|if
condition|(
name|attribList
index|[
literal|1
index|]
operator|!=
name|EGL_FALSE
condition|)
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
comment|// FIXME
break|break;
case|case
name|EGL_TEXTURE_FORMAT
case|:
switch|switch
condition|(
name|attribList
index|[
literal|1
index|]
condition|)
block|{
case|case
name|EGL_NO_TEXTURE
case|:
case|case
name|EGL_TEXTURE_RGB
case|:
case|case
name|EGL_TEXTURE_RGBA
case|:
name|textureFormat
operator|=
name|attribList
index|[
literal|1
index|]
expr_stmt|;
break|break;
default|default:
return|return
name|error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|,
name|EGL_NO_SURFACE
argument_list|)
return|;
block|}
break|break;
case|case
name|EGL_TEXTURE_TARGET
case|:
switch|switch
condition|(
name|attribList
index|[
literal|1
index|]
condition|)
block|{
case|case
name|EGL_NO_TEXTURE
case|:
case|case
name|EGL_TEXTURE_2D
case|:
name|textureTarget
operator|=
name|attribList
index|[
literal|1
index|]
expr_stmt|;
break|break;
default|default:
return|return
name|error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|,
name|EGL_NO_SURFACE
argument_list|)
return|;
block|}
break|break;
case|case
name|EGL_MIPMAP_TEXTURE
case|:
if|if
condition|(
name|attribList
index|[
literal|1
index|]
operator|!=
name|EGL_FALSE
condition|)
return|return
name|error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|,
name|EGL_NO_SURFACE
argument_list|)
return|;
break|break;
case|case
name|EGL_VG_COLORSPACE
case|:
return|return
name|error
argument_list|(
name|EGL_BAD_MATCH
argument_list|,
name|EGL_NO_SURFACE
argument_list|)
return|;
case|case
name|EGL_VG_ALPHA_FORMAT
case|:
return|return
name|error
argument_list|(
name|EGL_BAD_MATCH
argument_list|,
name|EGL_NO_SURFACE
argument_list|)
return|;
default|default:
return|return
name|error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|,
name|EGL_NO_SURFACE
argument_list|)
return|;
block|}
name|attribList
operator|+=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|width
operator|<
literal|0
operator|||
name|height
operator|<
literal|0
condition|)
block|{
return|return
name|error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|,
name|EGL_NO_SURFACE
argument_list|)
return|;
block|}
if|if
condition|(
name|width
operator|==
literal|0
operator|||
name|height
operator|==
literal|0
condition|)
block|{
return|return
name|error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|,
name|EGL_NO_SURFACE
argument_list|)
return|;
block|}
if|if
condition|(
name|textureFormat
operator|!=
name|EGL_NO_TEXTURE
operator|&&
operator|!
name|getNonPower2TextureSupport
argument_list|()
operator|&&
operator|(
operator|!
name|gl
operator|::
name|isPow2
argument_list|(
name|width
argument_list|)
operator|||
operator|!
name|gl
operator|::
name|isPow2
argument_list|(
name|height
argument_list|)
operator|)
condition|)
block|{
return|return
name|error
argument_list|(
name|EGL_BAD_MATCH
argument_list|,
name|EGL_NO_SURFACE
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|textureFormat
operator|!=
name|EGL_NO_TEXTURE
operator|&&
name|textureTarget
operator|==
name|EGL_NO_TEXTURE
operator|)
operator|||
operator|(
name|textureFormat
operator|==
name|EGL_NO_TEXTURE
operator|&&
name|textureTarget
operator|!=
name|EGL_NO_TEXTURE
operator|)
condition|)
block|{
return|return
name|error
argument_list|(
name|EGL_BAD_MATCH
argument_list|,
name|EGL_NO_SURFACE
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|configuration
operator|->
name|mSurfaceType
operator|&
name|EGL_PBUFFER_BIT
operator|)
condition|)
block|{
return|return
name|error
argument_list|(
name|EGL_BAD_MATCH
argument_list|,
name|EGL_NO_SURFACE
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|textureFormat
operator|==
name|EGL_TEXTURE_RGB
operator|&&
name|configuration
operator|->
name|mBindToTextureRGB
operator|!=
name|EGL_TRUE
operator|)
operator|||
operator|(
name|textureFormat
operator|==
name|EGL_TEXTURE_RGBA
operator|&&
name|configuration
operator|->
name|mBindToTextureRGBA
operator|!=
name|EGL_TRUE
operator|)
condition|)
block|{
return|return
name|error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|,
name|EGL_NO_SURFACE
argument_list|)
return|;
block|}
if|if
condition|(
name|testDeviceLost
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|restoreLostDevice
argument_list|()
condition|)
return|return
name|EGL_NO_SURFACE
return|;
block|}
name|Surface
modifier|*
name|surface
init|=
operator|new
name|Surface
argument_list|(
name|this
argument_list|,
name|configuration
argument_list|,
name|shareHandle
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|textureFormat
argument_list|,
name|textureTarget
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|surface
operator|->
name|initialize
argument_list|()
condition|)
block|{
operator|delete
name|surface
expr_stmt|;
return|return
name|EGL_NO_SURFACE
return|;
block|}
name|mSurfaceSet
operator|.
name|insert
argument_list|(
name|surface
argument_list|)
expr_stmt|;
return|return
name|success
argument_list|(
name|surface
argument_list|)
return|;
block|}
DECL|function|createContext
name|EGLContext
name|Display
operator|::
name|createContext
parameter_list|(
name|EGLConfig
name|configHandle
parameter_list|,
specifier|const
name|gl
operator|::
name|Context
modifier|*
name|shareContext
parameter_list|,
name|bool
name|notifyResets
parameter_list|,
name|bool
name|robustAccess
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mDevice
condition|)
block|{
if|if
condition|(
operator|!
name|createDevice
argument_list|()
condition|)
block|{
return|return
name|NULL
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|testDeviceLost
argument_list|()
condition|)
comment|// Lost device
block|{
if|if
condition|(
operator|!
name|restoreLostDevice
argument_list|()
condition|)
return|return
name|NULL
return|;
block|}
specifier|const
name|egl
operator|::
name|Config
modifier|*
name|config
init|=
name|mConfigSet
operator|.
name|get
argument_list|(
name|configHandle
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|glCreateContext
argument_list|(
name|config
argument_list|,
name|shareContext
argument_list|,
name|notifyResets
argument_list|,
name|robustAccess
argument_list|)
decl_stmt|;
name|mContextSet
operator|.
name|insert
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|mDeviceLost
operator|=
literal|false
expr_stmt|;
return|return
name|context
return|;
block|}
DECL|function|restoreLostDevice
name|bool
name|Display
operator|::
name|restoreLostDevice
parameter_list|()
block|{
for|for
control|(
name|ContextSet
operator|::
name|iterator
name|ctx
init|=
name|mContextSet
operator|.
name|begin
argument_list|()
init|;
name|ctx
operator|!=
name|mContextSet
operator|.
name|end
argument_list|()
condition|;
name|ctx
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|ctx
operator|)
operator|->
name|isResetNotificationEnabled
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// If reset notifications have been requested, application must delete all contexts first
block|}
comment|// Release surface resources to make the Reset() succeed
for|for
control|(
name|SurfaceSet
operator|::
name|iterator
name|surface
init|=
name|mSurfaceSet
operator|.
name|begin
argument_list|()
init|;
name|surface
operator|!=
name|mSurfaceSet
operator|.
name|end
argument_list|()
condition|;
name|surface
operator|++
control|)
block|{
operator|(
operator|*
name|surface
operator|)
operator|->
name|release
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|mEventQueryPool
operator|.
name|empty
argument_list|()
condition|)
block|{
name|mEventQueryPool
operator|.
name|back
argument_list|()
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mEventQueryPool
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
name|mVertexShaderCache
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mPixelShaderCache
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|resetDevice
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Restore any surfaces that may have been lost
for|for
control|(
name|SurfaceSet
operator|::
name|iterator
name|surface
init|=
name|mSurfaceSet
operator|.
name|begin
argument_list|()
init|;
name|surface
operator|!=
name|mSurfaceSet
operator|.
name|end
argument_list|()
condition|;
name|surface
operator|++
control|)
block|{
operator|(
operator|*
name|surface
operator|)
operator|->
name|resetSwapChain
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|destroySurface
name|void
name|Display
operator|::
name|destroySurface
parameter_list|(
name|egl
operator|::
name|Surface
modifier|*
name|surface
parameter_list|)
block|{
operator|delete
name|surface
expr_stmt|;
name|mSurfaceSet
operator|.
name|erase
argument_list|(
name|surface
argument_list|)
expr_stmt|;
block|}
DECL|function|destroyContext
name|void
name|Display
operator|::
name|destroyContext
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|)
block|{
name|glDestroyContext
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|mContextSet
operator|.
name|erase
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
DECL|function|notifyDeviceLost
name|void
name|Display
operator|::
name|notifyDeviceLost
parameter_list|()
block|{
for|for
control|(
name|ContextSet
operator|::
name|iterator
name|context
init|=
name|mContextSet
operator|.
name|begin
argument_list|()
init|;
name|context
operator|!=
name|mContextSet
operator|.
name|end
argument_list|()
condition|;
name|context
operator|++
control|)
block|{
operator|(
operator|*
name|context
operator|)
operator|->
name|markContextLost
argument_list|()
expr_stmt|;
block|}
name|mDeviceLost
operator|=
literal|true
expr_stmt|;
name|error
argument_list|(
name|EGL_CONTEXT_LOST
argument_list|)
expr_stmt|;
block|}
DECL|function|isDeviceLost
name|bool
name|Display
operator|::
name|isDeviceLost
parameter_list|()
block|{
return|return
name|mDeviceLost
return|;
block|}
DECL|function|isInitialized
name|bool
name|Display
operator|::
name|isInitialized
parameter_list|()
specifier|const
block|{
return|return
name|mD3d9
operator|!=
name|NULL
operator|&&
name|mConfigSet
operator|.
name|size
argument_list|()
operator|>
literal|0
return|;
block|}
DECL|function|isValidConfig
name|bool
name|Display
operator|::
name|isValidConfig
parameter_list|(
name|EGLConfig
name|config
parameter_list|)
block|{
return|return
name|mConfigSet
operator|.
name|get
argument_list|(
name|config
argument_list|)
operator|!=
name|NULL
return|;
block|}
DECL|function|isValidContext
name|bool
name|Display
operator|::
name|isValidContext
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|)
block|{
return|return
name|mContextSet
operator|.
name|find
argument_list|(
name|context
argument_list|)
operator|!=
name|mContextSet
operator|.
name|end
argument_list|()
return|;
block|}
DECL|function|isValidSurface
name|bool
name|Display
operator|::
name|isValidSurface
parameter_list|(
name|egl
operator|::
name|Surface
modifier|*
name|surface
parameter_list|)
block|{
return|return
name|mSurfaceSet
operator|.
name|find
argument_list|(
name|surface
argument_list|)
operator|!=
name|mSurfaceSet
operator|.
name|end
argument_list|()
return|;
block|}
DECL|function|hasExistingWindowSurface
name|bool
name|Display
operator|::
name|hasExistingWindowSurface
parameter_list|(
name|HWND
name|window
parameter_list|)
block|{
for|for
control|(
name|SurfaceSet
operator|::
name|iterator
name|surface
init|=
name|mSurfaceSet
operator|.
name|begin
argument_list|()
init|;
name|surface
operator|!=
name|mSurfaceSet
operator|.
name|end
argument_list|()
condition|;
name|surface
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|surface
operator|)
operator|->
name|getWindowHandle
argument_list|()
operator|==
name|window
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|function|getMinSwapInterval
name|EGLint
name|Display
operator|::
name|getMinSwapInterval
parameter_list|()
block|{
return|return
name|mMinSwapInterval
return|;
block|}
DECL|function|getMaxSwapInterval
name|EGLint
name|Display
operator|::
name|getMaxSwapInterval
parameter_list|()
block|{
return|return
name|mMaxSwapInterval
return|;
block|}
DECL|function|getDevice
name|IDirect3DDevice9
modifier|*
name|Display
operator|::
name|getDevice
parameter_list|()
block|{
if|if
condition|(
operator|!
name|mDevice
condition|)
block|{
if|if
condition|(
operator|!
name|createDevice
argument_list|()
condition|)
block|{
return|return
name|NULL
return|;
block|}
block|}
return|return
name|mDevice
return|;
block|}
DECL|function|getDeviceCaps
name|D3DCAPS9
name|Display
operator|::
name|getDeviceCaps
parameter_list|()
block|{
return|return
name|mDeviceCaps
return|;
block|}
DECL|function|getAdapterIdentifier
name|D3DADAPTER_IDENTIFIER9
modifier|*
name|Display
operator|::
name|getAdapterIdentifier
parameter_list|()
block|{
return|return
operator|&
name|mAdapterIdentifier
return|;
block|}
DECL|function|testDeviceLost
name|bool
name|Display
operator|::
name|testDeviceLost
parameter_list|()
block|{
if|if
condition|(
name|mDeviceEx
condition|)
block|{
return|return
name|FAILED
argument_list|(
name|mDeviceEx
operator|->
name|CheckDeviceState
argument_list|(
name|NULL
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|mDevice
condition|)
block|{
return|return
name|FAILED
argument_list|(
name|mDevice
operator|->
name|TestCooperativeLevel
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|false
return|;
comment|// No device yet, so no reset required
block|}
DECL|function|testDeviceResettable
name|bool
name|Display
operator|::
name|testDeviceResettable
parameter_list|()
block|{
name|HRESULT
name|status
init|=
name|D3D_OK
decl_stmt|;
if|if
condition|(
name|mDeviceEx
condition|)
block|{
name|status
operator|=
name|mDeviceEx
operator|->
name|CheckDeviceState
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mDevice
condition|)
block|{
name|status
operator|=
name|mDevice
operator|->
name|TestCooperativeLevel
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|D3DERR_DEVICENOTRESET
case|:
case|case
name|D3DERR_DEVICEHUNG
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
DECL|function|sync
name|void
name|Display
operator|::
name|sync
parameter_list|(
name|bool
name|block
parameter_list|)
block|{
name|HRESULT
name|result
decl_stmt|;
name|IDirect3DQuery9
modifier|*
name|query
init|=
name|allocateEventQuery
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|query
condition|)
block|{
return|return;
block|}
name|result
operator|=
name|query
operator|->
name|Issue
argument_list|(
name|D3DISSUE_END
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|result
operator|=
name|query
operator|->
name|GetData
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|D3DGETDATA_FLUSH
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|&&
name|result
operator|==
name|S_FALSE
condition|)
block|{
comment|// Keep polling, but allow other threads to do something useful first
name|Sleep
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// explicitly check for device loss
comment|// some drivers seem to return S_FALSE even if the device is lost
comment|// instead of D3DERR_DEVICELOST like they should
if|if
condition|(
name|testDeviceLost
argument_list|()
condition|)
block|{
name|result
operator|=
name|D3DERR_DEVICELOST
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|block
operator|&&
name|result
operator|==
name|S_FALSE
condition|)
do|;
name|freeEventQuery
argument_list|(
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDeviceLostError
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|notifyDeviceLost
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|allocateEventQuery
name|IDirect3DQuery9
modifier|*
name|Display
operator|::
name|allocateEventQuery
parameter_list|()
block|{
name|IDirect3DQuery9
modifier|*
name|query
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|mEventQueryPool
operator|.
name|empty
argument_list|()
condition|)
block|{
name|HRESULT
name|result
init|=
name|mDevice
operator|->
name|CreateQuery
argument_list|(
name|D3DQUERYTYPE_EVENT
argument_list|,
operator|&
name|query
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|query
operator|=
name|mEventQueryPool
operator|.
name|back
argument_list|()
expr_stmt|;
name|mEventQueryPool
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
return|return
name|query
return|;
block|}
DECL|function|freeEventQuery
name|void
name|Display
operator|::
name|freeEventQuery
parameter_list|(
name|IDirect3DQuery9
modifier|*
name|query
parameter_list|)
block|{
if|if
condition|(
name|mEventQueryPool
operator|.
name|size
argument_list|()
operator|>
literal|1000
condition|)
block|{
name|query
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|mEventQueryPool
operator|.
name|push_back
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|getMultiSampleSupport
name|void
name|Display
operator|::
name|getMultiSampleSupport
parameter_list|(
name|D3DFORMAT
name|format
parameter_list|,
name|bool
modifier|*
name|multiSampleArray
parameter_list|)
block|{
for|for
control|(
name|int
name|multiSampleIndex
init|=
literal|0
init|;
name|multiSampleIndex
operator|<=
name|D3DMULTISAMPLE_16_SAMPLES
condition|;
name|multiSampleIndex
operator|++
control|)
block|{
name|HRESULT
name|result
init|=
name|mD3d9
operator|->
name|CheckDeviceMultiSampleType
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|format
argument_list|,
name|TRUE
argument_list|,
operator|(
name|D3DMULTISAMPLE_TYPE
operator|)
name|multiSampleIndex
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|multiSampleArray
index|[
name|multiSampleIndex
index|]
operator|=
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|getDXT1TextureSupport
name|bool
name|Display
operator|::
name|getDXT1TextureSupport
parameter_list|()
block|{
name|D3DDISPLAYMODE
name|currentDisplayMode
decl_stmt|;
name|mD3d9
operator|->
name|GetAdapterDisplayMode
argument_list|(
name|mAdapter
argument_list|,
operator|&
name|currentDisplayMode
argument_list|)
expr_stmt|;
return|return
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
literal|0
argument_list|,
name|D3DRTYPE_TEXTURE
argument_list|,
name|D3DFMT_DXT1
argument_list|)
argument_list|)
return|;
block|}
DECL|function|getDXT3TextureSupport
name|bool
name|Display
operator|::
name|getDXT3TextureSupport
parameter_list|()
block|{
name|D3DDISPLAYMODE
name|currentDisplayMode
decl_stmt|;
name|mD3d9
operator|->
name|GetAdapterDisplayMode
argument_list|(
name|mAdapter
argument_list|,
operator|&
name|currentDisplayMode
argument_list|)
expr_stmt|;
return|return
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
literal|0
argument_list|,
name|D3DRTYPE_TEXTURE
argument_list|,
name|D3DFMT_DXT3
argument_list|)
argument_list|)
return|;
block|}
DECL|function|getDXT5TextureSupport
name|bool
name|Display
operator|::
name|getDXT5TextureSupport
parameter_list|()
block|{
name|D3DDISPLAYMODE
name|currentDisplayMode
decl_stmt|;
name|mD3d9
operator|->
name|GetAdapterDisplayMode
argument_list|(
name|mAdapter
argument_list|,
operator|&
name|currentDisplayMode
argument_list|)
expr_stmt|;
return|return
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
literal|0
argument_list|,
name|D3DRTYPE_TEXTURE
argument_list|,
name|D3DFMT_DXT5
argument_list|)
argument_list|)
return|;
block|}
comment|// we use INTZ for depth textures in Direct3D9
comment|// we also want NULL texture support to ensure the we can make depth-only FBOs
comment|// see http://aras-p.info/texts/D3D9GPUHacks.html
DECL|function|getDepthTextureSupport
name|bool
name|Display
operator|::
name|getDepthTextureSupport
parameter_list|()
specifier|const
block|{
name|D3DDISPLAYMODE
name|currentDisplayMode
decl_stmt|;
name|mD3d9
operator|->
name|GetAdapterDisplayMode
argument_list|(
name|mAdapter
argument_list|,
operator|&
name|currentDisplayMode
argument_list|)
expr_stmt|;
name|bool
name|intz
init|=
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
name|D3DUSAGE_DEPTHSTENCIL
argument_list|,
name|D3DRTYPE_TEXTURE
argument_list|,
name|D3DFMT_INTZ
argument_list|)
argument_list|)
decl_stmt|;
name|bool
name|null
init|=
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
name|D3DUSAGE_RENDERTARGET
argument_list|,
name|D3DRTYPE_SURFACE
argument_list|,
name|D3DFMT_NULL
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|intz
operator|&&
name|null
return|;
block|}
DECL|function|getFloat32TextureSupport
name|bool
name|Display
operator|::
name|getFloat32TextureSupport
parameter_list|(
name|bool
modifier|*
name|filtering
parameter_list|,
name|bool
modifier|*
name|renderable
parameter_list|)
block|{
name|D3DDISPLAYMODE
name|currentDisplayMode
decl_stmt|;
name|mD3d9
operator|->
name|GetAdapterDisplayMode
argument_list|(
name|mAdapter
argument_list|,
operator|&
name|currentDisplayMode
argument_list|)
expr_stmt|;
operator|*
name|filtering
operator|=
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
name|D3DUSAGE_QUERY_FILTER
argument_list|,
name|D3DRTYPE_TEXTURE
argument_list|,
name|D3DFMT_A32B32G32R32F
argument_list|)
argument_list|)
operator|&&
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
name|D3DUSAGE_QUERY_FILTER
argument_list|,
name|D3DRTYPE_CUBETEXTURE
argument_list|,
name|D3DFMT_A32B32G32R32F
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|renderable
operator|=
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
name|D3DUSAGE_RENDERTARGET
argument_list|,
name|D3DRTYPE_TEXTURE
argument_list|,
name|D3DFMT_A32B32G32R32F
argument_list|)
argument_list|)
operator|&&
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
name|D3DUSAGE_RENDERTARGET
argument_list|,
name|D3DRTYPE_CUBETEXTURE
argument_list|,
name|D3DFMT_A32B32G32R32F
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|filtering
operator|&&
operator|!
operator|*
name|renderable
condition|)
block|{
return|return
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
literal|0
argument_list|,
name|D3DRTYPE_TEXTURE
argument_list|,
name|D3DFMT_A32B32G32R32F
argument_list|)
argument_list|)
operator|&&
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
literal|0
argument_list|,
name|D3DRTYPE_CUBETEXTURE
argument_list|,
name|D3DFMT_A32B32G32R32F
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|true
return|;
block|}
block|}
DECL|function|getFloat16TextureSupport
name|bool
name|Display
operator|::
name|getFloat16TextureSupport
parameter_list|(
name|bool
modifier|*
name|filtering
parameter_list|,
name|bool
modifier|*
name|renderable
parameter_list|)
block|{
name|D3DDISPLAYMODE
name|currentDisplayMode
decl_stmt|;
name|mD3d9
operator|->
name|GetAdapterDisplayMode
argument_list|(
name|mAdapter
argument_list|,
operator|&
name|currentDisplayMode
argument_list|)
expr_stmt|;
operator|*
name|filtering
operator|=
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
name|D3DUSAGE_QUERY_FILTER
argument_list|,
name|D3DRTYPE_TEXTURE
argument_list|,
name|D3DFMT_A16B16G16R16F
argument_list|)
argument_list|)
operator|&&
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
name|D3DUSAGE_QUERY_FILTER
argument_list|,
name|D3DRTYPE_CUBETEXTURE
argument_list|,
name|D3DFMT_A16B16G16R16F
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|renderable
operator|=
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
name|D3DUSAGE_RENDERTARGET
argument_list|,
name|D3DRTYPE_TEXTURE
argument_list|,
name|D3DFMT_A16B16G16R16F
argument_list|)
argument_list|)
operator|&&
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
name|D3DUSAGE_RENDERTARGET
argument_list|,
name|D3DRTYPE_CUBETEXTURE
argument_list|,
name|D3DFMT_A16B16G16R16F
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|filtering
operator|&&
operator|!
operator|*
name|renderable
condition|)
block|{
return|return
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
literal|0
argument_list|,
name|D3DRTYPE_TEXTURE
argument_list|,
name|D3DFMT_A16B16G16R16F
argument_list|)
argument_list|)
operator|&&
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
literal|0
argument_list|,
name|D3DRTYPE_CUBETEXTURE
argument_list|,
name|D3DFMT_A16B16G16R16F
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|true
return|;
block|}
block|}
DECL|function|getLuminanceTextureSupport
name|bool
name|Display
operator|::
name|getLuminanceTextureSupport
parameter_list|()
block|{
name|D3DDISPLAYMODE
name|currentDisplayMode
decl_stmt|;
name|mD3d9
operator|->
name|GetAdapterDisplayMode
argument_list|(
name|mAdapter
argument_list|,
operator|&
name|currentDisplayMode
argument_list|)
expr_stmt|;
return|return
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
literal|0
argument_list|,
name|D3DRTYPE_TEXTURE
argument_list|,
name|D3DFMT_L8
argument_list|)
argument_list|)
return|;
block|}
DECL|function|getLuminanceAlphaTextureSupport
name|bool
name|Display
operator|::
name|getLuminanceAlphaTextureSupport
parameter_list|()
block|{
name|D3DDISPLAYMODE
name|currentDisplayMode
decl_stmt|;
name|mD3d9
operator|->
name|GetAdapterDisplayMode
argument_list|(
name|mAdapter
argument_list|,
operator|&
name|currentDisplayMode
argument_list|)
expr_stmt|;
return|return
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
literal|0
argument_list|,
name|D3DRTYPE_TEXTURE
argument_list|,
name|D3DFMT_A8L8
argument_list|)
argument_list|)
return|;
block|}
DECL|function|getTextureFilterAnisotropySupport
name|float
name|Display
operator|::
name|getTextureFilterAnisotropySupport
parameter_list|()
specifier|const
block|{
comment|// Must support a minimum of 2:1 anisotropy for max anisotropy to be considered supported, per the spec
if|if
condition|(
operator|(
name|mDeviceCaps
operator|.
name|RasterCaps
operator|&
name|D3DPRASTERCAPS_ANISOTROPY
operator|)
operator|&&
operator|(
name|mDeviceCaps
operator|.
name|MaxAnisotropy
operator|>=
literal|2
operator|)
condition|)
block|{
return|return
name|mDeviceCaps
operator|.
name|MaxAnisotropy
return|;
block|}
return|return
literal|1.0f
return|;
block|}
DECL|function|getBufferPool
name|D3DPOOL
name|Display
operator|::
name|getBufferPool
parameter_list|(
name|DWORD
name|usage
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|mD3d9Ex
operator|!=
name|NULL
condition|)
block|{
return|return
name|D3DPOOL_DEFAULT
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|usage
operator|&
name|D3DUSAGE_DYNAMIC
operator|)
condition|)
block|{
return|return
name|D3DPOOL_MANAGED
return|;
block|}
block|}
return|return
name|D3DPOOL_DEFAULT
return|;
block|}
DECL|function|getTexturePool
name|D3DPOOL
name|Display
operator|::
name|getTexturePool
parameter_list|(
name|DWORD
name|usage
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|mD3d9Ex
operator|!=
name|NULL
condition|)
block|{
return|return
name|D3DPOOL_DEFAULT
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|usage
operator|&
operator|(
name|D3DUSAGE_DEPTHSTENCIL
operator||
name|D3DUSAGE_RENDERTARGET
operator|)
operator|)
condition|)
block|{
return|return
name|D3DPOOL_MANAGED
return|;
block|}
block|}
return|return
name|D3DPOOL_DEFAULT
return|;
block|}
DECL|function|getEventQuerySupport
name|bool
name|Display
operator|::
name|getEventQuerySupport
parameter_list|()
block|{
name|IDirect3DQuery9
modifier|*
name|query
init|=
name|allocateEventQuery
argument_list|()
decl_stmt|;
if|if
condition|(
name|query
condition|)
block|{
name|freeEventQuery
argument_list|(
name|query
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
DECL|function|getDefaultPresentParameters
name|D3DPRESENT_PARAMETERS
name|Display
operator|::
name|getDefaultPresentParameters
parameter_list|()
block|{
name|D3DPRESENT_PARAMETERS
name|presentParameters
init|=
block|{
literal|0
block|}
decl_stmt|;
comment|// The default swap chain is never actually used. Surface will create a new swap chain with the proper parameters.
name|presentParameters
operator|.
name|AutoDepthStencilFormat
operator|=
name|D3DFMT_UNKNOWN
expr_stmt|;
name|presentParameters
operator|.
name|BackBufferCount
operator|=
literal|1
expr_stmt|;
name|presentParameters
operator|.
name|BackBufferFormat
operator|=
name|D3DFMT_UNKNOWN
expr_stmt|;
name|presentParameters
operator|.
name|BackBufferWidth
operator|=
literal|1
expr_stmt|;
name|presentParameters
operator|.
name|BackBufferHeight
operator|=
literal|1
expr_stmt|;
name|presentParameters
operator|.
name|EnableAutoDepthStencil
operator|=
name|FALSE
expr_stmt|;
name|presentParameters
operator|.
name|Flags
operator|=
literal|0
expr_stmt|;
name|presentParameters
operator|.
name|hDeviceWindow
operator|=
name|mDeviceWindow
expr_stmt|;
name|presentParameters
operator|.
name|MultiSampleQuality
operator|=
literal|0
expr_stmt|;
name|presentParameters
operator|.
name|MultiSampleType
operator|=
name|D3DMULTISAMPLE_NONE
expr_stmt|;
name|presentParameters
operator|.
name|PresentationInterval
operator|=
name|D3DPRESENT_INTERVAL_DEFAULT
expr_stmt|;
name|presentParameters
operator|.
name|SwapEffect
operator|=
name|D3DSWAPEFFECT_DISCARD
expr_stmt|;
name|presentParameters
operator|.
name|Windowed
operator|=
name|TRUE
expr_stmt|;
return|return
name|presentParameters
return|;
block|}
DECL|function|initExtensionString
name|void
name|Display
operator|::
name|initExtensionString
parameter_list|()
block|{
name|HMODULE
name|swiftShader
init|=
name|GetModuleHandle
argument_list|(
name|TEXT
argument_list|(
literal|"swiftshader_d3d9.dll"
argument_list|)
argument_list|)
decl_stmt|;
name|mExtensionString
operator|=
literal|""
expr_stmt|;
comment|// Multi-vendor (EXT) extensions
name|mExtensionString
operator|+=
literal|"EGL_EXT_create_context_robustness "
expr_stmt|;
comment|// ANGLE-specific extensions
if|if
condition|(
name|shareHandleSupported
argument_list|()
condition|)
block|{
name|mExtensionString
operator|+=
literal|"EGL_ANGLE_d3d_share_handle_client_buffer "
expr_stmt|;
block|}
name|mExtensionString
operator|+=
literal|"EGL_ANGLE_query_surface_pointer "
expr_stmt|;
if|if
condition|(
name|swiftShader
condition|)
block|{
name|mExtensionString
operator|+=
literal|"EGL_ANGLE_software_display "
expr_stmt|;
block|}
if|if
condition|(
name|shareHandleSupported
argument_list|()
condition|)
block|{
name|mExtensionString
operator|+=
literal|"EGL_ANGLE_surface_d3d_texture_2d_share_handle "
expr_stmt|;
block|}
name|mExtensionString
operator|+=
literal|"EGL_NV_post_sub_buffer"
expr_stmt|;
name|std
operator|::
name|string
operator|::
name|size_type
name|end
init|=
name|mExtensionString
operator|.
name|find_last_not_of
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|!=
name|std
operator|::
name|string
operator|::
name|npos
condition|)
block|{
name|mExtensionString
operator|.
name|resize
argument_list|(
name|end
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|getExtensionString
specifier|const
name|char
modifier|*
name|Display
operator|::
name|getExtensionString
parameter_list|()
specifier|const
block|{
return|return
name|mExtensionString
operator|.
name|c_str
argument_list|()
return|;
block|}
DECL|function|shareHandleSupported
name|bool
name|Display
operator|::
name|shareHandleSupported
parameter_list|()
specifier|const
block|{
comment|// PIX doesn't seem to support using share handles, so disable them.
return|return
name|isD3d9ExDevice
argument_list|()
operator|&&
operator|!
name|gl
operator|::
name|perfActive
argument_list|()
return|;
block|}
DECL|function|createVertexShader
name|IDirect3DVertexShader9
modifier|*
name|Display
operator|::
name|createVertexShader
parameter_list|(
specifier|const
name|DWORD
modifier|*
name|function
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
return|return
name|mVertexShaderCache
operator|.
name|create
argument_list|(
name|function
argument_list|,
name|length
argument_list|)
return|;
block|}
DECL|function|createPixelShader
name|IDirect3DPixelShader9
modifier|*
name|Display
operator|::
name|createPixelShader
parameter_list|(
specifier|const
name|DWORD
modifier|*
name|function
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
return|return
name|mPixelShaderCache
operator|.
name|create
argument_list|(
name|function
argument_list|,
name|length
argument_list|)
return|;
block|}
comment|// Only Direct3D 10 ready devices support all the necessary vertex texture formats.
comment|// We test this using D3D9 by checking support for the R16F format.
DECL|function|getVertexTextureSupport
name|bool
name|Display
operator|::
name|getVertexTextureSupport
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|isInitialized
argument_list|()
operator|||
name|mDeviceCaps
operator|.
name|PixelShaderVersion
operator|<
name|D3DPS_VERSION
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|D3DDISPLAYMODE
name|currentDisplayMode
decl_stmt|;
name|mD3d9
operator|->
name|GetAdapterDisplayMode
argument_list|(
name|mAdapter
argument_list|,
operator|&
name|currentDisplayMode
argument_list|)
expr_stmt|;
name|HRESULT
name|result
init|=
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
name|D3DUSAGE_QUERY_VERTEXTEXTURE
argument_list|,
name|D3DRTYPE_TEXTURE
argument_list|,
name|D3DFMT_R16F
argument_list|)
decl_stmt|;
return|return
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
return|;
block|}
DECL|function|getNonPower2TextureSupport
name|bool
name|Display
operator|::
name|getNonPower2TextureSupport
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsNonPower2Textures
return|;
block|}
DECL|function|getOcclusionQuerySupport
name|bool
name|Display
operator|::
name|getOcclusionQuerySupport
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|isInitialized
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|IDirect3DQuery9
modifier|*
name|query
init|=
name|NULL
decl_stmt|;
name|HRESULT
name|result
init|=
name|mDevice
operator|->
name|CreateQuery
argument_list|(
name|D3DQUERYTYPE_OCCLUSION
argument_list|,
operator|&
name|query
argument_list|)
decl_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
operator|&&
name|query
condition|)
block|{
name|query
operator|->
name|Release
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
DECL|function|getInstancingSupport
name|bool
name|Display
operator|::
name|getInstancingSupport
parameter_list|()
specifier|const
block|{
return|return
name|mDeviceCaps
operator|.
name|PixelShaderVersion
operator|>=
name|D3DPS_VERSION
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
end_namespace
end_unit
