begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2013 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Display.cpp: Implements the egl::Display class, representing the abstract
end_comment
begin_comment
comment|// display on which graphics are drawn. Implements EGLDisplay.
end_comment
begin_comment
comment|// [EGL 1.4] section 2.1.2 page 3.
end_comment
begin_include
include|#
directive|include
file|"libEGL/Display.h"
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_include
include|#
directive|include
file|<map>
end_include
begin_include
include|#
directive|include
file|<vector>
end_include
begin_include
include|#
directive|include
file|"common/debug.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/mathutil.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/main.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Context.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/SwapChain.h"
end_include
begin_include
include|#
directive|include
file|"libEGL/main.h"
end_include
begin_include
include|#
directive|include
file|"libEGL/Surface.h"
end_include
begin_namespace
DECL|namespace|egl
namespace|namespace
name|egl
block|{
namespace|namespace
block|{
DECL|typedef|DisplayMap
typedef|typedef
name|std
operator|::
name|map
argument_list|<
name|EGLNativeDisplayType
argument_list|,
name|Display
modifier|*
argument_list|>
name|DisplayMap
typedef|;
DECL|member|displays
name|DisplayMap
name|displays
decl_stmt|;
block|}
DECL|function|getDisplay
name|egl
operator|::
name|Display
modifier|*
name|Display
operator|::
name|getDisplay
parameter_list|(
name|EGLNativeDisplayType
name|displayId
parameter_list|)
block|{
if|if
condition|(
name|displays
operator|.
name|find
argument_list|(
name|displayId
argument_list|)
operator|!=
name|displays
operator|.
name|end
argument_list|()
condition|)
block|{
return|return
name|displays
index|[
name|displayId
index|]
return|;
block|}
comment|// FIXME: Check if displayId is a valid display device context
name|egl
operator|::
name|Display
modifier|*
name|display
init|=
operator|new
name|egl
operator|::
name|Display
argument_list|(
name|displayId
argument_list|,
operator|(
name|HDC
operator|)
name|displayId
argument_list|)
decl_stmt|;
name|displays
index|[
name|displayId
index|]
operator|=
name|display
expr_stmt|;
return|return
name|display
return|;
block|}
DECL|function|Display
name|Display
operator|::
name|Display
parameter_list|(
name|EGLNativeDisplayType
name|displayId
parameter_list|,
name|HDC
name|deviceContext
parameter_list|)
member_init_list|:
name|mDc
argument_list|(
name|deviceContext
argument_list|)
block|{
name|mDisplayId
operator|=
name|displayId
expr_stmt|;
name|mRenderer
operator|=
name|NULL
expr_stmt|;
block|}
DECL|function|~Display
name|Display
operator|::
name|~
name|Display
parameter_list|()
block|{
name|terminate
argument_list|()
expr_stmt|;
name|DisplayMap
operator|::
name|iterator
name|thisDisplay
init|=
name|displays
operator|.
name|find
argument_list|(
name|mDisplayId
argument_list|)
decl_stmt|;
if|if
condition|(
name|thisDisplay
operator|!=
name|displays
operator|.
name|end
argument_list|()
condition|)
block|{
name|displays
operator|.
name|erase
argument_list|(
name|thisDisplay
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|initialize
name|bool
name|Display
operator|::
name|initialize
parameter_list|()
block|{
if|if
condition|(
name|isInitialized
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
name|mRenderer
operator|=
name|glCreateRenderer
argument_list|(
name|this
argument_list|,
name|mDc
argument_list|,
name|mDisplayId
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mRenderer
condition|)
block|{
name|terminate
argument_list|()
expr_stmt|;
return|return
name|error
argument_list|(
name|EGL_NOT_INITIALIZED
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|EGLint
name|minSwapInterval
init|=
name|mRenderer
operator|->
name|getMinSwapInterval
argument_list|()
decl_stmt|;
name|EGLint
name|maxSwapInterval
init|=
name|mRenderer
operator|->
name|getMaxSwapInterval
argument_list|()
decl_stmt|;
name|EGLint
name|maxTextureWidth
init|=
name|mRenderer
operator|->
name|getMaxTextureWidth
argument_list|()
decl_stmt|;
name|EGLint
name|maxTextureHeight
init|=
name|mRenderer
operator|->
name|getMaxTextureHeight
argument_list|()
decl_stmt|;
name|rx
operator|::
name|ConfigDesc
modifier|*
name|descList
decl_stmt|;
name|int
name|numConfigs
init|=
name|mRenderer
operator|->
name|generateConfigs
argument_list|(
operator|&
name|descList
argument_list|)
decl_stmt|;
name|ConfigSet
name|configSet
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numConfigs
condition|;
operator|++
name|i
control|)
name|configSet
operator|.
name|add
argument_list|(
name|descList
index|[
name|i
index|]
argument_list|,
name|minSwapInterval
argument_list|,
name|maxSwapInterval
argument_list|,
name|maxTextureWidth
argument_list|,
name|maxTextureHeight
argument_list|)
expr_stmt|;
comment|// Give the sorted configs a unique ID and store them internally
name|EGLint
name|index
init|=
literal|1
decl_stmt|;
for|for
control|(
name|ConfigSet
operator|::
name|Iterator
name|config
init|=
name|configSet
operator|.
name|mSet
operator|.
name|begin
argument_list|()
init|;
name|config
operator|!=
name|configSet
operator|.
name|mSet
operator|.
name|end
argument_list|()
condition|;
name|config
operator|++
control|)
block|{
name|Config
name|configuration
init|=
operator|*
name|config
decl_stmt|;
name|configuration
operator|.
name|mConfigID
operator|=
name|index
expr_stmt|;
name|index
operator|++
expr_stmt|;
name|mConfigSet
operator|.
name|mSet
operator|.
name|insert
argument_list|(
name|configuration
argument_list|)
expr_stmt|;
block|}
name|mRenderer
operator|->
name|deleteConfigs
argument_list|(
name|descList
argument_list|)
expr_stmt|;
name|descList
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|isInitialized
argument_list|()
condition|)
block|{
name|terminate
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
name|initExtensionString
argument_list|()
expr_stmt|;
name|initVendorString
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|terminate
name|void
name|Display
operator|::
name|terminate
parameter_list|()
block|{
while|while
condition|(
operator|!
name|mSurfaceSet
operator|.
name|empty
argument_list|()
condition|)
block|{
name|destroySurface
argument_list|(
operator|*
name|mSurfaceSet
operator|.
name|begin
argument_list|()
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|mContextSet
operator|.
name|empty
argument_list|()
condition|)
block|{
name|destroyContext
argument_list|(
operator|*
name|mContextSet
operator|.
name|begin
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|glDestroyRenderer
argument_list|(
name|mRenderer
argument_list|)
expr_stmt|;
name|mRenderer
operator|=
name|NULL
expr_stmt|;
block|}
DECL|function|getConfigs
name|bool
name|Display
operator|::
name|getConfigs
parameter_list|(
name|EGLConfig
modifier|*
name|configs
parameter_list|,
specifier|const
name|EGLint
modifier|*
name|attribList
parameter_list|,
name|EGLint
name|configSize
parameter_list|,
name|EGLint
modifier|*
name|numConfig
parameter_list|)
block|{
return|return
name|mConfigSet
operator|.
name|getConfigs
argument_list|(
name|configs
argument_list|,
name|attribList
argument_list|,
name|configSize
argument_list|,
name|numConfig
argument_list|)
return|;
block|}
DECL|function|getConfigAttrib
name|bool
name|Display
operator|::
name|getConfigAttrib
parameter_list|(
name|EGLConfig
name|config
parameter_list|,
name|EGLint
name|attribute
parameter_list|,
name|EGLint
modifier|*
name|value
parameter_list|)
block|{
specifier|const
name|egl
operator|::
name|Config
modifier|*
name|configuration
init|=
name|mConfigSet
operator|.
name|get
argument_list|(
name|config
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|attribute
condition|)
block|{
case|case
name|EGL_BUFFER_SIZE
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mBufferSize
expr_stmt|;
break|break;
case|case
name|EGL_ALPHA_SIZE
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mAlphaSize
expr_stmt|;
break|break;
case|case
name|EGL_BLUE_SIZE
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mBlueSize
expr_stmt|;
break|break;
case|case
name|EGL_GREEN_SIZE
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mGreenSize
expr_stmt|;
break|break;
case|case
name|EGL_RED_SIZE
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mRedSize
expr_stmt|;
break|break;
case|case
name|EGL_DEPTH_SIZE
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mDepthSize
expr_stmt|;
break|break;
case|case
name|EGL_STENCIL_SIZE
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mStencilSize
expr_stmt|;
break|break;
case|case
name|EGL_CONFIG_CAVEAT
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mConfigCaveat
expr_stmt|;
break|break;
case|case
name|EGL_CONFIG_ID
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mConfigID
expr_stmt|;
break|break;
case|case
name|EGL_LEVEL
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mLevel
expr_stmt|;
break|break;
case|case
name|EGL_NATIVE_RENDERABLE
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mNativeRenderable
expr_stmt|;
break|break;
case|case
name|EGL_NATIVE_VISUAL_TYPE
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mNativeVisualType
expr_stmt|;
break|break;
case|case
name|EGL_SAMPLES
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mSamples
expr_stmt|;
break|break;
case|case
name|EGL_SAMPLE_BUFFERS
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mSampleBuffers
expr_stmt|;
break|break;
case|case
name|EGL_SURFACE_TYPE
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mSurfaceType
expr_stmt|;
break|break;
case|case
name|EGL_TRANSPARENT_TYPE
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mTransparentType
expr_stmt|;
break|break;
case|case
name|EGL_TRANSPARENT_BLUE_VALUE
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mTransparentBlueValue
expr_stmt|;
break|break;
case|case
name|EGL_TRANSPARENT_GREEN_VALUE
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mTransparentGreenValue
expr_stmt|;
break|break;
case|case
name|EGL_TRANSPARENT_RED_VALUE
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mTransparentRedValue
expr_stmt|;
break|break;
case|case
name|EGL_BIND_TO_TEXTURE_RGB
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mBindToTextureRGB
expr_stmt|;
break|break;
case|case
name|EGL_BIND_TO_TEXTURE_RGBA
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mBindToTextureRGBA
expr_stmt|;
break|break;
case|case
name|EGL_MIN_SWAP_INTERVAL
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mMinSwapInterval
expr_stmt|;
break|break;
case|case
name|EGL_MAX_SWAP_INTERVAL
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mMaxSwapInterval
expr_stmt|;
break|break;
case|case
name|EGL_LUMINANCE_SIZE
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mLuminanceSize
expr_stmt|;
break|break;
case|case
name|EGL_ALPHA_MASK_SIZE
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mAlphaMaskSize
expr_stmt|;
break|break;
case|case
name|EGL_COLOR_BUFFER_TYPE
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mColorBufferType
expr_stmt|;
break|break;
case|case
name|EGL_RENDERABLE_TYPE
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mRenderableType
expr_stmt|;
break|break;
case|case
name|EGL_MATCH_NATIVE_PIXMAP
case|:
operator|*
name|value
operator|=
literal|false
expr_stmt|;
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
break|break;
case|case
name|EGL_CONFORMANT
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mConformant
expr_stmt|;
break|break;
case|case
name|EGL_MAX_PBUFFER_WIDTH
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mMaxPBufferWidth
expr_stmt|;
break|break;
case|case
name|EGL_MAX_PBUFFER_HEIGHT
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mMaxPBufferHeight
expr_stmt|;
break|break;
case|case
name|EGL_MAX_PBUFFER_PIXELS
case|:
operator|*
name|value
operator|=
name|configuration
operator|->
name|mMaxPBufferPixels
expr_stmt|;
break|break;
default|default:
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|createWindowSurface
name|EGLSurface
name|Display
operator|::
name|createWindowSurface
parameter_list|(
name|HWND
name|window
parameter_list|,
name|EGLConfig
name|config
parameter_list|,
specifier|const
name|EGLint
modifier|*
name|attribList
parameter_list|)
block|{
specifier|const
name|Config
modifier|*
name|configuration
init|=
name|mConfigSet
operator|.
name|get
argument_list|(
name|config
argument_list|)
decl_stmt|;
name|EGLint
name|postSubBufferSupported
init|=
name|EGL_FALSE
decl_stmt|;
if|if
condition|(
name|attribList
condition|)
block|{
while|while
condition|(
operator|*
name|attribList
operator|!=
name|EGL_NONE
condition|)
block|{
switch|switch
condition|(
name|attribList
index|[
literal|0
index|]
condition|)
block|{
case|case
name|EGL_RENDER_BUFFER
case|:
switch|switch
condition|(
name|attribList
index|[
literal|1
index|]
condition|)
block|{
case|case
name|EGL_BACK_BUFFER
case|:
break|break;
case|case
name|EGL_SINGLE_BUFFER
case|:
return|return
name|error
argument_list|(
name|EGL_BAD_MATCH
argument_list|,
name|EGL_NO_SURFACE
argument_list|)
return|;
comment|// Rendering directly to front buffer not supported
default|default:
return|return
name|error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|,
name|EGL_NO_SURFACE
argument_list|)
return|;
block|}
break|break;
case|case
name|EGL_POST_SUB_BUFFER_SUPPORTED_NV
case|:
name|postSubBufferSupported
operator|=
name|attribList
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|EGL_VG_COLORSPACE
case|:
return|return
name|error
argument_list|(
name|EGL_BAD_MATCH
argument_list|,
name|EGL_NO_SURFACE
argument_list|)
return|;
case|case
name|EGL_VG_ALPHA_FORMAT
case|:
return|return
name|error
argument_list|(
name|EGL_BAD_MATCH
argument_list|,
name|EGL_NO_SURFACE
argument_list|)
return|;
default|default:
return|return
name|error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|,
name|EGL_NO_SURFACE
argument_list|)
return|;
block|}
name|attribList
operator|+=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hasExistingWindowSurface
argument_list|(
name|window
argument_list|)
condition|)
block|{
return|return
name|error
argument_list|(
name|EGL_BAD_ALLOC
argument_list|,
name|EGL_NO_SURFACE
argument_list|)
return|;
block|}
if|if
condition|(
name|mRenderer
operator|->
name|testDeviceLost
argument_list|(
literal|false
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|restoreLostDevice
argument_list|()
condition|)
return|return
name|EGL_NO_SURFACE
return|;
block|}
name|Surface
modifier|*
name|surface
init|=
operator|new
name|Surface
argument_list|(
name|this
argument_list|,
name|configuration
argument_list|,
name|window
argument_list|,
name|postSubBufferSupported
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|surface
operator|->
name|initialize
argument_list|()
condition|)
block|{
operator|delete
name|surface
expr_stmt|;
return|return
name|EGL_NO_SURFACE
return|;
block|}
name|mSurfaceSet
operator|.
name|insert
argument_list|(
name|surface
argument_list|)
expr_stmt|;
return|return
name|success
argument_list|(
name|surface
argument_list|)
return|;
block|}
DECL|function|createOffscreenSurface
name|EGLSurface
name|Display
operator|::
name|createOffscreenSurface
parameter_list|(
name|EGLConfig
name|config
parameter_list|,
name|HANDLE
name|shareHandle
parameter_list|,
specifier|const
name|EGLint
modifier|*
name|attribList
parameter_list|)
block|{
name|EGLint
name|width
init|=
literal|0
decl_stmt|,
name|height
init|=
literal|0
decl_stmt|;
name|EGLenum
name|textureFormat
init|=
name|EGL_NO_TEXTURE
decl_stmt|;
name|EGLenum
name|textureTarget
init|=
name|EGL_NO_TEXTURE
decl_stmt|;
specifier|const
name|Config
modifier|*
name|configuration
init|=
name|mConfigSet
operator|.
name|get
argument_list|(
name|config
argument_list|)
decl_stmt|;
if|if
condition|(
name|attribList
condition|)
block|{
while|while
condition|(
operator|*
name|attribList
operator|!=
name|EGL_NONE
condition|)
block|{
switch|switch
condition|(
name|attribList
index|[
literal|0
index|]
condition|)
block|{
case|case
name|EGL_WIDTH
case|:
name|width
operator|=
name|attribList
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|EGL_HEIGHT
case|:
name|height
operator|=
name|attribList
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|EGL_LARGEST_PBUFFER
case|:
if|if
condition|(
name|attribList
index|[
literal|1
index|]
operator|!=
name|EGL_FALSE
condition|)
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
comment|// FIXME
break|break;
case|case
name|EGL_TEXTURE_FORMAT
case|:
switch|switch
condition|(
name|attribList
index|[
literal|1
index|]
condition|)
block|{
case|case
name|EGL_NO_TEXTURE
case|:
case|case
name|EGL_TEXTURE_RGB
case|:
case|case
name|EGL_TEXTURE_RGBA
case|:
name|textureFormat
operator|=
name|attribList
index|[
literal|1
index|]
expr_stmt|;
break|break;
default|default:
return|return
name|error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|,
name|EGL_NO_SURFACE
argument_list|)
return|;
block|}
break|break;
case|case
name|EGL_TEXTURE_TARGET
case|:
switch|switch
condition|(
name|attribList
index|[
literal|1
index|]
condition|)
block|{
case|case
name|EGL_NO_TEXTURE
case|:
case|case
name|EGL_TEXTURE_2D
case|:
name|textureTarget
operator|=
name|attribList
index|[
literal|1
index|]
expr_stmt|;
break|break;
default|default:
return|return
name|error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|,
name|EGL_NO_SURFACE
argument_list|)
return|;
block|}
break|break;
case|case
name|EGL_MIPMAP_TEXTURE
case|:
if|if
condition|(
name|attribList
index|[
literal|1
index|]
operator|!=
name|EGL_FALSE
condition|)
return|return
name|error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|,
name|EGL_NO_SURFACE
argument_list|)
return|;
break|break;
case|case
name|EGL_VG_COLORSPACE
case|:
return|return
name|error
argument_list|(
name|EGL_BAD_MATCH
argument_list|,
name|EGL_NO_SURFACE
argument_list|)
return|;
case|case
name|EGL_VG_ALPHA_FORMAT
case|:
return|return
name|error
argument_list|(
name|EGL_BAD_MATCH
argument_list|,
name|EGL_NO_SURFACE
argument_list|)
return|;
default|default:
return|return
name|error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|,
name|EGL_NO_SURFACE
argument_list|)
return|;
block|}
name|attribList
operator|+=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|width
operator|<
literal|0
operator|||
name|height
operator|<
literal|0
condition|)
block|{
return|return
name|error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|,
name|EGL_NO_SURFACE
argument_list|)
return|;
block|}
if|if
condition|(
name|width
operator|==
literal|0
operator|||
name|height
operator|==
literal|0
condition|)
block|{
return|return
name|error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|,
name|EGL_NO_SURFACE
argument_list|)
return|;
block|}
if|if
condition|(
name|textureFormat
operator|!=
name|EGL_NO_TEXTURE
operator|&&
operator|!
name|mRenderer
operator|->
name|getNonPower2TextureSupport
argument_list|()
operator|&&
operator|(
operator|!
name|gl
operator|::
name|isPow2
argument_list|(
name|width
argument_list|)
operator|||
operator|!
name|gl
operator|::
name|isPow2
argument_list|(
name|height
argument_list|)
operator|)
condition|)
block|{
return|return
name|error
argument_list|(
name|EGL_BAD_MATCH
argument_list|,
name|EGL_NO_SURFACE
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|textureFormat
operator|!=
name|EGL_NO_TEXTURE
operator|&&
name|textureTarget
operator|==
name|EGL_NO_TEXTURE
operator|)
operator|||
operator|(
name|textureFormat
operator|==
name|EGL_NO_TEXTURE
operator|&&
name|textureTarget
operator|!=
name|EGL_NO_TEXTURE
operator|)
condition|)
block|{
return|return
name|error
argument_list|(
name|EGL_BAD_MATCH
argument_list|,
name|EGL_NO_SURFACE
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|configuration
operator|->
name|mSurfaceType
operator|&
name|EGL_PBUFFER_BIT
operator|)
condition|)
block|{
return|return
name|error
argument_list|(
name|EGL_BAD_MATCH
argument_list|,
name|EGL_NO_SURFACE
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|textureFormat
operator|==
name|EGL_TEXTURE_RGB
operator|&&
name|configuration
operator|->
name|mBindToTextureRGB
operator|!=
name|EGL_TRUE
operator|)
operator|||
operator|(
name|textureFormat
operator|==
name|EGL_TEXTURE_RGBA
operator|&&
name|configuration
operator|->
name|mBindToTextureRGBA
operator|!=
name|EGL_TRUE
operator|)
condition|)
block|{
return|return
name|error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|,
name|EGL_NO_SURFACE
argument_list|)
return|;
block|}
if|if
condition|(
name|mRenderer
operator|->
name|testDeviceLost
argument_list|(
literal|false
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|restoreLostDevice
argument_list|()
condition|)
return|return
name|EGL_NO_SURFACE
return|;
block|}
name|Surface
modifier|*
name|surface
init|=
operator|new
name|Surface
argument_list|(
name|this
argument_list|,
name|configuration
argument_list|,
name|shareHandle
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|textureFormat
argument_list|,
name|textureTarget
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|surface
operator|->
name|initialize
argument_list|()
condition|)
block|{
operator|delete
name|surface
expr_stmt|;
return|return
name|EGL_NO_SURFACE
return|;
block|}
name|mSurfaceSet
operator|.
name|insert
argument_list|(
name|surface
argument_list|)
expr_stmt|;
return|return
name|success
argument_list|(
name|surface
argument_list|)
return|;
block|}
DECL|function|createContext
name|EGLContext
name|Display
operator|::
name|createContext
parameter_list|(
name|EGLConfig
name|configHandle
parameter_list|,
specifier|const
name|gl
operator|::
name|Context
modifier|*
name|shareContext
parameter_list|,
name|bool
name|notifyResets
parameter_list|,
name|bool
name|robustAccess
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mRenderer
condition|)
block|{
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
name|mRenderer
operator|->
name|testDeviceLost
argument_list|(
literal|false
argument_list|)
condition|)
comment|// Lost device
block|{
if|if
condition|(
operator|!
name|restoreLostDevice
argument_list|()
condition|)
return|return
name|NULL
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|glCreateContext
argument_list|(
name|shareContext
argument_list|,
name|mRenderer
argument_list|,
name|notifyResets
argument_list|,
name|robustAccess
argument_list|)
decl_stmt|;
name|mContextSet
operator|.
name|insert
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|context
return|;
block|}
DECL|function|restoreLostDevice
name|bool
name|Display
operator|::
name|restoreLostDevice
parameter_list|()
block|{
for|for
control|(
name|ContextSet
operator|::
name|iterator
name|ctx
init|=
name|mContextSet
operator|.
name|begin
argument_list|()
init|;
name|ctx
operator|!=
name|mContextSet
operator|.
name|end
argument_list|()
condition|;
name|ctx
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|ctx
operator|)
operator|->
name|isResetNotificationEnabled
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// If reset notifications have been requested, application must delete all contexts first
block|}
comment|// Release surface resources to make the Reset() succeed
for|for
control|(
name|SurfaceSet
operator|::
name|iterator
name|surface
init|=
name|mSurfaceSet
operator|.
name|begin
argument_list|()
init|;
name|surface
operator|!=
name|mSurfaceSet
operator|.
name|end
argument_list|()
condition|;
name|surface
operator|++
control|)
block|{
operator|(
operator|*
name|surface
operator|)
operator|->
name|release
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mRenderer
operator|->
name|resetDevice
argument_list|()
condition|)
block|{
return|return
name|error
argument_list|(
name|EGL_BAD_ALLOC
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|// Restore any surfaces that may have been lost
for|for
control|(
name|SurfaceSet
operator|::
name|iterator
name|surface
init|=
name|mSurfaceSet
operator|.
name|begin
argument_list|()
init|;
name|surface
operator|!=
name|mSurfaceSet
operator|.
name|end
argument_list|()
condition|;
name|surface
operator|++
control|)
block|{
operator|(
operator|*
name|surface
operator|)
operator|->
name|resetSwapChain
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|destroySurface
name|void
name|Display
operator|::
name|destroySurface
parameter_list|(
name|egl
operator|::
name|Surface
modifier|*
name|surface
parameter_list|)
block|{
operator|delete
name|surface
expr_stmt|;
name|mSurfaceSet
operator|.
name|erase
argument_list|(
name|surface
argument_list|)
expr_stmt|;
block|}
DECL|function|destroyContext
name|void
name|Display
operator|::
name|destroyContext
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|)
block|{
name|glDestroyContext
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|mContextSet
operator|.
name|erase
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
DECL|function|notifyDeviceLost
name|void
name|Display
operator|::
name|notifyDeviceLost
parameter_list|()
block|{
for|for
control|(
name|ContextSet
operator|::
name|iterator
name|context
init|=
name|mContextSet
operator|.
name|begin
argument_list|()
init|;
name|context
operator|!=
name|mContextSet
operator|.
name|end
argument_list|()
condition|;
name|context
operator|++
control|)
block|{
operator|(
operator|*
name|context
operator|)
operator|->
name|markContextLost
argument_list|()
expr_stmt|;
block|}
name|egl
operator|::
name|error
argument_list|(
name|EGL_CONTEXT_LOST
argument_list|)
expr_stmt|;
block|}
DECL|function|recreateSwapChains
name|void
name|Display
operator|::
name|recreateSwapChains
parameter_list|()
block|{
for|for
control|(
name|SurfaceSet
operator|::
name|iterator
name|surface
init|=
name|mSurfaceSet
operator|.
name|begin
argument_list|()
init|;
name|surface
operator|!=
name|mSurfaceSet
operator|.
name|end
argument_list|()
condition|;
name|surface
operator|++
control|)
block|{
operator|(
operator|*
name|surface
operator|)
operator|->
name|getSwapChain
argument_list|()
operator|->
name|recreate
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|isInitialized
name|bool
name|Display
operator|::
name|isInitialized
parameter_list|()
specifier|const
block|{
return|return
name|mRenderer
operator|!=
name|NULL
operator|&&
name|mConfigSet
operator|.
name|size
argument_list|()
operator|>
literal|0
return|;
block|}
DECL|function|isValidConfig
name|bool
name|Display
operator|::
name|isValidConfig
parameter_list|(
name|EGLConfig
name|config
parameter_list|)
block|{
return|return
name|mConfigSet
operator|.
name|get
argument_list|(
name|config
argument_list|)
operator|!=
name|NULL
return|;
block|}
DECL|function|isValidContext
name|bool
name|Display
operator|::
name|isValidContext
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|)
block|{
return|return
name|mContextSet
operator|.
name|find
argument_list|(
name|context
argument_list|)
operator|!=
name|mContextSet
operator|.
name|end
argument_list|()
return|;
block|}
DECL|function|isValidSurface
name|bool
name|Display
operator|::
name|isValidSurface
parameter_list|(
name|egl
operator|::
name|Surface
modifier|*
name|surface
parameter_list|)
block|{
return|return
name|mSurfaceSet
operator|.
name|find
argument_list|(
name|surface
argument_list|)
operator|!=
name|mSurfaceSet
operator|.
name|end
argument_list|()
return|;
block|}
DECL|function|hasExistingWindowSurface
name|bool
name|Display
operator|::
name|hasExistingWindowSurface
parameter_list|(
name|HWND
name|window
parameter_list|)
block|{
for|for
control|(
name|SurfaceSet
operator|::
name|iterator
name|surface
init|=
name|mSurfaceSet
operator|.
name|begin
argument_list|()
init|;
name|surface
operator|!=
name|mSurfaceSet
operator|.
name|end
argument_list|()
condition|;
name|surface
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|surface
operator|)
operator|->
name|getWindowHandle
argument_list|()
operator|==
name|window
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|function|initExtensionString
name|void
name|Display
operator|::
name|initExtensionString
parameter_list|()
block|{
name|HMODULE
name|swiftShader
init|=
name|GetModuleHandle
argument_list|(
name|TEXT
argument_list|(
literal|"swiftshader_d3d9.dll"
argument_list|)
argument_list|)
decl_stmt|;
name|bool
name|shareHandleSupported
init|=
name|mRenderer
operator|->
name|getShareHandleSupport
argument_list|()
decl_stmt|;
name|mExtensionString
operator|=
literal|""
expr_stmt|;
comment|// Multi-vendor (EXT) extensions
name|mExtensionString
operator|+=
literal|"EGL_EXT_create_context_robustness "
expr_stmt|;
comment|// ANGLE-specific extensions
if|if
condition|(
name|shareHandleSupported
condition|)
block|{
name|mExtensionString
operator|+=
literal|"EGL_ANGLE_d3d_share_handle_client_buffer "
expr_stmt|;
block|}
name|mExtensionString
operator|+=
literal|"EGL_ANGLE_query_surface_pointer "
expr_stmt|;
if|if
condition|(
name|swiftShader
condition|)
block|{
name|mExtensionString
operator|+=
literal|"EGL_ANGLE_software_display "
expr_stmt|;
block|}
if|if
condition|(
name|shareHandleSupported
condition|)
block|{
name|mExtensionString
operator|+=
literal|"EGL_ANGLE_surface_d3d_texture_2d_share_handle "
expr_stmt|;
block|}
if|if
condition|(
name|mRenderer
operator|->
name|getPostSubBufferSupport
argument_list|()
condition|)
block|{
name|mExtensionString
operator|+=
literal|"EGL_NV_post_sub_buffer"
expr_stmt|;
block|}
name|std
operator|::
name|string
operator|::
name|size_type
name|end
init|=
name|mExtensionString
operator|.
name|find_last_not_of
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|!=
name|std
operator|::
name|string
operator|::
name|npos
condition|)
block|{
name|mExtensionString
operator|.
name|resize
argument_list|(
name|end
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|getExtensionString
specifier|const
name|char
modifier|*
name|Display
operator|::
name|getExtensionString
parameter_list|()
specifier|const
block|{
return|return
name|mExtensionString
operator|.
name|c_str
argument_list|()
return|;
block|}
DECL|function|initVendorString
name|void
name|Display
operator|::
name|initVendorString
parameter_list|()
block|{
name|mVendorString
operator|=
literal|"Google Inc."
expr_stmt|;
name|LUID
name|adapterLuid
init|=
block|{
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|mRenderer
operator|&&
name|mRenderer
operator|->
name|getLUID
argument_list|(
operator|&
name|adapterLuid
argument_list|)
condition|)
block|{
name|char
name|adapterLuidString
index|[
literal|64
index|]
decl_stmt|;
name|sprintf_s
argument_list|(
name|adapterLuidString
argument_list|,
sizeof|sizeof
argument_list|(
name|adapterLuidString
argument_list|)
argument_list|,
literal|" (adapter LUID: %08x%08x)"
argument_list|,
name|adapterLuid
operator|.
name|HighPart
argument_list|,
name|adapterLuid
operator|.
name|LowPart
argument_list|)
expr_stmt|;
name|mVendorString
operator|+=
name|adapterLuidString
expr_stmt|;
block|}
block|}
DECL|function|getVendorString
specifier|const
name|char
modifier|*
name|Display
operator|::
name|getVendorString
parameter_list|()
specifier|const
block|{
return|return
name|mVendorString
operator|.
name|c_str
argument_list|()
return|;
block|}
block|}
end_namespace
end_unit
