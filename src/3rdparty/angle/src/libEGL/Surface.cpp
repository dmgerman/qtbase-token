begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2010 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Surface.cpp: Implements the egl::Surface class, representing a drawing surface
end_comment
begin_comment
comment|// such as the client area of a window, including any back buffers.
end_comment
begin_comment
comment|// Implements EGLSurface and related functionality. [EGL 1.4] section 2.2 page 3.
end_comment
begin_include
include|#
directive|include
file|<tchar.h>
end_include
begin_include
include|#
directive|include
file|"libEGL/Surface.h"
end_include
begin_include
include|#
directive|include
file|"common/debug.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Texture.h"
end_include
begin_include
include|#
directive|include
file|"libEGL/main.h"
end_include
begin_include
include|#
directive|include
file|"libEGL/Display.h"
end_include
begin_include
include|#
directive|include
file|<dwmapi.h>
end_include
begin_namespace
DECL|namespace|egl
namespace|namespace
name|egl
block|{
DECL|function|Surface
name|Surface
operator|::
name|Surface
parameter_list|(
name|Display
modifier|*
name|display
parameter_list|,
specifier|const
name|Config
modifier|*
name|config
parameter_list|,
name|HWND
name|window
parameter_list|,
name|EGLint
name|postSubBufferSupported
parameter_list|)
member_init_list|:
name|mDisplay
argument_list|(
name|display
argument_list|)
member_init_list|,
name|mConfig
argument_list|(
name|config
argument_list|)
member_init_list|,
name|mWindow
argument_list|(
name|window
argument_list|)
member_init_list|,
name|mPostSubBufferSupported
argument_list|(
name|postSubBufferSupported
argument_list|)
block|{
name|mSwapChain
operator|=
name|NULL
expr_stmt|;
name|mBackBuffer
operator|=
name|NULL
expr_stmt|;
name|mDepthStencil
operator|=
name|NULL
expr_stmt|;
name|mRenderTarget
operator|=
name|NULL
expr_stmt|;
name|mOffscreenTexture
operator|=
name|NULL
expr_stmt|;
name|mShareHandle
operator|=
name|NULL
expr_stmt|;
name|mTexture
operator|=
name|NULL
expr_stmt|;
name|mTextureFormat
operator|=
name|EGL_NO_TEXTURE
expr_stmt|;
name|mTextureTarget
operator|=
name|EGL_NO_TEXTURE
expr_stmt|;
name|mPixelAspectRatio
operator|=
call|(
name|EGLint
call|)
argument_list|(
literal|1.0
operator|*
name|EGL_DISPLAY_SCALING
argument_list|)
expr_stmt|;
comment|// FIXME: Determine actual pixel aspect ratio
name|mRenderBuffer
operator|=
name|EGL_BACK_BUFFER
expr_stmt|;
name|mSwapBehavior
operator|=
name|EGL_BUFFER_PRESERVED
expr_stmt|;
name|mSwapInterval
operator|=
operator|-
literal|1
expr_stmt|;
name|setSwapInterval
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|subclassWindow
argument_list|()
expr_stmt|;
block|}
DECL|function|Surface
name|Surface
operator|::
name|Surface
parameter_list|(
name|Display
modifier|*
name|display
parameter_list|,
specifier|const
name|Config
modifier|*
name|config
parameter_list|,
name|HANDLE
name|shareHandle
parameter_list|,
name|EGLint
name|width
parameter_list|,
name|EGLint
name|height
parameter_list|,
name|EGLenum
name|textureFormat
parameter_list|,
name|EGLenum
name|textureType
parameter_list|)
member_init_list|:
name|mDisplay
argument_list|(
name|display
argument_list|)
member_init_list|,
name|mWindow
argument_list|(
name|NULL
argument_list|)
member_init_list|,
name|mConfig
argument_list|(
name|config
argument_list|)
member_init_list|,
name|mShareHandle
argument_list|(
name|shareHandle
argument_list|)
member_init_list|,
name|mWidth
argument_list|(
name|width
argument_list|)
member_init_list|,
name|mHeight
argument_list|(
name|height
argument_list|)
member_init_list|,
name|mPostSubBufferSupported
argument_list|(
name|EGL_FALSE
argument_list|)
block|{
name|mSwapChain
operator|=
name|NULL
expr_stmt|;
name|mBackBuffer
operator|=
name|NULL
expr_stmt|;
name|mDepthStencil
operator|=
name|NULL
expr_stmt|;
name|mRenderTarget
operator|=
name|NULL
expr_stmt|;
name|mOffscreenTexture
operator|=
name|NULL
expr_stmt|;
name|mWindowSubclassed
operator|=
literal|false
expr_stmt|;
name|mTexture
operator|=
name|NULL
expr_stmt|;
name|mTextureFormat
operator|=
name|textureFormat
expr_stmt|;
name|mTextureTarget
operator|=
name|textureType
expr_stmt|;
name|mPixelAspectRatio
operator|=
call|(
name|EGLint
call|)
argument_list|(
literal|1.0
operator|*
name|EGL_DISPLAY_SCALING
argument_list|)
expr_stmt|;
comment|// FIXME: Determine actual pixel aspect ratio
name|mRenderBuffer
operator|=
name|EGL_BACK_BUFFER
expr_stmt|;
name|mSwapBehavior
operator|=
name|EGL_BUFFER_PRESERVED
expr_stmt|;
name|mSwapInterval
operator|=
operator|-
literal|1
expr_stmt|;
name|setSwapInterval
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|function|~Surface
name|Surface
operator|::
name|~
name|Surface
parameter_list|()
block|{
name|unsubclassWindow
argument_list|()
expr_stmt|;
name|release
argument_list|()
expr_stmt|;
block|}
DECL|function|initialize
name|bool
name|Surface
operator|::
name|initialize
parameter_list|()
block|{
typedef|typedef
name|HRESULT
function_decl|(
name|STDAPICALLTYPE
modifier|*
name|PtrDwmIsCompositionEnabled
function_decl|)
parameter_list|(
name|BOOL
modifier|*
parameter_list|)
function_decl|;
typedef|typedef
name|HRESULT
function_decl|(
name|STDAPICALLTYPE
modifier|*
name|PtrDwmSetPresentParameters
function_decl|)
parameter_list|(
name|HWND
parameter_list|,
name|DWM_PRESENT_PARAMETERS
modifier|*
parameter_list|)
function_decl|;
name|ASSERT
argument_list|(
operator|!
name|mSwapChain
operator|&&
operator|!
name|mOffscreenTexture
operator|&&
operator|!
name|mDepthStencil
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|resetSwapChain
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// Modify present parameters for this window, if we are composited,
comment|// to minimize the amount of queuing done by DWM between our calls to
comment|// present and the actual screen.
if|if
condition|(
name|mWindow
operator|&&
operator|(
name|getComparableOSVersion
argument_list|()
operator|>=
name|versionWindowsVista
operator|)
condition|)
block|{
comment|// Resolve dwmapi.dll functions dynamically as the Library is
comment|// not present on Windows XP. Alternatively, /DELAYLOAD could be used.
specifier|static
name|PtrDwmIsCompositionEnabled
name|dwmIsCompositionEnabled
init|=
literal|0
decl_stmt|;
specifier|static
name|PtrDwmSetPresentParameters
name|dwmSetPresentParameters
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|dwmIsCompositionEnabled
condition|)
block|{
if|if
condition|(
specifier|const
name|HMODULE
name|dwmLibrary
init|=
name|LoadLibraryW
argument_list|(
literal|L"dwmapi.dll"
argument_list|)
condition|)
block|{
name|dwmIsCompositionEnabled
operator|=
operator|(
name|PtrDwmIsCompositionEnabled
operator|)
name|GetProcAddress
argument_list|(
name|dwmLibrary
argument_list|,
literal|"DwmIsCompositionEnabled"
argument_list|)
expr_stmt|;
name|dwmSetPresentParameters
operator|=
operator|(
name|PtrDwmSetPresentParameters
operator|)
name|GetProcAddress
argument_list|(
name|dwmLibrary
argument_list|,
literal|"DwmSetPresentParameters"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dwmIsCompositionEnabled
operator|&&
name|dwmSetPresentParameters
condition|)
block|{
name|BOOL
name|isComposited
decl_stmt|;
name|HRESULT
name|result
init|=
name|dwmIsCompositionEnabled
argument_list|(
operator|&
name|isComposited
argument_list|)
decl_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
operator|&&
name|isComposited
condition|)
block|{
name|DWM_PRESENT_PARAMETERS
name|presentParams
decl_stmt|;
name|memset
argument_list|(
operator|&
name|presentParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|presentParams
argument_list|)
argument_list|)
expr_stmt|;
name|presentParams
operator|.
name|cbSize
operator|=
sizeof|sizeof
argument_list|(
name|DWM_PRESENT_PARAMETERS
argument_list|)
expr_stmt|;
name|presentParams
operator|.
name|cBuffer
operator|=
literal|2
expr_stmt|;
name|result
operator|=
name|dwmSetPresentParameters
argument_list|(
name|mWindow
argument_list|,
operator|&
name|presentParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
name|ERR
argument_list|(
literal|"Unable to set present parameters: 0x%08X"
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|release
name|void
name|Surface
operator|::
name|release
parameter_list|()
block|{
if|if
condition|(
name|mSwapChain
condition|)
block|{
name|mSwapChain
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mSwapChain
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mBackBuffer
condition|)
block|{
name|mBackBuffer
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mBackBuffer
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mDepthStencil
condition|)
block|{
name|mDepthStencil
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mDepthStencil
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mRenderTarget
condition|)
block|{
name|mRenderTarget
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mRenderTarget
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mOffscreenTexture
condition|)
block|{
name|mOffscreenTexture
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mOffscreenTexture
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mTexture
condition|)
block|{
name|mTexture
operator|->
name|releaseTexImage
argument_list|()
expr_stmt|;
name|mTexture
operator|=
name|NULL
expr_stmt|;
block|}
name|mShareHandle
operator|=
name|NULL
expr_stmt|;
block|}
DECL|function|resetSwapChain
name|bool
name|Surface
operator|::
name|resetSwapChain
parameter_list|()
block|{
if|if
condition|(
operator|!
name|mWindow
condition|)
block|{
return|return
name|resetSwapChain
argument_list|(
name|mWidth
argument_list|,
name|mHeight
argument_list|)
return|;
block|}
name|RECT
name|windowRect
decl_stmt|;
if|if
condition|(
operator|!
name|GetClientRect
argument_list|(
name|getWindowHandle
argument_list|()
argument_list|,
operator|&
name|windowRect
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|ERR
argument_list|(
literal|"Could not retrieve the window dimensions"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|resetSwapChain
argument_list|(
name|windowRect
operator|.
name|right
operator|-
name|windowRect
operator|.
name|left
argument_list|,
name|windowRect
operator|.
name|bottom
operator|-
name|windowRect
operator|.
name|top
argument_list|)
return|;
block|}
DECL|function|resetSwapChain
name|bool
name|Surface
operator|::
name|resetSwapChain
parameter_list|(
name|int
name|backbufferWidth
parameter_list|,
name|int
name|backbufferHeight
parameter_list|)
block|{
name|IDirect3DDevice9
modifier|*
name|device
init|=
name|mDisplay
operator|->
name|getDevice
argument_list|()
decl_stmt|;
if|if
condition|(
name|device
operator|==
name|NULL
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Evict all non-render target textures to system memory and release all resources
comment|// before reallocating them to free up as much video memory as possible.
name|device
operator|->
name|EvictManagedResources
argument_list|()
expr_stmt|;
name|HRESULT
name|result
decl_stmt|;
comment|// Release specific resources to free up memory for the new render target, while the
comment|// old render target still exists for the purpose of preserving its contents.
if|if
condition|(
name|mSwapChain
condition|)
block|{
name|mSwapChain
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mSwapChain
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mBackBuffer
condition|)
block|{
name|mBackBuffer
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mBackBuffer
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mOffscreenTexture
condition|)
block|{
name|mOffscreenTexture
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mOffscreenTexture
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mDepthStencil
condition|)
block|{
name|mDepthStencil
operator|->
name|Release
argument_list|()
expr_stmt|;
name|mDepthStencil
operator|=
name|NULL
expr_stmt|;
block|}
name|mShareHandle
operator|=
name|NULL
expr_stmt|;
name|HANDLE
modifier|*
name|pShareHandle
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|mWindow
operator|&&
name|mDisplay
operator|->
name|shareHandleSupported
argument_list|()
condition|)
block|{
name|pShareHandle
operator|=
operator|&
name|mShareHandle
expr_stmt|;
block|}
name|result
operator|=
name|device
operator|->
name|CreateTexture
argument_list|(
name|backbufferWidth
argument_list|,
name|backbufferHeight
argument_list|,
literal|1
argument_list|,
name|D3DUSAGE_RENDERTARGET
argument_list|,
name|mConfig
operator|->
name|mRenderTargetFormat
argument_list|,
name|D3DPOOL_DEFAULT
argument_list|,
operator|&
name|mOffscreenTexture
argument_list|,
name|pShareHandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not create offscreen texture: %08lX"
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|release
argument_list|()
expr_stmt|;
if|if
condition|(
name|isDeviceLostError
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|mDisplay
operator|->
name|notifyDeviceLost
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
name|error
argument_list|(
name|EGL_BAD_ALLOC
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
name|IDirect3DSurface9
modifier|*
name|oldRenderTarget
init|=
name|mRenderTarget
decl_stmt|;
name|result
operator|=
name|mOffscreenTexture
operator|->
name|GetSurfaceLevel
argument_list|(
literal|0
argument_list|,
operator|&
name|mRenderTarget
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldRenderTarget
condition|)
block|{
name|RECT
name|rect
init|=
block|{
literal|0
block|,
literal|0
block|,
name|mWidth
block|,
name|mHeight
block|}
decl_stmt|;
if|if
condition|(
name|rect
operator|.
name|right
operator|>
cast|static_cast
argument_list|<
name|LONG
argument_list|>
argument_list|(
name|backbufferWidth
argument_list|)
condition|)
block|{
name|rect
operator|.
name|right
operator|=
name|backbufferWidth
expr_stmt|;
block|}
if|if
condition|(
name|rect
operator|.
name|bottom
operator|>
cast|static_cast
argument_list|<
name|LONG
argument_list|>
argument_list|(
name|backbufferHeight
argument_list|)
condition|)
block|{
name|rect
operator|.
name|bottom
operator|=
name|backbufferHeight
expr_stmt|;
block|}
name|mDisplay
operator|->
name|endScene
argument_list|()
expr_stmt|;
name|result
operator|=
name|device
operator|->
name|StretchRect
argument_list|(
name|oldRenderTarget
argument_list|,
operator|&
name|rect
argument_list|,
name|mRenderTarget
argument_list|,
operator|&
name|rect
argument_list|,
name|D3DTEXF_NONE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|oldRenderTarget
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|mWindow
condition|)
block|{
name|D3DPRESENT_PARAMETERS
name|presentParameters
init|=
block|{
literal|0
block|}
decl_stmt|;
name|presentParameters
operator|.
name|AutoDepthStencilFormat
operator|=
name|mConfig
operator|->
name|mDepthStencilFormat
expr_stmt|;
name|presentParameters
operator|.
name|BackBufferCount
operator|=
literal|1
expr_stmt|;
name|presentParameters
operator|.
name|BackBufferFormat
operator|=
name|mConfig
operator|->
name|mRenderTargetFormat
expr_stmt|;
name|presentParameters
operator|.
name|EnableAutoDepthStencil
operator|=
name|FALSE
expr_stmt|;
name|presentParameters
operator|.
name|Flags
operator|=
literal|0
expr_stmt|;
name|presentParameters
operator|.
name|hDeviceWindow
operator|=
name|getWindowHandle
argument_list|()
expr_stmt|;
name|presentParameters
operator|.
name|MultiSampleQuality
operator|=
literal|0
expr_stmt|;
comment|// FIXME: Unimplemented
name|presentParameters
operator|.
name|MultiSampleType
operator|=
name|D3DMULTISAMPLE_NONE
expr_stmt|;
comment|// FIXME: Unimplemented
name|presentParameters
operator|.
name|PresentationInterval
operator|=
name|mPresentInterval
expr_stmt|;
name|presentParameters
operator|.
name|SwapEffect
operator|=
name|D3DSWAPEFFECT_DISCARD
expr_stmt|;
name|presentParameters
operator|.
name|Windowed
operator|=
name|TRUE
expr_stmt|;
name|presentParameters
operator|.
name|BackBufferWidth
operator|=
name|backbufferWidth
expr_stmt|;
name|presentParameters
operator|.
name|BackBufferHeight
operator|=
name|backbufferHeight
expr_stmt|;
comment|// http://crbug.com/140239
comment|// http://crbug.com/143434
comment|//
comment|// Some AMD/Intel switchable systems / drivers appear to round swap chain surfaces to a multiple of 64 pixels in width
comment|// when using the integrated Intel. This rounds the width up rather than down.
comment|//
comment|// Some non-switchable AMD GPUs / drivers do not respect the source rectangle to Present. Therefore, when the vendor ID
comment|// is not Intel, the back buffer width must be exactly the same width as the window or horizontal scaling will occur.
name|D3DADAPTER_IDENTIFIER9
modifier|*
name|adapterIdentifier
init|=
name|mDisplay
operator|->
name|getAdapterIdentifier
argument_list|()
decl_stmt|;
if|if
condition|(
name|adapterIdentifier
operator|->
name|VendorId
operator|==
name|VENDOR_ID_INTEL
condition|)
block|{
name|presentParameters
operator|.
name|BackBufferWidth
operator|=
operator|(
name|presentParameters
operator|.
name|BackBufferWidth
operator|+
literal|63
operator|)
operator|/
literal|64
operator|*
literal|64
expr_stmt|;
block|}
name|result
operator|=
name|device
operator|->
name|CreateAdditionalSwapChain
argument_list|(
operator|&
name|presentParameters
argument_list|,
operator|&
name|mSwapChain
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|result
operator|==
name|D3DERR_OUTOFVIDEOMEMORY
operator|||
name|result
operator|==
name|E_OUTOFMEMORY
operator|||
name|result
operator|==
name|D3DERR_INVALIDCALL
operator|||
name|result
operator|==
name|D3DERR_DEVICELOST
argument_list|)
expr_stmt|;
name|ERR
argument_list|(
literal|"Could not create additional swap chains or offscreen surfaces: %08lX"
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|release
argument_list|()
expr_stmt|;
if|if
condition|(
name|isDeviceLostError
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|mDisplay
operator|->
name|notifyDeviceLost
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
name|error
argument_list|(
name|EGL_BAD_ALLOC
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
name|result
operator|=
name|mSwapChain
operator|->
name|GetBackBuffer
argument_list|(
literal|0
argument_list|,
name|D3DBACKBUFFER_TYPE_MONO
argument_list|,
operator|&
name|mBackBuffer
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|InvalidateRect
argument_list|(
name|mWindow
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mConfig
operator|->
name|mDepthStencilFormat
operator|!=
name|D3DFMT_UNKNOWN
condition|)
block|{
name|result
operator|=
name|device
operator|->
name|CreateDepthStencilSurface
argument_list|(
name|backbufferWidth
argument_list|,
name|backbufferHeight
argument_list|,
name|mConfig
operator|->
name|mDepthStencilFormat
argument_list|,
name|D3DMULTISAMPLE_NONE
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
operator|&
name|mDepthStencil
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|result
operator|==
name|D3DERR_OUTOFVIDEOMEMORY
operator|||
name|result
operator|==
name|E_OUTOFMEMORY
operator|||
name|result
operator|==
name|D3DERR_INVALIDCALL
argument_list|)
expr_stmt|;
name|ERR
argument_list|(
literal|"Could not create depthstencil surface for new swap chain: 0x%08X"
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|release
argument_list|()
expr_stmt|;
if|if
condition|(
name|isDeviceLostError
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|mDisplay
operator|->
name|notifyDeviceLost
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
name|error
argument_list|(
name|EGL_BAD_ALLOC
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
block|}
name|mWidth
operator|=
name|backbufferWidth
expr_stmt|;
name|mHeight
operator|=
name|backbufferHeight
expr_stmt|;
name|mPresentIntervalDirty
operator|=
literal|false
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|swapRect
name|bool
name|Surface
operator|::
name|swapRect
parameter_list|(
name|EGLint
name|x
parameter_list|,
name|EGLint
name|y
parameter_list|,
name|EGLint
name|width
parameter_list|,
name|EGLint
name|height
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mSwapChain
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|x
operator|+
name|width
operator|>
name|mWidth
condition|)
block|{
name|width
operator|=
name|mWidth
operator|-
name|x
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|+
name|height
operator|>
name|mHeight
condition|)
block|{
name|height
operator|=
name|mHeight
operator|-
name|y
expr_stmt|;
block|}
if|if
condition|(
name|width
operator|==
literal|0
operator|||
name|height
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
name|IDirect3DDevice9
modifier|*
name|device
init|=
name|mDisplay
operator|->
name|getDevice
argument_list|()
decl_stmt|;
comment|// Disable all pipeline operations
name|device
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ZENABLE
argument_list|,
name|D3DZB_FALSE
argument_list|)
expr_stmt|;
name|device
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_FILLMODE
argument_list|,
name|D3DFILL_SOLID
argument_list|)
expr_stmt|;
name|device
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ALPHATESTENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|device
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ALPHABLENDENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|device
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_CULLMODE
argument_list|,
name|D3DCULL_NONE
argument_list|)
expr_stmt|;
name|device
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_STENCILENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|device
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_CLIPPLANEENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|device
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_COLORWRITEENABLE
argument_list|,
name|D3DCOLORWRITEENABLE_ALPHA
operator||
name|D3DCOLORWRITEENABLE_BLUE
operator||
name|D3DCOLORWRITEENABLE_GREEN
operator||
name|D3DCOLORWRITEENABLE_RED
argument_list|)
expr_stmt|;
name|device
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_SRGBWRITEENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|device
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_SCISSORTESTENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|device
operator|->
name|SetPixelShader
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|device
operator|->
name|SetVertexShader
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|device
operator|->
name|SetRenderTarget
argument_list|(
literal|0
argument_list|,
name|mBackBuffer
argument_list|)
expr_stmt|;
name|device
operator|->
name|SetDepthStencilSurface
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|device
operator|->
name|SetTexture
argument_list|(
literal|0
argument_list|,
name|mOffscreenTexture
argument_list|)
expr_stmt|;
name|device
operator|->
name|SetTextureStageState
argument_list|(
literal|0
argument_list|,
name|D3DTSS_COLOROP
argument_list|,
name|D3DTOP_SELECTARG1
argument_list|)
expr_stmt|;
name|device
operator|->
name|SetTextureStageState
argument_list|(
literal|0
argument_list|,
name|D3DTSS_COLORARG1
argument_list|,
name|D3DTA_TEXTURE
argument_list|)
expr_stmt|;
name|device
operator|->
name|SetTextureStageState
argument_list|(
literal|1
argument_list|,
name|D3DTSS_COLOROP
argument_list|,
name|D3DTOP_DISABLE
argument_list|)
expr_stmt|;
name|device
operator|->
name|SetSamplerState
argument_list|(
literal|0
argument_list|,
name|D3DSAMP_MAGFILTER
argument_list|,
name|D3DTEXF_POINT
argument_list|)
expr_stmt|;
name|device
operator|->
name|SetSamplerState
argument_list|(
literal|0
argument_list|,
name|D3DSAMP_MINFILTER
argument_list|,
name|D3DTEXF_POINT
argument_list|)
expr_stmt|;
name|device
operator|->
name|SetSamplerState
argument_list|(
literal|0
argument_list|,
name|D3DSAMP_ADDRESSU
argument_list|,
name|D3DTADDRESS_CLAMP
argument_list|)
expr_stmt|;
name|device
operator|->
name|SetSamplerState
argument_list|(
literal|0
argument_list|,
name|D3DSAMP_ADDRESSV
argument_list|,
name|D3DTADDRESS_CLAMP
argument_list|)
expr_stmt|;
name|device
operator|->
name|SetFVF
argument_list|(
name|D3DFVF_XYZRHW
operator||
name|D3DFVF_TEX1
argument_list|)
expr_stmt|;
name|D3DVIEWPORT9
name|viewport
init|=
block|{
literal|0
block|,
literal|0
block|,
name|mWidth
block|,
name|mHeight
block|,
literal|0.0f
block|,
literal|1.0f
block|}
decl_stmt|;
name|device
operator|->
name|SetViewport
argument_list|(
operator|&
name|viewport
argument_list|)
expr_stmt|;
name|float
name|x1
init|=
name|x
operator|-
literal|0.5f
decl_stmt|;
name|float
name|y1
init|=
operator|(
name|mHeight
operator|-
name|y
operator|-
name|height
operator|)
operator|-
literal|0.5f
decl_stmt|;
name|float
name|x2
init|=
operator|(
name|x
operator|+
name|width
operator|)
operator|-
literal|0.5f
decl_stmt|;
name|float
name|y2
init|=
operator|(
name|mHeight
operator|-
name|y
operator|)
operator|-
literal|0.5f
decl_stmt|;
name|float
name|u1
init|=
name|x
operator|/
name|float
argument_list|(
name|mWidth
argument_list|)
decl_stmt|;
name|float
name|v1
init|=
name|y
operator|/
name|float
argument_list|(
name|mHeight
argument_list|)
decl_stmt|;
name|float
name|u2
init|=
operator|(
name|x
operator|+
name|width
operator|)
operator|/
name|float
argument_list|(
name|mWidth
argument_list|)
decl_stmt|;
name|float
name|v2
init|=
operator|(
name|y
operator|+
name|height
operator|)
operator|/
name|float
argument_list|(
name|mHeight
argument_list|)
decl_stmt|;
name|float
name|quad
index|[
literal|4
index|]
index|[
literal|6
index|]
init|=
block|{
block|{
name|x1
block|,
name|y1
block|,
literal|0.0f
block|,
literal|1.0f
block|,
name|u1
block|,
name|v2
block|}
block|,
block|{
name|x2
block|,
name|y1
block|,
literal|0.0f
block|,
literal|1.0f
block|,
name|u2
block|,
name|v2
block|}
block|,
block|{
name|x2
block|,
name|y2
block|,
literal|0.0f
block|,
literal|1.0f
block|,
name|u2
block|,
name|v1
block|}
block|,
block|{
name|x1
block|,
name|y2
block|,
literal|0.0f
block|,
literal|1.0f
block|,
name|u1
block|,
name|v1
block|}
block|}
decl_stmt|;
comment|// x, y, z, rhw, u, v
name|mDisplay
operator|->
name|startScene
argument_list|()
expr_stmt|;
name|device
operator|->
name|DrawPrimitiveUP
argument_list|(
name|D3DPT_TRIANGLEFAN
argument_list|,
literal|2
argument_list|,
name|quad
argument_list|,
literal|6
operator|*
sizeof|sizeof
argument_list|(
name|float
argument_list|)
argument_list|)
expr_stmt|;
name|mDisplay
operator|->
name|endScene
argument_list|()
expr_stmt|;
name|device
operator|->
name|SetTexture
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RECT
name|rect
init|=
block|{
name|x
block|,
name|mHeight
operator|-
name|y
operator|-
name|height
block|,
name|x
operator|+
name|width
block|,
name|mHeight
operator|-
name|y
block|}
decl_stmt|;
name|HRESULT
name|result
init|=
name|mSwapChain
operator|->
name|Present
argument_list|(
operator|&
name|rect
argument_list|,
operator|&
name|rect
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
cast|static_cast
argument_list|<
name|gl
operator|::
name|Context
operator|*
argument_list|>
argument_list|(
name|glGetCurrentContext
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|context
operator|->
name|markAllStateDirty
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|isDeviceLostError
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|mDisplay
operator|->
name|notifyDeviceLost
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|result
operator|==
name|D3DERR_OUTOFVIDEOMEMORY
operator|||
name|result
operator|==
name|E_OUTOFMEMORY
operator|||
name|result
operator|==
name|D3DERR_DRIVERINTERNALERROR
condition|)
block|{
return|return
name|error
argument_list|(
name|EGL_BAD_ALLOC
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|checkForOutOfDateSwapChain
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|getWindowHandle
name|HWND
name|Surface
operator|::
name|getWindowHandle
parameter_list|()
block|{
return|return
name|mWindow
return|;
block|}
DECL|macro|kSurfaceProperty
define|#
directive|define
name|kSurfaceProperty
value|_TEXT("Egl::SurfaceOwner")
DECL|macro|kParentWndProc
define|#
directive|define
name|kParentWndProc
value|_TEXT("Egl::SurfaceParentWndProc")
DECL|function|SurfaceWindowProc
specifier|static
name|LRESULT
name|CALLBACK
name|SurfaceWindowProc
parameter_list|(
name|HWND
name|hwnd
parameter_list|,
name|UINT
name|message
parameter_list|,
name|WPARAM
name|wparam
parameter_list|,
name|LPARAM
name|lparam
parameter_list|)
block|{
if|if
condition|(
name|message
operator|==
name|WM_SIZE
condition|)
block|{
name|Surface
modifier|*
name|surf
init|=
cast|reinterpret_cast
argument_list|<
name|Surface
operator|*
argument_list|>
argument_list|(
name|GetProp
argument_list|(
name|hwnd
argument_list|,
name|kSurfaceProperty
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|surf
condition|)
block|{
name|surf
operator|->
name|checkForOutOfDateSwapChain
argument_list|()
expr_stmt|;
block|}
block|}
name|WNDPROC
name|prevWndFunc
init|=
cast|reinterpret_cast
argument_list|<
name|WNDPROC
argument_list|>
argument_list|(
name|GetProp
argument_list|(
name|hwnd
argument_list|,
name|kParentWndProc
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|CallWindowProc
argument_list|(
name|prevWndFunc
argument_list|,
name|hwnd
argument_list|,
name|message
argument_list|,
name|wparam
argument_list|,
name|lparam
argument_list|)
return|;
block|}
DECL|function|subclassWindow
name|void
name|Surface
operator|::
name|subclassWindow
parameter_list|()
block|{
if|if
condition|(
operator|!
name|mWindow
condition|)
block|{
return|return;
block|}
name|DWORD
name|processId
decl_stmt|;
name|DWORD
name|threadId
init|=
name|GetWindowThreadProcessId
argument_list|(
name|mWindow
argument_list|,
operator|&
name|processId
argument_list|)
decl_stmt|;
if|if
condition|(
name|processId
operator|!=
name|GetCurrentProcessId
argument_list|()
operator|||
name|threadId
operator|!=
name|GetCurrentThreadId
argument_list|()
condition|)
block|{
return|return;
block|}
name|SetLastError
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|LONG_PTR
name|oldWndProc
init|=
name|SetWindowLongPtr
argument_list|(
name|mWindow
argument_list|,
name|GWLP_WNDPROC
argument_list|,
cast|reinterpret_cast
argument_list|<
name|LONG_PTR
argument_list|>
argument_list|(
name|SurfaceWindowProc
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldWndProc
operator|==
literal|0
operator|&&
name|GetLastError
argument_list|()
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|mWindowSubclassed
operator|=
literal|false
expr_stmt|;
return|return;
block|}
name|SetProp
argument_list|(
name|mWindow
argument_list|,
name|kSurfaceProperty
argument_list|,
cast|reinterpret_cast
argument_list|<
name|HANDLE
argument_list|>
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|SetProp
argument_list|(
name|mWindow
argument_list|,
name|kParentWndProc
argument_list|,
cast|reinterpret_cast
argument_list|<
name|HANDLE
argument_list|>
argument_list|(
name|oldWndProc
argument_list|)
argument_list|)
expr_stmt|;
name|mWindowSubclassed
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|unsubclassWindow
name|void
name|Surface
operator|::
name|unsubclassWindow
parameter_list|()
block|{
if|if
condition|(
operator|!
name|mWindowSubclassed
condition|)
block|{
return|return;
block|}
comment|// un-subclass
name|LONG_PTR
name|parentWndFunc
init|=
cast|reinterpret_cast
argument_list|<
name|LONG_PTR
argument_list|>
argument_list|(
name|GetProp
argument_list|(
name|mWindow
argument_list|,
name|kParentWndProc
argument_list|)
argument_list|)
decl_stmt|;
comment|// Check the windowproc is still SurfaceWindowProc.
comment|// If this assert fails, then it is likely the application has subclassed the
comment|// hwnd as well and did not unsubclass before destroying its EGL context. The
comment|// application should be modified to either subclass before initializing the
comment|// EGL context, or to unsubclass before destroying the EGL context.
if|if
condition|(
name|parentWndFunc
condition|)
block|{
name|LONG_PTR
name|prevWndFunc
init|=
name|SetWindowLongPtr
argument_list|(
name|mWindow
argument_list|,
name|GWLP_WNDPROC
argument_list|,
name|parentWndFunc
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|prevWndFunc
operator|==
cast|reinterpret_cast
argument_list|<
name|LONG_PTR
argument_list|>
argument_list|(
name|SurfaceWindowProc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RemoveProp
argument_list|(
name|mWindow
argument_list|,
name|kSurfaceProperty
argument_list|)
expr_stmt|;
name|RemoveProp
argument_list|(
name|mWindow
argument_list|,
name|kParentWndProc
argument_list|)
expr_stmt|;
name|mWindowSubclassed
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|checkForOutOfDateSwapChain
name|bool
name|Surface
operator|::
name|checkForOutOfDateSwapChain
parameter_list|()
block|{
name|RECT
name|client
decl_stmt|;
if|if
condition|(
operator|!
name|GetClientRect
argument_list|(
name|getWindowHandle
argument_list|()
argument_list|,
operator|&
name|client
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Grow the buffer now, if the window has grown. We need to grow now to avoid losing information.
name|int
name|clientWidth
init|=
name|client
operator|.
name|right
operator|-
name|client
operator|.
name|left
decl_stmt|;
name|int
name|clientHeight
init|=
name|client
operator|.
name|bottom
operator|-
name|client
operator|.
name|top
decl_stmt|;
name|bool
name|sizeDirty
init|=
name|clientWidth
operator|!=
name|getWidth
argument_list|()
operator|||
name|clientHeight
operator|!=
name|getHeight
argument_list|()
decl_stmt|;
if|if
condition|(
name|sizeDirty
operator|||
name|mPresentIntervalDirty
condition|)
block|{
name|resetSwapChain
argument_list|(
name|clientWidth
argument_list|,
name|clientHeight
argument_list|)
expr_stmt|;
if|if
condition|(
cast|static_cast
argument_list|<
name|egl
operator|::
name|Surface
operator|*
argument_list|>
argument_list|(
name|getCurrentDrawSurface
argument_list|()
argument_list|)
operator|==
name|this
condition|)
block|{
name|glMakeCurrent
argument_list|(
name|glGetCurrentContext
argument_list|()
argument_list|,
cast|static_cast
argument_list|<
name|egl
operator|::
name|Display
operator|*
argument_list|>
argument_list|(
name|getCurrentDisplay
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|function|convertInterval
name|DWORD
name|Surface
operator|::
name|convertInterval
parameter_list|(
name|EGLint
name|interval
parameter_list|)
block|{
switch|switch
condition|(
name|interval
condition|)
block|{
case|case
literal|0
case|:
return|return
name|D3DPRESENT_INTERVAL_IMMEDIATE
return|;
case|case
literal|1
case|:
return|return
name|D3DPRESENT_INTERVAL_ONE
return|;
case|case
literal|2
case|:
return|return
name|D3DPRESENT_INTERVAL_TWO
return|;
case|case
literal|3
case|:
return|return
name|D3DPRESENT_INTERVAL_THREE
return|;
case|case
literal|4
case|:
return|return
name|D3DPRESENT_INTERVAL_FOUR
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
name|D3DPRESENT_INTERVAL_DEFAULT
return|;
block|}
DECL|function|swap
name|bool
name|Surface
operator|::
name|swap
parameter_list|()
block|{
return|return
name|swapRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|mWidth
argument_list|,
name|mHeight
argument_list|)
return|;
block|}
DECL|function|postSubBuffer
name|bool
name|Surface
operator|::
name|postSubBuffer
parameter_list|(
name|EGLint
name|x
parameter_list|,
name|EGLint
name|y
parameter_list|,
name|EGLint
name|width
parameter_list|,
name|EGLint
name|height
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mPostSubBufferSupported
condition|)
block|{
comment|// Spec is not clear about how this should be handled.
return|return
literal|true
return|;
block|}
return|return
name|swapRect
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
return|;
block|}
DECL|function|getWidth
name|EGLint
name|Surface
operator|::
name|getWidth
parameter_list|()
specifier|const
block|{
return|return
name|mWidth
return|;
block|}
DECL|function|getHeight
name|EGLint
name|Surface
operator|::
name|getHeight
parameter_list|()
specifier|const
block|{
return|return
name|mHeight
return|;
block|}
DECL|function|isPostSubBufferSupported
name|EGLint
name|Surface
operator|::
name|isPostSubBufferSupported
parameter_list|()
specifier|const
block|{
return|return
name|mPostSubBufferSupported
return|;
block|}
comment|// Increments refcount on surface.
comment|// caller must Release() the returned surface
DECL|function|getRenderTarget
name|IDirect3DSurface9
modifier|*
name|Surface
operator|::
name|getRenderTarget
parameter_list|()
block|{
if|if
condition|(
name|mRenderTarget
condition|)
block|{
name|mRenderTarget
operator|->
name|AddRef
argument_list|()
expr_stmt|;
block|}
return|return
name|mRenderTarget
return|;
block|}
comment|// Increments refcount on surface.
comment|// caller must Release() the returned surface
DECL|function|getDepthStencil
name|IDirect3DSurface9
modifier|*
name|Surface
operator|::
name|getDepthStencil
parameter_list|()
block|{
if|if
condition|(
name|mDepthStencil
condition|)
block|{
name|mDepthStencil
operator|->
name|AddRef
argument_list|()
expr_stmt|;
block|}
return|return
name|mDepthStencil
return|;
block|}
DECL|function|getOffscreenTexture
name|IDirect3DTexture9
modifier|*
name|Surface
operator|::
name|getOffscreenTexture
parameter_list|()
block|{
if|if
condition|(
name|mOffscreenTexture
condition|)
block|{
name|mOffscreenTexture
operator|->
name|AddRef
argument_list|()
expr_stmt|;
block|}
return|return
name|mOffscreenTexture
return|;
block|}
DECL|function|setSwapInterval
name|void
name|Surface
operator|::
name|setSwapInterval
parameter_list|(
name|EGLint
name|interval
parameter_list|)
block|{
if|if
condition|(
name|mSwapInterval
operator|==
name|interval
condition|)
block|{
return|return;
block|}
name|mSwapInterval
operator|=
name|interval
expr_stmt|;
name|mSwapInterval
operator|=
name|std
operator|::
name|max
argument_list|(
name|mSwapInterval
argument_list|,
name|mDisplay
operator|->
name|getMinSwapInterval
argument_list|()
argument_list|)
expr_stmt|;
name|mSwapInterval
operator|=
name|std
operator|::
name|min
argument_list|(
name|mSwapInterval
argument_list|,
name|mDisplay
operator|->
name|getMaxSwapInterval
argument_list|()
argument_list|)
expr_stmt|;
name|mPresentInterval
operator|=
name|convertInterval
argument_list|(
name|mSwapInterval
argument_list|)
expr_stmt|;
name|mPresentIntervalDirty
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|getTextureFormat
name|EGLenum
name|Surface
operator|::
name|getTextureFormat
parameter_list|()
specifier|const
block|{
return|return
name|mTextureFormat
return|;
block|}
DECL|function|getTextureTarget
name|EGLenum
name|Surface
operator|::
name|getTextureTarget
parameter_list|()
specifier|const
block|{
return|return
name|mTextureTarget
return|;
block|}
DECL|function|setBoundTexture
name|void
name|Surface
operator|::
name|setBoundTexture
parameter_list|(
name|gl
operator|::
name|Texture2D
modifier|*
name|texture
parameter_list|)
block|{
name|mTexture
operator|=
name|texture
expr_stmt|;
block|}
DECL|function|getBoundTexture
name|gl
operator|::
name|Texture2D
modifier|*
name|Surface
operator|::
name|getBoundTexture
parameter_list|()
specifier|const
block|{
return|return
name|mTexture
return|;
block|}
DECL|function|getFormat
name|D3DFORMAT
name|Surface
operator|::
name|getFormat
parameter_list|()
specifier|const
block|{
return|return
name|mConfig
operator|->
name|mRenderTargetFormat
return|;
block|}
block|}
end_namespace
end_unit
