begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2010 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Config.cpp: Implements the egl::Config class, describing the format, type
end_comment
begin_comment
comment|// and size for an egl::Surface. Implements EGLConfig and related functionality.
end_comment
begin_comment
comment|// [EGL 1.4] section 3.4 page 15.
end_comment
begin_include
include|#
directive|include
file|"libEGL/Config.h"
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_include
include|#
directive|include
file|<vector>
end_include
begin_include
include|#
directive|include
file|"common/debug.h"
end_include
begin_using
using|using
namespace|namespace
name|std
namespace|;
end_using
begin_namespace
DECL|namespace|egl
namespace|namespace
name|egl
block|{
DECL|function|Config
name|Config
operator|::
name|Config
parameter_list|(
name|D3DDISPLAYMODE
name|displayMode
parameter_list|,
name|EGLint
name|minInterval
parameter_list|,
name|EGLint
name|maxInterval
parameter_list|,
name|D3DFORMAT
name|renderTargetFormat
parameter_list|,
name|D3DFORMAT
name|depthStencilFormat
parameter_list|,
name|EGLint
name|multiSample
parameter_list|,
name|EGLint
name|texWidth
parameter_list|,
name|EGLint
name|texHeight
parameter_list|)
member_init_list|:
name|mDisplayMode
argument_list|(
name|displayMode
argument_list|)
member_init_list|,
name|mRenderTargetFormat
argument_list|(
name|renderTargetFormat
argument_list|)
member_init_list|,
name|mDepthStencilFormat
argument_list|(
name|depthStencilFormat
argument_list|)
member_init_list|,
name|mMultiSample
argument_list|(
name|multiSample
argument_list|)
block|{
name|set
argument_list|(
name|displayMode
argument_list|,
name|minInterval
argument_list|,
name|maxInterval
argument_list|,
name|renderTargetFormat
argument_list|,
name|depthStencilFormat
argument_list|,
name|multiSample
argument_list|,
name|texWidth
argument_list|,
name|texHeight
argument_list|)
expr_stmt|;
block|}
DECL|function|setDefaults
name|void
name|Config
operator|::
name|setDefaults
parameter_list|()
block|{
name|mBufferSize
operator|=
literal|0
expr_stmt|;
name|mRedSize
operator|=
literal|0
expr_stmt|;
name|mGreenSize
operator|=
literal|0
expr_stmt|;
name|mBlueSize
operator|=
literal|0
expr_stmt|;
name|mLuminanceSize
operator|=
literal|0
expr_stmt|;
name|mAlphaSize
operator|=
literal|0
expr_stmt|;
name|mAlphaMaskSize
operator|=
literal|0
expr_stmt|;
name|mBindToTextureRGB
operator|=
name|EGL_DONT_CARE
expr_stmt|;
name|mBindToTextureRGBA
operator|=
name|EGL_DONT_CARE
expr_stmt|;
name|mColorBufferType
operator|=
name|EGL_RGB_BUFFER
expr_stmt|;
name|mConfigCaveat
operator|=
name|EGL_DONT_CARE
expr_stmt|;
name|mConfigID
operator|=
name|EGL_DONT_CARE
expr_stmt|;
name|mConformant
operator|=
literal|0
expr_stmt|;
name|mDepthSize
operator|=
literal|0
expr_stmt|;
name|mLevel
operator|=
literal|0
expr_stmt|;
name|mMatchNativePixmap
operator|=
name|EGL_NONE
expr_stmt|;
name|mMaxPBufferWidth
operator|=
literal|0
expr_stmt|;
name|mMaxPBufferHeight
operator|=
literal|0
expr_stmt|;
name|mMaxPBufferPixels
operator|=
literal|0
expr_stmt|;
name|mMaxSwapInterval
operator|=
name|EGL_DONT_CARE
expr_stmt|;
name|mMinSwapInterval
operator|=
name|EGL_DONT_CARE
expr_stmt|;
name|mNativeRenderable
operator|=
name|EGL_DONT_CARE
expr_stmt|;
name|mNativeVisualID
operator|=
literal|0
expr_stmt|;
name|mNativeVisualType
operator|=
name|EGL_DONT_CARE
expr_stmt|;
name|mRenderableType
operator|=
name|EGL_OPENGL_ES_BIT
expr_stmt|;
name|mSampleBuffers
operator|=
literal|0
expr_stmt|;
name|mSamples
operator|=
literal|0
expr_stmt|;
name|mStencilSize
operator|=
literal|0
expr_stmt|;
name|mSurfaceType
operator|=
name|EGL_WINDOW_BIT
expr_stmt|;
name|mTransparentType
operator|=
name|EGL_NONE
expr_stmt|;
name|mTransparentRedValue
operator|=
name|EGL_DONT_CARE
expr_stmt|;
name|mTransparentGreenValue
operator|=
name|EGL_DONT_CARE
expr_stmt|;
name|mTransparentBlueValue
operator|=
name|EGL_DONT_CARE
expr_stmt|;
block|}
DECL|function|set
name|void
name|Config
operator|::
name|set
parameter_list|(
name|D3DDISPLAYMODE
name|displayMode
parameter_list|,
name|EGLint
name|minInterval
parameter_list|,
name|EGLint
name|maxInterval
parameter_list|,
name|D3DFORMAT
name|renderTargetFormat
parameter_list|,
name|D3DFORMAT
name|depthStencilFormat
parameter_list|,
name|EGLint
name|multiSample
parameter_list|,
name|EGLint
name|texWidth
parameter_list|,
name|EGLint
name|texHeight
parameter_list|)
block|{
name|mBindToTextureRGB
operator|=
name|EGL_FALSE
expr_stmt|;
name|mBindToTextureRGBA
operator|=
name|EGL_FALSE
expr_stmt|;
switch|switch
condition|(
name|renderTargetFormat
condition|)
block|{
case|case
name|D3DFMT_A1R5G5B5
case|:
name|mBufferSize
operator|=
literal|16
expr_stmt|;
name|mRedSize
operator|=
literal|5
expr_stmt|;
name|mGreenSize
operator|=
literal|5
expr_stmt|;
name|mBlueSize
operator|=
literal|5
expr_stmt|;
name|mAlphaSize
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|D3DFMT_A2R10G10B10
case|:
name|mBufferSize
operator|=
literal|32
expr_stmt|;
name|mRedSize
operator|=
literal|10
expr_stmt|;
name|mGreenSize
operator|=
literal|10
expr_stmt|;
name|mBlueSize
operator|=
literal|10
expr_stmt|;
name|mAlphaSize
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|D3DFMT_A8R8G8B8
case|:
name|mBufferSize
operator|=
literal|32
expr_stmt|;
name|mRedSize
operator|=
literal|8
expr_stmt|;
name|mGreenSize
operator|=
literal|8
expr_stmt|;
name|mBlueSize
operator|=
literal|8
expr_stmt|;
name|mAlphaSize
operator|=
literal|8
expr_stmt|;
name|mBindToTextureRGBA
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|D3DFMT_R5G6B5
case|:
name|mBufferSize
operator|=
literal|16
expr_stmt|;
name|mRedSize
operator|=
literal|5
expr_stmt|;
name|mGreenSize
operator|=
literal|6
expr_stmt|;
name|mBlueSize
operator|=
literal|5
expr_stmt|;
name|mAlphaSize
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|D3DFMT_X8R8G8B8
case|:
name|mBufferSize
operator|=
literal|32
expr_stmt|;
name|mRedSize
operator|=
literal|8
expr_stmt|;
name|mGreenSize
operator|=
literal|8
expr_stmt|;
name|mBlueSize
operator|=
literal|8
expr_stmt|;
name|mAlphaSize
operator|=
literal|0
expr_stmt|;
name|mBindToTextureRGB
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
comment|// Other formats should not be valid
block|}
name|mLuminanceSize
operator|=
literal|0
expr_stmt|;
name|mAlphaMaskSize
operator|=
literal|0
expr_stmt|;
name|mColorBufferType
operator|=
name|EGL_RGB_BUFFER
expr_stmt|;
name|mConfigCaveat
operator|=
operator|(
name|displayMode
operator|.
name|Format
operator|==
name|renderTargetFormat
operator|)
condition|?
name|EGL_NONE
else|:
name|EGL_SLOW_CONFIG
expr_stmt|;
name|mConfigID
operator|=
literal|0
expr_stmt|;
name|mConformant
operator|=
name|EGL_OPENGL_ES2_BIT
expr_stmt|;
switch|switch
condition|(
name|depthStencilFormat
condition|)
block|{
case|case
name|D3DFMT_UNKNOWN
case|:
name|mDepthSize
operator|=
literal|0
expr_stmt|;
name|mStencilSize
operator|=
literal|0
expr_stmt|;
break|break;
comment|//    case D3DFMT_D16_LOCKABLE:
comment|//      mDepthSize = 16;
comment|//      mStencilSize = 0;
comment|//      break;
case|case
name|D3DFMT_D32
case|:
name|mDepthSize
operator|=
literal|32
expr_stmt|;
name|mStencilSize
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|D3DFMT_D15S1
case|:
name|mDepthSize
operator|=
literal|15
expr_stmt|;
name|mStencilSize
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|D3DFMT_D24S8
case|:
name|mDepthSize
operator|=
literal|24
expr_stmt|;
name|mStencilSize
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|D3DFMT_D24X8
case|:
name|mDepthSize
operator|=
literal|24
expr_stmt|;
name|mStencilSize
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|D3DFMT_D24X4S4
case|:
name|mDepthSize
operator|=
literal|24
expr_stmt|;
name|mStencilSize
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|D3DFMT_D16
case|:
name|mDepthSize
operator|=
literal|16
expr_stmt|;
name|mStencilSize
operator|=
literal|0
expr_stmt|;
break|break;
comment|//    case D3DFMT_D32F_LOCKABLE:
comment|//      mDepthSize = 32;
comment|//      mStencilSize = 0;
comment|//      break;
comment|//    case D3DFMT_D24FS8:
comment|//      mDepthSize = 24;
comment|//      mStencilSize = 8;
comment|//      break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
name|mLevel
operator|=
literal|0
expr_stmt|;
name|mMatchNativePixmap
operator|=
name|EGL_NONE
expr_stmt|;
name|mMaxPBufferWidth
operator|=
name|texWidth
expr_stmt|;
name|mMaxPBufferHeight
operator|=
name|texHeight
expr_stmt|;
name|mMaxPBufferPixels
operator|=
name|texWidth
operator|*
name|texHeight
expr_stmt|;
name|mMaxSwapInterval
operator|=
name|maxInterval
expr_stmt|;
name|mMinSwapInterval
operator|=
name|minInterval
expr_stmt|;
name|mNativeRenderable
operator|=
name|EGL_FALSE
expr_stmt|;
name|mNativeVisualID
operator|=
literal|0
expr_stmt|;
name|mNativeVisualType
operator|=
literal|0
expr_stmt|;
name|mRenderableType
operator|=
name|EGL_OPENGL_ES2_BIT
expr_stmt|;
name|mSampleBuffers
operator|=
name|multiSample
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|mSamples
operator|=
name|multiSample
expr_stmt|;
name|mSurfaceType
operator|=
name|EGL_PBUFFER_BIT
operator||
name|EGL_WINDOW_BIT
operator||
name|EGL_SWAP_BEHAVIOR_PRESERVED_BIT
expr_stmt|;
name|mTransparentType
operator|=
name|EGL_NONE
expr_stmt|;
name|mTransparentRedValue
operator|=
literal|0
expr_stmt|;
name|mTransparentGreenValue
operator|=
literal|0
expr_stmt|;
name|mTransparentBlueValue
operator|=
literal|0
expr_stmt|;
block|}
DECL|function|getHandle
name|EGLConfig
name|Config
operator|::
name|getHandle
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|EGLConfig
operator|)
operator|(
name|size_t
operator|)
name|mConfigID
return|;
block|}
DECL|function|SortConfig
name|SortConfig
operator|::
name|SortConfig
parameter_list|(
specifier|const
name|EGLint
modifier|*
name|attribList
parameter_list|)
member_init_list|:
name|mWantRed
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mWantGreen
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mWantBlue
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mWantAlpha
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mWantLuminance
argument_list|(
literal|false
argument_list|)
block|{
name|scanForWantedComponents
argument_list|(
name|attribList
argument_list|)
expr_stmt|;
block|}
DECL|function|scanForWantedComponents
name|void
name|SortConfig
operator|::
name|scanForWantedComponents
parameter_list|(
specifier|const
name|EGLint
modifier|*
name|attribList
parameter_list|)
block|{
comment|// [EGL] section 3.4.1 page 24
comment|// Sorting rule #3: by larger total number of color bits, not considering
comment|// components that are 0 or don't-care.
for|for
control|(
specifier|const
name|EGLint
modifier|*
name|attr
init|=
name|attribList
init|;
name|attr
index|[
literal|0
index|]
operator|!=
name|EGL_NONE
condition|;
name|attr
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|attr
index|[
literal|1
index|]
operator|!=
literal|0
operator|&&
name|attr
index|[
literal|1
index|]
operator|!=
name|EGL_DONT_CARE
condition|)
block|{
switch|switch
condition|(
name|attr
index|[
literal|0
index|]
condition|)
block|{
case|case
name|EGL_RED_SIZE
case|:
name|mWantRed
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|EGL_GREEN_SIZE
case|:
name|mWantGreen
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|EGL_BLUE_SIZE
case|:
name|mWantBlue
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|EGL_ALPHA_SIZE
case|:
name|mWantAlpha
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|EGL_LUMINANCE_SIZE
case|:
name|mWantLuminance
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
DECL|function|wantedComponentsSize
name|EGLint
name|SortConfig
operator|::
name|wantedComponentsSize
parameter_list|(
specifier|const
name|Config
modifier|&
name|config
parameter_list|)
specifier|const
block|{
name|EGLint
name|total
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mWantRed
condition|)
name|total
operator|+=
name|config
operator|.
name|mRedSize
expr_stmt|;
if|if
condition|(
name|mWantGreen
condition|)
name|total
operator|+=
name|config
operator|.
name|mGreenSize
expr_stmt|;
if|if
condition|(
name|mWantBlue
condition|)
name|total
operator|+=
name|config
operator|.
name|mBlueSize
expr_stmt|;
if|if
condition|(
name|mWantAlpha
condition|)
name|total
operator|+=
name|config
operator|.
name|mAlphaSize
expr_stmt|;
if|if
condition|(
name|mWantLuminance
condition|)
name|total
operator|+=
name|config
operator|.
name|mLuminanceSize
expr_stmt|;
return|return
name|total
return|;
block|}
DECL|function|operator ()
name|bool
name|SortConfig
operator|::
name|operator
name|()
parameter_list|(
specifier|const
name|Config
modifier|*
name|x
parameter_list|,
specifier|const
name|Config
modifier|*
name|y
parameter_list|)
specifier|const
block|{
return|return
call|(
modifier|*
name|this
call|)
argument_list|(
operator|*
name|x
argument_list|,
operator|*
name|y
argument_list|)
return|;
block|}
DECL|function|operator ()
name|bool
name|SortConfig
operator|::
name|operator
name|()
parameter_list|(
specifier|const
name|Config
modifier|&
name|x
parameter_list|,
specifier|const
name|Config
modifier|&
name|y
parameter_list|)
specifier|const
block|{
DECL|macro|SORT
define|#
directive|define
name|SORT
parameter_list|(
name|attribute
parameter_list|)
define|\
value|if (x.attribute != y.attribute)            \         {                                          \             return x.attribute< y.attribute;      \         }
name|META_ASSERT
argument_list|(
name|EGL_NONE
operator|<
name|EGL_SLOW_CONFIG
operator|&&
name|EGL_SLOW_CONFIG
operator|<
name|EGL_NON_CONFORMANT_CONFIG
argument_list|)
expr_stmt|;
name|SORT
argument_list|(
name|mConfigCaveat
argument_list|)
expr_stmt|;
name|META_ASSERT
argument_list|(
name|EGL_RGB_BUFFER
operator|<
name|EGL_LUMINANCE_BUFFER
argument_list|)
expr_stmt|;
name|SORT
argument_list|(
name|mColorBufferType
argument_list|)
expr_stmt|;
comment|// By larger total number of color bits, only considering those that are requested to be> 0.
name|EGLint
name|xComponentsSize
init|=
name|wantedComponentsSize
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|EGLint
name|yComponentsSize
init|=
name|wantedComponentsSize
argument_list|(
name|y
argument_list|)
decl_stmt|;
if|if
condition|(
name|xComponentsSize
operator|!=
name|yComponentsSize
condition|)
block|{
return|return
name|xComponentsSize
operator|>
name|yComponentsSize
return|;
block|}
name|SORT
argument_list|(
name|mBufferSize
argument_list|)
expr_stmt|;
name|SORT
argument_list|(
name|mSampleBuffers
argument_list|)
expr_stmt|;
name|SORT
argument_list|(
name|mSamples
argument_list|)
expr_stmt|;
name|SORT
argument_list|(
name|mDepthSize
argument_list|)
expr_stmt|;
name|SORT
argument_list|(
name|mStencilSize
argument_list|)
expr_stmt|;
name|SORT
argument_list|(
name|mAlphaMaskSize
argument_list|)
expr_stmt|;
name|SORT
argument_list|(
name|mNativeVisualType
argument_list|)
expr_stmt|;
name|SORT
argument_list|(
name|mConfigID
argument_list|)
expr_stmt|;
DECL|macro|SORT
undef|#
directive|undef
name|SORT
return|return
literal|false
return|;
block|}
comment|// We'd like to use SortConfig to also eliminate duplicate configs.
comment|// This works as long as we never have two configs with different per-RGB-component layouts,
comment|// but the same total.
comment|// 5551 and 565 are different because R+G+B is different.
comment|// 5551 and 555 are different because bufferSize is different.
DECL|member|mSortAttribs
specifier|const
name|EGLint
name|ConfigSet
operator|::
name|mSortAttribs
index|[]
init|=
block|{
name|EGL_RED_SIZE
block|,
literal|1
block|,
name|EGL_GREEN_SIZE
block|,
literal|1
block|,
name|EGL_BLUE_SIZE
block|,
literal|1
block|,
name|EGL_LUMINANCE_SIZE
block|,
literal|1
block|,
comment|// BUT NOT ALPHA
name|EGL_NONE
block|}
decl_stmt|;
DECL|function|ConfigSet
name|ConfigSet
operator|::
name|ConfigSet
parameter_list|()
member_init_list|:
name|mSet
argument_list|(
name|SortConfig
argument_list|(
name|mSortAttribs
argument_list|)
argument_list|)
block|{ }
DECL|function|add
name|void
name|ConfigSet
operator|::
name|add
parameter_list|(
name|D3DDISPLAYMODE
name|displayMode
parameter_list|,
name|EGLint
name|minSwapInterval
parameter_list|,
name|EGLint
name|maxSwapInterval
parameter_list|,
name|D3DFORMAT
name|renderTargetFormat
parameter_list|,
name|D3DFORMAT
name|depthStencilFormat
parameter_list|,
name|EGLint
name|multiSample
parameter_list|,
name|EGLint
name|texWidth
parameter_list|,
name|EGLint
name|texHeight
parameter_list|)
block|{
name|Config
name|config
argument_list|(
name|displayMode
argument_list|,
name|minSwapInterval
argument_list|,
name|maxSwapInterval
argument_list|,
name|renderTargetFormat
argument_list|,
name|depthStencilFormat
argument_list|,
name|multiSample
argument_list|,
name|texWidth
argument_list|,
name|texHeight
argument_list|)
decl_stmt|;
name|mSet
operator|.
name|insert
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
DECL|function|size
name|size_t
name|ConfigSet
operator|::
name|size
parameter_list|()
specifier|const
block|{
return|return
name|mSet
operator|.
name|size
argument_list|()
return|;
block|}
DECL|function|getConfigs
name|bool
name|ConfigSet
operator|::
name|getConfigs
parameter_list|(
name|EGLConfig
modifier|*
name|configs
parameter_list|,
specifier|const
name|EGLint
modifier|*
name|attribList
parameter_list|,
name|EGLint
name|configSize
parameter_list|,
name|EGLint
modifier|*
name|numConfig
parameter_list|)
block|{
name|vector
argument_list|<
specifier|const
name|Config
modifier|*
argument_list|>
name|passed
decl_stmt|;
name|passed
operator|.
name|reserve
argument_list|(
name|mSet
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|config
init|=
name|mSet
operator|.
name|begin
argument_list|()
init|;
name|config
operator|!=
name|mSet
operator|.
name|end
argument_list|()
condition|;
name|config
operator|++
control|)
block|{
name|bool
name|match
init|=
literal|true
decl_stmt|;
specifier|const
name|EGLint
modifier|*
name|attribute
init|=
name|attribList
decl_stmt|;
while|while
condition|(
name|attribute
index|[
literal|0
index|]
operator|!=
name|EGL_NONE
condition|)
block|{
switch|switch
condition|(
name|attribute
index|[
literal|0
index|]
condition|)
block|{
case|case
name|EGL_BUFFER_SIZE
case|:
name|match
operator|=
name|config
operator|->
name|mBufferSize
operator|>=
name|attribute
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|EGL_ALPHA_SIZE
case|:
name|match
operator|=
name|config
operator|->
name|mAlphaSize
operator|>=
name|attribute
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|EGL_BLUE_SIZE
case|:
name|match
operator|=
name|config
operator|->
name|mBlueSize
operator|>=
name|attribute
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|EGL_GREEN_SIZE
case|:
name|match
operator|=
name|config
operator|->
name|mGreenSize
operator|>=
name|attribute
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|EGL_RED_SIZE
case|:
name|match
operator|=
name|config
operator|->
name|mRedSize
operator|>=
name|attribute
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|EGL_DEPTH_SIZE
case|:
name|match
operator|=
name|config
operator|->
name|mDepthSize
operator|>=
name|attribute
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|EGL_STENCIL_SIZE
case|:
name|match
operator|=
name|config
operator|->
name|mStencilSize
operator|>=
name|attribute
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|EGL_CONFIG_CAVEAT
case|:
name|match
operator|=
name|config
operator|->
name|mConfigCaveat
operator|==
operator|(
name|EGLenum
operator|)
name|attribute
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|EGL_CONFIG_ID
case|:
name|match
operator|=
name|config
operator|->
name|mConfigID
operator|==
name|attribute
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|EGL_LEVEL
case|:
name|match
operator|=
name|config
operator|->
name|mLevel
operator|>=
name|attribute
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|EGL_NATIVE_RENDERABLE
case|:
name|match
operator|=
name|config
operator|->
name|mNativeRenderable
operator|==
operator|(
name|EGLBoolean
operator|)
name|attribute
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|EGL_NATIVE_VISUAL_TYPE
case|:
name|match
operator|=
name|config
operator|->
name|mNativeVisualType
operator|==
name|attribute
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|EGL_SAMPLES
case|:
name|match
operator|=
name|config
operator|->
name|mSamples
operator|>=
name|attribute
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|EGL_SAMPLE_BUFFERS
case|:
name|match
operator|=
name|config
operator|->
name|mSampleBuffers
operator|>=
name|attribute
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|EGL_SURFACE_TYPE
case|:
name|match
operator|=
operator|(
name|config
operator|->
name|mSurfaceType
operator|&
name|attribute
index|[
literal|1
index|]
operator|)
operator|==
name|attribute
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|EGL_TRANSPARENT_TYPE
case|:
name|match
operator|=
name|config
operator|->
name|mTransparentType
operator|==
operator|(
name|EGLenum
operator|)
name|attribute
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|EGL_TRANSPARENT_BLUE_VALUE
case|:
name|match
operator|=
name|config
operator|->
name|mTransparentBlueValue
operator|==
name|attribute
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|EGL_TRANSPARENT_GREEN_VALUE
case|:
name|match
operator|=
name|config
operator|->
name|mTransparentGreenValue
operator|==
name|attribute
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|EGL_TRANSPARENT_RED_VALUE
case|:
name|match
operator|=
name|config
operator|->
name|mTransparentRedValue
operator|==
name|attribute
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|EGL_BIND_TO_TEXTURE_RGB
case|:
name|match
operator|=
name|config
operator|->
name|mBindToTextureRGB
operator|==
operator|(
name|EGLBoolean
operator|)
name|attribute
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|EGL_BIND_TO_TEXTURE_RGBA
case|:
name|match
operator|=
name|config
operator|->
name|mBindToTextureRGBA
operator|==
operator|(
name|EGLBoolean
operator|)
name|attribute
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|EGL_MIN_SWAP_INTERVAL
case|:
name|match
operator|=
name|config
operator|->
name|mMinSwapInterval
operator|==
name|attribute
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|EGL_MAX_SWAP_INTERVAL
case|:
name|match
operator|=
name|config
operator|->
name|mMaxSwapInterval
operator|==
name|attribute
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|EGL_LUMINANCE_SIZE
case|:
name|match
operator|=
name|config
operator|->
name|mLuminanceSize
operator|>=
name|attribute
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|EGL_ALPHA_MASK_SIZE
case|:
name|match
operator|=
name|config
operator|->
name|mAlphaMaskSize
operator|>=
name|attribute
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|EGL_COLOR_BUFFER_TYPE
case|:
name|match
operator|=
name|config
operator|->
name|mColorBufferType
operator|==
operator|(
name|EGLenum
operator|)
name|attribute
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|EGL_RENDERABLE_TYPE
case|:
name|match
operator|=
operator|(
name|config
operator|->
name|mRenderableType
operator|&
name|attribute
index|[
literal|1
index|]
operator|)
operator|==
name|attribute
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|EGL_MATCH_NATIVE_PIXMAP
case|:
name|match
operator|=
literal|false
expr_stmt|;
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
break|break;
case|case
name|EGL_CONFORMANT
case|:
name|match
operator|=
operator|(
name|config
operator|->
name|mConformant
operator|&
name|attribute
index|[
literal|1
index|]
operator|)
operator|==
name|attribute
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|EGL_MAX_PBUFFER_WIDTH
case|:
name|match
operator|=
name|config
operator|->
name|mMaxPBufferWidth
operator|>=
name|attribute
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|EGL_MAX_PBUFFER_HEIGHT
case|:
name|match
operator|=
name|config
operator|->
name|mMaxPBufferHeight
operator|>=
name|attribute
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|EGL_MAX_PBUFFER_PIXELS
case|:
name|match
operator|=
name|config
operator|->
name|mMaxPBufferPixels
operator|>=
name|attribute
index|[
literal|1
index|]
expr_stmt|;
break|break;
default|default:
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|match
condition|)
block|{
break|break;
block|}
name|attribute
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|match
condition|)
block|{
name|passed
operator|.
name|push_back
argument_list|(
operator|&
operator|*
name|config
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|configs
condition|)
block|{
name|sort
argument_list|(
name|passed
operator|.
name|begin
argument_list|()
argument_list|,
name|passed
operator|.
name|end
argument_list|()
argument_list|,
name|SortConfig
argument_list|(
name|attribList
argument_list|)
argument_list|)
expr_stmt|;
name|EGLint
name|index
decl_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|configSize
operator|&&
name|index
operator|<
cast|static_cast
argument_list|<
name|EGLint
argument_list|>
argument_list|(
name|passed
operator|.
name|size
argument_list|()
argument_list|)
condition|;
name|index
operator|++
control|)
block|{
name|configs
index|[
name|index
index|]
operator|=
name|passed
index|[
name|index
index|]
operator|->
name|getHandle
argument_list|()
expr_stmt|;
block|}
operator|*
name|numConfig
operator|=
name|index
expr_stmt|;
block|}
else|else
block|{
operator|*
name|numConfig
operator|=
name|passed
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|get
specifier|const
name|egl
operator|::
name|Config
modifier|*
name|ConfigSet
operator|::
name|get
parameter_list|(
name|EGLConfig
name|configHandle
parameter_list|)
block|{
for|for
control|(
name|Iterator
name|config
init|=
name|mSet
operator|.
name|begin
argument_list|()
init|;
name|config
operator|!=
name|mSet
operator|.
name|end
argument_list|()
condition|;
name|config
operator|++
control|)
block|{
if|if
condition|(
name|config
operator|->
name|getHandle
argument_list|()
operator|==
name|configHandle
condition|)
block|{
return|return
operator|&
operator|(
operator|*
name|config
operator|)
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
block|}
end_namespace
end_unit
