begin_unit
begin_comment
comment|/****************************************************************************\ Copyright (c) 2002, NVIDIA Corporation.  NVIDIA Corporation("NVIDIA") supplies this software to you in consideration of your agreement to the following terms, and your use, installation, modification or redistribution of this NVIDIA software constitutes acceptance of these terms.  If you do not agree with these terms, please do not use, install, modify or redistribute this NVIDIA software.  In consideration of your agreement to abide by the following terms, and subject to these terms, NVIDIA grants you a personal, non-exclusive license, under NVIDIA's copyrights in this original NVIDIA software (the "NVIDIA Software"), to use, reproduce, modify and redistribute the NVIDIA Software, with or without modifications, in source and/or binary forms; provided that if you redistribute the NVIDIA Software, you must retain the copyright notice of NVIDIA, this notice and the following text and disclaimers in all such redistributions of the NVIDIA Software. Neither the name, trademarks, service marks nor logos of NVIDIA Corporation may be used to endorse or promote products derived from the NVIDIA Software without specific prior written permission from NVIDIA. Except as expressly stated in this notice, no other rights or licenses express or implied, are granted by NVIDIA herein, including but not limited to any patent rights that may be infringed by your derivative works or by other works in which the NVIDIA Software may be incorporated. No hardware is licensed hereunder.   THE NVIDIA SOFTWARE IS BEING PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR ITS USE AND OPERATION EITHER ALONE OR IN COMBINATION WITH OTHER PRODUCTS.  IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, EXEMPLARY, CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, LOST PROFITS; PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) OR ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION OF THE NVIDIA SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. \****************************************************************************/
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// symbols.c
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_include
include|#
directive|include
file|"compiler/preprocessor/slglobals.h"
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_if
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4706
name|)
end_pragma
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|/////////////////////////////////// Symbol Table Variables: ///////////////////////////////////
end_comment
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////////////////////
end_comment
begin_decl_stmt
DECL|variable|ScopeList
name|Scope
modifier|*
name|ScopeList
init|=
name|NULL
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|CurrentScope
name|Scope
modifier|*
name|CurrentScope
init|=
name|NULL
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|GlobalScope
name|Scope
modifier|*
name|GlobalScope
init|=
name|NULL
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|unlinkScope
specifier|static
name|void
name|unlinkScope
parameter_list|(
name|void
modifier|*
name|_scope
parameter_list|)
block|{
name|Scope
modifier|*
name|scope
init|=
name|_scope
decl_stmt|;
if|if
condition|(
name|scope
operator|->
name|next
condition|)
name|scope
operator|->
name|next
operator|->
name|prev
operator|=
name|scope
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|scope
operator|->
name|prev
condition|)
name|scope
operator|->
name|prev
operator|->
name|next
operator|=
name|scope
operator|->
name|next
expr_stmt|;
else|else
name|ScopeList
operator|=
name|scope
operator|->
name|next
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * NewScope()  *  */
end_comment
begin_function
DECL|function|NewScopeInPool
name|Scope
modifier|*
name|NewScopeInPool
parameter_list|(
name|MemoryPool
modifier|*
name|pool
parameter_list|)
block|{
name|Scope
modifier|*
name|lScope
decl_stmt|;
name|lScope
operator|=
name|mem_Alloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|Scope
argument_list|)
argument_list|)
expr_stmt|;
name|lScope
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|lScope
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
name|lScope
operator|->
name|funScope
operator|=
name|NULL
expr_stmt|;
name|lScope
operator|->
name|symbols
operator|=
name|NULL
expr_stmt|;
name|lScope
operator|->
name|level
operator|=
literal|0
expr_stmt|;
name|lScope
operator|->
name|programs
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|lScope
operator|->
name|next
operator|=
name|ScopeList
operator|)
condition|)
name|ScopeList
operator|->
name|prev
operator|=
name|lScope
expr_stmt|;
name|lScope
operator|->
name|prev
operator|=
literal|0
expr_stmt|;
name|ScopeList
operator|=
name|lScope
expr_stmt|;
name|mem_AddCleanup
argument_list|(
name|pool
argument_list|,
name|unlinkScope
argument_list|,
name|lScope
argument_list|)
expr_stmt|;
return|return
name|lScope
return|;
block|}
end_function
begin_comment
comment|// NewScope
end_comment
begin_comment
comment|/*  * PushScope()  *  */
end_comment
begin_function
DECL|function|PushScope
name|void
name|PushScope
parameter_list|(
name|Scope
modifier|*
name|fScope
parameter_list|)
block|{
name|Scope
modifier|*
name|lScope
decl_stmt|;
if|if
condition|(
name|CurrentScope
condition|)
block|{
name|fScope
operator|->
name|level
operator|=
name|CurrentScope
operator|->
name|level
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|fScope
operator|->
name|level
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|GlobalScope
condition|)
block|{
comment|/* HACK - CTD -- if GlobalScope==NULL and level==1, we're                  * defining a function in the superglobal scope.  Things                  * will break if we leave the level as 1, so we arbitrarily                  * set it to 2 */
name|fScope
operator|->
name|level
operator|=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fScope
operator|->
name|level
operator|>=
literal|2
condition|)
block|{
name|lScope
operator|=
name|fScope
expr_stmt|;
while|while
condition|(
name|lScope
operator|->
name|level
operator|>
literal|2
condition|)
name|lScope
operator|=
name|lScope
operator|->
name|next
expr_stmt|;
name|fScope
operator|->
name|funScope
operator|=
name|lScope
expr_stmt|;
block|}
block|}
else|else
block|{
name|fScope
operator|->
name|level
operator|=
literal|0
expr_stmt|;
block|}
name|fScope
operator|->
name|parent
operator|=
name|CurrentScope
expr_stmt|;
name|CurrentScope
operator|=
name|fScope
expr_stmt|;
block|}
end_function
begin_comment
comment|// PushScope
end_comment
begin_comment
comment|/*  * PopScope()  *  */
end_comment
begin_function
DECL|function|PopScope
name|Scope
modifier|*
name|PopScope
parameter_list|(
name|void
parameter_list|)
block|{
name|Scope
modifier|*
name|lScope
decl_stmt|;
name|lScope
operator|=
name|CurrentScope
expr_stmt|;
if|if
condition|(
name|CurrentScope
condition|)
name|CurrentScope
operator|=
name|CurrentScope
operator|->
name|parent
expr_stmt|;
return|return
name|lScope
return|;
block|}
end_function
begin_comment
comment|// PopScope
end_comment
begin_comment
comment|/*  * NewSymbol() - Allocate a new symbol node;  *  */
end_comment
begin_function
DECL|function|NewSymbol
name|Symbol
modifier|*
name|NewSymbol
parameter_list|(
name|SourceLoc
modifier|*
name|loc
parameter_list|,
name|Scope
modifier|*
name|fScope
parameter_list|,
name|int
name|name
parameter_list|,
name|symbolkind
name|kind
parameter_list|)
block|{
name|Symbol
modifier|*
name|lSymb
decl_stmt|;
name|char
modifier|*
name|pch
decl_stmt|;
name|unsigned
name|int
name|ii
decl_stmt|;
name|lSymb
operator|=
operator|(
name|Symbol
operator|*
operator|)
name|mem_Alloc
argument_list|(
name|fScope
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|Symbol
argument_list|)
argument_list|)
expr_stmt|;
name|lSymb
operator|->
name|left
operator|=
name|NULL
expr_stmt|;
name|lSymb
operator|->
name|right
operator|=
name|NULL
expr_stmt|;
name|lSymb
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|lSymb
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|lSymb
operator|->
name|loc
operator|=
operator|*
name|loc
expr_stmt|;
name|lSymb
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
comment|// Clear union area:
name|pch
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|lSymb
operator|->
name|details
expr_stmt|;
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
sizeof|sizeof
argument_list|(
name|lSymb
operator|->
name|details
argument_list|)
condition|;
name|ii
operator|++
control|)
operator|*
name|pch
operator|++
operator|=
literal|0
expr_stmt|;
return|return
name|lSymb
return|;
block|}
end_function
begin_comment
comment|// NewSymbol
end_comment
begin_comment
comment|/*  * lAddToTree() - Using a binary tree is not a good idea for basic atom values because they  *         are generated in order.  We'll fix this later (by reversing the bit pattern).  */
end_comment
begin_function
DECL|function|lAddToTree
specifier|static
name|void
name|lAddToTree
parameter_list|(
name|Symbol
modifier|*
modifier|*
name|fSymbols
parameter_list|,
name|Symbol
modifier|*
name|fSymb
parameter_list|)
block|{
name|Symbol
modifier|*
name|lSymb
decl_stmt|;
name|int
name|lrev
decl_stmt|,
name|frev
decl_stmt|;
name|lSymb
operator|=
operator|*
name|fSymbols
expr_stmt|;
if|if
condition|(
name|lSymb
condition|)
block|{
name|frev
operator|=
name|GetReversedAtom
argument_list|(
name|atable
argument_list|,
name|fSymb
operator|->
name|name
argument_list|)
expr_stmt|;
while|while
condition|(
name|lSymb
condition|)
block|{
name|lrev
operator|=
name|GetReversedAtom
argument_list|(
name|atable
argument_list|,
name|lSymb
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lrev
operator|==
name|frev
condition|)
block|{
name|CPPErrorToInfoLog
argument_list|(
literal|"GetAtomString(atable, fSymb->name)"
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
if|if
condition|(
name|lrev
operator|>
name|frev
condition|)
block|{
if|if
condition|(
name|lSymb
operator|->
name|left
condition|)
block|{
name|lSymb
operator|=
name|lSymb
operator|->
name|left
expr_stmt|;
block|}
else|else
block|{
name|lSymb
operator|->
name|left
operator|=
name|fSymb
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|lSymb
operator|->
name|right
condition|)
block|{
name|lSymb
operator|=
name|lSymb
operator|->
name|right
expr_stmt|;
block|}
else|else
block|{
name|lSymb
operator|->
name|right
operator|=
name|fSymb
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
operator|*
name|fSymbols
operator|=
name|fSymb
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// lAddToTree
end_comment
begin_comment
comment|/*  * AddSymbol() - Add a variable, type, or function name to a scope.  *  */
end_comment
begin_function
DECL|function|AddSymbol
name|Symbol
modifier|*
name|AddSymbol
parameter_list|(
name|SourceLoc
modifier|*
name|loc
parameter_list|,
name|Scope
modifier|*
name|fScope
parameter_list|,
name|int
name|atom
parameter_list|,
name|symbolkind
name|kind
parameter_list|)
block|{
name|Symbol
modifier|*
name|lSymb
decl_stmt|;
if|if
condition|(
operator|!
name|fScope
condition|)
name|fScope
operator|=
name|CurrentScope
expr_stmt|;
name|lSymb
operator|=
name|NewSymbol
argument_list|(
name|loc
argument_list|,
name|fScope
argument_list|,
name|atom
argument_list|,
name|kind
argument_list|)
expr_stmt|;
name|lAddToTree
argument_list|(
operator|&
name|fScope
operator|->
name|symbols
argument_list|,
name|lSymb
argument_list|)
expr_stmt|;
return|return
name|lSymb
return|;
block|}
end_function
begin_comment
comment|// AddSymbol
end_comment
begin_comment
comment|/*********************************************************************************************/
end_comment
begin_comment
comment|/************************************ Symbol Semantic Functions ******************************/
end_comment
begin_comment
comment|/*********************************************************************************************/
end_comment
begin_comment
comment|/*  * LookUpLocalSymbol()  *  */
end_comment
begin_function
DECL|function|LookUpLocalSymbol
name|Symbol
modifier|*
name|LookUpLocalSymbol
parameter_list|(
name|Scope
modifier|*
name|fScope
parameter_list|,
name|int
name|atom
parameter_list|)
block|{
name|Symbol
modifier|*
name|lSymb
decl_stmt|;
name|int
name|rname
decl_stmt|,
name|ratom
decl_stmt|;
name|ratom
operator|=
name|GetReversedAtom
argument_list|(
name|atable
argument_list|,
name|atom
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fScope
condition|)
name|fScope
operator|=
name|CurrentScope
expr_stmt|;
name|lSymb
operator|=
name|fScope
operator|->
name|symbols
expr_stmt|;
while|while
condition|(
name|lSymb
condition|)
block|{
name|rname
operator|=
name|GetReversedAtom
argument_list|(
name|atable
argument_list|,
name|lSymb
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|rname
operator|==
name|ratom
condition|)
block|{
return|return
name|lSymb
return|;
block|}
else|else
block|{
if|if
condition|(
name|rname
operator|>
name|ratom
condition|)
block|{
name|lSymb
operator|=
name|lSymb
operator|->
name|left
expr_stmt|;
block|}
else|else
block|{
name|lSymb
operator|=
name|lSymb
operator|->
name|right
expr_stmt|;
block|}
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_comment
comment|// LookUpLocalSymbol
end_comment
begin_comment
comment|/*  * LookUpSymbol()  *  */
end_comment
begin_function
DECL|function|LookUpSymbol
name|Symbol
modifier|*
name|LookUpSymbol
parameter_list|(
name|Scope
modifier|*
name|fScope
parameter_list|,
name|int
name|atom
parameter_list|)
block|{
name|Symbol
modifier|*
name|lSymb
decl_stmt|;
if|if
condition|(
operator|!
name|fScope
condition|)
name|fScope
operator|=
name|CurrentScope
expr_stmt|;
while|while
condition|(
name|fScope
condition|)
block|{
name|lSymb
operator|=
name|LookUpLocalSymbol
argument_list|(
name|fScope
argument_list|,
name|atom
argument_list|)
expr_stmt|;
if|if
condition|(
name|lSymb
condition|)
return|return
name|lSymb
return|;
name|fScope
operator|=
name|fScope
operator|->
name|parent
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_comment
comment|// LookUpSymbol
end_comment
end_unit
