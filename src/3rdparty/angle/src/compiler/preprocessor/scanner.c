begin_unit
begin_comment
comment|/****************************************************************************\ Copyright (c) 2002, NVIDIA Corporation.  NVIDIA Corporation("NVIDIA") supplies this software to you in consideration of your agreement to the following terms, and your use, installation, modification or redistribution of this NVIDIA software constitutes acceptance of these terms.  If you do not agree with these terms, please do not use, install, modify or redistribute this NVIDIA software.  In consideration of your agreement to abide by the following terms, and subject to these terms, NVIDIA grants you a personal, non-exclusive license, under NVIDIA's copyrights in this original NVIDIA software (the "NVIDIA Software"), to use, reproduce, modify and redistribute the NVIDIA Software, with or without modifications, in source and/or binary forms; provided that if you redistribute the NVIDIA Software, you must retain the copyright notice of NVIDIA, this notice and the following text and disclaimers in all such redistributions of the NVIDIA Software. Neither the name, trademarks, service marks nor logos of NVIDIA Corporation may be used to endorse or promote products derived from the NVIDIA Software without specific prior written permission from NVIDIA. Except as expressly stated in this notice, no other rights or licenses express or implied, are granted by NVIDIA herein, including but not limited to any patent rights that may be infringed by your derivative works or by other works in which the NVIDIA Software may be incorporated. No hardware is licensed hereunder.   THE NVIDIA SOFTWARE IS BEING PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR ITS USE AND OPERATION EITHER ALONE OR IN COMBINATION WITH OTHER PRODUCTS.  IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, EXEMPLARY, CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, LOST PROFITS; PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) OR ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION OF THE NVIDIA SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. \****************************************************************************/
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// scanner.c
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|<assert.h>
end_include
begin_include
include|#
directive|include
file|<stdarg.h>
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_if
if|#
directive|if
literal|0
end_if
begin_include
include|#
directive|include
file|<ieeefp.h>
end_include
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|isinff
define|#
directive|define
name|isinff
parameter_list|(
name|x
parameter_list|)
value|(((*(int *)&(x)& 0x7f800000L)==0x7f800000L)&& \                        ((*(int *)&(x)& 0x007fffffL)==0000000000L))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"compiler/preprocessor/slglobals.h"
end_include
begin_include
include|#
directive|include
file|"compiler/util.h"
end_include
begin_typedef
DECL|struct|StringInputSrc
typedef|typedef
struct|struct
name|StringInputSrc
block|{
DECL|member|base
name|InputSrc
name|base
decl_stmt|;
DECL|member|p
name|char
modifier|*
name|p
decl_stmt|;
block|}
DECL|typedef|StringInputSrc
name|StringInputSrc
typedef|;
end_typedef
begin_function_decl
specifier|static
name|int
name|ScanFromString
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|eof_scan
specifier|static
name|int
name|eof_scan
parameter_list|(
name|InputSrc
modifier|*
name|is
parameter_list|,
name|yystypepp
modifier|*
name|yylvalpp
parameter_list|)
block|{
return|return
name|EOF
return|;
block|}
end_function
begin_comment
comment|// eof_scan
end_comment
begin_function
DECL|function|noop
specifier|static
name|void
name|noop
parameter_list|(
name|InputSrc
modifier|*
name|in
parameter_list|,
name|int
name|ch
parameter_list|,
name|yystypepp
modifier|*
name|yylvalpp
parameter_list|)
block|{}
end_function
begin_decl_stmt
DECL|variable|eof_inputsrc
specifier|static
name|InputSrc
name|eof_inputsrc
init|=
block|{
literal|0
block|,
operator|&
name|eof_scan
block|,
operator|&
name|eof_scan
block|,
operator|&
name|noop
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_function_decl
specifier|static
name|int
name|byte_scan
parameter_list|(
name|InputSrc
modifier|*
parameter_list|,
name|yystypepp
modifier|*
name|yylvalpp
parameter_list|)
function_decl|;
end_function_decl
begin_define
DECL|macro|EOL_SY
define|#
directive|define
name|EOL_SY
value|'\n'
end_define
begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_if
begin_define
DECL|macro|DBG_BREAKPOINT
define|#
directive|define
name|DBG_BREAKPOINT
parameter_list|()
value|__asm int 3
end_define
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_M_AMD64
argument_list|)
end_elif
begin_define
DECL|macro|DBG_BREAKPOINT
define|#
directive|define
name|DBG_BREAKPOINT
parameter_list|()
value|assert(!"Dbg_Breakpoint");
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|DBG_BREAKPOINT
define|#
directive|define
name|DBG_BREAKPOINT
parameter_list|()
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_M_AMD64
argument_list|)
end_if
begin_function
DECL|function|RDTSC
name|__int64
name|RDTSC
parameter_list|(
name|void
parameter_list|)
block|{
name|__int64
name|v
decl_stmt|;
asm|__asm __emit 0x0f
asm|__asm __emit 0x31
asm|__asm mov dword ptr v, eax
asm|__asm mov dword ptr v+4, edx
return|return
name|v
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|InitScanner
name|int
name|InitScanner
parameter_list|(
name|CPPStruct
modifier|*
name|cpp
parameter_list|)
block|{
comment|// Add various atoms needed by the CPP line scanner:
if|if
condition|(
operator|!
name|InitCPP
argument_list|()
condition|)
return|return
literal|0
return|;
name|cpp
operator|->
name|mostRecentToken
operator|=
literal|0
expr_stmt|;
name|cpp
operator|->
name|tokenLoc
operator|=
operator|&
name|cpp
operator|->
name|ltokenLoc
expr_stmt|;
name|cpp
operator|->
name|ltokenLoc
operator|.
name|file
operator|=
literal|0
expr_stmt|;
name|cpp
operator|->
name|ltokenLoc
operator|.
name|line
operator|=
literal|0
expr_stmt|;
name|cpp
operator|->
name|currentInput
operator|=
operator|&
name|eof_inputsrc
expr_stmt|;
name|cpp
operator|->
name|previous_token
operator|=
literal|'\n'
expr_stmt|;
name|cpp
operator|->
name|pastFirstStatement
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|// InitScanner
end_comment
begin_function
DECL|function|FreeScanner
name|int
name|FreeScanner
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|FreeCPP
argument_list|()
operator|)
return|;
block|}
end_function
begin_function
DECL|function|InitScannerInput
name|int
name|InitScannerInput
parameter_list|(
name|CPPStruct
modifier|*
name|cpp
parameter_list|,
name|int
name|count
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
name|string
index|[]
parameter_list|,
specifier|const
name|int
name|length
index|[]
parameter_list|)
block|{
name|cpp
operator|->
name|PaWhichStr
operator|=
literal|0
expr_stmt|;
name|cpp
operator|->
name|PaArgv
operator|=
name|string
expr_stmt|;
name|cpp
operator|->
name|PaArgc
operator|=
name|count
expr_stmt|;
name|cpp
operator|->
name|PaStrLen
operator|=
name|length
expr_stmt|;
name|ScanFromString
argument_list|(
name|string
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * str_getch()  * takes care of reading from multiple strings.  * returns the next-char from the input stream.  * returns EOF when the complete shader is parsed.  */
end_comment
begin_function
DECL|function|str_getch
specifier|static
name|int
name|str_getch
parameter_list|(
name|StringInputSrc
modifier|*
name|in
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|in
operator|->
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|in
operator|->
name|p
operator|==
literal|'\n'
condition|)
block|{
name|in
operator|->
name|base
operator|.
name|line
operator|++
expr_stmt|;
name|IncLineNumber
argument_list|()
expr_stmt|;
block|}
return|return
operator|*
name|in
operator|->
name|p
operator|++
return|;
block|}
if|if
condition|(
operator|++
operator|(
name|cpp
operator|->
name|PaWhichStr
operator|)
operator|<
name|cpp
operator|->
name|PaArgc
condition|)
block|{
name|free
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|SetStringNumber
argument_list|(
name|cpp
operator|->
name|PaWhichStr
argument_list|)
expr_stmt|;
name|SetLineNumber
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ScanFromString
argument_list|(
name|cpp
operator|->
name|PaArgv
index|[
name|cpp
operator|->
name|PaWhichStr
index|]
argument_list|)
expr_stmt|;
name|in
operator|=
operator|(
name|StringInputSrc
operator|*
operator|)
name|cpp
operator|->
name|currentInput
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|cpp
operator|->
name|currentInput
operator|=
name|in
operator|->
name|base
operator|.
name|prev
expr_stmt|;
name|cpp
operator|->
name|PaWhichStr
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
name|EOF
return|;
block|}
block|}
block|}
end_function
begin_comment
comment|// str_getch
end_comment
begin_function
DECL|function|str_ungetch
specifier|static
name|void
name|str_ungetch
parameter_list|(
name|StringInputSrc
modifier|*
name|in
parameter_list|,
name|int
name|ch
parameter_list|,
name|yystypepp
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
name|in
operator|->
name|p
index|[
operator|-
literal|1
index|]
operator|==
name|ch
condition|)
name|in
operator|->
name|p
operator|--
expr_stmt|;
else|else
block|{
operator|*
operator|(
name|in
operator|->
name|p
operator|)
operator|=
literal|'\0'
expr_stmt|;
comment|//this would take care of shifting to the previous string.
name|cpp
operator|->
name|PaWhichStr
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
block|{
name|in
operator|->
name|base
operator|.
name|line
operator|--
expr_stmt|;
name|DecLineNumber
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// str_ungetch
end_comment
begin_function
DECL|function|ScanFromString
name|int
name|ScanFromString
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|StringInputSrc
modifier|*
name|in
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|StringInputSrc
argument_list|)
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|in
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|StringInputSrc
argument_list|)
argument_list|)
expr_stmt|;
name|in
operator|->
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|s
expr_stmt|;
name|in
operator|->
name|base
operator|.
name|line
operator|=
literal|1
expr_stmt|;
name|in
operator|->
name|base
operator|.
name|scan
operator|=
name|byte_scan
expr_stmt|;
name|in
operator|->
name|base
operator|.
name|getch
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|InputSrc
operator|*
argument_list|,
name|yystypepp
operator|*
argument_list|)
operator|)
name|str_getch
expr_stmt|;
name|in
operator|->
name|base
operator|.
name|ungetch
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|InputSrc
operator|*
argument_list|,
name|int
argument_list|,
name|yystypepp
operator|*
argument_list|)
operator|)
name|str_ungetch
expr_stmt|;
name|in
operator|->
name|base
operator|.
name|prev
operator|=
name|cpp
operator|->
name|currentInput
expr_stmt|;
name|cpp
operator|->
name|currentInput
operator|=
operator|&
name|in
operator|->
name|base
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|// ScanFromString;
end_comment
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|/////////////////////////////////// Floating point constants: /////////////////////////////////
end_comment
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////////////////////
end_comment
begin_define
DECL|macro|APPEND_CHAR_S
define|#
directive|define
name|APPEND_CHAR_S
parameter_list|(
name|ch
parameter_list|,
name|str
parameter_list|,
name|len
parameter_list|,
name|max_len
parameter_list|)
define|\
value|if (len< max_len) { \           str[len++] = ch; \       } else if (!alreadyComplained) { \           CPPErrorToInfoLog("BUFFER OVERFLOW"); \           alreadyComplained = 1; \       }
end_define
begin_comment
comment|/*  * lFloatConst() - Scan a floating point constant.  Assumes that the scanner  *         has seen at least one digit, followed by either a decimal '.' or the  *         letter 'e'.  * ch - '.' or 'e'  * len - length of string already copied into yylvalpp->symbol_name.  */
end_comment
begin_function
DECL|function|lFloatConst
specifier|static
name|int
name|lFloatConst
parameter_list|(
name|int
name|ch
parameter_list|,
name|int
name|len
parameter_list|,
name|yystypepp
modifier|*
name|yylvalpp
parameter_list|)
block|{
name|int
name|alreadyComplained
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
operator|(
name|ch
operator|==
literal|'.'
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'e'
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'E'
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'.'
condition|)
block|{
do|do
block|{
name|APPEND_CHAR_S
argument_list|(
name|ch
argument_list|,
name|yylvalpp
operator|->
name|symbol_name
argument_list|,
name|len
argument_list|,
name|MAX_SYMBOL_NAME_LEN
argument_list|)
expr_stmt|;
name|ch
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|getch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
do|;
block|}
comment|// Exponent:
if|if
condition|(
name|ch
operator|==
literal|'e'
operator|||
name|ch
operator|==
literal|'E'
condition|)
block|{
name|APPEND_CHAR_S
argument_list|(
name|ch
argument_list|,
name|yylvalpp
operator|->
name|symbol_name
argument_list|,
name|len
argument_list|,
name|MAX_SYMBOL_NAME_LEN
argument_list|)
expr_stmt|;
name|ch
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|getch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'+'
condition|)
block|{
name|APPEND_CHAR_S
argument_list|(
name|ch
argument_list|,
name|yylvalpp
operator|->
name|symbol_name
argument_list|,
name|len
argument_list|,
name|MAX_SYMBOL_NAME_LEN
argument_list|)
expr_stmt|;
name|ch
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|getch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'-'
condition|)
block|{
name|APPEND_CHAR_S
argument_list|(
name|ch
argument_list|,
name|yylvalpp
operator|->
name|symbol_name
argument_list|,
name|len
argument_list|,
name|MAX_SYMBOL_NAME_LEN
argument_list|)
expr_stmt|;
name|ch
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|getch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
block|{
while|while
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
block|{
name|APPEND_CHAR_S
argument_list|(
name|ch
argument_list|,
name|yylvalpp
operator|->
name|symbol_name
argument_list|,
name|len
argument_list|,
name|MAX_SYMBOL_NAME_LEN
argument_list|)
expr_stmt|;
name|ch
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|getch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|CPPErrorToInfoLog
argument_list|(
literal|"EXPONENT INVALID"
argument_list|)
expr_stmt|;
block|}
block|}
name|cpp
operator|->
name|currentInput
operator|->
name|ungetch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|ch
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|len
operator|<=
name|MAX_SYMBOL_NAME_LEN
argument_list|)
expr_stmt|;
name|yylvalpp
operator|->
name|symbol_name
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|yylvalpp
operator|->
name|sc_fval
operator|=
operator|(
name|float
operator|)
name|atof_dot
argument_list|(
name|yylvalpp
operator|->
name|symbol_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|isinff
argument_list|(
name|yylvalpp
operator|->
name|sc_fval
argument_list|)
condition|)
block|{
name|CPPErrorToInfoLog
argument_list|(
literal|"FLOAT CONSTANT OVERFLOW"
argument_list|)
expr_stmt|;
block|}
return|return
name|CPP_FLOATCONSTANT
return|;
block|}
end_function
begin_comment
comment|// lFloatConst
end_comment
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|///////////////////////////////////////// Normal Scanner //////////////////////////////////////
end_comment
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////////////////////
end_comment
begin_function
DECL|function|byte_scan
specifier|static
name|int
name|byte_scan
parameter_list|(
name|InputSrc
modifier|*
name|in
parameter_list|,
name|yystypepp
modifier|*
name|yylvalpp
parameter_list|)
block|{
name|char
name|string_val
index|[
name|MAX_STRING_LEN
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|alreadyComplained
init|=
literal|0
decl_stmt|;
name|int
name|len
decl_stmt|,
name|ch
decl_stmt|,
name|ii
decl_stmt|,
name|ival
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|yylvalpp
operator|->
name|sc_int
operator|=
literal|0
expr_stmt|;
name|ch
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|getch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
while|while
condition|(
name|ch
operator|==
literal|' '
operator|||
name|ch
operator|==
literal|'\t'
operator|||
name|ch
operator|==
literal|'\r'
condition|)
block|{
name|yylvalpp
operator|->
name|sc_int
operator|=
literal|1
expr_stmt|;
name|ch
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|getch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
name|cpp
operator|->
name|ltokenLoc
operator|.
name|file
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|name
expr_stmt|;
name|cpp
operator|->
name|ltokenLoc
operator|.
name|line
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|line
expr_stmt|;
name|alreadyComplained
operator|=
literal|0
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
default|default:
return|return
name|ch
return|;
comment|// Single character token
case|case
name|EOF
case|:
return|return
operator|-
literal|1
return|;
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
case|case
literal|'_'
case|:
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'h'
case|:
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
case|case
literal|'l'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'o'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
do|do
block|{
name|APPEND_CHAR_S
argument_list|(
name|ch
argument_list|,
name|yylvalpp
operator|->
name|symbol_name
argument_list|,
name|len
argument_list|,
name|MAX_SYMBOL_NAME_LEN
argument_list|)
expr_stmt|;
name|ch
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|getch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
operator|)
operator|||
name|ch
operator|==
literal|'_'
condition|)
do|;
name|assert
argument_list|(
name|len
operator|<=
name|MAX_SYMBOL_NAME_LEN
argument_list|)
expr_stmt|;
name|yylvalpp
operator|->
name|symbol_name
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cpp
operator|->
name|currentInput
operator|->
name|ungetch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|ch
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
name|yylvalpp
operator|->
name|sc_ident
operator|=
name|LookUpAddString
argument_list|(
name|atable
argument_list|,
name|yylvalpp
operator|->
name|symbol_name
argument_list|)
expr_stmt|;
return|return
name|CPP_IDENTIFIER
return|;
break|break;
case|case
literal|'0'
case|:
name|APPEND_CHAR_S
argument_list|(
name|ch
argument_list|,
name|yylvalpp
operator|->
name|symbol_name
argument_list|,
name|len
argument_list|,
name|MAX_SYMBOL_NAME_LEN
argument_list|)
expr_stmt|;
name|ch
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|getch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'x'
operator|||
name|ch
operator|==
literal|'X'
condition|)
block|{
comment|// hexadecimal integer constants
name|APPEND_CHAR_S
argument_list|(
name|ch
argument_list|,
name|yylvalpp
operator|->
name|symbol_name
argument_list|,
name|len
argument_list|,
name|MAX_SYMBOL_NAME_LEN
argument_list|)
expr_stmt|;
name|ch
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|getch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
operator|)
operator|||
operator|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'F'
operator|)
operator|||
operator|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'f'
operator|)
condition|)
block|{
name|ival
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|ival
operator|<=
literal|0x0fffffff
operator|)
operator|&&
operator|(
name|len
operator|<
name|MAX_SYMBOL_NAME_LEN
operator|)
condition|)
block|{
name|yylvalpp
operator|->
name|symbol_name
index|[
name|len
operator|++
index|]
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
block|{
name|ii
operator|=
name|ch
operator|-
literal|'0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'F'
condition|)
block|{
name|ii
operator|=
name|ch
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
block|}
else|else
block|{
name|ii
operator|=
name|ch
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
block|}
name|ival
operator|=
operator|(
name|ival
operator|<<
literal|4
operator|)
operator||
name|ii
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|alreadyComplained
condition|)
block|{
name|CPPErrorToInfoLog
argument_list|(
literal|"HEX CONSTANT OVERFLOW"
argument_list|)
expr_stmt|;
name|alreadyComplained
operator|=
literal|1
expr_stmt|;
block|}
name|ch
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|getch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
operator|)
operator|||
operator|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'F'
operator|)
operator|||
operator|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'f'
operator|)
condition|)
do|;
block|}
else|else
block|{
name|CPPErrorToInfoLog
argument_list|(
literal|"HEX CONSTANT INVALID"
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|len
operator|<=
name|MAX_SYMBOL_NAME_LEN
argument_list|)
expr_stmt|;
name|yylvalpp
operator|->
name|symbol_name
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cpp
operator|->
name|currentInput
operator|->
name|ungetch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|ch
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
name|yylvalpp
operator|->
name|sc_int
operator|=
name|ival
expr_stmt|;
return|return
name|CPP_INTCONSTANT
return|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'7'
condition|)
block|{
comment|// octal integer constants
name|ival
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|ival
operator|<=
literal|0x1fffffff
operator|)
operator|&&
operator|(
name|len
operator|<
name|MAX_SYMBOL_NAME_LEN
operator|)
condition|)
block|{
name|yylvalpp
operator|->
name|symbol_name
index|[
name|len
operator|++
index|]
operator|=
name|ch
expr_stmt|;
name|ii
operator|=
name|ch
operator|-
literal|'0'
expr_stmt|;
name|ival
operator|=
operator|(
name|ival
operator|<<
literal|3
operator|)
operator||
name|ii
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|alreadyComplained
condition|)
block|{
name|CPPErrorToInfoLog
argument_list|(
literal|"OCT CONSTANT OVERFLOW"
argument_list|)
expr_stmt|;
name|alreadyComplained
operator|=
literal|1
expr_stmt|;
block|}
name|ch
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|getch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'7'
condition|)
do|;
if|if
condition|(
name|ch
operator|==
literal|'.'
operator|||
name|ch
operator|==
literal|'e'
operator|||
name|ch
operator|==
literal|'f'
operator|||
name|ch
operator|==
literal|'h'
operator|||
name|ch
operator|==
literal|'x'
operator|||
name|ch
operator|==
literal|'E'
condition|)
return|return
name|lFloatConst
argument_list|(
name|ch
argument_list|,
name|len
argument_list|,
name|yylvalpp
argument_list|)
return|;
name|assert
argument_list|(
name|len
operator|<=
name|MAX_SYMBOL_NAME_LEN
argument_list|)
expr_stmt|;
name|yylvalpp
operator|->
name|symbol_name
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cpp
operator|->
name|currentInput
operator|->
name|ungetch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|ch
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
name|yylvalpp
operator|->
name|sc_int
operator|=
name|ival
expr_stmt|;
return|return
name|CPP_INTCONSTANT
return|;
block|}
else|else
block|{
name|cpp
operator|->
name|currentInput
operator|->
name|ungetch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|ch
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
name|ch
operator|=
literal|'0'
expr_stmt|;
block|}
comment|// Fall through...
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
do|do
block|{
name|APPEND_CHAR_S
argument_list|(
name|ch
argument_list|,
name|yylvalpp
operator|->
name|symbol_name
argument_list|,
name|len
argument_list|,
name|MAX_SYMBOL_NAME_LEN
argument_list|)
expr_stmt|;
name|ch
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|getch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
do|;
if|if
condition|(
name|ch
operator|==
literal|'.'
operator|||
name|ch
operator|==
literal|'e'
operator|||
name|ch
operator|==
literal|'E'
condition|)
block|{
return|return
name|lFloatConst
argument_list|(
name|ch
argument_list|,
name|len
argument_list|,
name|yylvalpp
argument_list|)
return|;
block|}
else|else
block|{
name|assert
argument_list|(
name|len
operator|<=
name|MAX_SYMBOL_NAME_LEN
argument_list|)
expr_stmt|;
name|yylvalpp
operator|->
name|symbol_name
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cpp
operator|->
name|currentInput
operator|->
name|ungetch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|ch
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
name|ival
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|len
condition|;
name|ii
operator|++
control|)
block|{
name|ch
operator|=
name|yylvalpp
operator|->
name|symbol_name
index|[
name|ii
index|]
operator|-
literal|'0'
expr_stmt|;
name|ival
operator|=
name|ival
operator|*
literal|10
operator|+
name|ch
expr_stmt|;
if|if
condition|(
operator|(
name|ival
operator|>
literal|214748364
operator|)
operator|||
operator|(
name|ival
operator|==
literal|214748364
operator|&&
name|ch
operator|>=
literal|8
operator|)
condition|)
block|{
name|CPPErrorToInfoLog
argument_list|(
literal|"INTEGER CONSTANT OVERFLOW"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|yylvalpp
operator|->
name|sc_int
operator|=
name|ival
expr_stmt|;
if|if
condition|(
name|ival
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|yylvalpp
operator|->
name|symbol_name
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
return|return
name|CPP_INTCONSTANT
return|;
block|}
break|break;
case|case
literal|'-'
case|:
name|ch
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|getch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'-'
condition|)
block|{
return|return
name|CPP_DEC_OP
return|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'='
condition|)
block|{
return|return
name|CPP_SUB_ASSIGN
return|;
block|}
else|else
block|{
name|cpp
operator|->
name|currentInput
operator|->
name|ungetch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|ch
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
return|return
literal|'-'
return|;
block|}
case|case
literal|'+'
case|:
name|ch
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|getch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'+'
condition|)
block|{
return|return
name|CPP_INC_OP
return|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'='
condition|)
block|{
return|return
name|CPP_ADD_ASSIGN
return|;
block|}
else|else
block|{
name|cpp
operator|->
name|currentInput
operator|->
name|ungetch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|ch
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
return|return
literal|'+'
return|;
block|}
case|case
literal|'*'
case|:
name|ch
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|getch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'='
condition|)
block|{
return|return
name|CPP_MUL_ASSIGN
return|;
block|}
else|else
block|{
name|cpp
operator|->
name|currentInput
operator|->
name|ungetch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|ch
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
return|return
literal|'*'
return|;
block|}
case|case
literal|'%'
case|:
name|ch
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|getch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'='
condition|)
block|{
return|return
name|CPP_MOD_ASSIGN
return|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'>'
condition|)
block|{
return|return
name|CPP_RIGHT_BRACE
return|;
block|}
else|else
block|{
name|cpp
operator|->
name|currentInput
operator|->
name|ungetch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|ch
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
return|return
literal|'%'
return|;
block|}
case|case
literal|':'
case|:
name|ch
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|getch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'>'
condition|)
block|{
return|return
name|CPP_RIGHT_BRACKET
return|;
block|}
else|else
block|{
name|cpp
operator|->
name|currentInput
operator|->
name|ungetch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|ch
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
return|return
literal|':'
return|;
block|}
case|case
literal|'^'
case|:
name|ch
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|getch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'^'
condition|)
block|{
return|return
name|CPP_XOR_OP
return|;
block|}
else|else
block|{
if|if
condition|(
name|ch
operator|==
literal|'='
condition|)
return|return
name|CPP_XOR_ASSIGN
return|;
else|else
block|{
name|cpp
operator|->
name|currentInput
operator|->
name|ungetch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|ch
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
return|return
literal|'^'
return|;
block|}
block|}
case|case
literal|'='
case|:
name|ch
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|getch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'='
condition|)
block|{
return|return
name|CPP_EQ_OP
return|;
block|}
else|else
block|{
name|cpp
operator|->
name|currentInput
operator|->
name|ungetch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|ch
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
return|return
literal|'='
return|;
block|}
case|case
literal|'!'
case|:
name|ch
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|getch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'='
condition|)
block|{
return|return
name|CPP_NE_OP
return|;
block|}
else|else
block|{
name|cpp
operator|->
name|currentInput
operator|->
name|ungetch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|ch
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
return|return
literal|'!'
return|;
block|}
case|case
literal|'|'
case|:
name|ch
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|getch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'|'
condition|)
block|{
return|return
name|CPP_OR_OP
return|;
block|}
else|else
block|{
if|if
condition|(
name|ch
operator|==
literal|'='
condition|)
return|return
name|CPP_OR_ASSIGN
return|;
else|else
block|{
name|cpp
operator|->
name|currentInput
operator|->
name|ungetch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|ch
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
return|return
literal|'|'
return|;
block|}
block|}
case|case
literal|'&'
case|:
name|ch
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|getch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'&'
condition|)
block|{
return|return
name|CPP_AND_OP
return|;
block|}
else|else
block|{
if|if
condition|(
name|ch
operator|==
literal|'='
condition|)
return|return
name|CPP_AND_ASSIGN
return|;
else|else
block|{
name|cpp
operator|->
name|currentInput
operator|->
name|ungetch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|ch
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
return|return
literal|'&'
return|;
block|}
block|}
case|case
literal|'<'
case|:
name|ch
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|getch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'<'
condition|)
block|{
name|ch
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|getch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'='
condition|)
return|return
name|CPP_LEFT_ASSIGN
return|;
else|else
block|{
name|cpp
operator|->
name|currentInput
operator|->
name|ungetch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|ch
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
return|return
name|CPP_LEFT_OP
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ch
operator|==
literal|'='
condition|)
block|{
return|return
name|CPP_LE_OP
return|;
block|}
else|else
block|{
if|if
condition|(
name|ch
operator|==
literal|'%'
condition|)
return|return
name|CPP_LEFT_BRACE
return|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|':'
condition|)
return|return
name|CPP_LEFT_BRACKET
return|;
else|else
block|{
name|cpp
operator|->
name|currentInput
operator|->
name|ungetch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|ch
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
return|return
literal|'<'
return|;
block|}
block|}
block|}
case|case
literal|'>'
case|:
name|ch
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|getch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'>'
condition|)
block|{
name|ch
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|getch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'='
condition|)
return|return
name|CPP_RIGHT_ASSIGN
return|;
else|else
block|{
name|cpp
operator|->
name|currentInput
operator|->
name|ungetch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|ch
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
return|return
name|CPP_RIGHT_OP
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ch
operator|==
literal|'='
condition|)
block|{
return|return
name|CPP_GE_OP
return|;
block|}
else|else
block|{
name|cpp
operator|->
name|currentInput
operator|->
name|ungetch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|ch
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
return|return
literal|'>'
return|;
block|}
block|}
case|case
literal|'.'
case|:
name|ch
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|getch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
block|{
name|cpp
operator|->
name|currentInput
operator|->
name|ungetch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|ch
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
return|return
name|lFloatConst
argument_list|(
literal|'.'
argument_list|,
literal|0
argument_list|,
name|yylvalpp
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|ch
operator|==
literal|'.'
condition|)
block|{
return|return
operator|-
literal|1
return|;
comment|// Special EOF hack
block|}
else|else
block|{
name|cpp
operator|->
name|currentInput
operator|->
name|ungetch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|ch
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
return|return
literal|'.'
return|;
block|}
block|}
case|case
literal|'/'
case|:
name|ch
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|getch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'/'
condition|)
block|{
do|do
block|{
name|ch
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|getch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ch
operator|!=
literal|'\n'
operator|&&
name|ch
operator|!=
name|EOF
condition|)
do|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|'\n'
return|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'*'
condition|)
block|{
name|ch
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|getch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
do|do
block|{
while|while
condition|(
name|ch
operator|!=
literal|'*'
condition|)
block|{
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
name|CPPErrorToInfoLog
argument_list|(
literal|"EOF IN COMMENT"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ch
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|getch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
name|ch
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|getch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
name|CPPErrorToInfoLog
argument_list|(
literal|"EOF IN COMMENT"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
do|while
condition|(
name|ch
operator|!=
literal|'/'
condition|)
do|;
comment|// Go try it again...
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'='
condition|)
block|{
return|return
name|CPP_DIV_ASSIGN
return|;
block|}
else|else
block|{
name|cpp
operator|->
name|currentInput
operator|->
name|ungetch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|ch
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
return|return
literal|'/'
return|;
block|}
break|break;
case|case
literal|'"'
case|:
name|ch
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|getch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
while|while
condition|(
name|ch
operator|!=
literal|'"'
operator|&&
name|ch
operator|!=
literal|'\n'
operator|&&
name|ch
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
name|CPPErrorToInfoLog
argument_list|(
literal|"The line continuation character (\\) is not part of the OpenGL ES Shading Language"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|APPEND_CHAR_S
argument_list|(
name|ch
argument_list|,
name|string_val
argument_list|,
name|len
argument_list|,
name|MAX_STRING_LEN
argument_list|)
expr_stmt|;
name|ch
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|getch
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|assert
argument_list|(
name|len
operator|<=
name|MAX_STRING_LEN
argument_list|)
expr_stmt|;
name|string_val
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'"'
condition|)
block|{
name|yylvalpp
operator|->
name|sc_ident
operator|=
name|LookUpAddString
argument_list|(
name|atable
argument_list|,
name|string_val
argument_list|)
expr_stmt|;
return|return
name|CPP_STRCONSTANT
return|;
block|}
else|else
block|{
name|CPPErrorToInfoLog
argument_list|(
literal|"EOL IN STRING"
argument_list|)
expr_stmt|;
return|return
name|ERROR_SY
return|;
block|}
break|break;
block|}
block|}
block|}
end_function
begin_comment
comment|// byte_scan
end_comment
begin_function
DECL|function|yylex_CPP
name|int
name|yylex_CPP
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|maxSize
parameter_list|)
block|{
name|yystypepp
name|yylvalpp
decl_stmt|;
name|int
name|token
init|=
literal|'\n'
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
name|tokenString
init|=
literal|0
decl_stmt|;
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
operator|&
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_EOF
argument_list|(
name|token
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|token
operator|<
literal|0
condition|)
block|{
comment|// This check may need to be improved to support UTF-8
comment|// characters in comments.
name|CPPErrorToInfoLog
argument_list|(
literal|"preprocessor encountered non-ASCII character in shader source"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|token
operator|==
literal|'#'
condition|)
block|{
if|if
condition|(
name|cpp
operator|->
name|previous_token
operator|==
literal|'\n'
operator|||
name|cpp
operator|->
name|previous_token
operator|==
literal|0
condition|)
block|{
name|token
operator|=
name|readCPPline
argument_list|(
operator|&
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_EOF
argument_list|(
name|token
argument_list|)
condition|)
return|return
literal|0
return|;
continue|continue;
block|}
else|else
block|{
name|CPPErrorToInfoLog
argument_list|(
literal|"preprocessor command must not be preceded by any other statement in that line"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|cpp
operator|->
name|previous_token
operator|=
name|token
expr_stmt|;
comment|// expand macros
if|if
condition|(
name|token
operator|==
name|CPP_IDENTIFIER
operator|&&
name|MacroExpand
argument_list|(
name|yylvalpp
operator|.
name|sc_ident
argument_list|,
operator|&
name|yylvalpp
argument_list|)
condition|)
block|{
name|cpp
operator|->
name|pastFirstStatement
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|token
operator|==
literal|'\n'
condition|)
continue|continue;
name|cpp
operator|->
name|pastFirstStatement
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|CPP_IDENTIFIER
condition|)
block|{
name|tokenString
operator|=
name|GetStringOfAtom
argument_list|(
name|atable
argument_list|,
name|yylvalpp
operator|.
name|sc_ident
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|CPP_FLOATCONSTANT
operator|||
name|token
operator|==
name|CPP_INTCONSTANT
condition|)
block|{
name|tokenString
operator|=
name|yylvalpp
operator|.
name|symbol_name
expr_stmt|;
block|}
else|else
block|{
name|tokenString
operator|=
name|GetStringOfAtom
argument_list|(
name|atable
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tokenString
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|tokenString
argument_list|)
decl_stmt|;
name|cpp
operator|->
name|tokensBeforeEOF
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|maxSize
condition|)
block|{
return|return
name|maxSize
return|;
block|}
elseif|else
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
name|tokenString
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
block|}
end_function
begin_comment
comment|// yylex
end_comment
begin_comment
comment|//Checks if the token just read is EOF or not.
end_comment
begin_function
DECL|function|check_EOF
name|int
name|check_EOF
parameter_list|(
name|int
name|token
parameter_list|)
block|{
if|if
condition|(
name|token
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|cpp
operator|->
name|ifdepth
operator|>
literal|0
condition|)
block|{
name|CPPErrorToInfoLog
argument_list|(
literal|"#endif missing!! Compilation stopped"
argument_list|)
expr_stmt|;
name|cpp
operator|->
name|CompileError
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|/////////////////////////////////////// End of scanner.c //////////////////////////////////////
end_comment
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////////////////////
end_comment
end_unit
