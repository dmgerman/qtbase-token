begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2011 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|"Token.h"
end_include
begin_include
include|#
directive|include
file|<cassert>
end_include
begin_include
include|#
directive|include
file|"numeric_lex.h"
end_include
begin_namespace
DECL|namespace|pp
namespace|namespace
name|pp
block|{
DECL|function|reset
name|void
name|Token
operator|::
name|reset
parameter_list|()
block|{
name|type
operator|=
literal|0
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
name|location
operator|=
name|SourceLocation
argument_list|()
expr_stmt|;
name|text
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|function|equals
name|bool
name|Token
operator|::
name|equals
parameter_list|(
specifier|const
name|Token
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|type
operator|==
name|other
operator|.
name|type
operator|)
operator|&&
operator|(
name|flags
operator|==
name|other
operator|.
name|flags
operator|)
operator|&&
operator|(
name|location
operator|==
name|other
operator|.
name|location
operator|)
operator|&&
operator|(
name|text
operator|==
name|other
operator|.
name|text
operator|)
return|;
block|}
DECL|function|setAtStartOfLine
name|void
name|Token
operator|::
name|setAtStartOfLine
parameter_list|(
name|bool
name|start
parameter_list|)
block|{
if|if
condition|(
name|start
condition|)
name|flags
operator||=
name|AT_START_OF_LINE
expr_stmt|;
else|else
name|flags
operator|&=
operator|~
name|AT_START_OF_LINE
expr_stmt|;
block|}
DECL|function|setHasLeadingSpace
name|void
name|Token
operator|::
name|setHasLeadingSpace
parameter_list|(
name|bool
name|space
parameter_list|)
block|{
if|if
condition|(
name|space
condition|)
name|flags
operator||=
name|HAS_LEADING_SPACE
expr_stmt|;
else|else
name|flags
operator|&=
operator|~
name|HAS_LEADING_SPACE
expr_stmt|;
block|}
DECL|function|setExpansionDisabled
name|void
name|Token
operator|::
name|setExpansionDisabled
parameter_list|(
name|bool
name|disable
parameter_list|)
block|{
if|if
condition|(
name|disable
condition|)
name|flags
operator||=
name|EXPANSION_DISABLED
expr_stmt|;
else|else
name|flags
operator|&=
operator|~
name|EXPANSION_DISABLED
expr_stmt|;
block|}
DECL|function|iValue
name|bool
name|Token
operator|::
name|iValue
parameter_list|(
name|int
modifier|*
name|value
parameter_list|)
specifier|const
block|{
name|assert
argument_list|(
name|type
operator|==
name|CONST_INT
argument_list|)
expr_stmt|;
return|return
name|numeric_lex_int
argument_list|(
name|text
argument_list|,
name|value
argument_list|)
return|;
block|}
DECL|function|uValue
name|bool
name|Token
operator|::
name|uValue
parameter_list|(
name|unsigned
name|int
modifier|*
name|value
parameter_list|)
specifier|const
block|{
name|assert
argument_list|(
name|type
operator|==
name|CONST_INT
argument_list|)
expr_stmt|;
return|return
name|numeric_lex_int
argument_list|(
name|text
argument_list|,
name|value
argument_list|)
return|;
block|}
DECL|function|fValue
name|bool
name|Token
operator|::
name|fValue
parameter_list|(
name|float
modifier|*
name|value
parameter_list|)
specifier|const
block|{
name|assert
argument_list|(
name|type
operator|==
name|CONST_FLOAT
argument_list|)
expr_stmt|;
return|return
name|numeric_lex_float
argument_list|(
name|text
argument_list|,
name|value
argument_list|)
return|;
block|}
DECL|function|operator <<
name|std
operator|::
name|ostream
modifier|&
name|operator
name|<<
parameter_list|(
name|std
operator|::
name|ostream
modifier|&
name|out
parameter_list|,
specifier|const
name|Token
modifier|&
name|token
parameter_list|)
block|{
if|if
condition|(
name|token
operator|.
name|hasLeadingSpace
argument_list|()
condition|)
name|out
operator|<<
literal|" "
expr_stmt|;
name|out
operator|<<
name|token
operator|.
name|text
expr_stmt|;
return|return
name|out
return|;
block|}
block|}
end_namespace
begin_comment
comment|// namespace pp
end_comment
end_unit
