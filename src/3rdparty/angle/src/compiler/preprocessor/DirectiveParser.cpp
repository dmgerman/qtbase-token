begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2011-2013 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|"DirectiveParser.h"
end_include
begin_include
include|#
directive|include
file|<cassert>
end_include
begin_include
include|#
directive|include
file|<cstdlib>
end_include
begin_include
include|#
directive|include
file|<sstream>
end_include
begin_include
include|#
directive|include
file|"DiagnosticsBase.h"
end_include
begin_include
include|#
directive|include
file|"DirectiveHandlerBase.h"
end_include
begin_include
include|#
directive|include
file|"ExpressionParser.h"
end_include
begin_include
include|#
directive|include
file|"MacroExpander.h"
end_include
begin_include
include|#
directive|include
file|"Token.h"
end_include
begin_include
include|#
directive|include
file|"Tokenizer.h"
end_include
begin_namespace
namespace|namespace
block|{
DECL|enum|DirectiveType
enum|enum
name|DirectiveType
block|{
DECL|enumerator|DIRECTIVE_NONE
name|DIRECTIVE_NONE
block|,
DECL|enumerator|DIRECTIVE_DEFINE
name|DIRECTIVE_DEFINE
block|,
DECL|enumerator|DIRECTIVE_UNDEF
name|DIRECTIVE_UNDEF
block|,
DECL|enumerator|DIRECTIVE_IF
name|DIRECTIVE_IF
block|,
DECL|enumerator|DIRECTIVE_IFDEF
name|DIRECTIVE_IFDEF
block|,
DECL|enumerator|DIRECTIVE_IFNDEF
name|DIRECTIVE_IFNDEF
block|,
DECL|enumerator|DIRECTIVE_ELSE
name|DIRECTIVE_ELSE
block|,
DECL|enumerator|DIRECTIVE_ELIF
name|DIRECTIVE_ELIF
block|,
DECL|enumerator|DIRECTIVE_ENDIF
name|DIRECTIVE_ENDIF
block|,
DECL|enumerator|DIRECTIVE_ERROR
name|DIRECTIVE_ERROR
block|,
DECL|enumerator|DIRECTIVE_PRAGMA
name|DIRECTIVE_PRAGMA
block|,
DECL|enumerator|DIRECTIVE_EXTENSION
name|DIRECTIVE_EXTENSION
block|,
DECL|enumerator|DIRECTIVE_VERSION
name|DIRECTIVE_VERSION
block|,
DECL|enumerator|DIRECTIVE_LINE
name|DIRECTIVE_LINE
block|}
enum|;
DECL|function|getDirective
name|DirectiveType
name|getDirective
parameter_list|(
specifier|const
name|pp
operator|::
name|Token
modifier|*
name|token
parameter_list|)
block|{
specifier|static
specifier|const
name|std
operator|::
name|string
name|kDirectiveDefine
argument_list|(
literal|"define"
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|std
operator|::
name|string
name|kDirectiveUndef
argument_list|(
literal|"undef"
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|std
operator|::
name|string
name|kDirectiveIf
argument_list|(
literal|"if"
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|std
operator|::
name|string
name|kDirectiveIfdef
argument_list|(
literal|"ifdef"
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|std
operator|::
name|string
name|kDirectiveIfndef
argument_list|(
literal|"ifndef"
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|std
operator|::
name|string
name|kDirectiveElse
argument_list|(
literal|"else"
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|std
operator|::
name|string
name|kDirectiveElif
argument_list|(
literal|"elif"
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|std
operator|::
name|string
name|kDirectiveEndif
argument_list|(
literal|"endif"
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|std
operator|::
name|string
name|kDirectiveError
argument_list|(
literal|"error"
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|std
operator|::
name|string
name|kDirectivePragma
argument_list|(
literal|"pragma"
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|std
operator|::
name|string
name|kDirectiveExtension
argument_list|(
literal|"extension"
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|std
operator|::
name|string
name|kDirectiveVersion
argument_list|(
literal|"version"
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|std
operator|::
name|string
name|kDirectiveLine
argument_list|(
literal|"line"
argument_list|)
decl_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|pp
operator|::
name|Token
operator|::
name|IDENTIFIER
condition|)
return|return
name|DIRECTIVE_NONE
return|;
if|if
condition|(
name|token
operator|->
name|text
operator|==
name|kDirectiveDefine
condition|)
return|return
name|DIRECTIVE_DEFINE
return|;
if|if
condition|(
name|token
operator|->
name|text
operator|==
name|kDirectiveUndef
condition|)
return|return
name|DIRECTIVE_UNDEF
return|;
if|if
condition|(
name|token
operator|->
name|text
operator|==
name|kDirectiveIf
condition|)
return|return
name|DIRECTIVE_IF
return|;
if|if
condition|(
name|token
operator|->
name|text
operator|==
name|kDirectiveIfdef
condition|)
return|return
name|DIRECTIVE_IFDEF
return|;
if|if
condition|(
name|token
operator|->
name|text
operator|==
name|kDirectiveIfndef
condition|)
return|return
name|DIRECTIVE_IFNDEF
return|;
if|if
condition|(
name|token
operator|->
name|text
operator|==
name|kDirectiveElse
condition|)
return|return
name|DIRECTIVE_ELSE
return|;
if|if
condition|(
name|token
operator|->
name|text
operator|==
name|kDirectiveElif
condition|)
return|return
name|DIRECTIVE_ELIF
return|;
if|if
condition|(
name|token
operator|->
name|text
operator|==
name|kDirectiveEndif
condition|)
return|return
name|DIRECTIVE_ENDIF
return|;
if|if
condition|(
name|token
operator|->
name|text
operator|==
name|kDirectiveError
condition|)
return|return
name|DIRECTIVE_ERROR
return|;
if|if
condition|(
name|token
operator|->
name|text
operator|==
name|kDirectivePragma
condition|)
return|return
name|DIRECTIVE_PRAGMA
return|;
if|if
condition|(
name|token
operator|->
name|text
operator|==
name|kDirectiveExtension
condition|)
return|return
name|DIRECTIVE_EXTENSION
return|;
if|if
condition|(
name|token
operator|->
name|text
operator|==
name|kDirectiveVersion
condition|)
return|return
name|DIRECTIVE_VERSION
return|;
if|if
condition|(
name|token
operator|->
name|text
operator|==
name|kDirectiveLine
condition|)
return|return
name|DIRECTIVE_LINE
return|;
return|return
name|DIRECTIVE_NONE
return|;
block|}
DECL|function|isConditionalDirective
name|bool
name|isConditionalDirective
parameter_list|(
name|DirectiveType
name|directive
parameter_list|)
block|{
switch|switch
condition|(
name|directive
condition|)
block|{
case|case
name|DIRECTIVE_IF
case|:
case|case
name|DIRECTIVE_IFDEF
case|:
case|case
name|DIRECTIVE_IFNDEF
case|:
case|case
name|DIRECTIVE_ELSE
case|:
case|case
name|DIRECTIVE_ELIF
case|:
case|case
name|DIRECTIVE_ENDIF
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|// Returns true if the token represents End Of Directive.
DECL|function|isEOD
name|bool
name|isEOD
parameter_list|(
specifier|const
name|pp
operator|::
name|Token
modifier|*
name|token
parameter_list|)
block|{
return|return
operator|(
name|token
operator|->
name|type
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|token
operator|->
name|type
operator|==
name|pp
operator|::
name|Token
operator|::
name|LAST
operator|)
return|;
block|}
DECL|function|skipUntilEOD
name|void
name|skipUntilEOD
parameter_list|(
name|pp
operator|::
name|Lexer
modifier|*
name|lexer
parameter_list|,
name|pp
operator|::
name|Token
modifier|*
name|token
parameter_list|)
block|{
while|while
condition|(
operator|!
name|isEOD
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|lexer
operator|->
name|lex
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|isMacroNameReserved
name|bool
name|isMacroNameReserved
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|name
parameter_list|)
block|{
comment|// Names prefixed with "GL_" are reserved.
if|if
condition|(
name|name
operator|.
name|substr
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|)
operator|==
literal|"GL_"
condition|)
return|return
literal|true
return|;
comment|// Names containing two consecutive underscores are reserved.
if|if
condition|(
name|name
operator|.
name|find
argument_list|(
literal|"__"
argument_list|)
operator|!=
name|std
operator|::
name|string
operator|::
name|npos
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
DECL|function|isMacroPredefined
name|bool
name|isMacroPredefined
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|name
parameter_list|,
specifier|const
name|pp
operator|::
name|MacroSet
modifier|&
name|macroSet
parameter_list|)
block|{
name|pp
operator|::
name|MacroSet
operator|::
name|const_iterator
name|iter
init|=
name|macroSet
operator|.
name|find
argument_list|(
name|name
argument_list|)
decl_stmt|;
return|return
name|iter
operator|!=
name|macroSet
operator|.
name|end
argument_list|()
condition|?
name|iter
operator|->
name|second
operator|.
name|predefined
else|:
literal|false
return|;
block|}
block|}
end_namespace
begin_comment
comment|// namespace anonymous
end_comment
begin_namespace
DECL|namespace|pp
namespace|namespace
name|pp
block|{
DECL|class|DefinedParser
class|class
name|DefinedParser
super|:
specifier|public
name|Lexer
block|{
public|public:
DECL|function|DefinedParser
name|DefinedParser
parameter_list|(
name|Lexer
modifier|*
name|lexer
parameter_list|,
specifier|const
name|MacroSet
modifier|*
name|macroSet
parameter_list|,
name|Diagnostics
modifier|*
name|diagnostics
parameter_list|)
member_init_list|:
name|mLexer
argument_list|(
name|lexer
argument_list|)
member_init_list|,
name|mMacroSet
argument_list|(
name|macroSet
argument_list|)
member_init_list|,
name|mDiagnostics
argument_list|(
name|diagnostics
argument_list|)
block|{     }
protected|protected:
DECL|function|lex
specifier|virtual
name|void
name|lex
parameter_list|(
name|Token
modifier|*
name|token
parameter_list|)
block|{
specifier|static
specifier|const
name|std
operator|::
name|string
name|kDefined
argument_list|(
literal|"defined"
argument_list|)
decl_stmt|;
name|mLexer
operator|->
name|lex
argument_list|(
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|Token
operator|::
name|IDENTIFIER
condition|)
return|return;
if|if
condition|(
name|token
operator|->
name|text
operator|!=
name|kDefined
condition|)
return|return;
name|bool
name|paren
init|=
literal|false
decl_stmt|;
name|mLexer
operator|->
name|lex
argument_list|(
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
literal|'('
condition|)
block|{
name|paren
operator|=
literal|true
expr_stmt|;
name|mLexer
operator|->
name|lex
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|Token
operator|::
name|IDENTIFIER
condition|)
block|{
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_UNEXPECTED_TOKEN
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
name|skipUntilEOD
argument_list|(
name|mLexer
argument_list|,
name|token
argument_list|)
expr_stmt|;
return|return;
block|}
name|MacroSet
operator|::
name|const_iterator
name|iter
init|=
name|mMacroSet
operator|->
name|find
argument_list|(
name|token
operator|->
name|text
argument_list|)
decl_stmt|;
name|std
operator|::
name|string
name|expression
init|=
name|iter
operator|!=
name|mMacroSet
operator|->
name|end
argument_list|()
condition|?
literal|"1"
else|:
literal|"0"
decl_stmt|;
if|if
condition|(
name|paren
condition|)
block|{
name|mLexer
operator|->
name|lex
argument_list|(
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
literal|')'
condition|)
block|{
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_UNEXPECTED_TOKEN
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
name|skipUntilEOD
argument_list|(
name|mLexer
argument_list|,
name|token
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|// We have a valid defined operator.
comment|// Convert the current token into a CONST_INT token.
name|token
operator|->
name|type
operator|=
name|Token
operator|::
name|CONST_INT
expr_stmt|;
name|token
operator|->
name|text
operator|=
name|expression
expr_stmt|;
block|}
private|private:
DECL|member|mLexer
name|Lexer
modifier|*
name|mLexer
decl_stmt|;
DECL|member|mMacroSet
specifier|const
name|MacroSet
modifier|*
name|mMacroSet
decl_stmt|;
DECL|member|mDiagnostics
name|Diagnostics
modifier|*
name|mDiagnostics
decl_stmt|;
block|}
class|;
DECL|function|DirectiveParser
name|DirectiveParser
operator|::
name|DirectiveParser
parameter_list|(
name|Tokenizer
modifier|*
name|tokenizer
parameter_list|,
name|MacroSet
modifier|*
name|macroSet
parameter_list|,
name|Diagnostics
modifier|*
name|diagnostics
parameter_list|,
name|DirectiveHandler
modifier|*
name|directiveHandler
parameter_list|)
member_init_list|:
name|mPastFirstStatement
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mTokenizer
argument_list|(
name|tokenizer
argument_list|)
member_init_list|,
name|mMacroSet
argument_list|(
name|macroSet
argument_list|)
member_init_list|,
name|mDiagnostics
argument_list|(
name|diagnostics
argument_list|)
member_init_list|,
name|mDirectiveHandler
argument_list|(
name|directiveHandler
argument_list|)
block|{ }
DECL|function|lex
name|void
name|DirectiveParser
operator|::
name|lex
parameter_list|(
name|Token
modifier|*
name|token
parameter_list|)
block|{
do|do
block|{
name|mTokenizer
operator|->
name|lex
argument_list|(
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|Token
operator|::
name|PP_HASH
condition|)
block|{
name|parseDirective
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|mPastFirstStatement
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|Token
operator|::
name|LAST
condition|)
block|{
if|if
condition|(
operator|!
name|mConditionalStack
operator|.
name|empty
argument_list|()
condition|)
block|{
specifier|const
name|ConditionalBlock
modifier|&
name|block
init|=
name|mConditionalStack
operator|.
name|back
argument_list|()
decl_stmt|;
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_CONDITIONAL_UNTERMINATED
argument_list|,
name|block
operator|.
name|location
argument_list|,
name|block
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
do|while
condition|(
name|skipping
argument_list|()
operator|||
operator|(
name|token
operator|->
name|type
operator|==
literal|'\n'
operator|)
condition|)
do|;
name|mPastFirstStatement
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|parseDirective
name|void
name|DirectiveParser
operator|::
name|parseDirective
parameter_list|(
name|Token
modifier|*
name|token
parameter_list|)
block|{
name|assert
argument_list|(
name|token
operator|->
name|type
operator|==
name|Token
operator|::
name|PP_HASH
argument_list|)
expr_stmt|;
name|mTokenizer
operator|->
name|lex
argument_list|(
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|isEOD
argument_list|(
name|token
argument_list|)
condition|)
block|{
comment|// Empty Directive.
return|return;
block|}
name|DirectiveType
name|directive
init|=
name|getDirective
argument_list|(
name|token
argument_list|)
decl_stmt|;
comment|// While in an excluded conditional block/group,
comment|// we only parse conditional directives.
if|if
condition|(
name|skipping
argument_list|()
operator|&&
operator|!
name|isConditionalDirective
argument_list|(
name|directive
argument_list|)
condition|)
block|{
name|skipUntilEOD
argument_list|(
name|mTokenizer
argument_list|,
name|token
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|directive
condition|)
block|{
case|case
name|DIRECTIVE_NONE
case|:
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_DIRECTIVE_INVALID_NAME
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
name|skipUntilEOD
argument_list|(
name|mTokenizer
argument_list|,
name|token
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIRECTIVE_DEFINE
case|:
name|parseDefine
argument_list|(
name|token
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIRECTIVE_UNDEF
case|:
name|parseUndef
argument_list|(
name|token
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIRECTIVE_IF
case|:
name|parseIf
argument_list|(
name|token
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIRECTIVE_IFDEF
case|:
name|parseIfdef
argument_list|(
name|token
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIRECTIVE_IFNDEF
case|:
name|parseIfndef
argument_list|(
name|token
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIRECTIVE_ELSE
case|:
name|parseElse
argument_list|(
name|token
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIRECTIVE_ELIF
case|:
name|parseElif
argument_list|(
name|token
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIRECTIVE_ENDIF
case|:
name|parseEndif
argument_list|(
name|token
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIRECTIVE_ERROR
case|:
name|parseError
argument_list|(
name|token
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIRECTIVE_PRAGMA
case|:
name|parsePragma
argument_list|(
name|token
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIRECTIVE_EXTENSION
case|:
name|parseExtension
argument_list|(
name|token
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIRECTIVE_VERSION
case|:
name|parseVersion
argument_list|(
name|token
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIRECTIVE_LINE
case|:
name|parseLine
argument_list|(
name|token
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
block|}
name|skipUntilEOD
argument_list|(
name|mTokenizer
argument_list|,
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|Token
operator|::
name|LAST
condition|)
block|{
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_EOF_IN_DIRECTIVE
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|parseDefine
name|void
name|DirectiveParser
operator|::
name|parseDefine
parameter_list|(
name|Token
modifier|*
name|token
parameter_list|)
block|{
name|assert
argument_list|(
name|getDirective
argument_list|(
name|token
argument_list|)
operator|==
name|DIRECTIVE_DEFINE
argument_list|)
expr_stmt|;
name|mTokenizer
operator|->
name|lex
argument_list|(
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|Token
operator|::
name|IDENTIFIER
condition|)
block|{
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_UNEXPECTED_TOKEN
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|isMacroPredefined
argument_list|(
name|token
operator|->
name|text
argument_list|,
operator|*
name|mMacroSet
argument_list|)
condition|)
block|{
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_MACRO_PREDEFINED_REDEFINED
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|isMacroNameReserved
argument_list|(
name|token
operator|->
name|text
argument_list|)
condition|)
block|{
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_MACRO_NAME_RESERVED
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
return|return;
block|}
name|Macro
name|macro
decl_stmt|;
name|macro
operator|.
name|type
operator|=
name|Macro
operator|::
name|kTypeObj
expr_stmt|;
name|macro
operator|.
name|name
operator|=
name|token
operator|->
name|text
expr_stmt|;
name|mTokenizer
operator|->
name|lex
argument_list|(
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
literal|'('
operator|&&
operator|!
name|token
operator|->
name|hasLeadingSpace
argument_list|()
condition|)
block|{
comment|// Function-like macro. Collect arguments.
name|macro
operator|.
name|type
operator|=
name|Macro
operator|::
name|kTypeFunc
expr_stmt|;
do|do
block|{
name|mTokenizer
operator|->
name|lex
argument_list|(
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|Token
operator|::
name|IDENTIFIER
condition|)
break|break;
name|macro
operator|.
name|parameters
operator|.
name|push_back
argument_list|(
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
name|mTokenizer
operator|->
name|lex
argument_list|(
name|token
argument_list|)
expr_stmt|;
comment|// Get ','.
block|}
do|while
condition|(
name|token
operator|->
name|type
operator|==
literal|','
condition|)
do|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
literal|')'
condition|)
block|{
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_UNEXPECTED_TOKEN
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
return|return;
block|}
name|mTokenizer
operator|->
name|lex
argument_list|(
name|token
argument_list|)
expr_stmt|;
comment|// Get ')'.
block|}
while|while
condition|(
operator|(
name|token
operator|->
name|type
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
name|token
operator|->
name|type
operator|!=
name|Token
operator|::
name|LAST
operator|)
condition|)
block|{
comment|// Reset the token location because it is unnecessary in replacement
comment|// list. Resetting it also allows us to reuse Token::equals() to
comment|// compare macros.
name|token
operator|->
name|location
operator|=
name|SourceLocation
argument_list|()
expr_stmt|;
name|macro
operator|.
name|replacements
operator|.
name|push_back
argument_list|(
operator|*
name|token
argument_list|)
expr_stmt|;
name|mTokenizer
operator|->
name|lex
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|macro
operator|.
name|replacements
operator|.
name|empty
argument_list|()
condition|)
block|{
comment|// Whitespace preceding the replacement list is not considered part of
comment|// the replacement list for either form of macro.
name|macro
operator|.
name|replacements
operator|.
name|front
argument_list|()
operator|.
name|setHasLeadingSpace
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// Check for macro redefinition.
name|MacroSet
operator|::
name|const_iterator
name|iter
init|=
name|mMacroSet
operator|->
name|find
argument_list|(
name|macro
operator|.
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|iter
operator|!=
name|mMacroSet
operator|->
name|end
argument_list|()
operator|&&
operator|!
name|macro
operator|.
name|equals
argument_list|(
name|iter
operator|->
name|second
argument_list|)
condition|)
block|{
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_MACRO_REDEFINED
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|macro
operator|.
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|mMacroSet
operator|->
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|macro
operator|.
name|name
argument_list|,
name|macro
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|parseUndef
name|void
name|DirectiveParser
operator|::
name|parseUndef
parameter_list|(
name|Token
modifier|*
name|token
parameter_list|)
block|{
name|assert
argument_list|(
name|getDirective
argument_list|(
name|token
argument_list|)
operator|==
name|DIRECTIVE_UNDEF
argument_list|)
expr_stmt|;
name|mTokenizer
operator|->
name|lex
argument_list|(
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|Token
operator|::
name|IDENTIFIER
condition|)
block|{
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_UNEXPECTED_TOKEN
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
return|return;
block|}
name|MacroSet
operator|::
name|iterator
name|iter
init|=
name|mMacroSet
operator|->
name|find
argument_list|(
name|token
operator|->
name|text
argument_list|)
decl_stmt|;
if|if
condition|(
name|iter
operator|!=
name|mMacroSet
operator|->
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|iter
operator|->
name|second
operator|.
name|predefined
condition|)
block|{
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_MACRO_PREDEFINED_UNDEFINED
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mMacroSet
operator|->
name|erase
argument_list|(
name|iter
argument_list|)
expr_stmt|;
block|}
block|}
name|mTokenizer
operator|->
name|lex
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
DECL|function|parseIf
name|void
name|DirectiveParser
operator|::
name|parseIf
parameter_list|(
name|Token
modifier|*
name|token
parameter_list|)
block|{
name|assert
argument_list|(
name|getDirective
argument_list|(
name|token
argument_list|)
operator|==
name|DIRECTIVE_IF
argument_list|)
expr_stmt|;
name|parseConditionalIf
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
DECL|function|parseIfdef
name|void
name|DirectiveParser
operator|::
name|parseIfdef
parameter_list|(
name|Token
modifier|*
name|token
parameter_list|)
block|{
name|assert
argument_list|(
name|getDirective
argument_list|(
name|token
argument_list|)
operator|==
name|DIRECTIVE_IFDEF
argument_list|)
expr_stmt|;
name|parseConditionalIf
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
DECL|function|parseIfndef
name|void
name|DirectiveParser
operator|::
name|parseIfndef
parameter_list|(
name|Token
modifier|*
name|token
parameter_list|)
block|{
name|assert
argument_list|(
name|getDirective
argument_list|(
name|token
argument_list|)
operator|==
name|DIRECTIVE_IFNDEF
argument_list|)
expr_stmt|;
name|parseConditionalIf
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
DECL|function|parseElse
name|void
name|DirectiveParser
operator|::
name|parseElse
parameter_list|(
name|Token
modifier|*
name|token
parameter_list|)
block|{
name|assert
argument_list|(
name|getDirective
argument_list|(
name|token
argument_list|)
operator|==
name|DIRECTIVE_ELSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mConditionalStack
operator|.
name|empty
argument_list|()
condition|)
block|{
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_CONDITIONAL_ELSE_WITHOUT_IF
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
name|skipUntilEOD
argument_list|(
name|mTokenizer
argument_list|,
name|token
argument_list|)
expr_stmt|;
return|return;
block|}
name|ConditionalBlock
modifier|&
name|block
init|=
name|mConditionalStack
operator|.
name|back
argument_list|()
decl_stmt|;
if|if
condition|(
name|block
operator|.
name|skipBlock
condition|)
block|{
comment|// No diagnostics. Just skip the whole line.
name|skipUntilEOD
argument_list|(
name|mTokenizer
argument_list|,
name|token
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|block
operator|.
name|foundElseGroup
condition|)
block|{
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_CONDITIONAL_ELSE_AFTER_ELSE
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
name|skipUntilEOD
argument_list|(
name|mTokenizer
argument_list|,
name|token
argument_list|)
expr_stmt|;
return|return;
block|}
name|block
operator|.
name|foundElseGroup
operator|=
literal|true
expr_stmt|;
name|block
operator|.
name|skipGroup
operator|=
name|block
operator|.
name|foundValidGroup
expr_stmt|;
name|block
operator|.
name|foundValidGroup
operator|=
literal|true
expr_stmt|;
comment|// Warn if there are extra tokens after #else.
name|mTokenizer
operator|->
name|lex
argument_list|(
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isEOD
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_CONDITIONAL_UNEXPECTED_TOKEN
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
name|skipUntilEOD
argument_list|(
name|mTokenizer
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|parseElif
name|void
name|DirectiveParser
operator|::
name|parseElif
parameter_list|(
name|Token
modifier|*
name|token
parameter_list|)
block|{
name|assert
argument_list|(
name|getDirective
argument_list|(
name|token
argument_list|)
operator|==
name|DIRECTIVE_ELIF
argument_list|)
expr_stmt|;
if|if
condition|(
name|mConditionalStack
operator|.
name|empty
argument_list|()
condition|)
block|{
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_CONDITIONAL_ELIF_WITHOUT_IF
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
name|skipUntilEOD
argument_list|(
name|mTokenizer
argument_list|,
name|token
argument_list|)
expr_stmt|;
return|return;
block|}
name|ConditionalBlock
modifier|&
name|block
init|=
name|mConditionalStack
operator|.
name|back
argument_list|()
decl_stmt|;
if|if
condition|(
name|block
operator|.
name|skipBlock
condition|)
block|{
comment|// No diagnostics. Just skip the whole line.
name|skipUntilEOD
argument_list|(
name|mTokenizer
argument_list|,
name|token
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|block
operator|.
name|foundElseGroup
condition|)
block|{
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_CONDITIONAL_ELIF_AFTER_ELSE
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
name|skipUntilEOD
argument_list|(
name|mTokenizer
argument_list|,
name|token
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|block
operator|.
name|foundValidGroup
condition|)
block|{
comment|// Do not parse the expression.
comment|// Also be careful not to emit a diagnostic.
name|block
operator|.
name|skipGroup
operator|=
literal|true
expr_stmt|;
name|skipUntilEOD
argument_list|(
name|mTokenizer
argument_list|,
name|token
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|expression
init|=
name|parseExpressionIf
argument_list|(
name|token
argument_list|)
decl_stmt|;
name|block
operator|.
name|skipGroup
operator|=
name|expression
operator|==
literal|0
expr_stmt|;
name|block
operator|.
name|foundValidGroup
operator|=
name|expression
operator|!=
literal|0
expr_stmt|;
block|}
DECL|function|parseEndif
name|void
name|DirectiveParser
operator|::
name|parseEndif
parameter_list|(
name|Token
modifier|*
name|token
parameter_list|)
block|{
name|assert
argument_list|(
name|getDirective
argument_list|(
name|token
argument_list|)
operator|==
name|DIRECTIVE_ENDIF
argument_list|)
expr_stmt|;
if|if
condition|(
name|mConditionalStack
operator|.
name|empty
argument_list|()
condition|)
block|{
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_CONDITIONAL_ENDIF_WITHOUT_IF
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
name|skipUntilEOD
argument_list|(
name|mTokenizer
argument_list|,
name|token
argument_list|)
expr_stmt|;
return|return;
block|}
name|mConditionalStack
operator|.
name|pop_back
argument_list|()
expr_stmt|;
comment|// Warn if there are tokens after #endif.
name|mTokenizer
operator|->
name|lex
argument_list|(
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isEOD
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_CONDITIONAL_UNEXPECTED_TOKEN
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
name|skipUntilEOD
argument_list|(
name|mTokenizer
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|parseError
name|void
name|DirectiveParser
operator|::
name|parseError
parameter_list|(
name|Token
modifier|*
name|token
parameter_list|)
block|{
name|assert
argument_list|(
name|getDirective
argument_list|(
name|token
argument_list|)
operator|==
name|DIRECTIVE_ERROR
argument_list|)
expr_stmt|;
name|std
operator|::
name|ostringstream
name|stream
decl_stmt|;
name|mTokenizer
operator|->
name|lex
argument_list|(
name|token
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|token
operator|->
name|type
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
name|token
operator|->
name|type
operator|!=
name|Token
operator|::
name|LAST
operator|)
condition|)
block|{
name|stream
operator|<<
operator|*
name|token
expr_stmt|;
name|mTokenizer
operator|->
name|lex
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
name|mDirectiveHandler
operator|->
name|handleError
argument_list|(
name|token
operator|->
name|location
argument_list|,
name|stream
operator|.
name|str
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Parses pragma of form: #pragma name[(value)].
DECL|function|parsePragma
name|void
name|DirectiveParser
operator|::
name|parsePragma
parameter_list|(
name|Token
modifier|*
name|token
parameter_list|)
block|{
name|assert
argument_list|(
name|getDirective
argument_list|(
name|token
argument_list|)
operator|==
name|DIRECTIVE_PRAGMA
argument_list|)
expr_stmt|;
enum|enum
name|State
block|{
name|PRAGMA_NAME
block|,
name|LEFT_PAREN
block|,
name|PRAGMA_VALUE
block|,
name|RIGHT_PAREN
block|}
enum|;
name|bool
name|valid
init|=
literal|true
decl_stmt|;
name|std
operator|::
name|string
name|name
decl_stmt|,
name|value
decl_stmt|;
name|int
name|state
init|=
name|PRAGMA_NAME
decl_stmt|;
name|mTokenizer
operator|->
name|lex
argument_list|(
name|token
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|token
operator|->
name|type
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
name|token
operator|->
name|type
operator|!=
name|Token
operator|::
name|LAST
operator|)
condition|)
block|{
switch|switch
condition|(
name|state
operator|++
condition|)
block|{
case|case
name|PRAGMA_NAME
case|:
name|name
operator|=
name|token
operator|->
name|text
expr_stmt|;
name|valid
operator|=
name|valid
operator|&&
operator|(
name|token
operator|->
name|type
operator|==
name|Token
operator|::
name|IDENTIFIER
operator|)
expr_stmt|;
break|break;
case|case
name|LEFT_PAREN
case|:
name|valid
operator|=
name|valid
operator|&&
operator|(
name|token
operator|->
name|type
operator|==
literal|'('
operator|)
expr_stmt|;
break|break;
case|case
name|PRAGMA_VALUE
case|:
name|value
operator|=
name|token
operator|->
name|text
expr_stmt|;
name|valid
operator|=
name|valid
operator|&&
operator|(
name|token
operator|->
name|type
operator|==
name|Token
operator|::
name|IDENTIFIER
operator|)
expr_stmt|;
break|break;
case|case
name|RIGHT_PAREN
case|:
name|valid
operator|=
name|valid
operator|&&
operator|(
name|token
operator|->
name|type
operator|==
literal|')'
operator|)
expr_stmt|;
break|break;
default|default:
name|valid
operator|=
literal|false
expr_stmt|;
break|break;
block|}
name|mTokenizer
operator|->
name|lex
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
name|valid
operator|=
name|valid
operator|&&
operator|(
operator|(
name|state
operator|==
name|PRAGMA_NAME
operator|)
operator|||
comment|// Empty pragma.
operator|(
name|state
operator|==
name|LEFT_PAREN
operator|)
operator|||
comment|// Without value.
operator|(
name|state
operator|==
name|RIGHT_PAREN
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
comment|// With value.
if|if
condition|(
operator|!
name|valid
condition|)
block|{
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_UNRECOGNIZED_PRAGMA
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|>
name|PRAGMA_NAME
condition|)
comment|// Do not notify for empty pragma.
block|{
name|mDirectiveHandler
operator|->
name|handlePragma
argument_list|(
name|token
operator|->
name|location
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|parseExtension
name|void
name|DirectiveParser
operator|::
name|parseExtension
parameter_list|(
name|Token
modifier|*
name|token
parameter_list|)
block|{
name|assert
argument_list|(
name|getDirective
argument_list|(
name|token
argument_list|)
operator|==
name|DIRECTIVE_EXTENSION
argument_list|)
expr_stmt|;
enum|enum
name|State
block|{
name|EXT_NAME
block|,
name|COLON
block|,
name|EXT_BEHAVIOR
block|}
enum|;
name|bool
name|valid
init|=
literal|true
decl_stmt|;
name|std
operator|::
name|string
name|name
decl_stmt|,
name|behavior
decl_stmt|;
name|int
name|state
init|=
name|EXT_NAME
decl_stmt|;
name|mTokenizer
operator|->
name|lex
argument_list|(
name|token
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|token
operator|->
name|type
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
name|token
operator|->
name|type
operator|!=
name|Token
operator|::
name|LAST
operator|)
condition|)
block|{
switch|switch
condition|(
name|state
operator|++
condition|)
block|{
case|case
name|EXT_NAME
case|:
if|if
condition|(
name|valid
operator|&&
operator|(
name|token
operator|->
name|type
operator|!=
name|Token
operator|::
name|IDENTIFIER
operator|)
condition|)
block|{
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_INVALID_EXTENSION_NAME
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
name|valid
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|valid
condition|)
name|name
operator|=
name|token
operator|->
name|text
expr_stmt|;
break|break;
case|case
name|COLON
case|:
if|if
condition|(
name|valid
operator|&&
operator|(
name|token
operator|->
name|type
operator|!=
literal|':'
operator|)
condition|)
block|{
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_UNEXPECTED_TOKEN
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
name|valid
operator|=
literal|false
expr_stmt|;
block|}
break|break;
case|case
name|EXT_BEHAVIOR
case|:
if|if
condition|(
name|valid
operator|&&
operator|(
name|token
operator|->
name|type
operator|!=
name|Token
operator|::
name|IDENTIFIER
operator|)
condition|)
block|{
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_INVALID_EXTENSION_BEHAVIOR
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
name|valid
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|valid
condition|)
name|behavior
operator|=
name|token
operator|->
name|text
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|valid
condition|)
block|{
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_UNEXPECTED_TOKEN
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
name|valid
operator|=
literal|false
expr_stmt|;
block|}
break|break;
block|}
name|mTokenizer
operator|->
name|lex
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|valid
operator|&&
operator|(
name|state
operator|!=
name|EXT_BEHAVIOR
operator|+
literal|1
operator|)
condition|)
block|{
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_INVALID_EXTENSION_DIRECTIVE
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
name|valid
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|valid
condition|)
name|mDirectiveHandler
operator|->
name|handleExtension
argument_list|(
name|token
operator|->
name|location
argument_list|,
name|name
argument_list|,
name|behavior
argument_list|)
expr_stmt|;
block|}
DECL|function|parseVersion
name|void
name|DirectiveParser
operator|::
name|parseVersion
parameter_list|(
name|Token
modifier|*
name|token
parameter_list|)
block|{
name|assert
argument_list|(
name|getDirective
argument_list|(
name|token
argument_list|)
operator|==
name|DIRECTIVE_VERSION
argument_list|)
expr_stmt|;
if|if
condition|(
name|mPastFirstStatement
condition|)
block|{
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_VERSION_NOT_FIRST_STATEMENT
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
name|skipUntilEOD
argument_list|(
name|mTokenizer
argument_list|,
name|token
argument_list|)
expr_stmt|;
return|return;
block|}
enum|enum
name|State
block|{
name|VERSION_NUMBER
block|,
name|VERSION_PROFILE
block|,
name|VERSION_ENDLINE
block|}
enum|;
name|bool
name|valid
init|=
literal|true
decl_stmt|;
name|int
name|version
init|=
literal|0
decl_stmt|;
name|int
name|state
init|=
name|VERSION_NUMBER
decl_stmt|;
name|mTokenizer
operator|->
name|lex
argument_list|(
name|token
argument_list|)
expr_stmt|;
while|while
condition|(
name|valid
operator|&&
operator|(
name|token
operator|->
name|type
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
name|token
operator|->
name|type
operator|!=
name|Token
operator|::
name|LAST
operator|)
condition|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|VERSION_NUMBER
case|:
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|Token
operator|::
name|CONST_INT
condition|)
block|{
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_INVALID_VERSION_NUMBER
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
name|valid
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|valid
operator|&&
operator|!
name|token
operator|->
name|iValue
argument_list|(
operator|&
name|version
argument_list|)
condition|)
block|{
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_INTEGER_OVERFLOW
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
name|valid
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|valid
condition|)
block|{
name|state
operator|=
operator|(
name|version
operator|<
literal|300
operator|)
condition|?
name|VERSION_ENDLINE
else|:
name|VERSION_PROFILE
expr_stmt|;
block|}
break|break;
case|case
name|VERSION_PROFILE
case|:
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|Token
operator|::
name|IDENTIFIER
operator|||
name|token
operator|->
name|text
operator|!=
literal|"es"
condition|)
block|{
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_INVALID_VERSION_DIRECTIVE
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
name|valid
operator|=
literal|false
expr_stmt|;
block|}
name|state
operator|=
name|VERSION_ENDLINE
expr_stmt|;
break|break;
default|default:
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_UNEXPECTED_TOKEN
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
name|valid
operator|=
literal|false
expr_stmt|;
break|break;
block|}
name|mTokenizer
operator|->
name|lex
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|valid
operator|&&
operator|(
name|state
operator|!=
name|VERSION_ENDLINE
operator|)
condition|)
block|{
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_INVALID_VERSION_DIRECTIVE
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
name|valid
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|valid
condition|)
block|{
name|mDirectiveHandler
operator|->
name|handleVersion
argument_list|(
name|token
operator|->
name|location
argument_list|,
name|version
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|parseLine
name|void
name|DirectiveParser
operator|::
name|parseLine
parameter_list|(
name|Token
modifier|*
name|token
parameter_list|)
block|{
name|assert
argument_list|(
name|getDirective
argument_list|(
name|token
argument_list|)
operator|==
name|DIRECTIVE_LINE
argument_list|)
expr_stmt|;
enum|enum
name|State
block|{
name|LINE_NUMBER
block|,
name|FILE_NUMBER
block|}
enum|;
name|bool
name|valid
init|=
literal|true
decl_stmt|;
name|int
name|line
init|=
literal|0
decl_stmt|,
name|file
init|=
literal|0
decl_stmt|;
name|int
name|state
init|=
name|LINE_NUMBER
decl_stmt|;
name|MacroExpander
name|macroExpander
argument_list|(
name|mTokenizer
argument_list|,
name|mMacroSet
argument_list|,
name|mDiagnostics
argument_list|)
decl_stmt|;
name|macroExpander
operator|.
name|lex
argument_list|(
name|token
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|token
operator|->
name|type
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
name|token
operator|->
name|type
operator|!=
name|Token
operator|::
name|LAST
operator|)
condition|)
block|{
switch|switch
condition|(
name|state
operator|++
condition|)
block|{
case|case
name|LINE_NUMBER
case|:
if|if
condition|(
name|valid
operator|&&
operator|(
name|token
operator|->
name|type
operator|!=
name|Token
operator|::
name|CONST_INT
operator|)
condition|)
block|{
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_INVALID_LINE_NUMBER
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
name|valid
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|valid
operator|&&
operator|!
name|token
operator|->
name|iValue
argument_list|(
operator|&
name|line
argument_list|)
condition|)
block|{
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_INTEGER_OVERFLOW
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
name|valid
operator|=
literal|false
expr_stmt|;
block|}
break|break;
case|case
name|FILE_NUMBER
case|:
if|if
condition|(
name|valid
operator|&&
operator|(
name|token
operator|->
name|type
operator|!=
name|Token
operator|::
name|CONST_INT
operator|)
condition|)
block|{
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_INVALID_FILE_NUMBER
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
name|valid
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|valid
operator|&&
operator|!
name|token
operator|->
name|iValue
argument_list|(
operator|&
name|file
argument_list|)
condition|)
block|{
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_INTEGER_OVERFLOW
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
name|valid
operator|=
literal|false
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|valid
condition|)
block|{
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_UNEXPECTED_TOKEN
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
name|valid
operator|=
literal|false
expr_stmt|;
block|}
break|break;
block|}
name|macroExpander
operator|.
name|lex
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|valid
operator|&&
operator|(
name|state
operator|!=
name|FILE_NUMBER
operator|)
operator|&&
operator|(
name|state
operator|!=
name|FILE_NUMBER
operator|+
literal|1
operator|)
condition|)
block|{
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_INVALID_LINE_DIRECTIVE
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
name|valid
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|valid
condition|)
block|{
name|mTokenizer
operator|->
name|setLineNumber
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|FILE_NUMBER
operator|+
literal|1
condition|)
name|mTokenizer
operator|->
name|setFileNumber
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|skipping
name|bool
name|DirectiveParser
operator|::
name|skipping
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|mConditionalStack
operator|.
name|empty
argument_list|()
condition|)
return|return
literal|false
return|;
specifier|const
name|ConditionalBlock
modifier|&
name|block
init|=
name|mConditionalStack
operator|.
name|back
argument_list|()
decl_stmt|;
return|return
name|block
operator|.
name|skipBlock
operator|||
name|block
operator|.
name|skipGroup
return|;
block|}
DECL|function|parseConditionalIf
name|void
name|DirectiveParser
operator|::
name|parseConditionalIf
parameter_list|(
name|Token
modifier|*
name|token
parameter_list|)
block|{
name|ConditionalBlock
name|block
decl_stmt|;
name|block
operator|.
name|type
operator|=
name|token
operator|->
name|text
expr_stmt|;
name|block
operator|.
name|location
operator|=
name|token
operator|->
name|location
expr_stmt|;
if|if
condition|(
name|skipping
argument_list|()
condition|)
block|{
comment|// This conditional block is inside another conditional group
comment|// which is skipped. As a consequence this whole block is skipped.
comment|// Be careful not to parse the conditional expression that might
comment|// emit a diagnostic.
name|skipUntilEOD
argument_list|(
name|mTokenizer
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|block
operator|.
name|skipBlock
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|DirectiveType
name|directive
init|=
name|getDirective
argument_list|(
name|token
argument_list|)
decl_stmt|;
name|int
name|expression
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|directive
condition|)
block|{
case|case
name|DIRECTIVE_IF
case|:
name|expression
operator|=
name|parseExpressionIf
argument_list|(
name|token
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIRECTIVE_IFDEF
case|:
name|expression
operator|=
name|parseExpressionIfdef
argument_list|(
name|token
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIRECTIVE_IFNDEF
case|:
name|expression
operator|=
name|parseExpressionIfdef
argument_list|(
name|token
argument_list|)
operator|==
literal|0
condition|?
literal|1
else|:
literal|0
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
block|}
name|block
operator|.
name|skipGroup
operator|=
name|expression
operator|==
literal|0
expr_stmt|;
name|block
operator|.
name|foundValidGroup
operator|=
name|expression
operator|!=
literal|0
expr_stmt|;
block|}
name|mConditionalStack
operator|.
name|push_back
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
DECL|function|parseExpressionIf
name|int
name|DirectiveParser
operator|::
name|parseExpressionIf
parameter_list|(
name|Token
modifier|*
name|token
parameter_list|)
block|{
name|assert
argument_list|(
operator|(
name|getDirective
argument_list|(
name|token
argument_list|)
operator|==
name|DIRECTIVE_IF
operator|)
operator|||
operator|(
name|getDirective
argument_list|(
name|token
argument_list|)
operator|==
name|DIRECTIVE_ELIF
operator|)
argument_list|)
expr_stmt|;
name|DefinedParser
name|definedParser
argument_list|(
name|mTokenizer
argument_list|,
name|mMacroSet
argument_list|,
name|mDiagnostics
argument_list|)
decl_stmt|;
name|MacroExpander
name|macroExpander
argument_list|(
operator|&
name|definedParser
argument_list|,
name|mMacroSet
argument_list|,
name|mDiagnostics
argument_list|)
decl_stmt|;
name|ExpressionParser
name|expressionParser
argument_list|(
operator|&
name|macroExpander
argument_list|,
name|mDiagnostics
argument_list|)
decl_stmt|;
name|int
name|expression
init|=
literal|0
decl_stmt|;
name|macroExpander
operator|.
name|lex
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|expressionParser
operator|.
name|parse
argument_list|(
name|token
argument_list|,
operator|&
name|expression
argument_list|)
expr_stmt|;
comment|// Warn if there are tokens after #if expression.
if|if
condition|(
operator|!
name|isEOD
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_CONDITIONAL_UNEXPECTED_TOKEN
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
name|skipUntilEOD
argument_list|(
name|mTokenizer
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
return|return
name|expression
return|;
block|}
DECL|function|parseExpressionIfdef
name|int
name|DirectiveParser
operator|::
name|parseExpressionIfdef
parameter_list|(
name|Token
modifier|*
name|token
parameter_list|)
block|{
name|assert
argument_list|(
operator|(
name|getDirective
argument_list|(
name|token
argument_list|)
operator|==
name|DIRECTIVE_IFDEF
operator|)
operator|||
operator|(
name|getDirective
argument_list|(
name|token
argument_list|)
operator|==
name|DIRECTIVE_IFNDEF
operator|)
argument_list|)
expr_stmt|;
name|mTokenizer
operator|->
name|lex
argument_list|(
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|Token
operator|::
name|IDENTIFIER
condition|)
block|{
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_UNEXPECTED_TOKEN
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
name|skipUntilEOD
argument_list|(
name|mTokenizer
argument_list|,
name|token
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|MacroSet
operator|::
name|const_iterator
name|iter
init|=
name|mMacroSet
operator|->
name|find
argument_list|(
name|token
operator|->
name|text
argument_list|)
decl_stmt|;
name|int
name|expression
init|=
name|iter
operator|!=
name|mMacroSet
operator|->
name|end
argument_list|()
condition|?
literal|1
else|:
literal|0
decl_stmt|;
comment|// Warn if there are tokens after #ifdef expression.
name|mTokenizer
operator|->
name|lex
argument_list|(
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isEOD
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|mDiagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|PP_CONDITIONAL_UNEXPECTED_TOKEN
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
name|skipUntilEOD
argument_list|(
name|mTokenizer
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
return|return
name|expression
return|;
block|}
block|}
end_namespace
begin_comment
comment|// namespace pp
end_comment
end_unit
