begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2011 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|"Preprocessor.h"
end_include
begin_include
include|#
directive|include
file|<cassert>
end_include
begin_include
include|#
directive|include
file|<sstream>
end_include
begin_include
include|#
directive|include
file|"Diagnostics.h"
end_include
begin_include
include|#
directive|include
file|"DirectiveParser.h"
end_include
begin_include
include|#
directive|include
file|"Macro.h"
end_include
begin_include
include|#
directive|include
file|"MacroExpander.h"
end_include
begin_include
include|#
directive|include
file|"Token.h"
end_include
begin_include
include|#
directive|include
file|"Tokenizer.h"
end_include
begin_namespace
DECL|namespace|pp
namespace|namespace
name|pp
block|{
DECL|struct|PreprocessorImpl
struct|struct
name|PreprocessorImpl
block|{
DECL|member|diagnostics
name|Diagnostics
modifier|*
name|diagnostics
decl_stmt|;
DECL|member|macroSet
name|MacroSet
name|macroSet
decl_stmt|;
DECL|member|tokenizer
name|Tokenizer
name|tokenizer
decl_stmt|;
DECL|member|directiveParser
name|DirectiveParser
name|directiveParser
decl_stmt|;
DECL|member|macroExpander
name|MacroExpander
name|macroExpander
decl_stmt|;
DECL|function|PreprocessorImpl
name|PreprocessorImpl
parameter_list|(
name|Diagnostics
modifier|*
name|diag
parameter_list|,
name|DirectiveHandler
modifier|*
name|directiveHandler
parameter_list|)
member_init_list|:
name|diagnostics
argument_list|(
name|diag
argument_list|)
member_init_list|,
name|tokenizer
argument_list|(
name|diag
argument_list|)
member_init_list|,
name|directiveParser
argument_list|(
operator|&
name|tokenizer
argument_list|,
operator|&
name|macroSet
argument_list|,
name|diag
argument_list|,
name|directiveHandler
argument_list|)
member_init_list|,
name|macroExpander
argument_list|(
operator|&
name|directiveParser
argument_list|,
operator|&
name|macroSet
argument_list|,
name|diag
argument_list|)
block|{     }
block|}
struct|;
DECL|function|Preprocessor
name|Preprocessor
operator|::
name|Preprocessor
parameter_list|(
name|Diagnostics
modifier|*
name|diagnostics
parameter_list|,
name|DirectiveHandler
modifier|*
name|directiveHandler
parameter_list|)
block|{
name|mImpl
operator|=
operator|new
name|PreprocessorImpl
argument_list|(
name|diagnostics
argument_list|,
name|directiveHandler
argument_list|)
expr_stmt|;
block|}
DECL|function|~Preprocessor
name|Preprocessor
operator|::
name|~
name|Preprocessor
parameter_list|()
block|{
operator|delete
name|mImpl
expr_stmt|;
block|}
DECL|function|init
name|bool
name|Preprocessor
operator|::
name|init
parameter_list|(
name|int
name|count
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
name|string
index|[]
parameter_list|,
specifier|const
name|int
name|length
index|[]
parameter_list|)
block|{
specifier|static
specifier|const
name|int
name|kGLSLVersion
init|=
literal|100
decl_stmt|;
comment|// Add standard pre-defined macros.
name|predefineMacro
argument_list|(
literal|"__LINE__"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|predefineMacro
argument_list|(
literal|"__FILE__"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|predefineMacro
argument_list|(
literal|"__VERSION__"
argument_list|,
name|kGLSLVersion
argument_list|)
expr_stmt|;
name|predefineMacro
argument_list|(
literal|"GL_ES"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|mImpl
operator|->
name|tokenizer
operator|.
name|init
argument_list|(
name|count
argument_list|,
name|string
argument_list|,
name|length
argument_list|)
return|;
block|}
DECL|function|predefineMacro
name|void
name|Preprocessor
operator|::
name|predefineMacro
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|std
operator|::
name|ostringstream
name|stream
decl_stmt|;
name|stream
operator|<<
name|value
expr_stmt|;
name|Token
name|token
decl_stmt|;
name|token
operator|.
name|type
operator|=
name|Token
operator|::
name|CONST_INT
expr_stmt|;
name|token
operator|.
name|text
operator|=
name|stream
operator|.
name|str
argument_list|()
expr_stmt|;
name|Macro
name|macro
decl_stmt|;
name|macro
operator|.
name|predefined
operator|=
literal|true
expr_stmt|;
name|macro
operator|.
name|type
operator|=
name|Macro
operator|::
name|kTypeObj
expr_stmt|;
name|macro
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|macro
operator|.
name|replacements
operator|.
name|push_back
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|mImpl
operator|->
name|macroSet
index|[
name|name
index|]
operator|=
name|macro
expr_stmt|;
block|}
DECL|function|lex
name|void
name|Preprocessor
operator|::
name|lex
parameter_list|(
name|Token
modifier|*
name|token
parameter_list|)
block|{
name|bool
name|validToken
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|validToken
condition|)
block|{
name|mImpl
operator|->
name|macroExpander
operator|.
name|lex
argument_list|(
name|token
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
comment|// We should not be returning internal preprocessing tokens.
comment|// Convert preprocessing tokens to compiler tokens or report
comment|// diagnostics.
case|case
name|Token
operator|::
name|PP_HASH
case|:
name|assert
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|Token
operator|::
name|CONST_INT
case|:
block|{
name|int
name|val
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|token
operator|->
name|iValue
argument_list|(
operator|&
name|val
argument_list|)
condition|)
block|{
comment|// Do not mark the token as invalid.
comment|// Just emit the diagnostic and reset value to 0.
name|mImpl
operator|->
name|diagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|INTEGER_OVERFLOW
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
name|token
operator|->
name|text
operator|.
name|assign
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
block|}
name|validToken
operator|=
literal|true
expr_stmt|;
break|break;
block|}
case|case
name|Token
operator|::
name|CONST_FLOAT
case|:
block|{
name|float
name|val
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|token
operator|->
name|fValue
argument_list|(
operator|&
name|val
argument_list|)
condition|)
block|{
comment|// Do not mark the token as invalid.
comment|// Just emit the diagnostic and reset value to 0.0.
name|mImpl
operator|->
name|diagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|FLOAT_OVERFLOW
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
name|token
operator|->
name|text
operator|.
name|assign
argument_list|(
literal|"0.0"
argument_list|)
expr_stmt|;
block|}
name|validToken
operator|=
literal|true
expr_stmt|;
break|break;
block|}
case|case
name|Token
operator|::
name|PP_NUMBER
case|:
name|mImpl
operator|->
name|diagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|INVALID_NUMBER
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
break|break;
case|case
name|Token
operator|::
name|PP_OTHER
case|:
name|mImpl
operator|->
name|diagnostics
operator|->
name|report
argument_list|(
name|Diagnostics
operator|::
name|INVALID_CHARACTER
argument_list|,
name|token
operator|->
name|location
argument_list|,
name|token
operator|->
name|text
argument_list|)
expr_stmt|;
break|break;
default|default:
name|validToken
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_namespace
begin_comment
comment|// namespace pp
end_comment
end_unit
