begin_unit
begin_comment
comment|/****************************************************************************\ Copyright (c) 2002, NVIDIA Corporation.  NVIDIA Corporation("NVIDIA") supplies this software to you in consideration of your agreement to the following terms, and your use, installation, modification or redistribution of this NVIDIA software constitutes acceptance of these terms.  If you do not agree with these terms, please do not use, install, modify or redistribute this NVIDIA software.  In consideration of your agreement to abide by the following terms, and subject to these terms, NVIDIA grants you a personal, non-exclusive license, under NVIDIA's copyrights in this original NVIDIA software (the "NVIDIA Software"), to use, reproduce, modify and redistribute the NVIDIA Software, with or without modifications, in source and/or binary forms; provided that if you redistribute the NVIDIA Software, you must retain the copyright notice of NVIDIA, this notice and the following text and disclaimers in all such redistributions of the NVIDIA Software. Neither the name, trademarks, service marks nor logos of NVIDIA Corporation may be used to endorse or promote products derived from the NVIDIA Software without specific prior written permission from NVIDIA. Except as expressly stated in this notice, no other rights or licenses express or implied, are granted by NVIDIA herein, including but not limited to any patent rights that may be infringed by your derivative works or by other works in which the NVIDIA Software may be incorporated. No hardware is licensed hereunder.   THE NVIDIA SOFTWARE IS BEING PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR ITS USE AND OPERATION EITHER ALONE OR IN COMBINATION WITH OTHER PRODUCTS.  IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, EXEMPLARY, CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, LOST PROFITS; PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) OR ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION OF THE NVIDIA SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. \****************************************************************************/
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// tokens.c
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_include
include|#
directive|include
file|<ctype.h>
end_include
begin_include
include|#
directive|include
file|"common/angleutils.h"
end_include
begin_include
include|#
directive|include
file|"compiler/debug.h"
end_include
begin_include
include|#
directive|include
file|"compiler/preprocessor/slglobals.h"
end_include
begin_include
include|#
directive|include
file|"compiler/util.h"
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_if
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4054
name|)
end_pragma
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4152
name|)
end_pragma
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|//////////////////////// Preprocessor and Token Recorder and Playback: ////////////////////////
end_comment
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|/*  * idstr()  * Copy a string to a malloc'ed block and convert it into something suitable  * for an ID  *  */
end_comment
begin_function
DECL|function|idstr
specifier|static
name|char
modifier|*
name|idstr
parameter_list|(
specifier|const
name|char
modifier|*
name|fstr
parameter_list|,
name|MemoryPool
modifier|*
name|pool
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|,
modifier|*
name|t
decl_stmt|;
specifier|const
name|char
modifier|*
name|f
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|fstr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pool
condition|)
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|mem_Alloc
argument_list|(
name|pool
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|f
operator|=
name|fstr
operator|,
name|t
operator|=
name|str
init|;
operator|*
name|f
condition|;
name|f
operator|++
control|)
block|{
if|if
condition|(
name|isalnum
argument_list|(
operator|*
name|f
argument_list|)
condition|)
operator|*
name|t
operator|++
operator|=
operator|*
name|f
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|f
operator|==
literal|'.'
operator|||
operator|*
name|f
operator|==
literal|'/'
condition|)
operator|*
name|t
operator|++
operator|=
literal|'_'
expr_stmt|;
block|}
operator|*
name|t
operator|=
literal|0
expr_stmt|;
return|return
name|str
return|;
block|}
end_function
begin_comment
comment|// idstr
end_comment
begin_comment
comment|/*  * lNewBlock()  *  */
end_comment
begin_function
DECL|function|lNewBlock
specifier|static
name|TokenBlock
modifier|*
name|lNewBlock
parameter_list|(
name|TokenStream
modifier|*
name|fTok
parameter_list|,
name|MemoryPool
modifier|*
name|pool
parameter_list|)
block|{
name|TokenBlock
modifier|*
name|lBlock
decl_stmt|;
if|if
condition|(
operator|!
name|pool
condition|)
name|lBlock
operator|=
operator|(
name|TokenBlock
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TokenBlock
argument_list|)
operator|+
literal|256
argument_list|)
expr_stmt|;
else|else
name|lBlock
operator|=
operator|(
name|TokenBlock
operator|*
operator|)
name|mem_Alloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|TokenBlock
argument_list|)
operator|+
literal|256
argument_list|)
expr_stmt|;
name|lBlock
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|lBlock
operator|->
name|current
operator|=
literal|0
expr_stmt|;
name|lBlock
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|lBlock
operator|+
sizeof|sizeof
argument_list|(
name|TokenBlock
argument_list|)
expr_stmt|;
name|lBlock
operator|->
name|max
operator|=
literal|256
expr_stmt|;
name|lBlock
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fTok
operator|->
name|head
condition|)
block|{
name|fTok
operator|->
name|current
operator|->
name|next
operator|=
name|lBlock
expr_stmt|;
block|}
else|else
block|{
name|fTok
operator|->
name|head
operator|=
name|lBlock
expr_stmt|;
block|}
name|fTok
operator|->
name|current
operator|=
name|lBlock
expr_stmt|;
return|return
name|lBlock
return|;
block|}
end_function
begin_comment
comment|// lNewBlock
end_comment
begin_comment
comment|/*  * lAddByte()  *  */
end_comment
begin_function
DECL|function|lAddByte
specifier|static
name|void
name|lAddByte
parameter_list|(
name|TokenStream
modifier|*
name|fTok
parameter_list|,
name|unsigned
name|char
name|fVal
parameter_list|)
block|{
name|TokenBlock
modifier|*
name|lBlock
decl_stmt|;
name|lBlock
operator|=
name|fTok
operator|->
name|current
expr_stmt|;
if|if
condition|(
name|lBlock
operator|->
name|count
operator|>=
name|lBlock
operator|->
name|max
condition|)
name|lBlock
operator|=
name|lNewBlock
argument_list|(
name|fTok
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lBlock
operator|->
name|data
index|[
name|lBlock
operator|->
name|count
operator|++
index|]
operator|=
name|fVal
expr_stmt|;
block|}
end_function
begin_comment
comment|// lAddByte
end_comment
begin_comment
comment|/*  * lReadByte() - Get the next byte from a stream.  *  */
end_comment
begin_function
DECL|function|lReadByte
specifier|static
name|int
name|lReadByte
parameter_list|(
name|TokenStream
modifier|*
name|pTok
parameter_list|)
block|{
name|TokenBlock
modifier|*
name|lBlock
decl_stmt|;
name|int
name|lval
init|=
operator|-
literal|1
decl_stmt|;
name|lBlock
operator|=
name|pTok
operator|->
name|current
expr_stmt|;
if|if
condition|(
name|lBlock
condition|)
block|{
if|if
condition|(
name|lBlock
operator|->
name|current
operator|>=
name|lBlock
operator|->
name|count
condition|)
block|{
name|lBlock
operator|=
name|lBlock
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|lBlock
condition|)
name|lBlock
operator|->
name|current
operator|=
literal|0
expr_stmt|;
name|pTok
operator|->
name|current
operator|=
name|lBlock
expr_stmt|;
block|}
if|if
condition|(
name|lBlock
condition|)
name|lval
operator|=
name|lBlock
operator|->
name|data
index|[
name|lBlock
operator|->
name|current
operator|++
index|]
expr_stmt|;
block|}
return|return
name|lval
return|;
block|}
end_function
begin_comment
comment|// lReadByte
end_comment
begin_comment
comment|/////////////////////////////////////// Global Functions://////////////////////////////////////
end_comment
begin_comment
comment|/*  * NewTokenStream()  *  */
end_comment
begin_function
DECL|function|NewTokenStream
name|TokenStream
modifier|*
name|NewTokenStream
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|MemoryPool
modifier|*
name|pool
parameter_list|)
block|{
name|TokenStream
modifier|*
name|pTok
decl_stmt|;
if|if
condition|(
operator|!
name|pool
condition|)
name|pTok
operator|=
operator|(
name|TokenStream
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TokenStream
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pTok
operator|=
operator|(
name|TokenStream
operator|*
operator|)
name|mem_Alloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|TokenStream
argument_list|)
argument_list|)
expr_stmt|;
name|pTok
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|pTok
operator|->
name|name
operator|=
name|idstr
argument_list|(
name|name
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|pTok
operator|->
name|head
operator|=
name|NULL
expr_stmt|;
name|pTok
operator|->
name|current
operator|=
name|NULL
expr_stmt|;
name|lNewBlock
argument_list|(
name|pTok
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|pTok
return|;
block|}
end_function
begin_comment
comment|// NewTokenStream
end_comment
begin_comment
comment|/*  * DeleteTokenStream()  *  */
end_comment
begin_function
DECL|function|DeleteTokenStream
name|void
name|DeleteTokenStream
parameter_list|(
name|TokenStream
modifier|*
name|pTok
parameter_list|)
block|{
name|TokenBlock
modifier|*
name|pBlock
decl_stmt|,
modifier|*
name|nBlock
decl_stmt|;
if|if
condition|(
name|pTok
condition|)
block|{
name|pBlock
operator|=
name|pTok
operator|->
name|head
expr_stmt|;
while|while
condition|(
name|pBlock
condition|)
block|{
name|nBlock
operator|=
name|pBlock
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|pBlock
argument_list|)
expr_stmt|;
name|pBlock
operator|=
name|nBlock
expr_stmt|;
block|}
if|if
condition|(
name|pTok
operator|->
name|name
condition|)
name|free
argument_list|(
name|pTok
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pTok
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// DeleteTokenStream
end_comment
begin_comment
comment|/*  * RecordToken() - Add a token to the end of a list for later playback or printout.  *  */
end_comment
begin_function
DECL|function|RecordToken
name|void
name|RecordToken
parameter_list|(
name|TokenStream
modifier|*
name|pTok
parameter_list|,
name|int
name|token
parameter_list|,
name|yystypepp
modifier|*
name|yylvalpp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|str
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|token
operator|>
literal|256
condition|)
name|lAddByte
argument_list|(
name|pTok
argument_list|,
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|token
operator|&
literal|0x7f
operator|)
operator|+
literal|0x80
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|lAddByte
argument_list|(
name|pTok
argument_list|,
call|(
name|unsigned
name|char
call|)
argument_list|(
name|token
operator|&
literal|0x7f
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|CPP_IDENTIFIER
case|:
case|case
name|CPP_TYPEIDENTIFIER
case|:
case|case
name|CPP_STRCONSTANT
case|:
name|s
operator|=
name|GetAtomString
argument_list|(
name|atable
argument_list|,
name|yylvalpp
operator|->
name|sc_ident
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|lAddByte
argument_list|(
name|pTok
argument_list|,
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
name|lAddByte
argument_list|(
name|pTok
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_FLOATCONSTANT
case|:
case|case
name|CPP_INTCONSTANT
case|:
name|str
operator|=
name|yylvalpp
operator|->
name|symbol_name
expr_stmt|;
while|while
condition|(
operator|*
name|str
condition|)
block|{
name|lAddByte
argument_list|(
name|pTok
argument_list|,
operator|(
name|unsigned
name|char
operator|)
operator|*
name|str
operator|++
argument_list|)
expr_stmt|;
block|}
name|lAddByte
argument_list|(
name|pTok
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|lAddByte
argument_list|(
name|pTok
argument_list|,
call|(
name|unsigned
name|char
call|)
argument_list|(
name|yylvalpp
operator|->
name|sc_int
condition|?
literal|1
else|:
literal|0
argument_list|)
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
block|}
end_function
begin_comment
comment|// RecordToken
end_comment
begin_comment
comment|/*  * RewindTokenStream() - Reset a token stream in preperation for reading.  *  */
end_comment
begin_function
DECL|function|RewindTokenStream
name|void
name|RewindTokenStream
parameter_list|(
name|TokenStream
modifier|*
name|pTok
parameter_list|)
block|{
if|if
condition|(
name|pTok
operator|->
name|head
condition|)
block|{
name|pTok
operator|->
name|current
operator|=
name|pTok
operator|->
name|head
expr_stmt|;
name|pTok
operator|->
name|current
operator|->
name|current
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// RewindTokenStream
end_comment
begin_comment
comment|/*  * ReadToken() - Read the next token from a stream.  *  */
end_comment
begin_function
DECL|function|ReadToken
name|int
name|ReadToken
parameter_list|(
name|TokenStream
modifier|*
name|pTok
parameter_list|,
name|yystypepp
modifier|*
name|yylvalpp
parameter_list|)
block|{
name|char
name|symbol_name
index|[
name|MAX_SYMBOL_NAME_LEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|string_val
index|[
name|MAX_STRING_LEN
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|ltoken
decl_stmt|,
name|len
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|int
name|base
decl_stmt|,
name|accum
decl_stmt|;
name|char
name|ch_val
decl_stmt|;
name|ltoken
operator|=
name|lReadByte
argument_list|(
name|pTok
argument_list|)
expr_stmt|;
if|if
condition|(
name|ltoken
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|ltoken
operator|>
literal|127
condition|)
name|ltoken
operator|+=
literal|128
expr_stmt|;
switch|switch
condition|(
name|ltoken
condition|)
block|{
case|case
name|CPP_IDENTIFIER
case|:
case|case
name|CPP_TYPEIDENTIFIER
case|:
name|len
operator|=
literal|0
expr_stmt|;
name|ch
operator|=
name|lReadByte
argument_list|(
name|pTok
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
operator|)
operator|||
name|ch
operator|==
literal|'_'
condition|)
block|{
if|if
condition|(
name|len
operator|<
name|MAX_SYMBOL_NAME_LEN
condition|)
block|{
name|symbol_name
index|[
name|len
operator|++
index|]
operator|=
name|ch
expr_stmt|;
name|ch
operator|=
name|lReadByte
argument_list|(
name|pTok
argument_list|)
expr_stmt|;
block|}
block|}
name|symbol_name
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|assert
argument_list|(
name|ch
operator|==
literal|'\0'
argument_list|)
expr_stmt|;
name|yylvalpp
operator|->
name|sc_ident
operator|=
name|LookUpAddString
argument_list|(
name|atable
argument_list|,
name|symbol_name
argument_list|)
expr_stmt|;
return|return
name|CPP_IDENTIFIER
return|;
break|break;
case|case
name|CPP_STRCONSTANT
case|:
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|lReadByte
argument_list|(
name|pTok
argument_list|)
operator|)
operator|!=
literal|0
condition|)
if|if
condition|(
name|len
operator|<
name|MAX_STRING_LEN
condition|)
name|string_val
index|[
name|len
operator|++
index|]
operator|=
name|ch
expr_stmt|;
name|string_val
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|yylvalpp
operator|->
name|sc_ident
operator|=
name|LookUpAddString
argument_list|(
name|atable
argument_list|,
name|string_val
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_FLOATCONSTANT
case|:
name|len
operator|=
literal|0
expr_stmt|;
name|ch
operator|=
name|lReadByte
argument_list|(
name|pTok
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'e'
operator|||
name|ch
operator|==
literal|'E'
operator|||
name|ch
operator|==
literal|'.'
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'+'
operator|||
name|ch
operator|==
literal|'-'
operator|)
condition|)
block|{
if|if
condition|(
name|len
operator|<
name|MAX_SYMBOL_NAME_LEN
condition|)
block|{
name|symbol_name
index|[
name|len
operator|++
index|]
operator|=
name|ch
expr_stmt|;
name|ch
operator|=
name|lReadByte
argument_list|(
name|pTok
argument_list|)
expr_stmt|;
block|}
block|}
name|symbol_name
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|assert
argument_list|(
name|ch
operator|==
literal|'\0'
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|yylvalpp
operator|->
name|symbol_name
argument_list|,
name|symbol_name
argument_list|)
expr_stmt|;
name|yylvalpp
operator|->
name|sc_fval
operator|=
operator|(
name|float
operator|)
name|atof_dot
argument_list|(
name|yylvalpp
operator|->
name|symbol_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_INTCONSTANT
case|:
name|len
operator|=
literal|0
expr_stmt|;
name|accum
operator|=
literal|0
expr_stmt|;
name|ch
operator|=
name|lReadByte
argument_list|(
name|pTok
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'0'
condition|)
block|{
name|symbol_name
index|[
name|len
operator|++
index|]
operator|=
name|ch
expr_stmt|;
name|ch
operator|=
name|lReadByte
argument_list|(
name|pTok
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'x'
operator|||
name|ch
operator|==
literal|'X'
condition|)
block|{
name|symbol_name
index|[
name|len
operator|++
index|]
operator|=
name|ch
expr_stmt|;
name|base
operator|=
literal|16
expr_stmt|;
name|ch
operator|=
name|lReadByte
argument_list|(
name|pTok
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
literal|8
expr_stmt|;
block|}
block|}
else|else
block|{
name|base
operator|=
literal|10
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|<
name|MAX_SYMBOL_NAME_LEN
condition|)
block|{
name|ch_val
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|ch
argument_list|)
condition|)
name|ch_val
operator|=
name|ch
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|isxdigit
argument_list|(
name|ch
argument_list|)
condition|)
name|ch_val
operator|=
name|tolower
argument_list|(
name|ch
argument_list|)
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
if|if
condition|(
name|ch_val
operator|<
literal|0
operator|||
name|ch_val
operator|>=
name|base
condition|)
break|break;
name|symbol_name
index|[
name|len
operator|++
index|]
operator|=
name|ch
expr_stmt|;
name|accum
operator|=
name|accum
operator|*
name|base
operator|+
name|ch_val
expr_stmt|;
name|ch
operator|=
name|lReadByte
argument_list|(
name|pTok
argument_list|)
expr_stmt|;
block|}
name|symbol_name
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|assert
argument_list|(
name|ch
operator|==
literal|'\0'
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|yylvalpp
operator|->
name|symbol_name
argument_list|,
name|symbol_name
argument_list|)
expr_stmt|;
name|yylvalpp
operator|->
name|sc_int
operator|=
name|accum
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|yylvalpp
operator|->
name|sc_int
operator|=
name|lReadByte
argument_list|(
name|pTok
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|ltoken
return|;
block|}
return|return
name|EOF_SY
return|;
block|}
end_function
begin_comment
comment|// ReadToken
end_comment
begin_typedef
DECL|struct|TokenInputSrc
typedef|typedef
struct|struct
name|TokenInputSrc
block|{
DECL|member|base
name|InputSrc
name|base
decl_stmt|;
DECL|member|tokens
name|TokenStream
modifier|*
name|tokens
decl_stmt|;
DECL|member|final
name|int
function_decl|(
modifier|*
name|final
function_decl|)
parameter_list|(
name|CPPStruct
modifier|*
parameter_list|)
function_decl|;
block|}
DECL|typedef|TokenInputSrc
name|TokenInputSrc
typedef|;
end_typedef
begin_function
DECL|function|scan_token
specifier|static
name|int
name|scan_token
parameter_list|(
name|TokenInputSrc
modifier|*
name|in
parameter_list|,
name|yystypepp
modifier|*
name|yylvalpp
parameter_list|)
block|{
name|int
name|token
init|=
name|ReadToken
argument_list|(
name|in
operator|->
name|tokens
argument_list|,
name|yylvalpp
argument_list|)
decl_stmt|;
name|int
function_decl|(
modifier|*
name|final
function_decl|)
parameter_list|(
name|CPPStruct
modifier|*
parameter_list|)
function_decl|;
name|cpp
operator|->
name|tokenLoc
operator|->
name|file
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|name
expr_stmt|;
name|cpp
operator|->
name|tokenLoc
operator|->
name|line
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|line
expr_stmt|;
if|if
condition|(
name|token
operator|==
literal|'\n'
condition|)
block|{
name|in
operator|->
name|base
operator|.
name|line
operator|++
expr_stmt|;
return|return
name|token
return|;
block|}
if|if
condition|(
name|token
operator|>
literal|0
condition|)
return|return
name|token
return|;
name|cpp
operator|->
name|currentInput
operator|=
name|in
operator|->
name|base
operator|.
name|prev
expr_stmt|;
name|final
operator|=
name|in
operator|->
name|final
expr_stmt|;
name|free
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|final
operator|&&
operator|!
name|final
argument_list|(
name|cpp
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|ReadFromTokenStream
name|int
name|ReadFromTokenStream
parameter_list|(
name|TokenStream
modifier|*
name|ts
parameter_list|,
name|int
name|name
parameter_list|,
name|int
function_decl|(
modifier|*
name|final
function_decl|)
parameter_list|(
name|CPPStruct
modifier|*
parameter_list|)
parameter_list|)
block|{
name|TokenInputSrc
modifier|*
name|in
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TokenInputSrc
argument_list|)
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|in
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|TokenInputSrc
argument_list|)
argument_list|)
expr_stmt|;
name|in
operator|->
name|base
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|in
operator|->
name|base
operator|.
name|prev
operator|=
name|cpp
operator|->
name|currentInput
expr_stmt|;
name|in
operator|->
name|base
operator|.
name|scan
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|InputSrc
operator|*
argument_list|,
name|yystypepp
operator|*
argument_list|)
operator|)
name|scan_token
expr_stmt|;
name|in
operator|->
name|base
operator|.
name|line
operator|=
literal|1
expr_stmt|;
name|in
operator|->
name|tokens
operator|=
name|ts
expr_stmt|;
name|in
operator|->
name|final
operator|=
name|final
expr_stmt|;
name|RewindTokenStream
argument_list|(
name|ts
argument_list|)
expr_stmt|;
name|cpp
operator|->
name|currentInput
operator|=
operator|&
name|in
operator|->
name|base
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_typedef
DECL|struct|UngotToken
typedef|typedef
struct|struct
name|UngotToken
block|{
DECL|member|base
name|InputSrc
name|base
decl_stmt|;
DECL|member|token
name|int
name|token
decl_stmt|;
DECL|member|lval
name|yystypepp
name|lval
decl_stmt|;
block|}
DECL|typedef|UngotToken
name|UngotToken
typedef|;
end_typedef
begin_function
DECL|function|reget_token
specifier|static
name|int
name|reget_token
parameter_list|(
name|UngotToken
modifier|*
name|t
parameter_list|,
name|yystypepp
modifier|*
name|yylvalpp
parameter_list|)
block|{
name|int
name|token
init|=
name|t
operator|->
name|token
decl_stmt|;
operator|*
name|yylvalpp
operator|=
name|t
operator|->
name|lval
expr_stmt|;
name|cpp
operator|->
name|currentInput
operator|=
name|t
operator|->
name|base
operator|.
name|prev
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|token
return|;
block|}
end_function
begin_function
DECL|function|UngetToken
name|void
name|UngetToken
parameter_list|(
name|int
name|token
parameter_list|,
name|yystypepp
modifier|*
name|yylvalpp
parameter_list|)
block|{
name|UngotToken
modifier|*
name|t
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|UngotToken
argument_list|)
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|UngotToken
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|token
operator|=
name|token
expr_stmt|;
name|t
operator|->
name|lval
operator|=
operator|*
name|yylvalpp
expr_stmt|;
name|t
operator|->
name|base
operator|.
name|scan
operator|=
operator|(
name|void
operator|*
operator|)
name|reget_token
expr_stmt|;
name|t
operator|->
name|base
operator|.
name|prev
operator|=
name|cpp
operator|->
name|currentInput
expr_stmt|;
name|t
operator|->
name|base
operator|.
name|name
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|name
expr_stmt|;
name|t
operator|->
name|base
operator|.
name|line
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|line
expr_stmt|;
name|cpp
operator|->
name|currentInput
operator|=
operator|&
name|t
operator|->
name|base
expr_stmt|;
block|}
end_function
begin_function
DECL|function|DumpTokenStream
name|void
name|DumpTokenStream
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|TokenStream
modifier|*
name|s
parameter_list|,
name|yystypepp
modifier|*
name|yylvalpp
parameter_list|)
block|{
name|int
name|token
decl_stmt|;
name|char
name|str
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|fp
operator|==
literal|0
condition|)
name|fp
operator|=
name|stdout
expr_stmt|;
name|RewindTokenStream
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|token
operator|=
name|ReadToken
argument_list|(
name|s
argument_list|,
name|yylvalpp
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|CPP_IDENTIFIER
case|:
case|case
name|CPP_TYPEIDENTIFIER
case|:
name|snprintf
argument_list|(
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
literal|"%s "
argument_list|,
name|GetAtomString
argument_list|(
name|atable
argument_list|,
name|yylvalpp
operator|->
name|sc_ident
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_STRCONSTANT
case|:
name|snprintf
argument_list|(
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
literal|"\"%s\""
argument_list|,
name|GetAtomString
argument_list|(
name|atable
argument_list|,
name|yylvalpp
operator|->
name|sc_ident
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_FLOATCONSTANT
case|:
comment|//printf("%g9.6 ", yylvalpp->sc_fval);
break|break;
case|case
name|CPP_INTCONSTANT
case|:
comment|//printf("%d ", yylvalpp->sc_int);
break|break;
default|default:
if|if
condition|(
name|token
operator|>=
literal|127
condition|)
name|snprintf
argument_list|(
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
literal|"%s "
argument_list|,
name|GetAtomString
argument_list|(
name|atable
argument_list|,
name|token
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
literal|"%c"
argument_list|,
name|token
argument_list|)
expr_stmt|;
break|break;
block|}
name|CPPDebugLogMsg
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|/////////////////////////////////////// End of tokens.c ///////////////////////////////////////
end_comment
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////////////////////
end_comment
end_unit
