begin_unit
begin_comment
comment|/****************************************************************************\ Copyright (c) 2002, NVIDIA Corporation.  NVIDIA Corporation("NVIDIA") supplies this software to you in consideration of your agreement to the following terms, and your use, installation, modification or redistribution of this NVIDIA software constitutes acceptance of these terms.  If you do not agree with these terms, please do not use, install, modify or redistribute this NVIDIA software.  In consideration of your agreement to abide by the following terms, and subject to these terms, NVIDIA grants you a personal, non-exclusive license, under NVIDIA's copyrights in this original NVIDIA software (the "NVIDIA Software"), to use, reproduce, modify and redistribute the NVIDIA Software, with or without modifications, in source and/or binary forms; provided that if you redistribute the NVIDIA Software, you must retain the copyright notice of NVIDIA, this notice and the following text and disclaimers in all such redistributions of the NVIDIA Software. Neither the name, trademarks, service marks nor logos of NVIDIA Corporation may be used to endorse or promote products derived from the NVIDIA Software without specific prior written permission from NVIDIA. Except as expressly stated in this notice, no other rights or licenses express or implied, are granted by NVIDIA herein, including but not limited to any patent rights that may be infringed by your derivative works or by other works in which the NVIDIA Software may be incorporated. No hardware is licensed hereunder.   THE NVIDIA SOFTWARE IS BEING PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR ITS USE AND OPERATION EITHER ALONE OR IN COMBINATION WITH OTHER PRODUCTS.  IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, EXEMPLARY, CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, LOST PROFITS; PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) OR ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION OF THE NVIDIA SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. \****************************************************************************/
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// atom.c
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_include
include|#
directive|include
file|"common/angleutils.h"
end_include
begin_include
include|#
directive|include
file|"compiler/debug.h"
end_include
begin_include
include|#
directive|include
file|"compiler/preprocessor/slglobals.h"
end_include
begin_undef
DECL|macro|malloc
undef|#
directive|undef
name|malloc
end_undef
begin_undef
DECL|macro|realloc
undef|#
directive|undef
name|realloc
end_undef
begin_undef
DECL|macro|free
undef|#
directive|undef
name|free
end_undef
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|////////////////////////////////////////// String table: //////////////////////////////////////
end_comment
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////////////////////
end_comment
begin_struct
specifier|static
specifier|const
struct|struct
block|{
DECL|member|val
name|int
name|val
decl_stmt|;
DECL|member|str
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|}
DECL|variable|tokens
name|tokens
index|[]
init|=
block|{
block|{
name|CPP_AND_OP
block|,
literal|"&&"
block|}
block|,
block|{
name|CPP_AND_ASSIGN
block|,
literal|"&="
block|}
block|,
block|{
name|CPP_SUB_ASSIGN
block|,
literal|"-="
block|}
block|,
block|{
name|CPP_MOD_ASSIGN
block|,
literal|"%="
block|}
block|,
block|{
name|CPP_ADD_ASSIGN
block|,
literal|"+="
block|}
block|,
block|{
name|CPP_DIV_ASSIGN
block|,
literal|"/="
block|}
block|,
block|{
name|CPP_MUL_ASSIGN
block|,
literal|"*="
block|}
block|,
block|{
name|CPP_RIGHT_BRACKET
block|,
literal|":>"
block|}
block|,
block|{
name|CPP_EQ_OP
block|,
literal|"=="
block|}
block|,
block|{
name|CPP_XOR_OP
block|,
literal|"^^"
block|}
block|,
block|{
name|CPP_XOR_ASSIGN
block|,
literal|"^="
block|}
block|,
block|{
name|CPP_FLOATCONSTANT
block|,
literal|"<float-const>"
block|}
block|,
block|{
name|CPP_GE_OP
block|,
literal|">="
block|}
block|,
block|{
name|CPP_RIGHT_OP
block|,
literal|">>"
block|}
block|,
block|{
name|CPP_RIGHT_ASSIGN
block|,
literal|">>="
block|}
block|,
block|{
name|CPP_IDENTIFIER
block|,
literal|"<ident>"
block|}
block|,
block|{
name|CPP_INTCONSTANT
block|,
literal|"<int-const>"
block|}
block|,
block|{
name|CPP_LE_OP
block|,
literal|"<="
block|}
block|,
block|{
name|CPP_LEFT_OP
block|,
literal|"<<"
block|}
block|,
block|{
name|CPP_LEFT_ASSIGN
block|,
literal|"<<="
block|}
block|,
block|{
name|CPP_LEFT_BRACKET
block|,
literal|"<:"
block|}
block|,
block|{
name|CPP_LEFT_BRACE
block|,
literal|"<%"
block|}
block|,
block|{
name|CPP_DEC_OP
block|,
literal|"--"
block|}
block|,
block|{
name|CPP_RIGHT_BRACE
block|,
literal|"%>"
block|}
block|,
block|{
name|CPP_NE_OP
block|,
literal|"!="
block|}
block|,
block|{
name|CPP_OR_OP
block|,
literal|"||"
block|}
block|,
block|{
name|CPP_OR_ASSIGN
block|,
literal|"|="
block|}
block|,
block|{
name|CPP_INC_OP
block|,
literal|"++"
block|}
block|,
block|{
name|CPP_STRCONSTANT
block|,
literal|"<string-const>"
block|}
block|,
block|{
name|CPP_TYPEIDENTIFIER
block|,
literal|"<type-ident>"
block|}
block|, }
struct|;
end_struct
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|////////////////////////////////////////// String table: //////////////////////////////////////
end_comment
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////////////////////
end_comment
begin_define
DECL|macro|INIT_STRING_TABLE_SIZE
define|#
directive|define
name|INIT_STRING_TABLE_SIZE
value|16384
end_define
begin_typedef
DECL|struct|StringTable_Rec
typedef|typedef
struct|struct
name|StringTable_Rec
block|{
DECL|member|strings
name|char
modifier|*
name|strings
decl_stmt|;
DECL|member|nextFree
name|int
name|nextFree
decl_stmt|;
DECL|member|size
name|int
name|size
decl_stmt|;
block|}
DECL|typedef|StringTable
name|StringTable
typedef|;
end_typedef
begin_comment
comment|/*  * InitStringTable() - Initialize the string table.  *  */
end_comment
begin_function
DECL|function|InitStringTable
specifier|static
name|int
name|InitStringTable
parameter_list|(
name|StringTable
modifier|*
name|stable
parameter_list|)
block|{
name|stable
operator|->
name|strings
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|INIT_STRING_TABLE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stable
operator|->
name|strings
condition|)
return|return
literal|0
return|;
comment|// Zero-th offset means "empty" so don't use it.
name|stable
operator|->
name|nextFree
operator|=
literal|1
expr_stmt|;
name|stable
operator|->
name|size
operator|=
name|INIT_STRING_TABLE_SIZE
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|// InitStringTable
end_comment
begin_comment
comment|/*  * FreeStringTable() - Free the string table.  *  */
end_comment
begin_function
DECL|function|FreeStringTable
specifier|static
name|void
name|FreeStringTable
parameter_list|(
name|StringTable
modifier|*
name|stable
parameter_list|)
block|{
if|if
condition|(
name|stable
operator|->
name|strings
condition|)
name|free
argument_list|(
name|stable
operator|->
name|strings
argument_list|)
expr_stmt|;
name|stable
operator|->
name|strings
operator|=
name|NULL
expr_stmt|;
name|stable
operator|->
name|nextFree
operator|=
literal|0
expr_stmt|;
name|stable
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|// FreeStringTable
end_comment
begin_comment
comment|/*  * HashString() - Hash a string with the base hash function.  *  */
end_comment
begin_function
DECL|function|HashString
specifier|static
name|int
name|HashString
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|hval
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|hval
operator|=
operator|(
name|hval
operator|*
literal|13507
operator|+
operator|*
name|s
operator|*
literal|197
operator|)
operator|^
operator|(
name|hval
operator|>>
literal|2
operator|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
return|return
name|hval
operator|&
literal|0x7fffffff
return|;
block|}
end_function
begin_comment
comment|// HashString
end_comment
begin_comment
comment|/*  * HashString2() - Hash a string with the incrimenting hash function.  *  */
end_comment
begin_function
DECL|function|HashString2
specifier|static
name|int
name|HashString2
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|hval
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|hval
operator|=
operator|(
name|hval
operator|*
literal|729
operator|+
operator|*
name|s
operator|*
literal|37
operator|)
operator|^
operator|(
name|hval
operator|>>
literal|1
operator|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
return|return
name|hval
return|;
block|}
end_function
begin_comment
comment|// HashString2
end_comment
begin_comment
comment|/*  * AddString() - Add a string to a string table.  Return it's offset.  *  */
end_comment
begin_function
DECL|function|AddString
specifier|static
name|int
name|AddString
parameter_list|(
name|StringTable
modifier|*
name|stable
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|loc
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|len
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|stable
operator|->
name|nextFree
operator|+
name|len
operator|+
literal|1
operator|>=
name|stable
operator|->
name|size
condition|)
block|{
name|assert
argument_list|(
name|stable
operator|->
name|size
operator|<
literal|1000000
argument_list|)
expr_stmt|;
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|stable
operator|->
name|size
operator|*
literal|2
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|str
argument_list|,
name|stable
operator|->
name|strings
argument_list|,
name|stable
operator|->
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|stable
operator|->
name|strings
argument_list|)
expr_stmt|;
name|stable
operator|->
name|strings
operator|=
name|str
expr_stmt|;
name|stable
operator|->
name|size
operator|=
name|stable
operator|->
name|size
operator|*
literal|2
expr_stmt|;
block|}
name|loc
operator|=
name|stable
operator|->
name|nextFree
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|stable
operator|->
name|strings
index|[
name|loc
index|]
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|stable
operator|->
name|nextFree
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
return|return
name|loc
return|;
block|}
end_function
begin_comment
comment|// AddString
end_comment
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|/////////////////////////////////////////// Hash table: ///////////////////////////////////////
end_comment
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////////////////////
end_comment
begin_define
DECL|macro|INIT_HASH_TABLE_SIZE
define|#
directive|define
name|INIT_HASH_TABLE_SIZE
value|2047
end_define
begin_define
DECL|macro|HASH_TABLE_MAX_COLLISIONS
define|#
directive|define
name|HASH_TABLE_MAX_COLLISIONS
value|3
end_define
begin_typedef
DECL|struct|HashEntry_Rec
typedef|typedef
struct|struct
name|HashEntry_Rec
block|{
DECL|member|index
name|int
name|index
decl_stmt|;
comment|// String table offset of string representation
DECL|member|value
name|int
name|value
decl_stmt|;
comment|// Atom (symbol) value
block|}
DECL|typedef|HashEntry
name|HashEntry
typedef|;
end_typedef
begin_typedef
DECL|struct|HashTable_Rec
typedef|typedef
struct|struct
name|HashTable_Rec
block|{
DECL|member|entry
name|HashEntry
modifier|*
name|entry
decl_stmt|;
DECL|member|size
name|int
name|size
decl_stmt|;
DECL|member|entries
name|int
name|entries
decl_stmt|;
DECL|member|counts
name|int
name|counts
index|[
name|HASH_TABLE_MAX_COLLISIONS
operator|+
literal|1
index|]
decl_stmt|;
block|}
DECL|typedef|HashTable
name|HashTable
typedef|;
end_typedef
begin_comment
comment|/*  * InitHashTable() - Initialize the hash table.  *  */
end_comment
begin_function
DECL|function|InitHashTable
specifier|static
name|int
name|InitHashTable
parameter_list|(
name|HashTable
modifier|*
name|htable
parameter_list|,
name|int
name|fsize
parameter_list|)
block|{
name|int
name|ii
decl_stmt|;
name|htable
operator|->
name|entry
operator|=
operator|(
name|HashEntry
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HashEntry
argument_list|)
operator|*
name|fsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htable
operator|->
name|entry
condition|)
return|return
literal|0
return|;
name|htable
operator|->
name|size
operator|=
name|fsize
expr_stmt|;
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|fsize
condition|;
name|ii
operator|++
control|)
block|{
name|htable
operator|->
name|entry
index|[
name|ii
index|]
operator|.
name|index
operator|=
literal|0
expr_stmt|;
name|htable
operator|->
name|entry
index|[
name|ii
index|]
operator|.
name|value
operator|=
literal|0
expr_stmt|;
block|}
name|htable
operator|->
name|entries
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<=
name|HASH_TABLE_MAX_COLLISIONS
condition|;
name|ii
operator|++
control|)
name|htable
operator|->
name|counts
index|[
name|ii
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|// InitHashTable
end_comment
begin_comment
comment|/*  * FreeHashTable() - Free the hash table.  *  */
end_comment
begin_function
DECL|function|FreeHashTable
specifier|static
name|void
name|FreeHashTable
parameter_list|(
name|HashTable
modifier|*
name|htable
parameter_list|)
block|{
if|if
condition|(
name|htable
operator|->
name|entry
condition|)
name|free
argument_list|(
name|htable
operator|->
name|entry
argument_list|)
expr_stmt|;
name|htable
operator|->
name|entry
operator|=
name|NULL
expr_stmt|;
name|htable
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|htable
operator|->
name|entries
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|// FreeHashTable
end_comment
begin_comment
comment|/*  * Empty() - See if a hash table entry is empty.  *  */
end_comment
begin_function
DECL|function|Empty
specifier|static
name|int
name|Empty
parameter_list|(
name|HashTable
modifier|*
name|htable
parameter_list|,
name|int
name|hashloc
parameter_list|)
block|{
name|assert
argument_list|(
name|hashloc
operator|>=
literal|0
operator|&&
name|hashloc
operator|<
name|htable
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|htable
operator|->
name|entry
index|[
name|hashloc
index|]
operator|.
name|index
operator|==
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
end_function
begin_comment
comment|// Empty
end_comment
begin_comment
comment|/*  * Match() - See if a hash table entry is matches a string.  *  */
end_comment
begin_function
DECL|function|Match
specifier|static
name|int
name|Match
parameter_list|(
name|HashTable
modifier|*
name|htable
parameter_list|,
name|StringTable
modifier|*
name|stable
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|hashloc
parameter_list|)
block|{
name|int
name|strloc
decl_stmt|;
name|strloc
operator|=
name|htable
operator|->
name|entry
index|[
name|hashloc
index|]
operator|.
name|index
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
operator|&
name|stable
operator|->
name|strings
index|[
name|strloc
index|]
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
end_function
begin_comment
comment|// Match
end_comment
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|/////////////////////////////////////////// Atom table: ///////////////////////////////////////
end_comment
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////////////////////
end_comment
begin_define
DECL|macro|INIT_ATOM_TABLE_SIZE
define|#
directive|define
name|INIT_ATOM_TABLE_SIZE
value|1024
end_define
begin_struct
DECL|struct|AtomTable_Rec
struct|struct
name|AtomTable_Rec
block|{
DECL|member|stable
name|StringTable
name|stable
decl_stmt|;
comment|// String table.
DECL|member|htable
name|HashTable
name|htable
decl_stmt|;
comment|// Hashes string to atom number and token value.  Multiple strings can
comment|// have the same token value but each unique string is a unique atom.
DECL|member|amap
name|int
modifier|*
name|amap
decl_stmt|;
comment|// Maps atom value to offset in string table.  Atoms all map to unique
comment|// strings except for some undefined values in the lower, fixed part
comment|// of the atom table that map to "<undefined>".  The lowest 256 atoms
comment|// correspond to single character ASCII values except for alphanumeric
comment|// characters and '_', which can be other tokens.  Next come the
comment|// language tokens with their atom values equal to the token value.
comment|// Then come predefined atoms, followed by user specified identifiers.
DECL|member|arev
name|int
modifier|*
name|arev
decl_stmt|;
comment|// Reversed atom for symbol table use.
DECL|member|nextFree
name|int
name|nextFree
decl_stmt|;
DECL|member|size
name|int
name|size
decl_stmt|;
block|}
struct|;
end_struct
begin_decl_stmt
DECL|variable|latable
specifier|static
name|AtomTable
name|latable
init|=
block|{
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|}
block|}
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|atable
name|AtomTable
modifier|*
name|atable
init|=
operator|&
name|latable
decl_stmt|;
end_decl_stmt
begin_function_decl
specifier|static
name|int
name|AddAtomFixed
parameter_list|(
name|AtomTable
modifier|*
name|atable
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|atom
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*  * GrowAtomTable() - Grow the atom table to at least "size" if it's smaller.  *  */
end_comment
begin_function
DECL|function|GrowAtomTable
specifier|static
name|int
name|GrowAtomTable
parameter_list|(
name|AtomTable
modifier|*
name|atable
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
modifier|*
name|newmap
decl_stmt|,
modifier|*
name|newrev
decl_stmt|;
if|if
condition|(
name|atable
operator|->
name|size
operator|<
name|size
condition|)
block|{
if|if
condition|(
name|atable
operator|->
name|amap
condition|)
block|{
name|newmap
operator|=
name|realloc
argument_list|(
name|atable
operator|->
name|amap
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|size
argument_list|)
expr_stmt|;
name|newrev
operator|=
name|realloc
argument_list|(
name|atable
operator|->
name|arev
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newmap
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|size
argument_list|)
expr_stmt|;
name|newrev
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|size
argument_list|)
expr_stmt|;
name|atable
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|newmap
operator|||
operator|!
name|newrev
condition|)
block|{
comment|/* failed to grow -- error */
if|if
condition|(
name|newmap
condition|)
name|atable
operator|->
name|amap
operator|=
name|newmap
expr_stmt|;
if|if
condition|(
name|newrev
condition|)
name|atable
operator|->
name|arev
operator|=
name|newrev
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|memset
argument_list|(
operator|&
name|newmap
index|[
name|atable
operator|->
name|size
index|]
argument_list|,
literal|0
argument_list|,
operator|(
name|size
operator|-
name|atable
operator|->
name|size
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|newrev
index|[
name|atable
operator|->
name|size
index|]
argument_list|,
literal|0
argument_list|,
operator|(
name|size
operator|-
name|atable
operator|->
name|size
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|atable
operator|->
name|amap
operator|=
name|newmap
expr_stmt|;
name|atable
operator|->
name|arev
operator|=
name|newrev
expr_stmt|;
name|atable
operator|->
name|size
operator|=
name|size
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|// GrowAtomTable
end_comment
begin_comment
comment|/*  * lReverse() - Reverse the bottom 20 bits of a 32 bit int.  *  */
end_comment
begin_function
DECL|function|lReverse
specifier|static
name|int
name|lReverse
parameter_list|(
name|int
name|fval
parameter_list|)
block|{
name|unsigned
name|int
name|in
init|=
name|fval
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|,
name|cnt
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|in
condition|)
block|{
name|result
operator|<<=
literal|1
expr_stmt|;
name|result
operator||=
name|in
operator|&
literal|1
expr_stmt|;
name|in
operator|>>=
literal|1
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
comment|// Don't use all 31 bits.  One million atoms is plenty and sometimes the
comment|// upper bits are used for other things.
if|if
condition|(
name|cnt
operator|<
literal|20
condition|)
name|result
operator|<<=
literal|20
operator|-
name|cnt
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|// lReverse
end_comment
begin_comment
comment|/*  * AllocateAtom() - Allocate a new atom.  Associated with the "undefined" value of -1.  *  */
end_comment
begin_function
DECL|function|AllocateAtom
specifier|static
name|int
name|AllocateAtom
parameter_list|(
name|AtomTable
modifier|*
name|atable
parameter_list|)
block|{
if|if
condition|(
name|atable
operator|->
name|nextFree
operator|>=
name|atable
operator|->
name|size
condition|)
name|GrowAtomTable
argument_list|(
name|atable
argument_list|,
name|atable
operator|->
name|nextFree
operator|*
literal|2
argument_list|)
expr_stmt|;
name|atable
operator|->
name|amap
index|[
name|atable
operator|->
name|nextFree
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|atable
operator|->
name|arev
index|[
name|atable
operator|->
name|nextFree
index|]
operator|=
name|lReverse
argument_list|(
name|atable
operator|->
name|nextFree
argument_list|)
expr_stmt|;
name|atable
operator|->
name|nextFree
operator|++
expr_stmt|;
return|return
name|atable
operator|->
name|nextFree
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|// AllocateAtom
end_comment
begin_comment
comment|/*  * SetAtomValue() - Allocate a new atom associated with "hashindex".  *  */
end_comment
begin_function
DECL|function|SetAtomValue
specifier|static
name|void
name|SetAtomValue
parameter_list|(
name|AtomTable
modifier|*
name|atable
parameter_list|,
name|int
name|atomnumber
parameter_list|,
name|int
name|hashindex
parameter_list|)
block|{
name|atable
operator|->
name|amap
index|[
name|atomnumber
index|]
operator|=
name|atable
operator|->
name|htable
operator|.
name|entry
index|[
name|hashindex
index|]
operator|.
name|index
expr_stmt|;
name|atable
operator|->
name|htable
operator|.
name|entry
index|[
name|hashindex
index|]
operator|.
name|value
operator|=
name|atomnumber
expr_stmt|;
block|}
end_function
begin_comment
comment|// SetAtomValue
end_comment
begin_comment
comment|/*  * FindHashLoc() - Find the hash location for this string.  Return -1 it hash table is full.  *  */
end_comment
begin_function
DECL|function|FindHashLoc
specifier|static
name|int
name|FindHashLoc
parameter_list|(
name|AtomTable
modifier|*
name|atable
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|hashloc
decl_stmt|,
name|hashdelta
decl_stmt|,
name|count
decl_stmt|;
name|int
name|FoundEmptySlot
init|=
literal|0
decl_stmt|;
name|int
name|collision
index|[
name|HASH_TABLE_MAX_COLLISIONS
operator|+
literal|1
index|]
decl_stmt|;
name|hashloc
operator|=
name|HashString
argument_list|(
name|s
argument_list|)
operator|%
name|atable
operator|->
name|htable
operator|.
name|size
expr_stmt|;
if|if
condition|(
operator|!
name|Empty
argument_list|(
operator|&
name|atable
operator|->
name|htable
argument_list|,
name|hashloc
argument_list|)
condition|)
block|{
if|if
condition|(
name|Match
argument_list|(
operator|&
name|atable
operator|->
name|htable
argument_list|,
operator|&
name|atable
operator|->
name|stable
argument_list|,
name|s
argument_list|,
name|hashloc
argument_list|)
condition|)
return|return
name|hashloc
return|;
name|collision
index|[
literal|0
index|]
operator|=
name|hashloc
expr_stmt|;
name|hashdelta
operator|=
name|HashString2
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|count
operator|<
name|HASH_TABLE_MAX_COLLISIONS
condition|)
block|{
name|hashloc
operator|=
operator|(
operator|(
name|hashloc
operator|+
name|hashdelta
operator|)
operator|&
literal|0x7fffffff
operator|)
operator|%
name|atable
operator|->
name|htable
operator|.
name|size
expr_stmt|;
if|if
condition|(
operator|!
name|Empty
argument_list|(
operator|&
name|atable
operator|->
name|htable
argument_list|,
name|hashloc
argument_list|)
condition|)
block|{
if|if
condition|(
name|Match
argument_list|(
operator|&
name|atable
operator|->
name|htable
argument_list|,
operator|&
name|atable
operator|->
name|stable
argument_list|,
name|s
argument_list|,
name|hashloc
argument_list|)
condition|)
block|{
return|return
name|hashloc
return|;
block|}
block|}
else|else
block|{
name|FoundEmptySlot
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|count
operator|++
expr_stmt|;
name|collision
index|[
name|count
index|]
operator|=
name|hashloc
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|FoundEmptySlot
condition|)
block|{
if|if
condition|(
name|cpp
operator|->
name|options
operator|.
name|DumpAtomTable
condition|)
block|{
name|int
name|ii
decl_stmt|;
name|char
name|str
index|[
literal|200
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
literal|"*** Hash failed with more than %d collisions. Must increase hash table size. ***"
argument_list|,
name|HASH_TABLE_MAX_COLLISIONS
argument_list|)
expr_stmt|;
name|CPPShInfoLogMsg
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
literal|"*** New string \"%s\", hash=%04x, delta=%04x"
argument_list|,
name|s
argument_list|,
name|collision
index|[
literal|0
index|]
argument_list|,
name|hashdelta
argument_list|)
expr_stmt|;
name|CPPShInfoLogMsg
argument_list|(
name|str
argument_list|)
expr_stmt|;
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<=
name|HASH_TABLE_MAX_COLLISIONS
condition|;
name|ii
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
literal|"*** Collides on try %d at hash entry %04x with \"%s\""
argument_list|,
name|ii
operator|+
literal|1
argument_list|,
name|collision
index|[
name|ii
index|]
argument_list|,
name|GetAtomString
argument_list|(
name|atable
argument_list|,
name|atable
operator|->
name|htable
operator|.
name|entry
index|[
name|collision
index|[
name|ii
index|]
index|]
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|CPPShInfoLogMsg
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|atable
operator|->
name|htable
operator|.
name|counts
index|[
name|count
index|]
operator|++
expr_stmt|;
block|}
block|}
return|return
name|hashloc
return|;
block|}
end_function
begin_comment
comment|// FindHashLoc
end_comment
begin_comment
comment|/*  * IncreaseHashTableSize()  *  */
end_comment
begin_function
DECL|function|IncreaseHashTableSize
specifier|static
name|int
name|IncreaseHashTableSize
parameter_list|(
name|AtomTable
modifier|*
name|atable
parameter_list|)
block|{
name|int
name|ii
decl_stmt|,
name|strloc
decl_stmt|,
name|oldhashloc
decl_stmt|,
name|value
decl_stmt|,
name|size
decl_stmt|;
name|AtomTable
name|oldtable
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
comment|// Save the old atom table and create a new one:
name|oldtable
operator|=
operator|*
name|atable
expr_stmt|;
name|size
operator|=
name|oldtable
operator|.
name|htable
operator|.
name|size
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|InitAtomTable
argument_list|(
name|atable
argument_list|,
name|size
argument_list|)
condition|)
return|return
literal|0
return|;
comment|// Add all the existing values to the new atom table preserving their atom values:
for|for
control|(
name|ii
operator|=
name|atable
operator|->
name|nextFree
init|;
name|ii
operator|<
name|oldtable
operator|.
name|nextFree
condition|;
name|ii
operator|++
control|)
block|{
name|strloc
operator|=
name|oldtable
operator|.
name|amap
index|[
name|ii
index|]
expr_stmt|;
name|s
operator|=
operator|&
name|oldtable
operator|.
name|stable
operator|.
name|strings
index|[
name|strloc
index|]
expr_stmt|;
name|oldhashloc
operator|=
name|FindHashLoc
argument_list|(
operator|&
name|oldtable
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|oldhashloc
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|value
operator|=
name|oldtable
operator|.
name|htable
operator|.
name|entry
index|[
name|oldhashloc
index|]
operator|.
name|value
expr_stmt|;
name|AddAtomFixed
argument_list|(
name|atable
argument_list|,
name|s
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|FreeAtomTable
argument_list|(
operator|&
name|oldtable
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|// IncreaseHashTableSize
end_comment
begin_comment
comment|/*  * LookUpAddStringHash() - Lookup a string in the hash table.  If it's not there, add it and  *        initialize the atom value in the hash table to 0.  Return the hash table index.  */
end_comment
begin_function
DECL|function|LookUpAddStringHash
specifier|static
name|int
name|LookUpAddStringHash
parameter_list|(
name|AtomTable
modifier|*
name|atable
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|hashloc
decl_stmt|,
name|strloc
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|hashloc
operator|=
name|FindHashLoc
argument_list|(
name|atable
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashloc
operator|>=
literal|0
condition|)
break|break;
name|IncreaseHashTableSize
argument_list|(
name|atable
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Empty
argument_list|(
operator|&
name|atable
operator|->
name|htable
argument_list|,
name|hashloc
argument_list|)
condition|)
block|{
name|atable
operator|->
name|htable
operator|.
name|entries
operator|++
expr_stmt|;
name|strloc
operator|=
name|AddString
argument_list|(
operator|&
name|atable
operator|->
name|stable
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|atable
operator|->
name|htable
operator|.
name|entry
index|[
name|hashloc
index|]
operator|.
name|index
operator|=
name|strloc
expr_stmt|;
name|atable
operator|->
name|htable
operator|.
name|entry
index|[
name|hashloc
index|]
operator|.
name|value
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|hashloc
return|;
block|}
end_function
begin_comment
comment|// LookUpAddStringHash
end_comment
begin_comment
comment|/*  * LookUpAddString() - Lookup a string in the hash table.  If it's not there, add it and  *        initialize the atom value in the hash table to the next atom number.  *        Return the atom value of string.  */
end_comment
begin_function
DECL|function|LookUpAddString
name|int
name|LookUpAddString
parameter_list|(
name|AtomTable
modifier|*
name|atable
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|hashindex
decl_stmt|,
name|atom
decl_stmt|;
name|hashindex
operator|=
name|LookUpAddStringHash
argument_list|(
name|atable
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|atom
operator|=
name|atable
operator|->
name|htable
operator|.
name|entry
index|[
name|hashindex
index|]
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|atom
operator|==
literal|0
condition|)
block|{
name|atom
operator|=
name|AllocateAtom
argument_list|(
name|atable
argument_list|)
expr_stmt|;
name|SetAtomValue
argument_list|(
name|atable
argument_list|,
name|atom
argument_list|,
name|hashindex
argument_list|)
expr_stmt|;
block|}
return|return
name|atom
return|;
block|}
end_function
begin_comment
comment|// LookUpAddString
end_comment
begin_comment
comment|/*  * GetAtomString()  *  */
end_comment
begin_function
DECL|function|GetAtomString
specifier|const
name|char
modifier|*
name|GetAtomString
parameter_list|(
name|AtomTable
modifier|*
name|atable
parameter_list|,
name|int
name|atom
parameter_list|)
block|{
name|int
name|soffset
decl_stmt|;
if|if
condition|(
name|atom
operator|>
literal|0
operator|&&
name|atom
operator|<
name|atable
operator|->
name|nextFree
condition|)
block|{
name|soffset
operator|=
name|atable
operator|->
name|amap
index|[
name|atom
index|]
expr_stmt|;
if|if
condition|(
name|soffset
operator|>
literal|0
operator|&&
name|soffset
operator|<
name|atable
operator|->
name|stable
operator|.
name|nextFree
condition|)
block|{
return|return
operator|&
name|atable
operator|->
name|stable
operator|.
name|strings
index|[
name|soffset
index|]
return|;
block|}
else|else
block|{
return|return
literal|"<internal error: bad soffset>"
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|atom
operator|==
literal|0
condition|)
block|{
return|return
literal|"<null atom>"
return|;
block|}
else|else
block|{
if|if
condition|(
name|atom
operator|==
name|EOF
condition|)
block|{
return|return
literal|"<EOF>"
return|;
block|}
else|else
block|{
return|return
literal|"<invalid atom>"
return|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|// GetAtomString
end_comment
begin_comment
comment|/*  * GetReversedAtom()  *  */
end_comment
begin_function
DECL|function|GetReversedAtom
name|int
name|GetReversedAtom
parameter_list|(
name|AtomTable
modifier|*
name|atable
parameter_list|,
name|int
name|atom
parameter_list|)
block|{
if|if
condition|(
name|atom
operator|>
literal|0
operator|&&
name|atom
operator|<
name|atable
operator|->
name|nextFree
condition|)
block|{
return|return
name|atable
operator|->
name|arev
index|[
name|atom
index|]
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
end_function
begin_comment
comment|// GetReversedAtom
end_comment
begin_comment
comment|/*  * AddAtom() - Add a string to the atom, hash and string tables if it isn't already there.  *         Return it's atom index.  */
end_comment
begin_function
DECL|function|AddAtom
name|int
name|AddAtom
parameter_list|(
name|AtomTable
modifier|*
name|atable
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|atom
decl_stmt|;
name|atom
operator|=
name|LookUpAddString
argument_list|(
name|atable
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|atom
return|;
block|}
end_function
begin_comment
comment|// AddAtom
end_comment
begin_comment
comment|/*  * AddAtomFixed() - Add an atom to the hash and string tables if it isn't already there.  *         Assign it the atom value of "atom".  */
end_comment
begin_function
DECL|function|AddAtomFixed
specifier|static
name|int
name|AddAtomFixed
parameter_list|(
name|AtomTable
modifier|*
name|atable
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|atom
parameter_list|)
block|{
name|int
name|hashindex
decl_stmt|,
name|lsize
decl_stmt|;
name|hashindex
operator|=
name|LookUpAddStringHash
argument_list|(
name|atable
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|atable
operator|->
name|nextFree
operator|>=
name|atable
operator|->
name|size
operator|||
name|atom
operator|>=
name|atable
operator|->
name|size
condition|)
block|{
name|lsize
operator|=
name|atable
operator|->
name|size
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|lsize
operator|<=
name|atom
condition|)
name|lsize
operator|=
name|atom
operator|+
literal|1
expr_stmt|;
name|GrowAtomTable
argument_list|(
name|atable
argument_list|,
name|lsize
argument_list|)
expr_stmt|;
block|}
name|atable
operator|->
name|amap
index|[
name|atom
index|]
operator|=
name|atable
operator|->
name|htable
operator|.
name|entry
index|[
name|hashindex
index|]
operator|.
name|index
expr_stmt|;
name|atable
operator|->
name|htable
operator|.
name|entry
index|[
name|hashindex
index|]
operator|.
name|value
operator|=
name|atom
expr_stmt|;
comment|//if (atom>= atable->nextFree)
comment|//    atable->nextFree = atom + 1;
while|while
condition|(
name|atom
operator|>=
name|atable
operator|->
name|nextFree
condition|)
block|{
name|atable
operator|->
name|arev
index|[
name|atable
operator|->
name|nextFree
index|]
operator|=
name|lReverse
argument_list|(
name|atable
operator|->
name|nextFree
argument_list|)
expr_stmt|;
name|atable
operator|->
name|nextFree
operator|++
expr_stmt|;
block|}
return|return
name|atom
return|;
block|}
end_function
begin_comment
comment|// AddAtomFixed
end_comment
begin_comment
comment|/*  * InitAtomTable() - Initialize the atom table.  *  */
end_comment
begin_function
DECL|function|InitAtomTable
name|int
name|InitAtomTable
parameter_list|(
name|AtomTable
modifier|*
name|atable
parameter_list|,
name|int
name|htsize
parameter_list|)
block|{
name|unsigned
name|int
name|ii
decl_stmt|;
name|htsize
operator|=
name|htsize
operator|<=
literal|0
condition|?
name|INIT_HASH_TABLE_SIZE
else|:
name|htsize
expr_stmt|;
if|if
condition|(
operator|!
name|InitStringTable
argument_list|(
operator|&
name|atable
operator|->
name|stable
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|InitHashTable
argument_list|(
operator|&
name|atable
operator|->
name|htable
argument_list|,
name|htsize
argument_list|)
condition|)
return|return
literal|0
return|;
name|atable
operator|->
name|nextFree
operator|=
literal|0
expr_stmt|;
name|atable
operator|->
name|amap
operator|=
name|NULL
expr_stmt|;
name|atable
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|GrowAtomTable
argument_list|(
name|atable
argument_list|,
name|INIT_ATOM_TABLE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|atable
operator|->
name|amap
condition|)
return|return
literal|0
return|;
comment|// Initialize lower part of atom table to "<undefined>" atom:
name|AddAtomFixed
argument_list|(
name|atable
argument_list|,
literal|"<undefined>"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|FIRST_USER_TOKEN_SY
condition|;
name|ii
operator|++
control|)
name|atable
operator|->
name|amap
index|[
name|ii
index|]
operator|=
name|atable
operator|->
name|amap
index|[
literal|0
index|]
expr_stmt|;
comment|// Add single character tokens to the atom table:
block|{
specifier|const
name|char
modifier|*
name|s
init|=
literal|"~!%^&*()-+=|,.<>/?;:[]{}#"
decl_stmt|;
name|char
name|t
index|[
literal|2
index|]
decl_stmt|;
name|t
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|t
index|[
literal|0
index|]
operator|=
operator|*
name|s
expr_stmt|;
name|AddAtomFixed
argument_list|(
name|atable
argument_list|,
name|t
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
block|}
comment|// Add multiple character scanner tokens :
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
sizeof|sizeof
argument_list|(
name|tokens
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|tokens
index|[
literal|0
index|]
argument_list|)
condition|;
name|ii
operator|++
control|)
name|AddAtomFixed
argument_list|(
name|atable
argument_list|,
name|tokens
index|[
name|ii
index|]
operator|.
name|str
argument_list|,
name|tokens
index|[
name|ii
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
comment|// Add error symbol if running in error mode:
if|if
condition|(
name|cpp
operator|->
name|options
operator|.
name|ErrorMode
condition|)
name|AddAtomFixed
argument_list|(
name|atable
argument_list|,
literal|"error"
argument_list|,
name|ERROR_SY
argument_list|)
expr_stmt|;
name|AddAtom
argument_list|(
name|atable
argument_list|,
literal|"<*** end fixed atoms ***>"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|// InitAtomTable
end_comment
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|////////////////////////////////// Debug Printing Functions: //////////////////////////////////
end_comment
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|/*  * PrintAtomTable()  *  */
end_comment
begin_function
DECL|function|PrintAtomTable
name|void
name|PrintAtomTable
parameter_list|(
name|AtomTable
modifier|*
name|atable
parameter_list|)
block|{
name|int
name|ii
decl_stmt|;
name|char
name|str
index|[
literal|200
index|]
decl_stmt|;
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|atable
operator|->
name|nextFree
condition|;
name|ii
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
literal|"%d: \"%s\""
argument_list|,
name|ii
argument_list|,
operator|&
name|atable
operator|->
name|stable
operator|.
name|strings
index|[
name|atable
operator|->
name|amap
index|[
name|ii
index|]
index|]
argument_list|)
expr_stmt|;
name|CPPDebugLogMsg
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
literal|"Hash table: size=%d, entries=%d, collisions="
argument_list|,
name|atable
operator|->
name|htable
operator|.
name|size
argument_list|,
name|atable
operator|->
name|htable
operator|.
name|entries
argument_list|)
expr_stmt|;
name|CPPDebugLogMsg
argument_list|(
name|str
argument_list|)
expr_stmt|;
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|HASH_TABLE_MAX_COLLISIONS
condition|;
name|ii
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
literal|" %d"
argument_list|,
name|atable
operator|->
name|htable
operator|.
name|counts
index|[
name|ii
index|]
argument_list|)
expr_stmt|;
name|CPPDebugLogMsg
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// PrintAtomTable
end_comment
begin_comment
comment|/*  * GetStringOfAtom()  *  */
end_comment
begin_function
DECL|function|GetStringOfAtom
name|char
modifier|*
name|GetStringOfAtom
parameter_list|(
name|AtomTable
modifier|*
name|atable
parameter_list|,
name|int
name|atom
parameter_list|)
block|{
name|char
modifier|*
name|chr_str
decl_stmt|;
name|chr_str
operator|=
operator|&
name|atable
operator|->
name|stable
operator|.
name|strings
index|[
name|atable
operator|->
name|amap
index|[
name|atom
index|]
index|]
expr_stmt|;
return|return
name|chr_str
return|;
block|}
end_function
begin_comment
comment|// GetStringOfAtom
end_comment
begin_comment
comment|/*  * FreeAtomTable() - Free the atom table and associated memory  *  */
end_comment
begin_function
DECL|function|FreeAtomTable
name|void
name|FreeAtomTable
parameter_list|(
name|AtomTable
modifier|*
name|atable
parameter_list|)
block|{
name|FreeStringTable
argument_list|(
operator|&
name|atable
operator|->
name|stable
argument_list|)
expr_stmt|;
name|FreeHashTable
argument_list|(
operator|&
name|atable
operator|->
name|htable
argument_list|)
expr_stmt|;
if|if
condition|(
name|atable
operator|->
name|amap
condition|)
name|free
argument_list|(
name|atable
operator|->
name|amap
argument_list|)
expr_stmt|;
if|if
condition|(
name|atable
operator|->
name|arev
condition|)
name|free
argument_list|(
name|atable
operator|->
name|arev
argument_list|)
expr_stmt|;
name|atable
operator|->
name|amap
operator|=
name|NULL
expr_stmt|;
name|atable
operator|->
name|arev
operator|=
name|NULL
expr_stmt|;
name|atable
operator|->
name|nextFree
operator|=
literal|0
expr_stmt|;
name|atable
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|// FreeAtomTable
end_comment
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|///////////////////////////////////////// End of atom.c ///////////////////////////////////////
end_comment
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////////////////////
end_comment
end_unit
