begin_unit
begin_comment
comment|/****************************************************************************\ Copyright (c) 2002, NVIDIA Corporation.  NVIDIA Corporation("NVIDIA") supplies this software to you in consideration of your agreement to the following terms, and your use, installation, modification or redistribution of this NVIDIA software constitutes acceptance of these terms.  If you do not agree with these terms, please do not use, install, modify or redistribute this NVIDIA software.  In consideration of your agreement to abide by the following terms, and subject to these terms, NVIDIA grants you a personal, non-exclusive license, under NVIDIA's copyrights in this original NVIDIA software (the "NVIDIA Software"), to use, reproduce, modify and redistribute the NVIDIA Software, with or without modifications, in source and/or binary forms; provided that if you redistribute the NVIDIA Software, you must retain the copyright notice of NVIDIA, this notice and the following text and disclaimers in all such redistributions of the NVIDIA Software. Neither the name, trademarks, service marks nor logos of NVIDIA Corporation may be used to endorse or promote products derived from the NVIDIA Software without specific prior written permission from NVIDIA. Except as expressly stated in this notice, no other rights or licenses express or implied, are granted by NVIDIA herein, including but not limited to any patent rights that may be infringed by your derivative works or by other works in which the NVIDIA Software may be incorporated. No hardware is licensed hereunder.   THE NVIDIA SOFTWARE IS BEING PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR ITS USE AND OPERATION EITHER ALONE OR IN COMBINATION WITH OTHER PRODUCTS.  IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, EXEMPLARY, CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, LOST PROFITS; PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) OR ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION OF THE NVIDIA SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. \****************************************************************************/
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|<stddef.h>
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|_MSC_VER
end_ifndef
begin_include
include|#
directive|include
file|<stdint.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"compiler/preprocessor/memory.h"
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_if
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4706
name|)
end_pragma
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// default alignment and chunksize, if called with 0 arguments
end_comment
begin_define
DECL|macro|CHUNKSIZE
define|#
directive|define
name|CHUNKSIZE
value|(64*1024)
end_define
begin_define
DECL|macro|ALIGN
define|#
directive|define
name|ALIGN
value|8
end_define
begin_comment
comment|// we need to call the `real' malloc and free, not our replacements
end_comment
begin_undef
DECL|macro|malloc
undef|#
directive|undef
name|malloc
end_undef
begin_undef
DECL|macro|free
undef|#
directive|undef
name|free
end_undef
begin_struct
DECL|struct|chunk
struct|struct
name|chunk
block|{
DECL|member|next
name|struct
name|chunk
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|cleanup
struct|struct
name|cleanup
block|{
DECL|member|next
name|struct
name|cleanup
modifier|*
name|next
decl_stmt|;
DECL|member|fn
name|void
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
DECL|member|arg
name|void
modifier|*
name|arg
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|MemoryPool_rec
struct|struct
name|MemoryPool_rec
block|{
DECL|member|next
name|struct
name|chunk
modifier|*
name|next
decl_stmt|;
DECL|member|free
DECL|member|end
name|uintptr_t
name|free
decl_stmt|,
name|end
decl_stmt|;
DECL|member|chunksize
name|size_t
name|chunksize
decl_stmt|;
DECL|member|alignmask
name|uintptr_t
name|alignmask
decl_stmt|;
DECL|member|cleanup
name|struct
name|cleanup
modifier|*
name|cleanup
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|mem_CreatePool
name|MemoryPool
modifier|*
name|mem_CreatePool
parameter_list|(
name|size_t
name|chunksize
parameter_list|,
name|unsigned
name|int
name|align
parameter_list|)
block|{
name|MemoryPool
modifier|*
name|pool
decl_stmt|;
if|if
condition|(
name|align
operator|==
literal|0
condition|)
name|align
operator|=
name|ALIGN
expr_stmt|;
if|if
condition|(
name|chunksize
operator|==
literal|0
condition|)
name|chunksize
operator|=
name|CHUNKSIZE
expr_stmt|;
if|if
condition|(
name|align
operator|&
operator|(
name|align
operator|-
literal|1
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|chunksize
operator|<
sizeof|sizeof
argument_list|(
name|MemoryPool
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|chunksize
operator|&
operator|(
name|align
operator|-
literal|1
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
operator|(
name|pool
operator|=
name|malloc
argument_list|(
name|chunksize
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|pool
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|pool
operator|->
name|chunksize
operator|=
name|chunksize
expr_stmt|;
name|pool
operator|->
name|alignmask
operator|=
call|(
name|uintptr_t
call|)
argument_list|(
name|align
argument_list|)
operator|-
literal|1
expr_stmt|;
name|pool
operator|->
name|free
operator|=
operator|(
call|(
name|uintptr_t
call|)
argument_list|(
name|pool
operator|+
literal|1
argument_list|)
operator|+
name|pool
operator|->
name|alignmask
operator|)
operator|&
operator|~
name|pool
operator|->
name|alignmask
expr_stmt|;
name|pool
operator|->
name|end
operator|=
operator|(
name|uintptr_t
operator|)
name|pool
operator|+
name|chunksize
expr_stmt|;
name|pool
operator|->
name|cleanup
operator|=
literal|0
expr_stmt|;
return|return
name|pool
return|;
block|}
end_function
begin_function
DECL|function|mem_FreePool
name|void
name|mem_FreePool
parameter_list|(
name|MemoryPool
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|cleanup
decl_stmt|;
name|struct
name|chunk
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|cleanup
operator|=
name|pool
operator|->
name|cleanup
init|;
name|cleanup
condition|;
name|cleanup
operator|=
name|cleanup
operator|->
name|next
control|)
block|{
name|cleanup
operator|->
name|fn
argument_list|(
name|cleanup
operator|->
name|arg
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
operator|(
expr|struct
name|chunk
operator|*
operator|)
name|pool
init|;
name|p
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|mem_Alloc
name|void
modifier|*
name|mem_Alloc
parameter_list|(
name|MemoryPool
modifier|*
name|pool
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|struct
name|chunk
modifier|*
name|ch
decl_stmt|;
name|void
modifier|*
name|rv
init|=
operator|(
name|void
operator|*
operator|)
name|pool
operator|->
name|free
decl_stmt|;
name|size
operator|=
operator|(
name|size
operator|+
name|pool
operator|->
name|alignmask
operator|)
operator|&
operator|~
name|pool
operator|->
name|alignmask
expr_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0
condition|)
name|size
operator|=
name|pool
operator|->
name|alignmask
expr_stmt|;
name|pool
operator|->
name|free
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|pool
operator|->
name|free
operator|>
name|pool
operator|->
name|end
operator|||
name|pool
operator|->
name|free
operator|<
operator|(
name|uintptr_t
operator|)
name|rv
condition|)
block|{
name|size_t
name|minreq
init|=
operator|(
name|size
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|chunk
argument_list|)
operator|+
name|pool
operator|->
name|alignmask
operator|)
operator|&
operator|~
name|pool
operator|->
name|alignmask
decl_stmt|;
name|pool
operator|->
name|free
operator|=
operator|(
name|uintptr_t
operator|)
name|rv
expr_stmt|;
if|if
condition|(
name|minreq
operator|>=
name|pool
operator|->
name|chunksize
condition|)
block|{
comment|// request size is too big for the chunksize, so allocate it as
comment|// a single chunk of the right size
name|ch
operator|=
name|malloc
argument_list|(
name|minreq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ch
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
name|ch
operator|=
name|malloc
argument_list|(
name|pool
operator|->
name|chunksize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ch
condition|)
return|return
literal|0
return|;
name|pool
operator|->
name|free
operator|=
operator|(
name|uintptr_t
operator|)
name|ch
operator|+
name|minreq
expr_stmt|;
name|pool
operator|->
name|end
operator|=
operator|(
name|uintptr_t
operator|)
name|ch
operator|+
name|pool
operator|->
name|chunksize
expr_stmt|;
block|}
name|ch
operator|->
name|next
operator|=
name|pool
operator|->
name|next
expr_stmt|;
name|pool
operator|->
name|next
operator|=
name|ch
expr_stmt|;
name|rv
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
call|(
name|uintptr_t
call|)
argument_list|(
name|ch
operator|+
literal|1
argument_list|)
operator|+
name|pool
operator|->
name|alignmask
operator|)
operator|&
operator|~
name|pool
operator|->
name|alignmask
operator|)
expr_stmt|;
block|}
return|return
name|rv
return|;
block|}
end_function
begin_function
DECL|function|mem_AddCleanup
name|int
name|mem_AddCleanup
parameter_list|(
name|MemoryPool
modifier|*
name|pool
parameter_list|,
name|void
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|cleanup
decl_stmt|;
name|pool
operator|->
name|free
operator|=
operator|(
name|pool
operator|->
name|free
operator|+
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|cleanup
operator|=
name|mem_Alloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cleanup
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cleanup
condition|)
return|return
operator|-
literal|1
return|;
name|cleanup
operator|->
name|next
operator|=
name|pool
operator|->
name|cleanup
expr_stmt|;
name|cleanup
operator|->
name|fn
operator|=
name|fn
expr_stmt|;
name|cleanup
operator|->
name|arg
operator|=
name|arg
expr_stmt|;
name|pool
operator|->
name|cleanup
operator|=
name|cleanup
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
end_unit
