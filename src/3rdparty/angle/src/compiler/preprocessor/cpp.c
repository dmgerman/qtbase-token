begin_unit
begin_comment
comment|/****************************************************************************\ Copyright (c) 2002, NVIDIA Corporation.  NVIDIA Corporation("NVIDIA") supplies this software to you in consideration of your agreement to the following terms, and your use, installation, modification or redistribution of this NVIDIA software constitutes acceptance of these terms.  If you do not agree with these terms, please do not use, install, modify or redistribute this NVIDIA software.  In consideration of your agreement to abide by the following terms, and subject to these terms, NVIDIA grants you a personal, non-exclusive license, under NVIDIA's copyrights in this original NVIDIA software (the "NVIDIA Software"), to use, reproduce, modify and redistribute the NVIDIA Software, with or without modifications, in source and/or binary forms; provided that if you redistribute the NVIDIA Software, you must retain the copyright notice of NVIDIA, this notice and the following text and disclaimers in all such redistributions of the NVIDIA Software. Neither the name, trademarks, service marks nor logos of NVIDIA Corporation may be used to endorse or promote products derived from the NVIDIA Software without specific prior written permission from NVIDIA. Except as expressly stated in this notice, no other rights or licenses express or implied, are granted by NVIDIA herein, including but not limited to any patent rights that may be infringed by your derivative works or by other works in which the NVIDIA Software may be incorporated. No hardware is licensed hereunder.   THE NVIDIA SOFTWARE IS BEING PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR ITS USE AND OPERATION EITHER ALONE OR IN COMBINATION WITH OTHER PRODUCTS.  IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, EXEMPLARY, CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, LOST PROFITS; PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) OR ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION OF THE NVIDIA SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. \****************************************************************************/
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// cpp.c
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|<stdarg.h>
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_include
include|#
directive|include
file|<ctype.h>
end_include
begin_include
include|#
directive|include
file|"common/angleutils.h"
end_include
begin_include
include|#
directive|include
file|"compiler/preprocessor/slglobals.h"
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_if
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4054
name|)
end_pragma
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4152
name|)
end_pragma
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4706
name|)
end_pragma
begin_endif
endif|#
directive|endif
end_endif
begin_function_decl
specifier|static
name|int
name|CPPif
parameter_list|(
name|yystypepp
modifier|*
name|yylvalpp
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Don't use memory.c's replacements, as we clean up properly here */
end_comment
begin_undef
DECL|macro|malloc
undef|#
directive|undef
name|malloc
end_undef
begin_undef
DECL|macro|free
undef|#
directive|undef
name|free
end_undef
begin_decl_stmt
DECL|variable|bindAtom
specifier|static
name|int
name|bindAtom
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|constAtom
specifier|static
name|int
name|constAtom
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|defaultAtom
specifier|static
name|int
name|defaultAtom
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|defineAtom
specifier|static
name|int
name|defineAtom
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|definedAtom
specifier|static
name|int
name|definedAtom
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|elseAtom
specifier|static
name|int
name|elseAtom
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|elifAtom
specifier|static
name|int
name|elifAtom
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|endifAtom
specifier|static
name|int
name|endifAtom
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|ifAtom
specifier|static
name|int
name|ifAtom
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|ifdefAtom
specifier|static
name|int
name|ifdefAtom
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|ifndefAtom
specifier|static
name|int
name|ifndefAtom
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|includeAtom
specifier|static
name|int
name|includeAtom
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|lineAtom
specifier|static
name|int
name|lineAtom
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pragmaAtom
specifier|static
name|int
name|pragmaAtom
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|texunitAtom
specifier|static
name|int
name|texunitAtom
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|undefAtom
specifier|static
name|int
name|undefAtom
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|errorAtom
specifier|static
name|int
name|errorAtom
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|__LINE__Atom
specifier|static
name|int
name|__LINE__Atom
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|__FILE__Atom
specifier|static
name|int
name|__FILE__Atom
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|__VERSION__Atom
specifier|static
name|int
name|__VERSION__Atom
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|versionAtom
specifier|static
name|int
name|versionAtom
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|extensionAtom
specifier|static
name|int
name|extensionAtom
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|macros
specifier|static
name|Scope
modifier|*
name|macros
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|MAX_MACRO_ARGS
define|#
directive|define
name|MAX_MACRO_ARGS
value|64
end_define
begin_decl_stmt
DECL|variable|ifloc
specifier|static
name|SourceLoc
name|ifloc
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|ifloc
comment|/* outermost #if */
end_comment
begin_function
DECL|function|InitCPP
name|int
name|InitCPP
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|buffer
index|[
literal|64
index|]
decl_stmt|,
modifier|*
name|t
decl_stmt|;
specifier|const
name|char
modifier|*
name|f
decl_stmt|;
comment|// Add various atoms needed by the CPP line scanner:
name|bindAtom
operator|=
name|LookUpAddString
argument_list|(
name|atable
argument_list|,
literal|"bind"
argument_list|)
expr_stmt|;
name|constAtom
operator|=
name|LookUpAddString
argument_list|(
name|atable
argument_list|,
literal|"const"
argument_list|)
expr_stmt|;
name|defaultAtom
operator|=
name|LookUpAddString
argument_list|(
name|atable
argument_list|,
literal|"default"
argument_list|)
expr_stmt|;
name|defineAtom
operator|=
name|LookUpAddString
argument_list|(
name|atable
argument_list|,
literal|"define"
argument_list|)
expr_stmt|;
name|definedAtom
operator|=
name|LookUpAddString
argument_list|(
name|atable
argument_list|,
literal|"defined"
argument_list|)
expr_stmt|;
name|elifAtom
operator|=
name|LookUpAddString
argument_list|(
name|atable
argument_list|,
literal|"elif"
argument_list|)
expr_stmt|;
name|elseAtom
operator|=
name|LookUpAddString
argument_list|(
name|atable
argument_list|,
literal|"else"
argument_list|)
expr_stmt|;
name|endifAtom
operator|=
name|LookUpAddString
argument_list|(
name|atable
argument_list|,
literal|"endif"
argument_list|)
expr_stmt|;
name|ifAtom
operator|=
name|LookUpAddString
argument_list|(
name|atable
argument_list|,
literal|"if"
argument_list|)
expr_stmt|;
name|ifdefAtom
operator|=
name|LookUpAddString
argument_list|(
name|atable
argument_list|,
literal|"ifdef"
argument_list|)
expr_stmt|;
name|ifndefAtom
operator|=
name|LookUpAddString
argument_list|(
name|atable
argument_list|,
literal|"ifndef"
argument_list|)
expr_stmt|;
name|includeAtom
operator|=
name|LookUpAddString
argument_list|(
name|atable
argument_list|,
literal|"include"
argument_list|)
expr_stmt|;
name|lineAtom
operator|=
name|LookUpAddString
argument_list|(
name|atable
argument_list|,
literal|"line"
argument_list|)
expr_stmt|;
name|pragmaAtom
operator|=
name|LookUpAddString
argument_list|(
name|atable
argument_list|,
literal|"pragma"
argument_list|)
expr_stmt|;
name|texunitAtom
operator|=
name|LookUpAddString
argument_list|(
name|atable
argument_list|,
literal|"texunit"
argument_list|)
expr_stmt|;
name|undefAtom
operator|=
name|LookUpAddString
argument_list|(
name|atable
argument_list|,
literal|"undef"
argument_list|)
expr_stmt|;
name|errorAtom
operator|=
name|LookUpAddString
argument_list|(
name|atable
argument_list|,
literal|"error"
argument_list|)
expr_stmt|;
name|__LINE__Atom
operator|=
name|LookUpAddString
argument_list|(
name|atable
argument_list|,
literal|"__LINE__"
argument_list|)
expr_stmt|;
name|__FILE__Atom
operator|=
name|LookUpAddString
argument_list|(
name|atable
argument_list|,
literal|"__FILE__"
argument_list|)
expr_stmt|;
name|__VERSION__Atom
operator|=
name|LookUpAddString
argument_list|(
name|atable
argument_list|,
literal|"__VERSION__"
argument_list|)
expr_stmt|;
name|versionAtom
operator|=
name|LookUpAddString
argument_list|(
name|atable
argument_list|,
literal|"version"
argument_list|)
expr_stmt|;
name|extensionAtom
operator|=
name|LookUpAddString
argument_list|(
name|atable
argument_list|,
literal|"extension"
argument_list|)
expr_stmt|;
name|macros
operator|=
name|NewScopeInPool
argument_list|(
name|mem_CreatePool
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buffer
argument_list|,
literal|"PROFILE_"
argument_list|)
expr_stmt|;
name|t
operator|=
name|buffer
operator|+
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|f
operator|=
name|cpp
operator|->
name|options
operator|.
name|profileString
expr_stmt|;
while|while
condition|(
operator|(
name|isalnum
argument_list|(
operator|*
name|f
argument_list|)
operator|||
operator|*
name|f
operator|==
literal|'_'
operator|)
operator|&&
name|t
operator|<
name|buffer
operator|+
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|-
literal|1
condition|)
operator|*
name|t
operator|++
operator|=
name|toupper
argument_list|(
operator|*
name|f
operator|++
argument_list|)
expr_stmt|;
operator|*
name|t
operator|=
literal|0
expr_stmt|;
name|PredefineIntMacro
argument_list|(
literal|"GL_ES"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PredefineIntMacro
argument_list|(
literal|"GL_FRAGMENT_PRECISION_HIGH"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|// InitCPP
end_comment
begin_function
DECL|function|FreeCPP
name|int
name|FreeCPP
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|macros
condition|)
block|{
name|mem_FreePool
argument_list|(
name|macros
operator|->
name|pool
argument_list|)
expr_stmt|;
name|macros
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|FinalCPP
name|int
name|FinalCPP
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|cpp
operator|->
name|ifdepth
condition|)
name|CPPErrorToInfoLog
argument_list|(
literal|"#if mismatch"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|CPPdefine
specifier|static
name|int
name|CPPdefine
parameter_list|(
name|yystypepp
modifier|*
name|yylvalpp
parameter_list|)
block|{
name|int
name|token
decl_stmt|,
name|name
decl_stmt|,
name|args
index|[
name|MAX_MACRO_ARGS
index|]
decl_stmt|,
name|argc
decl_stmt|;
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
name|MacroSymbol
name|mac
decl_stmt|;
name|Symbol
modifier|*
name|symb
decl_stmt|;
name|SourceLoc
name|dummyLoc
decl_stmt|;
name|memset
argument_list|(
operator|&
name|mac
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mac
argument_list|)
argument_list|)
expr_stmt|;
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|CPP_IDENTIFIER
condition|)
block|{
name|CPPErrorToInfoLog
argument_list|(
literal|"#define"
argument_list|)
expr_stmt|;
return|return
name|token
return|;
block|}
name|name
operator|=
name|yylvalpp
operator|->
name|sc_ident
expr_stmt|;
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
literal|'('
operator|&&
operator|!
name|yylvalpp
operator|->
name|sc_int
condition|)
block|{
comment|// gather arguments
name|argc
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
operator|&&
name|token
operator|==
literal|')'
condition|)
break|break;
if|if
condition|(
name|token
operator|!=
name|CPP_IDENTIFIER
condition|)
block|{
name|CPPErrorToInfoLog
argument_list|(
literal|"#define"
argument_list|)
expr_stmt|;
return|return
name|token
return|;
block|}
if|if
condition|(
name|argc
operator|<
name|MAX_MACRO_ARGS
condition|)
name|args
index|[
name|argc
operator|++
index|]
operator|=
name|yylvalpp
operator|->
name|sc_ident
expr_stmt|;
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|token
operator|==
literal|','
condition|)
do|;
if|if
condition|(
name|token
operator|!=
literal|')'
condition|)
block|{
name|CPPErrorToInfoLog
argument_list|(
literal|"#define"
argument_list|)
expr_stmt|;
return|return
name|token
return|;
block|}
name|mac
operator|.
name|argc
operator|=
name|argc
expr_stmt|;
name|mac
operator|.
name|args
operator|=
name|mem_Alloc
argument_list|(
name|macros
operator|->
name|pool
argument_list|,
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|mac
operator|.
name|args
argument_list|,
name|args
argument_list|,
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
name|mac
operator|.
name|body
operator|=
name|NewTokenStream
argument_list|(
name|GetAtomString
argument_list|(
name|atable
argument_list|,
name|name
argument_list|)
argument_list|,
name|macros
operator|->
name|pool
argument_list|)
expr_stmt|;
while|while
condition|(
name|token
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|token
operator|==
literal|'\\'
condition|)
block|{
name|CPPErrorToInfoLog
argument_list|(
literal|"The line continuation character (\\) is not part of the OpenGL ES Shading Language"
argument_list|)
expr_stmt|;
return|return
name|token
return|;
block|}
elseif|else
if|if
condition|(
name|token
operator|<=
literal|0
condition|)
block|{
comment|// EOF or error
name|CPPErrorToInfoLog
argument_list|(
literal|"unexpected end of input in #define preprocessor directive - expected a newline"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|RecordToken
argument_list|(
name|mac
operator|.
name|body
argument_list|,
name|token
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|symb
operator|=
name|LookUpSymbol
argument_list|(
name|macros
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|symb
condition|)
block|{
if|if
condition|(
operator|!
name|symb
operator|->
name|details
operator|.
name|mac
operator|.
name|undef
condition|)
block|{
comment|// already defined -- need to make sure they are identical
if|if
condition|(
name|symb
operator|->
name|details
operator|.
name|mac
operator|.
name|argc
operator|!=
name|mac
operator|.
name|argc
condition|)
goto|goto
name|error
goto|;
for|for
control|(
name|argc
operator|=
literal|0
init|;
name|argc
operator|<
name|mac
operator|.
name|argc
condition|;
name|argc
operator|++
control|)
if|if
condition|(
name|symb
operator|->
name|details
operator|.
name|mac
operator|.
name|args
index|[
name|argc
index|]
operator|!=
name|mac
operator|.
name|args
index|[
name|argc
index|]
condition|)
goto|goto
name|error
goto|;
name|RewindTokenStream
argument_list|(
name|symb
operator|->
name|details
operator|.
name|mac
operator|.
name|body
argument_list|)
expr_stmt|;
name|RewindTokenStream
argument_list|(
name|mac
operator|.
name|body
argument_list|)
expr_stmt|;
do|do
block|{
name|int
name|old_lval
decl_stmt|,
name|old_token
decl_stmt|;
name|old_token
operator|=
name|ReadToken
argument_list|(
name|symb
operator|->
name|details
operator|.
name|mac
operator|.
name|body
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
name|old_lval
operator|=
name|yylvalpp
operator|->
name|sc_int
expr_stmt|;
name|token
operator|=
name|ReadToken
argument_list|(
name|mac
operator|.
name|body
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|old_token
operator|||
name|yylvalpp
operator|->
name|sc_int
operator|!=
name|old_lval
condition|)
block|{
name|error
label|:
name|StoreStr
argument_list|(
literal|"Macro Redefined"
argument_list|)
expr_stmt|;
name|StoreStr
argument_list|(
name|GetStringOfAtom
argument_list|(
name|atable
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|message
operator|=
name|GetStrfromTStr
argument_list|()
expr_stmt|;
name|DecLineNumber
argument_list|()
expr_stmt|;
name|CPPShInfoLogMsg
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|IncLineNumber
argument_list|()
expr_stmt|;
name|ResetTString
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|token
operator|>
literal|0
condition|)
do|;
block|}
comment|//FreeMacro(&symb->details.mac);
block|}
else|else
block|{
name|dummyLoc
operator|.
name|file
operator|=
literal|0
expr_stmt|;
name|dummyLoc
operator|.
name|line
operator|=
literal|0
expr_stmt|;
name|symb
operator|=
name|AddSymbol
argument_list|(
operator|&
name|dummyLoc
argument_list|,
name|macros
argument_list|,
name|name
argument_list|,
name|MACRO_S
argument_list|)
expr_stmt|;
block|}
name|symb
operator|->
name|details
operator|.
name|mac
operator|=
name|mac
expr_stmt|;
return|return
literal|'\n'
return|;
block|}
end_function
begin_comment
comment|// CPPdefine
end_comment
begin_function
DECL|function|CPPundef
specifier|static
name|int
name|CPPundef
parameter_list|(
name|yystypepp
modifier|*
name|yylvalpp
parameter_list|)
block|{
name|int
name|token
init|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
decl_stmt|;
name|Symbol
modifier|*
name|symb
decl_stmt|;
if|if
condition|(
name|token
operator|==
literal|'\n'
condition|)
block|{
name|CPPErrorToInfoLog
argument_list|(
literal|"#undef"
argument_list|)
expr_stmt|;
return|return
name|token
return|;
block|}
if|if
condition|(
name|token
operator|!=
name|CPP_IDENTIFIER
condition|)
goto|goto
name|error
goto|;
name|symb
operator|=
name|LookUpSymbol
argument_list|(
name|macros
argument_list|,
name|yylvalpp
operator|->
name|sc_ident
argument_list|)
expr_stmt|;
if|if
condition|(
name|symb
condition|)
block|{
name|symb
operator|->
name|details
operator|.
name|mac
operator|.
name|undef
operator|=
literal|1
expr_stmt|;
block|}
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
literal|'\n'
condition|)
block|{
name|error
label|:
name|CPPErrorToInfoLog
argument_list|(
literal|"#undef"
argument_list|)
expr_stmt|;
block|}
return|return
name|token
return|;
block|}
end_function
begin_comment
comment|// CPPundef
end_comment
begin_comment
comment|/* CPPelse -- skip forward to appropriate spot.  This is actually used ** to skip to and #endif after seeing an #else, AND to skip to a #else, ** #elif, or #endif after a #if/#ifdef/#ifndef/#elif test was false */
end_comment
begin_function
DECL|function|CPPelse
specifier|static
name|int
name|CPPelse
parameter_list|(
name|int
name|matchelse
parameter_list|,
name|yystypepp
modifier|*
name|yylvalpp
parameter_list|)
block|{
name|int
name|atom
decl_stmt|,
name|depth
init|=
literal|0
decl_stmt|;
name|int
name|token
init|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
decl_stmt|;
while|while
condition|(
name|token
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|token
operator|!=
literal|'#'
condition|)
block|{
while|while
condition|(
name|token
operator|!=
literal|'\n'
condition|)
block|{
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|<=
literal|0
condition|)
block|{
comment|// EOF or error
name|CPPErrorToInfoLog
argument_list|(
literal|"unexpected end of input in #else preprocessor directive - expected a newline"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
operator|)
operator|!=
name|CPP_IDENTIFIER
condition|)
continue|continue;
name|atom
operator|=
name|yylvalpp
operator|->
name|sc_ident
expr_stmt|;
if|if
condition|(
name|atom
operator|==
name|ifAtom
operator|||
name|atom
operator|==
name|ifdefAtom
operator|||
name|atom
operator|==
name|ifndefAtom
condition|)
block|{
name|depth
operator|++
expr_stmt|;
name|cpp
operator|->
name|ifdepth
operator|++
expr_stmt|;
name|cpp
operator|->
name|elsetracker
operator|++
expr_stmt|;
if|if
condition|(
name|cpp
operator|->
name|ifdepth
operator|>
name|MAX_IF_NESTING
condition|)
block|{
name|CPPErrorToInfoLog
argument_list|(
literal|"max #if nesting depth exceeded"
argument_list|)
expr_stmt|;
name|cpp
operator|->
name|CompileError
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|// sanity check elsetracker
if|if
condition|(
name|cpp
operator|->
name|elsetracker
operator|<
literal|0
operator|||
name|cpp
operator|->
name|elsetracker
operator|>=
name|MAX_IF_NESTING
condition|)
block|{
name|CPPErrorToInfoLog
argument_list|(
literal|"mismatched #if/#endif statements"
argument_list|)
expr_stmt|;
name|cpp
operator|->
name|CompileError
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|cpp
operator|->
name|elsedepth
index|[
name|cpp
operator|->
name|elsetracker
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|==
name|endifAtom
condition|)
block|{
if|if
condition|(
operator|--
name|depth
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|cpp
operator|->
name|elsetracker
condition|)
operator|--
name|cpp
operator|->
name|elsetracker
expr_stmt|;
if|if
condition|(
name|cpp
operator|->
name|ifdepth
condition|)
operator|--
name|cpp
operator|->
name|ifdepth
expr_stmt|;
break|break;
block|}
operator|--
name|cpp
operator|->
name|elsetracker
expr_stmt|;
operator|--
name|cpp
operator|->
name|ifdepth
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
call|(
name|int
call|)
argument_list|(
name|matchelse
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
name|depth
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|atom
operator|==
name|elseAtom
condition|)
block|{
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
literal|'\n'
condition|)
block|{
name|CPPWarningToInfoLog
argument_list|(
literal|"unexpected tokens following #else preprocessor directive - expected a newline"
argument_list|)
expr_stmt|;
while|while
condition|(
name|token
operator|!=
literal|'\n'
condition|)
block|{
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|<=
literal|0
condition|)
block|{
comment|// EOF or error
name|CPPErrorToInfoLog
argument_list|(
literal|"unexpected end of input following #else preprocessor directive - expected a newline"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
break|break;
block|}
elseif|else
if|if
condition|(
name|atom
operator|==
name|elifAtom
condition|)
block|{
comment|/* we decrement cpp->ifdepth here, because CPPif will increment                  * it and we really want to leave it alone */
if|if
condition|(
name|cpp
operator|->
name|ifdepth
condition|)
block|{
operator|--
name|cpp
operator|->
name|ifdepth
expr_stmt|;
operator|--
name|cpp
operator|->
name|elsetracker
expr_stmt|;
block|}
return|return
name|CPPif
argument_list|(
name|yylvalpp
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|atom
operator|==
name|elseAtom
operator|)
operator|&&
operator|(
operator|!
name|ChkCorrectElseNesting
argument_list|()
operator|)
condition|)
block|{
name|CPPErrorToInfoLog
argument_list|(
literal|"#else after a #else"
argument_list|)
expr_stmt|;
name|cpp
operator|->
name|CompileError
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
empty_stmt|;
return|return
name|token
return|;
block|}
end_function
begin_enum
DECL|enum|eval_prec
enum|enum
name|eval_prec
block|{
DECL|enumerator|MIN_PREC
name|MIN_PREC
block|,
DECL|enumerator|COND
DECL|enumerator|LOGOR
DECL|enumerator|LOGAND
DECL|enumerator|OR
DECL|enumerator|XOR
DECL|enumerator|AND
DECL|enumerator|EQUAL
DECL|enumerator|RELATION
DECL|enumerator|SHIFT
DECL|enumerator|ADD
DECL|enumerator|MUL
DECL|enumerator|UNARY
name|COND
block|,
name|LOGOR
block|,
name|LOGAND
block|,
name|OR
block|,
name|XOR
block|,
name|AND
block|,
name|EQUAL
block|,
name|RELATION
block|,
name|SHIFT
block|,
name|ADD
block|,
name|MUL
block|,
name|UNARY
block|,
DECL|enumerator|MAX_PREC
name|MAX_PREC
block|}
enum|;
end_enum
begin_function
DECL|function|op_logor
specifier|static
name|int
name|op_logor
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|a
operator|||
name|b
return|;
block|}
end_function
begin_function
DECL|function|op_logand
specifier|static
name|int
name|op_logand
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|a
operator|&&
name|b
return|;
block|}
end_function
begin_function
DECL|function|op_or
specifier|static
name|int
name|op_or
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|a
operator||
name|b
return|;
block|}
end_function
begin_function
DECL|function|op_xor
specifier|static
name|int
name|op_xor
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|a
operator|^
name|b
return|;
block|}
end_function
begin_function
DECL|function|op_and
specifier|static
name|int
name|op_and
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|a
operator|&
name|b
return|;
block|}
end_function
begin_function
DECL|function|op_eq
specifier|static
name|int
name|op_eq
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|a
operator|==
name|b
return|;
block|}
end_function
begin_function
DECL|function|op_ne
specifier|static
name|int
name|op_ne
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|a
operator|!=
name|b
return|;
block|}
end_function
begin_function
DECL|function|op_ge
specifier|static
name|int
name|op_ge
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|a
operator|>=
name|b
return|;
block|}
end_function
begin_function
DECL|function|op_le
specifier|static
name|int
name|op_le
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|a
operator|<=
name|b
return|;
block|}
end_function
begin_function
DECL|function|op_gt
specifier|static
name|int
name|op_gt
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|a
operator|>
name|b
return|;
block|}
end_function
begin_function
DECL|function|op_lt
specifier|static
name|int
name|op_lt
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|a
operator|<
name|b
return|;
block|}
end_function
begin_function
DECL|function|op_shl
specifier|static
name|int
name|op_shl
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|a
operator|<<
name|b
return|;
block|}
end_function
begin_function
DECL|function|op_shr
specifier|static
name|int
name|op_shr
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|a
operator|>>
name|b
return|;
block|}
end_function
begin_function
DECL|function|op_add
specifier|static
name|int
name|op_add
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|a
operator|+
name|b
return|;
block|}
end_function
begin_function
DECL|function|op_sub
specifier|static
name|int
name|op_sub
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|a
operator|-
name|b
return|;
block|}
end_function
begin_function
DECL|function|op_mul
specifier|static
name|int
name|op_mul
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|a
operator|*
name|b
return|;
block|}
end_function
begin_function
DECL|function|op_div
specifier|static
name|int
name|op_div
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|a
operator|/
name|b
return|;
block|}
end_function
begin_function
DECL|function|op_mod
specifier|static
name|int
name|op_mod
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|a
operator|%
name|b
return|;
block|}
end_function
begin_function
DECL|function|op_pos
specifier|static
name|int
name|op_pos
parameter_list|(
name|int
name|a
parameter_list|)
block|{
return|return
name|a
return|;
block|}
end_function
begin_function
DECL|function|op_neg
specifier|static
name|int
name|op_neg
parameter_list|(
name|int
name|a
parameter_list|)
block|{
return|return
operator|-
name|a
return|;
block|}
end_function
begin_function
DECL|function|op_cmpl
specifier|static
name|int
name|op_cmpl
parameter_list|(
name|int
name|a
parameter_list|)
block|{
return|return
operator|~
name|a
return|;
block|}
end_function
begin_function
DECL|function|op_not
specifier|static
name|int
name|op_not
parameter_list|(
name|int
name|a
parameter_list|)
block|{
return|return
operator|!
name|a
return|;
block|}
end_function
begin_struct
struct|struct
block|{
DECL|member|token
DECL|member|prec
name|int
name|token
decl_stmt|,
name|prec
decl_stmt|,
argument_list|(
operator|*
name|op
argument_list|)
argument_list|(
name|int
argument_list|,
name|int
argument_list|)
decl_stmt|;
block|}
DECL|variable|binop
name|binop
index|[]
init|=
block|{
block|{
name|CPP_OR_OP
block|,
name|LOGOR
block|,
name|op_logor
block|}
block|,
block|{
name|CPP_AND_OP
block|,
name|LOGAND
block|,
name|op_logand
block|}
block|,
block|{
literal|'|'
block|,
name|OR
block|,
name|op_or
block|}
block|,
block|{
literal|'^'
block|,
name|XOR
block|,
name|op_xor
block|}
block|,
block|{
literal|'&'
block|,
name|AND
block|,
name|op_and
block|}
block|,
block|{
name|CPP_EQ_OP
block|,
name|EQUAL
block|,
name|op_eq
block|}
block|,
block|{
name|CPP_NE_OP
block|,
name|EQUAL
block|,
name|op_ne
block|}
block|,
block|{
literal|'>'
block|,
name|RELATION
block|,
name|op_gt
block|}
block|,
block|{
name|CPP_GE_OP
block|,
name|RELATION
block|,
name|op_ge
block|}
block|,
block|{
literal|'<'
block|,
name|RELATION
block|,
name|op_lt
block|}
block|,
block|{
name|CPP_LE_OP
block|,
name|RELATION
block|,
name|op_le
block|}
block|,
block|{
name|CPP_LEFT_OP
block|,
name|SHIFT
block|,
name|op_shl
block|}
block|,
block|{
name|CPP_RIGHT_OP
block|,
name|SHIFT
block|,
name|op_shr
block|}
block|,
block|{
literal|'+'
block|,
name|ADD
block|,
name|op_add
block|}
block|,
block|{
literal|'-'
block|,
name|ADD
block|,
name|op_sub
block|}
block|,
block|{
literal|'*'
block|,
name|MUL
block|,
name|op_mul
block|}
block|,
block|{
literal|'/'
block|,
name|MUL
block|,
name|op_div
block|}
block|,
block|{
literal|'%'
block|,
name|MUL
block|,
name|op_mod
block|}
block|, }
struct|;
end_struct
begin_struct
struct|struct
block|{
DECL|member|token
name|int
name|token
decl_stmt|,
argument_list|(
operator|*
name|op
argument_list|)
argument_list|(
name|int
argument_list|)
decl_stmt|;
block|}
DECL|variable|unop
name|unop
index|[]
init|=
block|{
block|{
literal|'+'
block|,
name|op_pos
block|}
block|,
block|{
literal|'-'
block|,
name|op_neg
block|}
block|,
block|{
literal|'~'
block|,
name|op_cmpl
block|}
block|,
block|{
literal|'!'
block|,
name|op_not
block|}
block|, }
struct|;
end_struct
begin_define
DECL|macro|ALEN
define|#
directive|define
name|ALEN
parameter_list|(
name|A
parameter_list|)
value|(sizeof(A)/sizeof(A[0]))
end_define
begin_function
DECL|function|eval
specifier|static
name|int
name|eval
parameter_list|(
name|int
name|token
parameter_list|,
name|int
name|prec
parameter_list|,
name|int
modifier|*
name|res
parameter_list|,
name|int
modifier|*
name|err
parameter_list|,
name|yystypepp
modifier|*
name|yylvalpp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|val
decl_stmt|;
name|Symbol
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|token
operator|==
name|CPP_IDENTIFIER
condition|)
block|{
if|if
condition|(
name|yylvalpp
operator|->
name|sc_ident
operator|==
name|definedAtom
condition|)
block|{
name|int
name|needclose
init|=
literal|0
decl_stmt|;
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
literal|'('
condition|)
block|{
name|needclose
operator|=
literal|1
expr_stmt|;
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|token
operator|!=
name|CPP_IDENTIFIER
condition|)
goto|goto
name|error
goto|;
operator|*
name|res
operator|=
operator|(
name|s
operator|=
name|LookUpSymbol
argument_list|(
name|macros
argument_list|,
name|yylvalpp
operator|->
name|sc_ident
argument_list|)
operator|)
condition|?
operator|!
name|s
operator|->
name|details
operator|.
name|mac
operator|.
name|undef
else|:
literal|0
expr_stmt|;
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|needclose
condition|)
block|{
if|if
condition|(
name|token
operator|!=
literal|')'
condition|)
goto|goto
name|error
goto|;
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|MacroExpand
argument_list|(
name|yylvalpp
operator|->
name|sc_ident
argument_list|,
name|yylvalpp
argument_list|)
condition|)
block|{
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
return|return
name|eval
argument_list|(
name|token
argument_list|,
name|prec
argument_list|,
name|res
argument_list|,
name|err
argument_list|,
name|yylvalpp
argument_list|)
return|;
block|}
else|else
block|{
goto|goto
name|error
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|CPP_INTCONSTANT
condition|)
block|{
operator|*
name|res
operator|=
name|yylvalpp
operator|->
name|sc_int
expr_stmt|;
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
literal|'('
condition|)
block|{
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
name|token
operator|=
name|eval
argument_list|(
name|token
argument_list|,
name|MIN_PREC
argument_list|,
name|res
argument_list|,
name|err
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|err
condition|)
block|{
if|if
condition|(
name|token
operator|!=
literal|')'
condition|)
goto|goto
name|error
goto|;
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|ALEN
argument_list|(
name|unop
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|unop
index|[
name|i
index|]
operator|.
name|token
operator|==
name|token
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
name|token
operator|=
name|eval
argument_list|(
name|token
argument_list|,
name|UNARY
argument_list|,
name|res
argument_list|,
name|err
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
name|unop
index|[
name|i
index|]
operator|.
name|op
argument_list|(
operator|*
name|res
argument_list|)
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|error
goto|;
block|}
block|}
while|while
condition|(
operator|!
operator|*
name|err
condition|)
block|{
if|if
condition|(
name|token
operator|==
literal|')'
operator|||
name|token
operator|==
literal|'\n'
condition|)
break|break;
for|for
control|(
name|i
operator|=
name|ALEN
argument_list|(
name|binop
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|binop
index|[
name|i
index|]
operator|.
name|token
operator|==
name|token
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|binop
index|[
name|i
index|]
operator|.
name|prec
operator|<=
name|prec
condition|)
break|break;
name|val
operator|=
operator|*
name|res
expr_stmt|;
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
name|token
operator|=
name|eval
argument_list|(
name|token
argument_list|,
name|binop
index|[
name|i
index|]
operator|.
name|prec
argument_list|,
name|res
argument_list|,
name|err
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|binop
index|[
name|i
index|]
operator|.
name|op
operator|==
name|op_div
operator|||
name|binop
index|[
name|i
index|]
operator|.
name|op
operator|==
name|op_mod
condition|)
block|{
if|if
condition|(
operator|*
name|res
operator|==
literal|0
condition|)
block|{
name|CPPErrorToInfoLog
argument_list|(
literal|"preprocessor divide or modulo by zero"
argument_list|)
expr_stmt|;
operator|*
name|err
operator|=
literal|1
expr_stmt|;
return|return
name|token
return|;
block|}
block|}
operator|*
name|res
operator|=
name|binop
index|[
name|i
index|]
operator|.
name|op
argument_list|(
name|val
argument_list|,
operator|*
name|res
argument_list|)
expr_stmt|;
block|}
return|return
name|token
return|;
name|error
label|:
name|CPPErrorToInfoLog
argument_list|(
literal|"incorrect preprocessor directive"
argument_list|)
expr_stmt|;
operator|*
name|err
operator|=
literal|1
expr_stmt|;
operator|*
name|res
operator|=
literal|0
expr_stmt|;
return|return
name|token
return|;
block|}
end_function
begin_comment
comment|// eval
end_comment
begin_function
DECL|function|CPPif
specifier|static
name|int
name|CPPif
parameter_list|(
name|yystypepp
modifier|*
name|yylvalpp
parameter_list|)
block|{
name|int
name|token
init|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|cpp
operator|->
name|ifdepth
operator|++
condition|)
name|ifloc
operator|=
operator|*
name|cpp
operator|->
name|tokenLoc
expr_stmt|;
if|if
condition|(
name|cpp
operator|->
name|ifdepth
operator|>
name|MAX_IF_NESTING
condition|)
block|{
name|CPPErrorToInfoLog
argument_list|(
literal|"max #if nesting depth exceeded"
argument_list|)
expr_stmt|;
name|cpp
operator|->
name|CompileError
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|cpp
operator|->
name|elsetracker
operator|++
expr_stmt|;
comment|// sanity check elsetracker
if|if
condition|(
name|cpp
operator|->
name|elsetracker
operator|<
literal|0
operator|||
name|cpp
operator|->
name|elsetracker
operator|>=
name|MAX_IF_NESTING
condition|)
block|{
name|CPPErrorToInfoLog
argument_list|(
literal|"mismatched #if/#endif statements"
argument_list|)
expr_stmt|;
name|cpp
operator|->
name|CompileError
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|cpp
operator|->
name|elsedepth
index|[
name|cpp
operator|->
name|elsetracker
index|]
operator|=
literal|0
expr_stmt|;
name|token
operator|=
name|eval
argument_list|(
name|token
argument_list|,
name|MIN_PREC
argument_list|,
operator|&
name|res
argument_list|,
operator|&
name|err
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
literal|'\n'
condition|)
block|{
name|CPPWarningToInfoLog
argument_list|(
literal|"unexpected tokens following #if preprocessor directive - expected a newline"
argument_list|)
expr_stmt|;
while|while
condition|(
name|token
operator|!=
literal|'\n'
condition|)
block|{
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|<=
literal|0
condition|)
block|{
comment|// EOF or error
name|CPPErrorToInfoLog
argument_list|(
literal|"unexpected end of input in #if preprocessor directive - expected a newline"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|res
operator|&&
operator|!
name|err
condition|)
block|{
name|token
operator|=
name|CPPelse
argument_list|(
literal|1
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
return|return
name|token
return|;
block|}
end_function
begin_comment
comment|// CPPif
end_comment
begin_function
DECL|function|CPPifdef
specifier|static
name|int
name|CPPifdef
parameter_list|(
name|int
name|defined
parameter_list|,
name|yystypepp
modifier|*
name|yylvalpp
parameter_list|)
block|{
name|int
name|token
init|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
decl_stmt|;
name|int
name|name
init|=
name|yylvalpp
operator|->
name|sc_ident
decl_stmt|;
if|if
condition|(
operator|++
name|cpp
operator|->
name|ifdepth
operator|>
name|MAX_IF_NESTING
condition|)
block|{
name|CPPErrorToInfoLog
argument_list|(
literal|"max #if nesting depth exceeded"
argument_list|)
expr_stmt|;
name|cpp
operator|->
name|CompileError
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|cpp
operator|->
name|elsetracker
operator|++
expr_stmt|;
comment|// sanity check elsetracker
if|if
condition|(
name|cpp
operator|->
name|elsetracker
operator|<
literal|0
operator|||
name|cpp
operator|->
name|elsetracker
operator|>=
name|MAX_IF_NESTING
condition|)
block|{
name|CPPErrorToInfoLog
argument_list|(
literal|"mismatched #if/#endif statements"
argument_list|)
expr_stmt|;
name|cpp
operator|->
name|CompileError
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|cpp
operator|->
name|elsedepth
index|[
name|cpp
operator|->
name|elsetracker
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|CPP_IDENTIFIER
condition|)
block|{
name|defined
condition|?
name|CPPErrorToInfoLog
argument_list|(
literal|"ifdef"
argument_list|)
else|:
name|CPPErrorToInfoLog
argument_list|(
literal|"ifndef"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Symbol
modifier|*
name|s
init|=
name|LookUpSymbol
argument_list|(
name|macros
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
literal|'\n'
condition|)
block|{
name|CPPWarningToInfoLog
argument_list|(
literal|"unexpected tokens following #ifdef preprocessor directive - expected a newline"
argument_list|)
expr_stmt|;
while|while
condition|(
name|token
operator|!=
literal|'\n'
condition|)
block|{
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|<=
literal|0
condition|)
block|{
comment|// EOF or error
name|CPPErrorToInfoLog
argument_list|(
literal|"unexpected end of input in #ifdef preprocessor directive - expected a newline"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
if|if
condition|(
operator|(
operator|(
name|s
operator|&&
operator|!
name|s
operator|->
name|details
operator|.
name|mac
operator|.
name|undef
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|!=
name|defined
condition|)
name|token
operator|=
name|CPPelse
argument_list|(
literal|1
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
return|return
name|token
return|;
block|}
end_function
begin_comment
comment|// CPPifdef
end_comment
begin_function
DECL|function|CPPline
specifier|static
name|int
name|CPPline
parameter_list|(
name|yystypepp
modifier|*
name|yylvalpp
parameter_list|)
block|{
name|int
name|token
init|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
decl_stmt|;
if|if
condition|(
name|token
operator|==
literal|'\n'
condition|)
block|{
name|DecLineNumber
argument_list|()
expr_stmt|;
name|CPPErrorToInfoLog
argument_list|(
literal|"#line"
argument_list|)
expr_stmt|;
name|IncLineNumber
argument_list|()
expr_stmt|;
return|return
name|token
return|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|CPP_INTCONSTANT
condition|)
block|{
name|yylvalpp
operator|->
name|sc_int
operator|=
name|atoi
argument_list|(
name|yylvalpp
operator|->
name|symbol_name
argument_list|)
expr_stmt|;
name|SetLineNumber
argument_list|(
name|yylvalpp
operator|->
name|sc_int
argument_list|)
expr_stmt|;
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|CPP_INTCONSTANT
condition|)
block|{
name|yylvalpp
operator|->
name|sc_int
operator|=
name|atoi
argument_list|(
name|yylvalpp
operator|->
name|symbol_name
argument_list|)
expr_stmt|;
name|SetStringNumber
argument_list|(
name|yylvalpp
operator|->
name|sc_int
argument_list|)
expr_stmt|;
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
literal|'\n'
condition|)
name|CPPErrorToInfoLog
argument_list|(
literal|"#line"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
literal|'\n'
condition|)
block|{
return|return
name|token
return|;
block|}
else|else
block|{
name|CPPErrorToInfoLog
argument_list|(
literal|"#line"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|CPPErrorToInfoLog
argument_list|(
literal|"#line"
argument_list|)
expr_stmt|;
block|}
return|return
name|token
return|;
block|}
end_function
begin_function
DECL|function|CPPerror
specifier|static
name|int
name|CPPerror
parameter_list|(
name|yystypepp
modifier|*
name|yylvalpp
parameter_list|)
block|{
name|int
name|token
init|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
while|while
condition|(
name|token
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|token
operator|<=
literal|0
condition|)
block|{
name|CPPErrorToInfoLog
argument_list|(
literal|"unexpected end of input in #error preprocessor directive - expected a newline"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|CPP_FLOATCONSTANT
operator|||
name|token
operator|==
name|CPP_INTCONSTANT
condition|)
block|{
name|StoreStr
argument_list|(
name|yylvalpp
operator|->
name|symbol_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|CPP_IDENTIFIER
operator|||
name|token
operator|==
name|CPP_STRCONSTANT
condition|)
block|{
name|StoreStr
argument_list|(
name|GetStringOfAtom
argument_list|(
name|atable
argument_list|,
name|yylvalpp
operator|->
name|sc_ident
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|StoreStr
argument_list|(
name|GetStringOfAtom
argument_list|(
name|atable
argument_list|,
name|token
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
name|DecLineNumber
argument_list|()
expr_stmt|;
comment|//store this msg into the shader's information log..set the Compile Error flag!!!!
name|message
operator|=
name|GetStrfromTStr
argument_list|()
expr_stmt|;
name|CPPShInfoLogMsg
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|ResetTString
argument_list|()
expr_stmt|;
name|cpp
operator|->
name|CompileError
operator|=
literal|1
expr_stmt|;
name|IncLineNumber
argument_list|()
expr_stmt|;
return|return
literal|'\n'
return|;
block|}
end_function
begin_comment
comment|//CPPerror
end_comment
begin_function
DECL|function|CPPpragma
specifier|static
name|int
name|CPPpragma
parameter_list|(
name|yystypepp
modifier|*
name|yylvalpp
parameter_list|)
block|{
name|char
name|SrcStrName
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|allTokens
decl_stmt|;
name|int
name|tokenCount
init|=
literal|0
decl_stmt|;
name|int
name|maxTokenCount
init|=
literal|10
decl_stmt|;
specifier|const
name|char
modifier|*
name|SrcStr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|token
init|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
decl_stmt|;
if|if
condition|(
name|token
operator|==
literal|'\n'
condition|)
block|{
name|DecLineNumber
argument_list|()
expr_stmt|;
name|CPPErrorToInfoLog
argument_list|(
literal|"#pragma"
argument_list|)
expr_stmt|;
name|IncLineNumber
argument_list|()
expr_stmt|;
return|return
name|token
return|;
block|}
name|allTokens
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|maxTokenCount
argument_list|)
expr_stmt|;
while|while
condition|(
name|token
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|tokenCount
operator|>=
name|maxTokenCount
condition|)
block|{
name|maxTokenCount
operator|*=
literal|2
expr_stmt|;
name|allTokens
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
name|allTokens
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|maxTokenCount
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|CPP_IDENTIFIER
case|:
name|SrcStr
operator|=
name|GetAtomString
argument_list|(
name|atable
argument_list|,
name|yylvalpp
operator|->
name|sc_ident
argument_list|)
expr_stmt|;
name|allTokens
index|[
name|tokenCount
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|SrcStr
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|allTokens
index|[
name|tokenCount
operator|++
index|]
argument_list|,
name|SrcStr
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_INTCONSTANT
case|:
name|SrcStr
operator|=
name|yylvalpp
operator|->
name|symbol_name
expr_stmt|;
name|allTokens
index|[
name|tokenCount
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|SrcStr
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|allTokens
index|[
name|tokenCount
operator|++
index|]
argument_list|,
name|SrcStr
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_FLOATCONSTANT
case|:
name|SrcStr
operator|=
name|yylvalpp
operator|->
name|symbol_name
expr_stmt|;
name|allTokens
index|[
name|tokenCount
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|SrcStr
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|allTokens
index|[
name|tokenCount
operator|++
index|]
argument_list|,
name|SrcStr
argument_list|)
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
comment|// EOF
name|CPPShInfoLogMsg
argument_list|(
literal|"#pragma directive must end with a newline"
argument_list|)
expr_stmt|;
goto|goto
name|freeMemoryAndReturnToken
goto|;
default|default:
name|SrcStrName
index|[
literal|0
index|]
operator|=
name|token
expr_stmt|;
name|SrcStrName
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|allTokens
index|[
name|tokenCount
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|allTokens
index|[
name|tokenCount
operator|++
index|]
argument_list|,
name|SrcStrName
argument_list|)
expr_stmt|;
block|}
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
name|HandlePragma
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|allTokens
argument_list|,
name|tokenCount
argument_list|)
expr_stmt|;
name|freeMemoryAndReturnToken
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tokenCount
condition|;
operator|++
name|i
control|)
block|{
name|free
argument_list|(
name|allTokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|allTokens
argument_list|)
expr_stmt|;
return|return
name|token
return|;
block|}
end_function
begin_comment
comment|// CPPpragma
end_comment
begin_define
DECL|macro|ESSL_VERSION_NUMBER
define|#
directive|define
name|ESSL_VERSION_NUMBER
value|100
end_define
begin_define
DECL|macro|ESSL_VERSION_STRING
define|#
directive|define
name|ESSL_VERSION_STRING
value|"100"
end_define
begin_function
DECL|function|CPPversion
specifier|static
name|int
name|CPPversion
parameter_list|(
name|yystypepp
modifier|*
name|yylvalpp
parameter_list|)
block|{
name|int
name|token
init|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
decl_stmt|;
if|if
condition|(
name|cpp
operator|->
name|pastFirstStatement
operator|==
literal|1
condition|)
name|CPPShInfoLogMsg
argument_list|(
literal|"#version must occur before any other statement in the program"
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
literal|'\n'
condition|)
block|{
name|DecLineNumber
argument_list|()
expr_stmt|;
name|CPPErrorToInfoLog
argument_list|(
literal|"#version"
argument_list|)
expr_stmt|;
name|IncLineNumber
argument_list|()
expr_stmt|;
return|return
name|token
return|;
block|}
if|if
condition|(
name|token
operator|!=
name|CPP_INTCONSTANT
condition|)
name|CPPErrorToInfoLog
argument_list|(
literal|"#version"
argument_list|)
expr_stmt|;
name|yylvalpp
operator|->
name|sc_int
operator|=
name|atoi
argument_list|(
name|yylvalpp
operator|->
name|symbol_name
argument_list|)
expr_stmt|;
comment|//SetVersionNumber(yylvalpp->sc_int);
if|if
condition|(
name|yylvalpp
operator|->
name|sc_int
operator|!=
name|ESSL_VERSION_NUMBER
condition|)
name|CPPShInfoLogMsg
argument_list|(
literal|"Version number not supported by ESSL"
argument_list|)
expr_stmt|;
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
literal|'\n'
condition|)
block|{
return|return
name|token
return|;
block|}
else|else
block|{
name|CPPErrorToInfoLog
argument_list|(
literal|"#version"
argument_list|)
expr_stmt|;
block|}
return|return
name|token
return|;
block|}
end_function
begin_comment
comment|// CPPversion
end_comment
begin_function
DECL|function|CPPextension
specifier|static
name|int
name|CPPextension
parameter_list|(
name|yystypepp
modifier|*
name|yylvalpp
parameter_list|)
block|{
name|int
name|token
init|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
decl_stmt|;
name|char
name|extensionName
index|[
name|MAX_SYMBOL_NAME_LEN
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|token
operator|==
literal|'\n'
condition|)
block|{
name|DecLineNumber
argument_list|()
expr_stmt|;
name|CPPShInfoLogMsg
argument_list|(
literal|"extension name not specified"
argument_list|)
expr_stmt|;
name|IncLineNumber
argument_list|()
expr_stmt|;
return|return
name|token
return|;
block|}
if|if
condition|(
name|token
operator|!=
name|CPP_IDENTIFIER
condition|)
name|CPPErrorToInfoLog
argument_list|(
literal|"#extension"
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|extensionName
argument_list|,
name|GetAtomString
argument_list|(
name|atable
argument_list|,
name|yylvalpp
operator|->
name|sc_ident
argument_list|)
argument_list|,
name|MAX_SYMBOL_NAME_LEN
argument_list|)
expr_stmt|;
name|extensionName
index|[
name|MAX_SYMBOL_NAME_LEN
index|]
operator|=
literal|'\0'
expr_stmt|;
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
literal|':'
condition|)
block|{
name|CPPShInfoLogMsg
argument_list|(
literal|"':' missing after extension name"
argument_list|)
expr_stmt|;
return|return
name|token
return|;
block|}
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|CPP_IDENTIFIER
condition|)
block|{
name|CPPShInfoLogMsg
argument_list|(
literal|"behavior for extension not specified"
argument_list|)
expr_stmt|;
return|return
name|token
return|;
block|}
name|updateExtensionBehavior
argument_list|(
name|extensionName
argument_list|,
name|GetAtomString
argument_list|(
name|atable
argument_list|,
name|yylvalpp
operator|->
name|sc_ident
argument_list|)
argument_list|)
expr_stmt|;
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
literal|'\n'
condition|)
block|{
return|return
name|token
return|;
block|}
else|else
block|{
name|CPPErrorToInfoLog
argument_list|(
literal|"#extension"
argument_list|)
expr_stmt|;
block|}
return|return
name|token
return|;
block|}
end_function
begin_comment
comment|// CPPextension
end_comment
begin_function
DECL|function|readCPPline
name|int
name|readCPPline
parameter_list|(
name|yystypepp
modifier|*
name|yylvalpp
parameter_list|)
block|{
name|int
name|token
init|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
if|if
condition|(
name|token
operator|==
name|CPP_IDENTIFIER
condition|)
block|{
if|if
condition|(
name|yylvalpp
operator|->
name|sc_ident
operator|==
name|defineAtom
condition|)
block|{
name|token
operator|=
name|CPPdefine
argument_list|(
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yylvalpp
operator|->
name|sc_ident
operator|==
name|elseAtom
condition|)
block|{
if|if
condition|(
name|ChkCorrectElseNesting
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|cpp
operator|->
name|ifdepth
condition|)
block|{
name|CPPErrorToInfoLog
argument_list|(
literal|"#else mismatch"
argument_list|)
expr_stmt|;
name|cpp
operator|->
name|CompileError
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
literal|'\n'
condition|)
block|{
name|CPPWarningToInfoLog
argument_list|(
literal|"unexpected tokens following #else preprocessor directive - expected a newline"
argument_list|)
expr_stmt|;
while|while
condition|(
name|token
operator|!=
literal|'\n'
condition|)
block|{
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|<=
literal|0
condition|)
block|{
comment|// EOF or error
name|CPPErrorToInfoLog
argument_list|(
literal|"unexpected end of input in #ifdef preprocessor directive - expected a newline"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
name|token
operator|=
name|CPPelse
argument_list|(
literal|0
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CPPErrorToInfoLog
argument_list|(
literal|"#else after a #else"
argument_list|)
expr_stmt|;
name|cpp
operator|->
name|ifdepth
operator|=
literal|0
expr_stmt|;
name|cpp
operator|->
name|elsetracker
operator|=
literal|0
expr_stmt|;
name|cpp
operator|->
name|pastFirstStatement
operator|=
literal|1
expr_stmt|;
name|cpp
operator|->
name|CompileError
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|yylvalpp
operator|->
name|sc_ident
operator|==
name|elifAtom
condition|)
block|{
if|if
condition|(
operator|!
name|cpp
operator|->
name|ifdepth
condition|)
block|{
name|CPPErrorToInfoLog
argument_list|(
literal|"#elif mismatch"
argument_list|)
expr_stmt|;
name|cpp
operator|->
name|CompileError
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|// this token is really a dont care, but we still need to eat the tokens
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
while|while
condition|(
name|token
operator|!=
literal|'\n'
condition|)
block|{
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|<=
literal|0
condition|)
block|{
comment|// EOF or error
name|CPPErrorToInfoLog
argument_list|(
literal|"unexpect tokens following #elif preprocessor directive - expected a newline"
argument_list|)
expr_stmt|;
name|cpp
operator|->
name|CompileError
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|token
operator|=
name|CPPelse
argument_list|(
literal|0
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yylvalpp
operator|->
name|sc_ident
operator|==
name|endifAtom
condition|)
block|{
if|if
condition|(
operator|!
name|cpp
operator|->
name|ifdepth
condition|)
block|{
name|CPPErrorToInfoLog
argument_list|(
literal|"#endif mismatch"
argument_list|)
expr_stmt|;
name|cpp
operator|->
name|CompileError
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
operator|--
name|cpp
operator|->
name|ifdepth
expr_stmt|;
if|if
condition|(
name|cpp
operator|->
name|elsetracker
condition|)
operator|--
name|cpp
operator|->
name|elsetracker
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yylvalpp
operator|->
name|sc_ident
operator|==
name|ifAtom
condition|)
block|{
name|token
operator|=
name|CPPif
argument_list|(
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yylvalpp
operator|->
name|sc_ident
operator|==
name|ifdefAtom
condition|)
block|{
name|token
operator|=
name|CPPifdef
argument_list|(
literal|1
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yylvalpp
operator|->
name|sc_ident
operator|==
name|ifndefAtom
condition|)
block|{
name|token
operator|=
name|CPPifdef
argument_list|(
literal|0
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yylvalpp
operator|->
name|sc_ident
operator|==
name|lineAtom
condition|)
block|{
name|token
operator|=
name|CPPline
argument_list|(
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yylvalpp
operator|->
name|sc_ident
operator|==
name|pragmaAtom
condition|)
block|{
name|token
operator|=
name|CPPpragma
argument_list|(
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yylvalpp
operator|->
name|sc_ident
operator|==
name|undefAtom
condition|)
block|{
name|token
operator|=
name|CPPundef
argument_list|(
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yylvalpp
operator|->
name|sc_ident
operator|==
name|errorAtom
condition|)
block|{
name|token
operator|=
name|CPPerror
argument_list|(
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yylvalpp
operator|->
name|sc_ident
operator|==
name|versionAtom
condition|)
block|{
name|token
operator|=
name|CPPversion
argument_list|(
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yylvalpp
operator|->
name|sc_ident
operator|==
name|extensionAtom
condition|)
block|{
name|token
operator|=
name|CPPextension
argument_list|(
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|StoreStr
argument_list|(
literal|"Invalid Directive"
argument_list|)
expr_stmt|;
name|StoreStr
argument_list|(
name|GetStringOfAtom
argument_list|(
name|atable
argument_list|,
name|yylvalpp
operator|->
name|sc_ident
argument_list|)
argument_list|)
expr_stmt|;
name|message
operator|=
name|GetStrfromTStr
argument_list|()
expr_stmt|;
name|CPPShInfoLogMsg
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|ResetTString
argument_list|()
expr_stmt|;
block|}
block|}
while|while
condition|(
name|token
operator|!=
literal|'\n'
operator|&&
name|token
operator|!=
literal|0
operator|&&
name|token
operator|!=
name|EOF
condition|)
block|{
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
name|cpp
operator|->
name|pastFirstStatement
operator|=
literal|1
expr_stmt|;
return|return
name|token
return|;
block|}
end_function
begin_comment
comment|// readCPPline
end_comment
begin_function
DECL|function|FreeMacro
name|void
name|FreeMacro
parameter_list|(
name|MacroSymbol
modifier|*
name|s
parameter_list|)
block|{
name|DeleteTokenStream
argument_list|(
name|s
operator|->
name|body
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|PredefineIntMacro
name|void
name|PredefineIntMacro
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|SourceLoc
name|location
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|Symbol
modifier|*
name|symbol
init|=
name|NULL
decl_stmt|;
name|MacroSymbol
name|macro
init|=
block|{
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|yystypepp
name|val
init|=
block|{
literal|0
block|,
literal|0.0
block|,
literal|0
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
name|int
name|atom
init|=
literal|0
decl_stmt|;
name|macro
operator|.
name|body
operator|=
name|NewTokenStream
argument_list|(
name|name
argument_list|,
name|macros
operator|->
name|pool
argument_list|)
expr_stmt|;
name|val
operator|.
name|sc_int
operator|=
name|value
expr_stmt|;
name|snprintf
argument_list|(
name|val
operator|.
name|symbol_name
argument_list|,
name|MAX_SYMBOL_NAME_LEN
operator|+
literal|1
argument_list|,
literal|"%d"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|RecordToken
argument_list|(
name|macro
operator|.
name|body
argument_list|,
name|CPP_INTCONSTANT
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|atom
operator|=
name|LookUpAddString
argument_list|(
name|atable
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|symbol
operator|=
name|AddSymbol
argument_list|(
operator|&
name|location
argument_list|,
name|macros
argument_list|,
name|atom
argument_list|,
name|MACRO_S
argument_list|)
expr_stmt|;
name|symbol
operator|->
name|details
operator|.
name|mac
operator|=
name|macro
expr_stmt|;
block|}
end_function
begin_function
DECL|function|eof_scan
specifier|static
name|int
name|eof_scan
parameter_list|(
name|InputSrc
modifier|*
name|in
parameter_list|,
name|yystypepp
modifier|*
name|yylvalpp
parameter_list|)
block|{
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|noop
specifier|static
name|void
name|noop
parameter_list|(
name|InputSrc
modifier|*
name|in
parameter_list|,
name|int
name|ch
parameter_list|,
name|yystypepp
modifier|*
name|yylvalpp
parameter_list|)
block|{ }
end_function
begin_function
DECL|function|PushEofSrc
specifier|static
name|void
name|PushEofSrc
parameter_list|()
block|{
name|InputSrc
modifier|*
name|in
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|InputSrc
argument_list|)
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|in
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|InputSrc
argument_list|)
argument_list|)
expr_stmt|;
name|in
operator|->
name|scan
operator|=
name|eof_scan
expr_stmt|;
name|in
operator|->
name|getch
operator|=
name|eof_scan
expr_stmt|;
name|in
operator|->
name|ungetch
operator|=
name|noop
expr_stmt|;
name|in
operator|->
name|prev
operator|=
name|cpp
operator|->
name|currentInput
expr_stmt|;
name|cpp
operator|->
name|currentInput
operator|=
name|in
expr_stmt|;
block|}
end_function
begin_function
DECL|function|PopEofSrc
specifier|static
name|void
name|PopEofSrc
parameter_list|()
block|{
if|if
condition|(
name|cpp
operator|->
name|currentInput
operator|->
name|scan
operator|==
name|eof_scan
condition|)
block|{
name|InputSrc
modifier|*
name|in
init|=
name|cpp
operator|->
name|currentInput
decl_stmt|;
name|cpp
operator|->
name|currentInput
operator|=
name|in
operator|->
name|prev
expr_stmt|;
name|free
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|PrescanMacroArg
specifier|static
name|TokenStream
modifier|*
name|PrescanMacroArg
parameter_list|(
name|TokenStream
modifier|*
name|a
parameter_list|,
name|yystypepp
modifier|*
name|yylvalpp
parameter_list|)
block|{
name|int
name|token
decl_stmt|;
name|TokenStream
modifier|*
name|n
decl_stmt|;
name|RewindTokenStream
argument_list|(
name|a
argument_list|)
expr_stmt|;
do|do
block|{
name|token
operator|=
name|ReadToken
argument_list|(
name|a
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|CPP_IDENTIFIER
operator|&&
name|LookUpSymbol
argument_list|(
name|macros
argument_list|,
name|yylvalpp
operator|->
name|sc_ident
argument_list|)
condition|)
break|break;
block|}
do|while
condition|(
name|token
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|token
operator|<=
literal|0
condition|)
return|return
name|a
return|;
name|n
operator|=
name|NewTokenStream
argument_list|(
literal|"macro arg"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PushEofSrc
argument_list|()
expr_stmt|;
name|ReadFromTokenStream
argument_list|(
name|a
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|token
operator|==
name|CPP_IDENTIFIER
operator|&&
name|MacroExpand
argument_list|(
name|yylvalpp
operator|->
name|sc_ident
argument_list|,
name|yylvalpp
argument_list|)
condition|)
continue|continue;
name|RecordToken
argument_list|(
name|n
argument_list|,
name|token
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
name|PopEofSrc
argument_list|()
expr_stmt|;
name|DeleteTokenStream
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function
begin_comment
comment|// PrescanMacroArg
end_comment
begin_typedef
DECL|struct|MacroInputSrc
typedef|typedef
struct|struct
name|MacroInputSrc
block|{
DECL|member|base
name|InputSrc
name|base
decl_stmt|;
DECL|member|mac
name|MacroSymbol
modifier|*
name|mac
decl_stmt|;
DECL|member|args
name|TokenStream
modifier|*
modifier|*
name|args
decl_stmt|;
block|}
DECL|typedef|MacroInputSrc
name|MacroInputSrc
typedef|;
end_typedef
begin_comment
comment|/* macro_scan --- ** return the next token for a macro expanion, handling macro args  */
end_comment
begin_function
DECL|function|macro_scan
specifier|static
name|int
name|macro_scan
parameter_list|(
name|MacroInputSrc
modifier|*
name|in
parameter_list|,
name|yystypepp
modifier|*
name|yylvalpp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|token
init|=
name|ReadToken
argument_list|(
name|in
operator|->
name|mac
operator|->
name|body
argument_list|,
name|yylvalpp
argument_list|)
decl_stmt|;
if|if
condition|(
name|token
operator|==
name|CPP_IDENTIFIER
condition|)
block|{
for|for
control|(
name|i
operator|=
name|in
operator|->
name|mac
operator|->
name|argc
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|in
operator|->
name|mac
operator|->
name|args
index|[
name|i
index|]
operator|==
name|yylvalpp
operator|->
name|sc_ident
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|ReadFromTokenStream
argument_list|(
name|in
operator|->
name|args
index|[
name|i
index|]
argument_list|,
name|yylvalpp
operator|->
name|sc_ident
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|token
operator|>
literal|0
condition|)
return|return
name|token
return|;
name|in
operator|->
name|mac
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
name|cpp
operator|->
name|currentInput
operator|=
name|in
operator|->
name|base
operator|.
name|prev
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|args
condition|)
block|{
for|for
control|(
name|i
operator|=
name|in
operator|->
name|mac
operator|->
name|argc
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|DeleteTokenStream
argument_list|(
name|in
operator|->
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|in
operator|->
name|args
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
return|;
block|}
end_function
begin_comment
comment|// macro_scan
end_comment
begin_comment
comment|/* MacroExpand ** check an identifier (atom) to see if it a macro that should be expanded. ** If it is, push an InputSrc that will produce the appropriate expansion ** and return TRUE.  If not, return FALSE. */
end_comment
begin_function
DECL|function|MacroExpand
name|int
name|MacroExpand
parameter_list|(
name|int
name|atom
parameter_list|,
name|yystypepp
modifier|*
name|yylvalpp
parameter_list|)
block|{
name|Symbol
modifier|*
name|sym
init|=
name|LookUpSymbol
argument_list|(
name|macros
argument_list|,
name|atom
argument_list|)
decl_stmt|;
name|MacroInputSrc
modifier|*
name|in
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|token
decl_stmt|,
name|depth
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
if|if
condition|(
name|atom
operator|==
name|__LINE__Atom
condition|)
block|{
name|yylvalpp
operator|->
name|sc_int
operator|=
name|GetLineNumber
argument_list|()
expr_stmt|;
name|snprintf
argument_list|(
name|yylvalpp
operator|->
name|symbol_name
argument_list|,
name|MAX_SYMBOL_NAME_LEN
operator|+
literal|1
argument_list|,
literal|"%d"
argument_list|,
name|yylvalpp
operator|->
name|sc_int
argument_list|)
expr_stmt|;
name|UngetToken
argument_list|(
name|CPP_INTCONSTANT
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|atom
operator|==
name|__FILE__Atom
condition|)
block|{
name|yylvalpp
operator|->
name|sc_int
operator|=
name|GetStringNumber
argument_list|()
expr_stmt|;
name|snprintf
argument_list|(
name|yylvalpp
operator|->
name|symbol_name
argument_list|,
name|MAX_SYMBOL_NAME_LEN
operator|+
literal|1
argument_list|,
literal|"%d"
argument_list|,
name|yylvalpp
operator|->
name|sc_int
argument_list|)
expr_stmt|;
name|UngetToken
argument_list|(
name|CPP_INTCONSTANT
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|atom
operator|==
name|__VERSION__Atom
condition|)
block|{
name|strcpy
argument_list|(
name|yylvalpp
operator|->
name|symbol_name
argument_list|,
name|ESSL_VERSION_STRING
argument_list|)
expr_stmt|;
name|yylvalpp
operator|->
name|sc_int
operator|=
name|atoi
argument_list|(
name|yylvalpp
operator|->
name|symbol_name
argument_list|)
expr_stmt|;
name|UngetToken
argument_list|(
name|CPP_INTCONSTANT
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|sym
operator|||
name|sym
operator|->
name|details
operator|.
name|mac
operator|.
name|undef
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sym
operator|->
name|details
operator|.
name|mac
operator|.
name|busy
condition|)
return|return
literal|0
return|;
comment|// no recursive expansions
name|in
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|in
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|in
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|in
argument_list|)
argument_list|)
expr_stmt|;
name|in
operator|->
name|base
operator|.
name|scan
operator|=
operator|(
name|void
operator|*
operator|)
name|macro_scan
expr_stmt|;
name|in
operator|->
name|base
operator|.
name|line
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|line
expr_stmt|;
name|in
operator|->
name|base
operator|.
name|name
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|name
expr_stmt|;
name|in
operator|->
name|mac
operator|=
operator|&
name|sym
operator|->
name|details
operator|.
name|mac
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|details
operator|.
name|mac
operator|.
name|args
condition|)
block|{
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
literal|'('
condition|)
block|{
name|UngetToken
argument_list|(
name|token
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
name|yylvalpp
operator|->
name|sc_ident
operator|=
name|atom
expr_stmt|;
return|return
literal|0
return|;
block|}
name|in
operator|->
name|args
operator|=
name|malloc
argument_list|(
name|in
operator|->
name|mac
operator|->
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|TokenStream
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|in
operator|->
name|mac
operator|->
name|argc
condition|;
name|i
operator|++
control|)
name|in
operator|->
name|args
index|[
name|i
index|]
operator|=
name|NewTokenStream
argument_list|(
literal|"macro arg"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|depth
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|<=
literal|0
condition|)
block|{
name|StoreStr
argument_list|(
literal|"EOF in Macro "
argument_list|)
expr_stmt|;
name|StoreStr
argument_list|(
name|GetStringOfAtom
argument_list|(
name|atable
argument_list|,
name|atom
argument_list|)
argument_list|)
expr_stmt|;
name|message
operator|=
name|GetStrfromTStr
argument_list|()
expr_stmt|;
name|CPPShInfoLogMsg
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|ResetTString
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|in
operator|->
name|mac
operator|->
name|argc
operator|==
literal|0
operator|)
operator|&&
operator|(
name|token
operator|!=
literal|')'
operator|)
condition|)
break|break;
if|if
condition|(
name|depth
operator|==
literal|0
operator|&&
operator|(
name|token
operator|==
literal|','
operator|||
name|token
operator|==
literal|')'
operator|)
condition|)
break|break;
if|if
condition|(
name|token
operator|==
literal|'('
condition|)
name|depth
operator|++
expr_stmt|;
if|if
condition|(
name|token
operator|==
literal|')'
condition|)
name|depth
operator|--
expr_stmt|;
name|RecordToken
argument_list|(
name|in
operator|->
name|args
index|[
name|i
index|]
argument_list|,
name|token
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|token
operator|==
literal|')'
condition|)
block|{
if|if
condition|(
operator|(
name|in
operator|->
name|mac
operator|->
name|argc
operator|==
literal|1
operator|)
operator|&&
name|j
operator|==
literal|0
condition|)
break|break;
name|i
operator|++
expr_stmt|;
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<
name|in
operator|->
name|mac
operator|->
name|argc
condition|)
do|;
if|if
condition|(
name|i
operator|<
name|in
operator|->
name|mac
operator|->
name|argc
condition|)
block|{
name|StoreStr
argument_list|(
literal|"Too few args in Macro "
argument_list|)
expr_stmt|;
name|StoreStr
argument_list|(
name|GetStringOfAtom
argument_list|(
name|atable
argument_list|,
name|atom
argument_list|)
argument_list|)
expr_stmt|;
name|message
operator|=
name|GetStrfromTStr
argument_list|()
expr_stmt|;
name|CPPShInfoLogMsg
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|ResetTString
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|!=
literal|')'
condition|)
block|{
name|depth
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|token
operator|>=
literal|0
operator|&&
operator|(
name|depth
operator|>
literal|0
operator|||
name|token
operator|!=
literal|')'
operator|)
condition|)
block|{
if|if
condition|(
name|token
operator|==
literal|')'
condition|)
name|depth
operator|--
expr_stmt|;
name|token
operator|=
name|cpp
operator|->
name|currentInput
operator|->
name|scan
argument_list|(
name|cpp
operator|->
name|currentInput
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
literal|'('
condition|)
name|depth
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|token
operator|<=
literal|0
condition|)
block|{
name|StoreStr
argument_list|(
literal|"EOF in Macro "
argument_list|)
expr_stmt|;
name|StoreStr
argument_list|(
name|GetStringOfAtom
argument_list|(
name|atable
argument_list|,
name|atom
argument_list|)
argument_list|)
expr_stmt|;
name|message
operator|=
name|GetStrfromTStr
argument_list|()
expr_stmt|;
name|CPPShInfoLogMsg
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|ResetTString
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
name|StoreStr
argument_list|(
literal|"Too many args in Macro "
argument_list|)
expr_stmt|;
name|StoreStr
argument_list|(
name|GetStringOfAtom
argument_list|(
name|atable
argument_list|,
name|atom
argument_list|)
argument_list|)
expr_stmt|;
name|message
operator|=
name|GetStrfromTStr
argument_list|()
expr_stmt|;
name|CPPShInfoLogMsg
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|ResetTString
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|in
operator|->
name|mac
operator|->
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|in
operator|->
name|args
index|[
name|i
index|]
operator|=
name|PrescanMacroArg
argument_list|(
name|in
operator|->
name|args
index|[
name|i
index|]
argument_list|,
name|yylvalpp
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
block|printf("<%s:%d>found macro %s\n", GetAtomString(atable, loc.file),            loc.line, GetAtomString(atable, atom));     for (i=0; i<in->mac->argc; i++) {         printf("\targ %s = '", GetAtomString(atable, in->mac->args[i]));         DumpTokenStream(stdout, in->args[i]);         printf("'\n");     }
endif|#
directive|endif
comment|/*retain the input source*/
name|in
operator|->
name|base
operator|.
name|prev
operator|=
name|cpp
operator|->
name|currentInput
expr_stmt|;
name|sym
operator|->
name|details
operator|.
name|mac
operator|.
name|busy
operator|=
literal|1
expr_stmt|;
name|RewindTokenStream
argument_list|(
name|sym
operator|->
name|details
operator|.
name|mac
operator|.
name|body
argument_list|)
expr_stmt|;
name|cpp
operator|->
name|currentInput
operator|=
operator|&
name|in
operator|->
name|base
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|// MacroExpand
end_comment
begin_function
DECL|function|ChkCorrectElseNesting
name|int
name|ChkCorrectElseNesting
parameter_list|(
name|void
parameter_list|)
block|{
comment|// sanity check to make sure elsetracker is in a valid range
if|if
condition|(
name|cpp
operator|->
name|elsetracker
operator|<
literal|0
operator|||
name|cpp
operator|->
name|elsetracker
operator|>=
name|MAX_IF_NESTING
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|cpp
operator|->
name|elsedepth
index|[
name|cpp
operator|->
name|elsetracker
index|]
operator|==
literal|0
condition|)
block|{
name|cpp
operator|->
name|elsedepth
index|[
name|cpp
operator|->
name|elsetracker
index|]
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
end_unit
