begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2012 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|"compiler/ParseHelper.h"
end_include
begin_include
include|#
directive|include
file|<stdarg.h>
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|"compiler/glslang.h"
end_include
begin_include
include|#
directive|include
file|"compiler/preprocessor/new/SourceLocation.h"
end_include
begin_comment
comment|///////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Sub- vector and matrix fields
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Look at a '.' field selector string and change it into offsets
end_comment
begin_comment
comment|// for a vector.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|parseVectorFields
name|bool
name|TParseContext
operator|::
name|parseVectorFields
parameter_list|(
specifier|const
name|TString
modifier|&
name|compString
parameter_list|,
name|int
name|vecSize
parameter_list|,
name|TVectorFields
modifier|&
name|fields
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|fields
operator|.
name|num
operator|=
operator|(
name|int
operator|)
name|compString
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|fields
operator|.
name|num
operator|>
literal|4
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"illegal vector field selection"
argument_list|,
name|compString
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
enum|enum
block|{
name|exyzw
block|,
name|ergba
block|,
name|estpq
block|,     }
name|fieldSet
index|[
literal|4
index|]
enum|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|num
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|compString
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'x'
case|:
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|fieldSet
index|[
name|i
index|]
operator|=
name|exyzw
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|fieldSet
index|[
name|i
index|]
operator|=
name|ergba
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|fieldSet
index|[
name|i
index|]
operator|=
name|estpq
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|fieldSet
index|[
name|i
index|]
operator|=
name|exyzw
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|fieldSet
index|[
name|i
index|]
operator|=
name|ergba
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|fieldSet
index|[
name|i
index|]
operator|=
name|estpq
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|2
expr_stmt|;
name|fieldSet
index|[
name|i
index|]
operator|=
name|exyzw
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|2
expr_stmt|;
name|fieldSet
index|[
name|i
index|]
operator|=
name|ergba
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|2
expr_stmt|;
name|fieldSet
index|[
name|i
index|]
operator|=
name|estpq
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|3
expr_stmt|;
name|fieldSet
index|[
name|i
index|]
operator|=
name|exyzw
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|3
expr_stmt|;
name|fieldSet
index|[
name|i
index|]
operator|=
name|ergba
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|3
expr_stmt|;
name|fieldSet
index|[
name|i
index|]
operator|=
name|estpq
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
name|line
argument_list|,
literal|"illegal vector field selection"
argument_list|,
name|compString
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|num
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|>=
name|vecSize
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"vector field selection out of range"
argument_list|,
name|compString
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|fieldSet
index|[
name|i
index|]
operator|!=
name|fieldSet
index|[
name|i
operator|-
literal|1
index|]
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"illegal - vector component fields not from the same set"
argument_list|,
name|compString
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Look at a '.' field selector string and change it into offsets
end_comment
begin_comment
comment|// for a matrix.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|parseMatrixFields
name|bool
name|TParseContext
operator|::
name|parseMatrixFields
parameter_list|(
specifier|const
name|TString
modifier|&
name|compString
parameter_list|,
name|int
name|matSize
parameter_list|,
name|TMatrixFields
modifier|&
name|fields
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|fields
operator|.
name|wholeRow
operator|=
literal|false
expr_stmt|;
name|fields
operator|.
name|wholeCol
operator|=
literal|false
expr_stmt|;
name|fields
operator|.
name|row
operator|=
operator|-
literal|1
expr_stmt|;
name|fields
operator|.
name|col
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|compString
operator|.
name|size
argument_list|()
operator|!=
literal|2
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"illegal length of matrix field selection"
argument_list|,
name|compString
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|compString
index|[
literal|0
index|]
operator|==
literal|'_'
condition|)
block|{
if|if
condition|(
name|compString
index|[
literal|1
index|]
operator|<
literal|'0'
operator|||
name|compString
index|[
literal|1
index|]
operator|>
literal|'3'
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"illegal matrix field selection"
argument_list|,
name|compString
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|fields
operator|.
name|wholeCol
operator|=
literal|true
expr_stmt|;
name|fields
operator|.
name|col
operator|=
name|compString
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|compString
index|[
literal|1
index|]
operator|==
literal|'_'
condition|)
block|{
if|if
condition|(
name|compString
index|[
literal|0
index|]
operator|<
literal|'0'
operator|||
name|compString
index|[
literal|0
index|]
operator|>
literal|'3'
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"illegal matrix field selection"
argument_list|,
name|compString
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|fields
operator|.
name|wholeRow
operator|=
literal|true
expr_stmt|;
name|fields
operator|.
name|row
operator|=
name|compString
index|[
literal|0
index|]
operator|-
literal|'0'
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|compString
index|[
literal|0
index|]
operator|<
literal|'0'
operator|||
name|compString
index|[
literal|0
index|]
operator|>
literal|'3'
operator|||
name|compString
index|[
literal|1
index|]
operator|<
literal|'0'
operator|||
name|compString
index|[
literal|1
index|]
operator|>
literal|'3'
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"illegal matrix field selection"
argument_list|,
name|compString
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|fields
operator|.
name|row
operator|=
name|compString
index|[
literal|0
index|]
operator|-
literal|'0'
expr_stmt|;
name|fields
operator|.
name|col
operator|=
name|compString
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
block|}
if|if
condition|(
name|fields
operator|.
name|row
operator|>=
name|matSize
operator|||
name|fields
operator|.
name|col
operator|>=
name|matSize
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"matrix field selection out of range"
argument_list|,
name|compString
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|///////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Errors
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Track whether errors have occurred.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|recover
name|void
name|TParseContext
operator|::
name|recover
parameter_list|()
block|{ }
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Used by flex/bison to output all syntax and parsing errors.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|error
name|void
name|TParseContext
operator|::
name|error
parameter_list|(
name|TSourceLoc
name|loc
parameter_list|,
specifier|const
name|char
modifier|*
name|reason
parameter_list|,
specifier|const
name|char
modifier|*
name|token
parameter_list|,
specifier|const
name|char
modifier|*
name|extraInfo
parameter_list|)
block|{
name|pp
operator|::
name|SourceLocation
name|srcLoc
decl_stmt|;
name|DecodeSourceLoc
argument_list|(
name|loc
argument_list|,
operator|&
name|srcLoc
operator|.
name|file
argument_list|,
operator|&
name|srcLoc
operator|.
name|line
argument_list|)
expr_stmt|;
name|diagnostics
operator|.
name|writeInfo
argument_list|(
name|pp
operator|::
name|Diagnostics
operator|::
name|ERROR
argument_list|,
name|srcLoc
argument_list|,
name|reason
argument_list|,
name|token
argument_list|,
name|extraInfo
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|warning
name|void
name|TParseContext
operator|::
name|warning
parameter_list|(
name|TSourceLoc
name|loc
parameter_list|,
specifier|const
name|char
modifier|*
name|reason
parameter_list|,
specifier|const
name|char
modifier|*
name|token
parameter_list|,
specifier|const
name|char
modifier|*
name|extraInfo
parameter_list|)
block|{
name|pp
operator|::
name|SourceLocation
name|srcLoc
decl_stmt|;
name|DecodeSourceLoc
argument_list|(
name|loc
argument_list|,
operator|&
name|srcLoc
operator|.
name|file
argument_list|,
operator|&
name|srcLoc
operator|.
name|line
argument_list|)
expr_stmt|;
name|diagnostics
operator|.
name|writeInfo
argument_list|(
name|pp
operator|::
name|Diagnostics
operator|::
name|WARNING
argument_list|,
name|srcLoc
argument_list|,
name|reason
argument_list|,
name|token
argument_list|,
name|extraInfo
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|trace
name|void
name|TParseContext
operator|::
name|trace
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|diagnostics
operator|.
name|writeDebug
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Same error message for all places assignments don't work.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|assignError
name|void
name|TParseContext
operator|::
name|assignError
parameter_list|(
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|op
parameter_list|,
name|TString
name|left
parameter_list|,
name|TString
name|right
parameter_list|)
block|{
name|std
operator|::
name|stringstream
name|extraInfoStream
decl_stmt|;
name|extraInfoStream
operator|<<
literal|"cannot convert from '"
operator|<<
name|right
operator|<<
literal|"' to '"
operator|<<
name|left
operator|<<
literal|"'"
expr_stmt|;
name|std
operator|::
name|string
name|extraInfo
init|=
name|extraInfoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|error
argument_list|(
name|line
argument_list|,
literal|""
argument_list|,
name|op
argument_list|,
name|extraInfo
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Same error message for all places unary operations don't work.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|unaryOpError
name|void
name|TParseContext
operator|::
name|unaryOpError
parameter_list|(
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|op
parameter_list|,
name|TString
name|operand
parameter_list|)
block|{
name|std
operator|::
name|stringstream
name|extraInfoStream
decl_stmt|;
name|extraInfoStream
operator|<<
literal|"no operation '"
operator|<<
name|op
operator|<<
literal|"' exists that takes an operand of type "
operator|<<
name|operand
operator|<<
literal|" (or there is no acceptable conversion)"
expr_stmt|;
name|std
operator|::
name|string
name|extraInfo
init|=
name|extraInfoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|error
argument_list|(
name|line
argument_list|,
literal|" wrong operand type"
argument_list|,
name|op
argument_list|,
name|extraInfo
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Same error message for all binary operations don't work.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|binaryOpError
name|void
name|TParseContext
operator|::
name|binaryOpError
parameter_list|(
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|op
parameter_list|,
name|TString
name|left
parameter_list|,
name|TString
name|right
parameter_list|)
block|{
name|std
operator|::
name|stringstream
name|extraInfoStream
decl_stmt|;
name|extraInfoStream
operator|<<
literal|"no operation '"
operator|<<
name|op
operator|<<
literal|"' exists that takes a left-hand operand of type '"
operator|<<
name|left
operator|<<
literal|"' and a right operand of type '"
operator|<<
name|right
operator|<<
literal|"' (or there is no acceptable conversion)"
expr_stmt|;
name|std
operator|::
name|string
name|extraInfo
init|=
name|extraInfoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|error
argument_list|(
name|line
argument_list|,
literal|" wrong operand types "
argument_list|,
name|op
argument_list|,
name|extraInfo
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|precisionErrorCheck
name|bool
name|TParseContext
operator|::
name|precisionErrorCheck
parameter_list|(
name|int
name|line
parameter_list|,
name|TPrecision
name|precision
parameter_list|,
name|TBasicType
name|type
parameter_list|)
block|{
if|if
condition|(
operator|!
name|checksPrecisionErrors
condition|)
return|return
literal|false
return|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|EbtFloat
case|:
if|if
condition|(
name|precision
operator|==
name|EbpUndefined
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"No precision specified for (float)"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
break|break;
case|case
name|EbtInt
case|:
if|if
condition|(
name|precision
operator|==
name|EbpUndefined
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"No precision specified (int)"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
break|break;
default|default:
return|return
literal|false
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Both test and if necessary, spit out an error, to see if the node is really
end_comment
begin_comment
comment|// an l-value that can be operated on this way.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns true if the was an error.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|lValueErrorCheck
name|bool
name|TParseContext
operator|::
name|lValueErrorCheck
parameter_list|(
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|op
parameter_list|,
name|TIntermTyped
modifier|*
name|node
parameter_list|)
block|{
name|TIntermSymbol
modifier|*
name|symNode
init|=
name|node
operator|->
name|getAsSymbolNode
argument_list|()
decl_stmt|;
name|TIntermBinary
modifier|*
name|binaryNode
init|=
name|node
operator|->
name|getAsBinaryNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|binaryNode
condition|)
block|{
name|bool
name|errorReturn
decl_stmt|;
switch|switch
condition|(
name|binaryNode
operator|->
name|getOp
argument_list|()
condition|)
block|{
case|case
name|EOpIndexDirect
case|:
case|case
name|EOpIndexIndirect
case|:
case|case
name|EOpIndexDirectStruct
case|:
return|return
name|lValueErrorCheck
argument_list|(
name|line
argument_list|,
name|op
argument_list|,
name|binaryNode
operator|->
name|getLeft
argument_list|()
argument_list|)
return|;
case|case
name|EOpVectorSwizzle
case|:
name|errorReturn
operator|=
name|lValueErrorCheck
argument_list|(
name|line
argument_list|,
name|op
argument_list|,
name|binaryNode
operator|->
name|getLeft
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|errorReturn
condition|)
block|{
name|int
name|offset
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|TIntermTyped
modifier|*
name|rightNode
init|=
name|binaryNode
operator|->
name|getRight
argument_list|()
decl_stmt|;
name|TIntermAggregate
modifier|*
name|aggrNode
init|=
name|rightNode
operator|->
name|getAsAggregate
argument_list|()
decl_stmt|;
for|for
control|(
name|TIntermSequence
operator|::
name|iterator
name|p
init|=
name|aggrNode
operator|->
name|getSequence
argument_list|()
operator|.
name|begin
argument_list|()
init|;
name|p
operator|!=
name|aggrNode
operator|->
name|getSequence
argument_list|()
operator|.
name|end
argument_list|()
condition|;
name|p
operator|++
control|)
block|{
name|int
name|value
init|=
operator|(
operator|*
name|p
operator|)
operator|->
name|getAsTyped
argument_list|()
operator|->
name|getAsConstantUnion
argument_list|()
operator|->
name|getUnionArrayPointer
argument_list|()
operator|->
name|getIConst
argument_list|()
decl_stmt|;
name|offset
index|[
name|value
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|offset
index|[
name|value
index|]
operator|>
literal|1
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|" l-value of swizzle cannot have duplicate components"
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
name|errorReturn
return|;
default|default:
break|break;
block|}
name|error
argument_list|(
name|line
argument_list|,
literal|" l-value required"
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|const
name|char
modifier|*
name|symbol
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|symNode
operator|!=
literal|0
condition|)
name|symbol
operator|=
name|symNode
operator|->
name|getSymbol
argument_list|()
operator|.
name|c_str
argument_list|()
expr_stmt|;
specifier|const
name|char
modifier|*
name|message
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|getQualifier
argument_list|()
condition|)
block|{
case|case
name|EvqConst
case|:
name|message
operator|=
literal|"can't modify a const"
expr_stmt|;
break|break;
case|case
name|EvqConstReadOnly
case|:
name|message
operator|=
literal|"can't modify a const"
expr_stmt|;
break|break;
case|case
name|EvqAttribute
case|:
name|message
operator|=
literal|"can't modify an attribute"
expr_stmt|;
break|break;
case|case
name|EvqUniform
case|:
name|message
operator|=
literal|"can't modify a uniform"
expr_stmt|;
break|break;
case|case
name|EvqVaryingIn
case|:
name|message
operator|=
literal|"can't modify a varying"
expr_stmt|;
break|break;
case|case
name|EvqInput
case|:
name|message
operator|=
literal|"can't modify an input"
expr_stmt|;
break|break;
case|case
name|EvqFragCoord
case|:
name|message
operator|=
literal|"can't modify gl_FragCoord"
expr_stmt|;
break|break;
case|case
name|EvqFrontFacing
case|:
name|message
operator|=
literal|"can't modify gl_FrontFacing"
expr_stmt|;
break|break;
case|case
name|EvqPointCoord
case|:
name|message
operator|=
literal|"can't modify gl_PointCoord"
expr_stmt|;
break|break;
default|default:
comment|//
comment|// Type that can't be written to?
comment|//
switch|switch
condition|(
name|node
operator|->
name|getBasicType
argument_list|()
condition|)
block|{
case|case
name|EbtSampler2D
case|:
case|case
name|EbtSamplerCube
case|:
name|message
operator|=
literal|"can't modify a sampler"
expr_stmt|;
break|break;
case|case
name|EbtVoid
case|:
name|message
operator|=
literal|"can't modify void"
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|message
operator|==
literal|0
operator|&&
name|binaryNode
operator|==
literal|0
operator|&&
name|symNode
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|" l-value required"
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|//
comment|// Everything else is okay, no error.
comment|//
if|if
condition|(
name|message
operator|==
literal|0
condition|)
return|return
literal|false
return|;
comment|//
comment|// If we get here, we have an error and a message.
comment|//
if|if
condition|(
name|symNode
condition|)
block|{
name|std
operator|::
name|stringstream
name|extraInfoStream
decl_stmt|;
name|extraInfoStream
operator|<<
literal|"\""
operator|<<
name|symbol
operator|<<
literal|"\" ("
operator|<<
name|message
operator|<<
literal|")"
expr_stmt|;
name|std
operator|::
name|string
name|extraInfo
init|=
name|extraInfoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|error
argument_list|(
name|line
argument_list|,
literal|" l-value required"
argument_list|,
name|op
argument_list|,
name|extraInfo
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|std
operator|::
name|stringstream
name|extraInfoStream
decl_stmt|;
name|extraInfoStream
operator|<<
literal|"("
operator|<<
name|message
operator|<<
literal|")"
expr_stmt|;
name|std
operator|::
name|string
name|extraInfo
init|=
name|extraInfoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|error
argument_list|(
name|line
argument_list|,
literal|" l-value required"
argument_list|,
name|op
argument_list|,
name|extraInfo
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Both test, and if necessary spit out an error, to see if the node is really
end_comment
begin_comment
comment|// a constant.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns true if the was an error.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|constErrorCheck
name|bool
name|TParseContext
operator|::
name|constErrorCheck
parameter_list|(
name|TIntermTyped
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|->
name|getQualifier
argument_list|()
operator|==
name|EvqConst
condition|)
return|return
literal|false
return|;
name|error
argument_list|(
name|node
operator|->
name|getLine
argument_list|()
argument_list|,
literal|"constant expression required"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Both test, and if necessary spit out an error, to see if the node is really
end_comment
begin_comment
comment|// an integer.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns true if the was an error.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|integerErrorCheck
name|bool
name|TParseContext
operator|::
name|integerErrorCheck
parameter_list|(
name|TIntermTyped
modifier|*
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|token
parameter_list|)
block|{
if|if
condition|(
name|node
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtInt
operator|&&
name|node
operator|->
name|getNominalSize
argument_list|()
operator|==
literal|1
condition|)
return|return
literal|false
return|;
name|error
argument_list|(
name|node
operator|->
name|getLine
argument_list|()
argument_list|,
literal|"integer expression required"
argument_list|,
name|token
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Both test, and if necessary spit out an error, to see if we are currently
end_comment
begin_comment
comment|// globally scoped.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns true if the was an error.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|globalErrorCheck
name|bool
name|TParseContext
operator|::
name|globalErrorCheck
parameter_list|(
name|int
name|line
parameter_list|,
name|bool
name|global
parameter_list|,
specifier|const
name|char
modifier|*
name|token
parameter_list|)
block|{
if|if
condition|(
name|global
condition|)
return|return
literal|false
return|;
name|error
argument_list|(
name|line
argument_list|,
literal|"only allowed at global scope"
argument_list|,
name|token
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// For now, keep it simple:  if it starts "gl_", it's reserved, independent
end_comment
begin_comment
comment|// of scope.  Except, if the symbol table is at the built-in push-level,
end_comment
begin_comment
comment|// which is when we are parsing built-ins.
end_comment
begin_comment
comment|// Also checks for "webgl_" and "_webgl_" reserved identifiers if parsing a
end_comment
begin_comment
comment|// webgl shader.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns true if there was an error.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|reservedErrorCheck
name|bool
name|TParseContext
operator|::
name|reservedErrorCheck
parameter_list|(
name|int
name|line
parameter_list|,
specifier|const
name|TString
modifier|&
name|identifier
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|reservedErrMsg
init|=
literal|"reserved built-in name"
decl_stmt|;
if|if
condition|(
operator|!
name|symbolTable
operator|.
name|atBuiltInLevel
argument_list|()
condition|)
block|{
if|if
condition|(
name|identifier
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|,
literal|"gl_"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
name|reservedErrMsg
argument_list|,
literal|"gl_"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|isWebGLBasedSpec
argument_list|(
name|shaderSpec
argument_list|)
condition|)
block|{
if|if
condition|(
name|identifier
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|6
argument_list|,
literal|"webgl_"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
name|reservedErrMsg
argument_list|,
literal|"webgl_"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|identifier
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|7
argument_list|,
literal|"_webgl_"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
name|reservedErrMsg
argument_list|,
literal|"_webgl_"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|shaderSpec
operator|==
name|SH_CSS_SHADERS_SPEC
operator|&&
name|identifier
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|,
literal|"css_"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
name|reservedErrMsg
argument_list|,
literal|"css_"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
if|if
condition|(
name|identifier
operator|.
name|find
argument_list|(
literal|"__"
argument_list|)
operator|!=
name|TString
operator|::
name|npos
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"identifiers containing two consecutive underscores (__) are reserved as possible future keywords"
argument_list|,
name|identifier
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Make sure there is enough data provided to the constructor to build
end_comment
begin_comment
comment|// something of the type of the constructor.  Also returns the type of
end_comment
begin_comment
comment|// the constructor.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns true if there was an error in construction.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|constructorErrorCheck
name|bool
name|TParseContext
operator|::
name|constructorErrorCheck
parameter_list|(
name|int
name|line
parameter_list|,
name|TIntermNode
modifier|*
name|node
parameter_list|,
name|TFunction
modifier|&
name|function
parameter_list|,
name|TOperator
name|op
parameter_list|,
name|TType
modifier|*
name|type
parameter_list|)
block|{
operator|*
name|type
operator|=
name|function
operator|.
name|getReturnType
argument_list|()
expr_stmt|;
name|bool
name|constructingMatrix
init|=
literal|false
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|EOpConstructMat2
case|:
case|case
name|EOpConstructMat3
case|:
case|case
name|EOpConstructMat4
case|:
name|constructingMatrix
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|//
comment|// Note: It's okay to have too many components available, but not okay to have unused
comment|// arguments.  'full' will go to true when enough args have been seen.  If we loop
comment|// again, there is an extra argument, so 'overfull' will become true.
comment|//
name|int
name|size
init|=
literal|0
decl_stmt|;
name|bool
name|constType
init|=
literal|true
decl_stmt|;
name|bool
name|full
init|=
literal|false
decl_stmt|;
name|bool
name|overFull
init|=
literal|false
decl_stmt|;
name|bool
name|matrixInMatrix
init|=
literal|false
decl_stmt|;
name|bool
name|arrayArg
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|function
operator|.
name|getParamCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|TParameter
modifier|&
name|param
init|=
name|function
operator|.
name|getParam
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|size
operator|+=
name|param
operator|.
name|type
operator|->
name|getObjectSize
argument_list|()
expr_stmt|;
if|if
condition|(
name|constructingMatrix
operator|&&
name|param
operator|.
name|type
operator|->
name|isMatrix
argument_list|()
condition|)
name|matrixInMatrix
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|full
condition|)
name|overFull
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|op
operator|!=
name|EOpConstructStruct
operator|&&
operator|!
name|type
operator|->
name|isArray
argument_list|()
operator|&&
name|size
operator|>=
name|type
operator|->
name|getObjectSize
argument_list|()
condition|)
name|full
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|param
operator|.
name|type
operator|->
name|getQualifier
argument_list|()
operator|!=
name|EvqConst
condition|)
name|constType
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|param
operator|.
name|type
operator|->
name|isArray
argument_list|()
condition|)
name|arrayArg
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|constType
condition|)
name|type
operator|->
name|setQualifier
argument_list|(
name|EvqConst
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|->
name|isArray
argument_list|()
operator|&&
name|type
operator|->
name|getArraySize
argument_list|()
operator|!=
name|function
operator|.
name|getParamCount
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"array constructor needs one argument per array element"
argument_list|,
literal|"constructor"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|arrayArg
operator|&&
name|op
operator|!=
name|EOpConstructStruct
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"constructing from a non-dereferenced array"
argument_list|,
literal|"constructor"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|matrixInMatrix
operator|&&
operator|!
name|type
operator|->
name|isArray
argument_list|()
condition|)
block|{
if|if
condition|(
name|function
operator|.
name|getParamCount
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"constructing matrix from matrix can only take one argument"
argument_list|,
literal|"constructor"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
if|if
condition|(
name|overFull
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"too many arguments"
argument_list|,
literal|"constructor"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|op
operator|==
name|EOpConstructStruct
operator|&&
operator|!
name|type
operator|->
name|isArray
argument_list|()
operator|&&
name|int
argument_list|(
name|type
operator|->
name|getStruct
argument_list|()
operator|->
name|size
argument_list|()
argument_list|)
operator|!=
name|function
operator|.
name|getParamCount
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"Number of constructor parameters does not match the number of structure fields"
argument_list|,
literal|"constructor"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|type
operator|->
name|isMatrix
argument_list|()
operator|||
operator|!
name|matrixInMatrix
condition|)
block|{
if|if
condition|(
operator|(
name|op
operator|!=
name|EOpConstructStruct
operator|&&
name|size
operator|!=
literal|1
operator|&&
name|size
operator|<
name|type
operator|->
name|getObjectSize
argument_list|()
operator|)
operator|||
operator|(
name|op
operator|==
name|EOpConstructStruct
operator|&&
name|size
operator|<
name|type
operator|->
name|getObjectSize
argument_list|()
operator|)
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"not enough data provided for construction"
argument_list|,
literal|"constructor"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
name|TIntermTyped
modifier|*
name|typed
init|=
name|node
condition|?
name|node
operator|->
name|getAsTyped
argument_list|()
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|typed
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"constructor argument does not have a type"
argument_list|,
literal|"constructor"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|op
operator|!=
name|EOpConstructStruct
operator|&&
name|IsSampler
argument_list|(
name|typed
operator|->
name|getBasicType
argument_list|()
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"cannot convert a sampler"
argument_list|,
literal|"constructor"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|typed
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtVoid
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"cannot convert a void"
argument_list|,
literal|"constructor"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|// This function checks to see if a void variable has been declared and raise an error message for such a case
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// returns true in case of an error
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|voidErrorCheck
name|bool
name|TParseContext
operator|::
name|voidErrorCheck
parameter_list|(
name|int
name|line
parameter_list|,
specifier|const
name|TString
modifier|&
name|identifier
parameter_list|,
specifier|const
name|TPublicType
modifier|&
name|pubType
parameter_list|)
block|{
if|if
condition|(
name|pubType
operator|.
name|type
operator|==
name|EbtVoid
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"illegal use of type 'void'"
argument_list|,
name|identifier
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|// This function checks to see if the node (for the expression) contains a scalar boolean expression or not
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// returns true in case of an error
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|boolErrorCheck
name|bool
name|TParseContext
operator|::
name|boolErrorCheck
parameter_list|(
name|int
name|line
parameter_list|,
specifier|const
name|TIntermTyped
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|->
name|getBasicType
argument_list|()
operator|!=
name|EbtBool
operator|||
name|type
operator|->
name|isArray
argument_list|()
operator|||
name|type
operator|->
name|isMatrix
argument_list|()
operator|||
name|type
operator|->
name|isVector
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"boolean expression expected"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|// This function checks to see if the node (for the expression) contains a scalar boolean expression or not
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// returns true in case of an error
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|boolErrorCheck
name|bool
name|TParseContext
operator|::
name|boolErrorCheck
parameter_list|(
name|int
name|line
parameter_list|,
specifier|const
name|TPublicType
modifier|&
name|pType
parameter_list|)
block|{
if|if
condition|(
name|pType
operator|.
name|type
operator|!=
name|EbtBool
operator|||
name|pType
operator|.
name|array
operator|||
name|pType
operator|.
name|matrix
operator|||
operator|(
name|pType
operator|.
name|size
operator|>
literal|1
operator|)
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"boolean expression expected"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|samplerErrorCheck
name|bool
name|TParseContext
operator|::
name|samplerErrorCheck
parameter_list|(
name|int
name|line
parameter_list|,
specifier|const
name|TPublicType
modifier|&
name|pType
parameter_list|,
specifier|const
name|char
modifier|*
name|reason
parameter_list|)
block|{
if|if
condition|(
name|pType
operator|.
name|type
operator|==
name|EbtStruct
condition|)
block|{
if|if
condition|(
name|containsSampler
argument_list|(
operator|*
name|pType
operator|.
name|userDef
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
name|reason
argument_list|,
name|getBasicString
argument_list|(
name|pType
operator|.
name|type
argument_list|)
argument_list|,
literal|"(structure contains a sampler)"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|IsSampler
argument_list|(
name|pType
operator|.
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
name|reason
argument_list|,
name|getBasicString
argument_list|(
name|pType
operator|.
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|structQualifierErrorCheck
name|bool
name|TParseContext
operator|::
name|structQualifierErrorCheck
parameter_list|(
name|int
name|line
parameter_list|,
specifier|const
name|TPublicType
modifier|&
name|pType
parameter_list|)
block|{
if|if
condition|(
operator|(
name|pType
operator|.
name|qualifier
operator|==
name|EvqVaryingIn
operator|||
name|pType
operator|.
name|qualifier
operator|==
name|EvqVaryingOut
operator|||
name|pType
operator|.
name|qualifier
operator|==
name|EvqAttribute
operator|)
operator|&&
name|pType
operator|.
name|type
operator|==
name|EbtStruct
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"cannot be used with a structure"
argument_list|,
name|getQualifierString
argument_list|(
name|pType
operator|.
name|qualifier
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|pType
operator|.
name|qualifier
operator|!=
name|EvqUniform
operator|&&
name|samplerErrorCheck
argument_list|(
name|line
argument_list|,
name|pType
argument_list|,
literal|"samplers must be uniform"
argument_list|)
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|parameterSamplerErrorCheck
name|bool
name|TParseContext
operator|::
name|parameterSamplerErrorCheck
parameter_list|(
name|int
name|line
parameter_list|,
name|TQualifier
name|qualifier
parameter_list|,
specifier|const
name|TType
modifier|&
name|type
parameter_list|)
block|{
if|if
condition|(
operator|(
name|qualifier
operator|==
name|EvqOut
operator|||
name|qualifier
operator|==
name|EvqInOut
operator|)
operator|&&
name|type
operator|.
name|getBasicType
argument_list|()
operator|!=
name|EbtStruct
operator|&&
name|IsSampler
argument_list|(
name|type
operator|.
name|getBasicType
argument_list|()
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"samplers cannot be output parameters"
argument_list|,
name|type
operator|.
name|getBasicString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|containsSampler
name|bool
name|TParseContext
operator|::
name|containsSampler
parameter_list|(
name|TType
modifier|&
name|type
parameter_list|)
block|{
if|if
condition|(
name|IsSampler
argument_list|(
name|type
operator|.
name|getBasicType
argument_list|()
argument_list|)
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|type
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtStruct
condition|)
block|{
name|TTypeList
modifier|&
name|structure
init|=
operator|*
name|type
operator|.
name|getStruct
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|structure
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|containsSampler
argument_list|(
operator|*
name|structure
index|[
name|i
index|]
operator|.
name|type
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Do size checking for an array type's size.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns true if there was an error.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|arraySizeErrorCheck
name|bool
name|TParseContext
operator|::
name|arraySizeErrorCheck
parameter_list|(
name|int
name|line
parameter_list|,
name|TIntermTyped
modifier|*
name|expr
parameter_list|,
name|int
modifier|&
name|size
parameter_list|)
block|{
name|TIntermConstantUnion
modifier|*
name|constant
init|=
name|expr
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
if|if
condition|(
name|constant
operator|==
literal|0
operator|||
name|constant
operator|->
name|getBasicType
argument_list|()
operator|!=
name|EbtInt
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"array size must be a constant integer expression"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|size
operator|=
name|constant
operator|->
name|getUnionArrayPointer
argument_list|()
operator|->
name|getIConst
argument_list|()
expr_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"array size must be a positive integer"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// See if this qualifier can be an array.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns true if there is an error.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|arrayQualifierErrorCheck
name|bool
name|TParseContext
operator|::
name|arrayQualifierErrorCheck
parameter_list|(
name|int
name|line
parameter_list|,
name|TPublicType
name|type
parameter_list|)
block|{
if|if
condition|(
operator|(
name|type
operator|.
name|qualifier
operator|==
name|EvqAttribute
operator|)
operator|||
operator|(
name|type
operator|.
name|qualifier
operator|==
name|EvqConst
operator|)
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"cannot declare arrays of this qualifier"
argument_list|,
name|TType
argument_list|(
name|type
argument_list|)
operator|.
name|getCompleteString
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// See if this type can be an array.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns true if there is an error.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|arrayTypeErrorCheck
name|bool
name|TParseContext
operator|::
name|arrayTypeErrorCheck
parameter_list|(
name|int
name|line
parameter_list|,
name|TPublicType
name|type
parameter_list|)
block|{
comment|//
comment|// Can the type be an array?
comment|//
if|if
condition|(
name|type
operator|.
name|array
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"cannot declare arrays of arrays"
argument_list|,
name|TType
argument_list|(
name|type
argument_list|)
operator|.
name|getCompleteString
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Do all the semantic checking for declaring an array, with and
end_comment
begin_comment
comment|// without a size, and make the right changes to the symbol table.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// size == 0 means no specified size.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns true if there was an error.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|arrayErrorCheck
name|bool
name|TParseContext
operator|::
name|arrayErrorCheck
parameter_list|(
name|int
name|line
parameter_list|,
name|TString
modifier|&
name|identifier
parameter_list|,
name|TPublicType
name|type
parameter_list|,
name|TVariable
modifier|*
modifier|&
name|variable
parameter_list|)
block|{
comment|//
comment|// Don't check for reserved word use until after we know it's not in the symbol table,
comment|// because reserved arrays can be redeclared.
comment|//
name|bool
name|builtIn
init|=
literal|false
decl_stmt|;
name|bool
name|sameScope
init|=
literal|false
decl_stmt|;
name|TSymbol
modifier|*
name|symbol
init|=
name|symbolTable
operator|.
name|find
argument_list|(
name|identifier
argument_list|,
operator|&
name|builtIn
argument_list|,
operator|&
name|sameScope
argument_list|)
decl_stmt|;
if|if
condition|(
name|symbol
operator|==
literal|0
operator|||
operator|!
name|sameScope
condition|)
block|{
if|if
condition|(
name|reservedErrorCheck
argument_list|(
name|line
argument_list|,
name|identifier
argument_list|)
condition|)
return|return
literal|true
return|;
name|variable
operator|=
operator|new
name|TVariable
argument_list|(
operator|&
name|identifier
argument_list|,
name|TType
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|.
name|arraySize
condition|)
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|setArraySize
argument_list|(
name|type
operator|.
name|arraySize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|symbolTable
operator|.
name|insert
argument_list|(
operator|*
name|variable
argument_list|)
condition|)
block|{
operator|delete
name|variable
expr_stmt|;
name|error
argument_list|(
name|line
argument_list|,
literal|"INTERNAL ERROR inserting new symbol"
argument_list|,
name|identifier
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|symbol
operator|->
name|isVariable
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"variable expected"
argument_list|,
name|identifier
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|variable
operator|=
cast|static_cast
argument_list|<
name|TVariable
operator|*
argument_list|>
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|isArray
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"redeclaring non-array as array"
argument_list|,
name|identifier
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|getArraySize
argument_list|()
operator|>
literal|0
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"redeclaration of array with size"
argument_list|,
name|identifier
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|sameElementType
argument_list|(
name|TType
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"redeclaration of array with a different type"
argument_list|,
name|identifier
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|TType
modifier|*
name|t
init|=
name|variable
operator|->
name|getArrayInformationType
argument_list|()
decl_stmt|;
while|while
condition|(
name|t
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|getMaxArraySize
argument_list|()
operator|>
name|type
operator|.
name|arraySize
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"higher index value already used for the array"
argument_list|,
name|identifier
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|t
operator|->
name|setArraySize
argument_list|(
name|type
operator|.
name|arraySize
argument_list|)
expr_stmt|;
name|t
operator|=
name|t
operator|->
name|getArrayInformationType
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|.
name|arraySize
condition|)
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|setArraySize
argument_list|(
name|type
operator|.
name|arraySize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|voidErrorCheck
argument_list|(
name|line
argument_list|,
name|identifier
argument_list|,
name|type
argument_list|)
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|arraySetMaxSize
name|bool
name|TParseContext
operator|::
name|arraySetMaxSize
parameter_list|(
name|TIntermSymbol
modifier|*
name|node
parameter_list|,
name|TType
modifier|*
name|type
parameter_list|,
name|int
name|size
parameter_list|,
name|bool
name|updateFlag
parameter_list|,
name|TSourceLoc
name|line
parameter_list|)
block|{
name|bool
name|builtIn
init|=
literal|false
decl_stmt|;
name|TSymbol
modifier|*
name|symbol
init|=
name|symbolTable
operator|.
name|find
argument_list|(
name|node
operator|->
name|getSymbol
argument_list|()
argument_list|,
operator|&
name|builtIn
argument_list|)
decl_stmt|;
if|if
condition|(
name|symbol
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|" undeclared identifier"
argument_list|,
name|node
operator|->
name|getSymbol
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|TVariable
modifier|*
name|variable
init|=
cast|static_cast
argument_list|<
name|TVariable
operator|*
argument_list|>
argument_list|(
name|symbol
argument_list|)
decl_stmt|;
name|type
operator|->
name|setArrayInformationType
argument_list|(
name|variable
operator|->
name|getArrayInformationType
argument_list|()
argument_list|)
expr_stmt|;
name|variable
operator|->
name|updateArrayInformationType
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|// special casing to test index value of gl_FragData. If the accessed index is>= gl_MaxDrawBuffers
comment|// its an error
if|if
condition|(
name|node
operator|->
name|getSymbol
argument_list|()
operator|==
literal|"gl_FragData"
condition|)
block|{
name|TSymbol
modifier|*
name|fragData
init|=
name|symbolTable
operator|.
name|find
argument_list|(
literal|"gl_MaxDrawBuffers"
argument_list|,
operator|&
name|builtIn
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|fragData
argument_list|)
expr_stmt|;
name|int
name|fragDataValue
init|=
cast|static_cast
argument_list|<
name|TVariable
operator|*
argument_list|>
argument_list|(
name|fragData
argument_list|)
operator|->
name|getConstPointer
argument_list|()
index|[
literal|0
index|]
operator|.
name|getIConst
argument_list|()
decl_stmt|;
if|if
condition|(
name|fragDataValue
operator|<=
name|size
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|""
argument_list|,
literal|"["
argument_list|,
literal|"gl_FragData can only have a max array size of up to gl_MaxDrawBuffers"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
comment|// we dont want to update the maxArraySize when this flag is not set, we just want to include this
comment|// node type in the chain of node types so that its updated when a higher maxArraySize comes in.
if|if
condition|(
operator|!
name|updateFlag
condition|)
return|return
literal|false
return|;
name|size
operator|++
expr_stmt|;
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|setMaxArraySize
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|type
operator|->
name|setMaxArraySize
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|TType
modifier|*
name|tt
init|=
name|type
decl_stmt|;
while|while
condition|(
name|tt
operator|->
name|getArrayInformationType
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|tt
operator|=
name|tt
operator|->
name|getArrayInformationType
argument_list|()
expr_stmt|;
name|tt
operator|->
name|setMaxArraySize
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Enforce non-initializer type/qualifier rules.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns true if there was an error.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|nonInitConstErrorCheck
name|bool
name|TParseContext
operator|::
name|nonInitConstErrorCheck
parameter_list|(
name|int
name|line
parameter_list|,
name|TString
modifier|&
name|identifier
parameter_list|,
name|TPublicType
modifier|&
name|type
parameter_list|,
name|bool
name|array
parameter_list|)
block|{
if|if
condition|(
name|type
operator|.
name|qualifier
operator|==
name|EvqConst
condition|)
block|{
comment|// Make the qualifier make sense.
name|type
operator|.
name|qualifier
operator|=
name|EvqTemporary
expr_stmt|;
if|if
condition|(
name|array
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"arrays may not be declared constant since they cannot be initialized"
argument_list|,
name|identifier
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|isStructureContainingArrays
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"structures containing arrays may not be declared constant since they cannot be initialized"
argument_list|,
name|identifier
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"variables with qualifier 'const' must be initialized"
argument_list|,
name|identifier
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Do semantic checking for a variable declaration that has no initializer,
end_comment
begin_comment
comment|// and update the symbol table.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns true if there was an error.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|nonInitErrorCheck
name|bool
name|TParseContext
operator|::
name|nonInitErrorCheck
parameter_list|(
name|int
name|line
parameter_list|,
name|TString
modifier|&
name|identifier
parameter_list|,
name|TPublicType
modifier|&
name|type
parameter_list|,
name|TVariable
modifier|*
modifier|&
name|variable
parameter_list|)
block|{
if|if
condition|(
name|reservedErrorCheck
argument_list|(
name|line
argument_list|,
name|identifier
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
name|variable
operator|=
operator|new
name|TVariable
argument_list|(
operator|&
name|identifier
argument_list|,
name|TType
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|symbolTable
operator|.
name|insert
argument_list|(
operator|*
name|variable
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"redefinition"
argument_list|,
name|variable
operator|->
name|getName
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
operator|delete
name|variable
expr_stmt|;
name|variable
operator|=
literal|0
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|voidErrorCheck
argument_list|(
name|line
argument_list|,
name|identifier
argument_list|,
name|type
argument_list|)
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|paramErrorCheck
name|bool
name|TParseContext
operator|::
name|paramErrorCheck
parameter_list|(
name|int
name|line
parameter_list|,
name|TQualifier
name|qualifier
parameter_list|,
name|TQualifier
name|paramQualifier
parameter_list|,
name|TType
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
name|qualifier
operator|!=
name|EvqConst
operator|&&
name|qualifier
operator|!=
name|EvqTemporary
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"qualifier not allowed on function parameter"
argument_list|,
name|getQualifierString
argument_list|(
name|qualifier
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|qualifier
operator|==
name|EvqConst
operator|&&
name|paramQualifier
operator|!=
name|EvqIn
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"qualifier not allowed with "
argument_list|,
name|getQualifierString
argument_list|(
name|qualifier
argument_list|)
argument_list|,
name|getQualifierString
argument_list|(
name|paramQualifier
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|qualifier
operator|==
name|EvqConst
condition|)
name|type
operator|->
name|setQualifier
argument_list|(
name|EvqConstReadOnly
argument_list|)
expr_stmt|;
else|else
name|type
operator|->
name|setQualifier
argument_list|(
name|paramQualifier
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|extensionErrorCheck
name|bool
name|TParseContext
operator|::
name|extensionErrorCheck
parameter_list|(
name|int
name|line
parameter_list|,
specifier|const
name|TString
modifier|&
name|extension
parameter_list|)
block|{
specifier|const
name|TExtensionBehavior
modifier|&
name|extBehavior
init|=
name|extensionBehavior
argument_list|()
decl_stmt|;
name|TExtensionBehavior
operator|::
name|const_iterator
name|iter
init|=
name|extBehavior
operator|.
name|find
argument_list|(
name|extension
operator|.
name|c_str
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|iter
operator|==
name|extBehavior
operator|.
name|end
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"extension"
argument_list|,
name|extension
operator|.
name|c_str
argument_list|()
argument_list|,
literal|"is not supported"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// In GLSL ES, an extension's default behavior is "disable".
if|if
condition|(
name|iter
operator|->
name|second
operator|==
name|EBhDisable
operator|||
name|iter
operator|->
name|second
operator|==
name|EBhUndefined
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"extension"
argument_list|,
name|extension
operator|.
name|c_str
argument_list|()
argument_list|,
literal|"is disabled"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|iter
operator|->
name|second
operator|==
name|EBhWarn
condition|)
block|{
name|warning
argument_list|(
name|line
argument_list|,
literal|"extension"
argument_list|,
name|extension
operator|.
name|c_str
argument_list|()
argument_list|,
literal|"is being used"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|supportsExtension
name|bool
name|TParseContext
operator|::
name|supportsExtension
parameter_list|(
specifier|const
name|char
modifier|*
name|extension
parameter_list|)
block|{
specifier|const
name|TExtensionBehavior
modifier|&
name|extbehavior
init|=
name|extensionBehavior
argument_list|()
decl_stmt|;
name|TExtensionBehavior
operator|::
name|const_iterator
name|iter
init|=
name|extbehavior
operator|.
name|find
argument_list|(
name|extension
argument_list|)
decl_stmt|;
return|return
operator|(
name|iter
operator|!=
name|extbehavior
operator|.
name|end
argument_list|()
operator|)
return|;
block|}
end_function
begin_function
DECL|function|handleExtensionDirective
name|void
name|TParseContext
operator|::
name|handleExtensionDirective
parameter_list|(
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|extName
parameter_list|,
specifier|const
name|char
modifier|*
name|behavior
parameter_list|)
block|{
name|pp
operator|::
name|SourceLocation
name|loc
decl_stmt|;
name|DecodeSourceLoc
argument_list|(
name|line
argument_list|,
operator|&
name|loc
operator|.
name|file
argument_list|,
operator|&
name|loc
operator|.
name|line
argument_list|)
expr_stmt|;
name|directiveHandler
operator|.
name|handleExtension
argument_list|(
name|loc
argument_list|,
name|extName
argument_list|,
name|behavior
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|handlePragmaDirective
name|void
name|TParseContext
operator|::
name|handlePragmaDirective
parameter_list|(
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|pp
operator|::
name|SourceLocation
name|loc
decl_stmt|;
name|DecodeSourceLoc
argument_list|(
name|line
argument_list|,
operator|&
name|loc
operator|.
name|file
argument_list|,
operator|&
name|loc
operator|.
name|line
argument_list|)
expr_stmt|;
name|directiveHandler
operator|.
name|handlePragma
argument_list|(
name|loc
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/////////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Non-Errors.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|/////////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Look up a function name in the symbol table, and make sure it is a function.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Return the function symbol if found, otherwise 0.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|findFunction
specifier|const
name|TFunction
modifier|*
name|TParseContext
operator|::
name|findFunction
parameter_list|(
name|int
name|line
parameter_list|,
name|TFunction
modifier|*
name|call
parameter_list|,
name|bool
modifier|*
name|builtIn
parameter_list|)
block|{
comment|// First find by unmangled name to check whether the function name has been
comment|// hidden by a variable name or struct typename.
specifier|const
name|TSymbol
modifier|*
name|symbol
init|=
name|symbolTable
operator|.
name|find
argument_list|(
name|call
operator|->
name|getName
argument_list|()
argument_list|,
name|builtIn
argument_list|)
decl_stmt|;
if|if
condition|(
name|symbol
operator|==
literal|0
condition|)
block|{
name|symbol
operator|=
name|symbolTable
operator|.
name|find
argument_list|(
name|call
operator|->
name|getMangledName
argument_list|()
argument_list|,
name|builtIn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|symbol
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"no matching overloaded function found"
argument_list|,
name|call
operator|->
name|getName
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|symbol
operator|->
name|isFunction
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"function name expected"
argument_list|,
name|call
operator|->
name|getName
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
cast|static_cast
argument_list|<
specifier|const
name|TFunction
operator|*
argument_list|>
argument_list|(
name|symbol
argument_list|)
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Initializers show up in several places in the grammar.  Have one set of
end_comment
begin_comment
comment|// code to handle them here.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|executeInitializer
name|bool
name|TParseContext
operator|::
name|executeInitializer
parameter_list|(
name|TSourceLoc
name|line
parameter_list|,
name|TString
modifier|&
name|identifier
parameter_list|,
name|TPublicType
modifier|&
name|pType
parameter_list|,
name|TIntermTyped
modifier|*
name|initializer
parameter_list|,
name|TIntermNode
modifier|*
modifier|&
name|intermNode
parameter_list|,
name|TVariable
modifier|*
name|variable
parameter_list|)
block|{
name|TType
name|type
init|=
name|TType
argument_list|(
name|pType
argument_list|)
decl_stmt|;
if|if
condition|(
name|variable
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reservedErrorCheck
argument_list|(
name|line
argument_list|,
name|identifier
argument_list|)
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|voidErrorCheck
argument_list|(
name|line
argument_list|,
name|identifier
argument_list|,
name|pType
argument_list|)
condition|)
return|return
literal|true
return|;
comment|//
comment|// add variable to symbol table
comment|//
name|variable
operator|=
operator|new
name|TVariable
argument_list|(
operator|&
name|identifier
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|symbolTable
operator|.
name|insert
argument_list|(
operator|*
name|variable
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"redefinition"
argument_list|,
name|variable
operator|->
name|getName
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
comment|// don't delete variable, it's used by error recovery, and the pool
comment|// pop will take care of the memory
block|}
block|}
comment|//
comment|// identifier must be of type constant, a global, or a temporary
comment|//
name|TQualifier
name|qualifier
init|=
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|getQualifier
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|qualifier
operator|!=
name|EvqTemporary
operator|)
operator|&&
operator|(
name|qualifier
operator|!=
name|EvqGlobal
operator|)
operator|&&
operator|(
name|qualifier
operator|!=
name|EvqConst
operator|)
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|" cannot initialize this type of qualifier "
argument_list|,
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|getQualifierString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|//
comment|// test for and propagate constant
comment|//
if|if
condition|(
name|qualifier
operator|==
name|EvqConst
condition|)
block|{
if|if
condition|(
name|qualifier
operator|!=
name|initializer
operator|->
name|getType
argument_list|()
operator|.
name|getQualifier
argument_list|()
condition|)
block|{
name|std
operator|::
name|stringstream
name|extraInfoStream
decl_stmt|;
name|extraInfoStream
operator|<<
literal|"'"
operator|<<
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|getCompleteString
argument_list|()
operator|<<
literal|"'"
expr_stmt|;
name|std
operator|::
name|string
name|extraInfo
init|=
name|extraInfoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|error
argument_list|(
name|line
argument_list|,
literal|" assigning non-constant to"
argument_list|,
literal|"="
argument_list|,
name|extraInfo
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|setQualifier
argument_list|(
name|EvqTemporary
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|type
operator|!=
name|initializer
operator|->
name|getType
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|" non-matching types for const initializer "
argument_list|,
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|getQualifierString
argument_list|()
argument_list|)
expr_stmt|;
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|setQualifier
argument_list|(
name|EvqTemporary
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|initializer
operator|->
name|getAsConstantUnion
argument_list|()
condition|)
block|{
name|ConstantUnion
modifier|*
name|unionArray
init|=
name|variable
operator|->
name|getConstPointer
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|getObjectSize
argument_list|()
operator|==
literal|1
operator|&&
name|type
operator|.
name|getBasicType
argument_list|()
operator|!=
name|EbtStruct
condition|)
block|{
operator|*
name|unionArray
operator|=
operator|(
name|initializer
operator|->
name|getAsConstantUnion
argument_list|()
operator|->
name|getUnionArrayPointer
argument_list|()
operator|)
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|variable
operator|->
name|shareConstPointer
argument_list|(
name|initializer
operator|->
name|getAsConstantUnion
argument_list|()
operator|->
name|getUnionArrayPointer
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|initializer
operator|->
name|getAsSymbolNode
argument_list|()
condition|)
block|{
specifier|const
name|TSymbol
modifier|*
name|symbol
init|=
name|symbolTable
operator|.
name|find
argument_list|(
name|initializer
operator|->
name|getAsSymbolNode
argument_list|()
operator|->
name|getSymbol
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|TVariable
modifier|*
name|tVar
init|=
cast|static_cast
argument_list|<
specifier|const
name|TVariable
operator|*
argument_list|>
argument_list|(
name|symbol
argument_list|)
decl_stmt|;
name|ConstantUnion
modifier|*
name|constArray
init|=
name|tVar
operator|->
name|getConstPointer
argument_list|()
decl_stmt|;
name|variable
operator|->
name|shareConstPointer
argument_list|(
name|constArray
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|std
operator|::
name|stringstream
name|extraInfoStream
decl_stmt|;
name|extraInfoStream
operator|<<
literal|"'"
operator|<<
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|getCompleteString
argument_list|()
operator|<<
literal|"'"
expr_stmt|;
name|std
operator|::
name|string
name|extraInfo
init|=
name|extraInfoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|error
argument_list|(
name|line
argument_list|,
literal|" cannot assign to"
argument_list|,
literal|"="
argument_list|,
name|extraInfo
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|setQualifier
argument_list|(
name|EvqTemporary
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
if|if
condition|(
name|qualifier
operator|!=
name|EvqConst
condition|)
block|{
name|TIntermSymbol
modifier|*
name|intermSymbol
init|=
name|intermediate
operator|.
name|addSymbol
argument_list|(
name|variable
operator|->
name|getUniqueId
argument_list|()
argument_list|,
name|variable
operator|->
name|getName
argument_list|()
argument_list|,
name|variable
operator|->
name|getType
argument_list|()
argument_list|,
name|line
argument_list|)
decl_stmt|;
name|intermNode
operator|=
name|intermediate
operator|.
name|addAssign
argument_list|(
name|EOpInitialize
argument_list|,
name|intermSymbol
argument_list|,
name|initializer
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|intermNode
operator|==
literal|0
condition|)
block|{
name|assignError
argument_list|(
name|line
argument_list|,
literal|"="
argument_list|,
name|intermSymbol
operator|->
name|getCompleteString
argument_list|()
argument_list|,
name|initializer
operator|->
name|getCompleteString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
else|else
name|intermNode
operator|=
literal|0
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|areAllChildConst
name|bool
name|TParseContext
operator|::
name|areAllChildConst
parameter_list|(
name|TIntermAggregate
modifier|*
name|aggrNode
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|aggrNode
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aggrNode
operator|->
name|isConstructor
argument_list|()
condition|)
return|return
literal|false
return|;
name|bool
name|allConstant
init|=
literal|true
decl_stmt|;
comment|// check if all the child nodes are constants so that they can be inserted into
comment|// the parent node
name|TIntermSequence
modifier|&
name|sequence
init|=
name|aggrNode
operator|->
name|getSequence
argument_list|()
decl_stmt|;
for|for
control|(
name|TIntermSequence
operator|::
name|iterator
name|p
init|=
name|sequence
operator|.
name|begin
argument_list|()
init|;
name|p
operator|!=
name|sequence
operator|.
name|end
argument_list|()
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|p
operator|)
operator|->
name|getAsTyped
argument_list|()
operator|->
name|getAsConstantUnion
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
return|return
name|allConstant
return|;
block|}
end_function
begin_comment
comment|// This function is used to test for the correctness of the parameters passed to various constructor functions
end_comment
begin_comment
comment|// and also convert them to the right datatype if it is allowed and required.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns 0 for an error or the constructed node (aggregate or typed) for no error.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addConstructor
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|addConstructor
parameter_list|(
name|TIntermNode
modifier|*
name|node
parameter_list|,
specifier|const
name|TType
modifier|*
name|type
parameter_list|,
name|TOperator
name|op
parameter_list|,
name|TFunction
modifier|*
name|fnCall
parameter_list|,
name|TSourceLoc
name|line
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|TIntermAggregate
modifier|*
name|aggrNode
init|=
name|node
operator|->
name|getAsAggregate
argument_list|()
decl_stmt|;
name|TTypeList
operator|::
name|const_iterator
name|memberTypes
decl_stmt|;
if|if
condition|(
name|op
operator|==
name|EOpConstructStruct
condition|)
name|memberTypes
operator|=
name|type
operator|->
name|getStruct
argument_list|()
operator|->
name|begin
argument_list|()
expr_stmt|;
name|TType
name|elementType
init|=
operator|*
name|type
decl_stmt|;
if|if
condition|(
name|type
operator|->
name|isArray
argument_list|()
condition|)
name|elementType
operator|.
name|clearArrayness
argument_list|()
expr_stmt|;
name|bool
name|singleArg
decl_stmt|;
if|if
condition|(
name|aggrNode
condition|)
block|{
if|if
condition|(
name|aggrNode
operator|->
name|getOp
argument_list|()
operator|!=
name|EOpNull
operator|||
name|aggrNode
operator|->
name|getSequence
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
name|singleArg
operator|=
literal|true
expr_stmt|;
else|else
name|singleArg
operator|=
literal|false
expr_stmt|;
block|}
else|else
name|singleArg
operator|=
literal|true
expr_stmt|;
name|TIntermTyped
modifier|*
name|newNode
decl_stmt|;
if|if
condition|(
name|singleArg
condition|)
block|{
comment|// If structure constructor or array constructor is being called
comment|// for only one parameter inside the structure, we need to call constructStruct function once.
if|if
condition|(
name|type
operator|->
name|isArray
argument_list|()
condition|)
name|newNode
operator|=
name|constructStruct
argument_list|(
name|node
argument_list|,
operator|&
name|elementType
argument_list|,
literal|1
argument_list|,
name|node
operator|->
name|getLine
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|==
name|EOpConstructStruct
condition|)
name|newNode
operator|=
name|constructStruct
argument_list|(
name|node
argument_list|,
operator|(
operator|*
name|memberTypes
operator|)
operator|.
name|type
argument_list|,
literal|1
argument_list|,
name|node
operator|->
name|getLine
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
else|else
name|newNode
operator|=
name|constructBuiltIn
argument_list|(
name|type
argument_list|,
name|op
argument_list|,
name|node
argument_list|,
name|node
operator|->
name|getLine
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|newNode
operator|&&
name|newNode
operator|->
name|getAsAggregate
argument_list|()
condition|)
block|{
name|TIntermTyped
modifier|*
name|constConstructor
init|=
name|foldConstConstructor
argument_list|(
name|newNode
operator|->
name|getAsAggregate
argument_list|()
argument_list|,
operator|*
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|constConstructor
condition|)
return|return
name|constConstructor
return|;
block|}
return|return
name|newNode
return|;
block|}
comment|//
comment|// Handle list of arguments.
comment|//
name|TIntermSequence
modifier|&
name|sequenceVector
init|=
name|aggrNode
operator|->
name|getSequence
argument_list|()
decl_stmt|;
comment|// Stores the information about the parameter to the constructor
comment|// if the structure constructor contains more than one parameter, then construct
comment|// each parameter
name|int
name|paramCount
init|=
literal|0
decl_stmt|;
comment|// keeps a track of the constructor parameter number being checked
comment|// for each parameter to the constructor call, check to see if the right type is passed or convert them
comment|// to the right type if possible (and allowed).
comment|// for structure constructors, just check if the right type is passed, no conversion is allowed.
for|for
control|(
name|TIntermSequence
operator|::
name|iterator
name|p
init|=
name|sequenceVector
operator|.
name|begin
argument_list|()
init|;
name|p
operator|!=
name|sequenceVector
operator|.
name|end
argument_list|()
condition|;
name|p
operator|++
operator|,
name|paramCount
operator|++
control|)
block|{
if|if
condition|(
name|type
operator|->
name|isArray
argument_list|()
condition|)
name|newNode
operator|=
name|constructStruct
argument_list|(
operator|*
name|p
argument_list|,
operator|&
name|elementType
argument_list|,
name|paramCount
operator|+
literal|1
argument_list|,
name|node
operator|->
name|getLine
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|==
name|EOpConstructStruct
condition|)
name|newNode
operator|=
name|constructStruct
argument_list|(
operator|*
name|p
argument_list|,
operator|(
name|memberTypes
index|[
name|paramCount
index|]
operator|)
operator|.
name|type
argument_list|,
name|paramCount
operator|+
literal|1
argument_list|,
name|node
operator|->
name|getLine
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
else|else
name|newNode
operator|=
name|constructBuiltIn
argument_list|(
name|type
argument_list|,
name|op
argument_list|,
operator|*
name|p
argument_list|,
name|node
operator|->
name|getLine
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|newNode
condition|)
block|{
operator|*
name|p
operator|=
name|newNode
expr_stmt|;
block|}
block|}
name|TIntermTyped
modifier|*
name|constructor
init|=
name|intermediate
operator|.
name|setAggregateOperator
argument_list|(
name|aggrNode
argument_list|,
name|op
argument_list|,
name|line
argument_list|)
decl_stmt|;
name|TIntermTyped
modifier|*
name|constConstructor
init|=
name|foldConstConstructor
argument_list|(
name|constructor
operator|->
name|getAsAggregate
argument_list|()
argument_list|,
operator|*
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|constConstructor
condition|)
return|return
name|constConstructor
return|;
return|return
name|constructor
return|;
block|}
end_function
begin_function
DECL|function|foldConstConstructor
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|foldConstConstructor
parameter_list|(
name|TIntermAggregate
modifier|*
name|aggrNode
parameter_list|,
specifier|const
name|TType
modifier|&
name|type
parameter_list|)
block|{
name|bool
name|canBeFolded
init|=
name|areAllChildConst
argument_list|(
name|aggrNode
argument_list|)
decl_stmt|;
name|aggrNode
operator|->
name|setType
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|canBeFolded
condition|)
block|{
name|bool
name|returnVal
init|=
literal|false
decl_stmt|;
name|ConstantUnion
modifier|*
name|unionArray
init|=
operator|new
name|ConstantUnion
index|[
name|type
operator|.
name|getObjectSize
argument_list|()
index|]
decl_stmt|;
if|if
condition|(
name|aggrNode
operator|->
name|getSequence
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|returnVal
operator|=
name|intermediate
operator|.
name|parseConstTree
argument_list|(
name|aggrNode
operator|->
name|getLine
argument_list|()
argument_list|,
name|aggrNode
argument_list|,
name|unionArray
argument_list|,
name|aggrNode
operator|->
name|getOp
argument_list|()
argument_list|,
name|symbolTable
argument_list|,
name|type
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|returnVal
operator|=
name|intermediate
operator|.
name|parseConstTree
argument_list|(
name|aggrNode
operator|->
name|getLine
argument_list|()
argument_list|,
name|aggrNode
argument_list|,
name|unionArray
argument_list|,
name|aggrNode
operator|->
name|getOp
argument_list|()
argument_list|,
name|symbolTable
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|returnVal
condition|)
return|return
literal|0
return|;
return|return
name|intermediate
operator|.
name|addConstantUnion
argument_list|(
name|unionArray
argument_list|,
name|type
argument_list|,
name|aggrNode
operator|->
name|getLine
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|// Function for constructor implementation. Calls addUnaryMath with appropriate EOp value
end_comment
begin_comment
comment|// for the parameter to the constructor (passed to this function). Essentially, it converts
end_comment
begin_comment
comment|// the parameter types correctly. If a constructor expects an int (like ivec2) and is passed a
end_comment
begin_comment
comment|// float, then float is converted to int.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns 0 for an error or the constructed node.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|constructBuiltIn
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|constructBuiltIn
parameter_list|(
specifier|const
name|TType
modifier|*
name|type
parameter_list|,
name|TOperator
name|op
parameter_list|,
name|TIntermNode
modifier|*
name|node
parameter_list|,
name|TSourceLoc
name|line
parameter_list|,
name|bool
name|subset
parameter_list|)
block|{
name|TIntermTyped
modifier|*
name|newNode
decl_stmt|;
name|TOperator
name|basicOp
decl_stmt|;
comment|//
comment|// First, convert types as needed.
comment|//
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|EOpConstructVec2
case|:
case|case
name|EOpConstructVec3
case|:
case|case
name|EOpConstructVec4
case|:
case|case
name|EOpConstructMat2
case|:
case|case
name|EOpConstructMat3
case|:
case|case
name|EOpConstructMat4
case|:
case|case
name|EOpConstructFloat
case|:
name|basicOp
operator|=
name|EOpConstructFloat
expr_stmt|;
break|break;
case|case
name|EOpConstructIVec2
case|:
case|case
name|EOpConstructIVec3
case|:
case|case
name|EOpConstructIVec4
case|:
case|case
name|EOpConstructInt
case|:
name|basicOp
operator|=
name|EOpConstructInt
expr_stmt|;
break|break;
case|case
name|EOpConstructBVec2
case|:
case|case
name|EOpConstructBVec3
case|:
case|case
name|EOpConstructBVec4
case|:
case|case
name|EOpConstructBool
case|:
name|basicOp
operator|=
name|EOpConstructBool
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
name|line
argument_list|,
literal|"unsupported construction"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
name|newNode
operator|=
name|intermediate
operator|.
name|addUnaryMath
argument_list|(
name|basicOp
argument_list|,
name|node
argument_list|,
name|node
operator|->
name|getLine
argument_list|()
argument_list|,
name|symbolTable
argument_list|)
expr_stmt|;
if|if
condition|(
name|newNode
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"can't convert"
argument_list|,
literal|"constructor"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|//
comment|// Now, if there still isn't an operation to do the construction, and we need one, add one.
comment|//
comment|// Otherwise, skip out early.
if|if
condition|(
name|subset
operator|||
operator|(
name|newNode
operator|!=
name|node
operator|&&
name|newNode
operator|->
name|getType
argument_list|()
operator|==
operator|*
name|type
operator|)
condition|)
return|return
name|newNode
return|;
comment|// setAggregateOperator will insert a new node for the constructor, as needed.
return|return
name|intermediate
operator|.
name|setAggregateOperator
argument_list|(
name|newNode
argument_list|,
name|op
argument_list|,
name|line
argument_list|)
return|;
block|}
end_function
begin_comment
comment|// This function tests for the type of the parameters to the structures constructors. Raises
end_comment
begin_comment
comment|// an error message if the expected type does not match the parameter passed to the constructor.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns 0 for an error or the input node itself if the expected and the given parameter types match.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|constructStruct
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|constructStruct
parameter_list|(
name|TIntermNode
modifier|*
name|node
parameter_list|,
name|TType
modifier|*
name|type
parameter_list|,
name|int
name|paramCount
parameter_list|,
name|TSourceLoc
name|line
parameter_list|,
name|bool
name|subset
parameter_list|)
block|{
if|if
condition|(
operator|*
name|type
operator|==
name|node
operator|->
name|getAsTyped
argument_list|()
operator|->
name|getType
argument_list|()
condition|)
block|{
if|if
condition|(
name|subset
condition|)
return|return
name|node
operator|->
name|getAsTyped
argument_list|()
return|;
else|else
return|return
name|intermediate
operator|.
name|setAggregateOperator
argument_list|(
name|node
operator|->
name|getAsTyped
argument_list|()
argument_list|,
name|EOpConstructStruct
argument_list|,
name|line
argument_list|)
return|;
block|}
else|else
block|{
name|std
operator|::
name|stringstream
name|extraInfoStream
decl_stmt|;
name|extraInfoStream
operator|<<
literal|"cannot convert parameter "
operator|<<
name|paramCount
operator|<<
literal|" from '"
operator|<<
name|node
operator|->
name|getAsTyped
argument_list|()
operator|->
name|getType
argument_list|()
operator|.
name|getBasicString
argument_list|()
operator|<<
literal|"' to '"
operator|<<
name|type
operator|->
name|getBasicString
argument_list|()
operator|<<
literal|"'"
expr_stmt|;
name|std
operator|::
name|string
name|extraInfo
init|=
name|extraInfoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|error
argument_list|(
name|line
argument_list|,
literal|""
argument_list|,
literal|"constructor"
argument_list|,
name|extraInfo
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// This function returns the tree representation for the vector field(s) being accessed from contant vector.
end_comment
begin_comment
comment|// If only one component of vector is accessed (v.x or v[0] where v is a contant vector), then a contant node is
end_comment
begin_comment
comment|// returned, else an aggregate node is returned (for v.xy). The input to this function could either be the symbol
end_comment
begin_comment
comment|// node or it could be the intermediate tree representation of accessing fields in a constant structure or column of
end_comment
begin_comment
comment|// a constant matrix.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addConstVectorNode
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|addConstVectorNode
parameter_list|(
name|TVectorFields
modifier|&
name|fields
parameter_list|,
name|TIntermTyped
modifier|*
name|node
parameter_list|,
name|TSourceLoc
name|line
parameter_list|)
block|{
name|TIntermTyped
modifier|*
name|typedNode
decl_stmt|;
name|TIntermConstantUnion
modifier|*
name|tempConstantNode
init|=
name|node
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
name|ConstantUnion
modifier|*
name|unionArray
decl_stmt|;
if|if
condition|(
name|tempConstantNode
condition|)
block|{
name|unionArray
operator|=
name|tempConstantNode
operator|->
name|getUnionArrayPointer
argument_list|()
expr_stmt|;
name|ASSERT
argument_list|(
name|unionArray
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unionArray
condition|)
block|{
return|return
name|node
return|;
block|}
block|}
else|else
block|{
comment|// The node has to be either a symbol node or an aggregate node or a tempConstant node, else, its an error
name|error
argument_list|(
name|line
argument_list|,
literal|"Cannot offset into the vector"
argument_list|,
literal|"Error"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ConstantUnion
modifier|*
name|constArray
init|=
operator|new
name|ConstantUnion
index|[
name|fields
operator|.
name|num
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|>=
name|node
operator|->
name|getType
argument_list|()
operator|.
name|getObjectSize
argument_list|()
condition|)
block|{
name|std
operator|::
name|stringstream
name|extraInfoStream
decl_stmt|;
name|extraInfoStream
operator|<<
literal|"vector field selection out of range '"
operator|<<
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|<<
literal|"'"
expr_stmt|;
name|std
operator|::
name|string
name|extraInfo
init|=
name|extraInfoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|error
argument_list|(
name|line
argument_list|,
literal|""
argument_list|,
literal|"["
argument_list|,
name|extraInfo
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|constArray
index|[
name|i
index|]
operator|=
name|unionArray
index|[
name|fields
operator|.
name|offsets
index|[
name|i
index|]
index|]
expr_stmt|;
block|}
name|typedNode
operator|=
name|intermediate
operator|.
name|addConstantUnion
argument_list|(
name|constArray
argument_list|,
name|node
operator|->
name|getType
argument_list|()
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
name|typedNode
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// This function returns the column being accessed from a constant matrix. The values are retrieved from
end_comment
begin_comment
comment|// the symbol table and parse-tree is built for a vector (each column of a matrix is a vector). The input
end_comment
begin_comment
comment|// to the function could either be a symbol node (m[0] where m is a constant matrix)that represents a
end_comment
begin_comment
comment|// constant matrix or it could be the tree representation of the constant matrix (s.m1[0] where s is a constant structure)
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addConstMatrixNode
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|addConstMatrixNode
parameter_list|(
name|int
name|index
parameter_list|,
name|TIntermTyped
modifier|*
name|node
parameter_list|,
name|TSourceLoc
name|line
parameter_list|)
block|{
name|TIntermTyped
modifier|*
name|typedNode
decl_stmt|;
name|TIntermConstantUnion
modifier|*
name|tempConstantNode
init|=
name|node
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
if|if
condition|(
name|index
operator|>=
name|node
operator|->
name|getType
argument_list|()
operator|.
name|getNominalSize
argument_list|()
condition|)
block|{
name|std
operator|::
name|stringstream
name|extraInfoStream
decl_stmt|;
name|extraInfoStream
operator|<<
literal|"matrix field selection out of range '"
operator|<<
name|index
operator|<<
literal|"'"
expr_stmt|;
name|std
operator|::
name|string
name|extraInfo
init|=
name|extraInfoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|error
argument_list|(
name|line
argument_list|,
literal|""
argument_list|,
literal|"["
argument_list|,
name|extraInfo
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tempConstantNode
condition|)
block|{
name|ConstantUnion
modifier|*
name|unionArray
init|=
name|tempConstantNode
operator|->
name|getUnionArrayPointer
argument_list|()
decl_stmt|;
name|int
name|size
init|=
name|tempConstantNode
operator|->
name|getType
argument_list|()
operator|.
name|getNominalSize
argument_list|()
decl_stmt|;
name|typedNode
operator|=
name|intermediate
operator|.
name|addConstantUnion
argument_list|(
operator|&
name|unionArray
index|[
name|size
operator|*
name|index
index|]
argument_list|,
name|tempConstantNode
operator|->
name|getType
argument_list|()
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"Cannot offset into the matrix"
argument_list|,
literal|"Error"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|typedNode
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// This function returns an element of an array accessed from a constant array. The values are retrieved from
end_comment
begin_comment
comment|// the symbol table and parse-tree is built for the type of the element. The input
end_comment
begin_comment
comment|// to the function could either be a symbol node (a[0] where a is a constant array)that represents a
end_comment
begin_comment
comment|// constant array or it could be the tree representation of the constant array (s.a1[0] where s is a constant structure)
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addConstArrayNode
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|addConstArrayNode
parameter_list|(
name|int
name|index
parameter_list|,
name|TIntermTyped
modifier|*
name|node
parameter_list|,
name|TSourceLoc
name|line
parameter_list|)
block|{
name|TIntermTyped
modifier|*
name|typedNode
decl_stmt|;
name|TIntermConstantUnion
modifier|*
name|tempConstantNode
init|=
name|node
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
name|TType
name|arrayElementType
init|=
name|node
operator|->
name|getType
argument_list|()
decl_stmt|;
name|arrayElementType
operator|.
name|clearArrayness
argument_list|()
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|node
operator|->
name|getType
argument_list|()
operator|.
name|getArraySize
argument_list|()
condition|)
block|{
name|std
operator|::
name|stringstream
name|extraInfoStream
decl_stmt|;
name|extraInfoStream
operator|<<
literal|"array field selection out of range '"
operator|<<
name|index
operator|<<
literal|"'"
expr_stmt|;
name|std
operator|::
name|string
name|extraInfo
init|=
name|extraInfoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|error
argument_list|(
name|line
argument_list|,
literal|""
argument_list|,
literal|"["
argument_list|,
name|extraInfo
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
block|}
name|int
name|arrayElementSize
init|=
name|arrayElementType
operator|.
name|getObjectSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|tempConstantNode
condition|)
block|{
name|ConstantUnion
modifier|*
name|unionArray
init|=
name|tempConstantNode
operator|->
name|getUnionArrayPointer
argument_list|()
decl_stmt|;
name|typedNode
operator|=
name|intermediate
operator|.
name|addConstantUnion
argument_list|(
operator|&
name|unionArray
index|[
name|arrayElementSize
operator|*
name|index
index|]
argument_list|,
name|tempConstantNode
operator|->
name|getType
argument_list|()
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"Cannot offset into the array"
argument_list|,
literal|"Error"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|typedNode
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// This function returns the value of a particular field inside a constant structure from the symbol table.
end_comment
begin_comment
comment|// If there is an embedded/nested struct, it appropriately calls addConstStructNested or addConstStructFromAggr
end_comment
begin_comment
comment|// function and returns the parse-tree with the values of the embedded/nested struct.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addConstStruct
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|addConstStruct
parameter_list|(
name|TString
modifier|&
name|identifier
parameter_list|,
name|TIntermTyped
modifier|*
name|node
parameter_list|,
name|TSourceLoc
name|line
parameter_list|)
block|{
specifier|const
name|TTypeList
modifier|*
name|fields
init|=
name|node
operator|->
name|getType
argument_list|()
operator|.
name|getStruct
argument_list|()
decl_stmt|;
name|TIntermTyped
modifier|*
name|typedNode
decl_stmt|;
name|int
name|instanceSize
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|index
init|=
literal|0
decl_stmt|;
name|TIntermConstantUnion
modifier|*
name|tempConstantNode
init|=
name|node
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|fields
operator|->
name|size
argument_list|()
condition|;
operator|++
name|index
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|fields
operator|)
index|[
name|index
index|]
operator|.
name|type
operator|->
name|getFieldName
argument_list|()
operator|==
name|identifier
condition|)
block|{
break|break;
block|}
else|else
block|{
name|instanceSize
operator|+=
operator|(
operator|*
name|fields
operator|)
index|[
name|index
index|]
operator|.
name|type
operator|->
name|getObjectSize
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tempConstantNode
condition|)
block|{
name|ConstantUnion
modifier|*
name|constArray
init|=
name|tempConstantNode
operator|->
name|getUnionArrayPointer
argument_list|()
decl_stmt|;
name|typedNode
operator|=
name|intermediate
operator|.
name|addConstantUnion
argument_list|(
name|constArray
operator|+
name|instanceSize
argument_list|,
name|tempConstantNode
operator|->
name|getType
argument_list|()
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|// type will be changed in the calling function
block|}
else|else
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"Cannot offset into the structure"
argument_list|,
literal|"Error"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|typedNode
return|;
block|}
end_function
begin_function
DECL|function|enterStructDeclaration
name|bool
name|TParseContext
operator|::
name|enterStructDeclaration
parameter_list|(
name|int
name|line
parameter_list|,
specifier|const
name|TString
modifier|&
name|identifier
parameter_list|)
block|{
operator|++
name|structNestingLevel
expr_stmt|;
comment|// Embedded structure definitions are not supported per GLSL ES spec.
comment|// They aren't allowed in GLSL either, but we need to detect this here
comment|// so we don't rely on the GLSL compiler to catch it.
if|if
condition|(
name|structNestingLevel
operator|>
literal|1
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|""
argument_list|,
literal|"Embedded struct definitions are not allowed"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|exitStructDeclaration
name|void
name|TParseContext
operator|::
name|exitStructDeclaration
parameter_list|()
block|{
operator|--
name|structNestingLevel
expr_stmt|;
block|}
end_function
begin_namespace
namespace|namespace
block|{
DECL|member|kWebGLMaxStructNesting
specifier|const
name|int
name|kWebGLMaxStructNesting
init|=
literal|4
decl_stmt|;
block|}
end_namespace
begin_comment
comment|// namespace
end_comment
begin_function
DECL|function|structNestingErrorCheck
name|bool
name|TParseContext
operator|::
name|structNestingErrorCheck
parameter_list|(
name|TSourceLoc
name|line
parameter_list|,
specifier|const
name|TType
modifier|&
name|fieldType
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isWebGLBasedSpec
argument_list|(
name|shaderSpec
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|fieldType
operator|.
name|getBasicType
argument_list|()
operator|!=
name|EbtStruct
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// We're already inside a structure definition at this point, so add
comment|// one to the field's struct nesting.
if|if
condition|(
literal|1
operator|+
name|fieldType
operator|.
name|getDeepestStructNesting
argument_list|()
operator|>
name|kWebGLMaxStructNesting
condition|)
block|{
name|std
operator|::
name|stringstream
name|extraInfoStream
decl_stmt|;
name|extraInfoStream
operator|<<
literal|"Reference of struct type "
operator|<<
name|fieldType
operator|.
name|getTypeName
argument_list|()
operator|<<
literal|" exceeds maximum struct nesting of "
operator|<<
name|kWebGLMaxStructNesting
expr_stmt|;
name|std
operator|::
name|string
name|extraInfo
init|=
name|extraInfoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|error
argument_list|(
name|line
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|extraInfo
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Parse an array of strings using yyparse.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns 0 for success.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|PaParseStrings
name|int
name|PaParseStrings
parameter_list|(
name|int
name|count
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
name|string
index|[]
parameter_list|,
specifier|const
name|int
name|length
index|[]
parameter_list|,
name|TParseContext
modifier|*
name|context
parameter_list|)
block|{
if|if
condition|(
operator|(
name|count
operator|==
literal|0
operator|)
operator|||
operator|(
name|string
operator|==
name|NULL
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|glslang_initialize
argument_list|(
name|context
argument_list|)
condition|)
return|return
literal|1
return|;
name|int
name|error
init|=
name|glslang_scan
argument_list|(
name|count
argument_list|,
name|string
argument_list|,
name|length
argument_list|,
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|glslang_parse
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|glslang_finalize
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|==
literal|0
operator|)
operator|&&
operator|(
name|context
operator|->
name|numErrors
argument_list|()
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
return|;
block|}
end_function
end_unit
