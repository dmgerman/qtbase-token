begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2012 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4718
name|)
end_pragma
begin_include
include|#
directive|include
file|"compiler/depgraph/DependencyGraph.h"
end_include
begin_include
include|#
directive|include
file|"compiler/depgraph/DependencyGraphBuilder.h"
end_include
begin_constructor
DECL|function|TDependencyGraph
name|TDependencyGraph
operator|::
name|TDependencyGraph
parameter_list|(
name|TIntermNode
modifier|*
name|intermNode
parameter_list|)
block|{
name|TDependencyGraphBuilder
operator|::
name|build
argument_list|(
name|intermNode
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~TDependencyGraph
name|TDependencyGraph
operator|::
name|~
name|TDependencyGraph
parameter_list|()
block|{
for|for
control|(
name|TGraphNodeVector
operator|::
name|const_iterator
name|iter
init|=
name|mAllNodes
operator|.
name|begin
argument_list|()
init|;
name|iter
operator|!=
name|mAllNodes
operator|.
name|end
argument_list|()
condition|;
operator|++
name|iter
control|)
block|{
name|TGraphNode
modifier|*
name|node
init|=
operator|*
name|iter
decl_stmt|;
operator|delete
name|node
expr_stmt|;
block|}
block|}
end_destructor
begin_function
DECL|function|createArgument
name|TGraphArgument
modifier|*
name|TDependencyGraph
operator|::
name|createArgument
parameter_list|(
name|TIntermAggregate
modifier|*
name|intermFunctionCall
parameter_list|,
name|int
name|argumentNumber
parameter_list|)
block|{
name|TGraphArgument
modifier|*
name|argument
init|=
operator|new
name|TGraphArgument
argument_list|(
name|intermFunctionCall
argument_list|,
name|argumentNumber
argument_list|)
decl_stmt|;
name|mAllNodes
operator|.
name|push_back
argument_list|(
name|argument
argument_list|)
expr_stmt|;
return|return
name|argument
return|;
block|}
end_function
begin_function
DECL|function|createFunctionCall
name|TGraphFunctionCall
modifier|*
name|TDependencyGraph
operator|::
name|createFunctionCall
parameter_list|(
name|TIntermAggregate
modifier|*
name|intermFunctionCall
parameter_list|)
block|{
name|TGraphFunctionCall
modifier|*
name|functionCall
init|=
operator|new
name|TGraphFunctionCall
argument_list|(
name|intermFunctionCall
argument_list|)
decl_stmt|;
name|mAllNodes
operator|.
name|push_back
argument_list|(
name|functionCall
argument_list|)
expr_stmt|;
if|if
condition|(
name|functionCall
operator|->
name|getIntermFunctionCall
argument_list|()
operator|->
name|isUserDefined
argument_list|()
condition|)
name|mUserDefinedFunctionCalls
operator|.
name|push_back
argument_list|(
name|functionCall
argument_list|)
expr_stmt|;
return|return
name|functionCall
return|;
block|}
end_function
begin_function
DECL|function|getOrCreateSymbol
name|TGraphSymbol
modifier|*
name|TDependencyGraph
operator|::
name|getOrCreateSymbol
parameter_list|(
name|TIntermSymbol
modifier|*
name|intermSymbol
parameter_list|)
block|{
name|TSymbolIdMap
operator|::
name|const_iterator
name|iter
init|=
name|mSymbolIdMap
operator|.
name|find
argument_list|(
name|intermSymbol
operator|->
name|getId
argument_list|()
argument_list|)
decl_stmt|;
name|TGraphSymbol
modifier|*
name|symbol
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|iter
operator|!=
name|mSymbolIdMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|TSymbolIdPair
name|pair
init|=
operator|*
name|iter
decl_stmt|;
name|symbol
operator|=
name|pair
operator|.
name|second
expr_stmt|;
block|}
else|else
block|{
name|symbol
operator|=
operator|new
name|TGraphSymbol
argument_list|(
name|intermSymbol
argument_list|)
expr_stmt|;
name|mAllNodes
operator|.
name|push_back
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
name|TSymbolIdPair
name|pair
argument_list|(
name|intermSymbol
operator|->
name|getId
argument_list|()
argument_list|,
name|symbol
argument_list|)
decl_stmt|;
name|mSymbolIdMap
operator|.
name|insert
argument_list|(
name|pair
argument_list|)
expr_stmt|;
comment|// We save all sampler symbols in a collection, so we can start graph traversals from them quickly.
if|if
condition|(
name|IsSampler
argument_list|(
name|intermSymbol
operator|->
name|getBasicType
argument_list|()
argument_list|)
condition|)
name|mSamplerSymbols
operator|.
name|push_back
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
block|}
return|return
name|symbol
return|;
block|}
end_function
begin_function
DECL|function|createSelection
name|TGraphSelection
modifier|*
name|TDependencyGraph
operator|::
name|createSelection
parameter_list|(
name|TIntermSelection
modifier|*
name|intermSelection
parameter_list|)
block|{
name|TGraphSelection
modifier|*
name|selection
init|=
operator|new
name|TGraphSelection
argument_list|(
name|intermSelection
argument_list|)
decl_stmt|;
name|mAllNodes
operator|.
name|push_back
argument_list|(
name|selection
argument_list|)
expr_stmt|;
return|return
name|selection
return|;
block|}
end_function
begin_function
DECL|function|createLoop
name|TGraphLoop
modifier|*
name|TDependencyGraph
operator|::
name|createLoop
parameter_list|(
name|TIntermLoop
modifier|*
name|intermLoop
parameter_list|)
block|{
name|TGraphLoop
modifier|*
name|loop
init|=
operator|new
name|TGraphLoop
argument_list|(
name|intermLoop
argument_list|)
decl_stmt|;
name|mAllNodes
operator|.
name|push_back
argument_list|(
name|loop
argument_list|)
expr_stmt|;
return|return
name|loop
return|;
block|}
end_function
begin_function
DECL|function|createLogicalOp
name|TGraphLogicalOp
modifier|*
name|TDependencyGraph
operator|::
name|createLogicalOp
parameter_list|(
name|TIntermBinary
modifier|*
name|intermLogicalOp
parameter_list|)
block|{
name|TGraphLogicalOp
modifier|*
name|logicalOp
init|=
operator|new
name|TGraphLogicalOp
argument_list|(
name|intermLogicalOp
argument_list|)
decl_stmt|;
name|mAllNodes
operator|.
name|push_back
argument_list|(
name|logicalOp
argument_list|)
expr_stmt|;
return|return
name|logicalOp
return|;
block|}
end_function
begin_function
DECL|function|getOpString
specifier|const
name|char
modifier|*
name|TGraphLogicalOp
operator|::
name|getOpString
parameter_list|()
specifier|const
block|{
specifier|const
name|char
modifier|*
name|opString
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|getIntermLogicalOp
argument_list|()
operator|->
name|getOp
argument_list|()
condition|)
block|{
case|case
name|EOpLogicalAnd
case|:
name|opString
operator|=
literal|"and"
expr_stmt|;
break|break;
case|case
name|EOpLogicalOr
case|:
name|opString
operator|=
literal|"or"
expr_stmt|;
break|break;
default|default:
name|opString
operator|=
literal|"unknown"
expr_stmt|;
break|break;
block|}
return|return
name|opString
return|;
block|}
end_function
end_unit
