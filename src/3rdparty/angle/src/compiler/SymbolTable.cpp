begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2012 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Symbol table for parsing.  Most functionaliy and main ideas
end_comment
begin_comment
comment|// are documented in the header file.
end_comment
begin_comment
comment|//
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_if
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4718
name|)
end_pragma
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"compiler/SymbolTable.h"
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_include
include|#
directive|include
file|"common/angleutils.h"
end_include
begin_constructor
DECL|function|TType
name|TType
operator|::
name|TType
parameter_list|(
specifier|const
name|TPublicType
modifier|&
name|p
parameter_list|)
member_init_list|:
name|type
argument_list|(
name|p
operator|.
name|type
argument_list|)
member_init_list|,
name|precision
argument_list|(
name|p
operator|.
name|precision
argument_list|)
member_init_list|,
name|qualifier
argument_list|(
name|p
operator|.
name|qualifier
argument_list|)
member_init_list|,
name|size
argument_list|(
name|p
operator|.
name|size
argument_list|)
member_init_list|,
name|matrix
argument_list|(
name|p
operator|.
name|matrix
argument_list|)
member_init_list|,
name|array
argument_list|(
name|p
operator|.
name|array
argument_list|)
member_init_list|,
name|arraySize
argument_list|(
name|p
operator|.
name|arraySize
argument_list|)
member_init_list|,
name|maxArraySize
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|arrayInformationType
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|structure
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|structureSize
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|deepestStructNesting
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|fieldName
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mangled
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|typeName
argument_list|(
literal|0
argument_list|)
block|{
if|if
condition|(
name|p
operator|.
name|userDef
condition|)
block|{
name|structure
operator|=
name|p
operator|.
name|userDef
operator|->
name|getStruct
argument_list|()
expr_stmt|;
name|typeName
operator|=
name|NewPoolTString
argument_list|(
name|p
operator|.
name|userDef
operator|->
name|getTypeName
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|computeDeepestStructNesting
argument_list|()
expr_stmt|;
block|}
block|}
end_constructor
begin_comment
comment|//
end_comment
begin_comment
comment|// Recursively generate mangled names.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|buildMangledName
name|void
name|TType
operator|::
name|buildMangledName
parameter_list|(
name|TString
modifier|&
name|mangledName
parameter_list|)
block|{
if|if
condition|(
name|isMatrix
argument_list|()
condition|)
name|mangledName
operator|+=
literal|'m'
expr_stmt|;
elseif|else
if|if
condition|(
name|isVector
argument_list|()
condition|)
name|mangledName
operator|+=
literal|'v'
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|EbtFloat
case|:
name|mangledName
operator|+=
literal|'f'
expr_stmt|;
break|break;
case|case
name|EbtInt
case|:
name|mangledName
operator|+=
literal|'i'
expr_stmt|;
break|break;
case|case
name|EbtBool
case|:
name|mangledName
operator|+=
literal|'b'
expr_stmt|;
break|break;
case|case
name|EbtSampler2D
case|:
name|mangledName
operator|+=
literal|"s2"
expr_stmt|;
break|break;
case|case
name|EbtSamplerCube
case|:
name|mangledName
operator|+=
literal|"sC"
expr_stmt|;
break|break;
case|case
name|EbtStruct
case|:
name|mangledName
operator|+=
literal|"struct-"
expr_stmt|;
if|if
condition|(
name|typeName
condition|)
name|mangledName
operator|+=
operator|*
name|typeName
expr_stmt|;
block|{
comment|// support MSVC++6.0
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|structure
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|mangledName
operator|+=
literal|'-'
expr_stmt|;
operator|(
operator|*
name|structure
operator|)
index|[
name|i
index|]
operator|.
name|type
operator|->
name|buildMangledName
argument_list|(
name|mangledName
argument_list|)
expr_stmt|;
block|}
block|}
default|default:
break|break;
block|}
name|mangledName
operator|+=
cast|static_cast
argument_list|<
name|char
argument_list|>
argument_list|(
literal|'0'
operator|+
name|getNominalSize
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|isArray
argument_list|()
condition|)
block|{
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|arraySize
argument_list|)
expr_stmt|;
name|mangledName
operator|+=
literal|'['
expr_stmt|;
name|mangledName
operator|+=
name|buf
expr_stmt|;
name|mangledName
operator|+=
literal|']'
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|getStructSize
name|int
name|TType
operator|::
name|getStructSize
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|getStruct
argument_list|()
condition|)
block|{
name|assert
argument_list|(
literal|false
operator|&&
literal|"Not a struct"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|structureSize
operator|==
literal|0
condition|)
for|for
control|(
name|TTypeList
operator|::
name|const_iterator
name|tl
init|=
name|getStruct
argument_list|()
operator|->
name|begin
argument_list|()
init|;
name|tl
operator|!=
name|getStruct
argument_list|()
operator|->
name|end
argument_list|()
condition|;
name|tl
operator|++
control|)
name|structureSize
operator|+=
operator|(
operator|(
operator|*
name|tl
operator|)
operator|.
name|type
operator|)
operator|->
name|getObjectSize
argument_list|()
expr_stmt|;
return|return
name|structureSize
return|;
block|}
end_function
begin_function
DECL|function|computeDeepestStructNesting
name|void
name|TType
operator|::
name|computeDeepestStructNesting
parameter_list|()
block|{
if|if
condition|(
operator|!
name|getStruct
argument_list|()
condition|)
block|{
return|return;
block|}
name|int
name|maxNesting
init|=
literal|0
decl_stmt|;
for|for
control|(
name|TTypeList
operator|::
name|const_iterator
name|tl
init|=
name|getStruct
argument_list|()
operator|->
name|begin
argument_list|()
init|;
name|tl
operator|!=
name|getStruct
argument_list|()
operator|->
name|end
argument_list|()
condition|;
operator|++
name|tl
control|)
block|{
name|maxNesting
operator|=
name|std
operator|::
name|max
argument_list|(
name|maxNesting
argument_list|,
operator|(
operator|(
operator|*
name|tl
operator|)
operator|.
name|type
operator|)
operator|->
name|getDeepestStructNesting
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|deepestStructNesting
operator|=
literal|1
operator|+
name|maxNesting
expr_stmt|;
block|}
end_function
begin_function
DECL|function|isStructureContainingArrays
name|bool
name|TType
operator|::
name|isStructureContainingArrays
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|structure
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|TTypeList
operator|::
name|const_iterator
name|member
init|=
name|structure
operator|->
name|begin
argument_list|()
init|;
name|member
operator|!=
name|structure
operator|->
name|end
argument_list|()
condition|;
name|member
operator|++
control|)
block|{
if|if
condition|(
name|member
operator|->
name|type
operator|->
name|isArray
argument_list|()
operator|||
name|member
operator|->
name|type
operator|->
name|isStructureContainingArrays
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Dump functions.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|dump
name|void
name|TVariable
operator|::
name|dump
parameter_list|(
name|TInfoSink
modifier|&
name|infoSink
parameter_list|)
specifier|const
block|{
name|infoSink
operator|.
name|debug
operator|<<
name|getName
argument_list|()
operator|.
name|c_str
argument_list|()
operator|<<
literal|": "
operator|<<
name|type
operator|.
name|getQualifierString
argument_list|()
operator|<<
literal|" "
operator|<<
name|type
operator|.
name|getPrecisionString
argument_list|()
operator|<<
literal|" "
operator|<<
name|type
operator|.
name|getBasicString
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
operator|.
name|isArray
argument_list|()
condition|)
block|{
name|infoSink
operator|.
name|debug
operator|<<
literal|"[0]"
expr_stmt|;
block|}
name|infoSink
operator|.
name|debug
operator|<<
literal|"\n"
expr_stmt|;
block|}
end_function
begin_function
DECL|function|dump
name|void
name|TFunction
operator|::
name|dump
parameter_list|(
name|TInfoSink
modifier|&
name|infoSink
parameter_list|)
specifier|const
block|{
name|infoSink
operator|.
name|debug
operator|<<
name|getName
argument_list|()
operator|.
name|c_str
argument_list|()
operator|<<
literal|": "
operator|<<
name|returnType
operator|.
name|getBasicString
argument_list|()
operator|<<
literal|" "
operator|<<
name|getMangledName
argument_list|()
operator|.
name|c_str
argument_list|()
operator|<<
literal|"\n"
expr_stmt|;
block|}
end_function
begin_function
DECL|function|dump
name|void
name|TSymbolTableLevel
operator|::
name|dump
parameter_list|(
name|TInfoSink
modifier|&
name|infoSink
parameter_list|)
specifier|const
block|{
name|tLevel
operator|::
name|const_iterator
name|it
decl_stmt|;
for|for
control|(
name|it
operator|=
name|level
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|level
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
operator|(
operator|*
name|it
operator|)
operator|.
name|second
operator|->
name|dump
argument_list|(
name|infoSink
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|dump
name|void
name|TSymbolTable
operator|::
name|dump
parameter_list|(
name|TInfoSink
modifier|&
name|infoSink
parameter_list|)
specifier|const
block|{
for|for
control|(
name|int
name|level
init|=
name|currentLevel
argument_list|()
init|;
name|level
operator|>=
literal|0
condition|;
operator|--
name|level
control|)
block|{
name|infoSink
operator|.
name|debug
operator|<<
literal|"LEVEL "
operator|<<
name|level
operator|<<
literal|"\n"
expr_stmt|;
name|table
index|[
name|level
index|]
operator|->
name|dump
argument_list|(
name|infoSink
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Functions have buried pointers to delete.
end_comment
begin_comment
comment|//
end_comment
begin_destructor
DECL|function|~TFunction
name|TFunction
operator|::
name|~
name|TFunction
parameter_list|()
block|{
for|for
control|(
name|TParamList
operator|::
name|iterator
name|i
init|=
name|parameters
operator|.
name|begin
argument_list|()
init|;
name|i
operator|!=
name|parameters
operator|.
name|end
argument_list|()
condition|;
operator|++
name|i
control|)
operator|delete
operator|(
operator|*
name|i
operator|)
operator|.
name|type
expr_stmt|;
block|}
end_destructor
begin_comment
comment|//
end_comment
begin_comment
comment|// Symbol table levels are a map of pointers to symbols that have to be deleted.
end_comment
begin_comment
comment|//
end_comment
begin_destructor
DECL|function|~TSymbolTableLevel
name|TSymbolTableLevel
operator|::
name|~
name|TSymbolTableLevel
parameter_list|()
block|{
for|for
control|(
name|tLevel
operator|::
name|iterator
name|it
init|=
name|level
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|level
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
operator|delete
operator|(
operator|*
name|it
operator|)
operator|.
name|second
expr_stmt|;
block|}
end_destructor
begin_comment
comment|//
end_comment
begin_comment
comment|// Change all function entries in the table with the non-mangled name
end_comment
begin_comment
comment|// to be related to the provided built-in operation.  This is a low
end_comment
begin_comment
comment|// performance operation, and only intended for symbol tables that
end_comment
begin_comment
comment|// live across a large number of compiles.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|relateToOperator
name|void
name|TSymbolTableLevel
operator|::
name|relateToOperator
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|TOperator
name|op
parameter_list|)
block|{
name|tLevel
operator|::
name|iterator
name|it
decl_stmt|;
for|for
control|(
name|it
operator|=
name|level
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|level
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|.
name|second
operator|->
name|isFunction
argument_list|()
condition|)
block|{
name|TFunction
modifier|*
name|function
init|=
cast|static_cast
argument_list|<
name|TFunction
operator|*
argument_list|>
argument_list|(
operator|(
operator|*
name|it
operator|)
operator|.
name|second
argument_list|)
decl_stmt|;
if|if
condition|(
name|function
operator|->
name|getName
argument_list|()
operator|==
name|name
condition|)
name|function
operator|->
name|relateToOperator
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Change all function entries in the table with the non-mangled name
end_comment
begin_comment
comment|// to be related to the provided built-in extension. This is a low
end_comment
begin_comment
comment|// performance operation, and only intended for symbol tables that
end_comment
begin_comment
comment|// live across a large number of compiles.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|relateToExtension
name|void
name|TSymbolTableLevel
operator|::
name|relateToExtension
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|TString
modifier|&
name|ext
parameter_list|)
block|{
for|for
control|(
name|tLevel
operator|::
name|iterator
name|it
init|=
name|level
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|level
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
name|it
operator|->
name|second
operator|->
name|isFunction
argument_list|()
condition|)
block|{
name|TFunction
modifier|*
name|function
init|=
cast|static_cast
argument_list|<
name|TFunction
operator|*
argument_list|>
argument_list|(
name|it
operator|->
name|second
argument_list|)
decl_stmt|;
if|if
condition|(
name|function
operator|->
name|getName
argument_list|()
operator|==
name|name
condition|)
name|function
operator|->
name|relateToExtension
argument_list|(
name|ext
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_constructor
DECL|function|TSymbol
name|TSymbol
operator|::
name|TSymbol
parameter_list|(
specifier|const
name|TSymbol
modifier|&
name|copyOf
parameter_list|)
block|{
name|name
operator|=
name|NewPoolTString
argument_list|(
name|copyOf
operator|.
name|name
operator|->
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|uniqueId
operator|=
name|copyOf
operator|.
name|uniqueId
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|TVariable
name|TVariable
operator|::
name|TVariable
parameter_list|(
specifier|const
name|TVariable
modifier|&
name|copyOf
parameter_list|,
name|TStructureMap
modifier|&
name|remapper
parameter_list|)
member_init_list|:
name|TSymbol
argument_list|(
name|copyOf
argument_list|)
block|{
name|type
operator|.
name|copyType
argument_list|(
name|copyOf
operator|.
name|type
argument_list|,
name|remapper
argument_list|)
expr_stmt|;
name|userType
operator|=
name|copyOf
operator|.
name|userType
expr_stmt|;
comment|// for builtIn symbol table level, unionArray and arrayInformation pointers should be NULL
name|assert
argument_list|(
name|copyOf
operator|.
name|arrayInformationType
operator|==
literal|0
argument_list|)
expr_stmt|;
name|arrayInformationType
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|copyOf
operator|.
name|unionArray
condition|)
block|{
name|assert
argument_list|(
operator|!
name|copyOf
operator|.
name|type
operator|.
name|getStruct
argument_list|()
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|copyOf
operator|.
name|type
operator|.
name|getObjectSize
argument_list|()
operator|==
literal|1
argument_list|)
expr_stmt|;
name|unionArray
operator|=
operator|new
name|ConstantUnion
index|[
literal|1
index|]
expr_stmt|;
name|unionArray
index|[
literal|0
index|]
operator|=
name|copyOf
operator|.
name|unionArray
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
name|unionArray
operator|=
literal|0
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|clone
name|TVariable
modifier|*
name|TVariable
operator|::
name|clone
parameter_list|(
name|TStructureMap
modifier|&
name|remapper
parameter_list|)
block|{
name|TVariable
modifier|*
name|variable
init|=
operator|new
name|TVariable
argument_list|(
operator|*
name|this
argument_list|,
name|remapper
argument_list|)
decl_stmt|;
return|return
name|variable
return|;
block|}
end_function
begin_constructor
DECL|function|TFunction
name|TFunction
operator|::
name|TFunction
parameter_list|(
specifier|const
name|TFunction
modifier|&
name|copyOf
parameter_list|,
name|TStructureMap
modifier|&
name|remapper
parameter_list|)
member_init_list|:
name|TSymbol
argument_list|(
name|copyOf
argument_list|)
block|{
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|copyOf
operator|.
name|parameters
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|TParameter
name|param
decl_stmt|;
name|parameters
operator|.
name|push_back
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|parameters
operator|.
name|back
argument_list|()
operator|.
name|copyParam
argument_list|(
name|copyOf
operator|.
name|parameters
index|[
name|i
index|]
argument_list|,
name|remapper
argument_list|)
expr_stmt|;
block|}
name|returnType
operator|.
name|copyType
argument_list|(
name|copyOf
operator|.
name|returnType
argument_list|,
name|remapper
argument_list|)
expr_stmt|;
name|mangledName
operator|=
name|copyOf
operator|.
name|mangledName
expr_stmt|;
name|op
operator|=
name|copyOf
operator|.
name|op
expr_stmt|;
name|defined
operator|=
name|copyOf
operator|.
name|defined
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|clone
name|TFunction
modifier|*
name|TFunction
operator|::
name|clone
parameter_list|(
name|TStructureMap
modifier|&
name|remapper
parameter_list|)
block|{
name|TFunction
modifier|*
name|function
init|=
operator|new
name|TFunction
argument_list|(
operator|*
name|this
argument_list|,
name|remapper
argument_list|)
decl_stmt|;
return|return
name|function
return|;
block|}
end_function
begin_function
DECL|function|clone
name|TSymbolTableLevel
modifier|*
name|TSymbolTableLevel
operator|::
name|clone
parameter_list|(
name|TStructureMap
modifier|&
name|remapper
parameter_list|)
block|{
name|TSymbolTableLevel
modifier|*
name|symTableLevel
init|=
operator|new
name|TSymbolTableLevel
argument_list|()
decl_stmt|;
name|tLevel
operator|::
name|iterator
name|iter
decl_stmt|;
for|for
control|(
name|iter
operator|=
name|level
operator|.
name|begin
argument_list|()
init|;
name|iter
operator|!=
name|level
operator|.
name|end
argument_list|()
condition|;
operator|++
name|iter
control|)
block|{
name|symTableLevel
operator|->
name|insert
argument_list|(
operator|*
name|iter
operator|->
name|second
operator|->
name|clone
argument_list|(
name|remapper
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|symTableLevel
return|;
block|}
end_function
begin_function
DECL|function|copyTable
name|void
name|TSymbolTable
operator|::
name|copyTable
parameter_list|(
specifier|const
name|TSymbolTable
modifier|&
name|copyOf
parameter_list|)
block|{
name|TStructureMap
name|remapper
decl_stmt|;
name|uniqueId
operator|=
name|copyOf
operator|.
name|uniqueId
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|copyOf
operator|.
name|table
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|table
operator|.
name|push_back
argument_list|(
name|copyOf
operator|.
name|table
index|[
name|i
index|]
operator|->
name|clone
argument_list|(
name|remapper
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|copyOf
operator|.
name|precisionStack
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|precisionStack
operator|.
name|push_back
argument_list|(
name|copyOf
operator|.
name|precisionStack
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function
end_unit
