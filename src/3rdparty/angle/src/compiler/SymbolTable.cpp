begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2012 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Symbol table for parsing.  Most functionaliy and main ideas
end_comment
begin_comment
comment|// are documented in the header file.
end_comment
begin_comment
comment|//
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_if
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4718
name|)
end_pragma
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"compiler/SymbolTable.h"
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_include
include|#
directive|include
file|<climits>
end_include
begin_constructor
DECL|function|TType
name|TType
operator|::
name|TType
parameter_list|(
specifier|const
name|TPublicType
modifier|&
name|p
parameter_list|)
member_init_list|:
name|type
argument_list|(
name|p
operator|.
name|type
argument_list|)
member_init_list|,
name|precision
argument_list|(
name|p
operator|.
name|precision
argument_list|)
member_init_list|,
name|qualifier
argument_list|(
name|p
operator|.
name|qualifier
argument_list|)
member_init_list|,
name|size
argument_list|(
name|p
operator|.
name|size
argument_list|)
member_init_list|,
name|matrix
argument_list|(
name|p
operator|.
name|matrix
argument_list|)
member_init_list|,
name|array
argument_list|(
name|p
operator|.
name|array
argument_list|)
member_init_list|,
name|arraySize
argument_list|(
name|p
operator|.
name|arraySize
argument_list|)
member_init_list|,
name|structure
argument_list|(
literal|0
argument_list|)
block|{
if|if
condition|(
name|p
operator|.
name|userDef
condition|)
name|structure
operator|=
name|p
operator|.
name|userDef
operator|->
name|getStruct
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|//
end_comment
begin_comment
comment|// Recursively generate mangled names.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|buildMangledName
name|TString
name|TType
operator|::
name|buildMangledName
parameter_list|()
specifier|const
block|{
name|TString
name|mangledName
decl_stmt|;
if|if
condition|(
name|isMatrix
argument_list|()
condition|)
name|mangledName
operator|+=
literal|'m'
expr_stmt|;
elseif|else
if|if
condition|(
name|isVector
argument_list|()
condition|)
name|mangledName
operator|+=
literal|'v'
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|EbtFloat
case|:
name|mangledName
operator|+=
literal|'f'
expr_stmt|;
break|break;
case|case
name|EbtInt
case|:
name|mangledName
operator|+=
literal|'i'
expr_stmt|;
break|break;
case|case
name|EbtBool
case|:
name|mangledName
operator|+=
literal|'b'
expr_stmt|;
break|break;
case|case
name|EbtSampler2D
case|:
name|mangledName
operator|+=
literal|"s2"
expr_stmt|;
break|break;
case|case
name|EbtSamplerCube
case|:
name|mangledName
operator|+=
literal|"sC"
expr_stmt|;
break|break;
case|case
name|EbtStruct
case|:
name|mangledName
operator|+=
name|structure
operator|->
name|mangledName
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|mangledName
operator|+=
cast|static_cast
argument_list|<
name|char
argument_list|>
argument_list|(
literal|'0'
operator|+
name|getNominalSize
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|isArray
argument_list|()
condition|)
block|{
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|arraySize
argument_list|)
expr_stmt|;
name|mangledName
operator|+=
literal|'['
expr_stmt|;
name|mangledName
operator|+=
name|buf
expr_stmt|;
name|mangledName
operator|+=
literal|']'
expr_stmt|;
block|}
return|return
name|mangledName
return|;
block|}
end_function
begin_function
DECL|function|getObjectSize
name|size_t
name|TType
operator|::
name|getObjectSize
parameter_list|()
specifier|const
block|{
name|size_t
name|totalSize
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|getBasicType
argument_list|()
operator|==
name|EbtStruct
condition|)
name|totalSize
operator|=
name|structure
operator|->
name|objectSize
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|matrix
condition|)
name|totalSize
operator|=
name|size
operator|*
name|size
expr_stmt|;
else|else
name|totalSize
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|isArray
argument_list|()
condition|)
block|{
name|size_t
name|arraySize
init|=
name|getArraySize
argument_list|()
decl_stmt|;
if|if
condition|(
name|arraySize
operator|>
name|INT_MAX
operator|/
name|totalSize
condition|)
name|totalSize
operator|=
name|INT_MAX
expr_stmt|;
else|else
name|totalSize
operator|*=
name|arraySize
expr_stmt|;
block|}
return|return
name|totalSize
return|;
block|}
end_function
begin_function
DECL|function|containsArrays
name|bool
name|TStructure
operator|::
name|containsArrays
parameter_list|()
specifier|const
block|{
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mFields
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|TType
modifier|*
name|fieldType
init|=
operator|(
operator|*
name|mFields
operator|)
index|[
name|i
index|]
operator|->
name|type
argument_list|()
decl_stmt|;
if|if
condition|(
name|fieldType
operator|->
name|isArray
argument_list|()
operator|||
name|fieldType
operator|->
name|isStructureContainingArrays
argument_list|()
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|buildMangledName
name|TString
name|TStructure
operator|::
name|buildMangledName
parameter_list|()
specifier|const
block|{
name|TString
name|mangledName
argument_list|(
literal|"struct-"
argument_list|)
decl_stmt|;
name|mangledName
operator|+=
operator|*
name|mName
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mFields
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|mangledName
operator|+=
literal|'-'
expr_stmt|;
name|mangledName
operator|+=
operator|(
operator|*
name|mFields
operator|)
index|[
name|i
index|]
operator|->
name|type
argument_list|()
operator|->
name|getMangledName
argument_list|()
expr_stmt|;
block|}
return|return
name|mangledName
return|;
block|}
end_function
begin_function
DECL|function|calculateObjectSize
name|size_t
name|TStructure
operator|::
name|calculateObjectSize
parameter_list|()
specifier|const
block|{
name|size_t
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mFields
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|size_t
name|fieldSize
init|=
operator|(
operator|*
name|mFields
operator|)
index|[
name|i
index|]
operator|->
name|type
argument_list|()
operator|->
name|getObjectSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|fieldSize
operator|>
name|INT_MAX
operator|-
name|size
condition|)
name|size
operator|=
name|INT_MAX
expr_stmt|;
else|else
name|size
operator|+=
name|fieldSize
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function
begin_function
DECL|function|calculateDeepestNesting
name|int
name|TStructure
operator|::
name|calculateDeepestNesting
parameter_list|()
specifier|const
block|{
name|int
name|maxNesting
init|=
literal|0
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mFields
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|maxNesting
operator|=
name|std
operator|::
name|max
argument_list|(
name|maxNesting
argument_list|,
operator|(
operator|*
name|mFields
operator|)
index|[
name|i
index|]
operator|->
name|type
argument_list|()
operator|->
name|getDeepestStructNesting
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
operator|+
name|maxNesting
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Dump functions.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|dump
name|void
name|TVariable
operator|::
name|dump
parameter_list|(
name|TInfoSink
modifier|&
name|infoSink
parameter_list|)
specifier|const
block|{
name|infoSink
operator|.
name|debug
operator|<<
name|getName
argument_list|()
operator|.
name|c_str
argument_list|()
operator|<<
literal|": "
operator|<<
name|type
operator|.
name|getQualifierString
argument_list|()
operator|<<
literal|" "
operator|<<
name|type
operator|.
name|getPrecisionString
argument_list|()
operator|<<
literal|" "
operator|<<
name|type
operator|.
name|getBasicString
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
operator|.
name|isArray
argument_list|()
condition|)
block|{
name|infoSink
operator|.
name|debug
operator|<<
literal|"[0]"
expr_stmt|;
block|}
name|infoSink
operator|.
name|debug
operator|<<
literal|"\n"
expr_stmt|;
block|}
end_function
begin_function
DECL|function|dump
name|void
name|TFunction
operator|::
name|dump
parameter_list|(
name|TInfoSink
modifier|&
name|infoSink
parameter_list|)
specifier|const
block|{
name|infoSink
operator|.
name|debug
operator|<<
name|getName
argument_list|()
operator|.
name|c_str
argument_list|()
operator|<<
literal|": "
operator|<<
name|returnType
operator|.
name|getBasicString
argument_list|()
operator|<<
literal|" "
operator|<<
name|getMangledName
argument_list|()
operator|.
name|c_str
argument_list|()
operator|<<
literal|"\n"
expr_stmt|;
block|}
end_function
begin_function
DECL|function|dump
name|void
name|TSymbolTableLevel
operator|::
name|dump
parameter_list|(
name|TInfoSink
modifier|&
name|infoSink
parameter_list|)
specifier|const
block|{
name|tLevel
operator|::
name|const_iterator
name|it
decl_stmt|;
for|for
control|(
name|it
operator|=
name|level
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|level
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
operator|(
operator|*
name|it
operator|)
operator|.
name|second
operator|->
name|dump
argument_list|(
name|infoSink
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|dump
name|void
name|TSymbolTable
operator|::
name|dump
parameter_list|(
name|TInfoSink
modifier|&
name|infoSink
parameter_list|)
specifier|const
block|{
for|for
control|(
name|int
name|level
init|=
name|currentLevel
argument_list|()
init|;
name|level
operator|>=
literal|0
condition|;
operator|--
name|level
control|)
block|{
name|infoSink
operator|.
name|debug
operator|<<
literal|"LEVEL "
operator|<<
name|level
operator|<<
literal|"\n"
expr_stmt|;
name|table
index|[
name|level
index|]
operator|->
name|dump
argument_list|(
name|infoSink
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Functions have buried pointers to delete.
end_comment
begin_comment
comment|//
end_comment
begin_destructor
DECL|function|~TFunction
name|TFunction
operator|::
name|~
name|TFunction
parameter_list|()
block|{
for|for
control|(
name|TParamList
operator|::
name|iterator
name|i
init|=
name|parameters
operator|.
name|begin
argument_list|()
init|;
name|i
operator|!=
name|parameters
operator|.
name|end
argument_list|()
condition|;
operator|++
name|i
control|)
operator|delete
operator|(
operator|*
name|i
operator|)
operator|.
name|type
expr_stmt|;
block|}
end_destructor
begin_comment
comment|//
end_comment
begin_comment
comment|// Symbol table levels are a map of pointers to symbols that have to be deleted.
end_comment
begin_comment
comment|//
end_comment
begin_destructor
DECL|function|~TSymbolTableLevel
name|TSymbolTableLevel
operator|::
name|~
name|TSymbolTableLevel
parameter_list|()
block|{
for|for
control|(
name|tLevel
operator|::
name|iterator
name|it
init|=
name|level
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|level
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
operator|delete
operator|(
operator|*
name|it
operator|)
operator|.
name|second
expr_stmt|;
block|}
end_destructor
begin_comment
comment|//
end_comment
begin_comment
comment|// Change all function entries in the table with the non-mangled name
end_comment
begin_comment
comment|// to be related to the provided built-in operation.  This is a low
end_comment
begin_comment
comment|// performance operation, and only intended for symbol tables that
end_comment
begin_comment
comment|// live across a large number of compiles.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|relateToOperator
name|void
name|TSymbolTableLevel
operator|::
name|relateToOperator
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|TOperator
name|op
parameter_list|)
block|{
name|tLevel
operator|::
name|iterator
name|it
decl_stmt|;
for|for
control|(
name|it
operator|=
name|level
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|level
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|.
name|second
operator|->
name|isFunction
argument_list|()
condition|)
block|{
name|TFunction
modifier|*
name|function
init|=
cast|static_cast
argument_list|<
name|TFunction
operator|*
argument_list|>
argument_list|(
operator|(
operator|*
name|it
operator|)
operator|.
name|second
argument_list|)
decl_stmt|;
if|if
condition|(
name|function
operator|->
name|getName
argument_list|()
operator|==
name|name
condition|)
name|function
operator|->
name|relateToOperator
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Change all function entries in the table with the non-mangled name
end_comment
begin_comment
comment|// to be related to the provided built-in extension. This is a low
end_comment
begin_comment
comment|// performance operation, and only intended for symbol tables that
end_comment
begin_comment
comment|// live across a large number of compiles.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|relateToExtension
name|void
name|TSymbolTableLevel
operator|::
name|relateToExtension
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|TString
modifier|&
name|ext
parameter_list|)
block|{
for|for
control|(
name|tLevel
operator|::
name|iterator
name|it
init|=
name|level
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|level
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|TSymbol
modifier|*
name|symbol
init|=
name|it
operator|->
name|second
decl_stmt|;
if|if
condition|(
name|symbol
operator|->
name|getName
argument_list|()
operator|==
name|name
condition|)
name|symbol
operator|->
name|relateToExtension
argument_list|(
name|ext
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_destructor
DECL|function|~TSymbolTable
name|TSymbolTable
operator|::
name|~
name|TSymbolTable
parameter_list|()
block|{
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|table
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
operator|delete
name|table
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|precisionStack
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
operator|delete
name|precisionStack
index|[
name|i
index|]
expr_stmt|;
block|}
end_destructor
end_unit
