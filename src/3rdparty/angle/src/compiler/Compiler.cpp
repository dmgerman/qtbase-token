begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2012 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|"compiler/BuiltInFunctionEmulator.h"
end_include
begin_include
include|#
directive|include
file|"compiler/DetectRecursion.h"
end_include
begin_include
include|#
directive|include
file|"compiler/ForLoopUnroll.h"
end_include
begin_include
include|#
directive|include
file|"compiler/Initialize.h"
end_include
begin_include
include|#
directive|include
file|"compiler/InitializeParseContext.h"
end_include
begin_include
include|#
directive|include
file|"compiler/MapLongVariableNames.h"
end_include
begin_include
include|#
directive|include
file|"compiler/ParseHelper.h"
end_include
begin_include
include|#
directive|include
file|"compiler/RenameFunction.h"
end_include
begin_include
include|#
directive|include
file|"compiler/ShHandle.h"
end_include
begin_include
include|#
directive|include
file|"compiler/ValidateLimitations.h"
end_include
begin_include
include|#
directive|include
file|"compiler/VariablePacker.h"
end_include
begin_include
include|#
directive|include
file|"compiler/depgraph/DependencyGraph.h"
end_include
begin_include
include|#
directive|include
file|"compiler/depgraph/DependencyGraphOutput.h"
end_include
begin_include
include|#
directive|include
file|"compiler/timing/RestrictFragmentShaderTiming.h"
end_include
begin_include
include|#
directive|include
file|"compiler/timing/RestrictVertexShaderTiming.h"
end_include
begin_function
DECL|function|isWebGLBasedSpec
name|bool
name|isWebGLBasedSpec
parameter_list|(
name|ShShaderSpec
name|spec
parameter_list|)
block|{
return|return
name|spec
operator|==
name|SH_WEBGL_SPEC
operator|||
name|spec
operator|==
name|SH_CSS_SHADERS_SPEC
return|;
block|}
end_function
begin_namespace
namespace|namespace
block|{
DECL|function|InitializeSymbolTable
name|bool
name|InitializeSymbolTable
parameter_list|(
specifier|const
name|TBuiltInStrings
modifier|&
name|builtInStrings
parameter_list|,
name|ShShaderType
name|type
parameter_list|,
name|ShShaderSpec
name|spec
parameter_list|,
specifier|const
name|ShBuiltInResources
modifier|&
name|resources
parameter_list|,
name|TInfoSink
modifier|&
name|infoSink
parameter_list|,
name|TSymbolTable
modifier|&
name|symbolTable
parameter_list|)
block|{
name|TIntermediate
name|intermediate
argument_list|(
name|infoSink
argument_list|)
decl_stmt|;
name|TExtensionBehavior
name|extBehavior
decl_stmt|;
name|InitExtensionBehavior
argument_list|(
name|resources
argument_list|,
name|extBehavior
argument_list|)
expr_stmt|;
comment|// The builtins deliberately don't specify precisions for the function
comment|// arguments and return types. For that reason we don't try to check them.
name|TParseContext
name|parseContext
argument_list|(
name|symbolTable
argument_list|,
name|extBehavior
argument_list|,
name|intermediate
argument_list|,
name|type
argument_list|,
name|spec
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|,
name|NULL
argument_list|,
name|infoSink
argument_list|)
decl_stmt|;
name|GlobalParseContext
operator|=
operator|&
name|parseContext
expr_stmt|;
name|assert
argument_list|(
name|symbolTable
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
comment|//
comment|// Parse the built-ins.  This should only happen once per
comment|// language symbol table.
comment|//
comment|// Push the symbol table to give it an initial scope.  This
comment|// push should not have a corresponding pop, so that built-ins
comment|// are preserved, and the test for an empty table fails.
comment|//
name|symbolTable
operator|.
name|push
argument_list|()
expr_stmt|;
for|for
control|(
name|TBuiltInStrings
operator|::
name|const_iterator
name|i
init|=
name|builtInStrings
operator|.
name|begin
argument_list|()
init|;
name|i
operator|!=
name|builtInStrings
operator|.
name|end
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|builtInShaders
init|=
name|i
operator|->
name|c_str
argument_list|()
decl_stmt|;
name|int
name|builtInLengths
init|=
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|i
operator|->
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|builtInLengths
operator|<=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|PaParseStrings
argument_list|(
literal|1
argument_list|,
operator|&
name|builtInShaders
argument_list|,
operator|&
name|builtInLengths
argument_list|,
operator|&
name|parseContext
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
literal|"Unable to parse built-ins"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|IdentifyBuiltIns
argument_list|(
name|type
argument_list|,
name|spec
argument_list|,
name|resources
argument_list|,
name|symbolTable
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|class|TScopedPoolAllocator
class|class
name|TScopedPoolAllocator
block|{
public|public:
DECL|function|TScopedPoolAllocator
name|TScopedPoolAllocator
parameter_list|(
name|TPoolAllocator
modifier|*
name|allocator
parameter_list|,
name|bool
name|pushPop
parameter_list|)
member_init_list|:
name|mAllocator
argument_list|(
name|allocator
argument_list|)
member_init_list|,
name|mPushPopAllocator
argument_list|(
name|pushPop
argument_list|)
block|{
if|if
condition|(
name|mPushPopAllocator
condition|)
name|mAllocator
operator|->
name|push
argument_list|()
expr_stmt|;
name|SetGlobalPoolAllocator
argument_list|(
name|mAllocator
argument_list|)
expr_stmt|;
block|}
DECL|function|~TScopedPoolAllocator
name|~
name|TScopedPoolAllocator
parameter_list|()
block|{
name|SetGlobalPoolAllocator
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mPushPopAllocator
condition|)
name|mAllocator
operator|->
name|pop
argument_list|()
expr_stmt|;
block|}
private|private:
DECL|member|mAllocator
name|TPoolAllocator
modifier|*
name|mAllocator
decl_stmt|;
DECL|member|mPushPopAllocator
name|bool
name|mPushPopAllocator
decl_stmt|;
block|}
class|;
block|}
end_namespace
begin_comment
comment|// namespace
end_comment
begin_constructor
DECL|function|TShHandleBase
name|TShHandleBase
operator|::
name|TShHandleBase
parameter_list|()
block|{
name|allocator
operator|.
name|push
argument_list|()
expr_stmt|;
name|SetGlobalPoolAllocator
argument_list|(
operator|&
name|allocator
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~TShHandleBase
name|TShHandleBase
operator|::
name|~
name|TShHandleBase
parameter_list|()
block|{
name|SetGlobalPoolAllocator
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|allocator
operator|.
name|popAll
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_constructor
DECL|function|TCompiler
name|TCompiler
operator|::
name|TCompiler
parameter_list|(
name|ShShaderType
name|type
parameter_list|,
name|ShShaderSpec
name|spec
parameter_list|)
member_init_list|:
name|shaderType
argument_list|(
name|type
argument_list|)
member_init_list|,
name|shaderSpec
argument_list|(
name|spec
argument_list|)
member_init_list|,
name|builtInFunctionEmulator
argument_list|(
name|type
argument_list|)
block|{
name|longNameMap
operator|=
name|LongNameMap
operator|::
name|GetInstance
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~TCompiler
name|TCompiler
operator|::
name|~
name|TCompiler
parameter_list|()
block|{
name|ASSERT
argument_list|(
name|longNameMap
argument_list|)
expr_stmt|;
name|longNameMap
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|Init
name|bool
name|TCompiler
operator|::
name|Init
parameter_list|(
specifier|const
name|ShBuiltInResources
modifier|&
name|resources
parameter_list|)
block|{
name|maxUniformVectors
operator|=
operator|(
name|shaderType
operator|==
name|SH_VERTEX_SHADER
operator|)
condition|?
name|resources
operator|.
name|MaxVertexUniformVectors
else|:
name|resources
operator|.
name|MaxFragmentUniformVectors
expr_stmt|;
name|TScopedPoolAllocator
name|scopedAlloc
argument_list|(
operator|&
name|allocator
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// Generate built-in symbol table.
if|if
condition|(
operator|!
name|InitBuiltInSymbolTable
argument_list|(
name|resources
argument_list|)
condition|)
return|return
literal|false
return|;
name|InitExtensionBehavior
argument_list|(
name|resources
argument_list|,
name|extensionBehavior
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|compile
name|bool
name|TCompiler
operator|::
name|compile
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
name|shaderStrings
index|[]
parameter_list|,
specifier|const
name|int
name|numStrings
parameter_list|,
name|int
name|compileOptions
parameter_list|)
block|{
name|TScopedPoolAllocator
name|scopedAlloc
argument_list|(
operator|&
name|allocator
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|clearResults
argument_list|()
expr_stmt|;
if|if
condition|(
name|numStrings
operator|==
literal|0
condition|)
return|return
literal|true
return|;
comment|// If compiling for WebGL, validate loop and indexing as well.
if|if
condition|(
name|isWebGLBasedSpec
argument_list|(
name|shaderSpec
argument_list|)
condition|)
name|compileOptions
operator||=
name|SH_VALIDATE_LOOP_INDEXING
expr_stmt|;
comment|// First string is path of source file if flag is set. The actual source follows.
specifier|const
name|char
modifier|*
name|sourcePath
init|=
name|NULL
decl_stmt|;
name|int
name|firstSource
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|compileOptions
operator|&
name|SH_SOURCE_PATH
condition|)
block|{
name|sourcePath
operator|=
name|shaderStrings
index|[
literal|0
index|]
expr_stmt|;
operator|++
name|firstSource
expr_stmt|;
block|}
name|TIntermediate
name|intermediate
argument_list|(
name|infoSink
argument_list|)
decl_stmt|;
name|TParseContext
name|parseContext
argument_list|(
name|symbolTable
argument_list|,
name|extensionBehavior
argument_list|,
name|intermediate
argument_list|,
name|shaderType
argument_list|,
name|shaderSpec
argument_list|,
name|compileOptions
argument_list|,
literal|true
argument_list|,
name|sourcePath
argument_list|,
name|infoSink
argument_list|)
decl_stmt|;
name|GlobalParseContext
operator|=
operator|&
name|parseContext
expr_stmt|;
comment|// We preserve symbols at the built-in level from compile-to-compile.
comment|// Start pushing the user-defined symbols at global level.
name|symbolTable
operator|.
name|push
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|symbolTable
operator|.
name|atGlobalLevel
argument_list|()
condition|)
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
literal|"Wrong symbol table level"
argument_list|)
expr_stmt|;
comment|// Parse shader.
name|bool
name|success
init|=
operator|(
name|PaParseStrings
argument_list|(
name|numStrings
operator|-
name|firstSource
argument_list|,
operator|&
name|shaderStrings
index|[
name|firstSource
index|]
argument_list|,
name|NULL
argument_list|,
operator|&
name|parseContext
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|parseContext
operator|.
name|treeRoot
operator|!=
name|NULL
operator|)
decl_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|TIntermNode
modifier|*
name|root
init|=
name|parseContext
operator|.
name|treeRoot
decl_stmt|;
name|success
operator|=
name|intermediate
operator|.
name|postProcess
argument_list|(
name|root
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|success
operator|=
name|detectRecursion
argument_list|(
name|root
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
operator|&&
operator|(
name|compileOptions
operator|&
name|SH_VALIDATE_LOOP_INDEXING
operator|)
condition|)
name|success
operator|=
name|validateLimitations
argument_list|(
name|root
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
operator|&&
operator|(
name|compileOptions
operator|&
name|SH_TIMING_RESTRICTIONS
operator|)
condition|)
name|success
operator|=
name|enforceTimingRestrictions
argument_list|(
name|root
argument_list|,
operator|(
name|compileOptions
operator|&
name|SH_DEPENDENCY_GRAPH
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
operator|&&
name|shaderSpec
operator|==
name|SH_CSS_SHADERS_SPEC
condition|)
name|rewriteCSSShader
argument_list|(
name|root
argument_list|)
expr_stmt|;
comment|// Unroll for-loop markup needs to happen after validateLimitations pass.
if|if
condition|(
name|success
operator|&&
operator|(
name|compileOptions
operator|&
name|SH_UNROLL_FOR_LOOP_WITH_INTEGER_INDEX
operator|)
condition|)
name|ForLoopUnroll
operator|::
name|MarkForLoopsWithIntegerIndicesForUnrolling
argument_list|(
name|root
argument_list|)
expr_stmt|;
comment|// Built-in function emulation needs to happen after validateLimitations pass.
if|if
condition|(
name|success
operator|&&
operator|(
name|compileOptions
operator|&
name|SH_EMULATE_BUILT_IN_FUNCTIONS
operator|)
condition|)
name|builtInFunctionEmulator
operator|.
name|MarkBuiltInFunctionsForEmulation
argument_list|(
name|root
argument_list|)
expr_stmt|;
comment|// Call mapLongVariableNames() before collectAttribsUniforms() so in
comment|// collectAttribsUniforms() we already have the mapped symbol names and
comment|// we could composite mapped and original variable names.
if|if
condition|(
name|success
operator|&&
operator|(
name|compileOptions
operator|&
name|SH_MAP_LONG_VARIABLE_NAMES
operator|)
condition|)
name|mapLongVariableNames
argument_list|(
name|root
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
operator|&&
operator|(
name|compileOptions
operator|&
name|SH_ATTRIBUTES_UNIFORMS
operator|)
condition|)
block|{
name|collectAttribsUniforms
argument_list|(
name|root
argument_list|)
expr_stmt|;
if|if
condition|(
name|compileOptions
operator|&
name|SH_ENFORCE_PACKING_RESTRICTIONS
condition|)
block|{
name|success
operator|=
name|enforcePackingRestrictions
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixError
argument_list|,
literal|"too many uniforms"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|success
operator|&&
operator|(
name|compileOptions
operator|&
name|SH_INTERMEDIATE_TREE
operator|)
condition|)
name|intermediate
operator|.
name|outputTree
argument_list|(
name|root
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
operator|&&
operator|(
name|compileOptions
operator|&
name|SH_OBJECT_CODE
operator|)
condition|)
name|translate
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
comment|// Cleanup memory.
name|intermediate
operator|.
name|remove
argument_list|(
name|parseContext
operator|.
name|treeRoot
argument_list|)
expr_stmt|;
comment|// Ensure symbol table is returned to the built-in level,
comment|// throwing away all but the built-ins.
while|while
condition|(
operator|!
name|symbolTable
operator|.
name|atBuiltInLevel
argument_list|()
condition|)
name|symbolTable
operator|.
name|pop
argument_list|()
expr_stmt|;
return|return
name|success
return|;
block|}
end_function
begin_function
DECL|function|InitBuiltInSymbolTable
name|bool
name|TCompiler
operator|::
name|InitBuiltInSymbolTable
parameter_list|(
specifier|const
name|ShBuiltInResources
modifier|&
name|resources
parameter_list|)
block|{
name|TBuiltIns
name|builtIns
decl_stmt|;
name|builtIns
operator|.
name|initialize
argument_list|(
name|shaderType
argument_list|,
name|shaderSpec
argument_list|,
name|resources
argument_list|)
expr_stmt|;
return|return
name|InitializeSymbolTable
argument_list|(
name|builtIns
operator|.
name|getBuiltInStrings
argument_list|()
argument_list|,
name|shaderType
argument_list|,
name|shaderSpec
argument_list|,
name|resources
argument_list|,
name|infoSink
argument_list|,
name|symbolTable
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|clearResults
name|void
name|TCompiler
operator|::
name|clearResults
parameter_list|()
block|{
name|infoSink
operator|.
name|info
operator|.
name|erase
argument_list|()
expr_stmt|;
name|infoSink
operator|.
name|obj
operator|.
name|erase
argument_list|()
expr_stmt|;
name|infoSink
operator|.
name|debug
operator|.
name|erase
argument_list|()
expr_stmt|;
name|attribs
operator|.
name|clear
argument_list|()
expr_stmt|;
name|uniforms
operator|.
name|clear
argument_list|()
expr_stmt|;
name|builtInFunctionEmulator
operator|.
name|Cleanup
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|detectRecursion
name|bool
name|TCompiler
operator|::
name|detectRecursion
parameter_list|(
name|TIntermNode
modifier|*
name|root
parameter_list|)
block|{
name|DetectRecursion
name|detect
decl_stmt|;
name|root
operator|->
name|traverse
argument_list|(
operator|&
name|detect
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|detect
operator|.
name|detectRecursion
argument_list|()
condition|)
block|{
case|case
name|DetectRecursion
operator|::
name|kErrorNone
case|:
return|return
literal|true
return|;
case|case
name|DetectRecursion
operator|::
name|kErrorMissingMain
case|:
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixError
argument_list|,
literal|"Missing main()"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
case|case
name|DetectRecursion
operator|::
name|kErrorRecursion
case|:
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixError
argument_list|,
literal|"Function recursion detected"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
end_function
begin_function
DECL|function|rewriteCSSShader
name|void
name|TCompiler
operator|::
name|rewriteCSSShader
parameter_list|(
name|TIntermNode
modifier|*
name|root
parameter_list|)
block|{
name|RenameFunction
name|renamer
argument_list|(
literal|"main("
argument_list|,
literal|"css_main("
argument_list|)
decl_stmt|;
name|root
operator|->
name|traverse
argument_list|(
operator|&
name|renamer
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|validateLimitations
name|bool
name|TCompiler
operator|::
name|validateLimitations
parameter_list|(
name|TIntermNode
modifier|*
name|root
parameter_list|)
block|{
name|ValidateLimitations
name|validate
argument_list|(
name|shaderType
argument_list|,
name|infoSink
operator|.
name|info
argument_list|)
decl_stmt|;
name|root
operator|->
name|traverse
argument_list|(
operator|&
name|validate
argument_list|)
expr_stmt|;
return|return
name|validate
operator|.
name|numErrors
argument_list|()
operator|==
literal|0
return|;
block|}
end_function
begin_function
DECL|function|enforceTimingRestrictions
name|bool
name|TCompiler
operator|::
name|enforceTimingRestrictions
parameter_list|(
name|TIntermNode
modifier|*
name|root
parameter_list|,
name|bool
name|outputGraph
parameter_list|)
block|{
if|if
condition|(
name|shaderSpec
operator|!=
name|SH_WEBGL_SPEC
condition|)
block|{
name|infoSink
operator|.
name|info
operator|<<
literal|"Timing restrictions must be enforced under the WebGL spec."
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|shaderType
operator|==
name|SH_FRAGMENT_SHADER
condition|)
block|{
name|TDependencyGraph
name|graph
argument_list|(
name|root
argument_list|)
decl_stmt|;
comment|// Output any errors first.
name|bool
name|success
init|=
name|enforceFragmentShaderTimingRestrictions
argument_list|(
name|graph
argument_list|)
decl_stmt|;
comment|// Then, output the dependency graph.
if|if
condition|(
name|outputGraph
condition|)
block|{
name|TDependencyGraphOutput
name|output
argument_list|(
name|infoSink
operator|.
name|info
argument_list|)
decl_stmt|;
name|output
operator|.
name|outputAllSpanningTrees
argument_list|(
name|graph
argument_list|)
expr_stmt|;
block|}
return|return
name|success
return|;
block|}
else|else
block|{
return|return
name|enforceVertexShaderTimingRestrictions
argument_list|(
name|root
argument_list|)
return|;
block|}
block|}
end_function
begin_function
DECL|function|enforceFragmentShaderTimingRestrictions
name|bool
name|TCompiler
operator|::
name|enforceFragmentShaderTimingRestrictions
parameter_list|(
specifier|const
name|TDependencyGraph
modifier|&
name|graph
parameter_list|)
block|{
name|RestrictFragmentShaderTiming
name|restrictor
argument_list|(
name|infoSink
operator|.
name|info
argument_list|)
decl_stmt|;
name|restrictor
operator|.
name|enforceRestrictions
argument_list|(
name|graph
argument_list|)
expr_stmt|;
return|return
name|restrictor
operator|.
name|numErrors
argument_list|()
operator|==
literal|0
return|;
block|}
end_function
begin_function
DECL|function|enforceVertexShaderTimingRestrictions
name|bool
name|TCompiler
operator|::
name|enforceVertexShaderTimingRestrictions
parameter_list|(
name|TIntermNode
modifier|*
name|root
parameter_list|)
block|{
name|RestrictVertexShaderTiming
name|restrictor
argument_list|(
name|infoSink
operator|.
name|info
argument_list|)
decl_stmt|;
name|restrictor
operator|.
name|enforceRestrictions
argument_list|(
name|root
argument_list|)
expr_stmt|;
return|return
name|restrictor
operator|.
name|numErrors
argument_list|()
operator|==
literal|0
return|;
block|}
end_function
begin_function
DECL|function|collectAttribsUniforms
name|void
name|TCompiler
operator|::
name|collectAttribsUniforms
parameter_list|(
name|TIntermNode
modifier|*
name|root
parameter_list|)
block|{
name|CollectAttribsUniforms
name|collect
argument_list|(
name|attribs
argument_list|,
name|uniforms
argument_list|)
decl_stmt|;
name|root
operator|->
name|traverse
argument_list|(
operator|&
name|collect
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|enforcePackingRestrictions
name|bool
name|TCompiler
operator|::
name|enforcePackingRestrictions
parameter_list|()
block|{
name|VariablePacker
name|packer
decl_stmt|;
return|return
name|packer
operator|.
name|CheckVariablesWithinPackingLimits
argument_list|(
name|maxUniformVectors
argument_list|,
name|uniforms
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|mapLongVariableNames
name|void
name|TCompiler
operator|::
name|mapLongVariableNames
parameter_list|(
name|TIntermNode
modifier|*
name|root
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|longNameMap
argument_list|)
expr_stmt|;
name|MapLongVariableNames
name|map
argument_list|(
name|longNameMap
argument_list|)
decl_stmt|;
name|root
operator|->
name|traverse
argument_list|(
operator|&
name|map
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|getMappedNameMaxLength
name|int
name|TCompiler
operator|::
name|getMappedNameMaxLength
parameter_list|()
specifier|const
block|{
return|return
name|MAX_SHORTENED_IDENTIFIER_SIZE
operator|+
literal|1
return|;
block|}
end_function
begin_function
DECL|function|getExtensionBehavior
specifier|const
name|TExtensionBehavior
modifier|&
name|TCompiler
operator|::
name|getExtensionBehavior
parameter_list|()
specifier|const
block|{
return|return
name|extensionBehavior
return|;
block|}
end_function
begin_function
DECL|function|getBuiltInFunctionEmulator
specifier|const
name|BuiltInFunctionEmulator
modifier|&
name|TCompiler
operator|::
name|getBuiltInFunctionEmulator
parameter_list|()
specifier|const
block|{
return|return
name|builtInFunctionEmulator
return|;
block|}
end_function
end_unit
