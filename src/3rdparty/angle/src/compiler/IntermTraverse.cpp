begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2010 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|"compiler/intermediate.h"
end_include
begin_comment
comment|//
end_comment
begin_comment
comment|// Traverse the intermediate representation tree, and
end_comment
begin_comment
comment|// call a node type specific function for each node.
end_comment
begin_comment
comment|// Done recursively through the member function Traverse().
end_comment
begin_comment
comment|// Node types can be skipped if their function to call is 0,
end_comment
begin_comment
comment|// but their subtree will still be traversed.
end_comment
begin_comment
comment|// Nodes with children can have their whole subtree skipped
end_comment
begin_comment
comment|// if preVisit is turned on and the type specific function
end_comment
begin_comment
comment|// returns false.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// preVisit, postVisit, and rightToLeft control what order
end_comment
begin_comment
comment|// nodes are visited in.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Traversal functions for terminals are straighforward....
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|traverse
name|void
name|TIntermSymbol
operator|::
name|traverse
parameter_list|(
name|TIntermTraverser
modifier|*
name|it
parameter_list|)
block|{
name|it
operator|->
name|visitSymbol
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|traverse
name|void
name|TIntermConstantUnion
operator|::
name|traverse
parameter_list|(
name|TIntermTraverser
modifier|*
name|it
parameter_list|)
block|{
name|it
operator|->
name|visitConstantUnion
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Traverse a binary node.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|traverse
name|void
name|TIntermBinary
operator|::
name|traverse
parameter_list|(
name|TIntermTraverser
modifier|*
name|it
parameter_list|)
block|{
name|bool
name|visit
init|=
literal|true
decl_stmt|;
comment|//
comment|// visit the node before children if pre-visiting.
comment|//
if|if
condition|(
name|it
operator|->
name|preVisit
condition|)
block|{
name|visit
operator|=
name|it
operator|->
name|visitBinary
argument_list|(
name|PreVisit
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// Visit the children, in the right order.
comment|//
if|if
condition|(
name|visit
condition|)
block|{
name|it
operator|->
name|incrementDepth
argument_list|()
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|rightToLeft
condition|)
block|{
if|if
condition|(
name|right
condition|)
block|{
name|right
operator|->
name|traverse
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|it
operator|->
name|inVisit
condition|)
block|{
name|visit
operator|=
name|it
operator|->
name|visitBinary
argument_list|(
name|InVisit
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|visit
operator|&&
name|left
condition|)
block|{
name|left
operator|->
name|traverse
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|left
condition|)
block|{
name|left
operator|->
name|traverse
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|it
operator|->
name|inVisit
condition|)
block|{
name|visit
operator|=
name|it
operator|->
name|visitBinary
argument_list|(
name|InVisit
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|visit
operator|&&
name|right
condition|)
block|{
name|right
operator|->
name|traverse
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
block|}
name|it
operator|->
name|decrementDepth
argument_list|()
expr_stmt|;
block|}
comment|//
comment|// Visit the node after the children, if requested and the traversal
comment|// hasn't been cancelled yet.
comment|//
if|if
condition|(
name|visit
operator|&&
name|it
operator|->
name|postVisit
condition|)
block|{
name|it
operator|->
name|visitBinary
argument_list|(
name|PostVisit
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Traverse a unary node.  Same comments in binary node apply here.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|traverse
name|void
name|TIntermUnary
operator|::
name|traverse
parameter_list|(
name|TIntermTraverser
modifier|*
name|it
parameter_list|)
block|{
name|bool
name|visit
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|it
operator|->
name|preVisit
condition|)
name|visit
operator|=
name|it
operator|->
name|visitUnary
argument_list|(
name|PreVisit
argument_list|,
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|visit
condition|)
block|{
name|it
operator|->
name|incrementDepth
argument_list|()
expr_stmt|;
name|operand
operator|->
name|traverse
argument_list|(
name|it
argument_list|)
expr_stmt|;
name|it
operator|->
name|decrementDepth
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|visit
operator|&&
name|it
operator|->
name|postVisit
condition|)
name|it
operator|->
name|visitUnary
argument_list|(
name|PostVisit
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Traverse an aggregate node.  Same comments in binary node apply here.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|traverse
name|void
name|TIntermAggregate
operator|::
name|traverse
parameter_list|(
name|TIntermTraverser
modifier|*
name|it
parameter_list|)
block|{
name|bool
name|visit
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|it
operator|->
name|preVisit
condition|)
block|{
name|visit
operator|=
name|it
operator|->
name|visitAggregate
argument_list|(
name|PreVisit
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|visit
condition|)
block|{
name|it
operator|->
name|incrementDepth
argument_list|()
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|rightToLeft
condition|)
block|{
for|for
control|(
name|TIntermSequence
operator|::
name|reverse_iterator
name|sit
init|=
name|sequence
operator|.
name|rbegin
argument_list|()
init|;
name|sit
operator|!=
name|sequence
operator|.
name|rend
argument_list|()
condition|;
name|sit
operator|++
control|)
block|{
operator|(
operator|*
name|sit
operator|)
operator|->
name|traverse
argument_list|(
name|it
argument_list|)
expr_stmt|;
if|if
condition|(
name|visit
operator|&&
name|it
operator|->
name|inVisit
condition|)
block|{
if|if
condition|(
operator|*
name|sit
operator|!=
name|sequence
operator|.
name|front
argument_list|()
condition|)
block|{
name|visit
operator|=
name|it
operator|->
name|visitAggregate
argument_list|(
name|InVisit
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|TIntermSequence
operator|::
name|iterator
name|sit
init|=
name|sequence
operator|.
name|begin
argument_list|()
init|;
name|sit
operator|!=
name|sequence
operator|.
name|end
argument_list|()
condition|;
name|sit
operator|++
control|)
block|{
operator|(
operator|*
name|sit
operator|)
operator|->
name|traverse
argument_list|(
name|it
argument_list|)
expr_stmt|;
if|if
condition|(
name|visit
operator|&&
name|it
operator|->
name|inVisit
condition|)
block|{
if|if
condition|(
operator|*
name|sit
operator|!=
name|sequence
operator|.
name|back
argument_list|()
condition|)
block|{
name|visit
operator|=
name|it
operator|->
name|visitAggregate
argument_list|(
name|InVisit
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|it
operator|->
name|decrementDepth
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|visit
operator|&&
name|it
operator|->
name|postVisit
condition|)
block|{
name|it
operator|->
name|visitAggregate
argument_list|(
name|PostVisit
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Traverse a selection node.  Same comments in binary node apply here.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|traverse
name|void
name|TIntermSelection
operator|::
name|traverse
parameter_list|(
name|TIntermTraverser
modifier|*
name|it
parameter_list|)
block|{
name|bool
name|visit
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|it
operator|->
name|preVisit
condition|)
name|visit
operator|=
name|it
operator|->
name|visitSelection
argument_list|(
name|PreVisit
argument_list|,
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|visit
condition|)
block|{
name|it
operator|->
name|incrementDepth
argument_list|()
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|rightToLeft
condition|)
block|{
if|if
condition|(
name|falseBlock
condition|)
name|falseBlock
operator|->
name|traverse
argument_list|(
name|it
argument_list|)
expr_stmt|;
if|if
condition|(
name|trueBlock
condition|)
name|trueBlock
operator|->
name|traverse
argument_list|(
name|it
argument_list|)
expr_stmt|;
name|condition
operator|->
name|traverse
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|condition
operator|->
name|traverse
argument_list|(
name|it
argument_list|)
expr_stmt|;
if|if
condition|(
name|trueBlock
condition|)
name|trueBlock
operator|->
name|traverse
argument_list|(
name|it
argument_list|)
expr_stmt|;
if|if
condition|(
name|falseBlock
condition|)
name|falseBlock
operator|->
name|traverse
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
name|it
operator|->
name|decrementDepth
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|visit
operator|&&
name|it
operator|->
name|postVisit
condition|)
name|it
operator|->
name|visitSelection
argument_list|(
name|PostVisit
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Traverse a loop node.  Same comments in binary node apply here.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|traverse
name|void
name|TIntermLoop
operator|::
name|traverse
parameter_list|(
name|TIntermTraverser
modifier|*
name|it
parameter_list|)
block|{
name|bool
name|visit
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|it
operator|->
name|preVisit
condition|)
block|{
name|visit
operator|=
name|it
operator|->
name|visitLoop
argument_list|(
name|PreVisit
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|visit
condition|)
block|{
name|it
operator|->
name|incrementDepth
argument_list|()
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|rightToLeft
condition|)
block|{
if|if
condition|(
name|expr
condition|)
block|{
name|expr
operator|->
name|traverse
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|body
condition|)
block|{
name|body
operator|->
name|traverse
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cond
condition|)
block|{
name|cond
operator|->
name|traverse
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|cond
condition|)
block|{
name|cond
operator|->
name|traverse
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|body
condition|)
block|{
name|body
operator|->
name|traverse
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expr
condition|)
block|{
name|expr
operator|->
name|traverse
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
block|}
name|it
operator|->
name|decrementDepth
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|visit
operator|&&
name|it
operator|->
name|postVisit
condition|)
block|{
name|it
operator|->
name|visitLoop
argument_list|(
name|PostVisit
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Traverse a branch node.  Same comments in binary node apply here.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|traverse
name|void
name|TIntermBranch
operator|::
name|traverse
parameter_list|(
name|TIntermTraverser
modifier|*
name|it
parameter_list|)
block|{
name|bool
name|visit
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|it
operator|->
name|preVisit
condition|)
name|visit
operator|=
name|it
operator|->
name|visitBranch
argument_list|(
name|PreVisit
argument_list|,
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|visit
operator|&&
name|expression
condition|)
block|{
name|it
operator|->
name|incrementDepth
argument_list|()
expr_stmt|;
name|expression
operator|->
name|traverse
argument_list|(
name|it
argument_list|)
expr_stmt|;
name|it
operator|->
name|decrementDepth
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|visit
operator|&&
name|it
operator|->
name|postVisit
condition|)
name|it
operator|->
name|visitBranch
argument_list|(
name|PostVisit
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
end_function
end_unit
