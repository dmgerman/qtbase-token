begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2010 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|_COMMON_INCLUDED_
end_ifndef
begin_define
DECL|macro|_COMMON_INCLUDED_
define|#
directive|define
name|_COMMON_INCLUDED_
end_define
begin_include
include|#
directive|include
file|<map>
end_include
begin_include
include|#
directive|include
file|<sstream>
end_include
begin_include
include|#
directive|include
file|<string>
end_include
begin_include
include|#
directive|include
file|<vector>
end_include
begin_include
include|#
directive|include
file|"compiler/PoolAlloc.h"
end_include
begin_comment
comment|// We need two pieces of information to report errors/warnings - string and
end_comment
begin_comment
comment|// line number. We encode these into a single int so that it can be easily
end_comment
begin_comment
comment|// incremented/decremented by lexer. The right SOURCE_LOC_LINE_SIZE bits store
end_comment
begin_comment
comment|// line number while the rest store the string number. Since the shaders are
end_comment
begin_comment
comment|// usually small, we should not run out of memory. SOURCE_LOC_LINE_SIZE
end_comment
begin_comment
comment|// can be increased to alleviate this issue.
end_comment
begin_typedef
DECL|typedef|TSourceLoc
typedef|typedef
name|int
name|TSourceLoc
typedef|;
end_typedef
begin_decl_stmt
DECL|variable|SOURCE_LOC_LINE_SIZE
specifier|const
name|unsigned
name|int
name|SOURCE_LOC_LINE_SIZE
init|=
literal|16
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|SOURCE_LOC_LINE_SIZE
comment|// in bits.
end_comment
begin_decl_stmt
DECL|variable|SOURCE_LOC_LINE_MASK
specifier|const
name|unsigned
name|int
name|SOURCE_LOC_LINE_MASK
init|=
operator|(
literal|1
operator|<<
name|SOURCE_LOC_LINE_SIZE
operator|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|EncodeSourceLoc
specifier|inline
name|TSourceLoc
name|EncodeSourceLoc
parameter_list|(
name|int
name|string
parameter_list|,
name|int
name|line
parameter_list|)
block|{
return|return
operator|(
name|string
operator|<<
name|SOURCE_LOC_LINE_SIZE
operator|)
operator||
operator|(
name|line
operator|&
name|SOURCE_LOC_LINE_MASK
operator|)
return|;
block|}
end_function
begin_function
DECL|function|DecodeSourceLoc
specifier|inline
name|void
name|DecodeSourceLoc
parameter_list|(
name|TSourceLoc
name|loc
parameter_list|,
name|int
modifier|*
name|string
parameter_list|,
name|int
modifier|*
name|line
parameter_list|)
block|{
if|if
condition|(
name|string
condition|)
operator|*
name|string
operator|=
name|loc
operator|>>
name|SOURCE_LOC_LINE_SIZE
expr_stmt|;
if|if
condition|(
name|line
condition|)
operator|*
name|line
operator|=
name|loc
operator|&
name|SOURCE_LOC_LINE_MASK
expr_stmt|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Put POOL_ALLOCATOR_NEW_DELETE in base classes to make them use this scheme.
end_comment
begin_comment
comment|//
end_comment
begin_define
DECL|macro|POOL_ALLOCATOR_NEW_DELETE
define|#
directive|define
name|POOL_ALLOCATOR_NEW_DELETE
parameter_list|(
name|A
parameter_list|)
define|\
value|void* operator new(size_t s) { return (A).allocate(s); }          \     void* operator new(size_t, void *_Where) { return (_Where);	}     \     void operator delete(void*) { }                                   \     void operator delete(void *, void *) { }                          \     void* operator new[](size_t s) { return (A).allocate(s); }        \     void* operator new[](size_t, void *_Where) { return (_Where);	} \     void operator delete[](void*) { }                                 \     void operator delete[](void *, void *) { }
end_define
begin_comment
comment|//
end_comment
begin_comment
comment|// Pool version of string.
end_comment
begin_comment
comment|//
end_comment
begin_typedef
DECL|typedef|TStringAllocator
typedef|typedef
name|pool_allocator
operator|<
name|char
operator|>
name|TStringAllocator
expr_stmt|;
end_typedef
begin_typedef
DECL|typedef|TString
typedef|typedef
name|std
operator|::
name|basic_string
operator|<
name|char
operator|,
name|std
operator|::
name|char_traits
operator|<
name|char
operator|>
operator|,
name|TStringAllocator
operator|>
name|TString
expr_stmt|;
end_typedef
begin_typedef
DECL|typedef|TStringStream
typedef|typedef
name|std
operator|::
name|basic_ostringstream
operator|<
name|char
operator|,
name|std
operator|::
name|char_traits
operator|<
name|char
operator|>
operator|,
name|TStringAllocator
operator|>
name|TStringStream
expr_stmt|;
end_typedef
begin_function
DECL|function|NewPoolTString
specifier|inline
name|TString
modifier|*
name|NewPoolTString
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|void
modifier|*
name|memory
init|=
name|GlobalPoolAllocator
operator|.
name|allocate
argument_list|(
sizeof|sizeof
argument_list|(
name|TString
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|new
argument_list|(
argument|memory
argument_list|)
name|TString
argument_list|(
name|s
argument_list|)
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Persistent string memory.  Should only be used for strings that survive
end_comment
begin_comment
comment|// across compiles.
end_comment
begin_comment
comment|//
end_comment
begin_define
DECL|macro|TPersistString
define|#
directive|define
name|TPersistString
value|std::string
end_define
begin_define
DECL|macro|TPersistStringStream
define|#
directive|define
name|TPersistStringStream
value|std::ostringstream
end_define
begin_comment
comment|//
end_comment
begin_comment
comment|// Pool allocator versions of vectors, lists, and maps
end_comment
begin_comment
comment|//
end_comment
begin_expr_stmt
DECL|variable|T
name|template
operator|<
name|class
name|T
operator|>
name|class
name|TVector
operator|:
name|public
name|std
operator|::
name|vector
operator|<
name|T
operator|,
name|pool_allocator
operator|<
name|T
operator|>
expr|>
block|{
name|public
operator|:
typedef|typedef
name|typename
name|std
operator|::
name|vector
operator|<
name|T
operator|,
name|pool_allocator
operator|<
name|T
operator|>
expr|>
operator|::
name|size_type
name|size_type
expr_stmt|;
name|TVector
argument_list|()
operator|:
name|std
operator|::
name|vector
operator|<
name|T
operator|,
name|pool_allocator
operator|<
name|T
operator|>
block|>
operator|(
operator|)
block|{}
name|TVector
argument_list|(
specifier|const
name|pool_allocator
operator|<
name|T
operator|>
operator|&
name|a
argument_list|)
operator|:
name|std
operator|::
name|vector
operator|<
name|T
operator|,
name|pool_allocator
operator|<
name|T
operator|>
expr|>
operator|(
name|a
operator|)
block|{}
name|TVector
argument_list|(
argument|size_type i
argument_list|)
operator|:
name|std
operator|::
name|vector
operator|<
name|T
operator|,
name|pool_allocator
operator|<
name|T
operator|>
expr|>
operator|(
name|i
operator|)
block|{}
end_expr_stmt
begin_expr_stmt
unit|};
DECL|variable|K
DECL|variable|D
DECL|variable|CMP
name|template
operator|<
name|class
name|K
operator|,
name|class
name|D
operator|,
name|class
name|CMP
operator|=
name|std
operator|::
name|less
operator|<
name|K
operator|>
expr|>
DECL|variable|D
DECL|variable|CMP
DECL|member|K
name|class
name|TMap
operator|:
name|public
name|std
operator|::
name|map
operator|<
name|K
operator|,
name|D
operator|,
name|CMP
operator|,
name|pool_allocator
operator|<
name|std
operator|::
name|pair
operator|<
specifier|const
name|K
operator|,
name|D
operator|>
expr|>
operator|>
block|{
name|public
operator|:
typedef|typedef
name|pool_allocator
operator|<
name|std
operator|::
name|pair
operator|<
specifier|const
name|K
operator|,
name|D
operator|>
expr|>
name|tAllocator
expr_stmt|;
name|TMap
argument_list|()
operator|:
name|std
operator|::
name|map
operator|<
name|K
operator|,
name|D
operator|,
name|CMP
operator|,
name|tAllocator
operator|>
operator|(
operator|)
block|{}
comment|// use correct two-stage name lookup supported in gcc 3.4 and above
name|TMap
argument_list|(
specifier|const
name|tAllocator
operator|&
name|a
argument_list|)
operator|:
name|std
operator|::
name|map
operator|<
name|K
operator|,
name|D
operator|,
name|CMP
operator|,
name|tAllocator
operator|>
operator|(
name|std
operator|::
name|map
operator|<
name|K
operator|,
name|D
operator|,
name|CMP
operator|,
name|tAllocator
operator|>
operator|::
name|key_compare
argument_list|()
operator|,
name|a
operator|)
block|{}
end_expr_stmt
begin_endif
unit|};
endif|#
directive|endif
end_endif
begin_comment
comment|// _COMMON_INCLUDED_
end_comment
end_unit
