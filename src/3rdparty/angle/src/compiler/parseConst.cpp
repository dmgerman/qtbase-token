begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2010 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|"compiler/ParseHelper.h"
end_include
begin_comment
comment|//
end_comment
begin_comment
comment|// Use this class to carry along data from node to node in
end_comment
begin_comment
comment|// the traversal
end_comment
begin_comment
comment|//
end_comment
begin_class
DECL|class|TConstTraverser
class|class
name|TConstTraverser
super|:
specifier|public
name|TIntermTraverser
block|{
public|public:
DECL|function|TConstTraverser
name|TConstTraverser
parameter_list|(
name|ConstantUnion
modifier|*
name|cUnion
parameter_list|,
name|bool
name|singleConstParam
parameter_list|,
name|TOperator
name|constructType
parameter_list|,
name|TInfoSink
modifier|&
name|sink
parameter_list|,
name|TSymbolTable
modifier|&
name|symTable
parameter_list|,
name|TType
modifier|&
name|t
parameter_list|)
member_init_list|:
name|error
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|index
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|unionArray
argument_list|(
name|cUnion
argument_list|)
member_init_list|,
name|type
argument_list|(
name|t
argument_list|)
member_init_list|,
name|constructorType
argument_list|(
name|constructType
argument_list|)
member_init_list|,
name|singleConstantParam
argument_list|(
name|singleConstParam
argument_list|)
member_init_list|,
name|infoSink
argument_list|(
name|sink
argument_list|)
member_init_list|,
name|symbolTable
argument_list|(
name|symTable
argument_list|)
member_init_list|,
name|size
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|isMatrix
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|matrixSize
argument_list|(
literal|0
argument_list|)
block|{     }
DECL|member|error
name|bool
name|error
decl_stmt|;
protected|protected:
name|void
name|visitSymbol
parameter_list|(
name|TIntermSymbol
modifier|*
parameter_list|)
function_decl|;
name|void
name|visitConstantUnion
parameter_list|(
name|TIntermConstantUnion
modifier|*
parameter_list|)
function_decl|;
name|bool
name|visitBinary
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermBinary
modifier|*
parameter_list|)
function_decl|;
name|bool
name|visitUnary
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermUnary
modifier|*
parameter_list|)
function_decl|;
name|bool
name|visitSelection
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermSelection
modifier|*
parameter_list|)
function_decl|;
name|bool
name|visitAggregate
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermAggregate
modifier|*
parameter_list|)
function_decl|;
name|bool
name|visitLoop
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermLoop
modifier|*
parameter_list|)
function_decl|;
name|bool
name|visitBranch
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermBranch
modifier|*
parameter_list|)
function_decl|;
DECL|member|index
name|int
name|index
decl_stmt|;
DECL|member|unionArray
name|ConstantUnion
modifier|*
name|unionArray
decl_stmt|;
DECL|member|type
name|TType
name|type
decl_stmt|;
DECL|member|constructorType
name|TOperator
name|constructorType
decl_stmt|;
DECL|member|singleConstantParam
name|bool
name|singleConstantParam
decl_stmt|;
DECL|member|infoSink
name|TInfoSink
modifier|&
name|infoSink
decl_stmt|;
DECL|member|symbolTable
name|TSymbolTable
modifier|&
name|symbolTable
decl_stmt|;
DECL|member|size
name|int
name|size
decl_stmt|;
comment|// size of the constructor ( 4 for vec4)
DECL|member|isMatrix
name|bool
name|isMatrix
decl_stmt|;
DECL|member|matrixSize
name|int
name|matrixSize
decl_stmt|;
comment|// dimension of the matrix (nominal size and not the instance size)
block|}
class|;
end_class
begin_comment
comment|//
end_comment
begin_comment
comment|// The rest of the file are the traversal functions.  The last one
end_comment
begin_comment
comment|// is the one that starts the traversal.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Return true from interior nodes to have the external traversal
end_comment
begin_comment
comment|// continue on to children.  If you process children yourself,
end_comment
begin_comment
comment|// return false.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|visitSymbol
name|void
name|TConstTraverser
operator|::
name|visitSymbol
parameter_list|(
name|TIntermSymbol
modifier|*
name|node
parameter_list|)
block|{
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
literal|"Symbol Node found in constant constructor"
argument_list|,
name|node
operator|->
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
end_function
begin_function
DECL|function|visitBinary
name|bool
name|TConstTraverser
operator|::
name|visitBinary
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermBinary
modifier|*
name|node
parameter_list|)
block|{
name|TQualifier
name|qualifier
init|=
name|node
operator|->
name|getType
argument_list|()
operator|.
name|getQualifier
argument_list|()
decl_stmt|;
if|if
condition|(
name|qualifier
operator|!=
name|EvqConst
condition|)
block|{
name|TString
name|buf
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"'constructor' : assigning non-constant to "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|type
operator|.
name|getCompleteString
argument_list|()
argument_list|)
expr_stmt|;
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixError
argument_list|,
name|buf
operator|.
name|c_str
argument_list|()
argument_list|,
name|node
operator|->
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
name|error
operator|=
literal|true
expr_stmt|;
return|return
literal|false
return|;
block|}
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
literal|"Binary Node found in constant constructor"
argument_list|,
name|node
operator|->
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|visitUnary
name|bool
name|TConstTraverser
operator|::
name|visitUnary
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermUnary
modifier|*
name|node
parameter_list|)
block|{
name|TString
name|buf
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"'constructor' : assigning non-constant to "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|type
operator|.
name|getCompleteString
argument_list|()
argument_list|)
expr_stmt|;
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixError
argument_list|,
name|buf
operator|.
name|c_str
argument_list|()
argument_list|,
name|node
operator|->
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
name|error
operator|=
literal|true
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|visitAggregate
name|bool
name|TConstTraverser
operator|::
name|visitAggregate
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermAggregate
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|isConstructor
argument_list|()
operator|&&
name|node
operator|->
name|getOp
argument_list|()
operator|!=
name|EOpComma
condition|)
block|{
name|TString
name|buf
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"'constructor' : assigning non-constant to "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|type
operator|.
name|getCompleteString
argument_list|()
argument_list|)
expr_stmt|;
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixError
argument_list|,
name|buf
operator|.
name|c_str
argument_list|()
argument_list|,
name|node
operator|->
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
name|error
operator|=
literal|true
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|node
operator|->
name|getSequence
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|error
operator|=
literal|true
expr_stmt|;
return|return
literal|false
return|;
block|}
name|bool
name|flag
init|=
name|node
operator|->
name|getSequence
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|node
operator|->
name|getSequence
argument_list|()
index|[
literal|0
index|]
operator|->
name|getAsTyped
argument_list|()
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
name|singleConstantParam
operator|=
literal|true
expr_stmt|;
name|constructorType
operator|=
name|node
operator|->
name|getOp
argument_list|()
expr_stmt|;
name|size
operator|=
name|node
operator|->
name|getType
argument_list|()
operator|.
name|getObjectSize
argument_list|()
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getType
argument_list|()
operator|.
name|isMatrix
argument_list|()
condition|)
block|{
name|isMatrix
operator|=
literal|true
expr_stmt|;
name|matrixSize
operator|=
name|node
operator|->
name|getType
argument_list|()
operator|.
name|getNominalSize
argument_list|()
expr_stmt|;
block|}
block|}
for|for
control|(
name|TIntermSequence
operator|::
name|iterator
name|p
init|=
name|node
operator|->
name|getSequence
argument_list|()
operator|.
name|begin
argument_list|()
init|;
name|p
operator|!=
name|node
operator|->
name|getSequence
argument_list|()
operator|.
name|end
argument_list|()
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|node
operator|->
name|getOp
argument_list|()
operator|==
name|EOpComma
condition|)
name|index
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|p
operator|)
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag
condition|)
block|{
name|singleConstantParam
operator|=
literal|false
expr_stmt|;
name|constructorType
operator|=
name|EOpNull
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
name|isMatrix
operator|=
literal|false
expr_stmt|;
name|matrixSize
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|visitSelection
name|bool
name|TConstTraverser
operator|::
name|visitSelection
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermSelection
modifier|*
name|node
parameter_list|)
block|{
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
literal|"Selection Node found in constant constructor"
argument_list|,
name|node
operator|->
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
name|error
operator|=
literal|true
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|visitConstantUnion
name|void
name|TConstTraverser
operator|::
name|visitConstantUnion
parameter_list|(
name|TIntermConstantUnion
modifier|*
name|node
parameter_list|)
block|{
name|ConstantUnion
modifier|*
name|leftUnionArray
init|=
name|unionArray
decl_stmt|;
name|int
name|instanceSize
init|=
name|type
operator|.
name|getObjectSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|index
operator|>=
name|instanceSize
condition|)
return|return;
if|if
condition|(
operator|!
name|singleConstantParam
condition|)
block|{
name|int
name|size
init|=
name|node
operator|->
name|getType
argument_list|()
operator|.
name|getObjectSize
argument_list|()
decl_stmt|;
name|ConstantUnion
modifier|*
name|rightUnionArray
init|=
name|node
operator|->
name|getUnionArrayPointer
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|index
operator|>=
name|instanceSize
condition|)
return|return;
name|leftUnionArray
index|[
name|index
index|]
operator|=
name|rightUnionArray
index|[
name|i
index|]
expr_stmt|;
operator|(
name|index
operator|)
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|totalSize
init|=
name|index
operator|+
name|size
decl_stmt|;
name|ConstantUnion
modifier|*
name|rightUnionArray
init|=
name|node
operator|->
name|getUnionArrayPointer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|isMatrix
condition|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|index
init|;
name|i
operator|<
name|totalSize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|instanceSize
condition|)
return|return;
name|leftUnionArray
index|[
name|i
index|]
operator|=
name|rightUnionArray
index|[
name|count
index|]
expr_stmt|;
operator|(
name|index
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getType
argument_list|()
operator|.
name|getObjectSize
argument_list|()
operator|>
literal|1
condition|)
name|count
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// for matrix constructors
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|element
init|=
name|index
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|index
init|;
name|i
operator|<
name|totalSize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|instanceSize
condition|)
return|return;
if|if
condition|(
name|element
operator|-
name|i
operator|==
literal|0
operator|||
operator|(
name|i
operator|-
name|element
operator|)
operator|%
operator|(
name|matrixSize
operator|+
literal|1
operator|)
operator|==
literal|0
condition|)
name|leftUnionArray
index|[
name|i
index|]
operator|=
name|rightUnionArray
index|[
name|count
index|]
expr_stmt|;
else|else
name|leftUnionArray
index|[
name|i
index|]
operator|.
name|setFConst
argument_list|(
literal|0.0f
argument_list|)
expr_stmt|;
operator|(
name|index
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getType
argument_list|()
operator|.
name|getObjectSize
argument_list|()
operator|>
literal|1
condition|)
name|count
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_function
DECL|function|visitLoop
name|bool
name|TConstTraverser
operator|::
name|visitLoop
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermLoop
modifier|*
name|node
parameter_list|)
block|{
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
literal|"Loop Node found in constant constructor"
argument_list|,
name|node
operator|->
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
name|error
operator|=
literal|true
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|visitBranch
name|bool
name|TConstTraverser
operator|::
name|visitBranch
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermBranch
modifier|*
name|node
parameter_list|)
block|{
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
literal|"Branch Node found in constant constructor"
argument_list|,
name|node
operator|->
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
name|error
operator|=
literal|true
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// This function is the one to call externally to start the traversal.
end_comment
begin_comment
comment|// Individual functions can be initialized to 0 to skip processing of that
end_comment
begin_comment
comment|// type of node.  It's children will still be processed.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|parseConstTree
name|bool
name|TIntermediate
operator|::
name|parseConstTree
parameter_list|(
name|TSourceLoc
name|line
parameter_list|,
name|TIntermNode
modifier|*
name|root
parameter_list|,
name|ConstantUnion
modifier|*
name|unionArray
parameter_list|,
name|TOperator
name|constructorType
parameter_list|,
name|TSymbolTable
modifier|&
name|symbolTable
parameter_list|,
name|TType
name|t
parameter_list|,
name|bool
name|singleConstantParam
parameter_list|)
block|{
if|if
condition|(
name|root
operator|==
literal|0
condition|)
return|return
literal|false
return|;
name|TConstTraverser
name|it
argument_list|(
name|unionArray
argument_list|,
name|singleConstantParam
argument_list|,
name|constructorType
argument_list|,
name|infoSink
argument_list|,
name|symbolTable
argument_list|,
name|t
argument_list|)
decl_stmt|;
name|root
operator|->
name|traverse
argument_list|(
operator|&
name|it
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|.
name|error
condition|)
return|return
literal|true
return|;
else|else
return|return
literal|false
return|;
block|}
end_function
end_unit
