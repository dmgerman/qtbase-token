begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2012 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Contains analysis utilities for dealing with HLSL's lack of support for
end_comment
begin_comment
comment|// the use of intrinsic functions which (implicitly or explicitly) compute
end_comment
begin_comment
comment|// gradients of functions with discontinuities.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|"compiler/DetectDiscontinuity.h"
end_include
begin_include
include|#
directive|include
file|"compiler/ParseHelper.h"
end_include
begin_namespace
DECL|namespace|sh
namespace|namespace
name|sh
block|{
DECL|function|traverse
name|bool
name|DetectLoopDiscontinuity
operator|::
name|traverse
parameter_list|(
name|TIntermNode
modifier|*
name|node
parameter_list|)
block|{
name|mLoopDepth
operator|=
literal|0
expr_stmt|;
name|mLoopDiscontinuity
operator|=
literal|false
expr_stmt|;
name|node
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|mLoopDiscontinuity
return|;
block|}
DECL|function|visitLoop
name|bool
name|DetectLoopDiscontinuity
operator|::
name|visitLoop
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermLoop
modifier|*
name|loop
parameter_list|)
block|{
if|if
condition|(
name|visit
operator|==
name|PreVisit
condition|)
block|{
operator|++
name|mLoopDepth
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|visit
operator|==
name|PostVisit
condition|)
block|{
operator|--
name|mLoopDepth
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|visitBranch
name|bool
name|DetectLoopDiscontinuity
operator|::
name|visitBranch
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermBranch
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|mLoopDiscontinuity
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|mLoopDepth
condition|)
block|{
return|return
literal|true
return|;
block|}
switch|switch
condition|(
name|node
operator|->
name|getFlowOp
argument_list|()
condition|)
block|{
case|case
name|EOpKill
case|:
break|break;
case|case
name|EOpBreak
case|:
case|case
name|EOpContinue
case|:
case|case
name|EOpReturn
case|:
name|mLoopDiscontinuity
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
operator|!
name|mLoopDiscontinuity
return|;
block|}
DECL|function|visitAggregate
name|bool
name|DetectLoopDiscontinuity
operator|::
name|visitAggregate
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermAggregate
modifier|*
name|node
parameter_list|)
block|{
return|return
operator|!
name|mLoopDiscontinuity
return|;
block|}
DECL|function|containsLoopDiscontinuity
name|bool
name|containsLoopDiscontinuity
parameter_list|(
name|TIntermNode
modifier|*
name|node
parameter_list|)
block|{
name|DetectLoopDiscontinuity
name|detectLoopDiscontinuity
decl_stmt|;
return|return
name|detectLoopDiscontinuity
operator|.
name|traverse
argument_list|(
name|node
argument_list|)
return|;
block|}
DECL|function|traverse
name|bool
name|DetectGradientOperation
operator|::
name|traverse
parameter_list|(
name|TIntermNode
modifier|*
name|node
parameter_list|)
block|{
name|mGradientOperation
operator|=
literal|false
expr_stmt|;
name|node
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|mGradientOperation
return|;
block|}
DECL|function|visitUnary
name|bool
name|DetectGradientOperation
operator|::
name|visitUnary
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermUnary
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|mGradientOperation
condition|)
block|{
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|node
operator|->
name|getOp
argument_list|()
condition|)
block|{
case|case
name|EOpDFdx
case|:
case|case
name|EOpDFdy
case|:
name|mGradientOperation
operator|=
literal|true
expr_stmt|;
default|default:
break|break;
block|}
return|return
operator|!
name|mGradientOperation
return|;
block|}
DECL|function|visitAggregate
name|bool
name|DetectGradientOperation
operator|::
name|visitAggregate
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermAggregate
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|mGradientOperation
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|node
operator|->
name|getOp
argument_list|()
operator|==
name|EOpFunctionCall
condition|)
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|isUserDefined
argument_list|()
condition|)
block|{
name|TString
name|name
init|=
name|TFunction
operator|::
name|unmangleName
argument_list|(
name|node
operator|->
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|==
literal|"texture2D"
operator|||
name|name
operator|==
literal|"texture2DProj"
operator|||
name|name
operator|==
literal|"textureCube"
condition|)
block|{
name|mGradientOperation
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// When a user defined function is called, we have to
comment|// conservatively assume it to contain gradient operations
name|mGradientOperation
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
operator|!
name|mGradientOperation
return|;
block|}
DECL|function|containsGradientOperation
name|bool
name|containsGradientOperation
parameter_list|(
name|TIntermNode
modifier|*
name|node
parameter_list|)
block|{
name|DetectGradientOperation
name|detectGradientOperation
decl_stmt|;
return|return
name|detectGradientOperation
operator|.
name|traverse
argument_list|(
name|node
argument_list|)
return|;
block|}
block|}
end_namespace
end_unit
