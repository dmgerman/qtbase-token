begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2012 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|_TYPES_INCLUDED
end_ifndef
begin_define
DECL|macro|_TYPES_INCLUDED
define|#
directive|define
name|_TYPES_INCLUDED
end_define
begin_include
include|#
directive|include
file|"compiler/BaseTypes.h"
end_include
begin_include
include|#
directive|include
file|"compiler/Common.h"
end_include
begin_include
include|#
directive|include
file|"compiler/debug.h"
end_include
begin_decl_stmt
DECL|variable|TType
name|class
name|TType
decl_stmt|;
end_decl_stmt
begin_struct_decl
struct_decl|struct
name|TPublicType
struct_decl|;
end_struct_decl
begin_comment
comment|//
end_comment
begin_comment
comment|// Need to have association of line numbers to types in a list for building structs.
end_comment
begin_comment
comment|//
end_comment
begin_struct
DECL|struct|TTypeLine
struct|struct
name|TTypeLine
block|{
DECL|member|type
name|TType
modifier|*
name|type
decl_stmt|;
DECL|member|line
name|int
name|line
decl_stmt|;
block|}
struct|;
end_struct
begin_typedef
DECL|typedef|TTypeList
typedef|typedef
name|TVector
operator|<
name|TTypeLine
operator|>
name|TTypeList
expr_stmt|;
end_typedef
begin_function
DECL|function|NewPoolTTypeList
specifier|inline
name|TTypeList
modifier|*
name|NewPoolTTypeList
parameter_list|()
block|{
name|void
modifier|*
name|memory
init|=
name|GlobalPoolAllocator
operator|.
name|allocate
argument_list|(
sizeof|sizeof
argument_list|(
name|TTypeList
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|new
argument_list|(
argument|memory
argument_list|)
name|TTypeList
return|;
block|}
end_function
begin_typedef
DECL|typedef|TTypeList
DECL|typedef|TStructureMap
typedef|typedef
name|TMap
operator|<
name|TTypeList
operator|*
operator|,
name|TTypeList
operator|*
operator|>
name|TStructureMap
expr_stmt|;
end_typedef
begin_typedef
DECL|typedef|TTypeList
DECL|typedef|TStructureMapIterator
typedef|typedef
name|TMap
operator|<
name|TTypeList
operator|*
operator|,
name|TTypeList
operator|*
operator|>
operator|::
name|iterator
name|TStructureMapIterator
expr_stmt|;
end_typedef
begin_comment
comment|//
end_comment
begin_comment
comment|// Base class for things that have a type.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TType
block|{
name|public
label|:
name|POOL_ALLOCATOR_NEW_DELETE
argument_list|(
argument|GlobalPoolAllocator
argument_list|)
name|TType
argument_list|()
block|{}
name|TType
argument_list|(
argument|TBasicType t
argument_list|,
argument|TPrecision p
argument_list|,
argument|TQualifier q = EvqTemporary
argument_list|,
argument|int s =
literal|1
argument_list|,
argument|bool m = false
argument_list|,
argument|bool a = false
argument_list|)
block|:
name|type
argument_list|(
name|t
argument_list|)
operator|,
name|precision
argument_list|(
name|p
argument_list|)
operator|,
name|qualifier
argument_list|(
name|q
argument_list|)
operator|,
name|size
argument_list|(
name|s
argument_list|)
operator|,
name|matrix
argument_list|(
name|m
argument_list|)
operator|,
name|array
argument_list|(
name|a
argument_list|)
operator|,
name|arraySize
argument_list|(
literal|0
argument_list|)
operator|,
name|maxArraySize
argument_list|(
literal|0
argument_list|)
operator|,
name|arrayInformationType
argument_list|(
literal|0
argument_list|)
operator|,
name|structure
argument_list|(
literal|0
argument_list|)
operator|,
name|structureSize
argument_list|(
literal|0
argument_list|)
operator|,
name|deepestStructNesting
argument_list|(
literal|0
argument_list|)
operator|,
name|fieldName
argument_list|(
literal|0
argument_list|)
operator|,
name|mangled
argument_list|(
literal|0
argument_list|)
operator|,
name|typeName
argument_list|(
literal|0
argument_list|)
block|{     }
name|explicit
name|TType
argument_list|(
specifier|const
name|TPublicType
operator|&
name|p
argument_list|)
expr_stmt|;
name|TType
argument_list|(
argument|TTypeList* userDef
argument_list|,
argument|const TString& n
argument_list|,
argument|TPrecision p = EbpUndefined
argument_list|)
block|:
name|type
argument_list|(
name|EbtStruct
argument_list|)
operator|,
name|precision
argument_list|(
name|p
argument_list|)
operator|,
name|qualifier
argument_list|(
name|EvqTemporary
argument_list|)
operator|,
name|size
argument_list|(
literal|1
argument_list|)
operator|,
name|matrix
argument_list|(
name|false
argument_list|)
operator|,
name|array
argument_list|(
name|false
argument_list|)
operator|,
name|arraySize
argument_list|(
literal|0
argument_list|)
operator|,
name|maxArraySize
argument_list|(
literal|0
argument_list|)
operator|,
name|arrayInformationType
argument_list|(
literal|0
argument_list|)
operator|,
name|structure
argument_list|(
name|userDef
argument_list|)
operator|,
name|structureSize
argument_list|(
literal|0
argument_list|)
operator|,
name|deepestStructNesting
argument_list|(
literal|0
argument_list|)
operator|,
name|fieldName
argument_list|(
literal|0
argument_list|)
operator|,
name|mangled
argument_list|(
literal|0
argument_list|)
block|{
name|typeName
operator|=
name|NewPoolTString
argument_list|(
name|n
operator|.
name|c_str
argument_list|()
argument_list|)
block|;     }
name|void
name|copyType
argument_list|(
argument|const TType& copyOf
argument_list|,
argument|TStructureMap& remapper
argument_list|)
block|{
name|type
operator|=
name|copyOf
operator|.
name|type
block|;
name|precision
operator|=
name|copyOf
operator|.
name|precision
block|;
name|qualifier
operator|=
name|copyOf
operator|.
name|qualifier
block|;
name|size
operator|=
name|copyOf
operator|.
name|size
block|;
name|matrix
operator|=
name|copyOf
operator|.
name|matrix
block|;
name|array
operator|=
name|copyOf
operator|.
name|array
block|;
name|arraySize
operator|=
name|copyOf
operator|.
name|arraySize
block|;
name|TStructureMapIterator
name|iter
block|;
if|if
condition|(
name|copyOf
operator|.
name|structure
condition|)
block|{
if|if
condition|(
operator|(
name|iter
operator|=
name|remapper
operator|.
name|find
argument_list|(
name|structure
argument_list|)
operator|)
operator|==
name|remapper
operator|.
name|end
argument_list|()
condition|)
block|{
comment|// create the new structure here
name|structure
operator|=
name|NewPoolTTypeList
argument_list|()
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|copyOf
operator|.
name|structure
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|TTypeLine
name|typeLine
decl_stmt|;
name|typeLine
operator|.
name|line
operator|=
operator|(
operator|*
name|copyOf
operator|.
name|structure
operator|)
index|[
name|i
index|]
operator|.
name|line
expr_stmt|;
name|typeLine
operator|.
name|type
operator|=
operator|(
operator|*
name|copyOf
operator|.
name|structure
operator|)
index|[
name|i
index|]
operator|.
name|type
operator|->
name|clone
argument_list|(
name|remapper
argument_list|)
expr_stmt|;
name|structure
operator|->
name|push_back
argument_list|(
name|typeLine
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|structure
operator|=
name|iter
operator|->
name|second
expr_stmt|;
block|}
block|}
else|else
name|structure
operator|=
literal|0
expr_stmt|;
name|fieldName
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|copyOf
operator|.
name|fieldName
condition|)
name|fieldName
operator|=
name|NewPoolTString
argument_list|(
name|copyOf
operator|.
name|fieldName
operator|->
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|typeName
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|copyOf
operator|.
name|typeName
condition|)
name|typeName
operator|=
name|NewPoolTString
argument_list|(
name|copyOf
operator|.
name|typeName
operator|->
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|mangled
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|copyOf
operator|.
name|mangled
condition|)
name|mangled
operator|=
name|NewPoolTString
argument_list|(
name|copyOf
operator|.
name|mangled
operator|->
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|structureSize
operator|=
name|copyOf
operator|.
name|structureSize
expr_stmt|;
name|maxArraySize
operator|=
name|copyOf
operator|.
name|maxArraySize
expr_stmt|;
name|deepestStructNesting
operator|=
name|copyOf
operator|.
name|deepestStructNesting
expr_stmt|;
name|assert
argument_list|(
name|copyOf
operator|.
name|arrayInformationType
operator|==
literal|0
argument_list|)
expr_stmt|;
name|arrayInformationType
operator|=
literal|0
expr_stmt|;
comment|// arrayInformationType should not be set for builtIn symbol table level
block|}
end_decl_stmt
begin_function
name|TType
modifier|*
name|clone
parameter_list|(
name|TStructureMap
modifier|&
name|remapper
parameter_list|)
block|{
name|TType
modifier|*
name|newType
init|=
name|new
name|TType
argument_list|()
decl_stmt|;
name|newType
operator|->
name|copyType
argument_list|(
operator|*
name|this
argument_list|,
name|remapper
argument_list|)
expr_stmt|;
return|return
name|newType
return|;
block|}
end_function
begin_expr_stmt
name|TBasicType
name|getBasicType
argument_list|()
specifier|const
block|{
return|return
name|type
return|;
block|}
end_expr_stmt
begin_function
name|void
name|setBasicType
parameter_list|(
name|TBasicType
name|t
parameter_list|)
block|{
name|type
operator|=
name|t
expr_stmt|;
block|}
end_function
begin_expr_stmt
name|TPrecision
name|getPrecision
argument_list|()
specifier|const
block|{
return|return
name|precision
return|;
block|}
end_expr_stmt
begin_function
name|void
name|setPrecision
parameter_list|(
name|TPrecision
name|p
parameter_list|)
block|{
name|precision
operator|=
name|p
expr_stmt|;
block|}
end_function
begin_expr_stmt
name|TQualifier
name|getQualifier
argument_list|()
specifier|const
block|{
return|return
name|qualifier
return|;
block|}
end_expr_stmt
begin_function
name|void
name|setQualifier
parameter_list|(
name|TQualifier
name|q
parameter_list|)
block|{
name|qualifier
operator|=
name|q
expr_stmt|;
block|}
end_function
begin_comment
comment|// One-dimensional size of single instance type
end_comment
begin_expr_stmt
name|int
name|getNominalSize
argument_list|()
specifier|const
block|{
return|return
name|size
return|;
block|}
end_expr_stmt
begin_function
name|void
name|setNominalSize
parameter_list|(
name|int
name|s
parameter_list|)
block|{
name|size
operator|=
name|s
expr_stmt|;
block|}
end_function
begin_comment
comment|// Full size of single instance of type
end_comment
begin_expr_stmt
name|int
name|getObjectSize
argument_list|()
specifier|const
block|{
name|int
name|totalSize
block|;
if|if
condition|(
name|getBasicType
argument_list|()
operator|==
name|EbtStruct
condition|)
name|totalSize
operator|=
name|getStructSize
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|matrix
condition|)
name|totalSize
operator|=
name|size
operator|*
name|size
expr_stmt|;
else|else
name|totalSize
operator|=
name|size
expr_stmt|;
end_expr_stmt
begin_if
if|if
condition|(
name|isArray
argument_list|()
condition|)
name|totalSize
operator|*=
name|std
operator|::
name|max
argument_list|(
name|getArraySize
argument_list|()
argument_list|,
name|getMaxArraySize
argument_list|()
argument_list|)
expr_stmt|;
end_if
begin_return
return|return
name|totalSize
return|;
end_return
begin_macro
unit|}      int
name|elementRegisterCount
argument_list|()
end_macro
begin_expr_stmt
specifier|const
block|{
name|TTypeList
operator|*
name|structure
operator|=
name|getStruct
argument_list|()
block|;
if|if
condition|(
name|structure
condition|)
block|{
name|int
name|registerCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|structure
operator|->
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|registerCount
operator|+=
operator|(
operator|*
name|structure
operator|)
index|[
name|i
index|]
operator|.
name|type
operator|->
name|totalRegisterCount
argument_list|()
expr_stmt|;
block|}
end_expr_stmt
begin_return
return|return
name|registerCount
return|;
end_return
begin_if
unit|}         else
if|if
condition|(
name|isMatrix
argument_list|()
condition|)
block|{
return|return
name|getNominalSize
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|1
return|;
block|}
end_if
begin_macro
unit|}      int
name|totalRegisterCount
argument_list|()
end_macro
begin_expr_stmt
specifier|const
block|{
if|if
condition|(
name|array
condition|)
block|{
return|return
name|arraySize
operator|*
name|elementRegisterCount
argument_list|()
return|;
block|}
end_expr_stmt
begin_else
else|else
block|{
return|return
name|elementRegisterCount
argument_list|()
return|;
block|}
end_else
begin_macro
unit|}      bool
name|isMatrix
argument_list|()
end_macro
begin_expr_stmt
specifier|const
block|{
return|return
name|matrix
operator|?
name|true
operator|:
name|false
return|;
block|}
end_expr_stmt
begin_function
name|void
name|setMatrix
parameter_list|(
name|bool
name|m
parameter_list|)
block|{
name|matrix
operator|=
name|m
expr_stmt|;
block|}
end_function
begin_expr_stmt
name|bool
name|isArray
argument_list|()
specifier|const
block|{
return|return
name|array
operator|?
name|true
operator|:
name|false
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|int
name|getArraySize
argument_list|()
specifier|const
block|{
return|return
name|arraySize
return|;
block|}
end_expr_stmt
begin_function
name|void
name|setArraySize
parameter_list|(
name|int
name|s
parameter_list|)
block|{
name|array
operator|=
name|true
expr_stmt|;
name|arraySize
operator|=
name|s
expr_stmt|;
block|}
end_function
begin_expr_stmt
name|int
name|getMaxArraySize
argument_list|()
specifier|const
block|{
return|return
name|maxArraySize
return|;
block|}
end_expr_stmt
begin_function
name|void
name|setMaxArraySize
parameter_list|(
name|int
name|s
parameter_list|)
block|{
name|maxArraySize
operator|=
name|s
expr_stmt|;
block|}
end_function
begin_function
name|void
name|clearArrayness
parameter_list|()
block|{
name|array
operator|=
name|false
expr_stmt|;
name|arraySize
operator|=
literal|0
expr_stmt|;
name|maxArraySize
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
name|void
name|setArrayInformationType
parameter_list|(
name|TType
modifier|*
name|t
parameter_list|)
block|{
name|arrayInformationType
operator|=
name|t
expr_stmt|;
block|}
end_function
begin_expr_stmt
name|TType
operator|*
name|getArrayInformationType
argument_list|()
specifier|const
block|{
return|return
name|arrayInformationType
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|bool
name|isVector
argument_list|()
specifier|const
block|{
return|return
name|size
operator|>
literal|1
operator|&&
operator|!
name|matrix
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|bool
name|isScalar
argument_list|()
specifier|const
block|{
return|return
name|size
operator|==
literal|1
operator|&&
operator|!
name|matrix
operator|&&
operator|!
name|structure
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|TTypeList
operator|*
name|getStruct
argument_list|()
specifier|const
block|{
return|return
name|structure
return|;
block|}
end_expr_stmt
begin_function
name|void
name|setStruct
parameter_list|(
name|TTypeList
modifier|*
name|s
parameter_list|)
block|{
name|structure
operator|=
name|s
expr_stmt|;
name|computeDeepestStructNesting
argument_list|()
expr_stmt|;
block|}
end_function
begin_expr_stmt
specifier|const
name|TString
operator|&
name|getTypeName
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|typeName
argument_list|)
block|;
return|return
operator|*
name|typeName
return|;
block|}
end_expr_stmt
begin_function
name|void
name|setTypeName
parameter_list|(
specifier|const
name|TString
modifier|&
name|n
parameter_list|)
block|{
name|typeName
operator|=
name|NewPoolTString
argument_list|(
name|n
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_expr_stmt
name|bool
name|isField
argument_list|()
specifier|const
block|{
return|return
name|fieldName
operator|!=
literal|0
return|;
block|}
end_expr_stmt
begin_expr_stmt
specifier|const
name|TString
operator|&
name|getFieldName
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|fieldName
argument_list|)
block|;
return|return
operator|*
name|fieldName
return|;
block|}
end_expr_stmt
begin_function
name|void
name|setFieldName
parameter_list|(
specifier|const
name|TString
modifier|&
name|n
parameter_list|)
block|{
name|fieldName
operator|=
name|NewPoolTString
argument_list|(
name|n
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|TString
modifier|&
name|getMangledName
parameter_list|()
block|{
if|if
condition|(
operator|!
name|mangled
condition|)
block|{
name|mangled
operator|=
name|NewPoolTString
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|buildMangledName
argument_list|(
operator|*
name|mangled
argument_list|)
expr_stmt|;
operator|*
name|mangled
operator|+=
literal|';'
expr_stmt|;
block|}
return|return
operator|*
name|mangled
return|;
block|}
end_function
begin_decl_stmt
name|bool
name|sameElementType
argument_list|(
specifier|const
name|TType
operator|&
name|right
argument_list|)
decl|const
block|{
return|return
name|type
operator|==
name|right
operator|.
name|type
operator|&&
name|size
operator|==
name|right
operator|.
name|size
operator|&&
name|matrix
operator|==
name|right
operator|.
name|matrix
operator|&&
name|structure
operator|==
name|right
operator|.
name|structure
return|;
block|}
end_decl_stmt
begin_expr_stmt
name|bool
name|operator
operator|==
operator|(
specifier|const
name|TType
operator|&
name|right
operator|)
specifier|const
block|{
return|return
name|type
operator|==
name|right
operator|.
name|type
operator|&&
name|size
operator|==
name|right
operator|.
name|size
operator|&&
name|matrix
operator|==
name|right
operator|.
name|matrix
operator|&&
name|array
operator|==
name|right
operator|.
name|array
operator|&&
operator|(
operator|!
name|array
operator|||
name|arraySize
operator|==
name|right
operator|.
name|arraySize
operator|)
operator|&&
name|structure
operator|==
name|right
operator|.
name|structure
return|;
comment|// don't check the qualifier, it's not ever what's being sought after
block|}
end_expr_stmt
begin_expr_stmt
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|TType
operator|&
name|right
operator|)
specifier|const
block|{
return|return
operator|!
name|operator
operator|==
operator|(
name|right
operator|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|bool
name|operator
operator|<
operator|(
specifier|const
name|TType
operator|&
name|right
operator|)
specifier|const
block|{
if|if
condition|(
name|type
operator|!=
name|right
operator|.
name|type
condition|)
return|return
name|type
operator|<
name|right
operator|.
name|type
return|;
end_expr_stmt
begin_if
if|if
condition|(
name|size
operator|!=
name|right
operator|.
name|size
condition|)
return|return
name|size
operator|<
name|right
operator|.
name|size
return|;
end_if
begin_if
if|if
condition|(
name|matrix
operator|!=
name|right
operator|.
name|matrix
condition|)
return|return
name|matrix
operator|<
name|right
operator|.
name|matrix
return|;
end_if
begin_if
if|if
condition|(
name|array
operator|!=
name|right
operator|.
name|array
condition|)
return|return
name|array
operator|<
name|right
operator|.
name|array
return|;
end_if
begin_if
if|if
condition|(
name|arraySize
operator|!=
name|right
operator|.
name|arraySize
condition|)
return|return
name|arraySize
operator|<
name|right
operator|.
name|arraySize
return|;
end_if
begin_if
if|if
condition|(
name|structure
operator|!=
name|right
operator|.
name|structure
condition|)
return|return
name|structure
operator|<
name|right
operator|.
name|structure
return|;
end_if
begin_return
return|return
name|false
return|;
end_return
begin_expr_stmt
unit|}      const
name|char
operator|*
name|getBasicString
argument_list|()
specifier|const
block|{
return|return
operator|::
name|getBasicString
argument_list|(
name|type
argument_list|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
specifier|const
name|char
operator|*
name|getPrecisionString
argument_list|()
specifier|const
block|{
return|return
operator|::
name|getPrecisionString
argument_list|(
name|precision
argument_list|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
specifier|const
name|char
operator|*
name|getQualifierString
argument_list|()
specifier|const
block|{
return|return
operator|::
name|getQualifierString
argument_list|(
name|qualifier
argument_list|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|TString
name|getCompleteString
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt
begin_comment
comment|// If this type is a struct, returns the deepest struct nesting of
end_comment
begin_comment
comment|// any field in the struct. For example:
end_comment
begin_comment
comment|//   struct nesting1 {
end_comment
begin_comment
comment|//     vec4 position;
end_comment
begin_comment
comment|//   };
end_comment
begin_comment
comment|//   struct nesting2 {
end_comment
begin_comment
comment|//     nesting1 field1;
end_comment
begin_comment
comment|//     vec4 field2;
end_comment
begin_comment
comment|//   };
end_comment
begin_comment
comment|// For type "nesting2", this method would return 2 -- the number
end_comment
begin_comment
comment|// of structures through which indirection must occur to reach the
end_comment
begin_comment
comment|// deepest field (nesting2.field1.position).
end_comment
begin_expr_stmt
name|int
name|getDeepestStructNesting
argument_list|()
specifier|const
block|{
return|return
name|deepestStructNesting
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|bool
name|isStructureContainingArrays
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt
begin_label
name|protected
label|:
end_label
begin_function_decl
name|void
name|buildMangledName
parameter_list|(
name|TString
modifier|&
parameter_list|)
function_decl|;
end_function_decl
begin_expr_stmt
name|int
name|getStructSize
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt
begin_function_decl
name|void
name|computeDeepestStructNesting
parameter_list|()
function_decl|;
end_function_decl
begin_decl_stmt
name|TBasicType
name|type
range|:
literal|6
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|TPrecision
name|precision
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|TQualifier
name|qualifier
range|:
literal|7
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|int
name|size
range|:
literal|8
decl_stmt|;
end_decl_stmt
begin_comment
comment|// size of vector or matrix, not size of array
end_comment
begin_decl_stmt
name|unsigned
name|int
name|matrix
range|:
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|unsigned
name|int
name|array
range|:
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|int
name|arraySize
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|int
name|maxArraySize
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|TType
modifier|*
name|arrayInformationType
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|TTypeList
modifier|*
name|structure
decl_stmt|;
end_decl_stmt
begin_comment
comment|// 0 unless this is a struct
end_comment
begin_decl_stmt
name|mutable
name|int
name|structureSize
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|int
name|deepestStructNesting
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|TString
modifier|*
name|fieldName
decl_stmt|;
end_decl_stmt
begin_comment
comment|// for structure field names
end_comment
begin_decl_stmt
name|TString
modifier|*
name|mangled
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|TString
modifier|*
name|typeName
decl_stmt|;
end_decl_stmt
begin_comment
comment|// for structure field type name
end_comment
begin_comment
unit|};
comment|//
end_comment
begin_comment
comment|// This is a workaround for a problem with the yacc stack,  It can't have
end_comment
begin_comment
comment|// types that it thinks have non-trivial constructors.  It should
end_comment
begin_comment
comment|// just be used while recognizing the grammar, not anything else.  Pointers
end_comment
begin_comment
comment|// could be used, but also trying to avoid lots of memory management overhead.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Not as bad as it looks, there is no actual assumption that the fields
end_comment
begin_comment
comment|// match up or are name the same or anything like that.
end_comment
begin_comment
comment|//
end_comment
begin_struct
DECL|struct|TPublicType
struct|struct
name|TPublicType
block|{
DECL|member|type
name|TBasicType
name|type
decl_stmt|;
DECL|member|qualifier
name|TQualifier
name|qualifier
decl_stmt|;
DECL|member|precision
name|TPrecision
name|precision
decl_stmt|;
DECL|member|size
name|int
name|size
decl_stmt|;
comment|// size of vector or matrix, not size of array
DECL|member|matrix
name|bool
name|matrix
decl_stmt|;
DECL|member|array
name|bool
name|array
decl_stmt|;
DECL|member|arraySize
name|int
name|arraySize
decl_stmt|;
DECL|member|userDef
name|TType
modifier|*
name|userDef
decl_stmt|;
DECL|member|line
name|int
name|line
decl_stmt|;
DECL|function|setBasic
name|void
name|setBasic
parameter_list|(
name|TBasicType
name|bt
parameter_list|,
name|TQualifier
name|q
parameter_list|,
name|int
name|ln
init|=
literal|0
parameter_list|)
block|{
name|type
operator|=
name|bt
expr_stmt|;
name|qualifier
operator|=
name|q
expr_stmt|;
name|precision
operator|=
name|EbpUndefined
expr_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
name|matrix
operator|=
name|false
expr_stmt|;
name|array
operator|=
name|false
expr_stmt|;
name|arraySize
operator|=
literal|0
expr_stmt|;
name|userDef
operator|=
literal|0
expr_stmt|;
name|line
operator|=
name|ln
expr_stmt|;
block|}
DECL|function|setAggregate
name|void
name|setAggregate
parameter_list|(
name|int
name|s
parameter_list|,
name|bool
name|m
init|=
name|false
parameter_list|)
block|{
name|size
operator|=
name|s
expr_stmt|;
name|matrix
operator|=
name|m
expr_stmt|;
block|}
DECL|function|setArray
name|void
name|setArray
parameter_list|(
name|bool
name|a
parameter_list|,
name|int
name|s
init|=
literal|0
parameter_list|)
block|{
name|array
operator|=
name|a
expr_stmt|;
name|arraySize
operator|=
name|s
expr_stmt|;
block|}
DECL|function|isStructureContainingArrays
name|bool
name|isStructureContainingArrays
argument_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|userDef
condition|)
block|{
return|return
name|false
return|;
block|}
return|return
name|userDef
operator|->
name|isStructureContainingArrays
argument_list|()
return|;
block|}
end_struct
begin_endif
unit|};
endif|#
directive|endif
end_endif
begin_comment
comment|// _TYPES_INCLUDED_
end_comment
end_unit
