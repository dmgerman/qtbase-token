begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2013 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Definition of the in-memory high-level intermediate representation
end_comment
begin_comment
comment|// of shaders.  This is a tree that parser creates.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Nodes in the tree are defined as a hierarchy of classes derived from
end_comment
begin_comment
comment|// TIntermNode. Each is a node in a tree.  There is no preset branching factor;
end_comment
begin_comment
comment|// each node can have it's own type of list of children.
end_comment
begin_comment
comment|//
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|__INTERMEDIATE_H
end_ifndef
begin_define
DECL|macro|__INTERMEDIATE_H
define|#
directive|define
name|__INTERMEDIATE_H
end_define
begin_include
include|#
directive|include
file|"GLSLANG/ShaderLang.h"
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_include
include|#
directive|include
file|"compiler/Common.h"
end_include
begin_include
include|#
directive|include
file|"compiler/Types.h"
end_include
begin_include
include|#
directive|include
file|"compiler/ConstantUnion.h"
end_include
begin_comment
comment|//
end_comment
begin_comment
comment|// Operators used by the high-level (parse tree) representation.
end_comment
begin_comment
comment|//
end_comment
begin_enum
DECL|enum|TOperator
enum|enum
name|TOperator
block|{
DECL|enumerator|EOpNull
name|EOpNull
block|,
comment|// if in a node, should only mean a node is still being built
DECL|enumerator|EOpSequence
name|EOpSequence
block|,
comment|// denotes a list of statements, or parameters, etc.
DECL|enumerator|EOpFunctionCall
name|EOpFunctionCall
block|,
DECL|enumerator|EOpFunction
name|EOpFunction
block|,
comment|// For function definition
DECL|enumerator|EOpParameters
name|EOpParameters
block|,
comment|// an aggregate listing the parameters to a function
DECL|enumerator|EOpDeclaration
name|EOpDeclaration
block|,
DECL|enumerator|EOpPrototype
name|EOpPrototype
block|,
comment|//
comment|// Unary operators
comment|//
DECL|enumerator|EOpNegative
name|EOpNegative
block|,
DECL|enumerator|EOpLogicalNot
name|EOpLogicalNot
block|,
DECL|enumerator|EOpVectorLogicalNot
name|EOpVectorLogicalNot
block|,
DECL|enumerator|EOpPostIncrement
name|EOpPostIncrement
block|,
DECL|enumerator|EOpPostDecrement
name|EOpPostDecrement
block|,
DECL|enumerator|EOpPreIncrement
name|EOpPreIncrement
block|,
DECL|enumerator|EOpPreDecrement
name|EOpPreDecrement
block|,
DECL|enumerator|EOpConvIntToBool
name|EOpConvIntToBool
block|,
DECL|enumerator|EOpConvFloatToBool
name|EOpConvFloatToBool
block|,
DECL|enumerator|EOpConvBoolToFloat
name|EOpConvBoolToFloat
block|,
DECL|enumerator|EOpConvIntToFloat
name|EOpConvIntToFloat
block|,
DECL|enumerator|EOpConvFloatToInt
name|EOpConvFloatToInt
block|,
DECL|enumerator|EOpConvBoolToInt
name|EOpConvBoolToInt
block|,
comment|//
comment|// binary operations
comment|//
DECL|enumerator|EOpAdd
name|EOpAdd
block|,
DECL|enumerator|EOpSub
name|EOpSub
block|,
DECL|enumerator|EOpMul
name|EOpMul
block|,
DECL|enumerator|EOpDiv
name|EOpDiv
block|,
DECL|enumerator|EOpEqual
name|EOpEqual
block|,
DECL|enumerator|EOpNotEqual
name|EOpNotEqual
block|,
DECL|enumerator|EOpVectorEqual
name|EOpVectorEqual
block|,
DECL|enumerator|EOpVectorNotEqual
name|EOpVectorNotEqual
block|,
DECL|enumerator|EOpLessThan
name|EOpLessThan
block|,
DECL|enumerator|EOpGreaterThan
name|EOpGreaterThan
block|,
DECL|enumerator|EOpLessThanEqual
name|EOpLessThanEqual
block|,
DECL|enumerator|EOpGreaterThanEqual
name|EOpGreaterThanEqual
block|,
DECL|enumerator|EOpComma
name|EOpComma
block|,
DECL|enumerator|EOpVectorTimesScalar
name|EOpVectorTimesScalar
block|,
DECL|enumerator|EOpVectorTimesMatrix
name|EOpVectorTimesMatrix
block|,
DECL|enumerator|EOpMatrixTimesVector
name|EOpMatrixTimesVector
block|,
DECL|enumerator|EOpMatrixTimesScalar
name|EOpMatrixTimesScalar
block|,
DECL|enumerator|EOpLogicalOr
name|EOpLogicalOr
block|,
DECL|enumerator|EOpLogicalXor
name|EOpLogicalXor
block|,
DECL|enumerator|EOpLogicalAnd
name|EOpLogicalAnd
block|,
DECL|enumerator|EOpIndexDirect
name|EOpIndexDirect
block|,
DECL|enumerator|EOpIndexIndirect
name|EOpIndexIndirect
block|,
DECL|enumerator|EOpIndexDirectStruct
name|EOpIndexDirectStruct
block|,
DECL|enumerator|EOpVectorSwizzle
name|EOpVectorSwizzle
block|,
comment|//
comment|// Built-in functions potentially mapped to operators
comment|//
DECL|enumerator|EOpRadians
name|EOpRadians
block|,
DECL|enumerator|EOpDegrees
name|EOpDegrees
block|,
DECL|enumerator|EOpSin
name|EOpSin
block|,
DECL|enumerator|EOpCos
name|EOpCos
block|,
DECL|enumerator|EOpTan
name|EOpTan
block|,
DECL|enumerator|EOpAsin
name|EOpAsin
block|,
DECL|enumerator|EOpAcos
name|EOpAcos
block|,
DECL|enumerator|EOpAtan
name|EOpAtan
block|,
DECL|enumerator|EOpPow
name|EOpPow
block|,
DECL|enumerator|EOpExp
name|EOpExp
block|,
DECL|enumerator|EOpLog
name|EOpLog
block|,
DECL|enumerator|EOpExp2
name|EOpExp2
block|,
DECL|enumerator|EOpLog2
name|EOpLog2
block|,
DECL|enumerator|EOpSqrt
name|EOpSqrt
block|,
DECL|enumerator|EOpInverseSqrt
name|EOpInverseSqrt
block|,
DECL|enumerator|EOpAbs
name|EOpAbs
block|,
DECL|enumerator|EOpSign
name|EOpSign
block|,
DECL|enumerator|EOpFloor
name|EOpFloor
block|,
DECL|enumerator|EOpCeil
name|EOpCeil
block|,
DECL|enumerator|EOpFract
name|EOpFract
block|,
DECL|enumerator|EOpMod
name|EOpMod
block|,
DECL|enumerator|EOpMin
name|EOpMin
block|,
DECL|enumerator|EOpMax
name|EOpMax
block|,
DECL|enumerator|EOpClamp
name|EOpClamp
block|,
DECL|enumerator|EOpMix
name|EOpMix
block|,
DECL|enumerator|EOpStep
name|EOpStep
block|,
DECL|enumerator|EOpSmoothStep
name|EOpSmoothStep
block|,
DECL|enumerator|EOpLength
name|EOpLength
block|,
DECL|enumerator|EOpDistance
name|EOpDistance
block|,
DECL|enumerator|EOpDot
name|EOpDot
block|,
DECL|enumerator|EOpCross
name|EOpCross
block|,
DECL|enumerator|EOpNormalize
name|EOpNormalize
block|,
DECL|enumerator|EOpFaceForward
name|EOpFaceForward
block|,
DECL|enumerator|EOpReflect
name|EOpReflect
block|,
DECL|enumerator|EOpRefract
name|EOpRefract
block|,
DECL|enumerator|EOpDFdx
name|EOpDFdx
block|,
comment|// Fragment only, OES_standard_derivatives extension
DECL|enumerator|EOpDFdy
name|EOpDFdy
block|,
comment|// Fragment only, OES_standard_derivatives extension
DECL|enumerator|EOpFwidth
name|EOpFwidth
block|,
comment|// Fragment only, OES_standard_derivatives extension
DECL|enumerator|EOpMatrixTimesMatrix
name|EOpMatrixTimesMatrix
block|,
DECL|enumerator|EOpAny
name|EOpAny
block|,
DECL|enumerator|EOpAll
name|EOpAll
block|,
comment|//
comment|// Branch
comment|//
DECL|enumerator|EOpKill
name|EOpKill
block|,
comment|// Fragment only
DECL|enumerator|EOpReturn
name|EOpReturn
block|,
DECL|enumerator|EOpBreak
name|EOpBreak
block|,
DECL|enumerator|EOpContinue
name|EOpContinue
block|,
comment|//
comment|// Constructors
comment|//
DECL|enumerator|EOpConstructInt
name|EOpConstructInt
block|,
DECL|enumerator|EOpConstructBool
name|EOpConstructBool
block|,
DECL|enumerator|EOpConstructFloat
name|EOpConstructFloat
block|,
DECL|enumerator|EOpConstructVec2
name|EOpConstructVec2
block|,
DECL|enumerator|EOpConstructVec3
name|EOpConstructVec3
block|,
DECL|enumerator|EOpConstructVec4
name|EOpConstructVec4
block|,
DECL|enumerator|EOpConstructBVec2
name|EOpConstructBVec2
block|,
DECL|enumerator|EOpConstructBVec3
name|EOpConstructBVec3
block|,
DECL|enumerator|EOpConstructBVec4
name|EOpConstructBVec4
block|,
DECL|enumerator|EOpConstructIVec2
name|EOpConstructIVec2
block|,
DECL|enumerator|EOpConstructIVec3
name|EOpConstructIVec3
block|,
DECL|enumerator|EOpConstructIVec4
name|EOpConstructIVec4
block|,
DECL|enumerator|EOpConstructMat2
name|EOpConstructMat2
block|,
DECL|enumerator|EOpConstructMat3
name|EOpConstructMat3
block|,
DECL|enumerator|EOpConstructMat4
name|EOpConstructMat4
block|,
DECL|enumerator|EOpConstructStruct
name|EOpConstructStruct
block|,
comment|//
comment|// moves
comment|//
DECL|enumerator|EOpAssign
name|EOpAssign
block|,
DECL|enumerator|EOpInitialize
name|EOpInitialize
block|,
DECL|enumerator|EOpAddAssign
name|EOpAddAssign
block|,
DECL|enumerator|EOpSubAssign
name|EOpSubAssign
block|,
DECL|enumerator|EOpMulAssign
name|EOpMulAssign
block|,
DECL|enumerator|EOpVectorTimesMatrixAssign
name|EOpVectorTimesMatrixAssign
block|,
DECL|enumerator|EOpVectorTimesScalarAssign
name|EOpVectorTimesScalarAssign
block|,
DECL|enumerator|EOpMatrixTimesScalarAssign
name|EOpMatrixTimesScalarAssign
block|,
DECL|enumerator|EOpMatrixTimesMatrixAssign
name|EOpMatrixTimesMatrixAssign
block|,
DECL|enumerator|EOpDivAssign
name|EOpDivAssign
block|}
enum|;
end_enum
begin_function_decl
specifier|extern
specifier|const
name|char
modifier|*
name|getOperatorString
parameter_list|(
name|TOperator
name|op
parameter_list|)
function_decl|;
end_function_decl
begin_decl_stmt
DECL|variable|TIntermTraverser
name|class
name|TIntermTraverser
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermAggregate
name|class
name|TIntermAggregate
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermBinary
name|class
name|TIntermBinary
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermUnary
name|class
name|TIntermUnary
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermConstantUnion
name|class
name|TIntermConstantUnion
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermSelection
name|class
name|TIntermSelection
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermTyped
name|class
name|TIntermTyped
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermSymbol
name|class
name|TIntermSymbol
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermLoop
name|class
name|TIntermLoop
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TInfoSink
name|class
name|TInfoSink
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// Base class for the tree nodes
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermNode
block|{
name|public
label|:
name|POOL_ALLOCATOR_NEW_DELETE
argument_list|()
expr_stmt|;
name|TIntermNode
argument_list|()
block|{
comment|// TODO: Move this to TSourceLoc constructor
comment|// after getting rid of TPublicType.
name|line
operator|.
name|first_file
operator|=
name|line
operator|.
name|last_file
operator|=
literal|0
expr_stmt|;
name|line
operator|.
name|first_line
operator|=
name|line
operator|.
name|last_line
operator|=
literal|0
expr_stmt|;
block|}
name|virtual
operator|~
name|TIntermNode
argument_list|()
block|{ }
specifier|const
name|TSourceLoc
operator|&
name|getLine
argument_list|()
specifier|const
block|{
return|return
name|line
return|;
block|}
name|void
name|setLine
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|l
parameter_list|)
block|{
name|line
operator|=
name|l
expr_stmt|;
block|}
name|virtual
name|void
name|traverse
parameter_list|(
name|TIntermTraverser
modifier|*
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|TIntermTyped
modifier|*
name|getAsTyped
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
name|virtual
name|TIntermConstantUnion
modifier|*
name|getAsConstantUnion
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
name|virtual
name|TIntermAggregate
modifier|*
name|getAsAggregate
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
name|virtual
name|TIntermBinary
modifier|*
name|getAsBinaryNode
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
name|virtual
name|TIntermUnary
modifier|*
name|getAsUnaryNode
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
name|virtual
name|TIntermSelection
modifier|*
name|getAsSelectionNode
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
name|virtual
name|TIntermSymbol
modifier|*
name|getAsSymbolNode
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
name|virtual
name|TIntermLoop
modifier|*
name|getAsLoopNode
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
name|protected
label|:
name|TSourceLoc
name|line
decl_stmt|;
block|}
end_decl_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// This is just to help yacc.
end_comment
begin_comment
comment|//
end_comment
begin_struct
DECL|struct|TIntermNodePair
struct|struct
name|TIntermNodePair
block|{
DECL|member|node1
name|TIntermNode
modifier|*
name|node1
decl_stmt|;
DECL|member|node2
name|TIntermNode
modifier|*
name|node2
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|//
end_comment
begin_comment
comment|// Intermediate class for nodes that have a type.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermTyped
range|:
name|public
name|TIntermNode
block|{
name|public
operator|:
name|TIntermTyped
argument_list|(
specifier|const
name|TType
operator|&
name|t
argument_list|)
operator|:
name|type
argument_list|(
argument|t
argument_list|)
block|{ }
name|virtual
name|TIntermTyped
operator|*
name|getAsTyped
argument_list|()
block|{
return|return
name|this
return|;
block|}
name|void
name|setType
argument_list|(
argument|const TType& t
argument_list|)
block|{
name|type
operator|=
name|t
block|; }
specifier|const
name|TType
operator|&
name|getType
argument_list|()
specifier|const
block|{
return|return
name|type
return|;
block|}
name|TType
operator|*
name|getTypePointer
argument_list|()
block|{
return|return
operator|&
name|type
return|;
block|}
name|TBasicType
name|getBasicType
argument_list|()
specifier|const
block|{
return|return
name|type
operator|.
name|getBasicType
argument_list|()
return|;
block|}
name|TQualifier
name|getQualifier
argument_list|()
specifier|const
block|{
return|return
name|type
operator|.
name|getQualifier
argument_list|()
return|;
block|}
name|TPrecision
name|getPrecision
argument_list|()
specifier|const
block|{
return|return
name|type
operator|.
name|getPrecision
argument_list|()
return|;
block|}
name|int
name|getNominalSize
argument_list|()
specifier|const
block|{
return|return
name|type
operator|.
name|getNominalSize
argument_list|()
return|;
block|}
name|bool
name|isMatrix
argument_list|()
specifier|const
block|{
return|return
name|type
operator|.
name|isMatrix
argument_list|()
return|;
block|}
name|bool
name|isArray
argument_list|()
specifier|const
block|{
return|return
name|type
operator|.
name|isArray
argument_list|()
return|;
block|}
name|bool
name|isVector
argument_list|()
specifier|const
block|{
return|return
name|type
operator|.
name|isVector
argument_list|()
return|;
block|}
name|bool
name|isScalar
argument_list|()
specifier|const
block|{
return|return
name|type
operator|.
name|isScalar
argument_list|()
return|;
block|}
specifier|const
name|char
operator|*
name|getBasicString
argument_list|()
specifier|const
block|{
return|return
name|type
operator|.
name|getBasicString
argument_list|()
return|;
block|}
specifier|const
name|char
operator|*
name|getQualifierString
argument_list|()
specifier|const
block|{
return|return
name|type
operator|.
name|getQualifierString
argument_list|()
return|;
block|}
name|TString
name|getCompleteString
argument_list|()
specifier|const
block|{
return|return
name|type
operator|.
name|getCompleteString
argument_list|()
return|;
block|}
name|int
name|totalRegisterCount
argument_list|()
specifier|const
block|{
return|return
name|type
operator|.
name|totalRegisterCount
argument_list|()
return|;
block|}
name|int
name|elementRegisterCount
argument_list|()
specifier|const
block|{
return|return
name|type
operator|.
name|elementRegisterCount
argument_list|()
return|;
block|}
name|int
name|getArraySize
argument_list|()
specifier|const
block|{
return|return
name|type
operator|.
name|getArraySize
argument_list|()
return|;
block|}
name|protected
operator|:
name|TType
name|type
block|; }
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// Handle for, do-while, and while loops.
end_comment
begin_comment
comment|//
end_comment
begin_enum
DECL|enum|TLoopType
enum|enum
name|TLoopType
block|{
DECL|enumerator|ELoopFor
name|ELoopFor
block|,
DECL|enumerator|ELoopWhile
name|ELoopWhile
block|,
DECL|enumerator|ELoopDoWhile
name|ELoopDoWhile
block|}
enum|;
end_enum
begin_decl_stmt
name|class
name|TIntermLoop
range|:
name|public
name|TIntermNode
block|{
name|public
operator|:
name|TIntermLoop
argument_list|(
argument|TLoopType aType
argument_list|,
argument|TIntermNode *aInit
argument_list|,
argument|TIntermTyped* aCond
argument_list|,
argument|TIntermTyped* aExpr
argument_list|,
argument|TIntermNode* aBody
argument_list|)
operator|:
name|type
argument_list|(
name|aType
argument_list|)
block|,
name|init
argument_list|(
name|aInit
argument_list|)
block|,
name|cond
argument_list|(
name|aCond
argument_list|)
block|,
name|expr
argument_list|(
name|aExpr
argument_list|)
block|,
name|body
argument_list|(
name|aBody
argument_list|)
block|,
name|unrollFlag
argument_list|(
argument|false
argument_list|)
block|{ }
name|virtual
name|TIntermLoop
operator|*
name|getAsLoopNode
argument_list|()
block|{
return|return
name|this
return|;
block|}
name|virtual
name|void
name|traverse
argument_list|(
name|TIntermTraverser
operator|*
argument_list|)
block|;
name|TLoopType
name|getType
argument_list|()
specifier|const
block|{
return|return
name|type
return|;
block|}
name|TIntermNode
operator|*
name|getInit
argument_list|()
block|{
return|return
name|init
return|;
block|}
name|TIntermTyped
operator|*
name|getCondition
argument_list|()
block|{
return|return
name|cond
return|;
block|}
name|TIntermTyped
operator|*
name|getExpression
argument_list|()
block|{
return|return
name|expr
return|;
block|}
name|TIntermNode
operator|*
name|getBody
argument_list|()
block|{
return|return
name|body
return|;
block|}
name|void
name|setUnrollFlag
argument_list|(
argument|bool flag
argument_list|)
block|{
name|unrollFlag
operator|=
name|flag
block|; }
name|bool
name|getUnrollFlag
argument_list|()
block|{
return|return
name|unrollFlag
return|;
block|}
name|protected
operator|:
name|TLoopType
name|type
block|;
name|TIntermNode
operator|*
name|init
block|;
comment|// for-loop initialization
name|TIntermTyped
operator|*
name|cond
block|;
comment|// loop exit condition
name|TIntermTyped
operator|*
name|expr
block|;
comment|// for-loop expression
name|TIntermNode
operator|*
name|body
block|;
comment|// loop body
name|bool
name|unrollFlag
block|;
comment|// Whether the loop should be unrolled or not.
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// Handle break, continue, return, and kill.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermBranch
range|:
name|public
name|TIntermNode
block|{
name|public
operator|:
name|TIntermBranch
argument_list|(
argument|TOperator op
argument_list|,
argument|TIntermTyped* e
argument_list|)
operator|:
name|flowOp
argument_list|(
name|op
argument_list|)
block|,
name|expression
argument_list|(
argument|e
argument_list|)
block|{ }
name|virtual
name|void
name|traverse
argument_list|(
name|TIntermTraverser
operator|*
argument_list|)
block|;
name|TOperator
name|getFlowOp
argument_list|()
block|{
return|return
name|flowOp
return|;
block|}
name|TIntermTyped
operator|*
name|getExpression
argument_list|()
block|{
return|return
name|expression
return|;
block|}
name|protected
operator|:
name|TOperator
name|flowOp
block|;
name|TIntermTyped
operator|*
name|expression
block|;
comment|// non-zero except for "return exp;" statements
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// Nodes that correspond to symbols or constants in the source code.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermSymbol
range|:
name|public
name|TIntermTyped
block|{
name|public
operator|:
comment|// if symbol is initialized as symbol(sym), the memory comes from the poolallocator of sym. If sym comes from
comment|// per process globalpoolallocator, then it causes increased memory usage per compile
comment|// it is essential to use "symbol = sym" to assign to symbol
name|TIntermSymbol
argument_list|(
argument|int i
argument_list|,
argument|const TString& sym
argument_list|,
argument|const TType& t
argument_list|)
operator|:
name|TIntermTyped
argument_list|(
name|t
argument_list|)
block|,
name|id
argument_list|(
argument|i
argument_list|)
block|{
name|symbol
operator|=
name|sym
block|;
name|originalSymbol
operator|=
name|sym
block|; }
name|int
name|getId
argument_list|()
specifier|const
block|{
return|return
name|id
return|;
block|}
specifier|const
name|TString
operator|&
name|getSymbol
argument_list|()
specifier|const
block|{
return|return
name|symbol
return|;
block|}
name|void
name|setId
argument_list|(
argument|int newId
argument_list|)
block|{
name|id
operator|=
name|newId
block|; }
name|void
name|setSymbol
argument_list|(
argument|const TString& sym
argument_list|)
block|{
name|symbol
operator|=
name|sym
block|; }
specifier|const
name|TString
operator|&
name|getOriginalSymbol
argument_list|()
specifier|const
block|{
return|return
name|originalSymbol
return|;
block|}
name|virtual
name|void
name|traverse
argument_list|(
name|TIntermTraverser
operator|*
argument_list|)
block|;
name|virtual
name|TIntermSymbol
operator|*
name|getAsSymbolNode
argument_list|()
block|{
return|return
name|this
return|;
block|}
name|protected
operator|:
name|int
name|id
block|;
name|TString
name|symbol
block|;
name|TString
name|originalSymbol
block|; }
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|class
name|TIntermConstantUnion
range|:
name|public
name|TIntermTyped
block|{
name|public
operator|:
name|TIntermConstantUnion
argument_list|(
name|ConstantUnion
operator|*
name|unionPointer
argument_list|,
specifier|const
name|TType
operator|&
name|t
argument_list|)
operator|:
name|TIntermTyped
argument_list|(
name|t
argument_list|)
block|,
name|unionArrayPointer
argument_list|(
argument|unionPointer
argument_list|)
block|{ }
name|ConstantUnion
operator|*
name|getUnionArrayPointer
argument_list|()
specifier|const
block|{
return|return
name|unionArrayPointer
return|;
block|}
name|int
name|getIConst
argument_list|(
argument|int index
argument_list|)
specifier|const
block|{
return|return
name|unionArrayPointer
operator|?
name|unionArrayPointer
index|[
name|index
index|]
operator|.
name|getIConst
argument_list|()
operator|:
literal|0
return|;
block|}
name|float
name|getFConst
argument_list|(
argument|int index
argument_list|)
specifier|const
block|{
return|return
name|unionArrayPointer
condition|?
name|unionArrayPointer
index|[
name|index
index|]
operator|.
name|getFConst
argument_list|()
else|:
literal|0.0f
return|;
block|}
name|bool
name|getBConst
argument_list|(
argument|int index
argument_list|)
specifier|const
block|{
return|return
name|unionArrayPointer
condition|?
name|unionArrayPointer
index|[
name|index
index|]
operator|.
name|getBConst
argument_list|()
else|:
name|false
return|;
block|}
name|virtual
name|TIntermConstantUnion
operator|*
name|getAsConstantUnion
argument_list|()
block|{
return|return
name|this
return|;
block|}
name|virtual
name|void
name|traverse
argument_list|(
name|TIntermTraverser
operator|*
argument_list|)
block|;
name|TIntermTyped
operator|*
name|fold
argument_list|(
name|TOperator
argument_list|,
name|TIntermTyped
operator|*
argument_list|,
name|TInfoSink
operator|&
argument_list|)
block|;
name|protected
operator|:
name|ConstantUnion
operator|*
name|unionArrayPointer
block|; }
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// Intermediate class for node types that hold operators.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermOperator
range|:
name|public
name|TIntermTyped
block|{
name|public
operator|:
name|TOperator
name|getOp
argument_list|()
specifier|const
block|{
return|return
name|op
return|;
block|}
name|void
name|setOp
argument_list|(
argument|TOperator o
argument_list|)
block|{
name|op
operator|=
name|o
block|; }
name|bool
name|modifiesState
argument_list|()
specifier|const
block|;
name|bool
name|isConstructor
argument_list|()
specifier|const
block|;
name|protected
operator|:
name|TIntermOperator
argument_list|(
argument|TOperator o
argument_list|)
operator|:
name|TIntermTyped
argument_list|(
name|TType
argument_list|(
name|EbtFloat
argument_list|,
name|EbpUndefined
argument_list|)
argument_list|)
block|,
name|op
argument_list|(
argument|o
argument_list|)
block|{}
name|TIntermOperator
argument_list|(
argument|TOperator o
argument_list|,
argument|TType& t
argument_list|)
operator|:
name|TIntermTyped
argument_list|(
name|t
argument_list|)
block|,
name|op
argument_list|(
argument|o
argument_list|)
block|{}
name|TOperator
name|op
block|; }
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// Nodes for all the basic binary math operators.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermBinary
range|:
name|public
name|TIntermOperator
block|{
name|public
operator|:
name|TIntermBinary
argument_list|(
argument|TOperator o
argument_list|)
operator|:
name|TIntermOperator
argument_list|(
name|o
argument_list|)
block|,
name|addIndexClamp
argument_list|(
argument|false
argument_list|)
block|{}
name|virtual
name|TIntermBinary
operator|*
name|getAsBinaryNode
argument_list|()
block|{
return|return
name|this
return|;
block|}
name|virtual
name|void
name|traverse
argument_list|(
name|TIntermTraverser
operator|*
argument_list|)
block|;
name|void
name|setLeft
argument_list|(
argument|TIntermTyped* n
argument_list|)
block|{
name|left
operator|=
name|n
block|; }
name|void
name|setRight
argument_list|(
argument|TIntermTyped* n
argument_list|)
block|{
name|right
operator|=
name|n
block|; }
name|TIntermTyped
operator|*
name|getLeft
argument_list|()
specifier|const
block|{
return|return
name|left
return|;
block|}
name|TIntermTyped
operator|*
name|getRight
argument_list|()
specifier|const
block|{
return|return
name|right
return|;
block|}
name|bool
name|promote
argument_list|(
name|TInfoSink
operator|&
argument_list|)
block|;
name|void
name|setAddIndexClamp
argument_list|()
block|{
name|addIndexClamp
operator|=
name|true
block|; }
name|bool
name|getAddIndexClamp
argument_list|()
block|{
return|return
name|addIndexClamp
return|;
block|}
name|protected
operator|:
name|TIntermTyped
operator|*
name|left
block|;
name|TIntermTyped
operator|*
name|right
block|;
comment|// If set to true, wrap any EOpIndexIndirect with a clamp to bounds.
name|bool
name|addIndexClamp
block|; }
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// Nodes for unary math operators.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermUnary
range|:
name|public
name|TIntermOperator
block|{
name|public
operator|:
name|TIntermUnary
argument_list|(
argument|TOperator o
argument_list|,
argument|TType& t
argument_list|)
operator|:
name|TIntermOperator
argument_list|(
name|o
argument_list|,
name|t
argument_list|)
block|,
name|operand
argument_list|(
literal|0
argument_list|)
block|,
name|useEmulatedFunction
argument_list|(
argument|false
argument_list|)
block|{}
name|TIntermUnary
argument_list|(
argument|TOperator o
argument_list|)
operator|:
name|TIntermOperator
argument_list|(
name|o
argument_list|)
block|,
name|operand
argument_list|(
literal|0
argument_list|)
block|,
name|useEmulatedFunction
argument_list|(
argument|false
argument_list|)
block|{}
name|virtual
name|void
name|traverse
argument_list|(
name|TIntermTraverser
operator|*
argument_list|)
block|;
name|virtual
name|TIntermUnary
operator|*
name|getAsUnaryNode
argument_list|()
block|{
return|return
name|this
return|;
block|}
name|void
name|setOperand
argument_list|(
argument|TIntermTyped* o
argument_list|)
block|{
name|operand
operator|=
name|o
block|; }
name|TIntermTyped
operator|*
name|getOperand
argument_list|()
block|{
return|return
name|operand
return|;
block|}
name|bool
name|promote
argument_list|(
name|TInfoSink
operator|&
argument_list|)
block|;
name|void
name|setUseEmulatedFunction
argument_list|()
block|{
name|useEmulatedFunction
operator|=
name|true
block|; }
name|bool
name|getUseEmulatedFunction
argument_list|()
block|{
return|return
name|useEmulatedFunction
return|;
block|}
name|protected
operator|:
name|TIntermTyped
operator|*
name|operand
block|;
comment|// If set to true, replace the built-in function call with an emulated one
comment|// to work around driver bugs.
name|bool
name|useEmulatedFunction
block|; }
decl_stmt|;
end_decl_stmt
begin_typedef
DECL|typedef|TIntermSequence
typedef|typedef
name|TVector
operator|<
name|TIntermNode
operator|*
operator|>
name|TIntermSequence
expr_stmt|;
end_typedef
begin_typedef
DECL|typedef|TQualifierList
typedef|typedef
name|TVector
operator|<
name|int
operator|>
name|TQualifierList
expr_stmt|;
end_typedef
begin_comment
comment|//
end_comment
begin_comment
comment|// Nodes that operate on an arbitrary sized set of children.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermAggregate
range|:
name|public
name|TIntermOperator
block|{
name|public
operator|:
name|TIntermAggregate
argument_list|()
operator|:
name|TIntermOperator
argument_list|(
name|EOpNull
argument_list|)
block|,
name|userDefined
argument_list|(
name|false
argument_list|)
block|,
name|useEmulatedFunction
argument_list|(
argument|false
argument_list|)
block|{ }
name|TIntermAggregate
argument_list|(
argument|TOperator o
argument_list|)
operator|:
name|TIntermOperator
argument_list|(
name|o
argument_list|)
block|,
name|useEmulatedFunction
argument_list|(
argument|false
argument_list|)
block|{ }
operator|~
name|TIntermAggregate
argument_list|()
block|{ }
name|virtual
name|TIntermAggregate
operator|*
name|getAsAggregate
argument_list|()
block|{
return|return
name|this
return|;
block|}
name|virtual
name|void
name|traverse
argument_list|(
name|TIntermTraverser
operator|*
argument_list|)
block|;
name|TIntermSequence
operator|&
name|getSequence
argument_list|()
block|{
return|return
name|sequence
return|;
block|}
name|void
name|setName
argument_list|(
argument|const TString& n
argument_list|)
block|{
name|name
operator|=
name|n
block|; }
specifier|const
name|TString
operator|&
name|getName
argument_list|()
specifier|const
block|{
return|return
name|name
return|;
block|}
name|void
name|setUserDefined
argument_list|()
block|{
name|userDefined
operator|=
name|true
block|; }
name|bool
name|isUserDefined
argument_list|()
specifier|const
block|{
return|return
name|userDefined
return|;
block|}
name|void
name|setOptimize
argument_list|(
argument|bool o
argument_list|)
block|{
name|optimize
operator|=
name|o
block|; }
name|bool
name|getOptimize
argument_list|()
block|{
return|return
name|optimize
return|;
block|}
name|void
name|setDebug
argument_list|(
argument|bool d
argument_list|)
block|{
name|debug
operator|=
name|d
block|; }
name|bool
name|getDebug
argument_list|()
block|{
return|return
name|debug
return|;
block|}
name|void
name|setUseEmulatedFunction
argument_list|()
block|{
name|useEmulatedFunction
operator|=
name|true
block|; }
name|bool
name|getUseEmulatedFunction
argument_list|()
block|{
return|return
name|useEmulatedFunction
return|;
block|}
name|protected
operator|:
name|TIntermAggregate
argument_list|(
specifier|const
name|TIntermAggregate
operator|&
argument_list|)
block|;
comment|// disallow copy constructor
name|TIntermAggregate
operator|&
name|operator
operator|=
operator|(
specifier|const
name|TIntermAggregate
operator|&
operator|)
block|;
comment|// disallow assignment operator
name|TIntermSequence
name|sequence
block|;
name|TString
name|name
block|;
name|bool
name|userDefined
block|;
comment|// used for user defined function names
name|bool
name|optimize
block|;
name|bool
name|debug
block|;
comment|// If set to true, replace the built-in function call with an emulated one
comment|// to work around driver bugs.
name|bool
name|useEmulatedFunction
block|; }
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// For if tests.  Simplified since there is no switch statement.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermSelection
range|:
name|public
name|TIntermTyped
block|{
name|public
operator|:
name|TIntermSelection
argument_list|(
name|TIntermTyped
operator|*
name|cond
argument_list|,
name|TIntermNode
operator|*
name|trueB
argument_list|,
name|TIntermNode
operator|*
name|falseB
argument_list|)
operator|:
name|TIntermTyped
argument_list|(
name|TType
argument_list|(
name|EbtVoid
argument_list|,
name|EbpUndefined
argument_list|)
argument_list|)
block|,
name|condition
argument_list|(
name|cond
argument_list|)
block|,
name|trueBlock
argument_list|(
name|trueB
argument_list|)
block|,
name|falseBlock
argument_list|(
argument|falseB
argument_list|)
block|{}
name|TIntermSelection
argument_list|(
name|TIntermTyped
operator|*
name|cond
argument_list|,
name|TIntermNode
operator|*
name|trueB
argument_list|,
name|TIntermNode
operator|*
name|falseB
argument_list|,
specifier|const
name|TType
operator|&
name|type
argument_list|)
operator|:
name|TIntermTyped
argument_list|(
name|type
argument_list|)
block|,
name|condition
argument_list|(
name|cond
argument_list|)
block|,
name|trueBlock
argument_list|(
name|trueB
argument_list|)
block|,
name|falseBlock
argument_list|(
argument|falseB
argument_list|)
block|{}
name|virtual
name|void
name|traverse
argument_list|(
name|TIntermTraverser
operator|*
argument_list|)
block|;
name|bool
name|usesTernaryOperator
argument_list|()
specifier|const
block|{
return|return
name|getBasicType
argument_list|()
operator|!=
name|EbtVoid
return|;
block|}
name|TIntermNode
operator|*
name|getCondition
argument_list|()
specifier|const
block|{
return|return
name|condition
return|;
block|}
name|TIntermNode
operator|*
name|getTrueBlock
argument_list|()
specifier|const
block|{
return|return
name|trueBlock
return|;
block|}
name|TIntermNode
operator|*
name|getFalseBlock
argument_list|()
specifier|const
block|{
return|return
name|falseBlock
return|;
block|}
name|TIntermSelection
operator|*
name|getAsSelectionNode
argument_list|()
block|{
return|return
name|this
return|;
block|}
name|protected
operator|:
name|TIntermTyped
operator|*
name|condition
block|;
name|TIntermNode
operator|*
name|trueBlock
block|;
name|TIntermNode
operator|*
name|falseBlock
block|; }
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enum|Visit
enum|enum
name|Visit
block|{
DECL|enumerator|PreVisit
name|PreVisit
block|,
DECL|enumerator|InVisit
name|InVisit
block|,
DECL|enumerator|PostVisit
name|PostVisit
block|}
enum|;
end_enum
begin_comment
comment|//
end_comment
begin_comment
comment|// For traversing the tree.  User should derive from this,
end_comment
begin_comment
comment|// put their traversal specific data in it, and then pass
end_comment
begin_comment
comment|// it to a Traverse method.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// When using this, just fill in the methods for nodes you want visited.
end_comment
begin_comment
comment|// Return false from a pre-visit to skip visiting that node's subtree.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermTraverser
block|{
name|public
label|:
name|POOL_ALLOCATOR_NEW_DELETE
argument_list|()
expr_stmt|;
name|TIntermTraverser
argument_list|(
argument|bool preVisit = true
argument_list|,
argument|bool inVisit = false
argument_list|,
argument|bool postVisit = false
argument_list|,
argument|bool rightToLeft = false
argument_list|)
block|:
name|preVisit
argument_list|(
name|preVisit
argument_list|)
operator|,
name|inVisit
argument_list|(
name|inVisit
argument_list|)
operator|,
name|postVisit
argument_list|(
name|postVisit
argument_list|)
operator|,
name|rightToLeft
argument_list|(
name|rightToLeft
argument_list|)
operator|,
name|depth
argument_list|(
literal|0
argument_list|)
operator|,
name|maxDepth
argument_list|(
literal|0
argument_list|)
block|{}
name|virtual
operator|~
name|TIntermTraverser
argument_list|()
block|{}
expr_stmt|;
name|virtual
name|void
name|visitSymbol
parameter_list|(
name|TIntermSymbol
modifier|*
parameter_list|)
block|{}
name|virtual
name|void
name|visitConstantUnion
parameter_list|(
name|TIntermConstantUnion
modifier|*
parameter_list|)
block|{}
name|virtual
name|bool
name|visitBinary
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermBinary
modifier|*
parameter_list|)
block|{
return|return
name|true
return|;
block|}
name|virtual
name|bool
name|visitUnary
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermUnary
modifier|*
parameter_list|)
block|{
return|return
name|true
return|;
block|}
name|virtual
name|bool
name|visitSelection
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermSelection
modifier|*
parameter_list|)
block|{
return|return
name|true
return|;
block|}
name|virtual
name|bool
name|visitAggregate
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermAggregate
modifier|*
parameter_list|)
block|{
return|return
name|true
return|;
block|}
name|virtual
name|bool
name|visitLoop
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermLoop
modifier|*
parameter_list|)
block|{
return|return
name|true
return|;
block|}
name|virtual
name|bool
name|visitBranch
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermBranch
modifier|*
parameter_list|)
block|{
return|return
name|true
return|;
block|}
name|int
name|getMaxDepth
argument_list|()
specifier|const
block|{
return|return
name|maxDepth
return|;
block|}
name|void
name|incrementDepth
parameter_list|()
block|{
name|depth
operator|++
expr_stmt|;
name|maxDepth
operator|=
name|std
operator|::
name|max
argument_list|(
name|maxDepth
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
name|void
name|decrementDepth
parameter_list|()
block|{
name|depth
operator|--
expr_stmt|;
block|}
comment|// Return the original name if hash function pointer is NULL;
comment|// otherwise return the hashed name.
specifier|static
name|TString
name|hash
parameter_list|(
specifier|const
name|TString
modifier|&
name|name
parameter_list|,
name|ShHashFunction64
name|hashFunction
parameter_list|)
function_decl|;
specifier|const
name|bool
name|preVisit
decl_stmt|;
specifier|const
name|bool
name|inVisit
decl_stmt|;
specifier|const
name|bool
name|postVisit
decl_stmt|;
specifier|const
name|bool
name|rightToLeft
decl_stmt|;
name|protected
label|:
name|int
name|depth
decl_stmt|;
name|int
name|maxDepth
decl_stmt|;
block|}
end_decl_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// __INTERMEDIATE_H
end_comment
end_unit
