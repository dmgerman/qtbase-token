begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Build the intermediate representation.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|<float.h>
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_include
include|#
directive|include
file|"compiler/translator/Intermediate.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/RemoveTree.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/SymbolTable.h"
end_include
begin_comment
comment|////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// First set of functions are to help build the intermediate representation.
end_comment
begin_comment
comment|// These functions are not member functions of the nodes.
end_comment
begin_comment
comment|// They are called from parser productions.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|/////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Add a terminal node for an identifier in an expression.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns the added node.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addSymbol
name|TIntermSymbol
modifier|*
name|TIntermediate
operator|::
name|addSymbol
parameter_list|(
name|int
name|id
parameter_list|,
specifier|const
name|TString
modifier|&
name|name
parameter_list|,
specifier|const
name|TType
modifier|&
name|type
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
name|TIntermSymbol
modifier|*
name|node
init|=
operator|new
name|TIntermSymbol
argument_list|(
name|id
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|node
operator|->
name|setLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Connect two nodes with a new parent that does a binary operation on the nodes.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns the added node.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addBinaryMath
name|TIntermTyped
modifier|*
name|TIntermediate
operator|::
name|addBinaryMath
parameter_list|(
name|TOperator
name|op
parameter_list|,
name|TIntermTyped
modifier|*
name|left
parameter_list|,
name|TIntermTyped
modifier|*
name|right
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|EOpEqual
case|:
case|case
name|EOpNotEqual
case|:
if|if
condition|(
name|left
operator|->
name|isArray
argument_list|()
condition|)
return|return
name|NULL
return|;
break|break;
case|case
name|EOpLessThan
case|:
case|case
name|EOpGreaterThan
case|:
case|case
name|EOpLessThanEqual
case|:
case|case
name|EOpGreaterThanEqual
case|:
if|if
condition|(
name|left
operator|->
name|isMatrix
argument_list|()
operator|||
name|left
operator|->
name|isArray
argument_list|()
operator|||
name|left
operator|->
name|isVector
argument_list|()
operator|||
name|left
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtStruct
condition|)
block|{
return|return
name|NULL
return|;
block|}
break|break;
case|case
name|EOpLogicalOr
case|:
case|case
name|EOpLogicalXor
case|:
case|case
name|EOpLogicalAnd
case|:
if|if
condition|(
name|left
operator|->
name|getBasicType
argument_list|()
operator|!=
name|EbtBool
operator|||
name|left
operator|->
name|isMatrix
argument_list|()
operator|||
name|left
operator|->
name|isArray
argument_list|()
operator|||
name|left
operator|->
name|isVector
argument_list|()
condition|)
block|{
return|return
name|NULL
return|;
block|}
break|break;
case|case
name|EOpAdd
case|:
case|case
name|EOpSub
case|:
case|case
name|EOpDiv
case|:
case|case
name|EOpMul
case|:
if|if
condition|(
name|left
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtStruct
operator|||
name|left
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtBool
condition|)
return|return
name|NULL
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|left
operator|->
name|getBasicType
argument_list|()
operator|!=
name|right
operator|->
name|getBasicType
argument_list|()
condition|)
block|{
return|return
name|NULL
return|;
block|}
comment|//
comment|// Need a new node holding things together then.  Make
comment|// one and promote it to the right type.
comment|//
name|TIntermBinary
modifier|*
name|node
init|=
operator|new
name|TIntermBinary
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|node
operator|->
name|setLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|node
operator|->
name|setLeft
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|node
operator|->
name|setRight
argument_list|(
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|promote
argument_list|(
name|mInfoSink
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|//
comment|// See if we can fold constants.
comment|//
name|TIntermConstantUnion
modifier|*
name|leftTempConstant
init|=
name|left
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
name|TIntermConstantUnion
modifier|*
name|rightTempConstant
init|=
name|right
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
if|if
condition|(
name|leftTempConstant
operator|&&
name|rightTempConstant
condition|)
block|{
name|TIntermTyped
modifier|*
name|typedReturnNode
init|=
name|leftTempConstant
operator|->
name|fold
argument_list|(
name|node
operator|->
name|getOp
argument_list|()
argument_list|,
name|rightTempConstant
argument_list|,
name|mInfoSink
argument_list|)
decl_stmt|;
if|if
condition|(
name|typedReturnNode
condition|)
return|return
name|typedReturnNode
return|;
block|}
return|return
name|node
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Connect two nodes through an assignment.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns the added node.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addAssign
name|TIntermTyped
modifier|*
name|TIntermediate
operator|::
name|addAssign
parameter_list|(
name|TOperator
name|op
parameter_list|,
name|TIntermTyped
modifier|*
name|left
parameter_list|,
name|TIntermTyped
modifier|*
name|right
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
if|if
condition|(
name|left
operator|->
name|getType
argument_list|()
operator|.
name|getStruct
argument_list|()
operator|||
name|right
operator|->
name|getType
argument_list|()
operator|.
name|getStruct
argument_list|()
condition|)
block|{
if|if
condition|(
name|left
operator|->
name|getType
argument_list|()
operator|!=
name|right
operator|->
name|getType
argument_list|()
condition|)
block|{
return|return
name|NULL
return|;
block|}
block|}
name|TIntermBinary
modifier|*
name|node
init|=
operator|new
name|TIntermBinary
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|node
operator|->
name|setLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|node
operator|->
name|setLeft
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|node
operator|->
name|setRight
argument_list|(
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|promote
argument_list|(
name|mInfoSink
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|node
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Connect two nodes through an index operator, where the left node is the base
end_comment
begin_comment
comment|// of an array or struct, and the right node is a direct or indirect offset.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns the added node.
end_comment
begin_comment
comment|// The caller should set the type of the returned node.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addIndex
name|TIntermTyped
modifier|*
name|TIntermediate
operator|::
name|addIndex
parameter_list|(
name|TOperator
name|op
parameter_list|,
name|TIntermTyped
modifier|*
name|base
parameter_list|,
name|TIntermTyped
modifier|*
name|index
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
name|TIntermBinary
modifier|*
name|node
init|=
operator|new
name|TIntermBinary
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|node
operator|->
name|setLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|node
operator|->
name|setLeft
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|node
operator|->
name|setRight
argument_list|(
name|index
argument_list|)
expr_stmt|;
comment|// caller should set the type
return|return
name|node
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Add one node as the parent of another that it operates on.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns the added node.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addUnaryMath
name|TIntermTyped
modifier|*
name|TIntermediate
operator|::
name|addUnaryMath
parameter_list|(
name|TOperator
name|op
parameter_list|,
name|TIntermNode
modifier|*
name|childNode
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
name|TIntermUnary
modifier|*
name|node
decl_stmt|;
name|TIntermTyped
modifier|*
name|child
init|=
name|childNode
operator|->
name|getAsTyped
argument_list|()
decl_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
block|{
name|mInfoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|line
argument_list|,
literal|"Bad type in AddUnaryMath"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|EOpLogicalNot
case|:
if|if
condition|(
name|child
operator|->
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|!=
name|EbtBool
operator|||
name|child
operator|->
name|getType
argument_list|()
operator|.
name|isMatrix
argument_list|()
operator|||
name|child
operator|->
name|getType
argument_list|()
operator|.
name|isArray
argument_list|()
operator|||
name|child
operator|->
name|getType
argument_list|()
operator|.
name|isVector
argument_list|()
condition|)
block|{
return|return
name|NULL
return|;
block|}
break|break;
case|case
name|EOpPostIncrement
case|:
case|case
name|EOpPreIncrement
case|:
case|case
name|EOpPostDecrement
case|:
case|case
name|EOpPreDecrement
case|:
case|case
name|EOpNegative
case|:
if|if
condition|(
name|child
operator|->
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtStruct
operator|||
name|child
operator|->
name|getType
argument_list|()
operator|.
name|isArray
argument_list|()
condition|)
block|{
return|return
name|NULL
return|;
block|}
default|default:
break|break;
block|}
name|TIntermConstantUnion
modifier|*
name|childTempConstant
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|child
operator|->
name|getAsConstantUnion
argument_list|()
condition|)
name|childTempConstant
operator|=
name|child
operator|->
name|getAsConstantUnion
argument_list|()
expr_stmt|;
comment|//
comment|// Make a new node for the operator.
comment|//
name|node
operator|=
operator|new
name|TIntermUnary
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|node
operator|->
name|setLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|node
operator|->
name|setOperand
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|promote
argument_list|(
name|mInfoSink
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|childTempConstant
condition|)
block|{
name|TIntermTyped
modifier|*
name|newChild
init|=
name|childTempConstant
operator|->
name|fold
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|mInfoSink
argument_list|)
decl_stmt|;
if|if
condition|(
name|newChild
condition|)
return|return
name|newChild
return|;
block|}
return|return
name|node
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// This is the safe way to change the operator on an aggregate, as it
end_comment
begin_comment
comment|// does lots of error checking and fixing.  Especially for establishing
end_comment
begin_comment
comment|// a function call's operation on it's set of parameters.  Sequences
end_comment
begin_comment
comment|// of instructions are also aggregates, but they just direnctly set
end_comment
begin_comment
comment|// their operator to EOpSequence.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns an aggregate node, which could be the one passed in if
end_comment
begin_comment
comment|// it was already an aggregate but no operator was set.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|setAggregateOperator
name|TIntermAggregate
modifier|*
name|TIntermediate
operator|::
name|setAggregateOperator
parameter_list|(
name|TIntermNode
modifier|*
name|node
parameter_list|,
name|TOperator
name|op
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
name|TIntermAggregate
modifier|*
name|aggNode
decl_stmt|;
comment|//
comment|// Make sure we have an aggregate.  If not turn it into one.
comment|//
if|if
condition|(
name|node
condition|)
block|{
name|aggNode
operator|=
name|node
operator|->
name|getAsAggregate
argument_list|()
expr_stmt|;
if|if
condition|(
name|aggNode
operator|==
name|NULL
operator|||
name|aggNode
operator|->
name|getOp
argument_list|()
operator|!=
name|EOpNull
condition|)
block|{
comment|//
comment|// Make an aggregate containing this node.
comment|//
name|aggNode
operator|=
operator|new
name|TIntermAggregate
argument_list|()
expr_stmt|;
name|aggNode
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|aggNode
operator|=
operator|new
name|TIntermAggregate
argument_list|()
expr_stmt|;
block|}
comment|//
comment|// Set the operator.
comment|//
name|aggNode
operator|->
name|setOp
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|aggNode
operator|->
name|setLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
name|aggNode
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Safe way to combine two nodes into an aggregate.  Works with null pointers,
end_comment
begin_comment
comment|// a node that's not a aggregate yet, etc.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns the resulting aggregate, unless 0 was passed in for
end_comment
begin_comment
comment|// both existing nodes.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|growAggregate
name|TIntermAggregate
modifier|*
name|TIntermediate
operator|::
name|growAggregate
parameter_list|(
name|TIntermNode
modifier|*
name|left
parameter_list|,
name|TIntermNode
modifier|*
name|right
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
if|if
condition|(
name|left
operator|==
name|NULL
operator|&&
name|right
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|TIntermAggregate
modifier|*
name|aggNode
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|left
condition|)
name|aggNode
operator|=
name|left
operator|->
name|getAsAggregate
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|aggNode
operator|||
name|aggNode
operator|->
name|getOp
argument_list|()
operator|!=
name|EOpNull
condition|)
block|{
name|aggNode
operator|=
operator|new
name|TIntermAggregate
expr_stmt|;
if|if
condition|(
name|left
condition|)
name|aggNode
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|left
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|right
condition|)
name|aggNode
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|right
argument_list|)
expr_stmt|;
name|aggNode
operator|->
name|setLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
name|aggNode
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Turn an existing node into an aggregate.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns an aggregate, unless NULL was passed in for the existing node.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|makeAggregate
name|TIntermAggregate
modifier|*
name|TIntermediate
operator|::
name|makeAggregate
parameter_list|(
name|TIntermNode
modifier|*
name|node
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|TIntermAggregate
modifier|*
name|aggNode
init|=
operator|new
name|TIntermAggregate
decl_stmt|;
name|aggNode
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|aggNode
operator|->
name|setLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
name|aggNode
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// For "if" test nodes.  There are three children; a condition,
end_comment
begin_comment
comment|// a true path, and a false path.  The two paths are in the
end_comment
begin_comment
comment|// nodePair.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns the selection node created.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addSelection
name|TIntermNode
modifier|*
name|TIntermediate
operator|::
name|addSelection
parameter_list|(
name|TIntermTyped
modifier|*
name|cond
parameter_list|,
name|TIntermNodePair
name|nodePair
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
comment|//
comment|// For compile time constant selections, prune the code and
comment|// test now.
comment|//
if|if
condition|(
name|cond
operator|->
name|getAsTyped
argument_list|()
operator|&&
name|cond
operator|->
name|getAsTyped
argument_list|()
operator|->
name|getAsConstantUnion
argument_list|()
condition|)
block|{
if|if
condition|(
name|cond
operator|->
name|getAsConstantUnion
argument_list|()
operator|->
name|getBConst
argument_list|(
literal|0
argument_list|)
operator|==
literal|true
condition|)
block|{
return|return
name|nodePair
operator|.
name|node1
condition|?
name|setAggregateOperator
argument_list|(
name|nodePair
operator|.
name|node1
argument_list|,
name|EOpSequence
argument_list|,
name|nodePair
operator|.
name|node1
operator|->
name|getLine
argument_list|()
argument_list|)
else|:
name|NULL
return|;
block|}
else|else
block|{
return|return
name|nodePair
operator|.
name|node2
condition|?
name|setAggregateOperator
argument_list|(
name|nodePair
operator|.
name|node2
argument_list|,
name|EOpSequence
argument_list|,
name|nodePair
operator|.
name|node2
operator|->
name|getLine
argument_list|()
argument_list|)
else|:
name|NULL
return|;
block|}
block|}
name|TIntermSelection
modifier|*
name|node
init|=
operator|new
name|TIntermSelection
argument_list|(
name|cond
argument_list|,
name|nodePair
operator|.
name|node1
argument_list|,
name|nodePair
operator|.
name|node2
argument_list|)
decl_stmt|;
name|node
operator|->
name|setLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
end_function
begin_function
DECL|function|addComma
name|TIntermTyped
modifier|*
name|TIntermediate
operator|::
name|addComma
parameter_list|(
name|TIntermTyped
modifier|*
name|left
parameter_list|,
name|TIntermTyped
modifier|*
name|right
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
if|if
condition|(
name|left
operator|->
name|getType
argument_list|()
operator|.
name|getQualifier
argument_list|()
operator|==
name|EvqConst
operator|&&
name|right
operator|->
name|getType
argument_list|()
operator|.
name|getQualifier
argument_list|()
operator|==
name|EvqConst
condition|)
block|{
return|return
name|right
return|;
block|}
else|else
block|{
name|TIntermTyped
modifier|*
name|commaAggregate
init|=
name|growAggregate
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|line
argument_list|)
decl_stmt|;
name|commaAggregate
operator|->
name|getAsAggregate
argument_list|()
operator|->
name|setOp
argument_list|(
name|EOpComma
argument_list|)
expr_stmt|;
name|commaAggregate
operator|->
name|setType
argument_list|(
name|right
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|commaAggregate
operator|->
name|getTypePointer
argument_list|()
operator|->
name|setQualifier
argument_list|(
name|EvqTemporary
argument_list|)
expr_stmt|;
return|return
name|commaAggregate
return|;
block|}
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// For "?:" test nodes.  There are three children; a condition,
end_comment
begin_comment
comment|// a true path, and a false path.  The two paths are specified
end_comment
begin_comment
comment|// as separate parameters.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns the selection node created, or 0 if one could not be.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addSelection
name|TIntermTyped
modifier|*
name|TIntermediate
operator|::
name|addSelection
parameter_list|(
name|TIntermTyped
modifier|*
name|cond
parameter_list|,
name|TIntermTyped
modifier|*
name|trueBlock
parameter_list|,
name|TIntermTyped
modifier|*
name|falseBlock
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cond
operator|||
operator|!
name|trueBlock
operator|||
operator|!
name|falseBlock
operator|||
name|trueBlock
operator|->
name|getType
argument_list|()
operator|!=
name|falseBlock
operator|->
name|getType
argument_list|()
condition|)
block|{
return|return
name|NULL
return|;
block|}
comment|//
comment|// See if all the operands are constant, then fold it otherwise not.
comment|//
if|if
condition|(
name|cond
operator|->
name|getAsConstantUnion
argument_list|()
operator|&&
name|trueBlock
operator|->
name|getAsConstantUnion
argument_list|()
operator|&&
name|falseBlock
operator|->
name|getAsConstantUnion
argument_list|()
condition|)
block|{
if|if
condition|(
name|cond
operator|->
name|getAsConstantUnion
argument_list|()
operator|->
name|getBConst
argument_list|(
literal|0
argument_list|)
condition|)
return|return
name|trueBlock
return|;
else|else
return|return
name|falseBlock
return|;
block|}
comment|//
comment|// Make a selection node.
comment|//
name|TIntermSelection
modifier|*
name|node
init|=
operator|new
name|TIntermSelection
argument_list|(
name|cond
argument_list|,
name|trueBlock
argument_list|,
name|falseBlock
argument_list|,
name|trueBlock
operator|->
name|getType
argument_list|()
argument_list|)
decl_stmt|;
name|node
operator|->
name|getTypePointer
argument_list|()
operator|->
name|setQualifier
argument_list|(
name|EvqTemporary
argument_list|)
expr_stmt|;
name|node
operator|->
name|setLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Constant terminal nodes.  Has a union that contains bool, float or int constants
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns the constant union node created.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addConstantUnion
name|TIntermConstantUnion
modifier|*
name|TIntermediate
operator|::
name|addConstantUnion
parameter_list|(
name|ConstantUnion
modifier|*
name|unionArrayPointer
parameter_list|,
specifier|const
name|TType
modifier|&
name|t
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
name|TIntermConstantUnion
modifier|*
name|node
init|=
operator|new
name|TIntermConstantUnion
argument_list|(
name|unionArrayPointer
argument_list|,
name|t
argument_list|)
decl_stmt|;
name|node
operator|->
name|setLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
end_function
begin_function
DECL|function|addSwizzle
name|TIntermTyped
modifier|*
name|TIntermediate
operator|::
name|addSwizzle
parameter_list|(
name|TVectorFields
modifier|&
name|fields
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
name|TIntermAggregate
modifier|*
name|node
init|=
operator|new
name|TIntermAggregate
argument_list|(
name|EOpSequence
argument_list|)
decl_stmt|;
name|node
operator|->
name|setLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|TIntermConstantUnion
modifier|*
name|constIntNode
decl_stmt|;
name|TIntermSequence
modifier|*
name|sequenceVector
init|=
name|node
operator|->
name|getSequence
argument_list|()
decl_stmt|;
name|ConstantUnion
modifier|*
name|unionArray
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|num
condition|;
name|i
operator|++
control|)
block|{
name|unionArray
operator|=
operator|new
name|ConstantUnion
index|[
literal|1
index|]
expr_stmt|;
name|unionArray
operator|->
name|setIConst
argument_list|(
name|fields
operator|.
name|offsets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|constIntNode
operator|=
name|addConstantUnion
argument_list|(
name|unionArray
argument_list|,
name|TType
argument_list|(
name|EbtInt
argument_list|,
name|EbpUndefined
argument_list|,
name|EvqConst
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|sequenceVector
operator|->
name|push_back
argument_list|(
name|constIntNode
argument_list|)
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Create loop nodes.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addLoop
name|TIntermNode
modifier|*
name|TIntermediate
operator|::
name|addLoop
parameter_list|(
name|TLoopType
name|type
parameter_list|,
name|TIntermNode
modifier|*
name|init
parameter_list|,
name|TIntermTyped
modifier|*
name|cond
parameter_list|,
name|TIntermTyped
modifier|*
name|expr
parameter_list|,
name|TIntermNode
modifier|*
name|body
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
name|TIntermNode
modifier|*
name|node
init|=
operator|new
name|TIntermLoop
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
name|cond
argument_list|,
name|expr
argument_list|,
name|body
argument_list|)
decl_stmt|;
name|node
operator|->
name|setLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Add branches.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addBranch
name|TIntermBranch
modifier|*
name|TIntermediate
operator|::
name|addBranch
parameter_list|(
name|TOperator
name|branchOp
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
return|return
name|addBranch
argument_list|(
name|branchOp
argument_list|,
literal|0
argument_list|,
name|line
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|addBranch
name|TIntermBranch
modifier|*
name|TIntermediate
operator|::
name|addBranch
parameter_list|(
name|TOperator
name|branchOp
parameter_list|,
name|TIntermTyped
modifier|*
name|expression
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
name|TIntermBranch
modifier|*
name|node
init|=
operator|new
name|TIntermBranch
argument_list|(
name|branchOp
argument_list|,
name|expression
argument_list|)
decl_stmt|;
name|node
operator|->
name|setLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// This is to be executed once the final root is put on top by the parsing
end_comment
begin_comment
comment|// process.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|postProcess
name|bool
name|TIntermediate
operator|::
name|postProcess
parameter_list|(
name|TIntermNode
modifier|*
name|root
parameter_list|)
block|{
if|if
condition|(
name|root
operator|==
name|NULL
condition|)
return|return
literal|true
return|;
comment|//
comment|// First, finish off the top level sequence, if any
comment|//
name|TIntermAggregate
modifier|*
name|aggRoot
init|=
name|root
operator|->
name|getAsAggregate
argument_list|()
decl_stmt|;
if|if
condition|(
name|aggRoot
operator|&&
name|aggRoot
operator|->
name|getOp
argument_list|()
operator|==
name|EOpNull
condition|)
name|aggRoot
operator|->
name|setOp
argument_list|(
name|EOpSequence
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// This deletes the tree.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|remove
name|void
name|TIntermediate
operator|::
name|remove
parameter_list|(
name|TIntermNode
modifier|*
name|root
parameter_list|)
block|{
if|if
condition|(
name|root
condition|)
name|RemoveAllTreeNodes
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
end_function
end_unit
