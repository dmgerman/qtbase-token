begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Build the intermediate representation.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|<float.h>
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_include
include|#
directive|include
file|"compiler/translator/Intermediate.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/SymbolTable.h"
end_include
begin_comment
comment|////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// First set of functions are to help build the intermediate representation.
end_comment
begin_comment
comment|// These functions are not member functions of the nodes.
end_comment
begin_comment
comment|// They are called from parser productions.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|/////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Add a terminal node for an identifier in an expression.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns the added node.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addSymbol
name|TIntermSymbol
modifier|*
name|TIntermediate
operator|::
name|addSymbol
parameter_list|(
name|int
name|id
parameter_list|,
specifier|const
name|TString
modifier|&
name|name
parameter_list|,
specifier|const
name|TType
modifier|&
name|type
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
name|TIntermSymbol
modifier|*
name|node
init|=
operator|new
name|TIntermSymbol
argument_list|(
name|id
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|node
operator|->
name|setLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Connect two nodes with a new parent that does a binary operation on the nodes.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns the added node.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addBinaryMath
name|TIntermTyped
modifier|*
name|TIntermediate
operator|::
name|addBinaryMath
parameter_list|(
name|TOperator
name|op
parameter_list|,
name|TIntermTyped
modifier|*
name|left
parameter_list|,
name|TIntermTyped
modifier|*
name|right
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
comment|//
comment|// Need a new node holding things together then.  Make
comment|// one and promote it to the right type.
comment|//
name|TIntermBinary
modifier|*
name|node
init|=
operator|new
name|TIntermBinary
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|node
operator|->
name|setLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|node
operator|->
name|setLeft
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|node
operator|->
name|setRight
argument_list|(
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|promote
argument_list|(
name|mInfoSink
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|// See if we can fold constants.
name|TIntermTyped
modifier|*
name|foldedNode
init|=
name|node
operator|->
name|fold
argument_list|(
name|mInfoSink
argument_list|)
decl_stmt|;
if|if
condition|(
name|foldedNode
condition|)
return|return
name|foldedNode
return|;
return|return
name|node
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Connect two nodes through an assignment.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns the added node.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addAssign
name|TIntermTyped
modifier|*
name|TIntermediate
operator|::
name|addAssign
parameter_list|(
name|TOperator
name|op
parameter_list|,
name|TIntermTyped
modifier|*
name|left
parameter_list|,
name|TIntermTyped
modifier|*
name|right
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
if|if
condition|(
name|left
operator|->
name|getType
argument_list|()
operator|.
name|getStruct
argument_list|()
operator|||
name|right
operator|->
name|getType
argument_list|()
operator|.
name|getStruct
argument_list|()
condition|)
block|{
if|if
condition|(
name|left
operator|->
name|getType
argument_list|()
operator|!=
name|right
operator|->
name|getType
argument_list|()
condition|)
block|{
return|return
name|NULL
return|;
block|}
block|}
name|TIntermBinary
modifier|*
name|node
init|=
operator|new
name|TIntermBinary
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|node
operator|->
name|setLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|node
operator|->
name|setLeft
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|node
operator|->
name|setRight
argument_list|(
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|promote
argument_list|(
name|mInfoSink
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|node
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Connect two nodes through an index operator, where the left node is the base
end_comment
begin_comment
comment|// of an array or struct, and the right node is a direct or indirect offset.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns the added node.
end_comment
begin_comment
comment|// The caller should set the type of the returned node.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addIndex
name|TIntermTyped
modifier|*
name|TIntermediate
operator|::
name|addIndex
parameter_list|(
name|TOperator
name|op
parameter_list|,
name|TIntermTyped
modifier|*
name|base
parameter_list|,
name|TIntermTyped
modifier|*
name|index
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
name|TIntermBinary
modifier|*
name|node
init|=
operator|new
name|TIntermBinary
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|node
operator|->
name|setLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|node
operator|->
name|setLeft
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|node
operator|->
name|setRight
argument_list|(
name|index
argument_list|)
expr_stmt|;
comment|// caller should set the type
return|return
name|node
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Add one node as the parent of another that it operates on.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns the added node.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addUnaryMath
name|TIntermTyped
modifier|*
name|TIntermediate
operator|::
name|addUnaryMath
parameter_list|(
name|TOperator
name|op
parameter_list|,
name|TIntermTyped
modifier|*
name|child
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
specifier|const
name|TType
modifier|*
name|funcReturnType
parameter_list|)
block|{
comment|//
comment|// Make a new node for the operator.
comment|//
name|TIntermUnary
modifier|*
name|node
init|=
operator|new
name|TIntermUnary
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|node
operator|->
name|setLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|node
operator|->
name|setOperand
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|node
operator|->
name|promote
argument_list|(
name|funcReturnType
argument_list|)
expr_stmt|;
name|TIntermTyped
modifier|*
name|foldedNode
init|=
name|node
operator|->
name|fold
argument_list|(
name|mInfoSink
argument_list|)
decl_stmt|;
if|if
condition|(
name|foldedNode
condition|)
return|return
name|foldedNode
return|;
return|return
name|node
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// This is the safe way to change the operator on an aggregate, as it
end_comment
begin_comment
comment|// does lots of error checking and fixing.  Especially for establishing
end_comment
begin_comment
comment|// a function call's operation on it's set of parameters.  Sequences
end_comment
begin_comment
comment|// of instructions are also aggregates, but they just direnctly set
end_comment
begin_comment
comment|// their operator to EOpSequence.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns an aggregate node, which could be the one passed in if
end_comment
begin_comment
comment|// it was already an aggregate but no operator was set.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|setAggregateOperator
name|TIntermAggregate
modifier|*
name|TIntermediate
operator|::
name|setAggregateOperator
parameter_list|(
name|TIntermNode
modifier|*
name|node
parameter_list|,
name|TOperator
name|op
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
name|TIntermAggregate
modifier|*
name|aggNode
decl_stmt|;
comment|//
comment|// Make sure we have an aggregate.  If not turn it into one.
comment|//
if|if
condition|(
name|node
condition|)
block|{
name|aggNode
operator|=
name|node
operator|->
name|getAsAggregate
argument_list|()
expr_stmt|;
if|if
condition|(
name|aggNode
operator|==
name|NULL
operator|||
name|aggNode
operator|->
name|getOp
argument_list|()
operator|!=
name|EOpNull
condition|)
block|{
comment|//
comment|// Make an aggregate containing this node.
comment|//
name|aggNode
operator|=
operator|new
name|TIntermAggregate
argument_list|()
expr_stmt|;
name|aggNode
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|aggNode
operator|=
operator|new
name|TIntermAggregate
argument_list|()
expr_stmt|;
block|}
comment|//
comment|// Set the operator.
comment|//
name|aggNode
operator|->
name|setOp
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|aggNode
operator|->
name|setLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
name|aggNode
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Safe way to combine two nodes into an aggregate.  Works with null pointers,
end_comment
begin_comment
comment|// a node that's not a aggregate yet, etc.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns the resulting aggregate, unless 0 was passed in for
end_comment
begin_comment
comment|// both existing nodes.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|growAggregate
name|TIntermAggregate
modifier|*
name|TIntermediate
operator|::
name|growAggregate
parameter_list|(
name|TIntermNode
modifier|*
name|left
parameter_list|,
name|TIntermNode
modifier|*
name|right
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
if|if
condition|(
name|left
operator|==
name|NULL
operator|&&
name|right
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|TIntermAggregate
modifier|*
name|aggNode
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|left
condition|)
name|aggNode
operator|=
name|left
operator|->
name|getAsAggregate
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|aggNode
operator|||
name|aggNode
operator|->
name|getOp
argument_list|()
operator|!=
name|EOpNull
condition|)
block|{
name|aggNode
operator|=
operator|new
name|TIntermAggregate
expr_stmt|;
if|if
condition|(
name|left
condition|)
name|aggNode
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|left
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|right
condition|)
name|aggNode
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|right
argument_list|)
expr_stmt|;
name|aggNode
operator|->
name|setLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
name|aggNode
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Turn an existing node into an aggregate.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns an aggregate, unless NULL was passed in for the existing node.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|makeAggregate
name|TIntermAggregate
modifier|*
name|TIntermediate
operator|::
name|makeAggregate
parameter_list|(
name|TIntermNode
modifier|*
name|node
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|TIntermAggregate
modifier|*
name|aggNode
init|=
operator|new
name|TIntermAggregate
decl_stmt|;
name|aggNode
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|aggNode
operator|->
name|setLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
name|aggNode
return|;
block|}
end_function
begin_comment
comment|// If the input node is nullptr, return nullptr.
end_comment
begin_comment
comment|// If the input node is a sequence (block) node, return it.
end_comment
begin_comment
comment|// If the input node is not a sequence node, put it inside a sequence node and return that.
end_comment
begin_function
DECL|function|ensureSequence
name|TIntermAggregate
modifier|*
name|TIntermediate
operator|::
name|ensureSequence
parameter_list|(
name|TIntermNode
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
literal|nullptr
condition|)
return|return
literal|nullptr
return|;
name|TIntermAggregate
modifier|*
name|aggNode
init|=
name|node
operator|->
name|getAsAggregate
argument_list|()
decl_stmt|;
if|if
condition|(
name|aggNode
operator|!=
literal|nullptr
operator|&&
name|aggNode
operator|->
name|getOp
argument_list|()
operator|==
name|EOpSequence
condition|)
return|return
name|aggNode
return|;
name|aggNode
operator|=
name|makeAggregate
argument_list|(
name|node
argument_list|,
name|node
operator|->
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
name|aggNode
operator|->
name|setOp
argument_list|(
name|EOpSequence
argument_list|)
expr_stmt|;
return|return
name|aggNode
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// For "if" test nodes.  There are three children; a condition,
end_comment
begin_comment
comment|// a true path, and a false path.  The two paths are in the
end_comment
begin_comment
comment|// nodePair.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns the selection node created.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addSelection
name|TIntermNode
modifier|*
name|TIntermediate
operator|::
name|addSelection
parameter_list|(
name|TIntermTyped
modifier|*
name|cond
parameter_list|,
name|TIntermNodePair
name|nodePair
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
comment|//
comment|// For compile time constant selections, prune the code and
comment|// test now.
comment|//
if|if
condition|(
name|cond
operator|->
name|getAsConstantUnion
argument_list|()
condition|)
block|{
if|if
condition|(
name|cond
operator|->
name|getAsConstantUnion
argument_list|()
operator|->
name|getBConst
argument_list|(
literal|0
argument_list|)
operator|==
literal|true
condition|)
block|{
return|return
name|nodePair
operator|.
name|node1
condition|?
name|setAggregateOperator
argument_list|(
name|nodePair
operator|.
name|node1
argument_list|,
name|EOpSequence
argument_list|,
name|nodePair
operator|.
name|node1
operator|->
name|getLine
argument_list|()
argument_list|)
else|:
name|NULL
return|;
block|}
else|else
block|{
return|return
name|nodePair
operator|.
name|node2
condition|?
name|setAggregateOperator
argument_list|(
name|nodePair
operator|.
name|node2
argument_list|,
name|EOpSequence
argument_list|,
name|nodePair
operator|.
name|node2
operator|->
name|getLine
argument_list|()
argument_list|)
else|:
name|NULL
return|;
block|}
block|}
name|TIntermSelection
modifier|*
name|node
init|=
operator|new
name|TIntermSelection
argument_list|(
name|cond
argument_list|,
name|ensureSequence
argument_list|(
name|nodePair
operator|.
name|node1
argument_list|)
argument_list|,
name|ensureSequence
argument_list|(
name|nodePair
operator|.
name|node2
argument_list|)
argument_list|)
decl_stmt|;
name|node
operator|->
name|setLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
end_function
begin_function
DECL|function|addComma
name|TIntermTyped
modifier|*
name|TIntermediate
operator|::
name|addComma
parameter_list|(
name|TIntermTyped
modifier|*
name|left
parameter_list|,
name|TIntermTyped
modifier|*
name|right
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
name|int
name|shaderVersion
parameter_list|)
block|{
name|TQualifier
name|resultQualifier
init|=
name|EvqConst
decl_stmt|;
comment|// ESSL3.00 section 12.43: The result of a sequence operator is not a constant-expression.
if|if
condition|(
name|shaderVersion
operator|>=
literal|300
operator|||
name|left
operator|->
name|getQualifier
argument_list|()
operator|!=
name|EvqConst
operator|||
name|right
operator|->
name|getQualifier
argument_list|()
operator|!=
name|EvqConst
condition|)
block|{
name|resultQualifier
operator|=
name|EvqTemporary
expr_stmt|;
block|}
name|TIntermTyped
modifier|*
name|commaNode
init|=
literal|nullptr
decl_stmt|;
if|if
condition|(
operator|!
name|left
operator|->
name|hasSideEffects
argument_list|()
condition|)
block|{
name|commaNode
operator|=
name|right
expr_stmt|;
block|}
else|else
block|{
name|commaNode
operator|=
name|growAggregate
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|commaNode
operator|->
name|getAsAggregate
argument_list|()
operator|->
name|setOp
argument_list|(
name|EOpComma
argument_list|)
expr_stmt|;
name|commaNode
operator|->
name|setType
argument_list|(
name|right
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|commaNode
operator|->
name|getTypePointer
argument_list|()
operator|->
name|setQualifier
argument_list|(
name|resultQualifier
argument_list|)
expr_stmt|;
return|return
name|commaNode
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// For "?:" test nodes.  There are three children; a condition,
end_comment
begin_comment
comment|// a true path, and a false path.  The two paths are specified
end_comment
begin_comment
comment|// as separate parameters.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns the selection node created, or one of trueBlock and falseBlock if the expression could be folded.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addSelection
name|TIntermTyped
modifier|*
name|TIntermediate
operator|::
name|addSelection
parameter_list|(
name|TIntermTyped
modifier|*
name|cond
parameter_list|,
name|TIntermTyped
modifier|*
name|trueBlock
parameter_list|,
name|TIntermTyped
modifier|*
name|falseBlock
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
name|TQualifier
name|resultQualifier
init|=
name|EvqTemporary
decl_stmt|;
if|if
condition|(
name|cond
operator|->
name|getQualifier
argument_list|()
operator|==
name|EvqConst
operator|&&
name|trueBlock
operator|->
name|getQualifier
argument_list|()
operator|==
name|EvqConst
operator|&&
name|falseBlock
operator|->
name|getQualifier
argument_list|()
operator|==
name|EvqConst
condition|)
block|{
name|resultQualifier
operator|=
name|EvqConst
expr_stmt|;
block|}
comment|// Note that the node resulting from here can be a constant union without being qualified as
comment|// constant.
if|if
condition|(
name|cond
operator|->
name|getAsConstantUnion
argument_list|()
condition|)
block|{
if|if
condition|(
name|cond
operator|->
name|getAsConstantUnion
argument_list|()
operator|->
name|getBConst
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|trueBlock
operator|->
name|getTypePointer
argument_list|()
operator|->
name|setQualifier
argument_list|(
name|resultQualifier
argument_list|)
expr_stmt|;
return|return
name|trueBlock
return|;
block|}
else|else
block|{
name|falseBlock
operator|->
name|getTypePointer
argument_list|()
operator|->
name|setQualifier
argument_list|(
name|resultQualifier
argument_list|)
expr_stmt|;
return|return
name|falseBlock
return|;
block|}
block|}
comment|//
comment|// Make a selection node.
comment|//
name|TIntermSelection
modifier|*
name|node
init|=
operator|new
name|TIntermSelection
argument_list|(
name|cond
argument_list|,
name|trueBlock
argument_list|,
name|falseBlock
argument_list|,
name|trueBlock
operator|->
name|getType
argument_list|()
argument_list|)
decl_stmt|;
name|node
operator|->
name|getTypePointer
argument_list|()
operator|->
name|setQualifier
argument_list|(
name|resultQualifier
argument_list|)
expr_stmt|;
name|node
operator|->
name|setLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
end_function
begin_function
DECL|function|addSwitch
name|TIntermSwitch
modifier|*
name|TIntermediate
operator|::
name|addSwitch
parameter_list|(
name|TIntermTyped
modifier|*
name|init
parameter_list|,
name|TIntermAggregate
modifier|*
name|statementList
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
name|TIntermSwitch
modifier|*
name|node
init|=
operator|new
name|TIntermSwitch
argument_list|(
name|init
argument_list|,
name|statementList
argument_list|)
decl_stmt|;
name|node
operator|->
name|setLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
end_function
begin_function
DECL|function|addCase
name|TIntermCase
modifier|*
name|TIntermediate
operator|::
name|addCase
parameter_list|(
name|TIntermTyped
modifier|*
name|condition
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
name|TIntermCase
modifier|*
name|node
init|=
operator|new
name|TIntermCase
argument_list|(
name|condition
argument_list|)
decl_stmt|;
name|node
operator|->
name|setLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Constant terminal nodes.  Has a union that contains bool, float or int constants
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns the constant union node created.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addConstantUnion
name|TIntermConstantUnion
modifier|*
name|TIntermediate
operator|::
name|addConstantUnion
parameter_list|(
specifier|const
name|TConstantUnion
modifier|*
name|constantUnion
parameter_list|,
specifier|const
name|TType
modifier|&
name|type
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
name|TIntermConstantUnion
modifier|*
name|node
init|=
operator|new
name|TIntermConstantUnion
argument_list|(
name|constantUnion
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|node
operator|->
name|setLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
end_function
begin_function
DECL|function|addSwizzle
name|TIntermTyped
modifier|*
name|TIntermediate
operator|::
name|addSwizzle
parameter_list|(
name|TVectorFields
modifier|&
name|fields
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
name|TIntermAggregate
modifier|*
name|node
init|=
operator|new
name|TIntermAggregate
argument_list|(
name|EOpSequence
argument_list|)
decl_stmt|;
name|node
operator|->
name|setLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|TIntermConstantUnion
modifier|*
name|constIntNode
decl_stmt|;
name|TIntermSequence
modifier|*
name|sequenceVector
init|=
name|node
operator|->
name|getSequence
argument_list|()
decl_stmt|;
name|TConstantUnion
modifier|*
name|unionArray
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|num
condition|;
name|i
operator|++
control|)
block|{
name|unionArray
operator|=
operator|new
name|TConstantUnion
index|[
literal|1
index|]
expr_stmt|;
name|unionArray
operator|->
name|setIConst
argument_list|(
name|fields
operator|.
name|offsets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|constIntNode
operator|=
name|addConstantUnion
argument_list|(
name|unionArray
argument_list|,
name|TType
argument_list|(
name|EbtInt
argument_list|,
name|EbpUndefined
argument_list|,
name|EvqConst
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|sequenceVector
operator|->
name|push_back
argument_list|(
name|constIntNode
argument_list|)
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Create loop nodes.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addLoop
name|TIntermNode
modifier|*
name|TIntermediate
operator|::
name|addLoop
parameter_list|(
name|TLoopType
name|type
parameter_list|,
name|TIntermNode
modifier|*
name|init
parameter_list|,
name|TIntermTyped
modifier|*
name|cond
parameter_list|,
name|TIntermTyped
modifier|*
name|expr
parameter_list|,
name|TIntermNode
modifier|*
name|body
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
name|TIntermNode
modifier|*
name|node
init|=
operator|new
name|TIntermLoop
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
name|cond
argument_list|,
name|expr
argument_list|,
name|ensureSequence
argument_list|(
name|body
argument_list|)
argument_list|)
decl_stmt|;
name|node
operator|->
name|setLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Add branches.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addBranch
name|TIntermBranch
modifier|*
name|TIntermediate
operator|::
name|addBranch
parameter_list|(
name|TOperator
name|branchOp
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
return|return
name|addBranch
argument_list|(
name|branchOp
argument_list|,
literal|0
argument_list|,
name|line
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|addBranch
name|TIntermBranch
modifier|*
name|TIntermediate
operator|::
name|addBranch
parameter_list|(
name|TOperator
name|branchOp
parameter_list|,
name|TIntermTyped
modifier|*
name|expression
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
name|TIntermBranch
modifier|*
name|node
init|=
operator|new
name|TIntermBranch
argument_list|(
name|branchOp
argument_list|,
name|expression
argument_list|)
decl_stmt|;
name|node
operator|->
name|setLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// This is to be executed once the final root is put on top by the parsing
end_comment
begin_comment
comment|// process.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|postProcess
name|TIntermAggregate
modifier|*
name|TIntermediate
operator|::
name|postProcess
parameter_list|(
name|TIntermNode
modifier|*
name|root
parameter_list|)
block|{
if|if
condition|(
name|root
operator|==
literal|nullptr
condition|)
return|return
literal|nullptr
return|;
comment|//
comment|// Finish off the top level sequence, if any
comment|//
name|TIntermAggregate
modifier|*
name|aggRoot
init|=
name|root
operator|->
name|getAsAggregate
argument_list|()
decl_stmt|;
if|if
condition|(
name|aggRoot
operator|!=
literal|nullptr
operator|&&
name|aggRoot
operator|->
name|getOp
argument_list|()
operator|==
name|EOpNull
condition|)
block|{
name|aggRoot
operator|->
name|setOp
argument_list|(
name|EOpSequence
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aggRoot
operator|==
literal|nullptr
operator|||
name|aggRoot
operator|->
name|getOp
argument_list|()
operator|!=
name|EOpSequence
condition|)
block|{
name|aggRoot
operator|=
operator|new
name|TIntermAggregate
argument_list|(
name|EOpSequence
argument_list|)
expr_stmt|;
name|aggRoot
operator|->
name|setLine
argument_list|(
name|root
operator|->
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
name|aggRoot
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
return|return
name|aggRoot
return|;
block|}
end_function
begin_function
DECL|function|foldAggregateBuiltIn
name|TIntermTyped
modifier|*
name|TIntermediate
operator|::
name|foldAggregateBuiltIn
parameter_list|(
name|TIntermAggregate
modifier|*
name|aggregate
parameter_list|)
block|{
switch|switch
condition|(
name|aggregate
operator|->
name|getOp
argument_list|()
condition|)
block|{
case|case
name|EOpAtan
case|:
case|case
name|EOpPow
case|:
case|case
name|EOpMod
case|:
case|case
name|EOpMin
case|:
case|case
name|EOpMax
case|:
case|case
name|EOpClamp
case|:
case|case
name|EOpMix
case|:
case|case
name|EOpStep
case|:
case|case
name|EOpSmoothStep
case|:
case|case
name|EOpMul
case|:
case|case
name|EOpOuterProduct
case|:
case|case
name|EOpLessThan
case|:
case|case
name|EOpLessThanEqual
case|:
case|case
name|EOpGreaterThan
case|:
case|case
name|EOpGreaterThanEqual
case|:
case|case
name|EOpVectorEqual
case|:
case|case
name|EOpVectorNotEqual
case|:
case|case
name|EOpDistance
case|:
case|case
name|EOpDot
case|:
case|case
name|EOpCross
case|:
case|case
name|EOpFaceForward
case|:
case|case
name|EOpReflect
case|:
case|case
name|EOpRefract
case|:
return|return
name|aggregate
operator|->
name|fold
argument_list|(
name|mInfoSink
argument_list|)
return|;
default|default:
comment|// TODO: Add support for folding array constructors
if|if
condition|(
name|aggregate
operator|->
name|isConstructor
argument_list|()
operator|&&
operator|!
name|aggregate
operator|->
name|isArray
argument_list|()
condition|)
block|{
return|return
name|aggregate
operator|->
name|fold
argument_list|(
name|mInfoSink
argument_list|)
return|;
block|}
comment|// Constant folding not supported for the built-in.
return|return
literal|nullptr
return|;
block|}
return|return
literal|nullptr
return|;
block|}
end_function
end_unit
