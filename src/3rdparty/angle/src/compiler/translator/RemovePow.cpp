begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2015 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// RemovePow is an AST traverser to convert pow(x, y) built-in calls where y is a
end_comment
begin_comment
comment|// constant to exp2(y * log2(x)). This works around an issue in NVIDIA 311 series
end_comment
begin_comment
comment|// OpenGL drivers.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|"compiler/translator/RemovePow.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/InfoSink.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/IntermNode.h"
end_include
begin_namespace
namespace|namespace
block|{
DECL|function|IsProblematicPow
name|bool
name|IsProblematicPow
parameter_list|(
name|TIntermTyped
modifier|*
name|node
parameter_list|)
block|{
name|TIntermAggregate
modifier|*
name|agg
init|=
name|node
operator|->
name|getAsAggregate
argument_list|()
decl_stmt|;
if|if
condition|(
name|agg
operator|!=
literal|nullptr
operator|&&
name|agg
operator|->
name|getOp
argument_list|()
operator|==
name|EOpPow
condition|)
block|{
name|ASSERT
argument_list|(
name|agg
operator|->
name|getSequence
argument_list|()
operator|->
name|size
argument_list|()
operator|==
literal|2
argument_list|)
expr_stmt|;
return|return
name|agg
operator|->
name|getSequence
argument_list|()
operator|->
name|at
argument_list|(
literal|1
argument_list|)
operator|->
name|getAsConstantUnion
argument_list|()
operator|!=
literal|nullptr
return|;
block|}
return|return
literal|false
return|;
block|}
comment|// Traverser that converts all pow operations simultaneously.
DECL|class|RemovePowTraverser
class|class
name|RemovePowTraverser
super|:
specifier|public
name|TIntermTraverser
block|{
public|public:
name|RemovePowTraverser
parameter_list|()
constructor_decl|;
DECL|member|override
name|bool
name|visitAggregate
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermAggregate
modifier|*
name|node
parameter_list|)
specifier|override
function_decl|;
DECL|function|nextIteration
name|void
name|nextIteration
parameter_list|()
block|{
name|mNeedAnotherIteration
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|needAnotherIteration
name|bool
name|needAnotherIteration
parameter_list|()
specifier|const
block|{
return|return
name|mNeedAnotherIteration
return|;
block|}
protected|protected:
DECL|member|mNeedAnotherIteration
name|bool
name|mNeedAnotherIteration
decl_stmt|;
block|}
class|;
DECL|function|RemovePowTraverser
name|RemovePowTraverser
operator|::
name|RemovePowTraverser
parameter_list|()
member_init_list|:
name|TIntermTraverser
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
member_init_list|,
name|mNeedAnotherIteration
argument_list|(
literal|false
argument_list|)
block|{ }
DECL|function|visitAggregate
name|bool
name|RemovePowTraverser
operator|::
name|visitAggregate
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermAggregate
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|IsProblematicPow
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|TInfoSink
name|nullSink
decl_stmt|;
name|TIntermTyped
modifier|*
name|x
init|=
name|node
operator|->
name|getSequence
argument_list|()
operator|->
name|at
argument_list|(
literal|0
argument_list|)
operator|->
name|getAsTyped
argument_list|()
decl_stmt|;
name|TIntermTyped
modifier|*
name|y
init|=
name|node
operator|->
name|getSequence
argument_list|()
operator|->
name|at
argument_list|(
literal|1
argument_list|)
operator|->
name|getAsTyped
argument_list|()
decl_stmt|;
name|TIntermUnary
modifier|*
name|log
init|=
operator|new
name|TIntermUnary
argument_list|(
name|EOpLog2
argument_list|)
decl_stmt|;
name|log
operator|->
name|setOperand
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|log
operator|->
name|setLine
argument_list|(
name|node
operator|->
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|->
name|setType
argument_list|(
name|x
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|TIntermBinary
modifier|*
name|mul
init|=
operator|new
name|TIntermBinary
argument_list|(
name|EOpMul
argument_list|)
decl_stmt|;
name|mul
operator|->
name|setLeft
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|mul
operator|->
name|setRight
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|mul
operator|->
name|setLine
argument_list|(
name|node
operator|->
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
name|bool
name|valid
init|=
name|mul
operator|->
name|promote
argument_list|(
name|nullSink
argument_list|)
decl_stmt|;
name|UNUSED_ASSERTION_VARIABLE
argument_list|(
name|valid
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|valid
argument_list|)
expr_stmt|;
name|TIntermUnary
modifier|*
name|exp
init|=
operator|new
name|TIntermUnary
argument_list|(
name|EOpExp2
argument_list|)
decl_stmt|;
name|exp
operator|->
name|setOperand
argument_list|(
name|mul
argument_list|)
expr_stmt|;
name|exp
operator|->
name|setLine
argument_list|(
name|node
operator|->
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
name|exp
operator|->
name|setType
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|NodeUpdateEntry
name|replacePow
argument_list|(
name|getParentNode
argument_list|()
argument_list|,
name|node
argument_list|,
name|exp
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|mReplacements
operator|.
name|push_back
argument_list|(
name|replacePow
argument_list|)
expr_stmt|;
comment|// If the x parameter also needs to be replaced, we need to do that in another traversal,
comment|// since it's parent node will change in a way that's not handled correctly by updateTree().
if|if
condition|(
name|IsProblematicPow
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|mNeedAnotherIteration
operator|=
literal|true
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
end_namespace
begin_comment
comment|// namespace
end_comment
begin_function
DECL|function|RemovePow
name|void
name|RemovePow
parameter_list|(
name|TIntermNode
modifier|*
name|root
parameter_list|)
block|{
name|RemovePowTraverser
name|traverser
decl_stmt|;
comment|// Iterate as necessary, and reset the traverser between iterations.
do|do
block|{
name|traverser
operator|.
name|nextIteration
argument_list|()
expr_stmt|;
name|root
operator|->
name|traverse
argument_list|(
operator|&
name|traverser
argument_list|)
expr_stmt|;
name|traverser
operator|.
name|updateTree
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|traverser
operator|.
name|needAnotherIteration
argument_list|()
condition|)
do|;
block|}
end_function
end_unit
