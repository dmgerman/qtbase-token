begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2013 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|"compiler/translator/OutputGLSL.h"
end_include
begin_constructor
DECL|function|TOutputGLSL
name|TOutputGLSL
operator|::
name|TOutputGLSL
parameter_list|(
name|TInfoSinkBase
modifier|&
name|objSink
parameter_list|,
name|ShArrayIndexClampingStrategy
name|clampingStrategy
parameter_list|,
name|ShHashFunction64
name|hashFunction
parameter_list|,
name|NameMap
modifier|&
name|nameMap
parameter_list|,
name|TSymbolTable
modifier|&
name|symbolTable
parameter_list|,
name|int
name|shaderVersion
parameter_list|,
name|ShShaderOutput
name|output
parameter_list|)
member_init_list|:
name|TOutputGLSLBase
argument_list|(
name|objSink
argument_list|,
name|clampingStrategy
argument_list|,
name|hashFunction
argument_list|,
name|nameMap
argument_list|,
name|symbolTable
argument_list|,
name|shaderVersion
argument_list|,
name|output
argument_list|)
block|{ }
end_constructor
begin_function
DECL|function|writeVariablePrecision
name|bool
name|TOutputGLSL
operator|::
name|writeVariablePrecision
parameter_list|(
name|TPrecision
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|visitSymbol
name|void
name|TOutputGLSL
operator|::
name|visitSymbol
parameter_list|(
name|TIntermSymbol
modifier|*
name|node
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|objSink
argument_list|()
decl_stmt|;
specifier|const
name|TString
modifier|&
name|symbol
init|=
name|node
operator|->
name|getSymbol
argument_list|()
decl_stmt|;
if|if
condition|(
name|symbol
operator|==
literal|"gl_FragDepthEXT"
condition|)
block|{
name|out
operator|<<
literal|"gl_FragDepth"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symbol
operator|==
literal|"gl_FragColor"
operator|&&
name|IsGLSL130OrNewer
argument_list|(
name|getShaderOutput
argument_list|()
argument_list|)
condition|)
block|{
name|out
operator|<<
literal|"webgl_FragColor"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symbol
operator|==
literal|"gl_FragData"
operator|&&
name|IsGLSL130OrNewer
argument_list|(
name|getShaderOutput
argument_list|()
argument_list|)
condition|)
block|{
name|out
operator|<<
literal|"webgl_FragData"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symbol
operator|==
literal|"gl_SecondaryFragColorEXT"
condition|)
block|{
name|out
operator|<<
literal|"angle_SecondaryFragColor"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symbol
operator|==
literal|"gl_SecondaryFragDataEXT"
condition|)
block|{
name|out
operator|<<
literal|"angle_SecondaryFragData"
expr_stmt|;
block|}
else|else
block|{
name|TOutputGLSLBase
operator|::
name|visitSymbol
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|translateTextureFunction
name|TString
name|TOutputGLSL
operator|::
name|translateTextureFunction
parameter_list|(
name|TString
modifier|&
name|name
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|simpleRename
index|[]
init|=
block|{
literal|"texture2DLodEXT"
block|,
literal|"texture2DLod"
block|,
literal|"texture2DProjLodEXT"
block|,
literal|"texture2DProjLod"
block|,
literal|"textureCubeLodEXT"
block|,
literal|"textureCubeLod"
block|,
literal|"texture2DGradEXT"
block|,
literal|"texture2DGradARB"
block|,
literal|"texture2DProjGradEXT"
block|,
literal|"texture2DProjGradARB"
block|,
literal|"textureCubeGradEXT"
block|,
literal|"textureCubeGradARB"
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|legacyToCoreRename
index|[]
init|=
block|{
literal|"texture2D"
block|,
literal|"texture"
block|,
literal|"texture2DProj"
block|,
literal|"textureProj"
block|,
literal|"texture2DLod"
block|,
literal|"textureLod"
block|,
literal|"texture2DProjLod"
block|,
literal|"textureProjLod"
block|,
literal|"texture2DRect"
block|,
literal|"texture"
block|,
literal|"textureCube"
block|,
literal|"texture"
block|,
literal|"textureCubeLod"
block|,
literal|"textureLod"
block|,
comment|// Extensions
literal|"texture2DLodEXT"
block|,
literal|"textureLod"
block|,
literal|"texture2DProjLodEXT"
block|,
literal|"textureProjLod"
block|,
literal|"textureCubeLodEXT"
block|,
literal|"textureLod"
block|,
literal|"texture2DGradEXT"
block|,
literal|"textureGrad"
block|,
literal|"texture2DProjGradEXT"
block|,
literal|"textureProjGrad"
block|,
literal|"textureCubeGradEXT"
block|,
literal|"textureGrad"
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mapping
init|=
operator|(
name|IsGLSL130OrNewer
argument_list|(
name|getShaderOutput
argument_list|()
argument_list|)
operator|)
condition|?
name|legacyToCoreRename
else|:
name|simpleRename
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|mapping
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|name
operator|==
name|mapping
index|[
name|i
index|]
condition|)
block|{
return|return
name|mapping
index|[
name|i
operator|+
literal|1
index|]
return|;
block|}
block|}
return|return
name|name
return|;
block|}
end_function
end_unit
