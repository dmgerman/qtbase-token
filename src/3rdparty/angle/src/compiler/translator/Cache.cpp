begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2015 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Cache.cpp: Implements a cache for various commonly created objects.
end_comment
begin_include
include|#
directive|include
file|<limits>
end_include
begin_include
include|#
directive|include
file|"common/angleutils.h"
end_include
begin_include
include|#
directive|include
file|"common/debug.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/Cache.h"
end_include
begin_namespace
namespace|namespace
block|{
DECL|class|TScopedAllocator
class|class
name|TScopedAllocator
super|:
name|angle
operator|::
name|NonCopyable
block|{
public|public:
DECL|function|TScopedAllocator
name|TScopedAllocator
parameter_list|(
name|TPoolAllocator
modifier|*
name|allocator
parameter_list|)
member_init_list|:
name|mPreviousAllocator
argument_list|(
name|GetGlobalPoolAllocator
argument_list|()
argument_list|)
block|{
name|SetGlobalPoolAllocator
argument_list|(
name|allocator
argument_list|)
expr_stmt|;
block|}
DECL|function|~TScopedAllocator
name|~
name|TScopedAllocator
parameter_list|()
block|{
name|SetGlobalPoolAllocator
argument_list|(
name|mPreviousAllocator
argument_list|)
expr_stmt|;
block|}
private|private:
DECL|member|mPreviousAllocator
name|TPoolAllocator
modifier|*
name|mPreviousAllocator
decl_stmt|;
block|}
class|;
block|}
end_namespace
begin_comment
comment|// namespace
end_comment
begin_constructor
DECL|function|TypeKey
name|TCache
operator|::
name|TypeKey
operator|::
name|TypeKey
parameter_list|(
name|TBasicType
name|basicType
parameter_list|,
name|TPrecision
name|precision
parameter_list|,
name|TQualifier
name|qualifier
parameter_list|,
name|unsigned
name|char
name|primarySize
parameter_list|,
name|unsigned
name|char
name|secondarySize
parameter_list|)
block|{
assert|static_assert
argument_list|(
sizeof|sizeof
argument_list|(
name|components
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|value
argument_list|)
argument_list|,
literal|"TypeKey::value is too small"
argument_list|)
assert|;
specifier|const
name|size_t
name|MaxEnumValue
init|=
name|std
operator|::
name|numeric_limits
argument_list|<
name|EnumComponentType
argument_list|>
operator|::
name|max
argument_list|()
decl_stmt|;
name|UNUSED_ASSERTION_VARIABLE
argument_list|(
name|MaxEnumValue
argument_list|)
expr_stmt|;
comment|// TODO: change to static_assert() once we deprecate MSVC 2013 support
name|ASSERT
argument_list|(
name|MaxEnumValue
operator|>=
name|EbtLast
operator|&&
name|MaxEnumValue
operator|>=
name|EbpLast
operator|&&
name|MaxEnumValue
operator|>=
name|EvqLast
operator|&&
literal|"TypeKey::EnumComponentType is too small"
argument_list|)
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
name|components
operator|.
name|basicType
operator|=
cast|static_cast
argument_list|<
name|EnumComponentType
argument_list|>
argument_list|(
name|basicType
argument_list|)
expr_stmt|;
name|components
operator|.
name|precision
operator|=
cast|static_cast
argument_list|<
name|EnumComponentType
argument_list|>
argument_list|(
name|precision
argument_list|)
expr_stmt|;
name|components
operator|.
name|qualifier
operator|=
cast|static_cast
argument_list|<
name|EnumComponentType
argument_list|>
argument_list|(
name|qualifier
argument_list|)
expr_stmt|;
name|components
operator|.
name|primarySize
operator|=
name|primarySize
expr_stmt|;
name|components
operator|.
name|secondarySize
operator|=
name|secondarySize
expr_stmt|;
block|}
end_constructor
begin_decl_stmt
DECL|member|sCache
name|TCache
modifier|*
name|TCache
operator|::
name|sCache
init|=
literal|nullptr
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|initialize
name|void
name|TCache
operator|::
name|initialize
parameter_list|()
block|{
if|if
condition|(
name|sCache
operator|==
literal|nullptr
condition|)
block|{
name|sCache
operator|=
operator|new
name|TCache
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|destroy
name|void
name|TCache
operator|::
name|destroy
parameter_list|()
block|{
name|SafeDelete
argument_list|(
name|sCache
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|getType
specifier|const
name|TType
modifier|*
name|TCache
operator|::
name|getType
parameter_list|(
name|TBasicType
name|basicType
parameter_list|,
name|TPrecision
name|precision
parameter_list|,
name|TQualifier
name|qualifier
parameter_list|,
name|unsigned
name|char
name|primarySize
parameter_list|,
name|unsigned
name|char
name|secondarySize
parameter_list|)
block|{
name|TypeKey
name|key
argument_list|(
name|basicType
argument_list|,
name|precision
argument_list|,
name|qualifier
argument_list|,
name|primarySize
argument_list|,
name|secondarySize
argument_list|)
decl_stmt|;
name|auto
name|it
init|=
name|sCache
operator|->
name|mTypes
operator|.
name|find
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|sCache
operator|->
name|mTypes
operator|.
name|end
argument_list|()
condition|)
block|{
return|return
name|it
operator|->
name|second
return|;
block|}
name|TScopedAllocator
name|scopedAllocator
argument_list|(
operator|&
name|sCache
operator|->
name|mAllocator
argument_list|)
decl_stmt|;
name|TType
modifier|*
name|type
init|=
operator|new
name|TType
argument_list|(
name|basicType
argument_list|,
name|precision
argument_list|,
name|qualifier
argument_list|,
name|primarySize
argument_list|,
name|secondarySize
argument_list|)
decl_stmt|;
name|type
operator|->
name|realize
argument_list|()
expr_stmt|;
name|sCache
operator|->
name|mTypes
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|key
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function
end_unit
