begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|"compiler/translator/EmulatePrecision.h"
end_include
begin_namespace
namespace|namespace
block|{
DECL|function|writeVectorPrecisionEmulationHelpers
specifier|static
name|void
name|writeVectorPrecisionEmulationHelpers
parameter_list|(
name|TInfoSinkBase
modifier|&
name|sink
parameter_list|,
name|ShShaderOutput
name|outputLanguage
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|std
operator|::
name|stringstream
name|vecTypeStrStr
decl_stmt|;
if|if
condition|(
name|outputLanguage
operator|==
name|SH_ESSL_OUTPUT
condition|)
name|vecTypeStrStr
operator|<<
literal|"highp "
expr_stmt|;
name|vecTypeStrStr
operator|<<
literal|"vec"
operator|<<
name|size
expr_stmt|;
name|std
operator|::
name|string
name|vecType
init|=
name|vecTypeStrStr
operator|.
name|str
argument_list|()
decl_stmt|;
name|sink
operator|<<
name|vecType
operator|<<
literal|" angle_frm(in "
operator|<<
name|vecType
operator|<<
literal|" v) {\n"
literal|"    v = clamp(v, -65504.0, 65504.0);\n"
literal|"    "
operator|<<
name|vecType
operator|<<
literal|" exponent = floor(log2(abs(v) + 1e-30)) - 10.0;\n"
literal|"    bvec"
operator|<<
name|size
operator|<<
literal|" isNonZero = greaterThanEqual(exponent, vec"
operator|<<
name|size
operator|<<
literal|"(-25.0));\n"
literal|"    v = v * exp2(-exponent);\n"
literal|"    v = sign(v) * floor(abs(v));\n"
literal|"    return v * exp2(exponent) * vec"
operator|<<
name|size
operator|<<
literal|"(isNonZero);\n"
literal|"}\n"
expr_stmt|;
name|sink
operator|<<
name|vecType
operator|<<
literal|" angle_frl(in "
operator|<<
name|vecType
operator|<<
literal|" v) {\n"
literal|"    v = clamp(v, -2.0, 2.0);\n"
literal|"    v = v * 256.0;\n"
literal|"    v = sign(v) * floor(abs(v));\n"
literal|"    return v * 0.00390625;\n"
literal|"}\n"
expr_stmt|;
block|}
DECL|function|writeMatrixPrecisionEmulationHelper
specifier|static
name|void
name|writeMatrixPrecisionEmulationHelper
parameter_list|(
name|TInfoSinkBase
modifier|&
name|sink
parameter_list|,
name|ShShaderOutput
name|outputLanguage
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|functionName
parameter_list|)
block|{
name|std
operator|::
name|stringstream
name|matTypeStrStr
decl_stmt|;
if|if
condition|(
name|outputLanguage
operator|==
name|SH_ESSL_OUTPUT
condition|)
name|matTypeStrStr
operator|<<
literal|"highp "
expr_stmt|;
name|matTypeStrStr
operator|<<
literal|"mat"
operator|<<
name|size
expr_stmt|;
name|std
operator|::
name|string
name|matType
init|=
name|matTypeStrStr
operator|.
name|str
argument_list|()
decl_stmt|;
name|sink
operator|<<
name|matType
operator|<<
literal|" "
operator|<<
name|functionName
operator|<<
literal|"(in "
operator|<<
name|matType
operator|<<
literal|" m) {\n"
literal|"    "
operator|<<
name|matType
operator|<<
literal|" rounded;\n"
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
name|sink
operator|<<
literal|"    rounded["
operator|<<
name|i
operator|<<
literal|"] = "
operator|<<
name|functionName
operator|<<
literal|"(m["
operator|<<
name|i
operator|<<
literal|"]);\n"
expr_stmt|;
block|}
name|sink
operator|<<
literal|"    return rounded;\n"
literal|"}\n"
expr_stmt|;
block|}
DECL|function|writeCommonPrecisionEmulationHelpers
specifier|static
name|void
name|writeCommonPrecisionEmulationHelpers
parameter_list|(
name|TInfoSinkBase
modifier|&
name|sink
parameter_list|,
name|ShShaderOutput
name|outputLanguage
parameter_list|)
block|{
comment|// Write the angle_frm functions that round floating point numbers to
comment|// half precision, and angle_frl functions that round them to minimum lowp
comment|// precision.
comment|// Unoptimized version of angle_frm for single floats:
comment|//
comment|// int webgl_maxNormalExponent(in int exponentBits) {
comment|//     int possibleExponents = int(exp2(float(exponentBits)));
comment|//     int exponentBias = possibleExponents / 2 - 1;
comment|//     int allExponentBitsOne = possibleExponents - 1;
comment|//     return (allExponentBitsOne - 1) - exponentBias;
comment|// }
comment|//
comment|// float angle_frm(in float x) {
comment|//     int mantissaBits = 10;
comment|//     int exponentBits = 5;
comment|//     float possibleMantissas = exp2(float(mantissaBits));
comment|//     float mantissaMax = 2.0 - 1.0 / possibleMantissas;
comment|//     int maxNE = webgl_maxNormalExponent(exponentBits);
comment|//     float max = exp2(float(maxNE)) * mantissaMax;
comment|//     if (x> max) {
comment|//         return max;
comment|//     }
comment|//     if (x< -max) {
comment|//         return -max;
comment|//     }
comment|//     float exponent = floor(log2(abs(x)));
comment|//     if (abs(x) == 0.0 || exponent< -float(maxNE)) {
comment|//         return 0.0 * sign(x)
comment|//     }
comment|//     x = x * exp2(-(exponent - float(mantissaBits)));
comment|//     x = sign(x) * floor(abs(x));
comment|//     return x * exp2(exponent - float(mantissaBits));
comment|// }
comment|// All numbers with a magnitude less than 2^-15 are subnormal, and are
comment|// flushed to zero.
comment|// Note the constant numbers below:
comment|// a) 65504 is the maximum possible mantissa (1.1111111111 in binary) times
comment|//    2^15, the maximum normal exponent.
comment|// b) 10.0 is the number of mantissa bits.
comment|// c) -25.0 is the minimum normal half-float exponent -15.0 minus the number
comment|//    of mantissa bits.
comment|// d) + 1e-30 is to make sure the argument of log2() won't be zero. It can
comment|//    only affect the result of log2 on x where abs(x)< 1e-22. Since these
comment|//    numbers will be flushed to zero either way (2^-15 is the smallest
comment|//    normal positive number), this does not introduce any error.
name|std
operator|::
name|string
name|floatType
init|=
literal|"float"
decl_stmt|;
if|if
condition|(
name|outputLanguage
operator|==
name|SH_ESSL_OUTPUT
condition|)
name|floatType
operator|=
literal|"highp float"
expr_stmt|;
name|sink
operator|<<
name|floatType
operator|<<
literal|" angle_frm(in "
operator|<<
name|floatType
operator|<<
literal|" x) {\n"
literal|"    x = clamp(x, -65504.0, 65504.0);\n"
literal|"    "
operator|<<
name|floatType
operator|<<
literal|" exponent = floor(log2(abs(x) + 1e-30)) - 10.0;\n"
literal|"    bool isNonZero = (exponent>= -25.0);\n"
literal|"    x = x * exp2(-exponent);\n"
literal|"    x = sign(x) * floor(abs(x));\n"
literal|"    return x * exp2(exponent) * float(isNonZero);\n"
literal|"}\n"
expr_stmt|;
name|sink
operator|<<
name|floatType
operator|<<
literal|" angle_frl(in "
operator|<<
name|floatType
operator|<<
literal|" x) {\n"
literal|"    x = clamp(x, -2.0, 2.0);\n"
literal|"    x = x * 256.0;\n"
literal|"    x = sign(x) * floor(abs(x));\n"
literal|"    return x * 0.00390625;\n"
literal|"}\n"
expr_stmt|;
name|writeVectorPrecisionEmulationHelpers
argument_list|(
name|sink
argument_list|,
name|outputLanguage
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|writeVectorPrecisionEmulationHelpers
argument_list|(
name|sink
argument_list|,
name|outputLanguage
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|writeVectorPrecisionEmulationHelpers
argument_list|(
name|sink
argument_list|,
name|outputLanguage
argument_list|,
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|size
init|=
literal|2
init|;
name|size
operator|<=
literal|4
condition|;
operator|++
name|size
control|)
block|{
name|writeMatrixPrecisionEmulationHelper
argument_list|(
name|sink
argument_list|,
name|outputLanguage
argument_list|,
name|size
argument_list|,
literal|"angle_frm"
argument_list|)
expr_stmt|;
name|writeMatrixPrecisionEmulationHelper
argument_list|(
name|sink
argument_list|,
name|outputLanguage
argument_list|,
name|size
argument_list|,
literal|"angle_frl"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|writeCompoundAssignmentPrecisionEmulation
specifier|static
name|void
name|writeCompoundAssignmentPrecisionEmulation
parameter_list|(
name|TInfoSinkBase
modifier|&
name|sink
parameter_list|,
name|ShShaderOutput
name|outputLanguage
parameter_list|,
specifier|const
name|char
modifier|*
name|lType
parameter_list|,
specifier|const
name|char
modifier|*
name|rType
parameter_list|,
specifier|const
name|char
modifier|*
name|opStr
parameter_list|,
specifier|const
name|char
modifier|*
name|opNameStr
parameter_list|)
block|{
name|std
operator|::
name|string
name|lTypeStr
init|=
name|lType
decl_stmt|;
name|std
operator|::
name|string
name|rTypeStr
init|=
name|rType
decl_stmt|;
if|if
condition|(
name|outputLanguage
operator|==
name|SH_ESSL_OUTPUT
condition|)
block|{
name|std
operator|::
name|stringstream
name|lTypeStrStr
decl_stmt|;
name|lTypeStrStr
operator|<<
literal|"highp "
operator|<<
name|lType
expr_stmt|;
name|lTypeStr
operator|=
name|lTypeStrStr
operator|.
name|str
argument_list|()
expr_stmt|;
name|std
operator|::
name|stringstream
name|rTypeStrStr
decl_stmt|;
name|rTypeStrStr
operator|<<
literal|"highp "
operator|<<
name|rType
expr_stmt|;
name|rTypeStr
operator|=
name|rTypeStrStr
operator|.
name|str
argument_list|()
expr_stmt|;
block|}
comment|// Note that y should be passed through angle_frm at the function call site,
comment|// but x can't be passed through angle_frm there since it is an inout parameter.
comment|// So only pass x and the result through angle_frm here.
name|sink
operator|<<
name|lTypeStr
operator|<<
literal|" angle_compound_"
operator|<<
name|opNameStr
operator|<<
literal|"_frm(inout "
operator|<<
name|lTypeStr
operator|<<
literal|" x, in "
operator|<<
name|rTypeStr
operator|<<
literal|" y) {\n"
literal|"    x = angle_frm(angle_frm(x) "
operator|<<
name|opStr
operator|<<
literal|" y);\n"
literal|"    return x;\n"
literal|"}\n"
expr_stmt|;
name|sink
operator|<<
name|lTypeStr
operator|<<
literal|" angle_compound_"
operator|<<
name|opNameStr
operator|<<
literal|"_frl(inout "
operator|<<
name|lTypeStr
operator|<<
literal|" x, in "
operator|<<
name|rTypeStr
operator|<<
literal|" y) {\n"
literal|"    x = angle_frl(angle_frm(x) "
operator|<<
name|opStr
operator|<<
literal|" y);\n"
literal|"    return x;\n"
literal|"}\n"
expr_stmt|;
block|}
DECL|function|getFloatTypeStr
specifier|const
name|char
modifier|*
name|getFloatTypeStr
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
operator|.
name|getNominalSize
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
return|return
literal|"float"
return|;
case|case
literal|2
case|:
return|return
name|type
operator|.
name|getSecondarySize
argument_list|()
operator|>
literal|1
condition|?
literal|"mat2"
else|:
literal|"vec2"
return|;
case|case
literal|3
case|:
return|return
name|type
operator|.
name|getSecondarySize
argument_list|()
operator|>
literal|1
condition|?
literal|"mat3"
else|:
literal|"vec3"
return|;
case|case
literal|4
case|:
return|return
name|type
operator|.
name|getSecondarySize
argument_list|()
operator|>
literal|1
condition|?
literal|"mat4"
else|:
literal|"vec4"
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
DECL|function|canRoundFloat
name|bool
name|canRoundFloat
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|)
block|{
return|return
name|type
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtFloat
operator|&&
operator|!
name|type
operator|.
name|isNonSquareMatrix
argument_list|()
operator|&&
operator|!
name|type
operator|.
name|isArray
argument_list|()
operator|&&
operator|(
name|type
operator|.
name|getPrecision
argument_list|()
operator|==
name|EbpLow
operator|||
name|type
operator|.
name|getPrecision
argument_list|()
operator|==
name|EbpMedium
operator|)
return|;
block|}
DECL|function|createInternalFunctionCallNode
name|TIntermAggregate
modifier|*
name|createInternalFunctionCallNode
parameter_list|(
name|TString
name|name
parameter_list|,
name|TIntermNode
modifier|*
name|child
parameter_list|)
block|{
name|TIntermAggregate
modifier|*
name|callNode
init|=
operator|new
name|TIntermAggregate
argument_list|()
decl_stmt|;
name|callNode
operator|->
name|setOp
argument_list|(
name|EOpInternalFunctionCall
argument_list|)
expr_stmt|;
name|callNode
operator|->
name|setName
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|callNode
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|child
argument_list|)
expr_stmt|;
return|return
name|callNode
return|;
block|}
DECL|function|createRoundingFunctionCallNode
name|TIntermAggregate
modifier|*
name|createRoundingFunctionCallNode
parameter_list|(
name|TIntermTyped
modifier|*
name|roundedChild
parameter_list|)
block|{
name|TString
name|roundFunctionName
decl_stmt|;
if|if
condition|(
name|roundedChild
operator|->
name|getPrecision
argument_list|()
operator|==
name|EbpMedium
condition|)
name|roundFunctionName
operator|=
literal|"angle_frm"
expr_stmt|;
else|else
name|roundFunctionName
operator|=
literal|"angle_frl"
expr_stmt|;
return|return
name|createInternalFunctionCallNode
argument_list|(
name|roundFunctionName
argument_list|,
name|roundedChild
argument_list|)
return|;
block|}
DECL|function|createCompoundAssignmentFunctionCallNode
name|TIntermAggregate
modifier|*
name|createCompoundAssignmentFunctionCallNode
parameter_list|(
name|TIntermTyped
modifier|*
name|left
parameter_list|,
name|TIntermTyped
modifier|*
name|right
parameter_list|,
specifier|const
name|char
modifier|*
name|opNameStr
parameter_list|)
block|{
name|std
operator|::
name|stringstream
name|strstr
decl_stmt|;
if|if
condition|(
name|left
operator|->
name|getPrecision
argument_list|()
operator|==
name|EbpMedium
condition|)
name|strstr
operator|<<
literal|"angle_compound_"
operator|<<
name|opNameStr
operator|<<
literal|"_frm"
expr_stmt|;
else|else
name|strstr
operator|<<
literal|"angle_compound_"
operator|<<
name|opNameStr
operator|<<
literal|"_frl"
expr_stmt|;
name|TString
name|functionName
init|=
name|strstr
operator|.
name|str
argument_list|()
operator|.
name|c_str
argument_list|()
decl_stmt|;
name|TIntermAggregate
modifier|*
name|callNode
init|=
name|createInternalFunctionCallNode
argument_list|(
name|functionName
argument_list|,
name|left
argument_list|)
decl_stmt|;
name|callNode
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|right
argument_list|)
expr_stmt|;
return|return
name|callNode
return|;
block|}
DECL|function|parentUsesResult
name|bool
name|parentUsesResult
parameter_list|(
name|TIntermNode
modifier|*
name|parent
parameter_list|,
name|TIntermNode
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
operator|!
name|parent
condition|)
block|{
return|return
literal|false
return|;
block|}
name|TIntermAggregate
modifier|*
name|aggParent
init|=
name|parent
operator|->
name|getAsAggregate
argument_list|()
decl_stmt|;
comment|// If the parent's op is EOpSequence, the result is not assigned anywhere,
comment|// so rounding it is not needed. In particular, this can avoid a lot of
comment|// unnecessary rounding of unused return values of assignment.
if|if
condition|(
name|aggParent
operator|&&
name|aggParent
operator|->
name|getOp
argument_list|()
operator|==
name|EOpSequence
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|aggParent
operator|&&
name|aggParent
operator|->
name|getOp
argument_list|()
operator|==
name|EOpComma
operator|&&
operator|(
name|aggParent
operator|->
name|getSequence
argument_list|()
operator|->
name|back
argument_list|()
operator|!=
name|node
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
block|}
end_namespace
begin_comment
comment|// namespace anonymous
end_comment
begin_constructor
DECL|function|EmulatePrecision
name|EmulatePrecision
operator|::
name|EmulatePrecision
parameter_list|()
member_init_list|:
name|TIntermTraverser
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
member_init_list|,
name|mDeclaringVariables
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mInLValue
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mInFunctionCallOutParameter
argument_list|(
literal|false
argument_list|)
block|{}
end_constructor
begin_function
DECL|function|visitSymbol
name|void
name|EmulatePrecision
operator|::
name|visitSymbol
parameter_list|(
name|TIntermSymbol
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|canRoundFloat
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|)
operator|&&
operator|!
name|mDeclaringVariables
operator|&&
operator|!
name|mInLValue
operator|&&
operator|!
name|mInFunctionCallOutParameter
condition|)
block|{
name|TIntermNode
modifier|*
name|parent
init|=
name|getParentNode
argument_list|()
decl_stmt|;
name|TIntermNode
modifier|*
name|replacement
init|=
name|createRoundingFunctionCallNode
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|mReplacements
operator|.
name|push_back
argument_list|(
name|NodeUpdateEntry
argument_list|(
name|parent
argument_list|,
name|node
argument_list|,
name|replacement
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|visitBinary
name|bool
name|EmulatePrecision
operator|::
name|visitBinary
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermBinary
modifier|*
name|node
parameter_list|)
block|{
name|bool
name|visitChildren
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|isAssignment
argument_list|()
condition|)
block|{
if|if
condition|(
name|visit
operator|==
name|PreVisit
condition|)
name|mInLValue
operator|=
literal|true
expr_stmt|;
elseif|else
if|if
condition|(
name|visit
operator|==
name|InVisit
condition|)
name|mInLValue
operator|=
literal|false
expr_stmt|;
block|}
name|TOperator
name|op
init|=
name|node
operator|->
name|getOp
argument_list|()
decl_stmt|;
comment|// RHS of initialize is not being declared.
if|if
condition|(
name|op
operator|==
name|EOpInitialize
operator|&&
name|visit
operator|==
name|InVisit
condition|)
name|mDeclaringVariables
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|(
name|op
operator|==
name|EOpIndexDirectStruct
operator|||
name|op
operator|==
name|EOpVectorSwizzle
operator|)
operator|&&
name|visit
operator|==
name|InVisit
condition|)
name|visitChildren
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|visit
operator|!=
name|PreVisit
condition|)
return|return
name|visitChildren
return|;
specifier|const
name|TType
modifier|&
name|type
init|=
name|node
operator|->
name|getType
argument_list|()
decl_stmt|;
name|bool
name|roundFloat
init|=
name|canRoundFloat
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|roundFloat
condition|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
comment|// Math operators that can result in a float may need to apply rounding to the return
comment|// value. Note that in the case of assignment, the rounding is applied to its return
comment|// value here, not the value being assigned.
case|case
name|EOpAssign
case|:
case|case
name|EOpAdd
case|:
case|case
name|EOpSub
case|:
case|case
name|EOpMul
case|:
case|case
name|EOpDiv
case|:
case|case
name|EOpVectorTimesScalar
case|:
case|case
name|EOpVectorTimesMatrix
case|:
case|case
name|EOpMatrixTimesVector
case|:
case|case
name|EOpMatrixTimesScalar
case|:
case|case
name|EOpMatrixTimesMatrix
case|:
block|{
name|TIntermNode
modifier|*
name|parent
init|=
name|getParentNode
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|parentUsesResult
argument_list|(
name|parent
argument_list|,
name|node
argument_list|)
condition|)
block|{
break|break;
block|}
name|TIntermNode
modifier|*
name|replacement
init|=
name|createRoundingFunctionCallNode
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|mReplacements
operator|.
name|push_back
argument_list|(
name|NodeUpdateEntry
argument_list|(
name|parent
argument_list|,
name|node
argument_list|,
name|replacement
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// Compound assignment cases need to replace the operator with a function call.
case|case
name|EOpAddAssign
case|:
block|{
name|mEmulateCompoundAdd
operator|.
name|insert
argument_list|(
name|TypePair
argument_list|(
name|getFloatTypeStr
argument_list|(
name|type
argument_list|)
argument_list|,
name|getFloatTypeStr
argument_list|(
name|node
operator|->
name|getRight
argument_list|()
operator|->
name|getType
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TIntermNode
modifier|*
name|parent
init|=
name|getParentNode
argument_list|()
decl_stmt|;
name|TIntermNode
modifier|*
name|replacement
init|=
name|createCompoundAssignmentFunctionCallNode
argument_list|(
name|node
operator|->
name|getLeft
argument_list|()
argument_list|,
name|node
operator|->
name|getRight
argument_list|()
argument_list|,
literal|"add"
argument_list|)
decl_stmt|;
name|mReplacements
operator|.
name|push_back
argument_list|(
name|NodeUpdateEntry
argument_list|(
name|parent
argument_list|,
name|node
argument_list|,
name|replacement
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|EOpSubAssign
case|:
block|{
name|mEmulateCompoundSub
operator|.
name|insert
argument_list|(
name|TypePair
argument_list|(
name|getFloatTypeStr
argument_list|(
name|type
argument_list|)
argument_list|,
name|getFloatTypeStr
argument_list|(
name|node
operator|->
name|getRight
argument_list|()
operator|->
name|getType
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TIntermNode
modifier|*
name|parent
init|=
name|getParentNode
argument_list|()
decl_stmt|;
name|TIntermNode
modifier|*
name|replacement
init|=
name|createCompoundAssignmentFunctionCallNode
argument_list|(
name|node
operator|->
name|getLeft
argument_list|()
argument_list|,
name|node
operator|->
name|getRight
argument_list|()
argument_list|,
literal|"sub"
argument_list|)
decl_stmt|;
name|mReplacements
operator|.
name|push_back
argument_list|(
name|NodeUpdateEntry
argument_list|(
name|parent
argument_list|,
name|node
argument_list|,
name|replacement
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|EOpMulAssign
case|:
case|case
name|EOpVectorTimesMatrixAssign
case|:
case|case
name|EOpVectorTimesScalarAssign
case|:
case|case
name|EOpMatrixTimesScalarAssign
case|:
case|case
name|EOpMatrixTimesMatrixAssign
case|:
block|{
name|mEmulateCompoundMul
operator|.
name|insert
argument_list|(
name|TypePair
argument_list|(
name|getFloatTypeStr
argument_list|(
name|type
argument_list|)
argument_list|,
name|getFloatTypeStr
argument_list|(
name|node
operator|->
name|getRight
argument_list|()
operator|->
name|getType
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TIntermNode
modifier|*
name|parent
init|=
name|getParentNode
argument_list|()
decl_stmt|;
name|TIntermNode
modifier|*
name|replacement
init|=
name|createCompoundAssignmentFunctionCallNode
argument_list|(
name|node
operator|->
name|getLeft
argument_list|()
argument_list|,
name|node
operator|->
name|getRight
argument_list|()
argument_list|,
literal|"mul"
argument_list|)
decl_stmt|;
name|mReplacements
operator|.
name|push_back
argument_list|(
name|NodeUpdateEntry
argument_list|(
name|parent
argument_list|,
name|node
argument_list|,
name|replacement
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|EOpDivAssign
case|:
block|{
name|mEmulateCompoundDiv
operator|.
name|insert
argument_list|(
name|TypePair
argument_list|(
name|getFloatTypeStr
argument_list|(
name|type
argument_list|)
argument_list|,
name|getFloatTypeStr
argument_list|(
name|node
operator|->
name|getRight
argument_list|()
operator|->
name|getType
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TIntermNode
modifier|*
name|parent
init|=
name|getParentNode
argument_list|()
decl_stmt|;
name|TIntermNode
modifier|*
name|replacement
init|=
name|createCompoundAssignmentFunctionCallNode
argument_list|(
name|node
operator|->
name|getLeft
argument_list|()
argument_list|,
name|node
operator|->
name|getRight
argument_list|()
argument_list|,
literal|"div"
argument_list|)
decl_stmt|;
name|mReplacements
operator|.
name|push_back
argument_list|(
name|NodeUpdateEntry
argument_list|(
name|parent
argument_list|,
name|node
argument_list|,
name|replacement
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
comment|// The rest of the binary operations should not need precision emulation.
break|break;
block|}
block|}
return|return
name|visitChildren
return|;
block|}
end_function
begin_function
DECL|function|visitAggregate
name|bool
name|EmulatePrecision
operator|::
name|visitAggregate
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermAggregate
modifier|*
name|node
parameter_list|)
block|{
name|bool
name|visitChildren
init|=
literal|true
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|getOp
argument_list|()
condition|)
block|{
case|case
name|EOpSequence
case|:
case|case
name|EOpConstructStruct
case|:
comment|// No special handling
break|break;
case|case
name|EOpFunction
case|:
if|if
condition|(
name|visit
operator|==
name|PreVisit
condition|)
block|{
specifier|const
name|TIntermSequence
modifier|&
name|sequence
init|=
operator|*
operator|(
name|node
operator|->
name|getSequence
argument_list|()
operator|)
decl_stmt|;
name|TIntermSequence
operator|::
name|const_iterator
name|seqIter
init|=
name|sequence
operator|.
name|begin
argument_list|()
decl_stmt|;
name|TIntermAggregate
modifier|*
name|params
init|=
operator|(
operator|*
name|seqIter
operator|)
operator|->
name|getAsAggregate
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|params
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|params
operator|->
name|getOp
argument_list|()
operator|==
name|EOpParameters
argument_list|)
expr_stmt|;
name|mFunctionMap
index|[
name|node
operator|->
name|getName
argument_list|()
index|]
operator|=
name|params
operator|->
name|getSequence
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|EOpPrototype
case|:
if|if
condition|(
name|visit
operator|==
name|PreVisit
condition|)
name|mFunctionMap
index|[
name|node
operator|->
name|getName
argument_list|()
index|]
operator|=
name|node
operator|->
name|getSequence
argument_list|()
expr_stmt|;
name|visitChildren
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|EOpParameters
case|:
name|visitChildren
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|EOpInvariantDeclaration
case|:
name|visitChildren
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|EOpDeclaration
case|:
comment|// Variable declaration.
if|if
condition|(
name|visit
operator|==
name|PreVisit
condition|)
block|{
name|mDeclaringVariables
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|visit
operator|==
name|InVisit
condition|)
block|{
name|mDeclaringVariables
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|mDeclaringVariables
operator|=
literal|false
expr_stmt|;
block|}
break|break;
case|case
name|EOpFunctionCall
case|:
block|{
comment|// Function call.
name|bool
name|inFunctionMap
init|=
operator|(
name|mFunctionMap
operator|.
name|find
argument_list|(
name|node
operator|->
name|getName
argument_list|()
argument_list|)
operator|!=
name|mFunctionMap
operator|.
name|end
argument_list|()
operator|)
decl_stmt|;
if|if
condition|(
name|visit
operator|==
name|PreVisit
condition|)
block|{
comment|// User-defined function return values are not rounded, this relies on that
comment|// calculations producing the value were rounded.
name|TIntermNode
modifier|*
name|parent
init|=
name|getParentNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|canRoundFloat
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|)
operator|&&
operator|!
name|inFunctionMap
operator|&&
name|parentUsesResult
argument_list|(
name|parent
argument_list|,
name|node
argument_list|)
condition|)
block|{
name|TIntermNode
modifier|*
name|replacement
init|=
name|createRoundingFunctionCallNode
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|mReplacements
operator|.
name|push_back
argument_list|(
name|NodeUpdateEntry
argument_list|(
name|parent
argument_list|,
name|node
argument_list|,
name|replacement
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inFunctionMap
condition|)
block|{
name|mSeqIterStack
operator|.
name|push_back
argument_list|(
name|mFunctionMap
index|[
name|node
operator|->
name|getName
argument_list|()
index|]
operator|->
name|begin
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|mSeqIterStack
operator|.
name|back
argument_list|()
operator|!=
name|mFunctionMap
index|[
name|node
operator|->
name|getName
argument_list|()
index|]
operator|->
name|end
argument_list|()
condition|)
block|{
name|TQualifier
name|qualifier
init|=
operator|(
operator|*
name|mSeqIterStack
operator|.
name|back
argument_list|()
operator|)
operator|->
name|getAsTyped
argument_list|()
operator|->
name|getQualifier
argument_list|()
decl_stmt|;
name|mInFunctionCallOutParameter
operator|=
operator|(
name|qualifier
operator|==
name|EvqOut
operator|||
name|qualifier
operator|==
name|EvqInOut
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// The function is not user-defined - it is likely built-in texture function.
comment|// Assume that those do not have out parameters.
name|mInFunctionCallOutParameter
operator|=
literal|false
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|visit
operator|==
name|InVisit
condition|)
block|{
if|if
condition|(
name|inFunctionMap
condition|)
block|{
operator|++
name|mSeqIterStack
operator|.
name|back
argument_list|()
expr_stmt|;
name|TQualifier
name|qualifier
init|=
operator|(
operator|*
name|mSeqIterStack
operator|.
name|back
argument_list|()
operator|)
operator|->
name|getAsTyped
argument_list|()
operator|->
name|getQualifier
argument_list|()
decl_stmt|;
name|mInFunctionCallOutParameter
operator|=
operator|(
name|qualifier
operator|==
name|EvqOut
operator|||
name|qualifier
operator|==
name|EvqInOut
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|inFunctionMap
condition|)
block|{
name|mSeqIterStack
operator|.
name|pop_back
argument_list|()
expr_stmt|;
name|mInFunctionCallOutParameter
operator|=
literal|false
expr_stmt|;
block|}
block|}
break|break;
block|}
default|default:
name|TIntermNode
modifier|*
name|parent
init|=
name|getParentNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|canRoundFloat
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|)
operator|&&
name|visit
operator|==
name|PreVisit
operator|&&
name|parentUsesResult
argument_list|(
name|parent
argument_list|,
name|node
argument_list|)
condition|)
block|{
name|TIntermNode
modifier|*
name|replacement
init|=
name|createRoundingFunctionCallNode
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|mReplacements
operator|.
name|push_back
argument_list|(
name|NodeUpdateEntry
argument_list|(
name|parent
argument_list|,
name|node
argument_list|,
name|replacement
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
name|visitChildren
return|;
block|}
end_function
begin_function
DECL|function|visitUnary
name|bool
name|EmulatePrecision
operator|::
name|visitUnary
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermUnary
modifier|*
name|node
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|->
name|getOp
argument_list|()
condition|)
block|{
case|case
name|EOpNegative
case|:
case|case
name|EOpVectorLogicalNot
case|:
case|case
name|EOpLogicalNot
case|:
break|break;
case|case
name|EOpPostIncrement
case|:
case|case
name|EOpPostDecrement
case|:
case|case
name|EOpPreIncrement
case|:
case|case
name|EOpPreDecrement
case|:
if|if
condition|(
name|visit
operator|==
name|PreVisit
condition|)
name|mInLValue
operator|=
literal|true
expr_stmt|;
elseif|else
if|if
condition|(
name|visit
operator|==
name|PostVisit
condition|)
name|mInLValue
operator|=
literal|false
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|canRoundFloat
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|)
operator|&&
name|visit
operator|==
name|PreVisit
condition|)
block|{
name|TIntermNode
modifier|*
name|parent
init|=
name|getParentNode
argument_list|()
decl_stmt|;
name|TIntermNode
modifier|*
name|replacement
init|=
name|createRoundingFunctionCallNode
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|mReplacements
operator|.
name|push_back
argument_list|(
name|NodeUpdateEntry
argument_list|(
name|parent
argument_list|,
name|node
argument_list|,
name|replacement
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|writeEmulationHelpers
name|void
name|EmulatePrecision
operator|::
name|writeEmulationHelpers
parameter_list|(
name|TInfoSinkBase
modifier|&
name|sink
parameter_list|,
name|ShShaderOutput
name|outputLanguage
parameter_list|)
block|{
comment|// Other languages not yet supported
name|ASSERT
argument_list|(
name|outputLanguage
operator|==
name|SH_GLSL_COMPATIBILITY_OUTPUT
operator|||
name|outputLanguage
operator|==
name|SH_GLSL_CORE_OUTPUT
operator|||
name|outputLanguage
operator|==
name|SH_ESSL_OUTPUT
argument_list|)
expr_stmt|;
name|writeCommonPrecisionEmulationHelpers
argument_list|(
name|sink
argument_list|,
name|outputLanguage
argument_list|)
expr_stmt|;
name|EmulationSet
operator|::
name|const_iterator
name|it
decl_stmt|;
for|for
control|(
name|it
operator|=
name|mEmulateCompoundAdd
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|mEmulateCompoundAdd
operator|.
name|end
argument_list|()
condition|;
name|it
operator|++
control|)
name|writeCompoundAssignmentPrecisionEmulation
argument_list|(
name|sink
argument_list|,
name|outputLanguage
argument_list|,
name|it
operator|->
name|lType
argument_list|,
name|it
operator|->
name|rType
argument_list|,
literal|"+"
argument_list|,
literal|"add"
argument_list|)
expr_stmt|;
for|for
control|(
name|it
operator|=
name|mEmulateCompoundSub
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|mEmulateCompoundSub
operator|.
name|end
argument_list|()
condition|;
name|it
operator|++
control|)
name|writeCompoundAssignmentPrecisionEmulation
argument_list|(
name|sink
argument_list|,
name|outputLanguage
argument_list|,
name|it
operator|->
name|lType
argument_list|,
name|it
operator|->
name|rType
argument_list|,
literal|"-"
argument_list|,
literal|"sub"
argument_list|)
expr_stmt|;
for|for
control|(
name|it
operator|=
name|mEmulateCompoundDiv
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|mEmulateCompoundDiv
operator|.
name|end
argument_list|()
condition|;
name|it
operator|++
control|)
name|writeCompoundAssignmentPrecisionEmulation
argument_list|(
name|sink
argument_list|,
name|outputLanguage
argument_list|,
name|it
operator|->
name|lType
argument_list|,
name|it
operator|->
name|rType
argument_list|,
literal|"/"
argument_list|,
literal|"div"
argument_list|)
expr_stmt|;
for|for
control|(
name|it
operator|=
name|mEmulateCompoundMul
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|mEmulateCompoundMul
operator|.
name|end
argument_list|()
condition|;
name|it
operator|++
control|)
name|writeCompoundAssignmentPrecisionEmulation
argument_list|(
name|sink
argument_list|,
name|outputLanguage
argument_list|,
name|it
operator|->
name|lType
argument_list|,
name|it
operator|->
name|rType
argument_list|,
literal|"*"
argument_list|,
literal|"mul"
argument_list|)
expr_stmt|;
block|}
end_function
end_unit
