begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2015 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// SeparateExpressionsReturningArrays splits array-returning expressions that are not array names from more complex
end_comment
begin_comment
comment|// expressions, assigning them to a temporary variable a#.
end_comment
begin_comment
comment|// Examples where a, b and c are all arrays:
end_comment
begin_comment
comment|// (a = b) == (a = c) is split into a = b; type[n] a1 = a; a = c; type[n] a2 = a; a1 == a2;
end_comment
begin_comment
comment|// type d = type[n](...)[i]; is split into type[n] a1 = type[n](...); type d = a1[i];
end_comment
begin_include
include|#
directive|include
file|"compiler/translator/SeparateExpressionsReturningArrays.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/IntermNode.h"
end_include
begin_namespace
namespace|namespace
block|{
comment|// Traverser that separates one array expression into a statement at a time.
DECL|class|SeparateExpressionsTraverser
class|class
name|SeparateExpressionsTraverser
super|:
specifier|public
name|TIntermTraverser
block|{
public|public:
name|SeparateExpressionsTraverser
parameter_list|()
constructor_decl|;
DECL|member|override
name|bool
name|visitBinary
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermBinary
modifier|*
name|node
parameter_list|)
specifier|override
function_decl|;
DECL|member|override
name|bool
name|visitAggregate
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermAggregate
modifier|*
name|node
parameter_list|)
specifier|override
function_decl|;
name|void
name|nextIteration
parameter_list|()
function_decl|;
DECL|function|foundArrayExpression
name|bool
name|foundArrayExpression
parameter_list|()
specifier|const
block|{
return|return
name|mFoundArrayExpression
return|;
block|}
protected|protected:
comment|// Marked to true once an operation that needs to be hoisted out of the expression has been found.
comment|// After that, no more AST updates are performed on that traversal.
DECL|member|mFoundArrayExpression
name|bool
name|mFoundArrayExpression
decl_stmt|;
block|}
class|;
DECL|function|SeparateExpressionsTraverser
name|SeparateExpressionsTraverser
operator|::
name|SeparateExpressionsTraverser
parameter_list|()
member_init_list|:
name|TIntermTraverser
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
member_init_list|,
name|mFoundArrayExpression
argument_list|(
literal|false
argument_list|)
block|{ }
comment|// Performs a shallow copy of an assignment node.
comment|// These shallow copies are useful when a node gets inserted into an aggregate node
comment|// and also needs to be replaced in its original location by a different node.
DECL|function|CopyAssignmentNode
name|TIntermBinary
modifier|*
name|CopyAssignmentNode
parameter_list|(
name|TIntermBinary
modifier|*
name|node
parameter_list|)
block|{
name|TIntermBinary
modifier|*
name|copyNode
init|=
operator|new
name|TIntermBinary
argument_list|(
name|node
operator|->
name|getOp
argument_list|()
argument_list|)
decl_stmt|;
name|copyNode
operator|->
name|setLeft
argument_list|(
name|node
operator|->
name|getLeft
argument_list|()
argument_list|)
expr_stmt|;
name|copyNode
operator|->
name|setRight
argument_list|(
name|node
operator|->
name|getRight
argument_list|()
argument_list|)
expr_stmt|;
name|copyNode
operator|->
name|setType
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|copyNode
return|;
block|}
comment|// Performs a shallow copy of a constructor/function call node.
DECL|function|CopyAggregateNode
name|TIntermAggregate
modifier|*
name|CopyAggregateNode
parameter_list|(
name|TIntermAggregate
modifier|*
name|node
parameter_list|)
block|{
name|TIntermAggregate
modifier|*
name|copyNode
init|=
operator|new
name|TIntermAggregate
argument_list|(
name|node
operator|->
name|getOp
argument_list|()
argument_list|)
decl_stmt|;
name|TIntermSequence
modifier|*
name|copySeq
init|=
name|copyNode
operator|->
name|getSequence
argument_list|()
decl_stmt|;
name|copySeq
operator|->
name|insert
argument_list|(
name|copySeq
operator|->
name|begin
argument_list|()
argument_list|,
name|node
operator|->
name|getSequence
argument_list|()
operator|->
name|begin
argument_list|()
argument_list|,
name|node
operator|->
name|getSequence
argument_list|()
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|copyNode
operator|->
name|setType
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|copyNode
operator|->
name|setFunctionId
argument_list|(
name|node
operator|->
name|getFunctionId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|isUserDefined
argument_list|()
condition|)
block|{
name|copyNode
operator|->
name|setUserDefined
argument_list|()
expr_stmt|;
block|}
name|copyNode
operator|->
name|setNameObj
argument_list|(
name|node
operator|->
name|getNameObj
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|copyNode
return|;
block|}
DECL|function|visitBinary
name|bool
name|SeparateExpressionsTraverser
operator|::
name|visitBinary
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermBinary
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|mFoundArrayExpression
condition|)
return|return
literal|false
return|;
comment|// Early return if the expression is not an array or if we're not inside a complex expression.
if|if
condition|(
operator|!
name|node
operator|->
name|getType
argument_list|()
operator|.
name|isArray
argument_list|()
operator|||
name|parentNodeIsBlock
argument_list|()
condition|)
return|return
literal|true
return|;
switch|switch
condition|(
name|node
operator|->
name|getOp
argument_list|()
condition|)
block|{
case|case
name|EOpAssign
case|:
block|{
name|mFoundArrayExpression
operator|=
literal|true
expr_stmt|;
name|TIntermSequence
name|insertions
decl_stmt|;
name|insertions
operator|.
name|push_back
argument_list|(
name|CopyAssignmentNode
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
comment|// TODO(oetuaho): In some cases it would be more optimal to not add the temporary node, but just use the
comment|// original target of the assignment. Care must be taken so that this doesn't happen when the same array
comment|// symbol is a target of assignment more than once in one expression.
name|insertions
operator|.
name|push_back
argument_list|(
name|createTempInitDeclaration
argument_list|(
name|node
operator|->
name|getLeft
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|insertStatementsInParentBlock
argument_list|(
name|insertions
argument_list|)
expr_stmt|;
name|NodeUpdateEntry
name|replaceVariable
argument_list|(
name|getParentNode
argument_list|()
argument_list|,
name|node
argument_list|,
name|createTempSymbol
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|mReplacements
operator|.
name|push_back
argument_list|(
name|replaceVariable
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
default|default:
return|return
literal|true
return|;
block|}
block|}
DECL|function|visitAggregate
name|bool
name|SeparateExpressionsTraverser
operator|::
name|visitAggregate
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermAggregate
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|mFoundArrayExpression
condition|)
return|return
literal|false
return|;
comment|// No need to traverse further
if|if
condition|(
name|getParentNode
argument_list|()
operator|!=
literal|nullptr
condition|)
block|{
name|TIntermBinary
modifier|*
name|parentBinary
init|=
name|getParentNode
argument_list|()
operator|->
name|getAsBinaryNode
argument_list|()
decl_stmt|;
name|bool
name|parentIsAssignment
init|=
operator|(
name|parentBinary
operator|!=
literal|nullptr
operator|&&
operator|(
name|parentBinary
operator|->
name|getOp
argument_list|()
operator|==
name|EOpAssign
operator|||
name|parentBinary
operator|->
name|getOp
argument_list|()
operator|==
name|EOpInitialize
operator|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|getType
argument_list|()
operator|.
name|isArray
argument_list|()
operator|||
name|parentNodeIsBlock
argument_list|()
operator|||
name|parentIsAssignment
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|node
operator|->
name|isConstructor
argument_list|()
condition|)
block|{
name|mFoundArrayExpression
operator|=
literal|true
expr_stmt|;
name|TIntermSequence
name|insertions
decl_stmt|;
name|insertions
operator|.
name|push_back
argument_list|(
name|createTempInitDeclaration
argument_list|(
name|CopyAggregateNode
argument_list|(
name|node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|insertStatementsInParentBlock
argument_list|(
name|insertions
argument_list|)
expr_stmt|;
name|NodeUpdateEntry
name|replaceVariable
argument_list|(
name|getParentNode
argument_list|()
argument_list|,
name|node
argument_list|,
name|createTempSymbol
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|mReplacements
operator|.
name|push_back
argument_list|(
name|replaceVariable
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|getOp
argument_list|()
operator|==
name|EOpFunctionCall
condition|)
block|{
name|mFoundArrayExpression
operator|=
literal|true
expr_stmt|;
name|TIntermSequence
name|insertions
decl_stmt|;
name|insertions
operator|.
name|push_back
argument_list|(
name|createTempInitDeclaration
argument_list|(
name|CopyAggregateNode
argument_list|(
name|node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|insertStatementsInParentBlock
argument_list|(
name|insertions
argument_list|)
expr_stmt|;
name|NodeUpdateEntry
name|replaceVariable
argument_list|(
name|getParentNode
argument_list|()
argument_list|,
name|node
argument_list|,
name|createTempSymbol
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|mReplacements
operator|.
name|push_back
argument_list|(
name|replaceVariable
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|nextIteration
name|void
name|SeparateExpressionsTraverser
operator|::
name|nextIteration
parameter_list|()
block|{
name|mFoundArrayExpression
operator|=
literal|false
expr_stmt|;
name|nextTemporaryIndex
argument_list|()
expr_stmt|;
block|}
block|}
end_namespace
begin_comment
comment|// namespace
end_comment
begin_function
DECL|function|SeparateExpressionsReturningArrays
name|void
name|SeparateExpressionsReturningArrays
parameter_list|(
name|TIntermNode
modifier|*
name|root
parameter_list|,
name|unsigned
name|int
modifier|*
name|temporaryIndex
parameter_list|)
block|{
name|SeparateExpressionsTraverser
name|traverser
decl_stmt|;
name|ASSERT
argument_list|(
name|temporaryIndex
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
name|traverser
operator|.
name|useTemporaryIndex
argument_list|(
name|temporaryIndex
argument_list|)
expr_stmt|;
comment|// Separate one expression at a time, and reset the traverser between iterations.
do|do
block|{
name|traverser
operator|.
name|nextIteration
argument_list|()
expr_stmt|;
name|root
operator|->
name|traverse
argument_list|(
operator|&
name|traverser
argument_list|)
expr_stmt|;
if|if
condition|(
name|traverser
operator|.
name|foundArrayExpression
argument_list|()
condition|)
name|traverser
operator|.
name|updateTree
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|traverser
operator|.
name|foundArrayExpression
argument_list|()
condition|)
do|;
block|}
end_function
end_unit
