begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|"compiler/translator/LoopInfo.h"
end_include
begin_namespace
namespace|namespace
block|{
DECL|function|EvaluateIntConstant
name|int
name|EvaluateIntConstant
parameter_list|(
name|TIntermConstantUnion
modifier|*
name|node
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|node
operator|&&
name|node
operator|->
name|getUnionArrayPointer
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|node
operator|->
name|getIConst
argument_list|(
literal|0
argument_list|)
return|;
block|}
DECL|function|GetLoopIntIncrement
name|int
name|GetLoopIntIncrement
parameter_list|(
name|TIntermLoop
modifier|*
name|node
parameter_list|)
block|{
name|TIntermNode
modifier|*
name|expr
init|=
name|node
operator|->
name|getExpression
argument_list|()
decl_stmt|;
comment|// for expression has one of the following forms:
comment|//     loop_index++
comment|//     loop_index--
comment|//     loop_index += constant_expression
comment|//     loop_index -= constant_expression
comment|//     ++loop_index
comment|//     --loop_index
comment|// The last two forms are not specified in the spec, but I am assuming
comment|// its an oversight.
name|TIntermUnary
modifier|*
name|unOp
init|=
name|expr
operator|->
name|getAsUnaryNode
argument_list|()
decl_stmt|;
name|TIntermBinary
modifier|*
name|binOp
init|=
name|unOp
condition|?
name|NULL
else|:
name|expr
operator|->
name|getAsBinaryNode
argument_list|()
decl_stmt|;
name|TOperator
name|op
init|=
name|EOpNull
decl_stmt|;
name|TIntermConstantUnion
modifier|*
name|incrementNode
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|unOp
condition|)
block|{
name|op
operator|=
name|unOp
operator|->
name|getOp
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|binOp
condition|)
block|{
name|op
operator|=
name|binOp
operator|->
name|getOp
argument_list|()
expr_stmt|;
name|ASSERT
argument_list|(
name|binOp
operator|->
name|getRight
argument_list|()
argument_list|)
expr_stmt|;
name|incrementNode
operator|=
name|binOp
operator|->
name|getRight
argument_list|()
operator|->
name|getAsConstantUnion
argument_list|()
expr_stmt|;
name|ASSERT
argument_list|(
name|incrementNode
argument_list|)
expr_stmt|;
block|}
name|int
name|increment
init|=
literal|0
decl_stmt|;
comment|// The operator is one of: ++ -- += -=.
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|EOpPostIncrement
case|:
case|case
name|EOpPreIncrement
case|:
name|ASSERT
argument_list|(
name|unOp
operator|&&
operator|!
name|binOp
argument_list|)
expr_stmt|;
name|increment
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|EOpPostDecrement
case|:
case|case
name|EOpPreDecrement
case|:
name|ASSERT
argument_list|(
name|unOp
operator|&&
operator|!
name|binOp
argument_list|)
expr_stmt|;
name|increment
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|EOpAddAssign
case|:
name|ASSERT
argument_list|(
operator|!
name|unOp
operator|&&
name|binOp
argument_list|)
expr_stmt|;
name|increment
operator|=
name|EvaluateIntConstant
argument_list|(
name|incrementNode
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpSubAssign
case|:
name|ASSERT
argument_list|(
operator|!
name|unOp
operator|&&
name|binOp
argument_list|)
expr_stmt|;
name|increment
operator|=
operator|-
name|EvaluateIntConstant
argument_list|(
name|incrementNode
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
name|increment
return|;
block|}
block|}
end_namespace
begin_comment
comment|// namespace anonymous
end_comment
begin_constructor
DECL|function|TLoopIndexInfo
name|TLoopIndexInfo
operator|::
name|TLoopIndexInfo
parameter_list|()
member_init_list|:
name|mId
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|mType
argument_list|(
name|EbtVoid
argument_list|)
member_init_list|,
name|mInitValue
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mStopValue
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mIncrementValue
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mOp
argument_list|(
name|EOpNull
argument_list|)
member_init_list|,
name|mCurrentValue
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_function
DECL|function|fillInfo
name|void
name|TLoopIndexInfo
operator|::
name|fillInfo
parameter_list|(
name|TIntermLoop
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return;
comment|// Here we assume all the operations are valid, because the loop node is
comment|// already validated in ValidateLimitations.
name|TIntermSequence
modifier|*
name|declSeq
init|=
name|node
operator|->
name|getInit
argument_list|()
operator|->
name|getAsAggregate
argument_list|()
operator|->
name|getSequence
argument_list|()
decl_stmt|;
name|TIntermBinary
modifier|*
name|declInit
init|=
operator|(
operator|*
name|declSeq
operator|)
index|[
literal|0
index|]
operator|->
name|getAsBinaryNode
argument_list|()
decl_stmt|;
name|TIntermSymbol
modifier|*
name|symbol
init|=
name|declInit
operator|->
name|getLeft
argument_list|()
operator|->
name|getAsSymbolNode
argument_list|()
decl_stmt|;
name|mId
operator|=
name|symbol
operator|->
name|getId
argument_list|()
expr_stmt|;
name|mType
operator|=
name|symbol
operator|->
name|getBasicType
argument_list|()
expr_stmt|;
if|if
condition|(
name|mType
operator|==
name|EbtInt
condition|)
block|{
name|TIntermConstantUnion
modifier|*
name|initNode
init|=
name|declInit
operator|->
name|getRight
argument_list|()
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
name|mInitValue
operator|=
name|EvaluateIntConstant
argument_list|(
name|initNode
argument_list|)
expr_stmt|;
name|mCurrentValue
operator|=
name|mInitValue
expr_stmt|;
name|mIncrementValue
operator|=
name|GetLoopIntIncrement
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|TIntermBinary
modifier|*
name|binOp
init|=
name|node
operator|->
name|getCondition
argument_list|()
operator|->
name|getAsBinaryNode
argument_list|()
decl_stmt|;
name|mStopValue
operator|=
name|EvaluateIntConstant
argument_list|(
name|binOp
operator|->
name|getRight
argument_list|()
operator|->
name|getAsConstantUnion
argument_list|()
argument_list|)
expr_stmt|;
name|mOp
operator|=
name|binOp
operator|->
name|getOp
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|satisfiesLoopCondition
name|bool
name|TLoopIndexInfo
operator|::
name|satisfiesLoopCondition
parameter_list|()
specifier|const
block|{
comment|// Relational operator is one of:>>=<<= == or !=.
switch|switch
condition|(
name|mOp
condition|)
block|{
case|case
name|EOpEqual
case|:
return|return
operator|(
name|mCurrentValue
operator|==
name|mStopValue
operator|)
return|;
case|case
name|EOpNotEqual
case|:
return|return
operator|(
name|mCurrentValue
operator|!=
name|mStopValue
operator|)
return|;
case|case
name|EOpLessThan
case|:
return|return
operator|(
name|mCurrentValue
operator|<
name|mStopValue
operator|)
return|;
case|case
name|EOpGreaterThan
case|:
return|return
operator|(
name|mCurrentValue
operator|>
name|mStopValue
operator|)
return|;
case|case
name|EOpLessThanEqual
case|:
return|return
operator|(
name|mCurrentValue
operator|<=
name|mStopValue
operator|)
return|;
case|case
name|EOpGreaterThanEqual
case|:
return|return
operator|(
name|mCurrentValue
operator|>=
name|mStopValue
operator|)
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
end_function
begin_constructor
DECL|function|TLoopInfo
name|TLoopInfo
operator|::
name|TLoopInfo
parameter_list|()
member_init_list|:
name|loop
argument_list|(
name|NULL
argument_list|)
block|{ }
end_constructor
begin_constructor
DECL|function|TLoopInfo
name|TLoopInfo
operator|::
name|TLoopInfo
parameter_list|(
name|TIntermLoop
modifier|*
name|node
parameter_list|)
member_init_list|:
name|loop
argument_list|(
name|node
argument_list|)
block|{
name|index
operator|.
name|fillInfo
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|findLoop
name|TIntermLoop
modifier|*
name|TLoopStack
operator|::
name|findLoop
parameter_list|(
name|TIntermSymbol
modifier|*
name|symbol
parameter_list|)
block|{
if|if
condition|(
operator|!
name|symbol
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|iterator
name|iter
init|=
name|begin
argument_list|()
init|;
name|iter
operator|!=
name|end
argument_list|()
condition|;
operator|++
name|iter
control|)
block|{
if|if
condition|(
name|iter
operator|->
name|index
operator|.
name|getId
argument_list|()
operator|==
name|symbol
operator|->
name|getId
argument_list|()
condition|)
return|return
name|iter
operator|->
name|loop
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|getIndexInfo
name|TLoopIndexInfo
modifier|*
name|TLoopStack
operator|::
name|getIndexInfo
parameter_list|(
name|TIntermSymbol
modifier|*
name|symbol
parameter_list|)
block|{
if|if
condition|(
operator|!
name|symbol
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|iterator
name|iter
init|=
name|begin
argument_list|()
init|;
name|iter
operator|!=
name|end
argument_list|()
condition|;
operator|++
name|iter
control|)
block|{
if|if
condition|(
name|iter
operator|->
name|index
operator|.
name|getId
argument_list|()
operator|==
name|symbol
operator|->
name|getId
argument_list|()
condition|)
return|return
operator|&
operator|(
name|iter
operator|->
name|index
operator|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|step
name|void
name|TLoopStack
operator|::
name|step
parameter_list|()
block|{
name|ASSERT
argument_list|(
operator|!
name|empty
argument_list|()
argument_list|)
expr_stmt|;
name|rbegin
argument_list|()
operator|->
name|index
operator|.
name|step
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|satisfiesLoopCondition
name|bool
name|TLoopStack
operator|::
name|satisfiesLoopCondition
parameter_list|()
block|{
name|ASSERT
argument_list|(
operator|!
name|empty
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|rbegin
argument_list|()
operator|->
name|index
operator|.
name|satisfiesLoopCondition
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|needsToReplaceSymbolWithValue
name|bool
name|TLoopStack
operator|::
name|needsToReplaceSymbolWithValue
parameter_list|(
name|TIntermSymbol
modifier|*
name|symbol
parameter_list|)
block|{
name|TIntermLoop
modifier|*
name|loop
init|=
name|findLoop
argument_list|(
name|symbol
argument_list|)
decl_stmt|;
return|return
name|loop
operator|&&
name|loop
operator|->
name|getUnrollFlag
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|getLoopIndexValue
name|int
name|TLoopStack
operator|::
name|getLoopIndexValue
parameter_list|(
name|TIntermSymbol
modifier|*
name|symbol
parameter_list|)
block|{
name|TLoopIndexInfo
modifier|*
name|info
init|=
name|getIndexInfo
argument_list|(
name|symbol
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|info
argument_list|)
expr_stmt|;
return|return
name|info
operator|->
name|getCurrentValue
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|push
name|void
name|TLoopStack
operator|::
name|push
parameter_list|(
name|TIntermLoop
modifier|*
name|loop
parameter_list|)
block|{
name|TLoopInfo
name|info
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|push_back
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|pop
name|void
name|TLoopStack
operator|::
name|pop
parameter_list|()
block|{
name|pop_back
argument_list|()
expr_stmt|;
block|}
end_function
end_unit
