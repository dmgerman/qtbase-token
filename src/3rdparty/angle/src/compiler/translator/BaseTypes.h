begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2010 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|_BASICTYPES_INCLUDED_
end_ifndef
begin_define
DECL|macro|_BASICTYPES_INCLUDED_
define|#
directive|define
name|_BASICTYPES_INCLUDED_
end_define
begin_comment
comment|//
end_comment
begin_comment
comment|// Precision qualifiers
end_comment
begin_comment
comment|//
end_comment
begin_enum
DECL|enum|TPrecision
enum|enum
name|TPrecision
block|{
comment|// These need to be kept sorted
DECL|enumerator|EbpUndefined
name|EbpUndefined
block|,
DECL|enumerator|EbpLow
name|EbpLow
block|,
DECL|enumerator|EbpMedium
name|EbpMedium
block|,
DECL|enumerator|EbpHigh
name|EbpHigh
block|}
enum|;
end_enum
begin_function
DECL|function|getPrecisionString
specifier|inline
specifier|const
name|char
modifier|*
name|getPrecisionString
parameter_list|(
name|TPrecision
name|p
parameter_list|)
block|{
switch|switch
condition|(
name|p
condition|)
block|{
case|case
name|EbpHigh
case|:
return|return
literal|"highp"
return|;
break|break;
case|case
name|EbpMedium
case|:
return|return
literal|"mediump"
return|;
break|break;
case|case
name|EbpLow
case|:
return|return
literal|"lowp"
return|;
break|break;
default|default:
return|return
literal|"mediump"
return|;
break|break;
comment|// Safest fallback
block|}
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Basic type.  Arrays, vectors, etc., are orthogonal to this.
end_comment
begin_comment
comment|//
end_comment
begin_enum
DECL|enum|TBasicType
enum|enum
name|TBasicType
block|{
DECL|enumerator|EbtVoid
name|EbtVoid
block|,
DECL|enumerator|EbtFloat
name|EbtFloat
block|,
DECL|enumerator|EbtInt
name|EbtInt
block|,
DECL|enumerator|EbtBool
name|EbtBool
block|,
DECL|enumerator|EbtGuardSamplerBegin
name|EbtGuardSamplerBegin
block|,
comment|// non type:  see implementation of IsSampler()
DECL|enumerator|EbtSampler2D
name|EbtSampler2D
block|,
DECL|enumerator|EbtSamplerCube
name|EbtSamplerCube
block|,
DECL|enumerator|EbtSamplerExternalOES
name|EbtSamplerExternalOES
block|,
comment|// Only valid if OES_EGL_image_external exists.
DECL|enumerator|EbtSampler2DRect
name|EbtSampler2DRect
block|,
comment|// Only valid if GL_ARB_texture_rectangle exists.
DECL|enumerator|EbtGuardSamplerEnd
name|EbtGuardSamplerEnd
block|,
comment|// non type:  see implementation of IsSampler()
DECL|enumerator|EbtStruct
name|EbtStruct
block|,
DECL|enumerator|EbtAddress
name|EbtAddress
block|,
comment|// should be deprecated??
DECL|enumerator|EbtInvariant
name|EbtInvariant
comment|// used as a type when qualifying a previously declared variable as being invariant
block|}
enum|;
end_enum
begin_function
DECL|function|getBasicString
specifier|inline
specifier|const
name|char
modifier|*
name|getBasicString
parameter_list|(
name|TBasicType
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|EbtVoid
case|:
return|return
literal|"void"
return|;
break|break;
case|case
name|EbtFloat
case|:
return|return
literal|"float"
return|;
break|break;
case|case
name|EbtInt
case|:
return|return
literal|"int"
return|;
break|break;
case|case
name|EbtBool
case|:
return|return
literal|"bool"
return|;
break|break;
case|case
name|EbtSampler2D
case|:
return|return
literal|"sampler2D"
return|;
break|break;
case|case
name|EbtSamplerCube
case|:
return|return
literal|"samplerCube"
return|;
break|break;
case|case
name|EbtSamplerExternalOES
case|:
return|return
literal|"samplerExternalOES"
return|;
break|break;
case|case
name|EbtSampler2DRect
case|:
return|return
literal|"sampler2DRect"
return|;
break|break;
case|case
name|EbtStruct
case|:
return|return
literal|"structure"
return|;
break|break;
default|default:
return|return
literal|"unknown type"
return|;
block|}
block|}
end_function
begin_function
DECL|function|IsSampler
specifier|inline
name|bool
name|IsSampler
parameter_list|(
name|TBasicType
name|type
parameter_list|)
block|{
return|return
name|type
operator|>
name|EbtGuardSamplerBegin
operator|&&
name|type
operator|<
name|EbtGuardSamplerEnd
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Qualifiers and built-ins.  These are mainly used to see what can be read
end_comment
begin_comment
comment|// or written, and by the machine dependent translator to know which registers
end_comment
begin_comment
comment|// to allocate variables in.  Since built-ins tend to go to different registers
end_comment
begin_comment
comment|// than varying or uniform, it makes sense they are peers, not sub-classes.
end_comment
begin_comment
comment|//
end_comment
begin_enum
DECL|enum|TQualifier
enum|enum
name|TQualifier
block|{
DECL|enumerator|EvqTemporary
name|EvqTemporary
block|,
comment|// For temporaries (within a function), read/write
DECL|enumerator|EvqGlobal
name|EvqGlobal
block|,
comment|// For globals read/write
DECL|enumerator|EvqInternal
name|EvqInternal
block|,
comment|// For internal use, not visible to the user
DECL|enumerator|EvqConst
name|EvqConst
block|,
comment|// User defined constants and non-output parameters in functions
DECL|enumerator|EvqAttribute
name|EvqAttribute
block|,
comment|// Readonly
DECL|enumerator|EvqVaryingIn
name|EvqVaryingIn
block|,
comment|// readonly, fragment shaders only
DECL|enumerator|EvqVaryingOut
name|EvqVaryingOut
block|,
comment|// vertex shaders only  read/write
DECL|enumerator|EvqInvariantVaryingIn
name|EvqInvariantVaryingIn
block|,
comment|// readonly, fragment shaders only
DECL|enumerator|EvqInvariantVaryingOut
name|EvqInvariantVaryingOut
block|,
comment|// vertex shaders only  read/write
DECL|enumerator|EvqUniform
name|EvqUniform
block|,
comment|// Readonly, vertex and fragment
comment|// parameters
DECL|enumerator|EvqIn
name|EvqIn
block|,
DECL|enumerator|EvqOut
name|EvqOut
block|,
DECL|enumerator|EvqInOut
name|EvqInOut
block|,
DECL|enumerator|EvqConstReadOnly
name|EvqConstReadOnly
block|,
comment|// built-ins written by vertex shader
DECL|enumerator|EvqPosition
name|EvqPosition
block|,
DECL|enumerator|EvqPointSize
name|EvqPointSize
block|,
comment|// built-ins read by fragment shader
DECL|enumerator|EvqFragCoord
name|EvqFragCoord
block|,
DECL|enumerator|EvqFrontFacing
name|EvqFrontFacing
block|,
DECL|enumerator|EvqPointCoord
name|EvqPointCoord
block|,
comment|// built-ins written by fragment shader
DECL|enumerator|EvqFragColor
name|EvqFragColor
block|,
DECL|enumerator|EvqFragData
name|EvqFragData
block|,
DECL|enumerator|EvqFragDepth
name|EvqFragDepth
block|,
comment|// end of list
DECL|enumerator|EvqLast
name|EvqLast
block|}
enum|;
end_enum
begin_comment
comment|//
end_comment
begin_comment
comment|// This is just for debug print out, carried along with the definitions above.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|getQualifierString
specifier|inline
specifier|const
name|char
modifier|*
name|getQualifierString
parameter_list|(
name|TQualifier
name|q
parameter_list|)
block|{
switch|switch
condition|(
name|q
condition|)
block|{
case|case
name|EvqTemporary
case|:
return|return
literal|"Temporary"
return|;
break|break;
case|case
name|EvqGlobal
case|:
return|return
literal|"Global"
return|;
break|break;
case|case
name|EvqConst
case|:
return|return
literal|"const"
return|;
break|break;
case|case
name|EvqConstReadOnly
case|:
return|return
literal|"const"
return|;
break|break;
case|case
name|EvqAttribute
case|:
return|return
literal|"attribute"
return|;
break|break;
case|case
name|EvqVaryingIn
case|:
return|return
literal|"varying"
return|;
break|break;
case|case
name|EvqVaryingOut
case|:
return|return
literal|"varying"
return|;
break|break;
case|case
name|EvqInvariantVaryingIn
case|:
return|return
literal|"invariant varying"
return|;
break|break;
case|case
name|EvqInvariantVaryingOut
case|:
return|return
literal|"invariant varying"
return|;
break|break;
case|case
name|EvqUniform
case|:
return|return
literal|"uniform"
return|;
break|break;
case|case
name|EvqIn
case|:
return|return
literal|"in"
return|;
break|break;
case|case
name|EvqOut
case|:
return|return
literal|"out"
return|;
break|break;
case|case
name|EvqInOut
case|:
return|return
literal|"inout"
return|;
break|break;
case|case
name|EvqPosition
case|:
return|return
literal|"Position"
return|;
break|break;
case|case
name|EvqPointSize
case|:
return|return
literal|"PointSize"
return|;
break|break;
case|case
name|EvqFragCoord
case|:
return|return
literal|"FragCoord"
return|;
break|break;
case|case
name|EvqFrontFacing
case|:
return|return
literal|"FrontFacing"
return|;
break|break;
case|case
name|EvqFragColor
case|:
return|return
literal|"FragColor"
return|;
break|break;
case|case
name|EvqFragData
case|:
return|return
literal|"FragData"
return|;
break|break;
case|case
name|EvqFragDepth
case|:
return|return
literal|"FragDepth"
return|;
break|break;
default|default:
return|return
literal|"unknown qualifier"
return|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// _BASICTYPES_INCLUDED_
end_comment
end_unit
