begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2013 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|_BASICTYPES_INCLUDED_
end_ifndef
begin_define
DECL|macro|_BASICTYPES_INCLUDED_
define|#
directive|define
name|_BASICTYPES_INCLUDED_
end_define
begin_include
include|#
directive|include
file|<assert.h>
end_include
begin_comment
comment|//
end_comment
begin_comment
comment|// Precision qualifiers
end_comment
begin_comment
comment|//
end_comment
begin_enum
DECL|enum|TPrecision
enum|enum
name|TPrecision
block|{
comment|// These need to be kept sorted
DECL|enumerator|EbpUndefined
name|EbpUndefined
block|,
DECL|enumerator|EbpLow
name|EbpLow
block|,
DECL|enumerator|EbpMedium
name|EbpMedium
block|,
DECL|enumerator|EbpHigh
name|EbpHigh
block|}
enum|;
end_enum
begin_function
DECL|function|getPrecisionString
specifier|inline
specifier|const
name|char
modifier|*
name|getPrecisionString
parameter_list|(
name|TPrecision
name|p
parameter_list|)
block|{
switch|switch
condition|(
name|p
condition|)
block|{
case|case
name|EbpHigh
case|:
return|return
literal|"highp"
return|;
break|break;
case|case
name|EbpMedium
case|:
return|return
literal|"mediump"
return|;
break|break;
case|case
name|EbpLow
case|:
return|return
literal|"lowp"
return|;
break|break;
default|default:
return|return
literal|"mediump"
return|;
break|break;
comment|// Safest fallback
block|}
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Basic type.  Arrays, vectors, etc., are orthogonal to this.
end_comment
begin_comment
comment|//
end_comment
begin_enum
DECL|enum|TBasicType
enum|enum
name|TBasicType
block|{
DECL|enumerator|EbtVoid
name|EbtVoid
block|,
DECL|enumerator|EbtFloat
name|EbtFloat
block|,
DECL|enumerator|EbtInt
name|EbtInt
block|,
DECL|enumerator|EbtUInt
name|EbtUInt
block|,
DECL|enumerator|EbtBool
name|EbtBool
block|,
DECL|enumerator|EbtGVec4
name|EbtGVec4
block|,
comment|// non type: represents vec4, ivec4 and uvec4
DECL|enumerator|EbtGuardSamplerBegin
name|EbtGuardSamplerBegin
block|,
comment|// non type: see implementation of IsSampler()
DECL|enumerator|EbtSampler2D
name|EbtSampler2D
block|,
DECL|enumerator|EbtSampler3D
name|EbtSampler3D
block|,
DECL|enumerator|EbtSamplerCube
name|EbtSamplerCube
block|,
DECL|enumerator|EbtSampler2DArray
name|EbtSampler2DArray
block|,
DECL|enumerator|EbtSamplerExternalOES
name|EbtSamplerExternalOES
block|,
comment|// Only valid if OES_EGL_image_external exists.
DECL|enumerator|EbtSampler2DRect
name|EbtSampler2DRect
block|,
comment|// Only valid if GL_ARB_texture_rectangle exists.
DECL|enumerator|EbtISampler2D
name|EbtISampler2D
block|,
DECL|enumerator|EbtISampler3D
name|EbtISampler3D
block|,
DECL|enumerator|EbtISamplerCube
name|EbtISamplerCube
block|,
DECL|enumerator|EbtISampler2DArray
name|EbtISampler2DArray
block|,
DECL|enumerator|EbtUSampler2D
name|EbtUSampler2D
block|,
DECL|enumerator|EbtUSampler3D
name|EbtUSampler3D
block|,
DECL|enumerator|EbtUSamplerCube
name|EbtUSamplerCube
block|,
DECL|enumerator|EbtUSampler2DArray
name|EbtUSampler2DArray
block|,
DECL|enumerator|EbtSampler2DShadow
name|EbtSampler2DShadow
block|,
DECL|enumerator|EbtSamplerCubeShadow
name|EbtSamplerCubeShadow
block|,
DECL|enumerator|EbtSampler2DArrayShadow
name|EbtSampler2DArrayShadow
block|,
DECL|enumerator|EbtGuardSamplerEnd
name|EbtGuardSamplerEnd
block|,
comment|// non type: see implementation of IsSampler()
DECL|enumerator|EbtGSampler2D
name|EbtGSampler2D
block|,
comment|// non type: represents sampler2D, isampler2D and usampler2D
DECL|enumerator|EbtGSampler3D
name|EbtGSampler3D
block|,
comment|// non type: represents sampler3D, isampler3D and usampler3D
DECL|enumerator|EbtGSamplerCube
name|EbtGSamplerCube
block|,
comment|// non type: represents samplerCube, isamplerCube and usamplerCube
DECL|enumerator|EbtGSampler2DArray
name|EbtGSampler2DArray
block|,
comment|// non type: represents sampler2DArray, isampler2DArray and usampler2DArray
DECL|enumerator|EbtStruct
name|EbtStruct
block|,
DECL|enumerator|EbtInterfaceBlock
name|EbtInterfaceBlock
block|,
DECL|enumerator|EbtAddress
name|EbtAddress
block|,
comment|// should be deprecated??
DECL|enumerator|EbtInvariant
name|EbtInvariant
comment|// used as a type when qualifying a previously declared variable as being invariant
block|}
enum|;
end_enum
begin_function
DECL|function|getBasicString
specifier|inline
specifier|const
name|char
modifier|*
name|getBasicString
parameter_list|(
name|TBasicType
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|EbtVoid
case|:
return|return
literal|"void"
return|;
break|break;
case|case
name|EbtFloat
case|:
return|return
literal|"float"
return|;
break|break;
case|case
name|EbtInt
case|:
return|return
literal|"int"
return|;
break|break;
case|case
name|EbtUInt
case|:
return|return
literal|"uint"
return|;
break|break;
case|case
name|EbtBool
case|:
return|return
literal|"bool"
return|;
break|break;
case|case
name|EbtSampler2D
case|:
return|return
literal|"sampler2D"
return|;
break|break;
case|case
name|EbtSampler3D
case|:
return|return
literal|"sampler3D"
return|;
break|break;
case|case
name|EbtSamplerCube
case|:
return|return
literal|"samplerCube"
return|;
break|break;
case|case
name|EbtSamplerExternalOES
case|:
return|return
literal|"samplerExternalOES"
return|;
break|break;
case|case
name|EbtSampler2DRect
case|:
return|return
literal|"sampler2DRect"
return|;
break|break;
case|case
name|EbtSampler2DArray
case|:
return|return
literal|"sampler2DArray"
return|;
break|break;
case|case
name|EbtISampler2D
case|:
return|return
literal|"isampler2D"
return|;
break|break;
case|case
name|EbtISampler3D
case|:
return|return
literal|"isampler3D"
return|;
break|break;
case|case
name|EbtISamplerCube
case|:
return|return
literal|"isamplerCube"
return|;
break|break;
case|case
name|EbtISampler2DArray
case|:
return|return
literal|"isampler2DArray"
return|;
break|break;
case|case
name|EbtUSampler2D
case|:
return|return
literal|"usampler2D"
return|;
break|break;
case|case
name|EbtUSampler3D
case|:
return|return
literal|"usampler3D"
return|;
break|break;
case|case
name|EbtUSamplerCube
case|:
return|return
literal|"usamplerCube"
return|;
break|break;
case|case
name|EbtUSampler2DArray
case|:
return|return
literal|"usampler2DArray"
return|;
break|break;
case|case
name|EbtSampler2DShadow
case|:
return|return
literal|"sampler2DShadow"
return|;
break|break;
case|case
name|EbtSamplerCubeShadow
case|:
return|return
literal|"samplerCubeShadow"
return|;
break|break;
case|case
name|EbtSampler2DArrayShadow
case|:
return|return
literal|"sampler2DArrayShadow"
return|;
break|break;
case|case
name|EbtStruct
case|:
return|return
literal|"structure"
return|;
break|break;
case|case
name|EbtInterfaceBlock
case|:
return|return
literal|"interface block"
return|;
break|break;
default|default:
return|return
literal|"unknown type"
return|;
block|}
block|}
end_function
begin_function
DECL|function|IsSampler
specifier|inline
name|bool
name|IsSampler
parameter_list|(
name|TBasicType
name|type
parameter_list|)
block|{
return|return
name|type
operator|>
name|EbtGuardSamplerBegin
operator|&&
name|type
operator|<
name|EbtGuardSamplerEnd
return|;
block|}
end_function
begin_function
DECL|function|IsIntegerSampler
specifier|inline
name|bool
name|IsIntegerSampler
parameter_list|(
name|TBasicType
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|EbtISampler2D
case|:
case|case
name|EbtISampler3D
case|:
case|case
name|EbtISamplerCube
case|:
case|case
name|EbtISampler2DArray
case|:
case|case
name|EbtUSampler2D
case|:
case|case
name|EbtUSampler3D
case|:
case|case
name|EbtUSamplerCube
case|:
case|case
name|EbtUSampler2DArray
case|:
return|return
name|true
return|;
case|case
name|EbtSampler2D
case|:
case|case
name|EbtSampler3D
case|:
case|case
name|EbtSamplerCube
case|:
case|case
name|EbtSamplerExternalOES
case|:
case|case
name|EbtSampler2DRect
case|:
case|case
name|EbtSampler2DArray
case|:
case|case
name|EbtSampler2DShadow
case|:
case|case
name|EbtSamplerCubeShadow
case|:
case|case
name|EbtSampler2DArrayShadow
case|:
return|return
name|false
return|;
default|default:
name|assert
argument_list|(
operator|!
name|IsSampler
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function
begin_function
DECL|function|IsSampler2D
specifier|inline
name|bool
name|IsSampler2D
parameter_list|(
name|TBasicType
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|EbtSampler2D
case|:
case|case
name|EbtISampler2D
case|:
case|case
name|EbtUSampler2D
case|:
case|case
name|EbtSampler2DArray
case|:
case|case
name|EbtISampler2DArray
case|:
case|case
name|EbtUSampler2DArray
case|:
case|case
name|EbtSampler2DRect
case|:
case|case
name|EbtSamplerExternalOES
case|:
case|case
name|EbtSampler2DShadow
case|:
case|case
name|EbtSampler2DArrayShadow
case|:
return|return
name|true
return|;
case|case
name|EbtSampler3D
case|:
case|case
name|EbtISampler3D
case|:
case|case
name|EbtUSampler3D
case|:
case|case
name|EbtISamplerCube
case|:
case|case
name|EbtUSamplerCube
case|:
case|case
name|EbtSamplerCube
case|:
case|case
name|EbtSamplerCubeShadow
case|:
return|return
name|false
return|;
default|default:
name|assert
argument_list|(
operator|!
name|IsSampler
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function
begin_function
DECL|function|IsSamplerCube
specifier|inline
name|bool
name|IsSamplerCube
parameter_list|(
name|TBasicType
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|EbtSamplerCube
case|:
case|case
name|EbtISamplerCube
case|:
case|case
name|EbtUSamplerCube
case|:
case|case
name|EbtSamplerCubeShadow
case|:
return|return
name|true
return|;
case|case
name|EbtSampler2D
case|:
case|case
name|EbtSampler3D
case|:
case|case
name|EbtSamplerExternalOES
case|:
case|case
name|EbtSampler2DRect
case|:
case|case
name|EbtSampler2DArray
case|:
case|case
name|EbtISampler2D
case|:
case|case
name|EbtISampler3D
case|:
case|case
name|EbtISampler2DArray
case|:
case|case
name|EbtUSampler2D
case|:
case|case
name|EbtUSampler3D
case|:
case|case
name|EbtUSampler2DArray
case|:
case|case
name|EbtSampler2DShadow
case|:
case|case
name|EbtSampler2DArrayShadow
case|:
return|return
name|false
return|;
default|default:
name|assert
argument_list|(
operator|!
name|IsSampler
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function
begin_function
DECL|function|IsSampler3D
specifier|inline
name|bool
name|IsSampler3D
parameter_list|(
name|TBasicType
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|EbtSampler3D
case|:
case|case
name|EbtISampler3D
case|:
case|case
name|EbtUSampler3D
case|:
return|return
name|true
return|;
case|case
name|EbtSampler2D
case|:
case|case
name|EbtSamplerCube
case|:
case|case
name|EbtSamplerExternalOES
case|:
case|case
name|EbtSampler2DRect
case|:
case|case
name|EbtSampler2DArray
case|:
case|case
name|EbtISampler2D
case|:
case|case
name|EbtISamplerCube
case|:
case|case
name|EbtISampler2DArray
case|:
case|case
name|EbtUSampler2D
case|:
case|case
name|EbtUSamplerCube
case|:
case|case
name|EbtUSampler2DArray
case|:
case|case
name|EbtSampler2DShadow
case|:
case|case
name|EbtSamplerCubeShadow
case|:
case|case
name|EbtSampler2DArrayShadow
case|:
return|return
name|false
return|;
default|default:
name|assert
argument_list|(
operator|!
name|IsSampler
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function
begin_function
DECL|function|IsSamplerArray
specifier|inline
name|bool
name|IsSamplerArray
parameter_list|(
name|TBasicType
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|EbtSampler2DArray
case|:
case|case
name|EbtISampler2DArray
case|:
case|case
name|EbtUSampler2DArray
case|:
case|case
name|EbtSampler2DArrayShadow
case|:
return|return
name|true
return|;
case|case
name|EbtSampler2D
case|:
case|case
name|EbtISampler2D
case|:
case|case
name|EbtUSampler2D
case|:
case|case
name|EbtSampler2DRect
case|:
case|case
name|EbtSamplerExternalOES
case|:
case|case
name|EbtSampler3D
case|:
case|case
name|EbtISampler3D
case|:
case|case
name|EbtUSampler3D
case|:
case|case
name|EbtISamplerCube
case|:
case|case
name|EbtUSamplerCube
case|:
case|case
name|EbtSamplerCube
case|:
case|case
name|EbtSampler2DShadow
case|:
case|case
name|EbtSamplerCubeShadow
case|:
return|return
name|false
return|;
default|default:
name|assert
argument_list|(
operator|!
name|IsSampler
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function
begin_function
DECL|function|IsShadowSampler
specifier|inline
name|bool
name|IsShadowSampler
parameter_list|(
name|TBasicType
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|EbtSampler2DShadow
case|:
case|case
name|EbtSamplerCubeShadow
case|:
case|case
name|EbtSampler2DArrayShadow
case|:
return|return
name|true
return|;
case|case
name|EbtISampler2D
case|:
case|case
name|EbtISampler3D
case|:
case|case
name|EbtISamplerCube
case|:
case|case
name|EbtISampler2DArray
case|:
case|case
name|EbtUSampler2D
case|:
case|case
name|EbtUSampler3D
case|:
case|case
name|EbtUSamplerCube
case|:
case|case
name|EbtUSampler2DArray
case|:
case|case
name|EbtSampler2D
case|:
case|case
name|EbtSampler3D
case|:
case|case
name|EbtSamplerCube
case|:
case|case
name|EbtSamplerExternalOES
case|:
case|case
name|EbtSampler2DRect
case|:
case|case
name|EbtSampler2DArray
case|:
return|return
name|false
return|;
default|default:
name|assert
argument_list|(
operator|!
name|IsSampler
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function
begin_function
DECL|function|SupportsPrecision
specifier|inline
name|bool
name|SupportsPrecision
parameter_list|(
name|TBasicType
name|type
parameter_list|)
block|{
return|return
name|type
operator|==
name|EbtFloat
operator|||
name|type
operator|==
name|EbtInt
operator|||
name|type
operator|==
name|EbtUInt
operator|||
name|IsSampler
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Qualifiers and built-ins.  These are mainly used to see what can be read
end_comment
begin_comment
comment|// or written, and by the machine dependent translator to know which registers
end_comment
begin_comment
comment|// to allocate variables in.  Since built-ins tend to go to different registers
end_comment
begin_comment
comment|// than varying or uniform, it makes sense they are peers, not sub-classes.
end_comment
begin_comment
comment|//
end_comment
begin_enum
DECL|enum|TQualifier
enum|enum
name|TQualifier
block|{
DECL|enumerator|EvqTemporary
name|EvqTemporary
block|,
comment|// For temporaries (within a function), read/write
DECL|enumerator|EvqGlobal
name|EvqGlobal
block|,
comment|// For globals read/write
DECL|enumerator|EvqInternal
name|EvqInternal
block|,
comment|// For internal use, not visible to the user
DECL|enumerator|EvqConst
name|EvqConst
block|,
comment|// User defined constants and non-output parameters in functions
DECL|enumerator|EvqAttribute
name|EvqAttribute
block|,
comment|// Readonly
DECL|enumerator|EvqVaryingIn
name|EvqVaryingIn
block|,
comment|// readonly, fragment shaders only
DECL|enumerator|EvqVaryingOut
name|EvqVaryingOut
block|,
comment|// vertex shaders only  read/write
DECL|enumerator|EvqInvariantVaryingIn
name|EvqInvariantVaryingIn
block|,
comment|// readonly, fragment shaders only
DECL|enumerator|EvqInvariantVaryingOut
name|EvqInvariantVaryingOut
block|,
comment|// vertex shaders only  read/write
DECL|enumerator|EvqUniform
name|EvqUniform
block|,
comment|// Readonly, vertex and fragment
DECL|enumerator|EvqVertexIn
name|EvqVertexIn
block|,
comment|// Vertex shader input
DECL|enumerator|EvqFragmentOut
name|EvqFragmentOut
block|,
comment|// Fragment shader output
DECL|enumerator|EvqVertexOut
name|EvqVertexOut
block|,
comment|// Vertex shader output
DECL|enumerator|EvqFragmentIn
name|EvqFragmentIn
block|,
comment|// Fragment shader input
comment|// parameters
DECL|enumerator|EvqIn
name|EvqIn
block|,
DECL|enumerator|EvqOut
name|EvqOut
block|,
DECL|enumerator|EvqInOut
name|EvqInOut
block|,
DECL|enumerator|EvqConstReadOnly
name|EvqConstReadOnly
block|,
comment|// built-ins written by vertex shader
DECL|enumerator|EvqPosition
name|EvqPosition
block|,
DECL|enumerator|EvqPointSize
name|EvqPointSize
block|,
comment|// built-ins read by fragment shader
DECL|enumerator|EvqFragCoord
name|EvqFragCoord
block|,
DECL|enumerator|EvqFrontFacing
name|EvqFrontFacing
block|,
DECL|enumerator|EvqPointCoord
name|EvqPointCoord
block|,
comment|// built-ins written by fragment shader
DECL|enumerator|EvqFragColor
name|EvqFragColor
block|,
DECL|enumerator|EvqFragData
name|EvqFragData
block|,
DECL|enumerator|EvqFragDepth
name|EvqFragDepth
block|,
comment|// GLSL ES 3.0 vertex output and fragment input
DECL|enumerator|EvqSmooth
name|EvqSmooth
block|,
comment|// Incomplete qualifier, smooth is the default
DECL|enumerator|EvqFlat
name|EvqFlat
block|,
comment|// Incomplete qualifier
DECL|enumerator|EvqSmoothOut
name|EvqSmoothOut
init|=
name|EvqSmooth
block|,
DECL|enumerator|EvqFlatOut
name|EvqFlatOut
init|=
name|EvqFlat
block|,
DECL|enumerator|EvqCentroidOut
name|EvqCentroidOut
block|,
comment|// Implies smooth
DECL|enumerator|EvqSmoothIn
name|EvqSmoothIn
block|,
DECL|enumerator|EvqFlatIn
name|EvqFlatIn
block|,
DECL|enumerator|EvqCentroidIn
name|EvqCentroidIn
block|,
comment|// Implies smooth
comment|// end of list
DECL|enumerator|EvqLast
name|EvqLast
block|}
enum|;
end_enum
begin_enum
DECL|enum|TLayoutMatrixPacking
enum|enum
name|TLayoutMatrixPacking
block|{
DECL|enumerator|EmpUnspecified
name|EmpUnspecified
block|,
DECL|enumerator|EmpRowMajor
name|EmpRowMajor
block|,
DECL|enumerator|EmpColumnMajor
name|EmpColumnMajor
block|}
enum|;
end_enum
begin_enum
DECL|enum|TLayoutBlockStorage
enum|enum
name|TLayoutBlockStorage
block|{
DECL|enumerator|EbsUnspecified
name|EbsUnspecified
block|,
DECL|enumerator|EbsShared
name|EbsShared
block|,
DECL|enumerator|EbsPacked
name|EbsPacked
block|,
DECL|enumerator|EbsStd140
name|EbsStd140
block|}
enum|;
end_enum
begin_struct
DECL|struct|TLayoutQualifier
struct|struct
name|TLayoutQualifier
block|{
DECL|member|location
name|int
name|location
decl_stmt|;
DECL|member|matrixPacking
name|TLayoutMatrixPacking
name|matrixPacking
decl_stmt|;
DECL|member|blockStorage
name|TLayoutBlockStorage
name|blockStorage
decl_stmt|;
DECL|function|create
specifier|static
name|TLayoutQualifier
name|create
parameter_list|()
block|{
name|TLayoutQualifier
name|layoutQualifier
decl_stmt|;
name|layoutQualifier
operator|.
name|location
operator|=
operator|-
literal|1
expr_stmt|;
name|layoutQualifier
operator|.
name|matrixPacking
operator|=
name|EmpUnspecified
expr_stmt|;
name|layoutQualifier
operator|.
name|blockStorage
operator|=
name|EbsUnspecified
expr_stmt|;
return|return
name|layoutQualifier
return|;
block|}
DECL|function|isEmpty
name|bool
name|isEmpty
argument_list|()
specifier|const
block|{
return|return
name|location
operator|==
operator|-
literal|1
operator|&&
name|matrixPacking
operator|==
name|EmpUnspecified
operator|&&
name|blockStorage
operator|==
name|EbsUnspecified
return|;
block|}
block|}
struct|;
end_struct
begin_comment
comment|//
end_comment
begin_comment
comment|// This is just for debug print out, carried along with the definitions above.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|getQualifierString
specifier|inline
specifier|const
name|char
modifier|*
name|getQualifierString
parameter_list|(
name|TQualifier
name|q
parameter_list|)
block|{
switch|switch
condition|(
name|q
condition|)
block|{
case|case
name|EvqTemporary
case|:
return|return
literal|"Temporary"
return|;
break|break;
case|case
name|EvqGlobal
case|:
return|return
literal|"Global"
return|;
break|break;
case|case
name|EvqConst
case|:
return|return
literal|"const"
return|;
break|break;
case|case
name|EvqConstReadOnly
case|:
return|return
literal|"const"
return|;
break|break;
case|case
name|EvqAttribute
case|:
return|return
literal|"attribute"
return|;
break|break;
case|case
name|EvqVaryingIn
case|:
return|return
literal|"varying"
return|;
break|break;
case|case
name|EvqVaryingOut
case|:
return|return
literal|"varying"
return|;
break|break;
case|case
name|EvqInvariantVaryingIn
case|:
return|return
literal|"invariant varying"
return|;
break|break;
case|case
name|EvqInvariantVaryingOut
case|:
return|return
literal|"invariant varying"
return|;
break|break;
case|case
name|EvqUniform
case|:
return|return
literal|"uniform"
return|;
break|break;
case|case
name|EvqVertexIn
case|:
return|return
literal|"in"
return|;
break|break;
case|case
name|EvqFragmentOut
case|:
return|return
literal|"out"
return|;
break|break;
case|case
name|EvqVertexOut
case|:
return|return
literal|"out"
return|;
break|break;
case|case
name|EvqFragmentIn
case|:
return|return
literal|"in"
return|;
break|break;
case|case
name|EvqIn
case|:
return|return
literal|"in"
return|;
break|break;
case|case
name|EvqOut
case|:
return|return
literal|"out"
return|;
break|break;
case|case
name|EvqInOut
case|:
return|return
literal|"inout"
return|;
break|break;
case|case
name|EvqPosition
case|:
return|return
literal|"Position"
return|;
break|break;
case|case
name|EvqPointSize
case|:
return|return
literal|"PointSize"
return|;
break|break;
case|case
name|EvqFragCoord
case|:
return|return
literal|"FragCoord"
return|;
break|break;
case|case
name|EvqFrontFacing
case|:
return|return
literal|"FrontFacing"
return|;
break|break;
case|case
name|EvqFragColor
case|:
return|return
literal|"FragColor"
return|;
break|break;
case|case
name|EvqFragData
case|:
return|return
literal|"FragData"
return|;
break|break;
case|case
name|EvqFragDepth
case|:
return|return
literal|"FragDepth"
return|;
break|break;
case|case
name|EvqSmoothOut
case|:
return|return
literal|"smooth out"
return|;
break|break;
case|case
name|EvqCentroidOut
case|:
return|return
literal|"centroid out"
return|;
break|break;
case|case
name|EvqFlatOut
case|:
return|return
literal|"flat out"
return|;
break|break;
case|case
name|EvqSmoothIn
case|:
return|return
literal|"smooth in"
return|;
break|break;
case|case
name|EvqCentroidIn
case|:
return|return
literal|"centroid in"
return|;
break|break;
case|case
name|EvqFlatIn
case|:
return|return
literal|"flat in"
return|;
break|break;
default|default:
return|return
literal|"unknown qualifier"
return|;
block|}
block|}
end_function
begin_function
DECL|function|getMatrixPackingString
specifier|inline
specifier|const
name|char
modifier|*
name|getMatrixPackingString
parameter_list|(
name|TLayoutMatrixPacking
name|mpq
parameter_list|)
block|{
switch|switch
condition|(
name|mpq
condition|)
block|{
case|case
name|EmpUnspecified
case|:
return|return
literal|"mp_unspecified"
return|;
case|case
name|EmpRowMajor
case|:
return|return
literal|"row_major"
return|;
case|case
name|EmpColumnMajor
case|:
return|return
literal|"column_major"
return|;
default|default:
return|return
literal|"unknown matrix packing"
return|;
block|}
block|}
end_function
begin_function
DECL|function|getBlockStorageString
specifier|inline
specifier|const
name|char
modifier|*
name|getBlockStorageString
parameter_list|(
name|TLayoutBlockStorage
name|bsq
parameter_list|)
block|{
switch|switch
condition|(
name|bsq
condition|)
block|{
case|case
name|EbsUnspecified
case|:
return|return
literal|"bs_unspecified"
return|;
case|case
name|EbsShared
case|:
return|return
literal|"shared"
return|;
case|case
name|EbsPacked
case|:
return|return
literal|"packed"
return|;
case|case
name|EbsStd140
case|:
return|return
literal|"std140"
return|;
default|default:
return|return
literal|"unknown block storage"
return|;
block|}
block|}
end_function
begin_function
DECL|function|getInterpolationString
specifier|inline
specifier|const
name|char
modifier|*
name|getInterpolationString
parameter_list|(
name|TQualifier
name|q
parameter_list|)
block|{
switch|switch
condition|(
name|q
condition|)
block|{
case|case
name|EvqSmoothOut
case|:
return|return
literal|"smooth"
return|;
break|break;
case|case
name|EvqCentroidOut
case|:
return|return
literal|"centroid"
return|;
break|break;
case|case
name|EvqFlatOut
case|:
return|return
literal|"flat"
return|;
break|break;
case|case
name|EvqSmoothIn
case|:
return|return
literal|"smooth"
return|;
break|break;
case|case
name|EvqCentroidIn
case|:
return|return
literal|"centroid"
return|;
break|break;
case|case
name|EvqFlatIn
case|:
return|return
literal|"flat"
return|;
break|break;
default|default:
return|return
literal|"unknown interpolation"
return|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// _BASICTYPES_INCLUDED_
end_comment
end_unit
