begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|"compiler/translator/OutputGLSLBase.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/compilerdebug.h"
end_include
begin_include
include|#
directive|include
file|<cfloat>
end_include
begin_namespace
namespace|namespace
block|{
DECL|function|arrayBrackets
name|TString
name|arrayBrackets
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|type
operator|.
name|isArray
argument_list|()
argument_list|)
expr_stmt|;
name|TInfoSinkBase
name|out
decl_stmt|;
name|out
operator|<<
literal|"["
operator|<<
name|type
operator|.
name|getArraySize
argument_list|()
operator|<<
literal|"]"
expr_stmt|;
return|return
name|TString
argument_list|(
name|out
operator|.
name|c_str
argument_list|()
argument_list|)
return|;
block|}
DECL|function|isSingleStatement
name|bool
name|isSingleStatement
parameter_list|(
name|TIntermNode
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
specifier|const
name|TIntermAggregate
modifier|*
name|aggregate
init|=
name|node
operator|->
name|getAsAggregate
argument_list|()
condition|)
block|{
return|return
operator|(
name|aggregate
operator|->
name|getOp
argument_list|()
operator|!=
name|EOpFunction
operator|)
operator|&&
operator|(
name|aggregate
operator|->
name|getOp
argument_list|()
operator|!=
name|EOpSequence
operator|)
return|;
block|}
elseif|else
if|if
condition|(
specifier|const
name|TIntermSelection
modifier|*
name|selection
init|=
name|node
operator|->
name|getAsSelectionNode
argument_list|()
condition|)
block|{
comment|// Ternary operators are usually part of an assignment operator.
comment|// This handles those rare cases in which they are all by themselves.
return|return
name|selection
operator|->
name|usesTernaryOperator
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|getAsLoopNode
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|getAsSwitchNode
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|getAsCaseNode
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
block|}
end_namespace
begin_comment
comment|// namespace
end_comment
begin_constructor
DECL|function|TOutputGLSLBase
name|TOutputGLSLBase
operator|::
name|TOutputGLSLBase
parameter_list|(
name|TInfoSinkBase
modifier|&
name|objSink
parameter_list|,
name|ShArrayIndexClampingStrategy
name|clampingStrategy
parameter_list|,
name|ShHashFunction64
name|hashFunction
parameter_list|,
name|NameMap
modifier|&
name|nameMap
parameter_list|,
name|TSymbolTable
modifier|&
name|symbolTable
parameter_list|,
name|int
name|shaderVersion
parameter_list|,
name|ShShaderOutput
name|output
parameter_list|)
member_init_list|:
name|TIntermTraverser
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
member_init_list|,
name|mObjSink
argument_list|(
name|objSink
argument_list|)
member_init_list|,
name|mDeclaringVariables
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mClampingStrategy
argument_list|(
name|clampingStrategy
argument_list|)
member_init_list|,
name|mHashFunction
argument_list|(
name|hashFunction
argument_list|)
member_init_list|,
name|mNameMap
argument_list|(
name|nameMap
argument_list|)
member_init_list|,
name|mSymbolTable
argument_list|(
name|symbolTable
argument_list|)
member_init_list|,
name|mShaderVersion
argument_list|(
name|shaderVersion
argument_list|)
member_init_list|,
name|mOutput
argument_list|(
name|output
argument_list|)
block|{ }
end_constructor
begin_function
DECL|function|writeTriplet
name|void
name|TOutputGLSLBase
operator|::
name|writeTriplet
parameter_list|(
name|Visit
name|visit
parameter_list|,
specifier|const
name|char
modifier|*
name|preStr
parameter_list|,
specifier|const
name|char
modifier|*
name|inStr
parameter_list|,
specifier|const
name|char
modifier|*
name|postStr
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|objSink
argument_list|()
decl_stmt|;
if|if
condition|(
name|visit
operator|==
name|PreVisit
operator|&&
name|preStr
condition|)
name|out
operator|<<
name|preStr
expr_stmt|;
elseif|else
if|if
condition|(
name|visit
operator|==
name|InVisit
operator|&&
name|inStr
condition|)
name|out
operator|<<
name|inStr
expr_stmt|;
elseif|else
if|if
condition|(
name|visit
operator|==
name|PostVisit
operator|&&
name|postStr
condition|)
name|out
operator|<<
name|postStr
expr_stmt|;
block|}
end_function
begin_function
DECL|function|writeBuiltInFunctionTriplet
name|void
name|TOutputGLSLBase
operator|::
name|writeBuiltInFunctionTriplet
parameter_list|(
name|Visit
name|visit
parameter_list|,
specifier|const
name|char
modifier|*
name|preStr
parameter_list|,
name|bool
name|useEmulatedFunction
parameter_list|)
block|{
name|TString
name|preString
init|=
name|useEmulatedFunction
condition|?
name|BuiltInFunctionEmulator
operator|::
name|GetEmulatedFunctionName
argument_list|(
name|preStr
argument_list|)
else|:
name|preStr
decl_stmt|;
name|writeTriplet
argument_list|(
name|visit
argument_list|,
name|preString
operator|.
name|c_str
argument_list|()
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|writeVariableType
name|void
name|TOutputGLSLBase
operator|::
name|writeVariableType
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|objSink
argument_list|()
decl_stmt|;
name|TQualifier
name|qualifier
init|=
name|type
operator|.
name|getQualifier
argument_list|()
decl_stmt|;
if|if
condition|(
name|qualifier
operator|!=
name|EvqTemporary
operator|&&
name|qualifier
operator|!=
name|EvqGlobal
condition|)
block|{
if|if
condition|(
name|mOutput
operator|==
name|SH_GLSL_CORE_OUTPUT
condition|)
block|{
switch|switch
condition|(
name|qualifier
condition|)
block|{
case|case
name|EvqAttribute
case|:
name|out
operator|<<
literal|"in"
operator|<<
literal|" "
expr_stmt|;
break|break;
case|case
name|EvqVaryingIn
case|:
name|out
operator|<<
literal|"in"
operator|<<
literal|" "
expr_stmt|;
break|break;
case|case
name|EvqVaryingOut
case|:
name|out
operator|<<
literal|"out"
operator|<<
literal|" "
expr_stmt|;
break|break;
case|case
name|EvqInvariantVaryingIn
case|:
name|out
operator|<<
literal|"invariant in"
operator|<<
literal|" "
expr_stmt|;
break|break;
case|case
name|EvqInvariantVaryingOut
case|:
name|out
operator|<<
literal|"invariant out"
operator|<<
literal|" "
expr_stmt|;
break|break;
default|default:
name|out
operator|<<
name|type
operator|.
name|getQualifierString
argument_list|()
operator|<<
literal|" "
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|out
operator|<<
name|type
operator|.
name|getQualifierString
argument_list|()
operator|<<
literal|" "
expr_stmt|;
block|}
block|}
comment|// Declare the struct if we have not done so already.
if|if
condition|(
name|type
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtStruct
operator|&&
operator|!
name|structDeclared
argument_list|(
name|type
operator|.
name|getStruct
argument_list|()
argument_list|)
condition|)
block|{
name|TStructure
modifier|*
name|structure
init|=
name|type
operator|.
name|getStruct
argument_list|()
decl_stmt|;
name|declareStruct
argument_list|(
name|structure
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|structure
operator|->
name|name
argument_list|()
operator|.
name|empty
argument_list|()
condition|)
block|{
name|mDeclaredStructs
operator|.
name|insert
argument_list|(
name|structure
operator|->
name|uniqueId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|writeVariablePrecision
argument_list|(
name|type
operator|.
name|getPrecision
argument_list|()
argument_list|)
condition|)
name|out
operator|<<
literal|" "
expr_stmt|;
name|out
operator|<<
name|getTypeName
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|writeFunctionParameters
name|void
name|TOutputGLSLBase
operator|::
name|writeFunctionParameters
parameter_list|(
specifier|const
name|TIntermSequence
modifier|&
name|args
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|objSink
argument_list|()
decl_stmt|;
for|for
control|(
name|TIntermSequence
operator|::
name|const_iterator
name|iter
init|=
name|args
operator|.
name|begin
argument_list|()
init|;
name|iter
operator|!=
name|args
operator|.
name|end
argument_list|()
condition|;
operator|++
name|iter
control|)
block|{
specifier|const
name|TIntermSymbol
modifier|*
name|arg
init|=
operator|(
operator|*
name|iter
operator|)
operator|->
name|getAsSymbolNode
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|arg
operator|!=
name|NULL
argument_list|)
expr_stmt|;
specifier|const
name|TType
modifier|&
name|type
init|=
name|arg
operator|->
name|getType
argument_list|()
decl_stmt|;
name|writeVariableType
argument_list|(
name|type
argument_list|)
expr_stmt|;
specifier|const
name|TString
modifier|&
name|name
init|=
name|arg
operator|->
name|getSymbol
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|name
operator|.
name|empty
argument_list|()
condition|)
name|out
operator|<<
literal|" "
operator|<<
name|hashName
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|.
name|isArray
argument_list|()
condition|)
name|out
operator|<<
name|arrayBrackets
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|// Put a comma if this is not the last argument.
if|if
condition|(
name|iter
operator|!=
name|args
operator|.
name|end
argument_list|()
operator|-
literal|1
condition|)
name|out
operator|<<
literal|", "
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|writeConstantUnion
specifier|const
name|ConstantUnion
modifier|*
name|TOutputGLSLBase
operator|::
name|writeConstantUnion
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|,
specifier|const
name|ConstantUnion
modifier|*
name|pConstUnion
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|objSink
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtStruct
condition|)
block|{
specifier|const
name|TStructure
modifier|*
name|structure
init|=
name|type
operator|.
name|getStruct
argument_list|()
decl_stmt|;
name|out
operator|<<
name|hashName
argument_list|(
name|structure
operator|->
name|name
argument_list|()
argument_list|)
operator|<<
literal|"("
expr_stmt|;
specifier|const
name|TFieldList
modifier|&
name|fields
init|=
name|structure
operator|->
name|fields
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|TType
modifier|*
name|fieldType
init|=
name|fields
index|[
name|i
index|]
operator|->
name|type
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|fieldType
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|pConstUnion
operator|=
name|writeConstantUnion
argument_list|(
operator|*
name|fieldType
argument_list|,
name|pConstUnion
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|fields
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
name|out
operator|<<
literal|", "
expr_stmt|;
block|}
name|out
operator|<<
literal|")"
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|size
init|=
name|type
operator|.
name|getObjectSize
argument_list|()
decl_stmt|;
name|bool
name|writeType
init|=
name|size
operator|>
literal|1
decl_stmt|;
if|if
condition|(
name|writeType
condition|)
name|out
operator|<<
name|getTypeName
argument_list|(
name|type
argument_list|)
operator|<<
literal|"("
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
operator|,
operator|++
name|pConstUnion
control|)
block|{
switch|switch
condition|(
name|pConstUnion
operator|->
name|getType
argument_list|()
condition|)
block|{
case|case
name|EbtFloat
case|:
name|out
operator|<<
name|std
operator|::
name|min
argument_list|(
name|FLT_MAX
argument_list|,
name|std
operator|::
name|max
argument_list|(
operator|-
name|FLT_MAX
argument_list|,
name|pConstUnion
operator|->
name|getFConst
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EbtInt
case|:
name|out
operator|<<
name|pConstUnion
operator|->
name|getIConst
argument_list|()
expr_stmt|;
break|break;
case|case
name|EbtUInt
case|:
name|out
operator|<<
name|pConstUnion
operator|->
name|getUConst
argument_list|()
operator|<<
literal|"u"
expr_stmt|;
break|break;
case|case
name|EbtBool
case|:
name|out
operator|<<
name|pConstUnion
operator|->
name|getBConst
argument_list|()
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
name|size
operator|-
literal|1
condition|)
name|out
operator|<<
literal|", "
expr_stmt|;
block|}
if|if
condition|(
name|writeType
condition|)
name|out
operator|<<
literal|")"
expr_stmt|;
block|}
return|return
name|pConstUnion
return|;
block|}
end_function
begin_function
DECL|function|visitSymbol
name|void
name|TOutputGLSLBase
operator|::
name|visitSymbol
parameter_list|(
name|TIntermSymbol
modifier|*
name|node
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|objSink
argument_list|()
decl_stmt|;
if|if
condition|(
name|mLoopUnrollStack
operator|.
name|needsToReplaceSymbolWithValue
argument_list|(
name|node
argument_list|)
condition|)
name|out
operator|<<
name|mLoopUnrollStack
operator|.
name|getLoopIndexValue
argument_list|(
name|node
argument_list|)
expr_stmt|;
else|else
name|out
operator|<<
name|hashVariableName
argument_list|(
name|node
operator|->
name|getSymbol
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|mDeclaringVariables
operator|&&
name|node
operator|->
name|getType
argument_list|()
operator|.
name|isArray
argument_list|()
condition|)
name|out
operator|<<
name|arrayBrackets
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|visitConstantUnion
name|void
name|TOutputGLSLBase
operator|::
name|visitConstantUnion
parameter_list|(
name|TIntermConstantUnion
modifier|*
name|node
parameter_list|)
block|{
name|writeConstantUnion
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|,
name|node
operator|->
name|getUnionArrayPointer
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|visitBinary
name|bool
name|TOutputGLSLBase
operator|::
name|visitBinary
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermBinary
modifier|*
name|node
parameter_list|)
block|{
name|bool
name|visitChildren
init|=
literal|true
decl_stmt|;
name|TInfoSinkBase
modifier|&
name|out
init|=
name|objSink
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|getOp
argument_list|()
condition|)
block|{
case|case
name|EOpInitialize
case|:
if|if
condition|(
name|visit
operator|==
name|InVisit
condition|)
block|{
name|out
operator|<<
literal|" = "
expr_stmt|;
comment|// RHS of initialize is not being declared.
name|mDeclaringVariables
operator|=
literal|false
expr_stmt|;
block|}
break|break;
case|case
name|EOpAssign
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" = "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpAddAssign
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" += "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpSubAssign
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" -= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpDivAssign
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" /= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpIModAssign
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" %= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
comment|// Notice the fall-through.
case|case
name|EOpMulAssign
case|:
case|case
name|EOpVectorTimesMatrixAssign
case|:
case|case
name|EOpVectorTimesScalarAssign
case|:
case|case
name|EOpMatrixTimesScalarAssign
case|:
case|case
name|EOpMatrixTimesMatrixAssign
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" *= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpBitShiftLeftAssign
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|"<<= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpBitShiftRightAssign
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|">>= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpBitwiseAndAssign
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|"&= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpBitwiseXorAssign
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" ^= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpBitwiseOrAssign
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" |= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpIndexDirect
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
name|NULL
argument_list|,
literal|"["
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpIndexIndirect
case|:
if|if
condition|(
name|node
operator|->
name|getAddIndexClamp
argument_list|()
condition|)
block|{
if|if
condition|(
name|visit
operator|==
name|InVisit
condition|)
block|{
if|if
condition|(
name|mClampingStrategy
operator|==
name|SH_CLAMP_WITH_CLAMP_INTRINSIC
condition|)
name|out
operator|<<
literal|"[int(clamp(float("
expr_stmt|;
else|else
name|out
operator|<<
literal|"[webgl_int_clamp("
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|visit
operator|==
name|PostVisit
condition|)
block|{
name|int
name|maxSize
decl_stmt|;
name|TIntermTyped
modifier|*
name|left
init|=
name|node
operator|->
name|getLeft
argument_list|()
decl_stmt|;
name|TType
name|leftType
init|=
name|left
operator|->
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|left
operator|->
name|isArray
argument_list|()
condition|)
block|{
comment|// The shader will fail validation if the array length is not> 0.
name|maxSize
operator|=
name|leftType
operator|.
name|getArraySize
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|maxSize
operator|=
name|leftType
operator|.
name|getNominalSize
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mClampingStrategy
operator|==
name|SH_CLAMP_WITH_CLAMP_INTRINSIC
condition|)
name|out
operator|<<
literal|"), 0.0, float("
operator|<<
name|maxSize
operator|<<
literal|")))]"
expr_stmt|;
else|else
name|out
operator|<<
literal|", 0, "
operator|<<
name|maxSize
operator|<<
literal|")]"
expr_stmt|;
block|}
block|}
else|else
block|{
name|writeTriplet
argument_list|(
name|visit
argument_list|,
name|NULL
argument_list|,
literal|"["
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EOpIndexDirectStruct
case|:
if|if
condition|(
name|visit
operator|==
name|InVisit
condition|)
block|{
comment|// Here we are writing out "foo.bar", where "foo" is struct
comment|// and "bar" is field. In AST, it is represented as a binary
comment|// node, where left child represents "foo" and right child "bar".
comment|// The node itself represents ".". The struct field "bar" is
comment|// actually stored as an index into TStructure::fields.
name|out
operator|<<
literal|"."
expr_stmt|;
specifier|const
name|TStructure
modifier|*
name|structure
init|=
name|node
operator|->
name|getLeft
argument_list|()
operator|->
name|getType
argument_list|()
operator|.
name|getStruct
argument_list|()
decl_stmt|;
specifier|const
name|TIntermConstantUnion
modifier|*
name|index
init|=
name|node
operator|->
name|getRight
argument_list|()
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
specifier|const
name|TField
modifier|*
name|field
init|=
name|structure
operator|->
name|fields
argument_list|()
index|[
name|index
operator|->
name|getIConst
argument_list|(
literal|0
argument_list|)
index|]
decl_stmt|;
name|TString
name|fieldName
init|=
name|field
operator|->
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|mSymbolTable
operator|.
name|findBuiltIn
argument_list|(
name|structure
operator|->
name|name
argument_list|()
argument_list|,
name|mShaderVersion
argument_list|)
condition|)
name|fieldName
operator|=
name|hashName
argument_list|(
name|fieldName
argument_list|)
expr_stmt|;
name|out
operator|<<
name|fieldName
expr_stmt|;
name|visitChildren
operator|=
literal|false
expr_stmt|;
block|}
break|break;
case|case
name|EOpVectorSwizzle
case|:
if|if
condition|(
name|visit
operator|==
name|InVisit
condition|)
block|{
name|out
operator|<<
literal|"."
expr_stmt|;
name|TIntermAggregate
modifier|*
name|rightChild
init|=
name|node
operator|->
name|getRight
argument_list|()
operator|->
name|getAsAggregate
argument_list|()
decl_stmt|;
name|TIntermSequence
modifier|*
name|sequence
init|=
name|rightChild
operator|->
name|getSequence
argument_list|()
decl_stmt|;
for|for
control|(
name|TIntermSequence
operator|::
name|iterator
name|sit
init|=
name|sequence
operator|->
name|begin
argument_list|()
init|;
name|sit
operator|!=
name|sequence
operator|->
name|end
argument_list|()
condition|;
operator|++
name|sit
control|)
block|{
name|TIntermConstantUnion
modifier|*
name|element
init|=
operator|(
operator|*
name|sit
operator|)
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|element
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtInt
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|element
operator|->
name|getNominalSize
argument_list|()
operator|==
literal|1
argument_list|)
expr_stmt|;
specifier|const
name|ConstantUnion
modifier|&
name|data
init|=
name|element
operator|->
name|getUnionArrayPointer
argument_list|()
index|[
literal|0
index|]
decl_stmt|;
name|ASSERT
argument_list|(
name|data
operator|.
name|getType
argument_list|()
operator|==
name|EbtInt
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|data
operator|.
name|getIConst
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
name|out
operator|<<
literal|"x"
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|out
operator|<<
literal|"y"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|out
operator|<<
literal|"z"
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|out
operator|<<
literal|"w"
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
name|visitChildren
operator|=
literal|false
expr_stmt|;
block|}
break|break;
case|case
name|EOpAdd
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" + "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpSub
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" - "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpMul
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" * "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpDiv
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" / "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpIMod
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" % "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpBitShiftLeft
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|"<< "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpBitShiftRight
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|">> "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpBitwiseAnd
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|"& "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpBitwiseXor
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" ^ "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpBitwiseOr
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" | "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpEqual
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" == "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpNotEqual
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" != "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpLessThan
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|"< "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpGreaterThan
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|"> "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpLessThanEqual
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|"<= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpGreaterThanEqual
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|">= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
comment|// Notice the fall-through.
case|case
name|EOpVectorTimesScalar
case|:
case|case
name|EOpVectorTimesMatrix
case|:
case|case
name|EOpMatrixTimesVector
case|:
case|case
name|EOpMatrixTimesScalar
case|:
case|case
name|EOpMatrixTimesMatrix
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" * "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpLogicalOr
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" || "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpLogicalXor
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" ^^ "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpLogicalAnd
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|"&& "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
name|visitChildren
return|;
block|}
end_function
begin_function
DECL|function|visitUnary
name|bool
name|TOutputGLSLBase
operator|::
name|visitUnary
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermUnary
modifier|*
name|node
parameter_list|)
block|{
name|TString
name|preString
decl_stmt|;
name|TString
name|postString
init|=
literal|")"
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|getOp
argument_list|()
condition|)
block|{
case|case
name|EOpNegative
case|:
name|preString
operator|=
literal|"(-"
expr_stmt|;
break|break;
case|case
name|EOpPositive
case|:
name|preString
operator|=
literal|"(+"
expr_stmt|;
break|break;
case|case
name|EOpVectorLogicalNot
case|:
name|preString
operator|=
literal|"not("
expr_stmt|;
break|break;
case|case
name|EOpLogicalNot
case|:
name|preString
operator|=
literal|"(!"
expr_stmt|;
break|break;
case|case
name|EOpBitwiseNot
case|:
name|preString
operator|=
literal|"(~"
expr_stmt|;
break|break;
case|case
name|EOpPostIncrement
case|:
name|preString
operator|=
literal|"("
expr_stmt|;
name|postString
operator|=
literal|"++)"
expr_stmt|;
break|break;
case|case
name|EOpPostDecrement
case|:
name|preString
operator|=
literal|"("
expr_stmt|;
name|postString
operator|=
literal|"--)"
expr_stmt|;
break|break;
case|case
name|EOpPreIncrement
case|:
name|preString
operator|=
literal|"(++"
expr_stmt|;
break|break;
case|case
name|EOpPreDecrement
case|:
name|preString
operator|=
literal|"(--"
expr_stmt|;
break|break;
case|case
name|EOpRadians
case|:
name|preString
operator|=
literal|"radians("
expr_stmt|;
break|break;
case|case
name|EOpDegrees
case|:
name|preString
operator|=
literal|"degrees("
expr_stmt|;
break|break;
case|case
name|EOpSin
case|:
name|preString
operator|=
literal|"sin("
expr_stmt|;
break|break;
case|case
name|EOpCos
case|:
name|preString
operator|=
literal|"cos("
expr_stmt|;
break|break;
case|case
name|EOpTan
case|:
name|preString
operator|=
literal|"tan("
expr_stmt|;
break|break;
case|case
name|EOpAsin
case|:
name|preString
operator|=
literal|"asin("
expr_stmt|;
break|break;
case|case
name|EOpAcos
case|:
name|preString
operator|=
literal|"acos("
expr_stmt|;
break|break;
case|case
name|EOpAtan
case|:
name|preString
operator|=
literal|"atan("
expr_stmt|;
break|break;
case|case
name|EOpSinh
case|:
name|preString
operator|=
literal|"sinh("
expr_stmt|;
break|break;
case|case
name|EOpCosh
case|:
name|preString
operator|=
literal|"cosh("
expr_stmt|;
break|break;
case|case
name|EOpTanh
case|:
name|preString
operator|=
literal|"tanh("
expr_stmt|;
break|break;
case|case
name|EOpAsinh
case|:
name|preString
operator|=
literal|"asinh("
expr_stmt|;
break|break;
case|case
name|EOpAcosh
case|:
name|preString
operator|=
literal|"acosh("
expr_stmt|;
break|break;
case|case
name|EOpAtanh
case|:
name|preString
operator|=
literal|"atanh("
expr_stmt|;
break|break;
case|case
name|EOpExp
case|:
name|preString
operator|=
literal|"exp("
expr_stmt|;
break|break;
case|case
name|EOpLog
case|:
name|preString
operator|=
literal|"log("
expr_stmt|;
break|break;
case|case
name|EOpExp2
case|:
name|preString
operator|=
literal|"exp2("
expr_stmt|;
break|break;
case|case
name|EOpLog2
case|:
name|preString
operator|=
literal|"log2("
expr_stmt|;
break|break;
case|case
name|EOpSqrt
case|:
name|preString
operator|=
literal|"sqrt("
expr_stmt|;
break|break;
case|case
name|EOpInverseSqrt
case|:
name|preString
operator|=
literal|"inversesqrt("
expr_stmt|;
break|break;
case|case
name|EOpAbs
case|:
name|preString
operator|=
literal|"abs("
expr_stmt|;
break|break;
case|case
name|EOpSign
case|:
name|preString
operator|=
literal|"sign("
expr_stmt|;
break|break;
case|case
name|EOpFloor
case|:
name|preString
operator|=
literal|"floor("
expr_stmt|;
break|break;
case|case
name|EOpTrunc
case|:
name|preString
operator|=
literal|"trunc("
expr_stmt|;
break|break;
case|case
name|EOpRound
case|:
name|preString
operator|=
literal|"round("
expr_stmt|;
break|break;
case|case
name|EOpRoundEven
case|:
name|preString
operator|=
literal|"roundEven("
expr_stmt|;
break|break;
case|case
name|EOpCeil
case|:
name|preString
operator|=
literal|"ceil("
expr_stmt|;
break|break;
case|case
name|EOpFract
case|:
name|preString
operator|=
literal|"fract("
expr_stmt|;
break|break;
case|case
name|EOpIsNan
case|:
name|preString
operator|=
literal|"isnan("
expr_stmt|;
break|break;
case|case
name|EOpIsInf
case|:
name|preString
operator|=
literal|"isinf("
expr_stmt|;
break|break;
case|case
name|EOpFloatBitsToInt
case|:
name|preString
operator|=
literal|"floatBitsToInt("
expr_stmt|;
break|break;
case|case
name|EOpFloatBitsToUint
case|:
name|preString
operator|=
literal|"floatBitsToUint("
expr_stmt|;
break|break;
case|case
name|EOpIntBitsToFloat
case|:
name|preString
operator|=
literal|"intBitsToFloat("
expr_stmt|;
break|break;
case|case
name|EOpUintBitsToFloat
case|:
name|preString
operator|=
literal|"uintBitsToFloat("
expr_stmt|;
break|break;
case|case
name|EOpPackSnorm2x16
case|:
name|preString
operator|=
literal|"packSnorm2x16("
expr_stmt|;
break|break;
case|case
name|EOpPackUnorm2x16
case|:
name|preString
operator|=
literal|"packUnorm2x16("
expr_stmt|;
break|break;
case|case
name|EOpPackHalf2x16
case|:
name|preString
operator|=
literal|"packHalf2x16("
expr_stmt|;
break|break;
case|case
name|EOpUnpackSnorm2x16
case|:
name|preString
operator|=
literal|"unpackSnorm2x16("
expr_stmt|;
break|break;
case|case
name|EOpUnpackUnorm2x16
case|:
name|preString
operator|=
literal|"unpackUnorm2x16("
expr_stmt|;
break|break;
case|case
name|EOpUnpackHalf2x16
case|:
name|preString
operator|=
literal|"unpackHalf2x16("
expr_stmt|;
break|break;
case|case
name|EOpLength
case|:
name|preString
operator|=
literal|"length("
expr_stmt|;
break|break;
case|case
name|EOpNormalize
case|:
name|preString
operator|=
literal|"normalize("
expr_stmt|;
break|break;
case|case
name|EOpDFdx
case|:
name|preString
operator|=
literal|"dFdx("
expr_stmt|;
break|break;
case|case
name|EOpDFdy
case|:
name|preString
operator|=
literal|"dFdy("
expr_stmt|;
break|break;
case|case
name|EOpFwidth
case|:
name|preString
operator|=
literal|"fwidth("
expr_stmt|;
break|break;
case|case
name|EOpTranspose
case|:
name|preString
operator|=
literal|"transpose("
expr_stmt|;
break|break;
case|case
name|EOpDeterminant
case|:
name|preString
operator|=
literal|"determinant("
expr_stmt|;
break|break;
case|case
name|EOpInverse
case|:
name|preString
operator|=
literal|"inverse("
expr_stmt|;
break|break;
case|case
name|EOpAny
case|:
name|preString
operator|=
literal|"any("
expr_stmt|;
break|break;
case|case
name|EOpAll
case|:
name|preString
operator|=
literal|"all("
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|visit
operator|==
name|PreVisit
operator|&&
name|node
operator|->
name|getUseEmulatedFunction
argument_list|()
condition|)
name|preString
operator|=
name|BuiltInFunctionEmulator
operator|::
name|GetEmulatedFunctionName
argument_list|(
name|preString
argument_list|)
expr_stmt|;
name|writeTriplet
argument_list|(
name|visit
argument_list|,
name|preString
operator|.
name|c_str
argument_list|()
argument_list|,
name|NULL
argument_list|,
name|postString
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|visitSelection
name|bool
name|TOutputGLSLBase
operator|::
name|visitSelection
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermSelection
modifier|*
name|node
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|objSink
argument_list|()
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|usesTernaryOperator
argument_list|()
condition|)
block|{
comment|// Notice two brackets at the beginning and end. The outer ones
comment|// encapsulate the whole ternary expression. This preserves the
comment|// order of precedence when ternary expressions are used in a
comment|// compound expression, i.e., c = 2 * (a< b ? 1 : 2).
name|out
operator|<<
literal|"(("
expr_stmt|;
name|node
operator|->
name|getCondition
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|") ? ("
expr_stmt|;
name|node
operator|->
name|getTrueBlock
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|") : ("
expr_stmt|;
name|node
operator|->
name|getFalseBlock
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"))"
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
literal|"if ("
expr_stmt|;
name|node
operator|->
name|getCondition
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|")\n"
expr_stmt|;
name|incrementDepth
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|visitCodeBlock
argument_list|(
name|node
operator|->
name|getTrueBlock
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getFalseBlock
argument_list|()
condition|)
block|{
name|out
operator|<<
literal|"else\n"
expr_stmt|;
name|visitCodeBlock
argument_list|(
name|node
operator|->
name|getFalseBlock
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|decrementDepth
argument_list|()
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|visitSwitch
name|bool
name|TOutputGLSLBase
operator|::
name|visitSwitch
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermSwitch
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|->
name|getStatementList
argument_list|()
condition|)
block|{
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"switch ("
argument_list|,
literal|") "
argument_list|,
literal|nullptr
argument_list|)
expr_stmt|;
comment|// The curly braces get written when visiting the statementList aggregate
block|}
else|else
block|{
comment|// No statementList, so it won't output curly braces
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"switch ("
argument_list|,
literal|") {"
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|visitCase
name|bool
name|TOutputGLSLBase
operator|::
name|visitCase
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermCase
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|->
name|hasCondition
argument_list|()
condition|)
block|{
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"case ("
argument_list|,
literal|nullptr
argument_list|,
literal|"):\n"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|objSink
argument_list|()
decl_stmt|;
name|out
operator|<<
literal|"default:\n"
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
end_function
begin_function
DECL|function|visitAggregate
name|bool
name|TOutputGLSLBase
operator|::
name|visitAggregate
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermAggregate
modifier|*
name|node
parameter_list|)
block|{
name|bool
name|visitChildren
init|=
literal|true
decl_stmt|;
name|TInfoSinkBase
modifier|&
name|out
init|=
name|objSink
argument_list|()
decl_stmt|;
name|TString
name|preString
decl_stmt|;
name|bool
name|useEmulatedFunction
init|=
operator|(
name|visit
operator|==
name|PreVisit
operator|&&
name|node
operator|->
name|getUseEmulatedFunction
argument_list|()
operator|)
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|getOp
argument_list|()
condition|)
block|{
case|case
name|EOpSequence
case|:
comment|// Scope the sequences except when at the global scope.
if|if
condition|(
name|mDepth
operator|>
literal|0
condition|)
block|{
name|out
operator|<<
literal|"{\n"
expr_stmt|;
block|}
name|incrementDepth
argument_list|(
name|node
argument_list|)
expr_stmt|;
for|for
control|(
name|TIntermSequence
operator|::
name|const_iterator
name|iter
init|=
name|node
operator|->
name|getSequence
argument_list|()
operator|->
name|begin
argument_list|()
init|;
name|iter
operator|!=
name|node
operator|->
name|getSequence
argument_list|()
operator|->
name|end
argument_list|()
condition|;
operator|++
name|iter
control|)
block|{
name|TIntermNode
modifier|*
name|curNode
init|=
operator|*
name|iter
decl_stmt|;
name|ASSERT
argument_list|(
name|curNode
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|curNode
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|isSingleStatement
argument_list|(
name|curNode
argument_list|)
condition|)
name|out
operator|<<
literal|";\n"
expr_stmt|;
block|}
name|decrementDepth
argument_list|()
expr_stmt|;
comment|// Scope the sequences except when at the global scope.
if|if
condition|(
name|mDepth
operator|>
literal|0
condition|)
block|{
name|out
operator|<<
literal|"}\n"
expr_stmt|;
block|}
name|visitChildren
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|EOpPrototype
case|:
comment|// Function declaration.
name|ASSERT
argument_list|(
name|visit
operator|==
name|PreVisit
argument_list|)
expr_stmt|;
name|writeVariableType
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|" "
operator|<<
name|hashFunctionName
argument_list|(
name|node
operator|->
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"("
expr_stmt|;
name|writeFunctionParameters
argument_list|(
operator|*
operator|(
name|node
operator|->
name|getSequence
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|")"
expr_stmt|;
name|visitChildren
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|EOpFunction
case|:
block|{
comment|// Function definition.
name|ASSERT
argument_list|(
name|visit
operator|==
name|PreVisit
argument_list|)
expr_stmt|;
name|writeVariableType
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|" "
operator|<<
name|hashFunctionName
argument_list|(
name|node
operator|->
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|incrementDepth
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|// Function definition node contains one or two children nodes
comment|// representing function parameters and function body. The latter
comment|// is not present in case of empty function bodies.
specifier|const
name|TIntermSequence
modifier|&
name|sequence
init|=
operator|*
operator|(
name|node
operator|->
name|getSequence
argument_list|()
operator|)
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
name|sequence
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|)
operator|||
operator|(
name|sequence
operator|.
name|size
argument_list|()
operator|==
literal|2
operator|)
argument_list|)
expr_stmt|;
name|TIntermSequence
operator|::
name|const_iterator
name|seqIter
init|=
name|sequence
operator|.
name|begin
argument_list|()
decl_stmt|;
comment|// Traverse function parameters.
name|TIntermAggregate
modifier|*
name|params
init|=
operator|(
operator|*
name|seqIter
operator|)
operator|->
name|getAsAggregate
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|params
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|params
operator|->
name|getOp
argument_list|()
operator|==
name|EOpParameters
argument_list|)
expr_stmt|;
name|params
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Traverse function body.
name|TIntermAggregate
modifier|*
name|body
init|=
operator|++
name|seqIter
operator|!=
name|sequence
operator|.
name|end
argument_list|()
condition|?
operator|(
operator|*
name|seqIter
operator|)
operator|->
name|getAsAggregate
argument_list|()
else|:
name|NULL
decl_stmt|;
name|visitCodeBlock
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|decrementDepth
argument_list|()
expr_stmt|;
comment|// Fully processed; no need to visit children.
name|visitChildren
operator|=
literal|false
expr_stmt|;
break|break;
block|}
case|case
name|EOpFunctionCall
case|:
comment|// Function call.
if|if
condition|(
name|visit
operator|==
name|PreVisit
condition|)
name|out
operator|<<
name|hashFunctionName
argument_list|(
name|node
operator|->
name|getName
argument_list|()
argument_list|)
operator|<<
literal|"("
expr_stmt|;
elseif|else
if|if
condition|(
name|visit
operator|==
name|InVisit
condition|)
name|out
operator|<<
literal|", "
expr_stmt|;
else|else
name|out
operator|<<
literal|")"
expr_stmt|;
break|break;
case|case
name|EOpInternalFunctionCall
case|:
comment|// Function call to an internal helper function.
if|if
condition|(
name|visit
operator|==
name|PreVisit
condition|)
name|out
operator|<<
name|node
operator|->
name|getName
argument_list|()
operator|<<
literal|"("
expr_stmt|;
elseif|else
if|if
condition|(
name|visit
operator|==
name|InVisit
condition|)
name|out
operator|<<
literal|", "
expr_stmt|;
else|else
name|out
operator|<<
literal|")"
expr_stmt|;
break|break;
case|case
name|EOpParameters
case|:
comment|// Function parameters.
name|ASSERT
argument_list|(
name|visit
operator|==
name|PreVisit
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"("
expr_stmt|;
name|writeFunctionParameters
argument_list|(
operator|*
operator|(
name|node
operator|->
name|getSequence
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|")"
expr_stmt|;
name|visitChildren
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|EOpDeclaration
case|:
comment|// Variable declaration.
if|if
condition|(
name|visit
operator|==
name|PreVisit
condition|)
block|{
specifier|const
name|TIntermSequence
modifier|&
name|sequence
init|=
operator|*
operator|(
name|node
operator|->
name|getSequence
argument_list|()
operator|)
decl_stmt|;
specifier|const
name|TIntermTyped
modifier|*
name|variable
init|=
name|sequence
operator|.
name|front
argument_list|()
operator|->
name|getAsTyped
argument_list|()
decl_stmt|;
name|writeVariableType
argument_list|(
name|variable
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|" "
expr_stmt|;
name|mDeclaringVariables
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|visit
operator|==
name|InVisit
condition|)
block|{
name|out
operator|<<
literal|", "
expr_stmt|;
name|mDeclaringVariables
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|mDeclaringVariables
operator|=
literal|false
expr_stmt|;
block|}
break|break;
case|case
name|EOpInvariantDeclaration
case|:
comment|// Invariant declaration.
name|ASSERT
argument_list|(
name|visit
operator|==
name|PreVisit
argument_list|)
expr_stmt|;
block|{
specifier|const
name|TIntermSequence
modifier|*
name|sequence
init|=
name|node
operator|->
name|getSequence
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|sequence
operator|&&
name|sequence
operator|->
name|size
argument_list|()
operator|==
literal|1
argument_list|)
expr_stmt|;
specifier|const
name|TIntermSymbol
modifier|*
name|symbol
init|=
name|sequence
operator|->
name|front
argument_list|()
operator|->
name|getAsSymbolNode
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"invariant "
operator|<<
name|hashVariableName
argument_list|(
name|symbol
operator|->
name|getSymbol
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|visitChildren
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|EOpConstructFloat
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"float("
argument_list|,
name|NULL
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructVec2
case|:
name|writeBuiltInFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"vec2("
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructVec3
case|:
name|writeBuiltInFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"vec3("
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructVec4
case|:
name|writeBuiltInFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"vec4("
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructBool
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"bool("
argument_list|,
name|NULL
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructBVec2
case|:
name|writeBuiltInFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"bvec2("
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructBVec3
case|:
name|writeBuiltInFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"bvec3("
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructBVec4
case|:
name|writeBuiltInFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"bvec4("
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructInt
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"int("
argument_list|,
name|NULL
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructIVec2
case|:
name|writeBuiltInFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"ivec2("
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructIVec3
case|:
name|writeBuiltInFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"ivec3("
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructIVec4
case|:
name|writeBuiltInFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"ivec4("
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructMat2
case|:
name|writeBuiltInFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"mat2("
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructMat3
case|:
name|writeBuiltInFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"mat3("
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructMat4
case|:
name|writeBuiltInFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"mat4("
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructStruct
case|:
if|if
condition|(
name|visit
operator|==
name|PreVisit
condition|)
block|{
specifier|const
name|TType
modifier|&
name|type
init|=
name|node
operator|->
name|getType
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|type
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtStruct
argument_list|)
expr_stmt|;
name|out
operator|<<
name|hashName
argument_list|(
name|type
operator|.
name|getStruct
argument_list|()
operator|->
name|name
argument_list|()
argument_list|)
operator|<<
literal|"("
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|visit
operator|==
name|InVisit
condition|)
block|{
name|out
operator|<<
literal|", "
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
literal|")"
expr_stmt|;
block|}
break|break;
case|case
name|EOpOuterProduct
case|:
name|writeBuiltInFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"outerProduct("
argument_list|,
name|useEmulatedFunction
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpLessThan
case|:
name|writeBuiltInFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"lessThan("
argument_list|,
name|useEmulatedFunction
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpGreaterThan
case|:
name|writeBuiltInFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"greaterThan("
argument_list|,
name|useEmulatedFunction
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpLessThanEqual
case|:
name|writeBuiltInFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"lessThanEqual("
argument_list|,
name|useEmulatedFunction
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpGreaterThanEqual
case|:
name|writeBuiltInFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"greaterThanEqual("
argument_list|,
name|useEmulatedFunction
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpVectorEqual
case|:
name|writeBuiltInFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"equal("
argument_list|,
name|useEmulatedFunction
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpVectorNotEqual
case|:
name|writeBuiltInFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"notEqual("
argument_list|,
name|useEmulatedFunction
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpComma
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpMod
case|:
name|writeBuiltInFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"mod("
argument_list|,
name|useEmulatedFunction
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpModf
case|:
name|writeBuiltInFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"modf("
argument_list|,
name|useEmulatedFunction
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpPow
case|:
name|writeBuiltInFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"pow("
argument_list|,
name|useEmulatedFunction
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpAtan
case|:
name|writeBuiltInFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"atan("
argument_list|,
name|useEmulatedFunction
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpMin
case|:
name|writeBuiltInFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"min("
argument_list|,
name|useEmulatedFunction
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpMax
case|:
name|writeBuiltInFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"max("
argument_list|,
name|useEmulatedFunction
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpClamp
case|:
name|writeBuiltInFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"clamp("
argument_list|,
name|useEmulatedFunction
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpMix
case|:
name|writeBuiltInFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"mix("
argument_list|,
name|useEmulatedFunction
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpStep
case|:
name|writeBuiltInFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"step("
argument_list|,
name|useEmulatedFunction
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpSmoothStep
case|:
name|writeBuiltInFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"smoothstep("
argument_list|,
name|useEmulatedFunction
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpDistance
case|:
name|writeBuiltInFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"distance("
argument_list|,
name|useEmulatedFunction
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpDot
case|:
name|writeBuiltInFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"dot("
argument_list|,
name|useEmulatedFunction
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpCross
case|:
name|writeBuiltInFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"cross("
argument_list|,
name|useEmulatedFunction
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpFaceForward
case|:
name|writeBuiltInFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"faceforward("
argument_list|,
name|useEmulatedFunction
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpReflect
case|:
name|writeBuiltInFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"reflect("
argument_list|,
name|useEmulatedFunction
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpRefract
case|:
name|writeBuiltInFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"refract("
argument_list|,
name|useEmulatedFunction
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpMul
case|:
name|writeBuiltInFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"matrixCompMult("
argument_list|,
name|useEmulatedFunction
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
name|visitChildren
return|;
block|}
end_function
begin_function
DECL|function|visitLoop
name|bool
name|TOutputGLSLBase
operator|::
name|visitLoop
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermLoop
modifier|*
name|node
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|objSink
argument_list|()
decl_stmt|;
name|incrementDepth
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|// Loop header.
name|TLoopType
name|loopType
init|=
name|node
operator|->
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|loopType
operator|==
name|ELoopFor
condition|)
comment|// for loop
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|getUnrollFlag
argument_list|()
condition|)
block|{
name|out
operator|<<
literal|"for ("
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getInit
argument_list|()
condition|)
name|node
operator|->
name|getInit
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"; "
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getCondition
argument_list|()
condition|)
name|node
operator|->
name|getCondition
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"; "
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getExpression
argument_list|()
condition|)
name|node
operator|->
name|getExpression
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|")\n"
expr_stmt|;
block|}
else|else
block|{
comment|// Need to put a one-iteration loop here to handle break.
name|TIntermSequence
modifier|*
name|declSeq
init|=
name|node
operator|->
name|getInit
argument_list|()
operator|->
name|getAsAggregate
argument_list|()
operator|->
name|getSequence
argument_list|()
decl_stmt|;
name|TIntermSymbol
modifier|*
name|indexSymbol
init|=
operator|(
operator|*
name|declSeq
operator|)
index|[
literal|0
index|]
operator|->
name|getAsBinaryNode
argument_list|()
operator|->
name|getLeft
argument_list|()
operator|->
name|getAsSymbolNode
argument_list|()
decl_stmt|;
name|TString
name|name
init|=
name|hashVariableName
argument_list|(
name|indexSymbol
operator|->
name|getSymbol
argument_list|()
argument_list|)
decl_stmt|;
name|out
operator|<<
literal|"for (int "
operator|<<
name|name
operator|<<
literal|" = 0; "
operator|<<
name|name
operator|<<
literal|"< 1; "
operator|<<
literal|"++"
operator|<<
name|name
operator|<<
literal|")\n"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|loopType
operator|==
name|ELoopWhile
condition|)
comment|// while loop
block|{
name|out
operator|<<
literal|"while ("
expr_stmt|;
name|ASSERT
argument_list|(
name|node
operator|->
name|getCondition
argument_list|()
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|node
operator|->
name|getCondition
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|")\n"
expr_stmt|;
block|}
else|else
comment|// do-while loop
block|{
name|ASSERT
argument_list|(
name|loopType
operator|==
name|ELoopDoWhile
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"do\n"
expr_stmt|;
block|}
comment|// Loop body.
if|if
condition|(
name|node
operator|->
name|getUnrollFlag
argument_list|()
condition|)
block|{
name|out
operator|<<
literal|"{\n"
expr_stmt|;
name|mLoopUnrollStack
operator|.
name|push
argument_list|(
name|node
argument_list|)
expr_stmt|;
while|while
condition|(
name|mLoopUnrollStack
operator|.
name|satisfiesLoopCondition
argument_list|()
condition|)
block|{
name|visitCodeBlock
argument_list|(
name|node
operator|->
name|getBody
argument_list|()
argument_list|)
expr_stmt|;
name|mLoopUnrollStack
operator|.
name|step
argument_list|()
expr_stmt|;
block|}
name|mLoopUnrollStack
operator|.
name|pop
argument_list|()
expr_stmt|;
name|out
operator|<<
literal|"}\n"
expr_stmt|;
block|}
else|else
block|{
name|visitCodeBlock
argument_list|(
name|node
operator|->
name|getBody
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Loop footer.
if|if
condition|(
name|loopType
operator|==
name|ELoopDoWhile
condition|)
comment|// do-while loop
block|{
name|out
operator|<<
literal|"while ("
expr_stmt|;
name|ASSERT
argument_list|(
name|node
operator|->
name|getCondition
argument_list|()
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|node
operator|->
name|getCondition
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|");\n"
expr_stmt|;
block|}
name|decrementDepth
argument_list|()
expr_stmt|;
comment|// No need to visit children. They have been already processed in
comment|// this function.
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|visitBranch
name|bool
name|TOutputGLSLBase
operator|::
name|visitBranch
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermBranch
modifier|*
name|node
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|->
name|getFlowOp
argument_list|()
condition|)
block|{
case|case
name|EOpKill
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"discard"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpBreak
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"break"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpContinue
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"continue"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpReturn
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"return "
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|visitCodeBlock
name|void
name|TOutputGLSLBase
operator|::
name|visitCodeBlock
parameter_list|(
name|TIntermNode
modifier|*
name|node
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|objSink
argument_list|()
decl_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
block|{
name|node
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Single statements not part of a sequence need to be terminated
comment|// with semi-colon.
if|if
condition|(
name|isSingleStatement
argument_list|(
name|node
argument_list|)
condition|)
name|out
operator|<<
literal|";\n"
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
literal|"{\n}\n"
expr_stmt|;
comment|// Empty code block.
block|}
block|}
end_function
begin_function
DECL|function|getTypeName
name|TString
name|TOutputGLSLBase
operator|::
name|getTypeName
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|)
block|{
name|TInfoSinkBase
name|out
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|isMatrix
argument_list|()
condition|)
block|{
name|out
operator|<<
literal|"mat"
expr_stmt|;
name|out
operator|<<
name|type
operator|.
name|getNominalSize
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|isVector
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|type
operator|.
name|getBasicType
argument_list|()
condition|)
block|{
case|case
name|EbtFloat
case|:
name|out
operator|<<
literal|"vec"
expr_stmt|;
break|break;
case|case
name|EbtInt
case|:
name|out
operator|<<
literal|"ivec"
expr_stmt|;
break|break;
case|case
name|EbtBool
case|:
name|out
operator|<<
literal|"bvec"
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
name|out
operator|<<
name|type
operator|.
name|getNominalSize
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|type
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtStruct
condition|)
name|out
operator|<<
name|hashName
argument_list|(
name|type
operator|.
name|getStruct
argument_list|()
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|out
operator|<<
name|type
operator|.
name|getBasicString
argument_list|()
expr_stmt|;
block|}
return|return
name|TString
argument_list|(
name|out
operator|.
name|c_str
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|hashName
name|TString
name|TOutputGLSLBase
operator|::
name|hashName
parameter_list|(
specifier|const
name|TString
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
name|mHashFunction
operator|==
name|NULL
operator|||
name|name
operator|.
name|empty
argument_list|()
condition|)
return|return
name|name
return|;
name|NameMap
operator|::
name|const_iterator
name|it
init|=
name|mNameMap
operator|.
name|find
argument_list|(
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|mNameMap
operator|.
name|end
argument_list|()
condition|)
return|return
name|it
operator|->
name|second
operator|.
name|c_str
argument_list|()
return|;
name|TString
name|hashedName
init|=
name|TIntermTraverser
operator|::
name|hash
argument_list|(
name|name
argument_list|,
name|mHashFunction
argument_list|)
decl_stmt|;
name|mNameMap
index|[
name|name
operator|.
name|c_str
argument_list|()
index|]
operator|=
name|hashedName
operator|.
name|c_str
argument_list|()
expr_stmt|;
return|return
name|hashedName
return|;
block|}
end_function
begin_function
DECL|function|hashVariableName
name|TString
name|TOutputGLSLBase
operator|::
name|hashVariableName
parameter_list|(
specifier|const
name|TString
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
name|mSymbolTable
operator|.
name|findBuiltIn
argument_list|(
name|name
argument_list|,
name|mShaderVersion
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|name
return|;
return|return
name|hashName
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|hashFunctionName
name|TString
name|TOutputGLSLBase
operator|::
name|hashFunctionName
parameter_list|(
specifier|const
name|TString
modifier|&
name|mangled_name
parameter_list|)
block|{
name|TString
name|name
init|=
name|TFunction
operator|::
name|unmangleName
argument_list|(
name|mangled_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|mSymbolTable
operator|.
name|findBuiltIn
argument_list|(
name|mangled_name
argument_list|,
name|mShaderVersion
argument_list|)
operator|!=
name|NULL
operator|||
name|name
operator|==
literal|"main"
condition|)
return|return
name|translateTextureFunction
argument_list|(
name|name
argument_list|)
return|;
return|return
name|hashName
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|structDeclared
name|bool
name|TOutputGLSLBase
operator|::
name|structDeclared
parameter_list|(
specifier|const
name|TStructure
modifier|*
name|structure
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|structure
argument_list|)
expr_stmt|;
if|if
condition|(
name|structure
operator|->
name|name
argument_list|()
operator|.
name|empty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
operator|(
name|mDeclaredStructs
operator|.
name|count
argument_list|(
name|structure
operator|->
name|uniqueId
argument_list|()
argument_list|)
operator|>
literal|0
operator|)
return|;
block|}
end_function
begin_function
DECL|function|declareStruct
name|void
name|TOutputGLSLBase
operator|::
name|declareStruct
parameter_list|(
specifier|const
name|TStructure
modifier|*
name|structure
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|objSink
argument_list|()
decl_stmt|;
name|out
operator|<<
literal|"struct "
operator|<<
name|hashName
argument_list|(
name|structure
operator|->
name|name
argument_list|()
argument_list|)
operator|<<
literal|"{\n"
expr_stmt|;
specifier|const
name|TFieldList
modifier|&
name|fields
init|=
name|structure
operator|->
name|fields
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|TField
modifier|*
name|field
init|=
name|fields
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|writeVariablePrecision
argument_list|(
name|field
operator|->
name|type
argument_list|()
operator|->
name|getPrecision
argument_list|()
argument_list|)
condition|)
name|out
operator|<<
literal|" "
expr_stmt|;
name|out
operator|<<
name|getTypeName
argument_list|(
operator|*
name|field
operator|->
name|type
argument_list|()
argument_list|)
operator|<<
literal|" "
operator|<<
name|hashName
argument_list|(
name|field
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|->
name|type
argument_list|()
operator|->
name|isArray
argument_list|()
condition|)
name|out
operator|<<
name|arrayBrackets
argument_list|(
operator|*
name|field
operator|->
name|type
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|";\n"
expr_stmt|;
block|}
name|out
operator|<<
literal|"}"
expr_stmt|;
block|}
end_function
end_unit
