begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// UniformHLSL.cpp:
end_comment
begin_comment
comment|//   Methods for GLSL to HLSL translation for uniforms and interface blocks.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|"compiler/translator/UniformHLSL.h"
end_include
begin_include
include|#
directive|include
file|"common/utilities.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/StructureHLSL.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/UtilsHLSL.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/blocklayoutHLSL.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/util.h"
end_include
begin_namespace
DECL|namespace|sh
namespace|namespace
name|sh
block|{
DECL|function|UniformRegisterPrefix
specifier|static
specifier|const
name|char
modifier|*
name|UniformRegisterPrefix
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|)
block|{
if|if
condition|(
name|IsSampler
argument_list|(
name|type
operator|.
name|getBasicType
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|"s"
return|;
block|}
else|else
block|{
return|return
literal|"c"
return|;
block|}
block|}
DECL|function|InterfaceBlockFieldTypeString
specifier|static
name|TString
name|InterfaceBlockFieldTypeString
parameter_list|(
specifier|const
name|TField
modifier|&
name|field
parameter_list|,
name|TLayoutBlockStorage
name|blockStorage
parameter_list|)
block|{
specifier|const
name|TType
modifier|&
name|fieldType
init|=
operator|*
name|field
operator|.
name|type
argument_list|()
decl_stmt|;
specifier|const
name|TLayoutMatrixPacking
name|matrixPacking
init|=
name|fieldType
operator|.
name|getLayoutQualifier
argument_list|()
operator|.
name|matrixPacking
decl_stmt|;
name|ASSERT
argument_list|(
name|matrixPacking
operator|!=
name|EmpUnspecified
argument_list|)
expr_stmt|;
name|TStructure
modifier|*
name|structure
init|=
name|fieldType
operator|.
name|getStruct
argument_list|()
decl_stmt|;
if|if
condition|(
name|fieldType
operator|.
name|isMatrix
argument_list|()
condition|)
block|{
comment|// Use HLSL row-major packing for GLSL column-major matrices
specifier|const
name|TString
modifier|&
name|matrixPackString
init|=
operator|(
name|matrixPacking
operator|==
name|EmpRowMajor
condition|?
literal|"column_major"
else|:
literal|"row_major"
operator|)
decl_stmt|;
return|return
name|matrixPackString
operator|+
literal|" "
operator|+
name|TypeString
argument_list|(
name|fieldType
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|structure
condition|)
block|{
comment|// Use HLSL row-major packing for GLSL column-major matrices
return|return
name|QualifiedStructNameString
argument_list|(
operator|*
name|structure
argument_list|,
name|matrixPacking
operator|==
name|EmpColumnMajor
argument_list|,
name|blockStorage
operator|==
name|EbsStd140
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|TypeString
argument_list|(
name|fieldType
argument_list|)
return|;
block|}
block|}
DECL|function|InterfaceBlockStructName
specifier|static
name|TString
name|InterfaceBlockStructName
parameter_list|(
specifier|const
name|TInterfaceBlock
modifier|&
name|interfaceBlock
parameter_list|)
block|{
return|return
name|DecoratePrivate
argument_list|(
name|interfaceBlock
operator|.
name|name
argument_list|()
argument_list|)
operator|+
literal|"_type"
return|;
block|}
DECL|function|UniformHLSL
name|UniformHLSL
operator|::
name|UniformHLSL
parameter_list|(
name|StructureHLSL
modifier|*
name|structureHLSL
parameter_list|,
name|ShShaderOutput
name|outputType
parameter_list|,
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|Uniform
argument_list|>
modifier|&
name|uniforms
parameter_list|)
member_init_list|:
name|mUniformRegister
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mInterfaceBlockRegister
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mSamplerRegister
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mStructureHLSL
argument_list|(
name|structureHLSL
argument_list|)
member_init_list|,
name|mOutputType
argument_list|(
name|outputType
argument_list|)
member_init_list|,
name|mUniforms
argument_list|(
name|uniforms
argument_list|)
block|{}
DECL|function|reserveUniformRegisters
name|void
name|UniformHLSL
operator|::
name|reserveUniformRegisters
parameter_list|(
name|unsigned
name|int
name|registerCount
parameter_list|)
block|{
name|mUniformRegister
operator|=
name|registerCount
expr_stmt|;
block|}
DECL|function|reserveInterfaceBlockRegisters
name|void
name|UniformHLSL
operator|::
name|reserveInterfaceBlockRegisters
parameter_list|(
name|unsigned
name|int
name|registerCount
parameter_list|)
block|{
name|mInterfaceBlockRegister
operator|=
name|registerCount
expr_stmt|;
block|}
DECL|function|findUniformByName
specifier|const
name|Uniform
modifier|*
name|UniformHLSL
operator|::
name|findUniformByName
parameter_list|(
specifier|const
name|TString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
for|for
control|(
name|size_t
name|uniformIndex
init|=
literal|0
init|;
name|uniformIndex
operator|<
name|mUniforms
operator|.
name|size
argument_list|()
condition|;
operator|++
name|uniformIndex
control|)
block|{
if|if
condition|(
name|mUniforms
index|[
name|uniformIndex
index|]
operator|.
name|name
operator|==
name|name
operator|.
name|c_str
argument_list|()
condition|)
block|{
return|return
operator|&
name|mUniforms
index|[
name|uniformIndex
index|]
return|;
block|}
block|}
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
DECL|function|declareUniformAndAssignRegister
name|unsigned
name|int
name|UniformHLSL
operator|::
name|declareUniformAndAssignRegister
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|,
specifier|const
name|TString
modifier|&
name|name
parameter_list|,
name|unsigned
name|int
modifier|*
name|registerCount
parameter_list|)
block|{
name|unsigned
name|int
name|registerIndex
init|=
operator|(
name|IsSampler
argument_list|(
name|type
operator|.
name|getBasicType
argument_list|()
argument_list|)
condition|?
name|mSamplerRegister
else|:
name|mUniformRegister
operator|)
decl_stmt|;
specifier|const
name|Uniform
modifier|*
name|uniform
init|=
name|findUniformByName
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|uniform
argument_list|)
expr_stmt|;
name|mUniformRegisterMap
index|[
name|uniform
operator|->
name|name
index|]
operator|=
name|registerIndex
expr_stmt|;
name|ASSERT
argument_list|(
name|registerCount
argument_list|)
expr_stmt|;
operator|*
name|registerCount
operator|=
name|HLSLVariableRegisterCount
argument_list|(
operator|*
name|uniform
argument_list|,
name|mOutputType
argument_list|)
expr_stmt|;
if|if
condition|(
name|gl
operator|::
name|IsSamplerType
argument_list|(
name|uniform
operator|->
name|type
argument_list|)
condition|)
block|{
name|mSamplerRegister
operator|+=
operator|*
name|registerCount
expr_stmt|;
block|}
else|else
block|{
name|mUniformRegister
operator|+=
operator|*
name|registerCount
expr_stmt|;
block|}
return|return
name|registerIndex
return|;
block|}
DECL|function|declareUniformAndAssignRegister
name|unsigned
name|int
name|UniformHLSL
operator|::
name|declareUniformAndAssignRegister
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|,
specifier|const
name|TString
modifier|&
name|name
parameter_list|)
block|{
name|unsigned
name|int
name|registerCount
decl_stmt|;
return|return
name|declareUniformAndAssignRegister
argument_list|(
name|type
argument_list|,
name|name
argument_list|,
operator|&
name|registerCount
argument_list|)
return|;
block|}
DECL|function|outputHLSLSamplerUniformGroup
name|void
name|UniformHLSL
operator|::
name|outputHLSLSamplerUniformGroup
parameter_list|(
name|TInfoSinkBase
modifier|&
name|out
parameter_list|,
specifier|const
name|HLSLTextureSamplerGroup
name|textureGroup
parameter_list|,
specifier|const
name|TVector
argument_list|<
specifier|const
name|TIntermSymbol
modifier|*
argument_list|>
modifier|&
name|group
parameter_list|,
name|unsigned
name|int
modifier|*
name|groupTextureRegisterIndex
parameter_list|)
block|{
if|if
condition|(
name|group
operator|.
name|empty
argument_list|()
condition|)
block|{
return|return;
block|}
name|unsigned
name|int
name|groupRegisterCount
init|=
literal|0
decl_stmt|;
for|for
control|(
specifier|const
name|TIntermSymbol
modifier|*
name|uniform
range|:
name|group
control|)
block|{
specifier|const
name|TType
modifier|&
name|type
init|=
name|uniform
operator|->
name|getType
argument_list|()
decl_stmt|;
specifier|const
name|TString
modifier|&
name|name
init|=
name|uniform
operator|->
name|getSymbol
argument_list|()
decl_stmt|;
name|unsigned
name|int
name|registerCount
decl_stmt|;
name|unsigned
name|int
name|samplerArrayIndex
init|=
name|declareUniformAndAssignRegister
argument_list|(
name|type
argument_list|,
name|name
argument_list|,
operator|&
name|registerCount
argument_list|)
decl_stmt|;
name|groupRegisterCount
operator|+=
name|registerCount
expr_stmt|;
if|if
condition|(
name|type
operator|.
name|isArray
argument_list|()
condition|)
block|{
name|out
operator|<<
literal|"static const uint "
operator|<<
name|DecorateIfNeeded
argument_list|(
name|uniform
operator|->
name|getName
argument_list|()
argument_list|)
operator|<<
name|ArrayString
argument_list|(
name|type
argument_list|)
operator|<<
literal|" = {"
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|type
operator|.
name|getArraySize
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|out
operator|<<
literal|", "
expr_stmt|;
name|out
operator|<<
operator|(
name|samplerArrayIndex
operator|+
name|i
operator|)
expr_stmt|;
block|}
name|out
operator|<<
literal|"};\n"
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
literal|"static const uint "
operator|<<
name|DecorateIfNeeded
argument_list|(
name|uniform
operator|->
name|getName
argument_list|()
argument_list|)
operator|<<
literal|" = "
operator|<<
name|samplerArrayIndex
operator|<<
literal|";\n"
expr_stmt|;
block|}
block|}
name|TString
name|suffix
init|=
name|TextureGroupSuffix
argument_list|(
name|textureGroup
argument_list|)
decl_stmt|;
comment|// Since HLSL_TEXTURE_2D is the first group, it has a fixed offset of zero.
if|if
condition|(
name|textureGroup
operator|!=
name|HLSL_TEXTURE_2D
condition|)
block|{
name|out
operator|<<
literal|"static const uint textureIndexOffset"
operator|<<
name|suffix
operator|<<
literal|" = "
operator|<<
operator|(
operator|*
name|groupTextureRegisterIndex
operator|)
operator|<<
literal|";\n"
expr_stmt|;
name|out
operator|<<
literal|"static const uint samplerIndexOffset"
operator|<<
name|suffix
operator|<<
literal|" = "
operator|<<
operator|(
operator|*
name|groupTextureRegisterIndex
operator|)
operator|<<
literal|";\n"
expr_stmt|;
block|}
name|out
operator|<<
literal|"uniform "
operator|<<
name|TextureString
argument_list|(
name|textureGroup
argument_list|)
operator|<<
literal|" textures"
operator|<<
name|suffix
operator|<<
literal|"["
operator|<<
name|groupRegisterCount
operator|<<
literal|"]"
operator|<<
literal|" : register(t"
operator|<<
operator|(
operator|*
name|groupTextureRegisterIndex
operator|)
operator|<<
literal|");\n"
expr_stmt|;
name|out
operator|<<
literal|"uniform "
operator|<<
name|SamplerString
argument_list|(
name|textureGroup
argument_list|)
operator|<<
literal|" samplers"
operator|<<
name|suffix
operator|<<
literal|"["
operator|<<
name|groupRegisterCount
operator|<<
literal|"]"
operator|<<
literal|" : register(s"
operator|<<
operator|(
operator|*
name|groupTextureRegisterIndex
operator|)
operator|<<
literal|");\n"
expr_stmt|;
operator|*
name|groupTextureRegisterIndex
operator|+=
name|groupRegisterCount
expr_stmt|;
block|}
DECL|function|uniformsHeader
name|void
name|UniformHLSL
operator|::
name|uniformsHeader
parameter_list|(
name|TInfoSinkBase
modifier|&
name|out
parameter_list|,
name|ShShaderOutput
name|outputType
parameter_list|,
specifier|const
name|ReferencedSymbols
modifier|&
name|referencedUniforms
parameter_list|)
block|{
if|if
condition|(
operator|!
name|referencedUniforms
operator|.
name|empty
argument_list|()
condition|)
block|{
name|out
operator|<<
literal|"// Uniforms\n\n"
expr_stmt|;
block|}
comment|// In the case of HLSL 4, sampler uniforms need to be grouped by type before the code is
comment|// written. They are grouped based on the combination of the HLSL texture type and
comment|// HLSL sampler type, enumerated in HLSLTextureSamplerGroup.
name|TVector
argument_list|<
name|TVector
argument_list|<
specifier|const
name|TIntermSymbol
modifier|*
argument_list|>
argument_list|>
name|groupedSamplerUniforms
decl_stmt|;
name|groupedSamplerUniforms
operator|.
name|resize
argument_list|(
name|HLSL_TEXTURE_MAX
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|auto
operator|&
name|uniformIt
operator|:
name|referencedUniforms
control|)
block|{
comment|// Output regular uniforms. Group sampler uniforms by type.
specifier|const
name|TIntermSymbol
modifier|&
name|uniform
init|=
operator|*
name|uniformIt
operator|.
name|second
decl_stmt|;
specifier|const
name|TType
modifier|&
name|type
init|=
name|uniform
operator|.
name|getType
argument_list|()
decl_stmt|;
specifier|const
name|TString
modifier|&
name|name
init|=
name|uniform
operator|.
name|getSymbol
argument_list|()
decl_stmt|;
if|if
condition|(
name|outputType
operator|==
name|SH_HLSL_4_1_OUTPUT
operator|&&
name|IsSampler
argument_list|(
name|type
operator|.
name|getBasicType
argument_list|()
argument_list|)
condition|)
block|{
name|HLSLTextureSamplerGroup
name|group
init|=
name|TextureGroup
argument_list|(
name|type
operator|.
name|getBasicType
argument_list|()
argument_list|)
decl_stmt|;
name|groupedSamplerUniforms
index|[
name|group
index|]
operator|.
name|push_back
argument_list|(
operator|&
name|uniform
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|outputType
operator|==
name|SH_HLSL_4_0_FL9_3_OUTPUT
operator|&&
name|IsSampler
argument_list|(
name|type
operator|.
name|getBasicType
argument_list|()
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|registerIndex
init|=
name|declareUniformAndAssignRegister
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|out
operator|<<
literal|"uniform "
operator|<<
name|SamplerString
argument_list|(
name|type
operator|.
name|getBasicType
argument_list|()
argument_list|)
operator|<<
literal|" sampler_"
operator|<<
name|DecorateUniform
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
operator|<<
name|ArrayString
argument_list|(
name|type
argument_list|)
operator|<<
literal|" : register(s"
operator|<<
name|str
argument_list|(
name|registerIndex
argument_list|)
operator|<<
literal|");\n"
expr_stmt|;
name|out
operator|<<
literal|"uniform "
operator|<<
name|TextureString
argument_list|(
name|type
operator|.
name|getBasicType
argument_list|()
argument_list|)
operator|<<
literal|" texture_"
operator|<<
name|DecorateUniform
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
operator|<<
name|ArrayString
argument_list|(
name|type
argument_list|)
operator|<<
literal|" : register(t"
operator|<<
name|str
argument_list|(
name|registerIndex
argument_list|)
operator|<<
literal|");\n"
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|registerIndex
init|=
name|declareUniformAndAssignRegister
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
decl_stmt|;
specifier|const
name|TStructure
modifier|*
name|structure
init|=
name|type
operator|.
name|getStruct
argument_list|()
decl_stmt|;
comment|// If this is a nameless struct, we need to use its full definition, rather than its (empty) name.
comment|// TypeString() will invoke defineNameless in this case; qualifier prefixes are unnecessary for
comment|// nameless structs in ES, as nameless structs cannot be used anywhere that layout qualifiers are
comment|// permitted.
specifier|const
name|TString
modifier|&
name|typeName
init|=
operator|(
operator|(
name|structure
operator|&&
operator|!
name|structure
operator|->
name|name
argument_list|()
operator|.
name|empty
argument_list|()
operator|)
condition|?
name|QualifiedStructNameString
argument_list|(
operator|*
name|structure
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
else|:
name|TypeString
argument_list|(
name|type
argument_list|)
operator|)
decl_stmt|;
specifier|const
name|TString
modifier|&
name|registerString
init|=
name|TString
argument_list|(
literal|"register("
argument_list|)
operator|+
name|UniformRegisterPrefix
argument_list|(
name|type
argument_list|)
operator|+
name|str
argument_list|(
name|registerIndex
argument_list|)
operator|+
literal|")"
decl_stmt|;
name|out
operator|<<
literal|"uniform "
operator|<<
name|typeName
operator|<<
literal|" "
operator|<<
name|DecorateUniform
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
operator|<<
name|ArrayString
argument_list|(
name|type
argument_list|)
operator|<<
literal|" : "
operator|<<
name|registerString
operator|<<
literal|";\n"
expr_stmt|;
block|}
block|}
if|if
condition|(
name|outputType
operator|==
name|SH_HLSL_4_1_OUTPUT
condition|)
block|{
name|unsigned
name|int
name|groupTextureRegisterIndex
init|=
literal|0
decl_stmt|;
comment|// TEXTURE_2D is special, index offset is assumed to be 0 and omitted in that case.
name|ASSERT
argument_list|(
name|HLSL_TEXTURE_MIN
operator|==
name|HLSL_TEXTURE_2D
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|groupId
init|=
name|HLSL_TEXTURE_MIN
init|;
name|groupId
operator|<
name|HLSL_TEXTURE_MAX
condition|;
operator|++
name|groupId
control|)
block|{
name|outputHLSLSamplerUniformGroup
argument_list|(
name|out
argument_list|,
name|HLSLTextureSamplerGroup
argument_list|(
name|groupId
argument_list|)
argument_list|,
name|groupedSamplerUniforms
index|[
name|groupId
index|]
argument_list|,
operator|&
name|groupTextureRegisterIndex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|interfaceBlocksHeader
name|TString
name|UniformHLSL
operator|::
name|interfaceBlocksHeader
parameter_list|(
specifier|const
name|ReferencedSymbols
modifier|&
name|referencedInterfaceBlocks
parameter_list|)
block|{
name|TString
name|interfaceBlocks
decl_stmt|;
for|for
control|(
name|ReferencedSymbols
operator|::
name|const_iterator
name|interfaceBlockIt
init|=
name|referencedInterfaceBlocks
operator|.
name|begin
argument_list|()
init|;
name|interfaceBlockIt
operator|!=
name|referencedInterfaceBlocks
operator|.
name|end
argument_list|()
condition|;
name|interfaceBlockIt
operator|++
control|)
block|{
specifier|const
name|TType
modifier|&
name|nodeType
init|=
name|interfaceBlockIt
operator|->
name|second
operator|->
name|getType
argument_list|()
decl_stmt|;
specifier|const
name|TInterfaceBlock
modifier|&
name|interfaceBlock
init|=
operator|*
name|nodeType
operator|.
name|getInterfaceBlock
argument_list|()
decl_stmt|;
name|unsigned
name|int
name|arraySize
init|=
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|interfaceBlock
operator|.
name|arraySize
argument_list|()
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|activeRegister
init|=
name|mInterfaceBlockRegister
decl_stmt|;
name|mInterfaceBlockRegisterMap
index|[
name|interfaceBlock
operator|.
name|name
argument_list|()
operator|.
name|c_str
argument_list|()
index|]
operator|=
name|activeRegister
expr_stmt|;
name|mInterfaceBlockRegister
operator|+=
name|std
operator|::
name|max
argument_list|(
literal|1u
argument_list|,
name|arraySize
argument_list|)
expr_stmt|;
comment|// FIXME: interface block field names
if|if
condition|(
name|interfaceBlock
operator|.
name|hasInstanceName
argument_list|()
condition|)
block|{
name|interfaceBlocks
operator|+=
name|interfaceBlockStructString
argument_list|(
name|interfaceBlock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arraySize
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|arrayIndex
init|=
literal|0
init|;
name|arrayIndex
operator|<
name|arraySize
condition|;
name|arrayIndex
operator|++
control|)
block|{
name|interfaceBlocks
operator|+=
name|interfaceBlockString
argument_list|(
name|interfaceBlock
argument_list|,
name|activeRegister
operator|+
name|arrayIndex
argument_list|,
name|arrayIndex
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|interfaceBlocks
operator|+=
name|interfaceBlockString
argument_list|(
name|interfaceBlock
argument_list|,
name|activeRegister
argument_list|,
name|GL_INVALID_INDEX
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|interfaceBlocks
operator|.
name|empty
argument_list|()
condition|?
literal|""
else|:
operator|(
literal|"// Interface Blocks\n\n"
operator|+
name|interfaceBlocks
operator|)
operator|)
return|;
block|}
DECL|function|interfaceBlockString
name|TString
name|UniformHLSL
operator|::
name|interfaceBlockString
parameter_list|(
specifier|const
name|TInterfaceBlock
modifier|&
name|interfaceBlock
parameter_list|,
name|unsigned
name|int
name|registerIndex
parameter_list|,
name|unsigned
name|int
name|arrayIndex
parameter_list|)
block|{
specifier|const
name|TString
modifier|&
name|arrayIndexString
init|=
operator|(
name|arrayIndex
operator|!=
name|GL_INVALID_INDEX
condition|?
name|Decorate
argument_list|(
name|str
argument_list|(
name|arrayIndex
argument_list|)
argument_list|)
else|:
literal|""
operator|)
decl_stmt|;
specifier|const
name|TString
modifier|&
name|blockName
init|=
name|interfaceBlock
operator|.
name|name
argument_list|()
operator|+
name|arrayIndexString
decl_stmt|;
name|TString
name|hlsl
decl_stmt|;
name|hlsl
operator|+=
literal|"cbuffer "
operator|+
name|blockName
operator|+
literal|" : register(b"
operator|+
name|str
argument_list|(
name|registerIndex
argument_list|)
operator|+
literal|")\n"
literal|"{\n"
expr_stmt|;
if|if
condition|(
name|interfaceBlock
operator|.
name|hasInstanceName
argument_list|()
condition|)
block|{
name|hlsl
operator|+=
literal|"    "
operator|+
name|InterfaceBlockStructName
argument_list|(
name|interfaceBlock
argument_list|)
operator|+
literal|" "
operator|+
name|interfaceBlockInstanceString
argument_list|(
name|interfaceBlock
argument_list|,
name|arrayIndex
argument_list|)
operator|+
literal|";\n"
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|TLayoutBlockStorage
name|blockStorage
init|=
name|interfaceBlock
operator|.
name|blockStorage
argument_list|()
decl_stmt|;
name|hlsl
operator|+=
name|interfaceBlockMembersString
argument_list|(
name|interfaceBlock
argument_list|,
name|blockStorage
argument_list|)
expr_stmt|;
block|}
name|hlsl
operator|+=
literal|"};\n\n"
expr_stmt|;
return|return
name|hlsl
return|;
block|}
DECL|function|interfaceBlockInstanceString
name|TString
name|UniformHLSL
operator|::
name|interfaceBlockInstanceString
parameter_list|(
specifier|const
name|TInterfaceBlock
modifier|&
name|interfaceBlock
parameter_list|,
name|unsigned
name|int
name|arrayIndex
parameter_list|)
block|{
if|if
condition|(
operator|!
name|interfaceBlock
operator|.
name|hasInstanceName
argument_list|()
condition|)
block|{
return|return
literal|""
return|;
block|}
elseif|else
if|if
condition|(
name|interfaceBlock
operator|.
name|isArray
argument_list|()
condition|)
block|{
return|return
name|DecoratePrivate
argument_list|(
name|interfaceBlock
operator|.
name|instanceName
argument_list|()
argument_list|)
operator|+
literal|"_"
operator|+
name|str
argument_list|(
name|arrayIndex
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Decorate
argument_list|(
name|interfaceBlock
operator|.
name|instanceName
argument_list|()
argument_list|)
return|;
block|}
block|}
DECL|function|interfaceBlockMembersString
name|TString
name|UniformHLSL
operator|::
name|interfaceBlockMembersString
parameter_list|(
specifier|const
name|TInterfaceBlock
modifier|&
name|interfaceBlock
parameter_list|,
name|TLayoutBlockStorage
name|blockStorage
parameter_list|)
block|{
name|TString
name|hlsl
decl_stmt|;
name|Std140PaddingHelper
name|padHelper
init|=
name|mStructureHLSL
operator|->
name|getPaddingHelper
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|typeIndex
init|=
literal|0
init|;
name|typeIndex
operator|<
name|interfaceBlock
operator|.
name|fields
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|typeIndex
operator|++
control|)
block|{
specifier|const
name|TField
modifier|&
name|field
init|=
operator|*
name|interfaceBlock
operator|.
name|fields
argument_list|()
index|[
name|typeIndex
index|]
decl_stmt|;
specifier|const
name|TType
modifier|&
name|fieldType
init|=
operator|*
name|field
operator|.
name|type
argument_list|()
decl_stmt|;
if|if
condition|(
name|blockStorage
operator|==
name|EbsStd140
condition|)
block|{
comment|// 2 and 3 component vector types in some cases need pre-padding
name|hlsl
operator|+=
name|padHelper
operator|.
name|prePaddingString
argument_list|(
name|fieldType
argument_list|)
expr_stmt|;
block|}
name|hlsl
operator|+=
literal|"    "
operator|+
name|InterfaceBlockFieldTypeString
argument_list|(
name|field
argument_list|,
name|blockStorage
argument_list|)
operator|+
literal|" "
operator|+
name|Decorate
argument_list|(
name|field
operator|.
name|name
argument_list|()
argument_list|)
operator|+
name|ArrayString
argument_list|(
name|fieldType
argument_list|)
operator|+
literal|";\n"
expr_stmt|;
comment|// must pad out after matrices and arrays, where HLSL usually allows itself room to pack stuff
if|if
condition|(
name|blockStorage
operator|==
name|EbsStd140
condition|)
block|{
specifier|const
name|bool
name|useHLSLRowMajorPacking
init|=
operator|(
name|fieldType
operator|.
name|getLayoutQualifier
argument_list|()
operator|.
name|matrixPacking
operator|==
name|EmpColumnMajor
operator|)
decl_stmt|;
name|hlsl
operator|+=
name|padHelper
operator|.
name|postPaddingString
argument_list|(
name|fieldType
argument_list|,
name|useHLSLRowMajorPacking
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|hlsl
return|;
block|}
DECL|function|interfaceBlockStructString
name|TString
name|UniformHLSL
operator|::
name|interfaceBlockStructString
parameter_list|(
specifier|const
name|TInterfaceBlock
modifier|&
name|interfaceBlock
parameter_list|)
block|{
specifier|const
name|TLayoutBlockStorage
name|blockStorage
init|=
name|interfaceBlock
operator|.
name|blockStorage
argument_list|()
decl_stmt|;
return|return
literal|"struct "
operator|+
name|InterfaceBlockStructName
argument_list|(
name|interfaceBlock
argument_list|)
operator|+
literal|"\n"
literal|"{\n"
operator|+
name|interfaceBlockMembersString
argument_list|(
name|interfaceBlock
argument_list|,
name|blockStorage
argument_list|)
operator|+
literal|"};\n\n"
return|;
block|}
block|}
end_namespace
end_unit
