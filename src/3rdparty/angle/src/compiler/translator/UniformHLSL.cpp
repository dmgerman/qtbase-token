begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// UniformHLSL.cpp:
end_comment
begin_comment
comment|//   Methods for GLSL to HLSL translation for uniforms and interface blocks.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|"OutputHLSL.h"
end_include
begin_include
include|#
directive|include
file|"common/blocklayout.h"
end_include
begin_include
include|#
directive|include
file|"common/utilities.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/UniformHLSL.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/StructureHLSL.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/util.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/UtilsHLSL.h"
end_include
begin_namespace
DECL|namespace|sh
namespace|namespace
name|sh
block|{
DECL|function|UniformRegisterPrefix
specifier|static
specifier|const
name|char
modifier|*
name|UniformRegisterPrefix
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|)
block|{
if|if
condition|(
name|IsSampler
argument_list|(
name|type
operator|.
name|getBasicType
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|"s"
return|;
block|}
else|else
block|{
return|return
literal|"c"
return|;
block|}
block|}
DECL|function|InterfaceBlockFieldName
specifier|static
name|TString
name|InterfaceBlockFieldName
parameter_list|(
specifier|const
name|TInterfaceBlock
modifier|&
name|interfaceBlock
parameter_list|,
specifier|const
name|TField
modifier|&
name|field
parameter_list|)
block|{
if|if
condition|(
name|interfaceBlock
operator|.
name|hasInstanceName
argument_list|()
condition|)
block|{
return|return
name|interfaceBlock
operator|.
name|name
argument_list|()
operator|+
literal|"."
operator|+
name|field
operator|.
name|name
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|field
operator|.
name|name
argument_list|()
return|;
block|}
block|}
DECL|function|InterfaceBlockFieldTypeString
specifier|static
name|TString
name|InterfaceBlockFieldTypeString
parameter_list|(
specifier|const
name|TField
modifier|&
name|field
parameter_list|,
name|TLayoutBlockStorage
name|blockStorage
parameter_list|)
block|{
specifier|const
name|TType
modifier|&
name|fieldType
init|=
operator|*
name|field
operator|.
name|type
argument_list|()
decl_stmt|;
specifier|const
name|TLayoutMatrixPacking
name|matrixPacking
init|=
name|fieldType
operator|.
name|getLayoutQualifier
argument_list|()
operator|.
name|matrixPacking
decl_stmt|;
name|ASSERT
argument_list|(
name|matrixPacking
operator|!=
name|EmpUnspecified
argument_list|)
expr_stmt|;
name|TStructure
modifier|*
name|structure
init|=
name|fieldType
operator|.
name|getStruct
argument_list|()
decl_stmt|;
if|if
condition|(
name|fieldType
operator|.
name|isMatrix
argument_list|()
condition|)
block|{
comment|// Use HLSL row-major packing for GLSL column-major matrices
specifier|const
name|TString
modifier|&
name|matrixPackString
init|=
operator|(
name|matrixPacking
operator|==
name|EmpRowMajor
condition|?
literal|"column_major"
else|:
literal|"row_major"
operator|)
decl_stmt|;
return|return
name|matrixPackString
operator|+
literal|" "
operator|+
name|TypeString
argument_list|(
name|fieldType
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|structure
condition|)
block|{
comment|// Use HLSL row-major packing for GLSL column-major matrices
return|return
name|QualifiedStructNameString
argument_list|(
operator|*
name|structure
argument_list|,
name|matrixPacking
operator|==
name|EmpColumnMajor
argument_list|,
name|blockStorage
operator|==
name|EbsStd140
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|TypeString
argument_list|(
name|fieldType
argument_list|)
return|;
block|}
block|}
DECL|function|InterfaceBlockStructName
specifier|static
name|TString
name|InterfaceBlockStructName
parameter_list|(
specifier|const
name|TInterfaceBlock
modifier|&
name|interfaceBlock
parameter_list|)
block|{
return|return
name|DecoratePrivate
argument_list|(
name|interfaceBlock
operator|.
name|name
argument_list|()
argument_list|)
operator|+
literal|"_type"
return|;
block|}
DECL|function|UniformHLSL
name|UniformHLSL
operator|::
name|UniformHLSL
parameter_list|(
name|StructureHLSL
modifier|*
name|structureHLSL
parameter_list|,
name|ShShaderOutput
name|outputType
parameter_list|)
member_init_list|:
name|mUniformRegister
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mInterfaceBlockRegister
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mSamplerRegister
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mStructureHLSL
argument_list|(
name|structureHLSL
argument_list|)
member_init_list|,
name|mOutputType
argument_list|(
name|outputType
argument_list|)
block|{}
DECL|function|reserveUniformRegisters
name|void
name|UniformHLSL
operator|::
name|reserveUniformRegisters
parameter_list|(
name|unsigned
name|int
name|registerCount
parameter_list|)
block|{
name|mUniformRegister
operator|=
name|registerCount
expr_stmt|;
block|}
DECL|function|reserveInterfaceBlockRegisters
name|void
name|UniformHLSL
operator|::
name|reserveInterfaceBlockRegisters
parameter_list|(
name|unsigned
name|int
name|registerCount
parameter_list|)
block|{
name|mInterfaceBlockRegister
operator|=
name|registerCount
expr_stmt|;
block|}
DECL|function|declareUniformAndAssignRegister
name|unsigned
name|int
name|UniformHLSL
operator|::
name|declareUniformAndAssignRegister
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|,
specifier|const
name|TString
modifier|&
name|name
parameter_list|)
block|{
name|unsigned
name|int
name|registerIndex
init|=
operator|(
name|IsSampler
argument_list|(
name|type
operator|.
name|getBasicType
argument_list|()
argument_list|)
condition|?
name|mSamplerRegister
else|:
name|mUniformRegister
operator|)
decl_stmt|;
name|GetVariableTraverser
argument_list|<
name|Uniform
argument_list|>
name|traverser
argument_list|(
operator|&
name|mActiveUniforms
argument_list|)
decl_stmt|;
name|traverser
operator|.
name|traverse
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
specifier|const
name|sh
operator|::
name|Uniform
modifier|&
name|activeUniform
init|=
name|mActiveUniforms
operator|.
name|back
argument_list|()
decl_stmt|;
name|mUniformRegisterMap
index|[
name|activeUniform
operator|.
name|name
index|]
operator|=
name|registerIndex
expr_stmt|;
name|unsigned
name|int
name|registerCount
init|=
name|HLSLVariableRegisterCount
argument_list|(
name|activeUniform
argument_list|,
name|mOutputType
argument_list|)
decl_stmt|;
if|if
condition|(
name|IsSampler
argument_list|(
name|type
operator|.
name|getBasicType
argument_list|()
argument_list|)
condition|)
block|{
name|mSamplerRegister
operator|+=
name|registerCount
expr_stmt|;
block|}
else|else
block|{
name|mUniformRegister
operator|+=
name|registerCount
expr_stmt|;
block|}
return|return
name|registerIndex
return|;
block|}
DECL|function|uniformsHeader
name|TString
name|UniformHLSL
operator|::
name|uniformsHeader
parameter_list|(
name|ShShaderOutput
name|outputType
parameter_list|,
specifier|const
name|ReferencedSymbols
modifier|&
name|referencedUniforms
parameter_list|)
block|{
name|TString
name|uniforms
decl_stmt|;
for|for
control|(
name|ReferencedSymbols
operator|::
name|const_iterator
name|uniformIt
init|=
name|referencedUniforms
operator|.
name|begin
argument_list|()
init|;
name|uniformIt
operator|!=
name|referencedUniforms
operator|.
name|end
argument_list|()
condition|;
name|uniformIt
operator|++
control|)
block|{
specifier|const
name|TIntermSymbol
modifier|&
name|uniform
init|=
operator|*
name|uniformIt
operator|->
name|second
decl_stmt|;
specifier|const
name|TType
modifier|&
name|type
init|=
name|uniform
operator|.
name|getType
argument_list|()
decl_stmt|;
specifier|const
name|TString
modifier|&
name|name
init|=
name|uniform
operator|.
name|getSymbol
argument_list|()
decl_stmt|;
name|unsigned
name|int
name|registerIndex
init|=
name|declareUniformAndAssignRegister
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|outputType
operator|==
name|SH_HLSL11_OUTPUT
operator|&&
name|IsSampler
argument_list|(
name|type
operator|.
name|getBasicType
argument_list|()
argument_list|)
condition|)
comment|// Also declare the texture
block|{
name|uniforms
operator|+=
literal|"uniform "
operator|+
name|SamplerString
argument_list|(
name|type
argument_list|)
operator|+
literal|" sampler_"
operator|+
name|DecorateUniform
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
operator|+
name|ArrayString
argument_list|(
name|type
argument_list|)
operator|+
literal|" : register(s"
operator|+
name|str
argument_list|(
name|registerIndex
argument_list|)
operator|+
literal|");\n"
expr_stmt|;
name|uniforms
operator|+=
literal|"uniform "
operator|+
name|TextureString
argument_list|(
name|type
argument_list|)
operator|+
literal|" texture_"
operator|+
name|DecorateUniform
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
operator|+
name|ArrayString
argument_list|(
name|type
argument_list|)
operator|+
literal|" : register(t"
operator|+
name|str
argument_list|(
name|registerIndex
argument_list|)
operator|+
literal|");\n"
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|TStructure
modifier|*
name|structure
init|=
name|type
operator|.
name|getStruct
argument_list|()
decl_stmt|;
specifier|const
name|TString
modifier|&
name|typeName
init|=
operator|(
name|structure
condition|?
name|QualifiedStructNameString
argument_list|(
operator|*
name|structure
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
else|:
name|TypeString
argument_list|(
name|type
argument_list|)
operator|)
decl_stmt|;
specifier|const
name|TString
modifier|&
name|registerString
init|=
name|TString
argument_list|(
literal|"register("
argument_list|)
operator|+
name|UniformRegisterPrefix
argument_list|(
name|type
argument_list|)
operator|+
name|str
argument_list|(
name|registerIndex
argument_list|)
operator|+
literal|")"
decl_stmt|;
name|uniforms
operator|+=
literal|"uniform "
operator|+
name|typeName
operator|+
literal|" "
operator|+
name|DecorateUniform
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
operator|+
name|ArrayString
argument_list|(
name|type
argument_list|)
operator|+
literal|" : "
operator|+
name|registerString
operator|+
literal|";\n"
expr_stmt|;
block|}
block|}
return|return
operator|(
name|uniforms
operator|.
name|empty
argument_list|()
condition|?
literal|""
else|:
operator|(
literal|"// Uniforms\n\n"
operator|+
name|uniforms
operator|)
operator|)
return|;
block|}
DECL|function|interfaceBlocksHeader
name|TString
name|UniformHLSL
operator|::
name|interfaceBlocksHeader
parameter_list|(
specifier|const
name|ReferencedSymbols
modifier|&
name|referencedInterfaceBlocks
parameter_list|)
block|{
name|TString
name|interfaceBlocks
decl_stmt|;
for|for
control|(
name|ReferencedSymbols
operator|::
name|const_iterator
name|interfaceBlockIt
init|=
name|referencedInterfaceBlocks
operator|.
name|begin
argument_list|()
init|;
name|interfaceBlockIt
operator|!=
name|referencedInterfaceBlocks
operator|.
name|end
argument_list|()
condition|;
name|interfaceBlockIt
operator|++
control|)
block|{
specifier|const
name|TType
modifier|&
name|nodeType
init|=
name|interfaceBlockIt
operator|->
name|second
operator|->
name|getType
argument_list|()
decl_stmt|;
specifier|const
name|TInterfaceBlock
modifier|&
name|interfaceBlock
init|=
operator|*
name|nodeType
operator|.
name|getInterfaceBlock
argument_list|()
decl_stmt|;
specifier|const
name|TFieldList
modifier|&
name|fieldList
init|=
name|interfaceBlock
operator|.
name|fields
argument_list|()
decl_stmt|;
name|unsigned
name|int
name|arraySize
init|=
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|interfaceBlock
operator|.
name|arraySize
argument_list|()
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|activeRegister
init|=
name|mInterfaceBlockRegister
decl_stmt|;
name|InterfaceBlock
name|activeBlock
argument_list|(
name|interfaceBlock
operator|.
name|name
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|,
name|arraySize
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|typeIndex
init|=
literal|0
init|;
name|typeIndex
operator|<
name|fieldList
operator|.
name|size
argument_list|()
condition|;
name|typeIndex
operator|++
control|)
block|{
specifier|const
name|TField
modifier|&
name|field
init|=
operator|*
name|fieldList
index|[
name|typeIndex
index|]
decl_stmt|;
specifier|const
name|TString
modifier|&
name|fullFieldName
init|=
name|InterfaceBlockFieldName
argument_list|(
name|interfaceBlock
argument_list|,
name|field
argument_list|)
decl_stmt|;
name|bool
name|isRowMajor
init|=
operator|(
name|field
operator|.
name|type
argument_list|()
operator|->
name|getLayoutQualifier
argument_list|()
operator|.
name|matrixPacking
operator|==
name|EmpRowMajor
operator|)
decl_stmt|;
name|GetInterfaceBlockFieldTraverser
name|traverser
argument_list|(
operator|&
name|activeBlock
operator|.
name|fields
argument_list|,
name|isRowMajor
argument_list|)
decl_stmt|;
name|traverser
operator|.
name|traverse
argument_list|(
operator|*
name|field
operator|.
name|type
argument_list|()
argument_list|,
name|fullFieldName
argument_list|)
expr_stmt|;
block|}
name|mInterfaceBlockRegisterMap
index|[
name|activeBlock
operator|.
name|name
index|]
operator|=
name|activeRegister
expr_stmt|;
name|mInterfaceBlockRegister
operator|+=
name|std
operator|::
name|max
argument_list|(
literal|1u
argument_list|,
name|arraySize
argument_list|)
expr_stmt|;
name|activeBlock
operator|.
name|layout
operator|=
name|GetBlockLayoutType
argument_list|(
name|interfaceBlock
operator|.
name|blockStorage
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|interfaceBlock
operator|.
name|matrixPacking
argument_list|()
operator|==
name|EmpRowMajor
condition|)
block|{
name|activeBlock
operator|.
name|isRowMajorLayout
operator|=
literal|true
expr_stmt|;
block|}
name|mActiveInterfaceBlocks
operator|.
name|push_back
argument_list|(
name|activeBlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|interfaceBlock
operator|.
name|hasInstanceName
argument_list|()
condition|)
block|{
name|interfaceBlocks
operator|+=
name|interfaceBlockStructString
argument_list|(
name|interfaceBlock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arraySize
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|arrayIndex
init|=
literal|0
init|;
name|arrayIndex
operator|<
name|arraySize
condition|;
name|arrayIndex
operator|++
control|)
block|{
name|interfaceBlocks
operator|+=
name|interfaceBlockString
argument_list|(
name|interfaceBlock
argument_list|,
name|activeRegister
operator|+
name|arrayIndex
argument_list|,
name|arrayIndex
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|interfaceBlocks
operator|+=
name|interfaceBlockString
argument_list|(
name|interfaceBlock
argument_list|,
name|activeRegister
argument_list|,
name|GL_INVALID_INDEX
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|interfaceBlocks
operator|.
name|empty
argument_list|()
condition|?
literal|""
else|:
operator|(
literal|"// Interface Blocks\n\n"
operator|+
name|interfaceBlocks
operator|)
operator|)
return|;
block|}
DECL|function|interfaceBlockString
name|TString
name|UniformHLSL
operator|::
name|interfaceBlockString
parameter_list|(
specifier|const
name|TInterfaceBlock
modifier|&
name|interfaceBlock
parameter_list|,
name|unsigned
name|int
name|registerIndex
parameter_list|,
name|unsigned
name|int
name|arrayIndex
parameter_list|)
block|{
specifier|const
name|TString
modifier|&
name|arrayIndexString
init|=
operator|(
name|arrayIndex
operator|!=
name|GL_INVALID_INDEX
condition|?
name|Decorate
argument_list|(
name|str
argument_list|(
name|arrayIndex
argument_list|)
argument_list|)
else|:
literal|""
operator|)
decl_stmt|;
specifier|const
name|TString
modifier|&
name|blockName
init|=
name|interfaceBlock
operator|.
name|name
argument_list|()
operator|+
name|arrayIndexString
decl_stmt|;
name|TString
name|hlsl
decl_stmt|;
name|hlsl
operator|+=
literal|"cbuffer "
operator|+
name|blockName
operator|+
literal|" : register(b"
operator|+
name|str
argument_list|(
name|registerIndex
argument_list|)
operator|+
literal|")\n"
literal|"{\n"
expr_stmt|;
if|if
condition|(
name|interfaceBlock
operator|.
name|hasInstanceName
argument_list|()
condition|)
block|{
name|hlsl
operator|+=
literal|"    "
operator|+
name|InterfaceBlockStructName
argument_list|(
name|interfaceBlock
argument_list|)
operator|+
literal|" "
operator|+
name|interfaceBlockInstanceString
argument_list|(
name|interfaceBlock
argument_list|,
name|arrayIndex
argument_list|)
operator|+
literal|";\n"
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|TLayoutBlockStorage
name|blockStorage
init|=
name|interfaceBlock
operator|.
name|blockStorage
argument_list|()
decl_stmt|;
name|hlsl
operator|+=
name|interfaceBlockMembersString
argument_list|(
name|interfaceBlock
argument_list|,
name|blockStorage
argument_list|)
expr_stmt|;
block|}
name|hlsl
operator|+=
literal|"};\n\n"
expr_stmt|;
return|return
name|hlsl
return|;
block|}
DECL|function|interfaceBlockInstanceString
name|TString
name|UniformHLSL
operator|::
name|interfaceBlockInstanceString
parameter_list|(
specifier|const
name|TInterfaceBlock
modifier|&
name|interfaceBlock
parameter_list|,
name|unsigned
name|int
name|arrayIndex
parameter_list|)
block|{
if|if
condition|(
operator|!
name|interfaceBlock
operator|.
name|hasInstanceName
argument_list|()
condition|)
block|{
return|return
literal|""
return|;
block|}
elseif|else
if|if
condition|(
name|interfaceBlock
operator|.
name|isArray
argument_list|()
condition|)
block|{
return|return
name|DecoratePrivate
argument_list|(
name|interfaceBlock
operator|.
name|instanceName
argument_list|()
argument_list|)
operator|+
literal|"_"
operator|+
name|str
argument_list|(
name|arrayIndex
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Decorate
argument_list|(
name|interfaceBlock
operator|.
name|instanceName
argument_list|()
argument_list|)
return|;
block|}
block|}
DECL|function|interfaceBlockMembersString
name|TString
name|UniformHLSL
operator|::
name|interfaceBlockMembersString
parameter_list|(
specifier|const
name|TInterfaceBlock
modifier|&
name|interfaceBlock
parameter_list|,
name|TLayoutBlockStorage
name|blockStorage
parameter_list|)
block|{
name|TString
name|hlsl
decl_stmt|;
name|Std140PaddingHelper
name|padHelper
init|=
name|mStructureHLSL
operator|->
name|getPaddingHelper
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|typeIndex
init|=
literal|0
init|;
name|typeIndex
operator|<
name|interfaceBlock
operator|.
name|fields
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|typeIndex
operator|++
control|)
block|{
specifier|const
name|TField
modifier|&
name|field
init|=
operator|*
name|interfaceBlock
operator|.
name|fields
argument_list|()
index|[
name|typeIndex
index|]
decl_stmt|;
specifier|const
name|TType
modifier|&
name|fieldType
init|=
operator|*
name|field
operator|.
name|type
argument_list|()
decl_stmt|;
if|if
condition|(
name|blockStorage
operator|==
name|EbsStd140
condition|)
block|{
comment|// 2 and 3 component vector types in some cases need pre-padding
name|hlsl
operator|+=
name|padHelper
operator|.
name|prePadding
argument_list|(
name|fieldType
argument_list|)
expr_stmt|;
block|}
name|hlsl
operator|+=
literal|"    "
operator|+
name|InterfaceBlockFieldTypeString
argument_list|(
name|field
argument_list|,
name|blockStorage
argument_list|)
operator|+
literal|" "
operator|+
name|Decorate
argument_list|(
name|field
operator|.
name|name
argument_list|()
argument_list|)
operator|+
name|ArrayString
argument_list|(
name|fieldType
argument_list|)
operator|+
literal|";\n"
expr_stmt|;
comment|// must pad out after matrices and arrays, where HLSL usually allows itself room to pack stuff
if|if
condition|(
name|blockStorage
operator|==
name|EbsStd140
condition|)
block|{
specifier|const
name|bool
name|useHLSLRowMajorPacking
init|=
operator|(
name|fieldType
operator|.
name|getLayoutQualifier
argument_list|()
operator|.
name|matrixPacking
operator|==
name|EmpColumnMajor
operator|)
decl_stmt|;
name|hlsl
operator|+=
name|padHelper
operator|.
name|postPaddingString
argument_list|(
name|fieldType
argument_list|,
name|useHLSLRowMajorPacking
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|hlsl
return|;
block|}
DECL|function|interfaceBlockStructString
name|TString
name|UniformHLSL
operator|::
name|interfaceBlockStructString
parameter_list|(
specifier|const
name|TInterfaceBlock
modifier|&
name|interfaceBlock
parameter_list|)
block|{
specifier|const
name|TLayoutBlockStorage
name|blockStorage
init|=
name|interfaceBlock
operator|.
name|blockStorage
argument_list|()
decl_stmt|;
return|return
literal|"struct "
operator|+
name|InterfaceBlockStructName
argument_list|(
name|interfaceBlock
argument_list|)
operator|+
literal|"\n"
literal|"{\n"
operator|+
name|interfaceBlockMembersString
argument_list|(
name|interfaceBlock
argument_list|,
name|blockStorage
argument_list|)
operator|+
literal|"};\n\n"
return|;
block|}
block|}
end_namespace
end_unit
