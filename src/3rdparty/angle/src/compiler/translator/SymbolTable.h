begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|_SYMBOL_TABLE_INCLUDED_
end_ifndef
begin_define
DECL|macro|_SYMBOL_TABLE_INCLUDED_
define|#
directive|define
name|_SYMBOL_TABLE_INCLUDED_
end_define
begin_comment
comment|//
end_comment
begin_comment
comment|// Symbol table for parsing.  Has these design characteristics:
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// * Same symbol table can be used to compile many shaders, to preserve
end_comment
begin_comment
comment|//   effort of creating and loading with the large numbers of built-in
end_comment
begin_comment
comment|//   symbols.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// * Name mangling will be used to give each function a unique name
end_comment
begin_comment
comment|//   so that symbol table lookups are never ambiguous.  This allows
end_comment
begin_comment
comment|//   a simpler symbol table structure.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// * Pushing and popping of scope, so symbol table will really be a stack
end_comment
begin_comment
comment|//   of symbol tables.  Searched from the top, with new inserts going into
end_comment
begin_comment
comment|//   the top.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// * Constants:  Compile time constant symbols will keep their values
end_comment
begin_comment
comment|//   in the symbol table.  The parser can substitute constants at parse
end_comment
begin_comment
comment|//   time, including doing constant folding and constant propagation.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// * No temporaries:  Temporaries made from operations (+, --, .xy, etc.)
end_comment
begin_comment
comment|//   are tracked in the intermediate representation, not the symbol table.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|<assert.h>
end_include
begin_include
include|#
directive|include
file|"common/angleutils.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/InfoSink.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/intermediate.h"
end_include
begin_comment
comment|// Symbol base class. (Can build functions or variables out of these...)
end_comment
begin_decl_stmt
name|class
name|TSymbol
block|{
name|public
label|:
name|POOL_ALLOCATOR_NEW_DELETE
argument_list|()
expr_stmt|;
name|TSymbol
argument_list|(
specifier|const
name|TString
operator|*
name|n
argument_list|)
operator|:
name|uniqueId
argument_list|(
literal|0
argument_list|)
operator|,
name|name
argument_list|(
argument|n
argument_list|)
block|{     }
name|virtual
operator|~
name|TSymbol
argument_list|()
block|{
comment|// don't delete name, it's from the pool
block|}
specifier|const
name|TString
operator|&
name|getName
argument_list|()
specifier|const
block|{
return|return
operator|*
name|name
return|;
block|}
name|virtual
specifier|const
name|TString
operator|&
name|getMangledName
argument_list|()
specifier|const
block|{
return|return
name|getName
argument_list|()
return|;
block|}
name|virtual
name|bool
name|isFunction
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|virtual
name|bool
name|isVariable
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|void
name|setUniqueId
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|uniqueId
operator|=
name|id
expr_stmt|;
block|}
name|int
name|getUniqueId
argument_list|()
specifier|const
block|{
return|return
name|uniqueId
return|;
block|}
name|void
name|relateToExtension
parameter_list|(
specifier|const
name|TString
modifier|&
name|ext
parameter_list|)
block|{
name|extension
operator|=
name|ext
expr_stmt|;
block|}
specifier|const
name|TString
operator|&
name|getExtension
argument_list|()
specifier|const
block|{
return|return
name|extension
return|;
block|}
name|private
label|:
name|DISALLOW_COPY_AND_ASSIGN
argument_list|(
name|TSymbol
argument_list|)
expr_stmt|;
name|int
name|uniqueId
decl_stmt|;
comment|// For real comparing during code generation
specifier|const
name|TString
modifier|*
name|name
decl_stmt|;
name|TString
name|extension
decl_stmt|;
block|}
end_decl_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_comment
comment|// Variable class, meaning a symbol that's not a function.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// There could be a separate class heirarchy for Constant variables;
end_comment
begin_comment
comment|// Only one of int, bool, or float, (or none) is correct for
end_comment
begin_comment
comment|// any particular use, but it's easy to do this way, and doesn't
end_comment
begin_comment
comment|// seem worth having separate classes, and "getConst" can't simply return
end_comment
begin_comment
comment|// different values for different types polymorphically, so this is
end_comment
begin_comment
comment|// just simple and pragmatic.
end_comment
begin_decl_stmt
name|class
name|TVariable
range|:
name|public
name|TSymbol
block|{
name|public
operator|:
name|TVariable
argument_list|(
argument|const TString *name
argument_list|,
argument|const TType&t
argument_list|,
argument|bool uT = false
argument_list|)
operator|:
name|TSymbol
argument_list|(
name|name
argument_list|)
block|,
name|type
argument_list|(
name|t
argument_list|)
block|,
name|userType
argument_list|(
name|uT
argument_list|)
block|,
name|unionArray
argument_list|(
literal|0
argument_list|)
block|{     }
name|virtual
operator|~
name|TVariable
argument_list|()
block|{     }
name|virtual
name|bool
name|isVariable
argument_list|()
specifier|const
block|{
return|return
name|true
return|;
block|}
name|TType
operator|&
name|getType
argument_list|()
block|{
return|return
name|type
return|;
block|}
specifier|const
name|TType
operator|&
name|getType
argument_list|()
specifier|const
block|{
return|return
name|type
return|;
block|}
name|bool
name|isUserType
argument_list|()
specifier|const
block|{
return|return
name|userType
return|;
block|}
name|void
name|setQualifier
argument_list|(
argument|TQualifier qualifier
argument_list|)
block|{
name|type
operator|.
name|setQualifier
argument_list|(
name|qualifier
argument_list|)
block|;     }
name|ConstantUnion
operator|*
name|getConstPointer
argument_list|()
block|{
if|if
condition|(
operator|!
name|unionArray
condition|)
name|unionArray
operator|=
name|new
name|ConstantUnion
index|[
name|type
operator|.
name|getObjectSize
argument_list|()
index|]
expr_stmt|;
return|return
name|unionArray
return|;
block|}
end_decl_stmt
begin_expr_stmt
name|ConstantUnion
operator|*
name|getConstPointer
argument_list|()
specifier|const
block|{
return|return
name|unionArray
return|;
block|}
end_expr_stmt
begin_function
name|void
name|shareConstPointer
parameter_list|(
name|ConstantUnion
modifier|*
name|constArray
parameter_list|)
block|{
if|if
condition|(
name|unionArray
operator|==
name|constArray
condition|)
return|return;
name|delete
index|[]
name|unionArray
decl_stmt|;
name|unionArray
operator|=
name|constArray
expr_stmt|;
block|}
end_function
begin_label
name|private
label|:
end_label
begin_expr_stmt
name|DISALLOW_COPY_AND_ASSIGN
argument_list|(
name|TVariable
argument_list|)
expr_stmt|;
end_expr_stmt
begin_decl_stmt
name|TType
name|type
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|bool
name|userType
decl_stmt|;
end_decl_stmt
begin_comment
comment|// we are assuming that Pool Allocator will free the memory
end_comment
begin_comment
comment|// allocated to unionArray when this object is destroyed.
end_comment
begin_decl_stmt
name|ConstantUnion
modifier|*
name|unionArray
decl_stmt|;
end_decl_stmt
begin_comment
unit|};
comment|// The function sub-class of symbols and the parser will need to
end_comment
begin_comment
comment|// share this definition of a function parameter.
end_comment
begin_struct
DECL|struct|TParameter
struct|struct
name|TParameter
block|{
DECL|member|name
name|TString
modifier|*
name|name
decl_stmt|;
DECL|member|type
name|TType
modifier|*
name|type
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|// The function sub-class of a symbol.
end_comment
begin_decl_stmt
name|class
name|TFunction
range|:
name|public
name|TSymbol
block|{
name|public
operator|:
name|TFunction
argument_list|(
argument|TOperator o
argument_list|)
operator|:
name|TSymbol
argument_list|(
literal|0
argument_list|)
block|,
name|returnType
argument_list|(
name|TType
argument_list|(
name|EbtVoid
argument_list|,
name|EbpUndefined
argument_list|)
argument_list|)
block|,
name|op
argument_list|(
name|o
argument_list|)
block|,
name|defined
argument_list|(
argument|false
argument_list|)
block|{     }
name|TFunction
argument_list|(
argument|const TString *name
argument_list|,
argument|const TType&retType
argument_list|,
argument|TOperator tOp = EOpNull
argument_list|)
operator|:
name|TSymbol
argument_list|(
name|name
argument_list|)
block|,
name|returnType
argument_list|(
name|retType
argument_list|)
block|,
name|mangledName
argument_list|(
name|TFunction
operator|::
name|mangleName
argument_list|(
operator|*
name|name
argument_list|)
argument_list|)
block|,
name|op
argument_list|(
name|tOp
argument_list|)
block|,
name|defined
argument_list|(
argument|false
argument_list|)
block|{     }
name|virtual
operator|~
name|TFunction
argument_list|()
block|;
name|virtual
name|bool
name|isFunction
argument_list|()
specifier|const
block|{
return|return
name|true
return|;
block|}
specifier|static
name|TString
name|mangleName
argument_list|(
argument|const TString&name
argument_list|)
block|{
return|return
name|name
operator|+
literal|'('
return|;
block|}
specifier|static
name|TString
name|unmangleName
argument_list|(
argument|const TString&mangledName
argument_list|)
block|{
return|return
name|TString
argument_list|(
name|mangledName
operator|.
name|c_str
argument_list|()
argument_list|,
name|mangledName
operator|.
name|find_first_of
argument_list|(
literal|'('
argument_list|)
argument_list|)
return|;
block|}
name|void
name|addParameter
argument_list|(
argument|TParameter&p
argument_list|)
block|{
name|parameters
operator|.
name|push_back
argument_list|(
name|p
argument_list|)
block|;
name|mangledName
operator|=
name|mangledName
operator|+
name|p
operator|.
name|type
operator|->
name|getMangledName
argument_list|()
block|;     }
specifier|const
name|TString
operator|&
name|getMangledName
argument_list|()
specifier|const
block|{
return|return
name|mangledName
return|;
block|}
specifier|const
name|TType
operator|&
name|getReturnType
argument_list|()
specifier|const
block|{
return|return
name|returnType
return|;
block|}
name|void
name|relateToOperator
argument_list|(
argument|TOperator o
argument_list|)
block|{
name|op
operator|=
name|o
block|;     }
name|TOperator
name|getBuiltInOp
argument_list|()
specifier|const
block|{
return|return
name|op
return|;
block|}
name|void
name|setDefined
argument_list|()
block|{
name|defined
operator|=
name|true
block|;     }
name|bool
name|isDefined
argument_list|()
block|{
return|return
name|defined
return|;
block|}
name|size_t
name|getParamCount
argument_list|()
specifier|const
block|{
return|return
name|parameters
operator|.
name|size
argument_list|()
return|;
block|}
specifier|const
name|TParameter
operator|&
name|getParam
argument_list|(
argument|size_t i
argument_list|)
specifier|const
block|{
return|return
name|parameters
index|[
name|i
index|]
return|;
block|}
name|private
operator|:
name|DISALLOW_COPY_AND_ASSIGN
argument_list|(
name|TFunction
argument_list|)
block|;
typedef|typedef
name|TVector
operator|<
name|TParameter
operator|>
name|TParamList
expr_stmt|;
name|TParamList
name|parameters
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|TType
name|returnType
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|TString
name|mangledName
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|TOperator
name|op
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|bool
name|defined
decl_stmt|;
end_decl_stmt
begin_comment
unit|};
comment|// Interface block name sub-symbol
end_comment
begin_decl_stmt
name|class
name|TInterfaceBlockName
range|:
name|public
name|TSymbol
block|{
name|public
operator|:
name|TInterfaceBlockName
argument_list|(
specifier|const
name|TString
operator|*
name|name
argument_list|)
operator|:
name|TSymbol
argument_list|(
argument|name
argument_list|)
block|{     }
name|virtual
operator|~
name|TInterfaceBlockName
argument_list|()
block|{     }
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|class
name|TSymbolTableLevel
block|{
name|public
label|:
typedef|typedef
name|TMap
operator|<
name|TString
operator|,
name|TSymbol
operator|*
operator|>
name|tLevel
expr_stmt|;
typedef|typedef
name|tLevel
operator|::
name|const_iterator
name|const_iterator
expr_stmt|;
typedef|typedef
specifier|const
name|tLevel
operator|::
name|value_type
name|tLevelPair
expr_stmt|;
typedef|typedef
name|std
operator|::
name|pair
operator|<
name|tLevel
operator|::
name|iterator
operator|,
name|bool
operator|>
name|tInsertResult
expr_stmt|;
name|TSymbolTableLevel
argument_list|()
block|{     }
operator|~
name|TSymbolTableLevel
argument_list|()
expr_stmt|;
name|bool
name|insert
parameter_list|(
name|TSymbol
modifier|*
name|symbol
parameter_list|)
function_decl|;
name|TSymbol
modifier|*
name|find
argument_list|(
specifier|const
name|TString
operator|&
name|name
argument_list|)
decl|const
decl_stmt|;
name|void
name|relateToOperator
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|TOperator
name|op
parameter_list|)
function_decl|;
name|void
name|relateToExtension
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|TString
modifier|&
name|ext
parameter_list|)
function_decl|;
name|protected
label|:
name|tLevel
name|level
decl_stmt|;
block|}
end_decl_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_enum
DECL|enum|ESymbolLevel
enum|enum
name|ESymbolLevel
block|{
DECL|enumerator|COMMON_BUILTINS
name|COMMON_BUILTINS
init|=
literal|0
block|,
DECL|enumerator|ESSL1_BUILTINS
name|ESSL1_BUILTINS
init|=
literal|1
block|,
DECL|enumerator|ESSL3_BUILTINS
name|ESSL3_BUILTINS
init|=
literal|2
block|,
DECL|enumerator|LAST_BUILTIN_LEVEL
name|LAST_BUILTIN_LEVEL
init|=
name|ESSL3_BUILTINS
block|,
DECL|enumerator|GLOBAL_LEVEL
name|GLOBAL_LEVEL
init|=
literal|3
block|}
enum|;
end_enum
begin_decl_stmt
name|class
name|TSymbolTable
block|{
name|public
label|:
name|TSymbolTable
argument_list|()
block|{
comment|// The symbol table cannot be used until push() is called, but
comment|// the lack of an initial call to push() can be used to detect
comment|// that the symbol table has not been preloaded with built-ins.
block|}
operator|~
name|TSymbolTable
argument_list|()
expr_stmt|;
comment|// When the symbol table is initialized with the built-ins, there should
comment|// 'push' calls, so that built-ins are at level 0 and the shader
comment|// globals are at level 1.
name|bool
name|isEmpty
parameter_list|()
block|{
return|return
name|table
operator|.
name|empty
argument_list|()
return|;
block|}
name|bool
name|atBuiltInLevel
parameter_list|()
block|{
return|return
name|currentLevel
argument_list|()
operator|<=
name|LAST_BUILTIN_LEVEL
return|;
block|}
name|bool
name|atGlobalLevel
parameter_list|()
block|{
return|return
name|currentLevel
argument_list|()
operator|<=
name|GLOBAL_LEVEL
return|;
block|}
name|void
name|push
parameter_list|()
block|{
name|table
operator|.
name|push_back
argument_list|(
argument|new TSymbolTableLevel
argument_list|)
expr_stmt|;
name|precisionStack
operator|.
name|push_back
argument_list|(
argument|new PrecisionStackLevel
argument_list|)
expr_stmt|;
block|}
name|void
name|pop
parameter_list|()
block|{
name|delete
name|table
operator|.
name|back
parameter_list|()
function_decl|;
name|table
operator|.
name|pop_back
argument_list|()
expr_stmt|;
name|delete
name|precisionStack
operator|.
name|back
parameter_list|()
function_decl|;
name|precisionStack
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
name|bool
name|declare
parameter_list|(
name|TSymbol
modifier|*
name|symbol
parameter_list|)
block|{
return|return
name|insert
argument_list|(
name|currentLevel
argument_list|()
argument_list|,
name|symbol
argument_list|)
return|;
block|}
name|bool
name|insert
parameter_list|(
name|ESymbolLevel
name|level
parameter_list|,
name|TSymbol
modifier|*
name|symbol
parameter_list|)
block|{
return|return
name|table
index|[
name|level
index|]
operator|->
name|insert
argument_list|(
name|symbol
argument_list|)
return|;
block|}
name|bool
name|insertConstInt
parameter_list|(
name|ESymbolLevel
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|TVariable
modifier|*
name|constant
init|=
name|new
name|TVariable
argument_list|(
name|NewPoolTString
argument_list|(
name|name
argument_list|)
argument_list|,
name|TType
argument_list|(
name|EbtInt
argument_list|,
name|EbpUndefined
argument_list|,
name|EvqConst
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|constant
operator|->
name|getConstPointer
argument_list|()
operator|->
name|setIConst
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|insert
argument_list|(
name|level
argument_list|,
name|constant
argument_list|)
return|;
block|}
name|void
name|insertBuiltIn
parameter_list|(
name|ESymbolLevel
name|level
parameter_list|,
name|TType
modifier|*
name|rvalue
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|TType
modifier|*
name|ptype1
parameter_list|,
name|TType
modifier|*
name|ptype2
init|=
literal|0
parameter_list|,
name|TType
modifier|*
name|ptype3
init|=
literal|0
parameter_list|,
name|TType
modifier|*
name|ptype4
init|=
literal|0
parameter_list|,
name|TType
modifier|*
name|ptype5
init|=
literal|0
parameter_list|)
function_decl|;
name|TSymbol
modifier|*
name|find
parameter_list|(
specifier|const
name|TString
modifier|&
name|name
parameter_list|,
name|int
name|shaderVersion
parameter_list|,
name|bool
modifier|*
name|builtIn
init|=
name|NULL
parameter_list|,
name|bool
modifier|*
name|sameScope
init|=
name|NULL
parameter_list|)
function_decl|;
name|TSymbol
modifier|*
name|findBuiltIn
parameter_list|(
specifier|const
name|TString
modifier|&
name|name
parameter_list|,
name|int
name|shaderVersion
parameter_list|)
function_decl|;
name|TSymbolTableLevel
modifier|*
name|getOuterLevel
parameter_list|()
block|{
name|assert
argument_list|(
name|currentLevel
argument_list|()
operator|>=
literal|1
argument_list|)
expr_stmt|;
return|return
name|table
index|[
name|currentLevel
argument_list|()
operator|-
literal|1
index|]
return|;
block|}
name|void
name|relateToOperator
parameter_list|(
name|ESymbolLevel
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|TOperator
name|op
parameter_list|)
block|{
name|table
index|[
name|level
index|]
operator|->
name|relateToOperator
argument_list|(
name|name
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
name|void
name|relateToExtension
parameter_list|(
name|ESymbolLevel
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|TString
modifier|&
name|ext
parameter_list|)
block|{
name|table
index|[
name|level
index|]
operator|->
name|relateToExtension
argument_list|(
name|name
argument_list|,
name|ext
argument_list|)
expr_stmt|;
block|}
name|void
name|dump
argument_list|(
name|TInfoSink
operator|&
name|infoSink
argument_list|)
decl|const
decl_stmt|;
name|bool
name|setDefaultPrecision
parameter_list|(
specifier|const
name|TPublicType
modifier|&
name|type
parameter_list|,
name|TPrecision
name|prec
parameter_list|)
block|{
if|if
condition|(
operator|!
name|SupportsPrecision
argument_list|(
name|type
operator|.
name|type
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|type
operator|.
name|isAggregate
argument_list|()
condition|)
return|return
name|false
return|;
comment|// Not allowed to set for aggregate types
name|int
name|indexOfLastElement
init|=
name|static_cast
operator|<
name|int
operator|>
operator|(
name|precisionStack
operator|.
name|size
argument_list|()
operator|)
operator|-
literal|1
decl_stmt|;
comment|// Uses map operator [], overwrites the current value
operator|(
operator|*
name|precisionStack
index|[
name|indexOfLastElement
index|]
operator|)
index|[
name|type
operator|.
name|type
index|]
operator|=
name|prec
expr_stmt|;
return|return
name|true
return|;
block|}
comment|// Searches down the precisionStack for a precision qualifier
comment|// for the specified TBasicType
name|TPrecision
name|getDefaultPrecision
parameter_list|(
name|TBasicType
name|type
parameter_list|)
function_decl|;
specifier|static
name|int
name|nextUniqueId
parameter_list|()
block|{
return|return
operator|++
name|uniqueIdCounter
return|;
block|}
name|private
label|:
name|ESymbolLevel
name|currentLevel
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
name|ESymbolLevel
operator|>
operator|(
name|table
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|)
return|;
block|}
name|std
operator|::
name|vector
operator|<
name|TSymbolTableLevel
operator|*
operator|>
name|table
expr_stmt|;
typedef|typedef
name|TMap
operator|<
name|TBasicType
operator|,
name|TPrecision
operator|>
name|PrecisionStackLevel
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|PrecisionStackLevel
operator|*
operator|>
name|precisionStack
expr_stmt|;
specifier|static
name|int
name|uniqueIdCounter
decl_stmt|;
block|}
end_decl_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// _SYMBOL_TABLE_INCLUDED_
end_comment
end_unit
