begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|"compiler/translator/Intermediate.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/SymbolTable.h"
end_include
begin_namespace
namespace|namespace
block|{
comment|//
comment|// Two purposes:
comment|// 1.  Show an example of how to iterate tree.  Functions can
comment|//     also directly call Traverse() on children themselves to
comment|//     have finer grained control over the process than shown here.
comment|//     See the last function for how to get started.
comment|// 2.  Print out a text based description of the tree.
comment|//
comment|//
comment|// Use this class to carry along data from node to node in
comment|// the traversal
comment|//
DECL|class|TOutputTraverser
class|class
name|TOutputTraverser
super|:
specifier|public
name|TIntermTraverser
block|{
public|public:
DECL|function|TOutputTraverser
name|TOutputTraverser
parameter_list|(
name|TInfoSinkBase
modifier|&
name|i
parameter_list|)
member_init_list|:
name|sink
argument_list|(
name|i
argument_list|)
block|{ }
DECL|member|sink
name|TInfoSinkBase
modifier|&
name|sink
decl_stmt|;
protected|protected:
name|void
name|visitSymbol
parameter_list|(
name|TIntermSymbol
modifier|*
parameter_list|)
function_decl|;
name|void
name|visitConstantUnion
parameter_list|(
name|TIntermConstantUnion
modifier|*
parameter_list|)
function_decl|;
name|bool
name|visitBinary
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermBinary
modifier|*
parameter_list|)
function_decl|;
name|bool
name|visitUnary
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermUnary
modifier|*
parameter_list|)
function_decl|;
name|bool
name|visitSelection
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermSelection
modifier|*
parameter_list|)
function_decl|;
name|bool
name|visitAggregate
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermAggregate
modifier|*
parameter_list|)
function_decl|;
name|bool
name|visitLoop
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermLoop
modifier|*
parameter_list|)
function_decl|;
name|bool
name|visitBranch
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermBranch
modifier|*
parameter_list|)
function_decl|;
block|}
class|;
comment|//
comment|// Helper functions for printing, not part of traversing.
comment|//
DECL|function|OutputTreeText
name|void
name|OutputTreeText
parameter_list|(
name|TInfoSinkBase
modifier|&
name|sink
parameter_list|,
name|TIntermNode
modifier|*
name|node
parameter_list|,
specifier|const
name|int
name|depth
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|sink
operator|.
name|location
argument_list|(
name|node
operator|->
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|depth
condition|;
operator|++
name|i
control|)
name|sink
operator|<<
literal|"  "
expr_stmt|;
block|}
block|}
end_namespace
begin_comment
comment|// namespace anonymous
end_comment
begin_function
DECL|function|getCompleteString
name|TString
name|TType
operator|::
name|getCompleteString
parameter_list|()
specifier|const
block|{
name|TStringStream
name|stream
decl_stmt|;
if|if
condition|(
name|qualifier
operator|!=
name|EvqTemporary
operator|&&
name|qualifier
operator|!=
name|EvqGlobal
condition|)
name|stream
operator|<<
name|getQualifierString
argument_list|()
operator|<<
literal|" "
expr_stmt|;
if|if
condition|(
name|precision
operator|!=
name|EbpUndefined
condition|)
name|stream
operator|<<
name|getPrecisionString
argument_list|()
operator|<<
literal|" "
expr_stmt|;
if|if
condition|(
name|array
condition|)
name|stream
operator|<<
literal|"array["
operator|<<
name|getArraySize
argument_list|()
operator|<<
literal|"] of "
expr_stmt|;
if|if
condition|(
name|isMatrix
argument_list|()
condition|)
name|stream
operator|<<
name|getCols
argument_list|()
operator|<<
literal|"X"
operator|<<
name|getRows
argument_list|()
operator|<<
literal|" matrix of "
expr_stmt|;
elseif|else
if|if
condition|(
name|isVector
argument_list|()
condition|)
name|stream
operator|<<
name|getNominalSize
argument_list|()
operator|<<
literal|"-component vector of "
expr_stmt|;
name|stream
operator|<<
name|getBasicString
argument_list|()
expr_stmt|;
return|return
name|stream
operator|.
name|str
argument_list|()
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// The rest of the file are the traversal functions.  The last one
end_comment
begin_comment
comment|// is the one that starts the traversal.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Return true from interior nodes to have the external traversal
end_comment
begin_comment
comment|// continue on to children.  If you process children yourself,
end_comment
begin_comment
comment|// return false.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|visitSymbol
name|void
name|TOutputTraverser
operator|::
name|visitSymbol
parameter_list|(
name|TIntermSymbol
modifier|*
name|node
parameter_list|)
block|{
name|OutputTreeText
argument_list|(
name|sink
argument_list|,
name|node
argument_list|,
name|mDepth
argument_list|)
expr_stmt|;
name|sink
operator|<<
literal|"'"
operator|<<
name|node
operator|->
name|getSymbol
argument_list|()
operator|<<
literal|"' "
expr_stmt|;
name|sink
operator|<<
literal|"("
operator|<<
name|node
operator|->
name|getCompleteString
argument_list|()
operator|<<
literal|")\n"
expr_stmt|;
block|}
end_function
begin_function
DECL|function|visitBinary
name|bool
name|TOutputTraverser
operator|::
name|visitBinary
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermBinary
modifier|*
name|node
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|sink
decl_stmt|;
name|OutputTreeText
argument_list|(
name|out
argument_list|,
name|node
argument_list|,
name|mDepth
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|node
operator|->
name|getOp
argument_list|()
condition|)
block|{
case|case
name|EOpAssign
case|:
name|out
operator|<<
literal|"move second child to first child"
expr_stmt|;
break|break;
case|case
name|EOpInitialize
case|:
name|out
operator|<<
literal|"initialize first child with second child"
expr_stmt|;
break|break;
case|case
name|EOpAddAssign
case|:
name|out
operator|<<
literal|"add second child into first child"
expr_stmt|;
break|break;
case|case
name|EOpSubAssign
case|:
name|out
operator|<<
literal|"subtract second child into first child"
expr_stmt|;
break|break;
case|case
name|EOpMulAssign
case|:
name|out
operator|<<
literal|"multiply second child into first child"
expr_stmt|;
break|break;
case|case
name|EOpVectorTimesMatrixAssign
case|:
name|out
operator|<<
literal|"matrix mult second child into first child"
expr_stmt|;
break|break;
case|case
name|EOpVectorTimesScalarAssign
case|:
name|out
operator|<<
literal|"vector scale second child into first child"
expr_stmt|;
break|break;
case|case
name|EOpMatrixTimesScalarAssign
case|:
name|out
operator|<<
literal|"matrix scale second child into first child"
expr_stmt|;
break|break;
case|case
name|EOpMatrixTimesMatrixAssign
case|:
name|out
operator|<<
literal|"matrix mult second child into first child"
expr_stmt|;
break|break;
case|case
name|EOpDivAssign
case|:
name|out
operator|<<
literal|"divide second child into first child"
expr_stmt|;
break|break;
case|case
name|EOpIndexDirect
case|:
name|out
operator|<<
literal|"direct index"
expr_stmt|;
break|break;
case|case
name|EOpIndexIndirect
case|:
name|out
operator|<<
literal|"indirect index"
expr_stmt|;
break|break;
case|case
name|EOpIndexDirectStruct
case|:
name|out
operator|<<
literal|"direct index for structure"
expr_stmt|;
break|break;
case|case
name|EOpIndexDirectInterfaceBlock
case|:
name|out
operator|<<
literal|"direct index for interface block"
expr_stmt|;
break|break;
case|case
name|EOpVectorSwizzle
case|:
name|out
operator|<<
literal|"vector swizzle"
expr_stmt|;
break|break;
case|case
name|EOpAdd
case|:
name|out
operator|<<
literal|"add"
expr_stmt|;
break|break;
case|case
name|EOpSub
case|:
name|out
operator|<<
literal|"subtract"
expr_stmt|;
break|break;
case|case
name|EOpMul
case|:
name|out
operator|<<
literal|"component-wise multiply"
expr_stmt|;
break|break;
case|case
name|EOpDiv
case|:
name|out
operator|<<
literal|"divide"
expr_stmt|;
break|break;
case|case
name|EOpEqual
case|:
name|out
operator|<<
literal|"Compare Equal"
expr_stmt|;
break|break;
case|case
name|EOpNotEqual
case|:
name|out
operator|<<
literal|"Compare Not Equal"
expr_stmt|;
break|break;
case|case
name|EOpLessThan
case|:
name|out
operator|<<
literal|"Compare Less Than"
expr_stmt|;
break|break;
case|case
name|EOpGreaterThan
case|:
name|out
operator|<<
literal|"Compare Greater Than"
expr_stmt|;
break|break;
case|case
name|EOpLessThanEqual
case|:
name|out
operator|<<
literal|"Compare Less Than or Equal"
expr_stmt|;
break|break;
case|case
name|EOpGreaterThanEqual
case|:
name|out
operator|<<
literal|"Compare Greater Than or Equal"
expr_stmt|;
break|break;
case|case
name|EOpVectorTimesScalar
case|:
name|out
operator|<<
literal|"vector-scale"
expr_stmt|;
break|break;
case|case
name|EOpVectorTimesMatrix
case|:
name|out
operator|<<
literal|"vector-times-matrix"
expr_stmt|;
break|break;
case|case
name|EOpMatrixTimesVector
case|:
name|out
operator|<<
literal|"matrix-times-vector"
expr_stmt|;
break|break;
case|case
name|EOpMatrixTimesScalar
case|:
name|out
operator|<<
literal|"matrix-scale"
expr_stmt|;
break|break;
case|case
name|EOpMatrixTimesMatrix
case|:
name|out
operator|<<
literal|"matrix-multiply"
expr_stmt|;
break|break;
case|case
name|EOpLogicalOr
case|:
name|out
operator|<<
literal|"logical-or"
expr_stmt|;
break|break;
case|case
name|EOpLogicalXor
case|:
name|out
operator|<<
literal|"logical-xor"
expr_stmt|;
break|break;
case|case
name|EOpLogicalAnd
case|:
name|out
operator|<<
literal|"logical-and"
expr_stmt|;
break|break;
default|default:
name|out
operator|<<
literal|"<unknown op>"
expr_stmt|;
block|}
name|out
operator|<<
literal|" ("
operator|<<
name|node
operator|->
name|getCompleteString
argument_list|()
operator|<<
literal|")"
expr_stmt|;
name|out
operator|<<
literal|"\n"
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|visitUnary
name|bool
name|TOutputTraverser
operator|::
name|visitUnary
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermUnary
modifier|*
name|node
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|sink
decl_stmt|;
name|OutputTreeText
argument_list|(
name|out
argument_list|,
name|node
argument_list|,
name|mDepth
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|node
operator|->
name|getOp
argument_list|()
condition|)
block|{
case|case
name|EOpNegative
case|:
name|out
operator|<<
literal|"Negate value"
expr_stmt|;
break|break;
case|case
name|EOpPositive
case|:
name|out
operator|<<
literal|"Positive sign"
expr_stmt|;
break|break;
case|case
name|EOpVectorLogicalNot
case|:
case|case
name|EOpLogicalNot
case|:
name|out
operator|<<
literal|"Negate conditional"
expr_stmt|;
break|break;
case|case
name|EOpPostIncrement
case|:
name|out
operator|<<
literal|"Post-Increment"
expr_stmt|;
break|break;
case|case
name|EOpPostDecrement
case|:
name|out
operator|<<
literal|"Post-Decrement"
expr_stmt|;
break|break;
case|case
name|EOpPreIncrement
case|:
name|out
operator|<<
literal|"Pre-Increment"
expr_stmt|;
break|break;
case|case
name|EOpPreDecrement
case|:
name|out
operator|<<
literal|"Pre-Decrement"
expr_stmt|;
break|break;
case|case
name|EOpRadians
case|:
name|out
operator|<<
literal|"radians"
expr_stmt|;
break|break;
case|case
name|EOpDegrees
case|:
name|out
operator|<<
literal|"degrees"
expr_stmt|;
break|break;
case|case
name|EOpSin
case|:
name|out
operator|<<
literal|"sine"
expr_stmt|;
break|break;
case|case
name|EOpCos
case|:
name|out
operator|<<
literal|"cosine"
expr_stmt|;
break|break;
case|case
name|EOpTan
case|:
name|out
operator|<<
literal|"tangent"
expr_stmt|;
break|break;
case|case
name|EOpAsin
case|:
name|out
operator|<<
literal|"arc sine"
expr_stmt|;
break|break;
case|case
name|EOpAcos
case|:
name|out
operator|<<
literal|"arc cosine"
expr_stmt|;
break|break;
case|case
name|EOpAtan
case|:
name|out
operator|<<
literal|"arc tangent"
expr_stmt|;
break|break;
case|case
name|EOpExp
case|:
name|out
operator|<<
literal|"exp"
expr_stmt|;
break|break;
case|case
name|EOpLog
case|:
name|out
operator|<<
literal|"log"
expr_stmt|;
break|break;
case|case
name|EOpExp2
case|:
name|out
operator|<<
literal|"exp2"
expr_stmt|;
break|break;
case|case
name|EOpLog2
case|:
name|out
operator|<<
literal|"log2"
expr_stmt|;
break|break;
case|case
name|EOpSqrt
case|:
name|out
operator|<<
literal|"sqrt"
expr_stmt|;
break|break;
case|case
name|EOpInverseSqrt
case|:
name|out
operator|<<
literal|"inverse sqrt"
expr_stmt|;
break|break;
case|case
name|EOpAbs
case|:
name|out
operator|<<
literal|"Absolute value"
expr_stmt|;
break|break;
case|case
name|EOpSign
case|:
name|out
operator|<<
literal|"Sign"
expr_stmt|;
break|break;
case|case
name|EOpFloor
case|:
name|out
operator|<<
literal|"Floor"
expr_stmt|;
break|break;
case|case
name|EOpCeil
case|:
name|out
operator|<<
literal|"Ceiling"
expr_stmt|;
break|break;
case|case
name|EOpFract
case|:
name|out
operator|<<
literal|"Fraction"
expr_stmt|;
break|break;
case|case
name|EOpLength
case|:
name|out
operator|<<
literal|"length"
expr_stmt|;
break|break;
case|case
name|EOpNormalize
case|:
name|out
operator|<<
literal|"normalize"
expr_stmt|;
break|break;
comment|// case EOpDPdx:           out<< "dPdx";                 break;
comment|// case EOpDPdy:           out<< "dPdy";                 break;
comment|// case EOpFwidth:         out<< "fwidth";               break;
case|case
name|EOpAny
case|:
name|out
operator|<<
literal|"any"
expr_stmt|;
break|break;
case|case
name|EOpAll
case|:
name|out
operator|<<
literal|"all"
expr_stmt|;
break|break;
default|default:
name|out
operator|.
name|prefix
argument_list|(
name|EPrefixError
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"Bad unary op"
expr_stmt|;
block|}
name|out
operator|<<
literal|" ("
operator|<<
name|node
operator|->
name|getCompleteString
argument_list|()
operator|<<
literal|")"
expr_stmt|;
name|out
operator|<<
literal|"\n"
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|visitAggregate
name|bool
name|TOutputTraverser
operator|::
name|visitAggregate
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermAggregate
modifier|*
name|node
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|sink
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|getOp
argument_list|()
operator|==
name|EOpNull
condition|)
block|{
name|out
operator|.
name|prefix
argument_list|(
name|EPrefixError
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"node is still EOpNull!"
expr_stmt|;
return|return
literal|true
return|;
block|}
name|OutputTreeText
argument_list|(
name|out
argument_list|,
name|node
argument_list|,
name|mDepth
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|node
operator|->
name|getOp
argument_list|()
condition|)
block|{
case|case
name|EOpSequence
case|:
name|out
operator|<<
literal|"Sequence\n"
expr_stmt|;
return|return
literal|true
return|;
case|case
name|EOpComma
case|:
name|out
operator|<<
literal|"Comma\n"
expr_stmt|;
return|return
literal|true
return|;
case|case
name|EOpFunction
case|:
name|out
operator|<<
literal|"Function Definition: "
operator|<<
name|node
operator|->
name|getName
argument_list|()
expr_stmt|;
break|break;
case|case
name|EOpFunctionCall
case|:
name|out
operator|<<
literal|"Function Call: "
operator|<<
name|node
operator|->
name|getName
argument_list|()
expr_stmt|;
break|break;
case|case
name|EOpParameters
case|:
name|out
operator|<<
literal|"Function Parameters: "
expr_stmt|;
break|break;
case|case
name|EOpPrototype
case|:
name|out
operator|<<
literal|"Function Prototype: "
operator|<<
name|node
operator|->
name|getName
argument_list|()
expr_stmt|;
break|break;
case|case
name|EOpConstructFloat
case|:
name|out
operator|<<
literal|"Construct float"
expr_stmt|;
break|break;
case|case
name|EOpConstructVec2
case|:
name|out
operator|<<
literal|"Construct vec2"
expr_stmt|;
break|break;
case|case
name|EOpConstructVec3
case|:
name|out
operator|<<
literal|"Construct vec3"
expr_stmt|;
break|break;
case|case
name|EOpConstructVec4
case|:
name|out
operator|<<
literal|"Construct vec4"
expr_stmt|;
break|break;
case|case
name|EOpConstructBool
case|:
name|out
operator|<<
literal|"Construct bool"
expr_stmt|;
break|break;
case|case
name|EOpConstructBVec2
case|:
name|out
operator|<<
literal|"Construct bvec2"
expr_stmt|;
break|break;
case|case
name|EOpConstructBVec3
case|:
name|out
operator|<<
literal|"Construct bvec3"
expr_stmt|;
break|break;
case|case
name|EOpConstructBVec4
case|:
name|out
operator|<<
literal|"Construct bvec4"
expr_stmt|;
break|break;
case|case
name|EOpConstructInt
case|:
name|out
operator|<<
literal|"Construct int"
expr_stmt|;
break|break;
case|case
name|EOpConstructIVec2
case|:
name|out
operator|<<
literal|"Construct ivec2"
expr_stmt|;
break|break;
case|case
name|EOpConstructIVec3
case|:
name|out
operator|<<
literal|"Construct ivec3"
expr_stmt|;
break|break;
case|case
name|EOpConstructIVec4
case|:
name|out
operator|<<
literal|"Construct ivec4"
expr_stmt|;
break|break;
case|case
name|EOpConstructUInt
case|:
name|out
operator|<<
literal|"Construct uint"
expr_stmt|;
break|break;
case|case
name|EOpConstructUVec2
case|:
name|out
operator|<<
literal|"Construct uvec2"
expr_stmt|;
break|break;
case|case
name|EOpConstructUVec3
case|:
name|out
operator|<<
literal|"Construct uvec3"
expr_stmt|;
break|break;
case|case
name|EOpConstructUVec4
case|:
name|out
operator|<<
literal|"Construct uvec4"
expr_stmt|;
break|break;
case|case
name|EOpConstructMat2
case|:
name|out
operator|<<
literal|"Construct mat2"
expr_stmt|;
break|break;
case|case
name|EOpConstructMat3
case|:
name|out
operator|<<
literal|"Construct mat3"
expr_stmt|;
break|break;
case|case
name|EOpConstructMat4
case|:
name|out
operator|<<
literal|"Construct mat4"
expr_stmt|;
break|break;
case|case
name|EOpConstructStruct
case|:
name|out
operator|<<
literal|"Construct structure"
expr_stmt|;
break|break;
case|case
name|EOpLessThan
case|:
name|out
operator|<<
literal|"Compare Less Than"
expr_stmt|;
break|break;
case|case
name|EOpGreaterThan
case|:
name|out
operator|<<
literal|"Compare Greater Than"
expr_stmt|;
break|break;
case|case
name|EOpLessThanEqual
case|:
name|out
operator|<<
literal|"Compare Less Than or Equal"
expr_stmt|;
break|break;
case|case
name|EOpGreaterThanEqual
case|:
name|out
operator|<<
literal|"Compare Greater Than or Equal"
expr_stmt|;
break|break;
case|case
name|EOpVectorEqual
case|:
name|out
operator|<<
literal|"Equal"
expr_stmt|;
break|break;
case|case
name|EOpVectorNotEqual
case|:
name|out
operator|<<
literal|"NotEqual"
expr_stmt|;
break|break;
case|case
name|EOpMod
case|:
name|out
operator|<<
literal|"mod"
expr_stmt|;
break|break;
case|case
name|EOpPow
case|:
name|out
operator|<<
literal|"pow"
expr_stmt|;
break|break;
case|case
name|EOpAtan
case|:
name|out
operator|<<
literal|"arc tangent"
expr_stmt|;
break|break;
case|case
name|EOpMin
case|:
name|out
operator|<<
literal|"min"
expr_stmt|;
break|break;
case|case
name|EOpMax
case|:
name|out
operator|<<
literal|"max"
expr_stmt|;
break|break;
case|case
name|EOpClamp
case|:
name|out
operator|<<
literal|"clamp"
expr_stmt|;
break|break;
case|case
name|EOpMix
case|:
name|out
operator|<<
literal|"mix"
expr_stmt|;
break|break;
case|case
name|EOpStep
case|:
name|out
operator|<<
literal|"step"
expr_stmt|;
break|break;
case|case
name|EOpSmoothStep
case|:
name|out
operator|<<
literal|"smoothstep"
expr_stmt|;
break|break;
case|case
name|EOpDistance
case|:
name|out
operator|<<
literal|"distance"
expr_stmt|;
break|break;
case|case
name|EOpDot
case|:
name|out
operator|<<
literal|"dot-product"
expr_stmt|;
break|break;
case|case
name|EOpCross
case|:
name|out
operator|<<
literal|"cross-product"
expr_stmt|;
break|break;
case|case
name|EOpFaceForward
case|:
name|out
operator|<<
literal|"face-forward"
expr_stmt|;
break|break;
case|case
name|EOpReflect
case|:
name|out
operator|<<
literal|"reflect"
expr_stmt|;
break|break;
case|case
name|EOpRefract
case|:
name|out
operator|<<
literal|"refract"
expr_stmt|;
break|break;
case|case
name|EOpMul
case|:
name|out
operator|<<
literal|"component-wise multiply"
expr_stmt|;
break|break;
case|case
name|EOpDeclaration
case|:
name|out
operator|<<
literal|"Declaration: "
expr_stmt|;
break|break;
case|case
name|EOpInvariantDeclaration
case|:
name|out
operator|<<
literal|"Invariant Declaration: "
expr_stmt|;
break|break;
default|default:
name|out
operator|.
name|prefix
argument_list|(
name|EPrefixError
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"Bad aggregation op"
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|getOp
argument_list|()
operator|!=
name|EOpSequence
operator|&&
name|node
operator|->
name|getOp
argument_list|()
operator|!=
name|EOpParameters
condition|)
name|out
operator|<<
literal|" ("
operator|<<
name|node
operator|->
name|getCompleteString
argument_list|()
operator|<<
literal|")"
expr_stmt|;
name|out
operator|<<
literal|"\n"
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|visitSelection
name|bool
name|TOutputTraverser
operator|::
name|visitSelection
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermSelection
modifier|*
name|node
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|sink
decl_stmt|;
name|OutputTreeText
argument_list|(
name|out
argument_list|,
name|node
argument_list|,
name|mDepth
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"Test condition and select"
expr_stmt|;
name|out
operator|<<
literal|" ("
operator|<<
name|node
operator|->
name|getCompleteString
argument_list|()
operator|<<
literal|")\n"
expr_stmt|;
operator|++
name|mDepth
expr_stmt|;
name|OutputTreeText
argument_list|(
name|sink
argument_list|,
name|node
argument_list|,
name|mDepth
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"Condition\n"
expr_stmt|;
name|node
operator|->
name|getCondition
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|OutputTreeText
argument_list|(
name|sink
argument_list|,
name|node
argument_list|,
name|mDepth
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getTrueBlock
argument_list|()
condition|)
block|{
name|out
operator|<<
literal|"true case\n"
expr_stmt|;
name|node
operator|->
name|getTrueBlock
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
literal|"true case is null\n"
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|getFalseBlock
argument_list|()
condition|)
block|{
name|OutputTreeText
argument_list|(
name|sink
argument_list|,
name|node
argument_list|,
name|mDepth
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"false case\n"
expr_stmt|;
name|node
operator|->
name|getFalseBlock
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
operator|--
name|mDepth
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|visitConstantUnion
name|void
name|TOutputTraverser
operator|::
name|visitConstantUnion
parameter_list|(
name|TIntermConstantUnion
modifier|*
name|node
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|sink
decl_stmt|;
name|size_t
name|size
init|=
name|node
operator|->
name|getType
argument_list|()
operator|.
name|getObjectSize
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|OutputTreeText
argument_list|(
name|out
argument_list|,
name|node
argument_list|,
name|mDepth
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|node
operator|->
name|getUnionArrayPointer
argument_list|()
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|EbtBool
case|:
if|if
condition|(
name|node
operator|->
name|getUnionArrayPointer
argument_list|()
index|[
name|i
index|]
operator|.
name|getBConst
argument_list|()
condition|)
name|out
operator|<<
literal|"true"
expr_stmt|;
else|else
name|out
operator|<<
literal|"false"
expr_stmt|;
name|out
operator|<<
literal|" ("
operator|<<
literal|"const bool"
operator|<<
literal|")"
expr_stmt|;
name|out
operator|<<
literal|"\n"
expr_stmt|;
break|break;
case|case
name|EbtFloat
case|:
name|out
operator|<<
name|node
operator|->
name|getUnionArrayPointer
argument_list|()
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
expr_stmt|;
name|out
operator|<<
literal|" (const float)\n"
expr_stmt|;
break|break;
case|case
name|EbtInt
case|:
name|out
operator|<<
name|node
operator|->
name|getUnionArrayPointer
argument_list|()
index|[
name|i
index|]
operator|.
name|getIConst
argument_list|()
expr_stmt|;
name|out
operator|<<
literal|" (const int)\n"
expr_stmt|;
break|break;
case|case
name|EbtUInt
case|:
name|out
operator|<<
name|node
operator|->
name|getUnionArrayPointer
argument_list|()
index|[
name|i
index|]
operator|.
name|getUConst
argument_list|()
expr_stmt|;
name|out
operator|<<
literal|" (const uint)\n"
expr_stmt|;
break|break;
default|default:
name|out
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|node
operator|->
name|getLine
argument_list|()
argument_list|,
literal|"Unknown constant"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function
begin_function
DECL|function|visitLoop
name|bool
name|TOutputTraverser
operator|::
name|visitLoop
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermLoop
modifier|*
name|node
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|sink
decl_stmt|;
name|OutputTreeText
argument_list|(
name|out
argument_list|,
name|node
argument_list|,
name|mDepth
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"Loop with condition "
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getType
argument_list|()
operator|==
name|ELoopDoWhile
condition|)
name|out
operator|<<
literal|"not "
expr_stmt|;
name|out
operator|<<
literal|"tested first\n"
expr_stmt|;
operator|++
name|mDepth
expr_stmt|;
name|OutputTreeText
argument_list|(
name|sink
argument_list|,
name|node
argument_list|,
name|mDepth
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getCondition
argument_list|()
condition|)
block|{
name|out
operator|<<
literal|"Loop Condition\n"
expr_stmt|;
name|node
operator|->
name|getCondition
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
literal|"No loop condition\n"
expr_stmt|;
block|}
name|OutputTreeText
argument_list|(
name|sink
argument_list|,
name|node
argument_list|,
name|mDepth
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getBody
argument_list|()
condition|)
block|{
name|out
operator|<<
literal|"Loop Body\n"
expr_stmt|;
name|node
operator|->
name|getBody
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
literal|"No loop body\n"
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|getExpression
argument_list|()
condition|)
block|{
name|OutputTreeText
argument_list|(
name|sink
argument_list|,
name|node
argument_list|,
name|mDepth
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"Loop Terminal Expression\n"
expr_stmt|;
name|node
operator|->
name|getExpression
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
operator|--
name|mDepth
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|visitBranch
name|bool
name|TOutputTraverser
operator|::
name|visitBranch
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermBranch
modifier|*
name|node
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|sink
decl_stmt|;
name|OutputTreeText
argument_list|(
name|out
argument_list|,
name|node
argument_list|,
name|mDepth
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|node
operator|->
name|getFlowOp
argument_list|()
condition|)
block|{
case|case
name|EOpKill
case|:
name|out
operator|<<
literal|"Branch: Kill"
expr_stmt|;
break|break;
case|case
name|EOpBreak
case|:
name|out
operator|<<
literal|"Branch: Break"
expr_stmt|;
break|break;
case|case
name|EOpContinue
case|:
name|out
operator|<<
literal|"Branch: Continue"
expr_stmt|;
break|break;
case|case
name|EOpReturn
case|:
name|out
operator|<<
literal|"Branch: Return"
expr_stmt|;
break|break;
default|default:
name|out
operator|<<
literal|"Branch: Unknown Branch"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|node
operator|->
name|getExpression
argument_list|()
condition|)
block|{
name|out
operator|<<
literal|" with expression\n"
expr_stmt|;
operator|++
name|mDepth
expr_stmt|;
name|node
operator|->
name|getExpression
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
operator|--
name|mDepth
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
literal|"\n"
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// This function is the one to call externally to start the traversal.
end_comment
begin_comment
comment|// Individual functions can be initialized to 0 to skip processing of that
end_comment
begin_comment
comment|// type of node.  It's children will still be processed.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|outputTree
name|void
name|TIntermediate
operator|::
name|outputTree
parameter_list|(
name|TIntermNode
modifier|*
name|root
parameter_list|)
block|{
if|if
condition|(
name|root
operator|==
name|NULL
condition|)
return|return;
name|TOutputTraverser
name|it
argument_list|(
name|mInfoSink
operator|.
name|info
argument_list|)
decl_stmt|;
name|root
operator|->
name|traverse
argument_list|(
operator|&
name|it
argument_list|)
expr_stmt|;
block|}
end_function
end_unit
