begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2013 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|"angle_gl.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/VariableInfo.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/util.h"
end_include
begin_include
include|#
directive|include
file|"common/utilities.h"
end_include
begin_function_decl
template|template
parameter_list|<
name|typename
name|VarT
parameter_list|>
specifier|static
name|void
name|ExpandUserDefinedVariable
parameter_list|(
specifier|const
name|VarT
modifier|&
name|variable
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|name
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|mappedName
parameter_list|,
name|bool
name|markStaticUse
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|VarT
argument_list|>
modifier|*
name|expanded
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|// Returns info for an attribute, uniform, or varying.
end_comment
begin_function
template|template
parameter_list|<
name|typename
name|VarT
parameter_list|>
DECL|function|ExpandVariable
specifier|static
name|void
name|ExpandVariable
parameter_list|(
specifier|const
name|VarT
modifier|&
name|variable
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|name
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|mappedName
parameter_list|,
name|bool
name|markStaticUse
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|VarT
argument_list|>
modifier|*
name|expanded
parameter_list|)
block|{
if|if
condition|(
name|variable
operator|.
name|isStruct
argument_list|()
condition|)
block|{
if|if
condition|(
name|variable
operator|.
name|isArray
argument_list|()
condition|)
block|{
for|for
control|(
name|size_t
name|elementIndex
init|=
literal|0
init|;
name|elementIndex
operator|<
name|variable
operator|.
name|elementCount
argument_list|()
condition|;
name|elementIndex
operator|++
control|)
block|{
name|std
operator|::
name|string
name|lname
init|=
name|name
operator|+
name|ArrayString
argument_list|(
name|elementIndex
argument_list|)
decl_stmt|;
name|std
operator|::
name|string
name|lmappedName
init|=
name|mappedName
operator|+
name|ArrayString
argument_list|(
name|elementIndex
argument_list|)
decl_stmt|;
name|ExpandUserDefinedVariable
argument_list|(
name|variable
argument_list|,
name|lname
argument_list|,
name|lmappedName
argument_list|,
name|markStaticUse
argument_list|,
name|expanded
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ExpandUserDefinedVariable
argument_list|(
name|variable
argument_list|,
name|name
argument_list|,
name|mappedName
argument_list|,
name|markStaticUse
argument_list|,
name|expanded
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|VarT
name|expandedVar
init|=
name|variable
decl_stmt|;
name|expandedVar
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|expandedVar
operator|.
name|mappedName
operator|=
name|mappedName
expr_stmt|;
comment|// Mark all expanded fields as used if the parent is used
if|if
condition|(
name|markStaticUse
condition|)
block|{
name|expandedVar
operator|.
name|staticUse
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|expandedVar
operator|.
name|isArray
argument_list|()
condition|)
block|{
name|expandedVar
operator|.
name|name
operator|+=
literal|"[0]"
expr_stmt|;
name|expandedVar
operator|.
name|mappedName
operator|+=
literal|"[0]"
expr_stmt|;
block|}
name|expanded
operator|->
name|push_back
argument_list|(
name|expandedVar
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
template|template
parameter_list|<
name|class
name|VarT
parameter_list|>
DECL|function|ExpandUserDefinedVariable
specifier|static
name|void
name|ExpandUserDefinedVariable
parameter_list|(
specifier|const
name|VarT
modifier|&
name|variable
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|name
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|mappedName
parameter_list|,
name|bool
name|markStaticUse
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|VarT
argument_list|>
modifier|*
name|expanded
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|variable
operator|.
name|isStruct
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|VarT
argument_list|>
modifier|&
name|fields
init|=
name|variable
operator|.
name|fields
decl_stmt|;
for|for
control|(
name|size_t
name|fieldIndex
init|=
literal|0
init|;
name|fieldIndex
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|fieldIndex
operator|++
control|)
block|{
specifier|const
name|VarT
modifier|&
name|field
init|=
name|fields
index|[
name|fieldIndex
index|]
decl_stmt|;
name|ExpandVariable
argument_list|(
name|field
argument_list|,
name|name
operator|+
literal|"."
operator|+
name|field
operator|.
name|name
argument_list|,
name|mappedName
operator|+
literal|"."
operator|+
name|field
operator|.
name|mappedName
argument_list|,
name|markStaticUse
argument_list|,
name|expanded
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
template|template
parameter_list|<
name|class
name|VarT
parameter_list|>
DECL|function|FindVariable
specifier|static
name|VarT
modifier|*
name|FindVariable
parameter_list|(
specifier|const
name|TString
modifier|&
name|name
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|VarT
argument_list|>
modifier|*
name|infoList
parameter_list|)
block|{
comment|// TODO(zmo): optimize this function.
for|for
control|(
name|size_t
name|ii
init|=
literal|0
init|;
name|ii
operator|<
name|infoList
operator|->
name|size
argument_list|()
condition|;
operator|++
name|ii
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|infoList
operator|)
index|[
name|ii
index|]
operator|.
name|name
operator|.
name|c_str
argument_list|()
operator|==
name|name
condition|)
return|return
operator|&
operator|(
operator|(
operator|*
name|infoList
operator|)
index|[
name|ii
index|]
operator|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_constructor
DECL|function|CollectVariables
name|CollectVariables
operator|::
name|CollectVariables
parameter_list|(
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|Attribute
argument_list|>
modifier|*
name|attribs
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|Attribute
argument_list|>
modifier|*
name|outputVariables
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|Uniform
argument_list|>
modifier|*
name|uniforms
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|Varying
argument_list|>
modifier|*
name|varyings
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|InterfaceBlock
argument_list|>
modifier|*
name|interfaceBlocks
parameter_list|,
name|ShHashFunction64
name|hashFunction
parameter_list|)
member_init_list|:
name|mAttribs
argument_list|(
name|attribs
argument_list|)
member_init_list|,
name|mOutputVariables
argument_list|(
name|outputVariables
argument_list|)
member_init_list|,
name|mUniforms
argument_list|(
name|uniforms
argument_list|)
member_init_list|,
name|mVaryings
argument_list|(
name|varyings
argument_list|)
member_init_list|,
name|mInterfaceBlocks
argument_list|(
name|interfaceBlocks
argument_list|)
member_init_list|,
name|mPointCoordAdded
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mFrontFacingAdded
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mFragCoordAdded
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mHashFunction
argument_list|(
name|hashFunction
argument_list|)
block|{ }
end_constructor
begin_comment
comment|// We want to check whether a uniform/varying is statically used
end_comment
begin_comment
comment|// because we only count the used ones in packing computing.
end_comment
begin_comment
comment|// Also, gl_FragCoord, gl_PointCoord, and gl_FrontFacing count
end_comment
begin_comment
comment|// toward varying counting if they are statically used in a fragment
end_comment
begin_comment
comment|// shader.
end_comment
begin_function
DECL|function|visitSymbol
name|void
name|CollectVariables
operator|::
name|visitSymbol
parameter_list|(
name|TIntermSymbol
modifier|*
name|symbol
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|symbol
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sh
operator|::
name|ShaderVariable
modifier|*
name|var
init|=
name|NULL
decl_stmt|;
specifier|const
name|TString
modifier|&
name|symbolName
init|=
name|symbol
operator|->
name|getSymbol
argument_list|()
decl_stmt|;
if|if
condition|(
name|sh
operator|::
name|IsVarying
argument_list|(
name|symbol
operator|->
name|getQualifier
argument_list|()
argument_list|)
condition|)
block|{
name|var
operator|=
name|FindVariable
argument_list|(
name|symbolName
argument_list|,
name|mVaryings
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symbol
operator|->
name|getType
argument_list|()
operator|!=
name|EbtInterfaceBlock
condition|)
block|{
switch|switch
condition|(
name|symbol
operator|->
name|getQualifier
argument_list|()
condition|)
block|{
case|case
name|EvqAttribute
case|:
case|case
name|EvqVertexIn
case|:
name|var
operator|=
name|FindVariable
argument_list|(
name|symbolName
argument_list|,
name|mAttribs
argument_list|)
expr_stmt|;
break|break;
case|case
name|EvqFragmentOut
case|:
name|var
operator|=
name|FindVariable
argument_list|(
name|symbolName
argument_list|,
name|mOutputVariables
argument_list|)
expr_stmt|;
break|break;
case|case
name|EvqUniform
case|:
block|{
specifier|const
name|TInterfaceBlock
modifier|*
name|interfaceBlock
init|=
name|symbol
operator|->
name|getType
argument_list|()
operator|.
name|getInterfaceBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|interfaceBlock
condition|)
block|{
name|sh
operator|::
name|InterfaceBlock
modifier|*
name|namedBlock
init|=
name|FindVariable
argument_list|(
name|interfaceBlock
operator|->
name|name
argument_list|()
argument_list|,
name|mInterfaceBlocks
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|namedBlock
argument_list|)
expr_stmt|;
name|var
operator|=
name|FindVariable
argument_list|(
name|symbolName
argument_list|,
operator|&
name|namedBlock
operator|->
name|fields
argument_list|)
expr_stmt|;
comment|// Set static use on the parent interface block here
name|namedBlock
operator|->
name|staticUse
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|var
operator|=
name|FindVariable
argument_list|(
name|symbolName
argument_list|,
name|mUniforms
argument_list|)
expr_stmt|;
block|}
comment|// It's an internal error to reference an undefined user uniform
name|ASSERT
argument_list|(
name|symbolName
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|,
literal|"gl_"
argument_list|)
operator|==
literal|0
operator|||
name|var
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EvqFragCoord
case|:
if|if
condition|(
operator|!
name|mFragCoordAdded
condition|)
block|{
name|sh
operator|::
name|Varying
name|info
decl_stmt|;
name|info
operator|.
name|name
operator|=
literal|"gl_FragCoord"
expr_stmt|;
name|info
operator|.
name|mappedName
operator|=
literal|"gl_FragCoord"
expr_stmt|;
name|info
operator|.
name|type
operator|=
name|GL_FLOAT_VEC4
expr_stmt|;
name|info
operator|.
name|arraySize
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|precision
operator|=
name|GL_MEDIUM_FLOAT
expr_stmt|;
comment|// Use mediump as it doesn't really matter.
name|info
operator|.
name|staticUse
operator|=
literal|true
expr_stmt|;
name|mVaryings
operator|->
name|push_back
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|mFragCoordAdded
operator|=
literal|true
expr_stmt|;
block|}
return|return;
case|case
name|EvqFrontFacing
case|:
if|if
condition|(
operator|!
name|mFrontFacingAdded
condition|)
block|{
name|sh
operator|::
name|Varying
name|info
decl_stmt|;
name|info
operator|.
name|name
operator|=
literal|"gl_FrontFacing"
expr_stmt|;
name|info
operator|.
name|mappedName
operator|=
literal|"gl_FrontFacing"
expr_stmt|;
name|info
operator|.
name|type
operator|=
name|GL_BOOL
expr_stmt|;
name|info
operator|.
name|arraySize
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|precision
operator|=
name|GL_NONE
expr_stmt|;
name|info
operator|.
name|staticUse
operator|=
literal|true
expr_stmt|;
name|mVaryings
operator|->
name|push_back
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|mFrontFacingAdded
operator|=
literal|true
expr_stmt|;
block|}
return|return;
case|case
name|EvqPointCoord
case|:
if|if
condition|(
operator|!
name|mPointCoordAdded
condition|)
block|{
name|sh
operator|::
name|Varying
name|info
decl_stmt|;
name|info
operator|.
name|name
operator|=
literal|"gl_PointCoord"
expr_stmt|;
name|info
operator|.
name|mappedName
operator|=
literal|"gl_PointCoord"
expr_stmt|;
name|info
operator|.
name|type
operator|=
name|GL_FLOAT_VEC2
expr_stmt|;
name|info
operator|.
name|arraySize
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|precision
operator|=
name|GL_MEDIUM_FLOAT
expr_stmt|;
comment|// Use mediump as it doesn't really matter.
name|info
operator|.
name|staticUse
operator|=
literal|true
expr_stmt|;
name|mVaryings
operator|->
name|push_back
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|mPointCoordAdded
operator|=
literal|true
expr_stmt|;
block|}
return|return;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|var
condition|)
block|{
name|var
operator|->
name|staticUse
operator|=
literal|true
expr_stmt|;
block|}
block|}
end_function
begin_class
template|template
parameter_list|<
name|typename
name|VarT
parameter_list|>
class|class
DECL|class|NameHashingTraverser
name|NameHashingTraverser
super|:
specifier|public
name|sh
operator|::
name|GetVariableTraverser
argument_list|<
name|VarT
argument_list|>
block|{
public|public:
DECL|function|NameHashingTraverser
name|NameHashingTraverser
parameter_list|(
name|std
operator|::
name|vector
argument_list|<
name|VarT
argument_list|>
modifier|*
name|output
parameter_list|,
name|ShHashFunction64
name|hashFunction
parameter_list|)
member_init_list|:
name|sh
operator|::
name|GetVariableTraverser
argument_list|<
name|VarT
argument_list|>
argument_list|(
name|output
argument_list|)
member_init_list|,
name|mHashFunction
argument_list|(
name|hashFunction
argument_list|)
block|{}
private|private:
DECL|function|visitVariable
name|void
name|visitVariable
parameter_list|(
name|VarT
modifier|*
name|variable
parameter_list|)
block|{
name|TString
name|stringName
init|=
name|TString
argument_list|(
name|variable
operator|->
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
decl_stmt|;
name|variable
operator|->
name|mappedName
operator|=
name|TIntermTraverser
operator|::
name|hash
argument_list|(
name|stringName
argument_list|,
name|mHashFunction
argument_list|)
operator|.
name|c_str
argument_list|()
expr_stmt|;
block|}
DECL|member|mHashFunction
name|ShHashFunction64
name|mHashFunction
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|// Attributes, which cannot have struct fields, are a special case
end_comment
begin_function
template|template
parameter_list|<>
DECL|function|visitVariable
name|void
name|CollectVariables
operator|::
name|visitVariable
parameter_list|(
specifier|const
name|TIntermSymbol
modifier|*
name|variable
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|Attribute
argument_list|>
modifier|*
name|infoList
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|variable
argument_list|)
expr_stmt|;
specifier|const
name|TType
modifier|&
name|type
init|=
name|variable
operator|->
name|getType
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|type
operator|.
name|getStruct
argument_list|()
argument_list|)
expr_stmt|;
name|sh
operator|::
name|Attribute
name|attribute
decl_stmt|;
name|attribute
operator|.
name|type
operator|=
name|sh
operator|::
name|GLVariableType
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|attribute
operator|.
name|precision
operator|=
name|sh
operator|::
name|GLVariablePrecision
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|attribute
operator|.
name|name
operator|=
name|variable
operator|->
name|getSymbol
argument_list|()
operator|.
name|c_str
argument_list|()
expr_stmt|;
name|attribute
operator|.
name|arraySize
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|type
operator|.
name|getArraySize
argument_list|()
argument_list|)
expr_stmt|;
name|attribute
operator|.
name|mappedName
operator|=
name|TIntermTraverser
operator|::
name|hash
argument_list|(
name|variable
operator|->
name|getSymbol
argument_list|()
argument_list|,
name|mHashFunction
argument_list|)
operator|.
name|c_str
argument_list|()
expr_stmt|;
name|attribute
operator|.
name|location
operator|=
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|getLayoutQualifier
argument_list|()
operator|.
name|location
expr_stmt|;
name|infoList
operator|->
name|push_back
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
template|template
parameter_list|<>
DECL|function|visitVariable
name|void
name|CollectVariables
operator|::
name|visitVariable
parameter_list|(
specifier|const
name|TIntermSymbol
modifier|*
name|variable
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|InterfaceBlock
argument_list|>
modifier|*
name|infoList
parameter_list|)
specifier|const
block|{
name|sh
operator|::
name|InterfaceBlock
name|interfaceBlock
decl_stmt|;
specifier|const
name|TInterfaceBlock
modifier|*
name|blockType
init|=
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|getInterfaceBlock
argument_list|()
decl_stmt|;
name|bool
name|isRowMajor
init|=
operator|(
name|blockType
operator|->
name|matrixPacking
argument_list|()
operator|==
name|EmpRowMajor
operator|)
decl_stmt|;
name|interfaceBlock
operator|.
name|name
operator|=
name|blockType
operator|->
name|name
argument_list|()
operator|.
name|c_str
argument_list|()
expr_stmt|;
name|interfaceBlock
operator|.
name|mappedName
operator|=
name|TIntermTraverser
operator|::
name|hash
argument_list|(
name|variable
operator|->
name|getSymbol
argument_list|()
argument_list|,
name|mHashFunction
argument_list|)
operator|.
name|c_str
argument_list|()
expr_stmt|;
name|interfaceBlock
operator|.
name|arraySize
operator|=
name|variable
operator|->
name|getArraySize
argument_list|()
expr_stmt|;
name|interfaceBlock
operator|.
name|isRowMajorLayout
operator|=
name|isRowMajor
expr_stmt|;
name|interfaceBlock
operator|.
name|layout
operator|=
name|sh
operator|::
name|GetBlockLayoutType
argument_list|(
name|blockType
operator|->
name|blockStorage
argument_list|()
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|blockType
argument_list|)
expr_stmt|;
specifier|const
name|TFieldList
modifier|&
name|blockFields
init|=
name|blockType
operator|->
name|fields
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|fieldIndex
init|=
literal|0
init|;
name|fieldIndex
operator|<
name|blockFields
operator|.
name|size
argument_list|()
condition|;
name|fieldIndex
operator|++
control|)
block|{
specifier|const
name|TField
modifier|*
name|field
init|=
name|blockFields
index|[
name|fieldIndex
index|]
decl_stmt|;
name|ASSERT
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|sh
operator|::
name|GetInterfaceBlockFieldTraverser
name|traverser
argument_list|(
operator|&
name|interfaceBlock
operator|.
name|fields
argument_list|,
name|isRowMajor
argument_list|)
decl_stmt|;
name|traverser
operator|.
name|traverse
argument_list|(
operator|*
name|field
operator|->
name|type
argument_list|()
argument_list|,
name|field
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|infoList
operator|->
name|push_back
argument_list|(
name|interfaceBlock
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|VarT
parameter_list|>
DECL|function|visitVariable
name|void
name|CollectVariables
operator|::
name|visitVariable
parameter_list|(
specifier|const
name|TIntermSymbol
modifier|*
name|variable
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|VarT
argument_list|>
modifier|*
name|infoList
parameter_list|)
specifier|const
block|{
name|NameHashingTraverser
argument_list|<
name|VarT
argument_list|>
name|traverser
argument_list|(
name|infoList
argument_list|,
name|mHashFunction
argument_list|)
decl_stmt|;
name|traverser
operator|.
name|traverse
argument_list|(
name|variable
operator|->
name|getType
argument_list|()
argument_list|,
name|variable
operator|->
name|getSymbol
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|VarT
parameter_list|>
DECL|function|visitInfoList
name|void
name|CollectVariables
operator|::
name|visitInfoList
parameter_list|(
specifier|const
name|TIntermSequence
modifier|&
name|sequence
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|VarT
argument_list|>
modifier|*
name|infoList
parameter_list|)
specifier|const
block|{
for|for
control|(
name|size_t
name|seqIndex
init|=
literal|0
init|;
name|seqIndex
operator|<
name|sequence
operator|.
name|size
argument_list|()
condition|;
name|seqIndex
operator|++
control|)
block|{
specifier|const
name|TIntermSymbol
modifier|*
name|variable
init|=
name|sequence
index|[
name|seqIndex
index|]
operator|->
name|getAsSymbolNode
argument_list|()
decl_stmt|;
comment|// The only case in which the sequence will not contain a
comment|// TIntermSymbol node is initialization. It will contain a
comment|// TInterBinary node in that case. Since attributes, uniforms,
comment|// and varyings cannot be initialized in a shader, we must have
comment|// only TIntermSymbol nodes in the sequence.
name|ASSERT
argument_list|(
name|variable
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|visitVariable
argument_list|(
name|variable
argument_list|,
name|infoList
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|visitAggregate
name|bool
name|CollectVariables
operator|::
name|visitAggregate
parameter_list|(
name|Visit
parameter_list|,
name|TIntermAggregate
modifier|*
name|node
parameter_list|)
block|{
name|bool
name|visitChildren
init|=
literal|true
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|getOp
argument_list|()
condition|)
block|{
case|case
name|EOpDeclaration
case|:
block|{
specifier|const
name|TIntermSequence
modifier|&
name|sequence
init|=
operator|*
operator|(
name|node
operator|->
name|getSequence
argument_list|()
operator|)
decl_stmt|;
specifier|const
name|TIntermTyped
modifier|&
name|typedNode
init|=
operator|*
operator|(
name|sequence
operator|.
name|front
argument_list|()
operator|->
name|getAsTyped
argument_list|()
operator|)
decl_stmt|;
name|TQualifier
name|qualifier
init|=
name|typedNode
operator|.
name|getQualifier
argument_list|()
decl_stmt|;
if|if
condition|(
name|typedNode
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtInterfaceBlock
condition|)
block|{
name|visitInfoList
argument_list|(
name|sequence
argument_list|,
name|mInterfaceBlocks
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qualifier
operator|==
name|EvqAttribute
operator|||
name|qualifier
operator|==
name|EvqVertexIn
operator|||
name|qualifier
operator|==
name|EvqFragmentOut
operator|||
name|qualifier
operator|==
name|EvqUniform
operator|||
name|sh
operator|::
name|IsVarying
argument_list|(
name|qualifier
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|qualifier
condition|)
block|{
case|case
name|EvqAttribute
case|:
case|case
name|EvqVertexIn
case|:
name|visitInfoList
argument_list|(
name|sequence
argument_list|,
name|mAttribs
argument_list|)
expr_stmt|;
break|break;
case|case
name|EvqFragmentOut
case|:
name|visitInfoList
argument_list|(
name|sequence
argument_list|,
name|mOutputVariables
argument_list|)
expr_stmt|;
break|break;
case|case
name|EvqUniform
case|:
name|visitInfoList
argument_list|(
name|sequence
argument_list|,
name|mUniforms
argument_list|)
expr_stmt|;
break|break;
default|default:
name|visitInfoList
argument_list|(
name|sequence
argument_list|,
name|mVaryings
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|sequence
operator|.
name|empty
argument_list|()
condition|)
block|{
name|visitChildren
operator|=
literal|false
expr_stmt|;
block|}
block|}
break|break;
block|}
default|default:
break|break;
block|}
return|return
name|visitChildren
return|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|VarT
parameter_list|>
DECL|function|ExpandVariables
name|void
name|ExpandVariables
parameter_list|(
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|VarT
argument_list|>
modifier|&
name|compact
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|VarT
argument_list|>
modifier|*
name|expanded
parameter_list|)
block|{
for|for
control|(
name|size_t
name|variableIndex
init|=
literal|0
init|;
name|variableIndex
operator|<
name|compact
operator|.
name|size
argument_list|()
condition|;
name|variableIndex
operator|++
control|)
block|{
specifier|const
name|VarT
modifier|&
name|variable
init|=
name|compact
index|[
name|variableIndex
index|]
decl_stmt|;
name|ExpandVariable
argument_list|(
name|variable
argument_list|,
name|variable
operator|.
name|name
argument_list|,
name|variable
operator|.
name|mappedName
argument_list|,
name|variable
operator|.
name|staticUse
argument_list|,
name|expanded
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function_decl
specifier|template
name|void
name|ExpandVariables
parameter_list|(
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|Uniform
argument_list|>
modifier|&
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|Uniform
argument_list|>
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|template
name|void
name|ExpandVariables
parameter_list|(
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|Varying
argument_list|>
modifier|&
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|Varying
argument_list|>
modifier|*
parameter_list|)
function_decl|;
end_function_decl
end_unit
