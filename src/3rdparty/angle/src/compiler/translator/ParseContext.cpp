begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|"compiler/translator/ParseContext.h"
end_include
begin_include
include|#
directive|include
file|<stdarg.h>
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|"compiler/preprocessor/SourceLocation.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/Cache.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/glslang.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/ValidateSwitch.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/ValidateGlobalInitializer.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/util.h"
end_include
begin_comment
comment|///////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Sub- vector and matrix fields
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Look at a '.' field selector string and change it into offsets
end_comment
begin_comment
comment|// for a vector.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|parseVectorFields
name|bool
name|TParseContext
operator|::
name|parseVectorFields
parameter_list|(
specifier|const
name|TString
modifier|&
name|compString
parameter_list|,
name|int
name|vecSize
parameter_list|,
name|TVectorFields
modifier|&
name|fields
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
name|fields
operator|.
name|num
operator|=
operator|(
name|int
operator|)
name|compString
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|fields
operator|.
name|num
operator|>
literal|4
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"illegal vector field selection"
argument_list|,
name|compString
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
enum|enum
block|{
name|exyzw
block|,
name|ergba
block|,
name|estpq
block|}
name|fieldSet
index|[
literal|4
index|]
enum|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|num
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|compString
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'x'
case|:
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|fieldSet
index|[
name|i
index|]
operator|=
name|exyzw
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|fieldSet
index|[
name|i
index|]
operator|=
name|ergba
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|fieldSet
index|[
name|i
index|]
operator|=
name|estpq
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|fieldSet
index|[
name|i
index|]
operator|=
name|exyzw
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|fieldSet
index|[
name|i
index|]
operator|=
name|ergba
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|fieldSet
index|[
name|i
index|]
operator|=
name|estpq
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|2
expr_stmt|;
name|fieldSet
index|[
name|i
index|]
operator|=
name|exyzw
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|2
expr_stmt|;
name|fieldSet
index|[
name|i
index|]
operator|=
name|ergba
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|2
expr_stmt|;
name|fieldSet
index|[
name|i
index|]
operator|=
name|estpq
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|3
expr_stmt|;
name|fieldSet
index|[
name|i
index|]
operator|=
name|exyzw
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|3
expr_stmt|;
name|fieldSet
index|[
name|i
index|]
operator|=
name|ergba
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|3
expr_stmt|;
name|fieldSet
index|[
name|i
index|]
operator|=
name|estpq
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
name|line
argument_list|,
literal|"illegal vector field selection"
argument_list|,
name|compString
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|num
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|>=
name|vecSize
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"vector field selection out of range"
argument_list|,
name|compString
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|fieldSet
index|[
name|i
index|]
operator|!=
name|fieldSet
index|[
name|i
operator|-
literal|1
index|]
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"illegal - vector component fields not from the same set"
argument_list|,
name|compString
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|///////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Errors
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Track whether errors have occurred.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|recover
name|void
name|TParseContext
operator|::
name|recover
parameter_list|()
block|{ }
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Used by flex/bison to output all syntax and parsing errors.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|error
name|void
name|TParseContext
operator|::
name|error
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|,
specifier|const
name|char
modifier|*
name|reason
parameter_list|,
specifier|const
name|char
modifier|*
name|token
parameter_list|,
specifier|const
name|char
modifier|*
name|extraInfo
parameter_list|)
block|{
name|pp
operator|::
name|SourceLocation
name|srcLoc
decl_stmt|;
name|srcLoc
operator|.
name|file
operator|=
name|loc
operator|.
name|first_file
expr_stmt|;
name|srcLoc
operator|.
name|line
operator|=
name|loc
operator|.
name|first_line
expr_stmt|;
name|mDiagnostics
operator|.
name|writeInfo
argument_list|(
name|pp
operator|::
name|Diagnostics
operator|::
name|PP_ERROR
argument_list|,
name|srcLoc
argument_list|,
name|reason
argument_list|,
name|token
argument_list|,
name|extraInfo
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|warning
name|void
name|TParseContext
operator|::
name|warning
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|,
specifier|const
name|char
modifier|*
name|reason
parameter_list|,
specifier|const
name|char
modifier|*
name|token
parameter_list|,
specifier|const
name|char
modifier|*
name|extraInfo
parameter_list|)
block|{
name|pp
operator|::
name|SourceLocation
name|srcLoc
decl_stmt|;
name|srcLoc
operator|.
name|file
operator|=
name|loc
operator|.
name|first_file
expr_stmt|;
name|srcLoc
operator|.
name|line
operator|=
name|loc
operator|.
name|first_line
expr_stmt|;
name|mDiagnostics
operator|.
name|writeInfo
argument_list|(
name|pp
operator|::
name|Diagnostics
operator|::
name|PP_WARNING
argument_list|,
name|srcLoc
argument_list|,
name|reason
argument_list|,
name|token
argument_list|,
name|extraInfo
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|outOfRangeError
name|void
name|TParseContext
operator|::
name|outOfRangeError
parameter_list|(
name|bool
name|isError
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|,
specifier|const
name|char
modifier|*
name|reason
parameter_list|,
specifier|const
name|char
modifier|*
name|token
parameter_list|,
specifier|const
name|char
modifier|*
name|extraInfo
parameter_list|)
block|{
if|if
condition|(
name|isError
condition|)
block|{
name|error
argument_list|(
name|loc
argument_list|,
name|reason
argument_list|,
name|token
argument_list|,
name|extraInfo
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
name|loc
argument_list|,
name|reason
argument_list|,
name|token
argument_list|,
name|extraInfo
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Same error message for all places assignments don't work.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|assignError
name|void
name|TParseContext
operator|::
name|assignError
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|op
parameter_list|,
name|TString
name|left
parameter_list|,
name|TString
name|right
parameter_list|)
block|{
name|std
operator|::
name|stringstream
name|extraInfoStream
decl_stmt|;
name|extraInfoStream
operator|<<
literal|"cannot convert from '"
operator|<<
name|right
operator|<<
literal|"' to '"
operator|<<
name|left
operator|<<
literal|"'"
expr_stmt|;
name|std
operator|::
name|string
name|extraInfo
init|=
name|extraInfoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|error
argument_list|(
name|line
argument_list|,
literal|""
argument_list|,
name|op
argument_list|,
name|extraInfo
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Same error message for all places unary operations don't work.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|unaryOpError
name|void
name|TParseContext
operator|::
name|unaryOpError
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|op
parameter_list|,
name|TString
name|operand
parameter_list|)
block|{
name|std
operator|::
name|stringstream
name|extraInfoStream
decl_stmt|;
name|extraInfoStream
operator|<<
literal|"no operation '"
operator|<<
name|op
operator|<<
literal|"' exists that takes an operand of type "
operator|<<
name|operand
operator|<<
literal|" (or there is no acceptable conversion)"
expr_stmt|;
name|std
operator|::
name|string
name|extraInfo
init|=
name|extraInfoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|error
argument_list|(
name|line
argument_list|,
literal|" wrong operand type"
argument_list|,
name|op
argument_list|,
name|extraInfo
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Same error message for all binary operations don't work.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|binaryOpError
name|void
name|TParseContext
operator|::
name|binaryOpError
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|op
parameter_list|,
name|TString
name|left
parameter_list|,
name|TString
name|right
parameter_list|)
block|{
name|std
operator|::
name|stringstream
name|extraInfoStream
decl_stmt|;
name|extraInfoStream
operator|<<
literal|"no operation '"
operator|<<
name|op
operator|<<
literal|"' exists that takes a left-hand operand of type '"
operator|<<
name|left
operator|<<
literal|"' and a right operand of type '"
operator|<<
name|right
operator|<<
literal|"' (or there is no acceptable conversion)"
expr_stmt|;
name|std
operator|::
name|string
name|extraInfo
init|=
name|extraInfoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|error
argument_list|(
name|line
argument_list|,
literal|" wrong operand types "
argument_list|,
name|op
argument_list|,
name|extraInfo
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|precisionErrorCheck
name|bool
name|TParseContext
operator|::
name|precisionErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
name|TPrecision
name|precision
parameter_list|,
name|TBasicType
name|type
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mChecksPrecisionErrors
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|precision
operator|==
name|EbpUndefined
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|EbtFloat
case|:
name|error
argument_list|(
name|line
argument_list|,
literal|"No precision specified for (float)"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
case|case
name|EbtInt
case|:
case|case
name|EbtUInt
case|:
name|UNREACHABLE
argument_list|()
expr_stmt|;
comment|// there's always a predeclared qualifier
name|error
argument_list|(
name|line
argument_list|,
literal|"No precision specified (int)"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
default|default:
if|if
condition|(
name|IsSampler
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"No precision specified (sampler)"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Both test and if necessary, spit out an error, to see if the node is really
end_comment
begin_comment
comment|// an l-value that can be operated on this way.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns true if the was an error.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|lValueErrorCheck
name|bool
name|TParseContext
operator|::
name|lValueErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|op
parameter_list|,
name|TIntermTyped
modifier|*
name|node
parameter_list|)
block|{
name|TIntermSymbol
modifier|*
name|symNode
init|=
name|node
operator|->
name|getAsSymbolNode
argument_list|()
decl_stmt|;
name|TIntermBinary
modifier|*
name|binaryNode
init|=
name|node
operator|->
name|getAsBinaryNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|binaryNode
condition|)
block|{
name|bool
name|errorReturn
decl_stmt|;
switch|switch
condition|(
name|binaryNode
operator|->
name|getOp
argument_list|()
condition|)
block|{
case|case
name|EOpIndexDirect
case|:
case|case
name|EOpIndexIndirect
case|:
case|case
name|EOpIndexDirectStruct
case|:
case|case
name|EOpIndexDirectInterfaceBlock
case|:
return|return
name|lValueErrorCheck
argument_list|(
name|line
argument_list|,
name|op
argument_list|,
name|binaryNode
operator|->
name|getLeft
argument_list|()
argument_list|)
return|;
case|case
name|EOpVectorSwizzle
case|:
name|errorReturn
operator|=
name|lValueErrorCheck
argument_list|(
name|line
argument_list|,
name|op
argument_list|,
name|binaryNode
operator|->
name|getLeft
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|errorReturn
condition|)
block|{
name|int
name|offset
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|TIntermTyped
modifier|*
name|rightNode
init|=
name|binaryNode
operator|->
name|getRight
argument_list|()
decl_stmt|;
name|TIntermAggregate
modifier|*
name|aggrNode
init|=
name|rightNode
operator|->
name|getAsAggregate
argument_list|()
decl_stmt|;
for|for
control|(
name|TIntermSequence
operator|::
name|iterator
name|p
init|=
name|aggrNode
operator|->
name|getSequence
argument_list|()
operator|->
name|begin
argument_list|()
init|;
name|p
operator|!=
name|aggrNode
operator|->
name|getSequence
argument_list|()
operator|->
name|end
argument_list|()
condition|;
name|p
operator|++
control|)
block|{
name|int
name|value
init|=
operator|(
operator|*
name|p
operator|)
operator|->
name|getAsTyped
argument_list|()
operator|->
name|getAsConstantUnion
argument_list|()
operator|->
name|getIConst
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|offset
index|[
name|value
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|offset
index|[
name|value
index|]
operator|>
literal|1
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|" l-value of swizzle cannot have duplicate components"
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
name|errorReturn
return|;
default|default:
break|break;
block|}
name|error
argument_list|(
name|line
argument_list|,
literal|" l-value required"
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|const
name|char
modifier|*
name|symbol
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|symNode
operator|!=
literal|0
condition|)
name|symbol
operator|=
name|symNode
operator|->
name|getSymbol
argument_list|()
operator|.
name|c_str
argument_list|()
expr_stmt|;
specifier|const
name|char
modifier|*
name|message
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|getQualifier
argument_list|()
condition|)
block|{
case|case
name|EvqConst
case|:
name|message
operator|=
literal|"can't modify a const"
expr_stmt|;
break|break;
case|case
name|EvqConstReadOnly
case|:
name|message
operator|=
literal|"can't modify a const"
expr_stmt|;
break|break;
case|case
name|EvqAttribute
case|:
name|message
operator|=
literal|"can't modify an attribute"
expr_stmt|;
break|break;
case|case
name|EvqFragmentIn
case|:
name|message
operator|=
literal|"can't modify an input"
expr_stmt|;
break|break;
case|case
name|EvqVertexIn
case|:
name|message
operator|=
literal|"can't modify an input"
expr_stmt|;
break|break;
case|case
name|EvqUniform
case|:
name|message
operator|=
literal|"can't modify a uniform"
expr_stmt|;
break|break;
case|case
name|EvqVaryingIn
case|:
name|message
operator|=
literal|"can't modify a varying"
expr_stmt|;
break|break;
case|case
name|EvqFragCoord
case|:
name|message
operator|=
literal|"can't modify gl_FragCoord"
expr_stmt|;
break|break;
case|case
name|EvqFrontFacing
case|:
name|message
operator|=
literal|"can't modify gl_FrontFacing"
expr_stmt|;
break|break;
case|case
name|EvqPointCoord
case|:
name|message
operator|=
literal|"can't modify gl_PointCoord"
expr_stmt|;
break|break;
default|default:
comment|//
comment|// Type that can't be written to?
comment|//
if|if
condition|(
name|node
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtVoid
condition|)
block|{
name|message
operator|=
literal|"can't modify void"
expr_stmt|;
block|}
if|if
condition|(
name|IsSampler
argument_list|(
name|node
operator|->
name|getBasicType
argument_list|()
argument_list|)
condition|)
block|{
name|message
operator|=
literal|"can't modify a sampler"
expr_stmt|;
block|}
block|}
if|if
condition|(
name|message
operator|==
literal|0
operator|&&
name|binaryNode
operator|==
literal|0
operator|&&
name|symNode
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|" l-value required"
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|//
comment|// Everything else is okay, no error.
comment|//
if|if
condition|(
name|message
operator|==
literal|0
condition|)
return|return
literal|false
return|;
comment|//
comment|// If we get here, we have an error and a message.
comment|//
if|if
condition|(
name|symNode
condition|)
block|{
name|std
operator|::
name|stringstream
name|extraInfoStream
decl_stmt|;
name|extraInfoStream
operator|<<
literal|"\""
operator|<<
name|symbol
operator|<<
literal|"\" ("
operator|<<
name|message
operator|<<
literal|")"
expr_stmt|;
name|std
operator|::
name|string
name|extraInfo
init|=
name|extraInfoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|error
argument_list|(
name|line
argument_list|,
literal|" l-value required"
argument_list|,
name|op
argument_list|,
name|extraInfo
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|std
operator|::
name|stringstream
name|extraInfoStream
decl_stmt|;
name|extraInfoStream
operator|<<
literal|"("
operator|<<
name|message
operator|<<
literal|")"
expr_stmt|;
name|std
operator|::
name|string
name|extraInfo
init|=
name|extraInfoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|error
argument_list|(
name|line
argument_list|,
literal|" l-value required"
argument_list|,
name|op
argument_list|,
name|extraInfo
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Both test, and if necessary spit out an error, to see if the node is really
end_comment
begin_comment
comment|// a constant.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns true if the was an error.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|constErrorCheck
name|bool
name|TParseContext
operator|::
name|constErrorCheck
parameter_list|(
name|TIntermTyped
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|->
name|getQualifier
argument_list|()
operator|==
name|EvqConst
condition|)
return|return
literal|false
return|;
name|error
argument_list|(
name|node
operator|->
name|getLine
argument_list|()
argument_list|,
literal|"constant expression required"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Both test, and if necessary spit out an error, to see if the node is really
end_comment
begin_comment
comment|// an integer.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns true if the was an error.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|integerErrorCheck
name|bool
name|TParseContext
operator|::
name|integerErrorCheck
parameter_list|(
name|TIntermTyped
modifier|*
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|token
parameter_list|)
block|{
if|if
condition|(
name|node
operator|->
name|isScalarInt
argument_list|()
condition|)
return|return
literal|false
return|;
name|error
argument_list|(
name|node
operator|->
name|getLine
argument_list|()
argument_list|,
literal|"integer expression required"
argument_list|,
name|token
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Both test, and if necessary spit out an error, to see if we are currently
end_comment
begin_comment
comment|// globally scoped.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns true if the was an error.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|globalErrorCheck
name|bool
name|TParseContext
operator|::
name|globalErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
name|bool
name|global
parameter_list|,
specifier|const
name|char
modifier|*
name|token
parameter_list|)
block|{
if|if
condition|(
name|global
condition|)
return|return
literal|false
return|;
name|error
argument_list|(
name|line
argument_list|,
literal|"only allowed at global scope"
argument_list|,
name|token
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// For now, keep it simple:  if it starts "gl_", it's reserved, independent
end_comment
begin_comment
comment|// of scope.  Except, if the symbol table is at the built-in push-level,
end_comment
begin_comment
comment|// which is when we are parsing built-ins.
end_comment
begin_comment
comment|// Also checks for "webgl_" and "_webgl_" reserved identifiers if parsing a
end_comment
begin_comment
comment|// webgl shader.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns true if there was an error.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|reservedErrorCheck
name|bool
name|TParseContext
operator|::
name|reservedErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
specifier|const
name|TString
modifier|&
name|identifier
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|reservedErrMsg
init|=
literal|"reserved built-in name"
decl_stmt|;
if|if
condition|(
operator|!
name|symbolTable
operator|.
name|atBuiltInLevel
argument_list|()
condition|)
block|{
if|if
condition|(
name|identifier
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|,
literal|"gl_"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
name|reservedErrMsg
argument_list|,
literal|"gl_"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|IsWebGLBasedSpec
argument_list|(
name|mShaderSpec
argument_list|)
condition|)
block|{
if|if
condition|(
name|identifier
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|6
argument_list|,
literal|"webgl_"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
name|reservedErrMsg
argument_list|,
literal|"webgl_"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|identifier
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|7
argument_list|,
literal|"_webgl_"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
name|reservedErrMsg
argument_list|,
literal|"_webgl_"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|mShaderSpec
operator|==
name|SH_CSS_SHADERS_SPEC
operator|&&
name|identifier
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|,
literal|"css_"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
name|reservedErrMsg
argument_list|,
literal|"css_"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
if|if
condition|(
name|identifier
operator|.
name|find
argument_list|(
literal|"__"
argument_list|)
operator|!=
name|TString
operator|::
name|npos
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"identifiers containing two consecutive underscores (__) are reserved as "
literal|"possible future keywords"
argument_list|,
name|identifier
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Make sure there is enough data provided to the constructor to build
end_comment
begin_comment
comment|// something of the type of the constructor.  Also returns the type of
end_comment
begin_comment
comment|// the constructor.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns true if there was an error in construction.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|constructorErrorCheck
name|bool
name|TParseContext
operator|::
name|constructorErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
name|TIntermNode
modifier|*
name|argumentsNode
parameter_list|,
name|TFunction
modifier|&
name|function
parameter_list|,
name|TOperator
name|op
parameter_list|,
name|TType
modifier|*
name|type
parameter_list|)
block|{
operator|*
name|type
operator|=
name|function
operator|.
name|getReturnType
argument_list|()
expr_stmt|;
name|bool
name|constructingMatrix
init|=
literal|false
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|EOpConstructMat2
case|:
case|case
name|EOpConstructMat2x3
case|:
case|case
name|EOpConstructMat2x4
case|:
case|case
name|EOpConstructMat3x2
case|:
case|case
name|EOpConstructMat3
case|:
case|case
name|EOpConstructMat3x4
case|:
case|case
name|EOpConstructMat4x2
case|:
case|case
name|EOpConstructMat4x3
case|:
case|case
name|EOpConstructMat4
case|:
name|constructingMatrix
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|//
comment|// Note: It's okay to have too many components available, but not okay to have unused
comment|// arguments.  'full' will go to true when enough args have been seen.  If we loop
comment|// again, there is an extra argument, so 'overfull' will become true.
comment|//
name|size_t
name|size
init|=
literal|0
decl_stmt|;
name|bool
name|constType
init|=
literal|true
decl_stmt|;
name|bool
name|full
init|=
literal|false
decl_stmt|;
name|bool
name|overFull
init|=
literal|false
decl_stmt|;
name|bool
name|matrixInMatrix
init|=
literal|false
decl_stmt|;
name|bool
name|arrayArg
init|=
literal|false
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|function
operator|.
name|getParamCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|TConstParameter
modifier|&
name|param
init|=
name|function
operator|.
name|getParam
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|size
operator|+=
name|param
operator|.
name|type
operator|->
name|getObjectSize
argument_list|()
expr_stmt|;
if|if
condition|(
name|constructingMatrix
operator|&&
name|param
operator|.
name|type
operator|->
name|isMatrix
argument_list|()
condition|)
name|matrixInMatrix
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|full
condition|)
name|overFull
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|op
operator|!=
name|EOpConstructStruct
operator|&&
operator|!
name|type
operator|->
name|isArray
argument_list|()
operator|&&
name|size
operator|>=
name|type
operator|->
name|getObjectSize
argument_list|()
condition|)
name|full
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|param
operator|.
name|type
operator|->
name|getQualifier
argument_list|()
operator|!=
name|EvqConst
condition|)
name|constType
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|param
operator|.
name|type
operator|->
name|isArray
argument_list|()
condition|)
name|arrayArg
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|constType
condition|)
name|type
operator|->
name|setQualifier
argument_list|(
name|EvqConst
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|->
name|isArray
argument_list|()
condition|)
block|{
if|if
condition|(
name|type
operator|->
name|isUnsizedArray
argument_list|()
condition|)
block|{
name|type
operator|->
name|setArraySize
argument_list|(
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|function
operator|.
name|getParamCount
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|type
operator|->
name|getArraySize
argument_list|()
argument_list|)
operator|!=
name|function
operator|.
name|getParamCount
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"array constructor needs one argument per array element"
argument_list|,
literal|"constructor"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
if|if
condition|(
name|arrayArg
operator|&&
name|op
operator|!=
name|EOpConstructStruct
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"constructing from a non-dereferenced array"
argument_list|,
literal|"constructor"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|matrixInMatrix
operator|&&
operator|!
name|type
operator|->
name|isArray
argument_list|()
condition|)
block|{
if|if
condition|(
name|function
operator|.
name|getParamCount
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"constructing matrix from matrix can only take one argument"
argument_list|,
literal|"constructor"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
if|if
condition|(
name|overFull
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"too many arguments"
argument_list|,
literal|"constructor"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|op
operator|==
name|EOpConstructStruct
operator|&&
operator|!
name|type
operator|->
name|isArray
argument_list|()
operator|&&
name|type
operator|->
name|getStruct
argument_list|()
operator|->
name|fields
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
name|function
operator|.
name|getParamCount
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"Number of constructor parameters does not match the number of structure fields"
argument_list|,
literal|"constructor"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|type
operator|->
name|isMatrix
argument_list|()
operator|||
operator|!
name|matrixInMatrix
condition|)
block|{
if|if
condition|(
operator|(
name|op
operator|!=
name|EOpConstructStruct
operator|&&
name|size
operator|!=
literal|1
operator|&&
name|size
operator|<
name|type
operator|->
name|getObjectSize
argument_list|()
operator|)
operator|||
operator|(
name|op
operator|==
name|EOpConstructStruct
operator|&&
name|size
operator|<
name|type
operator|->
name|getObjectSize
argument_list|()
operator|)
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"not enough data provided for construction"
argument_list|,
literal|"constructor"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
if|if
condition|(
name|argumentsNode
operator|==
literal|nullptr
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"constructor does not have any arguments"
argument_list|,
literal|"constructor"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|TIntermAggregate
modifier|*
name|argumentsAgg
init|=
name|argumentsNode
operator|->
name|getAsAggregate
argument_list|()
decl_stmt|;
for|for
control|(
name|TIntermNode
modifier|*
modifier|&
name|argNode
range|:
operator|*
name|argumentsAgg
operator|->
name|getSequence
argument_list|()
control|)
block|{
name|TIntermTyped
modifier|*
name|argTyped
init|=
name|argNode
operator|->
name|getAsTyped
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|argTyped
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|!=
name|EOpConstructStruct
operator|&&
name|IsSampler
argument_list|(
name|argTyped
operator|->
name|getBasicType
argument_list|()
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"cannot convert a sampler"
argument_list|,
literal|"constructor"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|argTyped
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtVoid
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"cannot convert a void"
argument_list|,
literal|"constructor"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|// This function checks to see if a void variable has been declared and raise an error message for
end_comment
begin_comment
comment|// such a case
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// returns true in case of an error
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|voidErrorCheck
name|bool
name|TParseContext
operator|::
name|voidErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
specifier|const
name|TString
modifier|&
name|identifier
parameter_list|,
specifier|const
name|TBasicType
modifier|&
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|EbtVoid
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"illegal use of type 'void'"
argument_list|,
name|identifier
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|// This function checks to see if the node (for the expression) contains a scalar boolean expression
end_comment
begin_comment
comment|// or not
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// returns true in case of an error
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|boolErrorCheck
name|bool
name|TParseContext
operator|::
name|boolErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
specifier|const
name|TIntermTyped
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|->
name|getBasicType
argument_list|()
operator|!=
name|EbtBool
operator|||
name|type
operator|->
name|isArray
argument_list|()
operator|||
name|type
operator|->
name|isMatrix
argument_list|()
operator|||
name|type
operator|->
name|isVector
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"boolean expression expected"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|// This function checks to see if the node (for the expression) contains a scalar boolean expression
end_comment
begin_comment
comment|// or not
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// returns true in case of an error
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|boolErrorCheck
name|bool
name|TParseContext
operator|::
name|boolErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
specifier|const
name|TPublicType
modifier|&
name|pType
parameter_list|)
block|{
if|if
condition|(
name|pType
operator|.
name|type
operator|!=
name|EbtBool
operator|||
name|pType
operator|.
name|isAggregate
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"boolean expression expected"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|samplerErrorCheck
name|bool
name|TParseContext
operator|::
name|samplerErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
specifier|const
name|TPublicType
modifier|&
name|pType
parameter_list|,
specifier|const
name|char
modifier|*
name|reason
parameter_list|)
block|{
if|if
condition|(
name|pType
operator|.
name|type
operator|==
name|EbtStruct
condition|)
block|{
if|if
condition|(
name|containsSampler
argument_list|(
operator|*
name|pType
operator|.
name|userDef
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
name|reason
argument_list|,
name|getBasicString
argument_list|(
name|pType
operator|.
name|type
argument_list|)
argument_list|,
literal|"(structure contains a sampler)"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|IsSampler
argument_list|(
name|pType
operator|.
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
name|reason
argument_list|,
name|getBasicString
argument_list|(
name|pType
operator|.
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|locationDeclaratorListCheck
name|bool
name|TParseContext
operator|::
name|locationDeclaratorListCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
specifier|const
name|TPublicType
modifier|&
name|pType
parameter_list|)
block|{
if|if
condition|(
name|pType
operator|.
name|layoutQualifier
operator|.
name|location
operator|!=
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"location must only be specified for a single input or output variable"
argument_list|,
literal|"location"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|parameterSamplerErrorCheck
name|bool
name|TParseContext
operator|::
name|parameterSamplerErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
name|TQualifier
name|qualifier
parameter_list|,
specifier|const
name|TType
modifier|&
name|type
parameter_list|)
block|{
if|if
condition|(
operator|(
name|qualifier
operator|==
name|EvqOut
operator|||
name|qualifier
operator|==
name|EvqInOut
operator|)
operator|&&
name|type
operator|.
name|getBasicType
argument_list|()
operator|!=
name|EbtStruct
operator|&&
name|IsSampler
argument_list|(
name|type
operator|.
name|getBasicType
argument_list|()
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"samplers cannot be output parameters"
argument_list|,
name|type
operator|.
name|getBasicString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|containsSampler
name|bool
name|TParseContext
operator|::
name|containsSampler
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|)
block|{
if|if
condition|(
name|IsSampler
argument_list|(
name|type
operator|.
name|getBasicType
argument_list|()
argument_list|)
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|type
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtStruct
operator|||
name|type
operator|.
name|isInterfaceBlock
argument_list|()
condition|)
block|{
specifier|const
name|TFieldList
modifier|&
name|fields
init|=
name|type
operator|.
name|getStruct
argument_list|()
operator|->
name|fields
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|containsSampler
argument_list|(
operator|*
name|fields
index|[
name|i
index|]
operator|->
name|type
argument_list|()
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Do size checking for an array type's size.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns true if there was an error.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|arraySizeErrorCheck
name|bool
name|TParseContext
operator|::
name|arraySizeErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
name|TIntermTyped
modifier|*
name|expr
parameter_list|,
name|int
modifier|&
name|size
parameter_list|)
block|{
name|TIntermConstantUnion
modifier|*
name|constant
init|=
name|expr
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
comment|// TODO(oetuaho@nvidia.com): Get rid of the constant == nullptr check here once all constant
comment|// expressions can be folded. Right now we don't allow constant expressions that ANGLE can't
comment|// fold as array size.
if|if
condition|(
name|expr
operator|->
name|getQualifier
argument_list|()
operator|!=
name|EvqConst
operator|||
name|constant
operator|==
literal|nullptr
operator|||
operator|!
name|constant
operator|->
name|isScalarInt
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"array size must be a constant integer expression"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
return|return
literal|true
return|;
block|}
name|unsigned
name|int
name|unsignedSize
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|constant
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtUInt
condition|)
block|{
name|unsignedSize
operator|=
name|constant
operator|->
name|getUConst
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|size
operator|=
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|unsignedSize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size
operator|=
name|constant
operator|->
name|getIConst
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"array size must be non-negative"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
return|return
literal|true
return|;
block|}
name|unsignedSize
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"array size must be greater than zero"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// The size of arrays is restricted here to prevent issues further down the
comment|// compiler/translator/driver stack. Shader Model 5 generation hardware is limited to
comment|// 4096 registers so this should be reasonable even for aggressively optimizable code.
specifier|const
name|unsigned
name|int
name|sizeLimit
init|=
literal|65536
decl_stmt|;
if|if
condition|(
name|unsignedSize
operator|>
name|sizeLimit
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"array size too large"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// See if this qualifier can be an array.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns true if there is an error.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|arrayQualifierErrorCheck
name|bool
name|TParseContext
operator|::
name|arrayQualifierErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
specifier|const
name|TPublicType
modifier|&
name|type
parameter_list|)
block|{
if|if
condition|(
operator|(
name|type
operator|.
name|qualifier
operator|==
name|EvqAttribute
operator|)
operator|||
operator|(
name|type
operator|.
name|qualifier
operator|==
name|EvqVertexIn
operator|)
operator|||
operator|(
name|type
operator|.
name|qualifier
operator|==
name|EvqConst
operator|&&
name|mShaderVersion
operator|<
literal|300
operator|)
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"cannot declare arrays of this qualifier"
argument_list|,
name|TType
argument_list|(
name|type
argument_list|)
operator|.
name|getCompleteString
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// See if this type can be an array.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns true if there is an error.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|arrayTypeErrorCheck
name|bool
name|TParseContext
operator|::
name|arrayTypeErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
specifier|const
name|TPublicType
modifier|&
name|type
parameter_list|)
block|{
comment|//
comment|// Can the type be an array?
comment|//
if|if
condition|(
name|type
operator|.
name|array
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"cannot declare arrays of arrays"
argument_list|,
name|TType
argument_list|(
name|type
argument_list|)
operator|.
name|getCompleteString
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// In ESSL1.00 shaders, structs cannot be varying (section 4.3.5). This is checked elsewhere.
comment|// In ESSL3.00 shaders, struct inputs/outputs are allowed but not arrays of structs (section
comment|// 4.3.4).
if|if
condition|(
name|mShaderVersion
operator|>=
literal|300
operator|&&
name|type
operator|.
name|type
operator|==
name|EbtStruct
operator|&&
name|sh
operator|::
name|IsVarying
argument_list|(
name|type
operator|.
name|qualifier
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"cannot declare arrays of structs of this qualifier"
argument_list|,
name|TType
argument_list|(
name|type
argument_list|)
operator|.
name|getCompleteString
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Enforce non-initializer type/qualifier rules.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns true if there was an error.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|nonInitErrorCheck
name|bool
name|TParseContext
operator|::
name|nonInitErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
specifier|const
name|TString
modifier|&
name|identifier
parameter_list|,
name|TPublicType
modifier|*
name|type
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|type
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|->
name|qualifier
operator|==
name|EvqConst
condition|)
block|{
comment|// Make the qualifier make sense.
name|type
operator|->
name|qualifier
operator|=
name|EvqTemporary
expr_stmt|;
comment|// Generate informative error messages for ESSL1.
comment|// In ESSL3 arrays and structures containing arrays can be constant.
if|if
condition|(
name|mShaderVersion
operator|<
literal|300
operator|&&
name|type
operator|->
name|isStructureContainingArrays
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"structures containing arrays may not be declared constant since they cannot be "
literal|"initialized"
argument_list|,
name|identifier
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"variables with qualifier 'const' must be initialized"
argument_list|,
name|identifier
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
if|if
condition|(
name|type
operator|->
name|isUnsizedArray
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"implicitly sized arrays need to be initialized"
argument_list|,
name|identifier
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|// Do some simple checks that are shared between all variable declarations,
end_comment
begin_comment
comment|// and update the symbol table.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns true if declaring the variable succeeded.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|declareVariable
name|bool
name|TParseContext
operator|::
name|declareVariable
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
specifier|const
name|TString
modifier|&
name|identifier
parameter_list|,
specifier|const
name|TType
modifier|&
name|type
parameter_list|,
name|TVariable
modifier|*
modifier|*
name|variable
parameter_list|)
block|{
name|ASSERT
argument_list|(
operator|(
operator|*
name|variable
operator|)
operator|==
literal|nullptr
argument_list|)
expr_stmt|;
name|bool
name|needsReservedErrorCheck
init|=
literal|true
decl_stmt|;
comment|// gl_LastFragData may be redeclared with a new precision qualifier
if|if
condition|(
name|type
operator|.
name|isArray
argument_list|()
operator|&&
name|identifier
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|15
argument_list|,
literal|"gl_LastFragData"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|TVariable
modifier|*
name|maxDrawBuffers
init|=
cast|static_cast
argument_list|<
specifier|const
name|TVariable
operator|*
argument_list|>
argument_list|(
name|symbolTable
operator|.
name|findBuiltIn
argument_list|(
literal|"gl_MaxDrawBuffers"
argument_list|,
name|mShaderVersion
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|getArraySize
argument_list|()
operator|==
name|maxDrawBuffers
operator|->
name|getConstPointer
argument_list|()
operator|->
name|getIConst
argument_list|()
condition|)
block|{
if|if
condition|(
name|TSymbol
modifier|*
name|builtInSymbol
init|=
name|symbolTable
operator|.
name|findBuiltIn
argument_list|(
name|identifier
argument_list|,
name|mShaderVersion
argument_list|)
condition|)
block|{
name|needsReservedErrorCheck
operator|=
name|extensionErrorCheck
argument_list|(
name|line
argument_list|,
name|builtInSymbol
operator|->
name|getExtension
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"redeclaration of gl_LastFragData with size != gl_MaxDrawBuffers"
argument_list|,
name|identifier
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|needsReservedErrorCheck
operator|&&
name|reservedErrorCheck
argument_list|(
name|line
argument_list|,
name|identifier
argument_list|)
condition|)
return|return
literal|false
return|;
operator|(
operator|*
name|variable
operator|)
operator|=
operator|new
name|TVariable
argument_list|(
operator|&
name|identifier
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|symbolTable
operator|.
name|declare
argument_list|(
operator|*
name|variable
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"redefinition"
argument_list|,
name|identifier
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
operator|*
name|variable
operator|=
literal|nullptr
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|voidErrorCheck
argument_list|(
name|line
argument_list|,
name|identifier
argument_list|,
name|type
operator|.
name|getBasicType
argument_list|()
argument_list|)
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|paramErrorCheck
name|bool
name|TParseContext
operator|::
name|paramErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
name|TQualifier
name|qualifier
parameter_list|,
name|TQualifier
name|paramQualifier
parameter_list|,
name|TType
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
name|qualifier
operator|!=
name|EvqConst
operator|&&
name|qualifier
operator|!=
name|EvqTemporary
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"qualifier not allowed on function parameter"
argument_list|,
name|getQualifierString
argument_list|(
name|qualifier
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|qualifier
operator|==
name|EvqConst
operator|&&
name|paramQualifier
operator|!=
name|EvqIn
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"qualifier not allowed with "
argument_list|,
name|getQualifierString
argument_list|(
name|qualifier
argument_list|)
argument_list|,
name|getQualifierString
argument_list|(
name|paramQualifier
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|qualifier
operator|==
name|EvqConst
condition|)
name|type
operator|->
name|setQualifier
argument_list|(
name|EvqConstReadOnly
argument_list|)
expr_stmt|;
else|else
name|type
operator|->
name|setQualifier
argument_list|(
name|paramQualifier
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|extensionErrorCheck
name|bool
name|TParseContext
operator|::
name|extensionErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
specifier|const
name|TString
modifier|&
name|extension
parameter_list|)
block|{
specifier|const
name|TExtensionBehavior
modifier|&
name|extBehavior
init|=
name|extensionBehavior
argument_list|()
decl_stmt|;
name|TExtensionBehavior
operator|::
name|const_iterator
name|iter
init|=
name|extBehavior
operator|.
name|find
argument_list|(
name|extension
operator|.
name|c_str
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|iter
operator|==
name|extBehavior
operator|.
name|end
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"extension"
argument_list|,
name|extension
operator|.
name|c_str
argument_list|()
argument_list|,
literal|"is not supported"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// In GLSL ES, an extension's default behavior is "disable".
if|if
condition|(
name|iter
operator|->
name|second
operator|==
name|EBhDisable
operator|||
name|iter
operator|->
name|second
operator|==
name|EBhUndefined
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"extension"
argument_list|,
name|extension
operator|.
name|c_str
argument_list|()
argument_list|,
literal|"is disabled"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|iter
operator|->
name|second
operator|==
name|EBhWarn
condition|)
block|{
name|warning
argument_list|(
name|line
argument_list|,
literal|"extension"
argument_list|,
name|extension
operator|.
name|c_str
argument_list|()
argument_list|,
literal|"is being used"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|// These checks are common for all declarations starting a declarator list, and declarators that
end_comment
begin_comment
comment|// follow an empty declaration.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|singleDeclarationErrorCheck
name|bool
name|TParseContext
operator|::
name|singleDeclarationErrorCheck
parameter_list|(
specifier|const
name|TPublicType
modifier|&
name|publicType
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|identifierLocation
parameter_list|)
block|{
switch|switch
condition|(
name|publicType
operator|.
name|qualifier
condition|)
block|{
case|case
name|EvqVaryingIn
case|:
case|case
name|EvqVaryingOut
case|:
case|case
name|EvqAttribute
case|:
case|case
name|EvqVertexIn
case|:
case|case
name|EvqFragmentOut
case|:
if|if
condition|(
name|publicType
operator|.
name|type
operator|==
name|EbtStruct
condition|)
block|{
name|error
argument_list|(
name|identifierLocation
argument_list|,
literal|"cannot be used with a structure"
argument_list|,
name|getQualifierString
argument_list|(
name|publicType
operator|.
name|qualifier
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
default|default:
break|break;
block|}
if|if
condition|(
name|publicType
operator|.
name|qualifier
operator|!=
name|EvqUniform
operator|&&
name|samplerErrorCheck
argument_list|(
name|identifierLocation
argument_list|,
name|publicType
argument_list|,
literal|"samplers must be uniform"
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// check for layout qualifier issues
specifier|const
name|TLayoutQualifier
name|layoutQualifier
init|=
name|publicType
operator|.
name|layoutQualifier
decl_stmt|;
if|if
condition|(
name|layoutQualifier
operator|.
name|matrixPacking
operator|!=
name|EmpUnspecified
condition|)
block|{
name|error
argument_list|(
name|identifierLocation
argument_list|,
literal|"layout qualifier"
argument_list|,
name|getMatrixPackingString
argument_list|(
name|layoutQualifier
operator|.
name|matrixPacking
argument_list|)
argument_list|,
literal|"only valid for interface blocks"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|layoutQualifier
operator|.
name|blockStorage
operator|!=
name|EbsUnspecified
condition|)
block|{
name|error
argument_list|(
name|identifierLocation
argument_list|,
literal|"layout qualifier"
argument_list|,
name|getBlockStorageString
argument_list|(
name|layoutQualifier
operator|.
name|blockStorage
argument_list|)
argument_list|,
literal|"only valid for interface blocks"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|publicType
operator|.
name|qualifier
operator|!=
name|EvqVertexIn
operator|&&
name|publicType
operator|.
name|qualifier
operator|!=
name|EvqFragmentOut
operator|&&
name|layoutLocationErrorCheck
argument_list|(
name|identifierLocation
argument_list|,
name|publicType
operator|.
name|layoutQualifier
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|layoutLocationErrorCheck
name|bool
name|TParseContext
operator|::
name|layoutLocationErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|location
parameter_list|,
specifier|const
name|TLayoutQualifier
modifier|&
name|layoutQualifier
parameter_list|)
block|{
if|if
condition|(
name|layoutQualifier
operator|.
name|location
operator|!=
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
name|location
argument_list|,
literal|"invalid layout qualifier:"
argument_list|,
literal|"location"
argument_list|,
literal|"only valid on program inputs and outputs"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|functionCallLValueErrorCheck
name|bool
name|TParseContext
operator|::
name|functionCallLValueErrorCheck
parameter_list|(
specifier|const
name|TFunction
modifier|*
name|fnCandidate
parameter_list|,
name|TIntermAggregate
modifier|*
name|aggregate
parameter_list|)
block|{
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fnCandidate
operator|->
name|getParamCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|TQualifier
name|qual
init|=
name|fnCandidate
operator|->
name|getParam
argument_list|(
name|i
argument_list|)
operator|.
name|type
operator|->
name|getQualifier
argument_list|()
decl_stmt|;
if|if
condition|(
name|qual
operator|==
name|EvqOut
operator|||
name|qual
operator|==
name|EvqInOut
condition|)
block|{
name|TIntermTyped
modifier|*
name|node
init|=
operator|(
operator|*
operator|(
name|aggregate
operator|->
name|getSequence
argument_list|()
operator|)
operator|)
index|[
name|i
index|]
operator|->
name|getAsTyped
argument_list|()
decl_stmt|;
if|if
condition|(
name|lValueErrorCheck
argument_list|(
name|node
operator|->
name|getLine
argument_list|()
argument_list|,
literal|"assign"
argument_list|,
name|node
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|node
operator|->
name|getLine
argument_list|()
argument_list|,
literal|"Constant value cannot be passed for 'out' or 'inout' parameters."
argument_list|,
literal|"Error"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|es3InvariantErrorCheck
name|void
name|TParseContext
operator|::
name|es3InvariantErrorCheck
parameter_list|(
specifier|const
name|TQualifier
name|qualifier
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|invariantLocation
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sh
operator|::
name|IsVaryingOut
argument_list|(
name|qualifier
argument_list|)
operator|&&
name|qualifier
operator|!=
name|EvqFragmentOut
condition|)
block|{
name|error
argument_list|(
name|invariantLocation
argument_list|,
literal|"Only out variables can be invariant."
argument_list|,
literal|"invariant"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|supportsExtension
name|bool
name|TParseContext
operator|::
name|supportsExtension
parameter_list|(
specifier|const
name|char
modifier|*
name|extension
parameter_list|)
block|{
specifier|const
name|TExtensionBehavior
modifier|&
name|extbehavior
init|=
name|extensionBehavior
argument_list|()
decl_stmt|;
name|TExtensionBehavior
operator|::
name|const_iterator
name|iter
init|=
name|extbehavior
operator|.
name|find
argument_list|(
name|extension
argument_list|)
decl_stmt|;
return|return
operator|(
name|iter
operator|!=
name|extbehavior
operator|.
name|end
argument_list|()
operator|)
return|;
block|}
end_function
begin_function
DECL|function|isExtensionEnabled
name|bool
name|TParseContext
operator|::
name|isExtensionEnabled
parameter_list|(
specifier|const
name|char
modifier|*
name|extension
parameter_list|)
specifier|const
block|{
return|return
operator|::
name|IsExtensionEnabled
argument_list|(
name|extensionBehavior
argument_list|()
argument_list|,
name|extension
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|handleExtensionDirective
name|void
name|TParseContext
operator|::
name|handleExtensionDirective
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|,
specifier|const
name|char
modifier|*
name|extName
parameter_list|,
specifier|const
name|char
modifier|*
name|behavior
parameter_list|)
block|{
name|pp
operator|::
name|SourceLocation
name|srcLoc
decl_stmt|;
name|srcLoc
operator|.
name|file
operator|=
name|loc
operator|.
name|first_file
expr_stmt|;
name|srcLoc
operator|.
name|line
operator|=
name|loc
operator|.
name|first_line
expr_stmt|;
name|mDirectiveHandler
operator|.
name|handleExtension
argument_list|(
name|srcLoc
argument_list|,
name|extName
argument_list|,
name|behavior
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|handlePragmaDirective
name|void
name|TParseContext
operator|::
name|handlePragmaDirective
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|bool
name|stdgl
parameter_list|)
block|{
name|pp
operator|::
name|SourceLocation
name|srcLoc
decl_stmt|;
name|srcLoc
operator|.
name|file
operator|=
name|loc
operator|.
name|first_file
expr_stmt|;
name|srcLoc
operator|.
name|line
operator|=
name|loc
operator|.
name|first_line
expr_stmt|;
name|mDirectiveHandler
operator|.
name|handlePragma
argument_list|(
name|srcLoc
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|stdgl
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/////////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Non-Errors.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|/////////////////////////////////////////////////////////////////////////////////
end_comment
begin_function
DECL|function|getNamedVariable
specifier|const
name|TVariable
modifier|*
name|TParseContext
operator|::
name|getNamedVariable
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|location
parameter_list|,
specifier|const
name|TString
modifier|*
name|name
parameter_list|,
specifier|const
name|TSymbol
modifier|*
name|symbol
parameter_list|)
block|{
specifier|const
name|TVariable
modifier|*
name|variable
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|symbol
condition|)
block|{
name|error
argument_list|(
name|location
argument_list|,
literal|"undeclared identifier"
argument_list|,
name|name
operator|->
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|symbol
operator|->
name|isVariable
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|location
argument_list|,
literal|"variable expected"
argument_list|,
name|name
operator|->
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|variable
operator|=
cast|static_cast
argument_list|<
specifier|const
name|TVariable
operator|*
argument_list|>
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbolTable
operator|.
name|findBuiltIn
argument_list|(
name|variable
operator|->
name|getName
argument_list|()
argument_list|,
name|mShaderVersion
argument_list|)
operator|&&
operator|!
name|variable
operator|->
name|getExtension
argument_list|()
operator|.
name|empty
argument_list|()
operator|&&
name|extensionErrorCheck
argument_list|(
name|location
argument_list|,
name|variable
operator|->
name|getExtension
argument_list|()
argument_list|)
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
block|}
comment|// Reject shaders using both gl_FragData and gl_FragColor
name|TQualifier
name|qualifier
init|=
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|getQualifier
argument_list|()
decl_stmt|;
if|if
condition|(
name|qualifier
operator|==
name|EvqFragData
operator|||
name|qualifier
operator|==
name|EvqSecondaryFragDataEXT
condition|)
block|{
name|mUsesFragData
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qualifier
operator|==
name|EvqFragColor
operator|||
name|qualifier
operator|==
name|EvqSecondaryFragColorEXT
condition|)
block|{
name|mUsesFragColor
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|qualifier
operator|==
name|EvqSecondaryFragDataEXT
operator|||
name|qualifier
operator|==
name|EvqSecondaryFragColorEXT
condition|)
block|{
name|mUsesSecondaryOutputs
operator|=
literal|true
expr_stmt|;
block|}
comment|// This validation is not quite correct - it's only an error to write to
comment|// both FragData and FragColor. For simplicity, and because users shouldn't
comment|// be rewarded for reading from undefined varaibles, return an error
comment|// if they are both referenced, rather than assigned.
if|if
condition|(
name|mUsesFragData
operator|&&
name|mUsesFragColor
condition|)
block|{
specifier|const
name|char
modifier|*
name|errorMessage
init|=
literal|"cannot use both gl_FragData and gl_FragColor"
decl_stmt|;
if|if
condition|(
name|mUsesSecondaryOutputs
condition|)
block|{
name|errorMessage
operator|=
literal|"cannot use both output variable sets (gl_FragData, gl_SecondaryFragDataEXT)"
literal|" and (gl_FragColor, gl_SecondaryFragColorEXT)"
expr_stmt|;
block|}
name|error
argument_list|(
name|location
argument_list|,
name|errorMessage
argument_list|,
name|name
operator|->
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|variable
condition|)
block|{
name|TType
name|type
argument_list|(
name|EbtFloat
argument_list|,
name|EbpUndefined
argument_list|)
decl_stmt|;
name|TVariable
modifier|*
name|fakeVariable
init|=
operator|new
name|TVariable
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|symbolTable
operator|.
name|declare
argument_list|(
name|fakeVariable
argument_list|)
expr_stmt|;
name|variable
operator|=
name|fakeVariable
expr_stmt|;
block|}
return|return
name|variable
return|;
block|}
end_function
begin_function
DECL|function|parseVariableIdentifier
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|parseVariableIdentifier
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|location
parameter_list|,
specifier|const
name|TString
modifier|*
name|name
parameter_list|,
specifier|const
name|TSymbol
modifier|*
name|symbol
parameter_list|)
block|{
specifier|const
name|TVariable
modifier|*
name|variable
init|=
name|getNamedVariable
argument_list|(
name|location
argument_list|,
name|name
argument_list|,
name|symbol
argument_list|)
decl_stmt|;
if|if
condition|(
name|variable
operator|->
name|getConstPointer
argument_list|()
condition|)
block|{
specifier|const
name|TConstantUnion
modifier|*
name|constArray
init|=
name|variable
operator|->
name|getConstPointer
argument_list|()
decl_stmt|;
return|return
name|intermediate
operator|.
name|addConstantUnion
argument_list|(
name|constArray
argument_list|,
name|variable
operator|->
name|getType
argument_list|()
argument_list|,
name|location
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|intermediate
operator|.
name|addSymbol
argument_list|(
name|variable
operator|->
name|getUniqueId
argument_list|()
argument_list|,
name|variable
operator|->
name|getName
argument_list|()
argument_list|,
name|variable
operator|->
name|getType
argument_list|()
argument_list|,
name|location
argument_list|)
return|;
block|}
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Look up a function name in the symbol table, and make sure it is a function.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Return the function symbol if found, otherwise 0.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|findFunction
specifier|const
name|TFunction
modifier|*
name|TParseContext
operator|::
name|findFunction
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
name|TFunction
modifier|*
name|call
parameter_list|,
name|int
name|inputShaderVersion
parameter_list|,
name|bool
modifier|*
name|builtIn
parameter_list|)
block|{
comment|// First find by unmangled name to check whether the function name has been
comment|// hidden by a variable name or struct typename.
comment|// If a function is found, check for one with a matching argument list.
specifier|const
name|TSymbol
modifier|*
name|symbol
init|=
name|symbolTable
operator|.
name|find
argument_list|(
name|call
operator|->
name|getName
argument_list|()
argument_list|,
name|inputShaderVersion
argument_list|,
name|builtIn
argument_list|)
decl_stmt|;
if|if
condition|(
name|symbol
operator|==
literal|0
operator|||
name|symbol
operator|->
name|isFunction
argument_list|()
condition|)
block|{
name|symbol
operator|=
name|symbolTable
operator|.
name|find
argument_list|(
name|call
operator|->
name|getMangledName
argument_list|()
argument_list|,
name|inputShaderVersion
argument_list|,
name|builtIn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|symbol
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"no matching overloaded function found"
argument_list|,
name|call
operator|->
name|getName
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|symbol
operator|->
name|isFunction
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"function name expected"
argument_list|,
name|call
operator|->
name|getName
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
cast|static_cast
argument_list|<
specifier|const
name|TFunction
operator|*
argument_list|>
argument_list|(
name|symbol
argument_list|)
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Initializers show up in several places in the grammar.  Have one set of
end_comment
begin_comment
comment|// code to handle them here.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns true on error, false if no error
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|executeInitializer
name|bool
name|TParseContext
operator|::
name|executeInitializer
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
specifier|const
name|TString
modifier|&
name|identifier
parameter_list|,
specifier|const
name|TPublicType
modifier|&
name|pType
parameter_list|,
name|TIntermTyped
modifier|*
name|initializer
parameter_list|,
name|TIntermNode
modifier|*
modifier|*
name|intermNode
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|intermNode
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
name|TType
name|type
init|=
name|TType
argument_list|(
name|pType
argument_list|)
decl_stmt|;
name|TVariable
modifier|*
name|variable
init|=
literal|nullptr
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|isUnsizedArray
argument_list|()
condition|)
block|{
name|type
operator|.
name|setArraySize
argument_list|(
name|initializer
operator|->
name|getArraySize
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|declareVariable
argument_list|(
name|line
argument_list|,
name|identifier
argument_list|,
name|type
argument_list|,
operator|&
name|variable
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
name|bool
name|globalInitWarning
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|symbolTable
operator|.
name|atGlobalLevel
argument_list|()
operator|&&
operator|!
name|ValidateGlobalInitializer
argument_list|(
name|initializer
argument_list|,
name|this
argument_list|,
operator|&
name|globalInitWarning
argument_list|)
condition|)
block|{
comment|// Error message does not completely match behavior with ESSL 1.00, but
comment|// we want to steer developers towards only using constant expressions.
name|error
argument_list|(
name|line
argument_list|,
literal|"global variable initializers must be constant expressions"
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|globalInitWarning
condition|)
block|{
name|warning
argument_list|(
name|line
argument_list|,
literal|"global variable initializers should be constant expressions "
literal|"(uniforms and globals are allowed in global initializers for legacy compatibility)"
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// identifier must be of type constant, a global, or a temporary
comment|//
name|TQualifier
name|qualifier
init|=
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|getQualifier
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|qualifier
operator|!=
name|EvqTemporary
operator|)
operator|&&
operator|(
name|qualifier
operator|!=
name|EvqGlobal
operator|)
operator|&&
operator|(
name|qualifier
operator|!=
name|EvqConst
operator|)
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|" cannot initialize this type of qualifier "
argument_list|,
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|getQualifierString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|//
comment|// test for and propagate constant
comment|//
if|if
condition|(
name|qualifier
operator|==
name|EvqConst
condition|)
block|{
if|if
condition|(
name|qualifier
operator|!=
name|initializer
operator|->
name|getType
argument_list|()
operator|.
name|getQualifier
argument_list|()
condition|)
block|{
name|std
operator|::
name|stringstream
name|extraInfoStream
decl_stmt|;
name|extraInfoStream
operator|<<
literal|"'"
operator|<<
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|getCompleteString
argument_list|()
operator|<<
literal|"'"
expr_stmt|;
name|std
operator|::
name|string
name|extraInfo
init|=
name|extraInfoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|error
argument_list|(
name|line
argument_list|,
literal|" assigning non-constant to"
argument_list|,
literal|"="
argument_list|,
name|extraInfo
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|setQualifier
argument_list|(
name|EvqTemporary
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|type
operator|!=
name|initializer
operator|->
name|getType
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|" non-matching types for const initializer "
argument_list|,
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|getQualifierString
argument_list|()
argument_list|)
expr_stmt|;
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|setQualifier
argument_list|(
name|EvqTemporary
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// Save the constant folded value to the variable if possible. For example array
comment|// initializers are not folded, since that way copying the array literal to multiple places
comment|// in the shader is avoided.
comment|// TODO(oetuaho@nvidia.com): Consider constant folding array initialization in cases where
comment|// it would be beneficial.
if|if
condition|(
name|initializer
operator|->
name|getAsConstantUnion
argument_list|()
condition|)
block|{
name|variable
operator|->
name|shareConstPointer
argument_list|(
name|initializer
operator|->
name|getAsConstantUnion
argument_list|()
operator|->
name|getUnionArrayPointer
argument_list|()
argument_list|)
expr_stmt|;
operator|*
name|intermNode
operator|=
literal|nullptr
expr_stmt|;
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|initializer
operator|->
name|getAsSymbolNode
argument_list|()
condition|)
block|{
specifier|const
name|TSymbol
modifier|*
name|symbol
init|=
name|symbolTable
operator|.
name|find
argument_list|(
name|initializer
operator|->
name|getAsSymbolNode
argument_list|()
operator|->
name|getSymbol
argument_list|()
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|const
name|TVariable
modifier|*
name|tVar
init|=
cast|static_cast
argument_list|<
specifier|const
name|TVariable
operator|*
argument_list|>
argument_list|(
name|symbol
argument_list|)
decl_stmt|;
specifier|const
name|TConstantUnion
modifier|*
name|constArray
init|=
name|tVar
operator|->
name|getConstPointer
argument_list|()
decl_stmt|;
if|if
condition|(
name|constArray
condition|)
block|{
name|variable
operator|->
name|shareConstPointer
argument_list|(
name|constArray
argument_list|)
expr_stmt|;
operator|*
name|intermNode
operator|=
literal|nullptr
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
name|TIntermSymbol
modifier|*
name|intermSymbol
init|=
name|intermediate
operator|.
name|addSymbol
argument_list|(
name|variable
operator|->
name|getUniqueId
argument_list|()
argument_list|,
name|variable
operator|->
name|getName
argument_list|()
argument_list|,
name|variable
operator|->
name|getType
argument_list|()
argument_list|,
name|line
argument_list|)
decl_stmt|;
operator|*
name|intermNode
operator|=
name|createAssign
argument_list|(
name|EOpInitialize
argument_list|,
name|intermSymbol
argument_list|,
name|initializer
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|intermNode
operator|==
literal|nullptr
condition|)
block|{
name|assignError
argument_list|(
name|line
argument_list|,
literal|"="
argument_list|,
name|intermSymbol
operator|->
name|getCompleteString
argument_list|()
argument_list|,
name|initializer
operator|->
name|getCompleteString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|addFullySpecifiedType
name|TPublicType
name|TParseContext
operator|::
name|addFullySpecifiedType
parameter_list|(
name|TQualifier
name|qualifier
parameter_list|,
name|bool
name|invariant
parameter_list|,
name|TLayoutQualifier
name|layoutQualifier
parameter_list|,
specifier|const
name|TPublicType
modifier|&
name|typeSpecifier
parameter_list|)
block|{
name|TPublicType
name|returnType
init|=
name|typeSpecifier
decl_stmt|;
name|returnType
operator|.
name|qualifier
operator|=
name|qualifier
expr_stmt|;
name|returnType
operator|.
name|invariant
operator|=
name|invariant
expr_stmt|;
name|returnType
operator|.
name|layoutQualifier
operator|=
name|layoutQualifier
expr_stmt|;
if|if
condition|(
name|mShaderVersion
operator|<
literal|300
condition|)
block|{
if|if
condition|(
name|typeSpecifier
operator|.
name|array
condition|)
block|{
name|error
argument_list|(
name|typeSpecifier
operator|.
name|line
argument_list|,
literal|"not supported"
argument_list|,
literal|"first-class array"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
name|returnType
operator|.
name|clearArrayness
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|qualifier
operator|==
name|EvqAttribute
operator|&&
operator|(
name|typeSpecifier
operator|.
name|type
operator|==
name|EbtBool
operator|||
name|typeSpecifier
operator|.
name|type
operator|==
name|EbtInt
operator|)
condition|)
block|{
name|error
argument_list|(
name|typeSpecifier
operator|.
name|line
argument_list|,
literal|"cannot be bool or int"
argument_list|,
name|getQualifierString
argument_list|(
name|qualifier
argument_list|)
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|qualifier
operator|==
name|EvqVaryingIn
operator|||
name|qualifier
operator|==
name|EvqVaryingOut
operator|)
operator|&&
operator|(
name|typeSpecifier
operator|.
name|type
operator|==
name|EbtBool
operator|||
name|typeSpecifier
operator|.
name|type
operator|==
name|EbtInt
operator|)
condition|)
block|{
name|error
argument_list|(
name|typeSpecifier
operator|.
name|line
argument_list|,
literal|"cannot be bool or int"
argument_list|,
name|getQualifierString
argument_list|(
name|qualifier
argument_list|)
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|layoutQualifier
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|globalErrorCheck
argument_list|(
name|typeSpecifier
operator|.
name|line
argument_list|,
name|symbolTable
operator|.
name|atGlobalLevel
argument_list|()
argument_list|,
literal|"layout"
argument_list|)
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sh
operator|::
name|IsVarying
argument_list|(
name|qualifier
argument_list|)
operator|||
name|qualifier
operator|==
name|EvqVertexIn
operator|||
name|qualifier
operator|==
name|EvqFragmentOut
condition|)
block|{
name|es3InputOutputTypeCheck
argument_list|(
name|qualifier
argument_list|,
name|typeSpecifier
argument_list|,
name|typeSpecifier
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|returnType
return|;
block|}
end_function
begin_function
DECL|function|es3InputOutputTypeCheck
name|void
name|TParseContext
operator|::
name|es3InputOutputTypeCheck
parameter_list|(
specifier|const
name|TQualifier
name|qualifier
parameter_list|,
specifier|const
name|TPublicType
modifier|&
name|type
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|qualifierLocation
parameter_list|)
block|{
comment|// An input/output variable can never be bool or a sampler. Samplers are checked elsewhere.
if|if
condition|(
name|type
operator|.
name|type
operator|==
name|EbtBool
condition|)
block|{
name|error
argument_list|(
name|qualifierLocation
argument_list|,
literal|"cannot be bool"
argument_list|,
name|getQualifierString
argument_list|(
name|qualifier
argument_list|)
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
comment|// Specific restrictions apply for vertex shader inputs and fragment shader outputs.
switch|switch
condition|(
name|qualifier
condition|)
block|{
case|case
name|EvqVertexIn
case|:
comment|// ESSL 3.00 section 4.3.4
if|if
condition|(
name|type
operator|.
name|array
condition|)
block|{
name|error
argument_list|(
name|qualifierLocation
argument_list|,
literal|"cannot be array"
argument_list|,
name|getQualifierString
argument_list|(
name|qualifier
argument_list|)
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
comment|// Vertex inputs with a struct type are disallowed in singleDeclarationErrorCheck
return|return;
case|case
name|EvqFragmentOut
case|:
comment|// ESSL 3.00 section 4.3.6
if|if
condition|(
name|type
operator|.
name|isMatrix
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|qualifierLocation
argument_list|,
literal|"cannot be matrix"
argument_list|,
name|getQualifierString
argument_list|(
name|qualifier
argument_list|)
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
comment|// Fragment outputs with a struct type are disallowed in singleDeclarationErrorCheck
return|return;
default|default:
break|break;
block|}
comment|// Vertex shader outputs / fragment shader inputs have a different, slightly more lenient set of
comment|// restrictions.
name|bool
name|typeContainsIntegers
init|=
operator|(
name|type
operator|.
name|type
operator|==
name|EbtInt
operator|||
name|type
operator|.
name|type
operator|==
name|EbtUInt
operator|||
name|type
operator|.
name|isStructureContainingType
argument_list|(
name|EbtInt
argument_list|)
operator|||
name|type
operator|.
name|isStructureContainingType
argument_list|(
name|EbtUInt
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|typeContainsIntegers
operator|&&
name|qualifier
operator|!=
name|EvqFlatIn
operator|&&
name|qualifier
operator|!=
name|EvqFlatOut
condition|)
block|{
name|error
argument_list|(
name|qualifierLocation
argument_list|,
literal|"must use 'flat' interpolation here"
argument_list|,
name|getQualifierString
argument_list|(
name|qualifier
argument_list|)
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|.
name|type
operator|==
name|EbtStruct
condition|)
block|{
comment|// ESSL 3.00 sections 4.3.4 and 4.3.6.
comment|// These restrictions are only implied by the ESSL 3.00 spec, but
comment|// the ESSL 3.10 spec lists these restrictions explicitly.
if|if
condition|(
name|type
operator|.
name|array
condition|)
block|{
name|error
argument_list|(
name|qualifierLocation
argument_list|,
literal|"cannot be an array of structures"
argument_list|,
name|getQualifierString
argument_list|(
name|qualifier
argument_list|)
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|.
name|isStructureContainingArrays
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|qualifierLocation
argument_list|,
literal|"cannot be a structure containing an array"
argument_list|,
name|getQualifierString
argument_list|(
name|qualifier
argument_list|)
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|.
name|isStructureContainingType
argument_list|(
name|EbtStruct
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|qualifierLocation
argument_list|,
literal|"cannot be a structure containing a structure"
argument_list|,
name|getQualifierString
argument_list|(
name|qualifier
argument_list|)
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|.
name|isStructureContainingType
argument_list|(
name|EbtBool
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|qualifierLocation
argument_list|,
literal|"cannot be a structure containing a bool"
argument_list|,
name|getQualifierString
argument_list|(
name|qualifier
argument_list|)
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|parseSingleDeclaration
name|TIntermAggregate
modifier|*
name|TParseContext
operator|::
name|parseSingleDeclaration
parameter_list|(
name|TPublicType
modifier|&
name|publicType
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|identifierOrTypeLocation
parameter_list|,
specifier|const
name|TString
modifier|&
name|identifier
parameter_list|)
block|{
name|TIntermSymbol
modifier|*
name|symbol
init|=
name|intermediate
operator|.
name|addSymbol
argument_list|(
literal|0
argument_list|,
name|identifier
argument_list|,
name|TType
argument_list|(
name|publicType
argument_list|)
argument_list|,
name|identifierOrTypeLocation
argument_list|)
decl_stmt|;
name|bool
name|emptyDeclaration
init|=
operator|(
name|identifier
operator|==
literal|""
operator|)
decl_stmt|;
name|mDeferredSingleDeclarationErrorCheck
operator|=
name|emptyDeclaration
expr_stmt|;
if|if
condition|(
name|emptyDeclaration
condition|)
block|{
if|if
condition|(
name|publicType
operator|.
name|isUnsizedArray
argument_list|()
condition|)
block|{
comment|// ESSL3 spec section 4.1.9: Array declaration which leaves the size unspecified is an
comment|// error. It is assumed that this applies to empty declarations as well.
name|error
argument_list|(
name|identifierOrTypeLocation
argument_list|,
literal|"empty array declaration needs to specify a size"
argument_list|,
name|identifier
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|singleDeclarationErrorCheck
argument_list|(
name|publicType
argument_list|,
name|identifierOrTypeLocation
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
if|if
condition|(
name|nonInitErrorCheck
argument_list|(
name|identifierOrTypeLocation
argument_list|,
name|identifier
argument_list|,
operator|&
name|publicType
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
name|TVariable
modifier|*
name|variable
init|=
literal|nullptr
decl_stmt|;
if|if
condition|(
operator|!
name|declareVariable
argument_list|(
name|identifierOrTypeLocation
argument_list|,
name|identifier
argument_list|,
name|TType
argument_list|(
name|publicType
argument_list|)
argument_list|,
operator|&
name|variable
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
if|if
condition|(
name|variable
operator|&&
name|symbol
condition|)
name|symbol
operator|->
name|setId
argument_list|(
name|variable
operator|->
name|getUniqueId
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|intermediate
operator|.
name|makeAggregate
argument_list|(
name|symbol
argument_list|,
name|identifierOrTypeLocation
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|parseSingleArrayDeclaration
name|TIntermAggregate
modifier|*
name|TParseContext
operator|::
name|parseSingleArrayDeclaration
parameter_list|(
name|TPublicType
modifier|&
name|publicType
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|identifierLocation
parameter_list|,
specifier|const
name|TString
modifier|&
name|identifier
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|indexLocation
parameter_list|,
name|TIntermTyped
modifier|*
name|indexExpression
parameter_list|)
block|{
name|mDeferredSingleDeclarationErrorCheck
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|singleDeclarationErrorCheck
argument_list|(
name|publicType
argument_list|,
name|identifierLocation
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
if|if
condition|(
name|nonInitErrorCheck
argument_list|(
name|identifierLocation
argument_list|,
name|identifier
argument_list|,
operator|&
name|publicType
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
if|if
condition|(
name|arrayTypeErrorCheck
argument_list|(
name|indexLocation
argument_list|,
name|publicType
argument_list|)
operator|||
name|arrayQualifierErrorCheck
argument_list|(
name|indexLocation
argument_list|,
name|publicType
argument_list|)
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
block|}
name|TType
name|arrayType
argument_list|(
name|publicType
argument_list|)
decl_stmt|;
name|int
name|size
decl_stmt|;
if|if
condition|(
name|arraySizeErrorCheck
argument_list|(
name|identifierLocation
argument_list|,
name|indexExpression
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
block|}
comment|// Make the type an array even if size check failed.
comment|// This ensures useless error messages regarding the variable's non-arrayness won't follow.
name|arrayType
operator|.
name|setArraySize
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|TVariable
modifier|*
name|variable
init|=
literal|nullptr
decl_stmt|;
if|if
condition|(
operator|!
name|declareVariable
argument_list|(
name|identifierLocation
argument_list|,
name|identifier
argument_list|,
name|arrayType
argument_list|,
operator|&
name|variable
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
name|TIntermSymbol
modifier|*
name|symbol
init|=
name|intermediate
operator|.
name|addSymbol
argument_list|(
literal|0
argument_list|,
name|identifier
argument_list|,
name|arrayType
argument_list|,
name|identifierLocation
argument_list|)
decl_stmt|;
if|if
condition|(
name|variable
operator|&&
name|symbol
condition|)
name|symbol
operator|->
name|setId
argument_list|(
name|variable
operator|->
name|getUniqueId
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|intermediate
operator|.
name|makeAggregate
argument_list|(
name|symbol
argument_list|,
name|identifierLocation
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|parseSingleInitDeclaration
name|TIntermAggregate
modifier|*
name|TParseContext
operator|::
name|parseSingleInitDeclaration
parameter_list|(
specifier|const
name|TPublicType
modifier|&
name|publicType
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|identifierLocation
parameter_list|,
specifier|const
name|TString
modifier|&
name|identifier
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|initLocation
parameter_list|,
name|TIntermTyped
modifier|*
name|initializer
parameter_list|)
block|{
name|mDeferredSingleDeclarationErrorCheck
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|singleDeclarationErrorCheck
argument_list|(
name|publicType
argument_list|,
name|identifierLocation
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
name|TIntermNode
modifier|*
name|intermNode
init|=
literal|nullptr
decl_stmt|;
if|if
condition|(
operator|!
name|executeInitializer
argument_list|(
name|identifierLocation
argument_list|,
name|identifier
argument_list|,
name|publicType
argument_list|,
name|initializer
argument_list|,
operator|&
name|intermNode
argument_list|)
condition|)
block|{
comment|//
comment|// Build intermediate representation
comment|//
return|return
name|intermNode
condition|?
name|intermediate
operator|.
name|makeAggregate
argument_list|(
name|intermNode
argument_list|,
name|initLocation
argument_list|)
else|:
literal|nullptr
return|;
block|}
else|else
block|{
name|recover
argument_list|()
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
block|}
end_function
begin_function
DECL|function|parseSingleArrayInitDeclaration
name|TIntermAggregate
modifier|*
name|TParseContext
operator|::
name|parseSingleArrayInitDeclaration
parameter_list|(
name|TPublicType
modifier|&
name|publicType
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|identifierLocation
parameter_list|,
specifier|const
name|TString
modifier|&
name|identifier
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|indexLocation
parameter_list|,
name|TIntermTyped
modifier|*
name|indexExpression
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|initLocation
parameter_list|,
name|TIntermTyped
modifier|*
name|initializer
parameter_list|)
block|{
name|mDeferredSingleDeclarationErrorCheck
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|singleDeclarationErrorCheck
argument_list|(
name|publicType
argument_list|,
name|identifierLocation
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
if|if
condition|(
name|arrayTypeErrorCheck
argument_list|(
name|indexLocation
argument_list|,
name|publicType
argument_list|)
operator|||
name|arrayQualifierErrorCheck
argument_list|(
name|indexLocation
argument_list|,
name|publicType
argument_list|)
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
block|}
name|TPublicType
name|arrayType
argument_list|(
name|publicType
argument_list|)
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
comment|// If indexExpression is nullptr, then the array will eventually get its size implicitly from
comment|// the initializer.
if|if
condition|(
name|indexExpression
operator|!=
literal|nullptr
operator|&&
name|arraySizeErrorCheck
argument_list|(
name|identifierLocation
argument_list|,
name|indexExpression
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
block|}
comment|// Make the type an array even if size check failed.
comment|// This ensures useless error messages regarding the variable's non-arrayness won't follow.
name|arrayType
operator|.
name|setArraySize
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|// initNode will correspond to the whole of "type b[n] = initializer".
name|TIntermNode
modifier|*
name|initNode
init|=
literal|nullptr
decl_stmt|;
if|if
condition|(
operator|!
name|executeInitializer
argument_list|(
name|identifierLocation
argument_list|,
name|identifier
argument_list|,
name|arrayType
argument_list|,
name|initializer
argument_list|,
operator|&
name|initNode
argument_list|)
condition|)
block|{
return|return
name|initNode
condition|?
name|intermediate
operator|.
name|makeAggregate
argument_list|(
name|initNode
argument_list|,
name|initLocation
argument_list|)
else|:
literal|nullptr
return|;
block|}
else|else
block|{
name|recover
argument_list|()
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
block|}
end_function
begin_function
DECL|function|parseInvariantDeclaration
name|TIntermAggregate
modifier|*
name|TParseContext
operator|::
name|parseInvariantDeclaration
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|invariantLoc
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|identifierLoc
parameter_list|,
specifier|const
name|TString
modifier|*
name|identifier
parameter_list|,
specifier|const
name|TSymbol
modifier|*
name|symbol
parameter_list|)
block|{
comment|// invariant declaration
if|if
condition|(
name|globalErrorCheck
argument_list|(
name|invariantLoc
argument_list|,
name|symbolTable
operator|.
name|atGlobalLevel
argument_list|()
argument_list|,
literal|"invariant varying"
argument_list|)
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|symbol
condition|)
block|{
name|error
argument_list|(
name|identifierLoc
argument_list|,
literal|"undeclared identifier declared as invariant"
argument_list|,
name|identifier
operator|->
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
else|else
block|{
specifier|const
name|TString
name|kGlFrontFacing
argument_list|(
literal|"gl_FrontFacing"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|identifier
operator|==
name|kGlFrontFacing
condition|)
block|{
name|error
argument_list|(
name|identifierLoc
argument_list|,
literal|"identifier should not be declared as invariant"
argument_list|,
name|identifier
operator|->
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
name|symbolTable
operator|.
name|addInvariantVarying
argument_list|(
name|std
operator|::
name|string
argument_list|(
name|identifier
operator|->
name|c_str
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
specifier|const
name|TVariable
modifier|*
name|variable
init|=
name|getNamedVariable
argument_list|(
name|identifierLoc
argument_list|,
name|identifier
argument_list|,
name|symbol
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|variable
argument_list|)
expr_stmt|;
specifier|const
name|TType
modifier|&
name|type
init|=
name|variable
operator|->
name|getType
argument_list|()
decl_stmt|;
name|TIntermSymbol
modifier|*
name|intermSymbol
init|=
name|intermediate
operator|.
name|addSymbol
argument_list|(
name|variable
operator|->
name|getUniqueId
argument_list|()
argument_list|,
operator|*
name|identifier
argument_list|,
name|type
argument_list|,
name|identifierLoc
argument_list|)
decl_stmt|;
name|TIntermAggregate
modifier|*
name|aggregate
init|=
name|intermediate
operator|.
name|makeAggregate
argument_list|(
name|intermSymbol
argument_list|,
name|identifierLoc
argument_list|)
decl_stmt|;
name|aggregate
operator|->
name|setOp
argument_list|(
name|EOpInvariantDeclaration
argument_list|)
expr_stmt|;
return|return
name|aggregate
return|;
block|}
block|}
end_function
begin_function
DECL|function|parseDeclarator
name|TIntermAggregate
modifier|*
name|TParseContext
operator|::
name|parseDeclarator
parameter_list|(
name|TPublicType
modifier|&
name|publicType
parameter_list|,
name|TIntermAggregate
modifier|*
name|aggregateDeclaration
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|identifierLocation
parameter_list|,
specifier|const
name|TString
modifier|&
name|identifier
parameter_list|)
block|{
comment|// If the declaration starting this declarator list was empty (example: int,), some checks were
comment|// not performed.
if|if
condition|(
name|mDeferredSingleDeclarationErrorCheck
condition|)
block|{
if|if
condition|(
name|singleDeclarationErrorCheck
argument_list|(
name|publicType
argument_list|,
name|identifierLocation
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
name|mDeferredSingleDeclarationErrorCheck
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|locationDeclaratorListCheck
argument_list|(
name|identifierLocation
argument_list|,
name|publicType
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
if|if
condition|(
name|nonInitErrorCheck
argument_list|(
name|identifierLocation
argument_list|,
name|identifier
argument_list|,
operator|&
name|publicType
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
name|TVariable
modifier|*
name|variable
init|=
literal|nullptr
decl_stmt|;
if|if
condition|(
operator|!
name|declareVariable
argument_list|(
name|identifierLocation
argument_list|,
name|identifier
argument_list|,
name|TType
argument_list|(
name|publicType
argument_list|)
argument_list|,
operator|&
name|variable
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
name|TIntermSymbol
modifier|*
name|symbol
init|=
name|intermediate
operator|.
name|addSymbol
argument_list|(
literal|0
argument_list|,
name|identifier
argument_list|,
name|TType
argument_list|(
name|publicType
argument_list|)
argument_list|,
name|identifierLocation
argument_list|)
decl_stmt|;
if|if
condition|(
name|variable
operator|&&
name|symbol
condition|)
name|symbol
operator|->
name|setId
argument_list|(
name|variable
operator|->
name|getUniqueId
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|intermediate
operator|.
name|growAggregate
argument_list|(
name|aggregateDeclaration
argument_list|,
name|symbol
argument_list|,
name|identifierLocation
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|parseArrayDeclarator
name|TIntermAggregate
modifier|*
name|TParseContext
operator|::
name|parseArrayDeclarator
parameter_list|(
name|TPublicType
modifier|&
name|publicType
parameter_list|,
name|TIntermAggregate
modifier|*
name|aggregateDeclaration
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|identifierLocation
parameter_list|,
specifier|const
name|TString
modifier|&
name|identifier
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|arrayLocation
parameter_list|,
name|TIntermTyped
modifier|*
name|indexExpression
parameter_list|)
block|{
comment|// If the declaration starting this declarator list was empty (example: int,), some checks were
comment|// not performed.
if|if
condition|(
name|mDeferredSingleDeclarationErrorCheck
condition|)
block|{
if|if
condition|(
name|singleDeclarationErrorCheck
argument_list|(
name|publicType
argument_list|,
name|identifierLocation
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
name|mDeferredSingleDeclarationErrorCheck
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|locationDeclaratorListCheck
argument_list|(
name|identifierLocation
argument_list|,
name|publicType
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
if|if
condition|(
name|nonInitErrorCheck
argument_list|(
name|identifierLocation
argument_list|,
name|identifier
argument_list|,
operator|&
name|publicType
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
if|if
condition|(
name|arrayTypeErrorCheck
argument_list|(
name|arrayLocation
argument_list|,
name|publicType
argument_list|)
operator|||
name|arrayQualifierErrorCheck
argument_list|(
name|arrayLocation
argument_list|,
name|publicType
argument_list|)
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|TType
name|arrayType
init|=
name|TType
argument_list|(
name|publicType
argument_list|)
decl_stmt|;
name|int
name|size
decl_stmt|;
if|if
condition|(
name|arraySizeErrorCheck
argument_list|(
name|arrayLocation
argument_list|,
name|indexExpression
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
block|}
name|arrayType
operator|.
name|setArraySize
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|TVariable
modifier|*
name|variable
init|=
literal|nullptr
decl_stmt|;
if|if
condition|(
operator|!
name|declareVariable
argument_list|(
name|identifierLocation
argument_list|,
name|identifier
argument_list|,
name|arrayType
argument_list|,
operator|&
name|variable
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
name|TIntermSymbol
modifier|*
name|symbol
init|=
name|intermediate
operator|.
name|addSymbol
argument_list|(
literal|0
argument_list|,
name|identifier
argument_list|,
name|arrayType
argument_list|,
name|identifierLocation
argument_list|)
decl_stmt|;
if|if
condition|(
name|variable
operator|&&
name|symbol
condition|)
name|symbol
operator|->
name|setId
argument_list|(
name|variable
operator|->
name|getUniqueId
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|intermediate
operator|.
name|growAggregate
argument_list|(
name|aggregateDeclaration
argument_list|,
name|symbol
argument_list|,
name|identifierLocation
argument_list|)
return|;
block|}
return|return
literal|nullptr
return|;
block|}
end_function
begin_function
DECL|function|parseInitDeclarator
name|TIntermAggregate
modifier|*
name|TParseContext
operator|::
name|parseInitDeclarator
parameter_list|(
specifier|const
name|TPublicType
modifier|&
name|publicType
parameter_list|,
name|TIntermAggregate
modifier|*
name|aggregateDeclaration
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|identifierLocation
parameter_list|,
specifier|const
name|TString
modifier|&
name|identifier
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|initLocation
parameter_list|,
name|TIntermTyped
modifier|*
name|initializer
parameter_list|)
block|{
comment|// If the declaration starting this declarator list was empty (example: int,), some checks were
comment|// not performed.
if|if
condition|(
name|mDeferredSingleDeclarationErrorCheck
condition|)
block|{
if|if
condition|(
name|singleDeclarationErrorCheck
argument_list|(
name|publicType
argument_list|,
name|identifierLocation
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
name|mDeferredSingleDeclarationErrorCheck
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|locationDeclaratorListCheck
argument_list|(
name|identifierLocation
argument_list|,
name|publicType
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
name|TIntermNode
modifier|*
name|intermNode
init|=
literal|nullptr
decl_stmt|;
if|if
condition|(
operator|!
name|executeInitializer
argument_list|(
name|identifierLocation
argument_list|,
name|identifier
argument_list|,
name|publicType
argument_list|,
name|initializer
argument_list|,
operator|&
name|intermNode
argument_list|)
condition|)
block|{
comment|//
comment|// build the intermediate representation
comment|//
if|if
condition|(
name|intermNode
condition|)
block|{
return|return
name|intermediate
operator|.
name|growAggregate
argument_list|(
name|aggregateDeclaration
argument_list|,
name|intermNode
argument_list|,
name|initLocation
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|aggregateDeclaration
return|;
block|}
block|}
else|else
block|{
name|recover
argument_list|()
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
block|}
end_function
begin_function
DECL|function|parseArrayInitDeclarator
name|TIntermAggregate
modifier|*
name|TParseContext
operator|::
name|parseArrayInitDeclarator
parameter_list|(
specifier|const
name|TPublicType
modifier|&
name|publicType
parameter_list|,
name|TIntermAggregate
modifier|*
name|aggregateDeclaration
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|identifierLocation
parameter_list|,
specifier|const
name|TString
modifier|&
name|identifier
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|indexLocation
parameter_list|,
name|TIntermTyped
modifier|*
name|indexExpression
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|initLocation
parameter_list|,
name|TIntermTyped
modifier|*
name|initializer
parameter_list|)
block|{
comment|// If the declaration starting this declarator list was empty (example: int,), some checks were
comment|// not performed.
if|if
condition|(
name|mDeferredSingleDeclarationErrorCheck
condition|)
block|{
if|if
condition|(
name|singleDeclarationErrorCheck
argument_list|(
name|publicType
argument_list|,
name|identifierLocation
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
name|mDeferredSingleDeclarationErrorCheck
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|locationDeclaratorListCheck
argument_list|(
name|identifierLocation
argument_list|,
name|publicType
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
if|if
condition|(
name|arrayTypeErrorCheck
argument_list|(
name|indexLocation
argument_list|,
name|publicType
argument_list|)
operator|||
name|arrayQualifierErrorCheck
argument_list|(
name|indexLocation
argument_list|,
name|publicType
argument_list|)
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
block|}
name|TPublicType
name|arrayType
argument_list|(
name|publicType
argument_list|)
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
comment|// If indexExpression is nullptr, then the array will eventually get its size implicitly from
comment|// the initializer.
if|if
condition|(
name|indexExpression
operator|!=
literal|nullptr
operator|&&
name|arraySizeErrorCheck
argument_list|(
name|identifierLocation
argument_list|,
name|indexExpression
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
block|}
comment|// Make the type an array even if size check failed.
comment|// This ensures useless error messages regarding the variable's non-arrayness won't follow.
name|arrayType
operator|.
name|setArraySize
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|// initNode will correspond to the whole of "b[n] = initializer".
name|TIntermNode
modifier|*
name|initNode
init|=
literal|nullptr
decl_stmt|;
if|if
condition|(
operator|!
name|executeInitializer
argument_list|(
name|identifierLocation
argument_list|,
name|identifier
argument_list|,
name|arrayType
argument_list|,
name|initializer
argument_list|,
operator|&
name|initNode
argument_list|)
condition|)
block|{
if|if
condition|(
name|initNode
condition|)
block|{
return|return
name|intermediate
operator|.
name|growAggregate
argument_list|(
name|aggregateDeclaration
argument_list|,
name|initNode
argument_list|,
name|initLocation
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|aggregateDeclaration
return|;
block|}
block|}
else|else
block|{
name|recover
argument_list|()
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
block|}
end_function
begin_function
DECL|function|parseGlobalLayoutQualifier
name|void
name|TParseContext
operator|::
name|parseGlobalLayoutQualifier
parameter_list|(
specifier|const
name|TPublicType
modifier|&
name|typeQualifier
parameter_list|)
block|{
if|if
condition|(
name|typeQualifier
operator|.
name|qualifier
operator|!=
name|EvqUniform
condition|)
block|{
name|error
argument_list|(
name|typeQualifier
operator|.
name|line
argument_list|,
literal|"invalid qualifier:"
argument_list|,
name|getQualifierString
argument_list|(
name|typeQualifier
operator|.
name|qualifier
argument_list|)
argument_list|,
literal|"global layout must be uniform"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return;
block|}
specifier|const
name|TLayoutQualifier
name|layoutQualifier
init|=
name|typeQualifier
operator|.
name|layoutQualifier
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|layoutQualifier
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|mShaderVersion
operator|<
literal|300
condition|)
block|{
name|error
argument_list|(
name|typeQualifier
operator|.
name|line
argument_list|,
literal|"layout qualifiers supported in GLSL ES 3.00 only"
argument_list|,
literal|"layout"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|layoutLocationErrorCheck
argument_list|(
name|typeQualifier
operator|.
name|line
argument_list|,
name|typeQualifier
operator|.
name|layoutQualifier
argument_list|)
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|layoutQualifier
operator|.
name|matrixPacking
operator|!=
name|EmpUnspecified
condition|)
block|{
name|mDefaultMatrixPacking
operator|=
name|layoutQualifier
operator|.
name|matrixPacking
expr_stmt|;
block|}
if|if
condition|(
name|layoutQualifier
operator|.
name|blockStorage
operator|!=
name|EbsUnspecified
condition|)
block|{
name|mDefaultBlockStorage
operator|=
name|layoutQualifier
operator|.
name|blockStorage
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|addFunctionPrototypeDeclaration
name|TIntermAggregate
modifier|*
name|TParseContext
operator|::
name|addFunctionPrototypeDeclaration
parameter_list|(
specifier|const
name|TFunction
modifier|&
name|function
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|location
parameter_list|)
block|{
comment|// Note: symbolTableFunction could be the same as function if this is the first declaration.
comment|// Either way the instance in the symbol table is used to track whether the function is declared
comment|// multiple times.
name|TFunction
modifier|*
name|symbolTableFunction
init|=
cast|static_cast
argument_list|<
name|TFunction
operator|*
argument_list|>
argument_list|(
name|symbolTable
operator|.
name|find
argument_list|(
name|function
operator|.
name|getMangledName
argument_list|()
argument_list|,
name|getShaderVersion
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|symbolTableFunction
operator|->
name|hasPrototypeDeclaration
argument_list|()
operator|&&
name|mShaderVersion
operator|==
literal|100
condition|)
block|{
comment|// ESSL 1.00.17 section 4.2.7.
comment|// Doesn't apply to ESSL 3.00.4: see section 4.2.3.
name|error
argument_list|(
name|location
argument_list|,
literal|"duplicate function prototype declarations are not allowed"
argument_list|,
literal|"function"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
name|symbolTableFunction
operator|->
name|setHasPrototypeDeclaration
argument_list|()
expr_stmt|;
name|TIntermAggregate
modifier|*
name|prototype
init|=
operator|new
name|TIntermAggregate
decl_stmt|;
name|prototype
operator|->
name|setType
argument_list|(
name|function
operator|.
name|getReturnType
argument_list|()
argument_list|)
expr_stmt|;
name|prototype
operator|->
name|setName
argument_list|(
name|function
operator|.
name|getMangledName
argument_list|()
argument_list|)
expr_stmt|;
name|prototype
operator|->
name|setFunctionId
argument_list|(
name|function
operator|.
name|getUniqueId
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|function
operator|.
name|getParamCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|TConstParameter
modifier|&
name|param
init|=
name|function
operator|.
name|getParam
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|param
operator|.
name|name
operator|!=
literal|0
condition|)
block|{
name|TVariable
name|variable
argument_list|(
name|param
operator|.
name|name
argument_list|,
operator|*
name|param
operator|.
name|type
argument_list|)
decl_stmt|;
name|TIntermSymbol
modifier|*
name|paramSymbol
init|=
name|intermediate
operator|.
name|addSymbol
argument_list|(
name|variable
operator|.
name|getUniqueId
argument_list|()
argument_list|,
name|variable
operator|.
name|getName
argument_list|()
argument_list|,
name|variable
operator|.
name|getType
argument_list|()
argument_list|,
name|location
argument_list|)
decl_stmt|;
name|prototype
operator|=
name|intermediate
operator|.
name|growAggregate
argument_list|(
name|prototype
argument_list|,
name|paramSymbol
argument_list|,
name|location
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TIntermSymbol
modifier|*
name|paramSymbol
init|=
name|intermediate
operator|.
name|addSymbol
argument_list|(
literal|0
argument_list|,
literal|""
argument_list|,
operator|*
name|param
operator|.
name|type
argument_list|,
name|location
argument_list|)
decl_stmt|;
name|prototype
operator|=
name|intermediate
operator|.
name|growAggregate
argument_list|(
name|prototype
argument_list|,
name|paramSymbol
argument_list|,
name|location
argument_list|)
expr_stmt|;
block|}
block|}
name|prototype
operator|->
name|setOp
argument_list|(
name|EOpPrototype
argument_list|)
expr_stmt|;
name|symbolTable
operator|.
name|pop
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|symbolTable
operator|.
name|atGlobalLevel
argument_list|()
condition|)
block|{
comment|// ESSL 3.00.4 section 4.2.4.
name|error
argument_list|(
name|location
argument_list|,
literal|"local function prototype declarations are not allowed"
argument_list|,
literal|"function"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
return|return
name|prototype
return|;
block|}
end_function
begin_function
DECL|function|addFunctionDefinition
name|TIntermAggregate
modifier|*
name|TParseContext
operator|::
name|addFunctionDefinition
parameter_list|(
specifier|const
name|TFunction
modifier|&
name|function
parameter_list|,
name|TIntermAggregate
modifier|*
name|functionPrototype
parameter_list|,
name|TIntermAggregate
modifier|*
name|functionBody
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|location
parameter_list|)
block|{
comment|//?? Check that all paths return a value if return type != void ?
comment|//   May be best done as post process phase on intermediate code
if|if
condition|(
name|mCurrentFunctionType
operator|->
name|getBasicType
argument_list|()
operator|!=
name|EbtVoid
operator|&&
operator|!
name|mFunctionReturnsValue
condition|)
block|{
name|error
argument_list|(
name|location
argument_list|,
literal|"function does not return a value:"
argument_list|,
literal|""
argument_list|,
name|function
operator|.
name|getName
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
name|TIntermAggregate
modifier|*
name|aggregate
init|=
name|intermediate
operator|.
name|growAggregate
argument_list|(
name|functionPrototype
argument_list|,
name|functionBody
argument_list|,
name|location
argument_list|)
decl_stmt|;
name|intermediate
operator|.
name|setAggregateOperator
argument_list|(
name|aggregate
argument_list|,
name|EOpFunction
argument_list|,
name|location
argument_list|)
expr_stmt|;
name|aggregate
operator|->
name|setName
argument_list|(
name|function
operator|.
name|getMangledName
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|aggregate
operator|->
name|setType
argument_list|(
name|function
operator|.
name|getReturnType
argument_list|()
argument_list|)
expr_stmt|;
name|aggregate
operator|->
name|setFunctionId
argument_list|(
name|function
operator|.
name|getUniqueId
argument_list|()
argument_list|)
expr_stmt|;
name|symbolTable
operator|.
name|pop
argument_list|()
expr_stmt|;
return|return
name|aggregate
return|;
block|}
end_function
begin_function
DECL|function|parseFunctionPrototype
name|void
name|TParseContext
operator|::
name|parseFunctionPrototype
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|location
parameter_list|,
name|TFunction
modifier|*
name|function
parameter_list|,
name|TIntermAggregate
modifier|*
modifier|*
name|aggregateOut
parameter_list|)
block|{
specifier|const
name|TSymbol
modifier|*
name|builtIn
init|=
name|symbolTable
operator|.
name|findBuiltIn
argument_list|(
name|function
operator|->
name|getMangledName
argument_list|()
argument_list|,
name|getShaderVersion
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|builtIn
condition|)
block|{
name|error
argument_list|(
name|location
argument_list|,
literal|"built-in functions cannot be redefined"
argument_list|,
name|function
operator|->
name|getName
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
name|TFunction
modifier|*
name|prevDec
init|=
cast|static_cast
argument_list|<
name|TFunction
operator|*
argument_list|>
argument_list|(
name|symbolTable
operator|.
name|find
argument_list|(
name|function
operator|->
name|getMangledName
argument_list|()
argument_list|,
name|getShaderVersion
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|//
comment|// Note:  'prevDec' could be 'function' if this is the first time we've seen function
comment|// as it would have just been put in the symbol table.  Otherwise, we're looking up
comment|// an earlier occurance.
comment|//
if|if
condition|(
name|prevDec
operator|->
name|isDefined
argument_list|()
condition|)
block|{
comment|// Then this function already has a body.
name|error
argument_list|(
name|location
argument_list|,
literal|"function already has a body"
argument_list|,
name|function
operator|->
name|getName
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
name|prevDec
operator|->
name|setDefined
argument_list|()
expr_stmt|;
comment|//
comment|// Overload the unique ID of the definition to be the same unique ID as the declaration.
comment|// Eventually we will probably want to have only a single definition and just swap the
comment|// arguments to be the definition's arguments.
comment|//
name|function
operator|->
name|setUniqueId
argument_list|(
name|prevDec
operator|->
name|getUniqueId
argument_list|()
argument_list|)
expr_stmt|;
comment|// Raise error message if main function takes any parameters or return anything other than void
if|if
condition|(
name|function
operator|->
name|getName
argument_list|()
operator|==
literal|"main"
condition|)
block|{
if|if
condition|(
name|function
operator|->
name|getParamCount
argument_list|()
operator|>
literal|0
condition|)
block|{
name|error
argument_list|(
name|location
argument_list|,
literal|"function cannot take any parameter(s)"
argument_list|,
name|function
operator|->
name|getName
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|function
operator|->
name|getReturnType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|!=
name|EbtVoid
condition|)
block|{
name|error
argument_list|(
name|location
argument_list|,
literal|""
argument_list|,
name|function
operator|->
name|getReturnType
argument_list|()
operator|.
name|getBasicString
argument_list|()
argument_list|,
literal|"main function cannot return a value"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
block|}
comment|//
comment|// Remember the return type for later checking for RETURN statements.
comment|//
name|mCurrentFunctionType
operator|=
operator|&
operator|(
name|prevDec
operator|->
name|getReturnType
argument_list|()
operator|)
expr_stmt|;
name|mFunctionReturnsValue
operator|=
literal|false
expr_stmt|;
comment|//
comment|// Insert parameters into the symbol table.
comment|// If the parameter has no name, it's not an error, just don't insert it
comment|// (could be used for unused args).
comment|//
comment|// Also, accumulate the list of parameters into the HIL, so lower level code
comment|// knows where to find parameters.
comment|//
name|TIntermAggregate
modifier|*
name|paramNodes
init|=
operator|new
name|TIntermAggregate
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|function
operator|->
name|getParamCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|TConstParameter
modifier|&
name|param
init|=
name|function
operator|->
name|getParam
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|param
operator|.
name|name
operator|!=
literal|0
condition|)
block|{
name|TVariable
modifier|*
name|variable
init|=
operator|new
name|TVariable
argument_list|(
name|param
operator|.
name|name
argument_list|,
operator|*
name|param
operator|.
name|type
argument_list|)
decl_stmt|;
comment|//
comment|// Insert the parameters with name in the symbol table.
comment|//
if|if
condition|(
operator|!
name|symbolTable
operator|.
name|declare
argument_list|(
name|variable
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|location
argument_list|,
literal|"redefinition"
argument_list|,
name|variable
operator|->
name|getName
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
name|paramNodes
operator|=
name|intermediate
operator|.
name|growAggregate
argument_list|(
name|paramNodes
argument_list|,
name|intermediate
operator|.
name|addSymbol
argument_list|(
literal|0
argument_list|,
literal|""
argument_list|,
operator|*
name|param
operator|.
name|type
argument_list|,
name|location
argument_list|)
argument_list|,
name|location
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|//
comment|// Add the parameter to the HIL
comment|//
name|TIntermSymbol
modifier|*
name|symbol
init|=
name|intermediate
operator|.
name|addSymbol
argument_list|(
name|variable
operator|->
name|getUniqueId
argument_list|()
argument_list|,
name|variable
operator|->
name|getName
argument_list|()
argument_list|,
name|variable
operator|->
name|getType
argument_list|()
argument_list|,
name|location
argument_list|)
decl_stmt|;
name|paramNodes
operator|=
name|intermediate
operator|.
name|growAggregate
argument_list|(
name|paramNodes
argument_list|,
name|symbol
argument_list|,
name|location
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|paramNodes
operator|=
name|intermediate
operator|.
name|growAggregate
argument_list|(
name|paramNodes
argument_list|,
name|intermediate
operator|.
name|addSymbol
argument_list|(
literal|0
argument_list|,
literal|""
argument_list|,
operator|*
name|param
operator|.
name|type
argument_list|,
name|location
argument_list|)
argument_list|,
name|location
argument_list|)
expr_stmt|;
block|}
block|}
name|intermediate
operator|.
name|setAggregateOperator
argument_list|(
name|paramNodes
argument_list|,
name|EOpParameters
argument_list|,
name|location
argument_list|)
expr_stmt|;
operator|*
name|aggregateOut
operator|=
name|paramNodes
expr_stmt|;
name|setLoopNestingLevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parseFunctionDeclarator
name|TFunction
modifier|*
name|TParseContext
operator|::
name|parseFunctionDeclarator
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|location
parameter_list|,
name|TFunction
modifier|*
name|function
parameter_list|)
block|{
comment|//
comment|// We don't know at this point whether this is a function definition or a prototype.
comment|// The definition production code will check for redefinitions.
comment|// In the case of ESSL 1.00 the prototype production code will also check for redeclarations.
comment|//
comment|// Return types and parameter qualifiers must match in all redeclarations, so those are checked
comment|// here.
comment|//
name|TFunction
modifier|*
name|prevDec
init|=
cast|static_cast
argument_list|<
name|TFunction
operator|*
argument_list|>
argument_list|(
name|symbolTable
operator|.
name|find
argument_list|(
name|function
operator|->
name|getMangledName
argument_list|()
argument_list|,
name|getShaderVersion
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|prevDec
condition|)
block|{
if|if
condition|(
name|prevDec
operator|->
name|getReturnType
argument_list|()
operator|!=
name|function
operator|->
name|getReturnType
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|location
argument_list|,
literal|"overloaded functions must have the same return type"
argument_list|,
name|function
operator|->
name|getReturnType
argument_list|()
operator|.
name|getBasicString
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|prevDec
operator|->
name|getParamCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|prevDec
operator|->
name|getParam
argument_list|(
name|i
argument_list|)
operator|.
name|type
operator|->
name|getQualifier
argument_list|()
operator|!=
name|function
operator|->
name|getParam
argument_list|(
name|i
argument_list|)
operator|.
name|type
operator|->
name|getQualifier
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|location
argument_list|,
literal|"overloaded functions must have the same parameter qualifiers"
argument_list|,
name|function
operator|->
name|getParam
argument_list|(
name|i
argument_list|)
operator|.
name|type
operator|->
name|getQualifierString
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|//
comment|// Check for previously declared variables using the same name.
comment|//
name|TSymbol
modifier|*
name|prevSym
init|=
name|symbolTable
operator|.
name|find
argument_list|(
name|function
operator|->
name|getName
argument_list|()
argument_list|,
name|getShaderVersion
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|prevSym
condition|)
block|{
if|if
condition|(
operator|!
name|prevSym
operator|->
name|isFunction
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|location
argument_list|,
literal|"redefinition"
argument_list|,
name|function
operator|->
name|getName
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|,
literal|"function"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Insert the unmangled name to detect potential future redefinition as a variable.
name|TFunction
modifier|*
name|newFunction
init|=
operator|new
name|TFunction
argument_list|(
name|NewPoolTString
argument_list|(
name|function
operator|->
name|getName
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|)
argument_list|,
operator|&
name|function
operator|->
name|getReturnType
argument_list|()
argument_list|)
decl_stmt|;
name|symbolTable
operator|.
name|getOuterLevel
argument_list|()
operator|->
name|insertUnmangled
argument_list|(
name|newFunction
argument_list|)
expr_stmt|;
block|}
comment|// We're at the inner scope level of the function's arguments and body statement.
comment|// Add the function prototype to the surrounding scope instead.
name|symbolTable
operator|.
name|getOuterLevel
argument_list|()
operator|->
name|insert
argument_list|(
name|function
argument_list|)
expr_stmt|;
comment|//
comment|// If this is a redeclaration, it could also be a definition, in which case, we want to use the
comment|// variable names from this one, and not the one that's
comment|// being redeclared.  So, pass back up this declaration, not the one in the symbol table.
comment|//
return|return
name|function
return|;
block|}
end_function
begin_function
DECL|function|addConstructorFunc
name|TFunction
modifier|*
name|TParseContext
operator|::
name|addConstructorFunc
parameter_list|(
specifier|const
name|TPublicType
modifier|&
name|publicTypeIn
parameter_list|)
block|{
name|TPublicType
name|publicType
init|=
name|publicTypeIn
decl_stmt|;
if|if
condition|(
name|publicType
operator|.
name|isStructSpecifier
condition|)
block|{
name|error
argument_list|(
name|publicType
operator|.
name|line
argument_list|,
literal|"constructor can't be a structure definition"
argument_list|,
name|getBasicString
argument_list|(
name|publicType
operator|.
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
name|TOperator
name|op
init|=
name|EOpNull
decl_stmt|;
if|if
condition|(
name|publicType
operator|.
name|userDef
condition|)
block|{
name|op
operator|=
name|EOpConstructStruct
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|publicType
operator|.
name|type
condition|)
block|{
case|case
name|EbtFloat
case|:
if|if
condition|(
name|publicType
operator|.
name|isMatrix
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|publicType
operator|.
name|getCols
argument_list|()
condition|)
block|{
case|case
literal|2
case|:
switch|switch
condition|(
name|publicType
operator|.
name|getRows
argument_list|()
condition|)
block|{
case|case
literal|2
case|:
name|op
operator|=
name|EOpConstructMat2
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|op
operator|=
name|EOpConstructMat2x3
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|op
operator|=
name|EOpConstructMat2x4
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|3
case|:
switch|switch
condition|(
name|publicType
operator|.
name|getRows
argument_list|()
condition|)
block|{
case|case
literal|2
case|:
name|op
operator|=
name|EOpConstructMat3x2
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|op
operator|=
name|EOpConstructMat3
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|op
operator|=
name|EOpConstructMat3x4
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|4
case|:
switch|switch
condition|(
name|publicType
operator|.
name|getRows
argument_list|()
condition|)
block|{
case|case
literal|2
case|:
name|op
operator|=
name|EOpConstructMat4x2
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|op
operator|=
name|EOpConstructMat4x3
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|op
operator|=
name|EOpConstructMat4
expr_stmt|;
break|break;
block|}
break|break;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|publicType
operator|.
name|getNominalSize
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
name|op
operator|=
name|EOpConstructFloat
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|op
operator|=
name|EOpConstructVec2
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|op
operator|=
name|EOpConstructVec3
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|op
operator|=
name|EOpConstructVec4
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|EbtInt
case|:
switch|switch
condition|(
name|publicType
operator|.
name|getNominalSize
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
name|op
operator|=
name|EOpConstructInt
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|op
operator|=
name|EOpConstructIVec2
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|op
operator|=
name|EOpConstructIVec3
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|op
operator|=
name|EOpConstructIVec4
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|EbtUInt
case|:
switch|switch
condition|(
name|publicType
operator|.
name|getNominalSize
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
name|op
operator|=
name|EOpConstructUInt
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|op
operator|=
name|EOpConstructUVec2
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|op
operator|=
name|EOpConstructUVec3
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|op
operator|=
name|EOpConstructUVec4
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|EbtBool
case|:
switch|switch
condition|(
name|publicType
operator|.
name|getNominalSize
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
name|op
operator|=
name|EOpConstructBool
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|op
operator|=
name|EOpConstructBVec2
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|op
operator|=
name|EOpConstructBVec3
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|op
operator|=
name|EOpConstructBVec4
expr_stmt|;
break|break;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|op
operator|==
name|EOpNull
condition|)
block|{
name|error
argument_list|(
name|publicType
operator|.
name|line
argument_list|,
literal|"cannot construct this type"
argument_list|,
name|getBasicString
argument_list|(
name|publicType
operator|.
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
name|publicType
operator|.
name|type
operator|=
name|EbtFloat
expr_stmt|;
name|op
operator|=
name|EOpConstructFloat
expr_stmt|;
block|}
block|}
name|TString
name|tempString
decl_stmt|;
specifier|const
name|TType
modifier|*
name|type
init|=
operator|new
name|TType
argument_list|(
name|publicType
argument_list|)
decl_stmt|;
return|return
operator|new
name|TFunction
argument_list|(
operator|&
name|tempString
argument_list|,
name|type
argument_list|,
name|op
argument_list|)
return|;
block|}
end_function
begin_comment
comment|// This function is used to test for the correctness of the parameters passed to various constructor
end_comment
begin_comment
comment|// functions and also convert them to the right datatype if it is allowed and required.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns 0 for an error or the constructed node (aggregate or typed) for no error.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addConstructor
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|addConstructor
parameter_list|(
name|TIntermNode
modifier|*
name|arguments
parameter_list|,
name|TType
modifier|*
name|type
parameter_list|,
name|TOperator
name|op
parameter_list|,
name|TFunction
modifier|*
name|fnCall
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
name|TIntermAggregate
modifier|*
name|constructor
init|=
name|arguments
operator|->
name|getAsAggregate
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|constructor
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|->
name|isArray
argument_list|()
condition|)
block|{
comment|// GLSL ES 3.00 section 5.4.4: Each argument must be the same type as the element type of
comment|// the array.
name|TIntermSequence
modifier|*
name|args
init|=
name|constructor
operator|->
name|getSequence
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|->
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|TType
modifier|&
name|argType
init|=
operator|(
operator|*
name|args
operator|)
index|[
name|i
index|]
operator|->
name|getAsTyped
argument_list|()
operator|->
name|getType
argument_list|()
decl_stmt|;
comment|// It has already been checked that the argument is not an array.
name|ASSERT
argument_list|(
operator|!
name|argType
operator|.
name|isArray
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|argType
operator|.
name|sameElementType
argument_list|(
operator|*
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"Array constructor argument has an incorrect type"
argument_list|,
literal|"Error"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|EOpConstructStruct
condition|)
block|{
specifier|const
name|TFieldList
modifier|&
name|fields
init|=
name|type
operator|->
name|getStruct
argument_list|()
operator|->
name|fields
argument_list|()
decl_stmt|;
name|TIntermSequence
modifier|*
name|args
init|=
name|constructor
operator|->
name|getSequence
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|args
operator|->
name|size
argument_list|()
operator|||
operator|(
operator|*
name|args
operator|)
index|[
name|i
index|]
operator|->
name|getAsTyped
argument_list|()
operator|->
name|getType
argument_list|()
operator|!=
operator|*
name|fields
index|[
name|i
index|]
operator|->
name|type
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"Structure constructor arguments do not match structure fields"
argument_list|,
literal|"Error"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
comment|// Turn the argument list itself into a constructor
name|constructor
operator|->
name|setOp
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|constructor
operator|->
name|setLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|constructor
operator|->
name|isConstructor
argument_list|()
argument_list|)
expr_stmt|;
comment|// Need to set type before setPrecisionFromChildren() because bool doesn't have precision.
name|constructor
operator|->
name|setType
argument_list|(
operator|*
name|type
argument_list|)
expr_stmt|;
comment|// Structs should not be precision qualified, the individual members may be.
comment|// Built-in types on the other hand should be precision qualified.
if|if
condition|(
name|op
operator|!=
name|EOpConstructStruct
condition|)
block|{
name|constructor
operator|->
name|setPrecisionFromChildren
argument_list|()
expr_stmt|;
name|type
operator|->
name|setPrecision
argument_list|(
name|constructor
operator|->
name|getPrecision
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|TIntermTyped
modifier|*
name|constConstructor
init|=
name|intermediate
operator|.
name|foldAggregateBuiltIn
argument_list|(
name|constructor
argument_list|)
decl_stmt|;
if|if
condition|(
name|constConstructor
condition|)
block|{
return|return
name|constConstructor
return|;
block|}
return|return
name|constructor
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// This function returns the tree representation for the vector field(s) being accessed from contant
end_comment
begin_comment
comment|// vector.
end_comment
begin_comment
comment|// If only one component of vector is accessed (v.x or v[0] where v is a contant vector), then a
end_comment
begin_comment
comment|// contant node is returned, else an aggregate node is returned (for v.xy). The input to this
end_comment
begin_comment
comment|// function could either be the symbol node or it could be the intermediate tree representation of
end_comment
begin_comment
comment|// accessing fields in a constant structure or column of a constant matrix.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addConstVectorNode
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|addConstVectorNode
parameter_list|(
name|TVectorFields
modifier|&
name|fields
parameter_list|,
name|TIntermConstantUnion
modifier|*
name|node
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
name|bool
name|outOfRangeIndexIsError
parameter_list|)
block|{
specifier|const
name|TConstantUnion
modifier|*
name|unionArray
init|=
name|node
operator|->
name|getUnionArrayPointer
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|unionArray
argument_list|)
expr_stmt|;
name|TConstantUnion
modifier|*
name|constArray
init|=
operator|new
name|TConstantUnion
index|[
name|fields
operator|.
name|num
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|>=
name|node
operator|->
name|getType
argument_list|()
operator|.
name|getNominalSize
argument_list|()
condition|)
block|{
name|std
operator|::
name|stringstream
name|extraInfoStream
decl_stmt|;
name|extraInfoStream
operator|<<
literal|"vector field selection out of range '"
operator|<<
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|<<
literal|"'"
expr_stmt|;
name|std
operator|::
name|string
name|extraInfo
init|=
name|extraInfoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|outOfRangeError
argument_list|(
name|outOfRangeIndexIsError
argument_list|,
name|line
argument_list|,
literal|""
argument_list|,
literal|"["
argument_list|,
name|extraInfo
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
name|node
operator|->
name|getType
argument_list|()
operator|.
name|getNominalSize
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
name|constArray
index|[
name|i
index|]
operator|=
name|unionArray
index|[
name|fields
operator|.
name|offsets
index|[
name|i
index|]
index|]
expr_stmt|;
block|}
return|return
name|intermediate
operator|.
name|addConstantUnion
argument_list|(
name|constArray
argument_list|,
name|node
operator|->
name|getType
argument_list|()
argument_list|,
name|line
argument_list|)
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// This function returns the column being accessed from a constant matrix. The values are retrieved
end_comment
begin_comment
comment|// from the symbol table and parse-tree is built for a vector (each column of a matrix is a vector).
end_comment
begin_comment
comment|// The input to the function could either be a symbol node (m[0] where m is a constant matrix)that
end_comment
begin_comment
comment|// represents a constant matrix or it could be the tree representation of the constant matrix
end_comment
begin_comment
comment|// (s.m1[0] where s is a constant structure)
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addConstMatrixNode
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|addConstMatrixNode
parameter_list|(
name|int
name|index
parameter_list|,
name|TIntermConstantUnion
modifier|*
name|node
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
name|bool
name|outOfRangeIndexIsError
parameter_list|)
block|{
if|if
condition|(
name|index
operator|>=
name|node
operator|->
name|getType
argument_list|()
operator|.
name|getCols
argument_list|()
condition|)
block|{
name|std
operator|::
name|stringstream
name|extraInfoStream
decl_stmt|;
name|extraInfoStream
operator|<<
literal|"matrix field selection out of range '"
operator|<<
name|index
operator|<<
literal|"'"
expr_stmt|;
name|std
operator|::
name|string
name|extraInfo
init|=
name|extraInfoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|outOfRangeError
argument_list|(
name|outOfRangeIndexIsError
argument_list|,
name|line
argument_list|,
literal|""
argument_list|,
literal|"["
argument_list|,
name|extraInfo
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|index
operator|=
name|node
operator|->
name|getType
argument_list|()
operator|.
name|getCols
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
specifier|const
name|TConstantUnion
modifier|*
name|unionArray
init|=
name|node
operator|->
name|getUnionArrayPointer
argument_list|()
decl_stmt|;
name|int
name|size
init|=
name|node
operator|->
name|getType
argument_list|()
operator|.
name|getCols
argument_list|()
decl_stmt|;
return|return
name|intermediate
operator|.
name|addConstantUnion
argument_list|(
operator|&
name|unionArray
index|[
name|size
operator|*
name|index
index|]
argument_list|,
name|node
operator|->
name|getType
argument_list|()
argument_list|,
name|line
argument_list|)
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// This function returns an element of an array accessed from a constant array. The values are
end_comment
begin_comment
comment|// retrieved from the symbol table and parse-tree is built for the type of the element. The input
end_comment
begin_comment
comment|// to the function could either be a symbol node (a[0] where a is a constant array)that represents a
end_comment
begin_comment
comment|// constant array or it could be the tree representation of the constant array (s.a1[0] where s is a
end_comment
begin_comment
comment|// constant structure)
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addConstArrayNode
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|addConstArrayNode
parameter_list|(
name|int
name|index
parameter_list|,
name|TIntermConstantUnion
modifier|*
name|node
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
name|bool
name|outOfRangeIndexIsError
parameter_list|)
block|{
name|TType
name|arrayElementType
init|=
name|node
operator|->
name|getType
argument_list|()
decl_stmt|;
name|arrayElementType
operator|.
name|clearArrayness
argument_list|()
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|node
operator|->
name|getType
argument_list|()
operator|.
name|getArraySize
argument_list|()
condition|)
block|{
name|std
operator|::
name|stringstream
name|extraInfoStream
decl_stmt|;
name|extraInfoStream
operator|<<
literal|"array field selection out of range '"
operator|<<
name|index
operator|<<
literal|"'"
expr_stmt|;
name|std
operator|::
name|string
name|extraInfo
init|=
name|extraInfoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|outOfRangeError
argument_list|(
name|outOfRangeIndexIsError
argument_list|,
name|line
argument_list|,
literal|""
argument_list|,
literal|"["
argument_list|,
name|extraInfo
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|index
operator|=
name|node
operator|->
name|getType
argument_list|()
operator|.
name|getArraySize
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
name|size_t
name|arrayElementSize
init|=
name|arrayElementType
operator|.
name|getObjectSize
argument_list|()
decl_stmt|;
specifier|const
name|TConstantUnion
modifier|*
name|unionArray
init|=
name|node
operator|->
name|getUnionArrayPointer
argument_list|()
decl_stmt|;
return|return
name|intermediate
operator|.
name|addConstantUnion
argument_list|(
operator|&
name|unionArray
index|[
name|arrayElementSize
operator|*
name|index
index|]
argument_list|,
name|node
operator|->
name|getType
argument_list|()
argument_list|,
name|line
argument_list|)
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// This function returns the value of a particular field inside a constant structure from the symbol
end_comment
begin_comment
comment|// table.
end_comment
begin_comment
comment|// If there is an embedded/nested struct, it appropriately calls addConstStructNested or
end_comment
begin_comment
comment|// addConstStructFromAggr function and returns the parse-tree with the values of the embedded/nested
end_comment
begin_comment
comment|// struct.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addConstStruct
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|addConstStruct
parameter_list|(
specifier|const
name|TString
modifier|&
name|identifier
parameter_list|,
name|TIntermTyped
modifier|*
name|node
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
specifier|const
name|TFieldList
modifier|&
name|fields
init|=
name|node
operator|->
name|getType
argument_list|()
operator|.
name|getStruct
argument_list|()
operator|->
name|fields
argument_list|()
decl_stmt|;
name|size_t
name|instanceSize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|size_t
name|index
init|=
literal|0
init|;
name|index
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
operator|++
name|index
control|)
block|{
if|if
condition|(
name|fields
index|[
name|index
index|]
operator|->
name|name
argument_list|()
operator|==
name|identifier
condition|)
block|{
break|break;
block|}
else|else
block|{
name|instanceSize
operator|+=
name|fields
index|[
name|index
index|]
operator|->
name|type
argument_list|()
operator|->
name|getObjectSize
argument_list|()
expr_stmt|;
block|}
block|}
name|TIntermTyped
modifier|*
name|typedNode
decl_stmt|;
name|TIntermConstantUnion
modifier|*
name|tempConstantNode
init|=
name|node
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
if|if
condition|(
name|tempConstantNode
condition|)
block|{
specifier|const
name|TConstantUnion
modifier|*
name|constArray
init|=
name|tempConstantNode
operator|->
name|getUnionArrayPointer
argument_list|()
decl_stmt|;
comment|// type will be changed in the calling function
name|typedNode
operator|=
name|intermediate
operator|.
name|addConstantUnion
argument_list|(
name|constArray
operator|+
name|instanceSize
argument_list|,
name|tempConstantNode
operator|->
name|getType
argument_list|()
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"Cannot offset into the structure"
argument_list|,
literal|"Error"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|typedNode
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Interface/uniform blocks
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addInterfaceBlock
name|TIntermAggregate
modifier|*
name|TParseContext
operator|::
name|addInterfaceBlock
parameter_list|(
specifier|const
name|TPublicType
modifier|&
name|typeQualifier
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|nameLine
parameter_list|,
specifier|const
name|TString
modifier|&
name|blockName
parameter_list|,
name|TFieldList
modifier|*
name|fieldList
parameter_list|,
specifier|const
name|TString
modifier|*
name|instanceName
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|instanceLine
parameter_list|,
name|TIntermTyped
modifier|*
name|arrayIndex
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|arrayIndexLine
parameter_list|)
block|{
if|if
condition|(
name|reservedErrorCheck
argument_list|(
name|nameLine
argument_list|,
name|blockName
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
if|if
condition|(
name|typeQualifier
operator|.
name|qualifier
operator|!=
name|EvqUniform
condition|)
block|{
name|error
argument_list|(
name|typeQualifier
operator|.
name|line
argument_list|,
literal|"invalid qualifier:"
argument_list|,
name|getQualifierString
argument_list|(
name|typeQualifier
operator|.
name|qualifier
argument_list|)
argument_list|,
literal|"interface blocks must be uniform"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
name|TLayoutQualifier
name|blockLayoutQualifier
init|=
name|typeQualifier
operator|.
name|layoutQualifier
decl_stmt|;
if|if
condition|(
name|layoutLocationErrorCheck
argument_list|(
name|typeQualifier
operator|.
name|line
argument_list|,
name|blockLayoutQualifier
argument_list|)
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|blockLayoutQualifier
operator|.
name|matrixPacking
operator|==
name|EmpUnspecified
condition|)
block|{
name|blockLayoutQualifier
operator|.
name|matrixPacking
operator|=
name|mDefaultMatrixPacking
expr_stmt|;
block|}
if|if
condition|(
name|blockLayoutQualifier
operator|.
name|blockStorage
operator|==
name|EbsUnspecified
condition|)
block|{
name|blockLayoutQualifier
operator|.
name|blockStorage
operator|=
name|mDefaultBlockStorage
expr_stmt|;
block|}
name|TSymbol
modifier|*
name|blockNameSymbol
init|=
operator|new
name|TInterfaceBlockName
argument_list|(
operator|&
name|blockName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|symbolTable
operator|.
name|declare
argument_list|(
name|blockNameSymbol
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|nameLine
argument_list|,
literal|"redefinition"
argument_list|,
name|blockName
operator|.
name|c_str
argument_list|()
argument_list|,
literal|"interface block name"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
comment|// check for sampler types and apply layout qualifiers
for|for
control|(
name|size_t
name|memberIndex
init|=
literal|0
init|;
name|memberIndex
operator|<
name|fieldList
operator|->
name|size
argument_list|()
condition|;
operator|++
name|memberIndex
control|)
block|{
name|TField
modifier|*
name|field
init|=
operator|(
operator|*
name|fieldList
operator|)
index|[
name|memberIndex
index|]
decl_stmt|;
name|TType
modifier|*
name|fieldType
init|=
name|field
operator|->
name|type
argument_list|()
decl_stmt|;
if|if
condition|(
name|IsSampler
argument_list|(
name|fieldType
operator|->
name|getBasicType
argument_list|()
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|field
operator|->
name|line
argument_list|()
argument_list|,
literal|"unsupported type"
argument_list|,
name|fieldType
operator|->
name|getBasicString
argument_list|()
argument_list|,
literal|"sampler types are not allowed in interface blocks"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
specifier|const
name|TQualifier
name|qualifier
init|=
name|fieldType
operator|->
name|getQualifier
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|qualifier
condition|)
block|{
case|case
name|EvqGlobal
case|:
case|case
name|EvqUniform
case|:
break|break;
default|default:
name|error
argument_list|(
name|field
operator|->
name|line
argument_list|()
argument_list|,
literal|"invalid qualifier on interface block member"
argument_list|,
name|getQualifierString
argument_list|(
name|qualifier
argument_list|)
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
break|break;
block|}
comment|// check layout qualifiers
name|TLayoutQualifier
name|fieldLayoutQualifier
init|=
name|fieldType
operator|->
name|getLayoutQualifier
argument_list|()
decl_stmt|;
if|if
condition|(
name|layoutLocationErrorCheck
argument_list|(
name|field
operator|->
name|line
argument_list|()
argument_list|,
name|fieldLayoutQualifier
argument_list|)
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fieldLayoutQualifier
operator|.
name|blockStorage
operator|!=
name|EbsUnspecified
condition|)
block|{
name|error
argument_list|(
name|field
operator|->
name|line
argument_list|()
argument_list|,
literal|"invalid layout qualifier:"
argument_list|,
name|getBlockStorageString
argument_list|(
name|fieldLayoutQualifier
operator|.
name|blockStorage
argument_list|)
argument_list|,
literal|"cannot be used here"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fieldLayoutQualifier
operator|.
name|matrixPacking
operator|==
name|EmpUnspecified
condition|)
block|{
name|fieldLayoutQualifier
operator|.
name|matrixPacking
operator|=
name|blockLayoutQualifier
operator|.
name|matrixPacking
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|fieldType
operator|->
name|isMatrix
argument_list|()
operator|&&
name|fieldType
operator|->
name|getBasicType
argument_list|()
operator|!=
name|EbtStruct
condition|)
block|{
name|warning
argument_list|(
name|field
operator|->
name|line
argument_list|()
argument_list|,
literal|"extraneous layout qualifier:"
argument_list|,
name|getMatrixPackingString
argument_list|(
name|fieldLayoutQualifier
operator|.
name|matrixPacking
argument_list|)
argument_list|,
literal|"only has an effect on matrix types"
argument_list|)
expr_stmt|;
block|}
name|fieldType
operator|->
name|setLayoutQualifier
argument_list|(
name|fieldLayoutQualifier
argument_list|)
expr_stmt|;
block|}
comment|// add array index
name|int
name|arraySize
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|arrayIndex
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|arraySizeErrorCheck
argument_list|(
name|arrayIndexLine
argument_list|,
name|arrayIndex
argument_list|,
name|arraySize
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
block|}
name|TInterfaceBlock
modifier|*
name|interfaceBlock
init|=
operator|new
name|TInterfaceBlock
argument_list|(
operator|&
name|blockName
argument_list|,
name|fieldList
argument_list|,
name|instanceName
argument_list|,
name|arraySize
argument_list|,
name|blockLayoutQualifier
argument_list|)
decl_stmt|;
name|TType
name|interfaceBlockType
argument_list|(
name|interfaceBlock
argument_list|,
name|typeQualifier
operator|.
name|qualifier
argument_list|,
name|blockLayoutQualifier
argument_list|,
name|arraySize
argument_list|)
decl_stmt|;
name|TString
name|symbolName
init|=
literal|""
decl_stmt|;
name|int
name|symbolId
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|instanceName
condition|)
block|{
comment|// define symbols for the members of the interface block
for|for
control|(
name|size_t
name|memberIndex
init|=
literal|0
init|;
name|memberIndex
operator|<
name|fieldList
operator|->
name|size
argument_list|()
condition|;
operator|++
name|memberIndex
control|)
block|{
name|TField
modifier|*
name|field
init|=
operator|(
operator|*
name|fieldList
operator|)
index|[
name|memberIndex
index|]
decl_stmt|;
name|TType
modifier|*
name|fieldType
init|=
name|field
operator|->
name|type
argument_list|()
decl_stmt|;
comment|// set parent pointer of the field variable
name|fieldType
operator|->
name|setInterfaceBlock
argument_list|(
name|interfaceBlock
argument_list|)
expr_stmt|;
name|TVariable
modifier|*
name|fieldVariable
init|=
operator|new
name|TVariable
argument_list|(
operator|&
name|field
operator|->
name|name
argument_list|()
argument_list|,
operator|*
name|fieldType
argument_list|)
decl_stmt|;
name|fieldVariable
operator|->
name|setQualifier
argument_list|(
name|typeQualifier
operator|.
name|qualifier
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|symbolTable
operator|.
name|declare
argument_list|(
name|fieldVariable
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|field
operator|->
name|line
argument_list|()
argument_list|,
literal|"redefinition"
argument_list|,
name|field
operator|->
name|name
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|,
literal|"interface block member name"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|reservedErrorCheck
argument_list|(
name|instanceLine
argument_list|,
operator|*
name|instanceName
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
comment|// add a symbol for this interface block
name|TVariable
modifier|*
name|instanceTypeDef
init|=
operator|new
name|TVariable
argument_list|(
name|instanceName
argument_list|,
name|interfaceBlockType
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|instanceTypeDef
operator|->
name|setQualifier
argument_list|(
name|typeQualifier
operator|.
name|qualifier
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|symbolTable
operator|.
name|declare
argument_list|(
name|instanceTypeDef
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|instanceLine
argument_list|,
literal|"redefinition"
argument_list|,
name|instanceName
operator|->
name|c_str
argument_list|()
argument_list|,
literal|"interface block instance name"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
name|symbolId
operator|=
name|instanceTypeDef
operator|->
name|getUniqueId
argument_list|()
expr_stmt|;
name|symbolName
operator|=
name|instanceTypeDef
operator|->
name|getName
argument_list|()
expr_stmt|;
block|}
name|TIntermAggregate
modifier|*
name|aggregate
init|=
name|intermediate
operator|.
name|makeAggregate
argument_list|(
name|intermediate
operator|.
name|addSymbol
argument_list|(
name|symbolId
argument_list|,
name|symbolName
argument_list|,
name|interfaceBlockType
argument_list|,
name|typeQualifier
operator|.
name|line
argument_list|)
argument_list|,
name|nameLine
argument_list|)
decl_stmt|;
name|aggregate
operator|->
name|setOp
argument_list|(
name|EOpDeclaration
argument_list|)
expr_stmt|;
name|exitStructDeclaration
argument_list|()
expr_stmt|;
return|return
name|aggregate
return|;
block|}
end_function
begin_function
DECL|function|enterStructDeclaration
name|bool
name|TParseContext
operator|::
name|enterStructDeclaration
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
specifier|const
name|TString
modifier|&
name|identifier
parameter_list|)
block|{
operator|++
name|mStructNestingLevel
expr_stmt|;
comment|// Embedded structure definitions are not supported per GLSL ES spec.
comment|// They aren't allowed in GLSL either, but we need to detect this here
comment|// so we don't rely on the GLSL compiler to catch it.
if|if
condition|(
name|mStructNestingLevel
operator|>
literal|1
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|""
argument_list|,
literal|"Embedded struct definitions are not allowed"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|exitStructDeclaration
name|void
name|TParseContext
operator|::
name|exitStructDeclaration
parameter_list|()
block|{
operator|--
name|mStructNestingLevel
expr_stmt|;
block|}
end_function
begin_namespace
namespace|namespace
block|{
DECL|member|kWebGLMaxStructNesting
specifier|const
name|int
name|kWebGLMaxStructNesting
init|=
literal|4
decl_stmt|;
block|}
end_namespace
begin_comment
comment|// namespace
end_comment
begin_function
DECL|function|structNestingErrorCheck
name|bool
name|TParseContext
operator|::
name|structNestingErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
specifier|const
name|TField
modifier|&
name|field
parameter_list|)
block|{
if|if
condition|(
operator|!
name|IsWebGLBasedSpec
argument_list|(
name|mShaderSpec
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|field
operator|.
name|type
argument_list|()
operator|->
name|getBasicType
argument_list|()
operator|!=
name|EbtStruct
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// We're already inside a structure definition at this point, so add
comment|// one to the field's struct nesting.
if|if
condition|(
literal|1
operator|+
name|field
operator|.
name|type
argument_list|()
operator|->
name|getDeepestStructNesting
argument_list|()
operator|>
name|kWebGLMaxStructNesting
condition|)
block|{
name|std
operator|::
name|stringstream
name|reasonStream
decl_stmt|;
name|reasonStream
operator|<<
literal|"Reference of struct type "
operator|<<
name|field
operator|.
name|type
argument_list|()
operator|->
name|getStruct
argument_list|()
operator|->
name|name
argument_list|()
operator|.
name|c_str
argument_list|()
operator|<<
literal|" exceeds maximum allowed nesting level of "
operator|<<
name|kWebGLMaxStructNesting
expr_stmt|;
name|std
operator|::
name|string
name|reason
init|=
name|reasonStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|error
argument_list|(
name|line
argument_list|,
name|reason
operator|.
name|c_str
argument_list|()
argument_list|,
name|field
operator|.
name|name
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Parse an array index expression
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addIndexExpression
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|addIndexExpression
parameter_list|(
name|TIntermTyped
modifier|*
name|baseExpression
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|location
parameter_list|,
name|TIntermTyped
modifier|*
name|indexExpression
parameter_list|)
block|{
name|TIntermTyped
modifier|*
name|indexedExpression
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|baseExpression
operator|->
name|isArray
argument_list|()
operator|&&
operator|!
name|baseExpression
operator|->
name|isMatrix
argument_list|()
operator|&&
operator|!
name|baseExpression
operator|->
name|isVector
argument_list|()
condition|)
block|{
if|if
condition|(
name|baseExpression
operator|->
name|getAsSymbolNode
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|location
argument_list|,
literal|" left of '[' is not of type array, matrix, or vector "
argument_list|,
name|baseExpression
operator|->
name|getAsSymbolNode
argument_list|()
operator|->
name|getSymbol
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
name|location
argument_list|,
literal|" left of '[' is not of type array, matrix, or vector "
argument_list|,
literal|"expression"
argument_list|)
expr_stmt|;
block|}
name|recover
argument_list|()
expr_stmt|;
block|}
name|TIntermConstantUnion
modifier|*
name|indexConstantUnion
init|=
name|indexExpression
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
comment|// TODO(oetuaho@nvidia.com): Get rid of indexConstantUnion == nullptr below once ANGLE is able
comment|// to constant fold all constant expressions. Right now we don't allow indexing interface blocks
comment|// or fragment outputs with expressions that ANGLE is not able to constant fold, even if the
comment|// index is a constant expression.
if|if
condition|(
name|indexExpression
operator|->
name|getQualifier
argument_list|()
operator|!=
name|EvqConst
operator|||
name|indexConstantUnion
operator|==
literal|nullptr
condition|)
block|{
if|if
condition|(
name|baseExpression
operator|->
name|isInterfaceBlock
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|location
argument_list|,
literal|""
argument_list|,
literal|"["
argument_list|,
literal|"array indexes for interface blocks arrays must be constant integral expressions"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|baseExpression
operator|->
name|getQualifier
argument_list|()
operator|==
name|EvqFragmentOut
condition|)
block|{
name|error
argument_list|(
name|location
argument_list|,
literal|""
argument_list|,
literal|"["
argument_list|,
literal|"array indexes for fragment outputs must be constant integral expressions"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mShaderSpec
operator|==
name|SH_WEBGL2_SPEC
operator|&&
name|baseExpression
operator|->
name|getQualifier
argument_list|()
operator|==
name|EvqFragData
condition|)
block|{
name|error
argument_list|(
name|location
argument_list|,
literal|""
argument_list|,
literal|"["
argument_list|,
literal|"array index for gl_FragData must be constant zero"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|indexConstantUnion
condition|)
block|{
comment|// If the index is not qualified as constant, the behavior in the spec is undefined. This
comment|// applies even if ANGLE has been able to constant fold it (ANGLE may constant fold
comment|// expressions that are not constant expressions). The most compatible way to handle this
comment|// case is to report a warning instead of an error and force the index to be in the
comment|// correct range.
name|bool
name|outOfRangeIndexIsError
init|=
name|indexExpression
operator|->
name|getQualifier
argument_list|()
operator|==
name|EvqConst
decl_stmt|;
name|int
name|index
init|=
name|indexConstantUnion
operator|->
name|getIConst
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
name|std
operator|::
name|stringstream
name|infoStream
decl_stmt|;
name|infoStream
operator|<<
name|index
expr_stmt|;
name|std
operator|::
name|string
name|info
init|=
name|infoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|outOfRangeError
argument_list|(
name|outOfRangeIndexIsError
argument_list|,
name|location
argument_list|,
literal|"negative index"
argument_list|,
name|info
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
block|}
name|TIntermConstantUnion
modifier|*
name|baseConstantUnion
init|=
name|baseExpression
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
if|if
condition|(
name|baseConstantUnion
condition|)
block|{
if|if
condition|(
name|baseExpression
operator|->
name|isArray
argument_list|()
condition|)
block|{
comment|// constant folding for array indexing
name|indexedExpression
operator|=
name|addConstArrayNode
argument_list|(
name|index
argument_list|,
name|baseConstantUnion
argument_list|,
name|location
argument_list|,
name|outOfRangeIndexIsError
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|baseExpression
operator|->
name|isVector
argument_list|()
condition|)
block|{
comment|// constant folding for vector indexing
name|TVectorFields
name|fields
decl_stmt|;
name|fields
operator|.
name|num
operator|=
literal|1
expr_stmt|;
name|fields
operator|.
name|offsets
index|[
literal|0
index|]
operator|=
name|index
expr_stmt|;
comment|// need to do it this way because v.xy sends fields integer array
name|indexedExpression
operator|=
name|addConstVectorNode
argument_list|(
name|fields
argument_list|,
name|baseConstantUnion
argument_list|,
name|location
argument_list|,
name|outOfRangeIndexIsError
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|baseExpression
operator|->
name|isMatrix
argument_list|()
condition|)
block|{
comment|// constant folding for matrix indexing
name|indexedExpression
operator|=
name|addConstMatrixNode
argument_list|(
name|index
argument_list|,
name|baseConstantUnion
argument_list|,
name|location
argument_list|,
name|outOfRangeIndexIsError
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|safeIndex
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|baseExpression
operator|->
name|isArray
argument_list|()
condition|)
block|{
if|if
condition|(
name|baseExpression
operator|->
name|getQualifier
argument_list|()
operator|==
name|EvqFragData
operator|&&
name|index
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|mShaderSpec
operator|==
name|SH_WEBGL2_SPEC
condition|)
block|{
comment|// Error has been already generated if index is not const.
if|if
condition|(
name|indexExpression
operator|->
name|getQualifier
argument_list|()
operator|==
name|EvqConst
condition|)
block|{
name|error
argument_list|(
name|location
argument_list|,
literal|""
argument_list|,
literal|"["
argument_list|,
literal|"array index for gl_FragData must be constant zero"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
name|safeIndex
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|isExtensionEnabled
argument_list|(
literal|"GL_EXT_draw_buffers"
argument_list|)
condition|)
block|{
name|outOfRangeError
argument_list|(
name|outOfRangeIndexIsError
argument_list|,
name|location
argument_list|,
literal|""
argument_list|,
literal|"["
argument_list|,
literal|"array index for gl_FragData must be zero when "
literal|"GL_EXT_draw_buffers is disabled"
argument_list|)
expr_stmt|;
name|safeIndex
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|// Only do generic out-of-range check if similar error hasn't already been reported.
if|if
condition|(
name|safeIndex
operator|<
literal|0
operator|&&
name|index
operator|>=
name|baseExpression
operator|->
name|getType
argument_list|()
operator|.
name|getArraySize
argument_list|()
condition|)
block|{
name|std
operator|::
name|stringstream
name|extraInfoStream
decl_stmt|;
name|extraInfoStream
operator|<<
literal|"array index out of range '"
operator|<<
name|index
operator|<<
literal|"'"
expr_stmt|;
name|std
operator|::
name|string
name|extraInfo
init|=
name|extraInfoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|outOfRangeError
argument_list|(
name|outOfRangeIndexIsError
argument_list|,
name|location
argument_list|,
literal|""
argument_list|,
literal|"["
argument_list|,
name|extraInfo
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|safeIndex
operator|=
name|baseExpression
operator|->
name|getType
argument_list|()
operator|.
name|getArraySize
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|baseExpression
operator|->
name|isVector
argument_list|()
operator|||
name|baseExpression
operator|->
name|isMatrix
argument_list|()
operator|)
operator|&&
name|baseExpression
operator|->
name|getType
argument_list|()
operator|.
name|getNominalSize
argument_list|()
operator|<=
name|index
condition|)
block|{
name|std
operator|::
name|stringstream
name|extraInfoStream
decl_stmt|;
name|extraInfoStream
operator|<<
literal|"field selection out of range '"
operator|<<
name|index
operator|<<
literal|"'"
expr_stmt|;
name|std
operator|::
name|string
name|extraInfo
init|=
name|extraInfoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|outOfRangeError
argument_list|(
name|outOfRangeIndexIsError
argument_list|,
name|location
argument_list|,
literal|""
argument_list|,
literal|"["
argument_list|,
name|extraInfo
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|safeIndex
operator|=
name|baseExpression
operator|->
name|getType
argument_list|()
operator|.
name|getNominalSize
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
comment|// Data of constant unions can't be changed, because it may be shared with other
comment|// constant unions or even builtins, like gl_MaxDrawBuffers. Instead use a new
comment|// sanitized object.
if|if
condition|(
name|safeIndex
operator|!=
operator|-
literal|1
condition|)
block|{
name|TConstantUnion
modifier|*
name|safeConstantUnion
init|=
operator|new
name|TConstantUnion
argument_list|()
decl_stmt|;
name|safeConstantUnion
operator|->
name|setIConst
argument_list|(
name|safeIndex
argument_list|)
expr_stmt|;
name|indexConstantUnion
operator|->
name|replaceConstantUnion
argument_list|(
name|safeConstantUnion
argument_list|)
expr_stmt|;
block|}
name|indexedExpression
operator|=
name|intermediate
operator|.
name|addIndex
argument_list|(
name|EOpIndexDirect
argument_list|,
name|baseExpression
argument_list|,
name|indexExpression
argument_list|,
name|location
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|indexedExpression
operator|=
name|intermediate
operator|.
name|addIndex
argument_list|(
name|EOpIndexIndirect
argument_list|,
name|baseExpression
argument_list|,
name|indexExpression
argument_list|,
name|location
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|indexedExpression
operator|==
literal|0
condition|)
block|{
name|TConstantUnion
modifier|*
name|unionArray
init|=
operator|new
name|TConstantUnion
index|[
literal|1
index|]
decl_stmt|;
name|unionArray
operator|->
name|setFConst
argument_list|(
literal|0.0f
argument_list|)
expr_stmt|;
name|indexedExpression
operator|=
name|intermediate
operator|.
name|addConstantUnion
argument_list|(
name|unionArray
argument_list|,
name|TType
argument_list|(
name|EbtFloat
argument_list|,
name|EbpHigh
argument_list|,
name|EvqConst
argument_list|)
argument_list|,
name|location
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|baseExpression
operator|->
name|isArray
argument_list|()
condition|)
block|{
name|TType
name|indexedType
init|=
name|baseExpression
operator|->
name|getType
argument_list|()
decl_stmt|;
name|indexedType
operator|.
name|clearArrayness
argument_list|()
expr_stmt|;
name|indexedExpression
operator|->
name|setType
argument_list|(
name|indexedType
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|baseExpression
operator|->
name|isMatrix
argument_list|()
condition|)
block|{
name|indexedExpression
operator|->
name|setType
argument_list|(
name|TType
argument_list|(
name|baseExpression
operator|->
name|getBasicType
argument_list|()
argument_list|,
name|baseExpression
operator|->
name|getPrecision
argument_list|()
argument_list|,
name|EvqTemporary
argument_list|,
cast|static_cast
argument_list|<
name|unsigned
name|char
argument_list|>
argument_list|(
name|baseExpression
operator|->
name|getRows
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|baseExpression
operator|->
name|isVector
argument_list|()
condition|)
block|{
name|indexedExpression
operator|->
name|setType
argument_list|(
name|TType
argument_list|(
name|baseExpression
operator|->
name|getBasicType
argument_list|()
argument_list|,
name|baseExpression
operator|->
name|getPrecision
argument_list|()
argument_list|,
name|EvqTemporary
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indexedExpression
operator|->
name|setType
argument_list|(
name|baseExpression
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|baseExpression
operator|->
name|getType
argument_list|()
operator|.
name|getQualifier
argument_list|()
operator|==
name|EvqConst
operator|&&
name|indexExpression
operator|->
name|getType
argument_list|()
operator|.
name|getQualifier
argument_list|()
operator|==
name|EvqConst
condition|)
block|{
name|indexedExpression
operator|->
name|getTypePointer
argument_list|()
operator|->
name|setQualifier
argument_list|(
name|EvqConst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indexedExpression
operator|->
name|getTypePointer
argument_list|()
operator|->
name|setQualifier
argument_list|(
name|EvqTemporary
argument_list|)
expr_stmt|;
block|}
return|return
name|indexedExpression
return|;
block|}
end_function
begin_function
DECL|function|addFieldSelectionExpression
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|addFieldSelectionExpression
parameter_list|(
name|TIntermTyped
modifier|*
name|baseExpression
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|dotLocation
parameter_list|,
specifier|const
name|TString
modifier|&
name|fieldString
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|fieldLocation
parameter_list|)
block|{
name|TIntermTyped
modifier|*
name|indexedExpression
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|baseExpression
operator|->
name|isArray
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|fieldLocation
argument_list|,
literal|"cannot apply dot operator to an array"
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|baseExpression
operator|->
name|isVector
argument_list|()
condition|)
block|{
name|TVectorFields
name|fields
decl_stmt|;
if|if
condition|(
operator|!
name|parseVectorFields
argument_list|(
name|fieldString
argument_list|,
name|baseExpression
operator|->
name|getNominalSize
argument_list|()
argument_list|,
name|fields
argument_list|,
name|fieldLocation
argument_list|)
condition|)
block|{
name|fields
operator|.
name|num
operator|=
literal|1
expr_stmt|;
name|fields
operator|.
name|offsets
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|baseExpression
operator|->
name|getAsConstantUnion
argument_list|()
condition|)
block|{
comment|// constant folding for vector fields
name|indexedExpression
operator|=
name|addConstVectorNode
argument_list|(
name|fields
argument_list|,
name|baseExpression
operator|->
name|getAsConstantUnion
argument_list|()
argument_list|,
name|fieldLocation
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TIntermTyped
modifier|*
name|index
init|=
name|intermediate
operator|.
name|addSwizzle
argument_list|(
name|fields
argument_list|,
name|fieldLocation
argument_list|)
decl_stmt|;
name|indexedExpression
operator|=
name|intermediate
operator|.
name|addIndex
argument_list|(
name|EOpVectorSwizzle
argument_list|,
name|baseExpression
argument_list|,
name|index
argument_list|,
name|dotLocation
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|indexedExpression
operator|==
literal|nullptr
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
name|indexedExpression
operator|=
name|baseExpression
expr_stmt|;
block|}
else|else
block|{
comment|// Note that the qualifier set here will be corrected later.
name|indexedExpression
operator|->
name|setType
argument_list|(
name|TType
argument_list|(
name|baseExpression
operator|->
name|getBasicType
argument_list|()
argument_list|,
name|baseExpression
operator|->
name|getPrecision
argument_list|()
argument_list|,
name|EvqTemporary
argument_list|,
call|(
name|unsigned
name|char
call|)
argument_list|(
name|fieldString
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|baseExpression
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtStruct
condition|)
block|{
name|bool
name|fieldFound
init|=
literal|false
decl_stmt|;
specifier|const
name|TFieldList
modifier|&
name|fields
init|=
name|baseExpression
operator|->
name|getType
argument_list|()
operator|.
name|getStruct
argument_list|()
operator|->
name|fields
argument_list|()
decl_stmt|;
if|if
condition|(
name|fields
operator|.
name|empty
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|dotLocation
argument_list|,
literal|"structure has no fields"
argument_list|,
literal|"Internal Error"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
name|indexedExpression
operator|=
name|baseExpression
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|fields
index|[
name|i
index|]
operator|->
name|name
argument_list|()
operator|==
name|fieldString
condition|)
block|{
name|fieldFound
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|fieldFound
condition|)
block|{
if|if
condition|(
name|baseExpression
operator|->
name|getAsConstantUnion
argument_list|()
condition|)
block|{
name|indexedExpression
operator|=
name|addConstStruct
argument_list|(
name|fieldString
argument_list|,
name|baseExpression
argument_list|,
name|dotLocation
argument_list|)
expr_stmt|;
if|if
condition|(
name|indexedExpression
operator|==
literal|0
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
name|indexedExpression
operator|=
name|baseExpression
expr_stmt|;
block|}
else|else
block|{
name|indexedExpression
operator|->
name|setType
argument_list|(
operator|*
name|fields
index|[
name|i
index|]
operator|->
name|type
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|TConstantUnion
modifier|*
name|unionArray
init|=
operator|new
name|TConstantUnion
index|[
literal|1
index|]
decl_stmt|;
name|unionArray
operator|->
name|setIConst
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|TIntermTyped
modifier|*
name|index
init|=
name|intermediate
operator|.
name|addConstantUnion
argument_list|(
name|unionArray
argument_list|,
operator|*
name|fields
index|[
name|i
index|]
operator|->
name|type
argument_list|()
argument_list|,
name|fieldLocation
argument_list|)
decl_stmt|;
name|indexedExpression
operator|=
name|intermediate
operator|.
name|addIndex
argument_list|(
name|EOpIndexDirectStruct
argument_list|,
name|baseExpression
argument_list|,
name|index
argument_list|,
name|dotLocation
argument_list|)
expr_stmt|;
name|indexedExpression
operator|->
name|setType
argument_list|(
operator|*
name|fields
index|[
name|i
index|]
operator|->
name|type
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
argument_list|(
name|dotLocation
argument_list|,
literal|" no such field in structure"
argument_list|,
name|fieldString
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
name|indexedExpression
operator|=
name|baseExpression
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|baseExpression
operator|->
name|isInterfaceBlock
argument_list|()
condition|)
block|{
name|bool
name|fieldFound
init|=
literal|false
decl_stmt|;
specifier|const
name|TFieldList
modifier|&
name|fields
init|=
name|baseExpression
operator|->
name|getType
argument_list|()
operator|.
name|getInterfaceBlock
argument_list|()
operator|->
name|fields
argument_list|()
decl_stmt|;
if|if
condition|(
name|fields
operator|.
name|empty
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|dotLocation
argument_list|,
literal|"interface block has no fields"
argument_list|,
literal|"Internal Error"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
name|indexedExpression
operator|=
name|baseExpression
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|fields
index|[
name|i
index|]
operator|->
name|name
argument_list|()
operator|==
name|fieldString
condition|)
block|{
name|fieldFound
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|fieldFound
condition|)
block|{
name|TConstantUnion
modifier|*
name|unionArray
init|=
operator|new
name|TConstantUnion
index|[
literal|1
index|]
decl_stmt|;
name|unionArray
operator|->
name|setIConst
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|TIntermTyped
modifier|*
name|index
init|=
name|intermediate
operator|.
name|addConstantUnion
argument_list|(
name|unionArray
argument_list|,
operator|*
name|fields
index|[
name|i
index|]
operator|->
name|type
argument_list|()
argument_list|,
name|fieldLocation
argument_list|)
decl_stmt|;
name|indexedExpression
operator|=
name|intermediate
operator|.
name|addIndex
argument_list|(
name|EOpIndexDirectInterfaceBlock
argument_list|,
name|baseExpression
argument_list|,
name|index
argument_list|,
name|dotLocation
argument_list|)
expr_stmt|;
name|indexedExpression
operator|->
name|setType
argument_list|(
operator|*
name|fields
index|[
name|i
index|]
operator|->
name|type
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
name|dotLocation
argument_list|,
literal|" no such field in interface block"
argument_list|,
name|fieldString
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
name|indexedExpression
operator|=
name|baseExpression
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|mShaderVersion
operator|<
literal|300
condition|)
block|{
name|error
argument_list|(
name|dotLocation
argument_list|,
literal|" field selection requires structure or vector on left hand side"
argument_list|,
name|fieldString
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
name|dotLocation
argument_list|,
literal|" field selection requires structure, vector, or interface block on left hand "
literal|"side"
argument_list|,
name|fieldString
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|recover
argument_list|()
expr_stmt|;
name|indexedExpression
operator|=
name|baseExpression
expr_stmt|;
block|}
if|if
condition|(
name|baseExpression
operator|->
name|getQualifier
argument_list|()
operator|==
name|EvqConst
condition|)
block|{
name|indexedExpression
operator|->
name|getTypePointer
argument_list|()
operator|->
name|setQualifier
argument_list|(
name|EvqConst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indexedExpression
operator|->
name|getTypePointer
argument_list|()
operator|->
name|setQualifier
argument_list|(
name|EvqTemporary
argument_list|)
expr_stmt|;
block|}
return|return
name|indexedExpression
return|;
block|}
end_function
begin_function
DECL|function|parseLayoutQualifier
name|TLayoutQualifier
name|TParseContext
operator|::
name|parseLayoutQualifier
parameter_list|(
specifier|const
name|TString
modifier|&
name|qualifierType
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|qualifierTypeLine
parameter_list|)
block|{
name|TLayoutQualifier
name|qualifier
decl_stmt|;
name|qualifier
operator|.
name|location
operator|=
operator|-
literal|1
expr_stmt|;
name|qualifier
operator|.
name|matrixPacking
operator|=
name|EmpUnspecified
expr_stmt|;
name|qualifier
operator|.
name|blockStorage
operator|=
name|EbsUnspecified
expr_stmt|;
if|if
condition|(
name|qualifierType
operator|==
literal|"shared"
condition|)
block|{
name|qualifier
operator|.
name|blockStorage
operator|=
name|EbsShared
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qualifierType
operator|==
literal|"packed"
condition|)
block|{
name|qualifier
operator|.
name|blockStorage
operator|=
name|EbsPacked
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qualifierType
operator|==
literal|"std140"
condition|)
block|{
name|qualifier
operator|.
name|blockStorage
operator|=
name|EbsStd140
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qualifierType
operator|==
literal|"row_major"
condition|)
block|{
name|qualifier
operator|.
name|matrixPacking
operator|=
name|EmpRowMajor
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qualifierType
operator|==
literal|"column_major"
condition|)
block|{
name|qualifier
operator|.
name|matrixPacking
operator|=
name|EmpColumnMajor
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qualifierType
operator|==
literal|"location"
condition|)
block|{
name|error
argument_list|(
name|qualifierTypeLine
argument_list|,
literal|"invalid layout qualifier"
argument_list|,
name|qualifierType
operator|.
name|c_str
argument_list|()
argument_list|,
literal|"location requires an argument"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
name|qualifierTypeLine
argument_list|,
literal|"invalid layout qualifier"
argument_list|,
name|qualifierType
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
return|return
name|qualifier
return|;
block|}
end_function
begin_function
DECL|function|parseLayoutQualifier
name|TLayoutQualifier
name|TParseContext
operator|::
name|parseLayoutQualifier
parameter_list|(
specifier|const
name|TString
modifier|&
name|qualifierType
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|qualifierTypeLine
parameter_list|,
specifier|const
name|TString
modifier|&
name|intValueString
parameter_list|,
name|int
name|intValue
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|intValueLine
parameter_list|)
block|{
name|TLayoutQualifier
name|qualifier
decl_stmt|;
name|qualifier
operator|.
name|location
operator|=
operator|-
literal|1
expr_stmt|;
name|qualifier
operator|.
name|matrixPacking
operator|=
name|EmpUnspecified
expr_stmt|;
name|qualifier
operator|.
name|blockStorage
operator|=
name|EbsUnspecified
expr_stmt|;
if|if
condition|(
name|qualifierType
operator|!=
literal|"location"
condition|)
block|{
name|error
argument_list|(
name|qualifierTypeLine
argument_list|,
literal|"invalid layout qualifier"
argument_list|,
name|qualifierType
operator|.
name|c_str
argument_list|()
argument_list|,
literal|"only location may have arguments"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// must check that location is non-negative
if|if
condition|(
name|intValue
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
name|intValueLine
argument_list|,
literal|"out of range:"
argument_list|,
name|intValueString
operator|.
name|c_str
argument_list|()
argument_list|,
literal|"location must be non-negative"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|qualifier
operator|.
name|location
operator|=
name|intValue
expr_stmt|;
block|}
block|}
return|return
name|qualifier
return|;
block|}
end_function
begin_function
DECL|function|joinLayoutQualifiers
name|TLayoutQualifier
name|TParseContext
operator|::
name|joinLayoutQualifiers
parameter_list|(
name|TLayoutQualifier
name|leftQualifier
parameter_list|,
name|TLayoutQualifier
name|rightQualifier
parameter_list|)
block|{
name|TLayoutQualifier
name|joinedQualifier
init|=
name|leftQualifier
decl_stmt|;
if|if
condition|(
name|rightQualifier
operator|.
name|location
operator|!=
operator|-
literal|1
condition|)
block|{
name|joinedQualifier
operator|.
name|location
operator|=
name|rightQualifier
operator|.
name|location
expr_stmt|;
block|}
if|if
condition|(
name|rightQualifier
operator|.
name|matrixPacking
operator|!=
name|EmpUnspecified
condition|)
block|{
name|joinedQualifier
operator|.
name|matrixPacking
operator|=
name|rightQualifier
operator|.
name|matrixPacking
expr_stmt|;
block|}
if|if
condition|(
name|rightQualifier
operator|.
name|blockStorage
operator|!=
name|EbsUnspecified
condition|)
block|{
name|joinedQualifier
operator|.
name|blockStorage
operator|=
name|rightQualifier
operator|.
name|blockStorage
expr_stmt|;
block|}
return|return
name|joinedQualifier
return|;
block|}
end_function
begin_function
DECL|function|joinInterpolationQualifiers
name|TPublicType
name|TParseContext
operator|::
name|joinInterpolationQualifiers
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|interpolationLoc
parameter_list|,
name|TQualifier
name|interpolationQualifier
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|storageLoc
parameter_list|,
name|TQualifier
name|storageQualifier
parameter_list|)
block|{
name|TQualifier
name|mergedQualifier
init|=
name|EvqSmoothIn
decl_stmt|;
if|if
condition|(
name|storageQualifier
operator|==
name|EvqFragmentIn
condition|)
block|{
if|if
condition|(
name|interpolationQualifier
operator|==
name|EvqSmooth
condition|)
name|mergedQualifier
operator|=
name|EvqSmoothIn
expr_stmt|;
elseif|else
if|if
condition|(
name|interpolationQualifier
operator|==
name|EvqFlat
condition|)
name|mergedQualifier
operator|=
name|EvqFlatIn
expr_stmt|;
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|storageQualifier
operator|==
name|EvqCentroidIn
condition|)
block|{
if|if
condition|(
name|interpolationQualifier
operator|==
name|EvqSmooth
condition|)
name|mergedQualifier
operator|=
name|EvqCentroidIn
expr_stmt|;
elseif|else
if|if
condition|(
name|interpolationQualifier
operator|==
name|EvqFlat
condition|)
name|mergedQualifier
operator|=
name|EvqFlatIn
expr_stmt|;
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|storageQualifier
operator|==
name|EvqVertexOut
condition|)
block|{
if|if
condition|(
name|interpolationQualifier
operator|==
name|EvqSmooth
condition|)
name|mergedQualifier
operator|=
name|EvqSmoothOut
expr_stmt|;
elseif|else
if|if
condition|(
name|interpolationQualifier
operator|==
name|EvqFlat
condition|)
name|mergedQualifier
operator|=
name|EvqFlatOut
expr_stmt|;
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|storageQualifier
operator|==
name|EvqCentroidOut
condition|)
block|{
if|if
condition|(
name|interpolationQualifier
operator|==
name|EvqSmooth
condition|)
name|mergedQualifier
operator|=
name|EvqCentroidOut
expr_stmt|;
elseif|else
if|if
condition|(
name|interpolationQualifier
operator|==
name|EvqFlat
condition|)
name|mergedQualifier
operator|=
name|EvqFlatOut
expr_stmt|;
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
name|interpolationLoc
argument_list|,
literal|"interpolation qualifier requires a fragment 'in' or vertex 'out' storage qualifier"
argument_list|,
name|getInterpolationString
argument_list|(
name|interpolationQualifier
argument_list|)
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
name|mergedQualifier
operator|=
name|storageQualifier
expr_stmt|;
block|}
name|TPublicType
name|type
decl_stmt|;
name|type
operator|.
name|setBasic
argument_list|(
name|EbtVoid
argument_list|,
name|mergedQualifier
argument_list|,
name|storageLoc
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function
begin_function
DECL|function|addStructDeclaratorList
name|TFieldList
modifier|*
name|TParseContext
operator|::
name|addStructDeclaratorList
parameter_list|(
specifier|const
name|TPublicType
modifier|&
name|typeSpecifier
parameter_list|,
name|TFieldList
modifier|*
name|fieldList
parameter_list|)
block|{
if|if
condition|(
name|voidErrorCheck
argument_list|(
name|typeSpecifier
operator|.
name|line
argument_list|,
operator|(
operator|*
name|fieldList
operator|)
index|[
literal|0
index|]
operator|->
name|name
argument_list|()
argument_list|,
name|typeSpecifier
operator|.
name|type
argument_list|)
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fieldList
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
comment|//
comment|// Careful not to replace already known aspects of type, like array-ness
comment|//
name|TType
modifier|*
name|type
init|=
operator|(
operator|*
name|fieldList
operator|)
index|[
name|i
index|]
operator|->
name|type
argument_list|()
decl_stmt|;
name|type
operator|->
name|setBasicType
argument_list|(
name|typeSpecifier
operator|.
name|type
argument_list|)
expr_stmt|;
name|type
operator|->
name|setPrimarySize
argument_list|(
name|typeSpecifier
operator|.
name|primarySize
argument_list|)
expr_stmt|;
name|type
operator|->
name|setSecondarySize
argument_list|(
name|typeSpecifier
operator|.
name|secondarySize
argument_list|)
expr_stmt|;
name|type
operator|->
name|setPrecision
argument_list|(
name|typeSpecifier
operator|.
name|precision
argument_list|)
expr_stmt|;
name|type
operator|->
name|setQualifier
argument_list|(
name|typeSpecifier
operator|.
name|qualifier
argument_list|)
expr_stmt|;
name|type
operator|->
name|setLayoutQualifier
argument_list|(
name|typeSpecifier
operator|.
name|layoutQualifier
argument_list|)
expr_stmt|;
comment|// don't allow arrays of arrays
if|if
condition|(
name|type
operator|->
name|isArray
argument_list|()
condition|)
block|{
if|if
condition|(
name|arrayTypeErrorCheck
argument_list|(
name|typeSpecifier
operator|.
name|line
argument_list|,
name|typeSpecifier
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|typeSpecifier
operator|.
name|array
condition|)
name|type
operator|->
name|setArraySize
argument_list|(
name|typeSpecifier
operator|.
name|arraySize
argument_list|)
expr_stmt|;
if|if
condition|(
name|typeSpecifier
operator|.
name|userDef
condition|)
block|{
name|type
operator|->
name|setStruct
argument_list|(
name|typeSpecifier
operator|.
name|userDef
operator|->
name|getStruct
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|structNestingErrorCheck
argument_list|(
name|typeSpecifier
operator|.
name|line
argument_list|,
operator|*
operator|(
operator|*
name|fieldList
operator|)
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|fieldList
return|;
block|}
end_function
begin_function
DECL|function|addStructure
name|TPublicType
name|TParseContext
operator|::
name|addStructure
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|structLine
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|nameLine
parameter_list|,
specifier|const
name|TString
modifier|*
name|structName
parameter_list|,
name|TFieldList
modifier|*
name|fieldList
parameter_list|)
block|{
name|TStructure
modifier|*
name|structure
init|=
operator|new
name|TStructure
argument_list|(
name|structName
argument_list|,
name|fieldList
argument_list|)
decl_stmt|;
name|TType
modifier|*
name|structureType
init|=
operator|new
name|TType
argument_list|(
name|structure
argument_list|)
decl_stmt|;
comment|// Store a bool in the struct if we're at global scope, to allow us to
comment|// skip the local struct scoping workaround in HLSL.
name|structure
operator|->
name|setUniqueId
argument_list|(
name|TSymbolTable
operator|::
name|nextUniqueId
argument_list|()
argument_list|)
expr_stmt|;
name|structure
operator|->
name|setAtGlobalScope
argument_list|(
name|symbolTable
operator|.
name|atGlobalLevel
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|structName
operator|->
name|empty
argument_list|()
condition|)
block|{
if|if
condition|(
name|reservedErrorCheck
argument_list|(
name|nameLine
argument_list|,
operator|*
name|structName
argument_list|)
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
block|}
name|TVariable
modifier|*
name|userTypeDef
init|=
operator|new
name|TVariable
argument_list|(
name|structName
argument_list|,
operator|*
name|structureType
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|symbolTable
operator|.
name|declare
argument_list|(
name|userTypeDef
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|nameLine
argument_list|,
literal|"redefinition"
argument_list|,
name|structName
operator|->
name|c_str
argument_list|()
argument_list|,
literal|"struct"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
block|}
comment|// ensure we do not specify any storage qualifiers on the struct members
for|for
control|(
name|unsigned
name|int
name|typeListIndex
init|=
literal|0
init|;
name|typeListIndex
operator|<
name|fieldList
operator|->
name|size
argument_list|()
condition|;
name|typeListIndex
operator|++
control|)
block|{
specifier|const
name|TField
modifier|&
name|field
init|=
operator|*
operator|(
operator|*
name|fieldList
operator|)
index|[
name|typeListIndex
index|]
decl_stmt|;
specifier|const
name|TQualifier
name|qualifier
init|=
name|field
operator|.
name|type
argument_list|()
operator|->
name|getQualifier
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|qualifier
condition|)
block|{
case|case
name|EvqGlobal
case|:
case|case
name|EvqTemporary
case|:
break|break;
default|default:
name|error
argument_list|(
name|field
operator|.
name|line
argument_list|()
argument_list|,
literal|"invalid qualifier on struct member"
argument_list|,
name|getQualifierString
argument_list|(
name|qualifier
argument_list|)
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|TPublicType
name|publicType
decl_stmt|;
name|publicType
operator|.
name|setBasic
argument_list|(
name|EbtStruct
argument_list|,
name|EvqTemporary
argument_list|,
name|structLine
argument_list|)
expr_stmt|;
name|publicType
operator|.
name|userDef
operator|=
name|structureType
expr_stmt|;
name|publicType
operator|.
name|isStructSpecifier
operator|=
literal|true
expr_stmt|;
name|exitStructDeclaration
argument_list|()
expr_stmt|;
return|return
name|publicType
return|;
block|}
end_function
begin_function
DECL|function|addSwitch
name|TIntermSwitch
modifier|*
name|TParseContext
operator|::
name|addSwitch
parameter_list|(
name|TIntermTyped
modifier|*
name|init
parameter_list|,
name|TIntermAggregate
modifier|*
name|statementList
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|)
block|{
name|TBasicType
name|switchType
init|=
name|init
operator|->
name|getBasicType
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|switchType
operator|!=
name|EbtInt
operator|&&
name|switchType
operator|!=
name|EbtUInt
operator|)
operator|||
name|init
operator|->
name|isMatrix
argument_list|()
operator|||
name|init
operator|->
name|isArray
argument_list|()
operator|||
name|init
operator|->
name|isVector
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|init
operator|->
name|getLine
argument_list|()
argument_list|,
literal|"init-expression in a switch statement must be a scalar integer"
argument_list|,
literal|"switch"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
if|if
condition|(
name|statementList
condition|)
block|{
if|if
condition|(
operator|!
name|ValidateSwitch
operator|::
name|validate
argument_list|(
name|switchType
argument_list|,
name|this
argument_list|,
name|statementList
argument_list|,
name|loc
argument_list|)
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
block|}
name|TIntermSwitch
modifier|*
name|node
init|=
name|intermediate
operator|.
name|addSwitch
argument_list|(
name|init
argument_list|,
name|statementList
argument_list|,
name|loc
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|nullptr
condition|)
block|{
name|error
argument_list|(
name|loc
argument_list|,
literal|"erroneous switch statement"
argument_list|,
literal|"switch"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
return|return
name|node
return|;
block|}
end_function
begin_function
DECL|function|addCase
name|TIntermCase
modifier|*
name|TParseContext
operator|::
name|addCase
parameter_list|(
name|TIntermTyped
modifier|*
name|condition
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|)
block|{
if|if
condition|(
name|mSwitchNestingLevel
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|loc
argument_list|,
literal|"case labels need to be inside switch statements"
argument_list|,
literal|"case"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
if|if
condition|(
name|condition
operator|==
literal|nullptr
condition|)
block|{
name|error
argument_list|(
name|loc
argument_list|,
literal|"case label must have a condition"
argument_list|,
literal|"case"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
if|if
condition|(
operator|(
name|condition
operator|->
name|getBasicType
argument_list|()
operator|!=
name|EbtInt
operator|&&
name|condition
operator|->
name|getBasicType
argument_list|()
operator|!=
name|EbtUInt
operator|)
operator|||
name|condition
operator|->
name|isMatrix
argument_list|()
operator|||
name|condition
operator|->
name|isArray
argument_list|()
operator|||
name|condition
operator|->
name|isVector
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|condition
operator|->
name|getLine
argument_list|()
argument_list|,
literal|"case label must be a scalar integer"
argument_list|,
literal|"case"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
name|TIntermConstantUnion
modifier|*
name|conditionConst
init|=
name|condition
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
comment|// TODO(oetuaho@nvidia.com): Get rid of the conditionConst == nullptr check once all constant
comment|// expressions can be folded. Right now we don't allow constant expressions that ANGLE can't
comment|// fold in case labels.
if|if
condition|(
name|condition
operator|->
name|getQualifier
argument_list|()
operator|!=
name|EvqConst
operator|||
name|conditionConst
operator|==
literal|nullptr
condition|)
block|{
name|error
argument_list|(
name|condition
operator|->
name|getLine
argument_list|()
argument_list|,
literal|"case label must be constant"
argument_list|,
literal|"case"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
name|TIntermCase
modifier|*
name|node
init|=
name|intermediate
operator|.
name|addCase
argument_list|(
name|condition
argument_list|,
name|loc
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|nullptr
condition|)
block|{
name|error
argument_list|(
name|loc
argument_list|,
literal|"erroneous case statement"
argument_list|,
literal|"case"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
return|return
name|node
return|;
block|}
end_function
begin_function
DECL|function|addDefault
name|TIntermCase
modifier|*
name|TParseContext
operator|::
name|addDefault
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|)
block|{
if|if
condition|(
name|mSwitchNestingLevel
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|loc
argument_list|,
literal|"default labels need to be inside switch statements"
argument_list|,
literal|"default"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
name|TIntermCase
modifier|*
name|node
init|=
name|intermediate
operator|.
name|addCase
argument_list|(
literal|nullptr
argument_list|,
name|loc
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|nullptr
condition|)
block|{
name|error
argument_list|(
name|loc
argument_list|,
literal|"erroneous default statement"
argument_list|,
literal|"default"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
return|return
name|node
return|;
block|}
end_function
begin_function
DECL|function|createUnaryMath
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|createUnaryMath
parameter_list|(
name|TOperator
name|op
parameter_list|,
name|TIntermTyped
modifier|*
name|child
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|,
specifier|const
name|TType
modifier|*
name|funcReturnType
parameter_list|)
block|{
if|if
condition|(
name|child
operator|==
literal|nullptr
condition|)
block|{
return|return
literal|nullptr
return|;
block|}
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|EOpLogicalNot
case|:
if|if
condition|(
name|child
operator|->
name|getBasicType
argument_list|()
operator|!=
name|EbtBool
operator|||
name|child
operator|->
name|isMatrix
argument_list|()
operator|||
name|child
operator|->
name|isArray
argument_list|()
operator|||
name|child
operator|->
name|isVector
argument_list|()
condition|)
block|{
return|return
literal|nullptr
return|;
block|}
break|break;
case|case
name|EOpBitwiseNot
case|:
if|if
condition|(
operator|(
name|child
operator|->
name|getBasicType
argument_list|()
operator|!=
name|EbtInt
operator|&&
name|child
operator|->
name|getBasicType
argument_list|()
operator|!=
name|EbtUInt
operator|)
operator|||
name|child
operator|->
name|isMatrix
argument_list|()
operator|||
name|child
operator|->
name|isArray
argument_list|()
condition|)
block|{
return|return
literal|nullptr
return|;
block|}
break|break;
case|case
name|EOpPostIncrement
case|:
case|case
name|EOpPreIncrement
case|:
case|case
name|EOpPostDecrement
case|:
case|case
name|EOpPreDecrement
case|:
case|case
name|EOpNegative
case|:
case|case
name|EOpPositive
case|:
if|if
condition|(
name|child
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtStruct
operator|||
name|child
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtBool
operator|||
name|child
operator|->
name|isArray
argument_list|()
condition|)
block|{
return|return
literal|nullptr
return|;
block|}
comment|// Operators for built-ins are already type checked against their prototype.
default|default:
break|break;
block|}
return|return
name|intermediate
operator|.
name|addUnaryMath
argument_list|(
name|op
argument_list|,
name|child
argument_list|,
name|loc
argument_list|,
name|funcReturnType
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|addUnaryMath
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|addUnaryMath
parameter_list|(
name|TOperator
name|op
parameter_list|,
name|TIntermTyped
modifier|*
name|child
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|)
block|{
name|TIntermTyped
modifier|*
name|node
init|=
name|createUnaryMath
argument_list|(
name|op
argument_list|,
name|child
argument_list|,
name|loc
argument_list|,
literal|nullptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|nullptr
condition|)
block|{
name|unaryOpError
argument_list|(
name|loc
argument_list|,
name|GetOperatorString
argument_list|(
name|op
argument_list|)
argument_list|,
name|child
operator|->
name|getCompleteString
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
name|child
return|;
block|}
return|return
name|node
return|;
block|}
end_function
begin_function
DECL|function|addUnaryMathLValue
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|addUnaryMathLValue
parameter_list|(
name|TOperator
name|op
parameter_list|,
name|TIntermTyped
modifier|*
name|child
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|)
block|{
if|if
condition|(
name|lValueErrorCheck
argument_list|(
name|loc
argument_list|,
name|GetOperatorString
argument_list|(
name|op
argument_list|)
argument_list|,
name|child
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
return|return
name|addUnaryMath
argument_list|(
name|op
argument_list|,
name|child
argument_list|,
name|loc
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|binaryOpCommonCheck
name|bool
name|TParseContext
operator|::
name|binaryOpCommonCheck
parameter_list|(
name|TOperator
name|op
parameter_list|,
name|TIntermTyped
modifier|*
name|left
parameter_list|,
name|TIntermTyped
modifier|*
name|right
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|)
block|{
if|if
condition|(
name|left
operator|->
name|isArray
argument_list|()
operator|||
name|right
operator|->
name|isArray
argument_list|()
condition|)
block|{
if|if
condition|(
name|mShaderVersion
operator|<
literal|300
condition|)
block|{
name|error
argument_list|(
name|loc
argument_list|,
literal|"Invalid operation for arrays"
argument_list|,
name|GetOperatorString
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|left
operator|->
name|isArray
argument_list|()
operator|!=
name|right
operator|->
name|isArray
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|loc
argument_list|,
literal|"array / non-array mismatch"
argument_list|,
name|GetOperatorString
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|EOpEqual
case|:
case|case
name|EOpNotEqual
case|:
case|case
name|EOpAssign
case|:
case|case
name|EOpInitialize
case|:
break|break;
default|default:
name|error
argument_list|(
name|loc
argument_list|,
literal|"Invalid operation for arrays"
argument_list|,
name|GetOperatorString
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// At this point, size of implicitly sized arrays should be resolved.
if|if
condition|(
name|left
operator|->
name|getArraySize
argument_list|()
operator|!=
name|right
operator|->
name|getArraySize
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|loc
argument_list|,
literal|"array size mismatch"
argument_list|,
name|GetOperatorString
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|// Check ops which require integer / ivec parameters
name|bool
name|isBitShift
init|=
literal|false
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|EOpBitShiftLeft
case|:
case|case
name|EOpBitShiftRight
case|:
case|case
name|EOpBitShiftLeftAssign
case|:
case|case
name|EOpBitShiftRightAssign
case|:
comment|// Unsigned can be bit-shifted by signed and vice versa, but we need to
comment|// check that the basic type is an integer type.
name|isBitShift
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|IsInteger
argument_list|(
name|left
operator|->
name|getBasicType
argument_list|()
argument_list|)
operator|||
operator|!
name|IsInteger
argument_list|(
name|right
operator|->
name|getBasicType
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
break|break;
case|case
name|EOpBitwiseAnd
case|:
case|case
name|EOpBitwiseXor
case|:
case|case
name|EOpBitwiseOr
case|:
case|case
name|EOpBitwiseAndAssign
case|:
case|case
name|EOpBitwiseXorAssign
case|:
case|case
name|EOpBitwiseOrAssign
case|:
comment|// It is enough to check the type of only one operand, since later it
comment|// is checked that the operand types match.
if|if
condition|(
operator|!
name|IsInteger
argument_list|(
name|left
operator|->
name|getBasicType
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
break|break;
default|default:
break|break;
block|}
comment|// GLSL ES 1.00 and 3.00 do not support implicit type casting.
comment|// So the basic type should usually match.
if|if
condition|(
operator|!
name|isBitShift
operator|&&
name|left
operator|->
name|getBasicType
argument_list|()
operator|!=
name|right
operator|->
name|getBasicType
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Check that type sizes match exactly on ops that require that.
comment|// Also check restrictions for structs that contain arrays or samplers.
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|EOpAssign
case|:
case|case
name|EOpInitialize
case|:
case|case
name|EOpEqual
case|:
case|case
name|EOpNotEqual
case|:
comment|// ESSL 1.00 sections 5.7, 5.8, 5.9
if|if
condition|(
name|mShaderVersion
operator|<
literal|300
operator|&&
name|left
operator|->
name|getType
argument_list|()
operator|.
name|isStructureContainingArrays
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|loc
argument_list|,
literal|"undefined operation for structs containing arrays"
argument_list|,
name|GetOperatorString
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Samplers as l-values are disallowed also in ESSL 3.00, see section 4.1.7,
comment|// we interpret the spec so that this extends to structs containing samplers,
comment|// similarly to ESSL 1.00 spec.
if|if
condition|(
operator|(
name|mShaderVersion
operator|<
literal|300
operator|||
name|op
operator|==
name|EOpAssign
operator|||
name|op
operator|==
name|EOpInitialize
operator|)
operator|&&
name|left
operator|->
name|getType
argument_list|()
operator|.
name|isStructureContainingSamplers
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|loc
argument_list|,
literal|"undefined operation for structs containing samplers"
argument_list|,
name|GetOperatorString
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
case|case
name|EOpLessThan
case|:
case|case
name|EOpGreaterThan
case|:
case|case
name|EOpLessThanEqual
case|:
case|case
name|EOpGreaterThanEqual
case|:
if|if
condition|(
operator|(
name|left
operator|->
name|getNominalSize
argument_list|()
operator|!=
name|right
operator|->
name|getNominalSize
argument_list|()
operator|)
operator|||
operator|(
name|left
operator|->
name|getSecondarySize
argument_list|()
operator|!=
name|right
operator|->
name|getSecondarySize
argument_list|()
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
default|default:
break|break;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|addBinaryMathInternal
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|addBinaryMathInternal
parameter_list|(
name|TOperator
name|op
parameter_list|,
name|TIntermTyped
modifier|*
name|left
parameter_list|,
name|TIntermTyped
modifier|*
name|right
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|)
block|{
if|if
condition|(
operator|!
name|binaryOpCommonCheck
argument_list|(
name|op
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|loc
argument_list|)
condition|)
return|return
literal|nullptr
return|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|EOpEqual
case|:
case|case
name|EOpNotEqual
case|:
break|break;
case|case
name|EOpLessThan
case|:
case|case
name|EOpGreaterThan
case|:
case|case
name|EOpLessThanEqual
case|:
case|case
name|EOpGreaterThanEqual
case|:
name|ASSERT
argument_list|(
operator|!
name|left
operator|->
name|isArray
argument_list|()
operator|&&
operator|!
name|right
operator|->
name|isArray
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|->
name|isMatrix
argument_list|()
operator|||
name|left
operator|->
name|isVector
argument_list|()
operator|||
name|left
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtStruct
condition|)
block|{
return|return
literal|nullptr
return|;
block|}
break|break;
case|case
name|EOpLogicalOr
case|:
case|case
name|EOpLogicalXor
case|:
case|case
name|EOpLogicalAnd
case|:
name|ASSERT
argument_list|(
operator|!
name|left
operator|->
name|isArray
argument_list|()
operator|&&
operator|!
name|right
operator|->
name|isArray
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|->
name|getBasicType
argument_list|()
operator|!=
name|EbtBool
operator|||
name|left
operator|->
name|isMatrix
argument_list|()
operator|||
name|left
operator|->
name|isVector
argument_list|()
condition|)
block|{
return|return
literal|nullptr
return|;
block|}
break|break;
case|case
name|EOpAdd
case|:
case|case
name|EOpSub
case|:
case|case
name|EOpDiv
case|:
case|case
name|EOpMul
case|:
name|ASSERT
argument_list|(
operator|!
name|left
operator|->
name|isArray
argument_list|()
operator|&&
operator|!
name|right
operator|->
name|isArray
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtStruct
operator|||
name|left
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtBool
condition|)
block|{
return|return
literal|nullptr
return|;
block|}
break|break;
case|case
name|EOpIMod
case|:
name|ASSERT
argument_list|(
operator|!
name|left
operator|->
name|isArray
argument_list|()
operator|&&
operator|!
name|right
operator|->
name|isArray
argument_list|()
argument_list|)
expr_stmt|;
comment|// Note that this is only for the % operator, not for mod()
if|if
condition|(
name|left
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtStruct
operator|||
name|left
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtBool
operator|||
name|left
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtFloat
condition|)
block|{
return|return
literal|nullptr
return|;
block|}
break|break;
comment|// Note that for bitwise ops, type checking is done in promote() to
comment|// share code between ops and compound assignment
default|default:
break|break;
block|}
return|return
name|intermediate
operator|.
name|addBinaryMath
argument_list|(
name|op
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|loc
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|addBinaryMath
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|addBinaryMath
parameter_list|(
name|TOperator
name|op
parameter_list|,
name|TIntermTyped
modifier|*
name|left
parameter_list|,
name|TIntermTyped
modifier|*
name|right
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|)
block|{
name|TIntermTyped
modifier|*
name|node
init|=
name|addBinaryMathInternal
argument_list|(
name|op
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|loc
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|0
condition|)
block|{
name|binaryOpError
argument_list|(
name|loc
argument_list|,
name|GetOperatorString
argument_list|(
name|op
argument_list|)
argument_list|,
name|left
operator|->
name|getCompleteString
argument_list|()
argument_list|,
name|right
operator|->
name|getCompleteString
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
name|left
return|;
block|}
return|return
name|node
return|;
block|}
end_function
begin_function
DECL|function|addBinaryMathBooleanResult
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|addBinaryMathBooleanResult
parameter_list|(
name|TOperator
name|op
parameter_list|,
name|TIntermTyped
modifier|*
name|left
parameter_list|,
name|TIntermTyped
modifier|*
name|right
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|)
block|{
name|TIntermTyped
modifier|*
name|node
init|=
name|addBinaryMathInternal
argument_list|(
name|op
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|loc
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|0
condition|)
block|{
name|binaryOpError
argument_list|(
name|loc
argument_list|,
name|GetOperatorString
argument_list|(
name|op
argument_list|)
argument_list|,
name|left
operator|->
name|getCompleteString
argument_list|()
argument_list|,
name|right
operator|->
name|getCompleteString
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
name|TConstantUnion
modifier|*
name|unionArray
init|=
operator|new
name|TConstantUnion
index|[
literal|1
index|]
decl_stmt|;
name|unionArray
operator|->
name|setBConst
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return
name|intermediate
operator|.
name|addConstantUnion
argument_list|(
name|unionArray
argument_list|,
name|TType
argument_list|(
name|EbtBool
argument_list|,
name|EbpUndefined
argument_list|,
name|EvqConst
argument_list|)
argument_list|,
name|loc
argument_list|)
return|;
block|}
return|return
name|node
return|;
block|}
end_function
begin_function
DECL|function|createAssign
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|createAssign
parameter_list|(
name|TOperator
name|op
parameter_list|,
name|TIntermTyped
modifier|*
name|left
parameter_list|,
name|TIntermTyped
modifier|*
name|right
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|)
block|{
if|if
condition|(
name|binaryOpCommonCheck
argument_list|(
name|op
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|loc
argument_list|)
condition|)
block|{
return|return
name|intermediate
operator|.
name|addAssign
argument_list|(
name|op
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|loc
argument_list|)
return|;
block|}
return|return
literal|nullptr
return|;
block|}
end_function
begin_function
DECL|function|addAssign
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|addAssign
parameter_list|(
name|TOperator
name|op
parameter_list|,
name|TIntermTyped
modifier|*
name|left
parameter_list|,
name|TIntermTyped
modifier|*
name|right
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|)
block|{
name|TIntermTyped
modifier|*
name|node
init|=
name|createAssign
argument_list|(
name|op
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|loc
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|nullptr
condition|)
block|{
name|assignError
argument_list|(
name|loc
argument_list|,
literal|"assign"
argument_list|,
name|left
operator|->
name|getCompleteString
argument_list|()
argument_list|,
name|right
operator|->
name|getCompleteString
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
name|left
return|;
block|}
return|return
name|node
return|;
block|}
end_function
begin_function
DECL|function|addComma
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|addComma
parameter_list|(
name|TIntermTyped
modifier|*
name|left
parameter_list|,
name|TIntermTyped
modifier|*
name|right
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|)
block|{
return|return
name|intermediate
operator|.
name|addComma
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|loc
argument_list|,
name|mShaderVersion
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|addBranch
name|TIntermBranch
modifier|*
name|TParseContext
operator|::
name|addBranch
parameter_list|(
name|TOperator
name|op
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|EOpContinue
case|:
if|if
condition|(
name|mLoopNestingLevel
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
name|loc
argument_list|,
literal|"continue statement only allowed in loops"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|EOpBreak
case|:
if|if
condition|(
name|mLoopNestingLevel
operator|<=
literal|0
operator|&&
name|mSwitchNestingLevel
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
name|loc
argument_list|,
literal|"break statement only allowed in loops and switch statements"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|EOpReturn
case|:
if|if
condition|(
name|mCurrentFunctionType
operator|->
name|getBasicType
argument_list|()
operator|!=
name|EbtVoid
condition|)
block|{
name|error
argument_list|(
name|loc
argument_list|,
literal|"non-void function must return a value"
argument_list|,
literal|"return"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
comment|// No checks for discard
break|break;
block|}
return|return
name|intermediate
operator|.
name|addBranch
argument_list|(
name|op
argument_list|,
name|loc
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|addBranch
name|TIntermBranch
modifier|*
name|TParseContext
operator|::
name|addBranch
parameter_list|(
name|TOperator
name|op
parameter_list|,
name|TIntermTyped
modifier|*
name|returnValue
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|op
operator|==
name|EOpReturn
argument_list|)
expr_stmt|;
name|mFunctionReturnsValue
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|mCurrentFunctionType
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtVoid
condition|)
block|{
name|error
argument_list|(
name|loc
argument_list|,
literal|"void function cannot return a value"
argument_list|,
literal|"return"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|mCurrentFunctionType
operator|!=
name|returnValue
operator|->
name|getType
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|loc
argument_list|,
literal|"function return is not matching type:"
argument_list|,
literal|"return"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
return|return
name|intermediate
operator|.
name|addBranch
argument_list|(
name|op
argument_list|,
name|returnValue
argument_list|,
name|loc
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|checkTextureOffsetConst
name|void
name|TParseContext
operator|::
name|checkTextureOffsetConst
parameter_list|(
name|TIntermAggregate
modifier|*
name|functionCall
parameter_list|)
block|{
name|ASSERT
argument_list|(
operator|!
name|functionCall
operator|->
name|isUserDefined
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|TString
modifier|&
name|name
init|=
name|functionCall
operator|->
name|getName
argument_list|()
decl_stmt|;
name|TIntermNode
modifier|*
name|offset
init|=
literal|nullptr
decl_stmt|;
name|TIntermSequence
modifier|*
name|arguments
init|=
name|functionCall
operator|->
name|getSequence
argument_list|()
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|16
argument_list|,
literal|"texelFetchOffset"
argument_list|)
operator|==
literal|0
operator|||
name|name
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|16
argument_list|,
literal|"textureLodOffset"
argument_list|)
operator|==
literal|0
operator|||
name|name
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|20
argument_list|,
literal|"textureProjLodOffset"
argument_list|)
operator|==
literal|0
operator|||
name|name
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|17
argument_list|,
literal|"textureGradOffset"
argument_list|)
operator|==
literal|0
operator|||
name|name
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|21
argument_list|,
literal|"textureProjGradOffset"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|offset
operator|=
name|arguments
operator|->
name|back
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|13
argument_list|,
literal|"textureOffset"
argument_list|)
operator|==
literal|0
operator|||
name|name
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|17
argument_list|,
literal|"textureProjOffset"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// A bias parameter might follow the offset parameter.
name|ASSERT
argument_list|(
name|arguments
operator|->
name|size
argument_list|()
operator|>=
literal|3
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
operator|*
name|arguments
operator|)
index|[
literal|2
index|]
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|!=
literal|nullptr
condition|)
block|{
name|TIntermConstantUnion
modifier|*
name|offsetConstantUnion
init|=
name|offset
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
if|if
condition|(
name|offset
operator|->
name|getAsTyped
argument_list|()
operator|->
name|getQualifier
argument_list|()
operator|!=
name|EvqConst
operator|||
operator|!
name|offsetConstantUnion
condition|)
block|{
name|TString
name|unmangledName
init|=
name|TFunction
operator|::
name|unmangleName
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|error
argument_list|(
name|functionCall
operator|->
name|getLine
argument_list|()
argument_list|,
literal|"Texture offset must be a constant expression"
argument_list|,
name|unmangledName
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|offsetConstantUnion
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtInt
argument_list|)
expr_stmt|;
name|size_t
name|size
init|=
name|offsetConstantUnion
operator|->
name|getType
argument_list|()
operator|.
name|getObjectSize
argument_list|()
decl_stmt|;
specifier|const
name|TConstantUnion
modifier|*
name|values
init|=
name|offsetConstantUnion
operator|->
name|getUnionArrayPointer
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0u
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
name|int
name|offsetValue
init|=
name|values
index|[
name|i
index|]
operator|.
name|getIConst
argument_list|()
decl_stmt|;
if|if
condition|(
name|offsetValue
operator|>
name|mMaxProgramTexelOffset
operator|||
name|offsetValue
operator|<
name|mMinProgramTexelOffset
condition|)
block|{
name|std
operator|::
name|stringstream
name|tokenStream
decl_stmt|;
name|tokenStream
operator|<<
name|offsetValue
expr_stmt|;
name|std
operator|::
name|string
name|token
init|=
name|tokenStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|error
argument_list|(
name|offset
operator|->
name|getLine
argument_list|()
argument_list|,
literal|"Texture offset value out of valid range"
argument_list|,
name|token
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function
begin_function
DECL|function|addFunctionCallOrMethod
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|addFunctionCallOrMethod
parameter_list|(
name|TFunction
modifier|*
name|fnCall
parameter_list|,
name|TIntermNode
modifier|*
name|paramNode
parameter_list|,
name|TIntermNode
modifier|*
name|thisNode
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|,
name|bool
modifier|*
name|fatalError
parameter_list|)
block|{
operator|*
name|fatalError
operator|=
literal|false
expr_stmt|;
name|TOperator
name|op
init|=
name|fnCall
operator|->
name|getBuiltInOp
argument_list|()
decl_stmt|;
name|TIntermTyped
modifier|*
name|callNode
init|=
literal|nullptr
decl_stmt|;
if|if
condition|(
name|thisNode
operator|!=
literal|nullptr
condition|)
block|{
name|TConstantUnion
modifier|*
name|unionArray
init|=
operator|new
name|TConstantUnion
index|[
literal|1
index|]
decl_stmt|;
name|int
name|arraySize
init|=
literal|0
decl_stmt|;
name|TIntermTyped
modifier|*
name|typedThis
init|=
name|thisNode
operator|->
name|getAsTyped
argument_list|()
decl_stmt|;
if|if
condition|(
name|fnCall
operator|->
name|getName
argument_list|()
operator|!=
literal|"length"
condition|)
block|{
name|error
argument_list|(
name|loc
argument_list|,
literal|"invalid method"
argument_list|,
name|fnCall
operator|->
name|getName
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|paramNode
operator|!=
literal|nullptr
condition|)
block|{
name|error
argument_list|(
name|loc
argument_list|,
literal|"method takes no parameters"
argument_list|,
literal|"length"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|typedThis
operator|==
literal|nullptr
operator|||
operator|!
name|typedThis
operator|->
name|isArray
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|loc
argument_list|,
literal|"length can only be called on arrays"
argument_list|,
literal|"length"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|arraySize
operator|=
name|typedThis
operator|->
name|getArraySize
argument_list|()
expr_stmt|;
if|if
condition|(
name|typedThis
operator|->
name|getAsSymbolNode
argument_list|()
operator|==
literal|nullptr
condition|)
block|{
comment|// This code path can be hit with expressions like these:
comment|// (a = b).length()
comment|// (func()).length()
comment|// (int[3](0, 1, 2)).length()
comment|// ESSL 3.00 section 5.9 defines expressions so that this is not actually a valid
comment|// expression.
comment|// It allows "An array name with the length method applied" in contrast to GLSL 4.4
comment|// spec section 5.9 which allows "An array, vector or matrix expression with the
comment|// length method applied".
name|error
argument_list|(
name|loc
argument_list|,
literal|"length can only be called on array names, not on array expressions"
argument_list|,
literal|"length"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
block|}
name|unionArray
operator|->
name|setIConst
argument_list|(
name|arraySize
argument_list|)
expr_stmt|;
name|callNode
operator|=
name|intermediate
operator|.
name|addConstantUnion
argument_list|(
name|unionArray
argument_list|,
name|TType
argument_list|(
name|EbtInt
argument_list|,
name|EbpUndefined
argument_list|,
name|EvqConst
argument_list|)
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|!=
name|EOpNull
condition|)
block|{
comment|//
comment|// Then this should be a constructor.
comment|// Don't go through the symbol table for constructors.
comment|// Their parameters will be verified algorithmically.
comment|//
name|TType
name|type
argument_list|(
name|EbtVoid
argument_list|,
name|EbpUndefined
argument_list|)
decl_stmt|;
comment|// use this to get the type back
if|if
condition|(
operator|!
name|constructorErrorCheck
argument_list|(
name|loc
argument_list|,
name|paramNode
argument_list|,
operator|*
name|fnCall
argument_list|,
name|op
argument_list|,
operator|&
name|type
argument_list|)
condition|)
block|{
comment|//
comment|// It's a constructor, of type 'type'.
comment|//
name|callNode
operator|=
name|addConstructor
argument_list|(
name|paramNode
argument_list|,
operator|&
name|type
argument_list|,
name|op
argument_list|,
name|fnCall
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|callNode
operator|==
literal|nullptr
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
name|callNode
operator|=
name|intermediate
operator|.
name|setAggregateOperator
argument_list|(
literal|nullptr
argument_list|,
name|op
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
name|callNode
operator|->
name|setType
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//
comment|// Not a constructor.  Find it in the symbol table.
comment|//
specifier|const
name|TFunction
modifier|*
name|fnCandidate
decl_stmt|;
name|bool
name|builtIn
decl_stmt|;
name|fnCandidate
operator|=
name|findFunction
argument_list|(
name|loc
argument_list|,
name|fnCall
argument_list|,
name|mShaderVersion
argument_list|,
operator|&
name|builtIn
argument_list|)
expr_stmt|;
if|if
condition|(
name|fnCandidate
condition|)
block|{
comment|//
comment|// A declared function.
comment|//
if|if
condition|(
name|builtIn
operator|&&
operator|!
name|fnCandidate
operator|->
name|getExtension
argument_list|()
operator|.
name|empty
argument_list|()
operator|&&
name|extensionErrorCheck
argument_list|(
name|loc
argument_list|,
name|fnCandidate
operator|->
name|getExtension
argument_list|()
argument_list|)
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
block|}
name|op
operator|=
name|fnCandidate
operator|->
name|getBuiltInOp
argument_list|()
expr_stmt|;
if|if
condition|(
name|builtIn
operator|&&
name|op
operator|!=
name|EOpNull
condition|)
block|{
comment|//
comment|// A function call mapped to a built-in operation.
comment|//
if|if
condition|(
name|fnCandidate
operator|->
name|getParamCount
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|//
comment|// Treat it like a built-in unary operator.
comment|//
name|TIntermAggregate
modifier|*
name|paramAgg
init|=
name|paramNode
operator|->
name|getAsAggregate
argument_list|()
decl_stmt|;
name|paramNode
operator|=
name|paramAgg
operator|->
name|getSequence
argument_list|()
operator|->
name|front
argument_list|()
expr_stmt|;
name|callNode
operator|=
name|createUnaryMath
argument_list|(
name|op
argument_list|,
name|paramNode
operator|->
name|getAsTyped
argument_list|()
argument_list|,
name|loc
argument_list|,
operator|&
name|fnCandidate
operator|->
name|getReturnType
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|callNode
operator|==
literal|nullptr
condition|)
block|{
name|std
operator|::
name|stringstream
name|extraInfoStream
decl_stmt|;
name|extraInfoStream
operator|<<
literal|"built in unary operator function.  Type: "
operator|<<
cast|static_cast
argument_list|<
name|TIntermTyped
operator|*
argument_list|>
argument_list|(
name|paramNode
argument_list|)
operator|->
name|getCompleteString
argument_list|()
expr_stmt|;
name|std
operator|::
name|string
name|extraInfo
init|=
name|extraInfoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|error
argument_list|(
name|paramNode
operator|->
name|getLine
argument_list|()
argument_list|,
literal|" wrong operand type"
argument_list|,
literal|"Internal Error"
argument_list|,
name|extraInfo
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
operator|*
name|fatalError
operator|=
literal|true
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
block|}
else|else
block|{
name|TIntermAggregate
modifier|*
name|aggregate
init|=
name|intermediate
operator|.
name|setAggregateOperator
argument_list|(
name|paramNode
argument_list|,
name|op
argument_list|,
name|loc
argument_list|)
decl_stmt|;
name|aggregate
operator|->
name|setType
argument_list|(
name|fnCandidate
operator|->
name|getReturnType
argument_list|()
argument_list|)
expr_stmt|;
name|aggregate
operator|->
name|setPrecisionFromChildren
argument_list|()
expr_stmt|;
if|if
condition|(
name|aggregate
operator|->
name|areChildrenConstQualified
argument_list|()
condition|)
block|{
name|aggregate
operator|->
name|getTypePointer
argument_list|()
operator|->
name|setQualifier
argument_list|(
name|EvqConst
argument_list|)
expr_stmt|;
block|}
comment|// Some built-in functions have out parameters too.
name|functionCallLValueErrorCheck
argument_list|(
name|fnCandidate
argument_list|,
name|aggregate
argument_list|)
expr_stmt|;
comment|// See if we can constant fold a built-in. Note that this may be possible even
comment|// if it is not const-qualified.
name|TIntermTyped
modifier|*
name|foldedNode
init|=
name|intermediate
operator|.
name|foldAggregateBuiltIn
argument_list|(
name|aggregate
argument_list|)
decl_stmt|;
if|if
condition|(
name|foldedNode
condition|)
block|{
name|callNode
operator|=
name|foldedNode
expr_stmt|;
block|}
else|else
block|{
name|callNode
operator|=
name|aggregate
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// This is a real function call
name|TIntermAggregate
modifier|*
name|aggregate
init|=
name|intermediate
operator|.
name|setAggregateOperator
argument_list|(
name|paramNode
argument_list|,
name|EOpFunctionCall
argument_list|,
name|loc
argument_list|)
decl_stmt|;
name|aggregate
operator|->
name|setType
argument_list|(
name|fnCandidate
operator|->
name|getReturnType
argument_list|()
argument_list|)
expr_stmt|;
comment|// this is how we know whether the given function is a builtIn function or a user
comment|// defined function
comment|// if builtIn == false, it's a userDefined -> could be an overloaded
comment|// builtIn function also
comment|// if builtIn == true, it's definitely a builtIn function with EOpNull
if|if
condition|(
operator|!
name|builtIn
condition|)
name|aggregate
operator|->
name|setUserDefined
argument_list|()
expr_stmt|;
name|aggregate
operator|->
name|setName
argument_list|(
name|fnCandidate
operator|->
name|getMangledName
argument_list|()
argument_list|)
expr_stmt|;
name|aggregate
operator|->
name|setFunctionId
argument_list|(
name|fnCandidate
operator|->
name|getUniqueId
argument_list|()
argument_list|)
expr_stmt|;
comment|// This needs to happen after the name is set
if|if
condition|(
name|builtIn
condition|)
block|{
name|aggregate
operator|->
name|setBuiltInFunctionPrecision
argument_list|()
expr_stmt|;
name|checkTextureOffsetConst
argument_list|(
name|aggregate
argument_list|)
expr_stmt|;
block|}
name|callNode
operator|=
name|aggregate
expr_stmt|;
name|functionCallLValueErrorCheck
argument_list|(
name|fnCandidate
argument_list|,
name|aggregate
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// error message was put out by findFunction()
comment|// Put on a dummy node for error recovery
name|TConstantUnion
modifier|*
name|unionArray
init|=
operator|new
name|TConstantUnion
index|[
literal|1
index|]
decl_stmt|;
name|unionArray
operator|->
name|setFConst
argument_list|(
literal|0.0f
argument_list|)
expr_stmt|;
name|callNode
operator|=
name|intermediate
operator|.
name|addConstantUnion
argument_list|(
name|unionArray
argument_list|,
name|TType
argument_list|(
name|EbtFloat
argument_list|,
name|EbpUndefined
argument_list|,
name|EvqConst
argument_list|)
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|callNode
return|;
block|}
end_function
begin_function
DECL|function|addTernarySelection
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|addTernarySelection
parameter_list|(
name|TIntermTyped
modifier|*
name|cond
parameter_list|,
name|TIntermTyped
modifier|*
name|trueBlock
parameter_list|,
name|TIntermTyped
modifier|*
name|falseBlock
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|)
block|{
if|if
condition|(
name|boolErrorCheck
argument_list|(
name|loc
argument_list|,
name|cond
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
if|if
condition|(
name|trueBlock
operator|->
name|getType
argument_list|()
operator|!=
name|falseBlock
operator|->
name|getType
argument_list|()
condition|)
block|{
name|binaryOpError
argument_list|(
name|loc
argument_list|,
literal|":"
argument_list|,
name|trueBlock
operator|->
name|getCompleteString
argument_list|()
argument_list|,
name|falseBlock
operator|->
name|getCompleteString
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
name|falseBlock
return|;
block|}
comment|// ESSL1 sections 5.2 and 5.7:
comment|// ESSL3 section 5.7:
comment|// Ternary operator is not among the operators allowed for structures/arrays.
if|if
condition|(
name|trueBlock
operator|->
name|isArray
argument_list|()
operator|||
name|trueBlock
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtStruct
condition|)
block|{
name|error
argument_list|(
name|loc
argument_list|,
literal|"ternary operator is not allowed for structures or arrays"
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
name|falseBlock
return|;
block|}
return|return
name|intermediate
operator|.
name|addSelection
argument_list|(
name|cond
argument_list|,
name|trueBlock
argument_list|,
name|falseBlock
argument_list|,
name|loc
argument_list|)
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Parse an array of strings using yyparse.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns 0 for success.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|PaParseStrings
name|int
name|PaParseStrings
parameter_list|(
name|size_t
name|count
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
name|string
index|[]
parameter_list|,
specifier|const
name|int
name|length
index|[]
parameter_list|,
name|TParseContext
modifier|*
name|context
parameter_list|)
block|{
if|if
condition|(
operator|(
name|count
operator|==
literal|0
operator|)
operator|||
operator|(
name|string
operator|==
name|NULL
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|glslang_initialize
argument_list|(
name|context
argument_list|)
condition|)
return|return
literal|1
return|;
name|int
name|error
init|=
name|glslang_scan
argument_list|(
name|count
argument_list|,
name|string
argument_list|,
name|length
argument_list|,
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|glslang_parse
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|glslang_finalize
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|==
literal|0
operator|)
operator|&&
operator|(
name|context
operator|->
name|numErrors
argument_list|()
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
return|;
block|}
end_function
end_unit
