begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|"compiler/translator/ParseContext.h"
end_include
begin_include
include|#
directive|include
file|<stdarg.h>
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|"compiler/preprocessor/SourceLocation.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/glslang.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/ValidateSwitch.h"
end_include
begin_comment
comment|///////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Sub- vector and matrix fields
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Look at a '.' field selector string and change it into offsets
end_comment
begin_comment
comment|// for a vector.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|parseVectorFields
name|bool
name|TParseContext
operator|::
name|parseVectorFields
parameter_list|(
specifier|const
name|TString
modifier|&
name|compString
parameter_list|,
name|int
name|vecSize
parameter_list|,
name|TVectorFields
modifier|&
name|fields
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
name|fields
operator|.
name|num
operator|=
operator|(
name|int
operator|)
name|compString
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|fields
operator|.
name|num
operator|>
literal|4
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"illegal vector field selection"
argument_list|,
name|compString
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
enum|enum
block|{
name|exyzw
block|,
name|ergba
block|,
name|estpq
block|}
name|fieldSet
index|[
literal|4
index|]
enum|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|num
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|compString
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'x'
case|:
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|fieldSet
index|[
name|i
index|]
operator|=
name|exyzw
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|fieldSet
index|[
name|i
index|]
operator|=
name|ergba
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|fieldSet
index|[
name|i
index|]
operator|=
name|estpq
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|fieldSet
index|[
name|i
index|]
operator|=
name|exyzw
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|fieldSet
index|[
name|i
index|]
operator|=
name|ergba
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|fieldSet
index|[
name|i
index|]
operator|=
name|estpq
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|2
expr_stmt|;
name|fieldSet
index|[
name|i
index|]
operator|=
name|exyzw
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|2
expr_stmt|;
name|fieldSet
index|[
name|i
index|]
operator|=
name|ergba
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|2
expr_stmt|;
name|fieldSet
index|[
name|i
index|]
operator|=
name|estpq
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|3
expr_stmt|;
name|fieldSet
index|[
name|i
index|]
operator|=
name|exyzw
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|3
expr_stmt|;
name|fieldSet
index|[
name|i
index|]
operator|=
name|ergba
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|3
expr_stmt|;
name|fieldSet
index|[
name|i
index|]
operator|=
name|estpq
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
name|line
argument_list|,
literal|"illegal vector field selection"
argument_list|,
name|compString
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|num
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|>=
name|vecSize
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"vector field selection out of range"
argument_list|,
name|compString
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|fieldSet
index|[
name|i
index|]
operator|!=
name|fieldSet
index|[
name|i
operator|-
literal|1
index|]
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"illegal - vector component fields not from the same set"
argument_list|,
name|compString
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Look at a '.' field selector string and change it into offsets
end_comment
begin_comment
comment|// for a matrix.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|parseMatrixFields
name|bool
name|TParseContext
operator|::
name|parseMatrixFields
parameter_list|(
specifier|const
name|TString
modifier|&
name|compString
parameter_list|,
name|int
name|matCols
parameter_list|,
name|int
name|matRows
parameter_list|,
name|TMatrixFields
modifier|&
name|fields
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
name|fields
operator|.
name|wholeRow
operator|=
literal|false
expr_stmt|;
name|fields
operator|.
name|wholeCol
operator|=
literal|false
expr_stmt|;
name|fields
operator|.
name|row
operator|=
operator|-
literal|1
expr_stmt|;
name|fields
operator|.
name|col
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|compString
operator|.
name|size
argument_list|()
operator|!=
literal|2
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"illegal length of matrix field selection"
argument_list|,
name|compString
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|compString
index|[
literal|0
index|]
operator|==
literal|'_'
condition|)
block|{
if|if
condition|(
name|compString
index|[
literal|1
index|]
operator|<
literal|'0'
operator|||
name|compString
index|[
literal|1
index|]
operator|>
literal|'3'
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"illegal matrix field selection"
argument_list|,
name|compString
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|fields
operator|.
name|wholeCol
operator|=
literal|true
expr_stmt|;
name|fields
operator|.
name|col
operator|=
name|compString
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|compString
index|[
literal|1
index|]
operator|==
literal|'_'
condition|)
block|{
if|if
condition|(
name|compString
index|[
literal|0
index|]
operator|<
literal|'0'
operator|||
name|compString
index|[
literal|0
index|]
operator|>
literal|'3'
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"illegal matrix field selection"
argument_list|,
name|compString
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|fields
operator|.
name|wholeRow
operator|=
literal|true
expr_stmt|;
name|fields
operator|.
name|row
operator|=
name|compString
index|[
literal|0
index|]
operator|-
literal|'0'
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|compString
index|[
literal|0
index|]
operator|<
literal|'0'
operator|||
name|compString
index|[
literal|0
index|]
operator|>
literal|'3'
operator|||
name|compString
index|[
literal|1
index|]
operator|<
literal|'0'
operator|||
name|compString
index|[
literal|1
index|]
operator|>
literal|'3'
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"illegal matrix field selection"
argument_list|,
name|compString
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|fields
operator|.
name|row
operator|=
name|compString
index|[
literal|0
index|]
operator|-
literal|'0'
expr_stmt|;
name|fields
operator|.
name|col
operator|=
name|compString
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
block|}
if|if
condition|(
name|fields
operator|.
name|row
operator|>=
name|matRows
operator|||
name|fields
operator|.
name|col
operator|>=
name|matCols
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"matrix field selection out of range"
argument_list|,
name|compString
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|///////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Errors
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Track whether errors have occurred.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|recover
name|void
name|TParseContext
operator|::
name|recover
parameter_list|()
block|{ }
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Used by flex/bison to output all syntax and parsing errors.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|error
name|void
name|TParseContext
operator|::
name|error
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|,
specifier|const
name|char
modifier|*
name|reason
parameter_list|,
specifier|const
name|char
modifier|*
name|token
parameter_list|,
specifier|const
name|char
modifier|*
name|extraInfo
parameter_list|)
block|{
name|pp
operator|::
name|SourceLocation
name|srcLoc
decl_stmt|;
name|srcLoc
operator|.
name|file
operator|=
name|loc
operator|.
name|first_file
expr_stmt|;
name|srcLoc
operator|.
name|line
operator|=
name|loc
operator|.
name|first_line
expr_stmt|;
name|diagnostics
operator|.
name|writeInfo
argument_list|(
name|pp
operator|::
name|Diagnostics
operator|::
name|PP_ERROR
argument_list|,
name|srcLoc
argument_list|,
name|reason
argument_list|,
name|token
argument_list|,
name|extraInfo
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|warning
name|void
name|TParseContext
operator|::
name|warning
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|,
specifier|const
name|char
modifier|*
name|reason
parameter_list|,
specifier|const
name|char
modifier|*
name|token
parameter_list|,
specifier|const
name|char
modifier|*
name|extraInfo
parameter_list|)
block|{
name|pp
operator|::
name|SourceLocation
name|srcLoc
decl_stmt|;
name|srcLoc
operator|.
name|file
operator|=
name|loc
operator|.
name|first_file
expr_stmt|;
name|srcLoc
operator|.
name|line
operator|=
name|loc
operator|.
name|first_line
expr_stmt|;
name|diagnostics
operator|.
name|writeInfo
argument_list|(
name|pp
operator|::
name|Diagnostics
operator|::
name|PP_WARNING
argument_list|,
name|srcLoc
argument_list|,
name|reason
argument_list|,
name|token
argument_list|,
name|extraInfo
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|trace
name|void
name|TParseContext
operator|::
name|trace
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|diagnostics
operator|.
name|writeDebug
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Same error message for all places assignments don't work.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|assignError
name|void
name|TParseContext
operator|::
name|assignError
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|op
parameter_list|,
name|TString
name|left
parameter_list|,
name|TString
name|right
parameter_list|)
block|{
name|std
operator|::
name|stringstream
name|extraInfoStream
decl_stmt|;
name|extraInfoStream
operator|<<
literal|"cannot convert from '"
operator|<<
name|right
operator|<<
literal|"' to '"
operator|<<
name|left
operator|<<
literal|"'"
expr_stmt|;
name|std
operator|::
name|string
name|extraInfo
init|=
name|extraInfoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|error
argument_list|(
name|line
argument_list|,
literal|""
argument_list|,
name|op
argument_list|,
name|extraInfo
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Same error message for all places unary operations don't work.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|unaryOpError
name|void
name|TParseContext
operator|::
name|unaryOpError
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|op
parameter_list|,
name|TString
name|operand
parameter_list|)
block|{
name|std
operator|::
name|stringstream
name|extraInfoStream
decl_stmt|;
name|extraInfoStream
operator|<<
literal|"no operation '"
operator|<<
name|op
operator|<<
literal|"' exists that takes an operand of type "
operator|<<
name|operand
operator|<<
literal|" (or there is no acceptable conversion)"
expr_stmt|;
name|std
operator|::
name|string
name|extraInfo
init|=
name|extraInfoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|error
argument_list|(
name|line
argument_list|,
literal|" wrong operand type"
argument_list|,
name|op
argument_list|,
name|extraInfo
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Same error message for all binary operations don't work.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|binaryOpError
name|void
name|TParseContext
operator|::
name|binaryOpError
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|op
parameter_list|,
name|TString
name|left
parameter_list|,
name|TString
name|right
parameter_list|)
block|{
name|std
operator|::
name|stringstream
name|extraInfoStream
decl_stmt|;
name|extraInfoStream
operator|<<
literal|"no operation '"
operator|<<
name|op
operator|<<
literal|"' exists that takes a left-hand operand of type '"
operator|<<
name|left
operator|<<
literal|"' and a right operand of type '"
operator|<<
name|right
operator|<<
literal|"' (or there is no acceptable conversion)"
expr_stmt|;
name|std
operator|::
name|string
name|extraInfo
init|=
name|extraInfoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|error
argument_list|(
name|line
argument_list|,
literal|" wrong operand types "
argument_list|,
name|op
argument_list|,
name|extraInfo
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|precisionErrorCheck
name|bool
name|TParseContext
operator|::
name|precisionErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
name|TPrecision
name|precision
parameter_list|,
name|TBasicType
name|type
parameter_list|)
block|{
if|if
condition|(
operator|!
name|checksPrecisionErrors
condition|)
return|return
literal|false
return|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|EbtFloat
case|:
if|if
condition|(
name|precision
operator|==
name|EbpUndefined
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"No precision specified for (float)"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
break|break;
case|case
name|EbtInt
case|:
if|if
condition|(
name|precision
operator|==
name|EbpUndefined
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"No precision specified (int)"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
break|break;
default|default:
return|return
literal|false
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Both test and if necessary, spit out an error, to see if the node is really
end_comment
begin_comment
comment|// an l-value that can be operated on this way.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns true if the was an error.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|lValueErrorCheck
name|bool
name|TParseContext
operator|::
name|lValueErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|op
parameter_list|,
name|TIntermTyped
modifier|*
name|node
parameter_list|)
block|{
name|TIntermSymbol
modifier|*
name|symNode
init|=
name|node
operator|->
name|getAsSymbolNode
argument_list|()
decl_stmt|;
name|TIntermBinary
modifier|*
name|binaryNode
init|=
name|node
operator|->
name|getAsBinaryNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|binaryNode
condition|)
block|{
name|bool
name|errorReturn
decl_stmt|;
switch|switch
condition|(
name|binaryNode
operator|->
name|getOp
argument_list|()
condition|)
block|{
case|case
name|EOpIndexDirect
case|:
case|case
name|EOpIndexIndirect
case|:
case|case
name|EOpIndexDirectStruct
case|:
case|case
name|EOpIndexDirectInterfaceBlock
case|:
return|return
name|lValueErrorCheck
argument_list|(
name|line
argument_list|,
name|op
argument_list|,
name|binaryNode
operator|->
name|getLeft
argument_list|()
argument_list|)
return|;
case|case
name|EOpVectorSwizzle
case|:
name|errorReturn
operator|=
name|lValueErrorCheck
argument_list|(
name|line
argument_list|,
name|op
argument_list|,
name|binaryNode
operator|->
name|getLeft
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|errorReturn
condition|)
block|{
name|int
name|offset
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|TIntermTyped
modifier|*
name|rightNode
init|=
name|binaryNode
operator|->
name|getRight
argument_list|()
decl_stmt|;
name|TIntermAggregate
modifier|*
name|aggrNode
init|=
name|rightNode
operator|->
name|getAsAggregate
argument_list|()
decl_stmt|;
for|for
control|(
name|TIntermSequence
operator|::
name|iterator
name|p
init|=
name|aggrNode
operator|->
name|getSequence
argument_list|()
operator|->
name|begin
argument_list|()
init|;
name|p
operator|!=
name|aggrNode
operator|->
name|getSequence
argument_list|()
operator|->
name|end
argument_list|()
condition|;
name|p
operator|++
control|)
block|{
name|int
name|value
init|=
operator|(
operator|*
name|p
operator|)
operator|->
name|getAsTyped
argument_list|()
operator|->
name|getAsConstantUnion
argument_list|()
operator|->
name|getIConst
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|offset
index|[
name|value
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|offset
index|[
name|value
index|]
operator|>
literal|1
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|" l-value of swizzle cannot have duplicate components"
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
name|errorReturn
return|;
default|default:
break|break;
block|}
name|error
argument_list|(
name|line
argument_list|,
literal|" l-value required"
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|const
name|char
modifier|*
name|symbol
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|symNode
operator|!=
literal|0
condition|)
name|symbol
operator|=
name|symNode
operator|->
name|getSymbol
argument_list|()
operator|.
name|c_str
argument_list|()
expr_stmt|;
specifier|const
name|char
modifier|*
name|message
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|getQualifier
argument_list|()
condition|)
block|{
case|case
name|EvqConst
case|:
name|message
operator|=
literal|"can't modify a const"
expr_stmt|;
break|break;
case|case
name|EvqConstReadOnly
case|:
name|message
operator|=
literal|"can't modify a const"
expr_stmt|;
break|break;
case|case
name|EvqAttribute
case|:
name|message
operator|=
literal|"can't modify an attribute"
expr_stmt|;
break|break;
case|case
name|EvqFragmentIn
case|:
name|message
operator|=
literal|"can't modify an input"
expr_stmt|;
break|break;
case|case
name|EvqVertexIn
case|:
name|message
operator|=
literal|"can't modify an input"
expr_stmt|;
break|break;
case|case
name|EvqUniform
case|:
name|message
operator|=
literal|"can't modify a uniform"
expr_stmt|;
break|break;
case|case
name|EvqVaryingIn
case|:
name|message
operator|=
literal|"can't modify a varying"
expr_stmt|;
break|break;
case|case
name|EvqFragCoord
case|:
name|message
operator|=
literal|"can't modify gl_FragCoord"
expr_stmt|;
break|break;
case|case
name|EvqFrontFacing
case|:
name|message
operator|=
literal|"can't modify gl_FrontFacing"
expr_stmt|;
break|break;
case|case
name|EvqPointCoord
case|:
name|message
operator|=
literal|"can't modify gl_PointCoord"
expr_stmt|;
break|break;
default|default:
comment|//
comment|// Type that can't be written to?
comment|//
if|if
condition|(
name|node
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtVoid
condition|)
block|{
name|message
operator|=
literal|"can't modify void"
expr_stmt|;
block|}
if|if
condition|(
name|IsSampler
argument_list|(
name|node
operator|->
name|getBasicType
argument_list|()
argument_list|)
condition|)
block|{
name|message
operator|=
literal|"can't modify a sampler"
expr_stmt|;
block|}
block|}
if|if
condition|(
name|message
operator|==
literal|0
operator|&&
name|binaryNode
operator|==
literal|0
operator|&&
name|symNode
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|" l-value required"
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|//
comment|// Everything else is okay, no error.
comment|//
if|if
condition|(
name|message
operator|==
literal|0
condition|)
return|return
literal|false
return|;
comment|//
comment|// If we get here, we have an error and a message.
comment|//
if|if
condition|(
name|symNode
condition|)
block|{
name|std
operator|::
name|stringstream
name|extraInfoStream
decl_stmt|;
name|extraInfoStream
operator|<<
literal|"\""
operator|<<
name|symbol
operator|<<
literal|"\" ("
operator|<<
name|message
operator|<<
literal|")"
expr_stmt|;
name|std
operator|::
name|string
name|extraInfo
init|=
name|extraInfoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|error
argument_list|(
name|line
argument_list|,
literal|" l-value required"
argument_list|,
name|op
argument_list|,
name|extraInfo
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|std
operator|::
name|stringstream
name|extraInfoStream
decl_stmt|;
name|extraInfoStream
operator|<<
literal|"("
operator|<<
name|message
operator|<<
literal|")"
expr_stmt|;
name|std
operator|::
name|string
name|extraInfo
init|=
name|extraInfoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|error
argument_list|(
name|line
argument_list|,
literal|" l-value required"
argument_list|,
name|op
argument_list|,
name|extraInfo
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Both test, and if necessary spit out an error, to see if the node is really
end_comment
begin_comment
comment|// a constant.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns true if the was an error.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|constErrorCheck
name|bool
name|TParseContext
operator|::
name|constErrorCheck
parameter_list|(
name|TIntermTyped
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|->
name|getQualifier
argument_list|()
operator|==
name|EvqConst
condition|)
return|return
literal|false
return|;
name|error
argument_list|(
name|node
operator|->
name|getLine
argument_list|()
argument_list|,
literal|"constant expression required"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Both test, and if necessary spit out an error, to see if the node is really
end_comment
begin_comment
comment|// an integer.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns true if the was an error.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|integerErrorCheck
name|bool
name|TParseContext
operator|::
name|integerErrorCheck
parameter_list|(
name|TIntermTyped
modifier|*
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|token
parameter_list|)
block|{
if|if
condition|(
name|node
operator|->
name|isScalarInt
argument_list|()
condition|)
return|return
literal|false
return|;
name|error
argument_list|(
name|node
operator|->
name|getLine
argument_list|()
argument_list|,
literal|"integer expression required"
argument_list|,
name|token
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Both test, and if necessary spit out an error, to see if we are currently
end_comment
begin_comment
comment|// globally scoped.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns true if the was an error.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|globalErrorCheck
name|bool
name|TParseContext
operator|::
name|globalErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
name|bool
name|global
parameter_list|,
specifier|const
name|char
modifier|*
name|token
parameter_list|)
block|{
if|if
condition|(
name|global
condition|)
return|return
literal|false
return|;
name|error
argument_list|(
name|line
argument_list|,
literal|"only allowed at global scope"
argument_list|,
name|token
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// For now, keep it simple:  if it starts "gl_", it's reserved, independent
end_comment
begin_comment
comment|// of scope.  Except, if the symbol table is at the built-in push-level,
end_comment
begin_comment
comment|// which is when we are parsing built-ins.
end_comment
begin_comment
comment|// Also checks for "webgl_" and "_webgl_" reserved identifiers if parsing a
end_comment
begin_comment
comment|// webgl shader.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns true if there was an error.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|reservedErrorCheck
name|bool
name|TParseContext
operator|::
name|reservedErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
specifier|const
name|TString
modifier|&
name|identifier
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|reservedErrMsg
init|=
literal|"reserved built-in name"
decl_stmt|;
if|if
condition|(
operator|!
name|symbolTable
operator|.
name|atBuiltInLevel
argument_list|()
condition|)
block|{
if|if
condition|(
name|identifier
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|,
literal|"gl_"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
name|reservedErrMsg
argument_list|,
literal|"gl_"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|IsWebGLBasedSpec
argument_list|(
name|shaderSpec
argument_list|)
condition|)
block|{
if|if
condition|(
name|identifier
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|6
argument_list|,
literal|"webgl_"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
name|reservedErrMsg
argument_list|,
literal|"webgl_"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|identifier
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|7
argument_list|,
literal|"_webgl_"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
name|reservedErrMsg
argument_list|,
literal|"_webgl_"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|shaderSpec
operator|==
name|SH_CSS_SHADERS_SPEC
operator|&&
name|identifier
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|,
literal|"css_"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
name|reservedErrMsg
argument_list|,
literal|"css_"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
if|if
condition|(
name|identifier
operator|.
name|find
argument_list|(
literal|"__"
argument_list|)
operator|!=
name|TString
operator|::
name|npos
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"identifiers containing two consecutive underscores (__) are reserved as possible future keywords"
argument_list|,
name|identifier
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Make sure there is enough data provided to the constructor to build
end_comment
begin_comment
comment|// something of the type of the constructor.  Also returns the type of
end_comment
begin_comment
comment|// the constructor.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns true if there was an error in construction.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|constructorErrorCheck
name|bool
name|TParseContext
operator|::
name|constructorErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
name|TIntermNode
modifier|*
name|node
parameter_list|,
name|TFunction
modifier|&
name|function
parameter_list|,
name|TOperator
name|op
parameter_list|,
name|TType
modifier|*
name|type
parameter_list|)
block|{
operator|*
name|type
operator|=
name|function
operator|.
name|getReturnType
argument_list|()
expr_stmt|;
name|bool
name|constructingMatrix
init|=
literal|false
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|EOpConstructMat2
case|:
case|case
name|EOpConstructMat3
case|:
case|case
name|EOpConstructMat4
case|:
name|constructingMatrix
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|//
comment|// Note: It's okay to have too many components available, but not okay to have unused
comment|// arguments.  'full' will go to true when enough args have been seen.  If we loop
comment|// again, there is an extra argument, so 'overfull' will become true.
comment|//
name|size_t
name|size
init|=
literal|0
decl_stmt|;
name|bool
name|constType
init|=
literal|true
decl_stmt|;
name|bool
name|full
init|=
literal|false
decl_stmt|;
name|bool
name|overFull
init|=
literal|false
decl_stmt|;
name|bool
name|matrixInMatrix
init|=
literal|false
decl_stmt|;
name|bool
name|arrayArg
init|=
literal|false
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|function
operator|.
name|getParamCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|TParameter
modifier|&
name|param
init|=
name|function
operator|.
name|getParam
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|size
operator|+=
name|param
operator|.
name|type
operator|->
name|getObjectSize
argument_list|()
expr_stmt|;
if|if
condition|(
name|constructingMatrix
operator|&&
name|param
operator|.
name|type
operator|->
name|isMatrix
argument_list|()
condition|)
name|matrixInMatrix
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|full
condition|)
name|overFull
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|op
operator|!=
name|EOpConstructStruct
operator|&&
operator|!
name|type
operator|->
name|isArray
argument_list|()
operator|&&
name|size
operator|>=
name|type
operator|->
name|getObjectSize
argument_list|()
condition|)
name|full
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|param
operator|.
name|type
operator|->
name|getQualifier
argument_list|()
operator|!=
name|EvqConst
condition|)
name|constType
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|param
operator|.
name|type
operator|->
name|isArray
argument_list|()
condition|)
name|arrayArg
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|constType
condition|)
name|type
operator|->
name|setQualifier
argument_list|(
name|EvqConst
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|->
name|isArray
argument_list|()
operator|&&
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|type
operator|->
name|getArraySize
argument_list|()
argument_list|)
operator|!=
name|function
operator|.
name|getParamCount
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"array constructor needs one argument per array element"
argument_list|,
literal|"constructor"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|arrayArg
operator|&&
name|op
operator|!=
name|EOpConstructStruct
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"constructing from a non-dereferenced array"
argument_list|,
literal|"constructor"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|matrixInMatrix
operator|&&
operator|!
name|type
operator|->
name|isArray
argument_list|()
condition|)
block|{
if|if
condition|(
name|function
operator|.
name|getParamCount
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"constructing matrix from matrix can only take one argument"
argument_list|,
literal|"constructor"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
if|if
condition|(
name|overFull
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"too many arguments"
argument_list|,
literal|"constructor"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|op
operator|==
name|EOpConstructStruct
operator|&&
operator|!
name|type
operator|->
name|isArray
argument_list|()
operator|&&
name|type
operator|->
name|getStruct
argument_list|()
operator|->
name|fields
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
name|function
operator|.
name|getParamCount
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"Number of constructor parameters does not match the number of structure fields"
argument_list|,
literal|"constructor"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|type
operator|->
name|isMatrix
argument_list|()
operator|||
operator|!
name|matrixInMatrix
condition|)
block|{
if|if
condition|(
operator|(
name|op
operator|!=
name|EOpConstructStruct
operator|&&
name|size
operator|!=
literal|1
operator|&&
name|size
operator|<
name|type
operator|->
name|getObjectSize
argument_list|()
operator|)
operator|||
operator|(
name|op
operator|==
name|EOpConstructStruct
operator|&&
name|size
operator|<
name|type
operator|->
name|getObjectSize
argument_list|()
operator|)
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"not enough data provided for construction"
argument_list|,
literal|"constructor"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
name|TIntermTyped
modifier|*
name|typed
init|=
name|node
condition|?
name|node
operator|->
name|getAsTyped
argument_list|()
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|typed
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"constructor argument does not have a type"
argument_list|,
literal|"constructor"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|op
operator|!=
name|EOpConstructStruct
operator|&&
name|IsSampler
argument_list|(
name|typed
operator|->
name|getBasicType
argument_list|()
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"cannot convert a sampler"
argument_list|,
literal|"constructor"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|typed
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtVoid
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"cannot convert a void"
argument_list|,
literal|"constructor"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|// This function checks to see if a void variable has been declared and raise an error message for such a case
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// returns true in case of an error
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|voidErrorCheck
name|bool
name|TParseContext
operator|::
name|voidErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
specifier|const
name|TString
modifier|&
name|identifier
parameter_list|,
specifier|const
name|TPublicType
modifier|&
name|pubType
parameter_list|)
block|{
if|if
condition|(
name|pubType
operator|.
name|type
operator|==
name|EbtVoid
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"illegal use of type 'void'"
argument_list|,
name|identifier
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|// This function checks to see if the node (for the expression) contains a scalar boolean expression or not
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// returns true in case of an error
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|boolErrorCheck
name|bool
name|TParseContext
operator|::
name|boolErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
specifier|const
name|TIntermTyped
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|->
name|getBasicType
argument_list|()
operator|!=
name|EbtBool
operator|||
name|type
operator|->
name|isArray
argument_list|()
operator|||
name|type
operator|->
name|isMatrix
argument_list|()
operator|||
name|type
operator|->
name|isVector
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"boolean expression expected"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|// This function checks to see if the node (for the expression) contains a scalar boolean expression or not
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// returns true in case of an error
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|boolErrorCheck
name|bool
name|TParseContext
operator|::
name|boolErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
specifier|const
name|TPublicType
modifier|&
name|pType
parameter_list|)
block|{
if|if
condition|(
name|pType
operator|.
name|type
operator|!=
name|EbtBool
operator|||
name|pType
operator|.
name|isAggregate
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"boolean expression expected"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|samplerErrorCheck
name|bool
name|TParseContext
operator|::
name|samplerErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
specifier|const
name|TPublicType
modifier|&
name|pType
parameter_list|,
specifier|const
name|char
modifier|*
name|reason
parameter_list|)
block|{
if|if
condition|(
name|pType
operator|.
name|type
operator|==
name|EbtStruct
condition|)
block|{
if|if
condition|(
name|containsSampler
argument_list|(
operator|*
name|pType
operator|.
name|userDef
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
name|reason
argument_list|,
name|getBasicString
argument_list|(
name|pType
operator|.
name|type
argument_list|)
argument_list|,
literal|"(structure contains a sampler)"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|IsSampler
argument_list|(
name|pType
operator|.
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
name|reason
argument_list|,
name|getBasicString
argument_list|(
name|pType
operator|.
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|structQualifierErrorCheck
name|bool
name|TParseContext
operator|::
name|structQualifierErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
specifier|const
name|TPublicType
modifier|&
name|pType
parameter_list|)
block|{
switch|switch
condition|(
name|pType
operator|.
name|qualifier
condition|)
block|{
case|case
name|EvqVaryingIn
case|:
case|case
name|EvqVaryingOut
case|:
case|case
name|EvqAttribute
case|:
case|case
name|EvqVertexIn
case|:
case|case
name|EvqFragmentOut
case|:
if|if
condition|(
name|pType
operator|.
name|type
operator|==
name|EbtStruct
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"cannot be used with a structure"
argument_list|,
name|getQualifierString
argument_list|(
name|pType
operator|.
name|qualifier
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
default|default:
break|break;
block|}
if|if
condition|(
name|pType
operator|.
name|qualifier
operator|!=
name|EvqUniform
operator|&&
name|samplerErrorCheck
argument_list|(
name|line
argument_list|,
name|pType
argument_list|,
literal|"samplers must be uniform"
argument_list|)
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|locationDeclaratorListCheck
name|bool
name|TParseContext
operator|::
name|locationDeclaratorListCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
specifier|const
name|TPublicType
modifier|&
name|pType
parameter_list|)
block|{
if|if
condition|(
name|pType
operator|.
name|layoutQualifier
operator|.
name|location
operator|!=
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"location must only be specified for a single input or output variable"
argument_list|,
literal|"location"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|parameterSamplerErrorCheck
name|bool
name|TParseContext
operator|::
name|parameterSamplerErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
name|TQualifier
name|qualifier
parameter_list|,
specifier|const
name|TType
modifier|&
name|type
parameter_list|)
block|{
if|if
condition|(
operator|(
name|qualifier
operator|==
name|EvqOut
operator|||
name|qualifier
operator|==
name|EvqInOut
operator|)
operator|&&
name|type
operator|.
name|getBasicType
argument_list|()
operator|!=
name|EbtStruct
operator|&&
name|IsSampler
argument_list|(
name|type
operator|.
name|getBasicType
argument_list|()
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"samplers cannot be output parameters"
argument_list|,
name|type
operator|.
name|getBasicString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|containsSampler
name|bool
name|TParseContext
operator|::
name|containsSampler
parameter_list|(
name|TType
modifier|&
name|type
parameter_list|)
block|{
if|if
condition|(
name|IsSampler
argument_list|(
name|type
operator|.
name|getBasicType
argument_list|()
argument_list|)
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|type
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtStruct
operator|||
name|type
operator|.
name|isInterfaceBlock
argument_list|()
condition|)
block|{
specifier|const
name|TFieldList
modifier|&
name|fields
init|=
name|type
operator|.
name|getStruct
argument_list|()
operator|->
name|fields
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|containsSampler
argument_list|(
operator|*
name|fields
index|[
name|i
index|]
operator|->
name|type
argument_list|()
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Do size checking for an array type's size.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns true if there was an error.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|arraySizeErrorCheck
name|bool
name|TParseContext
operator|::
name|arraySizeErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
name|TIntermTyped
modifier|*
name|expr
parameter_list|,
name|int
modifier|&
name|size
parameter_list|)
block|{
name|TIntermConstantUnion
modifier|*
name|constant
init|=
name|expr
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
if|if
condition|(
name|constant
operator|==
literal|0
operator|||
operator|!
name|constant
operator|->
name|isScalarInt
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"array size must be a constant integer expression"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|unsigned
name|int
name|unsignedSize
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|constant
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtUInt
condition|)
block|{
name|unsignedSize
operator|=
name|constant
operator|->
name|getUConst
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|size
operator|=
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|unsignedSize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size
operator|=
name|constant
operator|->
name|getIConst
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"array size must be non-negative"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
return|return
literal|true
return|;
block|}
name|unsignedSize
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"array size must be greater than zero"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// The size of arrays is restricted here to prevent issues further down the
comment|// compiler/translator/driver stack. Shader Model 5 generation hardware is limited to
comment|// 4096 registers so this should be reasonable even for aggressively optimizable code.
specifier|const
name|unsigned
name|int
name|sizeLimit
init|=
literal|65536
decl_stmt|;
if|if
condition|(
name|unsignedSize
operator|>
name|sizeLimit
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"array size too large"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// See if this qualifier can be an array.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns true if there is an error.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|arrayQualifierErrorCheck
name|bool
name|TParseContext
operator|::
name|arrayQualifierErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
name|TPublicType
name|type
parameter_list|)
block|{
if|if
condition|(
operator|(
name|type
operator|.
name|qualifier
operator|==
name|EvqAttribute
operator|)
operator|||
operator|(
name|type
operator|.
name|qualifier
operator|==
name|EvqVertexIn
operator|)
operator|||
operator|(
name|type
operator|.
name|qualifier
operator|==
name|EvqConst
operator|)
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"cannot declare arrays of this qualifier"
argument_list|,
name|TType
argument_list|(
name|type
argument_list|)
operator|.
name|getCompleteString
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// See if this type can be an array.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns true if there is an error.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|arrayTypeErrorCheck
name|bool
name|TParseContext
operator|::
name|arrayTypeErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
name|TPublicType
name|type
parameter_list|)
block|{
comment|//
comment|// Can the type be an array?
comment|//
if|if
condition|(
name|type
operator|.
name|array
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"cannot declare arrays of arrays"
argument_list|,
name|TType
argument_list|(
name|type
argument_list|)
operator|.
name|getCompleteString
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Do all the semantic checking for declaring an array, with and
end_comment
begin_comment
comment|// without a size, and make the right changes to the symbol table.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// size == 0 means no specified size.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns true if there was an error.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|arrayErrorCheck
name|bool
name|TParseContext
operator|::
name|arrayErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
specifier|const
name|TString
modifier|&
name|identifier
parameter_list|,
specifier|const
name|TPublicType
modifier|&
name|type
parameter_list|,
name|TVariable
modifier|*
modifier|&
name|variable
parameter_list|)
block|{
comment|//
comment|// Don't check for reserved word use until after we know it's not in the symbol table,
comment|// because reserved arrays can be redeclared.
comment|//
name|bool
name|builtIn
init|=
literal|false
decl_stmt|;
name|bool
name|sameScope
init|=
literal|false
decl_stmt|;
name|TSymbol
modifier|*
name|symbol
init|=
name|symbolTable
operator|.
name|find
argument_list|(
name|identifier
argument_list|,
literal|0
argument_list|,
operator|&
name|builtIn
argument_list|,
operator|&
name|sameScope
argument_list|)
decl_stmt|;
if|if
condition|(
name|symbol
operator|==
literal|0
operator|||
operator|!
name|sameScope
condition|)
block|{
name|bool
name|needsReservedErrorCheck
init|=
literal|true
decl_stmt|;
comment|// gl_LastFragData may be redeclared with a new precision qualifier
if|if
condition|(
name|identifier
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|15
argument_list|,
literal|"gl_LastFragData"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|type
operator|.
name|arraySize
operator|==
cast|static_cast
argument_list|<
specifier|const
name|TVariable
operator|*
argument_list|>
argument_list|(
name|symbolTable
operator|.
name|findBuiltIn
argument_list|(
literal|"gl_MaxDrawBuffers"
argument_list|,
name|shaderVersion
argument_list|)
argument_list|)
operator|->
name|getConstPointer
argument_list|()
operator|->
name|getIConst
argument_list|()
condition|)
block|{
if|if
condition|(
name|TSymbol
modifier|*
name|builtInSymbol
init|=
name|symbolTable
operator|.
name|findBuiltIn
argument_list|(
name|identifier
argument_list|,
name|shaderVersion
argument_list|)
condition|)
block|{
name|needsReservedErrorCheck
operator|=
name|extensionErrorCheck
argument_list|(
name|line
argument_list|,
name|builtInSymbol
operator|->
name|getExtension
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"redeclaration of array with size != gl_MaxDrawBuffers"
argument_list|,
name|identifier
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
if|if
condition|(
name|needsReservedErrorCheck
condition|)
if|if
condition|(
name|reservedErrorCheck
argument_list|(
name|line
argument_list|,
name|identifier
argument_list|)
condition|)
return|return
literal|true
return|;
name|variable
operator|=
operator|new
name|TVariable
argument_list|(
operator|&
name|identifier
argument_list|,
name|TType
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|.
name|arraySize
condition|)
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|setArraySize
argument_list|(
name|type
operator|.
name|arraySize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|symbolTable
operator|.
name|declare
argument_list|(
name|variable
argument_list|)
condition|)
block|{
operator|delete
name|variable
expr_stmt|;
name|error
argument_list|(
name|line
argument_list|,
literal|"INTERNAL ERROR inserting new symbol"
argument_list|,
name|identifier
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|symbol
operator|->
name|isVariable
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"variable expected"
argument_list|,
name|identifier
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|variable
operator|=
cast|static_cast
argument_list|<
name|TVariable
operator|*
argument_list|>
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|isArray
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"redeclaring non-array as array"
argument_list|,
name|identifier
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|getArraySize
argument_list|()
operator|>
literal|0
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"redeclaration of array with size"
argument_list|,
name|identifier
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|sameElementType
argument_list|(
name|TType
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"redeclaration of array with a different type"
argument_list|,
name|identifier
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|type
operator|.
name|arraySize
condition|)
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|setArraySize
argument_list|(
name|type
operator|.
name|arraySize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|voidErrorCheck
argument_list|(
name|line
argument_list|,
name|identifier
argument_list|,
name|type
argument_list|)
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Enforce non-initializer type/qualifier rules.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns true if there was an error.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|nonInitConstErrorCheck
name|bool
name|TParseContext
operator|::
name|nonInitConstErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
specifier|const
name|TString
modifier|&
name|identifier
parameter_list|,
name|TPublicType
modifier|&
name|type
parameter_list|,
name|bool
name|array
parameter_list|)
block|{
if|if
condition|(
name|type
operator|.
name|qualifier
operator|==
name|EvqConst
condition|)
block|{
comment|// Make the qualifier make sense.
name|type
operator|.
name|qualifier
operator|=
name|EvqTemporary
expr_stmt|;
if|if
condition|(
name|array
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"arrays may not be declared constant since they cannot be initialized"
argument_list|,
name|identifier
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|isStructureContainingArrays
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"structures containing arrays may not be declared constant since they cannot be initialized"
argument_list|,
name|identifier
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"variables with qualifier 'const' must be initialized"
argument_list|,
name|identifier
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Do semantic checking for a variable declaration that has no initializer,
end_comment
begin_comment
comment|// and update the symbol table.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns true if there was an error.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|nonInitErrorCheck
name|bool
name|TParseContext
operator|::
name|nonInitErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
specifier|const
name|TString
modifier|&
name|identifier
parameter_list|,
specifier|const
name|TPublicType
modifier|&
name|type
parameter_list|,
name|TVariable
modifier|*
modifier|&
name|variable
parameter_list|)
block|{
if|if
condition|(
name|reservedErrorCheck
argument_list|(
name|line
argument_list|,
name|identifier
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
name|variable
operator|=
operator|new
name|TVariable
argument_list|(
operator|&
name|identifier
argument_list|,
name|TType
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|symbolTable
operator|.
name|declare
argument_list|(
name|variable
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"redefinition"
argument_list|,
name|variable
operator|->
name|getName
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
operator|delete
name|variable
expr_stmt|;
name|variable
operator|=
literal|0
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|voidErrorCheck
argument_list|(
name|line
argument_list|,
name|identifier
argument_list|,
name|type
argument_list|)
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|paramErrorCheck
name|bool
name|TParseContext
operator|::
name|paramErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
name|TQualifier
name|qualifier
parameter_list|,
name|TQualifier
name|paramQualifier
parameter_list|,
name|TType
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
name|qualifier
operator|!=
name|EvqConst
operator|&&
name|qualifier
operator|!=
name|EvqTemporary
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"qualifier not allowed on function parameter"
argument_list|,
name|getQualifierString
argument_list|(
name|qualifier
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|qualifier
operator|==
name|EvqConst
operator|&&
name|paramQualifier
operator|!=
name|EvqIn
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"qualifier not allowed with "
argument_list|,
name|getQualifierString
argument_list|(
name|qualifier
argument_list|)
argument_list|,
name|getQualifierString
argument_list|(
name|paramQualifier
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|qualifier
operator|==
name|EvqConst
condition|)
name|type
operator|->
name|setQualifier
argument_list|(
name|EvqConstReadOnly
argument_list|)
expr_stmt|;
else|else
name|type
operator|->
name|setQualifier
argument_list|(
name|paramQualifier
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|extensionErrorCheck
name|bool
name|TParseContext
operator|::
name|extensionErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
specifier|const
name|TString
modifier|&
name|extension
parameter_list|)
block|{
specifier|const
name|TExtensionBehavior
modifier|&
name|extBehavior
init|=
name|extensionBehavior
argument_list|()
decl_stmt|;
name|TExtensionBehavior
operator|::
name|const_iterator
name|iter
init|=
name|extBehavior
operator|.
name|find
argument_list|(
name|extension
operator|.
name|c_str
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|iter
operator|==
name|extBehavior
operator|.
name|end
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"extension"
argument_list|,
name|extension
operator|.
name|c_str
argument_list|()
argument_list|,
literal|"is not supported"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// In GLSL ES, an extension's default behavior is "disable".
if|if
condition|(
name|iter
operator|->
name|second
operator|==
name|EBhDisable
operator|||
name|iter
operator|->
name|second
operator|==
name|EBhUndefined
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"extension"
argument_list|,
name|extension
operator|.
name|c_str
argument_list|()
argument_list|,
literal|"is disabled"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|iter
operator|->
name|second
operator|==
name|EBhWarn
condition|)
block|{
name|warning
argument_list|(
name|line
argument_list|,
literal|"extension"
argument_list|,
name|extension
operator|.
name|c_str
argument_list|()
argument_list|,
literal|"is being used"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|singleDeclarationErrorCheck
name|bool
name|TParseContext
operator|::
name|singleDeclarationErrorCheck
parameter_list|(
name|TPublicType
modifier|&
name|publicType
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|identifierLocation
parameter_list|,
specifier|const
name|TString
modifier|&
name|identifier
parameter_list|)
block|{
if|if
condition|(
name|structQualifierErrorCheck
argument_list|(
name|identifierLocation
argument_list|,
name|publicType
argument_list|)
condition|)
return|return
literal|true
return|;
comment|// check for layout qualifier issues
specifier|const
name|TLayoutQualifier
name|layoutQualifier
init|=
name|publicType
operator|.
name|layoutQualifier
decl_stmt|;
if|if
condition|(
name|layoutQualifier
operator|.
name|matrixPacking
operator|!=
name|EmpUnspecified
condition|)
block|{
name|error
argument_list|(
name|identifierLocation
argument_list|,
literal|"layout qualifier"
argument_list|,
name|getMatrixPackingString
argument_list|(
name|layoutQualifier
operator|.
name|matrixPacking
argument_list|)
argument_list|,
literal|"only valid for interface blocks"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|layoutQualifier
operator|.
name|blockStorage
operator|!=
name|EbsUnspecified
condition|)
block|{
name|error
argument_list|(
name|identifierLocation
argument_list|,
literal|"layout qualifier"
argument_list|,
name|getBlockStorageString
argument_list|(
name|layoutQualifier
operator|.
name|blockStorage
argument_list|)
argument_list|,
literal|"only valid for interface blocks"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|publicType
operator|.
name|qualifier
operator|!=
name|EvqVertexIn
operator|&&
name|publicType
operator|.
name|qualifier
operator|!=
name|EvqFragmentOut
operator|&&
name|layoutLocationErrorCheck
argument_list|(
name|identifierLocation
argument_list|,
name|publicType
operator|.
name|layoutQualifier
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|layoutLocationErrorCheck
name|bool
name|TParseContext
operator|::
name|layoutLocationErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|location
parameter_list|,
specifier|const
name|TLayoutQualifier
modifier|&
name|layoutQualifier
parameter_list|)
block|{
if|if
condition|(
name|layoutQualifier
operator|.
name|location
operator|!=
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
name|location
argument_list|,
literal|"invalid layout qualifier:"
argument_list|,
literal|"location"
argument_list|,
literal|"only valid on program inputs and outputs"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|functionCallLValueErrorCheck
name|bool
name|TParseContext
operator|::
name|functionCallLValueErrorCheck
parameter_list|(
specifier|const
name|TFunction
modifier|*
name|fnCandidate
parameter_list|,
name|TIntermAggregate
modifier|*
name|aggregate
parameter_list|)
block|{
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fnCandidate
operator|->
name|getParamCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|TQualifier
name|qual
init|=
name|fnCandidate
operator|->
name|getParam
argument_list|(
name|i
argument_list|)
operator|.
name|type
operator|->
name|getQualifier
argument_list|()
decl_stmt|;
if|if
condition|(
name|qual
operator|==
name|EvqOut
operator|||
name|qual
operator|==
name|EvqInOut
condition|)
block|{
name|TIntermTyped
modifier|*
name|node
init|=
operator|(
operator|*
operator|(
name|aggregate
operator|->
name|getSequence
argument_list|()
operator|)
operator|)
index|[
name|i
index|]
operator|->
name|getAsTyped
argument_list|()
decl_stmt|;
if|if
condition|(
name|lValueErrorCheck
argument_list|(
name|node
operator|->
name|getLine
argument_list|()
argument_list|,
literal|"assign"
argument_list|,
name|node
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|node
operator|->
name|getLine
argument_list|()
argument_list|,
literal|"Constant value cannot be passed for 'out' or 'inout' parameters."
argument_list|,
literal|"Error"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|supportsExtension
name|bool
name|TParseContext
operator|::
name|supportsExtension
parameter_list|(
specifier|const
name|char
modifier|*
name|extension
parameter_list|)
block|{
specifier|const
name|TExtensionBehavior
modifier|&
name|extbehavior
init|=
name|extensionBehavior
argument_list|()
decl_stmt|;
name|TExtensionBehavior
operator|::
name|const_iterator
name|iter
init|=
name|extbehavior
operator|.
name|find
argument_list|(
name|extension
argument_list|)
decl_stmt|;
return|return
operator|(
name|iter
operator|!=
name|extbehavior
operator|.
name|end
argument_list|()
operator|)
return|;
block|}
end_function
begin_function
DECL|function|isExtensionEnabled
name|bool
name|TParseContext
operator|::
name|isExtensionEnabled
parameter_list|(
specifier|const
name|char
modifier|*
name|extension
parameter_list|)
specifier|const
block|{
specifier|const
name|TExtensionBehavior
modifier|&
name|extbehavior
init|=
name|extensionBehavior
argument_list|()
decl_stmt|;
name|TExtensionBehavior
operator|::
name|const_iterator
name|iter
init|=
name|extbehavior
operator|.
name|find
argument_list|(
name|extension
argument_list|)
decl_stmt|;
if|if
condition|(
name|iter
operator|==
name|extbehavior
operator|.
name|end
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
operator|(
name|iter
operator|->
name|second
operator|==
name|EBhEnable
operator|||
name|iter
operator|->
name|second
operator|==
name|EBhRequire
operator|)
return|;
block|}
end_function
begin_function
DECL|function|handleExtensionDirective
name|void
name|TParseContext
operator|::
name|handleExtensionDirective
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|,
specifier|const
name|char
modifier|*
name|extName
parameter_list|,
specifier|const
name|char
modifier|*
name|behavior
parameter_list|)
block|{
name|pp
operator|::
name|SourceLocation
name|srcLoc
decl_stmt|;
name|srcLoc
operator|.
name|file
operator|=
name|loc
operator|.
name|first_file
expr_stmt|;
name|srcLoc
operator|.
name|line
operator|=
name|loc
operator|.
name|first_line
expr_stmt|;
name|directiveHandler
operator|.
name|handleExtension
argument_list|(
name|srcLoc
argument_list|,
name|extName
argument_list|,
name|behavior
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|handlePragmaDirective
name|void
name|TParseContext
operator|::
name|handlePragmaDirective
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|bool
name|stdgl
parameter_list|)
block|{
name|pp
operator|::
name|SourceLocation
name|srcLoc
decl_stmt|;
name|srcLoc
operator|.
name|file
operator|=
name|loc
operator|.
name|first_file
expr_stmt|;
name|srcLoc
operator|.
name|line
operator|=
name|loc
operator|.
name|first_line
expr_stmt|;
name|directiveHandler
operator|.
name|handlePragma
argument_list|(
name|srcLoc
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|stdgl
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/////////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Non-Errors.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|/////////////////////////////////////////////////////////////////////////////////
end_comment
begin_function
DECL|function|getNamedVariable
specifier|const
name|TVariable
modifier|*
name|TParseContext
operator|::
name|getNamedVariable
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|location
parameter_list|,
specifier|const
name|TString
modifier|*
name|name
parameter_list|,
specifier|const
name|TSymbol
modifier|*
name|symbol
parameter_list|)
block|{
specifier|const
name|TVariable
modifier|*
name|variable
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|symbol
condition|)
block|{
name|error
argument_list|(
name|location
argument_list|,
literal|"undeclared identifier"
argument_list|,
name|name
operator|->
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|symbol
operator|->
name|isVariable
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|location
argument_list|,
literal|"variable expected"
argument_list|,
name|name
operator|->
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|variable
operator|=
cast|static_cast
argument_list|<
specifier|const
name|TVariable
operator|*
argument_list|>
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbolTable
operator|.
name|findBuiltIn
argument_list|(
name|variable
operator|->
name|getName
argument_list|()
argument_list|,
name|shaderVersion
argument_list|)
operator|&&
operator|!
name|variable
operator|->
name|getExtension
argument_list|()
operator|.
name|empty
argument_list|()
operator|&&
name|extensionErrorCheck
argument_list|(
name|location
argument_list|,
name|variable
operator|->
name|getExtension
argument_list|()
argument_list|)
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|variable
condition|)
block|{
name|TType
name|type
argument_list|(
name|EbtFloat
argument_list|,
name|EbpUndefined
argument_list|)
decl_stmt|;
name|TVariable
modifier|*
name|fakeVariable
init|=
operator|new
name|TVariable
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|symbolTable
operator|.
name|declare
argument_list|(
name|fakeVariable
argument_list|)
expr_stmt|;
name|variable
operator|=
name|fakeVariable
expr_stmt|;
block|}
return|return
name|variable
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Look up a function name in the symbol table, and make sure it is a function.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Return the function symbol if found, otherwise 0.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|findFunction
specifier|const
name|TFunction
modifier|*
name|TParseContext
operator|::
name|findFunction
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
name|TFunction
modifier|*
name|call
parameter_list|,
name|int
name|inputShaderVersion
parameter_list|,
name|bool
modifier|*
name|builtIn
parameter_list|)
block|{
comment|// First find by unmangled name to check whether the function name has been
comment|// hidden by a variable name or struct typename.
comment|// If a function is found, check for one with a matching argument list.
specifier|const
name|TSymbol
modifier|*
name|symbol
init|=
name|symbolTable
operator|.
name|find
argument_list|(
name|call
operator|->
name|getName
argument_list|()
argument_list|,
name|inputShaderVersion
argument_list|,
name|builtIn
argument_list|)
decl_stmt|;
if|if
condition|(
name|symbol
operator|==
literal|0
operator|||
name|symbol
operator|->
name|isFunction
argument_list|()
condition|)
block|{
name|symbol
operator|=
name|symbolTable
operator|.
name|find
argument_list|(
name|call
operator|->
name|getMangledName
argument_list|()
argument_list|,
name|inputShaderVersion
argument_list|,
name|builtIn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|symbol
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"no matching overloaded function found"
argument_list|,
name|call
operator|->
name|getName
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|symbol
operator|->
name|isFunction
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"function name expected"
argument_list|,
name|call
operator|->
name|getName
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
cast|static_cast
argument_list|<
specifier|const
name|TFunction
operator|*
argument_list|>
argument_list|(
name|symbol
argument_list|)
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Initializers show up in several places in the grammar.  Have one set of
end_comment
begin_comment
comment|// code to handle them here.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns true on error, false if no error
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|executeInitializer
name|bool
name|TParseContext
operator|::
name|executeInitializer
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
specifier|const
name|TString
modifier|&
name|identifier
parameter_list|,
name|TPublicType
modifier|&
name|pType
parameter_list|,
name|TIntermTyped
modifier|*
name|initializer
parameter_list|,
name|TIntermNode
modifier|*
modifier|&
name|intermNode
parameter_list|,
name|TVariable
modifier|*
name|variable
parameter_list|)
block|{
name|TType
name|type
init|=
name|TType
argument_list|(
name|pType
argument_list|)
decl_stmt|;
if|if
condition|(
name|variable
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reservedErrorCheck
argument_list|(
name|line
argument_list|,
name|identifier
argument_list|)
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|voidErrorCheck
argument_list|(
name|line
argument_list|,
name|identifier
argument_list|,
name|pType
argument_list|)
condition|)
return|return
literal|true
return|;
comment|//
comment|// add variable to symbol table
comment|//
name|variable
operator|=
operator|new
name|TVariable
argument_list|(
operator|&
name|identifier
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|symbolTable
operator|.
name|declare
argument_list|(
name|variable
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"redefinition"
argument_list|,
name|variable
operator|->
name|getName
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
comment|// don't delete variable, it's used by error recovery, and the pool
comment|// pop will take care of the memory
block|}
block|}
comment|//
comment|// identifier must be of type constant, a global, or a temporary
comment|//
name|TQualifier
name|qualifier
init|=
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|getQualifier
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|qualifier
operator|!=
name|EvqTemporary
operator|)
operator|&&
operator|(
name|qualifier
operator|!=
name|EvqGlobal
operator|)
operator|&&
operator|(
name|qualifier
operator|!=
name|EvqConst
operator|)
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|" cannot initialize this type of qualifier "
argument_list|,
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|getQualifierString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|//
comment|// test for and propagate constant
comment|//
if|if
condition|(
name|qualifier
operator|==
name|EvqConst
condition|)
block|{
if|if
condition|(
name|qualifier
operator|!=
name|initializer
operator|->
name|getType
argument_list|()
operator|.
name|getQualifier
argument_list|()
condition|)
block|{
name|std
operator|::
name|stringstream
name|extraInfoStream
decl_stmt|;
name|extraInfoStream
operator|<<
literal|"'"
operator|<<
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|getCompleteString
argument_list|()
operator|<<
literal|"'"
expr_stmt|;
name|std
operator|::
name|string
name|extraInfo
init|=
name|extraInfoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|error
argument_list|(
name|line
argument_list|,
literal|" assigning non-constant to"
argument_list|,
literal|"="
argument_list|,
name|extraInfo
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|setQualifier
argument_list|(
name|EvqTemporary
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|type
operator|!=
name|initializer
operator|->
name|getType
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|" non-matching types for const initializer "
argument_list|,
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|getQualifierString
argument_list|()
argument_list|)
expr_stmt|;
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|setQualifier
argument_list|(
name|EvqTemporary
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|initializer
operator|->
name|getAsConstantUnion
argument_list|()
condition|)
block|{
name|variable
operator|->
name|shareConstPointer
argument_list|(
name|initializer
operator|->
name|getAsConstantUnion
argument_list|()
operator|->
name|getUnionArrayPointer
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|initializer
operator|->
name|getAsSymbolNode
argument_list|()
condition|)
block|{
specifier|const
name|TSymbol
modifier|*
name|symbol
init|=
name|symbolTable
operator|.
name|find
argument_list|(
name|initializer
operator|->
name|getAsSymbolNode
argument_list|()
operator|->
name|getSymbol
argument_list|()
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|const
name|TVariable
modifier|*
name|tVar
init|=
cast|static_cast
argument_list|<
specifier|const
name|TVariable
operator|*
argument_list|>
argument_list|(
name|symbol
argument_list|)
decl_stmt|;
name|ConstantUnion
modifier|*
name|constArray
init|=
name|tVar
operator|->
name|getConstPointer
argument_list|()
decl_stmt|;
name|variable
operator|->
name|shareConstPointer
argument_list|(
name|constArray
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|std
operator|::
name|stringstream
name|extraInfoStream
decl_stmt|;
name|extraInfoStream
operator|<<
literal|"'"
operator|<<
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|getCompleteString
argument_list|()
operator|<<
literal|"'"
expr_stmt|;
name|std
operator|::
name|string
name|extraInfo
init|=
name|extraInfoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|error
argument_list|(
name|line
argument_list|,
literal|" cannot assign to"
argument_list|,
literal|"="
argument_list|,
name|extraInfo
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|setQualifier
argument_list|(
name|EvqTemporary
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
if|if
condition|(
name|qualifier
operator|!=
name|EvqConst
condition|)
block|{
name|TIntermSymbol
modifier|*
name|intermSymbol
init|=
name|intermediate
operator|.
name|addSymbol
argument_list|(
name|variable
operator|->
name|getUniqueId
argument_list|()
argument_list|,
name|variable
operator|->
name|getName
argument_list|()
argument_list|,
name|variable
operator|->
name|getType
argument_list|()
argument_list|,
name|line
argument_list|)
decl_stmt|;
name|intermNode
operator|=
name|createAssign
argument_list|(
name|EOpInitialize
argument_list|,
name|intermSymbol
argument_list|,
name|initializer
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|intermNode
operator|==
literal|0
condition|)
block|{
name|assignError
argument_list|(
name|line
argument_list|,
literal|"="
argument_list|,
name|intermSymbol
operator|->
name|getCompleteString
argument_list|()
argument_list|,
name|initializer
operator|->
name|getCompleteString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
else|else
name|intermNode
operator|=
literal|0
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|areAllChildConst
name|bool
name|TParseContext
operator|::
name|areAllChildConst
parameter_list|(
name|TIntermAggregate
modifier|*
name|aggrNode
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|aggrNode
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aggrNode
operator|->
name|isConstructor
argument_list|()
condition|)
return|return
literal|false
return|;
name|bool
name|allConstant
init|=
literal|true
decl_stmt|;
comment|// check if all the child nodes are constants so that they can be inserted into
comment|// the parent node
name|TIntermSequence
modifier|*
name|sequence
init|=
name|aggrNode
operator|->
name|getSequence
argument_list|()
decl_stmt|;
for|for
control|(
name|TIntermSequence
operator|::
name|iterator
name|p
init|=
name|sequence
operator|->
name|begin
argument_list|()
init|;
name|p
operator|!=
name|sequence
operator|->
name|end
argument_list|()
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|p
operator|)
operator|->
name|getAsTyped
argument_list|()
operator|->
name|getAsConstantUnion
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
return|return
name|allConstant
return|;
block|}
end_function
begin_function
DECL|function|addFullySpecifiedType
name|TPublicType
name|TParseContext
operator|::
name|addFullySpecifiedType
parameter_list|(
name|TQualifier
name|qualifier
parameter_list|,
name|TLayoutQualifier
name|layoutQualifier
parameter_list|,
specifier|const
name|TPublicType
modifier|&
name|typeSpecifier
parameter_list|)
block|{
name|TPublicType
name|returnType
init|=
name|typeSpecifier
decl_stmt|;
name|returnType
operator|.
name|qualifier
operator|=
name|qualifier
expr_stmt|;
name|returnType
operator|.
name|layoutQualifier
operator|=
name|layoutQualifier
expr_stmt|;
if|if
condition|(
name|typeSpecifier
operator|.
name|array
condition|)
block|{
name|error
argument_list|(
name|typeSpecifier
operator|.
name|line
argument_list|,
literal|"not supported"
argument_list|,
literal|"first-class array"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
name|returnType
operator|.
name|setArray
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shaderVersion
operator|<
literal|300
condition|)
block|{
if|if
condition|(
name|qualifier
operator|==
name|EvqAttribute
operator|&&
operator|(
name|typeSpecifier
operator|.
name|type
operator|==
name|EbtBool
operator|||
name|typeSpecifier
operator|.
name|type
operator|==
name|EbtInt
operator|)
condition|)
block|{
name|error
argument_list|(
name|typeSpecifier
operator|.
name|line
argument_list|,
literal|"cannot be bool or int"
argument_list|,
name|getQualifierString
argument_list|(
name|qualifier
argument_list|)
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|qualifier
operator|==
name|EvqVaryingIn
operator|||
name|qualifier
operator|==
name|EvqVaryingOut
operator|)
operator|&&
operator|(
name|typeSpecifier
operator|.
name|type
operator|==
name|EbtBool
operator|||
name|typeSpecifier
operator|.
name|type
operator|==
name|EbtInt
operator|)
condition|)
block|{
name|error
argument_list|(
name|typeSpecifier
operator|.
name|line
argument_list|,
literal|"cannot be bool or int"
argument_list|,
name|getQualifierString
argument_list|(
name|qualifier
argument_list|)
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|qualifier
condition|)
block|{
case|case
name|EvqSmoothIn
case|:
case|case
name|EvqSmoothOut
case|:
case|case
name|EvqVertexOut
case|:
case|case
name|EvqFragmentIn
case|:
case|case
name|EvqCentroidOut
case|:
case|case
name|EvqCentroidIn
case|:
if|if
condition|(
name|typeSpecifier
operator|.
name|type
operator|==
name|EbtBool
condition|)
block|{
name|error
argument_list|(
name|typeSpecifier
operator|.
name|line
argument_list|,
literal|"cannot be bool"
argument_list|,
name|getQualifierString
argument_list|(
name|qualifier
argument_list|)
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|typeSpecifier
operator|.
name|type
operator|==
name|EbtInt
operator|||
name|typeSpecifier
operator|.
name|type
operator|==
name|EbtUInt
condition|)
block|{
name|error
argument_list|(
name|typeSpecifier
operator|.
name|line
argument_list|,
literal|"must use 'flat' interpolation here"
argument_list|,
name|getQualifierString
argument_list|(
name|qualifier
argument_list|)
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|EvqVertexIn
case|:
case|case
name|EvqFragmentOut
case|:
case|case
name|EvqFlatIn
case|:
case|case
name|EvqFlatOut
case|:
if|if
condition|(
name|typeSpecifier
operator|.
name|type
operator|==
name|EbtBool
condition|)
block|{
name|error
argument_list|(
name|typeSpecifier
operator|.
name|line
argument_list|,
literal|"cannot be bool"
argument_list|,
name|getQualifierString
argument_list|(
name|qualifier
argument_list|)
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|returnType
return|;
block|}
end_function
begin_function
DECL|function|parseSingleDeclaration
name|TIntermAggregate
modifier|*
name|TParseContext
operator|::
name|parseSingleDeclaration
parameter_list|(
name|TPublicType
modifier|&
name|publicType
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|identifierLocation
parameter_list|,
specifier|const
name|TString
modifier|&
name|identifier
parameter_list|)
block|{
name|TIntermSymbol
modifier|*
name|symbol
init|=
name|intermediate
operator|.
name|addSymbol
argument_list|(
literal|0
argument_list|,
name|identifier
argument_list|,
name|TType
argument_list|(
name|publicType
argument_list|)
argument_list|,
name|identifierLocation
argument_list|)
decl_stmt|;
name|TIntermAggregate
modifier|*
name|aggregate
init|=
name|intermediate
operator|.
name|makeAggregate
argument_list|(
name|symbol
argument_list|,
name|identifierLocation
argument_list|)
decl_stmt|;
if|if
condition|(
name|identifier
operator|!=
literal|""
condition|)
block|{
if|if
condition|(
name|singleDeclarationErrorCheck
argument_list|(
name|publicType
argument_list|,
name|identifierLocation
argument_list|,
name|identifier
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
comment|// this error check can mutate the type
if|if
condition|(
name|nonInitConstErrorCheck
argument_list|(
name|identifierLocation
argument_list|,
name|identifier
argument_list|,
name|publicType
argument_list|,
literal|false
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
name|TVariable
modifier|*
name|variable
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|nonInitErrorCheck
argument_list|(
name|identifierLocation
argument_list|,
name|identifier
argument_list|,
name|publicType
argument_list|,
name|variable
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
if|if
condition|(
name|variable
operator|&&
name|symbol
condition|)
block|{
name|symbol
operator|->
name|setId
argument_list|(
name|variable
operator|->
name|getUniqueId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|aggregate
return|;
block|}
end_function
begin_function
DECL|function|parseSingleArrayDeclaration
name|TIntermAggregate
modifier|*
name|TParseContext
operator|::
name|parseSingleArrayDeclaration
parameter_list|(
name|TPublicType
modifier|&
name|publicType
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|identifierLocation
parameter_list|,
specifier|const
name|TString
modifier|&
name|identifier
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|indexLocation
parameter_list|,
name|TIntermTyped
modifier|*
name|indexExpression
parameter_list|)
block|{
if|if
condition|(
name|singleDeclarationErrorCheck
argument_list|(
name|publicType
argument_list|,
name|identifierLocation
argument_list|,
name|identifier
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
comment|// this error check can mutate the type
if|if
condition|(
name|nonInitConstErrorCheck
argument_list|(
name|identifierLocation
argument_list|,
name|identifier
argument_list|,
name|publicType
argument_list|,
literal|true
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
if|if
condition|(
name|arrayTypeErrorCheck
argument_list|(
name|indexLocation
argument_list|,
name|publicType
argument_list|)
operator|||
name|arrayQualifierErrorCheck
argument_list|(
name|indexLocation
argument_list|,
name|publicType
argument_list|)
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
block|}
name|TPublicType
name|arrayType
init|=
name|publicType
decl_stmt|;
name|int
name|size
decl_stmt|;
if|if
condition|(
name|arraySizeErrorCheck
argument_list|(
name|identifierLocation
argument_list|,
name|indexExpression
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|arrayType
operator|.
name|setArray
argument_list|(
literal|true
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|TIntermSymbol
modifier|*
name|symbol
init|=
name|intermediate
operator|.
name|addSymbol
argument_list|(
literal|0
argument_list|,
name|identifier
argument_list|,
name|TType
argument_list|(
name|arrayType
argument_list|)
argument_list|,
name|identifierLocation
argument_list|)
decl_stmt|;
name|TIntermAggregate
modifier|*
name|aggregate
init|=
name|intermediate
operator|.
name|makeAggregate
argument_list|(
name|symbol
argument_list|,
name|identifierLocation
argument_list|)
decl_stmt|;
name|TVariable
modifier|*
name|variable
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|arrayErrorCheck
argument_list|(
name|identifierLocation
argument_list|,
name|identifier
argument_list|,
name|arrayType
argument_list|,
name|variable
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
if|if
condition|(
name|variable
operator|&&
name|symbol
condition|)
block|{
name|symbol
operator|->
name|setId
argument_list|(
name|variable
operator|->
name|getUniqueId
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|aggregate
return|;
block|}
end_function
begin_function
DECL|function|parseSingleInitDeclaration
name|TIntermAggregate
modifier|*
name|TParseContext
operator|::
name|parseSingleInitDeclaration
parameter_list|(
name|TPublicType
modifier|&
name|publicType
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|identifierLocation
parameter_list|,
specifier|const
name|TString
modifier|&
name|identifier
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|initLocation
parameter_list|,
name|TIntermTyped
modifier|*
name|initializer
parameter_list|)
block|{
if|if
condition|(
name|singleDeclarationErrorCheck
argument_list|(
name|publicType
argument_list|,
name|identifierLocation
argument_list|,
name|identifier
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
name|TIntermNode
modifier|*
name|intermNode
decl_stmt|;
if|if
condition|(
operator|!
name|executeInitializer
argument_list|(
name|identifierLocation
argument_list|,
name|identifier
argument_list|,
name|publicType
argument_list|,
name|initializer
argument_list|,
name|intermNode
argument_list|)
condition|)
block|{
comment|//
comment|// Build intermediate representation
comment|//
return|return
name|intermNode
condition|?
name|intermediate
operator|.
name|makeAggregate
argument_list|(
name|intermNode
argument_list|,
name|initLocation
argument_list|)
else|:
name|NULL
return|;
block|}
else|else
block|{
name|recover
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function
begin_function
DECL|function|parseInvariantDeclaration
name|TIntermAggregate
modifier|*
name|TParseContext
operator|::
name|parseInvariantDeclaration
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|invariantLoc
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|identifierLoc
parameter_list|,
specifier|const
name|TString
modifier|*
name|identifier
parameter_list|,
specifier|const
name|TSymbol
modifier|*
name|symbol
parameter_list|)
block|{
comment|// invariant declaration
if|if
condition|(
name|globalErrorCheck
argument_list|(
name|invariantLoc
argument_list|,
name|symbolTable
operator|.
name|atGlobalLevel
argument_list|()
argument_list|,
literal|"invariant varying"
argument_list|)
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|symbol
condition|)
block|{
name|error
argument_list|(
name|identifierLoc
argument_list|,
literal|"undeclared identifier declared as invariant"
argument_list|,
name|identifier
operator|->
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
block|{
specifier|const
name|TString
name|kGlFrontFacing
argument_list|(
literal|"gl_FrontFacing"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|identifier
operator|==
name|kGlFrontFacing
condition|)
block|{
name|error
argument_list|(
name|identifierLoc
argument_list|,
literal|"identifier should not be declared as invariant"
argument_list|,
name|identifier
operator|->
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|symbolTable
operator|.
name|addInvariantVarying
argument_list|(
name|std
operator|::
name|string
argument_list|(
name|identifier
operator|->
name|c_str
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
specifier|const
name|TVariable
modifier|*
name|variable
init|=
name|getNamedVariable
argument_list|(
name|identifierLoc
argument_list|,
name|identifier
argument_list|,
name|symbol
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|variable
argument_list|)
expr_stmt|;
specifier|const
name|TType
modifier|&
name|type
init|=
name|variable
operator|->
name|getType
argument_list|()
decl_stmt|;
name|TIntermSymbol
modifier|*
name|intermSymbol
init|=
name|intermediate
operator|.
name|addSymbol
argument_list|(
name|variable
operator|->
name|getUniqueId
argument_list|()
argument_list|,
operator|*
name|identifier
argument_list|,
name|type
argument_list|,
name|identifierLoc
argument_list|)
decl_stmt|;
name|TIntermAggregate
modifier|*
name|aggregate
init|=
name|intermediate
operator|.
name|makeAggregate
argument_list|(
name|intermSymbol
argument_list|,
name|identifierLoc
argument_list|)
decl_stmt|;
name|aggregate
operator|->
name|setOp
argument_list|(
name|EOpInvariantDeclaration
argument_list|)
expr_stmt|;
return|return
name|aggregate
return|;
block|}
block|}
end_function
begin_function
DECL|function|parseDeclarator
name|TIntermAggregate
modifier|*
name|TParseContext
operator|::
name|parseDeclarator
parameter_list|(
name|TPublicType
modifier|&
name|publicType
parameter_list|,
name|TIntermAggregate
modifier|*
name|aggregateDeclaration
parameter_list|,
name|TSymbol
modifier|*
name|identifierSymbol
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|identifierLocation
parameter_list|,
specifier|const
name|TString
modifier|&
name|identifier
parameter_list|)
block|{
name|TIntermSymbol
modifier|*
name|symbol
init|=
name|intermediate
operator|.
name|addSymbol
argument_list|(
literal|0
argument_list|,
name|identifier
argument_list|,
name|TType
argument_list|(
name|publicType
argument_list|)
argument_list|,
name|identifierLocation
argument_list|)
decl_stmt|;
name|TIntermAggregate
modifier|*
name|intermAggregate
init|=
name|intermediate
operator|.
name|growAggregate
argument_list|(
name|aggregateDeclaration
argument_list|,
name|symbol
argument_list|,
name|identifierLocation
argument_list|)
decl_stmt|;
if|if
condition|(
name|structQualifierErrorCheck
argument_list|(
name|identifierLocation
argument_list|,
name|publicType
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
if|if
condition|(
name|locationDeclaratorListCheck
argument_list|(
name|identifierLocation
argument_list|,
name|publicType
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
if|if
condition|(
name|nonInitConstErrorCheck
argument_list|(
name|identifierLocation
argument_list|,
name|identifier
argument_list|,
name|publicType
argument_list|,
literal|false
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
name|TVariable
modifier|*
name|variable
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|nonInitErrorCheck
argument_list|(
name|identifierLocation
argument_list|,
name|identifier
argument_list|,
name|publicType
argument_list|,
name|variable
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
if|if
condition|(
name|symbol
operator|&&
name|variable
condition|)
name|symbol
operator|->
name|setId
argument_list|(
name|variable
operator|->
name|getUniqueId
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|intermAggregate
return|;
block|}
end_function
begin_function
DECL|function|parseArrayDeclarator
name|TIntermAggregate
modifier|*
name|TParseContext
operator|::
name|parseArrayDeclarator
parameter_list|(
name|TPublicType
modifier|&
name|publicType
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|identifierLocation
parameter_list|,
specifier|const
name|TString
modifier|&
name|identifier
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|arrayLocation
parameter_list|,
name|TIntermNode
modifier|*
name|declaratorList
parameter_list|,
name|TIntermTyped
modifier|*
name|indexExpression
parameter_list|)
block|{
if|if
condition|(
name|structQualifierErrorCheck
argument_list|(
name|identifierLocation
argument_list|,
name|publicType
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
if|if
condition|(
name|locationDeclaratorListCheck
argument_list|(
name|identifierLocation
argument_list|,
name|publicType
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
if|if
condition|(
name|nonInitConstErrorCheck
argument_list|(
name|identifierLocation
argument_list|,
name|identifier
argument_list|,
name|publicType
argument_list|,
literal|true
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
if|if
condition|(
name|arrayTypeErrorCheck
argument_list|(
name|arrayLocation
argument_list|,
name|publicType
argument_list|)
operator|||
name|arrayQualifierErrorCheck
argument_list|(
name|arrayLocation
argument_list|,
name|publicType
argument_list|)
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|indexExpression
condition|)
block|{
name|int
name|size
decl_stmt|;
if|if
condition|(
name|arraySizeErrorCheck
argument_list|(
name|arrayLocation
argument_list|,
name|indexExpression
argument_list|,
name|size
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
name|TPublicType
name|arrayType
argument_list|(
name|publicType
argument_list|)
decl_stmt|;
name|arrayType
operator|.
name|setArray
argument_list|(
literal|true
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|TVariable
modifier|*
name|variable
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|arrayErrorCheck
argument_list|(
name|arrayLocation
argument_list|,
name|identifier
argument_list|,
name|arrayType
argument_list|,
name|variable
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
name|TType
name|type
init|=
name|TType
argument_list|(
name|arrayType
argument_list|)
decl_stmt|;
name|type
operator|.
name|setArraySize
argument_list|(
name|size
argument_list|)
expr_stmt|;
return|return
name|intermediate
operator|.
name|growAggregate
argument_list|(
name|declaratorList
argument_list|,
name|intermediate
operator|.
name|addSymbol
argument_list|(
name|variable
condition|?
name|variable
operator|->
name|getUniqueId
argument_list|()
else|:
literal|0
argument_list|,
name|identifier
argument_list|,
name|type
argument_list|,
name|identifierLocation
argument_list|)
argument_list|,
name|identifierLocation
argument_list|)
return|;
block|}
else|else
block|{
name|TPublicType
name|arrayType
argument_list|(
name|publicType
argument_list|)
decl_stmt|;
name|arrayType
operator|.
name|setArray
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|TVariable
modifier|*
name|variable
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|arrayErrorCheck
argument_list|(
name|arrayLocation
argument_list|,
name|identifier
argument_list|,
name|arrayType
argument_list|,
name|variable
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|parseInitDeclarator
name|TIntermAggregate
modifier|*
name|TParseContext
operator|::
name|parseInitDeclarator
parameter_list|(
name|TPublicType
modifier|&
name|publicType
parameter_list|,
name|TIntermAggregate
modifier|*
name|declaratorList
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|identifierLocation
parameter_list|,
specifier|const
name|TString
modifier|&
name|identifier
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|initLocation
parameter_list|,
name|TIntermTyped
modifier|*
name|initializer
parameter_list|)
block|{
if|if
condition|(
name|structQualifierErrorCheck
argument_list|(
name|identifierLocation
argument_list|,
name|publicType
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
if|if
condition|(
name|locationDeclaratorListCheck
argument_list|(
name|identifierLocation
argument_list|,
name|publicType
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
name|TIntermNode
modifier|*
name|intermNode
decl_stmt|;
if|if
condition|(
operator|!
name|executeInitializer
argument_list|(
name|identifierLocation
argument_list|,
name|identifier
argument_list|,
name|publicType
argument_list|,
name|initializer
argument_list|,
name|intermNode
argument_list|)
condition|)
block|{
comment|//
comment|// build the intermediate representation
comment|//
if|if
condition|(
name|intermNode
condition|)
block|{
return|return
name|intermediate
operator|.
name|growAggregate
argument_list|(
name|declaratorList
argument_list|,
name|intermNode
argument_list|,
name|initLocation
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|declaratorList
return|;
block|}
block|}
else|else
block|{
name|recover
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function
begin_function
DECL|function|parseGlobalLayoutQualifier
name|void
name|TParseContext
operator|::
name|parseGlobalLayoutQualifier
parameter_list|(
specifier|const
name|TPublicType
modifier|&
name|typeQualifier
parameter_list|)
block|{
if|if
condition|(
name|typeQualifier
operator|.
name|qualifier
operator|!=
name|EvqUniform
condition|)
block|{
name|error
argument_list|(
name|typeQualifier
operator|.
name|line
argument_list|,
literal|"invalid qualifier:"
argument_list|,
name|getQualifierString
argument_list|(
name|typeQualifier
operator|.
name|qualifier
argument_list|)
argument_list|,
literal|"global layout must be uniform"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return;
block|}
specifier|const
name|TLayoutQualifier
name|layoutQualifier
init|=
name|typeQualifier
operator|.
name|layoutQualifier
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|layoutQualifier
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|shaderVersion
operator|<
literal|300
condition|)
block|{
name|error
argument_list|(
name|typeQualifier
operator|.
name|line
argument_list|,
literal|"layout qualifiers supported in GLSL ES 3.00 only"
argument_list|,
literal|"layout"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|layoutLocationErrorCheck
argument_list|(
name|typeQualifier
operator|.
name|line
argument_list|,
name|typeQualifier
operator|.
name|layoutQualifier
argument_list|)
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|layoutQualifier
operator|.
name|matrixPacking
operator|!=
name|EmpUnspecified
condition|)
block|{
name|defaultMatrixPacking
operator|=
name|layoutQualifier
operator|.
name|matrixPacking
expr_stmt|;
block|}
if|if
condition|(
name|layoutQualifier
operator|.
name|blockStorage
operator|!=
name|EbsUnspecified
condition|)
block|{
name|defaultBlockStorage
operator|=
name|layoutQualifier
operator|.
name|blockStorage
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|addConstructorFunc
name|TFunction
modifier|*
name|TParseContext
operator|::
name|addConstructorFunc
parameter_list|(
name|TPublicType
name|publicType
parameter_list|)
block|{
name|TOperator
name|op
init|=
name|EOpNull
decl_stmt|;
if|if
condition|(
name|publicType
operator|.
name|userDef
condition|)
block|{
name|op
operator|=
name|EOpConstructStruct
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|publicType
operator|.
name|type
condition|)
block|{
case|case
name|EbtFloat
case|:
if|if
condition|(
name|publicType
operator|.
name|isMatrix
argument_list|()
condition|)
block|{
comment|// TODO: non-square matrices
switch|switch
condition|(
name|publicType
operator|.
name|getCols
argument_list|()
condition|)
block|{
case|case
literal|2
case|:
name|op
operator|=
name|EOpConstructMat2
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|op
operator|=
name|EOpConstructMat3
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|op
operator|=
name|EOpConstructMat4
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|publicType
operator|.
name|getNominalSize
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
name|op
operator|=
name|EOpConstructFloat
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|op
operator|=
name|EOpConstructVec2
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|op
operator|=
name|EOpConstructVec3
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|op
operator|=
name|EOpConstructVec4
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|EbtInt
case|:
switch|switch
condition|(
name|publicType
operator|.
name|getNominalSize
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
name|op
operator|=
name|EOpConstructInt
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|op
operator|=
name|EOpConstructIVec2
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|op
operator|=
name|EOpConstructIVec3
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|op
operator|=
name|EOpConstructIVec4
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|EbtUInt
case|:
switch|switch
condition|(
name|publicType
operator|.
name|getNominalSize
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
name|op
operator|=
name|EOpConstructUInt
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|op
operator|=
name|EOpConstructUVec2
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|op
operator|=
name|EOpConstructUVec3
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|op
operator|=
name|EOpConstructUVec4
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|EbtBool
case|:
switch|switch
condition|(
name|publicType
operator|.
name|getNominalSize
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
name|op
operator|=
name|EOpConstructBool
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|op
operator|=
name|EOpConstructBVec2
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|op
operator|=
name|EOpConstructBVec3
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|op
operator|=
name|EOpConstructBVec4
expr_stmt|;
break|break;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|op
operator|==
name|EOpNull
condition|)
block|{
name|error
argument_list|(
name|publicType
operator|.
name|line
argument_list|,
literal|"cannot construct this type"
argument_list|,
name|getBasicString
argument_list|(
name|publicType
operator|.
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
name|publicType
operator|.
name|type
operator|=
name|EbtFloat
expr_stmt|;
name|op
operator|=
name|EOpConstructFloat
expr_stmt|;
block|}
block|}
name|TString
name|tempString
decl_stmt|;
name|TType
name|type
argument_list|(
name|publicType
argument_list|)
decl_stmt|;
return|return
operator|new
name|TFunction
argument_list|(
operator|&
name|tempString
argument_list|,
name|type
argument_list|,
name|op
argument_list|)
return|;
block|}
end_function
begin_comment
comment|// This function is used to test for the correctness of the parameters passed to various constructor functions
end_comment
begin_comment
comment|// and also convert them to the right datatype if it is allowed and required.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns 0 for an error or the constructed node (aggregate or typed) for no error.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addConstructor
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|addConstructor
parameter_list|(
name|TIntermNode
modifier|*
name|arguments
parameter_list|,
name|TType
modifier|*
name|type
parameter_list|,
name|TOperator
name|op
parameter_list|,
name|TFunction
modifier|*
name|fnCall
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
name|TIntermAggregate
modifier|*
name|aggregateArguments
init|=
name|arguments
operator|->
name|getAsAggregate
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|aggregateArguments
condition|)
block|{
name|aggregateArguments
operator|=
operator|new
name|TIntermAggregate
expr_stmt|;
name|aggregateArguments
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|arguments
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|==
name|EOpConstructStruct
condition|)
block|{
specifier|const
name|TFieldList
modifier|&
name|fields
init|=
name|type
operator|->
name|getStruct
argument_list|()
operator|->
name|fields
argument_list|()
decl_stmt|;
name|TIntermSequence
modifier|*
name|args
init|=
name|aggregateArguments
operator|->
name|getSequence
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|args
operator|->
name|size
argument_list|()
operator|||
operator|(
operator|*
name|args
operator|)
index|[
name|i
index|]
operator|->
name|getAsTyped
argument_list|()
operator|->
name|getType
argument_list|()
operator|!=
operator|*
name|fields
index|[
name|i
index|]
operator|->
name|type
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"Structure constructor arguments do not match structure fields"
argument_list|,
literal|"Error"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
comment|// Turn the argument list itself into a constructor
name|TIntermAggregate
modifier|*
name|constructor
init|=
name|intermediate
operator|.
name|setAggregateOperator
argument_list|(
name|aggregateArguments
argument_list|,
name|op
argument_list|,
name|line
argument_list|)
decl_stmt|;
name|TIntermTyped
modifier|*
name|constConstructor
init|=
name|foldConstConstructor
argument_list|(
name|constructor
argument_list|,
operator|*
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|constConstructor
condition|)
block|{
return|return
name|constConstructor
return|;
block|}
comment|// Structs should not be precision qualified, the individual members may be.
comment|// Built-in types on the other hand should be precision qualified.
if|if
condition|(
name|op
operator|!=
name|EOpConstructStruct
condition|)
block|{
name|constructor
operator|->
name|setPrecisionFromChildren
argument_list|()
expr_stmt|;
name|type
operator|->
name|setPrecision
argument_list|(
name|constructor
operator|->
name|getPrecision
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|constructor
return|;
block|}
end_function
begin_function
DECL|function|foldConstConstructor
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|foldConstConstructor
parameter_list|(
name|TIntermAggregate
modifier|*
name|aggrNode
parameter_list|,
specifier|const
name|TType
modifier|&
name|type
parameter_list|)
block|{
name|bool
name|canBeFolded
init|=
name|areAllChildConst
argument_list|(
name|aggrNode
argument_list|)
decl_stmt|;
name|aggrNode
operator|->
name|setType
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|canBeFolded
condition|)
block|{
name|bool
name|returnVal
init|=
literal|false
decl_stmt|;
name|ConstantUnion
modifier|*
name|unionArray
init|=
operator|new
name|ConstantUnion
index|[
name|type
operator|.
name|getObjectSize
argument_list|()
index|]
decl_stmt|;
if|if
condition|(
name|aggrNode
operator|->
name|getSequence
argument_list|()
operator|->
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|returnVal
operator|=
name|intermediate
operator|.
name|parseConstTree
argument_list|(
name|aggrNode
operator|->
name|getLine
argument_list|()
argument_list|,
name|aggrNode
argument_list|,
name|unionArray
argument_list|,
name|aggrNode
operator|->
name|getOp
argument_list|()
argument_list|,
name|type
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|returnVal
operator|=
name|intermediate
operator|.
name|parseConstTree
argument_list|(
name|aggrNode
operator|->
name|getLine
argument_list|()
argument_list|,
name|aggrNode
argument_list|,
name|unionArray
argument_list|,
name|aggrNode
operator|->
name|getOp
argument_list|()
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|returnVal
condition|)
return|return
literal|0
return|;
return|return
name|intermediate
operator|.
name|addConstantUnion
argument_list|(
name|unionArray
argument_list|,
name|type
argument_list|,
name|aggrNode
operator|->
name|getLine
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// This function returns the tree representation for the vector field(s) being accessed from contant vector.
end_comment
begin_comment
comment|// If only one component of vector is accessed (v.x or v[0] where v is a contant vector), then a contant node is
end_comment
begin_comment
comment|// returned, else an aggregate node is returned (for v.xy). The input to this function could either be the symbol
end_comment
begin_comment
comment|// node or it could be the intermediate tree representation of accessing fields in a constant structure or column of
end_comment
begin_comment
comment|// a constant matrix.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addConstVectorNode
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|addConstVectorNode
parameter_list|(
name|TVectorFields
modifier|&
name|fields
parameter_list|,
name|TIntermTyped
modifier|*
name|node
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
name|TIntermTyped
modifier|*
name|typedNode
decl_stmt|;
name|TIntermConstantUnion
modifier|*
name|tempConstantNode
init|=
name|node
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
name|ConstantUnion
modifier|*
name|unionArray
decl_stmt|;
if|if
condition|(
name|tempConstantNode
condition|)
block|{
name|unionArray
operator|=
name|tempConstantNode
operator|->
name|getUnionArrayPointer
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|unionArray
condition|)
block|{
return|return
name|node
return|;
block|}
block|}
else|else
block|{
comment|// The node has to be either a symbol node or an aggregate node or a tempConstant node, else, its an error
name|error
argument_list|(
name|line
argument_list|,
literal|"Cannot offset into the vector"
argument_list|,
literal|"Error"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ConstantUnion
modifier|*
name|constArray
init|=
operator|new
name|ConstantUnion
index|[
name|fields
operator|.
name|num
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|>=
name|node
operator|->
name|getType
argument_list|()
operator|.
name|getNominalSize
argument_list|()
condition|)
block|{
name|std
operator|::
name|stringstream
name|extraInfoStream
decl_stmt|;
name|extraInfoStream
operator|<<
literal|"vector field selection out of range '"
operator|<<
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|<<
literal|"'"
expr_stmt|;
name|std
operator|::
name|string
name|extraInfo
init|=
name|extraInfoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|error
argument_list|(
name|line
argument_list|,
literal|""
argument_list|,
literal|"["
argument_list|,
name|extraInfo
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
name|fields
operator|.
name|offsets
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|constArray
index|[
name|i
index|]
operator|=
name|unionArray
index|[
name|fields
operator|.
name|offsets
index|[
name|i
index|]
index|]
expr_stmt|;
block|}
name|typedNode
operator|=
name|intermediate
operator|.
name|addConstantUnion
argument_list|(
name|constArray
argument_list|,
name|node
operator|->
name|getType
argument_list|()
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
name|typedNode
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// This function returns the column being accessed from a constant matrix. The values are retrieved from
end_comment
begin_comment
comment|// the symbol table and parse-tree is built for a vector (each column of a matrix is a vector). The input
end_comment
begin_comment
comment|// to the function could either be a symbol node (m[0] where m is a constant matrix)that represents a
end_comment
begin_comment
comment|// constant matrix or it could be the tree representation of the constant matrix (s.m1[0] where s is a constant structure)
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addConstMatrixNode
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|addConstMatrixNode
parameter_list|(
name|int
name|index
parameter_list|,
name|TIntermTyped
modifier|*
name|node
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
name|TIntermTyped
modifier|*
name|typedNode
decl_stmt|;
name|TIntermConstantUnion
modifier|*
name|tempConstantNode
init|=
name|node
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
if|if
condition|(
name|index
operator|>=
name|node
operator|->
name|getType
argument_list|()
operator|.
name|getCols
argument_list|()
condition|)
block|{
name|std
operator|::
name|stringstream
name|extraInfoStream
decl_stmt|;
name|extraInfoStream
operator|<<
literal|"matrix field selection out of range '"
operator|<<
name|index
operator|<<
literal|"'"
expr_stmt|;
name|std
operator|::
name|string
name|extraInfo
init|=
name|extraInfoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|error
argument_list|(
name|line
argument_list|,
literal|""
argument_list|,
literal|"["
argument_list|,
name|extraInfo
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tempConstantNode
condition|)
block|{
name|ConstantUnion
modifier|*
name|unionArray
init|=
name|tempConstantNode
operator|->
name|getUnionArrayPointer
argument_list|()
decl_stmt|;
name|int
name|size
init|=
name|tempConstantNode
operator|->
name|getType
argument_list|()
operator|.
name|getCols
argument_list|()
decl_stmt|;
name|typedNode
operator|=
name|intermediate
operator|.
name|addConstantUnion
argument_list|(
operator|&
name|unionArray
index|[
name|size
operator|*
name|index
index|]
argument_list|,
name|tempConstantNode
operator|->
name|getType
argument_list|()
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"Cannot offset into the matrix"
argument_list|,
literal|"Error"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|typedNode
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// This function returns an element of an array accessed from a constant array. The values are retrieved from
end_comment
begin_comment
comment|// the symbol table and parse-tree is built for the type of the element. The input
end_comment
begin_comment
comment|// to the function could either be a symbol node (a[0] where a is a constant array)that represents a
end_comment
begin_comment
comment|// constant array or it could be the tree representation of the constant array (s.a1[0] where s is a constant structure)
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addConstArrayNode
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|addConstArrayNode
parameter_list|(
name|int
name|index
parameter_list|,
name|TIntermTyped
modifier|*
name|node
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
name|TIntermTyped
modifier|*
name|typedNode
decl_stmt|;
name|TIntermConstantUnion
modifier|*
name|tempConstantNode
init|=
name|node
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
name|TType
name|arrayElementType
init|=
name|node
operator|->
name|getType
argument_list|()
decl_stmt|;
name|arrayElementType
operator|.
name|clearArrayness
argument_list|()
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|node
operator|->
name|getType
argument_list|()
operator|.
name|getArraySize
argument_list|()
condition|)
block|{
name|std
operator|::
name|stringstream
name|extraInfoStream
decl_stmt|;
name|extraInfoStream
operator|<<
literal|"array field selection out of range '"
operator|<<
name|index
operator|<<
literal|"'"
expr_stmt|;
name|std
operator|::
name|string
name|extraInfo
init|=
name|extraInfoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|error
argument_list|(
name|line
argument_list|,
literal|""
argument_list|,
literal|"["
argument_list|,
name|extraInfo
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tempConstantNode
condition|)
block|{
name|size_t
name|arrayElementSize
init|=
name|arrayElementType
operator|.
name|getObjectSize
argument_list|()
decl_stmt|;
name|ConstantUnion
modifier|*
name|unionArray
init|=
name|tempConstantNode
operator|->
name|getUnionArrayPointer
argument_list|()
decl_stmt|;
name|typedNode
operator|=
name|intermediate
operator|.
name|addConstantUnion
argument_list|(
operator|&
name|unionArray
index|[
name|arrayElementSize
operator|*
name|index
index|]
argument_list|,
name|tempConstantNode
operator|->
name|getType
argument_list|()
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"Cannot offset into the array"
argument_list|,
literal|"Error"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|typedNode
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// This function returns the value of a particular field inside a constant structure from the symbol table.
end_comment
begin_comment
comment|// If there is an embedded/nested struct, it appropriately calls addConstStructNested or addConstStructFromAggr
end_comment
begin_comment
comment|// function and returns the parse-tree with the values of the embedded/nested struct.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addConstStruct
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|addConstStruct
parameter_list|(
specifier|const
name|TString
modifier|&
name|identifier
parameter_list|,
name|TIntermTyped
modifier|*
name|node
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|)
block|{
specifier|const
name|TFieldList
modifier|&
name|fields
init|=
name|node
operator|->
name|getType
argument_list|()
operator|.
name|getStruct
argument_list|()
operator|->
name|fields
argument_list|()
decl_stmt|;
name|size_t
name|instanceSize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|size_t
name|index
init|=
literal|0
init|;
name|index
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
operator|++
name|index
control|)
block|{
if|if
condition|(
name|fields
index|[
name|index
index|]
operator|->
name|name
argument_list|()
operator|==
name|identifier
condition|)
block|{
break|break;
block|}
else|else
block|{
name|instanceSize
operator|+=
name|fields
index|[
name|index
index|]
operator|->
name|type
argument_list|()
operator|->
name|getObjectSize
argument_list|()
expr_stmt|;
block|}
block|}
name|TIntermTyped
modifier|*
name|typedNode
decl_stmt|;
name|TIntermConstantUnion
modifier|*
name|tempConstantNode
init|=
name|node
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
if|if
condition|(
name|tempConstantNode
condition|)
block|{
name|ConstantUnion
modifier|*
name|constArray
init|=
name|tempConstantNode
operator|->
name|getUnionArrayPointer
argument_list|()
decl_stmt|;
name|typedNode
operator|=
name|intermediate
operator|.
name|addConstantUnion
argument_list|(
name|constArray
operator|+
name|instanceSize
argument_list|,
name|tempConstantNode
operator|->
name|getType
argument_list|()
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|// type will be changed in the calling function
block|}
else|else
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|"Cannot offset into the structure"
argument_list|,
literal|"Error"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|typedNode
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Interface/uniform blocks
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addInterfaceBlock
name|TIntermAggregate
modifier|*
name|TParseContext
operator|::
name|addInterfaceBlock
parameter_list|(
specifier|const
name|TPublicType
modifier|&
name|typeQualifier
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|nameLine
parameter_list|,
specifier|const
name|TString
modifier|&
name|blockName
parameter_list|,
name|TFieldList
modifier|*
name|fieldList
parameter_list|,
specifier|const
name|TString
modifier|*
name|instanceName
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|instanceLine
parameter_list|,
name|TIntermTyped
modifier|*
name|arrayIndex
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|arrayIndexLine
parameter_list|)
block|{
if|if
condition|(
name|reservedErrorCheck
argument_list|(
name|nameLine
argument_list|,
name|blockName
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
if|if
condition|(
name|typeQualifier
operator|.
name|qualifier
operator|!=
name|EvqUniform
condition|)
block|{
name|error
argument_list|(
name|typeQualifier
operator|.
name|line
argument_list|,
literal|"invalid qualifier:"
argument_list|,
name|getQualifierString
argument_list|(
name|typeQualifier
operator|.
name|qualifier
argument_list|)
argument_list|,
literal|"interface blocks must be uniform"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
name|TLayoutQualifier
name|blockLayoutQualifier
init|=
name|typeQualifier
operator|.
name|layoutQualifier
decl_stmt|;
if|if
condition|(
name|layoutLocationErrorCheck
argument_list|(
name|typeQualifier
operator|.
name|line
argument_list|,
name|blockLayoutQualifier
argument_list|)
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|blockLayoutQualifier
operator|.
name|matrixPacking
operator|==
name|EmpUnspecified
condition|)
block|{
name|blockLayoutQualifier
operator|.
name|matrixPacking
operator|=
name|defaultMatrixPacking
expr_stmt|;
block|}
if|if
condition|(
name|blockLayoutQualifier
operator|.
name|blockStorage
operator|==
name|EbsUnspecified
condition|)
block|{
name|blockLayoutQualifier
operator|.
name|blockStorage
operator|=
name|defaultBlockStorage
expr_stmt|;
block|}
name|TSymbol
modifier|*
name|blockNameSymbol
init|=
operator|new
name|TInterfaceBlockName
argument_list|(
operator|&
name|blockName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|symbolTable
operator|.
name|declare
argument_list|(
name|blockNameSymbol
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|nameLine
argument_list|,
literal|"redefinition"
argument_list|,
name|blockName
operator|.
name|c_str
argument_list|()
argument_list|,
literal|"interface block name"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
comment|// check for sampler types and apply layout qualifiers
for|for
control|(
name|size_t
name|memberIndex
init|=
literal|0
init|;
name|memberIndex
operator|<
name|fieldList
operator|->
name|size
argument_list|()
condition|;
operator|++
name|memberIndex
control|)
block|{
name|TField
modifier|*
name|field
init|=
operator|(
operator|*
name|fieldList
operator|)
index|[
name|memberIndex
index|]
decl_stmt|;
name|TType
modifier|*
name|fieldType
init|=
name|field
operator|->
name|type
argument_list|()
decl_stmt|;
if|if
condition|(
name|IsSampler
argument_list|(
name|fieldType
operator|->
name|getBasicType
argument_list|()
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|field
operator|->
name|line
argument_list|()
argument_list|,
literal|"unsupported type"
argument_list|,
name|fieldType
operator|->
name|getBasicString
argument_list|()
argument_list|,
literal|"sampler types are not allowed in interface blocks"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
specifier|const
name|TQualifier
name|qualifier
init|=
name|fieldType
operator|->
name|getQualifier
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|qualifier
condition|)
block|{
case|case
name|EvqGlobal
case|:
case|case
name|EvqUniform
case|:
break|break;
default|default:
name|error
argument_list|(
name|field
operator|->
name|line
argument_list|()
argument_list|,
literal|"invalid qualifier on interface block member"
argument_list|,
name|getQualifierString
argument_list|(
name|qualifier
argument_list|)
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
break|break;
block|}
comment|// check layout qualifiers
name|TLayoutQualifier
name|fieldLayoutQualifier
init|=
name|fieldType
operator|->
name|getLayoutQualifier
argument_list|()
decl_stmt|;
if|if
condition|(
name|layoutLocationErrorCheck
argument_list|(
name|field
operator|->
name|line
argument_list|()
argument_list|,
name|fieldLayoutQualifier
argument_list|)
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fieldLayoutQualifier
operator|.
name|blockStorage
operator|!=
name|EbsUnspecified
condition|)
block|{
name|error
argument_list|(
name|field
operator|->
name|line
argument_list|()
argument_list|,
literal|"invalid layout qualifier:"
argument_list|,
name|getBlockStorageString
argument_list|(
name|fieldLayoutQualifier
operator|.
name|blockStorage
argument_list|)
argument_list|,
literal|"cannot be used here"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fieldLayoutQualifier
operator|.
name|matrixPacking
operator|==
name|EmpUnspecified
condition|)
block|{
name|fieldLayoutQualifier
operator|.
name|matrixPacking
operator|=
name|blockLayoutQualifier
operator|.
name|matrixPacking
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|fieldType
operator|->
name|isMatrix
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|field
operator|->
name|line
argument_list|()
argument_list|,
literal|"invalid layout qualifier:"
argument_list|,
name|getMatrixPackingString
argument_list|(
name|fieldLayoutQualifier
operator|.
name|matrixPacking
argument_list|)
argument_list|,
literal|"can only be used on matrix types"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
name|fieldType
operator|->
name|setLayoutQualifier
argument_list|(
name|fieldLayoutQualifier
argument_list|)
expr_stmt|;
block|}
comment|// add array index
name|int
name|arraySize
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|arrayIndex
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|arraySizeErrorCheck
argument_list|(
name|arrayIndexLine
argument_list|,
name|arrayIndex
argument_list|,
name|arraySize
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
block|}
name|TInterfaceBlock
modifier|*
name|interfaceBlock
init|=
operator|new
name|TInterfaceBlock
argument_list|(
operator|&
name|blockName
argument_list|,
name|fieldList
argument_list|,
name|instanceName
argument_list|,
name|arraySize
argument_list|,
name|blockLayoutQualifier
argument_list|)
decl_stmt|;
name|TType
name|interfaceBlockType
argument_list|(
name|interfaceBlock
argument_list|,
name|typeQualifier
operator|.
name|qualifier
argument_list|,
name|blockLayoutQualifier
argument_list|,
name|arraySize
argument_list|)
decl_stmt|;
name|TString
name|symbolName
init|=
literal|""
decl_stmt|;
name|int
name|symbolId
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|instanceName
condition|)
block|{
comment|// define symbols for the members of the interface block
for|for
control|(
name|size_t
name|memberIndex
init|=
literal|0
init|;
name|memberIndex
operator|<
name|fieldList
operator|->
name|size
argument_list|()
condition|;
operator|++
name|memberIndex
control|)
block|{
name|TField
modifier|*
name|field
init|=
operator|(
operator|*
name|fieldList
operator|)
index|[
name|memberIndex
index|]
decl_stmt|;
name|TType
modifier|*
name|fieldType
init|=
name|field
operator|->
name|type
argument_list|()
decl_stmt|;
comment|// set parent pointer of the field variable
name|fieldType
operator|->
name|setInterfaceBlock
argument_list|(
name|interfaceBlock
argument_list|)
expr_stmt|;
name|TVariable
modifier|*
name|fieldVariable
init|=
operator|new
name|TVariable
argument_list|(
operator|&
name|field
operator|->
name|name
argument_list|()
argument_list|,
operator|*
name|fieldType
argument_list|)
decl_stmt|;
name|fieldVariable
operator|->
name|setQualifier
argument_list|(
name|typeQualifier
operator|.
name|qualifier
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|symbolTable
operator|.
name|declare
argument_list|(
name|fieldVariable
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|field
operator|->
name|line
argument_list|()
argument_list|,
literal|"redefinition"
argument_list|,
name|field
operator|->
name|name
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|,
literal|"interface block member name"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// add a symbol for this interface block
name|TVariable
modifier|*
name|instanceTypeDef
init|=
operator|new
name|TVariable
argument_list|(
name|instanceName
argument_list|,
name|interfaceBlockType
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|instanceTypeDef
operator|->
name|setQualifier
argument_list|(
name|typeQualifier
operator|.
name|qualifier
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|symbolTable
operator|.
name|declare
argument_list|(
name|instanceTypeDef
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|instanceLine
argument_list|,
literal|"redefinition"
argument_list|,
name|instanceName
operator|->
name|c_str
argument_list|()
argument_list|,
literal|"interface block instance name"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
name|symbolId
operator|=
name|instanceTypeDef
operator|->
name|getUniqueId
argument_list|()
expr_stmt|;
name|symbolName
operator|=
name|instanceTypeDef
operator|->
name|getName
argument_list|()
expr_stmt|;
block|}
name|TIntermAggregate
modifier|*
name|aggregate
init|=
name|intermediate
operator|.
name|makeAggregate
argument_list|(
name|intermediate
operator|.
name|addSymbol
argument_list|(
name|symbolId
argument_list|,
name|symbolName
argument_list|,
name|interfaceBlockType
argument_list|,
name|typeQualifier
operator|.
name|line
argument_list|)
argument_list|,
name|nameLine
argument_list|)
decl_stmt|;
name|aggregate
operator|->
name|setOp
argument_list|(
name|EOpDeclaration
argument_list|)
expr_stmt|;
name|exitStructDeclaration
argument_list|()
expr_stmt|;
return|return
name|aggregate
return|;
block|}
end_function
begin_function
DECL|function|enterStructDeclaration
name|bool
name|TParseContext
operator|::
name|enterStructDeclaration
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
specifier|const
name|TString
modifier|&
name|identifier
parameter_list|)
block|{
operator|++
name|structNestingLevel
expr_stmt|;
comment|// Embedded structure definitions are not supported per GLSL ES spec.
comment|// They aren't allowed in GLSL either, but we need to detect this here
comment|// so we don't rely on the GLSL compiler to catch it.
if|if
condition|(
name|structNestingLevel
operator|>
literal|1
condition|)
block|{
name|error
argument_list|(
name|line
argument_list|,
literal|""
argument_list|,
literal|"Embedded struct definitions are not allowed"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|exitStructDeclaration
name|void
name|TParseContext
operator|::
name|exitStructDeclaration
parameter_list|()
block|{
operator|--
name|structNestingLevel
expr_stmt|;
block|}
end_function
begin_namespace
namespace|namespace
block|{
DECL|member|kWebGLMaxStructNesting
specifier|const
name|int
name|kWebGLMaxStructNesting
init|=
literal|4
decl_stmt|;
block|}
end_namespace
begin_comment
comment|// namespace
end_comment
begin_function
DECL|function|structNestingErrorCheck
name|bool
name|TParseContext
operator|::
name|structNestingErrorCheck
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
specifier|const
name|TField
modifier|&
name|field
parameter_list|)
block|{
if|if
condition|(
operator|!
name|IsWebGLBasedSpec
argument_list|(
name|shaderSpec
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|field
operator|.
name|type
argument_list|()
operator|->
name|getBasicType
argument_list|()
operator|!=
name|EbtStruct
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// We're already inside a structure definition at this point, so add
comment|// one to the field's struct nesting.
if|if
condition|(
literal|1
operator|+
name|field
operator|.
name|type
argument_list|()
operator|->
name|getDeepestStructNesting
argument_list|()
operator|>
name|kWebGLMaxStructNesting
condition|)
block|{
name|std
operator|::
name|stringstream
name|reasonStream
decl_stmt|;
name|reasonStream
operator|<<
literal|"Reference of struct type "
operator|<<
name|field
operator|.
name|type
argument_list|()
operator|->
name|getStruct
argument_list|()
operator|->
name|name
argument_list|()
operator|.
name|c_str
argument_list|()
operator|<<
literal|" exceeds maximum allowed nesting level of "
operator|<<
name|kWebGLMaxStructNesting
expr_stmt|;
name|std
operator|::
name|string
name|reason
init|=
name|reasonStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|error
argument_list|(
name|line
argument_list|,
name|reason
operator|.
name|c_str
argument_list|()
argument_list|,
name|field
operator|.
name|name
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Parse an array index expression
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|addIndexExpression
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|addIndexExpression
parameter_list|(
name|TIntermTyped
modifier|*
name|baseExpression
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|location
parameter_list|,
name|TIntermTyped
modifier|*
name|indexExpression
parameter_list|)
block|{
name|TIntermTyped
modifier|*
name|indexedExpression
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|baseExpression
operator|->
name|isArray
argument_list|()
operator|&&
operator|!
name|baseExpression
operator|->
name|isMatrix
argument_list|()
operator|&&
operator|!
name|baseExpression
operator|->
name|isVector
argument_list|()
condition|)
block|{
if|if
condition|(
name|baseExpression
operator|->
name|getAsSymbolNode
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|location
argument_list|,
literal|" left of '[' is not of type array, matrix, or vector "
argument_list|,
name|baseExpression
operator|->
name|getAsSymbolNode
argument_list|()
operator|->
name|getSymbol
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
name|location
argument_list|,
literal|" left of '[' is not of type array, matrix, or vector "
argument_list|,
literal|"expression"
argument_list|)
expr_stmt|;
block|}
name|recover
argument_list|()
expr_stmt|;
block|}
name|TIntermConstantUnion
modifier|*
name|indexConstantUnion
init|=
name|indexExpression
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
if|if
condition|(
name|indexExpression
operator|->
name|getQualifier
argument_list|()
operator|==
name|EvqConst
operator|&&
name|indexConstantUnion
condition|)
block|{
name|int
name|index
init|=
name|indexConstantUnion
operator|->
name|getIConst
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
name|std
operator|::
name|stringstream
name|infoStream
decl_stmt|;
name|infoStream
operator|<<
name|index
expr_stmt|;
name|std
operator|::
name|string
name|info
init|=
name|infoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|error
argument_list|(
name|location
argument_list|,
literal|"negative index"
argument_list|,
name|info
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|baseExpression
operator|->
name|getType
argument_list|()
operator|.
name|getQualifier
argument_list|()
operator|==
name|EvqConst
condition|)
block|{
if|if
condition|(
name|baseExpression
operator|->
name|isArray
argument_list|()
condition|)
block|{
comment|// constant folding for arrays
name|indexedExpression
operator|=
name|addConstArrayNode
argument_list|(
name|index
argument_list|,
name|baseExpression
argument_list|,
name|location
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|baseExpression
operator|->
name|isVector
argument_list|()
condition|)
block|{
comment|// constant folding for vectors
name|TVectorFields
name|fields
decl_stmt|;
name|fields
operator|.
name|num
operator|=
literal|1
expr_stmt|;
name|fields
operator|.
name|offsets
index|[
literal|0
index|]
operator|=
name|index
expr_stmt|;
comment|// need to do it this way because v.xy sends fields integer array
name|indexedExpression
operator|=
name|addConstVectorNode
argument_list|(
name|fields
argument_list|,
name|baseExpression
argument_list|,
name|location
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|baseExpression
operator|->
name|isMatrix
argument_list|()
condition|)
block|{
comment|// constant folding for matrices
name|indexedExpression
operator|=
name|addConstMatrixNode
argument_list|(
name|index
argument_list|,
name|baseExpression
argument_list|,
name|location
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|baseExpression
operator|->
name|isArray
argument_list|()
condition|)
block|{
if|if
condition|(
name|index
operator|>=
name|baseExpression
operator|->
name|getType
argument_list|()
operator|.
name|getArraySize
argument_list|()
condition|)
block|{
name|std
operator|::
name|stringstream
name|extraInfoStream
decl_stmt|;
name|extraInfoStream
operator|<<
literal|"array index out of range '"
operator|<<
name|index
operator|<<
literal|"'"
expr_stmt|;
name|std
operator|::
name|string
name|extraInfo
init|=
name|extraInfoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|error
argument_list|(
name|location
argument_list|,
literal|""
argument_list|,
literal|"["
argument_list|,
name|extraInfo
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
name|index
operator|=
name|baseExpression
operator|->
name|getType
argument_list|()
operator|.
name|getArraySize
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|baseExpression
operator|->
name|getQualifier
argument_list|()
operator|==
name|EvqFragData
operator|&&
name|index
operator|>
literal|0
operator|&&
operator|!
name|isExtensionEnabled
argument_list|(
literal|"GL_EXT_draw_buffers"
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|location
argument_list|,
literal|""
argument_list|,
literal|"["
argument_list|,
literal|"array indexes for gl_FragData must be zero when GL_EXT_draw_buffers is disabled"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|baseExpression
operator|->
name|isVector
argument_list|()
operator|||
name|baseExpression
operator|->
name|isMatrix
argument_list|()
operator|)
operator|&&
name|baseExpression
operator|->
name|getType
argument_list|()
operator|.
name|getNominalSize
argument_list|()
operator|<=
name|index
condition|)
block|{
name|std
operator|::
name|stringstream
name|extraInfoStream
decl_stmt|;
name|extraInfoStream
operator|<<
literal|"field selection out of range '"
operator|<<
name|index
operator|<<
literal|"'"
expr_stmt|;
name|std
operator|::
name|string
name|extraInfo
init|=
name|extraInfoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|error
argument_list|(
name|location
argument_list|,
literal|""
argument_list|,
literal|"["
argument_list|,
name|extraInfo
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
name|index
operator|=
name|baseExpression
operator|->
name|getType
argument_list|()
operator|.
name|getNominalSize
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
name|indexConstantUnion
operator|->
name|getUnionArrayPointer
argument_list|()
operator|->
name|setIConst
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|indexedExpression
operator|=
name|intermediate
operator|.
name|addIndex
argument_list|(
name|EOpIndexDirect
argument_list|,
name|baseExpression
argument_list|,
name|indexExpression
argument_list|,
name|location
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|baseExpression
operator|->
name|isInterfaceBlock
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|location
argument_list|,
literal|""
argument_list|,
literal|"["
argument_list|,
literal|"array indexes for interface blocks arrays must be constant integral expressions"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|baseExpression
operator|->
name|getQualifier
argument_list|()
operator|==
name|EvqFragmentOut
condition|)
block|{
name|error
argument_list|(
name|location
argument_list|,
literal|""
argument_list|,
literal|"["
argument_list|,
literal|"array indexes for fragment outputs must be constant integral expressions"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
name|indexedExpression
operator|=
name|intermediate
operator|.
name|addIndex
argument_list|(
name|EOpIndexIndirect
argument_list|,
name|baseExpression
argument_list|,
name|indexExpression
argument_list|,
name|location
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|indexedExpression
operator|==
literal|0
condition|)
block|{
name|ConstantUnion
modifier|*
name|unionArray
init|=
operator|new
name|ConstantUnion
index|[
literal|1
index|]
decl_stmt|;
name|unionArray
operator|->
name|setFConst
argument_list|(
literal|0.0f
argument_list|)
expr_stmt|;
name|indexedExpression
operator|=
name|intermediate
operator|.
name|addConstantUnion
argument_list|(
name|unionArray
argument_list|,
name|TType
argument_list|(
name|EbtFloat
argument_list|,
name|EbpHigh
argument_list|,
name|EvqConst
argument_list|)
argument_list|,
name|location
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|baseExpression
operator|->
name|isArray
argument_list|()
condition|)
block|{
specifier|const
name|TType
modifier|&
name|baseType
init|=
name|baseExpression
operator|->
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|baseType
operator|.
name|getStruct
argument_list|()
condition|)
block|{
name|TType
name|copyOfType
argument_list|(
name|baseType
operator|.
name|getStruct
argument_list|()
argument_list|)
decl_stmt|;
name|indexedExpression
operator|->
name|setType
argument_list|(
name|copyOfType
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|baseType
operator|.
name|isInterfaceBlock
argument_list|()
condition|)
block|{
name|TType
name|copyOfType
argument_list|(
name|baseType
operator|.
name|getInterfaceBlock
argument_list|()
argument_list|,
name|baseType
operator|.
name|getQualifier
argument_list|()
argument_list|,
name|baseType
operator|.
name|getLayoutQualifier
argument_list|()
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|indexedExpression
operator|->
name|setType
argument_list|(
name|copyOfType
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indexedExpression
operator|->
name|setType
argument_list|(
name|TType
argument_list|(
name|baseExpression
operator|->
name|getBasicType
argument_list|()
argument_list|,
name|baseExpression
operator|->
name|getPrecision
argument_list|()
argument_list|,
name|EvqTemporary
argument_list|,
name|baseExpression
operator|->
name|getNominalSize
argument_list|()
argument_list|,
name|baseExpression
operator|->
name|getSecondarySize
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|baseExpression
operator|->
name|getType
argument_list|()
operator|.
name|getQualifier
argument_list|()
operator|==
name|EvqConst
condition|)
block|{
name|indexedExpression
operator|->
name|getTypePointer
argument_list|()
operator|->
name|setQualifier
argument_list|(
name|EvqConst
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|baseExpression
operator|->
name|isMatrix
argument_list|()
condition|)
block|{
name|TQualifier
name|qualifier
init|=
name|baseExpression
operator|->
name|getType
argument_list|()
operator|.
name|getQualifier
argument_list|()
operator|==
name|EvqConst
condition|?
name|EvqConst
else|:
name|EvqTemporary
decl_stmt|;
name|indexedExpression
operator|->
name|setType
argument_list|(
name|TType
argument_list|(
name|baseExpression
operator|->
name|getBasicType
argument_list|()
argument_list|,
name|baseExpression
operator|->
name|getPrecision
argument_list|()
argument_list|,
name|qualifier
argument_list|,
name|baseExpression
operator|->
name|getRows
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|baseExpression
operator|->
name|isVector
argument_list|()
condition|)
block|{
name|TQualifier
name|qualifier
init|=
name|baseExpression
operator|->
name|getType
argument_list|()
operator|.
name|getQualifier
argument_list|()
operator|==
name|EvqConst
condition|?
name|EvqConst
else|:
name|EvqTemporary
decl_stmt|;
name|indexedExpression
operator|->
name|setType
argument_list|(
name|TType
argument_list|(
name|baseExpression
operator|->
name|getBasicType
argument_list|()
argument_list|,
name|baseExpression
operator|->
name|getPrecision
argument_list|()
argument_list|,
name|qualifier
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indexedExpression
operator|->
name|setType
argument_list|(
name|baseExpression
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|indexedExpression
return|;
block|}
end_function
begin_function
DECL|function|addFieldSelectionExpression
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|addFieldSelectionExpression
parameter_list|(
name|TIntermTyped
modifier|*
name|baseExpression
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|dotLocation
parameter_list|,
specifier|const
name|TString
modifier|&
name|fieldString
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|fieldLocation
parameter_list|)
block|{
name|TIntermTyped
modifier|*
name|indexedExpression
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|baseExpression
operator|->
name|isArray
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|fieldLocation
argument_list|,
literal|"cannot apply dot operator to an array"
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|baseExpression
operator|->
name|isVector
argument_list|()
condition|)
block|{
name|TVectorFields
name|fields
decl_stmt|;
if|if
condition|(
operator|!
name|parseVectorFields
argument_list|(
name|fieldString
argument_list|,
name|baseExpression
operator|->
name|getNominalSize
argument_list|()
argument_list|,
name|fields
argument_list|,
name|fieldLocation
argument_list|)
condition|)
block|{
name|fields
operator|.
name|num
operator|=
literal|1
expr_stmt|;
name|fields
operator|.
name|offsets
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|baseExpression
operator|->
name|getType
argument_list|()
operator|.
name|getQualifier
argument_list|()
operator|==
name|EvqConst
condition|)
block|{
comment|// constant folding for vector fields
name|indexedExpression
operator|=
name|addConstVectorNode
argument_list|(
name|fields
argument_list|,
name|baseExpression
argument_list|,
name|fieldLocation
argument_list|)
expr_stmt|;
if|if
condition|(
name|indexedExpression
operator|==
literal|0
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
name|indexedExpression
operator|=
name|baseExpression
expr_stmt|;
block|}
else|else
block|{
name|indexedExpression
operator|->
name|setType
argument_list|(
name|TType
argument_list|(
name|baseExpression
operator|->
name|getBasicType
argument_list|()
argument_list|,
name|baseExpression
operator|->
name|getPrecision
argument_list|()
argument_list|,
name|EvqConst
argument_list|,
call|(
name|int
call|)
argument_list|(
name|fieldString
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|TString
name|vectorString
init|=
name|fieldString
decl_stmt|;
name|TIntermTyped
modifier|*
name|index
init|=
name|intermediate
operator|.
name|addSwizzle
argument_list|(
name|fields
argument_list|,
name|fieldLocation
argument_list|)
decl_stmt|;
name|indexedExpression
operator|=
name|intermediate
operator|.
name|addIndex
argument_list|(
name|EOpVectorSwizzle
argument_list|,
name|baseExpression
argument_list|,
name|index
argument_list|,
name|dotLocation
argument_list|)
expr_stmt|;
name|indexedExpression
operator|->
name|setType
argument_list|(
name|TType
argument_list|(
name|baseExpression
operator|->
name|getBasicType
argument_list|()
argument_list|,
name|baseExpression
operator|->
name|getPrecision
argument_list|()
argument_list|,
name|EvqTemporary
argument_list|,
operator|(
name|int
operator|)
name|vectorString
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|baseExpression
operator|->
name|isMatrix
argument_list|()
condition|)
block|{
name|TMatrixFields
name|fields
decl_stmt|;
if|if
condition|(
operator|!
name|parseMatrixFields
argument_list|(
name|fieldString
argument_list|,
name|baseExpression
operator|->
name|getCols
argument_list|()
argument_list|,
name|baseExpression
operator|->
name|getRows
argument_list|()
argument_list|,
name|fields
argument_list|,
name|fieldLocation
argument_list|)
condition|)
block|{
name|fields
operator|.
name|wholeRow
operator|=
literal|false
expr_stmt|;
name|fields
operator|.
name|wholeCol
operator|=
literal|false
expr_stmt|;
name|fields
operator|.
name|row
operator|=
literal|0
expr_stmt|;
name|fields
operator|.
name|col
operator|=
literal|0
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fields
operator|.
name|wholeRow
operator|||
name|fields
operator|.
name|wholeCol
condition|)
block|{
name|error
argument_list|(
name|dotLocation
argument_list|,
literal|" non-scalar fields not implemented yet"
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
name|ConstantUnion
modifier|*
name|unionArray
init|=
operator|new
name|ConstantUnion
index|[
literal|1
index|]
decl_stmt|;
name|unionArray
operator|->
name|setIConst
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|TIntermTyped
modifier|*
name|index
init|=
name|intermediate
operator|.
name|addConstantUnion
argument_list|(
name|unionArray
argument_list|,
name|TType
argument_list|(
name|EbtInt
argument_list|,
name|EbpUndefined
argument_list|,
name|EvqConst
argument_list|)
argument_list|,
name|fieldLocation
argument_list|)
decl_stmt|;
name|indexedExpression
operator|=
name|intermediate
operator|.
name|addIndex
argument_list|(
name|EOpIndexDirect
argument_list|,
name|baseExpression
argument_list|,
name|index
argument_list|,
name|dotLocation
argument_list|)
expr_stmt|;
name|indexedExpression
operator|->
name|setType
argument_list|(
name|TType
argument_list|(
name|baseExpression
operator|->
name|getBasicType
argument_list|()
argument_list|,
name|baseExpression
operator|->
name|getPrecision
argument_list|()
argument_list|,
name|EvqTemporary
argument_list|,
name|baseExpression
operator|->
name|getCols
argument_list|()
argument_list|,
name|baseExpression
operator|->
name|getRows
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ConstantUnion
modifier|*
name|unionArray
init|=
operator|new
name|ConstantUnion
index|[
literal|1
index|]
decl_stmt|;
name|unionArray
operator|->
name|setIConst
argument_list|(
name|fields
operator|.
name|col
operator|*
name|baseExpression
operator|->
name|getRows
argument_list|()
operator|+
name|fields
operator|.
name|row
argument_list|)
expr_stmt|;
name|TIntermTyped
modifier|*
name|index
init|=
name|intermediate
operator|.
name|addConstantUnion
argument_list|(
name|unionArray
argument_list|,
name|TType
argument_list|(
name|EbtInt
argument_list|,
name|EbpUndefined
argument_list|,
name|EvqConst
argument_list|)
argument_list|,
name|fieldLocation
argument_list|)
decl_stmt|;
name|indexedExpression
operator|=
name|intermediate
operator|.
name|addIndex
argument_list|(
name|EOpIndexDirect
argument_list|,
name|baseExpression
argument_list|,
name|index
argument_list|,
name|dotLocation
argument_list|)
expr_stmt|;
name|indexedExpression
operator|->
name|setType
argument_list|(
name|TType
argument_list|(
name|baseExpression
operator|->
name|getBasicType
argument_list|()
argument_list|,
name|baseExpression
operator|->
name|getPrecision
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|baseExpression
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtStruct
condition|)
block|{
name|bool
name|fieldFound
init|=
literal|false
decl_stmt|;
specifier|const
name|TFieldList
modifier|&
name|fields
init|=
name|baseExpression
operator|->
name|getType
argument_list|()
operator|.
name|getStruct
argument_list|()
operator|->
name|fields
argument_list|()
decl_stmt|;
if|if
condition|(
name|fields
operator|.
name|empty
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|dotLocation
argument_list|,
literal|"structure has no fields"
argument_list|,
literal|"Internal Error"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
name|indexedExpression
operator|=
name|baseExpression
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|fields
index|[
name|i
index|]
operator|->
name|name
argument_list|()
operator|==
name|fieldString
condition|)
block|{
name|fieldFound
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|fieldFound
condition|)
block|{
if|if
condition|(
name|baseExpression
operator|->
name|getType
argument_list|()
operator|.
name|getQualifier
argument_list|()
operator|==
name|EvqConst
condition|)
block|{
name|indexedExpression
operator|=
name|addConstStruct
argument_list|(
name|fieldString
argument_list|,
name|baseExpression
argument_list|,
name|dotLocation
argument_list|)
expr_stmt|;
if|if
condition|(
name|indexedExpression
operator|==
literal|0
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
name|indexedExpression
operator|=
name|baseExpression
expr_stmt|;
block|}
else|else
block|{
name|indexedExpression
operator|->
name|setType
argument_list|(
operator|*
name|fields
index|[
name|i
index|]
operator|->
name|type
argument_list|()
argument_list|)
expr_stmt|;
comment|// change the qualifier of the return type, not of the structure field
comment|// as the structure definition is shared between various structures.
name|indexedExpression
operator|->
name|getTypePointer
argument_list|()
operator|->
name|setQualifier
argument_list|(
name|EvqConst
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ConstantUnion
modifier|*
name|unionArray
init|=
operator|new
name|ConstantUnion
index|[
literal|1
index|]
decl_stmt|;
name|unionArray
operator|->
name|setIConst
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|TIntermTyped
modifier|*
name|index
init|=
name|intermediate
operator|.
name|addConstantUnion
argument_list|(
name|unionArray
argument_list|,
operator|*
name|fields
index|[
name|i
index|]
operator|->
name|type
argument_list|()
argument_list|,
name|fieldLocation
argument_list|)
decl_stmt|;
name|indexedExpression
operator|=
name|intermediate
operator|.
name|addIndex
argument_list|(
name|EOpIndexDirectStruct
argument_list|,
name|baseExpression
argument_list|,
name|index
argument_list|,
name|dotLocation
argument_list|)
expr_stmt|;
name|indexedExpression
operator|->
name|setType
argument_list|(
operator|*
name|fields
index|[
name|i
index|]
operator|->
name|type
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
argument_list|(
name|dotLocation
argument_list|,
literal|" no such field in structure"
argument_list|,
name|fieldString
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
name|indexedExpression
operator|=
name|baseExpression
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|baseExpression
operator|->
name|isInterfaceBlock
argument_list|()
condition|)
block|{
name|bool
name|fieldFound
init|=
literal|false
decl_stmt|;
specifier|const
name|TFieldList
modifier|&
name|fields
init|=
name|baseExpression
operator|->
name|getType
argument_list|()
operator|.
name|getInterfaceBlock
argument_list|()
operator|->
name|fields
argument_list|()
decl_stmt|;
if|if
condition|(
name|fields
operator|.
name|empty
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|dotLocation
argument_list|,
literal|"interface block has no fields"
argument_list|,
literal|"Internal Error"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
name|indexedExpression
operator|=
name|baseExpression
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|fields
index|[
name|i
index|]
operator|->
name|name
argument_list|()
operator|==
name|fieldString
condition|)
block|{
name|fieldFound
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|fieldFound
condition|)
block|{
name|ConstantUnion
modifier|*
name|unionArray
init|=
operator|new
name|ConstantUnion
index|[
literal|1
index|]
decl_stmt|;
name|unionArray
operator|->
name|setIConst
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|TIntermTyped
modifier|*
name|index
init|=
name|intermediate
operator|.
name|addConstantUnion
argument_list|(
name|unionArray
argument_list|,
operator|*
name|fields
index|[
name|i
index|]
operator|->
name|type
argument_list|()
argument_list|,
name|fieldLocation
argument_list|)
decl_stmt|;
name|indexedExpression
operator|=
name|intermediate
operator|.
name|addIndex
argument_list|(
name|EOpIndexDirectInterfaceBlock
argument_list|,
name|baseExpression
argument_list|,
name|index
argument_list|,
name|dotLocation
argument_list|)
expr_stmt|;
name|indexedExpression
operator|->
name|setType
argument_list|(
operator|*
name|fields
index|[
name|i
index|]
operator|->
name|type
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
name|dotLocation
argument_list|,
literal|" no such field in interface block"
argument_list|,
name|fieldString
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
name|indexedExpression
operator|=
name|baseExpression
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|shaderVersion
operator|<
literal|300
condition|)
block|{
name|error
argument_list|(
name|dotLocation
argument_list|,
literal|" field selection requires structure, vector, or matrix on left hand side"
argument_list|,
name|fieldString
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
name|dotLocation
argument_list|,
literal|" field selection requires structure, vector, matrix, or interface block on left hand side"
argument_list|,
name|fieldString
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|recover
argument_list|()
expr_stmt|;
name|indexedExpression
operator|=
name|baseExpression
expr_stmt|;
block|}
return|return
name|indexedExpression
return|;
block|}
end_function
begin_function
DECL|function|parseLayoutQualifier
name|TLayoutQualifier
name|TParseContext
operator|::
name|parseLayoutQualifier
parameter_list|(
specifier|const
name|TString
modifier|&
name|qualifierType
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|qualifierTypeLine
parameter_list|)
block|{
name|TLayoutQualifier
name|qualifier
decl_stmt|;
name|qualifier
operator|.
name|location
operator|=
operator|-
literal|1
expr_stmt|;
name|qualifier
operator|.
name|matrixPacking
operator|=
name|EmpUnspecified
expr_stmt|;
name|qualifier
operator|.
name|blockStorage
operator|=
name|EbsUnspecified
expr_stmt|;
if|if
condition|(
name|qualifierType
operator|==
literal|"shared"
condition|)
block|{
name|qualifier
operator|.
name|blockStorage
operator|=
name|EbsShared
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qualifierType
operator|==
literal|"packed"
condition|)
block|{
name|qualifier
operator|.
name|blockStorage
operator|=
name|EbsPacked
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qualifierType
operator|==
literal|"std140"
condition|)
block|{
name|qualifier
operator|.
name|blockStorage
operator|=
name|EbsStd140
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qualifierType
operator|==
literal|"row_major"
condition|)
block|{
name|qualifier
operator|.
name|matrixPacking
operator|=
name|EmpRowMajor
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qualifierType
operator|==
literal|"column_major"
condition|)
block|{
name|qualifier
operator|.
name|matrixPacking
operator|=
name|EmpColumnMajor
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qualifierType
operator|==
literal|"location"
condition|)
block|{
name|error
argument_list|(
name|qualifierTypeLine
argument_list|,
literal|"invalid layout qualifier"
argument_list|,
name|qualifierType
operator|.
name|c_str
argument_list|()
argument_list|,
literal|"location requires an argument"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
name|qualifierTypeLine
argument_list|,
literal|"invalid layout qualifier"
argument_list|,
name|qualifierType
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
return|return
name|qualifier
return|;
block|}
end_function
begin_function
DECL|function|parseLayoutQualifier
name|TLayoutQualifier
name|TParseContext
operator|::
name|parseLayoutQualifier
parameter_list|(
specifier|const
name|TString
modifier|&
name|qualifierType
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|qualifierTypeLine
parameter_list|,
specifier|const
name|TString
modifier|&
name|intValueString
parameter_list|,
name|int
name|intValue
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|intValueLine
parameter_list|)
block|{
name|TLayoutQualifier
name|qualifier
decl_stmt|;
name|qualifier
operator|.
name|location
operator|=
operator|-
literal|1
expr_stmt|;
name|qualifier
operator|.
name|matrixPacking
operator|=
name|EmpUnspecified
expr_stmt|;
name|qualifier
operator|.
name|blockStorage
operator|=
name|EbsUnspecified
expr_stmt|;
if|if
condition|(
name|qualifierType
operator|!=
literal|"location"
condition|)
block|{
name|error
argument_list|(
name|qualifierTypeLine
argument_list|,
literal|"invalid layout qualifier"
argument_list|,
name|qualifierType
operator|.
name|c_str
argument_list|()
argument_list|,
literal|"only location may have arguments"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// must check that location is non-negative
if|if
condition|(
name|intValue
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
name|intValueLine
argument_list|,
literal|"out of range:"
argument_list|,
name|intValueString
operator|.
name|c_str
argument_list|()
argument_list|,
literal|"location must be non-negative"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|qualifier
operator|.
name|location
operator|=
name|intValue
expr_stmt|;
block|}
block|}
return|return
name|qualifier
return|;
block|}
end_function
begin_function
DECL|function|joinLayoutQualifiers
name|TLayoutQualifier
name|TParseContext
operator|::
name|joinLayoutQualifiers
parameter_list|(
name|TLayoutQualifier
name|leftQualifier
parameter_list|,
name|TLayoutQualifier
name|rightQualifier
parameter_list|)
block|{
name|TLayoutQualifier
name|joinedQualifier
init|=
name|leftQualifier
decl_stmt|;
if|if
condition|(
name|rightQualifier
operator|.
name|location
operator|!=
operator|-
literal|1
condition|)
block|{
name|joinedQualifier
operator|.
name|location
operator|=
name|rightQualifier
operator|.
name|location
expr_stmt|;
block|}
if|if
condition|(
name|rightQualifier
operator|.
name|matrixPacking
operator|!=
name|EmpUnspecified
condition|)
block|{
name|joinedQualifier
operator|.
name|matrixPacking
operator|=
name|rightQualifier
operator|.
name|matrixPacking
expr_stmt|;
block|}
if|if
condition|(
name|rightQualifier
operator|.
name|blockStorage
operator|!=
name|EbsUnspecified
condition|)
block|{
name|joinedQualifier
operator|.
name|blockStorage
operator|=
name|rightQualifier
operator|.
name|blockStorage
expr_stmt|;
block|}
return|return
name|joinedQualifier
return|;
block|}
end_function
begin_function
DECL|function|joinInterpolationQualifiers
name|TPublicType
name|TParseContext
operator|::
name|joinInterpolationQualifiers
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|interpolationLoc
parameter_list|,
name|TQualifier
name|interpolationQualifier
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|storageLoc
parameter_list|,
name|TQualifier
name|storageQualifier
parameter_list|)
block|{
name|TQualifier
name|mergedQualifier
init|=
name|EvqSmoothIn
decl_stmt|;
if|if
condition|(
name|storageQualifier
operator|==
name|EvqFragmentIn
condition|)
block|{
if|if
condition|(
name|interpolationQualifier
operator|==
name|EvqSmooth
condition|)
name|mergedQualifier
operator|=
name|EvqSmoothIn
expr_stmt|;
elseif|else
if|if
condition|(
name|interpolationQualifier
operator|==
name|EvqFlat
condition|)
name|mergedQualifier
operator|=
name|EvqFlatIn
expr_stmt|;
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|storageQualifier
operator|==
name|EvqCentroidIn
condition|)
block|{
if|if
condition|(
name|interpolationQualifier
operator|==
name|EvqSmooth
condition|)
name|mergedQualifier
operator|=
name|EvqCentroidIn
expr_stmt|;
elseif|else
if|if
condition|(
name|interpolationQualifier
operator|==
name|EvqFlat
condition|)
name|mergedQualifier
operator|=
name|EvqFlatIn
expr_stmt|;
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|storageQualifier
operator|==
name|EvqVertexOut
condition|)
block|{
if|if
condition|(
name|interpolationQualifier
operator|==
name|EvqSmooth
condition|)
name|mergedQualifier
operator|=
name|EvqSmoothOut
expr_stmt|;
elseif|else
if|if
condition|(
name|interpolationQualifier
operator|==
name|EvqFlat
condition|)
name|mergedQualifier
operator|=
name|EvqFlatOut
expr_stmt|;
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|storageQualifier
operator|==
name|EvqCentroidOut
condition|)
block|{
if|if
condition|(
name|interpolationQualifier
operator|==
name|EvqSmooth
condition|)
name|mergedQualifier
operator|=
name|EvqCentroidOut
expr_stmt|;
elseif|else
if|if
condition|(
name|interpolationQualifier
operator|==
name|EvqFlat
condition|)
name|mergedQualifier
operator|=
name|EvqFlatOut
expr_stmt|;
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
name|interpolationLoc
argument_list|,
literal|"interpolation qualifier requires a fragment 'in' or vertex 'out' storage qualifier"
argument_list|,
name|getInterpolationString
argument_list|(
name|interpolationQualifier
argument_list|)
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
name|mergedQualifier
operator|=
name|storageQualifier
expr_stmt|;
block|}
name|TPublicType
name|type
decl_stmt|;
name|type
operator|.
name|setBasic
argument_list|(
name|EbtVoid
argument_list|,
name|mergedQualifier
argument_list|,
name|storageLoc
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function
begin_function
DECL|function|addStructDeclaratorList
name|TFieldList
modifier|*
name|TParseContext
operator|::
name|addStructDeclaratorList
parameter_list|(
specifier|const
name|TPublicType
modifier|&
name|typeSpecifier
parameter_list|,
name|TFieldList
modifier|*
name|fieldList
parameter_list|)
block|{
if|if
condition|(
name|voidErrorCheck
argument_list|(
name|typeSpecifier
operator|.
name|line
argument_list|,
operator|(
operator|*
name|fieldList
operator|)
index|[
literal|0
index|]
operator|->
name|name
argument_list|()
argument_list|,
name|typeSpecifier
argument_list|)
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fieldList
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
comment|//
comment|// Careful not to replace already known aspects of type, like array-ness
comment|//
name|TType
modifier|*
name|type
init|=
operator|(
operator|*
name|fieldList
operator|)
index|[
name|i
index|]
operator|->
name|type
argument_list|()
decl_stmt|;
name|type
operator|->
name|setBasicType
argument_list|(
name|typeSpecifier
operator|.
name|type
argument_list|)
expr_stmt|;
name|type
operator|->
name|setPrimarySize
argument_list|(
name|typeSpecifier
operator|.
name|primarySize
argument_list|)
expr_stmt|;
name|type
operator|->
name|setSecondarySize
argument_list|(
name|typeSpecifier
operator|.
name|secondarySize
argument_list|)
expr_stmt|;
name|type
operator|->
name|setPrecision
argument_list|(
name|typeSpecifier
operator|.
name|precision
argument_list|)
expr_stmt|;
name|type
operator|->
name|setQualifier
argument_list|(
name|typeSpecifier
operator|.
name|qualifier
argument_list|)
expr_stmt|;
name|type
operator|->
name|setLayoutQualifier
argument_list|(
name|typeSpecifier
operator|.
name|layoutQualifier
argument_list|)
expr_stmt|;
comment|// don't allow arrays of arrays
if|if
condition|(
name|type
operator|->
name|isArray
argument_list|()
condition|)
block|{
if|if
condition|(
name|arrayTypeErrorCheck
argument_list|(
name|typeSpecifier
operator|.
name|line
argument_list|,
name|typeSpecifier
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|typeSpecifier
operator|.
name|array
condition|)
name|type
operator|->
name|setArraySize
argument_list|(
name|typeSpecifier
operator|.
name|arraySize
argument_list|)
expr_stmt|;
if|if
condition|(
name|typeSpecifier
operator|.
name|userDef
condition|)
block|{
name|type
operator|->
name|setStruct
argument_list|(
name|typeSpecifier
operator|.
name|userDef
operator|->
name|getStruct
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|structNestingErrorCheck
argument_list|(
name|typeSpecifier
operator|.
name|line
argument_list|,
operator|*
operator|(
operator|*
name|fieldList
operator|)
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|fieldList
return|;
block|}
end_function
begin_function
DECL|function|addStructure
name|TPublicType
name|TParseContext
operator|::
name|addStructure
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|structLine
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|nameLine
parameter_list|,
specifier|const
name|TString
modifier|*
name|structName
parameter_list|,
name|TFieldList
modifier|*
name|fieldList
parameter_list|)
block|{
name|TStructure
modifier|*
name|structure
init|=
operator|new
name|TStructure
argument_list|(
name|structName
argument_list|,
name|fieldList
argument_list|)
decl_stmt|;
name|TType
modifier|*
name|structureType
init|=
operator|new
name|TType
argument_list|(
name|structure
argument_list|)
decl_stmt|;
comment|// Store a bool in the struct if we're at global scope, to allow us to
comment|// skip the local struct scoping workaround in HLSL.
name|structure
operator|->
name|setUniqueId
argument_list|(
name|TSymbolTable
operator|::
name|nextUniqueId
argument_list|()
argument_list|)
expr_stmt|;
name|structure
operator|->
name|setAtGlobalScope
argument_list|(
name|symbolTable
operator|.
name|atGlobalLevel
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|structName
operator|->
name|empty
argument_list|()
condition|)
block|{
if|if
condition|(
name|reservedErrorCheck
argument_list|(
name|nameLine
argument_list|,
operator|*
name|structName
argument_list|)
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
block|}
name|TVariable
modifier|*
name|userTypeDef
init|=
operator|new
name|TVariable
argument_list|(
name|structName
argument_list|,
operator|*
name|structureType
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|symbolTable
operator|.
name|declare
argument_list|(
name|userTypeDef
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|nameLine
argument_list|,
literal|"redefinition"
argument_list|,
name|structName
operator|->
name|c_str
argument_list|()
argument_list|,
literal|"struct"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
block|}
comment|// ensure we do not specify any storage qualifiers on the struct members
for|for
control|(
name|unsigned
name|int
name|typeListIndex
init|=
literal|0
init|;
name|typeListIndex
operator|<
name|fieldList
operator|->
name|size
argument_list|()
condition|;
name|typeListIndex
operator|++
control|)
block|{
specifier|const
name|TField
modifier|&
name|field
init|=
operator|*
operator|(
operator|*
name|fieldList
operator|)
index|[
name|typeListIndex
index|]
decl_stmt|;
specifier|const
name|TQualifier
name|qualifier
init|=
name|field
operator|.
name|type
argument_list|()
operator|->
name|getQualifier
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|qualifier
condition|)
block|{
case|case
name|EvqGlobal
case|:
case|case
name|EvqTemporary
case|:
break|break;
default|default:
name|error
argument_list|(
name|field
operator|.
name|line
argument_list|()
argument_list|,
literal|"invalid qualifier on struct member"
argument_list|,
name|getQualifierString
argument_list|(
name|qualifier
argument_list|)
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|TPublicType
name|publicType
decl_stmt|;
name|publicType
operator|.
name|setBasic
argument_list|(
name|EbtStruct
argument_list|,
name|EvqTemporary
argument_list|,
name|structLine
argument_list|)
expr_stmt|;
name|publicType
operator|.
name|userDef
operator|=
name|structureType
expr_stmt|;
name|exitStructDeclaration
argument_list|()
expr_stmt|;
return|return
name|publicType
return|;
block|}
end_function
begin_function
DECL|function|addSwitch
name|TIntermSwitch
modifier|*
name|TParseContext
operator|::
name|addSwitch
parameter_list|(
name|TIntermTyped
modifier|*
name|init
parameter_list|,
name|TIntermAggregate
modifier|*
name|statementList
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|)
block|{
name|TBasicType
name|switchType
init|=
name|init
operator|->
name|getBasicType
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|switchType
operator|!=
name|EbtInt
operator|&&
name|switchType
operator|!=
name|EbtUInt
operator|)
operator|||
name|init
operator|->
name|isMatrix
argument_list|()
operator|||
name|init
operator|->
name|isArray
argument_list|()
operator|||
name|init
operator|->
name|isVector
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|init
operator|->
name|getLine
argument_list|()
argument_list|,
literal|"init-expression in a switch statement must be a scalar integer"
argument_list|,
literal|"switch"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
if|if
condition|(
name|statementList
condition|)
block|{
if|if
condition|(
operator|!
name|ValidateSwitch
operator|::
name|validate
argument_list|(
name|switchType
argument_list|,
name|this
argument_list|,
name|statementList
argument_list|,
name|loc
argument_list|)
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
block|}
name|TIntermSwitch
modifier|*
name|node
init|=
name|intermediate
operator|.
name|addSwitch
argument_list|(
name|init
argument_list|,
name|statementList
argument_list|,
name|loc
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|nullptr
condition|)
block|{
name|error
argument_list|(
name|loc
argument_list|,
literal|"erroneous switch statement"
argument_list|,
literal|"switch"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
return|return
name|node
return|;
block|}
end_function
begin_function
DECL|function|addCase
name|TIntermCase
modifier|*
name|TParseContext
operator|::
name|addCase
parameter_list|(
name|TIntermTyped
modifier|*
name|condition
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|)
block|{
if|if
condition|(
name|mSwitchNestingLevel
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|loc
argument_list|,
literal|"case labels need to be inside switch statements"
argument_list|,
literal|"case"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
if|if
condition|(
name|condition
operator|==
literal|nullptr
condition|)
block|{
name|error
argument_list|(
name|loc
argument_list|,
literal|"case label must have a condition"
argument_list|,
literal|"case"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
if|if
condition|(
operator|(
name|condition
operator|->
name|getBasicType
argument_list|()
operator|!=
name|EbtInt
operator|&&
name|condition
operator|->
name|getBasicType
argument_list|()
operator|!=
name|EbtUInt
operator|)
operator|||
name|condition
operator|->
name|isMatrix
argument_list|()
operator|||
name|condition
operator|->
name|isArray
argument_list|()
operator|||
name|condition
operator|->
name|isVector
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|condition
operator|->
name|getLine
argument_list|()
argument_list|,
literal|"case label must be a scalar integer"
argument_list|,
literal|"case"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
name|TIntermConstantUnion
modifier|*
name|conditionConst
init|=
name|condition
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
if|if
condition|(
name|conditionConst
operator|==
literal|nullptr
condition|)
block|{
name|error
argument_list|(
name|condition
operator|->
name|getLine
argument_list|()
argument_list|,
literal|"case label must be constant"
argument_list|,
literal|"case"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
name|TIntermCase
modifier|*
name|node
init|=
name|intermediate
operator|.
name|addCase
argument_list|(
name|condition
argument_list|,
name|loc
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|nullptr
condition|)
block|{
name|error
argument_list|(
name|loc
argument_list|,
literal|"erroneous case statement"
argument_list|,
literal|"case"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
return|return
name|node
return|;
block|}
end_function
begin_function
DECL|function|addDefault
name|TIntermCase
modifier|*
name|TParseContext
operator|::
name|addDefault
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|)
block|{
if|if
condition|(
name|mSwitchNestingLevel
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|loc
argument_list|,
literal|"default labels need to be inside switch statements"
argument_list|,
literal|"default"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
name|TIntermCase
modifier|*
name|node
init|=
name|intermediate
operator|.
name|addCase
argument_list|(
literal|nullptr
argument_list|,
name|loc
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|nullptr
condition|)
block|{
name|error
argument_list|(
name|loc
argument_list|,
literal|"erroneous default statement"
argument_list|,
literal|"default"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
return|return
name|node
return|;
block|}
end_function
begin_function
DECL|function|createUnaryMath
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|createUnaryMath
parameter_list|(
name|TOperator
name|op
parameter_list|,
name|TIntermTyped
modifier|*
name|child
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|,
specifier|const
name|TType
modifier|*
name|funcReturnType
parameter_list|)
block|{
if|if
condition|(
name|child
operator|==
literal|nullptr
condition|)
block|{
return|return
literal|nullptr
return|;
block|}
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|EOpLogicalNot
case|:
if|if
condition|(
name|child
operator|->
name|getBasicType
argument_list|()
operator|!=
name|EbtBool
operator|||
name|child
operator|->
name|isMatrix
argument_list|()
operator|||
name|child
operator|->
name|isArray
argument_list|()
operator|||
name|child
operator|->
name|isVector
argument_list|()
condition|)
block|{
return|return
literal|nullptr
return|;
block|}
break|break;
case|case
name|EOpBitwiseNot
case|:
if|if
condition|(
operator|(
name|child
operator|->
name|getBasicType
argument_list|()
operator|!=
name|EbtInt
operator|&&
name|child
operator|->
name|getBasicType
argument_list|()
operator|!=
name|EbtUInt
operator|)
operator|||
name|child
operator|->
name|isMatrix
argument_list|()
operator|||
name|child
operator|->
name|isArray
argument_list|()
condition|)
block|{
return|return
literal|nullptr
return|;
block|}
break|break;
case|case
name|EOpPostIncrement
case|:
case|case
name|EOpPreIncrement
case|:
case|case
name|EOpPostDecrement
case|:
case|case
name|EOpPreDecrement
case|:
case|case
name|EOpNegative
case|:
case|case
name|EOpPositive
case|:
if|if
condition|(
name|child
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtStruct
operator|||
name|child
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtBool
operator|||
name|child
operator|->
name|isArray
argument_list|()
condition|)
block|{
return|return
literal|nullptr
return|;
block|}
comment|// Operators for built-ins are already type checked against their prototype.
default|default:
break|break;
block|}
return|return
name|intermediate
operator|.
name|addUnaryMath
argument_list|(
name|op
argument_list|,
name|child
argument_list|,
name|loc
argument_list|,
name|funcReturnType
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|addUnaryMath
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|addUnaryMath
parameter_list|(
name|TOperator
name|op
parameter_list|,
name|TIntermTyped
modifier|*
name|child
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|)
block|{
name|TIntermTyped
modifier|*
name|node
init|=
name|createUnaryMath
argument_list|(
name|op
argument_list|,
name|child
argument_list|,
name|loc
argument_list|,
literal|nullptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|nullptr
condition|)
block|{
name|unaryOpError
argument_list|(
name|loc
argument_list|,
name|GetOperatorString
argument_list|(
name|op
argument_list|)
argument_list|,
name|child
operator|->
name|getCompleteString
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
name|child
return|;
block|}
return|return
name|node
return|;
block|}
end_function
begin_function
DECL|function|addUnaryMathLValue
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|addUnaryMathLValue
parameter_list|(
name|TOperator
name|op
parameter_list|,
name|TIntermTyped
modifier|*
name|child
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|)
block|{
if|if
condition|(
name|lValueErrorCheck
argument_list|(
name|loc
argument_list|,
name|GetOperatorString
argument_list|(
name|op
argument_list|)
argument_list|,
name|child
argument_list|)
condition|)
name|recover
argument_list|()
expr_stmt|;
return|return
name|addUnaryMath
argument_list|(
name|op
argument_list|,
name|child
argument_list|,
name|loc
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|binaryOpCommonCheck
name|bool
name|TParseContext
operator|::
name|binaryOpCommonCheck
parameter_list|(
name|TOperator
name|op
parameter_list|,
name|TIntermTyped
modifier|*
name|left
parameter_list|,
name|TIntermTyped
modifier|*
name|right
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|)
block|{
if|if
condition|(
name|left
operator|->
name|isArray
argument_list|()
operator|||
name|right
operator|->
name|isArray
argument_list|()
condition|)
block|{
if|if
condition|(
name|shaderVersion
operator|<
literal|300
condition|)
block|{
name|error
argument_list|(
name|loc
argument_list|,
literal|"Invalid operation for arrays"
argument_list|,
name|GetOperatorString
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|left
operator|->
name|isArray
argument_list|()
operator|!=
name|right
operator|->
name|isArray
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|loc
argument_list|,
literal|"array / non-array mismatch"
argument_list|,
name|GetOperatorString
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|EOpEqual
case|:
case|case
name|EOpNotEqual
case|:
case|case
name|EOpAssign
case|:
case|case
name|EOpInitialize
case|:
break|break;
default|default:
name|error
argument_list|(
name|loc
argument_list|,
literal|"Invalid operation for arrays"
argument_list|,
name|GetOperatorString
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|left
operator|->
name|getArraySize
argument_list|()
operator|!=
name|right
operator|->
name|getArraySize
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|loc
argument_list|,
literal|"array size mismatch"
argument_list|,
name|GetOperatorString
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|// Check ops which require integer / ivec parameters
name|bool
name|isBitShift
init|=
literal|false
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|EOpBitShiftLeft
case|:
case|case
name|EOpBitShiftRight
case|:
case|case
name|EOpBitShiftLeftAssign
case|:
case|case
name|EOpBitShiftRightAssign
case|:
comment|// Unsigned can be bit-shifted by signed and vice versa, but we need to
comment|// check that the basic type is an integer type.
name|isBitShift
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|IsInteger
argument_list|(
name|left
operator|->
name|getBasicType
argument_list|()
argument_list|)
operator|||
operator|!
name|IsInteger
argument_list|(
name|right
operator|->
name|getBasicType
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
break|break;
case|case
name|EOpBitwiseAnd
case|:
case|case
name|EOpBitwiseXor
case|:
case|case
name|EOpBitwiseOr
case|:
case|case
name|EOpBitwiseAndAssign
case|:
case|case
name|EOpBitwiseXorAssign
case|:
case|case
name|EOpBitwiseOrAssign
case|:
comment|// It is enough to check the type of only one operand, since later it
comment|// is checked that the operand types match.
if|if
condition|(
operator|!
name|IsInteger
argument_list|(
name|left
operator|->
name|getBasicType
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
break|break;
default|default:
break|break;
block|}
comment|// GLSL ES 1.00 and 3.00 do not support implicit type casting.
comment|// So the basic type should usually match.
if|if
condition|(
operator|!
name|isBitShift
operator|&&
name|left
operator|->
name|getBasicType
argument_list|()
operator|!=
name|right
operator|->
name|getBasicType
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Check that type sizes match exactly on ops that require that.
comment|// Also check restrictions for structs that contain arrays or samplers.
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|EOpAssign
case|:
case|case
name|EOpInitialize
case|:
case|case
name|EOpEqual
case|:
case|case
name|EOpNotEqual
case|:
comment|// ESSL 1.00 sections 5.7, 5.8, 5.9
if|if
condition|(
name|shaderVersion
operator|<
literal|300
operator|&&
name|left
operator|->
name|getType
argument_list|()
operator|.
name|isStructureContainingArrays
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|loc
argument_list|,
literal|"undefined operation for structs containing arrays"
argument_list|,
name|GetOperatorString
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Samplers as l-values are disallowed also in ESSL 3.00, see section 4.1.7,
comment|// we interpret the spec so that this extends to structs containing samplers,
comment|// similarly to ESSL 1.00 spec.
if|if
condition|(
operator|(
name|shaderVersion
operator|<
literal|300
operator|||
name|op
operator|==
name|EOpAssign
operator|||
name|op
operator|==
name|EOpInitialize
operator|)
operator|&&
name|left
operator|->
name|getType
argument_list|()
operator|.
name|isStructureContainingSamplers
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|loc
argument_list|,
literal|"undefined operation for structs containing samplers"
argument_list|,
name|GetOperatorString
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
case|case
name|EOpLessThan
case|:
case|case
name|EOpGreaterThan
case|:
case|case
name|EOpLessThanEqual
case|:
case|case
name|EOpGreaterThanEqual
case|:
if|if
condition|(
operator|(
name|left
operator|->
name|getNominalSize
argument_list|()
operator|!=
name|right
operator|->
name|getNominalSize
argument_list|()
operator|)
operator|||
operator|(
name|left
operator|->
name|getSecondarySize
argument_list|()
operator|!=
name|right
operator|->
name|getSecondarySize
argument_list|()
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
default|default:
break|break;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|addBinaryMathInternal
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|addBinaryMathInternal
parameter_list|(
name|TOperator
name|op
parameter_list|,
name|TIntermTyped
modifier|*
name|left
parameter_list|,
name|TIntermTyped
modifier|*
name|right
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|)
block|{
if|if
condition|(
operator|!
name|binaryOpCommonCheck
argument_list|(
name|op
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|loc
argument_list|)
condition|)
return|return
literal|nullptr
return|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|EOpEqual
case|:
case|case
name|EOpNotEqual
case|:
break|break;
case|case
name|EOpLessThan
case|:
case|case
name|EOpGreaterThan
case|:
case|case
name|EOpLessThanEqual
case|:
case|case
name|EOpGreaterThanEqual
case|:
name|ASSERT
argument_list|(
operator|!
name|left
operator|->
name|isArray
argument_list|()
operator|&&
operator|!
name|right
operator|->
name|isArray
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|->
name|isMatrix
argument_list|()
operator|||
name|left
operator|->
name|isVector
argument_list|()
operator|||
name|left
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtStruct
condition|)
block|{
return|return
literal|nullptr
return|;
block|}
break|break;
case|case
name|EOpLogicalOr
case|:
case|case
name|EOpLogicalXor
case|:
case|case
name|EOpLogicalAnd
case|:
name|ASSERT
argument_list|(
operator|!
name|left
operator|->
name|isArray
argument_list|()
operator|&&
operator|!
name|right
operator|->
name|isArray
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|->
name|getBasicType
argument_list|()
operator|!=
name|EbtBool
operator|||
name|left
operator|->
name|isMatrix
argument_list|()
operator|||
name|left
operator|->
name|isVector
argument_list|()
condition|)
block|{
return|return
literal|nullptr
return|;
block|}
break|break;
case|case
name|EOpAdd
case|:
case|case
name|EOpSub
case|:
case|case
name|EOpDiv
case|:
case|case
name|EOpMul
case|:
name|ASSERT
argument_list|(
operator|!
name|left
operator|->
name|isArray
argument_list|()
operator|&&
operator|!
name|right
operator|->
name|isArray
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtStruct
operator|||
name|left
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtBool
condition|)
block|{
return|return
literal|nullptr
return|;
block|}
break|break;
case|case
name|EOpIMod
case|:
name|ASSERT
argument_list|(
operator|!
name|left
operator|->
name|isArray
argument_list|()
operator|&&
operator|!
name|right
operator|->
name|isArray
argument_list|()
argument_list|)
expr_stmt|;
comment|// Note that this is only for the % operator, not for mod()
if|if
condition|(
name|left
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtStruct
operator|||
name|left
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtBool
operator|||
name|left
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtFloat
condition|)
block|{
return|return
literal|nullptr
return|;
block|}
break|break;
comment|// Note that for bitwise ops, type checking is done in promote() to
comment|// share code between ops and compound assignment
default|default:
break|break;
block|}
return|return
name|intermediate
operator|.
name|addBinaryMath
argument_list|(
name|op
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|loc
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|addBinaryMath
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|addBinaryMath
parameter_list|(
name|TOperator
name|op
parameter_list|,
name|TIntermTyped
modifier|*
name|left
parameter_list|,
name|TIntermTyped
modifier|*
name|right
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|)
block|{
name|TIntermTyped
modifier|*
name|node
init|=
name|addBinaryMathInternal
argument_list|(
name|op
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|loc
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|0
condition|)
block|{
name|binaryOpError
argument_list|(
name|loc
argument_list|,
name|GetOperatorString
argument_list|(
name|op
argument_list|)
argument_list|,
name|left
operator|->
name|getCompleteString
argument_list|()
argument_list|,
name|right
operator|->
name|getCompleteString
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
name|left
return|;
block|}
return|return
name|node
return|;
block|}
end_function
begin_function
DECL|function|addBinaryMathBooleanResult
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|addBinaryMathBooleanResult
parameter_list|(
name|TOperator
name|op
parameter_list|,
name|TIntermTyped
modifier|*
name|left
parameter_list|,
name|TIntermTyped
modifier|*
name|right
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|)
block|{
name|TIntermTyped
modifier|*
name|node
init|=
name|addBinaryMathInternal
argument_list|(
name|op
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|loc
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|0
condition|)
block|{
name|binaryOpError
argument_list|(
name|loc
argument_list|,
name|GetOperatorString
argument_list|(
name|op
argument_list|)
argument_list|,
name|left
operator|->
name|getCompleteString
argument_list|()
argument_list|,
name|right
operator|->
name|getCompleteString
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
name|ConstantUnion
modifier|*
name|unionArray
init|=
operator|new
name|ConstantUnion
index|[
literal|1
index|]
decl_stmt|;
name|unionArray
operator|->
name|setBConst
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return
name|intermediate
operator|.
name|addConstantUnion
argument_list|(
name|unionArray
argument_list|,
name|TType
argument_list|(
name|EbtBool
argument_list|,
name|EbpUndefined
argument_list|,
name|EvqConst
argument_list|)
argument_list|,
name|loc
argument_list|)
return|;
block|}
return|return
name|node
return|;
block|}
end_function
begin_function
DECL|function|createAssign
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|createAssign
parameter_list|(
name|TOperator
name|op
parameter_list|,
name|TIntermTyped
modifier|*
name|left
parameter_list|,
name|TIntermTyped
modifier|*
name|right
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|)
block|{
if|if
condition|(
name|binaryOpCommonCheck
argument_list|(
name|op
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|loc
argument_list|)
condition|)
block|{
return|return
name|intermediate
operator|.
name|addAssign
argument_list|(
name|op
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|loc
argument_list|)
return|;
block|}
return|return
literal|nullptr
return|;
block|}
end_function
begin_function
DECL|function|addAssign
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|addAssign
parameter_list|(
name|TOperator
name|op
parameter_list|,
name|TIntermTyped
modifier|*
name|left
parameter_list|,
name|TIntermTyped
modifier|*
name|right
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|)
block|{
name|TIntermTyped
modifier|*
name|node
init|=
name|createAssign
argument_list|(
name|op
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|loc
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|nullptr
condition|)
block|{
name|assignError
argument_list|(
name|loc
argument_list|,
literal|"assign"
argument_list|,
name|left
operator|->
name|getCompleteString
argument_list|()
argument_list|,
name|right
operator|->
name|getCompleteString
argument_list|()
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
return|return
name|left
return|;
block|}
return|return
name|node
return|;
block|}
end_function
begin_function
DECL|function|addBranch
name|TIntermBranch
modifier|*
name|TParseContext
operator|::
name|addBranch
parameter_list|(
name|TOperator
name|op
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|EOpContinue
case|:
if|if
condition|(
name|mLoopNestingLevel
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
name|loc
argument_list|,
literal|"continue statement only allowed in loops"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|EOpBreak
case|:
if|if
condition|(
name|mLoopNestingLevel
operator|<=
literal|0
operator|&&
name|mSwitchNestingLevel
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
name|loc
argument_list|,
literal|"break statement only allowed in loops and switch statements"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|EOpReturn
case|:
if|if
condition|(
name|currentFunctionType
operator|->
name|getBasicType
argument_list|()
operator|!=
name|EbtVoid
condition|)
block|{
name|error
argument_list|(
name|loc
argument_list|,
literal|"non-void function must return a value"
argument_list|,
literal|"return"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
comment|// No checks for discard
break|break;
block|}
return|return
name|intermediate
operator|.
name|addBranch
argument_list|(
name|op
argument_list|,
name|loc
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|addBranch
name|TIntermBranch
modifier|*
name|TParseContext
operator|::
name|addBranch
parameter_list|(
name|TOperator
name|op
parameter_list|,
name|TIntermTyped
modifier|*
name|returnValue
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|op
operator|==
name|EOpReturn
argument_list|)
expr_stmt|;
name|mFunctionReturnsValue
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|currentFunctionType
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtVoid
condition|)
block|{
name|error
argument_list|(
name|loc
argument_list|,
literal|"void function cannot return a value"
argument_list|,
literal|"return"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|currentFunctionType
operator|!=
name|returnValue
operator|->
name|getType
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|loc
argument_list|,
literal|"function return is not matching type:"
argument_list|,
literal|"return"
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
return|return
name|intermediate
operator|.
name|addBranch
argument_list|(
name|op
argument_list|,
name|returnValue
argument_list|,
name|loc
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|addFunctionCallOrMethod
name|TIntermTyped
modifier|*
name|TParseContext
operator|::
name|addFunctionCallOrMethod
parameter_list|(
name|TFunction
modifier|*
name|fnCall
parameter_list|,
name|TIntermNode
modifier|*
name|node
parameter_list|,
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|,
name|bool
modifier|*
name|fatalError
parameter_list|)
block|{
operator|*
name|fatalError
operator|=
literal|false
expr_stmt|;
name|TOperator
name|op
init|=
name|fnCall
operator|->
name|getBuiltInOp
argument_list|()
decl_stmt|;
name|TIntermTyped
modifier|*
name|callNode
init|=
literal|nullptr
decl_stmt|;
if|if
condition|(
name|op
operator|!=
name|EOpNull
condition|)
block|{
comment|//
comment|// Then this should be a constructor.
comment|// Don't go through the symbol table for constructors.
comment|// Their parameters will be verified algorithmically.
comment|//
name|TType
name|type
argument_list|(
name|EbtVoid
argument_list|,
name|EbpUndefined
argument_list|)
decl_stmt|;
comment|// use this to get the type back
if|if
condition|(
operator|!
name|constructorErrorCheck
argument_list|(
name|loc
argument_list|,
name|node
argument_list|,
operator|*
name|fnCall
argument_list|,
name|op
argument_list|,
operator|&
name|type
argument_list|)
condition|)
block|{
comment|//
comment|// It's a constructor, of type 'type'.
comment|//
name|callNode
operator|=
name|addConstructor
argument_list|(
name|node
argument_list|,
operator|&
name|type
argument_list|,
name|op
argument_list|,
name|fnCall
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|callNode
operator|==
literal|nullptr
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
name|callNode
operator|=
name|intermediate
operator|.
name|setAggregateOperator
argument_list|(
literal|nullptr
argument_list|,
name|op
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
name|callNode
operator|->
name|setType
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//
comment|// Not a constructor.  Find it in the symbol table.
comment|//
specifier|const
name|TFunction
modifier|*
name|fnCandidate
decl_stmt|;
name|bool
name|builtIn
decl_stmt|;
name|fnCandidate
operator|=
name|findFunction
argument_list|(
name|loc
argument_list|,
name|fnCall
argument_list|,
name|shaderVersion
argument_list|,
operator|&
name|builtIn
argument_list|)
expr_stmt|;
if|if
condition|(
name|fnCandidate
condition|)
block|{
comment|//
comment|// A declared function.
comment|//
if|if
condition|(
name|builtIn
operator|&&
operator|!
name|fnCandidate
operator|->
name|getExtension
argument_list|()
operator|.
name|empty
argument_list|()
operator|&&
name|extensionErrorCheck
argument_list|(
name|loc
argument_list|,
name|fnCandidate
operator|->
name|getExtension
argument_list|()
argument_list|)
condition|)
block|{
name|recover
argument_list|()
expr_stmt|;
block|}
name|op
operator|=
name|fnCandidate
operator|->
name|getBuiltInOp
argument_list|()
expr_stmt|;
if|if
condition|(
name|builtIn
operator|&&
name|op
operator|!=
name|EOpNull
condition|)
block|{
comment|//
comment|// A function call mapped to a built-in operation.
comment|//
if|if
condition|(
name|fnCandidate
operator|->
name|getParamCount
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|//
comment|// Treat it like a built-in unary operator.
comment|//
name|callNode
operator|=
name|createUnaryMath
argument_list|(
name|op
argument_list|,
name|node
operator|->
name|getAsTyped
argument_list|()
argument_list|,
name|loc
argument_list|,
operator|&
name|fnCandidate
operator|->
name|getReturnType
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|callNode
operator|==
literal|nullptr
condition|)
block|{
name|std
operator|::
name|stringstream
name|extraInfoStream
decl_stmt|;
name|extraInfoStream
operator|<<
literal|"built in unary operator function.  Type: "
operator|<<
cast|static_cast
argument_list|<
name|TIntermTyped
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
operator|->
name|getCompleteString
argument_list|()
expr_stmt|;
name|std
operator|::
name|string
name|extraInfo
init|=
name|extraInfoStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|error
argument_list|(
name|node
operator|->
name|getLine
argument_list|()
argument_list|,
literal|" wrong operand type"
argument_list|,
literal|"Internal Error"
argument_list|,
name|extraInfo
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
operator|*
name|fatalError
operator|=
literal|true
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
block|}
else|else
block|{
name|TIntermAggregate
modifier|*
name|aggregate
init|=
name|intermediate
operator|.
name|setAggregateOperator
argument_list|(
name|node
argument_list|,
name|op
argument_list|,
name|loc
argument_list|)
decl_stmt|;
name|aggregate
operator|->
name|setType
argument_list|(
name|fnCandidate
operator|->
name|getReturnType
argument_list|()
argument_list|)
expr_stmt|;
name|aggregate
operator|->
name|setPrecisionFromChildren
argument_list|()
expr_stmt|;
name|callNode
operator|=
name|aggregate
expr_stmt|;
comment|// Some built-in functions have out parameters too.
name|functionCallLValueErrorCheck
argument_list|(
name|fnCandidate
argument_list|,
name|aggregate
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// This is a real function call
name|TIntermAggregate
modifier|*
name|aggregate
init|=
name|intermediate
operator|.
name|setAggregateOperator
argument_list|(
name|node
argument_list|,
name|EOpFunctionCall
argument_list|,
name|loc
argument_list|)
decl_stmt|;
name|aggregate
operator|->
name|setType
argument_list|(
name|fnCandidate
operator|->
name|getReturnType
argument_list|()
argument_list|)
expr_stmt|;
comment|// this is how we know whether the given function is a builtIn function or a user defined function
comment|// if builtIn == false, it's a userDefined -> could be an overloaded builtIn function also
comment|// if builtIn == true, it's definitely a builtIn function with EOpNull
if|if
condition|(
operator|!
name|builtIn
condition|)
name|aggregate
operator|->
name|setUserDefined
argument_list|()
expr_stmt|;
name|aggregate
operator|->
name|setName
argument_list|(
name|fnCandidate
operator|->
name|getMangledName
argument_list|()
argument_list|)
expr_stmt|;
comment|// This needs to happen after the name is set
if|if
condition|(
name|builtIn
condition|)
name|aggregate
operator|->
name|setBuiltInFunctionPrecision
argument_list|()
expr_stmt|;
name|callNode
operator|=
name|aggregate
expr_stmt|;
name|functionCallLValueErrorCheck
argument_list|(
name|fnCandidate
argument_list|,
name|aggregate
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// error message was put out by findFunction()
comment|// Put on a dummy node for error recovery
name|ConstantUnion
modifier|*
name|unionArray
init|=
operator|new
name|ConstantUnion
index|[
literal|1
index|]
decl_stmt|;
name|unionArray
operator|->
name|setFConst
argument_list|(
literal|0.0f
argument_list|)
expr_stmt|;
name|callNode
operator|=
name|intermediate
operator|.
name|addConstantUnion
argument_list|(
name|unionArray
argument_list|,
name|TType
argument_list|(
name|EbtFloat
argument_list|,
name|EbpUndefined
argument_list|,
name|EvqConst
argument_list|)
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
block|}
operator|delete
name|fnCall
expr_stmt|;
return|return
name|callNode
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Parse an array of strings using yyparse.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns 0 for success.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|PaParseStrings
name|int
name|PaParseStrings
parameter_list|(
name|size_t
name|count
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
name|string
index|[]
parameter_list|,
specifier|const
name|int
name|length
index|[]
parameter_list|,
name|TParseContext
modifier|*
name|context
parameter_list|)
block|{
if|if
condition|(
operator|(
name|count
operator|==
literal|0
operator|)
operator|||
operator|(
name|string
operator|==
name|NULL
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|glslang_initialize
argument_list|(
name|context
argument_list|)
condition|)
return|return
literal|1
return|;
name|int
name|error
init|=
name|glslang_scan
argument_list|(
name|count
argument_list|,
name|string
argument_list|,
name|length
argument_list|,
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|glslang_parse
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|glslang_finalize
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|==
literal|0
operator|)
operator|&&
operator|(
name|context
operator|->
name|numErrors
argument_list|()
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
return|;
block|}
end_function
end_unit
