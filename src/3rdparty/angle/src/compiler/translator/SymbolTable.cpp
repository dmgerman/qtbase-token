begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2013 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Symbol table for parsing.  Most functionaliy and main ideas
end_comment
begin_comment
comment|// are documented in the header file.
end_comment
begin_comment
comment|//
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_if
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4718
name|)
end_pragma
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"compiler/translator/SymbolTable.h"
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_decl_stmt
DECL|member|uniqueIdCounter
name|int
name|TSymbolTable
operator|::
name|uniqueIdCounter
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// Functions have buried pointers to delete.
end_comment
begin_comment
comment|//
end_comment
begin_destructor
DECL|function|~TFunction
name|TFunction
operator|::
name|~
name|TFunction
parameter_list|()
block|{
for|for
control|(
name|TParamList
operator|::
name|iterator
name|i
init|=
name|parameters
operator|.
name|begin
argument_list|()
init|;
name|i
operator|!=
name|parameters
operator|.
name|end
argument_list|()
condition|;
operator|++
name|i
control|)
operator|delete
operator|(
operator|*
name|i
operator|)
operator|.
name|type
expr_stmt|;
block|}
end_destructor
begin_comment
comment|//
end_comment
begin_comment
comment|// Symbol table levels are a map of pointers to symbols that have to be deleted.
end_comment
begin_comment
comment|//
end_comment
begin_destructor
DECL|function|~TSymbolTableLevel
name|TSymbolTableLevel
operator|::
name|~
name|TSymbolTableLevel
parameter_list|()
block|{
for|for
control|(
name|tLevel
operator|::
name|iterator
name|it
init|=
name|level
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|level
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
operator|delete
operator|(
operator|*
name|it
operator|)
operator|.
name|second
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|insert
name|bool
name|TSymbolTableLevel
operator|::
name|insert
parameter_list|(
name|TSymbol
modifier|*
name|symbol
parameter_list|)
block|{
name|symbol
operator|->
name|setUniqueId
argument_list|(
name|TSymbolTable
operator|::
name|nextUniqueId
argument_list|()
argument_list|)
expr_stmt|;
comment|// returning true means symbol was added to the table
name|tInsertResult
name|result
init|=
name|level
operator|.
name|insert
argument_list|(
name|tLevelPair
argument_list|(
name|symbol
operator|->
name|getMangledName
argument_list|()
argument_list|,
name|symbol
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|result
operator|.
name|second
return|;
block|}
end_function
begin_function
DECL|function|find
name|TSymbol
modifier|*
name|TSymbolTableLevel
operator|::
name|find
parameter_list|(
specifier|const
name|TString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
name|tLevel
operator|::
name|const_iterator
name|it
init|=
name|level
operator|.
name|find
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|==
name|level
operator|.
name|end
argument_list|()
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|(
operator|*
name|it
operator|)
operator|.
name|second
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Change all function entries in the table with the non-mangled name
end_comment
begin_comment
comment|// to be related to the provided built-in operation.  This is a low
end_comment
begin_comment
comment|// performance operation, and only intended for symbol tables that
end_comment
begin_comment
comment|// live across a large number of compiles.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|relateToOperator
name|void
name|TSymbolTableLevel
operator|::
name|relateToOperator
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|TOperator
name|op
parameter_list|)
block|{
for|for
control|(
name|tLevel
operator|::
name|iterator
name|it
init|=
name|level
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|level
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|.
name|second
operator|->
name|isFunction
argument_list|()
condition|)
block|{
name|TFunction
modifier|*
name|function
init|=
cast|static_cast
argument_list|<
name|TFunction
operator|*
argument_list|>
argument_list|(
operator|(
operator|*
name|it
operator|)
operator|.
name|second
argument_list|)
decl_stmt|;
if|if
condition|(
name|function
operator|->
name|getName
argument_list|()
operator|==
name|name
condition|)
name|function
operator|->
name|relateToOperator
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Change all function entries in the table with the non-mangled name
end_comment
begin_comment
comment|// to be related to the provided built-in extension. This is a low
end_comment
begin_comment
comment|// performance operation, and only intended for symbol tables that
end_comment
begin_comment
comment|// live across a large number of compiles.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|relateToExtension
name|void
name|TSymbolTableLevel
operator|::
name|relateToExtension
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|TString
modifier|&
name|ext
parameter_list|)
block|{
for|for
control|(
name|tLevel
operator|::
name|iterator
name|it
init|=
name|level
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|level
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|TSymbol
modifier|*
name|symbol
init|=
name|it
operator|->
name|second
decl_stmt|;
if|if
condition|(
name|symbol
operator|->
name|getName
argument_list|()
operator|==
name|name
condition|)
name|symbol
operator|->
name|relateToExtension
argument_list|(
name|ext
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_constructor
DECL|function|TSymbol
name|TSymbol
operator|::
name|TSymbol
parameter_list|(
specifier|const
name|TSymbol
modifier|&
name|copyOf
parameter_list|)
block|{
name|name
operator|=
name|NewPoolTString
argument_list|(
name|copyOf
operator|.
name|name
operator|->
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|uniqueId
operator|=
name|copyOf
operator|.
name|uniqueId
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|find
name|TSymbol
modifier|*
name|TSymbolTable
operator|::
name|find
parameter_list|(
specifier|const
name|TString
modifier|&
name|name
parameter_list|,
name|int
name|shaderVersion
parameter_list|,
name|bool
modifier|*
name|builtIn
parameter_list|,
name|bool
modifier|*
name|sameScope
parameter_list|)
block|{
name|int
name|level
init|=
name|currentLevel
argument_list|()
decl_stmt|;
name|TSymbol
modifier|*
name|symbol
decl_stmt|;
do|do
block|{
if|if
condition|(
name|level
operator|==
name|ESSL3_BUILTINS
operator|&&
name|shaderVersion
operator|!=
literal|300
condition|)
name|level
operator|--
expr_stmt|;
if|if
condition|(
name|level
operator|==
name|ESSL1_BUILTINS
operator|&&
name|shaderVersion
operator|!=
literal|100
condition|)
name|level
operator|--
expr_stmt|;
name|symbol
operator|=
name|table
index|[
name|level
index|]
operator|->
name|find
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|symbol
operator|==
literal|0
operator|&&
operator|--
name|level
operator|>=
literal|0
condition|)
do|;
if|if
condition|(
name|builtIn
condition|)
operator|*
name|builtIn
operator|=
operator|(
name|level
operator|<=
name|LAST_BUILTIN_LEVEL
operator|)
expr_stmt|;
if|if
condition|(
name|sameScope
condition|)
operator|*
name|sameScope
operator|=
operator|(
name|level
operator|==
name|currentLevel
argument_list|()
operator|)
expr_stmt|;
return|return
name|symbol
return|;
block|}
end_function
begin_function
DECL|function|findBuiltIn
name|TSymbol
modifier|*
name|TSymbolTable
operator|::
name|findBuiltIn
parameter_list|(
specifier|const
name|TString
modifier|&
name|name
parameter_list|,
name|int
name|shaderVersion
parameter_list|)
block|{
for|for
control|(
name|int
name|level
init|=
name|LAST_BUILTIN_LEVEL
init|;
name|level
operator|>=
literal|0
condition|;
name|level
operator|--
control|)
block|{
if|if
condition|(
name|level
operator|==
name|ESSL3_BUILTINS
operator|&&
name|shaderVersion
operator|!=
literal|300
condition|)
name|level
operator|--
expr_stmt|;
if|if
condition|(
name|level
operator|==
name|ESSL1_BUILTINS
operator|&&
name|shaderVersion
operator|!=
literal|100
condition|)
name|level
operator|--
expr_stmt|;
name|TSymbol
modifier|*
name|symbol
init|=
name|table
index|[
name|level
index|]
operator|->
name|find
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|symbol
condition|)
return|return
name|symbol
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_destructor
DECL|function|~TSymbolTable
name|TSymbolTable
operator|::
name|~
name|TSymbolTable
parameter_list|()
block|{
while|while
condition|(
name|table
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
name|pop
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|insertBuiltIn
name|void
name|TSymbolTable
operator|::
name|insertBuiltIn
parameter_list|(
name|ESymbolLevel
name|level
parameter_list|,
name|TType
modifier|*
name|rvalue
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|TType
modifier|*
name|ptype1
parameter_list|,
name|TType
modifier|*
name|ptype2
parameter_list|,
name|TType
modifier|*
name|ptype3
parameter_list|,
name|TType
modifier|*
name|ptype4
parameter_list|,
name|TType
modifier|*
name|ptype5
parameter_list|)
block|{
if|if
condition|(
name|ptype1
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtGSampler2D
condition|)
block|{
name|bool
name|gvec4
init|=
operator|(
name|rvalue
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtGVec4
operator|)
decl_stmt|;
name|insertBuiltIn
argument_list|(
name|level
argument_list|,
name|gvec4
condition|?
operator|new
name|TType
argument_list|(
name|EbtFloat
argument_list|,
literal|4
argument_list|)
else|:
name|rvalue
argument_list|,
name|name
argument_list|,
operator|new
name|TType
argument_list|(
name|EbtSampler2D
argument_list|)
argument_list|,
name|ptype2
argument_list|,
name|ptype3
argument_list|,
name|ptype4
argument_list|,
name|ptype5
argument_list|)
expr_stmt|;
name|insertBuiltIn
argument_list|(
name|level
argument_list|,
name|gvec4
condition|?
operator|new
name|TType
argument_list|(
name|EbtInt
argument_list|,
literal|4
argument_list|)
else|:
name|rvalue
argument_list|,
name|name
argument_list|,
operator|new
name|TType
argument_list|(
name|EbtISampler2D
argument_list|)
argument_list|,
name|ptype2
argument_list|,
name|ptype3
argument_list|,
name|ptype4
argument_list|,
name|ptype5
argument_list|)
expr_stmt|;
name|insertBuiltIn
argument_list|(
name|level
argument_list|,
name|gvec4
condition|?
operator|new
name|TType
argument_list|(
name|EbtUInt
argument_list|,
literal|4
argument_list|)
else|:
name|rvalue
argument_list|,
name|name
argument_list|,
operator|new
name|TType
argument_list|(
name|EbtUSampler2D
argument_list|)
argument_list|,
name|ptype2
argument_list|,
name|ptype3
argument_list|,
name|ptype4
argument_list|,
name|ptype5
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ptype1
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtGSampler3D
condition|)
block|{
name|bool
name|gvec4
init|=
operator|(
name|rvalue
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtGVec4
operator|)
decl_stmt|;
name|insertBuiltIn
argument_list|(
name|level
argument_list|,
name|gvec4
condition|?
operator|new
name|TType
argument_list|(
name|EbtFloat
argument_list|,
literal|4
argument_list|)
else|:
name|rvalue
argument_list|,
name|name
argument_list|,
operator|new
name|TType
argument_list|(
name|EbtSampler3D
argument_list|)
argument_list|,
name|ptype2
argument_list|,
name|ptype3
argument_list|,
name|ptype4
argument_list|,
name|ptype5
argument_list|)
expr_stmt|;
name|insertBuiltIn
argument_list|(
name|level
argument_list|,
name|gvec4
condition|?
operator|new
name|TType
argument_list|(
name|EbtInt
argument_list|,
literal|4
argument_list|)
else|:
name|rvalue
argument_list|,
name|name
argument_list|,
operator|new
name|TType
argument_list|(
name|EbtISampler3D
argument_list|)
argument_list|,
name|ptype2
argument_list|,
name|ptype3
argument_list|,
name|ptype4
argument_list|,
name|ptype5
argument_list|)
expr_stmt|;
name|insertBuiltIn
argument_list|(
name|level
argument_list|,
name|gvec4
condition|?
operator|new
name|TType
argument_list|(
name|EbtUInt
argument_list|,
literal|4
argument_list|)
else|:
name|rvalue
argument_list|,
name|name
argument_list|,
operator|new
name|TType
argument_list|(
name|EbtUSampler3D
argument_list|)
argument_list|,
name|ptype2
argument_list|,
name|ptype3
argument_list|,
name|ptype4
argument_list|,
name|ptype5
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ptype1
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtGSamplerCube
condition|)
block|{
name|bool
name|gvec4
init|=
operator|(
name|rvalue
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtGVec4
operator|)
decl_stmt|;
name|insertBuiltIn
argument_list|(
name|level
argument_list|,
name|gvec4
condition|?
operator|new
name|TType
argument_list|(
name|EbtFloat
argument_list|,
literal|4
argument_list|)
else|:
name|rvalue
argument_list|,
name|name
argument_list|,
operator|new
name|TType
argument_list|(
name|EbtSamplerCube
argument_list|)
argument_list|,
name|ptype2
argument_list|,
name|ptype3
argument_list|,
name|ptype4
argument_list|,
name|ptype5
argument_list|)
expr_stmt|;
name|insertBuiltIn
argument_list|(
name|level
argument_list|,
name|gvec4
condition|?
operator|new
name|TType
argument_list|(
name|EbtInt
argument_list|,
literal|4
argument_list|)
else|:
name|rvalue
argument_list|,
name|name
argument_list|,
operator|new
name|TType
argument_list|(
name|EbtISamplerCube
argument_list|)
argument_list|,
name|ptype2
argument_list|,
name|ptype3
argument_list|,
name|ptype4
argument_list|,
name|ptype5
argument_list|)
expr_stmt|;
name|insertBuiltIn
argument_list|(
name|level
argument_list|,
name|gvec4
condition|?
operator|new
name|TType
argument_list|(
name|EbtUInt
argument_list|,
literal|4
argument_list|)
else|:
name|rvalue
argument_list|,
name|name
argument_list|,
operator|new
name|TType
argument_list|(
name|EbtUSamplerCube
argument_list|)
argument_list|,
name|ptype2
argument_list|,
name|ptype3
argument_list|,
name|ptype4
argument_list|,
name|ptype5
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ptype1
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtGSampler2DArray
condition|)
block|{
name|bool
name|gvec4
init|=
operator|(
name|rvalue
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtGVec4
operator|)
decl_stmt|;
name|insertBuiltIn
argument_list|(
name|level
argument_list|,
name|gvec4
condition|?
operator|new
name|TType
argument_list|(
name|EbtFloat
argument_list|,
literal|4
argument_list|)
else|:
name|rvalue
argument_list|,
name|name
argument_list|,
operator|new
name|TType
argument_list|(
name|EbtSampler2DArray
argument_list|)
argument_list|,
name|ptype2
argument_list|,
name|ptype3
argument_list|,
name|ptype4
argument_list|,
name|ptype5
argument_list|)
expr_stmt|;
name|insertBuiltIn
argument_list|(
name|level
argument_list|,
name|gvec4
condition|?
operator|new
name|TType
argument_list|(
name|EbtInt
argument_list|,
literal|4
argument_list|)
else|:
name|rvalue
argument_list|,
name|name
argument_list|,
operator|new
name|TType
argument_list|(
name|EbtISampler2DArray
argument_list|)
argument_list|,
name|ptype2
argument_list|,
name|ptype3
argument_list|,
name|ptype4
argument_list|,
name|ptype5
argument_list|)
expr_stmt|;
name|insertBuiltIn
argument_list|(
name|level
argument_list|,
name|gvec4
condition|?
operator|new
name|TType
argument_list|(
name|EbtUInt
argument_list|,
literal|4
argument_list|)
else|:
name|rvalue
argument_list|,
name|name
argument_list|,
operator|new
name|TType
argument_list|(
name|EbtUSampler2DArray
argument_list|)
argument_list|,
name|ptype2
argument_list|,
name|ptype3
argument_list|,
name|ptype4
argument_list|,
name|ptype5
argument_list|)
expr_stmt|;
return|return;
block|}
name|TFunction
modifier|*
name|function
init|=
operator|new
name|TFunction
argument_list|(
name|NewPoolTString
argument_list|(
name|name
argument_list|)
argument_list|,
operator|*
name|rvalue
argument_list|)
decl_stmt|;
name|TType
modifier|*
name|types
index|[]
init|=
block|{
name|ptype1
block|,
name|ptype2
block|,
name|ptype3
block|,
name|ptype4
block|,
name|ptype5
block|}
decl_stmt|;
for|for
control|(
name|size_t
name|ii
init|=
literal|0
init|;
name|ii
operator|<
sizeof|sizeof
argument_list|(
name|types
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|types
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|ii
control|)
block|{
if|if
condition|(
name|types
index|[
name|ii
index|]
condition|)
block|{
name|TParameter
name|param
init|=
block|{
name|NULL
block|,
name|types
index|[
name|ii
index|]
block|}
decl_stmt|;
name|function
operator|->
name|addParameter
argument_list|(
name|param
argument_list|)
expr_stmt|;
block|}
block|}
name|insert
argument_list|(
name|level
argument_list|,
name|function
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|getDefaultPrecision
name|TPrecision
name|TSymbolTable
operator|::
name|getDefaultPrecision
parameter_list|(
name|TBasicType
name|type
parameter_list|)
block|{
if|if
condition|(
operator|!
name|SupportsPrecision
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|EbpUndefined
return|;
comment|// unsigned integers use the same precision as signed
name|TBasicType
name|baseType
init|=
operator|(
name|type
operator|==
name|EbtUInt
operator|)
condition|?
name|EbtInt
else|:
name|type
decl_stmt|;
name|int
name|level
init|=
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|precisionStack
operator|.
name|size
argument_list|()
argument_list|)
operator|-
literal|1
decl_stmt|;
name|assert
argument_list|(
name|level
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|// Just to be safe. Should not happen.
comment|// If we dont find anything we return this. Should we error check this?
name|TPrecision
name|prec
init|=
name|EbpUndefined
decl_stmt|;
while|while
condition|(
name|level
operator|>=
literal|0
condition|)
block|{
name|PrecisionStackLevel
operator|::
name|iterator
name|it
init|=
name|precisionStack
index|[
name|level
index|]
operator|->
name|find
argument_list|(
name|baseType
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|precisionStack
index|[
name|level
index|]
operator|->
name|end
argument_list|()
condition|)
block|{
name|prec
operator|=
operator|(
operator|*
name|it
operator|)
operator|.
name|second
expr_stmt|;
break|break;
block|}
name|level
operator|--
expr_stmt|;
block|}
return|return
name|prec
return|;
block|}
end_function
end_unit
