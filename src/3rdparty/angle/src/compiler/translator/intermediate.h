begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Definition of the in-memory high-level intermediate representation
end_comment
begin_comment
comment|// of shaders.  This is a tree that parser creates.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Nodes in the tree are defined as a hierarchy of classes derived from
end_comment
begin_comment
comment|// TIntermNode. Each is a node in a tree.  There is no preset branching factor;
end_comment
begin_comment
comment|// each node can have it's own type of list of children.
end_comment
begin_comment
comment|//
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|COMPILER_TRANSLATOR_INTERMEDIATE_H_
end_ifndef
begin_define
DECL|macro|COMPILER_TRANSLATOR_INTERMEDIATE_H_
define|#
directive|define
name|COMPILER_TRANSLATOR_INTERMEDIATE_H_
end_define
begin_include
include|#
directive|include
file|"GLSLANG/ShaderLang.h"
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_include
include|#
directive|include
file|<queue>
end_include
begin_include
include|#
directive|include
file|"compiler/translator/Common.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/Types.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/ConstantUnion.h"
end_include
begin_comment
comment|//
end_comment
begin_comment
comment|// Operators used by the high-level (parse tree) representation.
end_comment
begin_comment
comment|//
end_comment
begin_enum
DECL|enum|TOperator
enum|enum
name|TOperator
block|{
DECL|enumerator|EOpNull
name|EOpNull
block|,
comment|// if in a node, should only mean a node is still being built
DECL|enumerator|EOpSequence
name|EOpSequence
block|,
comment|// denotes a list of statements, or parameters, etc.
DECL|enumerator|EOpFunctionCall
name|EOpFunctionCall
block|,
DECL|enumerator|EOpFunction
name|EOpFunction
block|,
comment|// For function definition
DECL|enumerator|EOpParameters
name|EOpParameters
block|,
comment|// an aggregate listing the parameters to a function
DECL|enumerator|EOpDeclaration
name|EOpDeclaration
block|,
DECL|enumerator|EOpPrototype
name|EOpPrototype
block|,
comment|//
comment|// Unary operators
comment|//
DECL|enumerator|EOpNegative
name|EOpNegative
block|,
DECL|enumerator|EOpLogicalNot
name|EOpLogicalNot
block|,
DECL|enumerator|EOpVectorLogicalNot
name|EOpVectorLogicalNot
block|,
DECL|enumerator|EOpPostIncrement
name|EOpPostIncrement
block|,
DECL|enumerator|EOpPostDecrement
name|EOpPostDecrement
block|,
DECL|enumerator|EOpPreIncrement
name|EOpPreIncrement
block|,
DECL|enumerator|EOpPreDecrement
name|EOpPreDecrement
block|,
comment|//
comment|// binary operations
comment|//
DECL|enumerator|EOpAdd
name|EOpAdd
block|,
DECL|enumerator|EOpSub
name|EOpSub
block|,
DECL|enumerator|EOpMul
name|EOpMul
block|,
DECL|enumerator|EOpDiv
name|EOpDiv
block|,
DECL|enumerator|EOpEqual
name|EOpEqual
block|,
DECL|enumerator|EOpNotEqual
name|EOpNotEqual
block|,
DECL|enumerator|EOpVectorEqual
name|EOpVectorEqual
block|,
DECL|enumerator|EOpVectorNotEqual
name|EOpVectorNotEqual
block|,
DECL|enumerator|EOpLessThan
name|EOpLessThan
block|,
DECL|enumerator|EOpGreaterThan
name|EOpGreaterThan
block|,
DECL|enumerator|EOpLessThanEqual
name|EOpLessThanEqual
block|,
DECL|enumerator|EOpGreaterThanEqual
name|EOpGreaterThanEqual
block|,
DECL|enumerator|EOpComma
name|EOpComma
block|,
DECL|enumerator|EOpVectorTimesScalar
name|EOpVectorTimesScalar
block|,
DECL|enumerator|EOpVectorTimesMatrix
name|EOpVectorTimesMatrix
block|,
DECL|enumerator|EOpMatrixTimesVector
name|EOpMatrixTimesVector
block|,
DECL|enumerator|EOpMatrixTimesScalar
name|EOpMatrixTimesScalar
block|,
DECL|enumerator|EOpLogicalOr
name|EOpLogicalOr
block|,
DECL|enumerator|EOpLogicalXor
name|EOpLogicalXor
block|,
DECL|enumerator|EOpLogicalAnd
name|EOpLogicalAnd
block|,
DECL|enumerator|EOpIndexDirect
name|EOpIndexDirect
block|,
DECL|enumerator|EOpIndexIndirect
name|EOpIndexIndirect
block|,
DECL|enumerator|EOpIndexDirectStruct
name|EOpIndexDirectStruct
block|,
DECL|enumerator|EOpIndexDirectInterfaceBlock
name|EOpIndexDirectInterfaceBlock
block|,
DECL|enumerator|EOpVectorSwizzle
name|EOpVectorSwizzle
block|,
comment|//
comment|// Built-in functions potentially mapped to operators
comment|//
DECL|enumerator|EOpRadians
name|EOpRadians
block|,
DECL|enumerator|EOpDegrees
name|EOpDegrees
block|,
DECL|enumerator|EOpSin
name|EOpSin
block|,
DECL|enumerator|EOpCos
name|EOpCos
block|,
DECL|enumerator|EOpTan
name|EOpTan
block|,
DECL|enumerator|EOpAsin
name|EOpAsin
block|,
DECL|enumerator|EOpAcos
name|EOpAcos
block|,
DECL|enumerator|EOpAtan
name|EOpAtan
block|,
DECL|enumerator|EOpPow
name|EOpPow
block|,
DECL|enumerator|EOpExp
name|EOpExp
block|,
DECL|enumerator|EOpLog
name|EOpLog
block|,
DECL|enumerator|EOpExp2
name|EOpExp2
block|,
DECL|enumerator|EOpLog2
name|EOpLog2
block|,
DECL|enumerator|EOpSqrt
name|EOpSqrt
block|,
DECL|enumerator|EOpInverseSqrt
name|EOpInverseSqrt
block|,
DECL|enumerator|EOpAbs
name|EOpAbs
block|,
DECL|enumerator|EOpSign
name|EOpSign
block|,
DECL|enumerator|EOpFloor
name|EOpFloor
block|,
DECL|enumerator|EOpCeil
name|EOpCeil
block|,
DECL|enumerator|EOpFract
name|EOpFract
block|,
DECL|enumerator|EOpMod
name|EOpMod
block|,
DECL|enumerator|EOpMin
name|EOpMin
block|,
DECL|enumerator|EOpMax
name|EOpMax
block|,
DECL|enumerator|EOpClamp
name|EOpClamp
block|,
DECL|enumerator|EOpMix
name|EOpMix
block|,
DECL|enumerator|EOpStep
name|EOpStep
block|,
DECL|enumerator|EOpSmoothStep
name|EOpSmoothStep
block|,
DECL|enumerator|EOpLength
name|EOpLength
block|,
DECL|enumerator|EOpDistance
name|EOpDistance
block|,
DECL|enumerator|EOpDot
name|EOpDot
block|,
DECL|enumerator|EOpCross
name|EOpCross
block|,
DECL|enumerator|EOpNormalize
name|EOpNormalize
block|,
DECL|enumerator|EOpFaceForward
name|EOpFaceForward
block|,
DECL|enumerator|EOpReflect
name|EOpReflect
block|,
DECL|enumerator|EOpRefract
name|EOpRefract
block|,
DECL|enumerator|EOpDFdx
name|EOpDFdx
block|,
comment|// Fragment only, OES_standard_derivatives extension
DECL|enumerator|EOpDFdy
name|EOpDFdy
block|,
comment|// Fragment only, OES_standard_derivatives extension
DECL|enumerator|EOpFwidth
name|EOpFwidth
block|,
comment|// Fragment only, OES_standard_derivatives extension
DECL|enumerator|EOpMatrixTimesMatrix
name|EOpMatrixTimesMatrix
block|,
DECL|enumerator|EOpAny
name|EOpAny
block|,
DECL|enumerator|EOpAll
name|EOpAll
block|,
comment|//
comment|// Branch
comment|//
DECL|enumerator|EOpKill
name|EOpKill
block|,
comment|// Fragment only
DECL|enumerator|EOpReturn
name|EOpReturn
block|,
DECL|enumerator|EOpBreak
name|EOpBreak
block|,
DECL|enumerator|EOpContinue
name|EOpContinue
block|,
comment|//
comment|// Constructors
comment|//
DECL|enumerator|EOpConstructInt
name|EOpConstructInt
block|,
DECL|enumerator|EOpConstructUInt
name|EOpConstructUInt
block|,
DECL|enumerator|EOpConstructBool
name|EOpConstructBool
block|,
DECL|enumerator|EOpConstructFloat
name|EOpConstructFloat
block|,
DECL|enumerator|EOpConstructVec2
name|EOpConstructVec2
block|,
DECL|enumerator|EOpConstructVec3
name|EOpConstructVec3
block|,
DECL|enumerator|EOpConstructVec4
name|EOpConstructVec4
block|,
DECL|enumerator|EOpConstructBVec2
name|EOpConstructBVec2
block|,
DECL|enumerator|EOpConstructBVec3
name|EOpConstructBVec3
block|,
DECL|enumerator|EOpConstructBVec4
name|EOpConstructBVec4
block|,
DECL|enumerator|EOpConstructIVec2
name|EOpConstructIVec2
block|,
DECL|enumerator|EOpConstructIVec3
name|EOpConstructIVec3
block|,
DECL|enumerator|EOpConstructIVec4
name|EOpConstructIVec4
block|,
DECL|enumerator|EOpConstructUVec2
name|EOpConstructUVec2
block|,
DECL|enumerator|EOpConstructUVec3
name|EOpConstructUVec3
block|,
DECL|enumerator|EOpConstructUVec4
name|EOpConstructUVec4
block|,
DECL|enumerator|EOpConstructMat2
name|EOpConstructMat2
block|,
DECL|enumerator|EOpConstructMat3
name|EOpConstructMat3
block|,
DECL|enumerator|EOpConstructMat4
name|EOpConstructMat4
block|,
DECL|enumerator|EOpConstructStruct
name|EOpConstructStruct
block|,
comment|//
comment|// moves
comment|//
DECL|enumerator|EOpAssign
name|EOpAssign
block|,
DECL|enumerator|EOpInitialize
name|EOpInitialize
block|,
DECL|enumerator|EOpAddAssign
name|EOpAddAssign
block|,
DECL|enumerator|EOpSubAssign
name|EOpSubAssign
block|,
DECL|enumerator|EOpMulAssign
name|EOpMulAssign
block|,
DECL|enumerator|EOpVectorTimesMatrixAssign
name|EOpVectorTimesMatrixAssign
block|,
DECL|enumerator|EOpVectorTimesScalarAssign
name|EOpVectorTimesScalarAssign
block|,
DECL|enumerator|EOpMatrixTimesScalarAssign
name|EOpMatrixTimesScalarAssign
block|,
DECL|enumerator|EOpMatrixTimesMatrixAssign
name|EOpMatrixTimesMatrixAssign
block|,
DECL|enumerator|EOpDivAssign
name|EOpDivAssign
block|}
enum|;
end_enum
begin_decl_stmt
DECL|variable|TIntermTraverser
name|class
name|TIntermTraverser
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermAggregate
name|class
name|TIntermAggregate
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermBinary
name|class
name|TIntermBinary
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermUnary
name|class
name|TIntermUnary
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermConstantUnion
name|class
name|TIntermConstantUnion
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermSelection
name|class
name|TIntermSelection
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermTyped
name|class
name|TIntermTyped
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermSymbol
name|class
name|TIntermSymbol
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermLoop
name|class
name|TIntermLoop
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TInfoSink
name|class
name|TInfoSink
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermRaw
name|class
name|TIntermRaw
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// Base class for the tree nodes
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermNode
block|{
name|public
label|:
name|POOL_ALLOCATOR_NEW_DELETE
argument_list|()
expr_stmt|;
name|TIntermNode
argument_list|()
block|{
comment|// TODO: Move this to TSourceLoc constructor
comment|// after getting rid of TPublicType.
name|mLine
operator|.
name|first_file
operator|=
name|mLine
operator|.
name|last_file
operator|=
literal|0
expr_stmt|;
name|mLine
operator|.
name|first_line
operator|=
name|mLine
operator|.
name|last_line
operator|=
literal|0
expr_stmt|;
block|}
name|virtual
operator|~
name|TIntermNode
argument_list|()
block|{ }
specifier|const
name|TSourceLoc
operator|&
name|getLine
argument_list|()
specifier|const
block|{
return|return
name|mLine
return|;
block|}
name|void
name|setLine
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|l
parameter_list|)
block|{
name|mLine
operator|=
name|l
expr_stmt|;
block|}
name|virtual
name|void
name|traverse
parameter_list|(
name|TIntermTraverser
modifier|*
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|TIntermTyped
modifier|*
name|getAsTyped
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
name|virtual
name|TIntermConstantUnion
modifier|*
name|getAsConstantUnion
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
name|virtual
name|TIntermAggregate
modifier|*
name|getAsAggregate
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
name|virtual
name|TIntermBinary
modifier|*
name|getAsBinaryNode
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
name|virtual
name|TIntermUnary
modifier|*
name|getAsUnaryNode
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
name|virtual
name|TIntermSelection
modifier|*
name|getAsSelectionNode
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
name|virtual
name|TIntermSymbol
modifier|*
name|getAsSymbolNode
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
name|virtual
name|TIntermLoop
modifier|*
name|getAsLoopNode
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
name|virtual
name|TIntermRaw
modifier|*
name|getAsRawNode
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
comment|// Replace a child node. Return true if |original| is a child
comment|// node and it is replaced; otherwise, return false.
name|virtual
name|bool
name|replaceChildNode
parameter_list|(
name|TIntermNode
modifier|*
name|original
parameter_list|,
name|TIntermNode
modifier|*
name|replacement
parameter_list|)
init|=
literal|0
function_decl|;
comment|// For traversing a tree in no particular order, but using
comment|// heap memory.
name|virtual
name|void
name|enqueueChildren
argument_list|(
name|std
operator|::
name|queue
operator|<
name|TIntermNode
operator|*
operator|>
operator|*
name|nodeQueue
argument_list|)
decl|const
init|=
literal|0
decl_stmt|;
name|protected
label|:
name|TSourceLoc
name|mLine
decl_stmt|;
block|}
end_decl_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// This is just to help yacc.
end_comment
begin_comment
comment|//
end_comment
begin_struct
DECL|struct|TIntermNodePair
struct|struct
name|TIntermNodePair
block|{
DECL|member|node1
name|TIntermNode
modifier|*
name|node1
decl_stmt|;
DECL|member|node2
name|TIntermNode
modifier|*
name|node2
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|//
end_comment
begin_comment
comment|// Intermediate class for nodes that have a type.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermTyped
range|:
name|public
name|TIntermNode
block|{
name|public
operator|:
name|TIntermTyped
argument_list|(
specifier|const
name|TType
operator|&
name|t
argument_list|)
operator|:
name|mType
argument_list|(
argument|t
argument_list|)
block|{ }
name|virtual
name|TIntermTyped
operator|*
name|getAsTyped
argument_list|()
block|{
return|return
name|this
return|;
block|}
name|virtual
name|bool
name|hasSideEffects
argument_list|()
specifier|const
operator|=
literal|0
block|;
name|void
name|setType
argument_list|(
argument|const TType&t
argument_list|)
block|{
name|mType
operator|=
name|t
block|; }
specifier|const
name|TType
operator|&
name|getType
argument_list|()
specifier|const
block|{
return|return
name|mType
return|;
block|}
name|TType
operator|*
name|getTypePointer
argument_list|()
block|{
return|return
operator|&
name|mType
return|;
block|}
name|TBasicType
name|getBasicType
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|getBasicType
argument_list|()
return|;
block|}
name|TQualifier
name|getQualifier
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|getQualifier
argument_list|()
return|;
block|}
name|TPrecision
name|getPrecision
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|getPrecision
argument_list|()
return|;
block|}
name|int
name|getCols
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|getCols
argument_list|()
return|;
block|}
name|int
name|getRows
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|getRows
argument_list|()
return|;
block|}
name|int
name|getNominalSize
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|getNominalSize
argument_list|()
return|;
block|}
name|int
name|getSecondarySize
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|getSecondarySize
argument_list|()
return|;
block|}
name|bool
name|isInterfaceBlock
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|isInterfaceBlock
argument_list|()
return|;
block|}
name|bool
name|isMatrix
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|isMatrix
argument_list|()
return|;
block|}
name|bool
name|isArray
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|isArray
argument_list|()
return|;
block|}
name|bool
name|isVector
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|isVector
argument_list|()
return|;
block|}
name|bool
name|isScalar
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|isScalar
argument_list|()
return|;
block|}
name|bool
name|isScalarInt
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|isScalarInt
argument_list|()
return|;
block|}
specifier|const
name|char
operator|*
name|getBasicString
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|getBasicString
argument_list|()
return|;
block|}
specifier|const
name|char
operator|*
name|getQualifierString
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|getQualifierString
argument_list|()
return|;
block|}
name|TString
name|getCompleteString
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|getCompleteString
argument_list|()
return|;
block|}
name|int
name|getArraySize
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|getArraySize
argument_list|()
return|;
block|}
name|protected
operator|:
name|TType
name|mType
block|; }
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// Handle for, do-while, and while loops.
end_comment
begin_comment
comment|//
end_comment
begin_enum
DECL|enum|TLoopType
enum|enum
name|TLoopType
block|{
DECL|enumerator|ELoopFor
name|ELoopFor
block|,
DECL|enumerator|ELoopWhile
name|ELoopWhile
block|,
DECL|enumerator|ELoopDoWhile
name|ELoopDoWhile
block|}
enum|;
end_enum
begin_decl_stmt
name|class
name|TIntermLoop
range|:
name|public
name|TIntermNode
block|{
name|public
operator|:
name|TIntermLoop
argument_list|(
argument|TLoopType type
argument_list|,
argument|TIntermNode *init
argument_list|,
argument|TIntermTyped *cond
argument_list|,
argument|TIntermTyped *expr
argument_list|,
argument|TIntermNode *body
argument_list|)
operator|:
name|mType
argument_list|(
name|type
argument_list|)
block|,
name|mInit
argument_list|(
name|init
argument_list|)
block|,
name|mCond
argument_list|(
name|cond
argument_list|)
block|,
name|mExpr
argument_list|(
name|expr
argument_list|)
block|,
name|mBody
argument_list|(
name|body
argument_list|)
block|,
name|mUnrollFlag
argument_list|(
argument|false
argument_list|)
block|{ }
name|virtual
name|TIntermLoop
operator|*
name|getAsLoopNode
argument_list|()
block|{
return|return
name|this
return|;
block|}
name|virtual
name|void
name|traverse
argument_list|(
name|TIntermTraverser
operator|*
argument_list|)
block|;
name|virtual
name|bool
name|replaceChildNode
argument_list|(
name|TIntermNode
operator|*
name|original
argument_list|,
name|TIntermNode
operator|*
name|replacement
argument_list|)
block|;
name|TLoopType
name|getType
argument_list|()
specifier|const
block|{
return|return
name|mType
return|;
block|}
name|TIntermNode
operator|*
name|getInit
argument_list|()
block|{
return|return
name|mInit
return|;
block|}
name|TIntermTyped
operator|*
name|getCondition
argument_list|()
block|{
return|return
name|mCond
return|;
block|}
name|TIntermTyped
operator|*
name|getExpression
argument_list|()
block|{
return|return
name|mExpr
return|;
block|}
name|TIntermNode
operator|*
name|getBody
argument_list|()
block|{
return|return
name|mBody
return|;
block|}
name|void
name|setUnrollFlag
argument_list|(
argument|bool flag
argument_list|)
block|{
name|mUnrollFlag
operator|=
name|flag
block|; }
name|bool
name|getUnrollFlag
argument_list|()
specifier|const
block|{
return|return
name|mUnrollFlag
return|;
block|}
name|virtual
name|void
name|enqueueChildren
argument_list|(
argument|std::queue<TIntermNode *> *nodeQueue
argument_list|)
specifier|const
block|;
name|protected
operator|:
name|TLoopType
name|mType
block|;
name|TIntermNode
operator|*
name|mInit
block|;
comment|// for-loop initialization
name|TIntermTyped
operator|*
name|mCond
block|;
comment|// loop exit condition
name|TIntermTyped
operator|*
name|mExpr
block|;
comment|// for-loop expression
name|TIntermNode
operator|*
name|mBody
block|;
comment|// loop body
name|bool
name|mUnrollFlag
block|;
comment|// Whether the loop should be unrolled or not.
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// Handle break, continue, return, and kill.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermBranch
range|:
name|public
name|TIntermNode
block|{
name|public
operator|:
name|TIntermBranch
argument_list|(
argument|TOperator op
argument_list|,
argument|TIntermTyped *e
argument_list|)
operator|:
name|mFlowOp
argument_list|(
name|op
argument_list|)
block|,
name|mExpression
argument_list|(
argument|e
argument_list|)
block|{ }
name|virtual
name|void
name|traverse
argument_list|(
name|TIntermTraverser
operator|*
argument_list|)
block|;
name|virtual
name|bool
name|replaceChildNode
argument_list|(
name|TIntermNode
operator|*
name|original
argument_list|,
name|TIntermNode
operator|*
name|replacement
argument_list|)
block|;
name|TOperator
name|getFlowOp
argument_list|()
block|{
return|return
name|mFlowOp
return|;
block|}
name|TIntermTyped
operator|*
name|getExpression
argument_list|()
block|{
return|return
name|mExpression
return|;
block|}
name|virtual
name|void
name|enqueueChildren
argument_list|(
argument|std::queue<TIntermNode *> *nodeQueue
argument_list|)
specifier|const
block|;
name|protected
operator|:
name|TOperator
name|mFlowOp
block|;
name|TIntermTyped
operator|*
name|mExpression
block|;
comment|// non-zero except for "return exp;" statements
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// Nodes that correspond to symbols or constants in the source code.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermSymbol
range|:
name|public
name|TIntermTyped
block|{
name|public
operator|:
comment|// if symbol is initialized as symbol(sym), the memory comes from the poolallocator of sym.
comment|// If sym comes from per process globalpoolallocator, then it causes increased memory usage
comment|// per compile it is essential to use "symbol = sym" to assign to symbol
name|TIntermSymbol
argument_list|(
argument|int id
argument_list|,
argument|const TString&symbol
argument_list|,
argument|const TType&type
argument_list|)
operator|:
name|TIntermTyped
argument_list|(
name|type
argument_list|)
block|,
name|mId
argument_list|(
argument|id
argument_list|)
block|{
name|mSymbol
operator|=
name|symbol
block|;     }
name|virtual
name|bool
name|hasSideEffects
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|int
name|getId
argument_list|()
specifier|const
block|{
return|return
name|mId
return|;
block|}
specifier|const
name|TString
operator|&
name|getSymbol
argument_list|()
specifier|const
block|{
return|return
name|mSymbol
return|;
block|}
name|void
name|setId
argument_list|(
argument|int newId
argument_list|)
block|{
name|mId
operator|=
name|newId
block|; }
name|virtual
name|void
name|traverse
argument_list|(
name|TIntermTraverser
operator|*
argument_list|)
block|;
name|virtual
name|TIntermSymbol
operator|*
name|getAsSymbolNode
argument_list|()
block|{
return|return
name|this
return|;
block|}
name|virtual
name|bool
name|replaceChildNode
argument_list|(
argument|TIntermNode *
argument_list|,
argument|TIntermNode *
argument_list|)
block|{
return|return
name|false
return|;
block|}
name|virtual
name|void
name|enqueueChildren
argument_list|(
argument|std::queue<TIntermNode *> *nodeQueue
argument_list|)
specifier|const
block|{}
name|protected
operator|:
name|int
name|mId
block|;
name|TString
name|mSymbol
block|; }
decl_stmt|;
end_decl_stmt
begin_comment
comment|// A Raw node stores raw code, that the translator will insert verbatim
end_comment
begin_comment
comment|// into the output stream. Useful for transformation operations that make
end_comment
begin_comment
comment|// complex code that might not fit naturally into the GLSL model.
end_comment
begin_decl_stmt
name|class
name|TIntermRaw
range|:
name|public
name|TIntermTyped
block|{
name|public
operator|:
name|TIntermRaw
argument_list|(
specifier|const
name|TType
operator|&
name|type
argument_list|,
specifier|const
name|TString
operator|&
name|rawText
argument_list|)
operator|:
name|TIntermTyped
argument_list|(
name|type
argument_list|)
block|,
name|mRawText
argument_list|(
argument|rawText
argument_list|)
block|{ }
name|virtual
name|bool
name|hasSideEffects
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|TString
name|getRawText
argument_list|()
specifier|const
block|{
return|return
name|mRawText
return|;
block|}
name|virtual
name|void
name|traverse
argument_list|(
name|TIntermTraverser
operator|*
argument_list|)
block|;
name|virtual
name|TIntermRaw
operator|*
name|getAsRawNode
argument_list|()
block|{
return|return
name|this
return|;
block|}
name|virtual
name|bool
name|replaceChildNode
argument_list|(
argument|TIntermNode *
argument_list|,
argument|TIntermNode *
argument_list|)
block|{
return|return
name|false
return|;
block|}
name|virtual
name|void
name|enqueueChildren
argument_list|(
argument|std::queue<TIntermNode *> *nodeQueue
argument_list|)
specifier|const
block|{}
name|protected
operator|:
name|TString
name|mRawText
block|; }
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|class
name|TIntermConstantUnion
range|:
name|public
name|TIntermTyped
block|{
name|public
operator|:
name|TIntermConstantUnion
argument_list|(
name|ConstantUnion
operator|*
name|unionPointer
argument_list|,
specifier|const
name|TType
operator|&
name|type
argument_list|)
operator|:
name|TIntermTyped
argument_list|(
name|type
argument_list|)
block|,
name|mUnionArrayPointer
argument_list|(
argument|unionPointer
argument_list|)
block|{ }
name|virtual
name|bool
name|hasSideEffects
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|ConstantUnion
operator|*
name|getUnionArrayPointer
argument_list|()
specifier|const
block|{
return|return
name|mUnionArrayPointer
return|;
block|}
name|int
name|getIConst
argument_list|(
argument|size_t index
argument_list|)
specifier|const
block|{
return|return
name|mUnionArrayPointer
operator|?
name|mUnionArrayPointer
index|[
name|index
index|]
operator|.
name|getIConst
argument_list|()
operator|:
literal|0
return|;
block|}
name|unsigned
name|int
name|getUConst
argument_list|(
argument|size_t index
argument_list|)
specifier|const
block|{
return|return
name|mUnionArrayPointer
condition|?
name|mUnionArrayPointer
index|[
name|index
index|]
operator|.
name|getUConst
argument_list|()
else|:
literal|0
return|;
block|}
name|float
name|getFConst
argument_list|(
argument|size_t index
argument_list|)
specifier|const
block|{
return|return
name|mUnionArrayPointer
condition|?
name|mUnionArrayPointer
index|[
name|index
index|]
operator|.
name|getFConst
argument_list|()
else|:
literal|0.0f
return|;
block|}
name|bool
name|getBConst
argument_list|(
argument|size_t index
argument_list|)
specifier|const
block|{
return|return
name|mUnionArrayPointer
condition|?
name|mUnionArrayPointer
index|[
name|index
index|]
operator|.
name|getBConst
argument_list|()
else|:
name|false
return|;
block|}
name|virtual
name|TIntermConstantUnion
operator|*
name|getAsConstantUnion
argument_list|()
block|{
return|return
name|this
return|;
block|}
name|virtual
name|void
name|traverse
argument_list|(
name|TIntermTraverser
operator|*
argument_list|)
block|;
name|virtual
name|bool
name|replaceChildNode
argument_list|(
argument|TIntermNode *
argument_list|,
argument|TIntermNode *
argument_list|)
block|{
return|return
name|false
return|;
block|}
name|TIntermTyped
operator|*
name|fold
argument_list|(
name|TOperator
argument_list|,
name|TIntermTyped
operator|*
argument_list|,
name|TInfoSink
operator|&
argument_list|)
block|;
name|virtual
name|void
name|enqueueChildren
argument_list|(
argument|std::queue<TIntermNode *> *nodeQueue
argument_list|)
specifier|const
block|{}
name|protected
operator|:
name|ConstantUnion
operator|*
name|mUnionArrayPointer
block|; }
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// Intermediate class for node types that hold operators.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermOperator
range|:
name|public
name|TIntermTyped
block|{
name|public
operator|:
name|TOperator
name|getOp
argument_list|()
specifier|const
block|{
return|return
name|mOp
return|;
block|}
name|void
name|setOp
argument_list|(
argument|TOperator op
argument_list|)
block|{
name|mOp
operator|=
name|op
block|; }
name|bool
name|isAssignment
argument_list|()
specifier|const
block|;
name|bool
name|isConstructor
argument_list|()
specifier|const
block|;
name|virtual
name|bool
name|hasSideEffects
argument_list|()
specifier|const
block|{
return|return
name|isAssignment
argument_list|()
return|;
block|}
name|protected
operator|:
name|TIntermOperator
argument_list|(
argument|TOperator op
argument_list|)
operator|:
name|TIntermTyped
argument_list|(
name|TType
argument_list|(
name|EbtFloat
argument_list|,
name|EbpUndefined
argument_list|)
argument_list|)
block|,
name|mOp
argument_list|(
argument|op
argument_list|)
block|{}
name|TIntermOperator
argument_list|(
argument|TOperator op
argument_list|,
argument|const TType&type
argument_list|)
operator|:
name|TIntermTyped
argument_list|(
name|type
argument_list|)
block|,
name|mOp
argument_list|(
argument|op
argument_list|)
block|{}
name|TOperator
name|mOp
block|; }
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// Nodes for all the basic binary math operators.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermBinary
range|:
name|public
name|TIntermOperator
block|{
name|public
operator|:
name|TIntermBinary
argument_list|(
argument|TOperator op
argument_list|)
operator|:
name|TIntermOperator
argument_list|(
name|op
argument_list|)
block|,
name|mAddIndexClamp
argument_list|(
argument|false
argument_list|)
block|{}
name|virtual
name|TIntermBinary
operator|*
name|getAsBinaryNode
argument_list|()
block|{
return|return
name|this
return|;
block|}
name|virtual
name|void
name|traverse
argument_list|(
name|TIntermTraverser
operator|*
argument_list|)
block|;
name|virtual
name|bool
name|replaceChildNode
argument_list|(
name|TIntermNode
operator|*
name|original
argument_list|,
name|TIntermNode
operator|*
name|replacement
argument_list|)
block|;
name|virtual
name|bool
name|hasSideEffects
argument_list|()
specifier|const
block|{
return|return
name|isAssignment
argument_list|()
operator|||
name|mLeft
operator|->
name|hasSideEffects
argument_list|()
operator|||
name|mRight
operator|->
name|hasSideEffects
argument_list|()
return|;
block|}
name|void
name|setLeft
argument_list|(
argument|TIntermTyped *node
argument_list|)
block|{
name|mLeft
operator|=
name|node
block|; }
name|void
name|setRight
argument_list|(
argument|TIntermTyped *node
argument_list|)
block|{
name|mRight
operator|=
name|node
block|; }
name|TIntermTyped
operator|*
name|getLeft
argument_list|()
specifier|const
block|{
return|return
name|mLeft
return|;
block|}
name|TIntermTyped
operator|*
name|getRight
argument_list|()
specifier|const
block|{
return|return
name|mRight
return|;
block|}
name|bool
name|promote
argument_list|(
name|TInfoSink
operator|&
argument_list|)
block|;
name|void
name|setAddIndexClamp
argument_list|()
block|{
name|mAddIndexClamp
operator|=
name|true
block|; }
name|bool
name|getAddIndexClamp
argument_list|()
block|{
return|return
name|mAddIndexClamp
return|;
block|}
name|virtual
name|void
name|enqueueChildren
argument_list|(
argument|std::queue<TIntermNode *> *nodeQueue
argument_list|)
specifier|const
block|;
name|protected
operator|:
name|TIntermTyped
operator|*
name|mLeft
block|;
name|TIntermTyped
operator|*
name|mRight
block|;
comment|// If set to true, wrap any EOpIndexIndirect with a clamp to bounds.
name|bool
name|mAddIndexClamp
block|; }
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// Nodes for unary math operators.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermUnary
range|:
name|public
name|TIntermOperator
block|{
name|public
operator|:
name|TIntermUnary
argument_list|(
argument|TOperator op
argument_list|,
argument|const TType&type
argument_list|)
operator|:
name|TIntermOperator
argument_list|(
name|op
argument_list|,
name|type
argument_list|)
block|,
name|mOperand
argument_list|(
name|NULL
argument_list|)
block|,
name|mUseEmulatedFunction
argument_list|(
argument|false
argument_list|)
block|{}
name|TIntermUnary
argument_list|(
argument|TOperator op
argument_list|)
operator|:
name|TIntermOperator
argument_list|(
name|op
argument_list|)
block|,
name|mOperand
argument_list|(
name|NULL
argument_list|)
block|,
name|mUseEmulatedFunction
argument_list|(
argument|false
argument_list|)
block|{}
name|virtual
name|void
name|traverse
argument_list|(
name|TIntermTraverser
operator|*
argument_list|)
block|;
name|virtual
name|TIntermUnary
operator|*
name|getAsUnaryNode
argument_list|()
block|{
return|return
name|this
return|;
block|}
name|virtual
name|bool
name|replaceChildNode
argument_list|(
name|TIntermNode
operator|*
name|original
argument_list|,
name|TIntermNode
operator|*
name|replacement
argument_list|)
block|;
name|virtual
name|bool
name|hasSideEffects
argument_list|()
specifier|const
block|{
return|return
name|isAssignment
argument_list|()
operator|||
name|mOperand
operator|->
name|hasSideEffects
argument_list|()
return|;
block|}
name|void
name|setOperand
argument_list|(
argument|TIntermTyped *operand
argument_list|)
block|{
name|mOperand
operator|=
name|operand
block|; }
name|TIntermTyped
operator|*
name|getOperand
argument_list|()
block|{
return|return
name|mOperand
return|;
block|}
name|bool
name|promote
argument_list|(
name|TInfoSink
operator|&
argument_list|)
block|;
name|void
name|setUseEmulatedFunction
argument_list|()
block|{
name|mUseEmulatedFunction
operator|=
name|true
block|; }
name|bool
name|getUseEmulatedFunction
argument_list|()
block|{
return|return
name|mUseEmulatedFunction
return|;
block|}
name|virtual
name|void
name|enqueueChildren
argument_list|(
argument|std::queue<TIntermNode *> *nodeQueue
argument_list|)
specifier|const
block|;
name|protected
operator|:
name|TIntermTyped
operator|*
name|mOperand
block|;
comment|// If set to true, replace the built-in function call with an emulated one
comment|// to work around driver bugs.
name|bool
name|mUseEmulatedFunction
block|; }
decl_stmt|;
end_decl_stmt
begin_typedef
DECL|typedef|TIntermSequence
typedef|typedef
name|TVector
operator|<
name|TIntermNode
operator|*
operator|>
name|TIntermSequence
expr_stmt|;
end_typedef
begin_typedef
DECL|typedef|TQualifierList
typedef|typedef
name|TVector
operator|<
name|int
operator|>
name|TQualifierList
expr_stmt|;
end_typedef
begin_comment
comment|//
end_comment
begin_comment
comment|// Nodes that operate on an arbitrary sized set of children.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermAggregate
range|:
name|public
name|TIntermOperator
block|{
name|public
operator|:
name|TIntermAggregate
argument_list|()
operator|:
name|TIntermOperator
argument_list|(
name|EOpNull
argument_list|)
block|,
name|mUserDefined
argument_list|(
name|false
argument_list|)
block|,
name|mUseEmulatedFunction
argument_list|(
argument|false
argument_list|)
block|{ }
name|TIntermAggregate
argument_list|(
argument|TOperator op
argument_list|)
operator|:
name|TIntermOperator
argument_list|(
name|op
argument_list|)
block|,
name|mUseEmulatedFunction
argument_list|(
argument|false
argument_list|)
block|{ }
operator|~
name|TIntermAggregate
argument_list|()
block|{ }
name|virtual
name|TIntermAggregate
operator|*
name|getAsAggregate
argument_list|()
block|{
return|return
name|this
return|;
block|}
name|virtual
name|void
name|traverse
argument_list|(
name|TIntermTraverser
operator|*
argument_list|)
block|;
name|virtual
name|bool
name|replaceChildNode
argument_list|(
name|TIntermNode
operator|*
name|original
argument_list|,
name|TIntermNode
operator|*
name|replacement
argument_list|)
block|;
comment|// Conservatively assume function calls and other aggregate operators have side-effects
name|virtual
name|bool
name|hasSideEffects
argument_list|()
specifier|const
block|{
return|return
name|true
return|;
block|}
name|TIntermSequence
operator|*
name|getSequence
argument_list|()
block|{
return|return
operator|&
name|mSequence
return|;
block|}
name|void
name|setName
argument_list|(
argument|const TString&name
argument_list|)
block|{
name|mName
operator|=
name|name
block|; }
specifier|const
name|TString
operator|&
name|getName
argument_list|()
specifier|const
block|{
return|return
name|mName
return|;
block|}
name|void
name|setUserDefined
argument_list|()
block|{
name|mUserDefined
operator|=
name|true
block|; }
name|bool
name|isUserDefined
argument_list|()
specifier|const
block|{
return|return
name|mUserDefined
return|;
block|}
name|void
name|setOptimize
argument_list|(
argument|bool optimize
argument_list|)
block|{
name|mOptimize
operator|=
name|optimize
block|; }
name|bool
name|getOptimize
argument_list|()
specifier|const
block|{
return|return
name|mOptimize
return|;
block|}
name|void
name|setDebug
argument_list|(
argument|bool debug
argument_list|)
block|{
name|mDebug
operator|=
name|debug
block|; }
name|bool
name|getDebug
argument_list|()
specifier|const
block|{
return|return
name|mDebug
return|;
block|}
name|void
name|setUseEmulatedFunction
argument_list|()
block|{
name|mUseEmulatedFunction
operator|=
name|true
block|; }
name|bool
name|getUseEmulatedFunction
argument_list|()
block|{
return|return
name|mUseEmulatedFunction
return|;
block|}
name|virtual
name|void
name|enqueueChildren
argument_list|(
argument|std::queue<TIntermNode *> *nodeQueue
argument_list|)
specifier|const
block|;
name|protected
operator|:
name|TIntermAggregate
argument_list|(
specifier|const
name|TIntermAggregate
operator|&
argument_list|)
block|;
comment|// disallow copy constructor
name|TIntermAggregate
operator|&
name|operator
operator|=
operator|(
specifier|const
name|TIntermAggregate
operator|&
operator|)
block|;
comment|// disallow assignment operator
name|TIntermSequence
name|mSequence
block|;
name|TString
name|mName
block|;
name|bool
name|mUserDefined
block|;
comment|// used for user defined function names
name|bool
name|mOptimize
block|;
name|bool
name|mDebug
block|;
comment|// If set to true, replace the built-in function call with an emulated one
comment|// to work around driver bugs.
name|bool
name|mUseEmulatedFunction
block|; }
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// For if tests.  Simplified since there is no switch statement.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermSelection
range|:
name|public
name|TIntermTyped
block|{
name|public
operator|:
name|TIntermSelection
argument_list|(
name|TIntermTyped
operator|*
name|cond
argument_list|,
name|TIntermNode
operator|*
name|trueB
argument_list|,
name|TIntermNode
operator|*
name|falseB
argument_list|)
operator|:
name|TIntermTyped
argument_list|(
name|TType
argument_list|(
name|EbtVoid
argument_list|,
name|EbpUndefined
argument_list|)
argument_list|)
block|,
name|mCondition
argument_list|(
name|cond
argument_list|)
block|,
name|mTrueBlock
argument_list|(
name|trueB
argument_list|)
block|,
name|mFalseBlock
argument_list|(
argument|falseB
argument_list|)
block|{}
name|TIntermSelection
argument_list|(
name|TIntermTyped
operator|*
name|cond
argument_list|,
name|TIntermNode
operator|*
name|trueB
argument_list|,
name|TIntermNode
operator|*
name|falseB
argument_list|,
specifier|const
name|TType
operator|&
name|type
argument_list|)
operator|:
name|TIntermTyped
argument_list|(
name|type
argument_list|)
block|,
name|mCondition
argument_list|(
name|cond
argument_list|)
block|,
name|mTrueBlock
argument_list|(
name|trueB
argument_list|)
block|,
name|mFalseBlock
argument_list|(
argument|falseB
argument_list|)
block|{}
name|virtual
name|void
name|traverse
argument_list|(
name|TIntermTraverser
operator|*
argument_list|)
block|;
name|virtual
name|bool
name|replaceChildNode
argument_list|(
name|TIntermNode
operator|*
name|original
argument_list|,
name|TIntermNode
operator|*
name|replacement
argument_list|)
block|;
comment|// Conservatively assume selections have side-effects
name|virtual
name|bool
name|hasSideEffects
argument_list|()
specifier|const
block|{
return|return
name|true
return|;
block|}
name|bool
name|usesTernaryOperator
argument_list|()
specifier|const
block|{
return|return
name|getBasicType
argument_list|()
operator|!=
name|EbtVoid
return|;
block|}
name|TIntermNode
operator|*
name|getCondition
argument_list|()
specifier|const
block|{
return|return
name|mCondition
return|;
block|}
name|TIntermNode
operator|*
name|getTrueBlock
argument_list|()
specifier|const
block|{
return|return
name|mTrueBlock
return|;
block|}
name|TIntermNode
operator|*
name|getFalseBlock
argument_list|()
specifier|const
block|{
return|return
name|mFalseBlock
return|;
block|}
name|TIntermSelection
operator|*
name|getAsSelectionNode
argument_list|()
block|{
return|return
name|this
return|;
block|}
name|virtual
name|void
name|enqueueChildren
argument_list|(
argument|std::queue<TIntermNode *> *nodeQueue
argument_list|)
specifier|const
block|;
name|protected
operator|:
name|TIntermTyped
operator|*
name|mCondition
block|;
name|TIntermNode
operator|*
name|mTrueBlock
block|;
name|TIntermNode
operator|*
name|mFalseBlock
block|; }
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enum|Visit
enum|enum
name|Visit
block|{
DECL|enumerator|PreVisit
name|PreVisit
block|,
DECL|enumerator|InVisit
name|InVisit
block|,
DECL|enumerator|PostVisit
name|PostVisit
block|}
enum|;
end_enum
begin_comment
comment|//
end_comment
begin_comment
comment|// For traversing the tree.  User should derive from this,
end_comment
begin_comment
comment|// put their traversal specific data in it, and then pass
end_comment
begin_comment
comment|// it to a Traverse method.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// When using this, just fill in the methods for nodes you want visited.
end_comment
begin_comment
comment|// Return false from a pre-visit to skip visiting that node's subtree.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermTraverser
block|{
name|public
label|:
name|POOL_ALLOCATOR_NEW_DELETE
argument_list|()
expr_stmt|;
comment|// TODO(zmo): remove default values.
name|TIntermTraverser
argument_list|(
argument|bool preVisit = true
argument_list|,
argument|bool inVisit = false
argument_list|,
argument|bool postVisit = false
argument_list|,
argument|bool rightToLeft = false
argument_list|)
block|:
name|preVisit
argument_list|(
name|preVisit
argument_list|)
operator|,
name|inVisit
argument_list|(
name|inVisit
argument_list|)
operator|,
name|postVisit
argument_list|(
name|postVisit
argument_list|)
operator|,
name|rightToLeft
argument_list|(
name|rightToLeft
argument_list|)
operator|,
name|mDepth
argument_list|(
literal|0
argument_list|)
operator|,
name|mMaxDepth
argument_list|(
literal|0
argument_list|)
block|{}
name|virtual
operator|~
name|TIntermTraverser
argument_list|()
block|{}
name|virtual
name|void
name|visitSymbol
argument_list|(
argument|TIntermSymbol *
argument_list|)
block|{}
name|virtual
name|void
name|visitRaw
argument_list|(
argument|TIntermRaw *
argument_list|)
block|{}
name|virtual
name|void
name|visitConstantUnion
argument_list|(
argument|TIntermConstantUnion *
argument_list|)
block|{}
name|virtual
name|bool
name|visitBinary
argument_list|(
argument|Visit
argument_list|,
argument|TIntermBinary *
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|virtual
name|bool
name|visitUnary
parameter_list|(
name|Visit
parameter_list|,
name|TIntermUnary
modifier|*
parameter_list|)
block|{
return|return
name|true
return|;
block|}
name|virtual
name|bool
name|visitSelection
parameter_list|(
name|Visit
parameter_list|,
name|TIntermSelection
modifier|*
parameter_list|)
block|{
return|return
name|true
return|;
block|}
name|virtual
name|bool
name|visitAggregate
parameter_list|(
name|Visit
parameter_list|,
name|TIntermAggregate
modifier|*
parameter_list|)
block|{
return|return
name|true
return|;
block|}
name|virtual
name|bool
name|visitLoop
parameter_list|(
name|Visit
parameter_list|,
name|TIntermLoop
modifier|*
parameter_list|)
block|{
return|return
name|true
return|;
block|}
name|virtual
name|bool
name|visitBranch
parameter_list|(
name|Visit
parameter_list|,
name|TIntermBranch
modifier|*
parameter_list|)
block|{
return|return
name|true
return|;
block|}
name|int
name|getMaxDepth
argument_list|()
specifier|const
block|{
return|return
name|mMaxDepth
return|;
block|}
name|void
name|incrementDepth
parameter_list|(
name|TIntermNode
modifier|*
name|current
parameter_list|)
block|{
name|mDepth
operator|++
expr_stmt|;
name|mMaxDepth
operator|=
name|std
operator|::
name|max
argument_list|(
name|mMaxDepth
argument_list|,
name|mDepth
argument_list|)
expr_stmt|;
name|mPath
operator|.
name|push_back
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
name|void
name|decrementDepth
parameter_list|()
block|{
name|mDepth
operator|--
expr_stmt|;
name|mPath
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
name|TIntermNode
modifier|*
name|getParentNode
parameter_list|()
block|{
return|return
name|mPath
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|?
name|NULL
else|:
name|mPath
operator|.
name|back
argument_list|()
return|;
block|}
comment|// Return the original name if hash function pointer is NULL;
comment|// otherwise return the hashed name.
specifier|static
name|TString
name|hash
parameter_list|(
specifier|const
name|TString
modifier|&
name|name
parameter_list|,
name|ShHashFunction64
name|hashFunction
parameter_list|)
function_decl|;
specifier|const
name|bool
name|preVisit
decl_stmt|;
specifier|const
name|bool
name|inVisit
decl_stmt|;
specifier|const
name|bool
name|postVisit
decl_stmt|;
specifier|const
name|bool
name|rightToLeft
decl_stmt|;
name|protected
label|:
name|int
name|mDepth
decl_stmt|;
name|int
name|mMaxDepth
decl_stmt|;
comment|// All the nodes from root to the current node's parent during traversing.
name|TVector
operator|<
name|TIntermNode
operator|*
operator|>
name|mPath
expr_stmt|;
block|}
end_decl_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// For traversing the tree, and computing max depth.
end_comment
begin_comment
comment|// Takes a maximum depth limit to prevent stack overflow.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TMaxDepthTraverser
range|:
name|public
name|TIntermTraverser
block|{
name|public
operator|:
name|POOL_ALLOCATOR_NEW_DELETE
argument_list|()
block|;
name|TMaxDepthTraverser
argument_list|(
argument|int depthLimit
argument_list|)
operator|:
name|TIntermTraverser
argument_list|(
name|true
argument_list|,
name|true
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
block|,
name|mDepthLimit
argument_list|(
argument|depthLimit
argument_list|)
block|{ }
name|virtual
name|bool
name|visitBinary
argument_list|(
argument|Visit
argument_list|,
argument|TIntermBinary *
argument_list|)
block|{
return|return
name|depthCheck
argument_list|()
return|;
block|}
name|virtual
name|bool
name|visitUnary
argument_list|(
argument|Visit
argument_list|,
argument|TIntermUnary *
argument_list|)
block|{
return|return
name|depthCheck
argument_list|()
return|;
block|}
name|virtual
name|bool
name|visitSelection
argument_list|(
argument|Visit
argument_list|,
argument|TIntermSelection *
argument_list|)
block|{
return|return
name|depthCheck
argument_list|()
return|;
block|}
name|virtual
name|bool
name|visitAggregate
argument_list|(
argument|Visit
argument_list|,
argument|TIntermAggregate *
argument_list|)
block|{
return|return
name|depthCheck
argument_list|()
return|;
block|}
name|virtual
name|bool
name|visitLoop
argument_list|(
argument|Visit
argument_list|,
argument|TIntermLoop *
argument_list|)
block|{
return|return
name|depthCheck
argument_list|()
return|;
block|}
name|virtual
name|bool
name|visitBranch
argument_list|(
argument|Visit
argument_list|,
argument|TIntermBranch *
argument_list|)
block|{
return|return
name|depthCheck
argument_list|()
return|;
block|}
name|protected
operator|:
name|bool
name|depthCheck
argument_list|()
specifier|const
block|{
return|return
name|mMaxDepth
operator|<
name|mDepthLimit
return|;
block|}
name|int
name|mDepthLimit
block|; }
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// COMPILER_TRANSLATOR_INTERMEDIATE_H_
end_comment
end_unit
