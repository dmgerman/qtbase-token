begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2010 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|"compiler/translator/PoolAlloc.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|_MSC_VER
end_ifndef
begin_include
include|#
directive|include
file|<stdint.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|"common/angleutils.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/InitializeGlobals.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/osinclude.h"
end_include
begin_decl_stmt
DECL|variable|PoolIndex
name|OS_TLSIndex
name|PoolIndex
init|=
name|OS_INVALID_TLS_INDEX
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|InitializePoolIndex
name|bool
name|InitializePoolIndex
parameter_list|()
block|{
name|assert
argument_list|(
name|PoolIndex
operator|==
name|OS_INVALID_TLS_INDEX
argument_list|)
expr_stmt|;
name|PoolIndex
operator|=
name|OS_AllocTLSIndex
argument_list|()
expr_stmt|;
return|return
name|PoolIndex
operator|!=
name|OS_INVALID_TLS_INDEX
return|;
block|}
end_function
begin_function
DECL|function|FreePoolIndex
name|void
name|FreePoolIndex
parameter_list|()
block|{
name|assert
argument_list|(
name|PoolIndex
operator|!=
name|OS_INVALID_TLS_INDEX
argument_list|)
expr_stmt|;
name|OS_FreeTLSIndex
argument_list|(
name|PoolIndex
argument_list|)
expr_stmt|;
name|PoolIndex
operator|=
name|OS_INVALID_TLS_INDEX
expr_stmt|;
block|}
end_function
begin_function
DECL|function|GetGlobalPoolAllocator
name|TPoolAllocator
modifier|*
name|GetGlobalPoolAllocator
parameter_list|()
block|{
name|assert
argument_list|(
name|PoolIndex
operator|!=
name|OS_INVALID_TLS_INDEX
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|TPoolAllocator
operator|*
argument_list|>
argument_list|(
name|OS_GetTLSValue
argument_list|(
name|PoolIndex
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|SetGlobalPoolAllocator
name|void
name|SetGlobalPoolAllocator
parameter_list|(
name|TPoolAllocator
modifier|*
name|poolAllocator
parameter_list|)
block|{
name|assert
argument_list|(
name|PoolIndex
operator|!=
name|OS_INVALID_TLS_INDEX
argument_list|)
expr_stmt|;
name|OS_SetTLSValue
argument_list|(
name|PoolIndex
argument_list|,
name|poolAllocator
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Implement the functionality of the TPoolAllocator class, which
end_comment
begin_comment
comment|// is documented in PoolAlloc.h.
end_comment
begin_comment
comment|//
end_comment
begin_constructor
DECL|function|TPoolAllocator
name|TPoolAllocator
operator|::
name|TPoolAllocator
parameter_list|(
name|int
name|growthIncrement
parameter_list|,
name|int
name|allocationAlignment
parameter_list|)
member_init_list|:
name|pageSize
argument_list|(
name|growthIncrement
argument_list|)
member_init_list|,
name|alignment
argument_list|(
name|allocationAlignment
argument_list|)
member_init_list|,
name|freeList
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|inUseList
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|numCalls
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|totalBytes
argument_list|(
literal|0
argument_list|)
block|{
comment|//
comment|// Don't allow page sizes we know are smaller than all common
comment|// OS page sizes.
comment|//
if|if
condition|(
name|pageSize
operator|<
literal|4
operator|*
literal|1024
condition|)
name|pageSize
operator|=
literal|4
operator|*
literal|1024
expr_stmt|;
comment|//
comment|// A large currentPageOffset indicates a new page needs to
comment|// be obtained to allocate memory.
comment|//
name|currentPageOffset
operator|=
name|pageSize
expr_stmt|;
comment|//
comment|// Adjust alignment to be at least pointer aligned and
comment|// power of 2.
comment|//
name|size_t
name|minAlign
init|=
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
decl_stmt|;
name|alignment
operator|&=
operator|~
operator|(
name|minAlign
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|alignment
operator|<
name|minAlign
condition|)
name|alignment
operator|=
name|minAlign
expr_stmt|;
name|size_t
name|a
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|a
operator|<
name|alignment
condition|)
name|a
operator|<<=
literal|1
expr_stmt|;
name|alignment
operator|=
name|a
expr_stmt|;
name|alignmentMask
operator|=
name|a
operator|-
literal|1
expr_stmt|;
comment|//
comment|// Align header skip
comment|//
name|headerSkip
operator|=
name|minAlign
expr_stmt|;
if|if
condition|(
name|headerSkip
operator|<
sizeof|sizeof
argument_list|(
name|tHeader
argument_list|)
condition|)
block|{
name|headerSkip
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|tHeader
argument_list|)
operator|+
name|alignmentMask
operator|)
operator|&
operator|~
name|alignmentMask
expr_stmt|;
block|}
block|}
end_constructor
begin_destructor
DECL|function|~TPoolAllocator
name|TPoolAllocator
operator|::
name|~
name|TPoolAllocator
parameter_list|()
block|{
while|while
condition|(
name|inUseList
condition|)
block|{
name|tHeader
modifier|*
name|next
init|=
name|inUseList
operator|->
name|nextPage
decl_stmt|;
name|inUseList
operator|->
name|~
name|tHeader
argument_list|()
expr_stmt|;
operator|delete
index|[]
cast|reinterpret_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
name|inUseList
argument_list|)
expr_stmt|;
name|inUseList
operator|=
name|next
expr_stmt|;
block|}
comment|// We should not check the guard blocks
comment|// here, because we did it already when the block was
comment|// placed into the free list.
comment|//
while|while
condition|(
name|freeList
condition|)
block|{
name|tHeader
modifier|*
name|next
init|=
name|freeList
operator|->
name|nextPage
decl_stmt|;
operator|delete
index|[]
cast|reinterpret_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
name|freeList
argument_list|)
expr_stmt|;
name|freeList
operator|=
name|next
expr_stmt|;
block|}
block|}
end_destructor
begin_comment
comment|// Support MSVC++ 6.0
end_comment
begin_decl_stmt
DECL|member|guardBlockBeginVal
specifier|const
name|unsigned
name|char
name|TAllocation
operator|::
name|guardBlockBeginVal
init|=
literal|0xfb
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|guardBlockEndVal
specifier|const
name|unsigned
name|char
name|TAllocation
operator|::
name|guardBlockEndVal
init|=
literal|0xfe
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|userDataFill
specifier|const
name|unsigned
name|char
name|TAllocation
operator|::
name|userDataFill
init|=
literal|0xcd
decl_stmt|;
end_decl_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|GUARD_BLOCKS
end_ifdef
begin_decl_stmt
DECL|member|guardBlockSize
specifier|const
name|size_t
name|TAllocation
operator|::
name|guardBlockSize
init|=
literal|16
decl_stmt|;
end_decl_stmt
begin_else
else|#
directive|else
end_else
begin_decl_stmt
DECL|member|guardBlockSize
specifier|const
name|size_t
name|TAllocation
operator|::
name|guardBlockSize
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//
end_comment
begin_comment
comment|// Check a single guard block for damage
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|checkGuardBlock
name|void
name|TAllocation
operator|::
name|checkGuardBlock
parameter_list|(
name|unsigned
name|char
modifier|*
name|blockMem
parameter_list|,
name|unsigned
name|char
name|val
parameter_list|,
specifier|const
name|char
modifier|*
name|locText
parameter_list|)
specifier|const
block|{
ifdef|#
directive|ifdef
name|GUARD_BLOCKS
for|for
control|(
name|size_t
name|x
init|=
literal|0
init|;
name|x
operator|<
name|guardBlockSize
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|blockMem
index|[
name|x
index|]
operator|!=
name|val
condition|)
block|{
name|char
name|assertMsg
index|[
literal|80
index|]
decl_stmt|;
comment|// We don't print the assert message.  It's here just to be helpful.
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
name|snprintf
argument_list|(
name|assertMsg
argument_list|,
sizeof|sizeof
argument_list|(
name|assertMsg
argument_list|)
argument_list|,
literal|"PoolAlloc: Damage %s %Iu byte allocation at 0x%p\n"
argument_list|,
name|locText
argument_list|,
name|size
argument_list|,
name|data
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
name|snprintf
argument_list|(
name|assertMsg
argument_list|,
sizeof|sizeof
argument_list|(
name|assertMsg
argument_list|)
argument_list|,
literal|"PoolAlloc: Damage %s %zu byte allocation at 0x%p\n"
argument_list|,
name|locText
argument_list|,
name|size
argument_list|,
name|data
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|assert
argument_list|(
literal|0
operator|&&
literal|"PoolAlloc: Damage in guard block"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|push
name|void
name|TPoolAllocator
operator|::
name|push
parameter_list|()
block|{
name|tAllocState
name|state
init|=
block|{
name|currentPageOffset
block|,
name|inUseList
block|}
decl_stmt|;
name|stack
operator|.
name|push_back
argument_list|(
name|state
argument_list|)
expr_stmt|;
comment|//
comment|// Indicate there is no current page to allocate from.
comment|//
name|currentPageOffset
operator|=
name|pageSize
expr_stmt|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Do a mass-deallocation of all the individual allocations
end_comment
begin_comment
comment|// that have occurred since the last push(), or since the
end_comment
begin_comment
comment|// last pop(), or since the object's creation.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// The deallocated pages are saved for future allocations.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|pop
name|void
name|TPoolAllocator
operator|::
name|pop
parameter_list|()
block|{
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|<
literal|1
condition|)
return|return;
name|tHeader
modifier|*
name|page
init|=
name|stack
operator|.
name|back
argument_list|()
operator|.
name|page
decl_stmt|;
name|currentPageOffset
operator|=
name|stack
operator|.
name|back
argument_list|()
operator|.
name|offset
expr_stmt|;
while|while
condition|(
name|inUseList
operator|!=
name|page
condition|)
block|{
comment|// invoke destructor to free allocation list
name|inUseList
operator|->
name|~
name|tHeader
argument_list|()
expr_stmt|;
name|tHeader
modifier|*
name|nextInUse
init|=
name|inUseList
operator|->
name|nextPage
decl_stmt|;
if|if
condition|(
name|inUseList
operator|->
name|pageCount
operator|>
literal|1
condition|)
operator|delete
index|[]
cast|reinterpret_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
name|inUseList
argument_list|)
expr_stmt|;
else|else
block|{
name|inUseList
operator|->
name|nextPage
operator|=
name|freeList
expr_stmt|;
name|freeList
operator|=
name|inUseList
expr_stmt|;
block|}
name|inUseList
operator|=
name|nextInUse
expr_stmt|;
block|}
name|stack
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Do a mass-deallocation of all the individual allocations
end_comment
begin_comment
comment|// that have occurred.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|popAll
name|void
name|TPoolAllocator
operator|::
name|popAll
parameter_list|()
block|{
while|while
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
name|pop
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|allocate
name|void
modifier|*
name|TPoolAllocator
operator|::
name|allocate
parameter_list|(
name|size_t
name|numBytes
parameter_list|)
block|{
comment|//
comment|// Just keep some interesting statistics.
comment|//
operator|++
name|numCalls
expr_stmt|;
name|totalBytes
operator|+=
name|numBytes
expr_stmt|;
comment|// If we are using guard blocks, all allocations are bracketed by
comment|// them: [guardblock][allocation][guardblock].  numBytes is how
comment|// much memory the caller asked for.  allocationSize is the total
comment|// size including guard blocks.  In release build,
comment|// guardBlockSize=0 and this all gets optimized away.
name|size_t
name|allocationSize
init|=
name|TAllocation
operator|::
name|allocationSize
argument_list|(
name|numBytes
argument_list|)
decl_stmt|;
comment|// Detect integer overflow.
if|if
condition|(
name|allocationSize
operator|<
name|numBytes
condition|)
return|return
literal|0
return|;
comment|//
comment|// Do the allocation, most likely case first, for efficiency.
comment|// This step could be moved to be inline sometime.
comment|//
if|if
condition|(
name|allocationSize
operator|<=
name|pageSize
operator|-
name|currentPageOffset
condition|)
block|{
comment|//
comment|// Safe to allocate from currentPageOffset.
comment|//
name|unsigned
name|char
modifier|*
name|memory
init|=
cast|reinterpret_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|inUseList
argument_list|)
operator|+
name|currentPageOffset
decl_stmt|;
name|currentPageOffset
operator|+=
name|allocationSize
expr_stmt|;
name|currentPageOffset
operator|=
operator|(
name|currentPageOffset
operator|+
name|alignmentMask
operator|)
operator|&
operator|~
name|alignmentMask
expr_stmt|;
return|return
name|initializeAllocation
argument_list|(
name|inUseList
argument_list|,
name|memory
argument_list|,
name|numBytes
argument_list|)
return|;
block|}
if|if
condition|(
name|allocationSize
operator|>
name|pageSize
operator|-
name|headerSkip
condition|)
block|{
comment|//
comment|// Do a multi-page allocation.  Don't mix these with the others.
comment|// The OS is efficient and allocating and free-ing multiple pages.
comment|//
name|size_t
name|numBytesToAlloc
init|=
name|allocationSize
operator|+
name|headerSkip
decl_stmt|;
comment|// Detect integer overflow.
if|if
condition|(
name|numBytesToAlloc
operator|<
name|allocationSize
condition|)
return|return
literal|0
return|;
name|tHeader
modifier|*
name|memory
init|=
cast|reinterpret_cast
argument_list|<
name|tHeader
operator|*
argument_list|>
argument_list|(
operator|::
operator|new
name|char
index|[
name|numBytesToAlloc
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|memory
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|// Use placement-new to initialize header
operator|new
operator|(
name|memory
operator|)
name|tHeader
argument_list|(
name|inUseList
argument_list|,
operator|(
name|numBytesToAlloc
operator|+
name|pageSize
operator|-
literal|1
operator|)
operator|/
name|pageSize
argument_list|)
expr_stmt|;
name|inUseList
operator|=
name|memory
expr_stmt|;
name|currentPageOffset
operator|=
name|pageSize
expr_stmt|;
comment|// make next allocation come from a new page
comment|// No guard blocks for multi-page allocations (yet)
return|return
cast|reinterpret_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
cast|reinterpret_cast
argument_list|<
name|uintptr_t
argument_list|>
argument_list|(
name|memory
argument_list|)
operator|+
name|headerSkip
argument_list|)
return|;
block|}
comment|//
comment|// Need a simple page to allocate from.
comment|//
name|tHeader
modifier|*
name|memory
decl_stmt|;
if|if
condition|(
name|freeList
condition|)
block|{
name|memory
operator|=
name|freeList
expr_stmt|;
name|freeList
operator|=
name|freeList
operator|->
name|nextPage
expr_stmt|;
block|}
else|else
block|{
name|memory
operator|=
cast|reinterpret_cast
argument_list|<
name|tHeader
operator|*
argument_list|>
argument_list|(
operator|::
operator|new
name|char
index|[
name|pageSize
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|memory
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
comment|// Use placement-new to initialize header
operator|new
operator|(
name|memory
operator|)
name|tHeader
argument_list|(
name|inUseList
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|inUseList
operator|=
name|memory
expr_stmt|;
name|unsigned
name|char
modifier|*
name|ret
init|=
cast|reinterpret_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|inUseList
argument_list|)
operator|+
name|headerSkip
decl_stmt|;
name|currentPageOffset
operator|=
operator|(
name|headerSkip
operator|+
name|allocationSize
operator|+
name|alignmentMask
operator|)
operator|&
operator|~
name|alignmentMask
expr_stmt|;
return|return
name|initializeAllocation
argument_list|(
name|inUseList
argument_list|,
name|ret
argument_list|,
name|numBytes
argument_list|)
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Check all allocations in a list for damage by calling check on each.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|checkAllocList
name|void
name|TAllocation
operator|::
name|checkAllocList
parameter_list|()
specifier|const
block|{
for|for
control|(
specifier|const
name|TAllocation
modifier|*
name|alloc
init|=
name|this
init|;
name|alloc
operator|!=
literal|0
condition|;
name|alloc
operator|=
name|alloc
operator|->
name|prevAlloc
control|)
name|alloc
operator|->
name|check
argument_list|()
expr_stmt|;
block|}
end_function
end_unit
