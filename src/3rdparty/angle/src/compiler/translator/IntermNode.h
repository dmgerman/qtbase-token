begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Definition of the in-memory high-level intermediate representation
end_comment
begin_comment
comment|// of shaders.  This is a tree that parser creates.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Nodes in the tree are defined as a hierarchy of classes derived from
end_comment
begin_comment
comment|// TIntermNode. Each is a node in a tree.  There is no preset branching factor;
end_comment
begin_comment
comment|// each node can have it's own type of list of children.
end_comment
begin_comment
comment|//
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|COMPILER_TRANSLATOR_INTERMNODE_H_
end_ifndef
begin_define
DECL|macro|COMPILER_TRANSLATOR_INTERMNODE_H_
define|#
directive|define
name|COMPILER_TRANSLATOR_INTERMNODE_H_
end_define
begin_include
include|#
directive|include
file|"GLSLANG/ShaderLang.h"
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_include
include|#
directive|include
file|<queue>
end_include
begin_include
include|#
directive|include
file|"common/angleutils.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/Common.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/Types.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/ConstantUnion.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/Operator.h"
end_include
begin_decl_stmt
DECL|variable|TIntermTraverser
name|class
name|TIntermTraverser
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermAggregate
name|class
name|TIntermAggregate
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermBinary
name|class
name|TIntermBinary
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermUnary
name|class
name|TIntermUnary
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermConstantUnion
name|class
name|TIntermConstantUnion
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermSelection
name|class
name|TIntermSelection
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermSwitch
name|class
name|TIntermSwitch
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermCase
name|class
name|TIntermCase
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermTyped
name|class
name|TIntermTyped
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermSymbol
name|class
name|TIntermSymbol
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermLoop
name|class
name|TIntermLoop
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TInfoSink
name|class
name|TInfoSink
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TInfoSinkBase
name|class
name|TInfoSinkBase
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermRaw
name|class
name|TIntermRaw
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// Base class for the tree nodes
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermNode
block|{
name|public
label|:
name|POOL_ALLOCATOR_NEW_DELETE
argument_list|()
expr_stmt|;
name|TIntermNode
argument_list|()
block|{
comment|// TODO: Move this to TSourceLoc constructor
comment|// after getting rid of TPublicType.
name|mLine
operator|.
name|first_file
operator|=
name|mLine
operator|.
name|last_file
operator|=
literal|0
expr_stmt|;
name|mLine
operator|.
name|first_line
operator|=
name|mLine
operator|.
name|last_line
operator|=
literal|0
expr_stmt|;
block|}
name|virtual
operator|~
name|TIntermNode
argument_list|()
block|{ }
specifier|const
name|TSourceLoc
operator|&
name|getLine
argument_list|()
specifier|const
block|{
return|return
name|mLine
return|;
block|}
name|void
name|setLine
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|l
parameter_list|)
block|{
name|mLine
operator|=
name|l
expr_stmt|;
block|}
name|virtual
name|void
name|traverse
parameter_list|(
name|TIntermTraverser
modifier|*
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|TIntermTyped
modifier|*
name|getAsTyped
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
name|virtual
name|TIntermConstantUnion
modifier|*
name|getAsConstantUnion
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
name|virtual
name|TIntermAggregate
modifier|*
name|getAsAggregate
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
name|virtual
name|TIntermBinary
modifier|*
name|getAsBinaryNode
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
name|virtual
name|TIntermUnary
modifier|*
name|getAsUnaryNode
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
name|virtual
name|TIntermSelection
modifier|*
name|getAsSelectionNode
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
name|virtual
name|TIntermSwitch
modifier|*
name|getAsSwitchNode
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
name|virtual
name|TIntermCase
modifier|*
name|getAsCaseNode
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
name|virtual
name|TIntermSymbol
modifier|*
name|getAsSymbolNode
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
name|virtual
name|TIntermLoop
modifier|*
name|getAsLoopNode
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
name|virtual
name|TIntermRaw
modifier|*
name|getAsRawNode
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
comment|// Replace a child node. Return true if |original| is a child
comment|// node and it is replaced; otherwise, return false.
name|virtual
name|bool
name|replaceChildNode
parameter_list|(
name|TIntermNode
modifier|*
name|original
parameter_list|,
name|TIntermNode
modifier|*
name|replacement
parameter_list|)
init|=
literal|0
function_decl|;
name|protected
label|:
name|TSourceLoc
name|mLine
decl_stmt|;
block|}
end_decl_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// This is just to help yacc.
end_comment
begin_comment
comment|//
end_comment
begin_struct
DECL|struct|TIntermNodePair
struct|struct
name|TIntermNodePair
block|{
DECL|member|node1
name|TIntermNode
modifier|*
name|node1
decl_stmt|;
DECL|member|node2
name|TIntermNode
modifier|*
name|node2
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|//
end_comment
begin_comment
comment|// Intermediate class for nodes that have a type.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermTyped
range|:
name|public
name|TIntermNode
block|{
name|public
operator|:
name|TIntermTyped
argument_list|(
specifier|const
name|TType
operator|&
name|t
argument_list|)
operator|:
name|mType
argument_list|(
argument|t
argument_list|)
block|{ }
name|virtual
name|TIntermTyped
operator|*
name|getAsTyped
argument_list|()
block|{
return|return
name|this
return|;
block|}
name|virtual
name|bool
name|hasSideEffects
argument_list|()
specifier|const
operator|=
literal|0
block|;
name|void
name|setType
argument_list|(
argument|const TType&t
argument_list|)
block|{
name|mType
operator|=
name|t
block|; }
name|void
name|setTypePreservePrecision
argument_list|(
specifier|const
name|TType
operator|&
name|t
argument_list|)
block|;
specifier|const
name|TType
operator|&
name|getType
argument_list|()
specifier|const
block|{
return|return
name|mType
return|;
block|}
name|TType
operator|*
name|getTypePointer
argument_list|()
block|{
return|return
operator|&
name|mType
return|;
block|}
name|TBasicType
name|getBasicType
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|getBasicType
argument_list|()
return|;
block|}
name|TQualifier
name|getQualifier
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|getQualifier
argument_list|()
return|;
block|}
name|TPrecision
name|getPrecision
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|getPrecision
argument_list|()
return|;
block|}
name|int
name|getCols
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|getCols
argument_list|()
return|;
block|}
name|int
name|getRows
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|getRows
argument_list|()
return|;
block|}
name|int
name|getNominalSize
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|getNominalSize
argument_list|()
return|;
block|}
name|int
name|getSecondarySize
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|getSecondarySize
argument_list|()
return|;
block|}
name|bool
name|isInterfaceBlock
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|isInterfaceBlock
argument_list|()
return|;
block|}
name|bool
name|isMatrix
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|isMatrix
argument_list|()
return|;
block|}
name|bool
name|isArray
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|isArray
argument_list|()
return|;
block|}
name|bool
name|isVector
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|isVector
argument_list|()
return|;
block|}
name|bool
name|isScalar
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|isScalar
argument_list|()
return|;
block|}
name|bool
name|isScalarInt
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|isScalarInt
argument_list|()
return|;
block|}
specifier|const
name|char
operator|*
name|getBasicString
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|getBasicString
argument_list|()
return|;
block|}
specifier|const
name|char
operator|*
name|getQualifierString
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|getQualifierString
argument_list|()
return|;
block|}
name|TString
name|getCompleteString
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|getCompleteString
argument_list|()
return|;
block|}
name|int
name|getArraySize
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|getArraySize
argument_list|()
return|;
block|}
name|protected
operator|:
name|TType
name|mType
block|; }
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// Handle for, do-while, and while loops.
end_comment
begin_comment
comment|//
end_comment
begin_enum
DECL|enum|TLoopType
enum|enum
name|TLoopType
block|{
DECL|enumerator|ELoopFor
name|ELoopFor
block|,
DECL|enumerator|ELoopWhile
name|ELoopWhile
block|,
DECL|enumerator|ELoopDoWhile
name|ELoopDoWhile
block|}
enum|;
end_enum
begin_decl_stmt
name|class
name|TIntermLoop
range|:
name|public
name|TIntermNode
block|{
name|public
operator|:
name|TIntermLoop
argument_list|(
argument|TLoopType type
argument_list|,
argument|TIntermNode *init
argument_list|,
argument|TIntermTyped *cond
argument_list|,
argument|TIntermTyped *expr
argument_list|,
argument|TIntermNode *body
argument_list|)
operator|:
name|mType
argument_list|(
name|type
argument_list|)
block|,
name|mInit
argument_list|(
name|init
argument_list|)
block|,
name|mCond
argument_list|(
name|cond
argument_list|)
block|,
name|mExpr
argument_list|(
name|expr
argument_list|)
block|,
name|mBody
argument_list|(
name|body
argument_list|)
block|,
name|mUnrollFlag
argument_list|(
argument|false
argument_list|)
block|{ }
name|virtual
name|TIntermLoop
operator|*
name|getAsLoopNode
argument_list|()
block|{
return|return
name|this
return|;
block|}
name|virtual
name|void
name|traverse
argument_list|(
name|TIntermTraverser
operator|*
argument_list|)
block|;
name|virtual
name|bool
name|replaceChildNode
argument_list|(
name|TIntermNode
operator|*
name|original
argument_list|,
name|TIntermNode
operator|*
name|replacement
argument_list|)
block|;
name|TLoopType
name|getType
argument_list|()
specifier|const
block|{
return|return
name|mType
return|;
block|}
name|TIntermNode
operator|*
name|getInit
argument_list|()
block|{
return|return
name|mInit
return|;
block|}
name|TIntermTyped
operator|*
name|getCondition
argument_list|()
block|{
return|return
name|mCond
return|;
block|}
name|TIntermTyped
operator|*
name|getExpression
argument_list|()
block|{
return|return
name|mExpr
return|;
block|}
name|TIntermNode
operator|*
name|getBody
argument_list|()
block|{
return|return
name|mBody
return|;
block|}
name|void
name|setUnrollFlag
argument_list|(
argument|bool flag
argument_list|)
block|{
name|mUnrollFlag
operator|=
name|flag
block|; }
name|bool
name|getUnrollFlag
argument_list|()
specifier|const
block|{
return|return
name|mUnrollFlag
return|;
block|}
name|protected
operator|:
name|TLoopType
name|mType
block|;
name|TIntermNode
operator|*
name|mInit
block|;
comment|// for-loop initialization
name|TIntermTyped
operator|*
name|mCond
block|;
comment|// loop exit condition
name|TIntermTyped
operator|*
name|mExpr
block|;
comment|// for-loop expression
name|TIntermNode
operator|*
name|mBody
block|;
comment|// loop body
name|bool
name|mUnrollFlag
block|;
comment|// Whether the loop should be unrolled or not.
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// Handle break, continue, return, and kill.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermBranch
range|:
name|public
name|TIntermNode
block|{
name|public
operator|:
name|TIntermBranch
argument_list|(
argument|TOperator op
argument_list|,
argument|TIntermTyped *e
argument_list|)
operator|:
name|mFlowOp
argument_list|(
name|op
argument_list|)
block|,
name|mExpression
argument_list|(
argument|e
argument_list|)
block|{ }
name|virtual
name|void
name|traverse
argument_list|(
name|TIntermTraverser
operator|*
argument_list|)
block|;
name|virtual
name|bool
name|replaceChildNode
argument_list|(
name|TIntermNode
operator|*
name|original
argument_list|,
name|TIntermNode
operator|*
name|replacement
argument_list|)
block|;
name|TOperator
name|getFlowOp
argument_list|()
block|{
return|return
name|mFlowOp
return|;
block|}
name|TIntermTyped
operator|*
name|getExpression
argument_list|()
block|{
return|return
name|mExpression
return|;
block|}
name|protected
operator|:
name|TOperator
name|mFlowOp
block|;
name|TIntermTyped
operator|*
name|mExpression
block|;
comment|// non-zero except for "return exp;" statements
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// Nodes that correspond to symbols or constants in the source code.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermSymbol
range|:
name|public
name|TIntermTyped
block|{
name|public
operator|:
comment|// if symbol is initialized as symbol(sym), the memory comes from the poolallocator of sym.
comment|// If sym comes from per process globalpoolallocator, then it causes increased memory usage
comment|// per compile it is essential to use "symbol = sym" to assign to symbol
name|TIntermSymbol
argument_list|(
argument|int id
argument_list|,
argument|const TString&symbol
argument_list|,
argument|const TType&type
argument_list|)
operator|:
name|TIntermTyped
argument_list|(
name|type
argument_list|)
block|,
name|mId
argument_list|(
argument|id
argument_list|)
block|{
name|mSymbol
operator|=
name|symbol
block|;     }
name|virtual
name|bool
name|hasSideEffects
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|int
name|getId
argument_list|()
specifier|const
block|{
return|return
name|mId
return|;
block|}
specifier|const
name|TString
operator|&
name|getSymbol
argument_list|()
specifier|const
block|{
return|return
name|mSymbol
return|;
block|}
name|void
name|setId
argument_list|(
argument|int newId
argument_list|)
block|{
name|mId
operator|=
name|newId
block|; }
name|virtual
name|void
name|traverse
argument_list|(
name|TIntermTraverser
operator|*
argument_list|)
block|;
name|virtual
name|TIntermSymbol
operator|*
name|getAsSymbolNode
argument_list|()
block|{
return|return
name|this
return|;
block|}
name|virtual
name|bool
name|replaceChildNode
argument_list|(
argument|TIntermNode *
argument_list|,
argument|TIntermNode *
argument_list|)
block|{
return|return
name|false
return|;
block|}
name|protected
operator|:
name|int
name|mId
block|;
name|TString
name|mSymbol
block|; }
decl_stmt|;
end_decl_stmt
begin_comment
comment|// A Raw node stores raw code, that the translator will insert verbatim
end_comment
begin_comment
comment|// into the output stream. Useful for transformation operations that make
end_comment
begin_comment
comment|// complex code that might not fit naturally into the GLSL model.
end_comment
begin_decl_stmt
name|class
name|TIntermRaw
range|:
name|public
name|TIntermTyped
block|{
name|public
operator|:
name|TIntermRaw
argument_list|(
specifier|const
name|TType
operator|&
name|type
argument_list|,
specifier|const
name|TString
operator|&
name|rawText
argument_list|)
operator|:
name|TIntermTyped
argument_list|(
name|type
argument_list|)
block|,
name|mRawText
argument_list|(
argument|rawText
argument_list|)
block|{ }
name|virtual
name|bool
name|hasSideEffects
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|TString
name|getRawText
argument_list|()
specifier|const
block|{
return|return
name|mRawText
return|;
block|}
name|virtual
name|void
name|traverse
argument_list|(
name|TIntermTraverser
operator|*
argument_list|)
block|;
name|virtual
name|TIntermRaw
operator|*
name|getAsRawNode
argument_list|()
block|{
return|return
name|this
return|;
block|}
name|virtual
name|bool
name|replaceChildNode
argument_list|(
argument|TIntermNode *
argument_list|,
argument|TIntermNode *
argument_list|)
block|{
return|return
name|false
return|;
block|}
name|protected
operator|:
name|TString
name|mRawText
block|; }
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|class
name|TIntermConstantUnion
range|:
name|public
name|TIntermTyped
block|{
name|public
operator|:
name|TIntermConstantUnion
argument_list|(
name|ConstantUnion
operator|*
name|unionPointer
argument_list|,
specifier|const
name|TType
operator|&
name|type
argument_list|)
operator|:
name|TIntermTyped
argument_list|(
name|type
argument_list|)
block|,
name|mUnionArrayPointer
argument_list|(
argument|unionPointer
argument_list|)
block|{ }
name|virtual
name|bool
name|hasSideEffects
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|ConstantUnion
operator|*
name|getUnionArrayPointer
argument_list|()
specifier|const
block|{
return|return
name|mUnionArrayPointer
return|;
block|}
name|int
name|getIConst
argument_list|(
argument|size_t index
argument_list|)
specifier|const
block|{
return|return
name|mUnionArrayPointer
operator|?
name|mUnionArrayPointer
index|[
name|index
index|]
operator|.
name|getIConst
argument_list|()
operator|:
literal|0
return|;
block|}
name|unsigned
name|int
name|getUConst
argument_list|(
argument|size_t index
argument_list|)
specifier|const
block|{
return|return
name|mUnionArrayPointer
condition|?
name|mUnionArrayPointer
index|[
name|index
index|]
operator|.
name|getUConst
argument_list|()
else|:
literal|0
return|;
block|}
name|float
name|getFConst
argument_list|(
argument|size_t index
argument_list|)
specifier|const
block|{
return|return
name|mUnionArrayPointer
condition|?
name|mUnionArrayPointer
index|[
name|index
index|]
operator|.
name|getFConst
argument_list|()
else|:
literal|0.0f
return|;
block|}
name|bool
name|getBConst
argument_list|(
argument|size_t index
argument_list|)
specifier|const
block|{
return|return
name|mUnionArrayPointer
condition|?
name|mUnionArrayPointer
index|[
name|index
index|]
operator|.
name|getBConst
argument_list|()
else|:
name|false
return|;
block|}
name|virtual
name|TIntermConstantUnion
operator|*
name|getAsConstantUnion
argument_list|()
block|{
return|return
name|this
return|;
block|}
name|virtual
name|void
name|traverse
argument_list|(
name|TIntermTraverser
operator|*
argument_list|)
block|;
name|virtual
name|bool
name|replaceChildNode
argument_list|(
argument|TIntermNode *
argument_list|,
argument|TIntermNode *
argument_list|)
block|{
return|return
name|false
return|;
block|}
name|TIntermTyped
operator|*
name|fold
argument_list|(
name|TOperator
argument_list|,
name|TIntermTyped
operator|*
argument_list|,
name|TInfoSink
operator|&
argument_list|)
block|;
name|protected
operator|:
name|ConstantUnion
operator|*
name|mUnionArrayPointer
block|; }
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// Intermediate class for node types that hold operators.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermOperator
range|:
name|public
name|TIntermTyped
block|{
name|public
operator|:
name|TOperator
name|getOp
argument_list|()
specifier|const
block|{
return|return
name|mOp
return|;
block|}
name|void
name|setOp
argument_list|(
argument|TOperator op
argument_list|)
block|{
name|mOp
operator|=
name|op
block|; }
name|bool
name|isAssignment
argument_list|()
specifier|const
block|;
name|bool
name|isConstructor
argument_list|()
specifier|const
block|;
name|virtual
name|bool
name|hasSideEffects
argument_list|()
specifier|const
block|{
return|return
name|isAssignment
argument_list|()
return|;
block|}
name|protected
operator|:
name|TIntermOperator
argument_list|(
argument|TOperator op
argument_list|)
operator|:
name|TIntermTyped
argument_list|(
name|TType
argument_list|(
name|EbtFloat
argument_list|,
name|EbpUndefined
argument_list|)
argument_list|)
block|,
name|mOp
argument_list|(
argument|op
argument_list|)
block|{}
name|TIntermOperator
argument_list|(
argument|TOperator op
argument_list|,
argument|const TType&type
argument_list|)
operator|:
name|TIntermTyped
argument_list|(
name|type
argument_list|)
block|,
name|mOp
argument_list|(
argument|op
argument_list|)
block|{}
name|TOperator
name|mOp
block|; }
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// Nodes for all the basic binary math operators.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermBinary
range|:
name|public
name|TIntermOperator
block|{
name|public
operator|:
name|TIntermBinary
argument_list|(
argument|TOperator op
argument_list|)
operator|:
name|TIntermOperator
argument_list|(
name|op
argument_list|)
block|,
name|mAddIndexClamp
argument_list|(
argument|false
argument_list|)
block|{}
name|virtual
name|TIntermBinary
operator|*
name|getAsBinaryNode
argument_list|()
block|{
return|return
name|this
return|;
block|}
name|virtual
name|void
name|traverse
argument_list|(
name|TIntermTraverser
operator|*
argument_list|)
block|;
name|virtual
name|bool
name|replaceChildNode
argument_list|(
name|TIntermNode
operator|*
name|original
argument_list|,
name|TIntermNode
operator|*
name|replacement
argument_list|)
block|;
name|virtual
name|bool
name|hasSideEffects
argument_list|()
specifier|const
block|{
return|return
name|isAssignment
argument_list|()
operator|||
name|mLeft
operator|->
name|hasSideEffects
argument_list|()
operator|||
name|mRight
operator|->
name|hasSideEffects
argument_list|()
return|;
block|}
name|void
name|setLeft
argument_list|(
argument|TIntermTyped *node
argument_list|)
block|{
name|mLeft
operator|=
name|node
block|; }
name|void
name|setRight
argument_list|(
argument|TIntermTyped *node
argument_list|)
block|{
name|mRight
operator|=
name|node
block|; }
name|TIntermTyped
operator|*
name|getLeft
argument_list|()
specifier|const
block|{
return|return
name|mLeft
return|;
block|}
name|TIntermTyped
operator|*
name|getRight
argument_list|()
specifier|const
block|{
return|return
name|mRight
return|;
block|}
name|bool
name|promote
argument_list|(
name|TInfoSink
operator|&
argument_list|)
block|;
name|void
name|setAddIndexClamp
argument_list|()
block|{
name|mAddIndexClamp
operator|=
name|true
block|; }
name|bool
name|getAddIndexClamp
argument_list|()
block|{
return|return
name|mAddIndexClamp
return|;
block|}
name|protected
operator|:
name|TIntermTyped
operator|*
name|mLeft
block|;
name|TIntermTyped
operator|*
name|mRight
block|;
comment|// If set to true, wrap any EOpIndexIndirect with a clamp to bounds.
name|bool
name|mAddIndexClamp
block|; }
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// Nodes for unary math operators.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermUnary
range|:
name|public
name|TIntermOperator
block|{
name|public
operator|:
name|TIntermUnary
argument_list|(
argument|TOperator op
argument_list|,
argument|const TType&type
argument_list|)
operator|:
name|TIntermOperator
argument_list|(
name|op
argument_list|,
name|type
argument_list|)
block|,
name|mOperand
argument_list|(
name|NULL
argument_list|)
block|,
name|mUseEmulatedFunction
argument_list|(
argument|false
argument_list|)
block|{}
name|TIntermUnary
argument_list|(
argument|TOperator op
argument_list|)
operator|:
name|TIntermOperator
argument_list|(
name|op
argument_list|)
block|,
name|mOperand
argument_list|(
name|NULL
argument_list|)
block|,
name|mUseEmulatedFunction
argument_list|(
argument|false
argument_list|)
block|{}
name|virtual
name|void
name|traverse
argument_list|(
name|TIntermTraverser
operator|*
argument_list|)
block|;
name|virtual
name|TIntermUnary
operator|*
name|getAsUnaryNode
argument_list|()
block|{
return|return
name|this
return|;
block|}
name|virtual
name|bool
name|replaceChildNode
argument_list|(
name|TIntermNode
operator|*
name|original
argument_list|,
name|TIntermNode
operator|*
name|replacement
argument_list|)
block|;
name|virtual
name|bool
name|hasSideEffects
argument_list|()
specifier|const
block|{
return|return
name|isAssignment
argument_list|()
operator|||
name|mOperand
operator|->
name|hasSideEffects
argument_list|()
return|;
block|}
name|void
name|setOperand
argument_list|(
argument|TIntermTyped *operand
argument_list|)
block|{
name|mOperand
operator|=
name|operand
block|; }
name|TIntermTyped
operator|*
name|getOperand
argument_list|()
block|{
return|return
name|mOperand
return|;
block|}
name|void
name|promote
argument_list|(
specifier|const
name|TType
operator|*
name|funcReturnType
argument_list|)
block|;
name|void
name|setUseEmulatedFunction
argument_list|()
block|{
name|mUseEmulatedFunction
operator|=
name|true
block|; }
name|bool
name|getUseEmulatedFunction
argument_list|()
block|{
return|return
name|mUseEmulatedFunction
return|;
block|}
name|protected
operator|:
name|TIntermTyped
operator|*
name|mOperand
block|;
comment|// If set to true, replace the built-in function call with an emulated one
comment|// to work around driver bugs.
name|bool
name|mUseEmulatedFunction
block|; }
decl_stmt|;
end_decl_stmt
begin_typedef
DECL|typedef|TIntermSequence
typedef|typedef
name|TVector
operator|<
name|TIntermNode
operator|*
operator|>
name|TIntermSequence
expr_stmt|;
end_typedef
begin_typedef
DECL|typedef|TQualifierList
typedef|typedef
name|TVector
operator|<
name|int
operator|>
name|TQualifierList
expr_stmt|;
end_typedef
begin_comment
comment|//
end_comment
begin_comment
comment|// Nodes that operate on an arbitrary sized set of children.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermAggregate
range|:
name|public
name|TIntermOperator
block|{
name|public
operator|:
name|TIntermAggregate
argument_list|()
operator|:
name|TIntermOperator
argument_list|(
name|EOpNull
argument_list|)
block|,
name|mUserDefined
argument_list|(
name|false
argument_list|)
block|,
name|mUseEmulatedFunction
argument_list|(
argument|false
argument_list|)
block|{ }
name|TIntermAggregate
argument_list|(
argument|TOperator op
argument_list|)
operator|:
name|TIntermOperator
argument_list|(
name|op
argument_list|)
block|,
name|mUseEmulatedFunction
argument_list|(
argument|false
argument_list|)
block|{ }
operator|~
name|TIntermAggregate
argument_list|()
block|{ }
name|virtual
name|TIntermAggregate
operator|*
name|getAsAggregate
argument_list|()
block|{
return|return
name|this
return|;
block|}
name|virtual
name|void
name|traverse
argument_list|(
name|TIntermTraverser
operator|*
argument_list|)
block|;
name|virtual
name|bool
name|replaceChildNode
argument_list|(
name|TIntermNode
operator|*
name|original
argument_list|,
name|TIntermNode
operator|*
name|replacement
argument_list|)
block|;
comment|// Conservatively assume function calls and other aggregate operators have side-effects
name|virtual
name|bool
name|hasSideEffects
argument_list|()
specifier|const
block|{
return|return
name|true
return|;
block|}
name|TIntermSequence
operator|*
name|getSequence
argument_list|()
block|{
return|return
operator|&
name|mSequence
return|;
block|}
name|void
name|setName
argument_list|(
argument|const TString&name
argument_list|)
block|{
name|mName
operator|=
name|name
block|; }
specifier|const
name|TString
operator|&
name|getName
argument_list|()
specifier|const
block|{
return|return
name|mName
return|;
block|}
name|void
name|setUserDefined
argument_list|()
block|{
name|mUserDefined
operator|=
name|true
block|; }
name|bool
name|isUserDefined
argument_list|()
specifier|const
block|{
return|return
name|mUserDefined
return|;
block|}
name|void
name|setOptimize
argument_list|(
argument|bool optimize
argument_list|)
block|{
name|mOptimize
operator|=
name|optimize
block|; }
name|bool
name|getOptimize
argument_list|()
specifier|const
block|{
return|return
name|mOptimize
return|;
block|}
name|void
name|setDebug
argument_list|(
argument|bool debug
argument_list|)
block|{
name|mDebug
operator|=
name|debug
block|; }
name|bool
name|getDebug
argument_list|()
specifier|const
block|{
return|return
name|mDebug
return|;
block|}
name|void
name|setUseEmulatedFunction
argument_list|()
block|{
name|mUseEmulatedFunction
operator|=
name|true
block|; }
name|bool
name|getUseEmulatedFunction
argument_list|()
block|{
return|return
name|mUseEmulatedFunction
return|;
block|}
name|void
name|setPrecisionFromChildren
argument_list|()
block|;
name|void
name|setBuiltInFunctionPrecision
argument_list|()
block|;
name|protected
operator|:
name|TIntermAggregate
argument_list|(
specifier|const
name|TIntermAggregate
operator|&
argument_list|)
block|;
comment|// disallow copy constructor
name|TIntermAggregate
operator|&
name|operator
operator|=
operator|(
specifier|const
name|TIntermAggregate
operator|&
operator|)
block|;
comment|// disallow assignment operator
name|TIntermSequence
name|mSequence
block|;
name|TString
name|mName
block|;
name|bool
name|mUserDefined
block|;
comment|// used for user defined function names
name|bool
name|mOptimize
block|;
name|bool
name|mDebug
block|;
comment|// If set to true, replace the built-in function call with an emulated one
comment|// to work around driver bugs.
name|bool
name|mUseEmulatedFunction
block|; }
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// For if tests.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermSelection
range|:
name|public
name|TIntermTyped
block|{
name|public
operator|:
name|TIntermSelection
argument_list|(
name|TIntermTyped
operator|*
name|cond
argument_list|,
name|TIntermNode
operator|*
name|trueB
argument_list|,
name|TIntermNode
operator|*
name|falseB
argument_list|)
operator|:
name|TIntermTyped
argument_list|(
name|TType
argument_list|(
name|EbtVoid
argument_list|,
name|EbpUndefined
argument_list|)
argument_list|)
block|,
name|mCondition
argument_list|(
name|cond
argument_list|)
block|,
name|mTrueBlock
argument_list|(
name|trueB
argument_list|)
block|,
name|mFalseBlock
argument_list|(
argument|falseB
argument_list|)
block|{}
name|TIntermSelection
argument_list|(
name|TIntermTyped
operator|*
name|cond
argument_list|,
name|TIntermNode
operator|*
name|trueB
argument_list|,
name|TIntermNode
operator|*
name|falseB
argument_list|,
specifier|const
name|TType
operator|&
name|type
argument_list|)
operator|:
name|TIntermTyped
argument_list|(
name|type
argument_list|)
block|,
name|mCondition
argument_list|(
name|cond
argument_list|)
block|,
name|mTrueBlock
argument_list|(
name|trueB
argument_list|)
block|,
name|mFalseBlock
argument_list|(
argument|falseB
argument_list|)
block|{}
name|virtual
name|void
name|traverse
argument_list|(
name|TIntermTraverser
operator|*
argument_list|)
block|;
name|virtual
name|bool
name|replaceChildNode
argument_list|(
name|TIntermNode
operator|*
name|original
argument_list|,
name|TIntermNode
operator|*
name|replacement
argument_list|)
block|;
comment|// Conservatively assume selections have side-effects
name|virtual
name|bool
name|hasSideEffects
argument_list|()
specifier|const
block|{
return|return
name|true
return|;
block|}
name|bool
name|usesTernaryOperator
argument_list|()
specifier|const
block|{
return|return
name|getBasicType
argument_list|()
operator|!=
name|EbtVoid
return|;
block|}
name|TIntermNode
operator|*
name|getCondition
argument_list|()
specifier|const
block|{
return|return
name|mCondition
return|;
block|}
name|TIntermNode
operator|*
name|getTrueBlock
argument_list|()
specifier|const
block|{
return|return
name|mTrueBlock
return|;
block|}
name|TIntermNode
operator|*
name|getFalseBlock
argument_list|()
specifier|const
block|{
return|return
name|mFalseBlock
return|;
block|}
name|TIntermSelection
operator|*
name|getAsSelectionNode
argument_list|()
block|{
return|return
name|this
return|;
block|}
name|protected
operator|:
name|TIntermTyped
operator|*
name|mCondition
block|;
name|TIntermNode
operator|*
name|mTrueBlock
block|;
name|TIntermNode
operator|*
name|mFalseBlock
block|; }
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// Switch statement.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermSwitch
range|:
name|public
name|TIntermNode
block|{
name|public
operator|:
name|TIntermSwitch
argument_list|(
name|TIntermTyped
operator|*
name|init
argument_list|,
name|TIntermAggregate
operator|*
name|statementList
argument_list|)
operator|:
name|TIntermNode
argument_list|()
block|,
name|mInit
argument_list|(
name|init
argument_list|)
block|,
name|mStatementList
argument_list|(
argument|statementList
argument_list|)
block|{     }
name|void
name|traverse
argument_list|(
argument|TIntermTraverser *it
argument_list|)
name|override
block|;
name|bool
name|replaceChildNode
argument_list|(
argument|TIntermNode *original
argument_list|,
argument|TIntermNode *replacement
argument_list|)
name|override
block|;
name|TIntermSwitch
operator|*
name|getAsSwitchNode
argument_list|()
name|override
block|{
return|return
name|this
return|;
block|}
name|TIntermAggregate
operator|*
name|getStatementList
argument_list|()
block|{
return|return
name|mStatementList
return|;
block|}
name|void
name|setStatementList
argument_list|(
argument|TIntermAggregate *statementList
argument_list|)
block|{
name|mStatementList
operator|=
name|statementList
block|; }
name|protected
operator|:
name|TIntermTyped
operator|*
name|mInit
block|;
name|TIntermAggregate
operator|*
name|mStatementList
block|; }
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// Case label.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermCase
range|:
name|public
name|TIntermNode
block|{
name|public
operator|:
name|TIntermCase
argument_list|(
name|TIntermTyped
operator|*
name|condition
argument_list|)
operator|:
name|TIntermNode
argument_list|()
block|,
name|mCondition
argument_list|(
argument|condition
argument_list|)
block|{     }
name|void
name|traverse
argument_list|(
argument|TIntermTraverser *it
argument_list|)
name|override
block|;
name|bool
name|replaceChildNode
argument_list|(
argument|TIntermNode *original
argument_list|,
argument|TIntermNode *replacement
argument_list|)
name|override
block|;
name|TIntermCase
operator|*
name|getAsCaseNode
argument_list|()
name|override
block|{
return|return
name|this
return|;
block|}
name|bool
name|hasCondition
argument_list|()
specifier|const
block|{
return|return
name|mCondition
operator|!=
name|nullptr
return|;
block|}
name|TIntermTyped
operator|*
name|getCondition
argument_list|()
specifier|const
block|{
return|return
name|mCondition
return|;
block|}
name|protected
operator|:
name|TIntermTyped
operator|*
name|mCondition
block|; }
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enum|Visit
enum|enum
name|Visit
block|{
DECL|enumerator|PreVisit
name|PreVisit
block|,
DECL|enumerator|InVisit
name|InVisit
block|,
DECL|enumerator|PostVisit
name|PostVisit
block|}
enum|;
end_enum
begin_comment
comment|//
end_comment
begin_comment
comment|// For traversing the tree.  User should derive from this,
end_comment
begin_comment
comment|// put their traversal specific data in it, and then pass
end_comment
begin_comment
comment|// it to a Traverse method.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// When using this, just fill in the methods for nodes you want visited.
end_comment
begin_comment
comment|// Return false from a pre-visit to skip visiting that node's subtree.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermTraverser
range|:
name|angle
operator|::
name|NonCopyable
block|{
name|public
operator|:
name|POOL_ALLOCATOR_NEW_DELETE
argument_list|()
block|;
comment|// TODO(zmo): remove default values.
name|TIntermTraverser
argument_list|(
argument|bool preVisit = true
argument_list|,
argument|bool inVisit = false
argument_list|,
argument|bool postVisit = false
argument_list|,
argument|bool rightToLeft = false
argument_list|)
operator|:
name|preVisit
argument_list|(
name|preVisit
argument_list|)
block|,
name|inVisit
argument_list|(
name|inVisit
argument_list|)
block|,
name|postVisit
argument_list|(
name|postVisit
argument_list|)
block|,
name|rightToLeft
argument_list|(
name|rightToLeft
argument_list|)
block|,
name|mDepth
argument_list|(
literal|0
argument_list|)
block|,
name|mMaxDepth
argument_list|(
literal|0
argument_list|)
block|{}
name|virtual
operator|~
name|TIntermTraverser
argument_list|()
block|{}
name|virtual
name|void
name|visitSymbol
argument_list|(
argument|TIntermSymbol *
argument_list|)
block|{}
name|virtual
name|void
name|visitRaw
argument_list|(
argument|TIntermRaw *
argument_list|)
block|{}
name|virtual
name|void
name|visitConstantUnion
argument_list|(
argument|TIntermConstantUnion *
argument_list|)
block|{}
name|virtual
name|bool
name|visitBinary
argument_list|(
argument|Visit
argument_list|,
argument|TIntermBinary *
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|virtual
name|bool
name|visitUnary
argument_list|(
argument|Visit
argument_list|,
argument|TIntermUnary *
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|virtual
name|bool
name|visitSelection
argument_list|(
argument|Visit
argument_list|,
argument|TIntermSelection *
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|virtual
name|bool
name|visitSwitch
argument_list|(
argument|Visit
argument_list|,
argument|TIntermSwitch *
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|virtual
name|bool
name|visitCase
argument_list|(
argument|Visit
argument_list|,
argument|TIntermCase *
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|virtual
name|bool
name|visitAggregate
argument_list|(
argument|Visit
argument_list|,
argument|TIntermAggregate *
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|virtual
name|bool
name|visitLoop
argument_list|(
argument|Visit
argument_list|,
argument|TIntermLoop *
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|virtual
name|bool
name|visitBranch
argument_list|(
argument|Visit
argument_list|,
argument|TIntermBranch *
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|int
name|getMaxDepth
argument_list|()
specifier|const
block|{
return|return
name|mMaxDepth
return|;
block|}
name|void
name|incrementDepth
argument_list|(
argument|TIntermNode *current
argument_list|)
block|{
name|mDepth
operator|++
block|;
name|mMaxDepth
operator|=
name|std
operator|::
name|max
argument_list|(
name|mMaxDepth
argument_list|,
name|mDepth
argument_list|)
block|;
name|mPath
operator|.
name|push_back
argument_list|(
name|current
argument_list|)
block|;     }
name|void
name|decrementDepth
argument_list|()
block|{
name|mDepth
operator|--
block|;
name|mPath
operator|.
name|pop_back
argument_list|()
block|;     }
name|TIntermNode
operator|*
name|getParentNode
argument_list|()
block|{
return|return
name|mPath
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|?
name|NULL
operator|:
name|mPath
operator|.
name|back
argument_list|()
return|;
block|}
comment|// Return the original name if hash function pointer is NULL;
comment|// otherwise return the hashed name.
specifier|static
name|TString
name|hash
argument_list|(
argument|const TString& name
argument_list|,
argument|ShHashFunction64 hashFunction
argument_list|)
block|;
specifier|const
name|bool
name|preVisit
block|;
specifier|const
name|bool
name|inVisit
block|;
specifier|const
name|bool
name|postVisit
block|;
specifier|const
name|bool
name|rightToLeft
block|;
comment|// If traversers need to replace nodes, they can add the replacements in
comment|// mReplacements during traversal and the user of the traverser should call
comment|// this function after traversal to perform them.
name|void
name|updateTree
argument_list|()
block|;
name|protected
operator|:
name|int
name|mDepth
block|;
name|int
name|mMaxDepth
block|;
comment|// All the nodes from root to the current node's parent during traversing.
name|TVector
operator|<
name|TIntermNode
operator|*
operator|>
name|mPath
block|;      struct
name|NodeUpdateEntry
block|{
name|NodeUpdateEntry
argument_list|(
argument|TIntermNode *_parent
argument_list|,
argument|TIntermNode *_original
argument_list|,
argument|TIntermNode *_replacement
argument_list|,
argument|bool _originalBecomesChildOfReplacement
argument_list|)
operator|:
name|parent
argument_list|(
name|_parent
argument_list|)
block|,
name|original
argument_list|(
name|_original
argument_list|)
block|,
name|replacement
argument_list|(
name|_replacement
argument_list|)
block|,
name|originalBecomesChildOfReplacement
argument_list|(
argument|_originalBecomesChildOfReplacement
argument_list|)
block|{}
name|TIntermNode
operator|*
name|parent
block|;
name|TIntermNode
operator|*
name|original
block|;
name|TIntermNode
operator|*
name|replacement
block|;
name|bool
name|originalBecomesChildOfReplacement
block|;     }
block|;
comment|// During traversing, save all the changes that need to happen into
comment|// mReplacements, then do them by calling updateTree().
name|std
operator|::
name|vector
operator|<
name|NodeUpdateEntry
operator|>
name|mReplacements
block|; }
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// For traversing the tree, and computing max depth.
end_comment
begin_comment
comment|// Takes a maximum depth limit to prevent stack overflow.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TMaxDepthTraverser
range|:
name|public
name|TIntermTraverser
block|{
name|public
operator|:
name|POOL_ALLOCATOR_NEW_DELETE
argument_list|()
block|;
name|TMaxDepthTraverser
argument_list|(
argument|int depthLimit
argument_list|)
operator|:
name|TIntermTraverser
argument_list|(
name|true
argument_list|,
name|true
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
block|,
name|mDepthLimit
argument_list|(
argument|depthLimit
argument_list|)
block|{ }
name|virtual
name|bool
name|visitBinary
argument_list|(
argument|Visit
argument_list|,
argument|TIntermBinary *
argument_list|)
block|{
return|return
name|depthCheck
argument_list|()
return|;
block|}
name|virtual
name|bool
name|visitUnary
argument_list|(
argument|Visit
argument_list|,
argument|TIntermUnary *
argument_list|)
block|{
return|return
name|depthCheck
argument_list|()
return|;
block|}
name|virtual
name|bool
name|visitSelection
argument_list|(
argument|Visit
argument_list|,
argument|TIntermSelection *
argument_list|)
block|{
return|return
name|depthCheck
argument_list|()
return|;
block|}
name|virtual
name|bool
name|visitAggregate
argument_list|(
argument|Visit
argument_list|,
argument|TIntermAggregate *
argument_list|)
block|{
return|return
name|depthCheck
argument_list|()
return|;
block|}
name|virtual
name|bool
name|visitLoop
argument_list|(
argument|Visit
argument_list|,
argument|TIntermLoop *
argument_list|)
block|{
return|return
name|depthCheck
argument_list|()
return|;
block|}
name|virtual
name|bool
name|visitBranch
argument_list|(
argument|Visit
argument_list|,
argument|TIntermBranch *
argument_list|)
block|{
return|return
name|depthCheck
argument_list|()
return|;
block|}
name|protected
operator|:
name|bool
name|depthCheck
argument_list|()
specifier|const
block|{
return|return
name|mMaxDepth
operator|<
name|mDepthLimit
return|;
block|}
name|int
name|mDepthLimit
block|; }
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// COMPILER_TRANSLATOR_INTERMNODE_H_
end_comment
end_unit
