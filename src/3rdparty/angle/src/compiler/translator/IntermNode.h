begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Definition of the in-memory high-level intermediate representation
end_comment
begin_comment
comment|// of shaders.  This is a tree that parser creates.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Nodes in the tree are defined as a hierarchy of classes derived from
end_comment
begin_comment
comment|// TIntermNode. Each is a node in a tree.  There is no preset branching factor;
end_comment
begin_comment
comment|// each node can have it's own type of list of children.
end_comment
begin_comment
comment|//
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|COMPILER_TRANSLATOR_INTERMNODE_H_
end_ifndef
begin_define
DECL|macro|COMPILER_TRANSLATOR_INTERMNODE_H_
define|#
directive|define
name|COMPILER_TRANSLATOR_INTERMNODE_H_
end_define
begin_include
include|#
directive|include
file|"GLSLANG/ShaderLang.h"
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_include
include|#
directive|include
file|<queue>
end_include
begin_include
include|#
directive|include
file|"common/angleutils.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/Common.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/ConstantUnion.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/Operator.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/Types.h"
end_include
begin_decl_stmt
DECL|variable|TIntermTraverser
name|class
name|TIntermTraverser
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermAggregate
name|class
name|TIntermAggregate
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermBinary
name|class
name|TIntermBinary
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermUnary
name|class
name|TIntermUnary
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermConstantUnion
name|class
name|TIntermConstantUnion
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermSelection
name|class
name|TIntermSelection
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermSwitch
name|class
name|TIntermSwitch
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermCase
name|class
name|TIntermCase
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermTyped
name|class
name|TIntermTyped
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermSymbol
name|class
name|TIntermSymbol
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermLoop
name|class
name|TIntermLoop
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TInfoSink
name|class
name|TInfoSink
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TInfoSinkBase
name|class
name|TInfoSinkBase
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TIntermRaw
name|class
name|TIntermRaw
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TSymbolTable
name|class
name|TSymbolTable
decl_stmt|;
end_decl_stmt
begin_comment
comment|// Encapsulate an identifier string and track whether it is coming from the original shader code
end_comment
begin_comment
comment|// (not internal) or from ANGLE (internal). Usually internal names shouldn't be decorated or hashed.
end_comment
begin_decl_stmt
name|class
name|TName
block|{
name|public
label|:
name|POOL_ALLOCATOR_NEW_DELETE
argument_list|()
expr_stmt|;
name|explicit
name|TName
argument_list|(
specifier|const
name|TString
operator|&
name|name
argument_list|)
operator|:
name|mName
argument_list|(
name|name
argument_list|)
operator|,
name|mIsInternal
argument_list|(
argument|false
argument_list|)
block|{}
name|TName
argument_list|()
operator|:
name|mName
argument_list|()
operator|,
name|mIsInternal
argument_list|(
argument|false
argument_list|)
block|{}
name|TName
argument_list|(
specifier|const
name|TName
operator|&
argument_list|)
operator|=
expr|default
expr_stmt|;
name|TName
modifier|&
name|operator
init|=
operator|(
specifier|const
name|TName
operator|&
operator|)
operator|=
expr|default
decl_stmt|;
specifier|const
name|TString
operator|&
name|getString
argument_list|()
specifier|const
block|{
return|return
name|mName
return|;
block|}
name|void
name|setString
parameter_list|(
specifier|const
name|TString
modifier|&
name|string
parameter_list|)
block|{
name|mName
operator|=
name|string
expr_stmt|;
block|}
name|bool
name|isInternal
argument_list|()
specifier|const
block|{
return|return
name|mIsInternal
return|;
block|}
name|void
name|setInternal
parameter_list|(
name|bool
name|isInternal
parameter_list|)
block|{
name|mIsInternal
operator|=
name|isInternal
expr_stmt|;
block|}
name|private
label|:
name|TString
name|mName
decl_stmt|;
name|bool
name|mIsInternal
decl_stmt|;
block|}
end_decl_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// Base class for the tree nodes
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermNode
range|:
name|angle
operator|::
name|NonCopyable
block|{
name|public
operator|:
name|POOL_ALLOCATOR_NEW_DELETE
argument_list|()
block|;
name|TIntermNode
argument_list|()
block|{
comment|// TODO: Move this to TSourceLoc constructor
comment|// after getting rid of TPublicType.
name|mLine
operator|.
name|first_file
operator|=
name|mLine
operator|.
name|last_file
operator|=
literal|0
block|;
name|mLine
operator|.
name|first_line
operator|=
name|mLine
operator|.
name|last_line
operator|=
literal|0
block|;     }
name|virtual
operator|~
name|TIntermNode
argument_list|()
block|{ }
specifier|const
name|TSourceLoc
operator|&
name|getLine
argument_list|()
specifier|const
block|{
return|return
name|mLine
return|;
block|}
name|void
name|setLine
argument_list|(
argument|const TSourceLoc&l
argument_list|)
block|{
name|mLine
operator|=
name|l
block|; }
name|virtual
name|void
name|traverse
argument_list|(
name|TIntermTraverser
operator|*
argument_list|)
operator|=
literal|0
block|;
name|virtual
name|TIntermTyped
operator|*
name|getAsTyped
argument_list|()
block|{
return|return
literal|0
return|;
block|}
name|virtual
name|TIntermConstantUnion
operator|*
name|getAsConstantUnion
argument_list|()
block|{
return|return
literal|0
return|;
block|}
name|virtual
name|TIntermAggregate
operator|*
name|getAsAggregate
argument_list|()
block|{
return|return
literal|0
return|;
block|}
name|virtual
name|TIntermBinary
operator|*
name|getAsBinaryNode
argument_list|()
block|{
return|return
literal|0
return|;
block|}
name|virtual
name|TIntermUnary
operator|*
name|getAsUnaryNode
argument_list|()
block|{
return|return
literal|0
return|;
block|}
name|virtual
name|TIntermSelection
operator|*
name|getAsSelectionNode
argument_list|()
block|{
return|return
literal|0
return|;
block|}
name|virtual
name|TIntermSwitch
operator|*
name|getAsSwitchNode
argument_list|()
block|{
return|return
literal|0
return|;
block|}
name|virtual
name|TIntermCase
operator|*
name|getAsCaseNode
argument_list|()
block|{
return|return
literal|0
return|;
block|}
name|virtual
name|TIntermSymbol
operator|*
name|getAsSymbolNode
argument_list|()
block|{
return|return
literal|0
return|;
block|}
name|virtual
name|TIntermLoop
operator|*
name|getAsLoopNode
argument_list|()
block|{
return|return
literal|0
return|;
block|}
name|virtual
name|TIntermRaw
operator|*
name|getAsRawNode
argument_list|()
block|{
return|return
literal|0
return|;
block|}
comment|// Replace a child node. Return true if |original| is a child
comment|// node and it is replaced; otherwise, return false.
name|virtual
name|bool
name|replaceChildNode
argument_list|(
name|TIntermNode
operator|*
name|original
argument_list|,
name|TIntermNode
operator|*
name|replacement
argument_list|)
operator|=
literal|0
block|;
name|protected
operator|:
name|TSourceLoc
name|mLine
block|; }
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// This is just to help yacc.
end_comment
begin_comment
comment|//
end_comment
begin_struct
DECL|struct|TIntermNodePair
struct|struct
name|TIntermNodePair
block|{
DECL|member|node1
name|TIntermNode
modifier|*
name|node1
decl_stmt|;
DECL|member|node2
name|TIntermNode
modifier|*
name|node2
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|//
end_comment
begin_comment
comment|// Intermediate class for nodes that have a type.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermTyped
range|:
name|public
name|TIntermNode
block|{
name|public
operator|:
name|TIntermTyped
argument_list|(
specifier|const
name|TType
operator|&
name|t
argument_list|)
operator|:
name|mType
argument_list|(
argument|t
argument_list|)
block|{ }
name|virtual
name|TIntermTyped
operator|*
name|deepCopy
argument_list|()
specifier|const
operator|=
literal|0
block|;
name|TIntermTyped
operator|*
name|getAsTyped
argument_list|()
name|override
block|{
return|return
name|this
return|;
block|}
name|virtual
name|bool
name|hasSideEffects
argument_list|()
specifier|const
operator|=
literal|0
block|;
name|void
name|setType
argument_list|(
argument|const TType&t
argument_list|)
block|{
name|mType
operator|=
name|t
block|; }
name|void
name|setTypePreservePrecision
argument_list|(
specifier|const
name|TType
operator|&
name|t
argument_list|)
block|;
specifier|const
name|TType
operator|&
name|getType
argument_list|()
specifier|const
block|{
return|return
name|mType
return|;
block|}
name|TType
operator|*
name|getTypePointer
argument_list|()
block|{
return|return
operator|&
name|mType
return|;
block|}
name|TBasicType
name|getBasicType
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|getBasicType
argument_list|()
return|;
block|}
name|TQualifier
name|getQualifier
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|getQualifier
argument_list|()
return|;
block|}
name|TPrecision
name|getPrecision
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|getPrecision
argument_list|()
return|;
block|}
name|int
name|getCols
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|getCols
argument_list|()
return|;
block|}
name|int
name|getRows
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|getRows
argument_list|()
return|;
block|}
name|int
name|getNominalSize
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|getNominalSize
argument_list|()
return|;
block|}
name|int
name|getSecondarySize
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|getSecondarySize
argument_list|()
return|;
block|}
name|bool
name|isInterfaceBlock
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|isInterfaceBlock
argument_list|()
return|;
block|}
name|bool
name|isMatrix
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|isMatrix
argument_list|()
return|;
block|}
name|bool
name|isArray
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|isArray
argument_list|()
return|;
block|}
name|bool
name|isVector
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|isVector
argument_list|()
return|;
block|}
name|bool
name|isScalar
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|isScalar
argument_list|()
return|;
block|}
name|bool
name|isScalarInt
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|isScalarInt
argument_list|()
return|;
block|}
specifier|const
name|char
operator|*
name|getBasicString
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|getBasicString
argument_list|()
return|;
block|}
name|TString
name|getCompleteString
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|getCompleteString
argument_list|()
return|;
block|}
name|int
name|getArraySize
argument_list|()
specifier|const
block|{
return|return
name|mType
operator|.
name|getArraySize
argument_list|()
return|;
block|}
name|protected
operator|:
name|TType
name|mType
block|;
name|TIntermTyped
argument_list|(
specifier|const
name|TIntermTyped
operator|&
name|node
argument_list|)
block|; }
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// Handle for, do-while, and while loops.
end_comment
begin_comment
comment|//
end_comment
begin_enum
DECL|enum|TLoopType
enum|enum
name|TLoopType
block|{
DECL|enumerator|ELoopFor
name|ELoopFor
block|,
DECL|enumerator|ELoopWhile
name|ELoopWhile
block|,
DECL|enumerator|ELoopDoWhile
name|ELoopDoWhile
block|}
enum|;
end_enum
begin_decl_stmt
name|class
name|TIntermLoop
range|:
name|public
name|TIntermNode
block|{
name|public
operator|:
name|TIntermLoop
argument_list|(
argument|TLoopType type
argument_list|,
argument|TIntermNode *init
argument_list|,
argument|TIntermTyped *cond
argument_list|,
argument|TIntermTyped *expr
argument_list|,
argument|TIntermAggregate *body
argument_list|)
operator|:
name|mType
argument_list|(
name|type
argument_list|)
block|,
name|mInit
argument_list|(
name|init
argument_list|)
block|,
name|mCond
argument_list|(
name|cond
argument_list|)
block|,
name|mExpr
argument_list|(
name|expr
argument_list|)
block|,
name|mBody
argument_list|(
name|body
argument_list|)
block|,
name|mUnrollFlag
argument_list|(
argument|false
argument_list|)
block|{     }
name|TIntermLoop
operator|*
name|getAsLoopNode
argument_list|()
name|override
block|{
return|return
name|this
return|;
block|}
name|void
name|traverse
argument_list|(
argument|TIntermTraverser *it
argument_list|)
name|override
block|;
name|bool
name|replaceChildNode
argument_list|(
argument|TIntermNode *original
argument_list|,
argument|TIntermNode *replacement
argument_list|)
name|override
block|;
name|TLoopType
name|getType
argument_list|()
specifier|const
block|{
return|return
name|mType
return|;
block|}
name|TIntermNode
operator|*
name|getInit
argument_list|()
block|{
return|return
name|mInit
return|;
block|}
name|TIntermTyped
operator|*
name|getCondition
argument_list|()
block|{
return|return
name|mCond
return|;
block|}
name|TIntermTyped
operator|*
name|getExpression
argument_list|()
block|{
return|return
name|mExpr
return|;
block|}
name|TIntermAggregate
operator|*
name|getBody
argument_list|()
block|{
return|return
name|mBody
return|;
block|}
name|void
name|setUnrollFlag
argument_list|(
argument|bool flag
argument_list|)
block|{
name|mUnrollFlag
operator|=
name|flag
block|; }
name|bool
name|getUnrollFlag
argument_list|()
specifier|const
block|{
return|return
name|mUnrollFlag
return|;
block|}
name|protected
operator|:
name|TLoopType
name|mType
block|;
name|TIntermNode
operator|*
name|mInit
block|;
comment|// for-loop initialization
name|TIntermTyped
operator|*
name|mCond
block|;
comment|// loop exit condition
name|TIntermTyped
operator|*
name|mExpr
block|;
comment|// for-loop expression
name|TIntermAggregate
operator|*
name|mBody
block|;
comment|// loop body
name|bool
name|mUnrollFlag
block|;
comment|// Whether the loop should be unrolled or not.
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// Handle break, continue, return, and kill.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermBranch
range|:
name|public
name|TIntermNode
block|{
name|public
operator|:
name|TIntermBranch
argument_list|(
argument|TOperator op
argument_list|,
argument|TIntermTyped *e
argument_list|)
operator|:
name|mFlowOp
argument_list|(
name|op
argument_list|)
block|,
name|mExpression
argument_list|(
argument|e
argument_list|)
block|{ }
name|void
name|traverse
argument_list|(
argument|TIntermTraverser *it
argument_list|)
name|override
block|;
name|bool
name|replaceChildNode
argument_list|(
argument|TIntermNode *original
argument_list|,
argument|TIntermNode *replacement
argument_list|)
name|override
block|;
name|TOperator
name|getFlowOp
argument_list|()
block|{
return|return
name|mFlowOp
return|;
block|}
name|TIntermTyped
operator|*
name|getExpression
argument_list|()
block|{
return|return
name|mExpression
return|;
block|}
name|protected
operator|:
name|TOperator
name|mFlowOp
block|;
name|TIntermTyped
operator|*
name|mExpression
block|;
comment|// non-zero except for "return exp;" statements
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// Nodes that correspond to symbols or constants in the source code.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermSymbol
range|:
name|public
name|TIntermTyped
block|{
name|public
operator|:
comment|// if symbol is initialized as symbol(sym), the memory comes from the poolallocator of sym.
comment|// If sym comes from per process globalpoolallocator, then it causes increased memory usage
comment|// per compile it is essential to use "symbol = sym" to assign to symbol
name|TIntermSymbol
argument_list|(
argument|int id
argument_list|,
argument|const TString&symbol
argument_list|,
argument|const TType&type
argument_list|)
operator|:
name|TIntermTyped
argument_list|(
name|type
argument_list|)
block|,
name|mId
argument_list|(
name|id
argument_list|)
block|,
name|mSymbol
argument_list|(
argument|symbol
argument_list|)
block|{     }
name|TIntermTyped
operator|*
name|deepCopy
argument_list|()
specifier|const
name|override
block|{
return|return
name|new
name|TIntermSymbol
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
name|bool
name|hasSideEffects
argument_list|()
specifier|const
name|override
block|{
return|return
name|false
return|;
block|}
name|int
name|getId
argument_list|()
specifier|const
block|{
return|return
name|mId
return|;
block|}
specifier|const
name|TString
operator|&
name|getSymbol
argument_list|()
specifier|const
block|{
return|return
name|mSymbol
operator|.
name|getString
argument_list|()
return|;
block|}
specifier|const
name|TName
operator|&
name|getName
argument_list|()
specifier|const
block|{
return|return
name|mSymbol
return|;
block|}
name|void
name|setId
argument_list|(
argument|int newId
argument_list|)
block|{
name|mId
operator|=
name|newId
block|; }
name|void
name|setInternal
argument_list|(
argument|bool internal
argument_list|)
block|{
name|mSymbol
operator|.
name|setInternal
argument_list|(
name|internal
argument_list|)
block|; }
name|void
name|traverse
argument_list|(
argument|TIntermTraverser *it
argument_list|)
name|override
block|;
name|TIntermSymbol
operator|*
name|getAsSymbolNode
argument_list|()
name|override
block|{
return|return
name|this
return|;
block|}
name|bool
name|replaceChildNode
argument_list|(
argument|TIntermNode *
argument_list|,
argument|TIntermNode *
argument_list|)
name|override
block|{
return|return
name|false
return|;
block|}
name|protected
operator|:
name|int
name|mId
block|;
name|TName
name|mSymbol
block|;
name|private
operator|:
name|TIntermSymbol
argument_list|(
specifier|const
name|TIntermSymbol
operator|&
argument_list|)
operator|=
expr|default
block|;
comment|// Note: not deleted, just private!
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|// A Raw node stores raw code, that the translator will insert verbatim
end_comment
begin_comment
comment|// into the output stream. Useful for transformation operations that make
end_comment
begin_comment
comment|// complex code that might not fit naturally into the GLSL model.
end_comment
begin_decl_stmt
name|class
name|TIntermRaw
range|:
name|public
name|TIntermTyped
block|{
name|public
operator|:
name|TIntermRaw
argument_list|(
specifier|const
name|TType
operator|&
name|type
argument_list|,
specifier|const
name|TString
operator|&
name|rawText
argument_list|)
operator|:
name|TIntermTyped
argument_list|(
name|type
argument_list|)
block|,
name|mRawText
argument_list|(
argument|rawText
argument_list|)
block|{ }
name|TIntermRaw
argument_list|(
specifier|const
name|TIntermRaw
operator|&
argument_list|)
operator|=
name|delete
block|;
name|TIntermTyped
operator|*
name|deepCopy
argument_list|()
specifier|const
name|override
block|{
name|UNREACHABLE
argument_list|()
block|;
return|return
name|nullptr
return|;
block|}
name|bool
name|hasSideEffects
argument_list|()
specifier|const
name|override
block|{
return|return
name|false
return|;
block|}
name|TString
name|getRawText
argument_list|()
specifier|const
block|{
return|return
name|mRawText
return|;
block|}
name|void
name|traverse
argument_list|(
argument|TIntermTraverser *it
argument_list|)
name|override
block|;
name|TIntermRaw
operator|*
name|getAsRawNode
argument_list|()
name|override
block|{
return|return
name|this
return|;
block|}
name|bool
name|replaceChildNode
argument_list|(
argument|TIntermNode *
argument_list|,
argument|TIntermNode *
argument_list|)
name|override
block|{
return|return
name|false
return|;
block|}
name|protected
operator|:
name|TString
name|mRawText
block|; }
decl_stmt|;
end_decl_stmt
begin_comment
comment|// Constant folded node.
end_comment
begin_comment
comment|// Note that nodes may be constant folded and not be constant expressions with the EvqConst
end_comment
begin_comment
comment|// qualifier. This happens for example when the following expression is processed:
end_comment
begin_comment
comment|// "true ? 1.0 : non_constant"
end_comment
begin_comment
comment|// Other nodes than TIntermConstantUnion may also be constant expressions.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermConstantUnion
range|:
name|public
name|TIntermTyped
block|{
name|public
operator|:
name|TIntermConstantUnion
argument_list|(
specifier|const
name|TConstantUnion
operator|*
name|unionPointer
argument_list|,
specifier|const
name|TType
operator|&
name|type
argument_list|)
operator|:
name|TIntermTyped
argument_list|(
name|type
argument_list|)
block|,
name|mUnionArrayPointer
argument_list|(
argument|unionPointer
argument_list|)
block|{     }
name|TIntermTyped
operator|*
name|deepCopy
argument_list|()
specifier|const
name|override
block|{
return|return
name|new
name|TIntermConstantUnion
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
name|bool
name|hasSideEffects
argument_list|()
specifier|const
name|override
block|{
return|return
name|false
return|;
block|}
specifier|const
name|TConstantUnion
operator|*
name|getUnionArrayPointer
argument_list|()
specifier|const
block|{
return|return
name|mUnionArrayPointer
return|;
block|}
name|int
name|getIConst
argument_list|(
argument|size_t index
argument_list|)
specifier|const
block|{
return|return
name|mUnionArrayPointer
operator|?
name|mUnionArrayPointer
index|[
name|index
index|]
operator|.
name|getIConst
argument_list|()
operator|:
literal|0
return|;
block|}
name|unsigned
name|int
name|getUConst
argument_list|(
argument|size_t index
argument_list|)
specifier|const
block|{
return|return
name|mUnionArrayPointer
condition|?
name|mUnionArrayPointer
index|[
name|index
index|]
operator|.
name|getUConst
argument_list|()
else|:
literal|0
return|;
block|}
name|float
name|getFConst
argument_list|(
argument|size_t index
argument_list|)
specifier|const
block|{
return|return
name|mUnionArrayPointer
condition|?
name|mUnionArrayPointer
index|[
name|index
index|]
operator|.
name|getFConst
argument_list|()
else|:
literal|0.0f
return|;
block|}
name|bool
name|getBConst
argument_list|(
argument|size_t index
argument_list|)
specifier|const
block|{
return|return
name|mUnionArrayPointer
condition|?
name|mUnionArrayPointer
index|[
name|index
index|]
operator|.
name|getBConst
argument_list|()
else|:
name|false
return|;
block|}
name|void
name|replaceConstantUnion
argument_list|(
argument|const TConstantUnion *safeConstantUnion
argument_list|)
block|{
comment|// Previous union pointer freed on pool deallocation.
name|mUnionArrayPointer
operator|=
name|safeConstantUnion
block|;     }
name|TIntermConstantUnion
operator|*
name|getAsConstantUnion
argument_list|()
name|override
block|{
return|return
name|this
return|;
block|}
name|void
name|traverse
argument_list|(
argument|TIntermTraverser *it
argument_list|)
name|override
block|;
name|bool
name|replaceChildNode
argument_list|(
argument|TIntermNode *
argument_list|,
argument|TIntermNode *
argument_list|)
name|override
block|{
return|return
name|false
return|;
block|}
name|TConstantUnion
operator|*
name|foldBinary
argument_list|(
argument|TOperator op
argument_list|,
argument|TIntermConstantUnion *rightNode
argument_list|,
argument|TInfoSink&infoSink
argument_list|)
block|;
name|TConstantUnion
operator|*
name|foldUnaryWithDifferentReturnType
argument_list|(
argument|TOperator op
argument_list|,
argument|TInfoSink&infoSink
argument_list|)
block|;
name|TConstantUnion
operator|*
name|foldUnaryWithSameReturnType
argument_list|(
argument|TOperator op
argument_list|,
argument|TInfoSink&infoSink
argument_list|)
block|;
specifier|static
name|TConstantUnion
operator|*
name|FoldAggregateConstructor
argument_list|(
name|TIntermAggregate
operator|*
name|aggregate
argument_list|,
name|TInfoSink
operator|&
name|infoSink
argument_list|)
block|;
specifier|static
name|TConstantUnion
operator|*
name|FoldAggregateBuiltIn
argument_list|(
name|TIntermAggregate
operator|*
name|aggregate
argument_list|,
name|TInfoSink
operator|&
name|infoSink
argument_list|)
block|;
name|protected
operator|:
comment|// Same data may be shared between multiple constant unions, so it can't be modified.
specifier|const
name|TConstantUnion
operator|*
name|mUnionArrayPointer
block|;
name|private
operator|:
typedef|typedef
name|float
function_decl|(
modifier|*
name|FloatTypeUnaryFunc
function_decl|)
parameter_list|(
name|float
parameter_list|)
function_decl|;
name|bool
name|foldFloatTypeUnary
argument_list|(
argument|const TConstantUnion&parameter
argument_list|,
argument|FloatTypeUnaryFunc builtinFunc
argument_list|,
argument|TInfoSink&infoSink
argument_list|,
argument|TConstantUnion *result
argument_list|)
specifier|const
decl_stmt|;
end_decl_stmt
begin_expr_stmt
name|TIntermConstantUnion
argument_list|(
specifier|const
name|TIntermConstantUnion
operator|&
name|node
argument_list|)
expr_stmt|;
end_expr_stmt
begin_comment
comment|// Note: not deleted, just private!
end_comment
begin_comment
unit|};
comment|//
end_comment
begin_comment
comment|// Intermediate class for node types that hold operators.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermOperator
range|:
name|public
name|TIntermTyped
block|{
name|public
operator|:
name|TOperator
name|getOp
argument_list|()
specifier|const
block|{
return|return
name|mOp
return|;
block|}
name|void
name|setOp
argument_list|(
argument|TOperator op
argument_list|)
block|{
name|mOp
operator|=
name|op
block|; }
name|bool
name|isAssignment
argument_list|()
specifier|const
block|;
name|bool
name|isMultiplication
argument_list|()
specifier|const
block|;
name|bool
name|isConstructor
argument_list|()
specifier|const
block|;
name|bool
name|hasSideEffects
argument_list|()
specifier|const
name|override
block|{
return|return
name|isAssignment
argument_list|()
return|;
block|}
name|protected
operator|:
name|TIntermOperator
argument_list|(
argument|TOperator op
argument_list|)
operator|:
name|TIntermTyped
argument_list|(
name|TType
argument_list|(
name|EbtFloat
argument_list|,
name|EbpUndefined
argument_list|)
argument_list|)
block|,
name|mOp
argument_list|(
argument|op
argument_list|)
block|{}
name|TIntermOperator
argument_list|(
argument|TOperator op
argument_list|,
argument|const TType&type
argument_list|)
operator|:
name|TIntermTyped
argument_list|(
name|type
argument_list|)
block|,
name|mOp
argument_list|(
argument|op
argument_list|)
block|{}
name|TIntermOperator
argument_list|(
specifier|const
name|TIntermOperator
operator|&
argument_list|)
operator|=
expr|default
block|;
name|TOperator
name|mOp
block|; }
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// Nodes for all the basic binary math operators.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermBinary
range|:
name|public
name|TIntermOperator
block|{
name|public
operator|:
name|TIntermBinary
argument_list|(
argument|TOperator op
argument_list|)
operator|:
name|TIntermOperator
argument_list|(
name|op
argument_list|)
block|,
name|mAddIndexClamp
argument_list|(
argument|false
argument_list|)
block|{}
name|TIntermTyped
operator|*
name|deepCopy
argument_list|()
specifier|const
name|override
block|{
return|return
name|new
name|TIntermBinary
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
name|TIntermBinary
operator|*
name|getAsBinaryNode
argument_list|()
name|override
block|{
return|return
name|this
return|;
block|}
block|;
name|void
name|traverse
argument_list|(
argument|TIntermTraverser *it
argument_list|)
name|override
block|;
name|bool
name|replaceChildNode
argument_list|(
argument|TIntermNode *original
argument_list|,
argument|TIntermNode *replacement
argument_list|)
name|override
block|;
name|bool
name|hasSideEffects
argument_list|()
specifier|const
name|override
block|{
return|return
name|isAssignment
argument_list|()
operator|||
name|mLeft
operator|->
name|hasSideEffects
argument_list|()
operator|||
name|mRight
operator|->
name|hasSideEffects
argument_list|()
return|;
block|}
name|void
name|setLeft
argument_list|(
argument|TIntermTyped *node
argument_list|)
block|{
name|mLeft
operator|=
name|node
block|; }
name|void
name|setRight
argument_list|(
argument|TIntermTyped *node
argument_list|)
block|{
name|mRight
operator|=
name|node
block|; }
name|TIntermTyped
operator|*
name|getLeft
argument_list|()
specifier|const
block|{
return|return
name|mLeft
return|;
block|}
name|TIntermTyped
operator|*
name|getRight
argument_list|()
specifier|const
block|{
return|return
name|mRight
return|;
block|}
name|bool
name|promote
argument_list|(
name|TInfoSink
operator|&
argument_list|)
block|;
name|TIntermTyped
operator|*
name|fold
argument_list|(
name|TInfoSink
operator|&
name|infoSink
argument_list|)
block|;
name|void
name|setAddIndexClamp
argument_list|()
block|{
name|mAddIndexClamp
operator|=
name|true
block|; }
name|bool
name|getAddIndexClamp
argument_list|()
block|{
return|return
name|mAddIndexClamp
return|;
block|}
name|protected
operator|:
name|TIntermTyped
operator|*
name|mLeft
block|;
name|TIntermTyped
operator|*
name|mRight
block|;
comment|// If set to true, wrap any EOpIndexIndirect with a clamp to bounds.
name|bool
name|mAddIndexClamp
block|;
name|private
operator|:
name|TIntermBinary
argument_list|(
specifier|const
name|TIntermBinary
operator|&
name|node
argument_list|)
block|;
comment|// Note: not deleted, just private!
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// Nodes for unary math operators.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermUnary
range|:
name|public
name|TIntermOperator
block|{
name|public
operator|:
name|TIntermUnary
argument_list|(
argument|TOperator op
argument_list|,
argument|const TType&type
argument_list|)
operator|:
name|TIntermOperator
argument_list|(
name|op
argument_list|,
name|type
argument_list|)
block|,
name|mOperand
argument_list|(
name|NULL
argument_list|)
block|,
name|mUseEmulatedFunction
argument_list|(
argument|false
argument_list|)
block|{}
name|TIntermUnary
argument_list|(
argument|TOperator op
argument_list|)
operator|:
name|TIntermOperator
argument_list|(
name|op
argument_list|)
block|,
name|mOperand
argument_list|(
name|NULL
argument_list|)
block|,
name|mUseEmulatedFunction
argument_list|(
argument|false
argument_list|)
block|{}
name|TIntermTyped
operator|*
name|deepCopy
argument_list|()
specifier|const
name|override
block|{
return|return
name|new
name|TIntermUnary
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
name|void
name|traverse
argument_list|(
argument|TIntermTraverser *it
argument_list|)
name|override
block|;
name|TIntermUnary
operator|*
name|getAsUnaryNode
argument_list|()
name|override
block|{
return|return
name|this
return|;
block|}
name|bool
name|replaceChildNode
argument_list|(
argument|TIntermNode *original
argument_list|,
argument|TIntermNode *replacement
argument_list|)
name|override
block|;
name|bool
name|hasSideEffects
argument_list|()
specifier|const
name|override
block|{
return|return
name|isAssignment
argument_list|()
operator|||
name|mOperand
operator|->
name|hasSideEffects
argument_list|()
return|;
block|}
name|void
name|setOperand
argument_list|(
argument|TIntermTyped *operand
argument_list|)
block|{
name|mOperand
operator|=
name|operand
block|; }
name|TIntermTyped
operator|*
name|getOperand
argument_list|()
block|{
return|return
name|mOperand
return|;
block|}
name|void
name|promote
argument_list|(
specifier|const
name|TType
operator|*
name|funcReturnType
argument_list|)
block|;
name|TIntermTyped
operator|*
name|fold
argument_list|(
name|TInfoSink
operator|&
name|infoSink
argument_list|)
block|;
name|void
name|setUseEmulatedFunction
argument_list|()
block|{
name|mUseEmulatedFunction
operator|=
name|true
block|; }
name|bool
name|getUseEmulatedFunction
argument_list|()
block|{
return|return
name|mUseEmulatedFunction
return|;
block|}
name|protected
operator|:
name|TIntermTyped
operator|*
name|mOperand
block|;
comment|// If set to true, replace the built-in function call with an emulated one
comment|// to work around driver bugs.
name|bool
name|mUseEmulatedFunction
block|;
name|private
operator|:
name|TIntermUnary
argument_list|(
specifier|const
name|TIntermUnary
operator|&
name|node
argument_list|)
block|;
comment|// note: not deleted, just private!
block|}
decl_stmt|;
end_decl_stmt
begin_typedef
DECL|typedef|TIntermSequence
typedef|typedef
name|TVector
operator|<
name|TIntermNode
operator|*
operator|>
name|TIntermSequence
expr_stmt|;
end_typedef
begin_typedef
DECL|typedef|TQualifierList
typedef|typedef
name|TVector
operator|<
name|int
operator|>
name|TQualifierList
expr_stmt|;
end_typedef
begin_comment
comment|//
end_comment
begin_comment
comment|// Nodes that operate on an arbitrary sized set of children.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermAggregate
range|:
name|public
name|TIntermOperator
block|{
name|public
operator|:
name|TIntermAggregate
argument_list|()
operator|:
name|TIntermOperator
argument_list|(
name|EOpNull
argument_list|)
block|,
name|mUserDefined
argument_list|(
name|false
argument_list|)
block|,
name|mUseEmulatedFunction
argument_list|(
name|false
argument_list|)
block|,
name|mGotPrecisionFromChildren
argument_list|(
argument|false
argument_list|)
block|{     }
name|TIntermAggregate
argument_list|(
argument|TOperator op
argument_list|)
operator|:
name|TIntermOperator
argument_list|(
name|op
argument_list|)
block|,
name|mUseEmulatedFunction
argument_list|(
name|false
argument_list|)
block|,
name|mGotPrecisionFromChildren
argument_list|(
argument|false
argument_list|)
block|{     }
operator|~
name|TIntermAggregate
argument_list|()
block|{ }
comment|// Note: only supported for nodes that can be a part of an expression.
name|TIntermTyped
operator|*
name|deepCopy
argument_list|()
specifier|const
name|override
block|{
return|return
name|new
name|TIntermAggregate
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
name|TIntermAggregate
operator|*
name|getAsAggregate
argument_list|()
name|override
block|{
return|return
name|this
return|;
block|}
name|void
name|traverse
argument_list|(
argument|TIntermTraverser *it
argument_list|)
name|override
block|;
name|bool
name|replaceChildNode
argument_list|(
argument|TIntermNode *original
argument_list|,
argument|TIntermNode *replacement
argument_list|)
name|override
block|;
name|bool
name|replaceChildNodeWithMultiple
argument_list|(
argument|TIntermNode *original
argument_list|,
argument|TIntermSequence replacements
argument_list|)
block|;
name|bool
name|insertChildNodes
argument_list|(
argument|TIntermSequence::size_type position
argument_list|,
argument|TIntermSequence insertions
argument_list|)
block|;
comment|// Conservatively assume function calls and other aggregate operators have side-effects
name|bool
name|hasSideEffects
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
name|TIntermTyped
operator|*
name|fold
argument_list|(
name|TInfoSink
operator|&
name|infoSink
argument_list|)
block|;
name|TIntermSequence
operator|*
name|getSequence
argument_list|()
block|{
return|return
operator|&
name|mSequence
return|;
block|}
name|void
name|setNameObj
argument_list|(
argument|const TName&name
argument_list|)
block|{
name|mName
operator|=
name|name
block|; }
specifier|const
name|TName
operator|&
name|getNameObj
argument_list|()
specifier|const
block|{
return|return
name|mName
return|;
block|}
name|void
name|setName
argument_list|(
argument|const TString&name
argument_list|)
block|{
name|mName
operator|.
name|setString
argument_list|(
name|name
argument_list|)
block|; }
specifier|const
name|TString
operator|&
name|getName
argument_list|()
specifier|const
block|{
return|return
name|mName
operator|.
name|getString
argument_list|()
return|;
block|}
name|void
name|setUserDefined
argument_list|()
block|{
name|mUserDefined
operator|=
name|true
block|; }
name|bool
name|isUserDefined
argument_list|()
specifier|const
block|{
return|return
name|mUserDefined
return|;
block|}
name|void
name|setFunctionId
argument_list|(
argument|int functionId
argument_list|)
block|{
name|mFunctionId
operator|=
name|functionId
block|; }
name|int
name|getFunctionId
argument_list|()
specifier|const
block|{
return|return
name|mFunctionId
return|;
block|}
name|void
name|setUseEmulatedFunction
argument_list|()
block|{
name|mUseEmulatedFunction
operator|=
name|true
block|; }
name|bool
name|getUseEmulatedFunction
argument_list|()
block|{
return|return
name|mUseEmulatedFunction
return|;
block|}
name|bool
name|areChildrenConstQualified
argument_list|()
block|;
name|void
name|setPrecisionFromChildren
argument_list|()
block|;
name|void
name|setBuiltInFunctionPrecision
argument_list|()
block|;
comment|// Returns true if changing parameter precision may affect the return value.
name|bool
name|gotPrecisionFromChildren
argument_list|()
specifier|const
block|{
return|return
name|mGotPrecisionFromChildren
return|;
block|}
name|protected
operator|:
name|TIntermSequence
name|mSequence
block|;
name|TName
name|mName
block|;
name|bool
name|mUserDefined
block|;
comment|// used for user defined function names
name|int
name|mFunctionId
block|;
comment|// If set to true, replace the built-in function call with an emulated one
comment|// to work around driver bugs.
name|bool
name|mUseEmulatedFunction
block|;
name|bool
name|mGotPrecisionFromChildren
block|;
name|private
operator|:
name|TIntermAggregate
argument_list|(
specifier|const
name|TIntermAggregate
operator|&
name|node
argument_list|)
block|;
comment|// note: not deleted, just private!
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// For if tests.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermSelection
range|:
name|public
name|TIntermTyped
block|{
name|public
operator|:
name|TIntermSelection
argument_list|(
name|TIntermTyped
operator|*
name|cond
argument_list|,
name|TIntermNode
operator|*
name|trueB
argument_list|,
name|TIntermNode
operator|*
name|falseB
argument_list|)
operator|:
name|TIntermTyped
argument_list|(
name|TType
argument_list|(
name|EbtVoid
argument_list|,
name|EbpUndefined
argument_list|)
argument_list|)
block|,
name|mCondition
argument_list|(
name|cond
argument_list|)
block|,
name|mTrueBlock
argument_list|(
name|trueB
argument_list|)
block|,
name|mFalseBlock
argument_list|(
argument|falseB
argument_list|)
block|{}
name|TIntermSelection
argument_list|(
name|TIntermTyped
operator|*
name|cond
argument_list|,
name|TIntermNode
operator|*
name|trueB
argument_list|,
name|TIntermNode
operator|*
name|falseB
argument_list|,
specifier|const
name|TType
operator|&
name|type
argument_list|)
operator|:
name|TIntermTyped
argument_list|(
name|type
argument_list|)
block|,
name|mCondition
argument_list|(
name|cond
argument_list|)
block|,
name|mTrueBlock
argument_list|(
name|trueB
argument_list|)
block|,
name|mFalseBlock
argument_list|(
argument|falseB
argument_list|)
block|{}
comment|// Note: only supported for ternary operator nodes.
name|TIntermTyped
operator|*
name|deepCopy
argument_list|()
specifier|const
name|override
block|{
return|return
name|new
name|TIntermSelection
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
name|void
name|traverse
argument_list|(
argument|TIntermTraverser *it
argument_list|)
name|override
block|;
name|bool
name|replaceChildNode
argument_list|(
argument|TIntermNode *original
argument_list|,
argument|TIntermNode *replacement
argument_list|)
name|override
block|;
comment|// Conservatively assume selections have side-effects
name|bool
name|hasSideEffects
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
name|bool
name|usesTernaryOperator
argument_list|()
specifier|const
block|{
return|return
name|getBasicType
argument_list|()
operator|!=
name|EbtVoid
return|;
block|}
name|TIntermNode
operator|*
name|getCondition
argument_list|()
specifier|const
block|{
return|return
name|mCondition
return|;
block|}
name|TIntermNode
operator|*
name|getTrueBlock
argument_list|()
specifier|const
block|{
return|return
name|mTrueBlock
return|;
block|}
name|TIntermNode
operator|*
name|getFalseBlock
argument_list|()
specifier|const
block|{
return|return
name|mFalseBlock
return|;
block|}
name|TIntermSelection
operator|*
name|getAsSelectionNode
argument_list|()
name|override
block|{
return|return
name|this
return|;
block|}
name|protected
operator|:
name|TIntermTyped
operator|*
name|mCondition
block|;
name|TIntermNode
operator|*
name|mTrueBlock
block|;
name|TIntermNode
operator|*
name|mFalseBlock
block|;
name|private
operator|:
name|TIntermSelection
argument_list|(
specifier|const
name|TIntermSelection
operator|&
name|node
argument_list|)
block|;
comment|// Note: not deleted, just private!
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// Switch statement.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermSwitch
range|:
name|public
name|TIntermNode
block|{
name|public
operator|:
name|TIntermSwitch
argument_list|(
name|TIntermTyped
operator|*
name|init
argument_list|,
name|TIntermAggregate
operator|*
name|statementList
argument_list|)
operator|:
name|TIntermNode
argument_list|()
block|,
name|mInit
argument_list|(
name|init
argument_list|)
block|,
name|mStatementList
argument_list|(
argument|statementList
argument_list|)
block|{     }
name|void
name|traverse
argument_list|(
argument|TIntermTraverser *it
argument_list|)
name|override
block|;
name|bool
name|replaceChildNode
argument_list|(
argument|TIntermNode *original
argument_list|,
argument|TIntermNode *replacement
argument_list|)
name|override
block|;
name|TIntermSwitch
operator|*
name|getAsSwitchNode
argument_list|()
name|override
block|{
return|return
name|this
return|;
block|}
name|TIntermTyped
operator|*
name|getInit
argument_list|()
block|{
return|return
name|mInit
return|;
block|}
name|TIntermAggregate
operator|*
name|getStatementList
argument_list|()
block|{
return|return
name|mStatementList
return|;
block|}
name|void
name|setStatementList
argument_list|(
argument|TIntermAggregate *statementList
argument_list|)
block|{
name|mStatementList
operator|=
name|statementList
block|; }
name|protected
operator|:
name|TIntermTyped
operator|*
name|mInit
block|;
name|TIntermAggregate
operator|*
name|mStatementList
block|; }
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// Case label.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermCase
range|:
name|public
name|TIntermNode
block|{
name|public
operator|:
name|TIntermCase
argument_list|(
name|TIntermTyped
operator|*
name|condition
argument_list|)
operator|:
name|TIntermNode
argument_list|()
block|,
name|mCondition
argument_list|(
argument|condition
argument_list|)
block|{     }
name|void
name|traverse
argument_list|(
argument|TIntermTraverser *it
argument_list|)
name|override
block|;
name|bool
name|replaceChildNode
argument_list|(
argument|TIntermNode *original
argument_list|,
argument|TIntermNode *replacement
argument_list|)
name|override
block|;
name|TIntermCase
operator|*
name|getAsCaseNode
argument_list|()
name|override
block|{
return|return
name|this
return|;
block|}
name|bool
name|hasCondition
argument_list|()
specifier|const
block|{
return|return
name|mCondition
operator|!=
name|nullptr
return|;
block|}
name|TIntermTyped
operator|*
name|getCondition
argument_list|()
specifier|const
block|{
return|return
name|mCondition
return|;
block|}
name|protected
operator|:
name|TIntermTyped
operator|*
name|mCondition
block|; }
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enum|Visit
enum|enum
name|Visit
block|{
DECL|enumerator|PreVisit
name|PreVisit
block|,
DECL|enumerator|InVisit
name|InVisit
block|,
DECL|enumerator|PostVisit
name|PostVisit
block|}
enum|;
end_enum
begin_comment
comment|//
end_comment
begin_comment
comment|// For traversing the tree.  User should derive from this class overriding the visit functions,
end_comment
begin_comment
comment|// and then pass an object of the subclass to a traverse method of a node.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// The traverse*() functions may also be overridden do other bookkeeping on the tree to provide
end_comment
begin_comment
comment|// contextual information to the visit functions, such as whether the node is the target of an
end_comment
begin_comment
comment|// assignment.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// When using this, just fill in the methods for nodes you want visited.
end_comment
begin_comment
comment|// Return false from a pre-visit to skip visiting that node's subtree.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TIntermTraverser
range|:
name|angle
operator|::
name|NonCopyable
block|{
name|public
operator|:
name|POOL_ALLOCATOR_NEW_DELETE
argument_list|()
block|;
name|TIntermTraverser
argument_list|(
argument|bool preVisit
argument_list|,
argument|bool inVisit
argument_list|,
argument|bool postVisit
argument_list|)
operator|:
name|preVisit
argument_list|(
name|preVisit
argument_list|)
block|,
name|inVisit
argument_list|(
name|inVisit
argument_list|)
block|,
name|postVisit
argument_list|(
name|postVisit
argument_list|)
block|,
name|mDepth
argument_list|(
literal|0
argument_list|)
block|,
name|mMaxDepth
argument_list|(
literal|0
argument_list|)
block|,
name|mTemporaryIndex
argument_list|(
argument|nullptr
argument_list|)
block|{     }
name|virtual
operator|~
name|TIntermTraverser
argument_list|()
block|{}
name|virtual
name|void
name|visitSymbol
argument_list|(
argument|TIntermSymbol *node
argument_list|)
block|{}
name|virtual
name|void
name|visitRaw
argument_list|(
argument|TIntermRaw *node
argument_list|)
block|{}
name|virtual
name|void
name|visitConstantUnion
argument_list|(
argument|TIntermConstantUnion *node
argument_list|)
block|{}
name|virtual
name|bool
name|visitBinary
argument_list|(
argument|Visit visit
argument_list|,
argument|TIntermBinary *node
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|virtual
name|bool
name|visitUnary
argument_list|(
argument|Visit visit
argument_list|,
argument|TIntermUnary *node
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|virtual
name|bool
name|visitSelection
argument_list|(
argument|Visit visit
argument_list|,
argument|TIntermSelection *node
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|virtual
name|bool
name|visitSwitch
argument_list|(
argument|Visit visit
argument_list|,
argument|TIntermSwitch *node
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|virtual
name|bool
name|visitCase
argument_list|(
argument|Visit visit
argument_list|,
argument|TIntermCase *node
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|virtual
name|bool
name|visitAggregate
argument_list|(
argument|Visit visit
argument_list|,
argument|TIntermAggregate *node
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|virtual
name|bool
name|visitLoop
argument_list|(
argument|Visit visit
argument_list|,
argument|TIntermLoop *node
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|virtual
name|bool
name|visitBranch
argument_list|(
argument|Visit visit
argument_list|,
argument|TIntermBranch *node
argument_list|)
block|{
return|return
name|true
return|;
block|}
comment|// The traverse functions contain logic for iterating over the children of the node
comment|// and calling the visit functions in the appropriate places. They also track some
comment|// context that may be used by the visit functions.
name|virtual
name|void
name|traverseSymbol
argument_list|(
name|TIntermSymbol
operator|*
name|node
argument_list|)
block|;
name|virtual
name|void
name|traverseRaw
argument_list|(
name|TIntermRaw
operator|*
name|node
argument_list|)
block|;
name|virtual
name|void
name|traverseConstantUnion
argument_list|(
name|TIntermConstantUnion
operator|*
name|node
argument_list|)
block|;
name|virtual
name|void
name|traverseBinary
argument_list|(
name|TIntermBinary
operator|*
name|node
argument_list|)
block|;
name|virtual
name|void
name|traverseUnary
argument_list|(
name|TIntermUnary
operator|*
name|node
argument_list|)
block|;
name|virtual
name|void
name|traverseSelection
argument_list|(
name|TIntermSelection
operator|*
name|node
argument_list|)
block|;
name|virtual
name|void
name|traverseSwitch
argument_list|(
name|TIntermSwitch
operator|*
name|node
argument_list|)
block|;
name|virtual
name|void
name|traverseCase
argument_list|(
name|TIntermCase
operator|*
name|node
argument_list|)
block|;
name|virtual
name|void
name|traverseAggregate
argument_list|(
name|TIntermAggregate
operator|*
name|node
argument_list|)
block|;
name|virtual
name|void
name|traverseLoop
argument_list|(
name|TIntermLoop
operator|*
name|node
argument_list|)
block|;
name|virtual
name|void
name|traverseBranch
argument_list|(
name|TIntermBranch
operator|*
name|node
argument_list|)
block|;
name|int
name|getMaxDepth
argument_list|()
specifier|const
block|{
return|return
name|mMaxDepth
return|;
block|}
comment|// Return the original name if hash function pointer is NULL;
comment|// otherwise return the hashed name.
specifier|static
name|TString
name|hash
argument_list|(
argument|const TString&name
argument_list|,
argument|ShHashFunction64 hashFunction
argument_list|)
block|;
comment|// If traversers need to replace nodes, they can add the replacements in
comment|// mReplacements/mMultiReplacements during traversal and the user of the traverser should call
comment|// this function after traversal to perform them.
name|void
name|updateTree
argument_list|()
block|;
comment|// Start creating temporary symbols from the given temporary symbol index + 1.
name|void
name|useTemporaryIndex
argument_list|(
argument|unsigned int *temporaryIndex
argument_list|)
block|;
name|protected
operator|:
name|void
name|incrementDepth
argument_list|(
argument|TIntermNode *current
argument_list|)
block|{
name|mDepth
operator|++
block|;
name|mMaxDepth
operator|=
name|std
operator|::
name|max
argument_list|(
name|mMaxDepth
argument_list|,
name|mDepth
argument_list|)
block|;
name|mPath
operator|.
name|push_back
argument_list|(
name|current
argument_list|)
block|;     }
name|void
name|decrementDepth
argument_list|()
block|{
name|mDepth
operator|--
block|;
name|mPath
operator|.
name|pop_back
argument_list|()
block|;     }
name|TIntermNode
operator|*
name|getParentNode
argument_list|()
block|{
return|return
name|mPath
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|?
name|NULL
operator|:
name|mPath
operator|.
name|back
argument_list|()
return|;
block|}
name|void
name|pushParentBlock
argument_list|(
name|TIntermAggregate
operator|*
name|node
argument_list|)
block|;
name|void
name|incrementParentBlockPos
argument_list|()
block|;
name|void
name|popParentBlock
argument_list|()
block|;
name|bool
name|parentNodeIsBlock
argument_list|()
block|{
return|return
operator|!
name|mParentBlockStack
operator|.
name|empty
argument_list|()
operator|&&
name|getParentNode
argument_list|()
operator|==
name|mParentBlockStack
operator|.
name|back
argument_list|()
operator|.
name|node
return|;
block|}
specifier|const
name|bool
name|preVisit
block|;
specifier|const
name|bool
name|inVisit
block|;
specifier|const
name|bool
name|postVisit
block|;
name|int
name|mDepth
block|;
name|int
name|mMaxDepth
block|;
comment|// All the nodes from root to the current node's parent during traversing.
name|TVector
operator|<
name|TIntermNode
operator|*
operator|>
name|mPath
block|;
comment|// To replace a single node with another on the parent node
block|struct
name|NodeUpdateEntry
block|{
name|NodeUpdateEntry
argument_list|(
argument|TIntermNode *_parent
argument_list|,
argument|TIntermNode *_original
argument_list|,
argument|TIntermNode *_replacement
argument_list|,
argument|bool _originalBecomesChildOfReplacement
argument_list|)
operator|:
name|parent
argument_list|(
name|_parent
argument_list|)
block|,
name|original
argument_list|(
name|_original
argument_list|)
block|,
name|replacement
argument_list|(
name|_replacement
argument_list|)
block|,
name|originalBecomesChildOfReplacement
argument_list|(
argument|_originalBecomesChildOfReplacement
argument_list|)
block|{}
name|TIntermNode
operator|*
name|parent
block|;
name|TIntermNode
operator|*
name|original
block|;
name|TIntermNode
operator|*
name|replacement
block|;
name|bool
name|originalBecomesChildOfReplacement
block|;     }
block|;
comment|// To replace a single node with multiple nodes on the parent aggregate node
block|struct
name|NodeReplaceWithMultipleEntry
block|{
name|NodeReplaceWithMultipleEntry
argument_list|(
argument|TIntermAggregate *_parent
argument_list|,
argument|TIntermNode *_original
argument_list|,
argument|TIntermSequence _replacements
argument_list|)
operator|:
name|parent
argument_list|(
name|_parent
argument_list|)
block|,
name|original
argument_list|(
name|_original
argument_list|)
block|,
name|replacements
argument_list|(
argument|_replacements
argument_list|)
block|{         }
name|TIntermAggregate
operator|*
name|parent
block|;
name|TIntermNode
operator|*
name|original
block|;
name|TIntermSequence
name|replacements
block|;     }
block|;
comment|// To insert multiple nodes on the parent aggregate node
block|struct
name|NodeInsertMultipleEntry
block|{
name|NodeInsertMultipleEntry
argument_list|(
argument|TIntermAggregate *_parent
argument_list|,
argument|TIntermSequence::size_type _position
argument_list|,
argument|TIntermSequence _insertionsBefore
argument_list|,
argument|TIntermSequence _insertionsAfter
argument_list|)
operator|:
name|parent
argument_list|(
name|_parent
argument_list|)
block|,
name|position
argument_list|(
name|_position
argument_list|)
block|,
name|insertionsBefore
argument_list|(
name|_insertionsBefore
argument_list|)
block|,
name|insertionsAfter
argument_list|(
argument|_insertionsAfter
argument_list|)
block|{         }
name|TIntermAggregate
operator|*
name|parent
block|;
name|TIntermSequence
operator|::
name|size_type
name|position
block|;
name|TIntermSequence
name|insertionsBefore
block|;
name|TIntermSequence
name|insertionsAfter
block|;     }
block|;
comment|// During traversing, save all the changes that need to happen into
comment|// mReplacements/mMultiReplacements, then do them by calling updateTree().
comment|// Multi replacements are processed after single replacements.
name|std
operator|::
name|vector
operator|<
name|NodeUpdateEntry
operator|>
name|mReplacements
block|;
name|std
operator|::
name|vector
operator|<
name|NodeReplaceWithMultipleEntry
operator|>
name|mMultiReplacements
block|;
name|std
operator|::
name|vector
operator|<
name|NodeInsertMultipleEntry
operator|>
name|mInsertions
block|;
comment|// Helper to insert statements in the parent block (sequence) of the node currently being traversed.
comment|// The statements will be inserted before the node being traversed once updateTree is called.
comment|// Should only be called during PreVisit or PostVisit from sequence nodes.
comment|// Note that inserting more than one set of nodes to the same parent node on a single updateTree call is not
comment|// supported.
name|void
name|insertStatementsInParentBlock
argument_list|(
specifier|const
name|TIntermSequence
operator|&
name|insertions
argument_list|)
block|;
comment|// Same as above, but supports simultaneous insertion of statements before and after the node
comment|// currently being traversed.
name|void
name|insertStatementsInParentBlock
argument_list|(
specifier|const
name|TIntermSequence
operator|&
name|insertionsBefore
argument_list|,
specifier|const
name|TIntermSequence
operator|&
name|insertionsAfter
argument_list|)
block|;
comment|// Helper to create a temporary symbol node with the given qualifier.
name|TIntermSymbol
operator|*
name|createTempSymbol
argument_list|(
argument|const TType&type
argument_list|,
argument|TQualifier qualifier
argument_list|)
block|;
comment|// Helper to create a temporary symbol node.
name|TIntermSymbol
operator|*
name|createTempSymbol
argument_list|(
specifier|const
name|TType
operator|&
name|type
argument_list|)
block|;
comment|// Create a node that declares but doesn't initialize a temporary symbol.
name|TIntermAggregate
operator|*
name|createTempDeclaration
argument_list|(
specifier|const
name|TType
operator|&
name|type
argument_list|)
block|;
comment|// Create a node that initializes the current temporary symbol with initializer having the given qualifier.
name|TIntermAggregate
operator|*
name|createTempInitDeclaration
argument_list|(
argument|TIntermTyped *initializer
argument_list|,
argument|TQualifier qualifier
argument_list|)
block|;
comment|// Create a node that initializes the current temporary symbol with initializer.
name|TIntermAggregate
operator|*
name|createTempInitDeclaration
argument_list|(
name|TIntermTyped
operator|*
name|initializer
argument_list|)
block|;
comment|// Create a node that assigns rightNode to the current temporary symbol.
name|TIntermBinary
operator|*
name|createTempAssignment
argument_list|(
name|TIntermTyped
operator|*
name|rightNode
argument_list|)
block|;
comment|// Increment temporary symbol index.
name|void
name|nextTemporaryIndex
argument_list|()
block|;
name|private
operator|:
expr|struct
name|ParentBlock
block|{
name|ParentBlock
argument_list|(
argument|TIntermAggregate *nodeIn
argument_list|,
argument|TIntermSequence::size_type posIn
argument_list|)
operator|:
name|node
argument_list|(
name|nodeIn
argument_list|)
block|,
name|pos
argument_list|(
argument|posIn
argument_list|)
block|{         }
name|TIntermAggregate
operator|*
name|node
block|;
name|TIntermSequence
operator|::
name|size_type
name|pos
block|;     }
block|;
comment|// All the code blocks from the root to the current node's parent during traversal.
name|std
operator|::
name|vector
operator|<
name|ParentBlock
operator|>
name|mParentBlockStack
block|;
name|unsigned
name|int
operator|*
name|mTemporaryIndex
block|; }
decl_stmt|;
end_decl_stmt
begin_comment
comment|// Traverser parent class that tracks where a node is a destination of a write operation and so is
end_comment
begin_comment
comment|// required to be an l-value.
end_comment
begin_decl_stmt
name|class
name|TLValueTrackingTraverser
range|:
name|public
name|TIntermTraverser
block|{
name|public
operator|:
name|TLValueTrackingTraverser
argument_list|(
argument|bool preVisit
argument_list|,
argument|bool inVisit
argument_list|,
argument|bool postVisit
argument_list|,
argument|const TSymbolTable&symbolTable
argument_list|,
argument|int shaderVersion
argument_list|)
operator|:
name|TIntermTraverser
argument_list|(
name|preVisit
argument_list|,
name|inVisit
argument_list|,
name|postVisit
argument_list|)
block|,
name|mOperatorRequiresLValue
argument_list|(
name|false
argument_list|)
block|,
name|mInFunctionCallOutParameter
argument_list|(
name|false
argument_list|)
block|,
name|mSymbolTable
argument_list|(
name|symbolTable
argument_list|)
block|,
name|mShaderVersion
argument_list|(
argument|shaderVersion
argument_list|)
block|{     }
name|virtual
operator|~
name|TLValueTrackingTraverser
argument_list|()
block|{}
name|void
name|traverseBinary
argument_list|(
argument|TIntermBinary *node
argument_list|)
name|override
block|;
name|void
name|traverseUnary
argument_list|(
argument|TIntermUnary *node
argument_list|)
name|override
block|;
name|void
name|traverseAggregate
argument_list|(
argument|TIntermAggregate *node
argument_list|)
name|override
block|;
name|protected
operator|:
name|bool
name|isLValueRequiredHere
argument_list|()
specifier|const
block|{
return|return
name|mOperatorRequiresLValue
operator|||
name|mInFunctionCallOutParameter
return|;
block|}
comment|// Return true if the prototype or definition of the function being called has been encountered
comment|// during traversal.
name|bool
name|isInFunctionMap
argument_list|(
argument|const TIntermAggregate *callNode
argument_list|)
specifier|const
block|;
name|private
operator|:
comment|// Track whether an l-value is required in the node that is currently being traversed by the
comment|// surrounding operator.
comment|// Use isLValueRequiredHere to check all conditions which require an l-value.
name|void
name|setOperatorRequiresLValue
argument_list|(
argument|bool lValueRequired
argument_list|)
block|{
name|mOperatorRequiresLValue
operator|=
name|lValueRequired
block|;     }
name|bool
name|operatorRequiresLValue
argument_list|()
specifier|const
block|{
return|return
name|mOperatorRequiresLValue
return|;
block|}
comment|// Add a function encountered during traversal to the function map.
name|void
name|addToFunctionMap
argument_list|(
specifier|const
name|TName
operator|&
name|name
argument_list|,
name|TIntermSequence
operator|*
name|paramSequence
argument_list|)
block|;
comment|// Return the parameters sequence from the function definition or prototype.
name|TIntermSequence
operator|*
name|getFunctionParameters
argument_list|(
specifier|const
name|TIntermAggregate
operator|*
name|callNode
argument_list|)
block|;
comment|// Track whether an l-value is required inside a function call.
name|void
name|setInFunctionCallOutParameter
argument_list|(
argument|bool inOutParameter
argument_list|)
block|;
name|bool
name|isInFunctionCallOutParameter
argument_list|()
specifier|const
block|;
name|bool
name|mOperatorRequiresLValue
block|;
name|bool
name|mInFunctionCallOutParameter
block|;      struct
name|TNameComparator
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|TName
operator|&
name|a
expr|,
specifier|const
name|TName
operator|&
name|b
operator|)
specifier|const
block|{
name|int
name|compareResult
operator|=
name|a
operator|.
name|getString
argument_list|()
operator|.
name|compare
argument_list|(
name|b
operator|.
name|getString
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|compareResult
operator|!=
literal|0
condition|)
return|return
name|compareResult
operator|<
literal|0
return|;
comment|// Internal functions may have same names as non-internal functions.
return|return
operator|!
name|a
operator|.
name|isInternal
argument_list|()
operator|&&
name|b
operator|.
name|isInternal
argument_list|()
return|;
block|}
expr|}
block|;
comment|// Map from mangled function names to their parameter sequences
name|TMap
operator|<
name|TName
block|,
name|TIntermSequence
operator|*
block|,
name|TNameComparator
operator|>
name|mFunctionMap
block|;
specifier|const
name|TSymbolTable
operator|&
name|mSymbolTable
block|;
specifier|const
name|int
name|mShaderVersion
block|; }
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// For traversing the tree, and computing max depth.
end_comment
begin_comment
comment|// Takes a maximum depth limit to prevent stack overflow.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TMaxDepthTraverser
range|:
name|public
name|TIntermTraverser
block|{
name|public
operator|:
name|POOL_ALLOCATOR_NEW_DELETE
argument_list|()
block|;
name|TMaxDepthTraverser
argument_list|(
argument|int depthLimit
argument_list|)
operator|:
name|TIntermTraverser
argument_list|(
name|true
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
block|,
name|mDepthLimit
argument_list|(
argument|depthLimit
argument_list|)
block|{ }
name|bool
name|visitBinary
argument_list|(
argument|Visit
argument_list|,
argument|TIntermBinary *
argument_list|)
name|override
block|{
return|return
name|depthCheck
argument_list|()
return|;
block|}
name|bool
name|visitUnary
argument_list|(
argument|Visit
argument_list|,
argument|TIntermUnary *
argument_list|)
name|override
block|{
return|return
name|depthCheck
argument_list|()
return|;
block|}
name|bool
name|visitSelection
argument_list|(
argument|Visit
argument_list|,
argument|TIntermSelection *
argument_list|)
name|override
block|{
return|return
name|depthCheck
argument_list|()
return|;
block|}
name|bool
name|visitAggregate
argument_list|(
argument|Visit
argument_list|,
argument|TIntermAggregate *
argument_list|)
name|override
block|{
return|return
name|depthCheck
argument_list|()
return|;
block|}
name|bool
name|visitLoop
argument_list|(
argument|Visit
argument_list|,
argument|TIntermLoop *
argument_list|)
name|override
block|{
return|return
name|depthCheck
argument_list|()
return|;
block|}
name|bool
name|visitBranch
argument_list|(
argument|Visit
argument_list|,
argument|TIntermBranch *
argument_list|)
name|override
block|{
return|return
name|depthCheck
argument_list|()
return|;
block|}
name|protected
operator|:
name|bool
name|depthCheck
argument_list|()
specifier|const
block|{
return|return
name|mMaxDepth
operator|<
name|mDepthLimit
return|;
block|}
name|int
name|mDepthLimit
block|; }
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// COMPILER_TRANSLATOR_INTERMNODE_H_
end_comment
end_unit
