begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// RewriteElseBlocks.cpp: Implementation for tree transform to change
end_comment
begin_comment
comment|//   all if-else blocks to if-if blocks.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|"compiler/translator/RewriteElseBlocks.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/NodeSearch.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/SymbolTable.h"
end_include
begin_namespace
DECL|namespace|sh
namespace|namespace
name|sh
block|{
DECL|function|MakeNewTemporary
name|TIntermSymbol
modifier|*
name|MakeNewTemporary
parameter_list|(
specifier|const
name|TString
modifier|&
name|name
parameter_list|,
name|TBasicType
name|type
parameter_list|)
block|{
name|TType
name|variableType
argument_list|(
name|type
argument_list|,
name|EbpHigh
argument_list|,
name|EvqInternal
argument_list|)
decl_stmt|;
return|return
operator|new
name|TIntermSymbol
argument_list|(
operator|-
literal|1
argument_list|,
name|name
argument_list|,
name|variableType
argument_list|)
return|;
block|}
DECL|function|MakeNewBinary
name|TIntermBinary
modifier|*
name|MakeNewBinary
parameter_list|(
name|TOperator
name|op
parameter_list|,
name|TIntermTyped
modifier|*
name|left
parameter_list|,
name|TIntermTyped
modifier|*
name|right
parameter_list|,
specifier|const
name|TType
modifier|&
name|resultType
parameter_list|)
block|{
name|TIntermBinary
modifier|*
name|binary
init|=
operator|new
name|TIntermBinary
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|binary
operator|->
name|setLeft
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|binary
operator|->
name|setRight
argument_list|(
name|right
argument_list|)
expr_stmt|;
name|binary
operator|->
name|setType
argument_list|(
name|resultType
argument_list|)
expr_stmt|;
return|return
name|binary
return|;
block|}
DECL|function|MakeNewUnary
name|TIntermUnary
modifier|*
name|MakeNewUnary
parameter_list|(
name|TOperator
name|op
parameter_list|,
name|TIntermTyped
modifier|*
name|operand
parameter_list|)
block|{
name|TIntermUnary
modifier|*
name|unary
init|=
operator|new
name|TIntermUnary
argument_list|(
name|op
argument_list|,
name|operand
operator|->
name|getType
argument_list|()
argument_list|)
decl_stmt|;
name|unary
operator|->
name|setOperand
argument_list|(
name|operand
argument_list|)
expr_stmt|;
return|return
name|unary
return|;
block|}
DECL|function|visitAggregate
name|bool
name|ElseBlockRewriter
operator|::
name|visitAggregate
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermAggregate
modifier|*
name|node
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|->
name|getOp
argument_list|()
condition|)
block|{
case|case
name|EOpSequence
case|:
block|{
for|for
control|(
name|size_t
name|statementIndex
init|=
literal|0
init|;
name|statementIndex
operator|!=
name|node
operator|->
name|getSequence
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|statementIndex
operator|++
control|)
block|{
name|TIntermNode
modifier|*
name|statement
init|=
name|node
operator|->
name|getSequence
argument_list|()
index|[
name|statementIndex
index|]
decl_stmt|;
name|TIntermSelection
modifier|*
name|selection
init|=
name|statement
operator|->
name|getAsSelectionNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|selection
operator|&&
name|selection
operator|->
name|getFalseBlock
argument_list|()
operator|!=
name|NULL
condition|)
block|{
name|node
operator|->
name|getSequence
argument_list|()
index|[
name|statementIndex
index|]
operator|=
name|rewriteSelection
argument_list|(
name|selection
argument_list|)
expr_stmt|;
operator|delete
name|selection
expr_stmt|;
block|}
block|}
block|}
break|break;
default|default:
break|break;
block|}
return|return
literal|true
return|;
block|}
DECL|function|rewriteSelection
name|TIntermNode
modifier|*
name|ElseBlockRewriter
operator|::
name|rewriteSelection
parameter_list|(
name|TIntermSelection
modifier|*
name|selection
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|selection
operator|->
name|getFalseBlock
argument_list|()
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|TString
name|temporaryName
init|=
literal|"cond_"
operator|+
name|str
argument_list|(
name|mTemporaryIndex
operator|++
argument_list|)
decl_stmt|;
name|TIntermTyped
modifier|*
name|typedCondition
init|=
name|selection
operator|->
name|getCondition
argument_list|()
operator|->
name|getAsTyped
argument_list|()
decl_stmt|;
name|TType
name|resultType
argument_list|(
name|EbtBool
argument_list|,
name|EbpUndefined
argument_list|)
decl_stmt|;
name|TIntermSymbol
modifier|*
name|conditionSymbolA
init|=
name|MakeNewTemporary
argument_list|(
name|temporaryName
argument_list|,
name|EbtBool
argument_list|)
decl_stmt|;
name|TIntermSymbol
modifier|*
name|conditionSymbolB
init|=
name|MakeNewTemporary
argument_list|(
name|temporaryName
argument_list|,
name|EbtBool
argument_list|)
decl_stmt|;
name|TIntermSymbol
modifier|*
name|conditionSymbolC
init|=
name|MakeNewTemporary
argument_list|(
name|temporaryName
argument_list|,
name|EbtBool
argument_list|)
decl_stmt|;
name|TIntermBinary
modifier|*
name|storeCondition
init|=
name|MakeNewBinary
argument_list|(
name|EOpInitialize
argument_list|,
name|conditionSymbolA
argument_list|,
name|typedCondition
argument_list|,
name|resultType
argument_list|)
decl_stmt|;
name|TIntermUnary
modifier|*
name|negatedCondition
init|=
name|MakeNewUnary
argument_list|(
name|EOpLogicalNot
argument_list|,
name|conditionSymbolB
argument_list|)
decl_stmt|;
name|TIntermSelection
modifier|*
name|falseBlock
init|=
operator|new
name|TIntermSelection
argument_list|(
name|negatedCondition
argument_list|,
name|selection
operator|->
name|getFalseBlock
argument_list|()
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|TIntermSelection
modifier|*
name|newIfElse
init|=
operator|new
name|TIntermSelection
argument_list|(
name|conditionSymbolC
argument_list|,
name|selection
operator|->
name|getTrueBlock
argument_list|()
argument_list|,
name|falseBlock
argument_list|)
decl_stmt|;
name|TIntermAggregate
modifier|*
name|declaration
init|=
operator|new
name|TIntermAggregate
argument_list|(
name|EOpDeclaration
argument_list|)
decl_stmt|;
name|declaration
operator|->
name|getSequence
argument_list|()
operator|.
name|push_back
argument_list|(
name|storeCondition
argument_list|)
expr_stmt|;
name|TIntermAggregate
modifier|*
name|block
init|=
operator|new
name|TIntermAggregate
argument_list|(
name|EOpSequence
argument_list|)
decl_stmt|;
name|block
operator|->
name|getSequence
argument_list|()
operator|.
name|push_back
argument_list|(
name|declaration
argument_list|)
expr_stmt|;
name|block
operator|->
name|getSequence
argument_list|()
operator|.
name|push_back
argument_list|(
name|newIfElse
argument_list|)
expr_stmt|;
return|return
name|block
return|;
block|}
DECL|function|RewriteElseBlocks
name|void
name|RewriteElseBlocks
parameter_list|(
name|TIntermNode
modifier|*
name|node
parameter_list|)
block|{
name|ElseBlockRewriter
name|rewriter
decl_stmt|;
name|node
operator|->
name|traverse
argument_list|(
operator|&
name|rewriter
argument_list|)
expr_stmt|;
block|}
block|}
end_namespace
end_unit
