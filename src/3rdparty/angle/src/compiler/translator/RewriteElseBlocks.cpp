begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// RewriteElseBlocks.cpp: Implementation for tree transform to change
end_comment
begin_comment
comment|//   all if-else blocks to if-if blocks.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|"compiler/translator/RewriteElseBlocks.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/NodeSearch.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/SymbolTable.h"
end_include
begin_namespace
DECL|namespace|sh
namespace|namespace
name|sh
block|{
namespace|namespace
block|{
DECL|class|ElseBlockRewriter
class|class
name|ElseBlockRewriter
super|:
specifier|public
name|TIntermTraverser
block|{
public|public:
name|ElseBlockRewriter
parameter_list|()
constructor_decl|;
protected|protected:
name|bool
name|visitAggregate
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermAggregate
modifier|*
name|aggregate
parameter_list|)
function_decl|;
private|private:
DECL|member|mTemporaryIndex
name|int
name|mTemporaryIndex
decl_stmt|;
DECL|member|mFunctionType
specifier|const
name|TType
modifier|*
name|mFunctionType
decl_stmt|;
name|TIntermNode
modifier|*
name|rewriteSelection
parameter_list|(
name|TIntermSelection
modifier|*
name|selection
parameter_list|)
function_decl|;
block|}
class|;
DECL|function|MakeNewTemporary
name|TIntermSymbol
modifier|*
name|MakeNewTemporary
parameter_list|(
specifier|const
name|TString
modifier|&
name|name
parameter_list|,
name|TBasicType
name|type
parameter_list|)
block|{
name|TType
name|variableType
argument_list|(
name|type
argument_list|,
name|EbpHigh
argument_list|,
name|EvqInternal
argument_list|)
decl_stmt|;
return|return
operator|new
name|TIntermSymbol
argument_list|(
operator|-
literal|1
argument_list|,
name|name
argument_list|,
name|variableType
argument_list|)
return|;
block|}
DECL|function|MakeNewBinary
name|TIntermBinary
modifier|*
name|MakeNewBinary
parameter_list|(
name|TOperator
name|op
parameter_list|,
name|TIntermTyped
modifier|*
name|left
parameter_list|,
name|TIntermTyped
modifier|*
name|right
parameter_list|,
specifier|const
name|TType
modifier|&
name|resultType
parameter_list|)
block|{
name|TIntermBinary
modifier|*
name|binary
init|=
operator|new
name|TIntermBinary
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|binary
operator|->
name|setLeft
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|binary
operator|->
name|setRight
argument_list|(
name|right
argument_list|)
expr_stmt|;
name|binary
operator|->
name|setType
argument_list|(
name|resultType
argument_list|)
expr_stmt|;
return|return
name|binary
return|;
block|}
DECL|function|MakeNewUnary
name|TIntermUnary
modifier|*
name|MakeNewUnary
parameter_list|(
name|TOperator
name|op
parameter_list|,
name|TIntermTyped
modifier|*
name|operand
parameter_list|)
block|{
name|TIntermUnary
modifier|*
name|unary
init|=
operator|new
name|TIntermUnary
argument_list|(
name|op
argument_list|,
name|operand
operator|->
name|getType
argument_list|()
argument_list|)
decl_stmt|;
name|unary
operator|->
name|setOperand
argument_list|(
name|operand
argument_list|)
expr_stmt|;
return|return
name|unary
return|;
block|}
DECL|function|ElseBlockRewriter
name|ElseBlockRewriter
operator|::
name|ElseBlockRewriter
parameter_list|()
member_init_list|:
name|TIntermTraverser
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
member_init_list|,
name|mTemporaryIndex
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mFunctionType
argument_list|(
name|NULL
argument_list|)
block|{}
DECL|function|visitAggregate
name|bool
name|ElseBlockRewriter
operator|::
name|visitAggregate
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermAggregate
modifier|*
name|node
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|->
name|getOp
argument_list|()
condition|)
block|{
case|case
name|EOpSequence
case|:
if|if
condition|(
name|visit
operator|==
name|PostVisit
condition|)
block|{
for|for
control|(
name|size_t
name|statementIndex
init|=
literal|0
init|;
name|statementIndex
operator|!=
name|node
operator|->
name|getSequence
argument_list|()
operator|->
name|size
argument_list|()
condition|;
name|statementIndex
operator|++
control|)
block|{
name|TIntermNode
modifier|*
name|statement
init|=
operator|(
operator|*
name|node
operator|->
name|getSequence
argument_list|()
operator|)
index|[
name|statementIndex
index|]
decl_stmt|;
name|TIntermSelection
modifier|*
name|selection
init|=
name|statement
operator|->
name|getAsSelectionNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|selection
operator|&&
name|selection
operator|->
name|getFalseBlock
argument_list|()
operator|!=
name|NULL
condition|)
block|{
comment|// Check for if / else if
name|TIntermSelection
modifier|*
name|elseIfBranch
init|=
name|selection
operator|->
name|getFalseBlock
argument_list|()
operator|->
name|getAsSelectionNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|elseIfBranch
condition|)
block|{
name|selection
operator|->
name|replaceChildNode
argument_list|(
name|elseIfBranch
argument_list|,
name|rewriteSelection
argument_list|(
name|elseIfBranch
argument_list|)
argument_list|)
expr_stmt|;
operator|delete
name|elseIfBranch
expr_stmt|;
block|}
operator|(
operator|*
name|node
operator|->
name|getSequence
argument_list|()
operator|)
index|[
name|statementIndex
index|]
operator|=
name|rewriteSelection
argument_list|(
name|selection
argument_list|)
expr_stmt|;
operator|delete
name|selection
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|EOpFunction
case|:
comment|// Store the current function context (see comment below)
name|mFunctionType
operator|=
operator|(
operator|(
name|visit
operator|==
name|PreVisit
operator|)
condition|?
operator|&
name|node
operator|->
name|getType
argument_list|()
else|:
name|NULL
operator|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
literal|true
return|;
block|}
DECL|function|rewriteSelection
name|TIntermNode
modifier|*
name|ElseBlockRewriter
operator|::
name|rewriteSelection
parameter_list|(
name|TIntermSelection
modifier|*
name|selection
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|selection
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|TString
name|temporaryName
init|=
literal|"cond_"
operator|+
name|str
argument_list|(
name|mTemporaryIndex
operator|++
argument_list|)
decl_stmt|;
name|TIntermTyped
modifier|*
name|typedCondition
init|=
name|selection
operator|->
name|getCondition
argument_list|()
operator|->
name|getAsTyped
argument_list|()
decl_stmt|;
name|TType
name|resultType
argument_list|(
name|EbtBool
argument_list|,
name|EbpUndefined
argument_list|)
decl_stmt|;
name|TIntermSymbol
modifier|*
name|conditionSymbolInit
init|=
name|MakeNewTemporary
argument_list|(
name|temporaryName
argument_list|,
name|EbtBool
argument_list|)
decl_stmt|;
name|TIntermBinary
modifier|*
name|storeCondition
init|=
name|MakeNewBinary
argument_list|(
name|EOpInitialize
argument_list|,
name|conditionSymbolInit
argument_list|,
name|typedCondition
argument_list|,
name|resultType
argument_list|)
decl_stmt|;
name|TIntermNode
modifier|*
name|negatedElse
init|=
name|NULL
decl_stmt|;
name|TIntermSelection
modifier|*
name|falseBlock
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|selection
operator|->
name|getFalseBlock
argument_list|()
condition|)
block|{
comment|// crbug.com/346463
comment|// D3D generates error messages claiming a function has no return value, when rewriting
comment|// an if-else clause that returns something non-void in a function. By appending dummy
comment|// returns (that are unreachable) we can silence this compile error.
if|if
condition|(
name|mFunctionType
operator|&&
name|mFunctionType
operator|->
name|getBasicType
argument_list|()
operator|!=
name|EbtVoid
condition|)
block|{
name|TString
name|typeString
init|=
name|mFunctionType
operator|->
name|getStruct
argument_list|()
condition|?
name|mFunctionType
operator|->
name|getStruct
argument_list|()
operator|->
name|name
argument_list|()
else|:
name|mFunctionType
operator|->
name|getBasicString
argument_list|()
decl_stmt|;
name|TString
name|rawText
init|=
literal|"return ("
operator|+
name|typeString
operator|+
literal|")0"
decl_stmt|;
name|negatedElse
operator|=
operator|new
name|TIntermRaw
argument_list|(
operator|*
name|mFunctionType
argument_list|,
name|rawText
argument_list|)
expr_stmt|;
block|}
name|TIntermSymbol
modifier|*
name|conditionSymbolElse
init|=
name|MakeNewTemporary
argument_list|(
name|temporaryName
argument_list|,
name|EbtBool
argument_list|)
decl_stmt|;
name|TIntermUnary
modifier|*
name|negatedCondition
init|=
name|MakeNewUnary
argument_list|(
name|EOpLogicalNot
argument_list|,
name|conditionSymbolElse
argument_list|)
decl_stmt|;
name|falseBlock
operator|=
operator|new
name|TIntermSelection
argument_list|(
name|negatedCondition
argument_list|,
name|selection
operator|->
name|getFalseBlock
argument_list|()
argument_list|,
name|negatedElse
argument_list|)
expr_stmt|;
block|}
name|TIntermSymbol
modifier|*
name|conditionSymbolSel
init|=
name|MakeNewTemporary
argument_list|(
name|temporaryName
argument_list|,
name|EbtBool
argument_list|)
decl_stmt|;
name|TIntermSelection
modifier|*
name|newSelection
init|=
operator|new
name|TIntermSelection
argument_list|(
name|conditionSymbolSel
argument_list|,
name|selection
operator|->
name|getTrueBlock
argument_list|()
argument_list|,
name|falseBlock
argument_list|)
decl_stmt|;
name|TIntermAggregate
modifier|*
name|declaration
init|=
operator|new
name|TIntermAggregate
argument_list|(
name|EOpDeclaration
argument_list|)
decl_stmt|;
name|declaration
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|storeCondition
argument_list|)
expr_stmt|;
name|TIntermAggregate
modifier|*
name|block
init|=
operator|new
name|TIntermAggregate
argument_list|(
name|EOpSequence
argument_list|)
decl_stmt|;
name|block
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|declaration
argument_list|)
expr_stmt|;
name|block
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|newSelection
argument_list|)
expr_stmt|;
return|return
name|block
return|;
block|}
block|}
DECL|function|RewriteElseBlocks
name|void
name|RewriteElseBlocks
parameter_list|(
name|TIntermNode
modifier|*
name|node
parameter_list|)
block|{
name|ElseBlockRewriter
name|rewriter
decl_stmt|;
name|node
operator|->
name|traverse
argument_list|(
operator|&
name|rewriter
argument_list|)
expr_stmt|;
block|}
block|}
end_namespace
end_unit
