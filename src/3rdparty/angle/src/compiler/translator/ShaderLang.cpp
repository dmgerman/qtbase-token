begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2013 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Implement the top-level of interface to the compiler,
end_comment
begin_comment
comment|// as defined in ShaderLang.h
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|"GLSLANG/ShaderLang.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/Compiler.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/InitializeDll.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/length_limits.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/TranslatorHLSL.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/VariablePacker.h"
end_include
begin_include
include|#
directive|include
file|"angle_gl.h"
end_include
begin_decl_stmt
DECL|variable|isInitialized
specifier|static
name|bool
name|isInitialized
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// This is the platform independent interface between an OGL driver
end_comment
begin_comment
comment|// and the shading language compiler.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|checkVariableMaxLengths
specifier|static
name|bool
name|checkVariableMaxLengths
parameter_list|(
specifier|const
name|ShHandle
name|handle
parameter_list|,
name|size_t
name|expectedValue
parameter_list|)
block|{
name|size_t
name|activeUniformLimit
init|=
literal|0
decl_stmt|;
name|ShGetInfo
argument_list|(
name|handle
argument_list|,
name|SH_ACTIVE_UNIFORM_MAX_LENGTH
argument_list|,
operator|&
name|activeUniformLimit
argument_list|)
expr_stmt|;
name|size_t
name|activeAttribLimit
init|=
literal|0
decl_stmt|;
name|ShGetInfo
argument_list|(
name|handle
argument_list|,
name|SH_ACTIVE_ATTRIBUTE_MAX_LENGTH
argument_list|,
operator|&
name|activeAttribLimit
argument_list|)
expr_stmt|;
name|size_t
name|varyingLimit
init|=
literal|0
decl_stmt|;
name|ShGetInfo
argument_list|(
name|handle
argument_list|,
name|SH_VARYING_MAX_LENGTH
argument_list|,
operator|&
name|varyingLimit
argument_list|)
expr_stmt|;
return|return
operator|(
name|expectedValue
operator|==
name|activeUniformLimit
operator|&&
name|expectedValue
operator|==
name|activeAttribLimit
operator|&&
name|expectedValue
operator|==
name|varyingLimit
operator|)
return|;
block|}
end_function
begin_function
DECL|function|checkMappedNameMaxLength
specifier|static
name|bool
name|checkMappedNameMaxLength
parameter_list|(
specifier|const
name|ShHandle
name|handle
parameter_list|,
name|size_t
name|expectedValue
parameter_list|)
block|{
name|size_t
name|mappedNameMaxLength
init|=
literal|0
decl_stmt|;
name|ShGetInfo
argument_list|(
name|handle
argument_list|,
name|SH_MAPPED_NAME_MAX_LENGTH
argument_list|,
operator|&
name|mappedNameMaxLength
argument_list|)
expr_stmt|;
return|return
operator|(
name|expectedValue
operator|==
name|mappedNameMaxLength
operator|)
return|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|VarT
parameter_list|>
DECL|function|ReturnVariable
specifier|static
specifier|const
name|sh
operator|::
name|ShaderVariable
modifier|*
name|ReturnVariable
parameter_list|(
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|VarT
argument_list|>
modifier|&
name|infoList
parameter_list|,
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|index
operator|<
literal|0
operator|||
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|index
argument_list|)
operator|>=
name|infoList
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
operator|&
name|infoList
index|[
name|index
index|]
return|;
block|}
end_function
begin_function
DECL|function|GetVariable
specifier|static
specifier|const
name|sh
operator|::
name|ShaderVariable
modifier|*
name|GetVariable
parameter_list|(
specifier|const
name|TCompiler
modifier|*
name|compiler
parameter_list|,
name|ShShaderInfo
name|varType
parameter_list|,
name|int
name|index
parameter_list|)
block|{
switch|switch
condition|(
name|varType
condition|)
block|{
case|case
name|SH_ACTIVE_ATTRIBUTES
case|:
return|return
name|ReturnVariable
argument_list|(
name|compiler
operator|->
name|getAttributes
argument_list|()
argument_list|,
name|index
argument_list|)
return|;
case|case
name|SH_ACTIVE_UNIFORMS
case|:
return|return
name|ReturnVariable
argument_list|(
name|compiler
operator|->
name|getExpandedUniforms
argument_list|()
argument_list|,
name|index
argument_list|)
return|;
case|case
name|SH_VARYINGS
case|:
return|return
name|ReturnVariable
argument_list|(
name|compiler
operator|->
name|getExpandedVaryings
argument_list|()
argument_list|,
name|index
argument_list|)
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function
begin_function
DECL|function|ConvertPrecision
specifier|static
name|ShPrecisionType
name|ConvertPrecision
parameter_list|(
name|sh
operator|::
name|GLenum
name|precision
parameter_list|)
block|{
switch|switch
condition|(
name|precision
condition|)
block|{
case|case
name|GL_HIGH_FLOAT
case|:
case|case
name|GL_HIGH_INT
case|:
return|return
name|SH_PRECISION_HIGHP
return|;
case|case
name|GL_MEDIUM_FLOAT
case|:
case|case
name|GL_MEDIUM_INT
case|:
return|return
name|SH_PRECISION_MEDIUMP
return|;
case|case
name|GL_LOW_FLOAT
case|:
case|case
name|GL_LOW_INT
case|:
return|return
name|SH_PRECISION_LOWP
return|;
default|default:
return|return
name|SH_PRECISION_UNDEFINED
return|;
block|}
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Driver must call this first, once, before doing any other compiler operations.
end_comment
begin_comment
comment|// Subsequent calls to this function are no-op.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|ShInitialize
name|int
name|ShInitialize
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isInitialized
condition|)
block|{
name|isInitialized
operator|=
name|InitProcess
argument_list|()
expr_stmt|;
block|}
return|return
name|isInitialized
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Cleanup symbol tables
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|ShFinalize
name|int
name|ShFinalize
parameter_list|()
block|{
if|if
condition|(
name|isInitialized
condition|)
block|{
name|DetachProcess
argument_list|()
expr_stmt|;
name|isInitialized
operator|=
literal|false
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Initialize built-in resources with minimum expected values.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|ShInitBuiltInResources
name|void
name|ShInitBuiltInResources
parameter_list|(
name|ShBuiltInResources
modifier|*
name|resources
parameter_list|)
block|{
comment|// Constants.
name|resources
operator|->
name|MaxVertexAttribs
operator|=
literal|8
expr_stmt|;
name|resources
operator|->
name|MaxVertexUniformVectors
operator|=
literal|128
expr_stmt|;
name|resources
operator|->
name|MaxVaryingVectors
operator|=
literal|8
expr_stmt|;
name|resources
operator|->
name|MaxVertexTextureImageUnits
operator|=
literal|0
expr_stmt|;
name|resources
operator|->
name|MaxCombinedTextureImageUnits
operator|=
literal|8
expr_stmt|;
name|resources
operator|->
name|MaxTextureImageUnits
operator|=
literal|8
expr_stmt|;
name|resources
operator|->
name|MaxFragmentUniformVectors
operator|=
literal|16
expr_stmt|;
name|resources
operator|->
name|MaxDrawBuffers
operator|=
literal|1
expr_stmt|;
comment|// Extensions.
name|resources
operator|->
name|OES_standard_derivatives
operator|=
literal|0
expr_stmt|;
name|resources
operator|->
name|OES_EGL_image_external
operator|=
literal|0
expr_stmt|;
name|resources
operator|->
name|ARB_texture_rectangle
operator|=
literal|0
expr_stmt|;
name|resources
operator|->
name|EXT_draw_buffers
operator|=
literal|0
expr_stmt|;
name|resources
operator|->
name|EXT_frag_depth
operator|=
literal|0
expr_stmt|;
name|resources
operator|->
name|EXT_shader_texture_lod
operator|=
literal|0
expr_stmt|;
comment|// Disable highp precision in fragment shader by default.
name|resources
operator|->
name|FragmentPrecisionHigh
operator|=
literal|0
expr_stmt|;
comment|// GLSL ES 3.0 constants.
name|resources
operator|->
name|MaxVertexOutputVectors
operator|=
literal|16
expr_stmt|;
name|resources
operator|->
name|MaxFragmentInputVectors
operator|=
literal|15
expr_stmt|;
name|resources
operator|->
name|MinProgramTexelOffset
operator|=
operator|-
literal|8
expr_stmt|;
name|resources
operator|->
name|MaxProgramTexelOffset
operator|=
literal|7
expr_stmt|;
comment|// Disable name hashing by default.
name|resources
operator|->
name|HashFunction
operator|=
name|NULL
expr_stmt|;
name|resources
operator|->
name|ArrayIndexClampingStrategy
operator|=
name|SH_CLAMP_WITH_CLAMP_INTRINSIC
expr_stmt|;
name|resources
operator|->
name|MaxExpressionComplexity
operator|=
literal|256
expr_stmt|;
name|resources
operator|->
name|MaxCallStackDepth
operator|=
literal|256
expr_stmt|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Driver calls these to create and destroy compiler objects.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|ShConstructCompiler
name|ShHandle
name|ShConstructCompiler
parameter_list|(
name|sh
operator|::
name|GLenum
name|type
parameter_list|,
name|ShShaderSpec
name|spec
parameter_list|,
name|ShShaderOutput
name|output
parameter_list|,
specifier|const
name|ShBuiltInResources
modifier|*
name|resources
parameter_list|)
block|{
name|TShHandleBase
modifier|*
name|base
init|=
cast|static_cast
argument_list|<
name|TShHandleBase
operator|*
argument_list|>
argument_list|(
name|ConstructCompiler
argument_list|(
name|type
argument_list|,
name|spec
argument_list|,
name|output
argument_list|)
argument_list|)
decl_stmt|;
name|TCompiler
modifier|*
name|compiler
init|=
name|base
operator|->
name|getAsCompiler
argument_list|()
decl_stmt|;
if|if
condition|(
name|compiler
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|// Generate built-in symbol table.
if|if
condition|(
operator|!
name|compiler
operator|->
name|Init
argument_list|(
operator|*
name|resources
argument_list|)
condition|)
block|{
name|ShDestruct
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
cast|reinterpret_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
name|base
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|ShDestruct
name|void
name|ShDestruct
parameter_list|(
name|ShHandle
name|handle
parameter_list|)
block|{
if|if
condition|(
name|handle
operator|==
literal|0
condition|)
return|return;
name|TShHandleBase
modifier|*
name|base
init|=
cast|static_cast
argument_list|<
name|TShHandleBase
operator|*
argument_list|>
argument_list|(
name|handle
argument_list|)
decl_stmt|;
if|if
condition|(
name|base
operator|->
name|getAsCompiler
argument_list|()
condition|)
name|DeleteCompiler
argument_list|(
name|base
operator|->
name|getAsCompiler
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|ShGetBuiltInResourcesString
name|void
name|ShGetBuiltInResourcesString
parameter_list|(
specifier|const
name|ShHandle
name|handle
parameter_list|,
name|size_t
name|outStringLen
parameter_list|,
name|char
modifier|*
name|outString
parameter_list|)
block|{
if|if
condition|(
operator|!
name|handle
operator|||
operator|!
name|outString
condition|)
block|{
return|return;
block|}
name|TShHandleBase
modifier|*
name|base
init|=
cast|static_cast
argument_list|<
name|TShHandleBase
operator|*
argument_list|>
argument_list|(
name|handle
argument_list|)
decl_stmt|;
name|TCompiler
modifier|*
name|compiler
init|=
name|base
operator|->
name|getAsCompiler
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|compiler
condition|)
block|{
return|return;
block|}
name|strncpy
argument_list|(
name|outString
argument_list|,
name|compiler
operator|->
name|getBuiltInResourcesString
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|,
name|outStringLen
argument_list|)
expr_stmt|;
name|outString
index|[
name|outStringLen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Do an actual compile on the given strings.  The result is left
end_comment
begin_comment
comment|// in the given compile object.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Return:  The return value of ShCompile is really boolean, indicating
end_comment
begin_comment
comment|// success or failure.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|ShCompile
name|int
name|ShCompile
parameter_list|(
specifier|const
name|ShHandle
name|handle
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
name|shaderStrings
index|[]
parameter_list|,
name|size_t
name|numStrings
parameter_list|,
name|int
name|compileOptions
parameter_list|)
block|{
if|if
condition|(
name|handle
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|TShHandleBase
modifier|*
name|base
init|=
cast|reinterpret_cast
argument_list|<
name|TShHandleBase
operator|*
argument_list|>
argument_list|(
name|handle
argument_list|)
decl_stmt|;
name|TCompiler
modifier|*
name|compiler
init|=
name|base
operator|->
name|getAsCompiler
argument_list|()
decl_stmt|;
if|if
condition|(
name|compiler
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|bool
name|success
init|=
name|compiler
operator|->
name|compile
argument_list|(
name|shaderStrings
argument_list|,
name|numStrings
argument_list|,
name|compileOptions
argument_list|)
decl_stmt|;
return|return
name|success
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function
begin_function
DECL|function|ShGetInfo
name|void
name|ShGetInfo
parameter_list|(
specifier|const
name|ShHandle
name|handle
parameter_list|,
name|ShShaderInfo
name|pname
parameter_list|,
name|size_t
modifier|*
name|params
parameter_list|)
block|{
if|if
condition|(
operator|!
name|handle
operator|||
operator|!
name|params
condition|)
return|return;
name|TShHandleBase
modifier|*
name|base
init|=
cast|static_cast
argument_list|<
name|TShHandleBase
operator|*
argument_list|>
argument_list|(
name|handle
argument_list|)
decl_stmt|;
name|TCompiler
modifier|*
name|compiler
init|=
name|base
operator|->
name|getAsCompiler
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|compiler
condition|)
return|return;
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|SH_INFO_LOG_LENGTH
case|:
operator|*
name|params
operator|=
name|compiler
operator|->
name|getInfoSink
argument_list|()
operator|.
name|info
operator|.
name|size
argument_list|()
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|SH_OBJECT_CODE_LENGTH
case|:
operator|*
name|params
operator|=
name|compiler
operator|->
name|getInfoSink
argument_list|()
operator|.
name|obj
operator|.
name|size
argument_list|()
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|SH_ACTIVE_UNIFORMS
case|:
operator|*
name|params
operator|=
name|compiler
operator|->
name|getExpandedUniforms
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
break|break;
case|case
name|SH_ACTIVE_UNIFORM_MAX_LENGTH
case|:
operator|*
name|params
operator|=
literal|1
operator|+
name|GetGlobalMaxTokenSize
argument_list|(
name|compiler
operator|->
name|getShaderSpec
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|SH_ACTIVE_ATTRIBUTES
case|:
operator|*
name|params
operator|=
name|compiler
operator|->
name|getAttributes
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
break|break;
case|case
name|SH_ACTIVE_ATTRIBUTE_MAX_LENGTH
case|:
operator|*
name|params
operator|=
literal|1
operator|+
name|GetGlobalMaxTokenSize
argument_list|(
name|compiler
operator|->
name|getShaderSpec
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|SH_VARYINGS
case|:
operator|*
name|params
operator|=
name|compiler
operator|->
name|getExpandedVaryings
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
break|break;
case|case
name|SH_VARYING_MAX_LENGTH
case|:
operator|*
name|params
operator|=
literal|1
operator|+
name|GetGlobalMaxTokenSize
argument_list|(
name|compiler
operator|->
name|getShaderSpec
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|SH_MAPPED_NAME_MAX_LENGTH
case|:
comment|// Use longer length than MAX_SHORTENED_IDENTIFIER_SIZE to
comment|// handle array and struct dereferences.
operator|*
name|params
operator|=
literal|1
operator|+
name|GetGlobalMaxTokenSize
argument_list|(
name|compiler
operator|->
name|getShaderSpec
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|SH_NAME_MAX_LENGTH
case|:
operator|*
name|params
operator|=
literal|1
operator|+
name|GetGlobalMaxTokenSize
argument_list|(
name|compiler
operator|->
name|getShaderSpec
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|SH_HASHED_NAME_MAX_LENGTH
case|:
if|if
condition|(
name|compiler
operator|->
name|getHashFunction
argument_list|()
operator|==
name|NULL
condition|)
block|{
operator|*
name|params
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// 64 bits hashing output requires 16 bytes for hex
comment|// representation.
specifier|const
name|char
name|HashedNamePrefix
index|[]
init|=
name|HASHED_NAME_PREFIX
decl_stmt|;
operator|(
name|void
operator|)
name|HashedNamePrefix
expr_stmt|;
operator|*
name|params
operator|=
literal|16
operator|+
sizeof|sizeof
argument_list|(
name|HashedNamePrefix
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SH_HASHED_NAMES_COUNT
case|:
operator|*
name|params
operator|=
name|compiler
operator|->
name|getNameMap
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
break|break;
case|case
name|SH_SHADER_VERSION
case|:
operator|*
name|params
operator|=
name|compiler
operator|->
name|getShaderVersion
argument_list|()
expr_stmt|;
break|break;
case|case
name|SH_RESOURCES_STRING_LENGTH
case|:
operator|*
name|params
operator|=
name|compiler
operator|->
name|getBuiltInResourcesString
argument_list|()
operator|.
name|length
argument_list|()
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|SH_OUTPUT_TYPE
case|:
operator|*
name|params
operator|=
name|compiler
operator|->
name|getOutputType
argument_list|()
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Return any compiler log of messages for the application.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|ShGetInfoLog
name|void
name|ShGetInfoLog
parameter_list|(
specifier|const
name|ShHandle
name|handle
parameter_list|,
name|char
modifier|*
name|infoLog
parameter_list|)
block|{
if|if
condition|(
operator|!
name|handle
operator|||
operator|!
name|infoLog
condition|)
return|return;
name|TShHandleBase
modifier|*
name|base
init|=
cast|static_cast
argument_list|<
name|TShHandleBase
operator|*
argument_list|>
argument_list|(
name|handle
argument_list|)
decl_stmt|;
name|TCompiler
modifier|*
name|compiler
init|=
name|base
operator|->
name|getAsCompiler
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|compiler
condition|)
return|return;
name|TInfoSink
modifier|&
name|infoSink
init|=
name|compiler
operator|->
name|getInfoSink
argument_list|()
decl_stmt|;
name|strcpy
argument_list|(
name|infoLog
argument_list|,
name|infoSink
operator|.
name|info
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Return any object code.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|ShGetObjectCode
name|void
name|ShGetObjectCode
parameter_list|(
specifier|const
name|ShHandle
name|handle
parameter_list|,
name|char
modifier|*
name|objCode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|handle
operator|||
operator|!
name|objCode
condition|)
return|return;
name|TShHandleBase
modifier|*
name|base
init|=
cast|static_cast
argument_list|<
name|TShHandleBase
operator|*
argument_list|>
argument_list|(
name|handle
argument_list|)
decl_stmt|;
name|TCompiler
modifier|*
name|compiler
init|=
name|base
operator|->
name|getAsCompiler
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|compiler
condition|)
return|return;
name|TInfoSink
modifier|&
name|infoSink
init|=
name|compiler
operator|->
name|getInfoSink
argument_list|()
decl_stmt|;
name|strcpy
argument_list|(
name|objCode
argument_list|,
name|infoSink
operator|.
name|obj
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|ShGetVariableInfo
name|void
name|ShGetVariableInfo
parameter_list|(
specifier|const
name|ShHandle
name|handle
parameter_list|,
name|ShShaderInfo
name|varType
parameter_list|,
name|int
name|index
parameter_list|,
name|size_t
modifier|*
name|length
parameter_list|,
name|int
modifier|*
name|size
parameter_list|,
name|sh
operator|::
name|GLenum
modifier|*
name|type
parameter_list|,
name|ShPrecisionType
modifier|*
name|precision
parameter_list|,
name|int
modifier|*
name|staticUse
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|mappedName
parameter_list|)
block|{
if|if
condition|(
operator|!
name|handle
operator|||
operator|!
name|size
operator|||
operator|!
name|type
operator|||
operator|!
name|precision
operator|||
operator|!
name|staticUse
operator|||
operator|!
name|name
condition|)
return|return;
name|ASSERT
argument_list|(
operator|(
name|varType
operator|==
name|SH_ACTIVE_ATTRIBUTES
operator|)
operator|||
operator|(
name|varType
operator|==
name|SH_ACTIVE_UNIFORMS
operator|)
operator|||
operator|(
name|varType
operator|==
name|SH_VARYINGS
operator|)
argument_list|)
expr_stmt|;
name|TShHandleBase
modifier|*
name|base
init|=
cast|reinterpret_cast
argument_list|<
name|TShHandleBase
operator|*
argument_list|>
argument_list|(
name|handle
argument_list|)
decl_stmt|;
name|TCompiler
modifier|*
name|compiler
init|=
name|base
operator|->
name|getAsCompiler
argument_list|()
decl_stmt|;
if|if
condition|(
name|compiler
operator|==
literal|0
condition|)
return|return;
specifier|const
name|sh
operator|::
name|ShaderVariable
modifier|*
name|varInfo
init|=
name|GetVariable
argument_list|(
name|compiler
argument_list|,
name|varType
argument_list|,
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|varInfo
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|length
condition|)
operator|*
name|length
operator|=
name|varInfo
operator|->
name|name
operator|.
name|size
argument_list|()
expr_stmt|;
operator|*
name|size
operator|=
name|varInfo
operator|->
name|elementCount
argument_list|()
expr_stmt|;
operator|*
name|type
operator|=
name|varInfo
operator|->
name|type
expr_stmt|;
operator|*
name|precision
operator|=
name|ConvertPrecision
argument_list|(
name|varInfo
operator|->
name|precision
argument_list|)
expr_stmt|;
operator|*
name|staticUse
operator|=
name|varInfo
operator|->
name|staticUse
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|// This size must match that queried by
comment|// SH_ACTIVE_UNIFORM_MAX_LENGTH, SH_ACTIVE_ATTRIBUTE_MAX_LENGTH, SH_VARYING_MAX_LENGTH
comment|// in ShGetInfo, below.
name|size_t
name|variableLength
init|=
literal|1
operator|+
name|GetGlobalMaxTokenSize
argument_list|(
name|compiler
operator|->
name|getShaderSpec
argument_list|()
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|checkVariableMaxLengths
argument_list|(
name|handle
argument_list|,
name|variableLength
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
name|varInfo
operator|->
name|name
operator|.
name|c_str
argument_list|()
argument_list|,
name|variableLength
argument_list|)
expr_stmt|;
name|name
index|[
name|variableLength
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mappedName
condition|)
block|{
comment|// This size must match that queried by
comment|// SH_MAPPED_NAME_MAX_LENGTH in ShGetInfo, below.
name|size_t
name|maxMappedNameLength
init|=
literal|1
operator|+
name|GetGlobalMaxTokenSize
argument_list|(
name|compiler
operator|->
name|getShaderSpec
argument_list|()
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|checkMappedNameMaxLength
argument_list|(
name|handle
argument_list|,
name|maxMappedNameLength
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|mappedName
argument_list|,
name|varInfo
operator|->
name|mappedName
operator|.
name|c_str
argument_list|()
argument_list|,
name|maxMappedNameLength
argument_list|)
expr_stmt|;
name|mappedName
index|[
name|maxMappedNameLength
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|ShGetNameHashingEntry
name|void
name|ShGetNameHashingEntry
parameter_list|(
specifier|const
name|ShHandle
name|handle
parameter_list|,
name|int
name|index
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|hashedName
parameter_list|)
block|{
if|if
condition|(
operator|!
name|handle
operator|||
operator|!
name|name
operator|||
operator|!
name|hashedName
operator|||
name|index
operator|<
literal|0
condition|)
return|return;
name|TShHandleBase
modifier|*
name|base
init|=
cast|static_cast
argument_list|<
name|TShHandleBase
operator|*
argument_list|>
argument_list|(
name|handle
argument_list|)
decl_stmt|;
name|TCompiler
modifier|*
name|compiler
init|=
name|base
operator|->
name|getAsCompiler
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|compiler
condition|)
return|return;
specifier|const
name|NameMap
modifier|&
name|nameMap
init|=
name|compiler
operator|->
name|getNameMap
argument_list|()
decl_stmt|;
if|if
condition|(
name|index
operator|>=
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|nameMap
operator|.
name|size
argument_list|()
argument_list|)
condition|)
return|return;
name|NameMap
operator|::
name|const_iterator
name|it
init|=
name|nameMap
operator|.
name|begin
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|index
condition|;
operator|++
name|i
control|)
operator|++
name|it
expr_stmt|;
name|size_t
name|len
init|=
name|it
operator|->
name|first
operator|.
name|length
argument_list|()
operator|+
literal|1
decl_stmt|;
name|size_t
name|max_len
init|=
literal|0
decl_stmt|;
name|ShGetInfo
argument_list|(
name|handle
argument_list|,
name|SH_NAME_MAX_LENGTH
argument_list|,
operator|&
name|max_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|max_len
condition|)
block|{
name|ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|len
operator|=
name|max_len
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|name
argument_list|,
name|it
operator|->
name|first
operator|.
name|c_str
argument_list|()
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|// To be on the safe side in case the source is longer than expected.
name|name
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|=
name|it
operator|->
name|second
operator|.
name|length
argument_list|()
operator|+
literal|1
expr_stmt|;
name|max_len
operator|=
literal|0
expr_stmt|;
name|ShGetInfo
argument_list|(
name|handle
argument_list|,
name|SH_HASHED_NAME_MAX_LENGTH
argument_list|,
operator|&
name|max_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|max_len
condition|)
block|{
name|ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|len
operator|=
name|max_len
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|hashedName
argument_list|,
name|it
operator|->
name|second
operator|.
name|c_str
argument_list|()
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|// To be on the safe side in case the source is longer than expected.
name|hashedName
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function
begin_function
DECL|function|ShGetInfoPointer
name|void
name|ShGetInfoPointer
parameter_list|(
specifier|const
name|ShHandle
name|handle
parameter_list|,
name|ShShaderInfo
name|pname
parameter_list|,
name|void
modifier|*
modifier|*
name|params
parameter_list|)
block|{
if|if
condition|(
operator|!
name|handle
operator|||
operator|!
name|params
condition|)
return|return;
name|TShHandleBase
modifier|*
name|base
init|=
cast|static_cast
argument_list|<
name|TShHandleBase
operator|*
argument_list|>
argument_list|(
name|handle
argument_list|)
decl_stmt|;
name|TranslatorHLSL
modifier|*
name|translator
init|=
name|base
operator|->
name|getAsTranslatorHLSL
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|translator
condition|)
return|return;
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|SH_ACTIVE_UNIFORMS_ARRAY
case|:
operator|*
name|params
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|translator
operator|->
name|getUniforms
argument_list|()
expr_stmt|;
break|break;
case|case
name|SH_ACTIVE_INTERFACE_BLOCKS_ARRAY
case|:
operator|*
name|params
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|translator
operator|->
name|getInterfaceBlocks
argument_list|()
expr_stmt|;
break|break;
case|case
name|SH_ACTIVE_OUTPUT_VARIABLES_ARRAY
case|:
operator|*
name|params
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|translator
operator|->
name|getOutputVariables
argument_list|()
expr_stmt|;
break|break;
case|case
name|SH_ACTIVE_ATTRIBUTES_ARRAY
case|:
operator|*
name|params
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|translator
operator|->
name|getAttributes
argument_list|()
expr_stmt|;
break|break;
case|case
name|SH_ACTIVE_VARYINGS_ARRAY
case|:
operator|*
name|params
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|translator
operator|->
name|getVaryings
argument_list|()
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|ShCheckVariablesWithinPackingLimits
name|int
name|ShCheckVariablesWithinPackingLimits
parameter_list|(
name|int
name|maxVectors
parameter_list|,
name|ShVariableInfo
modifier|*
name|varInfoArray
parameter_list|,
name|size_t
name|varInfoArraySize
parameter_list|)
block|{
if|if
condition|(
name|varInfoArraySize
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|ASSERT
argument_list|(
name|varInfoArray
argument_list|)
expr_stmt|;
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|ShaderVariable
argument_list|>
name|variables
decl_stmt|;
for|for
control|(
name|size_t
name|ii
init|=
literal|0
init|;
name|ii
operator|<
name|varInfoArraySize
condition|;
operator|++
name|ii
control|)
block|{
name|sh
operator|::
name|ShaderVariable
name|var
argument_list|(
name|varInfoArray
index|[
name|ii
index|]
operator|.
name|type
argument_list|,
operator|(
name|sh
operator|::
name|GLenum
operator|)
literal|0
argument_list|,
literal|""
argument_list|,
name|varInfoArray
index|[
name|ii
index|]
operator|.
name|size
argument_list|)
decl_stmt|;
name|variables
operator|.
name|push_back
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
name|VariablePacker
name|packer
decl_stmt|;
return|return
name|packer
operator|.
name|CheckVariablesWithinPackingLimits
argument_list|(
name|maxVectors
argument_list|,
name|variables
argument_list|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function
begin_function
DECL|function|ShGetInterfaceBlockRegister
name|bool
name|ShGetInterfaceBlockRegister
parameter_list|(
specifier|const
name|ShHandle
name|handle
parameter_list|,
specifier|const
name|char
modifier|*
name|interfaceBlockName
parameter_list|,
name|unsigned
name|int
modifier|*
name|indexOut
parameter_list|)
block|{
if|if
condition|(
operator|!
name|handle
operator|||
operator|!
name|interfaceBlockName
operator|||
operator|!
name|indexOut
condition|)
block|{
return|return
literal|false
return|;
block|}
name|TShHandleBase
modifier|*
name|base
init|=
cast|static_cast
argument_list|<
name|TShHandleBase
operator|*
argument_list|>
argument_list|(
name|handle
argument_list|)
decl_stmt|;
name|TranslatorHLSL
modifier|*
name|translator
init|=
name|base
operator|->
name|getAsTranslatorHLSL
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|translator
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|translator
operator|->
name|hasInterfaceBlock
argument_list|(
name|interfaceBlockName
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
operator|*
name|indexOut
operator|=
name|translator
operator|->
name|getInterfaceBlockRegister
argument_list|(
name|interfaceBlockName
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|ShGetUniformRegister
name|bool
name|ShGetUniformRegister
parameter_list|(
specifier|const
name|ShHandle
name|handle
parameter_list|,
specifier|const
name|char
modifier|*
name|uniformName
parameter_list|,
name|unsigned
name|int
modifier|*
name|indexOut
parameter_list|)
block|{
if|if
condition|(
operator|!
name|handle
operator|||
operator|!
name|uniformName
operator|||
operator|!
name|indexOut
condition|)
block|{
return|return
literal|false
return|;
block|}
name|TShHandleBase
modifier|*
name|base
init|=
cast|static_cast
argument_list|<
name|TShHandleBase
operator|*
argument_list|>
argument_list|(
name|handle
argument_list|)
decl_stmt|;
name|TranslatorHLSL
modifier|*
name|translator
init|=
name|base
operator|->
name|getAsTranslatorHLSL
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|translator
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|translator
operator|->
name|hasUniform
argument_list|(
name|uniformName
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
operator|*
name|indexOut
operator|=
name|translator
operator|->
name|getUniformRegister
argument_list|(
name|uniformName
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
end_unit
