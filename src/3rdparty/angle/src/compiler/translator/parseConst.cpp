begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|"compiler/translator/ParseContext.h"
end_include
begin_comment
comment|//
end_comment
begin_comment
comment|// Use this class to carry along data from node to node in
end_comment
begin_comment
comment|// the traversal
end_comment
begin_comment
comment|//
end_comment
begin_class
DECL|class|TConstTraverser
class|class
name|TConstTraverser
super|:
specifier|public
name|TIntermTraverser
block|{
public|public:
DECL|function|TConstTraverser
name|TConstTraverser
parameter_list|(
name|ConstantUnion
modifier|*
name|cUnion
parameter_list|,
name|bool
name|singleConstParam
parameter_list|,
name|TOperator
name|constructType
parameter_list|,
name|TInfoSink
modifier|&
name|sink
parameter_list|,
name|TType
modifier|&
name|t
parameter_list|)
member_init_list|:
name|error
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mIndex
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mUnionArray
argument_list|(
name|cUnion
argument_list|)
member_init_list|,
name|mType
argument_list|(
name|t
argument_list|)
member_init_list|,
name|mConstructorType
argument_list|(
name|constructType
argument_list|)
member_init_list|,
name|mSingleConstantParam
argument_list|(
name|singleConstParam
argument_list|)
member_init_list|,
name|mInfoSink
argument_list|(
name|sink
argument_list|)
member_init_list|,
name|mSize
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mIsDiagonalMatrixInit
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mMatrixCols
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mMatrixRows
argument_list|(
literal|0
argument_list|)
block|{     }
DECL|member|error
name|bool
name|error
decl_stmt|;
protected|protected:
name|void
name|visitSymbol
parameter_list|(
name|TIntermSymbol
modifier|*
parameter_list|)
function_decl|;
name|void
name|visitConstantUnion
parameter_list|(
name|TIntermConstantUnion
modifier|*
parameter_list|)
function_decl|;
name|bool
name|visitBinary
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermBinary
modifier|*
parameter_list|)
function_decl|;
name|bool
name|visitUnary
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermUnary
modifier|*
parameter_list|)
function_decl|;
name|bool
name|visitSelection
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermSelection
modifier|*
parameter_list|)
function_decl|;
name|bool
name|visitAggregate
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermAggregate
modifier|*
parameter_list|)
function_decl|;
name|bool
name|visitLoop
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermLoop
modifier|*
parameter_list|)
function_decl|;
name|bool
name|visitBranch
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermBranch
modifier|*
parameter_list|)
function_decl|;
DECL|member|mIndex
name|size_t
name|mIndex
decl_stmt|;
DECL|member|mUnionArray
name|ConstantUnion
modifier|*
name|mUnionArray
decl_stmt|;
DECL|member|mType
name|TType
name|mType
decl_stmt|;
DECL|member|mConstructorType
name|TOperator
name|mConstructorType
decl_stmt|;
DECL|member|mSingleConstantParam
name|bool
name|mSingleConstantParam
decl_stmt|;
DECL|member|mInfoSink
name|TInfoSink
modifier|&
name|mInfoSink
decl_stmt|;
DECL|member|mSize
name|size_t
name|mSize
decl_stmt|;
comment|// size of the constructor ( 4 for vec4)
DECL|member|mIsDiagonalMatrixInit
name|bool
name|mIsDiagonalMatrixInit
decl_stmt|;
DECL|member|mMatrixCols
name|int
name|mMatrixCols
decl_stmt|;
comment|// columns of the matrix
DECL|member|mMatrixRows
name|int
name|mMatrixRows
decl_stmt|;
comment|// rows of the matrix
block|}
class|;
end_class
begin_comment
comment|//
end_comment
begin_comment
comment|// The rest of the file are the traversal functions.  The last one
end_comment
begin_comment
comment|// is the one that starts the traversal.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Return true from interior nodes to have the external traversal
end_comment
begin_comment
comment|// continue on to children.  If you process children yourself,
end_comment
begin_comment
comment|// return false.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|visitSymbol
name|void
name|TConstTraverser
operator|::
name|visitSymbol
parameter_list|(
name|TIntermSymbol
modifier|*
name|node
parameter_list|)
block|{
name|mInfoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|node
operator|->
name|getLine
argument_list|()
argument_list|,
literal|"Symbol Node found in constant constructor"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function
begin_function
DECL|function|visitBinary
name|bool
name|TConstTraverser
operator|::
name|visitBinary
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermBinary
modifier|*
name|node
parameter_list|)
block|{
name|TQualifier
name|qualifier
init|=
name|node
operator|->
name|getType
argument_list|()
operator|.
name|getQualifier
argument_list|()
decl_stmt|;
if|if
condition|(
name|qualifier
operator|!=
name|EvqConst
condition|)
block|{
name|TString
name|buf
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"'constructor' : assigning non-constant to "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|mType
operator|.
name|getCompleteString
argument_list|()
argument_list|)
expr_stmt|;
name|mInfoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixError
argument_list|,
name|node
operator|->
name|getLine
argument_list|()
argument_list|,
name|buf
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|error
operator|=
literal|true
expr_stmt|;
return|return
literal|false
return|;
block|}
name|mInfoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|node
operator|->
name|getLine
argument_list|()
argument_list|,
literal|"Binary Node found in constant constructor"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|visitUnary
name|bool
name|TConstTraverser
operator|::
name|visitUnary
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermUnary
modifier|*
name|node
parameter_list|)
block|{
name|TString
name|buf
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"'constructor' : assigning non-constant to "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|mType
operator|.
name|getCompleteString
argument_list|()
argument_list|)
expr_stmt|;
name|mInfoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixError
argument_list|,
name|node
operator|->
name|getLine
argument_list|()
argument_list|,
name|buf
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|error
operator|=
literal|true
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|visitAggregate
name|bool
name|TConstTraverser
operator|::
name|visitAggregate
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermAggregate
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|isConstructor
argument_list|()
operator|&&
name|node
operator|->
name|getOp
argument_list|()
operator|!=
name|EOpComma
condition|)
block|{
name|TString
name|buf
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"'constructor' : assigning non-constant to "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|mType
operator|.
name|getCompleteString
argument_list|()
argument_list|)
expr_stmt|;
name|mInfoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixError
argument_list|,
name|node
operator|->
name|getLine
argument_list|()
argument_list|,
name|buf
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|error
operator|=
literal|true
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|node
operator|->
name|getSequence
argument_list|()
operator|->
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|error
operator|=
literal|true
expr_stmt|;
return|return
literal|false
return|;
block|}
name|bool
name|flag
init|=
name|node
operator|->
name|getSequence
argument_list|()
operator|->
name|size
argument_list|()
operator|==
literal|1
operator|&&
operator|(
operator|*
name|node
operator|->
name|getSequence
argument_list|()
operator|)
index|[
literal|0
index|]
operator|->
name|getAsTyped
argument_list|()
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
name|mSingleConstantParam
operator|=
literal|true
expr_stmt|;
name|mConstructorType
operator|=
name|node
operator|->
name|getOp
argument_list|()
expr_stmt|;
name|mSize
operator|=
name|node
operator|->
name|getType
argument_list|()
operator|.
name|getObjectSize
argument_list|()
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getType
argument_list|()
operator|.
name|isMatrix
argument_list|()
condition|)
block|{
name|mIsDiagonalMatrixInit
operator|=
literal|true
expr_stmt|;
name|mMatrixCols
operator|=
name|node
operator|->
name|getType
argument_list|()
operator|.
name|getCols
argument_list|()
expr_stmt|;
name|mMatrixRows
operator|=
name|node
operator|->
name|getType
argument_list|()
operator|.
name|getRows
argument_list|()
expr_stmt|;
block|}
block|}
for|for
control|(
name|TIntermSequence
operator|::
name|iterator
name|p
init|=
name|node
operator|->
name|getSequence
argument_list|()
operator|->
name|begin
argument_list|()
init|;
name|p
operator|!=
name|node
operator|->
name|getSequence
argument_list|()
operator|->
name|end
argument_list|()
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|node
operator|->
name|getOp
argument_list|()
operator|==
name|EOpComma
condition|)
name|mIndex
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|p
operator|)
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag
condition|)
block|{
name|mSingleConstantParam
operator|=
literal|false
expr_stmt|;
name|mConstructorType
operator|=
name|EOpNull
expr_stmt|;
name|mSize
operator|=
literal|0
expr_stmt|;
name|mIsDiagonalMatrixInit
operator|=
literal|false
expr_stmt|;
name|mMatrixCols
operator|=
literal|0
expr_stmt|;
name|mMatrixRows
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|visitSelection
name|bool
name|TConstTraverser
operator|::
name|visitSelection
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermSelection
modifier|*
name|node
parameter_list|)
block|{
name|mInfoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|node
operator|->
name|getLine
argument_list|()
argument_list|,
literal|"Selection Node found in constant constructor"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|true
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|visitConstantUnion
name|void
name|TConstTraverser
operator|::
name|visitConstantUnion
parameter_list|(
name|TIntermConstantUnion
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|getUnionArrayPointer
argument_list|()
condition|)
block|{
comment|// The constant was not initialized, this should already have been logged
name|ASSERT
argument_list|(
name|mInfoSink
operator|.
name|info
operator|.
name|size
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|ConstantUnion
modifier|*
name|leftUnionArray
init|=
name|mUnionArray
decl_stmt|;
name|size_t
name|instanceSize
init|=
name|mType
operator|.
name|getObjectSize
argument_list|()
decl_stmt|;
name|TBasicType
name|basicType
init|=
name|mType
operator|.
name|getBasicType
argument_list|()
decl_stmt|;
if|if
condition|(
name|mIndex
operator|>=
name|instanceSize
condition|)
return|return;
if|if
condition|(
operator|!
name|mSingleConstantParam
condition|)
block|{
name|size_t
name|objectSize
init|=
name|node
operator|->
name|getType
argument_list|()
operator|.
name|getObjectSize
argument_list|()
decl_stmt|;
name|ConstantUnion
modifier|*
name|rightUnionArray
init|=
name|node
operator|->
name|getUnionArrayPointer
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|objectSize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mIndex
operator|>=
name|instanceSize
condition|)
return|return;
name|leftUnionArray
index|[
name|mIndex
index|]
operator|.
name|cast
argument_list|(
name|basicType
argument_list|,
name|rightUnionArray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|mIndex
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|size_t
name|totalSize
init|=
name|mIndex
operator|+
name|mSize
decl_stmt|;
name|ConstantUnion
modifier|*
name|rightUnionArray
init|=
name|node
operator|->
name|getUnionArrayPointer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|mIsDiagonalMatrixInit
condition|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
name|mIndex
init|;
name|i
operator|<
name|totalSize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|instanceSize
condition|)
return|return;
name|leftUnionArray
index|[
name|i
index|]
operator|.
name|cast
argument_list|(
name|basicType
argument_list|,
name|rightUnionArray
index|[
name|count
index|]
argument_list|)
expr_stmt|;
name|mIndex
operator|++
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getType
argument_list|()
operator|.
name|getObjectSize
argument_list|()
operator|>
literal|1
condition|)
name|count
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// for matrix diagonal constructors from a single scalar
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|col
init|=
literal|0
init|;
name|col
operator|<
name|mMatrixCols
condition|;
name|col
operator|++
control|)
block|{
for|for
control|(
name|int
name|row
init|=
literal|0
init|;
name|row
operator|<
name|mMatrixRows
condition|;
name|row
operator|++
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|col
operator|==
name|row
condition|)
block|{
name|leftUnionArray
index|[
name|i
index|]
operator|.
name|cast
argument_list|(
name|basicType
argument_list|,
name|rightUnionArray
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|leftUnionArray
index|[
name|i
index|]
operator|.
name|setFConst
argument_list|(
literal|0.0f
argument_list|)
expr_stmt|;
block|}
name|mIndex
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function
begin_function
DECL|function|visitLoop
name|bool
name|TConstTraverser
operator|::
name|visitLoop
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermLoop
modifier|*
name|node
parameter_list|)
block|{
name|mInfoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|node
operator|->
name|getLine
argument_list|()
argument_list|,
literal|"Loop Node found in constant constructor"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|true
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|visitBranch
name|bool
name|TConstTraverser
operator|::
name|visitBranch
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermBranch
modifier|*
name|node
parameter_list|)
block|{
name|mInfoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|node
operator|->
name|getLine
argument_list|()
argument_list|,
literal|"Branch Node found in constant constructor"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|true
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// This function is the one to call externally to start the traversal.
end_comment
begin_comment
comment|// Individual functions can be initialized to 0 to skip processing of that
end_comment
begin_comment
comment|// type of node.  It's children will still be processed.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|parseConstTree
name|bool
name|TIntermediate
operator|::
name|parseConstTree
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|line
parameter_list|,
name|TIntermNode
modifier|*
name|root
parameter_list|,
name|ConstantUnion
modifier|*
name|unionArray
parameter_list|,
name|TOperator
name|constructorType
parameter_list|,
name|TType
name|t
parameter_list|,
name|bool
name|singleConstantParam
parameter_list|)
block|{
if|if
condition|(
name|root
operator|==
literal|0
condition|)
return|return
literal|false
return|;
name|TConstTraverser
name|it
argument_list|(
name|unionArray
argument_list|,
name|singleConstantParam
argument_list|,
name|constructorType
argument_list|,
name|mInfoSink
argument_list|,
name|t
argument_list|)
decl_stmt|;
name|root
operator|->
name|traverse
argument_list|(
operator|&
name|it
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|.
name|error
condition|)
return|return
literal|true
return|;
else|else
return|return
literal|false
return|;
block|}
end_function
end_unit
