begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2015 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|"compiler/translator/RemoveSwitchFallThrough.h"
end_include
begin_function
DECL|function|removeFallThrough
name|TIntermAggregate
modifier|*
name|RemoveSwitchFallThrough
operator|::
name|removeFallThrough
parameter_list|(
name|TIntermAggregate
modifier|*
name|statementList
parameter_list|)
block|{
name|RemoveSwitchFallThrough
name|rm
argument_list|(
name|statementList
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|statementList
argument_list|)
expr_stmt|;
name|statementList
operator|->
name|traverse
argument_list|(
operator|&
name|rm
argument_list|)
expr_stmt|;
name|bool
name|lastStatementWasBreak
init|=
name|rm
operator|.
name|mLastStatementWasBreak
decl_stmt|;
name|rm
operator|.
name|mLastStatementWasBreak
operator|=
literal|true
expr_stmt|;
name|rm
operator|.
name|handlePreviousCase
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|lastStatementWasBreak
condition|)
block|{
name|TIntermBranch
modifier|*
name|finalBreak
init|=
operator|new
name|TIntermBranch
argument_list|(
name|EOpBreak
argument_list|,
literal|nullptr
argument_list|)
decl_stmt|;
name|rm
operator|.
name|mStatementListOut
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|finalBreak
argument_list|)
expr_stmt|;
block|}
return|return
name|rm
operator|.
name|mStatementListOut
return|;
block|}
end_function
begin_constructor
DECL|function|RemoveSwitchFallThrough
name|RemoveSwitchFallThrough
operator|::
name|RemoveSwitchFallThrough
parameter_list|(
name|TIntermAggregate
modifier|*
name|statementList
parameter_list|)
member_init_list|:
name|TIntermTraverser
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
member_init_list|,
name|mStatementList
argument_list|(
name|statementList
argument_list|)
member_init_list|,
name|mLastStatementWasBreak
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mPreviousCase
argument_list|(
literal|nullptr
argument_list|)
block|{
name|mStatementListOut
operator|=
operator|new
name|TIntermAggregate
argument_list|()
expr_stmt|;
name|mStatementListOut
operator|->
name|setOp
argument_list|(
name|EOpSequence
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|visitSymbol
name|void
name|RemoveSwitchFallThrough
operator|::
name|visitSymbol
parameter_list|(
name|TIntermSymbol
modifier|*
name|node
parameter_list|)
block|{
comment|// Note that this assumes that switch statements which don't begin by a case statement
comment|// have already been weeded out in validation.
name|mPreviousCase
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|mLastStatementWasBreak
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|visitConstantUnion
name|void
name|RemoveSwitchFallThrough
operator|::
name|visitConstantUnion
parameter_list|(
name|TIntermConstantUnion
modifier|*
name|node
parameter_list|)
block|{
comment|// Conditions of case labels are not traversed, so this is some other constant
comment|// Could be just a statement like "0;"
name|mPreviousCase
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|mLastStatementWasBreak
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|visitBinary
name|bool
name|RemoveSwitchFallThrough
operator|::
name|visitBinary
parameter_list|(
name|Visit
parameter_list|,
name|TIntermBinary
modifier|*
name|node
parameter_list|)
block|{
name|mPreviousCase
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|mLastStatementWasBreak
operator|=
literal|false
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|visitUnary
name|bool
name|RemoveSwitchFallThrough
operator|::
name|visitUnary
parameter_list|(
name|Visit
parameter_list|,
name|TIntermUnary
modifier|*
name|node
parameter_list|)
block|{
name|mPreviousCase
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|mLastStatementWasBreak
operator|=
literal|false
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|visitSelection
name|bool
name|RemoveSwitchFallThrough
operator|::
name|visitSelection
parameter_list|(
name|Visit
parameter_list|,
name|TIntermSelection
modifier|*
name|node
parameter_list|)
block|{
name|mPreviousCase
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|mLastStatementWasBreak
operator|=
literal|false
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|visitSwitch
name|bool
name|RemoveSwitchFallThrough
operator|::
name|visitSwitch
parameter_list|(
name|Visit
parameter_list|,
name|TIntermSwitch
modifier|*
name|node
parameter_list|)
block|{
name|mPreviousCase
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|mLastStatementWasBreak
operator|=
literal|false
expr_stmt|;
comment|// Don't go into nested switch statements
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|outputSequence
name|void
name|RemoveSwitchFallThrough
operator|::
name|outputSequence
parameter_list|(
name|TIntermSequence
modifier|*
name|sequence
parameter_list|,
name|size_t
name|startIndex
parameter_list|)
block|{
for|for
control|(
name|size_t
name|i
init|=
name|startIndex
init|;
name|i
operator|<
name|sequence
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|mStatementListOut
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|sequence
operator|->
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|handlePreviousCase
name|void
name|RemoveSwitchFallThrough
operator|::
name|handlePreviousCase
parameter_list|()
block|{
if|if
condition|(
name|mPreviousCase
condition|)
name|mCasesSharingBreak
operator|.
name|push_back
argument_list|(
name|mPreviousCase
argument_list|)
expr_stmt|;
if|if
condition|(
name|mLastStatementWasBreak
condition|)
block|{
name|bool
name|labelsWithNoStatements
init|=
literal|true
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mCasesSharingBreak
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|mCasesSharingBreak
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|getSequence
argument_list|()
operator|->
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|labelsWithNoStatements
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|labelsWithNoStatements
condition|)
block|{
comment|// Fall-through is allowed in case the label has no statements.
name|outputSequence
argument_list|(
name|mCasesSharingBreak
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|getSequence
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Include all the statements that this case can fall through under the same label.
for|for
control|(
name|size_t
name|j
init|=
name|i
init|;
name|j
operator|<
name|mCasesSharingBreak
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|size_t
name|startIndex
init|=
name|j
operator|>
name|i
condition|?
literal|1
else|:
literal|0
decl_stmt|;
comment|// Add the label only from the first sequence.
name|outputSequence
argument_list|(
name|mCasesSharingBreak
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|->
name|getSequence
argument_list|()
argument_list|,
name|startIndex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|mCasesSharingBreak
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|mLastStatementWasBreak
operator|=
literal|false
expr_stmt|;
name|mPreviousCase
operator|=
literal|nullptr
expr_stmt|;
block|}
end_function
begin_function
DECL|function|visitCase
name|bool
name|RemoveSwitchFallThrough
operator|::
name|visitCase
parameter_list|(
name|Visit
parameter_list|,
name|TIntermCase
modifier|*
name|node
parameter_list|)
block|{
name|handlePreviousCase
argument_list|()
expr_stmt|;
name|mPreviousCase
operator|=
operator|new
name|TIntermAggregate
argument_list|()
expr_stmt|;
name|mPreviousCase
operator|->
name|setOp
argument_list|(
name|EOpSequence
argument_list|)
expr_stmt|;
name|mPreviousCase
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|// Don't traverse the condition of the case statement
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|visitAggregate
name|bool
name|RemoveSwitchFallThrough
operator|::
name|visitAggregate
parameter_list|(
name|Visit
parameter_list|,
name|TIntermAggregate
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|!=
name|mStatementList
condition|)
block|{
name|mPreviousCase
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|mLastStatementWasBreak
operator|=
literal|false
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|visitLoop
name|bool
name|RemoveSwitchFallThrough
operator|::
name|visitLoop
parameter_list|(
name|Visit
parameter_list|,
name|TIntermLoop
modifier|*
name|node
parameter_list|)
block|{
name|mPreviousCase
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|mLastStatementWasBreak
operator|=
literal|false
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|visitBranch
name|bool
name|RemoveSwitchFallThrough
operator|::
name|visitBranch
parameter_list|(
name|Visit
parameter_list|,
name|TIntermBranch
modifier|*
name|node
parameter_list|)
block|{
name|mPreviousCase
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|// TODO: Verify that accepting return or continue statements here doesn't cause problems.
name|mLastStatementWasBreak
operator|=
literal|true
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
end_unit
