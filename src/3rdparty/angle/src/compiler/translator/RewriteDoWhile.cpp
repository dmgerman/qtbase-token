begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2015 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// RewriteDoWhile.cpp: rewrites do-while loops using another equivalent
end_comment
begin_comment
comment|// construct.
end_comment
begin_include
include|#
directive|include
file|"compiler/translator/RewriteDoWhile.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/IntermNode.h"
end_include
begin_namespace
namespace|namespace
block|{
comment|// An AST traverser that rewrites loops of the form
comment|//   do {
comment|//     CODE;
comment|//   } while (CONDITION)
comment|//
comment|// to loops of the form
comment|//   bool temp = false;
comment|//   while (true) {
comment|//     if (temp) {
comment|//       if (!CONDITION) {
comment|//         break;
comment|//       }
comment|//     }
comment|//     temp = true;
comment|//     CODE;
comment|//   }
comment|//
comment|// The reason we don't use a simpler form, with for example just (temp&& !CONDITION) in the
comment|// while condition, is that short-circuit is often badly supported by driver shader compiler.
comment|// The double if has the same effect, but forces shader compilers to behave.
comment|//
comment|// TODO(cwallez) when UnfoldShortCircuitIntoIf handles loops correctly, revisit this as we might
comment|// be able to use while (temp || CONDITION) with temp initially set to true then run
comment|// UnfoldShortCircuitIntoIf
DECL|class|DoWhileRewriter
class|class
name|DoWhileRewriter
super|:
specifier|public
name|TIntermTraverser
block|{
public|public:
DECL|function|DoWhileRewriter
name|DoWhileRewriter
parameter_list|()
member_init_list|:
name|TIntermTraverser
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
block|{}
name|bool
name|visitAggregate
parameter_list|(
name|Visit
parameter_list|,
name|TIntermAggregate
modifier|*
name|node
parameter_list|)
specifier|override
block|{
comment|// A well-formed AST can only have do-while in EOpSequence which represent lists of
comment|// statements. By doing a prefix traversal we are able to replace the do-while in the
comment|// sequence directly as the content of the do-while will be traversed later.
if|if
condition|(
name|node
operator|->
name|getOp
argument_list|()
operator|!=
name|EOpSequence
condition|)
block|{
return|return
literal|true
return|;
block|}
name|TIntermSequence
modifier|*
name|statements
init|=
name|node
operator|->
name|getSequence
argument_list|()
decl_stmt|;
comment|// The statements vector will have new statements inserted when we encounter a do-while,
comment|// which prevents us from using a range-based for loop. Using the usual i++ works, as
comment|// the (two) new statements inserted replace the statement at the current position.
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|statements
operator|->
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|TIntermNode
modifier|*
name|statement
init|=
operator|(
operator|*
name|statements
operator|)
index|[
name|i
index|]
decl_stmt|;
name|TIntermLoop
modifier|*
name|loop
init|=
name|statement
operator|->
name|getAsLoopNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|loop
operator|==
literal|nullptr
operator|||
name|loop
operator|->
name|getType
argument_list|()
operator|!=
name|ELoopDoWhile
condition|)
block|{
continue|continue;
block|}
name|TType
name|boolType
init|=
name|TType
argument_list|(
name|EbtBool
argument_list|)
decl_stmt|;
comment|// bool temp = false;
name|TIntermAggregate
modifier|*
name|tempDeclaration
init|=
literal|nullptr
decl_stmt|;
block|{
name|TConstantUnion
modifier|*
name|falseConstant
init|=
operator|new
name|TConstantUnion
argument_list|()
decl_stmt|;
name|falseConstant
operator|->
name|setBConst
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|TIntermTyped
modifier|*
name|falseValue
init|=
operator|new
name|TIntermConstantUnion
argument_list|(
name|falseConstant
argument_list|,
name|boolType
argument_list|)
decl_stmt|;
name|tempDeclaration
operator|=
name|createTempInitDeclaration
argument_list|(
name|falseValue
argument_list|)
expr_stmt|;
block|}
comment|// temp = true;
name|TIntermBinary
modifier|*
name|assignTrue
init|=
literal|nullptr
decl_stmt|;
block|{
name|TConstantUnion
modifier|*
name|trueConstant
init|=
operator|new
name|TConstantUnion
argument_list|()
decl_stmt|;
name|trueConstant
operator|->
name|setBConst
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|TIntermTyped
modifier|*
name|trueValue
init|=
operator|new
name|TIntermConstantUnion
argument_list|(
name|trueConstant
argument_list|,
name|boolType
argument_list|)
decl_stmt|;
name|assignTrue
operator|=
name|createTempAssignment
argument_list|(
name|trueValue
argument_list|)
expr_stmt|;
block|}
comment|// if (temp) {
comment|//   if (!CONDITION) {
comment|//     break;
comment|//   }
comment|// }
name|TIntermSelection
modifier|*
name|breakIf
init|=
literal|nullptr
decl_stmt|;
block|{
name|TIntermBranch
modifier|*
name|breakStatement
init|=
operator|new
name|TIntermBranch
argument_list|(
name|EOpBreak
argument_list|,
literal|nullptr
argument_list|)
decl_stmt|;
name|TIntermAggregate
modifier|*
name|breakBlock
init|=
operator|new
name|TIntermAggregate
argument_list|(
name|EOpSequence
argument_list|)
decl_stmt|;
name|breakBlock
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|breakStatement
argument_list|)
expr_stmt|;
name|TIntermUnary
modifier|*
name|negatedCondition
init|=
operator|new
name|TIntermUnary
argument_list|(
name|EOpLogicalNot
argument_list|)
decl_stmt|;
name|negatedCondition
operator|->
name|setOperand
argument_list|(
name|loop
operator|->
name|getCondition
argument_list|()
argument_list|)
expr_stmt|;
name|TIntermSelection
modifier|*
name|innerIf
init|=
operator|new
name|TIntermSelection
argument_list|(
name|negatedCondition
argument_list|,
name|breakBlock
argument_list|,
literal|nullptr
argument_list|)
decl_stmt|;
name|TIntermAggregate
modifier|*
name|innerIfBlock
init|=
operator|new
name|TIntermAggregate
argument_list|(
name|EOpSequence
argument_list|)
decl_stmt|;
name|innerIfBlock
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|innerIf
argument_list|)
expr_stmt|;
name|breakIf
operator|=
operator|new
name|TIntermSelection
argument_list|(
name|createTempSymbol
argument_list|(
name|boolType
argument_list|)
argument_list|,
name|innerIfBlock
argument_list|,
literal|nullptr
argument_list|)
expr_stmt|;
block|}
comment|// Assemble the replacement loops, reusing the do-while loop's body and inserting our
comment|// statements at the front.
name|TIntermLoop
modifier|*
name|newLoop
init|=
literal|nullptr
decl_stmt|;
block|{
name|TConstantUnion
modifier|*
name|trueConstant
init|=
operator|new
name|TConstantUnion
argument_list|()
decl_stmt|;
name|trueConstant
operator|->
name|setBConst
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|TIntermTyped
modifier|*
name|trueValue
init|=
operator|new
name|TIntermConstantUnion
argument_list|(
name|trueConstant
argument_list|,
name|boolType
argument_list|)
decl_stmt|;
name|TIntermAggregate
modifier|*
name|body
init|=
literal|nullptr
decl_stmt|;
if|if
condition|(
name|loop
operator|->
name|getBody
argument_list|()
operator|!=
literal|nullptr
condition|)
block|{
name|body
operator|=
name|loop
operator|->
name|getBody
argument_list|()
operator|->
name|getAsAggregate
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|body
operator|=
operator|new
name|TIntermAggregate
argument_list|(
name|EOpSequence
argument_list|)
expr_stmt|;
block|}
name|auto
name|sequence
init|=
name|body
operator|->
name|getSequence
argument_list|()
decl_stmt|;
name|sequence
operator|->
name|insert
argument_list|(
name|sequence
operator|->
name|begin
argument_list|()
argument_list|,
name|assignTrue
argument_list|)
expr_stmt|;
name|sequence
operator|->
name|insert
argument_list|(
name|sequence
operator|->
name|begin
argument_list|()
argument_list|,
name|breakIf
argument_list|)
expr_stmt|;
name|newLoop
operator|=
operator|new
name|TIntermLoop
argument_list|(
name|ELoopWhile
argument_list|,
literal|nullptr
argument_list|,
name|trueValue
argument_list|,
literal|nullptr
argument_list|,
name|body
argument_list|)
expr_stmt|;
block|}
name|TIntermSequence
name|replacement
decl_stmt|;
name|replacement
operator|.
name|push_back
argument_list|(
name|tempDeclaration
argument_list|)
expr_stmt|;
name|replacement
operator|.
name|push_back
argument_list|(
name|newLoop
argument_list|)
expr_stmt|;
name|node
operator|->
name|replaceChildNodeWithMultiple
argument_list|(
name|loop
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
name|nextTemporaryIndex
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
class|;
block|}
end_namespace
begin_comment
comment|// anonymous namespace
end_comment
begin_function
DECL|function|RewriteDoWhile
name|void
name|RewriteDoWhile
parameter_list|(
name|TIntermNode
modifier|*
name|root
parameter_list|,
name|unsigned
name|int
modifier|*
name|temporaryIndex
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|temporaryIndex
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|DoWhileRewriter
name|rewriter
decl_stmt|;
name|rewriter
operator|.
name|useTemporaryIndex
argument_list|(
name|temporaryIndex
argument_list|)
expr_stmt|;
name|root
operator|->
name|traverse
argument_list|(
operator|&
name|rewriter
argument_list|)
expr_stmt|;
block|}
end_function
end_unit
