begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2015 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// RemoveDynamicIndexing is an AST traverser to remove dynamic indexing of vectors and matrices,
end_comment
begin_comment
comment|// replacing them with calls to functions that choose which component to return or write.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|"compiler/translator/RemoveDynamicIndexing.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/InfoSink.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/IntermNode.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/SymbolTable.h"
end_include
begin_namespace
namespace|namespace
block|{
DECL|function|GetIndexFunctionName
name|TName
name|GetIndexFunctionName
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|,
name|bool
name|write
parameter_list|)
block|{
name|TInfoSinkBase
name|nameSink
decl_stmt|;
name|nameSink
operator|<<
literal|"dyn_index_"
expr_stmt|;
if|if
condition|(
name|write
condition|)
block|{
name|nameSink
operator|<<
literal|"write_"
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|.
name|isMatrix
argument_list|()
condition|)
block|{
name|nameSink
operator|<<
literal|"mat"
operator|<<
name|type
operator|.
name|getCols
argument_list|()
operator|<<
literal|"x"
operator|<<
name|type
operator|.
name|getRows
argument_list|()
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|type
operator|.
name|getBasicType
argument_list|()
condition|)
block|{
case|case
name|EbtInt
case|:
name|nameSink
operator|<<
literal|"ivec"
expr_stmt|;
break|break;
case|case
name|EbtBool
case|:
name|nameSink
operator|<<
literal|"bvec"
expr_stmt|;
break|break;
case|case
name|EbtUInt
case|:
name|nameSink
operator|<<
literal|"uvec"
expr_stmt|;
break|break;
case|case
name|EbtFloat
case|:
name|nameSink
operator|<<
literal|"vec"
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
name|nameSink
operator|<<
name|type
operator|.
name|getNominalSize
argument_list|()
expr_stmt|;
block|}
name|TString
name|nameString
init|=
name|TFunction
operator|::
name|mangleName
argument_list|(
name|nameSink
operator|.
name|c_str
argument_list|()
argument_list|)
decl_stmt|;
name|TName
name|name
argument_list|(
name|nameString
argument_list|)
decl_stmt|;
name|name
operator|.
name|setInternal
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
name|name
return|;
block|}
DECL|function|CreateBaseSymbol
name|TIntermSymbol
modifier|*
name|CreateBaseSymbol
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|,
name|TQualifier
name|qualifier
parameter_list|)
block|{
name|TIntermSymbol
modifier|*
name|symbol
init|=
operator|new
name|TIntermSymbol
argument_list|(
literal|0
argument_list|,
literal|"base"
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|symbol
operator|->
name|setInternal
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|symbol
operator|->
name|getTypePointer
argument_list|()
operator|->
name|setQualifier
argument_list|(
name|qualifier
argument_list|)
expr_stmt|;
return|return
name|symbol
return|;
block|}
DECL|function|CreateIndexSymbol
name|TIntermSymbol
modifier|*
name|CreateIndexSymbol
parameter_list|()
block|{
name|TIntermSymbol
modifier|*
name|symbol
init|=
operator|new
name|TIntermSymbol
argument_list|(
literal|0
argument_list|,
literal|"index"
argument_list|,
name|TType
argument_list|(
name|EbtInt
argument_list|,
name|EbpHigh
argument_list|)
argument_list|)
decl_stmt|;
name|symbol
operator|->
name|setInternal
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|symbol
operator|->
name|getTypePointer
argument_list|()
operator|->
name|setQualifier
argument_list|(
name|EvqIn
argument_list|)
expr_stmt|;
return|return
name|symbol
return|;
block|}
DECL|function|CreateValueSymbol
name|TIntermSymbol
modifier|*
name|CreateValueSymbol
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|)
block|{
name|TIntermSymbol
modifier|*
name|symbol
init|=
operator|new
name|TIntermSymbol
argument_list|(
literal|0
argument_list|,
literal|"value"
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|symbol
operator|->
name|setInternal
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|symbol
operator|->
name|getTypePointer
argument_list|()
operator|->
name|setQualifier
argument_list|(
name|EvqIn
argument_list|)
expr_stmt|;
return|return
name|symbol
return|;
block|}
DECL|function|CreateIntConstantNode
name|TIntermConstantUnion
modifier|*
name|CreateIntConstantNode
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|TConstantUnion
modifier|*
name|constant
init|=
operator|new
name|TConstantUnion
argument_list|()
decl_stmt|;
name|constant
operator|->
name|setIConst
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
operator|new
name|TIntermConstantUnion
argument_list|(
name|constant
argument_list|,
name|TType
argument_list|(
name|EbtInt
argument_list|,
name|EbpHigh
argument_list|)
argument_list|)
return|;
block|}
DECL|function|CreateIndexDirectBaseSymbolNode
name|TIntermBinary
modifier|*
name|CreateIndexDirectBaseSymbolNode
parameter_list|(
specifier|const
name|TType
modifier|&
name|indexedType
parameter_list|,
specifier|const
name|TType
modifier|&
name|fieldType
parameter_list|,
specifier|const
name|int
name|index
parameter_list|,
name|TQualifier
name|baseQualifier
parameter_list|)
block|{
name|TIntermBinary
modifier|*
name|indexNode
init|=
operator|new
name|TIntermBinary
argument_list|(
name|EOpIndexDirect
argument_list|)
decl_stmt|;
name|indexNode
operator|->
name|setType
argument_list|(
name|fieldType
argument_list|)
expr_stmt|;
name|TIntermSymbol
modifier|*
name|baseSymbol
init|=
name|CreateBaseSymbol
argument_list|(
name|indexedType
argument_list|,
name|baseQualifier
argument_list|)
decl_stmt|;
name|indexNode
operator|->
name|setLeft
argument_list|(
name|baseSymbol
argument_list|)
expr_stmt|;
name|indexNode
operator|->
name|setRight
argument_list|(
name|CreateIntConstantNode
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|indexNode
return|;
block|}
DECL|function|CreateAssignValueSymbolNode
name|TIntermBinary
modifier|*
name|CreateAssignValueSymbolNode
parameter_list|(
name|TIntermTyped
modifier|*
name|targetNode
parameter_list|,
specifier|const
name|TType
modifier|&
name|assignedValueType
parameter_list|)
block|{
name|TIntermBinary
modifier|*
name|assignNode
init|=
operator|new
name|TIntermBinary
argument_list|(
name|EOpAssign
argument_list|)
decl_stmt|;
name|assignNode
operator|->
name|setType
argument_list|(
name|assignedValueType
argument_list|)
expr_stmt|;
name|assignNode
operator|->
name|setLeft
argument_list|(
name|targetNode
argument_list|)
expr_stmt|;
name|assignNode
operator|->
name|setRight
argument_list|(
name|CreateValueSymbol
argument_list|(
name|assignedValueType
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|assignNode
return|;
block|}
DECL|function|EnsureSignedInt
name|TIntermTyped
modifier|*
name|EnsureSignedInt
parameter_list|(
name|TIntermTyped
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtInt
condition|)
return|return
name|node
return|;
name|TIntermAggregate
modifier|*
name|convertedNode
init|=
operator|new
name|TIntermAggregate
argument_list|(
name|EOpConstructInt
argument_list|)
decl_stmt|;
name|convertedNode
operator|->
name|setType
argument_list|(
name|TType
argument_list|(
name|EbtInt
argument_list|)
argument_list|)
expr_stmt|;
name|convertedNode
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|convertedNode
operator|->
name|setPrecisionFromChildren
argument_list|()
expr_stmt|;
return|return
name|convertedNode
return|;
block|}
DECL|function|GetFieldType
name|TType
name|GetFieldType
parameter_list|(
specifier|const
name|TType
modifier|&
name|indexedType
parameter_list|)
block|{
if|if
condition|(
name|indexedType
operator|.
name|isMatrix
argument_list|()
condition|)
block|{
name|TType
name|fieldType
init|=
name|TType
argument_list|(
name|indexedType
operator|.
name|getBasicType
argument_list|()
argument_list|,
name|indexedType
operator|.
name|getPrecision
argument_list|()
argument_list|)
decl_stmt|;
name|fieldType
operator|.
name|setPrimarySize
argument_list|(
cast|static_cast
argument_list|<
name|unsigned
name|char
argument_list|>
argument_list|(
name|indexedType
operator|.
name|getRows
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fieldType
return|;
block|}
else|else
block|{
return|return
name|TType
argument_list|(
name|indexedType
operator|.
name|getBasicType
argument_list|()
argument_list|,
name|indexedType
operator|.
name|getPrecision
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|// Generate a read or write function for one field in a vector/matrix.
comment|// Out-of-range indices are clamped. This is consistent with how ANGLE handles out-of-range
comment|// indices in other places.
comment|// Note that indices can be either int or uint. We create only int versions of the functions,
comment|// and convert uint indices to int at the call site.
comment|// read function example:
comment|// float dyn_index_vec2(in vec2 base, in int index)
comment|// {
comment|//    switch(index)
comment|//    {
comment|//      case (0):
comment|//        return base[0];
comment|//      case (1):
comment|//        return base[1];
comment|//      default:
comment|//        break;
comment|//    }
comment|//    if (index< 0)
comment|//      return base[0];
comment|//    return base[1];
comment|// }
comment|// write function example:
comment|// void dyn_index_write_vec2(inout vec2 base, in int index, in float value)
comment|// {
comment|//    switch(index)
comment|//    {
comment|//      case (0):
comment|//        base[0] = value;
comment|//        return;
comment|//      case (1):
comment|//        base[1] = value;
comment|//        return;
comment|//      default:
comment|//        break;
comment|//    }
comment|//    if (index< 0)
comment|//    {
comment|//      base[0] = value;
comment|//      return;
comment|//    }
comment|//    base[1] = value;
comment|// }
comment|// Note that else is not used in above functions to avoid the RewriteElseBlocks transformation.
DECL|function|GetIndexFunctionDefinition
name|TIntermAggregate
modifier|*
name|GetIndexFunctionDefinition
parameter_list|(
name|TType
name|type
parameter_list|,
name|bool
name|write
parameter_list|)
block|{
name|ASSERT
argument_list|(
operator|!
name|type
operator|.
name|isArray
argument_list|()
argument_list|)
expr_stmt|;
comment|// Conservatively use highp here, even if the indexed type is not highp. That way the code can't
comment|// end up using mediump version of an indexing function for a highp value, if both mediump and
comment|// highp values are being indexed in the shader. For HLSL precision doesn't matter, but in
comment|// principle this code could be used with multiple backends.
name|type
operator|.
name|setPrecision
argument_list|(
name|EbpHigh
argument_list|)
expr_stmt|;
name|TIntermAggregate
modifier|*
name|indexingFunction
init|=
operator|new
name|TIntermAggregate
argument_list|(
name|EOpFunction
argument_list|)
decl_stmt|;
name|indexingFunction
operator|->
name|setNameObj
argument_list|(
name|GetIndexFunctionName
argument_list|(
name|type
argument_list|,
name|write
argument_list|)
argument_list|)
expr_stmt|;
name|TType
name|fieldType
init|=
name|GetFieldType
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|numCases
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|isMatrix
argument_list|()
condition|)
block|{
name|numCases
operator|=
name|type
operator|.
name|getCols
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|numCases
operator|=
name|type
operator|.
name|getNominalSize
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|write
condition|)
block|{
name|indexingFunction
operator|->
name|setType
argument_list|(
name|TType
argument_list|(
name|EbtVoid
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indexingFunction
operator|->
name|setType
argument_list|(
name|fieldType
argument_list|)
expr_stmt|;
block|}
name|TIntermAggregate
modifier|*
name|paramsNode
init|=
operator|new
name|TIntermAggregate
argument_list|(
name|EOpParameters
argument_list|)
decl_stmt|;
name|TQualifier
name|baseQualifier
init|=
name|EvqInOut
decl_stmt|;
if|if
condition|(
operator|!
name|write
condition|)
name|baseQualifier
operator|=
name|EvqIn
expr_stmt|;
name|TIntermSymbol
modifier|*
name|baseParam
init|=
name|CreateBaseSymbol
argument_list|(
name|type
argument_list|,
name|baseQualifier
argument_list|)
decl_stmt|;
name|paramsNode
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|baseParam
argument_list|)
expr_stmt|;
name|TIntermSymbol
modifier|*
name|indexParam
init|=
name|CreateIndexSymbol
argument_list|()
decl_stmt|;
name|paramsNode
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|indexParam
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
condition|)
block|{
name|TIntermSymbol
modifier|*
name|valueParam
init|=
name|CreateValueSymbol
argument_list|(
name|fieldType
argument_list|)
decl_stmt|;
name|paramsNode
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|valueParam
argument_list|)
expr_stmt|;
block|}
name|indexingFunction
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|paramsNode
argument_list|)
expr_stmt|;
name|TIntermAggregate
modifier|*
name|statementList
init|=
operator|new
name|TIntermAggregate
argument_list|(
name|EOpSequence
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numCases
condition|;
operator|++
name|i
control|)
block|{
name|TIntermCase
modifier|*
name|caseNode
init|=
operator|new
name|TIntermCase
argument_list|(
name|CreateIntConstantNode
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|statementList
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|caseNode
argument_list|)
expr_stmt|;
name|TIntermBinary
modifier|*
name|indexNode
init|=
name|CreateIndexDirectBaseSymbolNode
argument_list|(
name|type
argument_list|,
name|fieldType
argument_list|,
name|i
argument_list|,
name|baseQualifier
argument_list|)
decl_stmt|;
if|if
condition|(
name|write
condition|)
block|{
name|TIntermBinary
modifier|*
name|assignNode
init|=
name|CreateAssignValueSymbolNode
argument_list|(
name|indexNode
argument_list|,
name|fieldType
argument_list|)
decl_stmt|;
name|statementList
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|assignNode
argument_list|)
expr_stmt|;
name|TIntermBranch
modifier|*
name|returnNode
init|=
operator|new
name|TIntermBranch
argument_list|(
name|EOpReturn
argument_list|,
literal|nullptr
argument_list|)
decl_stmt|;
name|statementList
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|returnNode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TIntermBranch
modifier|*
name|returnNode
init|=
operator|new
name|TIntermBranch
argument_list|(
name|EOpReturn
argument_list|,
name|indexNode
argument_list|)
decl_stmt|;
name|statementList
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|returnNode
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Default case
name|TIntermCase
modifier|*
name|defaultNode
init|=
operator|new
name|TIntermCase
argument_list|(
literal|nullptr
argument_list|)
decl_stmt|;
name|statementList
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|defaultNode
argument_list|)
expr_stmt|;
name|TIntermBranch
modifier|*
name|breakNode
init|=
operator|new
name|TIntermBranch
argument_list|(
name|EOpBreak
argument_list|,
literal|nullptr
argument_list|)
decl_stmt|;
name|statementList
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|breakNode
argument_list|)
expr_stmt|;
name|TIntermSwitch
modifier|*
name|switchNode
init|=
operator|new
name|TIntermSwitch
argument_list|(
name|CreateIndexSymbol
argument_list|()
argument_list|,
name|statementList
argument_list|)
decl_stmt|;
name|TIntermAggregate
modifier|*
name|bodyNode
init|=
operator|new
name|TIntermAggregate
argument_list|(
name|EOpSequence
argument_list|)
decl_stmt|;
name|bodyNode
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|switchNode
argument_list|)
expr_stmt|;
name|TIntermBinary
modifier|*
name|cond
init|=
operator|new
name|TIntermBinary
argument_list|(
name|EOpLessThan
argument_list|)
decl_stmt|;
name|cond
operator|->
name|setType
argument_list|(
name|TType
argument_list|(
name|EbtBool
argument_list|,
name|EbpUndefined
argument_list|)
argument_list|)
expr_stmt|;
name|cond
operator|->
name|setLeft
argument_list|(
name|CreateIndexSymbol
argument_list|()
argument_list|)
expr_stmt|;
name|cond
operator|->
name|setRight
argument_list|(
name|CreateIntConstantNode
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|// Two blocks: one accesses (either reads or writes) the first element and returns,
comment|// the other accesses the last element.
name|TIntermAggregate
modifier|*
name|useFirstBlock
init|=
operator|new
name|TIntermAggregate
argument_list|(
name|EOpSequence
argument_list|)
decl_stmt|;
name|TIntermAggregate
modifier|*
name|useLastBlock
init|=
operator|new
name|TIntermAggregate
argument_list|(
name|EOpSequence
argument_list|)
decl_stmt|;
name|TIntermBinary
modifier|*
name|indexFirstNode
init|=
name|CreateIndexDirectBaseSymbolNode
argument_list|(
name|type
argument_list|,
name|fieldType
argument_list|,
literal|0
argument_list|,
name|baseQualifier
argument_list|)
decl_stmt|;
name|TIntermBinary
modifier|*
name|indexLastNode
init|=
name|CreateIndexDirectBaseSymbolNode
argument_list|(
name|type
argument_list|,
name|fieldType
argument_list|,
name|numCases
operator|-
literal|1
argument_list|,
name|baseQualifier
argument_list|)
decl_stmt|;
if|if
condition|(
name|write
condition|)
block|{
name|TIntermBinary
modifier|*
name|assignFirstNode
init|=
name|CreateAssignValueSymbolNode
argument_list|(
name|indexFirstNode
argument_list|,
name|fieldType
argument_list|)
decl_stmt|;
name|useFirstBlock
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|assignFirstNode
argument_list|)
expr_stmt|;
name|TIntermBranch
modifier|*
name|returnNode
init|=
operator|new
name|TIntermBranch
argument_list|(
name|EOpReturn
argument_list|,
literal|nullptr
argument_list|)
decl_stmt|;
name|useFirstBlock
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|returnNode
argument_list|)
expr_stmt|;
name|TIntermBinary
modifier|*
name|assignLastNode
init|=
name|CreateAssignValueSymbolNode
argument_list|(
name|indexLastNode
argument_list|,
name|fieldType
argument_list|)
decl_stmt|;
name|useLastBlock
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|assignLastNode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TIntermBranch
modifier|*
name|returnFirstNode
init|=
operator|new
name|TIntermBranch
argument_list|(
name|EOpReturn
argument_list|,
name|indexFirstNode
argument_list|)
decl_stmt|;
name|useFirstBlock
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|returnFirstNode
argument_list|)
expr_stmt|;
name|TIntermBranch
modifier|*
name|returnLastNode
init|=
operator|new
name|TIntermBranch
argument_list|(
name|EOpReturn
argument_list|,
name|indexLastNode
argument_list|)
decl_stmt|;
name|useLastBlock
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|returnLastNode
argument_list|)
expr_stmt|;
block|}
name|TIntermSelection
modifier|*
name|ifNode
init|=
operator|new
name|TIntermSelection
argument_list|(
name|cond
argument_list|,
name|useFirstBlock
argument_list|,
literal|nullptr
argument_list|)
decl_stmt|;
name|bodyNode
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|ifNode
argument_list|)
expr_stmt|;
name|bodyNode
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|useLastBlock
argument_list|)
expr_stmt|;
name|indexingFunction
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|bodyNode
argument_list|)
expr_stmt|;
return|return
name|indexingFunction
return|;
block|}
DECL|class|RemoveDynamicIndexingTraverser
class|class
name|RemoveDynamicIndexingTraverser
super|:
specifier|public
name|TLValueTrackingTraverser
block|{
public|public:
name|RemoveDynamicIndexingTraverser
parameter_list|(
specifier|const
name|TSymbolTable
modifier|&
name|symbolTable
parameter_list|,
name|int
name|shaderVersion
parameter_list|)
constructor_decl|;
DECL|member|override
name|bool
name|visitBinary
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermBinary
modifier|*
name|node
parameter_list|)
specifier|override
function_decl|;
name|void
name|insertHelperDefinitions
parameter_list|(
name|TIntermNode
modifier|*
name|root
parameter_list|)
function_decl|;
name|void
name|nextIteration
parameter_list|()
function_decl|;
DECL|function|usedTreeInsertion
name|bool
name|usedTreeInsertion
parameter_list|()
specifier|const
block|{
return|return
name|mUsedTreeInsertion
return|;
block|}
protected|protected:
comment|// Sets of types that are indexed. Note that these can not store multiple variants
comment|// of the same type with different precisions - only one precision gets stored.
DECL|member|mIndexedVecAndMatrixTypes
name|std
operator|::
name|set
argument_list|<
name|TType
argument_list|>
name|mIndexedVecAndMatrixTypes
decl_stmt|;
DECL|member|mWrittenVecAndMatrixTypes
name|std
operator|::
name|set
argument_list|<
name|TType
argument_list|>
name|mWrittenVecAndMatrixTypes
decl_stmt|;
DECL|member|mUsedTreeInsertion
name|bool
name|mUsedTreeInsertion
decl_stmt|;
comment|// When true, the traverser will remove side effects from any indexing expression.
comment|// This is done so that in code like
comment|//   V[j++][i]++.
comment|// where V is an array of vectors, j++ will only be evaluated once.
DECL|member|mRemoveIndexSideEffectsInSubtree
name|bool
name|mRemoveIndexSideEffectsInSubtree
decl_stmt|;
block|}
class|;
DECL|function|RemoveDynamicIndexingTraverser
name|RemoveDynamicIndexingTraverser
operator|::
name|RemoveDynamicIndexingTraverser
parameter_list|(
specifier|const
name|TSymbolTable
modifier|&
name|symbolTable
parameter_list|,
name|int
name|shaderVersion
parameter_list|)
member_init_list|:
name|TLValueTrackingTraverser
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|symbolTable
argument_list|,
name|shaderVersion
argument_list|)
member_init_list|,
name|mUsedTreeInsertion
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mRemoveIndexSideEffectsInSubtree
argument_list|(
literal|false
argument_list|)
block|{ }
DECL|function|insertHelperDefinitions
name|void
name|RemoveDynamicIndexingTraverser
operator|::
name|insertHelperDefinitions
parameter_list|(
name|TIntermNode
modifier|*
name|root
parameter_list|)
block|{
name|TIntermAggregate
modifier|*
name|rootAgg
init|=
name|root
operator|->
name|getAsAggregate
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|rootAgg
operator|!=
literal|nullptr
operator|&&
name|rootAgg
operator|->
name|getOp
argument_list|()
operator|==
name|EOpSequence
argument_list|)
expr_stmt|;
name|TIntermSequence
name|insertions
decl_stmt|;
for|for
control|(
name|TType
name|type
range|:
name|mIndexedVecAndMatrixTypes
control|)
block|{
name|insertions
operator|.
name|push_back
argument_list|(
name|GetIndexFunctionDefinition
argument_list|(
name|type
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|TType
name|type
range|:
name|mWrittenVecAndMatrixTypes
control|)
block|{
name|insertions
operator|.
name|push_back
argument_list|(
name|GetIndexFunctionDefinition
argument_list|(
name|type
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mInsertions
operator|.
name|push_back
argument_list|(
name|NodeInsertMultipleEntry
argument_list|(
name|rootAgg
argument_list|,
literal|0
argument_list|,
name|insertions
argument_list|,
name|TIntermSequence
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Create a call to dyn_index_*() based on an indirect indexing op node
DECL|function|CreateIndexFunctionCall
name|TIntermAggregate
modifier|*
name|CreateIndexFunctionCall
parameter_list|(
name|TIntermBinary
modifier|*
name|node
parameter_list|,
name|TIntermTyped
modifier|*
name|indexedNode
parameter_list|,
name|TIntermTyped
modifier|*
name|index
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|node
operator|->
name|getOp
argument_list|()
operator|==
name|EOpIndexIndirect
argument_list|)
expr_stmt|;
name|TIntermAggregate
modifier|*
name|indexingCall
init|=
operator|new
name|TIntermAggregate
argument_list|(
name|EOpFunctionCall
argument_list|)
decl_stmt|;
name|indexingCall
operator|->
name|setLine
argument_list|(
name|node
operator|->
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
name|indexingCall
operator|->
name|setUserDefined
argument_list|()
expr_stmt|;
name|indexingCall
operator|->
name|setNameObj
argument_list|(
name|GetIndexFunctionName
argument_list|(
name|indexedNode
operator|->
name|getType
argument_list|()
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|indexingCall
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|indexedNode
argument_list|)
expr_stmt|;
name|indexingCall
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|TType
name|fieldType
init|=
name|GetFieldType
argument_list|(
name|indexedNode
operator|->
name|getType
argument_list|()
argument_list|)
decl_stmt|;
name|indexingCall
operator|->
name|setType
argument_list|(
name|fieldType
argument_list|)
expr_stmt|;
return|return
name|indexingCall
return|;
block|}
DECL|function|CreateIndexedWriteFunctionCall
name|TIntermAggregate
modifier|*
name|CreateIndexedWriteFunctionCall
parameter_list|(
name|TIntermBinary
modifier|*
name|node
parameter_list|,
name|TIntermTyped
modifier|*
name|index
parameter_list|,
name|TIntermTyped
modifier|*
name|writtenValue
parameter_list|)
block|{
comment|// Deep copy the left node so that two pointers to the same node don't end up in the tree.
name|TIntermNode
modifier|*
name|leftCopy
init|=
name|node
operator|->
name|getLeft
argument_list|()
operator|->
name|deepCopy
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|leftCopy
operator|!=
literal|nullptr
operator|&&
name|leftCopy
operator|->
name|getAsTyped
argument_list|()
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
name|TIntermAggregate
modifier|*
name|indexedWriteCall
init|=
name|CreateIndexFunctionCall
argument_list|(
name|node
argument_list|,
name|leftCopy
operator|->
name|getAsTyped
argument_list|()
argument_list|,
name|index
argument_list|)
decl_stmt|;
name|indexedWriteCall
operator|->
name|setNameObj
argument_list|(
name|GetIndexFunctionName
argument_list|(
name|node
operator|->
name|getLeft
argument_list|()
operator|->
name|getType
argument_list|()
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|indexedWriteCall
operator|->
name|setType
argument_list|(
name|TType
argument_list|(
name|EbtVoid
argument_list|)
argument_list|)
expr_stmt|;
name|indexedWriteCall
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|writtenValue
argument_list|)
expr_stmt|;
return|return
name|indexedWriteCall
return|;
block|}
DECL|function|visitBinary
name|bool
name|RemoveDynamicIndexingTraverser
operator|::
name|visitBinary
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermBinary
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|mUsedTreeInsertion
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|node
operator|->
name|getOp
argument_list|()
operator|==
name|EOpIndexIndirect
condition|)
block|{
if|if
condition|(
name|mRemoveIndexSideEffectsInSubtree
condition|)
block|{
name|ASSERT
argument_list|(
name|node
operator|->
name|getRight
argument_list|()
operator|->
name|hasSideEffects
argument_list|()
argument_list|)
expr_stmt|;
comment|// In case we're just removing index side effects, convert
comment|//   v_expr[index_expr]
comment|// to this:
comment|//   int s0 = index_expr; v_expr[s0];
comment|// Now v_expr[s0] can be safely executed several times without unintended side effects.
comment|// Init the temp variable holding the index
name|TIntermAggregate
modifier|*
name|initIndex
init|=
name|createTempInitDeclaration
argument_list|(
name|node
operator|->
name|getRight
argument_list|()
argument_list|)
decl_stmt|;
name|TIntermSequence
name|insertions
decl_stmt|;
name|insertions
operator|.
name|push_back
argument_list|(
name|initIndex
argument_list|)
expr_stmt|;
name|insertStatementsInParentBlock
argument_list|(
name|insertions
argument_list|)
expr_stmt|;
name|mUsedTreeInsertion
operator|=
literal|true
expr_stmt|;
comment|// Replace the index with the temp variable
name|TIntermSymbol
modifier|*
name|tempIndex
init|=
name|createTempSymbol
argument_list|(
name|node
operator|->
name|getRight
argument_list|()
operator|->
name|getType
argument_list|()
argument_list|)
decl_stmt|;
name|NodeUpdateEntry
name|replaceIndex
argument_list|(
name|node
argument_list|,
name|node
operator|->
name|getRight
argument_list|()
argument_list|,
name|tempIndex
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|mReplacements
operator|.
name|push_back
argument_list|(
name|replaceIndex
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|node
operator|->
name|getLeft
argument_list|()
operator|->
name|isArray
argument_list|()
operator|&&
name|node
operator|->
name|getLeft
argument_list|()
operator|->
name|getBasicType
argument_list|()
operator|!=
name|EbtStruct
condition|)
block|{
name|bool
name|write
init|=
name|isLValueRequiredHere
argument_list|()
decl_stmt|;
name|TType
name|type
init|=
name|node
operator|->
name|getLeft
argument_list|()
operator|->
name|getType
argument_list|()
decl_stmt|;
name|mIndexedVecAndMatrixTypes
operator|.
name|insert
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
condition|)
block|{
comment|// Convert:
comment|//   v_expr[index_expr]++;
comment|// to this:
comment|//   int s0 = index_expr; float s1 = dyn_index(v_expr, s0); s1++;
comment|//   dyn_index_write(v_expr, s0, s1);
comment|// This works even if index_expr has some side effects.
if|if
condition|(
name|node
operator|->
name|getLeft
argument_list|()
operator|->
name|hasSideEffects
argument_list|()
condition|)
block|{
comment|// If v_expr has side effects, those need to be removed before proceeding.
comment|// Otherwise the side effects of v_expr would be evaluated twice.
comment|// The only case where an l-value can have side effects is when it is
comment|// indexing. For example, it can be V[j++] where V is an array of vectors.
name|mRemoveIndexSideEffectsInSubtree
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// TODO(oetuaho@nvidia.com): This is not optimal if the expression using the value
comment|// only writes it and doesn't need the previous value. http://anglebug.com/1116
name|mWrittenVecAndMatrixTypes
operator|.
name|insert
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TType
name|fieldType
init|=
name|GetFieldType
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|TIntermSequence
name|insertionsBefore
decl_stmt|;
name|TIntermSequence
name|insertionsAfter
decl_stmt|;
comment|// Store the index in a temporary signed int variable.
name|TIntermTyped
modifier|*
name|indexInitializer
init|=
name|EnsureSignedInt
argument_list|(
name|node
operator|->
name|getRight
argument_list|()
argument_list|)
decl_stmt|;
name|TIntermAggregate
modifier|*
name|initIndex
init|=
name|createTempInitDeclaration
argument_list|(
name|indexInitializer
argument_list|)
decl_stmt|;
name|initIndex
operator|->
name|setLine
argument_list|(
name|node
operator|->
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
name|insertionsBefore
operator|.
name|push_back
argument_list|(
name|initIndex
argument_list|)
expr_stmt|;
name|TIntermAggregate
modifier|*
name|indexingCall
init|=
name|CreateIndexFunctionCall
argument_list|(
name|node
argument_list|,
name|node
operator|->
name|getLeft
argument_list|()
argument_list|,
name|createTempSymbol
argument_list|(
name|indexInitializer
operator|->
name|getType
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// Create a node for referring to the index after the nextTemporaryIndex() call
comment|// below.
name|TIntermSymbol
modifier|*
name|tempIndex
init|=
name|createTempSymbol
argument_list|(
name|indexInitializer
operator|->
name|getType
argument_list|()
argument_list|)
decl_stmt|;
name|nextTemporaryIndex
argument_list|()
expr_stmt|;
comment|// From now on, creating temporary symbols that refer to the
comment|// field value.
name|insertionsBefore
operator|.
name|push_back
argument_list|(
name|createTempInitDeclaration
argument_list|(
name|indexingCall
argument_list|)
argument_list|)
expr_stmt|;
name|TIntermAggregate
modifier|*
name|indexedWriteCall
init|=
name|CreateIndexedWriteFunctionCall
argument_list|(
name|node
argument_list|,
name|tempIndex
argument_list|,
name|createTempSymbol
argument_list|(
name|fieldType
argument_list|)
argument_list|)
decl_stmt|;
name|insertionsAfter
operator|.
name|push_back
argument_list|(
name|indexedWriteCall
argument_list|)
expr_stmt|;
name|insertStatementsInParentBlock
argument_list|(
name|insertionsBefore
argument_list|,
name|insertionsAfter
argument_list|)
expr_stmt|;
name|NodeUpdateEntry
name|replaceIndex
argument_list|(
name|getParentNode
argument_list|()
argument_list|,
name|node
argument_list|,
name|createTempSymbol
argument_list|(
name|fieldType
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|mReplacements
operator|.
name|push_back
argument_list|(
name|replaceIndex
argument_list|)
expr_stmt|;
name|mUsedTreeInsertion
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// The indexed value is not being written, so we can simply convert
comment|//   v_expr[index_expr]
comment|// into
comment|//   dyn_index(v_expr, index_expr)
comment|// If the index_expr is unsigned, we'll convert it to signed.
name|ASSERT
argument_list|(
operator|!
name|mRemoveIndexSideEffectsInSubtree
argument_list|)
expr_stmt|;
name|TIntermAggregate
modifier|*
name|indexingCall
init|=
name|CreateIndexFunctionCall
argument_list|(
name|node
argument_list|,
name|node
operator|->
name|getLeft
argument_list|()
argument_list|,
name|EnsureSignedInt
argument_list|(
name|node
operator|->
name|getRight
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|NodeUpdateEntry
name|replaceIndex
argument_list|(
name|getParentNode
argument_list|()
argument_list|,
name|node
argument_list|,
name|indexingCall
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|mReplacements
operator|.
name|push_back
argument_list|(
name|replaceIndex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|!
name|mUsedTreeInsertion
return|;
block|}
DECL|function|nextIteration
name|void
name|RemoveDynamicIndexingTraverser
operator|::
name|nextIteration
parameter_list|()
block|{
name|mUsedTreeInsertion
operator|=
literal|false
expr_stmt|;
name|mRemoveIndexSideEffectsInSubtree
operator|=
literal|false
expr_stmt|;
name|nextTemporaryIndex
argument_list|()
expr_stmt|;
block|}
block|}
end_namespace
begin_comment
comment|// namespace
end_comment
begin_function
DECL|function|RemoveDynamicIndexing
name|void
name|RemoveDynamicIndexing
parameter_list|(
name|TIntermNode
modifier|*
name|root
parameter_list|,
name|unsigned
name|int
modifier|*
name|temporaryIndex
parameter_list|,
specifier|const
name|TSymbolTable
modifier|&
name|symbolTable
parameter_list|,
name|int
name|shaderVersion
parameter_list|)
block|{
name|RemoveDynamicIndexingTraverser
name|traverser
argument_list|(
name|symbolTable
argument_list|,
name|shaderVersion
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|temporaryIndex
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
name|traverser
operator|.
name|useTemporaryIndex
argument_list|(
name|temporaryIndex
argument_list|)
expr_stmt|;
do|do
block|{
name|traverser
operator|.
name|nextIteration
argument_list|()
expr_stmt|;
name|root
operator|->
name|traverse
argument_list|(
operator|&
name|traverser
argument_list|)
expr_stmt|;
name|traverser
operator|.
name|updateTree
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|traverser
operator|.
name|usedTreeInsertion
argument_list|()
condition|)
do|;
name|traverser
operator|.
name|insertHelperDefinitions
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|traverser
operator|.
name|updateTree
argument_list|()
expr_stmt|;
block|}
end_function
end_unit
