begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2015 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// CallDAG.h: Implements a call graph DAG of functions to be re-used accross
end_comment
begin_comment
comment|// analyses, allows to efficiently traverse the functions in topological
end_comment
begin_comment
comment|// order.
end_comment
begin_include
include|#
directive|include
file|"compiler/translator/CallDAG.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/InfoSink.h"
end_include
begin_comment
comment|// The CallDAGCreator does all the processing required to create the CallDAG
end_comment
begin_comment
comment|// structure so that the latter contains only the necessary variables.
end_comment
begin_class
DECL|class|CallDAGCreator
class|class
name|CallDAG
operator|::
name|CallDAGCreator
super|:
specifier|public
name|TIntermTraverser
block|{
public|public:
DECL|function|CallDAGCreator
name|CallDAGCreator
parameter_list|(
name|TInfoSinkBase
modifier|*
name|info
parameter_list|)
member_init_list|:
name|TIntermTraverser
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
member_init_list|,
name|mCreationInfo
argument_list|(
name|info
argument_list|)
member_init_list|,
name|mCurrentFunction
argument_list|(
literal|nullptr
argument_list|)
member_init_list|,
name|mCurrentIndex
argument_list|(
literal|0
argument_list|)
block|{     }
DECL|function|assignIndices
name|InitResult
name|assignIndices
parameter_list|()
block|{
name|int
name|skipped
init|=
literal|0
decl_stmt|;
for|for
control|(
name|auto
operator|&
name|it
operator|:
name|mFunctions
control|)
block|{
comment|// Skip unimplemented functions
if|if
condition|(
name|it
operator|.
name|second
operator|.
name|node
condition|)
block|{
name|InitResult
name|result
init|=
name|assignIndicesInternal
argument_list|(
operator|&
name|it
operator|.
name|second
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
name|INITDAG_SUCCESS
condition|)
block|{
operator|*
name|mCreationInfo
operator|<<
literal|"\n"
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
else|else
block|{
name|skipped
operator|++
expr_stmt|;
block|}
block|}
name|ASSERT
argument_list|(
name|mFunctions
operator|.
name|size
argument_list|()
operator|==
name|mCurrentIndex
operator|+
name|skipped
argument_list|)
expr_stmt|;
return|return
name|INITDAG_SUCCESS
return|;
block|}
DECL|function|fillDataStructures
name|void
name|fillDataStructures
parameter_list|(
name|std
operator|::
name|vector
argument_list|<
name|Record
argument_list|>
modifier|*
name|records
parameter_list|,
name|std
operator|::
name|map
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
modifier|*
name|idToIndex
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|records
operator|->
name|empty
argument_list|()
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|idToIndex
operator|->
name|empty
argument_list|()
argument_list|)
expr_stmt|;
name|records
operator|->
name|resize
argument_list|(
name|mCurrentIndex
argument_list|)
expr_stmt|;
for|for
control|(
name|auto
operator|&
name|it
operator|:
name|mFunctions
control|)
block|{
name|CreatorFunctionData
modifier|&
name|data
init|=
name|it
operator|.
name|second
decl_stmt|;
comment|// Skip unimplemented functions
if|if
condition|(
operator|!
name|data
operator|.
name|node
condition|)
block|{
continue|continue;
block|}
name|ASSERT
argument_list|(
name|data
operator|.
name|index
operator|<
name|records
operator|->
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Record
modifier|&
name|record
init|=
operator|(
operator|*
name|records
operator|)
index|[
name|data
operator|.
name|index
index|]
decl_stmt|;
name|record
operator|.
name|name
operator|=
name|data
operator|.
name|name
operator|.
name|data
argument_list|()
expr_stmt|;
name|record
operator|.
name|node
operator|=
name|data
operator|.
name|node
expr_stmt|;
name|record
operator|.
name|callees
operator|.
name|reserve
argument_list|(
name|data
operator|.
name|callees
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|auto
operator|&
name|callee
operator|:
name|data
operator|.
name|callees
control|)
block|{
name|record
operator|.
name|callees
operator|.
name|push_back
argument_list|(
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|callee
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|idToIndex
operator|)
index|[
name|data
operator|.
name|node
operator|->
name|getFunctionId
argument_list|()
index|]
operator|=
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|data
operator|.
name|index
argument_list|)
expr_stmt|;
block|}
block|}
private|private:
DECL|struct|CreatorFunctionData
struct|struct
name|CreatorFunctionData
block|{
DECL|function|CreatorFunctionData
name|CreatorFunctionData
parameter_list|()
member_init_list|:
name|node
argument_list|(
literal|nullptr
argument_list|)
member_init_list|,
name|index
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|indexAssigned
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|visiting
argument_list|(
literal|false
argument_list|)
block|{         }
DECL|member|callees
name|std
operator|::
name|set
argument_list|<
name|CreatorFunctionData
modifier|*
argument_list|>
name|callees
decl_stmt|;
DECL|member|node
name|TIntermAggregate
modifier|*
name|node
decl_stmt|;
DECL|member|name
name|TString
name|name
decl_stmt|;
DECL|member|index
name|size_t
name|index
decl_stmt|;
DECL|member|indexAssigned
name|bool
name|indexAssigned
decl_stmt|;
DECL|member|visiting
name|bool
name|visiting
decl_stmt|;
block|}
struct|;
comment|// Aggregates the AST node for each function as well as the name of the functions called by it
name|bool
name|visitAggregate
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermAggregate
modifier|*
name|node
parameter_list|)
specifier|override
block|{
switch|switch
condition|(
name|node
operator|->
name|getOp
argument_list|()
condition|)
block|{
case|case
name|EOpPrototype
case|:
if|if
condition|(
name|visit
operator|==
name|PreVisit
condition|)
block|{
comment|// Function declaration, create an empty record.
name|auto
operator|&
name|record
operator|=
name|mFunctions
index|[
name|node
operator|->
name|getName
argument_list|()
index|]
expr_stmt|;
name|record
operator|.
name|name
operator|=
name|node
operator|->
name|getName
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|EOpFunction
case|:
block|{
comment|// Function definition, create the record if need be and remember the node.
if|if
condition|(
name|visit
operator|==
name|PreVisit
condition|)
block|{
name|auto
name|it
init|=
name|mFunctions
operator|.
name|find
argument_list|(
name|node
operator|->
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|==
name|mFunctions
operator|.
name|end
argument_list|()
condition|)
block|{
name|mCurrentFunction
operator|=
operator|&
name|mFunctions
index|[
name|node
operator|->
name|getName
argument_list|()
index|]
expr_stmt|;
block|}
else|else
block|{
name|mCurrentFunction
operator|=
operator|&
name|it
operator|->
name|second
expr_stmt|;
block|}
name|mCurrentFunction
operator|->
name|node
operator|=
name|node
expr_stmt|;
name|mCurrentFunction
operator|->
name|name
operator|=
name|node
operator|->
name|getName
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|visit
operator|==
name|PostVisit
condition|)
block|{
name|mCurrentFunction
operator|=
literal|nullptr
expr_stmt|;
block|}
break|break;
block|}
case|case
name|EOpFunctionCall
case|:
block|{
comment|// Function call, add the callees
if|if
condition|(
name|visit
operator|==
name|PreVisit
condition|)
block|{
comment|// Do not handle calls to builtin functions
if|if
condition|(
name|node
operator|->
name|isUserDefined
argument_list|()
condition|)
block|{
name|auto
name|it
init|=
name|mFunctions
operator|.
name|find
argument_list|(
name|node
operator|->
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|it
operator|!=
name|mFunctions
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
comment|// We might be in a top-level function call to set a global variable
if|if
condition|(
name|mCurrentFunction
condition|)
block|{
name|mCurrentFunction
operator|->
name|callees
operator|.
name|insert
argument_list|(
operator|&
name|it
operator|->
name|second
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
default|default:
break|break;
block|}
return|return
literal|true
return|;
block|}
comment|// Recursively assigns indices to a sub DAG
DECL|function|assignIndicesInternal
name|InitResult
name|assignIndicesInternal
parameter_list|(
name|CreatorFunctionData
modifier|*
name|function
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|function
operator|->
name|node
condition|)
block|{
operator|*
name|mCreationInfo
operator|<<
literal|"Undefined function '"
operator|<<
name|function
operator|->
name|name
operator|<<
literal|")' used in the following call chain:"
expr_stmt|;
return|return
name|INITDAG_UNDEFINED
return|;
block|}
if|if
condition|(
name|function
operator|->
name|indexAssigned
condition|)
block|{
return|return
name|INITDAG_SUCCESS
return|;
block|}
if|if
condition|(
name|function
operator|->
name|visiting
condition|)
block|{
if|if
condition|(
name|mCreationInfo
condition|)
block|{
operator|*
name|mCreationInfo
operator|<<
literal|"Recursive function call in the following call chain:"
operator|<<
name|function
operator|->
name|name
expr_stmt|;
block|}
return|return
name|INITDAG_RECURSION
return|;
block|}
name|function
operator|->
name|visiting
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|auto
operator|&
name|callee
operator|:
name|function
operator|->
name|callees
control|)
block|{
name|InitResult
name|result
init|=
name|assignIndicesInternal
argument_list|(
name|callee
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
name|INITDAG_SUCCESS
condition|)
block|{
comment|// We know that there is an issue with the call chain in the AST,
comment|// print the link of the chain we were processing.
if|if
condition|(
name|mCreationInfo
condition|)
block|{
operator|*
name|mCreationInfo
operator|<<
literal|"<- "
operator|<<
name|function
operator|->
name|name
operator|<<
literal|")"
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
block|}
name|function
operator|->
name|index
operator|=
name|mCurrentIndex
operator|++
expr_stmt|;
name|function
operator|->
name|indexAssigned
operator|=
literal|true
expr_stmt|;
name|function
operator|->
name|visiting
operator|=
literal|false
expr_stmt|;
return|return
name|INITDAG_SUCCESS
return|;
block|}
DECL|member|mCreationInfo
name|TInfoSinkBase
modifier|*
name|mCreationInfo
decl_stmt|;
DECL|member|mFunctions
name|std
operator|::
name|map
argument_list|<
name|TString
argument_list|,
name|CreatorFunctionData
argument_list|>
name|mFunctions
decl_stmt|;
DECL|member|mCurrentFunction
name|CreatorFunctionData
modifier|*
name|mCurrentFunction
decl_stmt|;
DECL|member|mCurrentIndex
name|size_t
name|mCurrentIndex
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|// CallDAG
end_comment
begin_constructor
DECL|function|CallDAG
name|CallDAG
operator|::
name|CallDAG
parameter_list|()
block|{ }
end_constructor
begin_destructor
DECL|function|~CallDAG
name|CallDAG
operator|::
name|~
name|CallDAG
parameter_list|()
block|{ }
end_destructor
begin_decl_stmt
DECL|member|InvalidIndex
specifier|const
name|size_t
name|CallDAG
operator|::
name|InvalidIndex
init|=
name|std
operator|::
name|numeric_limits
argument_list|<
name|size_t
argument_list|>
operator|::
name|max
argument_list|()
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|findIndex
name|size_t
name|CallDAG
operator|::
name|findIndex
parameter_list|(
specifier|const
name|TIntermAggregate
modifier|*
name|function
parameter_list|)
specifier|const
block|{
name|TOperator
name|op
init|=
name|function
operator|->
name|getOp
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|op
operator|==
name|EOpPrototype
operator|||
name|op
operator|==
name|EOpFunction
operator|||
name|op
operator|==
name|EOpFunctionCall
argument_list|)
expr_stmt|;
name|UNUSED_ASSERTION_VARIABLE
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|auto
name|it
init|=
name|mFunctionIdToIndex
operator|.
name|find
argument_list|(
name|function
operator|->
name|getFunctionId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|==
name|mFunctionIdToIndex
operator|.
name|end
argument_list|()
condition|)
block|{
return|return
name|InvalidIndex
return|;
block|}
else|else
block|{
return|return
name|it
operator|->
name|second
return|;
block|}
block|}
end_function
begin_function
DECL|function|getRecordFromIndex
specifier|const
name|CallDAG
operator|::
name|Record
modifier|&
name|CallDAG
operator|::
name|getRecordFromIndex
parameter_list|(
name|size_t
name|index
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|index
operator|!=
name|InvalidIndex
operator|&&
name|index
operator|<
name|mRecords
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|mRecords
index|[
name|index
index|]
return|;
block|}
end_function
begin_function
DECL|function|getRecord
specifier|const
name|CallDAG
operator|::
name|Record
modifier|&
name|CallDAG
operator|::
name|getRecord
parameter_list|(
specifier|const
name|TIntermAggregate
modifier|*
name|function
parameter_list|)
specifier|const
block|{
name|size_t
name|index
init|=
name|findIndex
argument_list|(
name|function
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|index
operator|!=
name|InvalidIndex
operator|&&
name|index
operator|<
name|mRecords
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|mRecords
index|[
name|index
index|]
return|;
block|}
end_function
begin_function
DECL|function|size
name|size_t
name|CallDAG
operator|::
name|size
parameter_list|()
specifier|const
block|{
return|return
name|mRecords
operator|.
name|size
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|clear
name|void
name|CallDAG
operator|::
name|clear
parameter_list|()
block|{
name|mRecords
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mFunctionIdToIndex
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|init
name|CallDAG
operator|::
name|InitResult
name|CallDAG
operator|::
name|init
parameter_list|(
name|TIntermNode
modifier|*
name|root
parameter_list|,
name|TInfoSinkBase
modifier|*
name|info
parameter_list|)
block|{
name|CallDAGCreator
name|creator
argument_list|(
name|info
argument_list|)
decl_stmt|;
comment|// Creates the mapping of functions to callees
name|root
operator|->
name|traverse
argument_list|(
operator|&
name|creator
argument_list|)
expr_stmt|;
comment|// Does the topological sort and detects recursions
name|InitResult
name|result
init|=
name|creator
operator|.
name|assignIndices
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
operator|!=
name|INITDAG_SUCCESS
condition|)
block|{
return|return
name|result
return|;
block|}
name|creator
operator|.
name|fillDataStructures
argument_list|(
operator|&
name|mRecords
argument_list|,
operator|&
name|mFunctionIdToIndex
argument_list|)
expr_stmt|;
return|return
name|INITDAG_SUCCESS
return|;
block|}
end_function
end_unit
