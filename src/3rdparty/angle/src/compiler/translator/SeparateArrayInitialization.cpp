begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2015 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// The SeparateArrayInitialization function splits each array initialization into a declaration and an assignment.
end_comment
begin_comment
comment|// Example:
end_comment
begin_comment
comment|//     type[n] a = initializer;
end_comment
begin_comment
comment|// will effectively become
end_comment
begin_comment
comment|//     type[n] a;
end_comment
begin_comment
comment|//     a = initializer;
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Note that if the array is declared as const, the initialization may still be split, making the
end_comment
begin_comment
comment|// AST technically invalid. Because of that this transformation should only be used when subsequent
end_comment
begin_comment
comment|// stages don't care about const qualifiers. However, the initialization will not be split if the
end_comment
begin_comment
comment|// initializer can be written as a HLSL literal.
end_comment
begin_include
include|#
directive|include
file|"compiler/translator/SeparateArrayInitialization.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/IntermNode.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/OutputHLSL.h"
end_include
begin_namespace
namespace|namespace
block|{
DECL|class|SeparateArrayInitTraverser
class|class
name|SeparateArrayInitTraverser
super|:
specifier|private
name|TIntermTraverser
block|{
public|public:
specifier|static
name|void
name|apply
parameter_list|(
name|TIntermNode
modifier|*
name|root
parameter_list|)
function_decl|;
private|private:
name|SeparateArrayInitTraverser
parameter_list|()
constructor_decl|;
DECL|member|override
name|bool
name|visitAggregate
parameter_list|(
name|Visit
parameter_list|,
name|TIntermAggregate
modifier|*
name|node
parameter_list|)
specifier|override
function_decl|;
block|}
class|;
DECL|function|apply
name|void
name|SeparateArrayInitTraverser
operator|::
name|apply
parameter_list|(
name|TIntermNode
modifier|*
name|root
parameter_list|)
block|{
name|SeparateArrayInitTraverser
name|separateInit
decl_stmt|;
name|root
operator|->
name|traverse
argument_list|(
operator|&
name|separateInit
argument_list|)
expr_stmt|;
name|separateInit
operator|.
name|updateTree
argument_list|()
expr_stmt|;
block|}
DECL|function|SeparateArrayInitTraverser
name|SeparateArrayInitTraverser
operator|::
name|SeparateArrayInitTraverser
parameter_list|()
member_init_list|:
name|TIntermTraverser
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
block|{ }
DECL|function|visitAggregate
name|bool
name|SeparateArrayInitTraverser
operator|::
name|visitAggregate
parameter_list|(
name|Visit
parameter_list|,
name|TIntermAggregate
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|->
name|getOp
argument_list|()
operator|==
name|EOpDeclaration
condition|)
block|{
name|TIntermSequence
modifier|*
name|sequence
init|=
name|node
operator|->
name|getSequence
argument_list|()
decl_stmt|;
name|TIntermBinary
modifier|*
name|initNode
init|=
name|sequence
operator|->
name|back
argument_list|()
operator|->
name|getAsBinaryNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|initNode
operator|!=
literal|nullptr
operator|&&
name|initNode
operator|->
name|getOp
argument_list|()
operator|==
name|EOpInitialize
condition|)
block|{
name|TIntermTyped
modifier|*
name|initializer
init|=
name|initNode
operator|->
name|getRight
argument_list|()
decl_stmt|;
if|if
condition|(
name|initializer
operator|->
name|isArray
argument_list|()
operator|&&
operator|!
name|sh
operator|::
name|OutputHLSL
operator|::
name|canWriteAsHLSLLiteral
argument_list|(
name|initializer
argument_list|)
condition|)
block|{
comment|// We rely on that array declarations have been isolated to single declarations.
name|ASSERT
argument_list|(
name|sequence
operator|->
name|size
argument_list|()
operator|==
literal|1
argument_list|)
expr_stmt|;
name|TIntermTyped
modifier|*
name|symbol
init|=
name|initNode
operator|->
name|getLeft
argument_list|()
decl_stmt|;
name|TIntermAggregate
modifier|*
name|parentAgg
init|=
name|getParentNode
argument_list|()
operator|->
name|getAsAggregate
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|parentAgg
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
name|TIntermSequence
name|replacements
decl_stmt|;
name|TIntermAggregate
modifier|*
name|replacementDeclaration
init|=
operator|new
name|TIntermAggregate
decl_stmt|;
name|replacementDeclaration
operator|->
name|setOp
argument_list|(
name|EOpDeclaration
argument_list|)
expr_stmt|;
name|replacementDeclaration
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
name|replacementDeclaration
operator|->
name|setLine
argument_list|(
name|symbol
operator|->
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
name|replacements
operator|.
name|push_back
argument_list|(
name|replacementDeclaration
argument_list|)
expr_stmt|;
name|TIntermBinary
modifier|*
name|replacementAssignment
init|=
operator|new
name|TIntermBinary
argument_list|(
name|EOpAssign
argument_list|)
decl_stmt|;
name|replacementAssignment
operator|->
name|setLeft
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
name|replacementAssignment
operator|->
name|setRight
argument_list|(
name|initializer
argument_list|)
expr_stmt|;
name|replacementAssignment
operator|->
name|setType
argument_list|(
name|initializer
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|replacementAssignment
operator|->
name|setLine
argument_list|(
name|symbol
operator|->
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
name|replacements
operator|.
name|push_back
argument_list|(
name|replacementAssignment
argument_list|)
expr_stmt|;
name|mMultiReplacements
operator|.
name|push_back
argument_list|(
name|NodeReplaceWithMultipleEntry
argument_list|(
name|parentAgg
argument_list|,
name|node
argument_list|,
name|replacements
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
block|}
end_namespace
begin_comment
comment|// namespace
end_comment
begin_function
DECL|function|SeparateArrayInitialization
name|void
name|SeparateArrayInitialization
parameter_list|(
name|TIntermNode
modifier|*
name|root
parameter_list|)
block|{
name|SeparateArrayInitTraverser
operator|::
name|apply
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
end_function
end_unit
