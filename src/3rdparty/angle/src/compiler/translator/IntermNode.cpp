begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Build the intermediate representation.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|<float.h>
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_include
include|#
directive|include
file|<math.h>
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_include
include|#
directive|include
file|<vector>
end_include
begin_include
include|#
directive|include
file|"common/mathutil.h"
end_include
begin_include
include|#
directive|include
file|"common/matrix_utils.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/HashNames.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/IntermNode.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/SymbolTable.h"
end_include
begin_namespace
namespace|namespace
block|{
DECL|member|kPi
specifier|const
name|float
name|kPi
init|=
literal|3.14159265358979323846f
decl_stmt|;
DECL|member|kDegreesToRadiansMultiplier
specifier|const
name|float
name|kDegreesToRadiansMultiplier
init|=
name|kPi
operator|/
literal|180.0f
decl_stmt|;
DECL|member|kRadiansToDegreesMultiplier
specifier|const
name|float
name|kRadiansToDegreesMultiplier
init|=
literal|180.0f
operator|/
name|kPi
decl_stmt|;
DECL|function|GetHigherPrecision
name|TPrecision
name|GetHigherPrecision
parameter_list|(
name|TPrecision
name|left
parameter_list|,
name|TPrecision
name|right
parameter_list|)
block|{
return|return
name|left
operator|>
name|right
condition|?
name|left
else|:
name|right
return|;
block|}
DECL|function|ValidateMultiplication
name|bool
name|ValidateMultiplication
parameter_list|(
name|TOperator
name|op
parameter_list|,
specifier|const
name|TType
modifier|&
name|left
parameter_list|,
specifier|const
name|TType
modifier|&
name|right
parameter_list|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|EOpMul
case|:
case|case
name|EOpMulAssign
case|:
return|return
name|left
operator|.
name|getNominalSize
argument_list|()
operator|==
name|right
operator|.
name|getNominalSize
argument_list|()
operator|&&
name|left
operator|.
name|getSecondarySize
argument_list|()
operator|==
name|right
operator|.
name|getSecondarySize
argument_list|()
return|;
case|case
name|EOpVectorTimesScalar
case|:
case|case
name|EOpVectorTimesScalarAssign
case|:
return|return
literal|true
return|;
case|case
name|EOpVectorTimesMatrix
case|:
return|return
name|left
operator|.
name|getNominalSize
argument_list|()
operator|==
name|right
operator|.
name|getRows
argument_list|()
return|;
case|case
name|EOpVectorTimesMatrixAssign
case|:
return|return
name|left
operator|.
name|getNominalSize
argument_list|()
operator|==
name|right
operator|.
name|getRows
argument_list|()
operator|&&
name|left
operator|.
name|getNominalSize
argument_list|()
operator|==
name|right
operator|.
name|getCols
argument_list|()
return|;
case|case
name|EOpMatrixTimesVector
case|:
return|return
name|left
operator|.
name|getCols
argument_list|()
operator|==
name|right
operator|.
name|getNominalSize
argument_list|()
return|;
case|case
name|EOpMatrixTimesScalar
case|:
case|case
name|EOpMatrixTimesScalarAssign
case|:
return|return
literal|true
return|;
case|case
name|EOpMatrixTimesMatrix
case|:
return|return
name|left
operator|.
name|getCols
argument_list|()
operator|==
name|right
operator|.
name|getRows
argument_list|()
return|;
case|case
name|EOpMatrixTimesMatrixAssign
case|:
return|return
name|left
operator|.
name|getCols
argument_list|()
operator|==
name|right
operator|.
name|getCols
argument_list|()
operator|&&
name|left
operator|.
name|getRows
argument_list|()
operator|==
name|right
operator|.
name|getRows
argument_list|()
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|Vectorize
name|TConstantUnion
modifier|*
name|Vectorize
parameter_list|(
specifier|const
name|TConstantUnion
modifier|&
name|constant
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|TConstantUnion
modifier|*
name|constUnion
init|=
operator|new
name|TConstantUnion
index|[
name|size
index|]
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
name|constUnion
index|[
name|i
index|]
operator|=
name|constant
expr_stmt|;
return|return
name|constUnion
return|;
block|}
DECL|function|UndefinedConstantFoldingError
name|void
name|UndefinedConstantFoldingError
parameter_list|(
specifier|const
name|TSourceLoc
modifier|&
name|loc
parameter_list|,
name|TOperator
name|op
parameter_list|,
name|TBasicType
name|basicType
parameter_list|,
name|TInfoSink
modifier|&
name|infoSink
parameter_list|,
name|TConstantUnion
modifier|*
name|result
parameter_list|)
block|{
name|std
operator|::
name|stringstream
name|constantFoldingErrorStream
decl_stmt|;
name|constantFoldingErrorStream
operator|<<
literal|"'"
operator|<<
name|GetOperatorString
argument_list|(
name|op
argument_list|)
operator|<<
literal|"' operation result is undefined for the values passed in"
expr_stmt|;
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixWarning
argument_list|,
name|loc
argument_list|,
name|constantFoldingErrorStream
operator|.
name|str
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|basicType
condition|)
block|{
case|case
name|EbtFloat
case|:
name|result
operator|->
name|setFConst
argument_list|(
literal|0.0f
argument_list|)
expr_stmt|;
break|break;
case|case
name|EbtInt
case|:
name|result
operator|->
name|setIConst
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|EbtUInt
case|:
name|result
operator|->
name|setUConst
argument_list|(
literal|0u
argument_list|)
expr_stmt|;
break|break;
case|case
name|EbtBool
case|:
name|result
operator|->
name|setBConst
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
DECL|function|VectorLength
name|float
name|VectorLength
parameter_list|(
specifier|const
name|TConstantUnion
modifier|*
name|paramArray
parameter_list|,
name|size_t
name|paramArraySize
parameter_list|)
block|{
name|float
name|result
init|=
literal|0.0f
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|paramArraySize
condition|;
name|i
operator|++
control|)
block|{
name|float
name|f
init|=
name|paramArray
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
decl_stmt|;
name|result
operator|+=
name|f
operator|*
name|f
expr_stmt|;
block|}
return|return
name|sqrtf
argument_list|(
name|result
argument_list|)
return|;
block|}
DECL|function|VectorDotProduct
name|float
name|VectorDotProduct
parameter_list|(
specifier|const
name|TConstantUnion
modifier|*
name|paramArray1
parameter_list|,
specifier|const
name|TConstantUnion
modifier|*
name|paramArray2
parameter_list|,
name|size_t
name|paramArraySize
parameter_list|)
block|{
name|float
name|result
init|=
literal|0.0f
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|paramArraySize
condition|;
name|i
operator|++
control|)
name|result
operator|+=
name|paramArray1
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
operator|*
name|paramArray2
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
DECL|function|CreateFoldedNode
name|TIntermTyped
modifier|*
name|CreateFoldedNode
parameter_list|(
name|TConstantUnion
modifier|*
name|constArray
parameter_list|,
specifier|const
name|TIntermTyped
modifier|*
name|originalNode
parameter_list|,
name|TQualifier
name|qualifier
parameter_list|)
block|{
if|if
condition|(
name|constArray
operator|==
literal|nullptr
condition|)
block|{
return|return
literal|nullptr
return|;
block|}
name|TIntermTyped
modifier|*
name|folded
init|=
operator|new
name|TIntermConstantUnion
argument_list|(
name|constArray
argument_list|,
name|originalNode
operator|->
name|getType
argument_list|()
argument_list|)
decl_stmt|;
name|folded
operator|->
name|getTypePointer
argument_list|()
operator|->
name|setQualifier
argument_list|(
name|qualifier
argument_list|)
expr_stmt|;
name|folded
operator|->
name|setLine
argument_list|(
name|originalNode
operator|->
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|folded
return|;
block|}
DECL|function|GetMatrix
name|angle
operator|::
name|Matrix
argument_list|<
name|float
argument_list|>
name|GetMatrix
parameter_list|(
specifier|const
name|TConstantUnion
modifier|*
name|paramArray
parameter_list|,
specifier|const
name|unsigned
name|int
modifier|&
name|rows
parameter_list|,
specifier|const
name|unsigned
name|int
modifier|&
name|cols
parameter_list|)
block|{
name|std
operator|::
name|vector
argument_list|<
name|float
argument_list|>
name|elements
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rows
operator|*
name|cols
condition|;
name|i
operator|++
control|)
name|elements
operator|.
name|push_back
argument_list|(
name|paramArray
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
argument_list|)
expr_stmt|;
comment|// Transpose is used since the Matrix constructor expects arguments in row-major order,
comment|// whereas the paramArray is in column-major order.
return|return
name|angle
operator|::
name|Matrix
argument_list|<
name|float
argument_list|>
argument_list|(
name|elements
argument_list|,
name|rows
argument_list|,
name|cols
argument_list|)
operator|.
name|transpose
argument_list|()
return|;
block|}
DECL|function|GetMatrix
name|angle
operator|::
name|Matrix
argument_list|<
name|float
argument_list|>
name|GetMatrix
parameter_list|(
specifier|const
name|TConstantUnion
modifier|*
name|paramArray
parameter_list|,
specifier|const
name|unsigned
name|int
modifier|&
name|size
parameter_list|)
block|{
name|std
operator|::
name|vector
argument_list|<
name|float
argument_list|>
name|elements
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
operator|*
name|size
condition|;
name|i
operator|++
control|)
name|elements
operator|.
name|push_back
argument_list|(
name|paramArray
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
argument_list|)
expr_stmt|;
comment|// Transpose is used since the Matrix constructor expects arguments in row-major order,
comment|// whereas the paramArray is in column-major order.
return|return
name|angle
operator|::
name|Matrix
argument_list|<
name|float
argument_list|>
argument_list|(
name|elements
argument_list|,
name|size
argument_list|)
operator|.
name|transpose
argument_list|()
return|;
block|}
DECL|function|SetUnionArrayFromMatrix
name|void
name|SetUnionArrayFromMatrix
parameter_list|(
specifier|const
name|angle
operator|::
name|Matrix
argument_list|<
name|float
argument_list|>
modifier|&
name|m
parameter_list|,
name|TConstantUnion
modifier|*
name|resultArray
parameter_list|)
block|{
comment|// Transpose is used since the input Matrix is in row-major order,
comment|// whereas the actual result should be in column-major order.
name|angle
operator|::
name|Matrix
argument_list|<
name|float
argument_list|>
name|result
init|=
name|m
operator|.
name|transpose
argument_list|()
decl_stmt|;
name|std
operator|::
name|vector
argument_list|<
name|float
argument_list|>
name|resultElements
init|=
name|result
operator|.
name|elements
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|resultElements
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
name|resultArray
index|[
name|i
index|]
operator|.
name|setFConst
argument_list|(
name|resultElements
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_namespace
begin_comment
comment|// namespace anonymous
end_comment
begin_comment
comment|////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Member functions of the nodes used for building the tree.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|////////////////////////////////////////////////////////////////
end_comment
begin_function
DECL|function|setTypePreservePrecision
name|void
name|TIntermTyped
operator|::
name|setTypePreservePrecision
parameter_list|(
specifier|const
name|TType
modifier|&
name|t
parameter_list|)
block|{
name|TPrecision
name|precision
init|=
name|getPrecision
argument_list|()
decl_stmt|;
name|mType
operator|=
name|t
expr_stmt|;
name|ASSERT
argument_list|(
name|mType
operator|.
name|getBasicType
argument_list|()
operator|!=
name|EbtBool
operator|||
name|precision
operator|==
name|EbpUndefined
argument_list|)
expr_stmt|;
name|mType
operator|.
name|setPrecision
argument_list|(
name|precision
argument_list|)
expr_stmt|;
block|}
end_function
begin_define
DECL|macro|REPLACE_IF_IS
define|#
directive|define
name|REPLACE_IF_IS
parameter_list|(
name|node
parameter_list|,
name|type
parameter_list|,
name|original
parameter_list|,
name|replacement
parameter_list|)
define|\
value|if (node == original) { \         node = static_cast<type *>(replacement); \         return true; \     }
end_define
begin_function
DECL|function|replaceChildNode
name|bool
name|TIntermLoop
operator|::
name|replaceChildNode
parameter_list|(
name|TIntermNode
modifier|*
name|original
parameter_list|,
name|TIntermNode
modifier|*
name|replacement
parameter_list|)
block|{
name|REPLACE_IF_IS
argument_list|(
name|mInit
argument_list|,
name|TIntermNode
argument_list|,
name|original
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
name|REPLACE_IF_IS
argument_list|(
name|mCond
argument_list|,
name|TIntermTyped
argument_list|,
name|original
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
name|REPLACE_IF_IS
argument_list|(
name|mExpr
argument_list|,
name|TIntermTyped
argument_list|,
name|original
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
name|REPLACE_IF_IS
argument_list|(
name|mBody
argument_list|,
name|TIntermAggregate
argument_list|,
name|original
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|replaceChildNode
name|bool
name|TIntermBranch
operator|::
name|replaceChildNode
parameter_list|(
name|TIntermNode
modifier|*
name|original
parameter_list|,
name|TIntermNode
modifier|*
name|replacement
parameter_list|)
block|{
name|REPLACE_IF_IS
argument_list|(
name|mExpression
argument_list|,
name|TIntermTyped
argument_list|,
name|original
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|replaceChildNode
name|bool
name|TIntermBinary
operator|::
name|replaceChildNode
parameter_list|(
name|TIntermNode
modifier|*
name|original
parameter_list|,
name|TIntermNode
modifier|*
name|replacement
parameter_list|)
block|{
name|REPLACE_IF_IS
argument_list|(
name|mLeft
argument_list|,
name|TIntermTyped
argument_list|,
name|original
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
name|REPLACE_IF_IS
argument_list|(
name|mRight
argument_list|,
name|TIntermTyped
argument_list|,
name|original
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|replaceChildNode
name|bool
name|TIntermUnary
operator|::
name|replaceChildNode
parameter_list|(
name|TIntermNode
modifier|*
name|original
parameter_list|,
name|TIntermNode
modifier|*
name|replacement
parameter_list|)
block|{
name|REPLACE_IF_IS
argument_list|(
name|mOperand
argument_list|,
name|TIntermTyped
argument_list|,
name|original
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|replaceChildNode
name|bool
name|TIntermAggregate
operator|::
name|replaceChildNode
parameter_list|(
name|TIntermNode
modifier|*
name|original
parameter_list|,
name|TIntermNode
modifier|*
name|replacement
parameter_list|)
block|{
for|for
control|(
name|size_t
name|ii
init|=
literal|0
init|;
name|ii
operator|<
name|mSequence
operator|.
name|size
argument_list|()
condition|;
operator|++
name|ii
control|)
block|{
name|REPLACE_IF_IS
argument_list|(
name|mSequence
index|[
name|ii
index|]
argument_list|,
name|TIntermNode
argument_list|,
name|original
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|replaceChildNodeWithMultiple
name|bool
name|TIntermAggregate
operator|::
name|replaceChildNodeWithMultiple
parameter_list|(
name|TIntermNode
modifier|*
name|original
parameter_list|,
name|TIntermSequence
name|replacements
parameter_list|)
block|{
for|for
control|(
name|auto
name|it
init|=
name|mSequence
operator|.
name|begin
argument_list|()
init|;
name|it
operator|<
name|mSequence
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
operator|*
name|it
operator|==
name|original
condition|)
block|{
name|it
operator|=
name|mSequence
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
name|mSequence
operator|.
name|insert
argument_list|(
name|it
argument_list|,
name|replacements
operator|.
name|begin
argument_list|()
argument_list|,
name|replacements
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|insertChildNodes
name|bool
name|TIntermAggregate
operator|::
name|insertChildNodes
parameter_list|(
name|TIntermSequence
operator|::
name|size_type
name|position
parameter_list|,
name|TIntermSequence
name|insertions
parameter_list|)
block|{
if|if
condition|(
name|position
operator|>
name|mSequence
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|auto
name|it
init|=
name|mSequence
operator|.
name|begin
argument_list|()
operator|+
name|position
decl_stmt|;
name|mSequence
operator|.
name|insert
argument_list|(
name|it
argument_list|,
name|insertions
operator|.
name|begin
argument_list|()
argument_list|,
name|insertions
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|areChildrenConstQualified
name|bool
name|TIntermAggregate
operator|::
name|areChildrenConstQualified
parameter_list|()
block|{
for|for
control|(
name|TIntermNode
modifier|*
modifier|&
name|child
range|:
name|mSequence
control|)
block|{
name|TIntermTyped
modifier|*
name|typed
init|=
name|child
operator|->
name|getAsTyped
argument_list|()
decl_stmt|;
if|if
condition|(
name|typed
operator|&&
name|typed
operator|->
name|getQualifier
argument_list|()
operator|!=
name|EvqConst
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|setPrecisionFromChildren
name|void
name|TIntermAggregate
operator|::
name|setPrecisionFromChildren
parameter_list|()
block|{
name|mGotPrecisionFromChildren
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|getBasicType
argument_list|()
operator|==
name|EbtBool
condition|)
block|{
name|mType
operator|.
name|setPrecision
argument_list|(
name|EbpUndefined
argument_list|)
expr_stmt|;
return|return;
block|}
name|TPrecision
name|precision
init|=
name|EbpUndefined
decl_stmt|;
name|TIntermSequence
operator|::
name|iterator
name|childIter
init|=
name|mSequence
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|childIter
operator|!=
name|mSequence
operator|.
name|end
argument_list|()
condition|)
block|{
name|TIntermTyped
modifier|*
name|typed
init|=
operator|(
operator|*
name|childIter
operator|)
operator|->
name|getAsTyped
argument_list|()
decl_stmt|;
if|if
condition|(
name|typed
condition|)
name|precision
operator|=
name|GetHigherPrecision
argument_list|(
name|typed
operator|->
name|getPrecision
argument_list|()
argument_list|,
name|precision
argument_list|)
expr_stmt|;
operator|++
name|childIter
expr_stmt|;
block|}
name|mType
operator|.
name|setPrecision
argument_list|(
name|precision
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setBuiltInFunctionPrecision
name|void
name|TIntermAggregate
operator|::
name|setBuiltInFunctionPrecision
parameter_list|()
block|{
comment|// All built-ins returning bool should be handled as ops, not functions.
name|ASSERT
argument_list|(
name|getBasicType
argument_list|()
operator|!=
name|EbtBool
argument_list|)
expr_stmt|;
name|TPrecision
name|precision
init|=
name|EbpUndefined
decl_stmt|;
name|TIntermSequence
operator|::
name|iterator
name|childIter
init|=
name|mSequence
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|childIter
operator|!=
name|mSequence
operator|.
name|end
argument_list|()
condition|)
block|{
name|TIntermTyped
modifier|*
name|typed
init|=
operator|(
operator|*
name|childIter
operator|)
operator|->
name|getAsTyped
argument_list|()
decl_stmt|;
comment|// ESSL spec section 8: texture functions get their precision from the sampler.
if|if
condition|(
name|typed
operator|&&
name|IsSampler
argument_list|(
name|typed
operator|->
name|getBasicType
argument_list|()
argument_list|)
condition|)
block|{
name|precision
operator|=
name|typed
operator|->
name|getPrecision
argument_list|()
expr_stmt|;
break|break;
block|}
operator|++
name|childIter
expr_stmt|;
block|}
comment|// ESSL 3.0 spec section 8: textureSize always gets highp precision.
comment|// All other functions that take a sampler are assumed to be texture functions.
if|if
condition|(
name|mName
operator|.
name|getString
argument_list|()
operator|.
name|find
argument_list|(
literal|"textureSize"
argument_list|)
operator|==
literal|0
condition|)
name|mType
operator|.
name|setPrecision
argument_list|(
name|EbpHigh
argument_list|)
expr_stmt|;
else|else
name|mType
operator|.
name|setPrecision
argument_list|(
name|precision
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|replaceChildNode
name|bool
name|TIntermSelection
operator|::
name|replaceChildNode
parameter_list|(
name|TIntermNode
modifier|*
name|original
parameter_list|,
name|TIntermNode
modifier|*
name|replacement
parameter_list|)
block|{
name|REPLACE_IF_IS
argument_list|(
name|mCondition
argument_list|,
name|TIntermTyped
argument_list|,
name|original
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
name|REPLACE_IF_IS
argument_list|(
name|mTrueBlock
argument_list|,
name|TIntermNode
argument_list|,
name|original
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
name|REPLACE_IF_IS
argument_list|(
name|mFalseBlock
argument_list|,
name|TIntermNode
argument_list|,
name|original
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|replaceChildNode
name|bool
name|TIntermSwitch
operator|::
name|replaceChildNode
parameter_list|(
name|TIntermNode
modifier|*
name|original
parameter_list|,
name|TIntermNode
modifier|*
name|replacement
parameter_list|)
block|{
name|REPLACE_IF_IS
argument_list|(
name|mInit
argument_list|,
name|TIntermTyped
argument_list|,
name|original
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
name|REPLACE_IF_IS
argument_list|(
name|mStatementList
argument_list|,
name|TIntermAggregate
argument_list|,
name|original
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|replaceChildNode
name|bool
name|TIntermCase
operator|::
name|replaceChildNode
parameter_list|(
name|TIntermNode
modifier|*
name|original
parameter_list|,
name|TIntermNode
modifier|*
name|replacement
parameter_list|)
block|{
name|REPLACE_IF_IS
argument_list|(
name|mCondition
argument_list|,
name|TIntermTyped
argument_list|,
name|original
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_constructor
DECL|function|TIntermTyped
name|TIntermTyped
operator|::
name|TIntermTyped
parameter_list|(
specifier|const
name|TIntermTyped
modifier|&
name|node
parameter_list|)
member_init_list|:
name|TIntermNode
argument_list|()
member_init_list|,
name|mType
argument_list|(
name|node
operator|.
name|mType
argument_list|)
block|{
comment|// Copy constructor is disallowed for TIntermNode in order to disallow it for subclasses that
comment|// don't explicitly allow it, so normal TIntermNode constructor is used to construct the copy.
comment|// We need to manually copy any fields of TIntermNode besides handling fields in TIntermTyped.
name|mLine
operator|=
name|node
operator|.
name|mLine
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|TIntermConstantUnion
name|TIntermConstantUnion
operator|::
name|TIntermConstantUnion
parameter_list|(
specifier|const
name|TIntermConstantUnion
modifier|&
name|node
parameter_list|)
member_init_list|:
name|TIntermTyped
argument_list|(
name|node
argument_list|)
block|{
name|mUnionArrayPointer
operator|=
name|node
operator|.
name|mUnionArrayPointer
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|TIntermAggregate
name|TIntermAggregate
operator|::
name|TIntermAggregate
parameter_list|(
specifier|const
name|TIntermAggregate
modifier|&
name|node
parameter_list|)
member_init_list|:
name|TIntermOperator
argument_list|(
name|node
argument_list|)
member_init_list|,
name|mName
argument_list|(
name|node
operator|.
name|mName
argument_list|)
member_init_list|,
name|mUserDefined
argument_list|(
name|node
operator|.
name|mUserDefined
argument_list|)
member_init_list|,
name|mFunctionId
argument_list|(
name|node
operator|.
name|mFunctionId
argument_list|)
member_init_list|,
name|mUseEmulatedFunction
argument_list|(
name|node
operator|.
name|mUseEmulatedFunction
argument_list|)
member_init_list|,
name|mGotPrecisionFromChildren
argument_list|(
name|node
operator|.
name|mGotPrecisionFromChildren
argument_list|)
block|{
for|for
control|(
name|TIntermNode
modifier|*
name|child
range|:
name|node
operator|.
name|mSequence
control|)
block|{
name|TIntermTyped
modifier|*
name|typedChild
init|=
name|child
operator|->
name|getAsTyped
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|typedChild
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
name|TIntermTyped
modifier|*
name|childCopy
init|=
name|typedChild
operator|->
name|deepCopy
argument_list|()
decl_stmt|;
name|mSequence
operator|.
name|push_back
argument_list|(
name|childCopy
argument_list|)
expr_stmt|;
block|}
block|}
end_constructor
begin_constructor
DECL|function|TIntermBinary
name|TIntermBinary
operator|::
name|TIntermBinary
parameter_list|(
specifier|const
name|TIntermBinary
modifier|&
name|node
parameter_list|)
member_init_list|:
name|TIntermOperator
argument_list|(
name|node
argument_list|)
member_init_list|,
name|mAddIndexClamp
argument_list|(
name|node
operator|.
name|mAddIndexClamp
argument_list|)
block|{
name|TIntermTyped
modifier|*
name|leftCopy
init|=
name|node
operator|.
name|mLeft
operator|->
name|deepCopy
argument_list|()
decl_stmt|;
name|TIntermTyped
modifier|*
name|rightCopy
init|=
name|node
operator|.
name|mRight
operator|->
name|deepCopy
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|leftCopy
operator|!=
literal|nullptr
operator|&&
name|rightCopy
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
name|mLeft
operator|=
name|leftCopy
expr_stmt|;
name|mRight
operator|=
name|rightCopy
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|TIntermUnary
name|TIntermUnary
operator|::
name|TIntermUnary
parameter_list|(
specifier|const
name|TIntermUnary
modifier|&
name|node
parameter_list|)
member_init_list|:
name|TIntermOperator
argument_list|(
name|node
argument_list|)
member_init_list|,
name|mUseEmulatedFunction
argument_list|(
name|node
operator|.
name|mUseEmulatedFunction
argument_list|)
block|{
name|TIntermTyped
modifier|*
name|operandCopy
init|=
name|node
operator|.
name|mOperand
operator|->
name|deepCopy
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|operandCopy
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
name|mOperand
operator|=
name|operandCopy
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|TIntermSelection
name|TIntermSelection
operator|::
name|TIntermSelection
parameter_list|(
specifier|const
name|TIntermSelection
modifier|&
name|node
parameter_list|)
member_init_list|:
name|TIntermTyped
argument_list|(
name|node
argument_list|)
block|{
comment|// Only supported for ternary nodes, not if statements.
name|TIntermTyped
modifier|*
name|trueTyped
init|=
name|node
operator|.
name|mTrueBlock
operator|->
name|getAsTyped
argument_list|()
decl_stmt|;
name|TIntermTyped
modifier|*
name|falseTyped
init|=
name|node
operator|.
name|mFalseBlock
operator|->
name|getAsTyped
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|trueTyped
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|falseTyped
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
name|TIntermTyped
modifier|*
name|conditionCopy
init|=
name|node
operator|.
name|mCondition
operator|->
name|deepCopy
argument_list|()
decl_stmt|;
name|TIntermTyped
modifier|*
name|trueCopy
init|=
name|trueTyped
operator|->
name|deepCopy
argument_list|()
decl_stmt|;
name|TIntermTyped
modifier|*
name|falseCopy
init|=
name|falseTyped
operator|->
name|deepCopy
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|conditionCopy
operator|!=
literal|nullptr
operator|&&
name|trueCopy
operator|!=
literal|nullptr
operator|&&
name|falseCopy
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
name|mCondition
operator|=
name|conditionCopy
expr_stmt|;
name|mTrueBlock
operator|=
name|trueCopy
expr_stmt|;
name|mFalseBlock
operator|=
name|falseCopy
expr_stmt|;
block|}
end_constructor
begin_comment
comment|//
end_comment
begin_comment
comment|// Say whether or not an operation node changes the value of a variable.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|isAssignment
name|bool
name|TIntermOperator
operator|::
name|isAssignment
parameter_list|()
specifier|const
block|{
switch|switch
condition|(
name|mOp
condition|)
block|{
case|case
name|EOpPostIncrement
case|:
case|case
name|EOpPostDecrement
case|:
case|case
name|EOpPreIncrement
case|:
case|case
name|EOpPreDecrement
case|:
case|case
name|EOpAssign
case|:
case|case
name|EOpAddAssign
case|:
case|case
name|EOpSubAssign
case|:
case|case
name|EOpMulAssign
case|:
case|case
name|EOpVectorTimesMatrixAssign
case|:
case|case
name|EOpVectorTimesScalarAssign
case|:
case|case
name|EOpMatrixTimesScalarAssign
case|:
case|case
name|EOpMatrixTimesMatrixAssign
case|:
case|case
name|EOpDivAssign
case|:
case|case
name|EOpIModAssign
case|:
case|case
name|EOpBitShiftLeftAssign
case|:
case|case
name|EOpBitShiftRightAssign
case|:
case|case
name|EOpBitwiseAndAssign
case|:
case|case
name|EOpBitwiseXorAssign
case|:
case|case
name|EOpBitwiseOrAssign
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
end_function
begin_function
DECL|function|isMultiplication
name|bool
name|TIntermOperator
operator|::
name|isMultiplication
parameter_list|()
specifier|const
block|{
switch|switch
condition|(
name|mOp
condition|)
block|{
case|case
name|EOpMul
case|:
case|case
name|EOpMatrixTimesMatrix
case|:
case|case
name|EOpMatrixTimesVector
case|:
case|case
name|EOpMatrixTimesScalar
case|:
case|case
name|EOpVectorTimesMatrix
case|:
case|case
name|EOpVectorTimesScalar
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// returns true if the operator is for one of the constructors
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|isConstructor
name|bool
name|TIntermOperator
operator|::
name|isConstructor
parameter_list|()
specifier|const
block|{
switch|switch
condition|(
name|mOp
condition|)
block|{
case|case
name|EOpConstructVec2
case|:
case|case
name|EOpConstructVec3
case|:
case|case
name|EOpConstructVec4
case|:
case|case
name|EOpConstructMat2
case|:
case|case
name|EOpConstructMat2x3
case|:
case|case
name|EOpConstructMat2x4
case|:
case|case
name|EOpConstructMat3x2
case|:
case|case
name|EOpConstructMat3
case|:
case|case
name|EOpConstructMat3x4
case|:
case|case
name|EOpConstructMat4x2
case|:
case|case
name|EOpConstructMat4x3
case|:
case|case
name|EOpConstructMat4
case|:
case|case
name|EOpConstructFloat
case|:
case|case
name|EOpConstructIVec2
case|:
case|case
name|EOpConstructIVec3
case|:
case|case
name|EOpConstructIVec4
case|:
case|case
name|EOpConstructInt
case|:
case|case
name|EOpConstructUVec2
case|:
case|case
name|EOpConstructUVec3
case|:
case|case
name|EOpConstructUVec4
case|:
case|case
name|EOpConstructUInt
case|:
case|case
name|EOpConstructBVec2
case|:
case|case
name|EOpConstructBVec3
case|:
case|case
name|EOpConstructBVec4
case|:
case|case
name|EOpConstructBool
case|:
case|case
name|EOpConstructStruct
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Make sure the type of a unary operator is appropriate for its
end_comment
begin_comment
comment|// combination of operation and operand type.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|promote
name|void
name|TIntermUnary
operator|::
name|promote
parameter_list|(
specifier|const
name|TType
modifier|*
name|funcReturnType
parameter_list|)
block|{
switch|switch
condition|(
name|mOp
condition|)
block|{
case|case
name|EOpFloatBitsToInt
case|:
case|case
name|EOpFloatBitsToUint
case|:
case|case
name|EOpIntBitsToFloat
case|:
case|case
name|EOpUintBitsToFloat
case|:
case|case
name|EOpPackSnorm2x16
case|:
case|case
name|EOpPackUnorm2x16
case|:
case|case
name|EOpPackHalf2x16
case|:
case|case
name|EOpUnpackSnorm2x16
case|:
case|case
name|EOpUnpackUnorm2x16
case|:
name|mType
operator|.
name|setPrecision
argument_list|(
name|EbpHigh
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpUnpackHalf2x16
case|:
name|mType
operator|.
name|setPrecision
argument_list|(
name|EbpMedium
argument_list|)
expr_stmt|;
break|break;
default|default:
name|setType
argument_list|(
name|mOperand
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|funcReturnType
operator|!=
literal|nullptr
condition|)
block|{
if|if
condition|(
name|funcReturnType
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtBool
condition|)
block|{
comment|// Bool types should not have precision.
name|setType
argument_list|(
operator|*
name|funcReturnType
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Precision of the node has been set based on the operand.
name|setTypePreservePrecision
argument_list|(
operator|*
name|funcReturnType
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mOperand
operator|->
name|getQualifier
argument_list|()
operator|==
name|EvqConst
condition|)
name|mType
operator|.
name|setQualifier
argument_list|(
name|EvqConst
argument_list|)
expr_stmt|;
else|else
name|mType
operator|.
name|setQualifier
argument_list|(
name|EvqTemporary
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Establishes the type of the resultant operation, as well as
end_comment
begin_comment
comment|// makes the operator the correct one for the operands.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// For lots of operations it should already be established that the operand
end_comment
begin_comment
comment|// combination is valid, but returns false if operator can't work on operands.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|promote
name|bool
name|TIntermBinary
operator|::
name|promote
parameter_list|(
name|TInfoSink
modifier|&
name|infoSink
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|mLeft
operator|->
name|isArray
argument_list|()
operator|==
name|mRight
operator|->
name|isArray
argument_list|()
argument_list|)
expr_stmt|;
comment|//
comment|// Base assumption:  just make the type the same as the left
comment|// operand.  Then only deviations from this need be coded.
comment|//
name|setType
argument_list|(
name|mLeft
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
comment|// The result gets promoted to the highest precision.
name|TPrecision
name|higherPrecision
init|=
name|GetHigherPrecision
argument_list|(
name|mLeft
operator|->
name|getPrecision
argument_list|()
argument_list|,
name|mRight
operator|->
name|getPrecision
argument_list|()
argument_list|)
decl_stmt|;
name|getTypePointer
argument_list|()
operator|->
name|setPrecision
argument_list|(
name|higherPrecision
argument_list|)
expr_stmt|;
name|TQualifier
name|resultQualifier
init|=
name|EvqConst
decl_stmt|;
comment|// Binary operations results in temporary variables unless both
comment|// operands are const.
if|if
condition|(
name|mLeft
operator|->
name|getQualifier
argument_list|()
operator|!=
name|EvqConst
operator|||
name|mRight
operator|->
name|getQualifier
argument_list|()
operator|!=
name|EvqConst
condition|)
block|{
name|resultQualifier
operator|=
name|EvqTemporary
expr_stmt|;
name|getTypePointer
argument_list|()
operator|->
name|setQualifier
argument_list|(
name|EvqTemporary
argument_list|)
expr_stmt|;
block|}
specifier|const
name|int
name|nominalSize
init|=
name|std
operator|::
name|max
argument_list|(
name|mLeft
operator|->
name|getNominalSize
argument_list|()
argument_list|,
name|mRight
operator|->
name|getNominalSize
argument_list|()
argument_list|)
decl_stmt|;
comment|//
comment|// All scalars or structs. Code after this test assumes this case is removed!
comment|//
if|if
condition|(
name|nominalSize
operator|==
literal|1
condition|)
block|{
switch|switch
condition|(
name|mOp
condition|)
block|{
comment|//
comment|// Promote to conditional
comment|//
case|case
name|EOpEqual
case|:
case|case
name|EOpNotEqual
case|:
case|case
name|EOpLessThan
case|:
case|case
name|EOpGreaterThan
case|:
case|case
name|EOpLessThanEqual
case|:
case|case
name|EOpGreaterThanEqual
case|:
name|setType
argument_list|(
name|TType
argument_list|(
name|EbtBool
argument_list|,
name|EbpUndefined
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|//
comment|// And and Or operate on conditionals
comment|//
case|case
name|EOpLogicalAnd
case|:
case|case
name|EOpLogicalXor
case|:
case|case
name|EOpLogicalOr
case|:
name|ASSERT
argument_list|(
name|mLeft
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtBool
operator|&&
name|mRight
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtBool
argument_list|)
expr_stmt|;
name|setType
argument_list|(
name|TType
argument_list|(
name|EbtBool
argument_list|,
name|EbpUndefined
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
literal|true
return|;
block|}
comment|// If we reach here, at least one of the operands is vector or matrix.
comment|// The other operand could be a scalar, vector, or matrix.
comment|// Can these two operands be combined?
comment|//
name|TBasicType
name|basicType
init|=
name|mLeft
operator|->
name|getBasicType
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|mOp
condition|)
block|{
case|case
name|EOpMul
case|:
if|if
condition|(
operator|!
name|mLeft
operator|->
name|isMatrix
argument_list|()
operator|&&
name|mRight
operator|->
name|isMatrix
argument_list|()
condition|)
block|{
if|if
condition|(
name|mLeft
operator|->
name|isVector
argument_list|()
condition|)
block|{
name|mOp
operator|=
name|EOpVectorTimesMatrix
expr_stmt|;
name|setType
argument_list|(
name|TType
argument_list|(
name|basicType
argument_list|,
name|higherPrecision
argument_list|,
name|resultQualifier
argument_list|,
cast|static_cast
argument_list|<
name|unsigned
name|char
argument_list|>
argument_list|(
name|mRight
operator|->
name|getCols
argument_list|()
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mOp
operator|=
name|EOpMatrixTimesScalar
expr_stmt|;
name|setType
argument_list|(
name|TType
argument_list|(
name|basicType
argument_list|,
name|higherPrecision
argument_list|,
name|resultQualifier
argument_list|,
cast|static_cast
argument_list|<
name|unsigned
name|char
argument_list|>
argument_list|(
name|mRight
operator|->
name|getCols
argument_list|()
argument_list|)
argument_list|,
cast|static_cast
argument_list|<
name|unsigned
name|char
argument_list|>
argument_list|(
name|mRight
operator|->
name|getRows
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mLeft
operator|->
name|isMatrix
argument_list|()
operator|&&
operator|!
name|mRight
operator|->
name|isMatrix
argument_list|()
condition|)
block|{
if|if
condition|(
name|mRight
operator|->
name|isVector
argument_list|()
condition|)
block|{
name|mOp
operator|=
name|EOpMatrixTimesVector
expr_stmt|;
name|setType
argument_list|(
name|TType
argument_list|(
name|basicType
argument_list|,
name|higherPrecision
argument_list|,
name|resultQualifier
argument_list|,
cast|static_cast
argument_list|<
name|unsigned
name|char
argument_list|>
argument_list|(
name|mLeft
operator|->
name|getRows
argument_list|()
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mOp
operator|=
name|EOpMatrixTimesScalar
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mLeft
operator|->
name|isMatrix
argument_list|()
operator|&&
name|mRight
operator|->
name|isMatrix
argument_list|()
condition|)
block|{
name|mOp
operator|=
name|EOpMatrixTimesMatrix
expr_stmt|;
name|setType
argument_list|(
name|TType
argument_list|(
name|basicType
argument_list|,
name|higherPrecision
argument_list|,
name|resultQualifier
argument_list|,
cast|static_cast
argument_list|<
name|unsigned
name|char
argument_list|>
argument_list|(
name|mRight
operator|->
name|getCols
argument_list|()
argument_list|)
argument_list|,
cast|static_cast
argument_list|<
name|unsigned
name|char
argument_list|>
argument_list|(
name|mLeft
operator|->
name|getRows
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|mLeft
operator|->
name|isMatrix
argument_list|()
operator|&&
operator|!
name|mRight
operator|->
name|isMatrix
argument_list|()
condition|)
block|{
if|if
condition|(
name|mLeft
operator|->
name|isVector
argument_list|()
operator|&&
name|mRight
operator|->
name|isVector
argument_list|()
condition|)
block|{
comment|// leave as component product
block|}
elseif|else
if|if
condition|(
name|mLeft
operator|->
name|isVector
argument_list|()
operator|||
name|mRight
operator|->
name|isVector
argument_list|()
condition|)
block|{
name|mOp
operator|=
name|EOpVectorTimesScalar
expr_stmt|;
name|setType
argument_list|(
name|TType
argument_list|(
name|basicType
argument_list|,
name|higherPrecision
argument_list|,
name|resultQualifier
argument_list|,
cast|static_cast
argument_list|<
name|unsigned
name|char
argument_list|>
argument_list|(
name|nominalSize
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Missing elses"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|ValidateMultiplication
argument_list|(
name|mOp
argument_list|,
name|mLeft
operator|->
name|getType
argument_list|()
argument_list|,
name|mRight
operator|->
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
break|break;
case|case
name|EOpMulAssign
case|:
if|if
condition|(
operator|!
name|mLeft
operator|->
name|isMatrix
argument_list|()
operator|&&
name|mRight
operator|->
name|isMatrix
argument_list|()
condition|)
block|{
if|if
condition|(
name|mLeft
operator|->
name|isVector
argument_list|()
condition|)
block|{
name|mOp
operator|=
name|EOpVectorTimesMatrixAssign
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|mLeft
operator|->
name|isMatrix
argument_list|()
operator|&&
operator|!
name|mRight
operator|->
name|isMatrix
argument_list|()
condition|)
block|{
if|if
condition|(
name|mRight
operator|->
name|isVector
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
name|mOp
operator|=
name|EOpMatrixTimesScalarAssign
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mLeft
operator|->
name|isMatrix
argument_list|()
operator|&&
name|mRight
operator|->
name|isMatrix
argument_list|()
condition|)
block|{
name|mOp
operator|=
name|EOpMatrixTimesMatrixAssign
expr_stmt|;
name|setType
argument_list|(
name|TType
argument_list|(
name|basicType
argument_list|,
name|higherPrecision
argument_list|,
name|resultQualifier
argument_list|,
cast|static_cast
argument_list|<
name|unsigned
name|char
argument_list|>
argument_list|(
name|mRight
operator|->
name|getCols
argument_list|()
argument_list|)
argument_list|,
cast|static_cast
argument_list|<
name|unsigned
name|char
argument_list|>
argument_list|(
name|mLeft
operator|->
name|getRows
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|mLeft
operator|->
name|isMatrix
argument_list|()
operator|&&
operator|!
name|mRight
operator|->
name|isMatrix
argument_list|()
condition|)
block|{
if|if
condition|(
name|mLeft
operator|->
name|isVector
argument_list|()
operator|&&
name|mRight
operator|->
name|isVector
argument_list|()
condition|)
block|{
comment|// leave as component product
block|}
elseif|else
if|if
condition|(
name|mLeft
operator|->
name|isVector
argument_list|()
operator|||
name|mRight
operator|->
name|isVector
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|mLeft
operator|->
name|isVector
argument_list|()
condition|)
return|return
literal|false
return|;
name|mOp
operator|=
name|EOpVectorTimesScalarAssign
expr_stmt|;
name|setType
argument_list|(
name|TType
argument_list|(
name|basicType
argument_list|,
name|higherPrecision
argument_list|,
name|resultQualifier
argument_list|,
cast|static_cast
argument_list|<
name|unsigned
name|char
argument_list|>
argument_list|(
name|mLeft
operator|->
name|getNominalSize
argument_list|()
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Missing elses"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|ValidateMultiplication
argument_list|(
name|mOp
argument_list|,
name|mLeft
operator|->
name|getType
argument_list|()
argument_list|,
name|mRight
operator|->
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
break|break;
case|case
name|EOpAssign
case|:
case|case
name|EOpInitialize
case|:
comment|// No more additional checks are needed.
name|ASSERT
argument_list|(
operator|(
name|mLeft
operator|->
name|getNominalSize
argument_list|()
operator|==
name|mRight
operator|->
name|getNominalSize
argument_list|()
operator|)
operator|&&
operator|(
name|mLeft
operator|->
name|getSecondarySize
argument_list|()
operator|==
name|mRight
operator|->
name|getSecondarySize
argument_list|()
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpAdd
case|:
case|case
name|EOpSub
case|:
case|case
name|EOpDiv
case|:
case|case
name|EOpIMod
case|:
case|case
name|EOpBitShiftLeft
case|:
case|case
name|EOpBitShiftRight
case|:
case|case
name|EOpBitwiseAnd
case|:
case|case
name|EOpBitwiseXor
case|:
case|case
name|EOpBitwiseOr
case|:
case|case
name|EOpAddAssign
case|:
case|case
name|EOpSubAssign
case|:
case|case
name|EOpDivAssign
case|:
case|case
name|EOpIModAssign
case|:
case|case
name|EOpBitShiftLeftAssign
case|:
case|case
name|EOpBitShiftRightAssign
case|:
case|case
name|EOpBitwiseAndAssign
case|:
case|case
name|EOpBitwiseXorAssign
case|:
case|case
name|EOpBitwiseOrAssign
case|:
if|if
condition|(
operator|(
name|mLeft
operator|->
name|isMatrix
argument_list|()
operator|&&
name|mRight
operator|->
name|isVector
argument_list|()
operator|)
operator|||
operator|(
name|mLeft
operator|->
name|isVector
argument_list|()
operator|&&
name|mRight
operator|->
name|isMatrix
argument_list|()
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Are the sizes compatible?
if|if
condition|(
name|mLeft
operator|->
name|getNominalSize
argument_list|()
operator|!=
name|mRight
operator|->
name|getNominalSize
argument_list|()
operator|||
name|mLeft
operator|->
name|getSecondarySize
argument_list|()
operator|!=
name|mRight
operator|->
name|getSecondarySize
argument_list|()
condition|)
block|{
comment|// If the nominal sizes of operands do not match:
comment|// One of them must be a scalar.
if|if
condition|(
operator|!
name|mLeft
operator|->
name|isScalar
argument_list|()
operator|&&
operator|!
name|mRight
operator|->
name|isScalar
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// In the case of compound assignment other than multiply-assign,
comment|// the right side needs to be a scalar. Otherwise a vector/matrix
comment|// would be assigned to a scalar. A scalar can't be shifted by a
comment|// vector either.
if|if
condition|(
operator|!
name|mRight
operator|->
name|isScalar
argument_list|()
operator|&&
operator|(
name|isAssignment
argument_list|()
operator|||
name|mOp
operator|==
name|EOpBitShiftLeft
operator|||
name|mOp
operator|==
name|EOpBitShiftRight
operator|)
condition|)
return|return
literal|false
return|;
block|}
block|{
specifier|const
name|int
name|secondarySize
init|=
name|std
operator|::
name|max
argument_list|(
name|mLeft
operator|->
name|getSecondarySize
argument_list|()
argument_list|,
name|mRight
operator|->
name|getSecondarySize
argument_list|()
argument_list|)
decl_stmt|;
name|setType
argument_list|(
name|TType
argument_list|(
name|basicType
argument_list|,
name|higherPrecision
argument_list|,
name|resultQualifier
argument_list|,
cast|static_cast
argument_list|<
name|unsigned
name|char
argument_list|>
argument_list|(
name|nominalSize
argument_list|)
argument_list|,
cast|static_cast
argument_list|<
name|unsigned
name|char
argument_list|>
argument_list|(
name|secondarySize
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mLeft
operator|->
name|isArray
argument_list|()
condition|)
block|{
name|ASSERT
argument_list|(
name|mLeft
operator|->
name|getArraySize
argument_list|()
operator|==
name|mRight
operator|->
name|getArraySize
argument_list|()
argument_list|)
expr_stmt|;
name|mType
operator|.
name|setArraySize
argument_list|(
name|mLeft
operator|->
name|getArraySize
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|EOpEqual
case|:
case|case
name|EOpNotEqual
case|:
case|case
name|EOpLessThan
case|:
case|case
name|EOpGreaterThan
case|:
case|case
name|EOpLessThanEqual
case|:
case|case
name|EOpGreaterThanEqual
case|:
name|ASSERT
argument_list|(
operator|(
name|mLeft
operator|->
name|getNominalSize
argument_list|()
operator|==
name|mRight
operator|->
name|getNominalSize
argument_list|()
operator|)
operator|&&
operator|(
name|mLeft
operator|->
name|getSecondarySize
argument_list|()
operator|==
name|mRight
operator|->
name|getSecondarySize
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|setType
argument_list|(
name|TType
argument_list|(
name|EbtBool
argument_list|,
name|EbpUndefined
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|fold
name|TIntermTyped
modifier|*
name|TIntermBinary
operator|::
name|fold
parameter_list|(
name|TInfoSink
modifier|&
name|infoSink
parameter_list|)
block|{
name|TIntermConstantUnion
modifier|*
name|leftConstant
init|=
name|mLeft
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
name|TIntermConstantUnion
modifier|*
name|rightConstant
init|=
name|mRight
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
if|if
condition|(
name|leftConstant
operator|==
literal|nullptr
operator|||
name|rightConstant
operator|==
literal|nullptr
condition|)
block|{
return|return
literal|nullptr
return|;
block|}
name|TConstantUnion
modifier|*
name|constArray
init|=
name|leftConstant
operator|->
name|foldBinary
argument_list|(
name|mOp
argument_list|,
name|rightConstant
argument_list|,
name|infoSink
argument_list|)
decl_stmt|;
comment|// Nodes may be constant folded without being qualified as constant.
name|TQualifier
name|resultQualifier
init|=
name|EvqConst
decl_stmt|;
if|if
condition|(
name|mLeft
operator|->
name|getQualifier
argument_list|()
operator|!=
name|EvqConst
operator|||
name|mRight
operator|->
name|getQualifier
argument_list|()
operator|!=
name|EvqConst
condition|)
block|{
name|resultQualifier
operator|=
name|EvqTemporary
expr_stmt|;
block|}
return|return
name|CreateFoldedNode
argument_list|(
name|constArray
argument_list|,
name|this
argument_list|,
name|resultQualifier
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|fold
name|TIntermTyped
modifier|*
name|TIntermUnary
operator|::
name|fold
parameter_list|(
name|TInfoSink
modifier|&
name|infoSink
parameter_list|)
block|{
name|TIntermConstantUnion
modifier|*
name|operandConstant
init|=
name|mOperand
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
if|if
condition|(
name|operandConstant
operator|==
literal|nullptr
condition|)
block|{
return|return
literal|nullptr
return|;
block|}
name|TConstantUnion
modifier|*
name|constArray
init|=
literal|nullptr
decl_stmt|;
switch|switch
condition|(
name|mOp
condition|)
block|{
case|case
name|EOpAny
case|:
case|case
name|EOpAll
case|:
case|case
name|EOpLength
case|:
case|case
name|EOpTranspose
case|:
case|case
name|EOpDeterminant
case|:
case|case
name|EOpInverse
case|:
case|case
name|EOpPackSnorm2x16
case|:
case|case
name|EOpUnpackSnorm2x16
case|:
case|case
name|EOpPackUnorm2x16
case|:
case|case
name|EOpUnpackUnorm2x16
case|:
case|case
name|EOpPackHalf2x16
case|:
case|case
name|EOpUnpackHalf2x16
case|:
name|constArray
operator|=
name|operandConstant
operator|->
name|foldUnaryWithDifferentReturnType
argument_list|(
name|mOp
argument_list|,
name|infoSink
argument_list|)
expr_stmt|;
break|break;
default|default:
name|constArray
operator|=
name|operandConstant
operator|->
name|foldUnaryWithSameReturnType
argument_list|(
name|mOp
argument_list|,
name|infoSink
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// Nodes may be constant folded without being qualified as constant.
name|TQualifier
name|resultQualifier
init|=
name|mOperand
operator|->
name|getQualifier
argument_list|()
operator|==
name|EvqConst
condition|?
name|EvqConst
else|:
name|EvqTemporary
decl_stmt|;
return|return
name|CreateFoldedNode
argument_list|(
name|constArray
argument_list|,
name|this
argument_list|,
name|resultQualifier
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|fold
name|TIntermTyped
modifier|*
name|TIntermAggregate
operator|::
name|fold
parameter_list|(
name|TInfoSink
modifier|&
name|infoSink
parameter_list|)
block|{
comment|// Make sure that all params are constant before actual constant folding.
for|for
control|(
name|auto
operator|*
name|param
operator|:
operator|*
name|getSequence
argument_list|()
control|)
block|{
if|if
condition|(
name|param
operator|->
name|getAsConstantUnion
argument_list|()
operator|==
literal|nullptr
condition|)
block|{
return|return
literal|nullptr
return|;
block|}
block|}
name|TConstantUnion
modifier|*
name|constArray
init|=
literal|nullptr
decl_stmt|;
if|if
condition|(
name|isConstructor
argument_list|()
condition|)
name|constArray
operator|=
name|TIntermConstantUnion
operator|::
name|FoldAggregateConstructor
argument_list|(
name|this
argument_list|,
name|infoSink
argument_list|)
expr_stmt|;
else|else
name|constArray
operator|=
name|TIntermConstantUnion
operator|::
name|FoldAggregateBuiltIn
argument_list|(
name|this
argument_list|,
name|infoSink
argument_list|)
expr_stmt|;
comment|// Nodes may be constant folded without being qualified as constant.
name|TQualifier
name|resultQualifier
init|=
name|areChildrenConstQualified
argument_list|()
condition|?
name|EvqConst
else|:
name|EvqTemporary
decl_stmt|;
return|return
name|CreateFoldedNode
argument_list|(
name|constArray
argument_list|,
name|this
argument_list|,
name|resultQualifier
argument_list|)
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// The fold functions see if an operation on a constant can be done in place,
end_comment
begin_comment
comment|// without generating run-time code.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns the constant value to keep using or nullptr.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|foldBinary
name|TConstantUnion
modifier|*
name|TIntermConstantUnion
operator|::
name|foldBinary
parameter_list|(
name|TOperator
name|op
parameter_list|,
name|TIntermConstantUnion
modifier|*
name|rightNode
parameter_list|,
name|TInfoSink
modifier|&
name|infoSink
parameter_list|)
block|{
specifier|const
name|TConstantUnion
modifier|*
name|leftArray
init|=
name|getUnionArrayPointer
argument_list|()
decl_stmt|;
specifier|const
name|TConstantUnion
modifier|*
name|rightArray
init|=
name|rightNode
operator|->
name|getUnionArrayPointer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|leftArray
condition|)
return|return
literal|nullptr
return|;
if|if
condition|(
operator|!
name|rightArray
condition|)
return|return
literal|nullptr
return|;
name|size_t
name|objectSize
init|=
name|getType
argument_list|()
operator|.
name|getObjectSize
argument_list|()
decl_stmt|;
comment|// for a case like float f = vec4(2, 3, 4, 5) + 1.2;
if|if
condition|(
name|rightNode
operator|->
name|getType
argument_list|()
operator|.
name|getObjectSize
argument_list|()
operator|==
literal|1
operator|&&
name|objectSize
operator|>
literal|1
condition|)
block|{
name|rightArray
operator|=
name|Vectorize
argument_list|(
operator|*
name|rightNode
operator|->
name|getUnionArrayPointer
argument_list|()
argument_list|,
name|objectSize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rightNode
operator|->
name|getType
argument_list|()
operator|.
name|getObjectSize
argument_list|()
operator|>
literal|1
operator|&&
name|objectSize
operator|==
literal|1
condition|)
block|{
comment|// for a case like float f = 1.2 + vec4(2, 3, 4, 5);
name|leftArray
operator|=
name|Vectorize
argument_list|(
operator|*
name|getUnionArrayPointer
argument_list|()
argument_list|,
name|rightNode
operator|->
name|getType
argument_list|()
operator|.
name|getObjectSize
argument_list|()
argument_list|)
expr_stmt|;
name|objectSize
operator|=
name|rightNode
operator|->
name|getType
argument_list|()
operator|.
name|getObjectSize
argument_list|()
expr_stmt|;
block|}
name|TConstantUnion
modifier|*
name|resultArray
init|=
literal|nullptr
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|EOpAdd
case|:
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|objectSize
index|]
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|objectSize
condition|;
name|i
operator|++
control|)
name|resultArray
index|[
name|i
index|]
operator|=
name|leftArray
index|[
name|i
index|]
operator|+
name|rightArray
index|[
name|i
index|]
expr_stmt|;
break|break;
case|case
name|EOpSub
case|:
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|objectSize
index|]
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|objectSize
condition|;
name|i
operator|++
control|)
name|resultArray
index|[
name|i
index|]
operator|=
name|leftArray
index|[
name|i
index|]
operator|-
name|rightArray
index|[
name|i
index|]
expr_stmt|;
break|break;
case|case
name|EOpMul
case|:
case|case
name|EOpVectorTimesScalar
case|:
case|case
name|EOpMatrixTimesScalar
case|:
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|objectSize
index|]
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|objectSize
condition|;
name|i
operator|++
control|)
name|resultArray
index|[
name|i
index|]
operator|=
name|leftArray
index|[
name|i
index|]
operator|*
name|rightArray
index|[
name|i
index|]
expr_stmt|;
break|break;
case|case
name|EOpMatrixTimesMatrix
case|:
block|{
if|if
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|!=
name|EbtFloat
operator|||
name|rightNode
operator|->
name|getBasicType
argument_list|()
operator|!=
name|EbtFloat
condition|)
block|{
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Constant Folding cannot be done for matrix multiply"
argument_list|)
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
specifier|const
name|int
name|leftCols
init|=
name|getCols
argument_list|()
decl_stmt|;
specifier|const
name|int
name|leftRows
init|=
name|getRows
argument_list|()
decl_stmt|;
specifier|const
name|int
name|rightCols
init|=
name|rightNode
operator|->
name|getType
argument_list|()
operator|.
name|getCols
argument_list|()
decl_stmt|;
specifier|const
name|int
name|rightRows
init|=
name|rightNode
operator|->
name|getType
argument_list|()
operator|.
name|getRows
argument_list|()
decl_stmt|;
specifier|const
name|int
name|resultCols
init|=
name|rightCols
decl_stmt|;
specifier|const
name|int
name|resultRows
init|=
name|leftRows
decl_stmt|;
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|resultCols
operator|*
name|resultRows
index|]
expr_stmt|;
for|for
control|(
name|int
name|row
init|=
literal|0
init|;
name|row
operator|<
name|resultRows
condition|;
name|row
operator|++
control|)
block|{
for|for
control|(
name|int
name|column
init|=
literal|0
init|;
name|column
operator|<
name|resultCols
condition|;
name|column
operator|++
control|)
block|{
name|resultArray
index|[
name|resultRows
operator|*
name|column
operator|+
name|row
index|]
operator|.
name|setFConst
argument_list|(
literal|0.0f
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leftCols
condition|;
name|i
operator|++
control|)
block|{
name|resultArray
index|[
name|resultRows
operator|*
name|column
operator|+
name|row
index|]
operator|.
name|setFConst
argument_list|(
name|resultArray
index|[
name|resultRows
operator|*
name|column
operator|+
name|row
index|]
operator|.
name|getFConst
argument_list|()
operator|+
name|leftArray
index|[
name|i
operator|*
name|leftRows
operator|+
name|row
index|]
operator|.
name|getFConst
argument_list|()
operator|*
name|rightArray
index|[
name|column
operator|*
name|rightRows
operator|+
name|i
index|]
operator|.
name|getFConst
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
break|break;
case|case
name|EOpDiv
case|:
case|case
name|EOpIMod
case|:
block|{
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|objectSize
index|]
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|objectSize
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
condition|)
block|{
case|case
name|EbtFloat
case|:
if|if
condition|(
name|rightArray
index|[
name|i
index|]
operator|==
literal|0.0f
condition|)
block|{
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixWarning
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Divide by zero error during constant folding"
argument_list|)
expr_stmt|;
name|resultArray
index|[
name|i
index|]
operator|.
name|setFConst
argument_list|(
name|leftArray
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
operator|<
literal|0
condition|?
operator|-
name|FLT_MAX
else|:
name|FLT_MAX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|op
operator|==
name|EOpDiv
argument_list|)
expr_stmt|;
name|resultArray
index|[
name|i
index|]
operator|.
name|setFConst
argument_list|(
name|leftArray
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
operator|/
name|rightArray
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EbtInt
case|:
if|if
condition|(
name|rightArray
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixWarning
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Divide by zero error during constant folding"
argument_list|)
expr_stmt|;
name|resultArray
index|[
name|i
index|]
operator|.
name|setIConst
argument_list|(
name|INT_MAX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|op
operator|==
name|EOpDiv
condition|)
block|{
name|resultArray
index|[
name|i
index|]
operator|.
name|setIConst
argument_list|(
name|leftArray
index|[
name|i
index|]
operator|.
name|getIConst
argument_list|()
operator|/
name|rightArray
index|[
name|i
index|]
operator|.
name|getIConst
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|op
operator|==
name|EOpIMod
argument_list|)
expr_stmt|;
name|resultArray
index|[
name|i
index|]
operator|.
name|setIConst
argument_list|(
name|leftArray
index|[
name|i
index|]
operator|.
name|getIConst
argument_list|()
operator|%
name|rightArray
index|[
name|i
index|]
operator|.
name|getIConst
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|EbtUInt
case|:
if|if
condition|(
name|rightArray
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixWarning
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Divide by zero error during constant folding"
argument_list|)
expr_stmt|;
name|resultArray
index|[
name|i
index|]
operator|.
name|setUConst
argument_list|(
name|UINT_MAX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|op
operator|==
name|EOpDiv
condition|)
block|{
name|resultArray
index|[
name|i
index|]
operator|.
name|setUConst
argument_list|(
name|leftArray
index|[
name|i
index|]
operator|.
name|getUConst
argument_list|()
operator|/
name|rightArray
index|[
name|i
index|]
operator|.
name|getUConst
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|op
operator|==
name|EOpIMod
argument_list|)
expr_stmt|;
name|resultArray
index|[
name|i
index|]
operator|.
name|setUConst
argument_list|(
name|leftArray
index|[
name|i
index|]
operator|.
name|getUConst
argument_list|()
operator|%
name|rightArray
index|[
name|i
index|]
operator|.
name|getUConst
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Constant folding cannot be done for \"/\""
argument_list|)
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
block|}
block|}
break|break;
case|case
name|EOpMatrixTimesVector
case|:
block|{
if|if
condition|(
name|rightNode
operator|->
name|getBasicType
argument_list|()
operator|!=
name|EbtFloat
condition|)
block|{
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Constant Folding cannot be done for matrix times vector"
argument_list|)
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
specifier|const
name|int
name|matrixCols
init|=
name|getCols
argument_list|()
decl_stmt|;
specifier|const
name|int
name|matrixRows
init|=
name|getRows
argument_list|()
decl_stmt|;
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|matrixRows
index|]
expr_stmt|;
for|for
control|(
name|int
name|matrixRow
init|=
literal|0
init|;
name|matrixRow
operator|<
name|matrixRows
condition|;
name|matrixRow
operator|++
control|)
block|{
name|resultArray
index|[
name|matrixRow
index|]
operator|.
name|setFConst
argument_list|(
literal|0.0f
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|col
init|=
literal|0
init|;
name|col
operator|<
name|matrixCols
condition|;
name|col
operator|++
control|)
block|{
name|resultArray
index|[
name|matrixRow
index|]
operator|.
name|setFConst
argument_list|(
name|resultArray
index|[
name|matrixRow
index|]
operator|.
name|getFConst
argument_list|()
operator|+
name|leftArray
index|[
name|col
operator|*
name|matrixRows
operator|+
name|matrixRow
index|]
operator|.
name|getFConst
argument_list|()
operator|*
name|rightArray
index|[
name|col
index|]
operator|.
name|getFConst
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|EOpVectorTimesMatrix
case|:
block|{
if|if
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|!=
name|EbtFloat
condition|)
block|{
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Constant Folding cannot be done for vector times matrix"
argument_list|)
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
specifier|const
name|int
name|matrixCols
init|=
name|rightNode
operator|->
name|getType
argument_list|()
operator|.
name|getCols
argument_list|()
decl_stmt|;
specifier|const
name|int
name|matrixRows
init|=
name|rightNode
operator|->
name|getType
argument_list|()
operator|.
name|getRows
argument_list|()
decl_stmt|;
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|matrixCols
index|]
expr_stmt|;
for|for
control|(
name|int
name|matrixCol
init|=
literal|0
init|;
name|matrixCol
operator|<
name|matrixCols
condition|;
name|matrixCol
operator|++
control|)
block|{
name|resultArray
index|[
name|matrixCol
index|]
operator|.
name|setFConst
argument_list|(
literal|0.0f
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|matrixRow
init|=
literal|0
init|;
name|matrixRow
operator|<
name|matrixRows
condition|;
name|matrixRow
operator|++
control|)
block|{
name|resultArray
index|[
name|matrixCol
index|]
operator|.
name|setFConst
argument_list|(
name|resultArray
index|[
name|matrixCol
index|]
operator|.
name|getFConst
argument_list|()
operator|+
name|leftArray
index|[
name|matrixRow
index|]
operator|.
name|getFConst
argument_list|()
operator|*
name|rightArray
index|[
name|matrixCol
operator|*
name|matrixRows
operator|+
name|matrixRow
index|]
operator|.
name|getFConst
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|EOpLogicalAnd
case|:
block|{
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|objectSize
index|]
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|objectSize
condition|;
name|i
operator|++
control|)
block|{
name|resultArray
index|[
name|i
index|]
operator|=
name|leftArray
index|[
name|i
index|]
operator|&&
name|rightArray
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
break|break;
case|case
name|EOpLogicalOr
case|:
block|{
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|objectSize
index|]
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|objectSize
condition|;
name|i
operator|++
control|)
block|{
name|resultArray
index|[
name|i
index|]
operator|=
name|leftArray
index|[
name|i
index|]
operator|||
name|rightArray
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
break|break;
case|case
name|EOpLogicalXor
case|:
block|{
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|objectSize
index|]
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|objectSize
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
condition|)
block|{
case|case
name|EbtBool
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setBConst
argument_list|(
name|leftArray
index|[
name|i
index|]
operator|!=
name|rightArray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
case|case
name|EOpBitwiseAnd
case|:
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|objectSize
index|]
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|objectSize
condition|;
name|i
operator|++
control|)
name|resultArray
index|[
name|i
index|]
operator|=
name|leftArray
index|[
name|i
index|]
operator|&
name|rightArray
index|[
name|i
index|]
expr_stmt|;
break|break;
case|case
name|EOpBitwiseXor
case|:
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|objectSize
index|]
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|objectSize
condition|;
name|i
operator|++
control|)
name|resultArray
index|[
name|i
index|]
operator|=
name|leftArray
index|[
name|i
index|]
operator|^
name|rightArray
index|[
name|i
index|]
expr_stmt|;
break|break;
case|case
name|EOpBitwiseOr
case|:
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|objectSize
index|]
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|objectSize
condition|;
name|i
operator|++
control|)
name|resultArray
index|[
name|i
index|]
operator|=
name|leftArray
index|[
name|i
index|]
operator||
name|rightArray
index|[
name|i
index|]
expr_stmt|;
break|break;
case|case
name|EOpBitShiftLeft
case|:
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|objectSize
index|]
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|objectSize
condition|;
name|i
operator|++
control|)
name|resultArray
index|[
name|i
index|]
operator|=
name|leftArray
index|[
name|i
index|]
operator|<<
name|rightArray
index|[
name|i
index|]
expr_stmt|;
break|break;
case|case
name|EOpBitShiftRight
case|:
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|objectSize
index|]
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|objectSize
condition|;
name|i
operator|++
control|)
name|resultArray
index|[
name|i
index|]
operator|=
name|leftArray
index|[
name|i
index|]
operator|>>
name|rightArray
index|[
name|i
index|]
expr_stmt|;
break|break;
case|case
name|EOpLessThan
case|:
name|ASSERT
argument_list|(
name|objectSize
operator|==
literal|1
argument_list|)
expr_stmt|;
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
literal|1
index|]
expr_stmt|;
name|resultArray
operator|->
name|setBConst
argument_list|(
operator|*
name|leftArray
operator|<
operator|*
name|rightArray
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpGreaterThan
case|:
name|ASSERT
argument_list|(
name|objectSize
operator|==
literal|1
argument_list|)
expr_stmt|;
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
literal|1
index|]
expr_stmt|;
name|resultArray
operator|->
name|setBConst
argument_list|(
operator|*
name|leftArray
operator|>
operator|*
name|rightArray
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpLessThanEqual
case|:
name|ASSERT
argument_list|(
name|objectSize
operator|==
literal|1
argument_list|)
expr_stmt|;
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
literal|1
index|]
expr_stmt|;
name|resultArray
operator|->
name|setBConst
argument_list|(
operator|!
operator|(
operator|*
name|leftArray
operator|>
operator|*
name|rightArray
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpGreaterThanEqual
case|:
name|ASSERT
argument_list|(
name|objectSize
operator|==
literal|1
argument_list|)
expr_stmt|;
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
literal|1
index|]
expr_stmt|;
name|resultArray
operator|->
name|setBConst
argument_list|(
operator|!
operator|(
operator|*
name|leftArray
operator|<
operator|*
name|rightArray
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpEqual
case|:
case|case
name|EOpNotEqual
case|:
block|{
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
literal|1
index|]
expr_stmt|;
name|bool
name|equal
init|=
literal|true
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|objectSize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|leftArray
index|[
name|i
index|]
operator|!=
name|rightArray
index|[
name|i
index|]
condition|)
block|{
name|equal
operator|=
literal|false
expr_stmt|;
break|break;
comment|// break out of for loop
block|}
block|}
if|if
condition|(
name|op
operator|==
name|EOpEqual
condition|)
block|{
name|resultArray
operator|->
name|setBConst
argument_list|(
name|equal
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|resultArray
operator|->
name|setBConst
argument_list|(
operator|!
name|equal
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Invalid operator for constant folding"
argument_list|)
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
return|return
name|resultArray
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// The fold functions see if an operation on a constant can be done in place,
end_comment
begin_comment
comment|// without generating run-time code.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns the constant value to keep using or nullptr.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|foldUnaryWithDifferentReturnType
name|TConstantUnion
modifier|*
name|TIntermConstantUnion
operator|::
name|foldUnaryWithDifferentReturnType
parameter_list|(
name|TOperator
name|op
parameter_list|,
name|TInfoSink
modifier|&
name|infoSink
parameter_list|)
block|{
comment|//
comment|// Do operations where the return type has a different number of components compared to the operand type.
comment|//
specifier|const
name|TConstantUnion
modifier|*
name|operandArray
init|=
name|getUnionArrayPointer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|operandArray
condition|)
return|return
literal|nullptr
return|;
name|size_t
name|objectSize
init|=
name|getType
argument_list|()
operator|.
name|getObjectSize
argument_list|()
decl_stmt|;
name|TConstantUnion
modifier|*
name|resultArray
init|=
literal|nullptr
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|EOpAny
case|:
if|if
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtBool
condition|)
block|{
name|resultArray
operator|=
operator|new
name|TConstantUnion
argument_list|()
expr_stmt|;
name|resultArray
operator|->
name|setBConst
argument_list|(
literal|false
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|objectSize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|operandArray
index|[
name|i
index|]
operator|.
name|getBConst
argument_list|()
condition|)
block|{
name|resultArray
operator|->
name|setBConst
argument_list|(
literal|true
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
block|}
else|else
block|{
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Unary operation not folded into constant"
argument_list|)
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
case|case
name|EOpAll
case|:
if|if
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtBool
condition|)
block|{
name|resultArray
operator|=
operator|new
name|TConstantUnion
argument_list|()
expr_stmt|;
name|resultArray
operator|->
name|setBConst
argument_list|(
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|objectSize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|operandArray
index|[
name|i
index|]
operator|.
name|getBConst
argument_list|()
condition|)
block|{
name|resultArray
operator|->
name|setBConst
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
block|}
else|else
block|{
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Unary operation not folded into constant"
argument_list|)
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
case|case
name|EOpLength
case|:
if|if
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtFloat
condition|)
block|{
name|resultArray
operator|=
operator|new
name|TConstantUnion
argument_list|()
expr_stmt|;
name|resultArray
operator|->
name|setFConst
argument_list|(
name|VectorLength
argument_list|(
name|operandArray
argument_list|,
name|objectSize
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Unary operation not folded into constant"
argument_list|)
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
case|case
name|EOpTranspose
case|:
if|if
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtFloat
condition|)
block|{
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|objectSize
index|]
expr_stmt|;
name|angle
operator|::
name|Matrix
argument_list|<
name|float
argument_list|>
name|result
init|=
name|GetMatrix
argument_list|(
name|operandArray
argument_list|,
name|getType
argument_list|()
operator|.
name|getNominalSize
argument_list|()
argument_list|,
name|getType
argument_list|()
operator|.
name|getSecondarySize
argument_list|()
argument_list|)
operator|.
name|transpose
argument_list|()
decl_stmt|;
name|SetUnionArrayFromMatrix
argument_list|(
name|result
argument_list|,
name|resultArray
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Unary operation not folded into constant"
argument_list|)
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
case|case
name|EOpDeterminant
case|:
if|if
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtFloat
condition|)
block|{
name|unsigned
name|int
name|size
init|=
name|getType
argument_list|()
operator|.
name|getNominalSize
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|size
operator|>=
literal|2
operator|&&
name|size
operator|<=
literal|4
argument_list|)
expr_stmt|;
name|resultArray
operator|=
operator|new
name|TConstantUnion
argument_list|()
expr_stmt|;
name|resultArray
operator|->
name|setFConst
argument_list|(
name|GetMatrix
argument_list|(
name|operandArray
argument_list|,
name|size
argument_list|)
operator|.
name|determinant
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Unary operation not folded into constant"
argument_list|)
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
case|case
name|EOpInverse
case|:
if|if
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtFloat
condition|)
block|{
name|unsigned
name|int
name|size
init|=
name|getType
argument_list|()
operator|.
name|getNominalSize
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|size
operator|>=
literal|2
operator|&&
name|size
operator|<=
literal|4
argument_list|)
expr_stmt|;
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|objectSize
index|]
expr_stmt|;
name|angle
operator|::
name|Matrix
argument_list|<
name|float
argument_list|>
name|result
init|=
name|GetMatrix
argument_list|(
name|operandArray
argument_list|,
name|size
argument_list|)
operator|.
name|inverse
argument_list|()
decl_stmt|;
name|SetUnionArrayFromMatrix
argument_list|(
name|result
argument_list|,
name|resultArray
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Unary operation not folded into constant"
argument_list|)
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
case|case
name|EOpPackSnorm2x16
case|:
if|if
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtFloat
condition|)
block|{
name|ASSERT
argument_list|(
name|getType
argument_list|()
operator|.
name|getNominalSize
argument_list|()
operator|==
literal|2
argument_list|)
expr_stmt|;
name|resultArray
operator|=
operator|new
name|TConstantUnion
argument_list|()
expr_stmt|;
name|resultArray
operator|->
name|setUConst
argument_list|(
name|gl
operator|::
name|packSnorm2x16
argument_list|(
name|operandArray
index|[
literal|0
index|]
operator|.
name|getFConst
argument_list|()
argument_list|,
name|operandArray
index|[
literal|1
index|]
operator|.
name|getFConst
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Unary operation not folded into constant"
argument_list|)
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
case|case
name|EOpUnpackSnorm2x16
case|:
if|if
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtUInt
condition|)
block|{
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
literal|2
index|]
expr_stmt|;
name|float
name|f1
decl_stmt|,
name|f2
decl_stmt|;
name|gl
operator|::
name|unpackSnorm2x16
argument_list|(
name|operandArray
index|[
literal|0
index|]
operator|.
name|getUConst
argument_list|()
argument_list|,
operator|&
name|f1
argument_list|,
operator|&
name|f2
argument_list|)
expr_stmt|;
name|resultArray
index|[
literal|0
index|]
operator|.
name|setFConst
argument_list|(
name|f1
argument_list|)
expr_stmt|;
name|resultArray
index|[
literal|1
index|]
operator|.
name|setFConst
argument_list|(
name|f2
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Unary operation not folded into constant"
argument_list|)
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
case|case
name|EOpPackUnorm2x16
case|:
if|if
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtFloat
condition|)
block|{
name|ASSERT
argument_list|(
name|getType
argument_list|()
operator|.
name|getNominalSize
argument_list|()
operator|==
literal|2
argument_list|)
expr_stmt|;
name|resultArray
operator|=
operator|new
name|TConstantUnion
argument_list|()
expr_stmt|;
name|resultArray
operator|->
name|setUConst
argument_list|(
name|gl
operator|::
name|packUnorm2x16
argument_list|(
name|operandArray
index|[
literal|0
index|]
operator|.
name|getFConst
argument_list|()
argument_list|,
name|operandArray
index|[
literal|1
index|]
operator|.
name|getFConst
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Unary operation not folded into constant"
argument_list|)
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
case|case
name|EOpUnpackUnorm2x16
case|:
if|if
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtUInt
condition|)
block|{
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
literal|2
index|]
expr_stmt|;
name|float
name|f1
decl_stmt|,
name|f2
decl_stmt|;
name|gl
operator|::
name|unpackUnorm2x16
argument_list|(
name|operandArray
index|[
literal|0
index|]
operator|.
name|getUConst
argument_list|()
argument_list|,
operator|&
name|f1
argument_list|,
operator|&
name|f2
argument_list|)
expr_stmt|;
name|resultArray
index|[
literal|0
index|]
operator|.
name|setFConst
argument_list|(
name|f1
argument_list|)
expr_stmt|;
name|resultArray
index|[
literal|1
index|]
operator|.
name|setFConst
argument_list|(
name|f2
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Unary operation not folded into constant"
argument_list|)
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
case|case
name|EOpPackHalf2x16
case|:
if|if
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtFloat
condition|)
block|{
name|ASSERT
argument_list|(
name|getType
argument_list|()
operator|.
name|getNominalSize
argument_list|()
operator|==
literal|2
argument_list|)
expr_stmt|;
name|resultArray
operator|=
operator|new
name|TConstantUnion
argument_list|()
expr_stmt|;
name|resultArray
operator|->
name|setUConst
argument_list|(
name|gl
operator|::
name|packHalf2x16
argument_list|(
name|operandArray
index|[
literal|0
index|]
operator|.
name|getFConst
argument_list|()
argument_list|,
name|operandArray
index|[
literal|1
index|]
operator|.
name|getFConst
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Unary operation not folded into constant"
argument_list|)
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
case|case
name|EOpUnpackHalf2x16
case|:
if|if
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtUInt
condition|)
block|{
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
literal|2
index|]
expr_stmt|;
name|float
name|f1
decl_stmt|,
name|f2
decl_stmt|;
name|gl
operator|::
name|unpackHalf2x16
argument_list|(
name|operandArray
index|[
literal|0
index|]
operator|.
name|getUConst
argument_list|()
argument_list|,
operator|&
name|f1
argument_list|,
operator|&
name|f2
argument_list|)
expr_stmt|;
name|resultArray
index|[
literal|0
index|]
operator|.
name|setFConst
argument_list|(
name|f1
argument_list|)
expr_stmt|;
name|resultArray
index|[
literal|1
index|]
operator|.
name|setFConst
argument_list|(
name|f2
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Unary operation not folded into constant"
argument_list|)
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|resultArray
return|;
block|}
end_function
begin_function
DECL|function|foldUnaryWithSameReturnType
name|TConstantUnion
modifier|*
name|TIntermConstantUnion
operator|::
name|foldUnaryWithSameReturnType
parameter_list|(
name|TOperator
name|op
parameter_list|,
name|TInfoSink
modifier|&
name|infoSink
parameter_list|)
block|{
comment|//
comment|// Do unary operations where the return type is the same as operand type.
comment|//
specifier|const
name|TConstantUnion
modifier|*
name|operandArray
init|=
name|getUnionArrayPointer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|operandArray
condition|)
return|return
literal|nullptr
return|;
name|size_t
name|objectSize
init|=
name|getType
argument_list|()
operator|.
name|getObjectSize
argument_list|()
decl_stmt|;
name|TConstantUnion
modifier|*
name|resultArray
init|=
operator|new
name|TConstantUnion
index|[
name|objectSize
index|]
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|objectSize
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|EOpNegative
case|:
switch|switch
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
condition|)
block|{
case|case
name|EbtFloat
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setFConst
argument_list|(
operator|-
name|operandArray
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EbtInt
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setIConst
argument_list|(
operator|-
name|operandArray
index|[
name|i
index|]
operator|.
name|getIConst
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EbtUInt
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setUConst
argument_list|(
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
operator|-
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|operandArray
index|[
name|i
index|]
operator|.
name|getUConst
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Unary operation not folded into constant"
argument_list|)
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
break|break;
case|case
name|EOpPositive
case|:
switch|switch
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
condition|)
block|{
case|case
name|EbtFloat
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setFConst
argument_list|(
name|operandArray
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EbtInt
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setIConst
argument_list|(
name|operandArray
index|[
name|i
index|]
operator|.
name|getIConst
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EbtUInt
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setUConst
argument_list|(
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|operandArray
index|[
name|i
index|]
operator|.
name|getUConst
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Unary operation not folded into constant"
argument_list|)
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
break|break;
case|case
name|EOpLogicalNot
case|:
comment|// this code is written for possible future use,
comment|// will not get executed currently
switch|switch
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
condition|)
block|{
case|case
name|EbtBool
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setBConst
argument_list|(
operator|!
name|operandArray
index|[
name|i
index|]
operator|.
name|getBConst
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Unary operation not folded into constant"
argument_list|)
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
break|break;
case|case
name|EOpBitwiseNot
case|:
switch|switch
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
condition|)
block|{
case|case
name|EbtInt
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setIConst
argument_list|(
operator|~
name|operandArray
index|[
name|i
index|]
operator|.
name|getIConst
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EbtUInt
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setUConst
argument_list|(
operator|~
name|operandArray
index|[
name|i
index|]
operator|.
name|getUConst
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Unary operation not folded into constant"
argument_list|)
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
break|break;
case|case
name|EOpRadians
case|:
if|if
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtFloat
condition|)
block|{
name|resultArray
index|[
name|i
index|]
operator|.
name|setFConst
argument_list|(
name|kDegreesToRadiansMultiplier
operator|*
name|operandArray
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Unary operation not folded into constant"
argument_list|)
expr_stmt|;
return|return
literal|nullptr
return|;
case|case
name|EOpDegrees
case|:
if|if
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtFloat
condition|)
block|{
name|resultArray
index|[
name|i
index|]
operator|.
name|setFConst
argument_list|(
name|kRadiansToDegreesMultiplier
operator|*
name|operandArray
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Unary operation not folded into constant"
argument_list|)
expr_stmt|;
return|return
literal|nullptr
return|;
case|case
name|EOpSin
case|:
if|if
condition|(
operator|!
name|foldFloatTypeUnary
argument_list|(
name|operandArray
index|[
name|i
index|]
argument_list|,
operator|&
name|sinf
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|nullptr
return|;
break|break;
case|case
name|EOpCos
case|:
if|if
condition|(
operator|!
name|foldFloatTypeUnary
argument_list|(
name|operandArray
index|[
name|i
index|]
argument_list|,
operator|&
name|cosf
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|nullptr
return|;
break|break;
case|case
name|EOpTan
case|:
if|if
condition|(
operator|!
name|foldFloatTypeUnary
argument_list|(
name|operandArray
index|[
name|i
index|]
argument_list|,
operator|&
name|tanf
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|nullptr
return|;
break|break;
case|case
name|EOpAsin
case|:
comment|// For asin(x), results are undefined if |x|> 1, we are choosing to set result to 0.
if|if
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtFloat
operator|&&
name|fabsf
argument_list|(
name|operandArray
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
argument_list|)
operator|>
literal|1.0f
condition|)
name|UndefinedConstantFoldingError
argument_list|(
name|getLine
argument_list|()
argument_list|,
name|op
argument_list|,
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|foldFloatTypeUnary
argument_list|(
name|operandArray
index|[
name|i
index|]
argument_list|,
operator|&
name|asinf
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|nullptr
return|;
break|break;
case|case
name|EOpAcos
case|:
comment|// For acos(x), results are undefined if |x|> 1, we are choosing to set result to 0.
if|if
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtFloat
operator|&&
name|fabsf
argument_list|(
name|operandArray
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
argument_list|)
operator|>
literal|1.0f
condition|)
name|UndefinedConstantFoldingError
argument_list|(
name|getLine
argument_list|()
argument_list|,
name|op
argument_list|,
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|foldFloatTypeUnary
argument_list|(
name|operandArray
index|[
name|i
index|]
argument_list|,
operator|&
name|acosf
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|nullptr
return|;
break|break;
case|case
name|EOpAtan
case|:
if|if
condition|(
operator|!
name|foldFloatTypeUnary
argument_list|(
name|operandArray
index|[
name|i
index|]
argument_list|,
operator|&
name|atanf
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|nullptr
return|;
break|break;
case|case
name|EOpSinh
case|:
if|if
condition|(
operator|!
name|foldFloatTypeUnary
argument_list|(
name|operandArray
index|[
name|i
index|]
argument_list|,
operator|&
name|sinhf
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|nullptr
return|;
break|break;
case|case
name|EOpCosh
case|:
if|if
condition|(
operator|!
name|foldFloatTypeUnary
argument_list|(
name|operandArray
index|[
name|i
index|]
argument_list|,
operator|&
name|coshf
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|nullptr
return|;
break|break;
case|case
name|EOpTanh
case|:
if|if
condition|(
operator|!
name|foldFloatTypeUnary
argument_list|(
name|operandArray
index|[
name|i
index|]
argument_list|,
operator|&
name|tanhf
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|nullptr
return|;
break|break;
case|case
name|EOpAsinh
case|:
if|if
condition|(
operator|!
name|foldFloatTypeUnary
argument_list|(
name|operandArray
index|[
name|i
index|]
argument_list|,
operator|&
name|asinhf
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|nullptr
return|;
break|break;
case|case
name|EOpAcosh
case|:
comment|// For acosh(x), results are undefined if x< 1, we are choosing to set result to 0.
if|if
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtFloat
operator|&&
name|operandArray
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
operator|<
literal|1.0f
condition|)
name|UndefinedConstantFoldingError
argument_list|(
name|getLine
argument_list|()
argument_list|,
name|op
argument_list|,
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|foldFloatTypeUnary
argument_list|(
name|operandArray
index|[
name|i
index|]
argument_list|,
operator|&
name|acoshf
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|nullptr
return|;
break|break;
case|case
name|EOpAtanh
case|:
comment|// For atanh(x), results are undefined if |x|>= 1, we are choosing to set result to 0.
if|if
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtFloat
operator|&&
name|fabsf
argument_list|(
name|operandArray
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
argument_list|)
operator|>=
literal|1.0f
condition|)
name|UndefinedConstantFoldingError
argument_list|(
name|getLine
argument_list|()
argument_list|,
name|op
argument_list|,
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|foldFloatTypeUnary
argument_list|(
name|operandArray
index|[
name|i
index|]
argument_list|,
operator|&
name|atanhf
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|nullptr
return|;
break|break;
case|case
name|EOpAbs
case|:
switch|switch
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
condition|)
block|{
case|case
name|EbtFloat
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setFConst
argument_list|(
name|fabsf
argument_list|(
name|operandArray
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EbtInt
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setIConst
argument_list|(
name|abs
argument_list|(
name|operandArray
index|[
name|i
index|]
operator|.
name|getIConst
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Unary operation not folded into constant"
argument_list|)
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
break|break;
case|case
name|EOpSign
case|:
switch|switch
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
condition|)
block|{
case|case
name|EbtFloat
case|:
block|{
name|float
name|fConst
init|=
name|operandArray
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
decl_stmt|;
name|float
name|fResult
init|=
literal|0.0f
decl_stmt|;
if|if
condition|(
name|fConst
operator|>
literal|0.0f
condition|)
name|fResult
operator|=
literal|1.0f
expr_stmt|;
elseif|else
if|if
condition|(
name|fConst
operator|<
literal|0.0f
condition|)
name|fResult
operator|=
operator|-
literal|1.0f
expr_stmt|;
name|resultArray
index|[
name|i
index|]
operator|.
name|setFConst
argument_list|(
name|fResult
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EbtInt
case|:
block|{
name|int
name|iConst
init|=
name|operandArray
index|[
name|i
index|]
operator|.
name|getIConst
argument_list|()
decl_stmt|;
name|int
name|iResult
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|iConst
operator|>
literal|0
condition|)
name|iResult
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|iConst
operator|<
literal|0
condition|)
name|iResult
operator|=
operator|-
literal|1
expr_stmt|;
name|resultArray
index|[
name|i
index|]
operator|.
name|setIConst
argument_list|(
name|iResult
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Unary operation not folded into constant"
argument_list|)
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
break|break;
case|case
name|EOpFloor
case|:
if|if
condition|(
operator|!
name|foldFloatTypeUnary
argument_list|(
name|operandArray
index|[
name|i
index|]
argument_list|,
operator|&
name|floorf
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|nullptr
return|;
break|break;
case|case
name|EOpTrunc
case|:
if|if
condition|(
operator|!
name|foldFloatTypeUnary
argument_list|(
name|operandArray
index|[
name|i
index|]
argument_list|,
operator|&
name|truncf
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|nullptr
return|;
break|break;
case|case
name|EOpRound
case|:
if|if
condition|(
operator|!
name|foldFloatTypeUnary
argument_list|(
name|operandArray
index|[
name|i
index|]
argument_list|,
operator|&
name|roundf
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|nullptr
return|;
break|break;
case|case
name|EOpRoundEven
case|:
if|if
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtFloat
condition|)
block|{
name|float
name|x
init|=
name|operandArray
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
decl_stmt|;
name|float
name|result
decl_stmt|;
name|float
name|fractPart
init|=
name|modff
argument_list|(
name|x
argument_list|,
operator|&
name|result
argument_list|)
decl_stmt|;
if|if
condition|(
name|fabsf
argument_list|(
name|fractPart
argument_list|)
operator|==
literal|0.5f
condition|)
name|result
operator|=
literal|2.0f
operator|*
name|roundf
argument_list|(
name|x
operator|/
literal|2.0f
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|roundf
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|resultArray
index|[
name|i
index|]
operator|.
name|setFConst
argument_list|(
name|result
argument_list|)
expr_stmt|;
break|break;
block|}
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Unary operation not folded into constant"
argument_list|)
expr_stmt|;
return|return
literal|nullptr
return|;
case|case
name|EOpCeil
case|:
if|if
condition|(
operator|!
name|foldFloatTypeUnary
argument_list|(
name|operandArray
index|[
name|i
index|]
argument_list|,
operator|&
name|ceilf
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|nullptr
return|;
break|break;
case|case
name|EOpFract
case|:
if|if
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtFloat
condition|)
block|{
name|float
name|x
init|=
name|operandArray
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
decl_stmt|;
name|resultArray
index|[
name|i
index|]
operator|.
name|setFConst
argument_list|(
name|x
operator|-
name|floorf
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Unary operation not folded into constant"
argument_list|)
expr_stmt|;
return|return
literal|nullptr
return|;
case|case
name|EOpIsNan
case|:
if|if
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtFloat
condition|)
block|{
name|resultArray
index|[
name|i
index|]
operator|.
name|setBConst
argument_list|(
name|gl
operator|::
name|isNaN
argument_list|(
name|operandArray
index|[
literal|0
index|]
operator|.
name|getFConst
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Unary operation not folded into constant"
argument_list|)
expr_stmt|;
return|return
literal|nullptr
return|;
case|case
name|EOpIsInf
case|:
if|if
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtFloat
condition|)
block|{
name|resultArray
index|[
name|i
index|]
operator|.
name|setBConst
argument_list|(
name|gl
operator|::
name|isInf
argument_list|(
name|operandArray
index|[
literal|0
index|]
operator|.
name|getFConst
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Unary operation not folded into constant"
argument_list|)
expr_stmt|;
return|return
literal|nullptr
return|;
case|case
name|EOpFloatBitsToInt
case|:
if|if
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtFloat
condition|)
block|{
name|resultArray
index|[
name|i
index|]
operator|.
name|setIConst
argument_list|(
name|gl
operator|::
name|bitCast
argument_list|<
name|int32_t
argument_list|>
argument_list|(
name|operandArray
index|[
literal|0
index|]
operator|.
name|getFConst
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Unary operation not folded into constant"
argument_list|)
expr_stmt|;
return|return
literal|nullptr
return|;
case|case
name|EOpFloatBitsToUint
case|:
if|if
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtFloat
condition|)
block|{
name|resultArray
index|[
name|i
index|]
operator|.
name|setUConst
argument_list|(
name|gl
operator|::
name|bitCast
argument_list|<
name|uint32_t
argument_list|>
argument_list|(
name|operandArray
index|[
literal|0
index|]
operator|.
name|getFConst
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Unary operation not folded into constant"
argument_list|)
expr_stmt|;
return|return
literal|nullptr
return|;
case|case
name|EOpIntBitsToFloat
case|:
if|if
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtInt
condition|)
block|{
name|resultArray
index|[
name|i
index|]
operator|.
name|setFConst
argument_list|(
name|gl
operator|::
name|bitCast
argument_list|<
name|float
argument_list|>
argument_list|(
name|operandArray
index|[
literal|0
index|]
operator|.
name|getIConst
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Unary operation not folded into constant"
argument_list|)
expr_stmt|;
return|return
literal|nullptr
return|;
case|case
name|EOpUintBitsToFloat
case|:
if|if
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtUInt
condition|)
block|{
name|resultArray
index|[
name|i
index|]
operator|.
name|setFConst
argument_list|(
name|gl
operator|::
name|bitCast
argument_list|<
name|float
argument_list|>
argument_list|(
name|operandArray
index|[
literal|0
index|]
operator|.
name|getUConst
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Unary operation not folded into constant"
argument_list|)
expr_stmt|;
return|return
literal|nullptr
return|;
case|case
name|EOpExp
case|:
if|if
condition|(
operator|!
name|foldFloatTypeUnary
argument_list|(
name|operandArray
index|[
name|i
index|]
argument_list|,
operator|&
name|expf
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|nullptr
return|;
break|break;
case|case
name|EOpLog
case|:
comment|// For log(x), results are undefined if x<= 0, we are choosing to set result to 0.
if|if
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtFloat
operator|&&
name|operandArray
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
operator|<=
literal|0.0f
condition|)
name|UndefinedConstantFoldingError
argument_list|(
name|getLine
argument_list|()
argument_list|,
name|op
argument_list|,
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|foldFloatTypeUnary
argument_list|(
name|operandArray
index|[
name|i
index|]
argument_list|,
operator|&
name|logf
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|nullptr
return|;
break|break;
case|case
name|EOpExp2
case|:
if|if
condition|(
operator|!
name|foldFloatTypeUnary
argument_list|(
name|operandArray
index|[
name|i
index|]
argument_list|,
operator|&
name|exp2f
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|nullptr
return|;
break|break;
case|case
name|EOpLog2
case|:
comment|// For log2(x), results are undefined if x<= 0, we are choosing to set result to 0.
comment|// And log2f is not available on some plarforms like old android, so just using log(x)/log(2) here.
if|if
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtFloat
operator|&&
name|operandArray
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
operator|<=
literal|0.0f
condition|)
name|UndefinedConstantFoldingError
argument_list|(
name|getLine
argument_list|()
argument_list|,
name|op
argument_list|,
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|foldFloatTypeUnary
argument_list|(
name|operandArray
index|[
name|i
index|]
argument_list|,
operator|&
name|logf
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|nullptr
return|;
else|else
name|resultArray
index|[
name|i
index|]
operator|.
name|setFConst
argument_list|(
name|resultArray
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
operator|/
name|logf
argument_list|(
literal|2.0f
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpSqrt
case|:
comment|// For sqrt(x), results are undefined if x< 0, we are choosing to set result to 0.
if|if
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtFloat
operator|&&
name|operandArray
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
operator|<
literal|0.0f
condition|)
name|UndefinedConstantFoldingError
argument_list|(
name|getLine
argument_list|()
argument_list|,
name|op
argument_list|,
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|foldFloatTypeUnary
argument_list|(
name|operandArray
index|[
name|i
index|]
argument_list|,
operator|&
name|sqrtf
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|nullptr
return|;
break|break;
case|case
name|EOpInverseSqrt
case|:
comment|// There is no stdlib built-in function equavalent for GLES built-in inversesqrt(),
comment|// so getting the square root first using builtin function sqrt() and then taking its inverse.
comment|// Also, for inversesqrt(x), results are undefined if x<= 0, we are choosing to set result to 0.
if|if
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtFloat
operator|&&
name|operandArray
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
operator|<=
literal|0.0f
condition|)
name|UndefinedConstantFoldingError
argument_list|(
name|getLine
argument_list|()
argument_list|,
name|op
argument_list|,
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|foldFloatTypeUnary
argument_list|(
name|operandArray
index|[
name|i
index|]
argument_list|,
operator|&
name|sqrtf
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|nullptr
return|;
else|else
name|resultArray
index|[
name|i
index|]
operator|.
name|setFConst
argument_list|(
literal|1.0f
operator|/
name|resultArray
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpVectorLogicalNot
case|:
if|if
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtBool
condition|)
block|{
name|resultArray
index|[
name|i
index|]
operator|.
name|setBConst
argument_list|(
operator|!
name|operandArray
index|[
name|i
index|]
operator|.
name|getBConst
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Unary operation not folded into constant"
argument_list|)
expr_stmt|;
return|return
literal|nullptr
return|;
case|case
name|EOpNormalize
case|:
if|if
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtFloat
condition|)
block|{
name|float
name|x
init|=
name|operandArray
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
decl_stmt|;
name|float
name|length
init|=
name|VectorLength
argument_list|(
name|operandArray
argument_list|,
name|objectSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
condition|)
name|resultArray
index|[
name|i
index|]
operator|.
name|setFConst
argument_list|(
name|x
operator|/
name|length
argument_list|)
expr_stmt|;
else|else
name|UndefinedConstantFoldingError
argument_list|(
name|getLine
argument_list|()
argument_list|,
name|op
argument_list|,
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Unary operation not folded into constant"
argument_list|)
expr_stmt|;
return|return
literal|nullptr
return|;
case|case
name|EOpDFdx
case|:
case|case
name|EOpDFdy
case|:
case|case
name|EOpFwidth
case|:
if|if
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtFloat
condition|)
block|{
comment|// Derivatives of constant arguments should be 0.
name|resultArray
index|[
name|i
index|]
operator|.
name|setFConst
argument_list|(
literal|0.0f
argument_list|)
expr_stmt|;
break|break;
block|}
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Unary operation not folded into constant"
argument_list|)
expr_stmt|;
return|return
literal|nullptr
return|;
default|default:
return|return
literal|nullptr
return|;
block|}
block|}
return|return
name|resultArray
return|;
block|}
end_function
begin_function
DECL|function|foldFloatTypeUnary
name|bool
name|TIntermConstantUnion
operator|::
name|foldFloatTypeUnary
parameter_list|(
specifier|const
name|TConstantUnion
modifier|&
name|parameter
parameter_list|,
name|FloatTypeUnaryFunc
name|builtinFunc
parameter_list|,
name|TInfoSink
modifier|&
name|infoSink
parameter_list|,
name|TConstantUnion
modifier|*
name|result
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|builtinFunc
argument_list|)
expr_stmt|;
if|if
condition|(
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtFloat
condition|)
block|{
name|result
operator|->
name|setFConst
argument_list|(
name|builtinFunc
argument_list|(
name|parameter
operator|.
name|getFConst
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|infoSink
operator|.
name|info
operator|.
name|message
argument_list|(
name|EPrefixInternalError
argument_list|,
name|getLine
argument_list|()
argument_list|,
literal|"Unary operation not folded into constant"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|// static
end_comment
begin_function
DECL|function|FoldAggregateConstructor
name|TConstantUnion
modifier|*
name|TIntermConstantUnion
operator|::
name|FoldAggregateConstructor
parameter_list|(
name|TIntermAggregate
modifier|*
name|aggregate
parameter_list|,
name|TInfoSink
modifier|&
name|infoSink
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|aggregate
operator|->
name|getSequence
argument_list|()
operator|->
name|size
argument_list|()
operator|>
literal|0u
argument_list|)
expr_stmt|;
name|size_t
name|resultSize
init|=
name|aggregate
operator|->
name|getType
argument_list|()
operator|.
name|getObjectSize
argument_list|()
decl_stmt|;
name|TConstantUnion
modifier|*
name|resultArray
init|=
operator|new
name|TConstantUnion
index|[
name|resultSize
index|]
decl_stmt|;
name|TBasicType
name|basicType
init|=
name|aggregate
operator|->
name|getBasicType
argument_list|()
decl_stmt|;
name|size_t
name|resultIndex
init|=
literal|0u
decl_stmt|;
if|if
condition|(
name|aggregate
operator|->
name|getSequence
argument_list|()
operator|->
name|size
argument_list|()
operator|==
literal|1u
condition|)
block|{
name|TIntermNode
modifier|*
name|argument
init|=
name|aggregate
operator|->
name|getSequence
argument_list|()
operator|->
name|front
argument_list|()
decl_stmt|;
name|TIntermConstantUnion
modifier|*
name|argumentConstant
init|=
name|argument
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
specifier|const
name|TConstantUnion
modifier|*
name|argumentUnionArray
init|=
name|argumentConstant
operator|->
name|getUnionArrayPointer
argument_list|()
decl_stmt|;
comment|// Check the special case of constructing a matrix diagonal from a single scalar,
comment|// or a vector from a single scalar.
if|if
condition|(
name|argumentConstant
operator|->
name|getType
argument_list|()
operator|.
name|getObjectSize
argument_list|()
operator|==
literal|1u
condition|)
block|{
if|if
condition|(
name|aggregate
operator|->
name|isMatrix
argument_list|()
condition|)
block|{
name|int
name|resultCols
init|=
name|aggregate
operator|->
name|getType
argument_list|()
operator|.
name|getCols
argument_list|()
decl_stmt|;
name|int
name|resultRows
init|=
name|aggregate
operator|->
name|getType
argument_list|()
operator|.
name|getRows
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|col
init|=
literal|0
init|;
name|col
operator|<
name|resultCols
condition|;
operator|++
name|col
control|)
block|{
for|for
control|(
name|int
name|row
init|=
literal|0
init|;
name|row
operator|<
name|resultRows
condition|;
operator|++
name|row
control|)
block|{
if|if
condition|(
name|col
operator|==
name|row
condition|)
block|{
name|resultArray
index|[
name|resultIndex
index|]
operator|.
name|cast
argument_list|(
name|basicType
argument_list|,
name|argumentUnionArray
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|resultArray
index|[
name|resultIndex
index|]
operator|.
name|setFConst
argument_list|(
literal|0.0f
argument_list|)
expr_stmt|;
block|}
operator|++
name|resultIndex
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
while|while
condition|(
name|resultIndex
operator|<
name|resultSize
condition|)
block|{
name|resultArray
index|[
name|resultIndex
index|]
operator|.
name|cast
argument_list|(
name|basicType
argument_list|,
name|argumentUnionArray
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|++
name|resultIndex
expr_stmt|;
block|}
block|}
name|ASSERT
argument_list|(
name|resultIndex
operator|==
name|resultSize
argument_list|)
expr_stmt|;
return|return
name|resultArray
return|;
block|}
elseif|else
if|if
condition|(
name|aggregate
operator|->
name|isMatrix
argument_list|()
operator|&&
name|argumentConstant
operator|->
name|isMatrix
argument_list|()
condition|)
block|{
comment|// The special case of constructing a matrix from a matrix.
name|int
name|argumentCols
init|=
name|argumentConstant
operator|->
name|getType
argument_list|()
operator|.
name|getCols
argument_list|()
decl_stmt|;
name|int
name|argumentRows
init|=
name|argumentConstant
operator|->
name|getType
argument_list|()
operator|.
name|getRows
argument_list|()
decl_stmt|;
name|int
name|resultCols
init|=
name|aggregate
operator|->
name|getType
argument_list|()
operator|.
name|getCols
argument_list|()
decl_stmt|;
name|int
name|resultRows
init|=
name|aggregate
operator|->
name|getType
argument_list|()
operator|.
name|getRows
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|col
init|=
literal|0
init|;
name|col
operator|<
name|resultCols
condition|;
operator|++
name|col
control|)
block|{
for|for
control|(
name|int
name|row
init|=
literal|0
init|;
name|row
operator|<
name|resultRows
condition|;
operator|++
name|row
control|)
block|{
if|if
condition|(
name|col
operator|<
name|argumentCols
operator|&&
name|row
operator|<
name|argumentRows
condition|)
block|{
name|resultArray
index|[
name|resultIndex
index|]
operator|.
name|cast
argument_list|(
name|basicType
argument_list|,
name|argumentUnionArray
index|[
name|col
operator|*
name|argumentRows
operator|+
name|row
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|col
operator|==
name|row
condition|)
block|{
name|resultArray
index|[
name|resultIndex
index|]
operator|.
name|setFConst
argument_list|(
literal|1.0f
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|resultArray
index|[
name|resultIndex
index|]
operator|.
name|setFConst
argument_list|(
literal|0.0f
argument_list|)
expr_stmt|;
block|}
operator|++
name|resultIndex
expr_stmt|;
block|}
block|}
name|ASSERT
argument_list|(
name|resultIndex
operator|==
name|resultSize
argument_list|)
expr_stmt|;
return|return
name|resultArray
return|;
block|}
block|}
for|for
control|(
name|TIntermNode
modifier|*
modifier|&
name|argument
range|:
operator|*
name|aggregate
operator|->
name|getSequence
argument_list|()
control|)
block|{
name|TIntermConstantUnion
modifier|*
name|argumentConstant
init|=
name|argument
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
name|size_t
name|argumentSize
init|=
name|argumentConstant
operator|->
name|getType
argument_list|()
operator|.
name|getObjectSize
argument_list|()
decl_stmt|;
specifier|const
name|TConstantUnion
modifier|*
name|argumentUnionArray
init|=
name|argumentConstant
operator|->
name|getUnionArrayPointer
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0u
init|;
name|i
operator|<
name|argumentSize
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|resultIndex
operator|>=
name|resultSize
condition|)
break|break;
name|resultArray
index|[
name|resultIndex
index|]
operator|.
name|cast
argument_list|(
name|basicType
argument_list|,
name|argumentUnionArray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|++
name|resultIndex
expr_stmt|;
block|}
block|}
name|ASSERT
argument_list|(
name|resultIndex
operator|==
name|resultSize
argument_list|)
expr_stmt|;
return|return
name|resultArray
return|;
block|}
end_function
begin_comment
comment|// static
end_comment
begin_function
DECL|function|FoldAggregateBuiltIn
name|TConstantUnion
modifier|*
name|TIntermConstantUnion
operator|::
name|FoldAggregateBuiltIn
parameter_list|(
name|TIntermAggregate
modifier|*
name|aggregate
parameter_list|,
name|TInfoSink
modifier|&
name|infoSink
parameter_list|)
block|{
name|TOperator
name|op
init|=
name|aggregate
operator|->
name|getOp
argument_list|()
decl_stmt|;
name|TIntermSequence
modifier|*
name|sequence
init|=
name|aggregate
operator|->
name|getSequence
argument_list|()
decl_stmt|;
name|unsigned
name|int
name|paramsCount
init|=
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|sequence
operator|->
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|std
operator|::
name|vector
argument_list|<
specifier|const
name|TConstantUnion
modifier|*
argument_list|>
name|unionArrays
argument_list|(
name|paramsCount
argument_list|)
decl_stmt|;
name|std
operator|::
name|vector
argument_list|<
name|size_t
argument_list|>
name|objectSizes
argument_list|(
name|paramsCount
argument_list|)
decl_stmt|;
name|size_t
name|maxObjectSize
init|=
literal|0
decl_stmt|;
name|TBasicType
name|basicType
init|=
name|EbtVoid
decl_stmt|;
name|TSourceLoc
name|loc
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|paramsCount
condition|;
name|i
operator|++
control|)
block|{
name|TIntermConstantUnion
modifier|*
name|paramConstant
init|=
operator|(
operator|*
name|sequence
operator|)
index|[
name|i
index|]
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|paramConstant
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
comment|// Should be checked already.
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|basicType
operator|=
name|paramConstant
operator|->
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
expr_stmt|;
name|loc
operator|=
name|paramConstant
operator|->
name|getLine
argument_list|()
expr_stmt|;
block|}
name|unionArrays
index|[
name|i
index|]
operator|=
name|paramConstant
operator|->
name|getUnionArrayPointer
argument_list|()
expr_stmt|;
name|objectSizes
index|[
name|i
index|]
operator|=
name|paramConstant
operator|->
name|getType
argument_list|()
operator|.
name|getObjectSize
argument_list|()
expr_stmt|;
if|if
condition|(
name|objectSizes
index|[
name|i
index|]
operator|>
name|maxObjectSize
condition|)
name|maxObjectSize
operator|=
name|objectSizes
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
operator|*
name|sequence
operator|)
index|[
literal|0
index|]
operator|->
name|getAsTyped
argument_list|()
operator|->
name|isMatrix
argument_list|()
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|paramsCount
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|objectSizes
index|[
name|i
index|]
operator|!=
name|maxObjectSize
condition|)
name|unionArrays
index|[
name|i
index|]
operator|=
name|Vectorize
argument_list|(
operator|*
name|unionArrays
index|[
name|i
index|]
argument_list|,
name|maxObjectSize
argument_list|)
expr_stmt|;
block|}
name|TConstantUnion
modifier|*
name|resultArray
init|=
literal|nullptr
decl_stmt|;
if|if
condition|(
name|paramsCount
operator|==
literal|2
condition|)
block|{
comment|//
comment|// Binary built-in
comment|//
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|EOpAtan
case|:
block|{
if|if
condition|(
name|basicType
operator|==
name|EbtFloat
condition|)
block|{
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|maxObjectSize
index|]
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxObjectSize
condition|;
name|i
operator|++
control|)
block|{
name|float
name|y
init|=
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
decl_stmt|;
name|float
name|x
init|=
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
decl_stmt|;
comment|// Results are undefined if x and y are both 0.
if|if
condition|(
name|x
operator|==
literal|0.0f
operator|&&
name|y
operator|==
literal|0.0f
condition|)
name|UndefinedConstantFoldingError
argument_list|(
name|loc
argument_list|,
name|op
argument_list|,
name|basicType
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|resultArray
index|[
name|i
index|]
operator|.
name|setFConst
argument_list|(
name|atan2f
argument_list|(
name|y
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|EOpPow
case|:
block|{
if|if
condition|(
name|basicType
operator|==
name|EbtFloat
condition|)
block|{
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|maxObjectSize
index|]
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxObjectSize
condition|;
name|i
operator|++
control|)
block|{
name|float
name|x
init|=
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
decl_stmt|;
name|float
name|y
init|=
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
decl_stmt|;
comment|// Results are undefined if x< 0.
comment|// Results are undefined if x = 0 and y<= 0.
if|if
condition|(
name|x
operator|<
literal|0.0f
condition|)
name|UndefinedConstantFoldingError
argument_list|(
name|loc
argument_list|,
name|op
argument_list|,
name|basicType
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
literal|0.0f
operator|&&
name|y
operator|<=
literal|0.0f
condition|)
name|UndefinedConstantFoldingError
argument_list|(
name|loc
argument_list|,
name|op
argument_list|,
name|basicType
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|resultArray
index|[
name|i
index|]
operator|.
name|setFConst
argument_list|(
name|powf
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|EOpMod
case|:
block|{
if|if
condition|(
name|basicType
operator|==
name|EbtFloat
condition|)
block|{
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|maxObjectSize
index|]
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxObjectSize
condition|;
name|i
operator|++
control|)
block|{
name|float
name|x
init|=
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
decl_stmt|;
name|float
name|y
init|=
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
decl_stmt|;
name|resultArray
index|[
name|i
index|]
operator|.
name|setFConst
argument_list|(
name|x
operator|-
name|y
operator|*
name|floorf
argument_list|(
name|x
operator|/
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|EOpMin
case|:
block|{
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|maxObjectSize
index|]
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxObjectSize
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|basicType
condition|)
block|{
case|case
name|EbtFloat
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setFConst
argument_list|(
name|std
operator|::
name|min
argument_list|(
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
argument_list|,
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EbtInt
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setIConst
argument_list|(
name|std
operator|::
name|min
argument_list|(
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getIConst
argument_list|()
argument_list|,
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getIConst
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EbtUInt
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setUConst
argument_list|(
name|std
operator|::
name|min
argument_list|(
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getUConst
argument_list|()
argument_list|,
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getUConst
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
case|case
name|EOpMax
case|:
block|{
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|maxObjectSize
index|]
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxObjectSize
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|basicType
condition|)
block|{
case|case
name|EbtFloat
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setFConst
argument_list|(
name|std
operator|::
name|max
argument_list|(
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
argument_list|,
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EbtInt
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setIConst
argument_list|(
name|std
operator|::
name|max
argument_list|(
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getIConst
argument_list|()
argument_list|,
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getIConst
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EbtUInt
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setUConst
argument_list|(
name|std
operator|::
name|max
argument_list|(
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getUConst
argument_list|()
argument_list|,
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getUConst
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
case|case
name|EOpStep
case|:
block|{
if|if
condition|(
name|basicType
operator|==
name|EbtFloat
condition|)
block|{
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|maxObjectSize
index|]
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxObjectSize
condition|;
name|i
operator|++
control|)
name|resultArray
index|[
name|i
index|]
operator|.
name|setFConst
argument_list|(
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
operator|<
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
condition|?
literal|0.0f
else|:
literal|1.0f
argument_list|)
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|EOpLessThan
case|:
block|{
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|maxObjectSize
index|]
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxObjectSize
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|basicType
condition|)
block|{
case|case
name|EbtFloat
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setBConst
argument_list|(
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
operator|<
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EbtInt
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setBConst
argument_list|(
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getIConst
argument_list|()
operator|<
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getIConst
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EbtUInt
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setBConst
argument_list|(
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getUConst
argument_list|()
operator|<
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getUConst
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
case|case
name|EOpLessThanEqual
case|:
block|{
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|maxObjectSize
index|]
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxObjectSize
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|basicType
condition|)
block|{
case|case
name|EbtFloat
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setBConst
argument_list|(
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
operator|<=
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EbtInt
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setBConst
argument_list|(
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getIConst
argument_list|()
operator|<=
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getIConst
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EbtUInt
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setBConst
argument_list|(
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getUConst
argument_list|()
operator|<=
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getUConst
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
case|case
name|EOpGreaterThan
case|:
block|{
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|maxObjectSize
index|]
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxObjectSize
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|basicType
condition|)
block|{
case|case
name|EbtFloat
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setBConst
argument_list|(
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
operator|>
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EbtInt
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setBConst
argument_list|(
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getIConst
argument_list|()
operator|>
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getIConst
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EbtUInt
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setBConst
argument_list|(
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getUConst
argument_list|()
operator|>
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getUConst
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
case|case
name|EOpGreaterThanEqual
case|:
block|{
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|maxObjectSize
index|]
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxObjectSize
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|basicType
condition|)
block|{
case|case
name|EbtFloat
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setBConst
argument_list|(
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
operator|>=
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EbtInt
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setBConst
argument_list|(
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getIConst
argument_list|()
operator|>=
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getIConst
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EbtUInt
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setBConst
argument_list|(
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getUConst
argument_list|()
operator|>=
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getUConst
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
case|case
name|EOpVectorEqual
case|:
block|{
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|maxObjectSize
index|]
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxObjectSize
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|basicType
condition|)
block|{
case|case
name|EbtFloat
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setBConst
argument_list|(
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
operator|==
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EbtInt
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setBConst
argument_list|(
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getIConst
argument_list|()
operator|==
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getIConst
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EbtUInt
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setBConst
argument_list|(
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getUConst
argument_list|()
operator|==
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getUConst
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EbtBool
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setBConst
argument_list|(
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getBConst
argument_list|()
operator|==
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getBConst
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
case|case
name|EOpVectorNotEqual
case|:
block|{
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|maxObjectSize
index|]
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxObjectSize
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|basicType
condition|)
block|{
case|case
name|EbtFloat
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setBConst
argument_list|(
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
operator|!=
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EbtInt
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setBConst
argument_list|(
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getIConst
argument_list|()
operator|!=
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getIConst
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EbtUInt
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setBConst
argument_list|(
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getUConst
argument_list|()
operator|!=
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getUConst
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EbtBool
case|:
name|resultArray
index|[
name|i
index|]
operator|.
name|setBConst
argument_list|(
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getBConst
argument_list|()
operator|!=
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getBConst
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
case|case
name|EOpDistance
case|:
if|if
condition|(
name|basicType
operator|==
name|EbtFloat
condition|)
block|{
name|TConstantUnion
modifier|*
name|distanceArray
init|=
operator|new
name|TConstantUnion
index|[
name|maxObjectSize
index|]
decl_stmt|;
name|resultArray
operator|=
operator|new
name|TConstantUnion
argument_list|()
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxObjectSize
condition|;
name|i
operator|++
control|)
block|{
name|float
name|x
init|=
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
decl_stmt|;
name|float
name|y
init|=
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
decl_stmt|;
name|distanceArray
index|[
name|i
index|]
operator|.
name|setFConst
argument_list|(
name|x
operator|-
name|y
argument_list|)
expr_stmt|;
block|}
name|resultArray
operator|->
name|setFConst
argument_list|(
name|VectorLength
argument_list|(
name|distanceArray
argument_list|,
name|maxObjectSize
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
case|case
name|EOpDot
case|:
if|if
condition|(
name|basicType
operator|==
name|EbtFloat
condition|)
block|{
name|resultArray
operator|=
operator|new
name|TConstantUnion
argument_list|()
expr_stmt|;
name|resultArray
operator|->
name|setFConst
argument_list|(
name|VectorDotProduct
argument_list|(
name|unionArrays
index|[
literal|0
index|]
argument_list|,
name|unionArrays
index|[
literal|1
index|]
argument_list|,
name|maxObjectSize
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
case|case
name|EOpCross
case|:
if|if
condition|(
name|basicType
operator|==
name|EbtFloat
operator|&&
name|maxObjectSize
operator|==
literal|3
condition|)
block|{
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|maxObjectSize
index|]
expr_stmt|;
name|float
name|x0
init|=
name|unionArrays
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|.
name|getFConst
argument_list|()
decl_stmt|;
name|float
name|x1
init|=
name|unionArrays
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|.
name|getFConst
argument_list|()
decl_stmt|;
name|float
name|x2
init|=
name|unionArrays
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|.
name|getFConst
argument_list|()
decl_stmt|;
name|float
name|y0
init|=
name|unionArrays
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|.
name|getFConst
argument_list|()
decl_stmt|;
name|float
name|y1
init|=
name|unionArrays
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|.
name|getFConst
argument_list|()
decl_stmt|;
name|float
name|y2
init|=
name|unionArrays
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|.
name|getFConst
argument_list|()
decl_stmt|;
name|resultArray
index|[
literal|0
index|]
operator|.
name|setFConst
argument_list|(
name|x1
operator|*
name|y2
operator|-
name|y1
operator|*
name|x2
argument_list|)
expr_stmt|;
name|resultArray
index|[
literal|1
index|]
operator|.
name|setFConst
argument_list|(
name|x2
operator|*
name|y0
operator|-
name|y2
operator|*
name|x0
argument_list|)
expr_stmt|;
name|resultArray
index|[
literal|2
index|]
operator|.
name|setFConst
argument_list|(
name|x0
operator|*
name|y1
operator|-
name|y0
operator|*
name|x1
argument_list|)
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
case|case
name|EOpReflect
case|:
if|if
condition|(
name|basicType
operator|==
name|EbtFloat
condition|)
block|{
comment|// genType reflect (genType I, genType N) :
comment|//     For the incident vector I and surface orientation N, returns the reflection direction:
comment|//     I - 2 * dot(N, I) * N.
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|maxObjectSize
index|]
expr_stmt|;
name|float
name|dotProduct
init|=
name|VectorDotProduct
argument_list|(
name|unionArrays
index|[
literal|1
index|]
argument_list|,
name|unionArrays
index|[
literal|0
index|]
argument_list|,
name|maxObjectSize
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxObjectSize
condition|;
name|i
operator|++
control|)
block|{
name|float
name|result
init|=
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
operator|-
literal|2.0f
operator|*
name|dotProduct
operator|*
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
decl_stmt|;
name|resultArray
index|[
name|i
index|]
operator|.
name|setFConst
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
case|case
name|EOpMul
case|:
if|if
condition|(
name|basicType
operator|==
name|EbtFloat
operator|&&
operator|(
operator|*
name|sequence
operator|)
index|[
literal|0
index|]
operator|->
name|getAsTyped
argument_list|()
operator|->
name|isMatrix
argument_list|()
operator|&&
operator|(
operator|*
name|sequence
operator|)
index|[
literal|1
index|]
operator|->
name|getAsTyped
argument_list|()
operator|->
name|isMatrix
argument_list|()
condition|)
block|{
comment|// Perform component-wise matrix multiplication.
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|maxObjectSize
index|]
expr_stmt|;
name|int
name|size
init|=
operator|(
operator|*
name|sequence
operator|)
index|[
literal|0
index|]
operator|->
name|getAsTyped
argument_list|()
operator|->
name|getNominalSize
argument_list|()
decl_stmt|;
name|angle
operator|::
name|Matrix
argument_list|<
name|float
argument_list|>
name|result
init|=
name|GetMatrix
argument_list|(
name|unionArrays
index|[
literal|0
index|]
argument_list|,
name|size
argument_list|)
operator|.
name|compMult
argument_list|(
name|GetMatrix
argument_list|(
name|unionArrays
index|[
literal|1
index|]
argument_list|,
name|size
argument_list|)
argument_list|)
decl_stmt|;
name|SetUnionArrayFromMatrix
argument_list|(
name|result
argument_list|,
name|resultArray
argument_list|)
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
case|case
name|EOpOuterProduct
case|:
if|if
condition|(
name|basicType
operator|==
name|EbtFloat
condition|)
block|{
name|size_t
name|numRows
init|=
operator|(
operator|*
name|sequence
operator|)
index|[
literal|0
index|]
operator|->
name|getAsTyped
argument_list|()
operator|->
name|getType
argument_list|()
operator|.
name|getObjectSize
argument_list|()
decl_stmt|;
name|size_t
name|numCols
init|=
operator|(
operator|*
name|sequence
operator|)
index|[
literal|1
index|]
operator|->
name|getAsTyped
argument_list|()
operator|->
name|getType
argument_list|()
operator|.
name|getObjectSize
argument_list|()
decl_stmt|;
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|numRows
operator|*
name|numCols
index|]
expr_stmt|;
name|angle
operator|::
name|Matrix
argument_list|<
name|float
argument_list|>
name|result
init|=
name|GetMatrix
argument_list|(
name|unionArrays
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|,
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|numCols
argument_list|)
argument_list|)
operator|.
name|outerProduct
argument_list|(
name|GetMatrix
argument_list|(
name|unionArrays
index|[
literal|1
index|]
argument_list|,
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|numRows
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|SetUnionArrayFromMatrix
argument_list|(
name|result
argument_list|,
name|resultArray
argument_list|)
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
comment|// TODO: Add constant folding support for other built-in operations that take 2 parameters and not handled above.
return|return
literal|nullptr
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|paramsCount
operator|==
literal|3
condition|)
block|{
comment|//
comment|// Ternary built-in
comment|//
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|EOpClamp
case|:
block|{
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|maxObjectSize
index|]
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxObjectSize
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|basicType
condition|)
block|{
case|case
name|EbtFloat
case|:
block|{
name|float
name|x
init|=
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
decl_stmt|;
name|float
name|min
init|=
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
decl_stmt|;
name|float
name|max
init|=
name|unionArrays
index|[
literal|2
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
decl_stmt|;
comment|// Results are undefined if min> max.
if|if
condition|(
name|min
operator|>
name|max
condition|)
name|UndefinedConstantFoldingError
argument_list|(
name|loc
argument_list|,
name|op
argument_list|,
name|basicType
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|resultArray
index|[
name|i
index|]
operator|.
name|setFConst
argument_list|(
name|gl
operator|::
name|clamp
argument_list|(
name|x
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EbtInt
case|:
block|{
name|int
name|x
init|=
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getIConst
argument_list|()
decl_stmt|;
name|int
name|min
init|=
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getIConst
argument_list|()
decl_stmt|;
name|int
name|max
init|=
name|unionArrays
index|[
literal|2
index|]
index|[
name|i
index|]
operator|.
name|getIConst
argument_list|()
decl_stmt|;
comment|// Results are undefined if min> max.
if|if
condition|(
name|min
operator|>
name|max
condition|)
name|UndefinedConstantFoldingError
argument_list|(
name|loc
argument_list|,
name|op
argument_list|,
name|basicType
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|resultArray
index|[
name|i
index|]
operator|.
name|setIConst
argument_list|(
name|gl
operator|::
name|clamp
argument_list|(
name|x
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EbtUInt
case|:
block|{
name|unsigned
name|int
name|x
init|=
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getUConst
argument_list|()
decl_stmt|;
name|unsigned
name|int
name|min
init|=
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getUConst
argument_list|()
decl_stmt|;
name|unsigned
name|int
name|max
init|=
name|unionArrays
index|[
literal|2
index|]
index|[
name|i
index|]
operator|.
name|getUConst
argument_list|()
decl_stmt|;
comment|// Results are undefined if min> max.
if|if
condition|(
name|min
operator|>
name|max
condition|)
name|UndefinedConstantFoldingError
argument_list|(
name|loc
argument_list|,
name|op
argument_list|,
name|basicType
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|resultArray
index|[
name|i
index|]
operator|.
name|setUConst
argument_list|(
name|gl
operator|::
name|clamp
argument_list|(
name|x
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
case|case
name|EOpMix
case|:
block|{
if|if
condition|(
name|basicType
operator|==
name|EbtFloat
condition|)
block|{
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|maxObjectSize
index|]
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxObjectSize
condition|;
name|i
operator|++
control|)
block|{
name|float
name|x
init|=
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
decl_stmt|;
name|float
name|y
init|=
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
decl_stmt|;
name|TBasicType
name|type
init|=
operator|(
operator|*
name|sequence
operator|)
index|[
literal|2
index|]
operator|->
name|getAsTyped
argument_list|()
operator|->
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|EbtFloat
condition|)
block|{
comment|// Returns the linear blend of x and y, i.e., x * (1 - a) + y * a.
name|float
name|a
init|=
name|unionArrays
index|[
literal|2
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
decl_stmt|;
name|resultArray
index|[
name|i
index|]
operator|.
name|setFConst
argument_list|(
name|x
operator|*
operator|(
literal|1.0f
operator|-
name|a
operator|)
operator|+
name|y
operator|*
name|a
argument_list|)
expr_stmt|;
block|}
else|else
comment|// 3rd parameter is EbtBool
block|{
name|ASSERT
argument_list|(
name|type
operator|==
name|EbtBool
argument_list|)
expr_stmt|;
comment|// Selects which vector each returned component comes from.
comment|// For a component of a that is false, the corresponding component of x is returned.
comment|// For a component of a that is true, the corresponding component of y is returned.
name|bool
name|a
init|=
name|unionArrays
index|[
literal|2
index|]
index|[
name|i
index|]
operator|.
name|getBConst
argument_list|()
decl_stmt|;
name|resultArray
index|[
name|i
index|]
operator|.
name|setFConst
argument_list|(
name|a
condition|?
name|y
else|:
name|x
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|EOpSmoothStep
case|:
block|{
if|if
condition|(
name|basicType
operator|==
name|EbtFloat
condition|)
block|{
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|maxObjectSize
index|]
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxObjectSize
condition|;
name|i
operator|++
control|)
block|{
name|float
name|edge0
init|=
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
decl_stmt|;
name|float
name|edge1
init|=
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
decl_stmt|;
name|float
name|x
init|=
name|unionArrays
index|[
literal|2
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
decl_stmt|;
comment|// Results are undefined if edge0>= edge1.
if|if
condition|(
name|edge0
operator|>=
name|edge1
condition|)
block|{
name|UndefinedConstantFoldingError
argument_list|(
name|loc
argument_list|,
name|op
argument_list|,
name|basicType
argument_list|,
name|infoSink
argument_list|,
operator|&
name|resultArray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Returns 0.0 if x<= edge0 and 1.0 if x>= edge1 and performs smooth
comment|// Hermite interpolation between 0 and 1 when edge0< x< edge1.
name|float
name|t
init|=
name|gl
operator|::
name|clamp
argument_list|(
operator|(
name|x
operator|-
name|edge0
operator|)
operator|/
operator|(
name|edge1
operator|-
name|edge0
operator|)
argument_list|,
literal|0.0f
argument_list|,
literal|1.0f
argument_list|)
decl_stmt|;
name|resultArray
index|[
name|i
index|]
operator|.
name|setFConst
argument_list|(
name|t
operator|*
name|t
operator|*
operator|(
literal|3.0f
operator|-
literal|2.0f
operator|*
name|t
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|EOpFaceForward
case|:
if|if
condition|(
name|basicType
operator|==
name|EbtFloat
condition|)
block|{
comment|// genType faceforward(genType N, genType I, genType Nref) :
comment|//     If dot(Nref, I)< 0 return N, otherwise return -N.
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|maxObjectSize
index|]
expr_stmt|;
name|float
name|dotProduct
init|=
name|VectorDotProduct
argument_list|(
name|unionArrays
index|[
literal|2
index|]
argument_list|,
name|unionArrays
index|[
literal|1
index|]
argument_list|,
name|maxObjectSize
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxObjectSize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dotProduct
operator|<
literal|0
condition|)
name|resultArray
index|[
name|i
index|]
operator|.
name|setFConst
argument_list|(
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|resultArray
index|[
name|i
index|]
operator|.
name|setFConst
argument_list|(
operator|-
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
case|case
name|EOpRefract
case|:
if|if
condition|(
name|basicType
operator|==
name|EbtFloat
condition|)
block|{
comment|// genType refract(genType I, genType N, float eta) :
comment|//     For the incident vector I and surface normal N, and the ratio of indices of refraction eta,
comment|//     return the refraction vector. The result is computed by
comment|//         k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I))
comment|//         if (k< 0.0)
comment|//             return genType(0.0)
comment|//         else
comment|//             return eta * I - (eta * dot(N, I) + sqrt(k)) * N
name|resultArray
operator|=
operator|new
name|TConstantUnion
index|[
name|maxObjectSize
index|]
expr_stmt|;
name|float
name|dotProduct
init|=
name|VectorDotProduct
argument_list|(
name|unionArrays
index|[
literal|1
index|]
argument_list|,
name|unionArrays
index|[
literal|0
index|]
argument_list|,
name|maxObjectSize
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxObjectSize
condition|;
name|i
operator|++
control|)
block|{
name|float
name|eta
init|=
name|unionArrays
index|[
literal|2
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
decl_stmt|;
name|float
name|k
init|=
literal|1.0f
operator|-
name|eta
operator|*
name|eta
operator|*
operator|(
literal|1.0f
operator|-
name|dotProduct
operator|*
name|dotProduct
operator|)
decl_stmt|;
if|if
condition|(
name|k
operator|<
literal|0.0f
condition|)
name|resultArray
index|[
name|i
index|]
operator|.
name|setFConst
argument_list|(
literal|0.0f
argument_list|)
expr_stmt|;
else|else
name|resultArray
index|[
name|i
index|]
operator|.
name|setFConst
argument_list|(
name|eta
operator|*
name|unionArrays
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
operator|-
operator|(
name|eta
operator|*
name|dotProduct
operator|+
name|sqrtf
argument_list|(
name|k
argument_list|)
operator|)
operator|*
name|unionArrays
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|getFConst
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
comment|// TODO: Add constant folding support for other built-in operations that take 3 parameters and not handled above.
return|return
literal|nullptr
return|;
block|}
block|}
return|return
name|resultArray
return|;
block|}
end_function
begin_comment
comment|// static
end_comment
begin_function
DECL|function|hash
name|TString
name|TIntermTraverser
operator|::
name|hash
parameter_list|(
specifier|const
name|TString
modifier|&
name|name
parameter_list|,
name|ShHashFunction64
name|hashFunction
parameter_list|)
block|{
if|if
condition|(
name|hashFunction
operator|==
name|NULL
operator|||
name|name
operator|.
name|empty
argument_list|()
condition|)
return|return
name|name
return|;
name|khronos_uint64_t
name|number
init|=
call|(
modifier|*
name|hashFunction
call|)
argument_list|(
name|name
operator|.
name|c_str
argument_list|()
argument_list|,
name|name
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|TStringStream
name|stream
decl_stmt|;
name|stream
operator|<<
name|HASHED_NAME_PREFIX
operator|<<
name|std
operator|::
name|hex
operator|<<
name|number
expr_stmt|;
name|TString
name|hashedName
init|=
name|stream
operator|.
name|str
argument_list|()
decl_stmt|;
return|return
name|hashedName
return|;
block|}
end_function
begin_function
DECL|function|updateTree
name|void
name|TIntermTraverser
operator|::
name|updateTree
parameter_list|()
block|{
for|for
control|(
name|size_t
name|ii
init|=
literal|0
init|;
name|ii
operator|<
name|mInsertions
operator|.
name|size
argument_list|()
condition|;
operator|++
name|ii
control|)
block|{
specifier|const
name|NodeInsertMultipleEntry
modifier|&
name|insertion
init|=
name|mInsertions
index|[
name|ii
index|]
decl_stmt|;
name|ASSERT
argument_list|(
name|insertion
operator|.
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insertion
operator|.
name|insertionsAfter
operator|.
name|empty
argument_list|()
condition|)
block|{
name|bool
name|inserted
init|=
name|insertion
operator|.
name|parent
operator|->
name|insertChildNodes
argument_list|(
name|insertion
operator|.
name|position
operator|+
literal|1
argument_list|,
name|insertion
operator|.
name|insertionsAfter
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|inserted
argument_list|)
expr_stmt|;
name|UNUSED_ASSERTION_VARIABLE
argument_list|(
name|inserted
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|insertion
operator|.
name|insertionsBefore
operator|.
name|empty
argument_list|()
condition|)
block|{
name|bool
name|inserted
init|=
name|insertion
operator|.
name|parent
operator|->
name|insertChildNodes
argument_list|(
name|insertion
operator|.
name|position
argument_list|,
name|insertion
operator|.
name|insertionsBefore
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|inserted
argument_list|)
expr_stmt|;
name|UNUSED_ASSERTION_VARIABLE
argument_list|(
name|inserted
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|size_t
name|ii
init|=
literal|0
init|;
name|ii
operator|<
name|mReplacements
operator|.
name|size
argument_list|()
condition|;
operator|++
name|ii
control|)
block|{
specifier|const
name|NodeUpdateEntry
modifier|&
name|replacement
init|=
name|mReplacements
index|[
name|ii
index|]
decl_stmt|;
name|ASSERT
argument_list|(
name|replacement
operator|.
name|parent
argument_list|)
expr_stmt|;
name|bool
name|replaced
init|=
name|replacement
operator|.
name|parent
operator|->
name|replaceChildNode
argument_list|(
name|replacement
operator|.
name|original
argument_list|,
name|replacement
operator|.
name|replacement
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|replaced
argument_list|)
expr_stmt|;
name|UNUSED_ASSERTION_VARIABLE
argument_list|(
name|replaced
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|replacement
operator|.
name|originalBecomesChildOfReplacement
condition|)
block|{
comment|// In AST traversing, a parent is visited before its children.
comment|// After we replace a node, if its immediate child is to
comment|// be replaced, we need to make sure we don't update the replaced
comment|// node; instead, we update the replacement node.
for|for
control|(
name|size_t
name|jj
init|=
name|ii
operator|+
literal|1
init|;
name|jj
operator|<
name|mReplacements
operator|.
name|size
argument_list|()
condition|;
operator|++
name|jj
control|)
block|{
name|NodeUpdateEntry
modifier|&
name|replacement2
init|=
name|mReplacements
index|[
name|jj
index|]
decl_stmt|;
if|if
condition|(
name|replacement2
operator|.
name|parent
operator|==
name|replacement
operator|.
name|original
condition|)
name|replacement2
operator|.
name|parent
operator|=
name|replacement
operator|.
name|replacement
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|size_t
name|ii
init|=
literal|0
init|;
name|ii
operator|<
name|mMultiReplacements
operator|.
name|size
argument_list|()
condition|;
operator|++
name|ii
control|)
block|{
specifier|const
name|NodeReplaceWithMultipleEntry
modifier|&
name|replacement
init|=
name|mMultiReplacements
index|[
name|ii
index|]
decl_stmt|;
name|ASSERT
argument_list|(
name|replacement
operator|.
name|parent
argument_list|)
expr_stmt|;
name|bool
name|replaced
init|=
name|replacement
operator|.
name|parent
operator|->
name|replaceChildNodeWithMultiple
argument_list|(
name|replacement
operator|.
name|original
argument_list|,
name|replacement
operator|.
name|replacements
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|replaced
argument_list|)
expr_stmt|;
name|UNUSED_ASSERTION_VARIABLE
argument_list|(
name|replaced
argument_list|)
expr_stmt|;
block|}
name|mInsertions
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mReplacements
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mMultiReplacements
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
end_unit
