begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|"compiler/translator/OutputHLSL.h"
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_include
include|#
directive|include
file|<cfloat>
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|"common/angleutils.h"
end_include
begin_include
include|#
directive|include
file|"common/utilities.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/BuiltInFunctionEmulator.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/BuiltInFunctionEmulatorHLSL.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/DetectDiscontinuity.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/FlagStd140Structs.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/InfoSink.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/NodeSearch.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/RemoveSwitchFallThrough.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/RewriteElseBlocks.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/SearchSymbol.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/StructureHLSL.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/TranslatorHLSL.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/UnfoldShortCircuit.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/UniformHLSL.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/UtilsHLSL.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/blocklayout.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/compilerdebug.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/util.h"
end_include
begin_namespace
DECL|namespace|sh
namespace|namespace
name|sh
block|{
DECL|function|name
name|TString
name|OutputHLSL
operator|::
name|TextureFunction
operator|::
name|name
parameter_list|()
specifier|const
block|{
name|TString
name|name
init|=
literal|"gl_texture"
decl_stmt|;
if|if
condition|(
name|IsSampler2D
argument_list|(
name|sampler
argument_list|)
condition|)
block|{
name|name
operator|+=
literal|"2D"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IsSampler3D
argument_list|(
name|sampler
argument_list|)
condition|)
block|{
name|name
operator|+=
literal|"3D"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IsSamplerCube
argument_list|(
name|sampler
argument_list|)
condition|)
block|{
name|name
operator|+=
literal|"Cube"
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
if|if
condition|(
name|proj
condition|)
block|{
name|name
operator|+=
literal|"Proj"
expr_stmt|;
block|}
if|if
condition|(
name|offset
condition|)
block|{
name|name
operator|+=
literal|"Offset"
expr_stmt|;
block|}
switch|switch
condition|(
name|method
condition|)
block|{
case|case
name|IMPLICIT
case|:
break|break;
case|case
name|BIAS
case|:
break|break;
comment|// Extra parameter makes the signature unique
case|case
name|LOD
case|:
name|name
operator|+=
literal|"Lod"
expr_stmt|;
break|break;
case|case
name|LOD0
case|:
name|name
operator|+=
literal|"Lod0"
expr_stmt|;
break|break;
case|case
name|LOD0BIAS
case|:
name|name
operator|+=
literal|"Lod0"
expr_stmt|;
break|break;
comment|// Extra parameter makes the signature unique
case|case
name|SIZE
case|:
name|name
operator|+=
literal|"Size"
expr_stmt|;
break|break;
case|case
name|FETCH
case|:
name|name
operator|+=
literal|"Fetch"
expr_stmt|;
break|break;
case|case
name|GRAD
case|:
name|name
operator|+=
literal|"Grad"
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
name|name
operator|+
literal|"("
return|;
block|}
DECL|function|operator <
name|bool
name|OutputHLSL
operator|::
name|TextureFunction
operator|::
name|operator
name|<
parameter_list|(
specifier|const
name|TextureFunction
modifier|&
name|rhs
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|sampler
operator|<
name|rhs
operator|.
name|sampler
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|sampler
operator|>
name|rhs
operator|.
name|sampler
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|coords
operator|<
name|rhs
operator|.
name|coords
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|coords
operator|>
name|rhs
operator|.
name|coords
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|proj
operator|&&
name|rhs
operator|.
name|proj
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|proj
operator|&&
operator|!
name|rhs
operator|.
name|proj
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|offset
operator|&&
name|rhs
operator|.
name|offset
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|offset
operator|&&
operator|!
name|rhs
operator|.
name|offset
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|method
operator|<
name|rhs
operator|.
name|method
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|method
operator|>
name|rhs
operator|.
name|method
condition|)
return|return
literal|false
return|;
return|return
literal|false
return|;
block|}
DECL|function|OutputHLSL
name|OutputHLSL
operator|::
name|OutputHLSL
parameter_list|(
name|sh
operator|::
name|GLenum
name|shaderType
parameter_list|,
name|int
name|shaderVersion
parameter_list|,
specifier|const
name|TExtensionBehavior
modifier|&
name|extensionBehavior
parameter_list|,
specifier|const
name|char
modifier|*
name|sourcePath
parameter_list|,
name|ShShaderOutput
name|outputType
parameter_list|,
name|int
name|numRenderTargets
parameter_list|,
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|Uniform
argument_list|>
modifier|&
name|uniforms
parameter_list|,
name|int
name|compileOptions
parameter_list|)
member_init_list|:
name|TIntermTraverser
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
member_init_list|,
name|mShaderType
argument_list|(
name|shaderType
argument_list|)
member_init_list|,
name|mShaderVersion
argument_list|(
name|shaderVersion
argument_list|)
member_init_list|,
name|mExtensionBehavior
argument_list|(
name|extensionBehavior
argument_list|)
member_init_list|,
name|mSourcePath
argument_list|(
name|sourcePath
argument_list|)
member_init_list|,
name|mOutputType
argument_list|(
name|outputType
argument_list|)
member_init_list|,
name|mNumRenderTargets
argument_list|(
name|numRenderTargets
argument_list|)
member_init_list|,
name|mCompileOptions
argument_list|(
name|compileOptions
argument_list|)
block|{
name|mUnfoldShortCircuit
operator|=
operator|new
name|UnfoldShortCircuit
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|mInsideFunction
operator|=
literal|false
expr_stmt|;
name|mUsesFragColor
operator|=
literal|false
expr_stmt|;
name|mUsesFragData
operator|=
literal|false
expr_stmt|;
name|mUsesDepthRange
operator|=
literal|false
expr_stmt|;
name|mUsesFragCoord
operator|=
literal|false
expr_stmt|;
name|mUsesPointCoord
operator|=
literal|false
expr_stmt|;
name|mUsesFrontFacing
operator|=
literal|false
expr_stmt|;
name|mUsesPointSize
operator|=
literal|false
expr_stmt|;
name|mUsesInstanceID
operator|=
literal|false
expr_stmt|;
name|mUsesFragDepth
operator|=
literal|false
expr_stmt|;
name|mUsesXor
operator|=
literal|false
expr_stmt|;
name|mUsesDiscardRewriting
operator|=
literal|false
expr_stmt|;
name|mUsesNestedBreak
operator|=
literal|false
expr_stmt|;
name|mRequiresIEEEStrictCompiling
operator|=
literal|false
expr_stmt|;
name|mUniqueIndex
operator|=
literal|0
expr_stmt|;
name|mContainsLoopDiscontinuity
operator|=
literal|false
expr_stmt|;
name|mContainsAnyLoop
operator|=
literal|false
expr_stmt|;
name|mOutputLod0Function
operator|=
literal|false
expr_stmt|;
name|mInsideDiscontinuousLoop
operator|=
literal|false
expr_stmt|;
name|mNestedLoopDepth
operator|=
literal|0
expr_stmt|;
name|mExcessiveLoopIndex
operator|=
name|NULL
expr_stmt|;
name|mStructureHLSL
operator|=
operator|new
name|StructureHLSL
expr_stmt|;
name|mUniformHLSL
operator|=
operator|new
name|UniformHLSL
argument_list|(
name|mStructureHLSL
argument_list|,
name|outputType
argument_list|,
name|uniforms
argument_list|)
expr_stmt|;
if|if
condition|(
name|mOutputType
operator|==
name|SH_HLSL9_OUTPUT
condition|)
block|{
comment|// Fragment shaders need dx_DepthRange, dx_ViewCoords and dx_DepthFront.
comment|// Vertex shaders need a slightly different set: dx_DepthRange, dx_ViewCoords and dx_ViewAdjust.
comment|// In both cases total 3 uniform registers need to be reserved.
name|mUniformHLSL
operator|->
name|reserveUniformRegisters
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
comment|// Reserve registers for the default uniform block and driver constants
name|mUniformHLSL
operator|->
name|reserveInterfaceBlockRegisters
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
DECL|function|~OutputHLSL
name|OutputHLSL
operator|::
name|~
name|OutputHLSL
parameter_list|()
block|{
name|SafeDelete
argument_list|(
name|mUnfoldShortCircuit
argument_list|)
expr_stmt|;
name|SafeDelete
argument_list|(
name|mStructureHLSL
argument_list|)
expr_stmt|;
name|SafeDelete
argument_list|(
name|mUniformHLSL
argument_list|)
expr_stmt|;
for|for
control|(
name|auto
name|it
init|=
name|mStructEqualityFunctions
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|mStructEqualityFunctions
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|SafeDelete
argument_list|(
operator|*
name|it
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|auto
name|it
init|=
name|mArrayEqualityFunctions
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|mArrayEqualityFunctions
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|SafeDelete
argument_list|(
operator|*
name|it
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|output
name|void
name|OutputHLSL
operator|::
name|output
parameter_list|(
name|TIntermNode
modifier|*
name|treeRoot
parameter_list|,
name|TInfoSinkBase
modifier|&
name|objSink
parameter_list|)
block|{
name|mContainsLoopDiscontinuity
operator|=
name|mShaderType
operator|==
name|GL_FRAGMENT_SHADER
operator|&&
name|containsLoopDiscontinuity
argument_list|(
name|treeRoot
argument_list|)
expr_stmt|;
name|mContainsAnyLoop
operator|=
name|containsAnyLoop
argument_list|(
name|treeRoot
argument_list|)
expr_stmt|;
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|TIntermTyped
modifier|*
argument_list|>
modifier|&
name|flaggedStructs
init|=
name|FlagStd140ValueStructs
argument_list|(
name|treeRoot
argument_list|)
decl_stmt|;
name|makeFlaggedStructMaps
argument_list|(
name|flaggedStructs
argument_list|)
expr_stmt|;
comment|// Work around D3D9 bug that would manifest in vertex shaders with selection blocks which
comment|// use a vertex attribute as a condition, and some related computation in the else block.
if|if
condition|(
name|mOutputType
operator|==
name|SH_HLSL9_OUTPUT
operator|&&
name|mShaderType
operator|==
name|GL_VERTEX_SHADER
condition|)
block|{
name|RewriteElseBlocks
argument_list|(
name|treeRoot
argument_list|)
expr_stmt|;
block|}
name|BuiltInFunctionEmulator
name|builtInFunctionEmulator
decl_stmt|;
name|InitBuiltInFunctionEmulatorForHLSL
argument_list|(
operator|&
name|builtInFunctionEmulator
argument_list|)
expr_stmt|;
name|builtInFunctionEmulator
operator|.
name|MarkBuiltInFunctionsForEmulation
argument_list|(
name|treeRoot
argument_list|)
expr_stmt|;
comment|// Output the body and footer first to determine what has to go in the header
name|mInfoSinkStack
operator|.
name|push
argument_list|(
operator|&
name|mBody
argument_list|)
expr_stmt|;
name|treeRoot
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|mInfoSinkStack
operator|.
name|pop
argument_list|()
expr_stmt|;
name|mInfoSinkStack
operator|.
name|push
argument_list|(
operator|&
name|mFooter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mDeferredGlobalInitializers
operator|.
name|empty
argument_list|()
condition|)
block|{
name|writeDeferredGlobalInitializers
argument_list|(
name|mFooter
argument_list|)
expr_stmt|;
block|}
name|mInfoSinkStack
operator|.
name|pop
argument_list|()
expr_stmt|;
name|mInfoSinkStack
operator|.
name|push
argument_list|(
operator|&
name|mHeader
argument_list|)
expr_stmt|;
name|header
argument_list|(
operator|&
name|builtInFunctionEmulator
argument_list|)
expr_stmt|;
name|mInfoSinkStack
operator|.
name|pop
argument_list|()
expr_stmt|;
name|objSink
operator|<<
name|mHeader
operator|.
name|c_str
argument_list|()
expr_stmt|;
name|objSink
operator|<<
name|mBody
operator|.
name|c_str
argument_list|()
expr_stmt|;
name|objSink
operator|<<
name|mFooter
operator|.
name|c_str
argument_list|()
expr_stmt|;
name|builtInFunctionEmulator
operator|.
name|Cleanup
argument_list|()
expr_stmt|;
block|}
DECL|function|makeFlaggedStructMaps
name|void
name|OutputHLSL
operator|::
name|makeFlaggedStructMaps
parameter_list|(
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|TIntermTyped
modifier|*
argument_list|>
modifier|&
name|flaggedStructs
parameter_list|)
block|{
for|for
control|(
name|unsigned
name|int
name|structIndex
init|=
literal|0
init|;
name|structIndex
operator|<
name|flaggedStructs
operator|.
name|size
argument_list|()
condition|;
name|structIndex
operator|++
control|)
block|{
name|TIntermTyped
modifier|*
name|flaggedNode
init|=
name|flaggedStructs
index|[
name|structIndex
index|]
decl_stmt|;
name|TInfoSinkBase
name|structInfoSink
decl_stmt|;
name|mInfoSinkStack
operator|.
name|push
argument_list|(
operator|&
name|structInfoSink
argument_list|)
expr_stmt|;
comment|// This will mark the necessary block elements as referenced
name|flaggedNode
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|TString
name|structName
argument_list|(
name|structInfoSink
operator|.
name|c_str
argument_list|()
argument_list|)
decl_stmt|;
name|mInfoSinkStack
operator|.
name|pop
argument_list|()
expr_stmt|;
name|mFlaggedStructOriginalNames
index|[
name|flaggedNode
index|]
operator|=
name|structName
expr_stmt|;
for|for
control|(
name|size_t
name|pos
init|=
name|structName
operator|.
name|find
argument_list|(
literal|'.'
argument_list|)
init|;
name|pos
operator|!=
name|std
operator|::
name|string
operator|::
name|npos
condition|;
name|pos
operator|=
name|structName
operator|.
name|find
argument_list|(
literal|'.'
argument_list|)
control|)
block|{
name|structName
operator|.
name|erase
argument_list|(
name|pos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|mFlaggedStructMappedNames
index|[
name|flaggedNode
index|]
operator|=
literal|"map"
operator|+
name|structName
expr_stmt|;
block|}
block|}
DECL|function|getInterfaceBlockRegisterMap
specifier|const
name|std
operator|::
name|map
argument_list|<
name|std
operator|::
name|string
argument_list|,
name|unsigned
name|int
argument_list|>
modifier|&
name|OutputHLSL
operator|::
name|getInterfaceBlockRegisterMap
parameter_list|()
specifier|const
block|{
return|return
name|mUniformHLSL
operator|->
name|getInterfaceBlockRegisterMap
argument_list|()
return|;
block|}
DECL|function|getUniformRegisterMap
specifier|const
name|std
operator|::
name|map
argument_list|<
name|std
operator|::
name|string
argument_list|,
name|unsigned
name|int
argument_list|>
modifier|&
name|OutputHLSL
operator|::
name|getUniformRegisterMap
parameter_list|()
specifier|const
block|{
return|return
name|mUniformHLSL
operator|->
name|getUniformRegisterMap
argument_list|()
return|;
block|}
DECL|function|vectorSize
name|int
name|OutputHLSL
operator|::
name|vectorSize
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|)
specifier|const
block|{
name|int
name|elementSize
init|=
name|type
operator|.
name|isMatrix
argument_list|()
condition|?
name|type
operator|.
name|getCols
argument_list|()
else|:
literal|1
decl_stmt|;
name|int
name|arraySize
init|=
name|type
operator|.
name|isArray
argument_list|()
condition|?
name|type
operator|.
name|getArraySize
argument_list|()
else|:
literal|1
decl_stmt|;
return|return
name|elementSize
operator|*
name|arraySize
return|;
block|}
DECL|function|structInitializerString
name|TString
name|OutputHLSL
operator|::
name|structInitializerString
parameter_list|(
name|int
name|indent
parameter_list|,
specifier|const
name|TStructure
modifier|&
name|structure
parameter_list|,
specifier|const
name|TString
modifier|&
name|rhsStructName
parameter_list|)
block|{
name|TString
name|init
decl_stmt|;
name|TString
name|preIndentString
decl_stmt|;
name|TString
name|fullIndentString
decl_stmt|;
for|for
control|(
name|int
name|spaces
init|=
literal|0
init|;
name|spaces
operator|<
operator|(
name|indent
operator|*
literal|4
operator|)
condition|;
name|spaces
operator|++
control|)
block|{
name|preIndentString
operator|+=
literal|' '
expr_stmt|;
block|}
for|for
control|(
name|int
name|spaces
init|=
literal|0
init|;
name|spaces
operator|<
operator|(
operator|(
name|indent
operator|+
literal|1
operator|)
operator|*
literal|4
operator|)
condition|;
name|spaces
operator|++
control|)
block|{
name|fullIndentString
operator|+=
literal|' '
expr_stmt|;
block|}
name|init
operator|+=
name|preIndentString
operator|+
literal|"{\n"
expr_stmt|;
specifier|const
name|TFieldList
modifier|&
name|fields
init|=
name|structure
operator|.
name|fields
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|fieldIndex
init|=
literal|0
init|;
name|fieldIndex
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|fieldIndex
operator|++
control|)
block|{
specifier|const
name|TField
modifier|&
name|field
init|=
operator|*
name|fields
index|[
name|fieldIndex
index|]
decl_stmt|;
specifier|const
name|TString
modifier|&
name|fieldName
init|=
name|rhsStructName
operator|+
literal|"."
operator|+
name|Decorate
argument_list|(
name|field
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|TType
modifier|&
name|fieldType
init|=
operator|*
name|field
operator|.
name|type
argument_list|()
decl_stmt|;
if|if
condition|(
name|fieldType
operator|.
name|getStruct
argument_list|()
condition|)
block|{
name|init
operator|+=
name|structInitializerString
argument_list|(
name|indent
operator|+
literal|1
argument_list|,
operator|*
name|fieldType
operator|.
name|getStruct
argument_list|()
argument_list|,
name|fieldName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|init
operator|+=
name|fullIndentString
operator|+
name|fieldName
operator|+
literal|",\n"
expr_stmt|;
block|}
block|}
name|init
operator|+=
name|preIndentString
operator|+
literal|"}"
operator|+
operator|(
name|indent
operator|==
literal|0
condition|?
literal|";"
else|:
literal|","
operator|)
operator|+
literal|"\n"
expr_stmt|;
return|return
name|init
return|;
block|}
DECL|function|header
name|void
name|OutputHLSL
operator|::
name|header
parameter_list|(
specifier|const
name|BuiltInFunctionEmulator
modifier|*
name|builtInFunctionEmulator
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|getInfoSink
argument_list|()
decl_stmt|;
name|TString
name|varyings
decl_stmt|;
name|TString
name|attributes
decl_stmt|;
name|TString
name|flaggedStructs
decl_stmt|;
for|for
control|(
name|std
operator|::
name|map
argument_list|<
name|TIntermTyped
operator|*
argument_list|,
name|TString
argument_list|>
operator|::
name|const_iterator
name|flaggedStructIt
init|=
name|mFlaggedStructMappedNames
operator|.
name|begin
argument_list|()
init|;
name|flaggedStructIt
operator|!=
name|mFlaggedStructMappedNames
operator|.
name|end
argument_list|()
condition|;
name|flaggedStructIt
operator|++
control|)
block|{
name|TIntermTyped
modifier|*
name|structNode
init|=
name|flaggedStructIt
operator|->
name|first
decl_stmt|;
specifier|const
name|TString
modifier|&
name|mappedName
init|=
name|flaggedStructIt
operator|->
name|second
decl_stmt|;
specifier|const
name|TStructure
modifier|&
name|structure
init|=
operator|*
name|structNode
operator|->
name|getType
argument_list|()
operator|.
name|getStruct
argument_list|()
decl_stmt|;
specifier|const
name|TString
modifier|&
name|originalName
init|=
name|mFlaggedStructOriginalNames
index|[
name|structNode
index|]
decl_stmt|;
name|flaggedStructs
operator|+=
literal|"static "
operator|+
name|Decorate
argument_list|(
name|structure
operator|.
name|name
argument_list|()
argument_list|)
operator|+
literal|" "
operator|+
name|mappedName
operator|+
literal|" =\n"
expr_stmt|;
name|flaggedStructs
operator|+=
name|structInitializerString
argument_list|(
literal|0
argument_list|,
name|structure
argument_list|,
name|originalName
argument_list|)
expr_stmt|;
name|flaggedStructs
operator|+=
literal|"\n"
expr_stmt|;
block|}
for|for
control|(
name|ReferencedSymbols
operator|::
name|const_iterator
name|varying
init|=
name|mReferencedVaryings
operator|.
name|begin
argument_list|()
init|;
name|varying
operator|!=
name|mReferencedVaryings
operator|.
name|end
argument_list|()
condition|;
name|varying
operator|++
control|)
block|{
specifier|const
name|TType
modifier|&
name|type
init|=
name|varying
operator|->
name|second
operator|->
name|getType
argument_list|()
decl_stmt|;
specifier|const
name|TString
modifier|&
name|name
init|=
name|varying
operator|->
name|second
operator|->
name|getSymbol
argument_list|()
decl_stmt|;
comment|// Program linking depends on this exact format
name|varyings
operator|+=
literal|"static "
operator|+
name|InterpolationString
argument_list|(
name|type
operator|.
name|getQualifier
argument_list|()
argument_list|)
operator|+
literal|" "
operator|+
name|TypeString
argument_list|(
name|type
argument_list|)
operator|+
literal|" "
operator|+
name|Decorate
argument_list|(
name|name
argument_list|)
operator|+
name|ArrayString
argument_list|(
name|type
argument_list|)
operator|+
literal|" = "
operator|+
name|initializer
argument_list|(
name|type
argument_list|)
operator|+
literal|";\n"
expr_stmt|;
block|}
for|for
control|(
name|ReferencedSymbols
operator|::
name|const_iterator
name|attribute
init|=
name|mReferencedAttributes
operator|.
name|begin
argument_list|()
init|;
name|attribute
operator|!=
name|mReferencedAttributes
operator|.
name|end
argument_list|()
condition|;
name|attribute
operator|++
control|)
block|{
specifier|const
name|TType
modifier|&
name|type
init|=
name|attribute
operator|->
name|second
operator|->
name|getType
argument_list|()
decl_stmt|;
specifier|const
name|TString
modifier|&
name|name
init|=
name|attribute
operator|->
name|second
operator|->
name|getSymbol
argument_list|()
decl_stmt|;
name|attributes
operator|+=
literal|"static "
operator|+
name|TypeString
argument_list|(
name|type
argument_list|)
operator|+
literal|" "
operator|+
name|Decorate
argument_list|(
name|name
argument_list|)
operator|+
name|ArrayString
argument_list|(
name|type
argument_list|)
operator|+
literal|" = "
operator|+
name|initializer
argument_list|(
name|type
argument_list|)
operator|+
literal|";\n"
expr_stmt|;
block|}
name|out
operator|<<
name|mStructureHLSL
operator|->
name|structsHeader
argument_list|()
expr_stmt|;
name|out
operator|<<
name|mUniformHLSL
operator|->
name|uniformsHeader
argument_list|(
name|mOutputType
argument_list|,
name|mReferencedUniforms
argument_list|)
expr_stmt|;
name|out
operator|<<
name|mUniformHLSL
operator|->
name|interfaceBlocksHeader
argument_list|(
name|mReferencedInterfaceBlocks
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mEqualityFunctions
operator|.
name|empty
argument_list|()
condition|)
block|{
name|out
operator|<<
literal|"\n// Equality functions\n\n"
expr_stmt|;
for|for
control|(
name|auto
name|it
init|=
name|mEqualityFunctions
operator|.
name|cbegin
argument_list|()
init|;
name|it
operator|!=
name|mEqualityFunctions
operator|.
name|cend
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|out
operator|<<
operator|(
operator|*
name|it
operator|)
operator|->
name|functionDefinition
operator|<<
literal|"\n"
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|mArrayAssignmentFunctions
operator|.
name|empty
argument_list|()
condition|)
block|{
name|out
operator|<<
literal|"\n// Assignment functions\n\n"
expr_stmt|;
for|for
control|(
name|auto
name|it
init|=
name|mArrayAssignmentFunctions
operator|.
name|cbegin
argument_list|()
init|;
name|it
operator|!=
name|mArrayAssignmentFunctions
operator|.
name|cend
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|out
operator|<<
name|it
operator|->
name|functionDefinition
operator|<<
literal|"\n"
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mUsesDiscardRewriting
condition|)
block|{
name|out
operator|<<
literal|"#define ANGLE_USES_DISCARD_REWRITING\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesNestedBreak
condition|)
block|{
name|out
operator|<<
literal|"#define ANGLE_USES_NESTED_BREAK\n"
expr_stmt|;
block|}
if|if
condition|(
name|mRequiresIEEEStrictCompiling
condition|)
block|{
name|out
operator|<<
literal|"#define ANGLE_REQUIRES_IEEE_STRICT_COMPILING\n"
expr_stmt|;
block|}
name|out
operator|<<
literal|"#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n"
literal|"#define LOOP [loop]\n"
literal|"#define FLATTEN [flatten]\n"
literal|"#else\n"
literal|"#define LOOP\n"
literal|"#define FLATTEN\n"
literal|"#endif\n"
expr_stmt|;
if|if
condition|(
name|mShaderType
operator|==
name|GL_FRAGMENT_SHADER
condition|)
block|{
name|TExtensionBehavior
operator|::
name|const_iterator
name|iter
init|=
name|mExtensionBehavior
operator|.
name|find
argument_list|(
literal|"GL_EXT_draw_buffers"
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|usingMRTExtension
init|=
operator|(
name|iter
operator|!=
name|mExtensionBehavior
operator|.
name|end
argument_list|()
operator|&&
operator|(
name|iter
operator|->
name|second
operator|==
name|EBhEnable
operator|||
name|iter
operator|->
name|second
operator|==
name|EBhRequire
operator|)
operator|)
decl_stmt|;
name|out
operator|<<
literal|"// Varyings\n"
expr_stmt|;
name|out
operator|<<
name|varyings
expr_stmt|;
name|out
operator|<<
literal|"\n"
expr_stmt|;
if|if
condition|(
name|mShaderVersion
operator|>=
literal|300
condition|)
block|{
for|for
control|(
name|ReferencedSymbols
operator|::
name|const_iterator
name|outputVariableIt
init|=
name|mReferencedOutputVariables
operator|.
name|begin
argument_list|()
init|;
name|outputVariableIt
operator|!=
name|mReferencedOutputVariables
operator|.
name|end
argument_list|()
condition|;
name|outputVariableIt
operator|++
control|)
block|{
specifier|const
name|TString
modifier|&
name|variableName
init|=
name|outputVariableIt
operator|->
name|first
decl_stmt|;
specifier|const
name|TType
modifier|&
name|variableType
init|=
name|outputVariableIt
operator|->
name|second
operator|->
name|getType
argument_list|()
decl_stmt|;
name|out
operator|<<
literal|"static "
operator|+
name|TypeString
argument_list|(
name|variableType
argument_list|)
operator|+
literal|" out_"
operator|+
name|variableName
operator|+
name|ArrayString
argument_list|(
name|variableType
argument_list|)
operator|+
literal|" = "
operator|+
name|initializer
argument_list|(
name|variableType
argument_list|)
operator|+
literal|";\n"
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|const
name|unsigned
name|int
name|numColorValues
init|=
name|usingMRTExtension
condition|?
name|mNumRenderTargets
else|:
literal|1
decl_stmt|;
name|out
operator|<<
literal|"static float4 gl_Color["
operator|<<
name|numColorValues
operator|<<
literal|"] =\n"
literal|"{\n"
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numColorValues
condition|;
name|i
operator|++
control|)
block|{
name|out
operator|<<
literal|"    float4(0, 0, 0, 0)"
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|!=
name|numColorValues
condition|)
block|{
name|out
operator|<<
literal|","
expr_stmt|;
block|}
name|out
operator|<<
literal|"\n"
expr_stmt|;
block|}
name|out
operator|<<
literal|"};\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesFragDepth
condition|)
block|{
name|out
operator|<<
literal|"static float gl_Depth = 0.0;\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesFragCoord
condition|)
block|{
name|out
operator|<<
literal|"static float4 gl_FragCoord = float4(0, 0, 0, 0);\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesPointCoord
condition|)
block|{
name|out
operator|<<
literal|"static float2 gl_PointCoord = float2(0.5, 0.5);\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesFrontFacing
condition|)
block|{
name|out
operator|<<
literal|"static bool gl_FrontFacing = false;\n"
expr_stmt|;
block|}
name|out
operator|<<
literal|"\n"
expr_stmt|;
if|if
condition|(
name|mUsesDepthRange
condition|)
block|{
name|out
operator|<<
literal|"struct gl_DepthRangeParameters\n"
literal|"{\n"
literal|"    float near;\n"
literal|"    float far;\n"
literal|"    float diff;\n"
literal|"};\n"
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
name|mOutputType
operator|==
name|SH_HLSL11_OUTPUT
condition|)
block|{
name|out
operator|<<
literal|"cbuffer DriverConstants : register(b1)\n"
literal|"{\n"
expr_stmt|;
if|if
condition|(
name|mUsesDepthRange
condition|)
block|{
name|out
operator|<<
literal|"    float3 dx_DepthRange : packoffset(c0);\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesFragCoord
condition|)
block|{
name|out
operator|<<
literal|"    float4 dx_ViewCoords : packoffset(c1);\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesFragCoord
operator|||
name|mUsesFrontFacing
condition|)
block|{
name|out
operator|<<
literal|"    float3 dx_DepthFront : packoffset(c2);\n"
expr_stmt|;
block|}
name|out
operator|<<
literal|"};\n"
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mUsesDepthRange
condition|)
block|{
name|out
operator|<<
literal|"uniform float3 dx_DepthRange : register(c0);"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesFragCoord
condition|)
block|{
name|out
operator|<<
literal|"uniform float4 dx_ViewCoords : register(c1);\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesFragCoord
operator|||
name|mUsesFrontFacing
condition|)
block|{
name|out
operator|<<
literal|"uniform float3 dx_DepthFront : register(c2);\n"
expr_stmt|;
block|}
block|}
name|out
operator|<<
literal|"\n"
expr_stmt|;
if|if
condition|(
name|mUsesDepthRange
condition|)
block|{
name|out
operator|<<
literal|"static gl_DepthRangeParameters gl_DepthRange = {dx_DepthRange.x, dx_DepthRange.y, dx_DepthRange.z};\n"
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|flaggedStructs
operator|.
name|empty
argument_list|()
condition|)
block|{
name|out
operator|<<
literal|"// Std140 Structures accessed by value\n"
expr_stmt|;
name|out
operator|<<
literal|"\n"
expr_stmt|;
name|out
operator|<<
name|flaggedStructs
expr_stmt|;
name|out
operator|<<
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
name|usingMRTExtension
operator|&&
name|mNumRenderTargets
operator|>
literal|1
condition|)
block|{
name|out
operator|<<
literal|"#define GL_USES_MRT\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesFragColor
condition|)
block|{
name|out
operator|<<
literal|"#define GL_USES_FRAG_COLOR\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesFragData
condition|)
block|{
name|out
operator|<<
literal|"#define GL_USES_FRAG_DATA\n"
expr_stmt|;
block|}
block|}
else|else
comment|// Vertex shader
block|{
name|out
operator|<<
literal|"// Attributes\n"
expr_stmt|;
name|out
operator|<<
name|attributes
expr_stmt|;
name|out
operator|<<
literal|"\n"
literal|"static float4 gl_Position = float4(0, 0, 0, 0);\n"
expr_stmt|;
if|if
condition|(
name|mUsesPointSize
condition|)
block|{
name|out
operator|<<
literal|"static float gl_PointSize = float(1);\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesInstanceID
condition|)
block|{
name|out
operator|<<
literal|"static int gl_InstanceID;"
expr_stmt|;
block|}
name|out
operator|<<
literal|"\n"
literal|"// Varyings\n"
expr_stmt|;
name|out
operator|<<
name|varyings
expr_stmt|;
name|out
operator|<<
literal|"\n"
expr_stmt|;
if|if
condition|(
name|mUsesDepthRange
condition|)
block|{
name|out
operator|<<
literal|"struct gl_DepthRangeParameters\n"
literal|"{\n"
literal|"    float near;\n"
literal|"    float far;\n"
literal|"    float diff;\n"
literal|"};\n"
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
name|mOutputType
operator|==
name|SH_HLSL11_OUTPUT
condition|)
block|{
name|out
operator|<<
literal|"cbuffer DriverConstants : register(b1)\n"
literal|"{\n"
expr_stmt|;
if|if
condition|(
name|mUsesDepthRange
condition|)
block|{
name|out
operator|<<
literal|"    float3 dx_DepthRange : packoffset(c0);\n"
expr_stmt|;
block|}
comment|// dx_ViewAdjust and dx_ViewCoords will only be used in Feature Level 9 shaders.
comment|// However, we declare it for all shaders (including Feature Level 10+).
comment|// The bytecode is the same whether we declare it or not, since D3DCompiler removes it if it's unused.
name|out
operator|<<
literal|"    float4 dx_ViewAdjust : packoffset(c1);\n"
expr_stmt|;
name|out
operator|<<
literal|"    float2 dx_ViewCoords : packoffset(c2);\n"
expr_stmt|;
name|out
operator|<<
literal|"};\n"
literal|"\n"
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mUsesDepthRange
condition|)
block|{
name|out
operator|<<
literal|"uniform float3 dx_DepthRange : register(c0);\n"
expr_stmt|;
block|}
name|out
operator|<<
literal|"uniform float4 dx_ViewAdjust : register(c1);\n"
expr_stmt|;
name|out
operator|<<
literal|"uniform float2 dx_ViewCoords : register(c2);\n"
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesDepthRange
condition|)
block|{
name|out
operator|<<
literal|"static gl_DepthRangeParameters gl_DepthRange = {dx_DepthRange.x, dx_DepthRange.y, dx_DepthRange.z};\n"
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|flaggedStructs
operator|.
name|empty
argument_list|()
condition|)
block|{
name|out
operator|<<
literal|"// Std140 Structures accessed by value\n"
expr_stmt|;
name|out
operator|<<
literal|"\n"
expr_stmt|;
name|out
operator|<<
name|flaggedStructs
expr_stmt|;
name|out
operator|<<
literal|"\n"
expr_stmt|;
block|}
block|}
for|for
control|(
name|TextureFunctionSet
operator|::
name|const_iterator
name|textureFunction
init|=
name|mUsesTexture
operator|.
name|begin
argument_list|()
init|;
name|textureFunction
operator|!=
name|mUsesTexture
operator|.
name|end
argument_list|()
condition|;
name|textureFunction
operator|++
control|)
block|{
comment|// Return type
if|if
condition|(
name|textureFunction
operator|->
name|method
operator|==
name|TextureFunction
operator|::
name|SIZE
condition|)
block|{
switch|switch
condition|(
name|textureFunction
operator|->
name|sampler
condition|)
block|{
case|case
name|EbtSampler2D
case|:
name|out
operator|<<
literal|"int2 "
expr_stmt|;
break|break;
case|case
name|EbtSampler3D
case|:
name|out
operator|<<
literal|"int3 "
expr_stmt|;
break|break;
case|case
name|EbtSamplerCube
case|:
name|out
operator|<<
literal|"int2 "
expr_stmt|;
break|break;
case|case
name|EbtSampler2DArray
case|:
name|out
operator|<<
literal|"int3 "
expr_stmt|;
break|break;
case|case
name|EbtISampler2D
case|:
name|out
operator|<<
literal|"int2 "
expr_stmt|;
break|break;
case|case
name|EbtISampler3D
case|:
name|out
operator|<<
literal|"int3 "
expr_stmt|;
break|break;
case|case
name|EbtISamplerCube
case|:
name|out
operator|<<
literal|"int2 "
expr_stmt|;
break|break;
case|case
name|EbtISampler2DArray
case|:
name|out
operator|<<
literal|"int3 "
expr_stmt|;
break|break;
case|case
name|EbtUSampler2D
case|:
name|out
operator|<<
literal|"int2 "
expr_stmt|;
break|break;
case|case
name|EbtUSampler3D
case|:
name|out
operator|<<
literal|"int3 "
expr_stmt|;
break|break;
case|case
name|EbtUSamplerCube
case|:
name|out
operator|<<
literal|"int2 "
expr_stmt|;
break|break;
case|case
name|EbtUSampler2DArray
case|:
name|out
operator|<<
literal|"int3 "
expr_stmt|;
break|break;
case|case
name|EbtSampler2DShadow
case|:
name|out
operator|<<
literal|"int2 "
expr_stmt|;
break|break;
case|case
name|EbtSamplerCubeShadow
case|:
name|out
operator|<<
literal|"int2 "
expr_stmt|;
break|break;
case|case
name|EbtSampler2DArrayShadow
case|:
name|out
operator|<<
literal|"int3 "
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
else|else
comment|// Sampling function
block|{
switch|switch
condition|(
name|textureFunction
operator|->
name|sampler
condition|)
block|{
case|case
name|EbtSampler2D
case|:
name|out
operator|<<
literal|"float4 "
expr_stmt|;
break|break;
case|case
name|EbtSampler3D
case|:
name|out
operator|<<
literal|"float4 "
expr_stmt|;
break|break;
case|case
name|EbtSamplerCube
case|:
name|out
operator|<<
literal|"float4 "
expr_stmt|;
break|break;
case|case
name|EbtSampler2DArray
case|:
name|out
operator|<<
literal|"float4 "
expr_stmt|;
break|break;
case|case
name|EbtISampler2D
case|:
name|out
operator|<<
literal|"int4 "
expr_stmt|;
break|break;
case|case
name|EbtISampler3D
case|:
name|out
operator|<<
literal|"int4 "
expr_stmt|;
break|break;
case|case
name|EbtISamplerCube
case|:
name|out
operator|<<
literal|"int4 "
expr_stmt|;
break|break;
case|case
name|EbtISampler2DArray
case|:
name|out
operator|<<
literal|"int4 "
expr_stmt|;
break|break;
case|case
name|EbtUSampler2D
case|:
name|out
operator|<<
literal|"uint4 "
expr_stmt|;
break|break;
case|case
name|EbtUSampler3D
case|:
name|out
operator|<<
literal|"uint4 "
expr_stmt|;
break|break;
case|case
name|EbtUSamplerCube
case|:
name|out
operator|<<
literal|"uint4 "
expr_stmt|;
break|break;
case|case
name|EbtUSampler2DArray
case|:
name|out
operator|<<
literal|"uint4 "
expr_stmt|;
break|break;
case|case
name|EbtSampler2DShadow
case|:
name|out
operator|<<
literal|"float "
expr_stmt|;
break|break;
case|case
name|EbtSamplerCubeShadow
case|:
name|out
operator|<<
literal|"float "
expr_stmt|;
break|break;
case|case
name|EbtSampler2DArrayShadow
case|:
name|out
operator|<<
literal|"float "
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Function name
name|out
operator|<<
name|textureFunction
operator|->
name|name
argument_list|()
expr_stmt|;
comment|// Argument list
name|int
name|hlslCoords
init|=
literal|4
decl_stmt|;
if|if
condition|(
name|mOutputType
operator|==
name|SH_HLSL9_OUTPUT
condition|)
block|{
switch|switch
condition|(
name|textureFunction
operator|->
name|sampler
condition|)
block|{
case|case
name|EbtSampler2D
case|:
name|out
operator|<<
literal|"sampler2D s"
expr_stmt|;
name|hlslCoords
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|EbtSamplerCube
case|:
name|out
operator|<<
literal|"samplerCUBE s"
expr_stmt|;
name|hlslCoords
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|textureFunction
operator|->
name|method
condition|)
block|{
case|case
name|TextureFunction
operator|::
name|IMPLICIT
case|:
break|break;
case|case
name|TextureFunction
operator|::
name|BIAS
case|:
name|hlslCoords
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|TextureFunction
operator|::
name|LOD
case|:
name|hlslCoords
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|TextureFunction
operator|::
name|LOD0
case|:
name|hlslCoords
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|TextureFunction
operator|::
name|LOD0BIAS
case|:
name|hlslCoords
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mOutputType
operator|==
name|SH_HLSL11_OUTPUT
condition|)
block|{
switch|switch
condition|(
name|textureFunction
operator|->
name|sampler
condition|)
block|{
case|case
name|EbtSampler2D
case|:
name|out
operator|<<
literal|"Texture2D x, SamplerState s"
expr_stmt|;
name|hlslCoords
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|EbtSampler3D
case|:
name|out
operator|<<
literal|"Texture3D x, SamplerState s"
expr_stmt|;
name|hlslCoords
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|EbtSamplerCube
case|:
name|out
operator|<<
literal|"TextureCube x, SamplerState s"
expr_stmt|;
name|hlslCoords
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|EbtSampler2DArray
case|:
name|out
operator|<<
literal|"Texture2DArray x, SamplerState s"
expr_stmt|;
name|hlslCoords
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|EbtISampler2D
case|:
name|out
operator|<<
literal|"Texture2D<int4> x, SamplerState s"
expr_stmt|;
name|hlslCoords
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|EbtISampler3D
case|:
name|out
operator|<<
literal|"Texture3D<int4> x, SamplerState s"
expr_stmt|;
name|hlslCoords
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|EbtISamplerCube
case|:
name|out
operator|<<
literal|"Texture2DArray<int4> x, SamplerState s"
expr_stmt|;
name|hlslCoords
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|EbtISampler2DArray
case|:
name|out
operator|<<
literal|"Texture2DArray<int4> x, SamplerState s"
expr_stmt|;
name|hlslCoords
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|EbtUSampler2D
case|:
name|out
operator|<<
literal|"Texture2D<uint4> x, SamplerState s"
expr_stmt|;
name|hlslCoords
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|EbtUSampler3D
case|:
name|out
operator|<<
literal|"Texture3D<uint4> x, SamplerState s"
expr_stmt|;
name|hlslCoords
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|EbtUSamplerCube
case|:
name|out
operator|<<
literal|"Texture2DArray<uint4> x, SamplerState s"
expr_stmt|;
name|hlslCoords
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|EbtUSampler2DArray
case|:
name|out
operator|<<
literal|"Texture2DArray<uint4> x, SamplerState s"
expr_stmt|;
name|hlslCoords
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|EbtSampler2DShadow
case|:
name|out
operator|<<
literal|"Texture2D x, SamplerComparisonState s"
expr_stmt|;
name|hlslCoords
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|EbtSamplerCubeShadow
case|:
name|out
operator|<<
literal|"TextureCube x, SamplerComparisonState s"
expr_stmt|;
name|hlslCoords
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|EbtSampler2DArrayShadow
case|:
name|out
operator|<<
literal|"Texture2DArray x, SamplerComparisonState s"
expr_stmt|;
name|hlslCoords
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
if|if
condition|(
name|textureFunction
operator|->
name|method
operator|==
name|TextureFunction
operator|::
name|FETCH
condition|)
comment|// Integer coordinates
block|{
switch|switch
condition|(
name|textureFunction
operator|->
name|coords
condition|)
block|{
case|case
literal|2
case|:
name|out
operator|<<
literal|", int2 t"
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|out
operator|<<
literal|", int3 t"
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
else|else
comment|// Floating-point coordinates (except textureSize)
block|{
switch|switch
condition|(
name|textureFunction
operator|->
name|coords
condition|)
block|{
case|case
literal|1
case|:
name|out
operator|<<
literal|", int lod"
expr_stmt|;
break|break;
comment|// textureSize()
case|case
literal|2
case|:
name|out
operator|<<
literal|", float2 t"
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|out
operator|<<
literal|", float3 t"
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|out
operator|<<
literal|", float4 t"
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|textureFunction
operator|->
name|method
operator|==
name|TextureFunction
operator|::
name|GRAD
condition|)
block|{
switch|switch
condition|(
name|textureFunction
operator|->
name|sampler
condition|)
block|{
case|case
name|EbtSampler2D
case|:
case|case
name|EbtISampler2D
case|:
case|case
name|EbtUSampler2D
case|:
case|case
name|EbtSampler2DArray
case|:
case|case
name|EbtISampler2DArray
case|:
case|case
name|EbtUSampler2DArray
case|:
case|case
name|EbtSampler2DShadow
case|:
case|case
name|EbtSampler2DArrayShadow
case|:
name|out
operator|<<
literal|", float2 ddx, float2 ddy"
expr_stmt|;
break|break;
case|case
name|EbtSampler3D
case|:
case|case
name|EbtISampler3D
case|:
case|case
name|EbtUSampler3D
case|:
case|case
name|EbtSamplerCube
case|:
case|case
name|EbtISamplerCube
case|:
case|case
name|EbtUSamplerCube
case|:
case|case
name|EbtSamplerCubeShadow
case|:
name|out
operator|<<
literal|", float3 ddx, float3 ddy"
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|textureFunction
operator|->
name|method
condition|)
block|{
case|case
name|TextureFunction
operator|::
name|IMPLICIT
case|:
break|break;
case|case
name|TextureFunction
operator|::
name|BIAS
case|:
break|break;
comment|// Comes after the offset parameter
case|case
name|TextureFunction
operator|::
name|LOD
case|:
name|out
operator|<<
literal|", float lod"
expr_stmt|;
break|break;
case|case
name|TextureFunction
operator|::
name|LOD0
case|:
break|break;
case|case
name|TextureFunction
operator|::
name|LOD0BIAS
case|:
break|break;
comment|// Comes after the offset parameter
case|case
name|TextureFunction
operator|::
name|SIZE
case|:
break|break;
case|case
name|TextureFunction
operator|::
name|FETCH
case|:
name|out
operator|<<
literal|", int mip"
expr_stmt|;
break|break;
case|case
name|TextureFunction
operator|::
name|GRAD
case|:
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|textureFunction
operator|->
name|offset
condition|)
block|{
switch|switch
condition|(
name|textureFunction
operator|->
name|sampler
condition|)
block|{
case|case
name|EbtSampler2D
case|:
name|out
operator|<<
literal|", int2 offset"
expr_stmt|;
break|break;
case|case
name|EbtSampler3D
case|:
name|out
operator|<<
literal|", int3 offset"
expr_stmt|;
break|break;
case|case
name|EbtSampler2DArray
case|:
name|out
operator|<<
literal|", int2 offset"
expr_stmt|;
break|break;
case|case
name|EbtISampler2D
case|:
name|out
operator|<<
literal|", int2 offset"
expr_stmt|;
break|break;
case|case
name|EbtISampler3D
case|:
name|out
operator|<<
literal|", int3 offset"
expr_stmt|;
break|break;
case|case
name|EbtISampler2DArray
case|:
name|out
operator|<<
literal|", int2 offset"
expr_stmt|;
break|break;
case|case
name|EbtUSampler2D
case|:
name|out
operator|<<
literal|", int2 offset"
expr_stmt|;
break|break;
case|case
name|EbtUSampler3D
case|:
name|out
operator|<<
literal|", int3 offset"
expr_stmt|;
break|break;
case|case
name|EbtUSampler2DArray
case|:
name|out
operator|<<
literal|", int2 offset"
expr_stmt|;
break|break;
case|case
name|EbtSampler2DShadow
case|:
name|out
operator|<<
literal|", int2 offset"
expr_stmt|;
break|break;
case|case
name|EbtSampler2DArrayShadow
case|:
name|out
operator|<<
literal|", int2 offset"
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|textureFunction
operator|->
name|method
operator|==
name|TextureFunction
operator|::
name|BIAS
operator|||
name|textureFunction
operator|->
name|method
operator|==
name|TextureFunction
operator|::
name|LOD0BIAS
condition|)
block|{
name|out
operator|<<
literal|", float bias"
expr_stmt|;
block|}
name|out
operator|<<
literal|")\n"
literal|"{\n"
expr_stmt|;
if|if
condition|(
name|textureFunction
operator|->
name|method
operator|==
name|TextureFunction
operator|::
name|SIZE
condition|)
block|{
if|if
condition|(
name|IsSampler2D
argument_list|(
name|textureFunction
operator|->
name|sampler
argument_list|)
operator|||
name|IsSamplerCube
argument_list|(
name|textureFunction
operator|->
name|sampler
argument_list|)
condition|)
block|{
if|if
condition|(
name|IsSamplerArray
argument_list|(
name|textureFunction
operator|->
name|sampler
argument_list|)
condition|)
block|{
name|out
operator|<<
literal|"    uint width; uint height; uint layers; uint numberOfLevels;\n"
literal|"    x.GetDimensions(lod, width, height, layers, numberOfLevels);\n"
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
literal|"    uint width; uint height; uint numberOfLevels;\n"
literal|"    x.GetDimensions(lod, width, height, numberOfLevels);\n"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|IsSampler3D
argument_list|(
name|textureFunction
operator|->
name|sampler
argument_list|)
condition|)
block|{
name|out
operator|<<
literal|"    uint width; uint height; uint depth; uint numberOfLevels;\n"
literal|"    x.GetDimensions(lod, width, height, depth, numberOfLevels);\n"
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|textureFunction
operator|->
name|sampler
condition|)
block|{
case|case
name|EbtSampler2D
case|:
name|out
operator|<<
literal|"    return int2(width, height);"
expr_stmt|;
break|break;
case|case
name|EbtSampler3D
case|:
name|out
operator|<<
literal|"    return int3(width, height, depth);"
expr_stmt|;
break|break;
case|case
name|EbtSamplerCube
case|:
name|out
operator|<<
literal|"    return int2(width, height);"
expr_stmt|;
break|break;
case|case
name|EbtSampler2DArray
case|:
name|out
operator|<<
literal|"    return int3(width, height, layers);"
expr_stmt|;
break|break;
case|case
name|EbtISampler2D
case|:
name|out
operator|<<
literal|"    return int2(width, height);"
expr_stmt|;
break|break;
case|case
name|EbtISampler3D
case|:
name|out
operator|<<
literal|"    return int3(width, height, depth);"
expr_stmt|;
break|break;
case|case
name|EbtISamplerCube
case|:
name|out
operator|<<
literal|"    return int2(width, height);"
expr_stmt|;
break|break;
case|case
name|EbtISampler2DArray
case|:
name|out
operator|<<
literal|"    return int3(width, height, layers);"
expr_stmt|;
break|break;
case|case
name|EbtUSampler2D
case|:
name|out
operator|<<
literal|"    return int2(width, height);"
expr_stmt|;
break|break;
case|case
name|EbtUSampler3D
case|:
name|out
operator|<<
literal|"    return int3(width, height, depth);"
expr_stmt|;
break|break;
case|case
name|EbtUSamplerCube
case|:
name|out
operator|<<
literal|"    return int2(width, height);"
expr_stmt|;
break|break;
case|case
name|EbtUSampler2DArray
case|:
name|out
operator|<<
literal|"    return int3(width, height, layers);"
expr_stmt|;
break|break;
case|case
name|EbtSampler2DShadow
case|:
name|out
operator|<<
literal|"    return int2(width, height);"
expr_stmt|;
break|break;
case|case
name|EbtSamplerCubeShadow
case|:
name|out
operator|<<
literal|"    return int2(width, height);"
expr_stmt|;
break|break;
case|case
name|EbtSampler2DArrayShadow
case|:
name|out
operator|<<
literal|"    return int3(width, height, layers);"
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|IsIntegerSampler
argument_list|(
name|textureFunction
operator|->
name|sampler
argument_list|)
operator|&&
name|IsSamplerCube
argument_list|(
name|textureFunction
operator|->
name|sampler
argument_list|)
condition|)
block|{
name|out
operator|<<
literal|"    float width; float height; float layers; float levels;\n"
expr_stmt|;
name|out
operator|<<
literal|"    uint mip = 0;\n"
expr_stmt|;
name|out
operator|<<
literal|"    x.GetDimensions(mip, width, height, layers, levels);\n"
expr_stmt|;
name|out
operator|<<
literal|"    bool xMajor = abs(t.x)> abs(t.y)&& abs(t.x)> abs(t.z);\n"
expr_stmt|;
name|out
operator|<<
literal|"    bool yMajor = abs(t.y)> abs(t.z)&& abs(t.y)> abs(t.x);\n"
expr_stmt|;
name|out
operator|<<
literal|"    bool zMajor = abs(t.z)> abs(t.x)&& abs(t.z)> abs(t.y);\n"
expr_stmt|;
name|out
operator|<<
literal|"    bool negative = (xMajor&& t.x< 0.0f) || (yMajor&& t.y< 0.0f) || (zMajor&& t.z< 0.0f);\n"
expr_stmt|;
comment|// FACE_POSITIVE_X = 000b
comment|// FACE_NEGATIVE_X = 001b
comment|// FACE_POSITIVE_Y = 010b
comment|// FACE_NEGATIVE_Y = 011b
comment|// FACE_POSITIVE_Z = 100b
comment|// FACE_NEGATIVE_Z = 101b
name|out
operator|<<
literal|"    int face = (int)negative + (int)yMajor * 2 + (int)zMajor * 4;\n"
expr_stmt|;
name|out
operator|<<
literal|"    float u = xMajor ? -t.z : (yMajor&& t.y< 0.0f ? -t.x : t.x);\n"
expr_stmt|;
name|out
operator|<<
literal|"    float v = yMajor ? t.z : (negative ? t.y : -t.y);\n"
expr_stmt|;
name|out
operator|<<
literal|"    float m = xMajor ? t.x : (yMajor ? t.y : t.z);\n"
expr_stmt|;
name|out
operator|<<
literal|"    t.x = (u * 0.5f / m) + 0.5f;\n"
expr_stmt|;
name|out
operator|<<
literal|"    t.y = (v * 0.5f / m) + 0.5f;\n"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IsIntegerSampler
argument_list|(
name|textureFunction
operator|->
name|sampler
argument_list|)
operator|&&
name|textureFunction
operator|->
name|method
operator|!=
name|TextureFunction
operator|::
name|FETCH
condition|)
block|{
if|if
condition|(
name|IsSampler2D
argument_list|(
name|textureFunction
operator|->
name|sampler
argument_list|)
condition|)
block|{
if|if
condition|(
name|IsSamplerArray
argument_list|(
name|textureFunction
operator|->
name|sampler
argument_list|)
condition|)
block|{
name|out
operator|<<
literal|"    float width; float height; float layers; float levels;\n"
expr_stmt|;
if|if
condition|(
name|textureFunction
operator|->
name|method
operator|==
name|TextureFunction
operator|::
name|LOD0
condition|)
block|{
name|out
operator|<<
literal|"    uint mip = 0;\n"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|textureFunction
operator|->
name|method
operator|==
name|TextureFunction
operator|::
name|LOD0BIAS
condition|)
block|{
name|out
operator|<<
literal|"    uint mip = bias;\n"
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|textureFunction
operator|->
name|method
operator|==
name|TextureFunction
operator|::
name|IMPLICIT
operator|||
name|textureFunction
operator|->
name|method
operator|==
name|TextureFunction
operator|::
name|BIAS
condition|)
block|{
name|out
operator|<<
literal|"    x.GetDimensions(0, width, height, layers, levels);\n"
literal|"    float2 tSized = float2(t.x * width, t.y * height);\n"
literal|"    float dx = length(ddx(tSized));\n"
literal|"    float dy = length(ddy(tSized));\n"
literal|"    float lod = log2(max(dx, dy));\n"
expr_stmt|;
if|if
condition|(
name|textureFunction
operator|->
name|method
operator|==
name|TextureFunction
operator|::
name|BIAS
condition|)
block|{
name|out
operator|<<
literal|"    lod += bias;\n"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|textureFunction
operator|->
name|method
operator|==
name|TextureFunction
operator|::
name|GRAD
condition|)
block|{
name|out
operator|<<
literal|"    x.GetDimensions(0, width, height, layers, levels);\n"
literal|"    float lod = log2(max(length(ddx), length(ddy)));\n"
expr_stmt|;
block|}
name|out
operator|<<
literal|"    uint mip = uint(min(max(round(lod), 0), levels - 1));\n"
expr_stmt|;
block|}
name|out
operator|<<
literal|"    x.GetDimensions(mip, width, height, layers, levels);\n"
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
literal|"    float width; float height; float levels;\n"
expr_stmt|;
if|if
condition|(
name|textureFunction
operator|->
name|method
operator|==
name|TextureFunction
operator|::
name|LOD0
condition|)
block|{
name|out
operator|<<
literal|"    uint mip = 0;\n"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|textureFunction
operator|->
name|method
operator|==
name|TextureFunction
operator|::
name|LOD0BIAS
condition|)
block|{
name|out
operator|<<
literal|"    uint mip = bias;\n"
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|textureFunction
operator|->
name|method
operator|==
name|TextureFunction
operator|::
name|IMPLICIT
operator|||
name|textureFunction
operator|->
name|method
operator|==
name|TextureFunction
operator|::
name|BIAS
condition|)
block|{
name|out
operator|<<
literal|"    x.GetDimensions(0, width, height, levels);\n"
literal|"    float2 tSized = float2(t.x * width, t.y * height);\n"
literal|"    float dx = length(ddx(tSized));\n"
literal|"    float dy = length(ddy(tSized));\n"
literal|"    float lod = log2(max(dx, dy));\n"
expr_stmt|;
if|if
condition|(
name|textureFunction
operator|->
name|method
operator|==
name|TextureFunction
operator|::
name|BIAS
condition|)
block|{
name|out
operator|<<
literal|"    lod += bias;\n"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|textureFunction
operator|->
name|method
operator|==
name|TextureFunction
operator|::
name|LOD
condition|)
block|{
name|out
operator|<<
literal|"    x.GetDimensions(0, width, height, levels);\n"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|textureFunction
operator|->
name|method
operator|==
name|TextureFunction
operator|::
name|GRAD
condition|)
block|{
name|out
operator|<<
literal|"    x.GetDimensions(0, width, height, levels);\n"
literal|"    float lod = log2(max(length(ddx), length(ddy)));\n"
expr_stmt|;
block|}
name|out
operator|<<
literal|"    uint mip = uint(min(max(round(lod), 0), levels - 1));\n"
expr_stmt|;
block|}
name|out
operator|<<
literal|"    x.GetDimensions(mip, width, height, levels);\n"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|IsSampler3D
argument_list|(
name|textureFunction
operator|->
name|sampler
argument_list|)
condition|)
block|{
name|out
operator|<<
literal|"    float width; float height; float depth; float levels;\n"
expr_stmt|;
if|if
condition|(
name|textureFunction
operator|->
name|method
operator|==
name|TextureFunction
operator|::
name|LOD0
condition|)
block|{
name|out
operator|<<
literal|"    uint mip = 0;\n"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|textureFunction
operator|->
name|method
operator|==
name|TextureFunction
operator|::
name|LOD0BIAS
condition|)
block|{
name|out
operator|<<
literal|"    uint mip = bias;\n"
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|textureFunction
operator|->
name|method
operator|==
name|TextureFunction
operator|::
name|IMPLICIT
operator|||
name|textureFunction
operator|->
name|method
operator|==
name|TextureFunction
operator|::
name|BIAS
condition|)
block|{
name|out
operator|<<
literal|"    x.GetDimensions(0, width, height, depth, levels);\n"
literal|"    float3 tSized = float3(t.x * width, t.y * height, t.z * depth);\n"
literal|"    float dx = length(ddx(tSized));\n"
literal|"    float dy = length(ddy(tSized));\n"
literal|"    float lod = log2(max(dx, dy));\n"
expr_stmt|;
if|if
condition|(
name|textureFunction
operator|->
name|method
operator|==
name|TextureFunction
operator|::
name|BIAS
condition|)
block|{
name|out
operator|<<
literal|"    lod += bias;\n"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|textureFunction
operator|->
name|method
operator|==
name|TextureFunction
operator|::
name|GRAD
condition|)
block|{
name|out
operator|<<
literal|"    x.GetDimensions(0, width, height, depth, levels);\n"
literal|"    float lod = log2(max(length(ddx), length(ddy)));\n"
expr_stmt|;
block|}
name|out
operator|<<
literal|"    uint mip = uint(min(max(round(lod), 0), levels - 1));\n"
expr_stmt|;
block|}
name|out
operator|<<
literal|"    x.GetDimensions(mip, width, height, depth, levels);\n"
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
name|out
operator|<<
literal|"    return "
expr_stmt|;
comment|// HLSL intrinsic
if|if
condition|(
name|mOutputType
operator|==
name|SH_HLSL9_OUTPUT
condition|)
block|{
switch|switch
condition|(
name|textureFunction
operator|->
name|sampler
condition|)
block|{
case|case
name|EbtSampler2D
case|:
name|out
operator|<<
literal|"tex2D"
expr_stmt|;
break|break;
case|case
name|EbtSamplerCube
case|:
name|out
operator|<<
literal|"texCUBE"
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|textureFunction
operator|->
name|method
condition|)
block|{
case|case
name|TextureFunction
operator|::
name|IMPLICIT
case|:
name|out
operator|<<
literal|"(s, "
expr_stmt|;
break|break;
case|case
name|TextureFunction
operator|::
name|BIAS
case|:
name|out
operator|<<
literal|"bias(s, "
expr_stmt|;
break|break;
case|case
name|TextureFunction
operator|::
name|LOD
case|:
name|out
operator|<<
literal|"lod(s, "
expr_stmt|;
break|break;
case|case
name|TextureFunction
operator|::
name|LOD0
case|:
name|out
operator|<<
literal|"lod(s, "
expr_stmt|;
break|break;
case|case
name|TextureFunction
operator|::
name|LOD0BIAS
case|:
name|out
operator|<<
literal|"lod(s, "
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mOutputType
operator|==
name|SH_HLSL11_OUTPUT
condition|)
block|{
if|if
condition|(
name|textureFunction
operator|->
name|method
operator|==
name|TextureFunction
operator|::
name|GRAD
condition|)
block|{
if|if
condition|(
name|IsIntegerSampler
argument_list|(
name|textureFunction
operator|->
name|sampler
argument_list|)
condition|)
block|{
name|out
operator|<<
literal|"x.Load("
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IsShadowSampler
argument_list|(
name|textureFunction
operator|->
name|sampler
argument_list|)
condition|)
block|{
name|out
operator|<<
literal|"x.SampleCmpLevelZero(s, "
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
literal|"x.SampleGrad(s, "
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|IsIntegerSampler
argument_list|(
name|textureFunction
operator|->
name|sampler
argument_list|)
operator|||
name|textureFunction
operator|->
name|method
operator|==
name|TextureFunction
operator|::
name|FETCH
condition|)
block|{
name|out
operator|<<
literal|"x.Load("
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IsShadowSampler
argument_list|(
name|textureFunction
operator|->
name|sampler
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|textureFunction
operator|->
name|method
condition|)
block|{
case|case
name|TextureFunction
operator|::
name|IMPLICIT
case|:
name|out
operator|<<
literal|"x.SampleCmp(s, "
expr_stmt|;
break|break;
case|case
name|TextureFunction
operator|::
name|BIAS
case|:
name|out
operator|<<
literal|"x.SampleCmp(s, "
expr_stmt|;
break|break;
case|case
name|TextureFunction
operator|::
name|LOD
case|:
name|out
operator|<<
literal|"x.SampleCmp(s, "
expr_stmt|;
break|break;
case|case
name|TextureFunction
operator|::
name|LOD0
case|:
name|out
operator|<<
literal|"x.SampleCmpLevelZero(s, "
expr_stmt|;
break|break;
case|case
name|TextureFunction
operator|::
name|LOD0BIAS
case|:
name|out
operator|<<
literal|"x.SampleCmpLevelZero(s, "
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|textureFunction
operator|->
name|method
condition|)
block|{
case|case
name|TextureFunction
operator|::
name|IMPLICIT
case|:
name|out
operator|<<
literal|"x.Sample(s, "
expr_stmt|;
break|break;
case|case
name|TextureFunction
operator|::
name|BIAS
case|:
name|out
operator|<<
literal|"x.SampleBias(s, "
expr_stmt|;
break|break;
case|case
name|TextureFunction
operator|::
name|LOD
case|:
name|out
operator|<<
literal|"x.SampleLevel(s, "
expr_stmt|;
break|break;
case|case
name|TextureFunction
operator|::
name|LOD0
case|:
name|out
operator|<<
literal|"x.SampleLevel(s, "
expr_stmt|;
break|break;
case|case
name|TextureFunction
operator|::
name|LOD0BIAS
case|:
name|out
operator|<<
literal|"x.SampleLevel(s, "
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
comment|// Integer sampling requires integer addresses
name|TString
name|addressx
init|=
literal|""
decl_stmt|;
name|TString
name|addressy
init|=
literal|""
decl_stmt|;
name|TString
name|addressz
init|=
literal|""
decl_stmt|;
name|TString
name|close
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|IsIntegerSampler
argument_list|(
name|textureFunction
operator|->
name|sampler
argument_list|)
operator|||
name|textureFunction
operator|->
name|method
operator|==
name|TextureFunction
operator|::
name|FETCH
condition|)
block|{
switch|switch
condition|(
name|hlslCoords
condition|)
block|{
case|case
literal|2
case|:
name|out
operator|<<
literal|"int3("
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|out
operator|<<
literal|"int4("
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
comment|// Convert from normalized floating-point to integer
if|if
condition|(
name|textureFunction
operator|->
name|method
operator|!=
name|TextureFunction
operator|::
name|FETCH
condition|)
block|{
name|addressx
operator|=
literal|"int(floor(width * frac(("
expr_stmt|;
name|addressy
operator|=
literal|"int(floor(height * frac(("
expr_stmt|;
if|if
condition|(
name|IsSamplerArray
argument_list|(
name|textureFunction
operator|->
name|sampler
argument_list|)
condition|)
block|{
name|addressz
operator|=
literal|"int(max(0, min(layers - 1, floor(0.5 + "
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IsSamplerCube
argument_list|(
name|textureFunction
operator|->
name|sampler
argument_list|)
condition|)
block|{
name|addressz
operator|=
literal|"(((("
expr_stmt|;
block|}
else|else
block|{
name|addressz
operator|=
literal|"int(floor(depth * frac(("
expr_stmt|;
block|}
name|close
operator|=
literal|"))))"
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|hlslCoords
condition|)
block|{
case|case
literal|2
case|:
name|out
operator|<<
literal|"float2("
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|out
operator|<<
literal|"float3("
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|out
operator|<<
literal|"float4("
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
name|TString
name|proj
init|=
literal|""
decl_stmt|;
comment|// Only used for projected textures
if|if
condition|(
name|textureFunction
operator|->
name|proj
condition|)
block|{
switch|switch
condition|(
name|textureFunction
operator|->
name|coords
condition|)
block|{
case|case
literal|3
case|:
name|proj
operator|=
literal|" / t.z"
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|proj
operator|=
literal|" / t.w"
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
name|out
operator|<<
name|addressx
operator|+
operator|(
literal|"t.x"
operator|+
name|proj
operator|)
operator|+
name|close
operator|+
literal|", "
operator|+
name|addressy
operator|+
operator|(
literal|"t.y"
operator|+
name|proj
operator|)
operator|+
name|close
expr_stmt|;
if|if
condition|(
name|mOutputType
operator|==
name|SH_HLSL9_OUTPUT
condition|)
block|{
if|if
condition|(
name|hlslCoords
operator|>=
literal|3
condition|)
block|{
if|if
condition|(
name|textureFunction
operator|->
name|coords
operator|<
literal|3
condition|)
block|{
name|out
operator|<<
literal|", 0"
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
literal|", t.z"
operator|+
name|proj
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hlslCoords
operator|==
literal|4
condition|)
block|{
switch|switch
condition|(
name|textureFunction
operator|->
name|method
condition|)
block|{
case|case
name|TextureFunction
operator|::
name|BIAS
case|:
name|out
operator|<<
literal|", bias"
expr_stmt|;
break|break;
case|case
name|TextureFunction
operator|::
name|LOD
case|:
name|out
operator|<<
literal|", lod"
expr_stmt|;
break|break;
case|case
name|TextureFunction
operator|::
name|LOD0
case|:
name|out
operator|<<
literal|", 0"
expr_stmt|;
break|break;
case|case
name|TextureFunction
operator|::
name|LOD0BIAS
case|:
name|out
operator|<<
literal|", bias"
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
name|out
operator|<<
literal|"));\n"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mOutputType
operator|==
name|SH_HLSL11_OUTPUT
condition|)
block|{
if|if
condition|(
name|hlslCoords
operator|>=
literal|3
condition|)
block|{
if|if
condition|(
name|IsIntegerSampler
argument_list|(
name|textureFunction
operator|->
name|sampler
argument_list|)
operator|&&
name|IsSamplerCube
argument_list|(
name|textureFunction
operator|->
name|sampler
argument_list|)
condition|)
block|{
name|out
operator|<<
literal|", face"
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
literal|", "
operator|+
name|addressz
operator|+
operator|(
literal|"t.z"
operator|+
name|proj
operator|)
operator|+
name|close
expr_stmt|;
block|}
block|}
if|if
condition|(
name|textureFunction
operator|->
name|method
operator|==
name|TextureFunction
operator|::
name|GRAD
condition|)
block|{
if|if
condition|(
name|IsIntegerSampler
argument_list|(
name|textureFunction
operator|->
name|sampler
argument_list|)
condition|)
block|{
name|out
operator|<<
literal|", mip)"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IsShadowSampler
argument_list|(
name|textureFunction
operator|->
name|sampler
argument_list|)
condition|)
block|{
comment|// Compare value
if|if
condition|(
name|textureFunction
operator|->
name|proj
condition|)
block|{
comment|// According to ESSL 3.00.4 sec 8.8 p95 on textureProj:
comment|// The resulting third component of P' in the shadow forms is used as Dref
name|out
operator|<<
literal|"), t.z"
operator|<<
name|proj
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|textureFunction
operator|->
name|coords
condition|)
block|{
case|case
literal|3
case|:
name|out
operator|<<
literal|"), t.z"
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|out
operator|<<
literal|"), t.w"
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|out
operator|<<
literal|"), ddx, ddy"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|IsIntegerSampler
argument_list|(
name|textureFunction
operator|->
name|sampler
argument_list|)
operator|||
name|textureFunction
operator|->
name|method
operator|==
name|TextureFunction
operator|::
name|FETCH
condition|)
block|{
name|out
operator|<<
literal|", mip)"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IsShadowSampler
argument_list|(
name|textureFunction
operator|->
name|sampler
argument_list|)
condition|)
block|{
comment|// Compare value
if|if
condition|(
name|textureFunction
operator|->
name|proj
condition|)
block|{
comment|// According to ESSL 3.00.4 sec 8.8 p95 on textureProj:
comment|// The resulting third component of P' in the shadow forms is used as Dref
name|out
operator|<<
literal|"), t.z"
operator|<<
name|proj
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|textureFunction
operator|->
name|coords
condition|)
block|{
case|case
literal|3
case|:
name|out
operator|<<
literal|"), t.z"
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|out
operator|<<
literal|"), t.w"
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|textureFunction
operator|->
name|method
condition|)
block|{
case|case
name|TextureFunction
operator|::
name|IMPLICIT
case|:
name|out
operator|<<
literal|")"
expr_stmt|;
break|break;
case|case
name|TextureFunction
operator|::
name|BIAS
case|:
name|out
operator|<<
literal|"), bias"
expr_stmt|;
break|break;
case|case
name|TextureFunction
operator|::
name|LOD
case|:
name|out
operator|<<
literal|"), lod"
expr_stmt|;
break|break;
case|case
name|TextureFunction
operator|::
name|LOD0
case|:
name|out
operator|<<
literal|"), 0"
expr_stmt|;
break|break;
case|case
name|TextureFunction
operator|::
name|LOD0BIAS
case|:
name|out
operator|<<
literal|"), bias"
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|textureFunction
operator|->
name|offset
condition|)
block|{
name|out
operator|<<
literal|", offset"
expr_stmt|;
block|}
name|out
operator|<<
literal|");"
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
name|out
operator|<<
literal|"\n"
literal|"}\n"
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesFragCoord
condition|)
block|{
name|out
operator|<<
literal|"#define GL_USES_FRAG_COORD\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesPointCoord
condition|)
block|{
name|out
operator|<<
literal|"#define GL_USES_POINT_COORD\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesFrontFacing
condition|)
block|{
name|out
operator|<<
literal|"#define GL_USES_FRONT_FACING\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesPointSize
condition|)
block|{
name|out
operator|<<
literal|"#define GL_USES_POINT_SIZE\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesFragDepth
condition|)
block|{
name|out
operator|<<
literal|"#define GL_USES_FRAG_DEPTH\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesDepthRange
condition|)
block|{
name|out
operator|<<
literal|"#define GL_USES_DEPTH_RANGE\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesXor
condition|)
block|{
name|out
operator|<<
literal|"bool xor(bool p, bool q)\n"
literal|"{\n"
literal|"    return (p || q)&& !(p&& q);\n"
literal|"}\n"
literal|"\n"
expr_stmt|;
block|}
name|builtInFunctionEmulator
operator|->
name|OutputEmulatedFunctions
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
DECL|function|visitSymbol
name|void
name|OutputHLSL
operator|::
name|visitSymbol
parameter_list|(
name|TIntermSymbol
modifier|*
name|node
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|getInfoSink
argument_list|()
decl_stmt|;
comment|// Handle accessing std140 structs by value
if|if
condition|(
name|mFlaggedStructMappedNames
operator|.
name|count
argument_list|(
name|node
argument_list|)
operator|>
literal|0
condition|)
block|{
name|out
operator|<<
name|mFlaggedStructMappedNames
index|[
name|node
index|]
expr_stmt|;
return|return;
block|}
name|TString
name|name
init|=
name|node
operator|->
name|getSymbol
argument_list|()
decl_stmt|;
if|if
condition|(
name|name
operator|==
literal|"gl_DepthRange"
condition|)
block|{
name|mUsesDepthRange
operator|=
literal|true
expr_stmt|;
name|out
operator|<<
name|name
expr_stmt|;
block|}
else|else
block|{
name|TQualifier
name|qualifier
init|=
name|node
operator|->
name|getQualifier
argument_list|()
decl_stmt|;
if|if
condition|(
name|qualifier
operator|==
name|EvqUniform
condition|)
block|{
specifier|const
name|TType
modifier|&
name|nodeType
init|=
name|node
operator|->
name|getType
argument_list|()
decl_stmt|;
specifier|const
name|TInterfaceBlock
modifier|*
name|interfaceBlock
init|=
name|nodeType
operator|.
name|getInterfaceBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|interfaceBlock
condition|)
block|{
name|mReferencedInterfaceBlocks
index|[
name|interfaceBlock
operator|->
name|name
argument_list|()
index|]
operator|=
name|node
expr_stmt|;
block|}
else|else
block|{
name|mReferencedUniforms
index|[
name|name
index|]
operator|=
name|node
expr_stmt|;
block|}
name|out
operator|<<
name|DecorateUniform
argument_list|(
name|name
argument_list|,
name|nodeType
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qualifier
operator|==
name|EvqAttribute
operator|||
name|qualifier
operator|==
name|EvqVertexIn
condition|)
block|{
name|mReferencedAttributes
index|[
name|name
index|]
operator|=
name|node
expr_stmt|;
name|out
operator|<<
name|Decorate
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IsVarying
argument_list|(
name|qualifier
argument_list|)
condition|)
block|{
name|mReferencedVaryings
index|[
name|name
index|]
operator|=
name|node
expr_stmt|;
name|out
operator|<<
name|Decorate
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qualifier
operator|==
name|EvqFragmentOut
condition|)
block|{
name|mReferencedOutputVariables
index|[
name|name
index|]
operator|=
name|node
expr_stmt|;
name|out
operator|<<
literal|"out_"
operator|<<
name|name
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qualifier
operator|==
name|EvqFragColor
condition|)
block|{
name|out
operator|<<
literal|"gl_Color[0]"
expr_stmt|;
name|mUsesFragColor
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qualifier
operator|==
name|EvqFragData
condition|)
block|{
name|out
operator|<<
literal|"gl_Color"
expr_stmt|;
name|mUsesFragData
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qualifier
operator|==
name|EvqFragCoord
condition|)
block|{
name|mUsesFragCoord
operator|=
literal|true
expr_stmt|;
name|out
operator|<<
name|name
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qualifier
operator|==
name|EvqPointCoord
condition|)
block|{
name|mUsesPointCoord
operator|=
literal|true
expr_stmt|;
name|out
operator|<<
name|name
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qualifier
operator|==
name|EvqFrontFacing
condition|)
block|{
name|mUsesFrontFacing
operator|=
literal|true
expr_stmt|;
name|out
operator|<<
name|name
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qualifier
operator|==
name|EvqPointSize
condition|)
block|{
name|mUsesPointSize
operator|=
literal|true
expr_stmt|;
name|out
operator|<<
name|name
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qualifier
operator|==
name|EvqInstanceID
condition|)
block|{
name|mUsesInstanceID
operator|=
literal|true
expr_stmt|;
name|out
operator|<<
name|name
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
literal|"gl_FragDepthEXT"
condition|)
block|{
name|mUsesFragDepth
operator|=
literal|true
expr_stmt|;
name|out
operator|<<
literal|"gl_Depth"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qualifier
operator|==
name|EvqInternal
condition|)
block|{
name|out
operator|<<
name|name
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
name|Decorate
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|visitRaw
name|void
name|OutputHLSL
operator|::
name|visitRaw
parameter_list|(
name|TIntermRaw
modifier|*
name|node
parameter_list|)
block|{
name|getInfoSink
argument_list|()
operator|<<
name|node
operator|->
name|getRawText
argument_list|()
expr_stmt|;
block|}
DECL|function|outputEqual
name|void
name|OutputHLSL
operator|::
name|outputEqual
parameter_list|(
name|Visit
name|visit
parameter_list|,
specifier|const
name|TType
modifier|&
name|type
parameter_list|,
name|TOperator
name|op
parameter_list|,
name|TInfoSinkBase
modifier|&
name|out
parameter_list|)
block|{
if|if
condition|(
name|type
operator|.
name|isScalar
argument_list|()
operator|&&
operator|!
name|type
operator|.
name|isArray
argument_list|()
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|EOpEqual
condition|)
block|{
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" == "
argument_list|,
literal|")"
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" != "
argument_list|,
literal|")"
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|visit
operator|==
name|PreVisit
operator|&&
name|op
operator|==
name|EOpNotEqual
condition|)
block|{
name|out
operator|<<
literal|"!"
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|.
name|isArray
argument_list|()
condition|)
block|{
specifier|const
name|TString
modifier|&
name|functionName
init|=
name|addArrayEqualityFunction
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|outputTriplet
argument_list|(
name|visit
argument_list|,
operator|(
name|functionName
operator|+
literal|"("
operator|)
operator|.
name|c_str
argument_list|()
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtStruct
condition|)
block|{
specifier|const
name|TStructure
modifier|&
name|structure
init|=
operator|*
name|type
operator|.
name|getStruct
argument_list|()
decl_stmt|;
specifier|const
name|TString
modifier|&
name|functionName
init|=
name|addStructEqualityFunction
argument_list|(
name|structure
argument_list|)
decl_stmt|;
name|outputTriplet
argument_list|(
name|visit
argument_list|,
operator|(
name|functionName
operator|+
literal|"("
operator|)
operator|.
name|c_str
argument_list|()
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|type
operator|.
name|isMatrix
argument_list|()
operator|||
name|type
operator|.
name|isVector
argument_list|()
argument_list|)
expr_stmt|;
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"all("
argument_list|,
literal|" == "
argument_list|,
literal|")"
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|visitBinary
name|bool
name|OutputHLSL
operator|::
name|visitBinary
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermBinary
modifier|*
name|node
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|getInfoSink
argument_list|()
decl_stmt|;
comment|// Handle accessing std140 structs by value
if|if
condition|(
name|mFlaggedStructMappedNames
operator|.
name|count
argument_list|(
name|node
argument_list|)
operator|>
literal|0
condition|)
block|{
name|out
operator|<<
name|mFlaggedStructMappedNames
index|[
name|node
index|]
expr_stmt|;
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|node
operator|->
name|getOp
argument_list|()
condition|)
block|{
case|case
name|EOpAssign
case|:
if|if
condition|(
name|node
operator|->
name|getLeft
argument_list|()
operator|->
name|isArray
argument_list|()
condition|)
block|{
specifier|const
name|TString
modifier|&
name|functionName
init|=
name|addArrayAssignmentFunction
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|)
decl_stmt|;
name|outputTriplet
argument_list|(
name|visit
argument_list|,
operator|(
name|functionName
operator|+
literal|"("
operator|)
operator|.
name|c_str
argument_list|()
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" = "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EOpInitialize
case|:
if|if
condition|(
name|visit
operator|==
name|PreVisit
condition|)
block|{
comment|// GLSL allows to write things like "float x = x;" where a new variable x is defined
comment|// and the value of an existing variable x is assigned. HLSL uses C semantics (the
comment|// new variable is created before the assignment is evaluated), so we need to convert
comment|// this to "float t = x, x = t;".
name|TIntermSymbol
modifier|*
name|symbolNode
init|=
name|node
operator|->
name|getLeft
argument_list|()
operator|->
name|getAsSymbolNode
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|symbolNode
argument_list|)
expr_stmt|;
name|TIntermTyped
modifier|*
name|expression
init|=
name|node
operator|->
name|getRight
argument_list|()
decl_stmt|;
comment|// TODO (jmadill): do a 'deep' scan to know if an expression is statically const
if|if
condition|(
name|symbolNode
operator|->
name|getQualifier
argument_list|()
operator|==
name|EvqGlobal
operator|&&
name|expression
operator|->
name|getQualifier
argument_list|()
operator|!=
name|EvqConst
condition|)
block|{
comment|// For variables which are not constant, defer their real initialization until
comment|// after we initialize other globals: uniforms, attributes and varyings.
name|mDeferredGlobalInitializers
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|symbolNode
argument_list|,
name|expression
argument_list|)
argument_list|)
expr_stmt|;
specifier|const
name|TString
modifier|&
name|initString
init|=
name|initializer
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|)
decl_stmt|;
name|node
operator|->
name|setRight
argument_list|(
operator|new
name|TIntermRaw
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|,
name|initString
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|writeSameSymbolInitializer
argument_list|(
name|out
argument_list|,
name|symbolNode
argument_list|,
name|expression
argument_list|)
condition|)
block|{
comment|// Skip initializing the rest of the expression
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|visit
operator|==
name|InVisit
condition|)
block|{
name|out
operator|<<
literal|" = "
expr_stmt|;
block|}
break|break;
case|case
name|EOpAddAssign
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" += "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpSubAssign
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" -= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpMulAssign
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" *= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpVectorTimesScalarAssign
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" *= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpMatrixTimesScalarAssign
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" *= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpVectorTimesMatrixAssign
case|:
if|if
condition|(
name|visit
operator|==
name|PreVisit
condition|)
block|{
name|out
operator|<<
literal|"("
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|visit
operator|==
name|InVisit
condition|)
block|{
name|out
operator|<<
literal|" = mul("
expr_stmt|;
name|node
operator|->
name|getLeft
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|", transpose("
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
literal|")))"
expr_stmt|;
block|}
break|break;
case|case
name|EOpMatrixTimesMatrixAssign
case|:
if|if
condition|(
name|visit
operator|==
name|PreVisit
condition|)
block|{
name|out
operator|<<
literal|"("
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|visit
operator|==
name|InVisit
condition|)
block|{
name|out
operator|<<
literal|" = transpose(mul(transpose("
expr_stmt|;
name|node
operator|->
name|getLeft
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"), transpose("
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
literal|"))))"
expr_stmt|;
block|}
break|break;
case|case
name|EOpDivAssign
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" /= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpIModAssign
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" %= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpBitShiftLeftAssign
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|"<<= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpBitShiftRightAssign
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|">>= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpBitwiseAndAssign
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|"&= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpBitwiseXorAssign
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" ^= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpBitwiseOrAssign
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" |= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpIndexDirect
case|:
block|{
specifier|const
name|TType
modifier|&
name|leftType
init|=
name|node
operator|->
name|getLeft
argument_list|()
operator|->
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|leftType
operator|.
name|isInterfaceBlock
argument_list|()
condition|)
block|{
if|if
condition|(
name|visit
operator|==
name|PreVisit
condition|)
block|{
name|TInterfaceBlock
modifier|*
name|interfaceBlock
init|=
name|leftType
operator|.
name|getInterfaceBlock
argument_list|()
decl_stmt|;
specifier|const
name|int
name|arrayIndex
init|=
name|node
operator|->
name|getRight
argument_list|()
operator|->
name|getAsConstantUnion
argument_list|()
operator|->
name|getIConst
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|mReferencedInterfaceBlocks
index|[
name|interfaceBlock
operator|->
name|instanceName
argument_list|()
index|]
operator|=
name|node
operator|->
name|getLeft
argument_list|()
operator|->
name|getAsSymbolNode
argument_list|()
expr_stmt|;
name|out
operator|<<
name|mUniformHLSL
operator|->
name|interfaceBlockInstanceString
argument_list|(
operator|*
name|interfaceBlock
argument_list|,
name|arrayIndex
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|""
argument_list|,
literal|"["
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|EOpIndexIndirect
case|:
comment|// We do not currently support indirect references to interface blocks
name|ASSERT
argument_list|(
name|node
operator|->
name|getLeft
argument_list|()
operator|->
name|getBasicType
argument_list|()
operator|!=
name|EbtInterfaceBlock
argument_list|)
expr_stmt|;
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|""
argument_list|,
literal|"["
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpIndexDirectStruct
case|:
if|if
condition|(
name|visit
operator|==
name|InVisit
condition|)
block|{
specifier|const
name|TStructure
modifier|*
name|structure
init|=
name|node
operator|->
name|getLeft
argument_list|()
operator|->
name|getType
argument_list|()
operator|.
name|getStruct
argument_list|()
decl_stmt|;
specifier|const
name|TIntermConstantUnion
modifier|*
name|index
init|=
name|node
operator|->
name|getRight
argument_list|()
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
specifier|const
name|TField
modifier|*
name|field
init|=
name|structure
operator|->
name|fields
argument_list|()
index|[
name|index
operator|->
name|getIConst
argument_list|(
literal|0
argument_list|)
index|]
decl_stmt|;
name|out
operator|<<
literal|"."
operator|+
name|DecorateField
argument_list|(
name|field
operator|->
name|name
argument_list|()
argument_list|,
operator|*
name|structure
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|EOpIndexDirectInterfaceBlock
case|:
if|if
condition|(
name|visit
operator|==
name|InVisit
condition|)
block|{
specifier|const
name|TInterfaceBlock
modifier|*
name|interfaceBlock
init|=
name|node
operator|->
name|getLeft
argument_list|()
operator|->
name|getType
argument_list|()
operator|.
name|getInterfaceBlock
argument_list|()
decl_stmt|;
specifier|const
name|TIntermConstantUnion
modifier|*
name|index
init|=
name|node
operator|->
name|getRight
argument_list|()
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
specifier|const
name|TField
modifier|*
name|field
init|=
name|interfaceBlock
operator|->
name|fields
argument_list|()
index|[
name|index
operator|->
name|getIConst
argument_list|(
literal|0
argument_list|)
index|]
decl_stmt|;
name|out
operator|<<
literal|"."
operator|+
name|Decorate
argument_list|(
name|field
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|EOpVectorSwizzle
case|:
if|if
condition|(
name|visit
operator|==
name|InVisit
condition|)
block|{
name|out
operator|<<
literal|"."
expr_stmt|;
name|TIntermAggregate
modifier|*
name|swizzle
init|=
name|node
operator|->
name|getRight
argument_list|()
operator|->
name|getAsAggregate
argument_list|()
decl_stmt|;
if|if
condition|(
name|swizzle
condition|)
block|{
name|TIntermSequence
modifier|*
name|sequence
init|=
name|swizzle
operator|->
name|getSequence
argument_list|()
decl_stmt|;
for|for
control|(
name|TIntermSequence
operator|::
name|iterator
name|sit
init|=
name|sequence
operator|->
name|begin
argument_list|()
init|;
name|sit
operator|!=
name|sequence
operator|->
name|end
argument_list|()
condition|;
name|sit
operator|++
control|)
block|{
name|TIntermConstantUnion
modifier|*
name|element
init|=
operator|(
operator|*
name|sit
operator|)
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
if|if
condition|(
name|element
condition|)
block|{
name|int
name|i
init|=
name|element
operator|->
name|getIConst
argument_list|(
literal|0
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
name|out
operator|<<
literal|"x"
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|out
operator|<<
literal|"y"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|out
operator|<<
literal|"z"
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|out
operator|<<
literal|"w"
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
comment|// Fully processed
block|}
break|break;
case|case
name|EOpAdd
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" + "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpSub
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" - "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpMul
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" * "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpDiv
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" / "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpIMod
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" % "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpBitShiftLeft
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|"<< "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpBitShiftRight
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|">> "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpBitwiseAnd
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|"& "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpBitwiseXor
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" ^ "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpBitwiseOr
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" | "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpEqual
case|:
case|case
name|EOpNotEqual
case|:
name|outputEqual
argument_list|(
name|visit
argument_list|,
name|node
operator|->
name|getLeft
argument_list|()
operator|->
name|getType
argument_list|()
argument_list|,
name|node
operator|->
name|getOp
argument_list|()
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpLessThan
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|"< "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpGreaterThan
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|"> "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpLessThanEqual
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|"<= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpGreaterThanEqual
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|">= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpVectorTimesScalar
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" * "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpMatrixTimesScalar
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" * "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpVectorTimesMatrix
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"mul("
argument_list|,
literal|", transpose("
argument_list|,
literal|"))"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpMatrixTimesVector
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"mul(transpose("
argument_list|,
literal|"), "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpMatrixTimesMatrix
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"transpose(mul(transpose("
argument_list|,
literal|"), transpose("
argument_list|,
literal|")))"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpLogicalOr
case|:
if|if
condition|(
name|node
operator|->
name|getRight
argument_list|()
operator|->
name|hasSideEffects
argument_list|()
condition|)
block|{
name|out
operator|<<
literal|"s"
operator|<<
name|mUnfoldShortCircuit
operator|->
name|getNextTemporaryIndex
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" || "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
case|case
name|EOpLogicalXor
case|:
name|mUsesXor
operator|=
literal|true
expr_stmt|;
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"xor("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpLogicalAnd
case|:
if|if
condition|(
name|node
operator|->
name|getRight
argument_list|()
operator|->
name|hasSideEffects
argument_list|()
condition|)
block|{
name|out
operator|<<
literal|"s"
operator|<<
name|mUnfoldShortCircuit
operator|->
name|getNextTemporaryIndex
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|"&& "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|visitUnary
name|bool
name|OutputHLSL
operator|::
name|visitUnary
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermUnary
modifier|*
name|node
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|->
name|getOp
argument_list|()
condition|)
block|{
case|case
name|EOpNegative
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"(-"
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpPositive
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"(+"
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpVectorLogicalNot
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"(!"
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpLogicalNot
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"(!"
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpBitwiseNot
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"(~"
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpPostIncrement
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|""
argument_list|,
literal|"++)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpPostDecrement
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|""
argument_list|,
literal|"--)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpPreIncrement
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"(++"
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpPreDecrement
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"(--"
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpRadians
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"radians("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpDegrees
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"degrees("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpSin
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"sin("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpCos
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"cos("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpTan
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"tan("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpAsin
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"asin("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpAcos
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"acos("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpAtan
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"atan("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpSinh
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"sinh("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpCosh
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"cosh("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpTanh
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"tanh("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpAsinh
case|:
name|ASSERT
argument_list|(
name|node
operator|->
name|getUseEmulatedFunction
argument_list|()
argument_list|)
expr_stmt|;
name|writeEmulatedFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"asinh("
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpAcosh
case|:
name|ASSERT
argument_list|(
name|node
operator|->
name|getUseEmulatedFunction
argument_list|()
argument_list|)
expr_stmt|;
name|writeEmulatedFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"acosh("
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpAtanh
case|:
name|ASSERT
argument_list|(
name|node
operator|->
name|getUseEmulatedFunction
argument_list|()
argument_list|)
expr_stmt|;
name|writeEmulatedFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"atanh("
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpExp
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"exp("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpLog
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"log("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpExp2
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"exp2("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpLog2
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"log2("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpSqrt
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"sqrt("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpInverseSqrt
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"rsqrt("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpAbs
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"abs("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpSign
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"sign("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpFloor
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"floor("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpTrunc
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"trunc("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpRound
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"round("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpRoundEven
case|:
name|ASSERT
argument_list|(
name|node
operator|->
name|getUseEmulatedFunction
argument_list|()
argument_list|)
expr_stmt|;
name|writeEmulatedFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"roundEven("
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpCeil
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"ceil("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpFract
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"frac("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpIsNan
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"isnan("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|mRequiresIEEEStrictCompiling
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|EOpIsInf
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"isinf("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpFloatBitsToInt
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"asint("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpFloatBitsToUint
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"asuint("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpIntBitsToFloat
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"asfloat("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpUintBitsToFloat
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"asfloat("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpPackSnorm2x16
case|:
name|ASSERT
argument_list|(
name|node
operator|->
name|getUseEmulatedFunction
argument_list|()
argument_list|)
expr_stmt|;
name|writeEmulatedFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"packSnorm2x16("
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpPackUnorm2x16
case|:
name|ASSERT
argument_list|(
name|node
operator|->
name|getUseEmulatedFunction
argument_list|()
argument_list|)
expr_stmt|;
name|writeEmulatedFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"packUnorm2x16("
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpPackHalf2x16
case|:
name|ASSERT
argument_list|(
name|node
operator|->
name|getUseEmulatedFunction
argument_list|()
argument_list|)
expr_stmt|;
name|writeEmulatedFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"packHalf2x16("
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpUnpackSnorm2x16
case|:
name|ASSERT
argument_list|(
name|node
operator|->
name|getUseEmulatedFunction
argument_list|()
argument_list|)
expr_stmt|;
name|writeEmulatedFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"unpackSnorm2x16("
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpUnpackUnorm2x16
case|:
name|ASSERT
argument_list|(
name|node
operator|->
name|getUseEmulatedFunction
argument_list|()
argument_list|)
expr_stmt|;
name|writeEmulatedFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"unpackUnorm2x16("
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpUnpackHalf2x16
case|:
name|ASSERT
argument_list|(
name|node
operator|->
name|getUseEmulatedFunction
argument_list|()
argument_list|)
expr_stmt|;
name|writeEmulatedFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"unpackHalf2x16("
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpLength
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"length("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpNormalize
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"normalize("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpDFdx
case|:
if|if
condition|(
name|mInsideDiscontinuousLoop
operator|||
name|mOutputLod0Function
condition|)
block|{
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|""
argument_list|,
literal|", 0.0)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"ddx("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EOpDFdy
case|:
if|if
condition|(
name|mInsideDiscontinuousLoop
operator|||
name|mOutputLod0Function
condition|)
block|{
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|""
argument_list|,
literal|", 0.0)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"ddy("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EOpFwidth
case|:
if|if
condition|(
name|mInsideDiscontinuousLoop
operator|||
name|mOutputLod0Function
condition|)
block|{
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|""
argument_list|,
literal|", 0.0)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"fwidth("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EOpTranspose
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"transpose("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpDeterminant
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"determinant(transpose("
argument_list|,
literal|""
argument_list|,
literal|"))"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpInverse
case|:
name|ASSERT
argument_list|(
name|node
operator|->
name|getUseEmulatedFunction
argument_list|()
argument_list|)
expr_stmt|;
name|writeEmulatedFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"inverse("
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpAny
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"any("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpAll
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"all("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|visitAggregate
name|bool
name|OutputHLSL
operator|::
name|visitAggregate
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermAggregate
modifier|*
name|node
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|getInfoSink
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|getOp
argument_list|()
condition|)
block|{
case|case
name|EOpSequence
case|:
block|{
if|if
condition|(
name|mInsideFunction
condition|)
block|{
name|outputLineDirective
argument_list|(
name|node
operator|->
name|getLine
argument_list|()
operator|.
name|first_line
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"{\n"
expr_stmt|;
block|}
for|for
control|(
name|TIntermSequence
operator|::
name|iterator
name|sit
init|=
name|node
operator|->
name|getSequence
argument_list|()
operator|->
name|begin
argument_list|()
init|;
name|sit
operator|!=
name|node
operator|->
name|getSequence
argument_list|()
operator|->
name|end
argument_list|()
condition|;
name|sit
operator|++
control|)
block|{
name|outputLineDirective
argument_list|(
operator|(
operator|*
name|sit
operator|)
operator|->
name|getLine
argument_list|()
operator|.
name|first_line
argument_list|)
expr_stmt|;
name|traverseStatements
argument_list|(
operator|*
name|sit
argument_list|)
expr_stmt|;
comment|// Don't output ; after case labels, they're terminated by :
comment|// This is needed especially since outputting a ; after a case statement would turn empty
comment|// case statements into non-empty case statements, disallowing fall-through from them.
if|if
condition|(
operator|(
operator|*
name|sit
operator|)
operator|->
name|getAsCaseNode
argument_list|()
operator|==
literal|nullptr
condition|)
name|out
operator|<<
literal|";\n"
expr_stmt|;
block|}
if|if
condition|(
name|mInsideFunction
condition|)
block|{
name|outputLineDirective
argument_list|(
name|node
operator|->
name|getLine
argument_list|()
operator|.
name|last_line
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"}\n"
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
case|case
name|EOpDeclaration
case|:
if|if
condition|(
name|visit
operator|==
name|PreVisit
condition|)
block|{
name|TIntermSequence
modifier|*
name|sequence
init|=
name|node
operator|->
name|getSequence
argument_list|()
decl_stmt|;
name|TIntermTyped
modifier|*
name|variable
init|=
operator|(
operator|*
name|sequence
operator|)
index|[
literal|0
index|]
operator|->
name|getAsTyped
argument_list|()
decl_stmt|;
if|if
condition|(
name|variable
operator|&&
operator|(
name|variable
operator|->
name|getQualifier
argument_list|()
operator|==
name|EvqTemporary
operator|||
name|variable
operator|->
name|getQualifier
argument_list|()
operator|==
name|EvqGlobal
operator|)
condition|)
block|{
name|TStructure
modifier|*
name|structure
init|=
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|getStruct
argument_list|()
decl_stmt|;
if|if
condition|(
name|structure
condition|)
block|{
name|mStructureHLSL
operator|->
name|addConstructor
argument_list|(
name|variable
operator|->
name|getType
argument_list|()
argument_list|,
name|StructNameString
argument_list|(
operator|*
name|structure
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|variable
operator|->
name|getAsSymbolNode
argument_list|()
operator|||
name|variable
operator|->
name|getAsSymbolNode
argument_list|()
operator|->
name|getSymbol
argument_list|()
operator|!=
literal|""
condition|)
comment|// Variable declaration
block|{
for|for
control|(
name|auto
name|it
init|=
name|sequence
operator|->
name|cbegin
argument_list|()
init|;
name|it
operator|!=
name|sequence
operator|->
name|cend
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
specifier|const
specifier|auto
modifier|&
name|seqElement
init|=
operator|*
name|it
decl_stmt|;
if|if
condition|(
name|isSingleStatement
argument_list|(
name|seqElement
argument_list|)
condition|)
block|{
name|mUnfoldShortCircuit
operator|->
name|traverse
argument_list|(
name|seqElement
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mInsideFunction
condition|)
block|{
name|out
operator|<<
literal|"static "
expr_stmt|;
block|}
name|out
operator|<<
name|TypeString
argument_list|(
name|variable
operator|->
name|getType
argument_list|()
argument_list|)
operator|+
literal|" "
expr_stmt|;
name|TIntermSymbol
modifier|*
name|symbol
init|=
name|seqElement
operator|->
name|getAsSymbolNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|symbol
condition|)
block|{
name|symbol
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
name|ArrayString
argument_list|(
name|symbol
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|" = "
operator|+
name|initializer
argument_list|(
name|symbol
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|seqElement
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|seqElement
operator|!=
name|sequence
operator|->
name|back
argument_list|()
condition|)
block|{
name|out
operator|<<
literal|";\n"
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|variable
operator|->
name|getAsSymbolNode
argument_list|()
operator|&&
name|variable
operator|->
name|getAsSymbolNode
argument_list|()
operator|->
name|getSymbol
argument_list|()
operator|==
literal|""
condition|)
comment|// Type (struct) declaration
block|{
comment|// Already added to constructor map
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|variable
operator|&&
name|IsVaryingOut
argument_list|(
name|variable
operator|->
name|getQualifier
argument_list|()
argument_list|)
condition|)
block|{
for|for
control|(
name|TIntermSequence
operator|::
name|iterator
name|sit
init|=
name|sequence
operator|->
name|begin
argument_list|()
init|;
name|sit
operator|!=
name|sequence
operator|->
name|end
argument_list|()
condition|;
name|sit
operator|++
control|)
block|{
name|TIntermSymbol
modifier|*
name|symbol
init|=
operator|(
operator|*
name|sit
operator|)
operator|->
name|getAsSymbolNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|symbol
condition|)
block|{
comment|// Vertex (output) varyings which are declared but not written to should still be declared to allow successful linking
name|mReferencedVaryings
index|[
name|symbol
operator|->
name|getSymbol
argument_list|()
index|]
operator|=
name|symbol
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|sit
operator|)
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|visit
operator|==
name|InVisit
condition|)
block|{
name|out
operator|<<
literal|", "
expr_stmt|;
block|}
break|break;
case|case
name|EOpInvariantDeclaration
case|:
comment|// Do not do any translation
return|return
literal|false
return|;
case|case
name|EOpPrototype
case|:
if|if
condition|(
name|visit
operator|==
name|PreVisit
condition|)
block|{
name|out
operator|<<
name|TypeString
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|)
operator|<<
literal|" "
operator|<<
name|Decorate
argument_list|(
name|TFunction
operator|::
name|unmangleName
argument_list|(
name|node
operator|->
name|getName
argument_list|()
argument_list|)
argument_list|)
operator|<<
operator|(
name|mOutputLod0Function
condition|?
literal|"Lod0("
else|:
literal|"("
operator|)
expr_stmt|;
name|TIntermSequence
modifier|*
name|arguments
init|=
name|node
operator|->
name|getSequence
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|arguments
operator|->
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|TIntermSymbol
modifier|*
name|symbol
init|=
operator|(
operator|*
name|arguments
operator|)
index|[
name|i
index|]
operator|->
name|getAsSymbolNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|symbol
condition|)
block|{
name|out
operator|<<
name|argumentString
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|arguments
operator|->
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
name|out
operator|<<
literal|", "
expr_stmt|;
block|}
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
name|out
operator|<<
literal|");\n"
expr_stmt|;
comment|// Also prototype the Lod0 variant if needed
if|if
condition|(
name|mContainsLoopDiscontinuity
operator|&&
operator|!
name|mOutputLod0Function
condition|)
block|{
name|mOutputLod0Function
operator|=
literal|true
expr_stmt|;
name|node
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|mOutputLod0Function
operator|=
literal|false
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
break|break;
case|case
name|EOpComma
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpFunction
case|:
block|{
name|TString
name|name
init|=
name|TFunction
operator|::
name|unmangleName
argument_list|(
name|node
operator|->
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|out
operator|<<
name|TypeString
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|)
operator|<<
literal|" "
expr_stmt|;
if|if
condition|(
name|name
operator|==
literal|"main"
condition|)
block|{
name|out
operator|<<
literal|"gl_main("
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
name|Decorate
argument_list|(
name|name
argument_list|)
operator|<<
operator|(
name|mOutputLod0Function
condition|?
literal|"Lod0("
else|:
literal|"("
operator|)
expr_stmt|;
block|}
name|TIntermSequence
modifier|*
name|sequence
init|=
name|node
operator|->
name|getSequence
argument_list|()
decl_stmt|;
name|TIntermSequence
modifier|*
name|arguments
init|=
operator|(
operator|*
name|sequence
operator|)
index|[
literal|0
index|]
operator|->
name|getAsAggregate
argument_list|()
operator|->
name|getSequence
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|arguments
operator|->
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|TIntermSymbol
modifier|*
name|symbol
init|=
operator|(
operator|*
name|arguments
operator|)
index|[
name|i
index|]
operator|->
name|getAsSymbolNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|symbol
condition|)
block|{
name|TStructure
modifier|*
name|structure
init|=
name|symbol
operator|->
name|getType
argument_list|()
operator|.
name|getStruct
argument_list|()
decl_stmt|;
if|if
condition|(
name|structure
condition|)
block|{
name|mStructureHLSL
operator|->
name|addConstructor
argument_list|(
name|symbol
operator|->
name|getType
argument_list|()
argument_list|,
name|StructNameString
argument_list|(
operator|*
name|structure
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|out
operator|<<
name|argumentString
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|arguments
operator|->
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
name|out
operator|<<
literal|", "
expr_stmt|;
block|}
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
name|out
operator|<<
literal|")\n"
literal|"{\n"
expr_stmt|;
if|if
condition|(
name|sequence
operator|->
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|mInsideFunction
operator|=
literal|true
expr_stmt|;
operator|(
operator|*
name|sequence
operator|)
index|[
literal|1
index|]
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|mInsideFunction
operator|=
literal|false
expr_stmt|;
block|}
name|out
operator|<<
literal|"}\n"
expr_stmt|;
if|if
condition|(
name|mContainsLoopDiscontinuity
operator|&&
operator|!
name|mOutputLod0Function
condition|)
block|{
if|if
condition|(
name|name
operator|!=
literal|"main"
condition|)
block|{
name|mOutputLod0Function
operator|=
literal|true
expr_stmt|;
name|node
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|mOutputLod0Function
operator|=
literal|false
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
break|break;
case|case
name|EOpFunctionCall
case|:
block|{
name|TString
name|name
init|=
name|TFunction
operator|::
name|unmangleName
argument_list|(
name|node
operator|->
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|bool
name|lod0
init|=
name|mInsideDiscontinuousLoop
operator|||
name|mOutputLod0Function
decl_stmt|;
name|TIntermSequence
modifier|*
name|arguments
init|=
name|node
operator|->
name|getSequence
argument_list|()
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|isUserDefined
argument_list|()
condition|)
block|{
name|out
operator|<<
name|Decorate
argument_list|(
name|name
argument_list|)
operator|<<
operator|(
name|lod0
condition|?
literal|"Lod0("
else|:
literal|"("
operator|)
expr_stmt|;
block|}
else|else
block|{
name|TBasicType
name|samplerType
init|=
operator|(
operator|*
name|arguments
operator|)
index|[
literal|0
index|]
operator|->
name|getAsTyped
argument_list|()
operator|->
name|getType
argument_list|()
operator|.
name|getBasicType
argument_list|()
decl_stmt|;
name|TextureFunction
name|textureFunction
decl_stmt|;
name|textureFunction
operator|.
name|sampler
operator|=
name|samplerType
expr_stmt|;
name|textureFunction
operator|.
name|coords
operator|=
operator|(
operator|*
name|arguments
operator|)
index|[
literal|1
index|]
operator|->
name|getAsTyped
argument_list|()
operator|->
name|getNominalSize
argument_list|()
expr_stmt|;
name|textureFunction
operator|.
name|method
operator|=
name|TextureFunction
operator|::
name|IMPLICIT
expr_stmt|;
name|textureFunction
operator|.
name|proj
operator|=
literal|false
expr_stmt|;
name|textureFunction
operator|.
name|offset
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|name
operator|==
literal|"texture2D"
operator|||
name|name
operator|==
literal|"textureCube"
operator|||
name|name
operator|==
literal|"texture"
condition|)
block|{
name|textureFunction
operator|.
name|method
operator|=
name|TextureFunction
operator|::
name|IMPLICIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
literal|"texture2DProj"
operator|||
name|name
operator|==
literal|"textureProj"
condition|)
block|{
name|textureFunction
operator|.
name|method
operator|=
name|TextureFunction
operator|::
name|IMPLICIT
expr_stmt|;
name|textureFunction
operator|.
name|proj
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
literal|"texture2DLod"
operator|||
name|name
operator|==
literal|"textureCubeLod"
operator|||
name|name
operator|==
literal|"textureLod"
operator|||
name|name
operator|==
literal|"texture2DLodEXT"
operator|||
name|name
operator|==
literal|"textureCubeLodEXT"
condition|)
block|{
name|textureFunction
operator|.
name|method
operator|=
name|TextureFunction
operator|::
name|LOD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
literal|"texture2DProjLod"
operator|||
name|name
operator|==
literal|"textureProjLod"
operator|||
name|name
operator|==
literal|"texture2DProjLodEXT"
condition|)
block|{
name|textureFunction
operator|.
name|method
operator|=
name|TextureFunction
operator|::
name|LOD
expr_stmt|;
name|textureFunction
operator|.
name|proj
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
literal|"textureSize"
condition|)
block|{
name|textureFunction
operator|.
name|method
operator|=
name|TextureFunction
operator|::
name|SIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
literal|"textureOffset"
condition|)
block|{
name|textureFunction
operator|.
name|method
operator|=
name|TextureFunction
operator|::
name|IMPLICIT
expr_stmt|;
name|textureFunction
operator|.
name|offset
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
literal|"textureProjOffset"
condition|)
block|{
name|textureFunction
operator|.
name|method
operator|=
name|TextureFunction
operator|::
name|IMPLICIT
expr_stmt|;
name|textureFunction
operator|.
name|offset
operator|=
literal|true
expr_stmt|;
name|textureFunction
operator|.
name|proj
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
literal|"textureLodOffset"
condition|)
block|{
name|textureFunction
operator|.
name|method
operator|=
name|TextureFunction
operator|::
name|LOD
expr_stmt|;
name|textureFunction
operator|.
name|offset
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
literal|"textureProjLodOffset"
condition|)
block|{
name|textureFunction
operator|.
name|method
operator|=
name|TextureFunction
operator|::
name|LOD
expr_stmt|;
name|textureFunction
operator|.
name|proj
operator|=
literal|true
expr_stmt|;
name|textureFunction
operator|.
name|offset
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
literal|"texelFetch"
condition|)
block|{
name|textureFunction
operator|.
name|method
operator|=
name|TextureFunction
operator|::
name|FETCH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
literal|"texelFetchOffset"
condition|)
block|{
name|textureFunction
operator|.
name|method
operator|=
name|TextureFunction
operator|::
name|FETCH
expr_stmt|;
name|textureFunction
operator|.
name|offset
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
literal|"textureGrad"
operator|||
name|name
operator|==
literal|"texture2DGradEXT"
condition|)
block|{
name|textureFunction
operator|.
name|method
operator|=
name|TextureFunction
operator|::
name|GRAD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
literal|"textureGradOffset"
condition|)
block|{
name|textureFunction
operator|.
name|method
operator|=
name|TextureFunction
operator|::
name|GRAD
expr_stmt|;
name|textureFunction
operator|.
name|offset
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
literal|"textureProjGrad"
operator|||
name|name
operator|==
literal|"texture2DProjGradEXT"
operator|||
name|name
operator|==
literal|"textureCubeGradEXT"
condition|)
block|{
name|textureFunction
operator|.
name|method
operator|=
name|TextureFunction
operator|::
name|GRAD
expr_stmt|;
name|textureFunction
operator|.
name|proj
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
literal|"textureProjGradOffset"
condition|)
block|{
name|textureFunction
operator|.
name|method
operator|=
name|TextureFunction
operator|::
name|GRAD
expr_stmt|;
name|textureFunction
operator|.
name|proj
operator|=
literal|true
expr_stmt|;
name|textureFunction
operator|.
name|offset
operator|=
literal|true
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
if|if
condition|(
name|textureFunction
operator|.
name|method
operator|==
name|TextureFunction
operator|::
name|IMPLICIT
condition|)
comment|// Could require lod 0 or have a bias argument
block|{
name|unsigned
name|int
name|mandatoryArgumentCount
init|=
literal|2
decl_stmt|;
comment|// All functions have sampler and coordinate arguments
if|if
condition|(
name|textureFunction
operator|.
name|offset
condition|)
block|{
name|mandatoryArgumentCount
operator|++
expr_stmt|;
block|}
name|bool
name|bias
init|=
operator|(
name|arguments
operator|->
name|size
argument_list|()
operator|>
name|mandatoryArgumentCount
operator|)
decl_stmt|;
comment|// Bias argument is optional
if|if
condition|(
name|lod0
operator|||
name|mShaderType
operator|==
name|GL_VERTEX_SHADER
condition|)
block|{
if|if
condition|(
name|bias
condition|)
block|{
name|textureFunction
operator|.
name|method
operator|=
name|TextureFunction
operator|::
name|LOD0BIAS
expr_stmt|;
block|}
else|else
block|{
name|textureFunction
operator|.
name|method
operator|=
name|TextureFunction
operator|::
name|LOD0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|bias
condition|)
block|{
name|textureFunction
operator|.
name|method
operator|=
name|TextureFunction
operator|::
name|BIAS
expr_stmt|;
block|}
block|}
name|mUsesTexture
operator|.
name|insert
argument_list|(
name|textureFunction
argument_list|)
expr_stmt|;
name|out
operator|<<
name|textureFunction
operator|.
name|name
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|TIntermSequence
operator|::
name|iterator
name|arg
init|=
name|arguments
operator|->
name|begin
argument_list|()
init|;
name|arg
operator|!=
name|arguments
operator|->
name|end
argument_list|()
condition|;
name|arg
operator|++
control|)
block|{
if|if
condition|(
name|mOutputType
operator|==
name|SH_HLSL11_OUTPUT
operator|&&
name|IsSampler
argument_list|(
operator|(
operator|*
name|arg
operator|)
operator|->
name|getAsTyped
argument_list|()
operator|->
name|getBasicType
argument_list|()
argument_list|)
condition|)
block|{
name|out
operator|<<
literal|"texture_"
expr_stmt|;
operator|(
operator|*
name|arg
operator|)
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|", sampler_"
expr_stmt|;
block|}
operator|(
operator|*
name|arg
operator|)
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|<
name|arguments
operator|->
name|end
argument_list|()
operator|-
literal|1
condition|)
block|{
name|out
operator|<<
literal|", "
expr_stmt|;
block|}
block|}
name|out
operator|<<
literal|")"
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|EOpParameters
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|", "
argument_list|,
literal|")\n{\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructFloat
case|:
name|outputConstructor
argument_list|(
name|visit
argument_list|,
name|node
operator|->
name|getType
argument_list|()
argument_list|,
literal|"vec1"
argument_list|,
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructVec2
case|:
name|outputConstructor
argument_list|(
name|visit
argument_list|,
name|node
operator|->
name|getType
argument_list|()
argument_list|,
literal|"vec2"
argument_list|,
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructVec3
case|:
name|outputConstructor
argument_list|(
name|visit
argument_list|,
name|node
operator|->
name|getType
argument_list|()
argument_list|,
literal|"vec3"
argument_list|,
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructVec4
case|:
name|outputConstructor
argument_list|(
name|visit
argument_list|,
name|node
operator|->
name|getType
argument_list|()
argument_list|,
literal|"vec4"
argument_list|,
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructBool
case|:
name|outputConstructor
argument_list|(
name|visit
argument_list|,
name|node
operator|->
name|getType
argument_list|()
argument_list|,
literal|"bvec1"
argument_list|,
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructBVec2
case|:
name|outputConstructor
argument_list|(
name|visit
argument_list|,
name|node
operator|->
name|getType
argument_list|()
argument_list|,
literal|"bvec2"
argument_list|,
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructBVec3
case|:
name|outputConstructor
argument_list|(
name|visit
argument_list|,
name|node
operator|->
name|getType
argument_list|()
argument_list|,
literal|"bvec3"
argument_list|,
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructBVec4
case|:
name|outputConstructor
argument_list|(
name|visit
argument_list|,
name|node
operator|->
name|getType
argument_list|()
argument_list|,
literal|"bvec4"
argument_list|,
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructInt
case|:
name|outputConstructor
argument_list|(
name|visit
argument_list|,
name|node
operator|->
name|getType
argument_list|()
argument_list|,
literal|"ivec1"
argument_list|,
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructIVec2
case|:
name|outputConstructor
argument_list|(
name|visit
argument_list|,
name|node
operator|->
name|getType
argument_list|()
argument_list|,
literal|"ivec2"
argument_list|,
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructIVec3
case|:
name|outputConstructor
argument_list|(
name|visit
argument_list|,
name|node
operator|->
name|getType
argument_list|()
argument_list|,
literal|"ivec3"
argument_list|,
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructIVec4
case|:
name|outputConstructor
argument_list|(
name|visit
argument_list|,
name|node
operator|->
name|getType
argument_list|()
argument_list|,
literal|"ivec4"
argument_list|,
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructUInt
case|:
name|outputConstructor
argument_list|(
name|visit
argument_list|,
name|node
operator|->
name|getType
argument_list|()
argument_list|,
literal|"uvec1"
argument_list|,
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructUVec2
case|:
name|outputConstructor
argument_list|(
name|visit
argument_list|,
name|node
operator|->
name|getType
argument_list|()
argument_list|,
literal|"uvec2"
argument_list|,
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructUVec3
case|:
name|outputConstructor
argument_list|(
name|visit
argument_list|,
name|node
operator|->
name|getType
argument_list|()
argument_list|,
literal|"uvec3"
argument_list|,
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructUVec4
case|:
name|outputConstructor
argument_list|(
name|visit
argument_list|,
name|node
operator|->
name|getType
argument_list|()
argument_list|,
literal|"uvec4"
argument_list|,
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructMat2
case|:
name|outputConstructor
argument_list|(
name|visit
argument_list|,
name|node
operator|->
name|getType
argument_list|()
argument_list|,
literal|"mat2"
argument_list|,
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructMat3
case|:
name|outputConstructor
argument_list|(
name|visit
argument_list|,
name|node
operator|->
name|getType
argument_list|()
argument_list|,
literal|"mat3"
argument_list|,
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructMat4
case|:
name|outputConstructor
argument_list|(
name|visit
argument_list|,
name|node
operator|->
name|getType
argument_list|()
argument_list|,
literal|"mat4"
argument_list|,
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructStruct
case|:
block|{
specifier|const
name|TString
modifier|&
name|structName
init|=
name|StructNameString
argument_list|(
operator|*
name|node
operator|->
name|getType
argument_list|()
operator|.
name|getStruct
argument_list|()
argument_list|)
decl_stmt|;
name|mStructureHLSL
operator|->
name|addConstructor
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|,
name|structName
argument_list|,
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
name|outputTriplet
argument_list|(
name|visit
argument_list|,
operator|(
name|structName
operator|+
literal|"_ctor("
operator|)
operator|.
name|c_str
argument_list|()
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EOpLessThan
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|"< "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpGreaterThan
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|"> "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpLessThanEqual
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|"<= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpGreaterThanEqual
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|">= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpVectorEqual
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" == "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpVectorNotEqual
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" != "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpMod
case|:
name|ASSERT
argument_list|(
name|node
operator|->
name|getUseEmulatedFunction
argument_list|()
argument_list|)
expr_stmt|;
name|writeEmulatedFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"mod("
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpModf
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"modf("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpPow
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"pow("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpAtan
case|:
name|ASSERT
argument_list|(
name|node
operator|->
name|getSequence
argument_list|()
operator|->
name|size
argument_list|()
operator|==
literal|2
argument_list|)
expr_stmt|;
comment|// atan(x) is a unary operator
name|ASSERT
argument_list|(
name|node
operator|->
name|getUseEmulatedFunction
argument_list|()
argument_list|)
expr_stmt|;
name|writeEmulatedFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"atan("
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpMin
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"min("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpMax
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"max("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpClamp
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"clamp("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpMix
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"lerp("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpStep
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"step("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpSmoothStep
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"smoothstep("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpDistance
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"distance("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpDot
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"dot("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpCross
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"cross("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpFaceForward
case|:
name|ASSERT
argument_list|(
name|node
operator|->
name|getUseEmulatedFunction
argument_list|()
argument_list|)
expr_stmt|;
name|writeEmulatedFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"faceforward("
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpReflect
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"reflect("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpRefract
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"refract("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpOuterProduct
case|:
name|ASSERT
argument_list|(
name|node
operator|->
name|getUseEmulatedFunction
argument_list|()
argument_list|)
expr_stmt|;
name|writeEmulatedFunctionTriplet
argument_list|(
name|visit
argument_list|,
literal|"outerProduct("
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpMul
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" * "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|visitSelection
name|bool
name|OutputHLSL
operator|::
name|visitSelection
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermSelection
modifier|*
name|node
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|getInfoSink
argument_list|()
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|usesTernaryOperator
argument_list|()
condition|)
block|{
name|out
operator|<<
literal|"s"
operator|<<
name|mUnfoldShortCircuit
operator|->
name|getNextTemporaryIndex
argument_list|()
expr_stmt|;
block|}
else|else
comment|// if/else statement
block|{
name|mUnfoldShortCircuit
operator|->
name|traverse
argument_list|(
name|node
operator|->
name|getCondition
argument_list|()
argument_list|)
expr_stmt|;
comment|// D3D errors when there is a gradient operation in a loop in an unflattened if
comment|// however flattening all the ifs in branch heavy shaders made D3D error too.
comment|// As a temporary workaround we flatten the ifs only if there is at least a loop
comment|// present somewhere in the shader.
if|if
condition|(
name|mShaderType
operator|==
name|GL_FRAGMENT_SHADER
operator|&&
name|mContainsAnyLoop
condition|)
block|{
name|out
operator|<<
literal|"FLATTEN "
expr_stmt|;
block|}
name|out
operator|<<
literal|"if ("
expr_stmt|;
name|node
operator|->
name|getCondition
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|")\n"
expr_stmt|;
name|outputLineDirective
argument_list|(
name|node
operator|->
name|getLine
argument_list|()
operator|.
name|first_line
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"{\n"
expr_stmt|;
name|bool
name|discard
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|getTrueBlock
argument_list|()
condition|)
block|{
name|traverseStatements
argument_list|(
name|node
operator|->
name|getTrueBlock
argument_list|()
argument_list|)
expr_stmt|;
comment|// Detect true discard
name|discard
operator|=
operator|(
name|discard
operator|||
name|FindDiscard
operator|::
name|search
argument_list|(
name|node
operator|->
name|getTrueBlock
argument_list|()
argument_list|)
operator|)
expr_stmt|;
block|}
name|outputLineDirective
argument_list|(
name|node
operator|->
name|getLine
argument_list|()
operator|.
name|first_line
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|";\n}\n"
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getFalseBlock
argument_list|()
condition|)
block|{
name|out
operator|<<
literal|"else\n"
expr_stmt|;
name|outputLineDirective
argument_list|(
name|node
operator|->
name|getFalseBlock
argument_list|()
operator|->
name|getLine
argument_list|()
operator|.
name|first_line
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"{\n"
expr_stmt|;
name|outputLineDirective
argument_list|(
name|node
operator|->
name|getFalseBlock
argument_list|()
operator|->
name|getLine
argument_list|()
operator|.
name|first_line
argument_list|)
expr_stmt|;
name|traverseStatements
argument_list|(
name|node
operator|->
name|getFalseBlock
argument_list|()
argument_list|)
expr_stmt|;
name|outputLineDirective
argument_list|(
name|node
operator|->
name|getFalseBlock
argument_list|()
operator|->
name|getLine
argument_list|()
operator|.
name|first_line
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|";\n}\n"
expr_stmt|;
comment|// Detect false discard
name|discard
operator|=
operator|(
name|discard
operator|||
name|FindDiscard
operator|::
name|search
argument_list|(
name|node
operator|->
name|getFalseBlock
argument_list|()
argument_list|)
operator|)
expr_stmt|;
block|}
comment|// ANGLE issue 486: Detect problematic conditional discard
if|if
condition|(
name|discard
operator|&&
name|FindSideEffectRewriting
operator|::
name|search
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|mUsesDiscardRewriting
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|function|visitSwitch
name|bool
name|OutputHLSL
operator|::
name|visitSwitch
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermSwitch
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|->
name|getStatementList
argument_list|()
condition|)
block|{
name|node
operator|->
name|setStatementList
argument_list|(
name|RemoveSwitchFallThrough
operator|::
name|removeFallThrough
argument_list|(
name|node
operator|->
name|getStatementList
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"switch ("
argument_list|,
literal|") "
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|// The curly braces get written when visiting the statementList aggregate
block|}
else|else
block|{
comment|// No statementList, so it won't output curly braces
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"switch ("
argument_list|,
literal|") {"
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|visitCase
name|bool
name|OutputHLSL
operator|::
name|visitCase
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermCase
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|->
name|hasCondition
argument_list|()
condition|)
block|{
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"case ("
argument_list|,
literal|""
argument_list|,
literal|"):\n"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|getInfoSink
argument_list|()
decl_stmt|;
name|out
operator|<<
literal|"default:\n"
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|visitConstantUnion
name|void
name|OutputHLSL
operator|::
name|visitConstantUnion
parameter_list|(
name|TIntermConstantUnion
modifier|*
name|node
parameter_list|)
block|{
name|writeConstantUnion
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|,
name|node
operator|->
name|getUnionArrayPointer
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|function|visitLoop
name|bool
name|OutputHLSL
operator|::
name|visitLoop
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermLoop
modifier|*
name|node
parameter_list|)
block|{
name|mNestedLoopDepth
operator|++
expr_stmt|;
name|bool
name|wasDiscontinuous
init|=
name|mInsideDiscontinuousLoop
decl_stmt|;
if|if
condition|(
name|mContainsLoopDiscontinuity
operator|&&
operator|!
name|mInsideDiscontinuousLoop
condition|)
block|{
name|mInsideDiscontinuousLoop
operator|=
name|containsLoopDiscontinuity
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mOutputType
operator|==
name|SH_HLSL9_OUTPUT
condition|)
block|{
if|if
condition|(
name|handleExcessiveLoop
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|mInsideDiscontinuousLoop
operator|=
name|wasDiscontinuous
expr_stmt|;
name|mNestedLoopDepth
operator|--
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|TInfoSinkBase
modifier|&
name|out
init|=
name|getInfoSink
argument_list|()
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|getType
argument_list|()
operator|==
name|ELoopDoWhile
condition|)
block|{
name|out
operator|<<
literal|"{LOOP do\n"
expr_stmt|;
name|outputLineDirective
argument_list|(
name|node
operator|->
name|getLine
argument_list|()
operator|.
name|first_line
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"{\n"
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
literal|"{LOOP for("
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getInit
argument_list|()
condition|)
block|{
name|node
operator|->
name|getInit
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|out
operator|<<
literal|"; "
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getCondition
argument_list|()
condition|)
block|{
name|node
operator|->
name|getCondition
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|out
operator|<<
literal|"; "
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getExpression
argument_list|()
condition|)
block|{
name|node
operator|->
name|getExpression
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|out
operator|<<
literal|")\n"
expr_stmt|;
name|outputLineDirective
argument_list|(
name|node
operator|->
name|getLine
argument_list|()
operator|.
name|first_line
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"{\n"
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|getBody
argument_list|()
condition|)
block|{
name|traverseStatements
argument_list|(
name|node
operator|->
name|getBody
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|outputLineDirective
argument_list|(
name|node
operator|->
name|getLine
argument_list|()
operator|.
name|first_line
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|";}\n"
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getType
argument_list|()
operator|==
name|ELoopDoWhile
condition|)
block|{
name|outputLineDirective
argument_list|(
name|node
operator|->
name|getCondition
argument_list|()
operator|->
name|getLine
argument_list|()
operator|.
name|first_line
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"while(\n"
expr_stmt|;
name|node
operator|->
name|getCondition
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|");"
expr_stmt|;
block|}
name|out
operator|<<
literal|"}\n"
expr_stmt|;
name|mInsideDiscontinuousLoop
operator|=
name|wasDiscontinuous
expr_stmt|;
name|mNestedLoopDepth
operator|--
expr_stmt|;
return|return
literal|false
return|;
block|}
DECL|function|visitBranch
name|bool
name|OutputHLSL
operator|::
name|visitBranch
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermBranch
modifier|*
name|node
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|getInfoSink
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|getFlowOp
argument_list|()
condition|)
block|{
case|case
name|EOpKill
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"discard;\n"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpBreak
case|:
if|if
condition|(
name|visit
operator|==
name|PreVisit
condition|)
block|{
if|if
condition|(
name|mNestedLoopDepth
operator|>
literal|1
condition|)
block|{
name|mUsesNestedBreak
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|mExcessiveLoopIndex
condition|)
block|{
name|out
operator|<<
literal|"{Break"
expr_stmt|;
name|mExcessiveLoopIndex
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|" = true; break;}\n"
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
literal|"break;\n"
expr_stmt|;
block|}
block|}
break|break;
case|case
name|EOpContinue
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"continue;\n"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpReturn
case|:
if|if
condition|(
name|visit
operator|==
name|PreVisit
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|getExpression
argument_list|()
condition|)
block|{
name|out
operator|<<
literal|"return "
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
literal|"return;\n"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|visit
operator|==
name|PostVisit
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|getExpression
argument_list|()
condition|)
block|{
name|out
operator|<<
literal|";\n"
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|traverseStatements
name|void
name|OutputHLSL
operator|::
name|traverseStatements
parameter_list|(
name|TIntermNode
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|isSingleStatement
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|mUnfoldShortCircuit
operator|->
name|traverse
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|node
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
DECL|function|isSingleStatement
name|bool
name|OutputHLSL
operator|::
name|isSingleStatement
parameter_list|(
name|TIntermNode
modifier|*
name|node
parameter_list|)
block|{
name|TIntermAggregate
modifier|*
name|aggregate
init|=
name|node
operator|->
name|getAsAggregate
argument_list|()
decl_stmt|;
if|if
condition|(
name|aggregate
condition|)
block|{
if|if
condition|(
name|aggregate
operator|->
name|getOp
argument_list|()
operator|==
name|EOpSequence
condition|)
block|{
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|aggregate
operator|->
name|getOp
argument_list|()
operator|==
name|EOpDeclaration
condition|)
block|{
comment|// Declaring multiple comma-separated variables must be considered multiple statements
comment|// because each individual declaration has side effects which are visible in the next.
return|return
literal|false
return|;
block|}
else|else
block|{
for|for
control|(
name|TIntermSequence
operator|::
name|iterator
name|sit
init|=
name|aggregate
operator|->
name|getSequence
argument_list|()
operator|->
name|begin
argument_list|()
init|;
name|sit
operator|!=
name|aggregate
operator|->
name|getSequence
argument_list|()
operator|->
name|end
argument_list|()
condition|;
name|sit
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isSingleStatement
argument_list|(
operator|*
name|sit
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|// Handle loops with more than 254 iterations (unsupported by D3D9) by splitting them
comment|// (The D3D documentation says 255 iterations, but the compiler complains at anything more than 254).
DECL|function|handleExcessiveLoop
name|bool
name|OutputHLSL
operator|::
name|handleExcessiveLoop
parameter_list|(
name|TIntermLoop
modifier|*
name|node
parameter_list|)
block|{
specifier|const
name|int
name|MAX_LOOP_ITERATIONS
init|=
literal|254
decl_stmt|;
name|TInfoSinkBase
modifier|&
name|out
init|=
name|getInfoSink
argument_list|()
decl_stmt|;
comment|// Parse loops of the form:
comment|// for(int index = initial; index [comparator] limit; index += increment)
name|TIntermSymbol
modifier|*
name|index
init|=
name|NULL
decl_stmt|;
name|TOperator
name|comparator
init|=
name|EOpNull
decl_stmt|;
name|int
name|initial
init|=
literal|0
decl_stmt|;
name|int
name|limit
init|=
literal|0
decl_stmt|;
name|int
name|increment
init|=
literal|0
decl_stmt|;
comment|// Parse index name and intial value
if|if
condition|(
name|node
operator|->
name|getInit
argument_list|()
condition|)
block|{
name|TIntermAggregate
modifier|*
name|init
init|=
name|node
operator|->
name|getInit
argument_list|()
operator|->
name|getAsAggregate
argument_list|()
decl_stmt|;
if|if
condition|(
name|init
condition|)
block|{
name|TIntermSequence
modifier|*
name|sequence
init|=
name|init
operator|->
name|getSequence
argument_list|()
decl_stmt|;
name|TIntermTyped
modifier|*
name|variable
init|=
operator|(
operator|*
name|sequence
operator|)
index|[
literal|0
index|]
operator|->
name|getAsTyped
argument_list|()
decl_stmt|;
if|if
condition|(
name|variable
operator|&&
name|variable
operator|->
name|getQualifier
argument_list|()
operator|==
name|EvqTemporary
condition|)
block|{
name|TIntermBinary
modifier|*
name|assign
init|=
name|variable
operator|->
name|getAsBinaryNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|assign
operator|->
name|getOp
argument_list|()
operator|==
name|EOpInitialize
condition|)
block|{
name|TIntermSymbol
modifier|*
name|symbol
init|=
name|assign
operator|->
name|getLeft
argument_list|()
operator|->
name|getAsSymbolNode
argument_list|()
decl_stmt|;
name|TIntermConstantUnion
modifier|*
name|constant
init|=
name|assign
operator|->
name|getRight
argument_list|()
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
if|if
condition|(
name|symbol
operator|&&
name|constant
condition|)
block|{
if|if
condition|(
name|constant
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtInt
operator|&&
name|constant
operator|->
name|isScalar
argument_list|()
condition|)
block|{
name|index
operator|=
name|symbol
expr_stmt|;
name|initial
operator|=
name|constant
operator|->
name|getIConst
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
comment|// Parse comparator and limit value
if|if
condition|(
name|index
operator|!=
name|NULL
operator|&&
name|node
operator|->
name|getCondition
argument_list|()
condition|)
block|{
name|TIntermBinary
modifier|*
name|test
init|=
name|node
operator|->
name|getCondition
argument_list|()
operator|->
name|getAsBinaryNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|test
operator|&&
name|test
operator|->
name|getLeft
argument_list|()
operator|->
name|getAsSymbolNode
argument_list|()
operator|->
name|getId
argument_list|()
operator|==
name|index
operator|->
name|getId
argument_list|()
condition|)
block|{
name|TIntermConstantUnion
modifier|*
name|constant
init|=
name|test
operator|->
name|getRight
argument_list|()
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
if|if
condition|(
name|constant
condition|)
block|{
if|if
condition|(
name|constant
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtInt
operator|&&
name|constant
operator|->
name|isScalar
argument_list|()
condition|)
block|{
name|comparator
operator|=
name|test
operator|->
name|getOp
argument_list|()
expr_stmt|;
name|limit
operator|=
name|constant
operator|->
name|getIConst
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// Parse increment
if|if
condition|(
name|index
operator|!=
name|NULL
operator|&&
name|comparator
operator|!=
name|EOpNull
operator|&&
name|node
operator|->
name|getExpression
argument_list|()
condition|)
block|{
name|TIntermBinary
modifier|*
name|binaryTerminal
init|=
name|node
operator|->
name|getExpression
argument_list|()
operator|->
name|getAsBinaryNode
argument_list|()
decl_stmt|;
name|TIntermUnary
modifier|*
name|unaryTerminal
init|=
name|node
operator|->
name|getExpression
argument_list|()
operator|->
name|getAsUnaryNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|binaryTerminal
condition|)
block|{
name|TOperator
name|op
init|=
name|binaryTerminal
operator|->
name|getOp
argument_list|()
decl_stmt|;
name|TIntermConstantUnion
modifier|*
name|constant
init|=
name|binaryTerminal
operator|->
name|getRight
argument_list|()
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
if|if
condition|(
name|constant
condition|)
block|{
if|if
condition|(
name|constant
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtInt
operator|&&
name|constant
operator|->
name|isScalar
argument_list|()
condition|)
block|{
name|int
name|value
init|=
name|constant
operator|->
name|getIConst
argument_list|(
literal|0
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|EOpAddAssign
case|:
name|increment
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|EOpSubAssign
case|:
name|increment
operator|=
operator|-
name|value
expr_stmt|;
break|break;
default|default:
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|unaryTerminal
condition|)
block|{
name|TOperator
name|op
init|=
name|unaryTerminal
operator|->
name|getOp
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|EOpPostIncrement
case|:
name|increment
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|EOpPostDecrement
case|:
name|increment
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|EOpPreIncrement
case|:
name|increment
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|EOpPreDecrement
case|:
name|increment
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|index
operator|!=
name|NULL
operator|&&
name|comparator
operator|!=
name|EOpNull
operator|&&
name|increment
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|comparator
operator|==
name|EOpLessThanEqual
condition|)
block|{
name|comparator
operator|=
name|EOpLessThan
expr_stmt|;
name|limit
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|comparator
operator|==
name|EOpLessThan
condition|)
block|{
name|int
name|iterations
init|=
operator|(
name|limit
operator|-
name|initial
operator|)
operator|/
name|increment
decl_stmt|;
if|if
condition|(
name|iterations
operator|<=
name|MAX_LOOP_ITERATIONS
condition|)
block|{
return|return
literal|false
return|;
comment|// Not an excessive loop
block|}
name|TIntermSymbol
modifier|*
name|restoreIndex
init|=
name|mExcessiveLoopIndex
decl_stmt|;
name|mExcessiveLoopIndex
operator|=
name|index
expr_stmt|;
name|out
operator|<<
literal|"{int "
expr_stmt|;
name|index
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|";\n"
literal|"bool Break"
expr_stmt|;
name|index
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|" = false;\n"
expr_stmt|;
name|bool
name|firstLoopFragment
init|=
literal|true
decl_stmt|;
while|while
condition|(
name|iterations
operator|>
literal|0
condition|)
block|{
name|int
name|clampedLimit
init|=
name|initial
operator|+
name|increment
operator|*
name|std
operator|::
name|min
argument_list|(
name|MAX_LOOP_ITERATIONS
argument_list|,
name|iterations
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|firstLoopFragment
condition|)
block|{
name|out
operator|<<
literal|"if (!Break"
expr_stmt|;
name|index
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|") {\n"
expr_stmt|;
block|}
if|if
condition|(
name|iterations
operator|<=
name|MAX_LOOP_ITERATIONS
condition|)
comment|// Last loop fragment
block|{
name|mExcessiveLoopIndex
operator|=
name|NULL
expr_stmt|;
comment|// Stops setting the Break flag
block|}
comment|// for(int index = initial; index< clampedLimit; index += increment)
name|out
operator|<<
literal|"LOOP for("
expr_stmt|;
name|index
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|" = "
expr_stmt|;
name|out
operator|<<
name|initial
expr_stmt|;
name|out
operator|<<
literal|"; "
expr_stmt|;
name|index
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"< "
expr_stmt|;
name|out
operator|<<
name|clampedLimit
expr_stmt|;
name|out
operator|<<
literal|"; "
expr_stmt|;
name|index
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|" += "
expr_stmt|;
name|out
operator|<<
name|increment
expr_stmt|;
name|out
operator|<<
literal|")\n"
expr_stmt|;
name|outputLineDirective
argument_list|(
name|node
operator|->
name|getLine
argument_list|()
operator|.
name|first_line
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"{\n"
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getBody
argument_list|()
condition|)
block|{
name|node
operator|->
name|getBody
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|outputLineDirective
argument_list|(
name|node
operator|->
name|getLine
argument_list|()
operator|.
name|first_line
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|";}\n"
expr_stmt|;
if|if
condition|(
operator|!
name|firstLoopFragment
condition|)
block|{
name|out
operator|<<
literal|"}\n"
expr_stmt|;
block|}
name|firstLoopFragment
operator|=
literal|false
expr_stmt|;
name|initial
operator|+=
name|MAX_LOOP_ITERATIONS
operator|*
name|increment
expr_stmt|;
name|iterations
operator|-=
name|MAX_LOOP_ITERATIONS
expr_stmt|;
block|}
name|out
operator|<<
literal|"}"
expr_stmt|;
name|mExcessiveLoopIndex
operator|=
name|restoreIndex
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
block|}
return|return
literal|false
return|;
comment|// Not handled as an excessive loop
block|}
DECL|function|outputTriplet
name|void
name|OutputHLSL
operator|::
name|outputTriplet
parameter_list|(
name|Visit
name|visit
parameter_list|,
specifier|const
name|char
modifier|*
name|preString
parameter_list|,
specifier|const
name|char
modifier|*
name|inString
parameter_list|,
specifier|const
name|char
modifier|*
name|postString
parameter_list|,
name|TInfoSinkBase
modifier|&
name|out
parameter_list|)
block|{
if|if
condition|(
name|visit
operator|==
name|PreVisit
condition|)
block|{
name|out
operator|<<
name|preString
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|visit
operator|==
name|InVisit
condition|)
block|{
name|out
operator|<<
name|inString
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|visit
operator|==
name|PostVisit
condition|)
block|{
name|out
operator|<<
name|postString
expr_stmt|;
block|}
block|}
DECL|function|outputTriplet
name|void
name|OutputHLSL
operator|::
name|outputTriplet
parameter_list|(
name|Visit
name|visit
parameter_list|,
specifier|const
name|char
modifier|*
name|preString
parameter_list|,
specifier|const
name|char
modifier|*
name|inString
parameter_list|,
specifier|const
name|char
modifier|*
name|postString
parameter_list|)
block|{
name|outputTriplet
argument_list|(
name|visit
argument_list|,
name|preString
argument_list|,
name|inString
argument_list|,
name|postString
argument_list|,
name|getInfoSink
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|function|outputLineDirective
name|void
name|OutputHLSL
operator|::
name|outputLineDirective
parameter_list|(
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
operator|(
name|mCompileOptions
operator|&
name|SH_LINE_DIRECTIVES
operator|)
operator|&&
operator|(
name|line
operator|>
literal|0
operator|)
condition|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|getInfoSink
argument_list|()
decl_stmt|;
name|out
operator|<<
literal|"\n"
expr_stmt|;
name|out
operator|<<
literal|"#line "
operator|<<
name|line
expr_stmt|;
if|if
condition|(
name|mSourcePath
condition|)
block|{
name|out
operator|<<
literal|" \""
operator|<<
name|mSourcePath
operator|<<
literal|"\""
expr_stmt|;
block|}
name|out
operator|<<
literal|"\n"
expr_stmt|;
block|}
block|}
DECL|function|argumentString
name|TString
name|OutputHLSL
operator|::
name|argumentString
parameter_list|(
specifier|const
name|TIntermSymbol
modifier|*
name|symbol
parameter_list|)
block|{
name|TQualifier
name|qualifier
init|=
name|symbol
operator|->
name|getQualifier
argument_list|()
decl_stmt|;
specifier|const
name|TType
modifier|&
name|type
init|=
name|symbol
operator|->
name|getType
argument_list|()
decl_stmt|;
name|TString
name|name
init|=
name|symbol
operator|->
name|getSymbol
argument_list|()
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|empty
argument_list|()
condition|)
comment|// HLSL demands named arguments, also for prototypes
block|{
name|name
operator|=
literal|"x"
operator|+
name|str
argument_list|(
name|mUniqueIndex
operator|++
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|Decorate
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mOutputType
operator|==
name|SH_HLSL11_OUTPUT
operator|&&
name|IsSampler
argument_list|(
name|type
operator|.
name|getBasicType
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|QualifierString
argument_list|(
name|qualifier
argument_list|)
operator|+
literal|" "
operator|+
name|TextureString
argument_list|(
name|type
argument_list|)
operator|+
literal|" texture_"
operator|+
name|name
operator|+
name|ArrayString
argument_list|(
name|type
argument_list|)
operator|+
literal|", "
operator|+
name|QualifierString
argument_list|(
name|qualifier
argument_list|)
operator|+
literal|" "
operator|+
name|SamplerString
argument_list|(
name|type
argument_list|)
operator|+
literal|" sampler_"
operator|+
name|name
operator|+
name|ArrayString
argument_list|(
name|type
argument_list|)
return|;
block|}
return|return
name|QualifierString
argument_list|(
name|qualifier
argument_list|)
operator|+
literal|" "
operator|+
name|TypeString
argument_list|(
name|type
argument_list|)
operator|+
literal|" "
operator|+
name|name
operator|+
name|ArrayString
argument_list|(
name|type
argument_list|)
return|;
block|}
DECL|function|initializer
name|TString
name|OutputHLSL
operator|::
name|initializer
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|)
block|{
name|TString
name|string
decl_stmt|;
name|size_t
name|size
init|=
name|type
operator|.
name|getObjectSize
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|component
init|=
literal|0
init|;
name|component
operator|<
name|size
condition|;
name|component
operator|++
control|)
block|{
name|string
operator|+=
literal|"0"
expr_stmt|;
if|if
condition|(
name|component
operator|+
literal|1
operator|<
name|size
condition|)
block|{
name|string
operator|+=
literal|", "
expr_stmt|;
block|}
block|}
return|return
literal|"{"
operator|+
name|string
operator|+
literal|"}"
return|;
block|}
DECL|function|outputConstructor
name|void
name|OutputHLSL
operator|::
name|outputConstructor
parameter_list|(
name|Visit
name|visit
parameter_list|,
specifier|const
name|TType
modifier|&
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|TIntermSequence
modifier|*
name|parameters
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|getInfoSink
argument_list|()
decl_stmt|;
if|if
condition|(
name|visit
operator|==
name|PreVisit
condition|)
block|{
name|mStructureHLSL
operator|->
name|addConstructor
argument_list|(
name|type
argument_list|,
name|name
argument_list|,
name|parameters
argument_list|)
expr_stmt|;
name|out
operator|<<
name|name
operator|<<
literal|"("
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|visit
operator|==
name|InVisit
condition|)
block|{
name|out
operator|<<
literal|", "
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|visit
operator|==
name|PostVisit
condition|)
block|{
name|out
operator|<<
literal|")"
expr_stmt|;
block|}
block|}
DECL|function|writeConstantUnion
specifier|const
name|ConstantUnion
modifier|*
name|OutputHLSL
operator|::
name|writeConstantUnion
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|,
specifier|const
name|ConstantUnion
modifier|*
name|constUnion
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|getInfoSink
argument_list|()
decl_stmt|;
specifier|const
name|TStructure
modifier|*
name|structure
init|=
name|type
operator|.
name|getStruct
argument_list|()
decl_stmt|;
if|if
condition|(
name|structure
condition|)
block|{
name|out
operator|<<
name|StructNameString
argument_list|(
operator|*
name|structure
argument_list|)
operator|+
literal|"_ctor("
expr_stmt|;
specifier|const
name|TFieldList
modifier|&
name|fields
init|=
name|structure
operator|->
name|fields
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|TType
modifier|*
name|fieldType
init|=
name|fields
index|[
name|i
index|]
operator|->
name|type
argument_list|()
decl_stmt|;
name|constUnion
operator|=
name|writeConstantUnion
argument_list|(
operator|*
name|fieldType
argument_list|,
name|constUnion
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|fields
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
name|out
operator|<<
literal|", "
expr_stmt|;
block|}
block|}
name|out
operator|<<
literal|")"
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|size
init|=
name|type
operator|.
name|getObjectSize
argument_list|()
decl_stmt|;
name|bool
name|writeType
init|=
name|size
operator|>
literal|1
decl_stmt|;
if|if
condition|(
name|writeType
condition|)
block|{
name|out
operator|<<
name|TypeString
argument_list|(
name|type
argument_list|)
operator|<<
literal|"("
expr_stmt|;
block|}
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
operator|,
name|constUnion
operator|++
control|)
block|{
switch|switch
condition|(
name|constUnion
operator|->
name|getType
argument_list|()
condition|)
block|{
case|case
name|EbtFloat
case|:
name|out
operator|<<
name|std
operator|::
name|min
argument_list|(
name|FLT_MAX
argument_list|,
name|std
operator|::
name|max
argument_list|(
operator|-
name|FLT_MAX
argument_list|,
name|constUnion
operator|->
name|getFConst
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EbtInt
case|:
name|out
operator|<<
name|constUnion
operator|->
name|getIConst
argument_list|()
expr_stmt|;
break|break;
case|case
name|EbtUInt
case|:
name|out
operator|<<
name|constUnion
operator|->
name|getUConst
argument_list|()
expr_stmt|;
break|break;
case|case
name|EbtBool
case|:
name|out
operator|<<
name|constUnion
operator|->
name|getBConst
argument_list|()
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
name|size
operator|-
literal|1
condition|)
block|{
name|out
operator|<<
literal|", "
expr_stmt|;
block|}
block|}
if|if
condition|(
name|writeType
condition|)
block|{
name|out
operator|<<
literal|")"
expr_stmt|;
block|}
block|}
return|return
name|constUnion
return|;
block|}
DECL|function|writeEmulatedFunctionTriplet
name|void
name|OutputHLSL
operator|::
name|writeEmulatedFunctionTriplet
parameter_list|(
name|Visit
name|visit
parameter_list|,
specifier|const
name|char
modifier|*
name|preStr
parameter_list|)
block|{
name|TString
name|preString
init|=
name|BuiltInFunctionEmulator
operator|::
name|GetEmulatedFunctionName
argument_list|(
name|preStr
argument_list|)
decl_stmt|;
name|outputTriplet
argument_list|(
name|visit
argument_list|,
name|preString
operator|.
name|c_str
argument_list|()
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
DECL|function|writeSameSymbolInitializer
name|bool
name|OutputHLSL
operator|::
name|writeSameSymbolInitializer
parameter_list|(
name|TInfoSinkBase
modifier|&
name|out
parameter_list|,
name|TIntermSymbol
modifier|*
name|symbolNode
parameter_list|,
name|TIntermTyped
modifier|*
name|expression
parameter_list|)
block|{
name|sh
operator|::
name|SearchSymbol
name|searchSymbol
argument_list|(
name|symbolNode
operator|->
name|getSymbol
argument_list|()
argument_list|)
decl_stmt|;
name|expression
operator|->
name|traverse
argument_list|(
operator|&
name|searchSymbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|searchSymbol
operator|.
name|foundMatch
argument_list|()
condition|)
block|{
comment|// Type already printed
name|out
operator|<<
literal|"t"
operator|+
name|str
argument_list|(
name|mUniqueIndex
argument_list|)
operator|+
literal|" = "
expr_stmt|;
name|expression
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|", "
expr_stmt|;
name|symbolNode
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|" = t"
operator|+
name|str
argument_list|(
name|mUniqueIndex
argument_list|)
expr_stmt|;
name|mUniqueIndex
operator|++
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|function|writeDeferredGlobalInitializers
name|void
name|OutputHLSL
operator|::
name|writeDeferredGlobalInitializers
parameter_list|(
name|TInfoSinkBase
modifier|&
name|out
parameter_list|)
block|{
name|out
operator|<<
literal|"#define ANGLE_USES_DEFERRED_INIT\n"
operator|<<
literal|"\n"
operator|<<
literal|"void initializeDeferredGlobals()\n"
operator|<<
literal|"{\n"
expr_stmt|;
for|for
control|(
name|auto
name|it
init|=
name|mDeferredGlobalInitializers
operator|.
name|cbegin
argument_list|()
init|;
name|it
operator|!=
name|mDeferredGlobalInitializers
operator|.
name|cend
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
specifier|const
specifier|auto
modifier|&
name|deferredGlobal
init|=
operator|*
name|it
decl_stmt|;
name|TIntermSymbol
modifier|*
name|symbol
init|=
name|deferredGlobal
operator|.
name|first
decl_stmt|;
name|TIntermTyped
modifier|*
name|expression
init|=
name|deferredGlobal
operator|.
name|second
decl_stmt|;
name|ASSERT
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|symbol
operator|->
name|getQualifier
argument_list|()
operator|==
name|EvqGlobal
operator|&&
name|expression
operator|->
name|getQualifier
argument_list|()
operator|!=
name|EvqConst
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"    "
operator|<<
name|Decorate
argument_list|(
name|symbol
operator|->
name|getSymbol
argument_list|()
argument_list|)
operator|<<
literal|" = "
expr_stmt|;
if|if
condition|(
operator|!
name|writeSameSymbolInitializer
argument_list|(
name|out
argument_list|,
name|symbol
argument_list|,
name|expression
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|mInfoSinkStack
operator|.
name|top
argument_list|()
operator|==
operator|&
name|out
argument_list|)
expr_stmt|;
name|expression
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|out
operator|<<
literal|";\n"
expr_stmt|;
block|}
name|out
operator|<<
literal|"}\n"
operator|<<
literal|"\n"
expr_stmt|;
block|}
DECL|function|addStructEqualityFunction
name|TString
name|OutputHLSL
operator|::
name|addStructEqualityFunction
parameter_list|(
specifier|const
name|TStructure
modifier|&
name|structure
parameter_list|)
block|{
specifier|const
name|TFieldList
modifier|&
name|fields
init|=
name|structure
operator|.
name|fields
argument_list|()
decl_stmt|;
for|for
control|(
name|auto
name|it
init|=
name|mStructEqualityFunctions
operator|.
name|cbegin
argument_list|()
init|;
name|it
operator|!=
name|mStructEqualityFunctions
operator|.
name|cend
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|auto
operator|*
name|eqFunction
operator|=
operator|*
name|it
expr_stmt|;
if|if
condition|(
name|eqFunction
operator|->
name|structure
operator|==
operator|&
name|structure
condition|)
block|{
return|return
name|eqFunction
operator|->
name|functionName
return|;
block|}
block|}
specifier|const
name|TString
modifier|&
name|structNameString
init|=
name|StructNameString
argument_list|(
name|structure
argument_list|)
decl_stmt|;
name|StructEqualityFunction
modifier|*
name|function
init|=
operator|new
name|StructEqualityFunction
argument_list|()
decl_stmt|;
name|function
operator|->
name|structure
operator|=
operator|&
name|structure
expr_stmt|;
name|function
operator|->
name|functionName
operator|=
literal|"angle_eq_"
operator|+
name|structNameString
expr_stmt|;
name|TInfoSinkBase
name|fnOut
decl_stmt|;
name|fnOut
operator|<<
literal|"bool "
operator|<<
name|function
operator|->
name|functionName
operator|<<
literal|"("
operator|<<
name|structNameString
operator|<<
literal|" a, "
operator|<<
name|structNameString
operator|+
literal|" b)\n"
operator|<<
literal|"{\n"
literal|"    return "
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|TField
modifier|*
name|field
init|=
name|fields
index|[
name|i
index|]
decl_stmt|;
specifier|const
name|TType
modifier|*
name|fieldType
init|=
name|field
operator|->
name|type
argument_list|()
decl_stmt|;
specifier|const
name|TString
modifier|&
name|fieldNameA
init|=
literal|"a."
operator|+
name|Decorate
argument_list|(
name|field
operator|->
name|name
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|TString
modifier|&
name|fieldNameB
init|=
literal|"b."
operator|+
name|Decorate
argument_list|(
name|field
operator|->
name|name
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|fnOut
operator|<<
literal|"&& "
expr_stmt|;
block|}
name|fnOut
operator|<<
literal|"("
expr_stmt|;
name|outputEqual
argument_list|(
name|PreVisit
argument_list|,
operator|*
name|fieldType
argument_list|,
name|EOpEqual
argument_list|,
name|fnOut
argument_list|)
expr_stmt|;
name|fnOut
operator|<<
name|fieldNameA
expr_stmt|;
name|outputEqual
argument_list|(
name|InVisit
argument_list|,
operator|*
name|fieldType
argument_list|,
name|EOpEqual
argument_list|,
name|fnOut
argument_list|)
expr_stmt|;
name|fnOut
operator|<<
name|fieldNameB
expr_stmt|;
name|outputEqual
argument_list|(
name|PostVisit
argument_list|,
operator|*
name|fieldType
argument_list|,
name|EOpEqual
argument_list|,
name|fnOut
argument_list|)
expr_stmt|;
name|fnOut
operator|<<
literal|")"
expr_stmt|;
block|}
name|fnOut
operator|<<
literal|";\n"
operator|<<
literal|"}\n"
expr_stmt|;
name|function
operator|->
name|functionDefinition
operator|=
name|fnOut
operator|.
name|c_str
argument_list|()
expr_stmt|;
name|mStructEqualityFunctions
operator|.
name|push_back
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|mEqualityFunctions
operator|.
name|push_back
argument_list|(
name|function
argument_list|)
expr_stmt|;
return|return
name|function
operator|->
name|functionName
return|;
block|}
DECL|function|addArrayEqualityFunction
name|TString
name|OutputHLSL
operator|::
name|addArrayEqualityFunction
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|)
block|{
for|for
control|(
name|auto
name|it
init|=
name|mArrayEqualityFunctions
operator|.
name|cbegin
argument_list|()
init|;
name|it
operator|!=
name|mArrayEqualityFunctions
operator|.
name|cend
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
specifier|const
specifier|auto
modifier|&
name|eqFunction
init|=
operator|*
name|it
decl_stmt|;
if|if
condition|(
name|eqFunction
operator|->
name|type
operator|==
name|type
condition|)
block|{
return|return
name|eqFunction
operator|->
name|functionName
return|;
block|}
block|}
specifier|const
name|TString
modifier|&
name|typeName
init|=
name|TypeString
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|ArrayHelperFunction
modifier|*
name|function
init|=
operator|new
name|ArrayHelperFunction
argument_list|()
decl_stmt|;
name|function
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|TInfoSinkBase
name|fnNameOut
decl_stmt|;
name|fnNameOut
operator|<<
literal|"angle_eq_"
operator|<<
name|type
operator|.
name|getArraySize
argument_list|()
operator|<<
literal|"_"
operator|<<
name|typeName
expr_stmt|;
name|function
operator|->
name|functionName
operator|=
name|fnNameOut
operator|.
name|c_str
argument_list|()
expr_stmt|;
name|TType
name|nonArrayType
init|=
name|type
decl_stmt|;
name|nonArrayType
operator|.
name|clearArrayness
argument_list|()
expr_stmt|;
name|TInfoSinkBase
name|fnOut
decl_stmt|;
name|fnOut
operator|<<
literal|"bool "
operator|<<
name|function
operator|->
name|functionName
operator|<<
literal|"("
operator|<<
name|typeName
operator|<<
literal|" a["
operator|<<
name|type
operator|.
name|getArraySize
argument_list|()
operator|<<
literal|"], "
operator|<<
name|typeName
operator|<<
literal|" b["
operator|<<
name|type
operator|.
name|getArraySize
argument_list|()
operator|<<
literal|"])\n"
operator|<<
literal|"{\n"
literal|"    for (int i = 0; i< "
operator|<<
name|type
operator|.
name|getArraySize
argument_list|()
operator|<<
literal|"; ++i)\n"
literal|"    {\n"
literal|"        if ("
expr_stmt|;
name|outputEqual
argument_list|(
name|PreVisit
argument_list|,
name|nonArrayType
argument_list|,
name|EOpNotEqual
argument_list|,
name|fnOut
argument_list|)
expr_stmt|;
name|fnOut
operator|<<
literal|"a[i]"
expr_stmt|;
name|outputEqual
argument_list|(
name|InVisit
argument_list|,
name|nonArrayType
argument_list|,
name|EOpNotEqual
argument_list|,
name|fnOut
argument_list|)
expr_stmt|;
name|fnOut
operator|<<
literal|"b[i]"
expr_stmt|;
name|outputEqual
argument_list|(
name|PostVisit
argument_list|,
name|nonArrayType
argument_list|,
name|EOpNotEqual
argument_list|,
name|fnOut
argument_list|)
expr_stmt|;
name|fnOut
operator|<<
literal|") { return false; }\n"
literal|"    }\n"
literal|"    return true;\n"
literal|"}\n"
expr_stmt|;
name|function
operator|->
name|functionDefinition
operator|=
name|fnOut
operator|.
name|c_str
argument_list|()
expr_stmt|;
name|mArrayEqualityFunctions
operator|.
name|push_back
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|mEqualityFunctions
operator|.
name|push_back
argument_list|(
name|function
argument_list|)
expr_stmt|;
return|return
name|function
operator|->
name|functionName
return|;
block|}
DECL|function|addArrayAssignmentFunction
name|TString
name|OutputHLSL
operator|::
name|addArrayAssignmentFunction
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|)
block|{
for|for
control|(
name|auto
name|it
init|=
name|mArrayAssignmentFunctions
operator|.
name|cbegin
argument_list|()
init|;
name|it
operator|!=
name|mArrayAssignmentFunctions
operator|.
name|cend
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
specifier|const
specifier|auto
modifier|&
name|assignFunction
init|=
operator|*
name|it
decl_stmt|;
if|if
condition|(
name|assignFunction
operator|.
name|type
operator|==
name|type
condition|)
block|{
return|return
name|assignFunction
operator|.
name|functionName
return|;
block|}
block|}
specifier|const
name|TString
modifier|&
name|typeName
init|=
name|TypeString
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|ArrayHelperFunction
name|function
decl_stmt|;
name|function
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|TInfoSinkBase
name|fnNameOut
decl_stmt|;
name|fnNameOut
operator|<<
literal|"angle_assign_"
operator|<<
name|type
operator|.
name|getArraySize
argument_list|()
operator|<<
literal|"_"
operator|<<
name|typeName
expr_stmt|;
name|function
operator|.
name|functionName
operator|=
name|fnNameOut
operator|.
name|c_str
argument_list|()
expr_stmt|;
name|TInfoSinkBase
name|fnOut
decl_stmt|;
name|fnOut
operator|<<
literal|"void "
operator|<<
name|function
operator|.
name|functionName
operator|<<
literal|"(out "
operator|<<
name|typeName
operator|<<
literal|" a["
operator|<<
name|type
operator|.
name|getArraySize
argument_list|()
operator|<<
literal|"], "
operator|<<
name|typeName
operator|<<
literal|" b["
operator|<<
name|type
operator|.
name|getArraySize
argument_list|()
operator|<<
literal|"])\n"
operator|<<
literal|"{\n"
literal|"    for (int i = 0; i< "
operator|<<
name|type
operator|.
name|getArraySize
argument_list|()
operator|<<
literal|"; ++i)\n"
literal|"    {\n"
literal|"        a[i] = b[i];\n"
literal|"    }\n"
literal|"}\n"
expr_stmt|;
name|function
operator|.
name|functionDefinition
operator|=
name|fnOut
operator|.
name|c_str
argument_list|()
expr_stmt|;
name|mArrayAssignmentFunctions
operator|.
name|push_back
argument_list|(
name|function
argument_list|)
expr_stmt|;
return|return
name|function
operator|.
name|functionName
return|;
block|}
block|}
end_namespace
end_unit
