begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|COMPILER_TRANSLATOR_PARSECONTEXT_H_
end_ifndef
begin_define
DECL|macro|COMPILER_TRANSLATOR_PARSECONTEXT_H_
define|#
directive|define
name|COMPILER_TRANSLATOR_PARSECONTEXT_H_
end_define
begin_include
include|#
directive|include
file|"compiler/translator/Compiler.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/Diagnostics.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/DirectiveHandler.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/Intermediate.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/SymbolTable.h"
end_include
begin_include
include|#
directive|include
file|"compiler/preprocessor/Preprocessor.h"
end_include
begin_struct
DECL|struct|TMatrixFields
struct|struct
name|TMatrixFields
block|{
DECL|member|wholeRow
name|bool
name|wholeRow
decl_stmt|;
DECL|member|wholeCol
name|bool
name|wholeCol
decl_stmt|;
DECL|member|row
name|int
name|row
decl_stmt|;
DECL|member|col
name|int
name|col
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|//
end_comment
begin_comment
comment|// The following are extra variables needed during parsing, grouped together so
end_comment
begin_comment
comment|// they can be passed to the parser without needing a global.
end_comment
begin_comment
comment|//
end_comment
begin_decl_stmt
name|class
name|TParseContext
range|:
name|angle
operator|::
name|NonCopyable
block|{
name|public
operator|:
name|TParseContext
argument_list|(
argument|TSymbolTable&symt
argument_list|,
argument|TExtensionBehavior&ext
argument_list|,
argument|TIntermediate&interm
argument_list|,
argument|sh::GLenum type
argument_list|,
argument|ShShaderSpec spec
argument_list|,
argument|int options
argument_list|,
argument|bool checksPrecErrors
argument_list|,
argument|TInfoSink&is
argument_list|,
argument|const ShBuiltInResources&resources
argument_list|)
operator|:
name|intermediate
argument_list|(
name|interm
argument_list|)
block|,
name|symbolTable
argument_list|(
name|symt
argument_list|)
block|,
name|mDeferredSingleDeclarationErrorCheck
argument_list|(
name|false
argument_list|)
block|,
name|mShaderType
argument_list|(
name|type
argument_list|)
block|,
name|mShaderSpec
argument_list|(
name|spec
argument_list|)
block|,
name|mShaderVersion
argument_list|(
literal|100
argument_list|)
block|,
name|mTreeRoot
argument_list|(
name|nullptr
argument_list|)
block|,
name|mLoopNestingLevel
argument_list|(
literal|0
argument_list|)
block|,
name|mStructNestingLevel
argument_list|(
literal|0
argument_list|)
block|,
name|mSwitchNestingLevel
argument_list|(
literal|0
argument_list|)
block|,
name|mCurrentFunctionType
argument_list|(
name|nullptr
argument_list|)
block|,
name|mFunctionReturnsValue
argument_list|(
name|false
argument_list|)
block|,
name|mChecksPrecisionErrors
argument_list|(
name|checksPrecErrors
argument_list|)
block|,
name|mFragmentPrecisionHighOnESSL1
argument_list|(
name|false
argument_list|)
block|,
name|mDefaultMatrixPacking
argument_list|(
name|EmpColumnMajor
argument_list|)
block|,
name|mDefaultBlockStorage
argument_list|(
name|EbsShared
argument_list|)
block|,
name|mDiagnostics
argument_list|(
name|is
argument_list|)
block|,
name|mDirectiveHandler
argument_list|(
name|ext
argument_list|,
name|mDiagnostics
argument_list|,
name|mShaderVersion
argument_list|,
name|mShaderType
argument_list|,
name|resources
operator|.
name|WEBGL_debug_shader_precision
operator|==
literal|1
argument_list|)
block|,
name|mPreprocessor
argument_list|(
operator|&
name|mDiagnostics
argument_list|,
operator|&
name|mDirectiveHandler
argument_list|)
block|,
name|mScanner
argument_list|(
name|nullptr
argument_list|)
block|,
name|mUsesFragData
argument_list|(
name|false
argument_list|)
block|,
name|mUsesFragColor
argument_list|(
name|false
argument_list|)
block|,
name|mUsesSecondaryOutputs
argument_list|(
name|false
argument_list|)
block|,
name|mMinProgramTexelOffset
argument_list|(
name|resources
operator|.
name|MinProgramTexelOffset
argument_list|)
block|,
name|mMaxProgramTexelOffset
argument_list|(
argument|resources.MaxProgramTexelOffset
argument_list|)
block|{     }
specifier|const
name|pp
operator|::
name|Preprocessor
operator|&
name|getPreprocessor
argument_list|()
specifier|const
block|{
return|return
name|mPreprocessor
return|;
block|}
name|pp
operator|::
name|Preprocessor
operator|&
name|getPreprocessor
argument_list|()
block|{
return|return
name|mPreprocessor
return|;
block|}
name|void
operator|*
name|getScanner
argument_list|()
specifier|const
block|{
return|return
name|mScanner
return|;
block|}
name|void
name|setScanner
argument_list|(
argument|void *scanner
argument_list|)
block|{
name|mScanner
operator|=
name|scanner
block|; }
name|int
name|getShaderVersion
argument_list|()
specifier|const
block|{
return|return
name|mShaderVersion
return|;
block|}
name|sh
operator|::
name|GLenum
name|getShaderType
argument_list|()
specifier|const
block|{
return|return
name|mShaderType
return|;
block|}
name|ShShaderSpec
name|getShaderSpec
argument_list|()
specifier|const
block|{
return|return
name|mShaderSpec
return|;
block|}
name|int
name|numErrors
argument_list|()
specifier|const
block|{
return|return
name|mDiagnostics
operator|.
name|numErrors
argument_list|()
return|;
block|}
name|TInfoSink
operator|&
name|infoSink
argument_list|()
block|{
return|return
name|mDiagnostics
operator|.
name|infoSink
argument_list|()
return|;
block|}
name|void
name|error
argument_list|(
specifier|const
name|TSourceLoc
operator|&
name|loc
argument_list|,
specifier|const
name|char
operator|*
name|reason
argument_list|,
specifier|const
name|char
operator|*
name|token
argument_list|,
specifier|const
name|char
operator|*
name|extraInfo
operator|=
literal|""
argument_list|)
block|;
name|void
name|warning
argument_list|(
specifier|const
name|TSourceLoc
operator|&
name|loc
argument_list|,
specifier|const
name|char
operator|*
name|reason
argument_list|,
specifier|const
name|char
operator|*
name|token
argument_list|,
specifier|const
name|char
operator|*
name|extraInfo
operator|=
literal|""
argument_list|)
block|;
comment|// If isError is false, a warning will be reported instead.
name|void
name|outOfRangeError
argument_list|(
argument|bool isError
argument_list|,
argument|const TSourceLoc&loc
argument_list|,
argument|const char *reason
argument_list|,
argument|const char *token
argument_list|,
argument|const char *extraInfo =
literal|""
argument_list|)
block|;
name|void
name|recover
argument_list|()
block|;
name|TIntermNode
operator|*
name|getTreeRoot
argument_list|()
specifier|const
block|{
return|return
name|mTreeRoot
return|;
block|}
name|void
name|setTreeRoot
argument_list|(
argument|TIntermNode *treeRoot
argument_list|)
block|{
name|mTreeRoot
operator|=
name|treeRoot
block|; }
name|bool
name|getFragmentPrecisionHigh
argument_list|()
specifier|const
block|{
return|return
name|mFragmentPrecisionHighOnESSL1
operator|||
name|mShaderVersion
operator|>=
literal|300
return|;
block|}
name|void
name|setFragmentPrecisionHighOnESSL1
argument_list|(
argument|bool fragmentPrecisionHigh
argument_list|)
block|{
name|mFragmentPrecisionHighOnESSL1
operator|=
name|fragmentPrecisionHigh
block|;     }
name|void
name|setLoopNestingLevel
argument_list|(
argument|int loopNestintLevel
argument_list|)
block|{
name|mLoopNestingLevel
operator|=
name|loopNestintLevel
block|;     }
name|void
name|incrLoopNestingLevel
argument_list|()
block|{
operator|++
name|mLoopNestingLevel
block|; }
name|void
name|decrLoopNestingLevel
argument_list|()
block|{
operator|--
name|mLoopNestingLevel
block|; }
name|void
name|incrSwitchNestingLevel
argument_list|()
block|{
operator|++
name|mSwitchNestingLevel
block|; }
name|void
name|decrSwitchNestingLevel
argument_list|()
block|{
operator|--
name|mSwitchNestingLevel
block|; }
comment|// This method is guaranteed to succeed, even if no variable with 'name' exists.
specifier|const
name|TVariable
operator|*
name|getNamedVariable
argument_list|(
specifier|const
name|TSourceLoc
operator|&
name|location
argument_list|,
specifier|const
name|TString
operator|*
name|name
argument_list|,
specifier|const
name|TSymbol
operator|*
name|symbol
argument_list|)
block|;
name|TIntermTyped
operator|*
name|parseVariableIdentifier
argument_list|(
specifier|const
name|TSourceLoc
operator|&
name|location
argument_list|,
specifier|const
name|TString
operator|*
name|name
argument_list|,
specifier|const
name|TSymbol
operator|*
name|symbol
argument_list|)
block|;
name|bool
name|parseVectorFields
argument_list|(
argument|const TString&
argument_list|,
argument|int vecSize
argument_list|,
argument|TVectorFields&
argument_list|,
argument|const TSourceLoc&line
argument_list|)
block|;
name|bool
name|reservedErrorCheck
argument_list|(
specifier|const
name|TSourceLoc
operator|&
name|line
argument_list|,
specifier|const
name|TString
operator|&
name|identifier
argument_list|)
block|;
name|void
name|assignError
argument_list|(
argument|const TSourceLoc&line
argument_list|,
argument|const char *op
argument_list|,
argument|TString left
argument_list|,
argument|TString right
argument_list|)
block|;
name|void
name|unaryOpError
argument_list|(
argument|const TSourceLoc&line
argument_list|,
argument|const char *op
argument_list|,
argument|TString operand
argument_list|)
block|;
name|void
name|binaryOpError
argument_list|(
argument|const TSourceLoc&line
argument_list|,
argument|const char *op
argument_list|,
argument|TString left
argument_list|,
argument|TString right
argument_list|)
block|;
name|bool
name|precisionErrorCheck
argument_list|(
argument|const TSourceLoc&line
argument_list|,
argument|TPrecision precision
argument_list|,
argument|TBasicType type
argument_list|)
block|;
name|bool
name|lValueErrorCheck
argument_list|(
specifier|const
name|TSourceLoc
operator|&
name|line
argument_list|,
specifier|const
name|char
operator|*
name|op
argument_list|,
name|TIntermTyped
operator|*
argument_list|)
block|;
name|bool
name|constErrorCheck
argument_list|(
name|TIntermTyped
operator|*
name|node
argument_list|)
block|;
name|bool
name|integerErrorCheck
argument_list|(
name|TIntermTyped
operator|*
name|node
argument_list|,
specifier|const
name|char
operator|*
name|token
argument_list|)
block|;
name|bool
name|globalErrorCheck
argument_list|(
argument|const TSourceLoc&line
argument_list|,
argument|bool global
argument_list|,
argument|const char *token
argument_list|)
block|;
name|bool
name|constructorErrorCheck
argument_list|(
argument|const TSourceLoc&line
argument_list|,
argument|TIntermNode *argumentsNode
argument_list|,
argument|TFunction&function
argument_list|,
argument|TOperator op
argument_list|,
argument|TType *type
argument_list|)
block|;
name|bool
name|arraySizeErrorCheck
argument_list|(
specifier|const
name|TSourceLoc
operator|&
name|line
argument_list|,
name|TIntermTyped
operator|*
name|expr
argument_list|,
name|int
operator|&
name|size
argument_list|)
block|;
name|bool
name|arrayQualifierErrorCheck
argument_list|(
specifier|const
name|TSourceLoc
operator|&
name|line
argument_list|,
specifier|const
name|TPublicType
operator|&
name|type
argument_list|)
block|;
name|bool
name|arrayTypeErrorCheck
argument_list|(
specifier|const
name|TSourceLoc
operator|&
name|line
argument_list|,
specifier|const
name|TPublicType
operator|&
name|type
argument_list|)
block|;
name|bool
name|voidErrorCheck
argument_list|(
specifier|const
name|TSourceLoc
operator|&
name|line
argument_list|,
specifier|const
name|TString
operator|&
name|identifier
argument_list|,
specifier|const
name|TBasicType
operator|&
name|type
argument_list|)
block|;
name|bool
name|boolErrorCheck
argument_list|(
specifier|const
name|TSourceLoc
operator|&
argument_list|,
specifier|const
name|TIntermTyped
operator|*
argument_list|)
block|;
name|bool
name|boolErrorCheck
argument_list|(
specifier|const
name|TSourceLoc
operator|&
argument_list|,
specifier|const
name|TPublicType
operator|&
argument_list|)
block|;
name|bool
name|samplerErrorCheck
argument_list|(
specifier|const
name|TSourceLoc
operator|&
name|line
argument_list|,
specifier|const
name|TPublicType
operator|&
name|pType
argument_list|,
specifier|const
name|char
operator|*
name|reason
argument_list|)
block|;
name|bool
name|locationDeclaratorListCheck
argument_list|(
specifier|const
name|TSourceLoc
operator|&
name|line
argument_list|,
specifier|const
name|TPublicType
operator|&
name|pType
argument_list|)
block|;
name|bool
name|parameterSamplerErrorCheck
argument_list|(
argument|const TSourceLoc&line
argument_list|,
argument|TQualifier qualifier
argument_list|,
argument|const TType&type
argument_list|)
block|;
name|bool
name|paramErrorCheck
argument_list|(
argument|const TSourceLoc&line
argument_list|,
argument|TQualifier qualifier
argument_list|,
argument|TQualifier paramQualifier
argument_list|,
argument|TType *type
argument_list|)
block|;
name|bool
name|extensionErrorCheck
argument_list|(
specifier|const
name|TSourceLoc
operator|&
name|line
argument_list|,
specifier|const
name|TString
operator|&
argument_list|)
block|;
name|bool
name|singleDeclarationErrorCheck
argument_list|(
specifier|const
name|TPublicType
operator|&
name|publicType
argument_list|,
specifier|const
name|TSourceLoc
operator|&
name|identifierLocation
argument_list|)
block|;
name|bool
name|layoutLocationErrorCheck
argument_list|(
specifier|const
name|TSourceLoc
operator|&
name|location
argument_list|,
specifier|const
name|TLayoutQualifier
operator|&
name|layoutQualifier
argument_list|)
block|;
name|bool
name|functionCallLValueErrorCheck
argument_list|(
specifier|const
name|TFunction
operator|*
name|fnCandidate
argument_list|,
name|TIntermAggregate
operator|*
argument_list|)
block|;
name|void
name|es3InvariantErrorCheck
argument_list|(
argument|const TQualifier qualifier
argument_list|,
argument|const TSourceLoc&invariantLocation
argument_list|)
block|;
name|void
name|es3InputOutputTypeCheck
argument_list|(
argument|const TQualifier qualifier
argument_list|,
argument|const TPublicType&type
argument_list|,
argument|const TSourceLoc&qualifierLocation
argument_list|)
block|;
specifier|const
name|TPragma
operator|&
name|pragma
argument_list|()
specifier|const
block|{
return|return
name|mDirectiveHandler
operator|.
name|pragma
argument_list|()
return|;
block|}
specifier|const
name|TExtensionBehavior
operator|&
name|extensionBehavior
argument_list|()
specifier|const
block|{
return|return
name|mDirectiveHandler
operator|.
name|extensionBehavior
argument_list|()
return|;
block|}
name|bool
name|supportsExtension
argument_list|(
specifier|const
name|char
operator|*
name|extension
argument_list|)
block|;
name|bool
name|isExtensionEnabled
argument_list|(
argument|const char *extension
argument_list|)
specifier|const
block|;
name|void
name|handleExtensionDirective
argument_list|(
specifier|const
name|TSourceLoc
operator|&
name|loc
argument_list|,
specifier|const
name|char
operator|*
name|extName
argument_list|,
specifier|const
name|char
operator|*
name|behavior
argument_list|)
block|;
name|void
name|handlePragmaDirective
argument_list|(
argument|const TSourceLoc&loc
argument_list|,
argument|const char *name
argument_list|,
argument|const char *value
argument_list|,
argument|bool stdgl
argument_list|)
block|;
name|bool
name|containsSampler
argument_list|(
specifier|const
name|TType
operator|&
name|type
argument_list|)
block|;
specifier|const
name|TFunction
operator|*
name|findFunction
argument_list|(
argument|const TSourceLoc&line
argument_list|,
argument|TFunction *pfnCall
argument_list|,
argument|int inputShaderVersion
argument_list|,
argument|bool *builtIn =
literal|0
argument_list|)
block|;
name|bool
name|executeInitializer
argument_list|(
specifier|const
name|TSourceLoc
operator|&
name|line
argument_list|,
specifier|const
name|TString
operator|&
name|identifier
argument_list|,
specifier|const
name|TPublicType
operator|&
name|pType
argument_list|,
name|TIntermTyped
operator|*
name|initializer
argument_list|,
name|TIntermNode
operator|*
operator|*
name|intermNode
argument_list|)
block|;
name|TPublicType
name|addFullySpecifiedType
argument_list|(
argument|TQualifier qualifier
argument_list|,
argument|bool invariant
argument_list|,
argument|TLayoutQualifier layoutQualifier
argument_list|,
argument|const TPublicType&typeSpecifier
argument_list|)
block|;
name|TIntermAggregate
operator|*
name|parseSingleDeclaration
argument_list|(
name|TPublicType
operator|&
name|publicType
argument_list|,
specifier|const
name|TSourceLoc
operator|&
name|identifierOrTypeLocation
argument_list|,
specifier|const
name|TString
operator|&
name|identifier
argument_list|)
block|;
name|TIntermAggregate
operator|*
name|parseSingleArrayDeclaration
argument_list|(
name|TPublicType
operator|&
name|publicType
argument_list|,
specifier|const
name|TSourceLoc
operator|&
name|identifierLocation
argument_list|,
specifier|const
name|TString
operator|&
name|identifier
argument_list|,
specifier|const
name|TSourceLoc
operator|&
name|indexLocation
argument_list|,
name|TIntermTyped
operator|*
name|indexExpression
argument_list|)
block|;
name|TIntermAggregate
operator|*
name|parseSingleInitDeclaration
argument_list|(
specifier|const
name|TPublicType
operator|&
name|publicType
argument_list|,
specifier|const
name|TSourceLoc
operator|&
name|identifierLocation
argument_list|,
specifier|const
name|TString
operator|&
name|identifier
argument_list|,
specifier|const
name|TSourceLoc
operator|&
name|initLocation
argument_list|,
name|TIntermTyped
operator|*
name|initializer
argument_list|)
block|;
comment|// Parse a declaration like "type a[n] = initializer"
comment|// Note that this does not apply to declarations like "type[n] a = initializer"
name|TIntermAggregate
operator|*
name|parseSingleArrayInitDeclaration
argument_list|(
name|TPublicType
operator|&
name|publicType
argument_list|,
specifier|const
name|TSourceLoc
operator|&
name|identifierLocation
argument_list|,
specifier|const
name|TString
operator|&
name|identifier
argument_list|,
specifier|const
name|TSourceLoc
operator|&
name|indexLocation
argument_list|,
name|TIntermTyped
operator|*
name|indexExpression
argument_list|,
specifier|const
name|TSourceLoc
operator|&
name|initLocation
argument_list|,
name|TIntermTyped
operator|*
name|initializer
argument_list|)
block|;
name|TIntermAggregate
operator|*
name|parseInvariantDeclaration
argument_list|(
specifier|const
name|TSourceLoc
operator|&
name|invariantLoc
argument_list|,
specifier|const
name|TSourceLoc
operator|&
name|identifierLoc
argument_list|,
specifier|const
name|TString
operator|*
name|identifier
argument_list|,
specifier|const
name|TSymbol
operator|*
name|symbol
argument_list|)
block|;
name|TIntermAggregate
operator|*
name|parseDeclarator
argument_list|(
name|TPublicType
operator|&
name|publicType
argument_list|,
name|TIntermAggregate
operator|*
name|aggregateDeclaration
argument_list|,
specifier|const
name|TSourceLoc
operator|&
name|identifierLocation
argument_list|,
specifier|const
name|TString
operator|&
name|identifier
argument_list|)
block|;
name|TIntermAggregate
operator|*
name|parseArrayDeclarator
argument_list|(
name|TPublicType
operator|&
name|publicType
argument_list|,
name|TIntermAggregate
operator|*
name|aggregateDeclaration
argument_list|,
specifier|const
name|TSourceLoc
operator|&
name|identifierLocation
argument_list|,
specifier|const
name|TString
operator|&
name|identifier
argument_list|,
specifier|const
name|TSourceLoc
operator|&
name|arrayLocation
argument_list|,
name|TIntermTyped
operator|*
name|indexExpression
argument_list|)
block|;
name|TIntermAggregate
operator|*
name|parseInitDeclarator
argument_list|(
specifier|const
name|TPublicType
operator|&
name|publicType
argument_list|,
name|TIntermAggregate
operator|*
name|aggregateDeclaration
argument_list|,
specifier|const
name|TSourceLoc
operator|&
name|identifierLocation
argument_list|,
specifier|const
name|TString
operator|&
name|identifier
argument_list|,
specifier|const
name|TSourceLoc
operator|&
name|initLocation
argument_list|,
name|TIntermTyped
operator|*
name|initializer
argument_list|)
block|;
comment|// Parse a declarator like "a[n] = initializer"
name|TIntermAggregate
operator|*
name|parseArrayInitDeclarator
argument_list|(
specifier|const
name|TPublicType
operator|&
name|publicType
argument_list|,
name|TIntermAggregate
operator|*
name|aggregateDeclaration
argument_list|,
specifier|const
name|TSourceLoc
operator|&
name|identifierLocation
argument_list|,
specifier|const
name|TString
operator|&
name|identifier
argument_list|,
specifier|const
name|TSourceLoc
operator|&
name|indexLocation
argument_list|,
name|TIntermTyped
operator|*
name|indexExpression
argument_list|,
specifier|const
name|TSourceLoc
operator|&
name|initLocation
argument_list|,
name|TIntermTyped
operator|*
name|initializer
argument_list|)
block|;
name|void
name|parseGlobalLayoutQualifier
argument_list|(
specifier|const
name|TPublicType
operator|&
name|typeQualifier
argument_list|)
block|;
name|TIntermAggregate
operator|*
name|addFunctionPrototypeDeclaration
argument_list|(
specifier|const
name|TFunction
operator|&
name|function
argument_list|,
specifier|const
name|TSourceLoc
operator|&
name|location
argument_list|)
block|;
name|TIntermAggregate
operator|*
name|addFunctionDefinition
argument_list|(
specifier|const
name|TFunction
operator|&
name|function
argument_list|,
name|TIntermAggregate
operator|*
name|functionPrototype
argument_list|,
name|TIntermAggregate
operator|*
name|functionBody
argument_list|,
specifier|const
name|TSourceLoc
operator|&
name|location
argument_list|)
block|;
name|void
name|parseFunctionPrototype
argument_list|(
specifier|const
name|TSourceLoc
operator|&
name|location
argument_list|,
name|TFunction
operator|*
name|function
argument_list|,
name|TIntermAggregate
operator|*
operator|*
name|aggregateOut
argument_list|)
block|;
name|TFunction
operator|*
name|parseFunctionDeclarator
argument_list|(
specifier|const
name|TSourceLoc
operator|&
name|location
argument_list|,
name|TFunction
operator|*
name|function
argument_list|)
block|;
name|TFunction
operator|*
name|addConstructorFunc
argument_list|(
specifier|const
name|TPublicType
operator|&
name|publicType
argument_list|)
block|;
name|TIntermTyped
operator|*
name|addConstructor
argument_list|(
argument|TIntermNode *arguments
argument_list|,
argument|TType *type
argument_list|,
argument|TOperator op
argument_list|,
argument|TFunction *fnCall
argument_list|,
argument|const TSourceLoc&line
argument_list|)
block|;
name|TIntermTyped
operator|*
name|addConstVectorNode
argument_list|(
argument|TVectorFields&fields
argument_list|,
argument|TIntermConstantUnion *node
argument_list|,
argument|const TSourceLoc&line
argument_list|,
argument|bool outOfRangeIndexIsError
argument_list|)
block|;
name|TIntermTyped
operator|*
name|addConstMatrixNode
argument_list|(
argument|int index
argument_list|,
argument|TIntermConstantUnion *node
argument_list|,
argument|const TSourceLoc&line
argument_list|,
argument|bool outOfRangeIndexIsError
argument_list|)
block|;
name|TIntermTyped
operator|*
name|addConstArrayNode
argument_list|(
argument|int index
argument_list|,
argument|TIntermConstantUnion *node
argument_list|,
argument|const TSourceLoc&line
argument_list|,
argument|bool outOfRangeIndexIsError
argument_list|)
block|;
name|TIntermTyped
operator|*
name|addConstStruct
argument_list|(
specifier|const
name|TString
operator|&
name|identifier
argument_list|,
name|TIntermTyped
operator|*
name|node
argument_list|,
specifier|const
name|TSourceLoc
operator|&
name|line
argument_list|)
block|;
name|TIntermTyped
operator|*
name|addIndexExpression
argument_list|(
name|TIntermTyped
operator|*
name|baseExpression
argument_list|,
specifier|const
name|TSourceLoc
operator|&
name|location
argument_list|,
name|TIntermTyped
operator|*
name|indexExpression
argument_list|)
block|;
name|TIntermTyped
operator|*
name|addFieldSelectionExpression
argument_list|(
name|TIntermTyped
operator|*
name|baseExpression
argument_list|,
specifier|const
name|TSourceLoc
operator|&
name|dotLocation
argument_list|,
specifier|const
name|TString
operator|&
name|fieldString
argument_list|,
specifier|const
name|TSourceLoc
operator|&
name|fieldLocation
argument_list|)
block|;
name|TFieldList
operator|*
name|addStructDeclaratorList
argument_list|(
specifier|const
name|TPublicType
operator|&
name|typeSpecifier
argument_list|,
name|TFieldList
operator|*
name|fieldList
argument_list|)
block|;
name|TPublicType
name|addStructure
argument_list|(
specifier|const
name|TSourceLoc
operator|&
name|structLine
argument_list|,
specifier|const
name|TSourceLoc
operator|&
name|nameLine
argument_list|,
specifier|const
name|TString
operator|*
name|structName
argument_list|,
name|TFieldList
operator|*
name|fieldList
argument_list|)
block|;
name|TIntermAggregate
operator|*
name|addInterfaceBlock
argument_list|(
specifier|const
name|TPublicType
operator|&
name|typeQualifier
argument_list|,
specifier|const
name|TSourceLoc
operator|&
name|nameLine
argument_list|,
specifier|const
name|TString
operator|&
name|blockName
argument_list|,
name|TFieldList
operator|*
name|fieldList
argument_list|,
specifier|const
name|TString
operator|*
name|instanceName
argument_list|,
specifier|const
name|TSourceLoc
operator|&
name|instanceLine
argument_list|,
name|TIntermTyped
operator|*
name|arrayIndex
argument_list|,
specifier|const
name|TSourceLoc
operator|&
name|arrayIndexLine
argument_list|)
block|;
name|TLayoutQualifier
name|parseLayoutQualifier
argument_list|(
specifier|const
name|TString
operator|&
name|qualifierType
argument_list|,
specifier|const
name|TSourceLoc
operator|&
name|qualifierTypeLine
argument_list|)
block|;
name|TLayoutQualifier
name|parseLayoutQualifier
argument_list|(
argument|const TString&qualifierType
argument_list|,
argument|const TSourceLoc&qualifierTypeLine
argument_list|,
argument|const TString&intValueString
argument_list|,
argument|int intValue
argument_list|,
argument|const TSourceLoc&intValueLine
argument_list|)
block|;
name|TLayoutQualifier
name|joinLayoutQualifiers
argument_list|(
argument|TLayoutQualifier leftQualifier
argument_list|,
argument|TLayoutQualifier rightQualifier
argument_list|)
block|;
name|TPublicType
name|joinInterpolationQualifiers
argument_list|(
argument|const TSourceLoc&interpolationLoc
argument_list|,
argument|TQualifier interpolationQualifier
argument_list|,
argument|const TSourceLoc&storageLoc
argument_list|,
argument|TQualifier storageQualifier
argument_list|)
block|;
comment|// Performs an error check for embedded struct declarations.
comment|// Returns true if an error was raised due to the declaration of
comment|// this struct.
name|bool
name|enterStructDeclaration
argument_list|(
specifier|const
name|TSourceLoc
operator|&
name|line
argument_list|,
specifier|const
name|TString
operator|&
name|identifier
argument_list|)
block|;
name|void
name|exitStructDeclaration
argument_list|()
block|;
name|bool
name|structNestingErrorCheck
argument_list|(
specifier|const
name|TSourceLoc
operator|&
name|line
argument_list|,
specifier|const
name|TField
operator|&
name|field
argument_list|)
block|;
name|TIntermSwitch
operator|*
name|addSwitch
argument_list|(
name|TIntermTyped
operator|*
name|init
argument_list|,
name|TIntermAggregate
operator|*
name|statementList
argument_list|,
specifier|const
name|TSourceLoc
operator|&
name|loc
argument_list|)
block|;
name|TIntermCase
operator|*
name|addCase
argument_list|(
name|TIntermTyped
operator|*
name|condition
argument_list|,
specifier|const
name|TSourceLoc
operator|&
name|loc
argument_list|)
block|;
name|TIntermCase
operator|*
name|addDefault
argument_list|(
specifier|const
name|TSourceLoc
operator|&
name|loc
argument_list|)
block|;
name|TIntermTyped
operator|*
name|addUnaryMath
argument_list|(
argument|TOperator op
argument_list|,
argument|TIntermTyped *child
argument_list|,
argument|const TSourceLoc&loc
argument_list|)
block|;
name|TIntermTyped
operator|*
name|addUnaryMathLValue
argument_list|(
argument|TOperator op
argument_list|,
argument|TIntermTyped *child
argument_list|,
argument|const TSourceLoc&loc
argument_list|)
block|;
name|TIntermTyped
operator|*
name|addBinaryMath
argument_list|(
argument|TOperator op
argument_list|,
argument|TIntermTyped *left
argument_list|,
argument|TIntermTyped *right
argument_list|,
argument|const TSourceLoc&loc
argument_list|)
block|;
name|TIntermTyped
operator|*
name|addBinaryMathBooleanResult
argument_list|(
argument|TOperator op
argument_list|,
argument|TIntermTyped *left
argument_list|,
argument|TIntermTyped *right
argument_list|,
argument|const TSourceLoc&loc
argument_list|)
block|;
name|TIntermTyped
operator|*
name|addAssign
argument_list|(
argument|TOperator op
argument_list|,
argument|TIntermTyped *left
argument_list|,
argument|TIntermTyped *right
argument_list|,
argument|const TSourceLoc&loc
argument_list|)
block|;
name|TIntermTyped
operator|*
name|addComma
argument_list|(
name|TIntermTyped
operator|*
name|left
argument_list|,
name|TIntermTyped
operator|*
name|right
argument_list|,
specifier|const
name|TSourceLoc
operator|&
name|loc
argument_list|)
block|;
name|TIntermBranch
operator|*
name|addBranch
argument_list|(
argument|TOperator op
argument_list|,
argument|const TSourceLoc&loc
argument_list|)
block|;
name|TIntermBranch
operator|*
name|addBranch
argument_list|(
argument|TOperator op
argument_list|,
argument|TIntermTyped *returnValue
argument_list|,
argument|const TSourceLoc&loc
argument_list|)
block|;
name|void
name|checkTextureOffsetConst
argument_list|(
name|TIntermAggregate
operator|*
name|functionCall
argument_list|)
block|;
name|TIntermTyped
operator|*
name|addFunctionCallOrMethod
argument_list|(
name|TFunction
operator|*
name|fnCall
argument_list|,
name|TIntermNode
operator|*
name|paramNode
argument_list|,
name|TIntermNode
operator|*
name|thisNode
argument_list|,
specifier|const
name|TSourceLoc
operator|&
name|loc
argument_list|,
name|bool
operator|*
name|fatalError
argument_list|)
block|;
name|TIntermTyped
operator|*
name|addTernarySelection
argument_list|(
name|TIntermTyped
operator|*
name|cond
argument_list|,
name|TIntermTyped
operator|*
name|trueBlock
argument_list|,
name|TIntermTyped
operator|*
name|falseBlock
argument_list|,
specifier|const
name|TSourceLoc
operator|&
name|line
argument_list|)
block|;
comment|// TODO(jmadill): make these private
name|TIntermediate
operator|&
name|intermediate
block|;
comment|// to hold and build a parse tree
name|TSymbolTable
operator|&
name|symbolTable
block|;
comment|// symbol table that goes with the language currently being parsed
name|private
operator|:
name|bool
name|declareVariable
argument_list|(
specifier|const
name|TSourceLoc
operator|&
name|line
argument_list|,
specifier|const
name|TString
operator|&
name|identifier
argument_list|,
specifier|const
name|TType
operator|&
name|type
argument_list|,
name|TVariable
operator|*
operator|*
name|variable
argument_list|)
block|;
name|bool
name|nonInitErrorCheck
argument_list|(
specifier|const
name|TSourceLoc
operator|&
name|line
argument_list|,
specifier|const
name|TString
operator|&
name|identifier
argument_list|,
name|TPublicType
operator|*
name|type
argument_list|)
block|;
name|TIntermTyped
operator|*
name|addBinaryMathInternal
argument_list|(
argument|TOperator op
argument_list|,
argument|TIntermTyped *left
argument_list|,
argument|TIntermTyped *right
argument_list|,
argument|const TSourceLoc&loc
argument_list|)
block|;
name|TIntermTyped
operator|*
name|createAssign
argument_list|(
argument|TOperator op
argument_list|,
argument|TIntermTyped *left
argument_list|,
argument|TIntermTyped *right
argument_list|,
argument|const TSourceLoc&loc
argument_list|)
block|;
comment|// The funcReturnType parameter is expected to be non-null when the operation is a built-in function.
comment|// It is expected to be null for other unary operators.
name|TIntermTyped
operator|*
name|createUnaryMath
argument_list|(
argument|TOperator op
argument_list|,
argument|TIntermTyped *child
argument_list|,
argument|const TSourceLoc&loc
argument_list|,
argument|const TType *funcReturnType
argument_list|)
block|;
comment|// Return true if the checks pass
name|bool
name|binaryOpCommonCheck
argument_list|(
argument|TOperator op
argument_list|,
argument|TIntermTyped *left
argument_list|,
argument|TIntermTyped *right
argument_list|,
argument|const TSourceLoc&loc
argument_list|)
block|;
comment|// Set to true when the last/current declarator list was started with an empty declaration.
name|bool
name|mDeferredSingleDeclarationErrorCheck
block|;
name|sh
operator|::
name|GLenum
name|mShaderType
block|;
comment|// vertex or fragment language (future: pack or unpack)
name|ShShaderSpec
name|mShaderSpec
block|;
comment|// The language specification compiler conforms to - GLES2 or WebGL.
name|int
name|mShaderVersion
block|;
name|TIntermNode
operator|*
name|mTreeRoot
block|;
comment|// root of parse tree being created
name|int
name|mLoopNestingLevel
block|;
comment|// 0 if outside all loops
name|int
name|mStructNestingLevel
block|;
comment|// incremented while parsing a struct declaration
name|int
name|mSwitchNestingLevel
block|;
comment|// 0 if outside all switch statements
specifier|const
name|TType
operator|*
name|mCurrentFunctionType
block|;
comment|// the return type of the function that's currently being parsed
name|bool
name|mFunctionReturnsValue
block|;
comment|// true if a non-void function has a return
name|bool
name|mChecksPrecisionErrors
block|;
comment|// true if an error will be generated when a variable is declared without precision, explicit or implicit.
name|bool
name|mFragmentPrecisionHighOnESSL1
block|;
comment|// true if highp precision is supported when compiling
comment|// ESSL1.
name|TLayoutMatrixPacking
name|mDefaultMatrixPacking
block|;
name|TLayoutBlockStorage
name|mDefaultBlockStorage
block|;
name|TString
name|mHashErrMsg
block|;
name|TDiagnostics
name|mDiagnostics
block|;
name|TDirectiveHandler
name|mDirectiveHandler
block|;
name|pp
operator|::
name|Preprocessor
name|mPreprocessor
block|;
name|void
operator|*
name|mScanner
block|;
name|bool
name|mUsesFragData
block|;
comment|// track if we are using both gl_FragData and gl_FragColor
name|bool
name|mUsesFragColor
block|;
name|bool
name|mUsesSecondaryOutputs
block|;
comment|// Track if we are using either gl_SecondaryFragData or
comment|// gl_Secondary FragColor or both.
name|int
name|mMinProgramTexelOffset
block|;
name|int
name|mMaxProgramTexelOffset
block|; }
decl_stmt|;
end_decl_stmt
begin_function_decl
name|int
name|PaParseStrings
parameter_list|(
name|size_t
name|count
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
name|string
index|[]
parameter_list|,
specifier|const
name|int
name|length
index|[]
parameter_list|,
name|TParseContext
modifier|*
name|context
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// COMPILER_TRANSLATOR_PARSECONTEXT_H_
end_comment
end_unit
