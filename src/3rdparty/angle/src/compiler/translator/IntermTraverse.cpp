begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2010 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|"compiler/translator/IntermNode.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/InfoSink.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/SymbolTable.h"
end_include
begin_function
DECL|function|traverse
name|void
name|TIntermSymbol
operator|::
name|traverse
parameter_list|(
name|TIntermTraverser
modifier|*
name|it
parameter_list|)
block|{
name|it
operator|->
name|traverseSymbol
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|traverse
name|void
name|TIntermRaw
operator|::
name|traverse
parameter_list|(
name|TIntermTraverser
modifier|*
name|it
parameter_list|)
block|{
name|it
operator|->
name|traverseRaw
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|traverse
name|void
name|TIntermConstantUnion
operator|::
name|traverse
parameter_list|(
name|TIntermTraverser
modifier|*
name|it
parameter_list|)
block|{
name|it
operator|->
name|traverseConstantUnion
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|traverse
name|void
name|TIntermBinary
operator|::
name|traverse
parameter_list|(
name|TIntermTraverser
modifier|*
name|it
parameter_list|)
block|{
name|it
operator|->
name|traverseBinary
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|traverse
name|void
name|TIntermUnary
operator|::
name|traverse
parameter_list|(
name|TIntermTraverser
modifier|*
name|it
parameter_list|)
block|{
name|it
operator|->
name|traverseUnary
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|traverse
name|void
name|TIntermSelection
operator|::
name|traverse
parameter_list|(
name|TIntermTraverser
modifier|*
name|it
parameter_list|)
block|{
name|it
operator|->
name|traverseSelection
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|traverse
name|void
name|TIntermSwitch
operator|::
name|traverse
parameter_list|(
name|TIntermTraverser
modifier|*
name|it
parameter_list|)
block|{
name|it
operator|->
name|traverseSwitch
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|traverse
name|void
name|TIntermCase
operator|::
name|traverse
parameter_list|(
name|TIntermTraverser
modifier|*
name|it
parameter_list|)
block|{
name|it
operator|->
name|traverseCase
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|traverse
name|void
name|TIntermAggregate
operator|::
name|traverse
parameter_list|(
name|TIntermTraverser
modifier|*
name|it
parameter_list|)
block|{
name|it
operator|->
name|traverseAggregate
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|traverse
name|void
name|TIntermLoop
operator|::
name|traverse
parameter_list|(
name|TIntermTraverser
modifier|*
name|it
parameter_list|)
block|{
name|it
operator|->
name|traverseLoop
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|traverse
name|void
name|TIntermBranch
operator|::
name|traverse
parameter_list|(
name|TIntermTraverser
modifier|*
name|it
parameter_list|)
block|{
name|it
operator|->
name|traverseBranch
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|pushParentBlock
name|void
name|TIntermTraverser
operator|::
name|pushParentBlock
parameter_list|(
name|TIntermAggregate
modifier|*
name|node
parameter_list|)
block|{
name|mParentBlockStack
operator|.
name|push_back
argument_list|(
name|ParentBlock
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|incrementParentBlockPos
name|void
name|TIntermTraverser
operator|::
name|incrementParentBlockPos
parameter_list|()
block|{
operator|++
name|mParentBlockStack
operator|.
name|back
argument_list|()
operator|.
name|pos
expr_stmt|;
block|}
end_function
begin_function
DECL|function|popParentBlock
name|void
name|TIntermTraverser
operator|::
name|popParentBlock
parameter_list|()
block|{
name|ASSERT
argument_list|(
operator|!
name|mParentBlockStack
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
name|mParentBlockStack
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|insertStatementsInParentBlock
name|void
name|TIntermTraverser
operator|::
name|insertStatementsInParentBlock
parameter_list|(
specifier|const
name|TIntermSequence
modifier|&
name|insertions
parameter_list|)
block|{
name|TIntermSequence
name|emptyInsertionsAfter
decl_stmt|;
name|insertStatementsInParentBlock
argument_list|(
name|insertions
argument_list|,
name|emptyInsertionsAfter
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|insertStatementsInParentBlock
name|void
name|TIntermTraverser
operator|::
name|insertStatementsInParentBlock
parameter_list|(
specifier|const
name|TIntermSequence
modifier|&
name|insertionsBefore
parameter_list|,
specifier|const
name|TIntermSequence
modifier|&
name|insertionsAfter
parameter_list|)
block|{
name|ASSERT
argument_list|(
operator|!
name|mParentBlockStack
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
name|NodeInsertMultipleEntry
name|insert
argument_list|(
name|mParentBlockStack
operator|.
name|back
argument_list|()
operator|.
name|node
argument_list|,
name|mParentBlockStack
operator|.
name|back
argument_list|()
operator|.
name|pos
argument_list|,
name|insertionsBefore
argument_list|,
name|insertionsAfter
argument_list|)
decl_stmt|;
name|mInsertions
operator|.
name|push_back
argument_list|(
name|insert
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|createTempSymbol
name|TIntermSymbol
modifier|*
name|TIntermTraverser
operator|::
name|createTempSymbol
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|,
name|TQualifier
name|qualifier
parameter_list|)
block|{
comment|// Each traversal uses at most one temporary variable, so the index stays the same within a single traversal.
name|TInfoSinkBase
name|symbolNameOut
decl_stmt|;
name|ASSERT
argument_list|(
name|mTemporaryIndex
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
name|symbolNameOut
operator|<<
literal|"s"
operator|<<
operator|(
operator|*
name|mTemporaryIndex
operator|)
expr_stmt|;
name|TString
name|symbolName
init|=
name|symbolNameOut
operator|.
name|c_str
argument_list|()
decl_stmt|;
name|TIntermSymbol
modifier|*
name|node
init|=
operator|new
name|TIntermSymbol
argument_list|(
literal|0
argument_list|,
name|symbolName
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|node
operator|->
name|setInternal
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|node
operator|->
name|getTypePointer
argument_list|()
operator|->
name|setQualifier
argument_list|(
name|qualifier
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
end_function
begin_function
DECL|function|createTempSymbol
name|TIntermSymbol
modifier|*
name|TIntermTraverser
operator|::
name|createTempSymbol
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|)
block|{
return|return
name|createTempSymbol
argument_list|(
name|type
argument_list|,
name|EvqTemporary
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|createTempDeclaration
name|TIntermAggregate
modifier|*
name|TIntermTraverser
operator|::
name|createTempDeclaration
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|)
block|{
name|TIntermAggregate
modifier|*
name|tempDeclaration
init|=
operator|new
name|TIntermAggregate
argument_list|(
name|EOpDeclaration
argument_list|)
decl_stmt|;
name|tempDeclaration
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|createTempSymbol
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|tempDeclaration
return|;
block|}
end_function
begin_function
DECL|function|createTempInitDeclaration
name|TIntermAggregate
modifier|*
name|TIntermTraverser
operator|::
name|createTempInitDeclaration
parameter_list|(
name|TIntermTyped
modifier|*
name|initializer
parameter_list|,
name|TQualifier
name|qualifier
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|initializer
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
name|TIntermSymbol
modifier|*
name|tempSymbol
init|=
name|createTempSymbol
argument_list|(
name|initializer
operator|->
name|getType
argument_list|()
argument_list|,
name|qualifier
argument_list|)
decl_stmt|;
name|TIntermAggregate
modifier|*
name|tempDeclaration
init|=
operator|new
name|TIntermAggregate
argument_list|(
name|EOpDeclaration
argument_list|)
decl_stmt|;
name|TIntermBinary
modifier|*
name|tempInit
init|=
operator|new
name|TIntermBinary
argument_list|(
name|EOpInitialize
argument_list|)
decl_stmt|;
name|tempInit
operator|->
name|setLeft
argument_list|(
name|tempSymbol
argument_list|)
expr_stmt|;
name|tempInit
operator|->
name|setRight
argument_list|(
name|initializer
argument_list|)
expr_stmt|;
name|tempInit
operator|->
name|setType
argument_list|(
name|tempSymbol
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|tempDeclaration
operator|->
name|getSequence
argument_list|()
operator|->
name|push_back
argument_list|(
name|tempInit
argument_list|)
expr_stmt|;
return|return
name|tempDeclaration
return|;
block|}
end_function
begin_function
DECL|function|createTempInitDeclaration
name|TIntermAggregate
modifier|*
name|TIntermTraverser
operator|::
name|createTempInitDeclaration
parameter_list|(
name|TIntermTyped
modifier|*
name|initializer
parameter_list|)
block|{
return|return
name|createTempInitDeclaration
argument_list|(
name|initializer
argument_list|,
name|EvqTemporary
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|createTempAssignment
name|TIntermBinary
modifier|*
name|TIntermTraverser
operator|::
name|createTempAssignment
parameter_list|(
name|TIntermTyped
modifier|*
name|rightNode
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|rightNode
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
name|TIntermSymbol
modifier|*
name|tempSymbol
init|=
name|createTempSymbol
argument_list|(
name|rightNode
operator|->
name|getType
argument_list|()
argument_list|)
decl_stmt|;
name|TIntermBinary
modifier|*
name|assignment
init|=
operator|new
name|TIntermBinary
argument_list|(
name|EOpAssign
argument_list|)
decl_stmt|;
name|assignment
operator|->
name|setLeft
argument_list|(
name|tempSymbol
argument_list|)
expr_stmt|;
name|assignment
operator|->
name|setRight
argument_list|(
name|rightNode
argument_list|)
expr_stmt|;
name|assignment
operator|->
name|setType
argument_list|(
name|tempSymbol
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|assignment
return|;
block|}
end_function
begin_function
DECL|function|useTemporaryIndex
name|void
name|TIntermTraverser
operator|::
name|useTemporaryIndex
parameter_list|(
name|unsigned
name|int
modifier|*
name|temporaryIndex
parameter_list|)
block|{
name|mTemporaryIndex
operator|=
name|temporaryIndex
expr_stmt|;
block|}
end_function
begin_function
DECL|function|nextTemporaryIndex
name|void
name|TIntermTraverser
operator|::
name|nextTemporaryIndex
parameter_list|()
block|{
name|ASSERT
argument_list|(
name|mTemporaryIndex
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
operator|++
operator|(
operator|*
name|mTemporaryIndex
operator|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|addToFunctionMap
name|void
name|TLValueTrackingTraverser
operator|::
name|addToFunctionMap
parameter_list|(
specifier|const
name|TName
modifier|&
name|name
parameter_list|,
name|TIntermSequence
modifier|*
name|paramSequence
parameter_list|)
block|{
name|mFunctionMap
index|[
name|name
index|]
operator|=
name|paramSequence
expr_stmt|;
block|}
end_function
begin_function
DECL|function|isInFunctionMap
name|bool
name|TLValueTrackingTraverser
operator|::
name|isInFunctionMap
parameter_list|(
specifier|const
name|TIntermAggregate
modifier|*
name|callNode
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|callNode
operator|->
name|getOp
argument_list|()
operator|==
name|EOpFunctionCall
argument_list|)
expr_stmt|;
return|return
operator|(
name|mFunctionMap
operator|.
name|find
argument_list|(
name|callNode
operator|->
name|getNameObj
argument_list|()
argument_list|)
operator|!=
name|mFunctionMap
operator|.
name|end
argument_list|()
operator|)
return|;
block|}
end_function
begin_function
DECL|function|getFunctionParameters
name|TIntermSequence
modifier|*
name|TLValueTrackingTraverser
operator|::
name|getFunctionParameters
parameter_list|(
specifier|const
name|TIntermAggregate
modifier|*
name|callNode
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|isInFunctionMap
argument_list|(
name|callNode
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|mFunctionMap
index|[
name|callNode
operator|->
name|getNameObj
argument_list|()
index|]
return|;
block|}
end_function
begin_function
DECL|function|setInFunctionCallOutParameter
name|void
name|TLValueTrackingTraverser
operator|::
name|setInFunctionCallOutParameter
parameter_list|(
name|bool
name|inOutParameter
parameter_list|)
block|{
name|mInFunctionCallOutParameter
operator|=
name|inOutParameter
expr_stmt|;
block|}
end_function
begin_function
DECL|function|isInFunctionCallOutParameter
name|bool
name|TLValueTrackingTraverser
operator|::
name|isInFunctionCallOutParameter
parameter_list|()
specifier|const
block|{
return|return
name|mInFunctionCallOutParameter
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Traverse the intermediate representation tree, and
end_comment
begin_comment
comment|// call a node type specific function for each node.
end_comment
begin_comment
comment|// Done recursively through the member function Traverse().
end_comment
begin_comment
comment|// Node types can be skipped if their function to call is 0,
end_comment
begin_comment
comment|// but their subtree will still be traversed.
end_comment
begin_comment
comment|// Nodes with children can have their whole subtree skipped
end_comment
begin_comment
comment|// if preVisit is turned on and the type specific function
end_comment
begin_comment
comment|// returns false.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Traversal functions for terminals are straighforward....
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|traverseSymbol
name|void
name|TIntermTraverser
operator|::
name|traverseSymbol
parameter_list|(
name|TIntermSymbol
modifier|*
name|node
parameter_list|)
block|{
name|visitSymbol
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|traverseConstantUnion
name|void
name|TIntermTraverser
operator|::
name|traverseConstantUnion
parameter_list|(
name|TIntermConstantUnion
modifier|*
name|node
parameter_list|)
block|{
name|visitConstantUnion
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Traverse a binary node.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|traverseBinary
name|void
name|TIntermTraverser
operator|::
name|traverseBinary
parameter_list|(
name|TIntermBinary
modifier|*
name|node
parameter_list|)
block|{
name|bool
name|visit
init|=
literal|true
decl_stmt|;
comment|//
comment|// visit the node before children if pre-visiting.
comment|//
if|if
condition|(
name|preVisit
condition|)
name|visit
operator|=
name|visitBinary
argument_list|(
name|PreVisit
argument_list|,
name|node
argument_list|)
expr_stmt|;
comment|//
comment|// Visit the children, in the right order.
comment|//
if|if
condition|(
name|visit
condition|)
block|{
name|incrementDepth
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getLeft
argument_list|()
condition|)
name|node
operator|->
name|getLeft
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|inVisit
condition|)
name|visit
operator|=
name|visitBinary
argument_list|(
name|InVisit
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|visit
operator|&&
name|node
operator|->
name|getRight
argument_list|()
condition|)
name|node
operator|->
name|getRight
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|decrementDepth
argument_list|()
expr_stmt|;
block|}
comment|//
comment|// Visit the node after the children, if requested and the traversal
comment|// hasn't been cancelled yet.
comment|//
if|if
condition|(
name|visit
operator|&&
name|postVisit
condition|)
name|visitBinary
argument_list|(
name|PostVisit
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|traverseBinary
name|void
name|TLValueTrackingTraverser
operator|::
name|traverseBinary
parameter_list|(
name|TIntermBinary
modifier|*
name|node
parameter_list|)
block|{
name|bool
name|visit
init|=
literal|true
decl_stmt|;
comment|//
comment|// visit the node before children if pre-visiting.
comment|//
if|if
condition|(
name|preVisit
condition|)
name|visit
operator|=
name|visitBinary
argument_list|(
name|PreVisit
argument_list|,
name|node
argument_list|)
expr_stmt|;
comment|//
comment|// Visit the children, in the right order.
comment|//
if|if
condition|(
name|visit
condition|)
block|{
name|incrementDepth
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|// Some binary operations like indexing can be inside an expression which must be an
comment|// l-value.
name|bool
name|parentOperatorRequiresLValue
init|=
name|operatorRequiresLValue
argument_list|()
decl_stmt|;
name|bool
name|parentInFunctionCallOutParameter
init|=
name|isInFunctionCallOutParameter
argument_list|()
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|isAssignment
argument_list|()
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|isLValueRequiredHere
argument_list|()
argument_list|)
expr_stmt|;
name|setOperatorRequiresLValue
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|getLeft
argument_list|()
condition|)
name|node
operator|->
name|getLeft
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|inVisit
condition|)
name|visit
operator|=
name|visitBinary
argument_list|(
name|InVisit
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|isAssignment
argument_list|()
condition|)
name|setOperatorRequiresLValue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// Index is not required to be an l-value even when the surrounding expression is required
comment|// to be an l-value.
name|TOperator
name|op
init|=
name|node
operator|->
name|getOp
argument_list|()
decl_stmt|;
if|if
condition|(
name|op
operator|==
name|EOpIndexDirect
operator|||
name|op
operator|==
name|EOpIndexDirectInterfaceBlock
operator|||
name|op
operator|==
name|EOpIndexDirectStruct
operator|||
name|op
operator|==
name|EOpIndexIndirect
condition|)
block|{
name|setOperatorRequiresLValue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|setInFunctionCallOutParameter
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|visit
operator|&&
name|node
operator|->
name|getRight
argument_list|()
condition|)
name|node
operator|->
name|getRight
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|setOperatorRequiresLValue
argument_list|(
name|parentOperatorRequiresLValue
argument_list|)
expr_stmt|;
name|setInFunctionCallOutParameter
argument_list|(
name|parentInFunctionCallOutParameter
argument_list|)
expr_stmt|;
name|decrementDepth
argument_list|()
expr_stmt|;
block|}
comment|//
comment|// Visit the node after the children, if requested and the traversal
comment|// hasn't been cancelled yet.
comment|//
if|if
condition|(
name|visit
operator|&&
name|postVisit
condition|)
name|visitBinary
argument_list|(
name|PostVisit
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Traverse a unary node.  Same comments in binary node apply here.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|traverseUnary
name|void
name|TIntermTraverser
operator|::
name|traverseUnary
parameter_list|(
name|TIntermUnary
modifier|*
name|node
parameter_list|)
block|{
name|bool
name|visit
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|preVisit
condition|)
name|visit
operator|=
name|visitUnary
argument_list|(
name|PreVisit
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|visit
condition|)
block|{
name|incrementDepth
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|->
name|getOperand
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|decrementDepth
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|visit
operator|&&
name|postVisit
condition|)
name|visitUnary
argument_list|(
name|PostVisit
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|traverseUnary
name|void
name|TLValueTrackingTraverser
operator|::
name|traverseUnary
parameter_list|(
name|TIntermUnary
modifier|*
name|node
parameter_list|)
block|{
name|bool
name|visit
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|preVisit
condition|)
name|visit
operator|=
name|visitUnary
argument_list|(
name|PreVisit
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|visit
condition|)
block|{
name|incrementDepth
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|operatorRequiresLValue
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|node
operator|->
name|getOp
argument_list|()
condition|)
block|{
case|case
name|EOpPostIncrement
case|:
case|case
name|EOpPostDecrement
case|:
case|case
name|EOpPreIncrement
case|:
case|case
name|EOpPreDecrement
case|:
name|setOperatorRequiresLValue
argument_list|(
literal|true
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|node
operator|->
name|getOperand
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|setOperatorRequiresLValue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|decrementDepth
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|visit
operator|&&
name|postVisit
condition|)
name|visitUnary
argument_list|(
name|PostVisit
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Traverse an aggregate node.  Same comments in binary node apply here.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|traverseAggregate
name|void
name|TIntermTraverser
operator|::
name|traverseAggregate
parameter_list|(
name|TIntermAggregate
modifier|*
name|node
parameter_list|)
block|{
name|bool
name|visit
init|=
literal|true
decl_stmt|;
name|TIntermSequence
modifier|*
name|sequence
init|=
name|node
operator|->
name|getSequence
argument_list|()
decl_stmt|;
if|if
condition|(
name|preVisit
condition|)
name|visit
operator|=
name|visitAggregate
argument_list|(
name|PreVisit
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|visit
condition|)
block|{
name|incrementDepth
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getOp
argument_list|()
operator|==
name|EOpSequence
condition|)
name|pushParentBlock
argument_list|(
name|node
argument_list|)
expr_stmt|;
for|for
control|(
name|auto
operator|*
name|child
operator|:
operator|*
name|sequence
control|)
block|{
name|child
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|visit
operator|&&
name|inVisit
condition|)
block|{
if|if
condition|(
name|child
operator|!=
name|sequence
operator|->
name|back
argument_list|()
condition|)
name|visit
operator|=
name|visitAggregate
argument_list|(
name|InVisit
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|getOp
argument_list|()
operator|==
name|EOpSequence
condition|)
name|incrementParentBlockPos
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|getOp
argument_list|()
operator|==
name|EOpSequence
condition|)
name|popParentBlock
argument_list|()
expr_stmt|;
name|decrementDepth
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|visit
operator|&&
name|postVisit
condition|)
name|visitAggregate
argument_list|(
name|PostVisit
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|traverseAggregate
name|void
name|TLValueTrackingTraverser
operator|::
name|traverseAggregate
parameter_list|(
name|TIntermAggregate
modifier|*
name|node
parameter_list|)
block|{
name|bool
name|visit
init|=
literal|true
decl_stmt|;
name|TIntermSequence
modifier|*
name|sequence
init|=
name|node
operator|->
name|getSequence
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|getOp
argument_list|()
condition|)
block|{
case|case
name|EOpFunction
case|:
block|{
name|TIntermAggregate
modifier|*
name|params
init|=
name|sequence
operator|->
name|front
argument_list|()
operator|->
name|getAsAggregate
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|params
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|params
operator|->
name|getOp
argument_list|()
operator|==
name|EOpParameters
argument_list|)
expr_stmt|;
name|addToFunctionMap
argument_list|(
name|node
operator|->
name|getNameObj
argument_list|()
argument_list|,
name|params
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|EOpPrototype
case|:
name|addToFunctionMap
argument_list|(
name|node
operator|->
name|getNameObj
argument_list|()
argument_list|,
name|sequence
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|preVisit
condition|)
name|visit
operator|=
name|visitAggregate
argument_list|(
name|PreVisit
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|visit
condition|)
block|{
name|bool
name|inFunctionMap
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|getOp
argument_list|()
operator|==
name|EOpFunctionCall
condition|)
block|{
name|inFunctionMap
operator|=
name|isInFunctionMap
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inFunctionMap
condition|)
block|{
comment|// The function is not user-defined - it is likely built-in texture function.
comment|// Assume that those do not have out parameters.
name|setInFunctionCallOutParameter
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
name|incrementDepth
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|inFunctionMap
condition|)
block|{
name|TIntermSequence
modifier|*
name|params
init|=
name|getFunctionParameters
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|TIntermSequence
operator|::
name|iterator
name|paramIter
init|=
name|params
operator|->
name|begin
argument_list|()
decl_stmt|;
for|for
control|(
name|auto
operator|*
name|child
operator|:
operator|*
name|sequence
control|)
block|{
name|ASSERT
argument_list|(
name|paramIter
operator|!=
name|params
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|TQualifier
name|qualifier
init|=
operator|(
operator|*
name|paramIter
operator|)
operator|->
name|getAsTyped
argument_list|()
operator|->
name|getQualifier
argument_list|()
decl_stmt|;
name|setInFunctionCallOutParameter
argument_list|(
name|qualifier
operator|==
name|EvqOut
operator|||
name|qualifier
operator|==
name|EvqInOut
argument_list|)
expr_stmt|;
name|child
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|visit
operator|&&
name|inVisit
condition|)
block|{
if|if
condition|(
name|child
operator|!=
name|sequence
operator|->
name|back
argument_list|()
condition|)
name|visit
operator|=
name|visitAggregate
argument_list|(
name|InVisit
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
operator|++
name|paramIter
expr_stmt|;
block|}
name|setInFunctionCallOutParameter
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|node
operator|->
name|getOp
argument_list|()
operator|==
name|EOpSequence
condition|)
name|pushParentBlock
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|// Find the built-in function corresponding to this op so that we can determine the
comment|// in/out qualifiers of its parameters.
name|TFunction
modifier|*
name|builtInFunc
init|=
literal|nullptr
decl_stmt|;
name|TString
name|opString
init|=
name|GetOperatorString
argument_list|(
name|node
operator|->
name|getOp
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|isConstructor
argument_list|()
operator|&&
operator|!
name|opString
operator|.
name|empty
argument_list|()
condition|)
block|{
comment|// The return type doesn't affect the mangled name of the function, which is used
comment|// to look it up from the symbol table.
name|TType
name|dummyReturnType
decl_stmt|;
name|TFunction
name|call
argument_list|(
operator|&
name|opString
argument_list|,
operator|&
name|dummyReturnType
argument_list|,
name|node
operator|->
name|getOp
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|auto
operator|*
name|child
operator|:
operator|*
name|sequence
control|)
block|{
name|TType
modifier|*
name|paramType
init|=
name|child
operator|->
name|getAsTyped
argument_list|()
operator|->
name|getTypePointer
argument_list|()
decl_stmt|;
name|TConstParameter
name|p
argument_list|(
name|paramType
argument_list|)
decl_stmt|;
name|call
operator|.
name|addParameter
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|TSymbol
modifier|*
name|sym
init|=
name|mSymbolTable
operator|.
name|findBuiltIn
argument_list|(
name|call
operator|.
name|getMangledName
argument_list|()
argument_list|,
name|mShaderVersion
argument_list|)
decl_stmt|;
if|if
condition|(
name|sym
operator|!=
literal|nullptr
operator|&&
name|sym
operator|->
name|isFunction
argument_list|()
condition|)
block|{
name|builtInFunc
operator|=
cast|static_cast
argument_list|<
name|TFunction
operator|*
argument_list|>
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|builtInFunc
operator|->
name|getParamCount
argument_list|()
operator|==
name|sequence
operator|->
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|size_t
name|paramIndex
init|=
literal|0
decl_stmt|;
for|for
control|(
name|auto
operator|*
name|child
operator|:
operator|*
name|sequence
control|)
block|{
name|TQualifier
name|qualifier
init|=
name|EvqIn
decl_stmt|;
if|if
condition|(
name|builtInFunc
operator|!=
literal|nullptr
condition|)
name|qualifier
operator|=
name|builtInFunc
operator|->
name|getParam
argument_list|(
name|paramIndex
argument_list|)
operator|.
name|type
operator|->
name|getQualifier
argument_list|()
expr_stmt|;
name|setInFunctionCallOutParameter
argument_list|(
name|qualifier
operator|==
name|EvqOut
operator|||
name|qualifier
operator|==
name|EvqInOut
argument_list|)
expr_stmt|;
name|child
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|visit
operator|&&
name|inVisit
condition|)
block|{
if|if
condition|(
name|child
operator|!=
name|sequence
operator|->
name|back
argument_list|()
condition|)
name|visit
operator|=
name|visitAggregate
argument_list|(
name|InVisit
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|getOp
argument_list|()
operator|==
name|EOpSequence
condition|)
name|incrementParentBlockPos
argument_list|()
expr_stmt|;
operator|++
name|paramIndex
expr_stmt|;
block|}
name|setInFunctionCallOutParameter
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getOp
argument_list|()
operator|==
name|EOpSequence
condition|)
name|popParentBlock
argument_list|()
expr_stmt|;
block|}
name|decrementDepth
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|visit
operator|&&
name|postVisit
condition|)
name|visitAggregate
argument_list|(
name|PostVisit
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Traverse a selection node.  Same comments in binary node apply here.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|traverseSelection
name|void
name|TIntermTraverser
operator|::
name|traverseSelection
parameter_list|(
name|TIntermSelection
modifier|*
name|node
parameter_list|)
block|{
name|bool
name|visit
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|preVisit
condition|)
name|visit
operator|=
name|visitSelection
argument_list|(
name|PreVisit
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|visit
condition|)
block|{
name|incrementDepth
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|->
name|getCondition
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getTrueBlock
argument_list|()
condition|)
name|node
operator|->
name|getTrueBlock
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getFalseBlock
argument_list|()
condition|)
name|node
operator|->
name|getFalseBlock
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|decrementDepth
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|visit
operator|&&
name|postVisit
condition|)
name|visitSelection
argument_list|(
name|PostVisit
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Traverse a switch node.  Same comments in binary node apply here.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|traverseSwitch
name|void
name|TIntermTraverser
operator|::
name|traverseSwitch
parameter_list|(
name|TIntermSwitch
modifier|*
name|node
parameter_list|)
block|{
name|bool
name|visit
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|preVisit
condition|)
name|visit
operator|=
name|visitSwitch
argument_list|(
name|PreVisit
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|visit
condition|)
block|{
name|incrementDepth
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|->
name|getInit
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|inVisit
condition|)
name|visit
operator|=
name|visitSwitch
argument_list|(
name|InVisit
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|visit
operator|&&
name|node
operator|->
name|getStatementList
argument_list|()
condition|)
name|node
operator|->
name|getStatementList
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|decrementDepth
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|visit
operator|&&
name|postVisit
condition|)
name|visitSwitch
argument_list|(
name|PostVisit
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Traverse a case node.  Same comments in binary node apply here.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|traverseCase
name|void
name|TIntermTraverser
operator|::
name|traverseCase
parameter_list|(
name|TIntermCase
modifier|*
name|node
parameter_list|)
block|{
name|bool
name|visit
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|preVisit
condition|)
name|visit
operator|=
name|visitCase
argument_list|(
name|PreVisit
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|visit
operator|&&
name|node
operator|->
name|getCondition
argument_list|()
condition|)
name|node
operator|->
name|getCondition
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|visit
operator|&&
name|postVisit
condition|)
name|visitCase
argument_list|(
name|PostVisit
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Traverse a loop node.  Same comments in binary node apply here.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|traverseLoop
name|void
name|TIntermTraverser
operator|::
name|traverseLoop
parameter_list|(
name|TIntermLoop
modifier|*
name|node
parameter_list|)
block|{
name|bool
name|visit
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|preVisit
condition|)
name|visit
operator|=
name|visitLoop
argument_list|(
name|PreVisit
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|visit
condition|)
block|{
name|incrementDepth
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getInit
argument_list|()
condition|)
name|node
operator|->
name|getInit
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getCondition
argument_list|()
condition|)
name|node
operator|->
name|getCondition
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getBody
argument_list|()
condition|)
name|node
operator|->
name|getBody
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getExpression
argument_list|()
condition|)
name|node
operator|->
name|getExpression
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|decrementDepth
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|visit
operator|&&
name|postVisit
condition|)
name|visitLoop
argument_list|(
name|PostVisit
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Traverse a branch node.  Same comments in binary node apply here.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|traverseBranch
name|void
name|TIntermTraverser
operator|::
name|traverseBranch
parameter_list|(
name|TIntermBranch
modifier|*
name|node
parameter_list|)
block|{
name|bool
name|visit
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|preVisit
condition|)
name|visit
operator|=
name|visitBranch
argument_list|(
name|PreVisit
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|visit
operator|&&
name|node
operator|->
name|getExpression
argument_list|()
condition|)
block|{
name|incrementDepth
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|->
name|getExpression
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|decrementDepth
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|visit
operator|&&
name|postVisit
condition|)
name|visitBranch
argument_list|(
name|PostVisit
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|traverseRaw
name|void
name|TIntermTraverser
operator|::
name|traverseRaw
parameter_list|(
name|TIntermRaw
modifier|*
name|node
parameter_list|)
block|{
name|visitRaw
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
end_function
end_unit
