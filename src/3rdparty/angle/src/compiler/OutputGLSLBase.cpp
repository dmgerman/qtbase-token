begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2011 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|"compiler/OutputGLSLBase.h"
end_include
begin_include
include|#
directive|include
file|"compiler/debug.h"
end_include
begin_include
include|#
directive|include
file|<cfloat>
end_include
begin_namespace
namespace|namespace
block|{
DECL|function|arrayBrackets
name|TString
name|arrayBrackets
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|type
operator|.
name|isArray
argument_list|()
argument_list|)
expr_stmt|;
name|TInfoSinkBase
name|out
decl_stmt|;
name|out
operator|<<
literal|"["
operator|<<
name|type
operator|.
name|getArraySize
argument_list|()
operator|<<
literal|"]"
expr_stmt|;
return|return
name|TString
argument_list|(
name|out
operator|.
name|c_str
argument_list|()
argument_list|)
return|;
block|}
DECL|function|isSingleStatement
name|bool
name|isSingleStatement
parameter_list|(
name|TIntermNode
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
specifier|const
name|TIntermAggregate
modifier|*
name|aggregate
init|=
name|node
operator|->
name|getAsAggregate
argument_list|()
condition|)
block|{
return|return
operator|(
name|aggregate
operator|->
name|getOp
argument_list|()
operator|!=
name|EOpFunction
operator|)
operator|&&
operator|(
name|aggregate
operator|->
name|getOp
argument_list|()
operator|!=
name|EOpSequence
operator|)
return|;
block|}
elseif|else
if|if
condition|(
specifier|const
name|TIntermSelection
modifier|*
name|selection
init|=
name|node
operator|->
name|getAsSelectionNode
argument_list|()
condition|)
block|{
comment|// Ternary operators are usually part of an assignment operator.
comment|// This handles those rare cases in which they are all by themselves.
return|return
name|selection
operator|->
name|usesTernaryOperator
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|getAsLoopNode
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
block|}
end_namespace
begin_comment
comment|// namespace
end_comment
begin_constructor
DECL|function|TOutputGLSLBase
name|TOutputGLSLBase
operator|::
name|TOutputGLSLBase
parameter_list|(
name|TInfoSinkBase
modifier|&
name|objSink
parameter_list|,
name|ShArrayIndexClampingStrategy
name|clampingStrategy
parameter_list|,
name|ShHashFunction64
name|hashFunction
parameter_list|,
name|NameMap
modifier|&
name|nameMap
parameter_list|,
name|TSymbolTable
modifier|&
name|symbolTable
parameter_list|)
member_init_list|:
name|TIntermTraverser
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
member_init_list|,
name|mObjSink
argument_list|(
name|objSink
argument_list|)
member_init_list|,
name|mDeclaringVariables
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mClampingStrategy
argument_list|(
name|clampingStrategy
argument_list|)
member_init_list|,
name|mHashFunction
argument_list|(
name|hashFunction
argument_list|)
member_init_list|,
name|mNameMap
argument_list|(
name|nameMap
argument_list|)
member_init_list|,
name|mSymbolTable
argument_list|(
name|symbolTable
argument_list|)
block|{ }
end_constructor
begin_function
DECL|function|writeTriplet
name|void
name|TOutputGLSLBase
operator|::
name|writeTriplet
parameter_list|(
name|Visit
name|visit
parameter_list|,
specifier|const
name|char
modifier|*
name|preStr
parameter_list|,
specifier|const
name|char
modifier|*
name|inStr
parameter_list|,
specifier|const
name|char
modifier|*
name|postStr
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|objSink
argument_list|()
decl_stmt|;
if|if
condition|(
name|visit
operator|==
name|PreVisit
operator|&&
name|preStr
condition|)
block|{
name|out
operator|<<
name|preStr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|visit
operator|==
name|InVisit
operator|&&
name|inStr
condition|)
block|{
name|out
operator|<<
name|inStr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|visit
operator|==
name|PostVisit
operator|&&
name|postStr
condition|)
block|{
name|out
operator|<<
name|postStr
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|writeVariableType
name|void
name|TOutputGLSLBase
operator|::
name|writeVariableType
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|objSink
argument_list|()
decl_stmt|;
name|TQualifier
name|qualifier
init|=
name|type
operator|.
name|getQualifier
argument_list|()
decl_stmt|;
comment|// TODO(alokp): Validate qualifier for variable declarations.
if|if
condition|(
operator|(
name|qualifier
operator|!=
name|EvqTemporary
operator|)
operator|&&
operator|(
name|qualifier
operator|!=
name|EvqGlobal
operator|)
condition|)
name|out
operator|<<
name|type
operator|.
name|getQualifierString
argument_list|()
operator|<<
literal|" "
expr_stmt|;
comment|// Declare the struct if we have not done so already.
if|if
condition|(
operator|(
name|type
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtStruct
operator|)
operator|&&
operator|(
name|mDeclaredStructs
operator|.
name|find
argument_list|(
name|type
operator|.
name|getTypeName
argument_list|()
argument_list|)
operator|==
name|mDeclaredStructs
operator|.
name|end
argument_list|()
operator|)
condition|)
block|{
name|out
operator|<<
literal|"struct "
operator|<<
name|hashName
argument_list|(
name|type
operator|.
name|getTypeName
argument_list|()
argument_list|)
operator|<<
literal|"{\n"
expr_stmt|;
specifier|const
name|TTypeList
modifier|*
name|structure
init|=
name|type
operator|.
name|getStruct
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|structure
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|structure
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|TType
modifier|*
name|fieldType
init|=
operator|(
operator|*
name|structure
operator|)
index|[
name|i
index|]
operator|.
name|type
decl_stmt|;
name|ASSERT
argument_list|(
name|fieldType
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|writeVariablePrecision
argument_list|(
name|fieldType
operator|->
name|getPrecision
argument_list|()
argument_list|)
condition|)
name|out
operator|<<
literal|" "
expr_stmt|;
name|out
operator|<<
name|getTypeName
argument_list|(
operator|*
name|fieldType
argument_list|)
operator|<<
literal|" "
operator|<<
name|hashName
argument_list|(
name|fieldType
operator|->
name|getFieldName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|fieldType
operator|->
name|isArray
argument_list|()
condition|)
name|out
operator|<<
name|arrayBrackets
argument_list|(
operator|*
name|fieldType
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|";\n"
expr_stmt|;
block|}
name|out
operator|<<
literal|"}"
expr_stmt|;
name|mDeclaredStructs
operator|.
name|insert
argument_list|(
name|type
operator|.
name|getTypeName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|writeVariablePrecision
argument_list|(
name|type
operator|.
name|getPrecision
argument_list|()
argument_list|)
condition|)
name|out
operator|<<
literal|" "
expr_stmt|;
name|out
operator|<<
name|getTypeName
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|writeFunctionParameters
name|void
name|TOutputGLSLBase
operator|::
name|writeFunctionParameters
parameter_list|(
specifier|const
name|TIntermSequence
modifier|&
name|args
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|objSink
argument_list|()
decl_stmt|;
for|for
control|(
name|TIntermSequence
operator|::
name|const_iterator
name|iter
init|=
name|args
operator|.
name|begin
argument_list|()
init|;
name|iter
operator|!=
name|args
operator|.
name|end
argument_list|()
condition|;
operator|++
name|iter
control|)
block|{
specifier|const
name|TIntermSymbol
modifier|*
name|arg
init|=
operator|(
operator|*
name|iter
operator|)
operator|->
name|getAsSymbolNode
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|arg
operator|!=
name|NULL
argument_list|)
expr_stmt|;
specifier|const
name|TType
modifier|&
name|type
init|=
name|arg
operator|->
name|getType
argument_list|()
decl_stmt|;
name|writeVariableType
argument_list|(
name|type
argument_list|)
expr_stmt|;
specifier|const
name|TString
modifier|&
name|name
init|=
name|arg
operator|->
name|getSymbol
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|name
operator|.
name|empty
argument_list|()
condition|)
name|out
operator|<<
literal|" "
operator|<<
name|hashName
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|.
name|isArray
argument_list|()
condition|)
name|out
operator|<<
name|arrayBrackets
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|// Put a comma if this is not the last argument.
if|if
condition|(
name|iter
operator|!=
name|args
operator|.
name|end
argument_list|()
operator|-
literal|1
condition|)
name|out
operator|<<
literal|", "
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|writeConstantUnion
specifier|const
name|ConstantUnion
modifier|*
name|TOutputGLSLBase
operator|::
name|writeConstantUnion
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|,
specifier|const
name|ConstantUnion
modifier|*
name|pConstUnion
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|objSink
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtStruct
condition|)
block|{
name|out
operator|<<
name|hashName
argument_list|(
name|type
operator|.
name|getTypeName
argument_list|()
argument_list|)
operator|<<
literal|"("
expr_stmt|;
specifier|const
name|TTypeList
modifier|*
name|structure
init|=
name|type
operator|.
name|getStruct
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|structure
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|structure
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|TType
modifier|*
name|fieldType
init|=
operator|(
operator|*
name|structure
operator|)
index|[
name|i
index|]
operator|.
name|type
decl_stmt|;
name|ASSERT
argument_list|(
name|fieldType
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|pConstUnion
operator|=
name|writeConstantUnion
argument_list|(
operator|*
name|fieldType
argument_list|,
name|pConstUnion
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|structure
operator|->
name|size
argument_list|()
operator|-
literal|1
condition|)
name|out
operator|<<
literal|", "
expr_stmt|;
block|}
name|out
operator|<<
literal|")"
expr_stmt|;
block|}
else|else
block|{
name|int
name|size
init|=
name|type
operator|.
name|getObjectSize
argument_list|()
decl_stmt|;
name|bool
name|writeType
init|=
name|size
operator|>
literal|1
decl_stmt|;
if|if
condition|(
name|writeType
condition|)
name|out
operator|<<
name|getTypeName
argument_list|(
name|type
argument_list|)
operator|<<
literal|"("
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
operator|,
operator|++
name|pConstUnion
control|)
block|{
switch|switch
condition|(
name|pConstUnion
operator|->
name|getType
argument_list|()
condition|)
block|{
case|case
name|EbtFloat
case|:
name|out
operator|<<
name|std
operator|::
name|min
argument_list|(
name|FLT_MAX
argument_list|,
name|std
operator|::
name|max
argument_list|(
operator|-
name|FLT_MAX
argument_list|,
name|pConstUnion
operator|->
name|getFConst
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EbtInt
case|:
name|out
operator|<<
name|pConstUnion
operator|->
name|getIConst
argument_list|()
expr_stmt|;
break|break;
case|case
name|EbtBool
case|:
name|out
operator|<<
name|pConstUnion
operator|->
name|getBConst
argument_list|()
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
name|size
operator|-
literal|1
condition|)
name|out
operator|<<
literal|", "
expr_stmt|;
block|}
if|if
condition|(
name|writeType
condition|)
name|out
operator|<<
literal|")"
expr_stmt|;
block|}
return|return
name|pConstUnion
return|;
block|}
end_function
begin_function
DECL|function|visitSymbol
name|void
name|TOutputGLSLBase
operator|::
name|visitSymbol
parameter_list|(
name|TIntermSymbol
modifier|*
name|node
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|objSink
argument_list|()
decl_stmt|;
if|if
condition|(
name|mLoopUnroll
operator|.
name|NeedsToReplaceSymbolWithValue
argument_list|(
name|node
argument_list|)
condition|)
name|out
operator|<<
name|mLoopUnroll
operator|.
name|GetLoopIndexValue
argument_list|(
name|node
argument_list|)
expr_stmt|;
else|else
name|out
operator|<<
name|hashVariableName
argument_list|(
name|node
operator|->
name|getSymbol
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|mDeclaringVariables
operator|&&
name|node
operator|->
name|getType
argument_list|()
operator|.
name|isArray
argument_list|()
condition|)
name|out
operator|<<
name|arrayBrackets
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|visitConstantUnion
name|void
name|TOutputGLSLBase
operator|::
name|visitConstantUnion
parameter_list|(
name|TIntermConstantUnion
modifier|*
name|node
parameter_list|)
block|{
name|writeConstantUnion
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|,
name|node
operator|->
name|getUnionArrayPointer
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|visitBinary
name|bool
name|TOutputGLSLBase
operator|::
name|visitBinary
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermBinary
modifier|*
name|node
parameter_list|)
block|{
name|bool
name|visitChildren
init|=
literal|true
decl_stmt|;
name|TInfoSinkBase
modifier|&
name|out
init|=
name|objSink
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|getOp
argument_list|()
condition|)
block|{
case|case
name|EOpInitialize
case|:
if|if
condition|(
name|visit
operator|==
name|InVisit
condition|)
block|{
name|out
operator|<<
literal|" = "
expr_stmt|;
comment|// RHS of initialize is not being declared.
name|mDeclaringVariables
operator|=
literal|false
expr_stmt|;
block|}
break|break;
case|case
name|EOpAssign
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" = "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpAddAssign
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" += "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpSubAssign
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" -= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpDivAssign
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" /= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
comment|// Notice the fall-through.
case|case
name|EOpMulAssign
case|:
case|case
name|EOpVectorTimesMatrixAssign
case|:
case|case
name|EOpVectorTimesScalarAssign
case|:
case|case
name|EOpMatrixTimesScalarAssign
case|:
case|case
name|EOpMatrixTimesMatrixAssign
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" *= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpIndexDirect
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
name|NULL
argument_list|,
literal|"["
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpIndexIndirect
case|:
if|if
condition|(
name|node
operator|->
name|getAddIndexClamp
argument_list|()
condition|)
block|{
if|if
condition|(
name|visit
operator|==
name|InVisit
condition|)
block|{
if|if
condition|(
name|mClampingStrategy
operator|==
name|SH_CLAMP_WITH_CLAMP_INTRINSIC
condition|)
block|{
name|out
operator|<<
literal|"[int(clamp(float("
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
literal|"[webgl_int_clamp("
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|visit
operator|==
name|PostVisit
condition|)
block|{
name|int
name|maxSize
decl_stmt|;
name|TIntermTyped
modifier|*
name|left
init|=
name|node
operator|->
name|getLeft
argument_list|()
decl_stmt|;
name|TType
name|leftType
init|=
name|left
operator|->
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|left
operator|->
name|isArray
argument_list|()
condition|)
block|{
comment|// The shader will fail validation if the array length is not> 0.
name|maxSize
operator|=
name|leftType
operator|.
name|getArraySize
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|maxSize
operator|=
name|leftType
operator|.
name|getNominalSize
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mClampingStrategy
operator|==
name|SH_CLAMP_WITH_CLAMP_INTRINSIC
condition|)
block|{
name|out
operator|<<
literal|"), 0.0, float("
operator|<<
name|maxSize
operator|<<
literal|")))]"
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
literal|", 0, "
operator|<<
name|maxSize
operator|<<
literal|")]"
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|writeTriplet
argument_list|(
name|visit
argument_list|,
name|NULL
argument_list|,
literal|"["
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EOpIndexDirectStruct
case|:
if|if
condition|(
name|visit
operator|==
name|InVisit
condition|)
block|{
name|out
operator|<<
literal|"."
expr_stmt|;
comment|// TODO(alokp): ASSERT
name|TString
name|fieldName
init|=
name|node
operator|->
name|getType
argument_list|()
operator|.
name|getFieldName
argument_list|()
decl_stmt|;
specifier|const
name|TType
modifier|&
name|structType
init|=
name|node
operator|->
name|getLeft
argument_list|()
operator|->
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|mSymbolTable
operator|.
name|findBuiltIn
argument_list|(
name|structType
operator|.
name|getTypeName
argument_list|()
argument_list|)
condition|)
name|fieldName
operator|=
name|hashName
argument_list|(
name|fieldName
argument_list|)
expr_stmt|;
name|out
operator|<<
name|fieldName
expr_stmt|;
name|visitChildren
operator|=
literal|false
expr_stmt|;
block|}
break|break;
case|case
name|EOpVectorSwizzle
case|:
if|if
condition|(
name|visit
operator|==
name|InVisit
condition|)
block|{
name|out
operator|<<
literal|"."
expr_stmt|;
name|TIntermAggregate
modifier|*
name|rightChild
init|=
name|node
operator|->
name|getRight
argument_list|()
operator|->
name|getAsAggregate
argument_list|()
decl_stmt|;
name|TIntermSequence
modifier|&
name|sequence
init|=
name|rightChild
operator|->
name|getSequence
argument_list|()
decl_stmt|;
for|for
control|(
name|TIntermSequence
operator|::
name|iterator
name|sit
init|=
name|sequence
operator|.
name|begin
argument_list|()
init|;
name|sit
operator|!=
name|sequence
operator|.
name|end
argument_list|()
condition|;
operator|++
name|sit
control|)
block|{
name|TIntermConstantUnion
modifier|*
name|element
init|=
operator|(
operator|*
name|sit
operator|)
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|element
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtInt
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|element
operator|->
name|getNominalSize
argument_list|()
operator|==
literal|1
argument_list|)
expr_stmt|;
specifier|const
name|ConstantUnion
modifier|&
name|data
init|=
name|element
operator|->
name|getUnionArrayPointer
argument_list|()
index|[
literal|0
index|]
decl_stmt|;
name|ASSERT
argument_list|(
name|data
operator|.
name|getType
argument_list|()
operator|==
name|EbtInt
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|data
operator|.
name|getIConst
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
name|out
operator|<<
literal|"x"
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|out
operator|<<
literal|"y"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|out
operator|<<
literal|"z"
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|out
operator|<<
literal|"w"
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|visitChildren
operator|=
literal|false
expr_stmt|;
block|}
break|break;
case|case
name|EOpAdd
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" + "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpSub
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" - "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpMul
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" * "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpDiv
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" / "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpMod
case|:
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
break|break;
case|case
name|EOpEqual
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" == "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpNotEqual
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" != "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpLessThan
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|"< "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpGreaterThan
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|"> "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpLessThanEqual
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|"<= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpGreaterThanEqual
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|">= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
comment|// Notice the fall-through.
case|case
name|EOpVectorTimesScalar
case|:
case|case
name|EOpVectorTimesMatrix
case|:
case|case
name|EOpMatrixTimesVector
case|:
case|case
name|EOpMatrixTimesScalar
case|:
case|case
name|EOpMatrixTimesMatrix
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" * "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpLogicalOr
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" || "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpLogicalXor
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" ^^ "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpLogicalAnd
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|"&& "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
name|visitChildren
return|;
block|}
end_function
begin_function
DECL|function|visitUnary
name|bool
name|TOutputGLSLBase
operator|::
name|visitUnary
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermUnary
modifier|*
name|node
parameter_list|)
block|{
name|TString
name|preString
decl_stmt|;
name|TString
name|postString
init|=
literal|")"
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|getOp
argument_list|()
condition|)
block|{
case|case
name|EOpNegative
case|:
name|preString
operator|=
literal|"(-"
expr_stmt|;
break|break;
case|case
name|EOpVectorLogicalNot
case|:
name|preString
operator|=
literal|"not("
expr_stmt|;
break|break;
case|case
name|EOpLogicalNot
case|:
name|preString
operator|=
literal|"(!"
expr_stmt|;
break|break;
case|case
name|EOpPostIncrement
case|:
name|preString
operator|=
literal|"("
expr_stmt|;
name|postString
operator|=
literal|"++)"
expr_stmt|;
break|break;
case|case
name|EOpPostDecrement
case|:
name|preString
operator|=
literal|"("
expr_stmt|;
name|postString
operator|=
literal|"--)"
expr_stmt|;
break|break;
case|case
name|EOpPreIncrement
case|:
name|preString
operator|=
literal|"(++"
expr_stmt|;
break|break;
case|case
name|EOpPreDecrement
case|:
name|preString
operator|=
literal|"(--"
expr_stmt|;
break|break;
case|case
name|EOpConvIntToBool
case|:
case|case
name|EOpConvFloatToBool
case|:
switch|switch
condition|(
name|node
operator|->
name|getOperand
argument_list|()
operator|->
name|getType
argument_list|()
operator|.
name|getNominalSize
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
name|preString
operator|=
literal|"bool("
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|preString
operator|=
literal|"bvec2("
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|preString
operator|=
literal|"bvec3("
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|preString
operator|=
literal|"bvec4("
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|EOpConvBoolToFloat
case|:
case|case
name|EOpConvIntToFloat
case|:
switch|switch
condition|(
name|node
operator|->
name|getOperand
argument_list|()
operator|->
name|getType
argument_list|()
operator|.
name|getNominalSize
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
name|preString
operator|=
literal|"float("
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|preString
operator|=
literal|"vec2("
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|preString
operator|=
literal|"vec3("
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|preString
operator|=
literal|"vec4("
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|EOpConvFloatToInt
case|:
case|case
name|EOpConvBoolToInt
case|:
switch|switch
condition|(
name|node
operator|->
name|getOperand
argument_list|()
operator|->
name|getType
argument_list|()
operator|.
name|getNominalSize
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
name|preString
operator|=
literal|"int("
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|preString
operator|=
literal|"ivec2("
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|preString
operator|=
literal|"ivec3("
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|preString
operator|=
literal|"ivec4("
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|EOpRadians
case|:
name|preString
operator|=
literal|"radians("
expr_stmt|;
break|break;
case|case
name|EOpDegrees
case|:
name|preString
operator|=
literal|"degrees("
expr_stmt|;
break|break;
case|case
name|EOpSin
case|:
name|preString
operator|=
literal|"sin("
expr_stmt|;
break|break;
case|case
name|EOpCos
case|:
name|preString
operator|=
literal|"cos("
expr_stmt|;
break|break;
case|case
name|EOpTan
case|:
name|preString
operator|=
literal|"tan("
expr_stmt|;
break|break;
case|case
name|EOpAsin
case|:
name|preString
operator|=
literal|"asin("
expr_stmt|;
break|break;
case|case
name|EOpAcos
case|:
name|preString
operator|=
literal|"acos("
expr_stmt|;
break|break;
case|case
name|EOpAtan
case|:
name|preString
operator|=
literal|"atan("
expr_stmt|;
break|break;
case|case
name|EOpExp
case|:
name|preString
operator|=
literal|"exp("
expr_stmt|;
break|break;
case|case
name|EOpLog
case|:
name|preString
operator|=
literal|"log("
expr_stmt|;
break|break;
case|case
name|EOpExp2
case|:
name|preString
operator|=
literal|"exp2("
expr_stmt|;
break|break;
case|case
name|EOpLog2
case|:
name|preString
operator|=
literal|"log2("
expr_stmt|;
break|break;
case|case
name|EOpSqrt
case|:
name|preString
operator|=
literal|"sqrt("
expr_stmt|;
break|break;
case|case
name|EOpInverseSqrt
case|:
name|preString
operator|=
literal|"inversesqrt("
expr_stmt|;
break|break;
case|case
name|EOpAbs
case|:
name|preString
operator|=
literal|"abs("
expr_stmt|;
break|break;
case|case
name|EOpSign
case|:
name|preString
operator|=
literal|"sign("
expr_stmt|;
break|break;
case|case
name|EOpFloor
case|:
name|preString
operator|=
literal|"floor("
expr_stmt|;
break|break;
case|case
name|EOpCeil
case|:
name|preString
operator|=
literal|"ceil("
expr_stmt|;
break|break;
case|case
name|EOpFract
case|:
name|preString
operator|=
literal|"fract("
expr_stmt|;
break|break;
case|case
name|EOpLength
case|:
name|preString
operator|=
literal|"length("
expr_stmt|;
break|break;
case|case
name|EOpNormalize
case|:
name|preString
operator|=
literal|"normalize("
expr_stmt|;
break|break;
case|case
name|EOpDFdx
case|:
name|preString
operator|=
literal|"dFdx("
expr_stmt|;
break|break;
case|case
name|EOpDFdy
case|:
name|preString
operator|=
literal|"dFdy("
expr_stmt|;
break|break;
case|case
name|EOpFwidth
case|:
name|preString
operator|=
literal|"fwidth("
expr_stmt|;
break|break;
case|case
name|EOpAny
case|:
name|preString
operator|=
literal|"any("
expr_stmt|;
break|break;
case|case
name|EOpAll
case|:
name|preString
operator|=
literal|"all("
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|visit
operator|==
name|PreVisit
operator|&&
name|node
operator|->
name|getUseEmulatedFunction
argument_list|()
condition|)
name|preString
operator|=
name|BuiltInFunctionEmulator
operator|::
name|GetEmulatedFunctionName
argument_list|(
name|preString
argument_list|)
expr_stmt|;
name|writeTriplet
argument_list|(
name|visit
argument_list|,
name|preString
operator|.
name|c_str
argument_list|()
argument_list|,
name|NULL
argument_list|,
name|postString
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|visitSelection
name|bool
name|TOutputGLSLBase
operator|::
name|visitSelection
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermSelection
modifier|*
name|node
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|objSink
argument_list|()
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|usesTernaryOperator
argument_list|()
condition|)
block|{
comment|// Notice two brackets at the beginning and end. The outer ones
comment|// encapsulate the whole ternary expression. This preserves the
comment|// order of precedence when ternary expressions are used in a
comment|// compound expression, i.e., c = 2 * (a< b ? 1 : 2).
name|out
operator|<<
literal|"(("
expr_stmt|;
name|node
operator|->
name|getCondition
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|") ? ("
expr_stmt|;
name|node
operator|->
name|getTrueBlock
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|") : ("
expr_stmt|;
name|node
operator|->
name|getFalseBlock
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"))"
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
literal|"if ("
expr_stmt|;
name|node
operator|->
name|getCondition
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|")\n"
expr_stmt|;
name|incrementDepth
argument_list|()
expr_stmt|;
name|visitCodeBlock
argument_list|(
name|node
operator|->
name|getTrueBlock
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getFalseBlock
argument_list|()
condition|)
block|{
name|out
operator|<<
literal|"else\n"
expr_stmt|;
name|visitCodeBlock
argument_list|(
name|node
operator|->
name|getFalseBlock
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|decrementDepth
argument_list|()
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|visitAggregate
name|bool
name|TOutputGLSLBase
operator|::
name|visitAggregate
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermAggregate
modifier|*
name|node
parameter_list|)
block|{
name|bool
name|visitChildren
init|=
literal|true
decl_stmt|;
name|TInfoSinkBase
modifier|&
name|out
init|=
name|objSink
argument_list|()
decl_stmt|;
name|TString
name|preString
decl_stmt|;
name|bool
name|delayedWrite
init|=
literal|false
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|getOp
argument_list|()
condition|)
block|{
case|case
name|EOpSequence
case|:
block|{
comment|// Scope the sequences except when at the global scope.
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
name|out
operator|<<
literal|"{\n"
expr_stmt|;
name|incrementDepth
argument_list|()
expr_stmt|;
specifier|const
name|TIntermSequence
modifier|&
name|sequence
init|=
name|node
operator|->
name|getSequence
argument_list|()
decl_stmt|;
for|for
control|(
name|TIntermSequence
operator|::
name|const_iterator
name|iter
init|=
name|sequence
operator|.
name|begin
argument_list|()
init|;
name|iter
operator|!=
name|sequence
operator|.
name|end
argument_list|()
condition|;
operator|++
name|iter
control|)
block|{
name|TIntermNode
modifier|*
name|node
init|=
operator|*
name|iter
decl_stmt|;
name|ASSERT
argument_list|(
name|node
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|node
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|isSingleStatement
argument_list|(
name|node
argument_list|)
condition|)
name|out
operator|<<
literal|";\n"
expr_stmt|;
block|}
name|decrementDepth
argument_list|()
expr_stmt|;
comment|// Scope the sequences except when at the global scope.
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
name|out
operator|<<
literal|"}\n"
expr_stmt|;
name|visitChildren
operator|=
literal|false
expr_stmt|;
break|break;
block|}
case|case
name|EOpPrototype
case|:
block|{
comment|// Function declaration.
name|ASSERT
argument_list|(
name|visit
operator|==
name|PreVisit
argument_list|)
expr_stmt|;
name|writeVariableType
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|" "
operator|<<
name|hashName
argument_list|(
name|node
operator|->
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"("
expr_stmt|;
name|writeFunctionParameters
argument_list|(
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|")"
expr_stmt|;
name|visitChildren
operator|=
literal|false
expr_stmt|;
break|break;
block|}
case|case
name|EOpFunction
case|:
block|{
comment|// Function definition.
name|ASSERT
argument_list|(
name|visit
operator|==
name|PreVisit
argument_list|)
expr_stmt|;
name|writeVariableType
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|" "
operator|<<
name|hashFunctionName
argument_list|(
name|node
operator|->
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|incrementDepth
argument_list|()
expr_stmt|;
comment|// Function definition node contains one or two children nodes
comment|// representing function parameters and function body. The latter
comment|// is not present in case of empty function bodies.
specifier|const
name|TIntermSequence
modifier|&
name|sequence
init|=
name|node
operator|->
name|getSequence
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
name|sequence
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|)
operator|||
operator|(
name|sequence
operator|.
name|size
argument_list|()
operator|==
literal|2
operator|)
argument_list|)
expr_stmt|;
name|TIntermSequence
operator|::
name|const_iterator
name|seqIter
init|=
name|sequence
operator|.
name|begin
argument_list|()
decl_stmt|;
comment|// Traverse function parameters.
name|TIntermAggregate
modifier|*
name|params
init|=
operator|(
operator|*
name|seqIter
operator|)
operator|->
name|getAsAggregate
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|params
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|params
operator|->
name|getOp
argument_list|()
operator|==
name|EOpParameters
argument_list|)
expr_stmt|;
name|params
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Traverse function body.
name|TIntermAggregate
modifier|*
name|body
init|=
operator|++
name|seqIter
operator|!=
name|sequence
operator|.
name|end
argument_list|()
condition|?
operator|(
operator|*
name|seqIter
operator|)
operator|->
name|getAsAggregate
argument_list|()
else|:
name|NULL
decl_stmt|;
name|visitCodeBlock
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|decrementDepth
argument_list|()
expr_stmt|;
comment|// Fully processed; no need to visit children.
name|visitChildren
operator|=
literal|false
expr_stmt|;
break|break;
block|}
case|case
name|EOpFunctionCall
case|:
comment|// Function call.
if|if
condition|(
name|visit
operator|==
name|PreVisit
condition|)
block|{
name|out
operator|<<
name|hashFunctionName
argument_list|(
name|node
operator|->
name|getName
argument_list|()
argument_list|)
operator|<<
literal|"("
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|visit
operator|==
name|InVisit
condition|)
block|{
name|out
operator|<<
literal|", "
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
literal|")"
expr_stmt|;
block|}
break|break;
case|case
name|EOpParameters
case|:
block|{
comment|// Function parameters.
name|ASSERT
argument_list|(
name|visit
operator|==
name|PreVisit
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"("
expr_stmt|;
name|writeFunctionParameters
argument_list|(
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|")"
expr_stmt|;
name|visitChildren
operator|=
literal|false
expr_stmt|;
break|break;
block|}
case|case
name|EOpDeclaration
case|:
block|{
comment|// Variable declaration.
if|if
condition|(
name|visit
operator|==
name|PreVisit
condition|)
block|{
specifier|const
name|TIntermSequence
modifier|&
name|sequence
init|=
name|node
operator|->
name|getSequence
argument_list|()
decl_stmt|;
specifier|const
name|TIntermTyped
modifier|*
name|variable
init|=
name|sequence
operator|.
name|front
argument_list|()
operator|->
name|getAsTyped
argument_list|()
decl_stmt|;
name|writeVariableType
argument_list|(
name|variable
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|" "
expr_stmt|;
name|mDeclaringVariables
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|visit
operator|==
name|InVisit
condition|)
block|{
name|out
operator|<<
literal|", "
expr_stmt|;
name|mDeclaringVariables
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|mDeclaringVariables
operator|=
literal|false
expr_stmt|;
block|}
break|break;
block|}
case|case
name|EOpConstructFloat
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"float("
argument_list|,
name|NULL
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructVec2
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"vec2("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructVec3
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"vec3("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructVec4
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"vec4("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructBool
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"bool("
argument_list|,
name|NULL
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructBVec2
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"bvec2("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructBVec3
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"bvec3("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructBVec4
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"bvec4("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructInt
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"int("
argument_list|,
name|NULL
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructIVec2
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"ivec2("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructIVec3
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"ivec3("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructIVec4
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"ivec4("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructMat2
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"mat2("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructMat3
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"mat3("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructMat4
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"mat4("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructStruct
case|:
if|if
condition|(
name|visit
operator|==
name|PreVisit
condition|)
block|{
specifier|const
name|TType
modifier|&
name|type
init|=
name|node
operator|->
name|getType
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|type
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtStruct
argument_list|)
expr_stmt|;
name|out
operator|<<
name|hashName
argument_list|(
name|type
operator|.
name|getTypeName
argument_list|()
argument_list|)
operator|<<
literal|"("
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|visit
operator|==
name|InVisit
condition|)
block|{
name|out
operator|<<
literal|", "
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
literal|")"
expr_stmt|;
block|}
break|break;
case|case
name|EOpLessThan
case|:
name|preString
operator|=
literal|"lessThan("
expr_stmt|;
name|delayedWrite
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|EOpGreaterThan
case|:
name|preString
operator|=
literal|"greaterThan("
expr_stmt|;
name|delayedWrite
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|EOpLessThanEqual
case|:
name|preString
operator|=
literal|"lessThanEqual("
expr_stmt|;
name|delayedWrite
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|EOpGreaterThanEqual
case|:
name|preString
operator|=
literal|"greaterThanEqual("
expr_stmt|;
name|delayedWrite
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|EOpVectorEqual
case|:
name|preString
operator|=
literal|"equal("
expr_stmt|;
name|delayedWrite
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|EOpVectorNotEqual
case|:
name|preString
operator|=
literal|"notEqual("
expr_stmt|;
name|delayedWrite
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|EOpComma
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
name|NULL
argument_list|,
literal|", "
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpMod
case|:
name|preString
operator|=
literal|"mod("
expr_stmt|;
name|delayedWrite
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|EOpPow
case|:
name|preString
operator|=
literal|"pow("
expr_stmt|;
name|delayedWrite
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|EOpAtan
case|:
name|preString
operator|=
literal|"atan("
expr_stmt|;
name|delayedWrite
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|EOpMin
case|:
name|preString
operator|=
literal|"min("
expr_stmt|;
name|delayedWrite
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|EOpMax
case|:
name|preString
operator|=
literal|"max("
expr_stmt|;
name|delayedWrite
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|EOpClamp
case|:
name|preString
operator|=
literal|"clamp("
expr_stmt|;
name|delayedWrite
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|EOpMix
case|:
name|preString
operator|=
literal|"mix("
expr_stmt|;
name|delayedWrite
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|EOpStep
case|:
name|preString
operator|=
literal|"step("
expr_stmt|;
name|delayedWrite
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|EOpSmoothStep
case|:
name|preString
operator|=
literal|"smoothstep("
expr_stmt|;
name|delayedWrite
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|EOpDistance
case|:
name|preString
operator|=
literal|"distance("
expr_stmt|;
name|delayedWrite
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|EOpDot
case|:
name|preString
operator|=
literal|"dot("
expr_stmt|;
name|delayedWrite
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|EOpCross
case|:
name|preString
operator|=
literal|"cross("
expr_stmt|;
name|delayedWrite
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|EOpFaceForward
case|:
name|preString
operator|=
literal|"faceforward("
expr_stmt|;
name|delayedWrite
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|EOpReflect
case|:
name|preString
operator|=
literal|"reflect("
expr_stmt|;
name|delayedWrite
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|EOpRefract
case|:
name|preString
operator|=
literal|"refract("
expr_stmt|;
name|delayedWrite
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|EOpMul
case|:
name|preString
operator|=
literal|"matrixCompMult("
expr_stmt|;
name|delayedWrite
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|delayedWrite
operator|&&
name|visit
operator|==
name|PreVisit
operator|&&
name|node
operator|->
name|getUseEmulatedFunction
argument_list|()
condition|)
name|preString
operator|=
name|BuiltInFunctionEmulator
operator|::
name|GetEmulatedFunctionName
argument_list|(
name|preString
argument_list|)
expr_stmt|;
if|if
condition|(
name|delayedWrite
condition|)
name|writeTriplet
argument_list|(
name|visit
argument_list|,
name|preString
operator|.
name|c_str
argument_list|()
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
return|return
name|visitChildren
return|;
block|}
end_function
begin_function
DECL|function|visitLoop
name|bool
name|TOutputGLSLBase
operator|::
name|visitLoop
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermLoop
modifier|*
name|node
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|objSink
argument_list|()
decl_stmt|;
name|incrementDepth
argument_list|()
expr_stmt|;
comment|// Loop header.
name|TLoopType
name|loopType
init|=
name|node
operator|->
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|loopType
operator|==
name|ELoopFor
condition|)
comment|// for loop
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|getUnrollFlag
argument_list|()
condition|)
block|{
name|out
operator|<<
literal|"for ("
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getInit
argument_list|()
condition|)
name|node
operator|->
name|getInit
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"; "
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getCondition
argument_list|()
condition|)
name|node
operator|->
name|getCondition
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"; "
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getExpression
argument_list|()
condition|)
name|node
operator|->
name|getExpression
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|")\n"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|loopType
operator|==
name|ELoopWhile
condition|)
comment|// while loop
block|{
name|out
operator|<<
literal|"while ("
expr_stmt|;
name|ASSERT
argument_list|(
name|node
operator|->
name|getCondition
argument_list|()
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|node
operator|->
name|getCondition
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|")\n"
expr_stmt|;
block|}
else|else
comment|// do-while loop
block|{
name|ASSERT
argument_list|(
name|loopType
operator|==
name|ELoopDoWhile
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"do\n"
expr_stmt|;
block|}
comment|// Loop body.
if|if
condition|(
name|node
operator|->
name|getUnrollFlag
argument_list|()
condition|)
block|{
name|TLoopIndexInfo
name|indexInfo
decl_stmt|;
name|mLoopUnroll
operator|.
name|FillLoopIndexInfo
argument_list|(
name|node
argument_list|,
name|indexInfo
argument_list|)
expr_stmt|;
name|mLoopUnroll
operator|.
name|Push
argument_list|(
name|indexInfo
argument_list|)
expr_stmt|;
while|while
condition|(
name|mLoopUnroll
operator|.
name|SatisfiesLoopCondition
argument_list|()
condition|)
block|{
name|visitCodeBlock
argument_list|(
name|node
operator|->
name|getBody
argument_list|()
argument_list|)
expr_stmt|;
name|mLoopUnroll
operator|.
name|Step
argument_list|()
expr_stmt|;
block|}
name|mLoopUnroll
operator|.
name|Pop
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|visitCodeBlock
argument_list|(
name|node
operator|->
name|getBody
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Loop footer.
if|if
condition|(
name|loopType
operator|==
name|ELoopDoWhile
condition|)
comment|// do-while loop
block|{
name|out
operator|<<
literal|"while ("
expr_stmt|;
name|ASSERT
argument_list|(
name|node
operator|->
name|getCondition
argument_list|()
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|node
operator|->
name|getCondition
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|");\n"
expr_stmt|;
block|}
name|decrementDepth
argument_list|()
expr_stmt|;
comment|// No need to visit children. They have been already processed in
comment|// this function.
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|visitBranch
name|bool
name|TOutputGLSLBase
operator|::
name|visitBranch
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermBranch
modifier|*
name|node
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|->
name|getFlowOp
argument_list|()
condition|)
block|{
case|case
name|EOpKill
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"discard"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpBreak
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"break"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpContinue
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"continue"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpReturn
case|:
name|writeTriplet
argument_list|(
name|visit
argument_list|,
literal|"return "
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|visitCodeBlock
name|void
name|TOutputGLSLBase
operator|::
name|visitCodeBlock
parameter_list|(
name|TIntermNode
modifier|*
name|node
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|objSink
argument_list|()
decl_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
block|{
name|node
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Single statements not part of a sequence need to be terminated
comment|// with semi-colon.
if|if
condition|(
name|isSingleStatement
argument_list|(
name|node
argument_list|)
condition|)
name|out
operator|<<
literal|";\n"
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
literal|"{\n}\n"
expr_stmt|;
comment|// Empty code block.
block|}
block|}
end_function
begin_function
DECL|function|getTypeName
name|TString
name|TOutputGLSLBase
operator|::
name|getTypeName
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|)
block|{
name|TInfoSinkBase
name|out
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|isMatrix
argument_list|()
condition|)
block|{
name|out
operator|<<
literal|"mat"
expr_stmt|;
name|out
operator|<<
name|type
operator|.
name|getNominalSize
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|isVector
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|type
operator|.
name|getBasicType
argument_list|()
condition|)
block|{
case|case
name|EbtFloat
case|:
name|out
operator|<<
literal|"vec"
expr_stmt|;
break|break;
case|case
name|EbtInt
case|:
name|out
operator|<<
literal|"ivec"
expr_stmt|;
break|break;
case|case
name|EbtBool
case|:
name|out
operator|<<
literal|"bvec"
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
name|out
operator|<<
name|type
operator|.
name|getNominalSize
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|type
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtStruct
condition|)
name|out
operator|<<
name|hashName
argument_list|(
name|type
operator|.
name|getTypeName
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|out
operator|<<
name|type
operator|.
name|getBasicString
argument_list|()
expr_stmt|;
block|}
return|return
name|TString
argument_list|(
name|out
operator|.
name|c_str
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|hashName
name|TString
name|TOutputGLSLBase
operator|::
name|hashName
parameter_list|(
specifier|const
name|TString
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
name|mHashFunction
operator|==
name|NULL
operator|||
name|name
operator|.
name|empty
argument_list|()
condition|)
return|return
name|name
return|;
name|NameMap
operator|::
name|const_iterator
name|it
init|=
name|mNameMap
operator|.
name|find
argument_list|(
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|mNameMap
operator|.
name|end
argument_list|()
condition|)
return|return
name|it
operator|->
name|second
operator|.
name|c_str
argument_list|()
return|;
name|TString
name|hashedName
init|=
name|TIntermTraverser
operator|::
name|hash
argument_list|(
name|name
argument_list|,
name|mHashFunction
argument_list|)
decl_stmt|;
name|mNameMap
index|[
name|name
operator|.
name|c_str
argument_list|()
index|]
operator|=
name|hashedName
operator|.
name|c_str
argument_list|()
expr_stmt|;
return|return
name|hashedName
return|;
block|}
end_function
begin_function
DECL|function|hashVariableName
name|TString
name|TOutputGLSLBase
operator|::
name|hashVariableName
parameter_list|(
specifier|const
name|TString
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
name|mSymbolTable
operator|.
name|findBuiltIn
argument_list|(
name|name
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|name
return|;
return|return
name|hashName
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|hashFunctionName
name|TString
name|TOutputGLSLBase
operator|::
name|hashFunctionName
parameter_list|(
specifier|const
name|TString
modifier|&
name|mangled_name
parameter_list|)
block|{
name|TString
name|name
init|=
name|TFunction
operator|::
name|unmangleName
argument_list|(
name|mangled_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|mSymbolTable
operator|.
name|findBuiltIn
argument_list|(
name|mangled_name
argument_list|)
operator|!=
name|NULL
operator|||
name|name
operator|==
literal|"main"
condition|)
return|return
name|name
return|;
return|return
name|hashName
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function
end_unit
