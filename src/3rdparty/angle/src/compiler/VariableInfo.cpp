begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2010 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|"compiler/VariableInfo.h"
end_include
begin_function
DECL|function|arrayBrackets
specifier|static
name|TString
name|arrayBrackets
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|TStringStream
name|stream
decl_stmt|;
name|stream
operator|<<
literal|"["
operator|<<
name|index
operator|<<
literal|"]"
expr_stmt|;
return|return
name|stream
operator|.
name|str
argument_list|()
return|;
block|}
end_function
begin_comment
comment|// Returns the data type for an attribute or uniform.
end_comment
begin_function
DECL|function|getVariableDataType
specifier|static
name|ShDataType
name|getVariableDataType
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
operator|.
name|getBasicType
argument_list|()
condition|)
block|{
case|case
name|EbtFloat
case|:
if|if
condition|(
name|type
operator|.
name|isMatrix
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|type
operator|.
name|getNominalSize
argument_list|()
condition|)
block|{
case|case
literal|2
case|:
return|return
name|SH_FLOAT_MAT2
return|;
case|case
literal|3
case|:
return|return
name|SH_FLOAT_MAT3
return|;
case|case
literal|4
case|:
return|return
name|SH_FLOAT_MAT4
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|isVector
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|type
operator|.
name|getNominalSize
argument_list|()
condition|)
block|{
case|case
literal|2
case|:
return|return
name|SH_FLOAT_VEC2
return|;
case|case
literal|3
case|:
return|return
name|SH_FLOAT_VEC3
return|;
case|case
literal|4
case|:
return|return
name|SH_FLOAT_VEC4
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
return|return
name|SH_FLOAT
return|;
block|}
case|case
name|EbtInt
case|:
if|if
condition|(
name|type
operator|.
name|isMatrix
argument_list|()
condition|)
block|{
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|isVector
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|type
operator|.
name|getNominalSize
argument_list|()
condition|)
block|{
case|case
literal|2
case|:
return|return
name|SH_INT_VEC2
return|;
case|case
literal|3
case|:
return|return
name|SH_INT_VEC3
return|;
case|case
literal|4
case|:
return|return
name|SH_INT_VEC4
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
return|return
name|SH_INT
return|;
block|}
case|case
name|EbtBool
case|:
if|if
condition|(
name|type
operator|.
name|isMatrix
argument_list|()
condition|)
block|{
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|isVector
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|type
operator|.
name|getNominalSize
argument_list|()
condition|)
block|{
case|case
literal|2
case|:
return|return
name|SH_BOOL_VEC2
return|;
case|case
literal|3
case|:
return|return
name|SH_BOOL_VEC3
return|;
case|case
literal|4
case|:
return|return
name|SH_BOOL_VEC4
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
return|return
name|SH_BOOL
return|;
block|}
case|case
name|EbtSampler2D
case|:
return|return
name|SH_SAMPLER_2D
return|;
case|case
name|EbtSamplerCube
case|:
return|return
name|SH_SAMPLER_CUBE
return|;
case|case
name|EbtSamplerExternalOES
case|:
return|return
name|SH_SAMPLER_EXTERNAL_OES
return|;
case|case
name|EbtSampler2DRect
case|:
return|return
name|SH_SAMPLER_2D_RECT_ARB
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
name|SH_NONE
return|;
block|}
end_function
begin_function_decl
specifier|static
name|void
name|getBuiltInVariableInfo
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|,
specifier|const
name|TString
modifier|&
name|name
parameter_list|,
specifier|const
name|TString
modifier|&
name|mappedName
parameter_list|,
name|TVariableInfoList
modifier|&
name|infoList
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|getUserDefinedVariableInfo
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|,
specifier|const
name|TString
modifier|&
name|name
parameter_list|,
specifier|const
name|TString
modifier|&
name|mappedName
parameter_list|,
name|TVariableInfoList
modifier|&
name|infoList
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|// Returns info for an attribute or uniform.
end_comment
begin_function
DECL|function|getVariableInfo
specifier|static
name|void
name|getVariableInfo
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|,
specifier|const
name|TString
modifier|&
name|name
parameter_list|,
specifier|const
name|TString
modifier|&
name|mappedName
parameter_list|,
name|TVariableInfoList
modifier|&
name|infoList
parameter_list|)
block|{
if|if
condition|(
name|type
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtStruct
condition|)
block|{
if|if
condition|(
name|type
operator|.
name|isArray
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|type
operator|.
name|getArraySize
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|TString
name|lname
init|=
name|name
operator|+
name|arrayBrackets
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|TString
name|lmappedName
init|=
name|mappedName
operator|+
name|arrayBrackets
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|getUserDefinedVariableInfo
argument_list|(
name|type
argument_list|,
name|lname
argument_list|,
name|lmappedName
argument_list|,
name|infoList
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|getUserDefinedVariableInfo
argument_list|(
name|type
argument_list|,
name|name
argument_list|,
name|mappedName
argument_list|,
name|infoList
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|getBuiltInVariableInfo
argument_list|(
name|type
argument_list|,
name|name
argument_list|,
name|mappedName
argument_list|,
name|infoList
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|getBuiltInVariableInfo
name|void
name|getBuiltInVariableInfo
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|,
specifier|const
name|TString
modifier|&
name|name
parameter_list|,
specifier|const
name|TString
modifier|&
name|mappedName
parameter_list|,
name|TVariableInfoList
modifier|&
name|infoList
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|type
operator|.
name|getBasicType
argument_list|()
operator|!=
name|EbtStruct
argument_list|)
expr_stmt|;
name|TVariableInfo
name|varInfo
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|isArray
argument_list|()
condition|)
block|{
name|varInfo
operator|.
name|name
operator|=
operator|(
name|name
operator|+
literal|"[0]"
operator|)
operator|.
name|c_str
argument_list|()
expr_stmt|;
name|varInfo
operator|.
name|mappedName
operator|=
operator|(
name|mappedName
operator|+
literal|"[0]"
operator|)
operator|.
name|c_str
argument_list|()
expr_stmt|;
name|varInfo
operator|.
name|size
operator|=
name|type
operator|.
name|getArraySize
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|varInfo
operator|.
name|name
operator|=
name|name
operator|.
name|c_str
argument_list|()
expr_stmt|;
name|varInfo
operator|.
name|mappedName
operator|=
name|mappedName
operator|.
name|c_str
argument_list|()
expr_stmt|;
name|varInfo
operator|.
name|size
operator|=
literal|1
expr_stmt|;
block|}
name|varInfo
operator|.
name|type
operator|=
name|getVariableDataType
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|infoList
operator|.
name|push_back
argument_list|(
name|varInfo
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|getUserDefinedVariableInfo
name|void
name|getUserDefinedVariableInfo
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|,
specifier|const
name|TString
modifier|&
name|name
parameter_list|,
specifier|const
name|TString
modifier|&
name|mappedName
parameter_list|,
name|TVariableInfoList
modifier|&
name|infoList
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|type
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtStruct
argument_list|)
expr_stmt|;
specifier|const
name|TTypeList
modifier|*
name|structure
init|=
name|type
operator|.
name|getStruct
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|structure
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|TType
modifier|*
name|fieldType
init|=
operator|(
operator|*
name|structure
operator|)
index|[
name|i
index|]
operator|.
name|type
decl_stmt|;
name|getVariableInfo
argument_list|(
operator|*
name|fieldType
argument_list|,
name|name
operator|+
literal|"."
operator|+
name|fieldType
operator|->
name|getFieldName
argument_list|()
argument_list|,
name|mappedName
operator|+
literal|"."
operator|+
name|fieldType
operator|->
name|getFieldName
argument_list|()
argument_list|,
name|infoList
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_constructor
DECL|function|TVariableInfo
name|TVariableInfo
operator|::
name|TVariableInfo
parameter_list|()
block|{ }
end_constructor
begin_constructor
DECL|function|TVariableInfo
name|TVariableInfo
operator|::
name|TVariableInfo
parameter_list|(
name|ShDataType
name|type
parameter_list|,
name|int
name|size
parameter_list|)
member_init_list|:
name|type
argument_list|(
name|type
argument_list|)
member_init_list|,
name|size
argument_list|(
name|size
argument_list|)
block|{ }
end_constructor
begin_constructor
DECL|function|CollectAttribsUniforms
name|CollectAttribsUniforms
operator|::
name|CollectAttribsUniforms
parameter_list|(
name|TVariableInfoList
modifier|&
name|attribs
parameter_list|,
name|TVariableInfoList
modifier|&
name|uniforms
parameter_list|)
member_init_list|:
name|mAttribs
argument_list|(
name|attribs
argument_list|)
member_init_list|,
name|mUniforms
argument_list|(
name|uniforms
argument_list|)
block|{ }
end_constructor
begin_comment
comment|// We are only interested in attribute and uniform variable declaration.
end_comment
begin_function
DECL|function|visitSymbol
name|void
name|CollectAttribsUniforms
operator|::
name|visitSymbol
parameter_list|(
name|TIntermSymbol
modifier|*
parameter_list|)
block|{ }
end_function
begin_function
DECL|function|visitConstantUnion
name|void
name|CollectAttribsUniforms
operator|::
name|visitConstantUnion
parameter_list|(
name|TIntermConstantUnion
modifier|*
parameter_list|)
block|{ }
end_function
begin_function
DECL|function|visitBinary
name|bool
name|CollectAttribsUniforms
operator|::
name|visitBinary
parameter_list|(
name|Visit
parameter_list|,
name|TIntermBinary
modifier|*
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|visitUnary
name|bool
name|CollectAttribsUniforms
operator|::
name|visitUnary
parameter_list|(
name|Visit
parameter_list|,
name|TIntermUnary
modifier|*
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|visitSelection
name|bool
name|CollectAttribsUniforms
operator|::
name|visitSelection
parameter_list|(
name|Visit
parameter_list|,
name|TIntermSelection
modifier|*
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|visitAggregate
name|bool
name|CollectAttribsUniforms
operator|::
name|visitAggregate
parameter_list|(
name|Visit
parameter_list|,
name|TIntermAggregate
modifier|*
name|node
parameter_list|)
block|{
name|bool
name|visitChildren
init|=
literal|false
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|getOp
argument_list|()
condition|)
block|{
case|case
name|EOpSequence
case|:
comment|// We need to visit sequence children to get to variable declarations.
name|visitChildren
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|EOpDeclaration
case|:
block|{
specifier|const
name|TIntermSequence
modifier|&
name|sequence
init|=
name|node
operator|->
name|getSequence
argument_list|()
decl_stmt|;
name|TQualifier
name|qualifier
init|=
name|sequence
operator|.
name|front
argument_list|()
operator|->
name|getAsTyped
argument_list|()
operator|->
name|getQualifier
argument_list|()
decl_stmt|;
if|if
condition|(
name|qualifier
operator|==
name|EvqAttribute
operator|||
name|qualifier
operator|==
name|EvqUniform
condition|)
block|{
name|TVariableInfoList
modifier|&
name|infoList
init|=
name|qualifier
operator|==
name|EvqAttribute
condition|?
name|mAttribs
else|:
name|mUniforms
decl_stmt|;
for|for
control|(
name|TIntermSequence
operator|::
name|const_iterator
name|i
init|=
name|sequence
operator|.
name|begin
argument_list|()
init|;
name|i
operator|!=
name|sequence
operator|.
name|end
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|TIntermSymbol
modifier|*
name|variable
init|=
operator|(
operator|*
name|i
operator|)
operator|->
name|getAsSymbolNode
argument_list|()
decl_stmt|;
comment|// The only case in which the sequence will not contain a
comment|// TIntermSymbol node is initialization. It will contain a
comment|// TInterBinary node in that case. Since attributes and unifroms
comment|// cannot be initialized in a shader, we must have only
comment|// TIntermSymbol nodes in the sequence.
name|ASSERT
argument_list|(
name|variable
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|getVariableInfo
argument_list|(
name|variable
operator|->
name|getType
argument_list|()
argument_list|,
name|variable
operator|->
name|getOriginalSymbol
argument_list|()
argument_list|,
name|variable
operator|->
name|getSymbol
argument_list|()
argument_list|,
name|infoList
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
default|default:
break|break;
block|}
return|return
name|visitChildren
return|;
block|}
end_function
begin_function
DECL|function|visitLoop
name|bool
name|CollectAttribsUniforms
operator|::
name|visitLoop
parameter_list|(
name|Visit
parameter_list|,
name|TIntermLoop
modifier|*
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|visitBranch
name|bool
name|CollectAttribsUniforms
operator|::
name|visitBranch
parameter_list|(
name|Visit
parameter_list|,
name|TIntermBranch
modifier|*
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
end_function
end_unit
