begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2012 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|"compiler/OutputHLSL.h"
end_include
begin_include
include|#
directive|include
file|"common/angleutils.h"
end_include
begin_include
include|#
directive|include
file|"compiler/debug.h"
end_include
begin_include
include|#
directive|include
file|"compiler/InfoSink.h"
end_include
begin_include
include|#
directive|include
file|"compiler/UnfoldShortCircuit.h"
end_include
begin_include
include|#
directive|include
file|"compiler/SearchSymbol.h"
end_include
begin_include
include|#
directive|include
file|"compiler/DetectDiscontinuity.h"
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_namespace
DECL|namespace|sh
namespace|namespace
name|sh
block|{
comment|// Integer to TString conversion
DECL|function|str
name|TString
name|str
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|char
name|buffer
index|[
literal|20
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
DECL|function|OutputHLSL
name|OutputHLSL
operator|::
name|OutputHLSL
parameter_list|(
name|TParseContext
modifier|&
name|context
parameter_list|)
member_init_list|:
name|TIntermTraverser
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
member_init_list|,
name|mContext
argument_list|(
name|context
argument_list|)
block|{
name|mUnfoldShortCircuit
operator|=
operator|new
name|UnfoldShortCircuit
argument_list|(
name|context
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|mInsideFunction
operator|=
literal|false
expr_stmt|;
name|mUsesTexture2D
operator|=
literal|false
expr_stmt|;
name|mUsesTexture2D_bias
operator|=
literal|false
expr_stmt|;
name|mUsesTexture2DProj
operator|=
literal|false
expr_stmt|;
name|mUsesTexture2DProj_bias
operator|=
literal|false
expr_stmt|;
name|mUsesTexture2DProjLod
operator|=
literal|false
expr_stmt|;
name|mUsesTexture2DLod
operator|=
literal|false
expr_stmt|;
name|mUsesTextureCube
operator|=
literal|false
expr_stmt|;
name|mUsesTextureCube_bias
operator|=
literal|false
expr_stmt|;
name|mUsesTextureCubeLod
operator|=
literal|false
expr_stmt|;
name|mUsesTexture2DLod0
operator|=
literal|false
expr_stmt|;
name|mUsesTexture2DLod0_bias
operator|=
literal|false
expr_stmt|;
name|mUsesTexture2DProjLod0
operator|=
literal|false
expr_stmt|;
name|mUsesTexture2DProjLod0_bias
operator|=
literal|false
expr_stmt|;
name|mUsesTextureCubeLod0
operator|=
literal|false
expr_stmt|;
name|mUsesTextureCubeLod0_bias
operator|=
literal|false
expr_stmt|;
name|mUsesDepthRange
operator|=
literal|false
expr_stmt|;
name|mUsesFragCoord
operator|=
literal|false
expr_stmt|;
name|mUsesPointCoord
operator|=
literal|false
expr_stmt|;
name|mUsesFrontFacing
operator|=
literal|false
expr_stmt|;
name|mUsesPointSize
operator|=
literal|false
expr_stmt|;
name|mUsesXor
operator|=
literal|false
expr_stmt|;
name|mUsesMod1
operator|=
literal|false
expr_stmt|;
name|mUsesMod2v
operator|=
literal|false
expr_stmt|;
name|mUsesMod2f
operator|=
literal|false
expr_stmt|;
name|mUsesMod3v
operator|=
literal|false
expr_stmt|;
name|mUsesMod3f
operator|=
literal|false
expr_stmt|;
name|mUsesMod4v
operator|=
literal|false
expr_stmt|;
name|mUsesMod4f
operator|=
literal|false
expr_stmt|;
name|mUsesFaceforward1
operator|=
literal|false
expr_stmt|;
name|mUsesFaceforward2
operator|=
literal|false
expr_stmt|;
name|mUsesFaceforward3
operator|=
literal|false
expr_stmt|;
name|mUsesFaceforward4
operator|=
literal|false
expr_stmt|;
name|mUsesEqualMat2
operator|=
literal|false
expr_stmt|;
name|mUsesEqualMat3
operator|=
literal|false
expr_stmt|;
name|mUsesEqualMat4
operator|=
literal|false
expr_stmt|;
name|mUsesEqualVec2
operator|=
literal|false
expr_stmt|;
name|mUsesEqualVec3
operator|=
literal|false
expr_stmt|;
name|mUsesEqualVec4
operator|=
literal|false
expr_stmt|;
name|mUsesEqualIVec2
operator|=
literal|false
expr_stmt|;
name|mUsesEqualIVec3
operator|=
literal|false
expr_stmt|;
name|mUsesEqualIVec4
operator|=
literal|false
expr_stmt|;
name|mUsesEqualBVec2
operator|=
literal|false
expr_stmt|;
name|mUsesEqualBVec3
operator|=
literal|false
expr_stmt|;
name|mUsesEqualBVec4
operator|=
literal|false
expr_stmt|;
name|mUsesAtan2_1
operator|=
literal|false
expr_stmt|;
name|mUsesAtan2_2
operator|=
literal|false
expr_stmt|;
name|mUsesAtan2_3
operator|=
literal|false
expr_stmt|;
name|mUsesAtan2_4
operator|=
literal|false
expr_stmt|;
name|mScopeDepth
operator|=
literal|0
expr_stmt|;
name|mUniqueIndex
operator|=
literal|0
expr_stmt|;
name|mContainsLoopDiscontinuity
operator|=
literal|false
expr_stmt|;
name|mOutputLod0Function
operator|=
literal|false
expr_stmt|;
name|mInsideDiscontinuousLoop
operator|=
literal|false
expr_stmt|;
name|mExcessiveLoopIndex
operator|=
name|NULL
expr_stmt|;
block|}
DECL|function|~OutputHLSL
name|OutputHLSL
operator|::
name|~
name|OutputHLSL
parameter_list|()
block|{
operator|delete
name|mUnfoldShortCircuit
expr_stmt|;
block|}
DECL|function|output
name|void
name|OutputHLSL
operator|::
name|output
parameter_list|()
block|{
name|mContainsLoopDiscontinuity
operator|=
name|containsLoopDiscontinuity
argument_list|(
name|mContext
operator|.
name|treeRoot
argument_list|)
expr_stmt|;
name|mContext
operator|.
name|treeRoot
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Output the body first to determine what has to go in the header
name|header
argument_list|()
expr_stmt|;
name|mContext
operator|.
name|infoSink
argument_list|()
operator|.
name|obj
operator|<<
name|mHeader
operator|.
name|c_str
argument_list|()
expr_stmt|;
name|mContext
operator|.
name|infoSink
argument_list|()
operator|.
name|obj
operator|<<
name|mBody
operator|.
name|c_str
argument_list|()
expr_stmt|;
block|}
DECL|function|getBodyStream
name|TInfoSinkBase
modifier|&
name|OutputHLSL
operator|::
name|getBodyStream
parameter_list|()
block|{
return|return
name|mBody
return|;
block|}
DECL|function|vectorSize
name|int
name|OutputHLSL
operator|::
name|vectorSize
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|)
specifier|const
block|{
name|int
name|elementSize
init|=
name|type
operator|.
name|isMatrix
argument_list|()
condition|?
name|type
operator|.
name|getNominalSize
argument_list|()
else|:
literal|1
decl_stmt|;
name|int
name|arraySize
init|=
name|type
operator|.
name|isArray
argument_list|()
condition|?
name|type
operator|.
name|getArraySize
argument_list|()
else|:
literal|1
decl_stmt|;
return|return
name|elementSize
operator|*
name|arraySize
return|;
block|}
DECL|function|header
name|void
name|OutputHLSL
operator|::
name|header
parameter_list|()
block|{
name|ShShaderType
name|shaderType
init|=
name|mContext
operator|.
name|shaderType
decl_stmt|;
name|TInfoSinkBase
modifier|&
name|out
init|=
name|mHeader
decl_stmt|;
for|for
control|(
name|StructDeclarations
operator|::
name|iterator
name|structDeclaration
init|=
name|mStructDeclarations
operator|.
name|begin
argument_list|()
init|;
name|structDeclaration
operator|!=
name|mStructDeclarations
operator|.
name|end
argument_list|()
condition|;
name|structDeclaration
operator|++
control|)
block|{
name|out
operator|<<
operator|*
name|structDeclaration
expr_stmt|;
block|}
for|for
control|(
name|Constructors
operator|::
name|iterator
name|constructor
init|=
name|mConstructors
operator|.
name|begin
argument_list|()
init|;
name|constructor
operator|!=
name|mConstructors
operator|.
name|end
argument_list|()
condition|;
name|constructor
operator|++
control|)
block|{
name|out
operator|<<
operator|*
name|constructor
expr_stmt|;
block|}
if|if
condition|(
name|shaderType
operator|==
name|SH_FRAGMENT_SHADER
condition|)
block|{
name|TString
name|uniforms
decl_stmt|;
name|TString
name|varyings
decl_stmt|;
name|TSymbolTableLevel
modifier|*
name|symbols
init|=
name|mContext
operator|.
name|symbolTable
operator|.
name|getGlobalLevel
argument_list|()
decl_stmt|;
name|int
name|semanticIndex
init|=
literal|0
decl_stmt|;
for|for
control|(
name|TSymbolTableLevel
operator|::
name|const_iterator
name|namedSymbol
init|=
name|symbols
operator|->
name|begin
argument_list|()
init|;
name|namedSymbol
operator|!=
name|symbols
operator|->
name|end
argument_list|()
condition|;
name|namedSymbol
operator|++
control|)
block|{
specifier|const
name|TSymbol
modifier|*
name|symbol
init|=
operator|(
operator|*
name|namedSymbol
operator|)
operator|.
name|second
decl_stmt|;
specifier|const
name|TString
modifier|&
name|name
init|=
name|symbol
operator|->
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|symbol
operator|->
name|isVariable
argument_list|()
condition|)
block|{
specifier|const
name|TVariable
modifier|*
name|variable
init|=
cast|static_cast
argument_list|<
specifier|const
name|TVariable
operator|*
argument_list|>
argument_list|(
name|symbol
argument_list|)
decl_stmt|;
specifier|const
name|TType
modifier|&
name|type
init|=
name|variable
operator|->
name|getType
argument_list|()
decl_stmt|;
name|TQualifier
name|qualifier
init|=
name|type
operator|.
name|getQualifier
argument_list|()
decl_stmt|;
if|if
condition|(
name|qualifier
operator|==
name|EvqUniform
condition|)
block|{
if|if
condition|(
name|mReferencedUniforms
operator|.
name|find
argument_list|(
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
operator|!=
name|mReferencedUniforms
operator|.
name|end
argument_list|()
condition|)
block|{
name|uniforms
operator|+=
literal|"uniform "
operator|+
name|typeString
argument_list|(
name|type
argument_list|)
operator|+
literal|" "
operator|+
name|decorateUniform
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
operator|+
name|arrayString
argument_list|(
name|type
argument_list|)
operator|+
literal|";\n"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|qualifier
operator|==
name|EvqVaryingIn
operator|||
name|qualifier
operator|==
name|EvqInvariantVaryingIn
condition|)
block|{
if|if
condition|(
name|mReferencedVaryings
operator|.
name|find
argument_list|(
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
operator|!=
name|mReferencedVaryings
operator|.
name|end
argument_list|()
condition|)
block|{
comment|// Program linking depends on this exact format
name|varyings
operator|+=
literal|"static "
operator|+
name|typeString
argument_list|(
name|type
argument_list|)
operator|+
literal|" "
operator|+
name|decorate
argument_list|(
name|name
argument_list|)
operator|+
name|arrayString
argument_list|(
name|type
argument_list|)
operator|+
literal|" = "
operator|+
name|initializer
argument_list|(
name|type
argument_list|)
operator|+
literal|";\n"
expr_stmt|;
name|semanticIndex
operator|+=
name|type
operator|.
name|isArray
argument_list|()
condition|?
name|type
operator|.
name|getArraySize
argument_list|()
else|:
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|qualifier
operator|==
name|EvqGlobal
operator|||
name|qualifier
operator|==
name|EvqTemporary
condition|)
block|{
comment|// Globals are declared and intialized as an aggregate node
block|}
elseif|else
if|if
condition|(
name|qualifier
operator|==
name|EvqConst
condition|)
block|{
comment|// Constants are repeated as literals where used
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
name|out
operator|<<
literal|"// Varyings\n"
expr_stmt|;
name|out
operator|<<
name|varyings
expr_stmt|;
name|out
operator|<<
literal|"\n"
literal|"static float4 gl_Color[1] = {float4(0, 0, 0, 0)};\n"
expr_stmt|;
if|if
condition|(
name|mUsesFragCoord
condition|)
block|{
name|out
operator|<<
literal|"static float4 gl_FragCoord = float4(0, 0, 0, 0);\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesPointCoord
condition|)
block|{
name|out
operator|<<
literal|"static float2 gl_PointCoord = float2(0.5, 0.5);\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesFrontFacing
condition|)
block|{
name|out
operator|<<
literal|"static bool gl_FrontFacing = false;\n"
expr_stmt|;
block|}
name|out
operator|<<
literal|"\n"
expr_stmt|;
if|if
condition|(
name|mUsesFragCoord
condition|)
block|{
name|out
operator|<<
literal|"uniform float4 dx_Coord;\n"
literal|"uniform float2 dx_Depth;\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesFrontFacing
condition|)
block|{
name|out
operator|<<
literal|"uniform bool dx_PointsOrLines;\n"
literal|"uniform bool dx_FrontCCW;\n"
expr_stmt|;
block|}
name|out
operator|<<
literal|"\n"
expr_stmt|;
name|out
operator|<<
name|uniforms
expr_stmt|;
name|out
operator|<<
literal|"\n"
expr_stmt|;
if|if
condition|(
name|mUsesTexture2D
condition|)
block|{
name|out
operator|<<
literal|"float4 gl_texture2D(sampler2D s, float2 t)\n"
literal|"{\n"
literal|"    return tex2D(s, t);\n"
literal|"}\n"
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesTexture2D_bias
condition|)
block|{
name|out
operator|<<
literal|"float4 gl_texture2D(sampler2D s, float2 t, float bias)\n"
literal|"{\n"
literal|"    return tex2Dbias(s, float4(t.x, t.y, 0, bias));\n"
literal|"}\n"
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesTexture2DProj
condition|)
block|{
name|out
operator|<<
literal|"float4 gl_texture2DProj(sampler2D s, float3 t)\n"
literal|"{\n"
literal|"    return tex2Dproj(s, float4(t.x, t.y, 0, t.z));\n"
literal|"}\n"
literal|"\n"
literal|"float4 gl_texture2DProj(sampler2D s, float4 t)\n"
literal|"{\n"
literal|"    return tex2Dproj(s, t);\n"
literal|"}\n"
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesTexture2DProj_bias
condition|)
block|{
name|out
operator|<<
literal|"float4 gl_texture2DProj(sampler2D s, float3 t, float bias)\n"
literal|"{\n"
literal|"    return tex2Dbias(s, float4(t.x / t.z, t.y / t.z, 0, bias));\n"
literal|"}\n"
literal|"\n"
literal|"float4 gl_texture2DProj(sampler2D s, float4 t, float bias)\n"
literal|"{\n"
literal|"    return tex2Dbias(s, float4(t.x / t.w, t.y / t.w, 0, bias));\n"
literal|"}\n"
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesTextureCube
condition|)
block|{
name|out
operator|<<
literal|"float4 gl_textureCube(samplerCUBE s, float3 t)\n"
literal|"{\n"
literal|"    return texCUBE(s, t);\n"
literal|"}\n"
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesTextureCube_bias
condition|)
block|{
name|out
operator|<<
literal|"float4 gl_textureCube(samplerCUBE s, float3 t, float bias)\n"
literal|"{\n"
literal|"    return texCUBEbias(s, float4(t.x, t.y, t.z, bias));\n"
literal|"}\n"
literal|"\n"
expr_stmt|;
block|}
comment|// These *Lod0 intrinsics are not available in GL fragment shaders.
comment|// They are used to sample using discontinuous texture coordinates.
if|if
condition|(
name|mUsesTexture2DLod0
condition|)
block|{
name|out
operator|<<
literal|"float4 gl_texture2DLod0(sampler2D s, float2 t)\n"
literal|"{\n"
literal|"    return tex2Dlod(s, float4(t.x, t.y, 0, 0));\n"
literal|"}\n"
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesTexture2DLod0_bias
condition|)
block|{
name|out
operator|<<
literal|"float4 gl_texture2DLod0(sampler2D s, float2 t, float bias)\n"
literal|"{\n"
literal|"    return tex2Dlod(s, float4(t.x, t.y, 0, 0));\n"
literal|"}\n"
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesTexture2DProjLod0
condition|)
block|{
name|out
operator|<<
literal|"float4 gl_texture2DProjLod0(sampler2D s, float3 t)\n"
literal|"{\n"
literal|"    return tex2Dlod(s, float4(t.x / t.z, t.y / t.z, 0, 0));\n"
literal|"}\n"
literal|"\n"
literal|"float4 gl_texture2DProjLod(sampler2D s, float4 t)\n"
literal|"{\n"
literal|"    return tex2Dlod(s, float4(t.x / t.w, t.y / t.w, 0, 0));\n"
literal|"}\n"
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesTexture2DProjLod0_bias
condition|)
block|{
name|out
operator|<<
literal|"float4 gl_texture2DProjLod0_bias(sampler2D s, float3 t, float bias)\n"
literal|"{\n"
literal|"    return tex2Dlod(s, float4(t.x / t.z, t.y / t.z, 0, 0));\n"
literal|"}\n"
literal|"\n"
literal|"float4 gl_texture2DProjLod_bias(sampler2D s, float4 t, float bias)\n"
literal|"{\n"
literal|"    return tex2Dlod(s, float4(t.x / t.w, t.y / t.w, 0, 0));\n"
literal|"}\n"
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesTextureCubeLod0
condition|)
block|{
name|out
operator|<<
literal|"float4 gl_textureCubeLod0(samplerCUBE s, float3 t)\n"
literal|"{\n"
literal|"    return texCUBElod(s, float4(t.x, t.y, t.z, 0));\n"
literal|"}\n"
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesTextureCubeLod0_bias
condition|)
block|{
name|out
operator|<<
literal|"float4 gl_textureCubeLod0(samplerCUBE s, float3 t, float bias)\n"
literal|"{\n"
literal|"    return texCUBElod(s, float4(t.x, t.y, t.z, 0));\n"
literal|"}\n"
literal|"\n"
expr_stmt|;
block|}
block|}
else|else
comment|// Vertex shader
block|{
name|TString
name|uniforms
decl_stmt|;
name|TString
name|attributes
decl_stmt|;
name|TString
name|varyings
decl_stmt|;
name|TSymbolTableLevel
modifier|*
name|symbols
init|=
name|mContext
operator|.
name|symbolTable
operator|.
name|getGlobalLevel
argument_list|()
decl_stmt|;
for|for
control|(
name|TSymbolTableLevel
operator|::
name|const_iterator
name|namedSymbol
init|=
name|symbols
operator|->
name|begin
argument_list|()
init|;
name|namedSymbol
operator|!=
name|symbols
operator|->
name|end
argument_list|()
condition|;
name|namedSymbol
operator|++
control|)
block|{
specifier|const
name|TSymbol
modifier|*
name|symbol
init|=
operator|(
operator|*
name|namedSymbol
operator|)
operator|.
name|second
decl_stmt|;
specifier|const
name|TString
modifier|&
name|name
init|=
name|symbol
operator|->
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|symbol
operator|->
name|isVariable
argument_list|()
condition|)
block|{
specifier|const
name|TVariable
modifier|*
name|variable
init|=
cast|static_cast
argument_list|<
specifier|const
name|TVariable
operator|*
argument_list|>
argument_list|(
name|symbol
argument_list|)
decl_stmt|;
specifier|const
name|TType
modifier|&
name|type
init|=
name|variable
operator|->
name|getType
argument_list|()
decl_stmt|;
name|TQualifier
name|qualifier
init|=
name|type
operator|.
name|getQualifier
argument_list|()
decl_stmt|;
if|if
condition|(
name|qualifier
operator|==
name|EvqUniform
condition|)
block|{
if|if
condition|(
name|mReferencedUniforms
operator|.
name|find
argument_list|(
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
operator|!=
name|mReferencedUniforms
operator|.
name|end
argument_list|()
condition|)
block|{
name|uniforms
operator|+=
literal|"uniform "
operator|+
name|typeString
argument_list|(
name|type
argument_list|)
operator|+
literal|" "
operator|+
name|decorateUniform
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
operator|+
name|arrayString
argument_list|(
name|type
argument_list|)
operator|+
literal|";\n"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|qualifier
operator|==
name|EvqAttribute
condition|)
block|{
if|if
condition|(
name|mReferencedAttributes
operator|.
name|find
argument_list|(
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
operator|!=
name|mReferencedAttributes
operator|.
name|end
argument_list|()
condition|)
block|{
name|attributes
operator|+=
literal|"static "
operator|+
name|typeString
argument_list|(
name|type
argument_list|)
operator|+
literal|" "
operator|+
name|decorate
argument_list|(
name|name
argument_list|)
operator|+
name|arrayString
argument_list|(
name|type
argument_list|)
operator|+
literal|" = "
operator|+
name|initializer
argument_list|(
name|type
argument_list|)
operator|+
literal|";\n"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|qualifier
operator|==
name|EvqVaryingOut
operator|||
name|qualifier
operator|==
name|EvqInvariantVaryingOut
condition|)
block|{
if|if
condition|(
name|mReferencedVaryings
operator|.
name|find
argument_list|(
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
operator|!=
name|mReferencedVaryings
operator|.
name|end
argument_list|()
condition|)
block|{
comment|// Program linking depends on this exact format
name|varyings
operator|+=
literal|"static "
operator|+
name|typeString
argument_list|(
name|type
argument_list|)
operator|+
literal|" "
operator|+
name|decorate
argument_list|(
name|name
argument_list|)
operator|+
name|arrayString
argument_list|(
name|type
argument_list|)
operator|+
literal|" = "
operator|+
name|initializer
argument_list|(
name|type
argument_list|)
operator|+
literal|";\n"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|qualifier
operator|==
name|EvqGlobal
operator|||
name|qualifier
operator|==
name|EvqTemporary
condition|)
block|{
comment|// Globals are declared and intialized as an aggregate node
block|}
elseif|else
if|if
condition|(
name|qualifier
operator|==
name|EvqConst
condition|)
block|{
comment|// Constants are repeated as literals where used
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
name|out
operator|<<
literal|"// Attributes\n"
expr_stmt|;
name|out
operator|<<
name|attributes
expr_stmt|;
name|out
operator|<<
literal|"\n"
literal|"static float4 gl_Position = float4(0, 0, 0, 0);\n"
expr_stmt|;
if|if
condition|(
name|mUsesPointSize
condition|)
block|{
name|out
operator|<<
literal|"static float gl_PointSize = float(1);\n"
expr_stmt|;
block|}
name|out
operator|<<
literal|"\n"
literal|"// Varyings\n"
expr_stmt|;
name|out
operator|<<
name|varyings
expr_stmt|;
name|out
operator|<<
literal|"\n"
literal|"uniform float2 dx_HalfPixelSize;\n"
literal|"\n"
expr_stmt|;
name|out
operator|<<
name|uniforms
expr_stmt|;
name|out
operator|<<
literal|"\n"
expr_stmt|;
if|if
condition|(
name|mUsesTexture2D
condition|)
block|{
name|out
operator|<<
literal|"float4 gl_texture2D(sampler2D s, float2 t)\n"
literal|"{\n"
literal|"    return tex2Dlod(s, float4(t.x, t.y, 0, 0));\n"
literal|"}\n"
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesTexture2DLod
condition|)
block|{
name|out
operator|<<
literal|"float4 gl_texture2DLod(sampler2D s, float2 t, float lod)\n"
literal|"{\n"
literal|"    return tex2Dlod(s, float4(t.x, t.y, 0, lod));\n"
literal|"}\n"
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesTexture2DProj
condition|)
block|{
name|out
operator|<<
literal|"float4 gl_texture2DProj(sampler2D s, float3 t)\n"
literal|"{\n"
literal|"    return tex2Dlod(s, float4(t.x / t.z, t.y / t.z, 0, 0));\n"
literal|"}\n"
literal|"\n"
literal|"float4 gl_texture2DProj(sampler2D s, float4 t)\n"
literal|"{\n"
literal|"    return tex2Dlod(s, float4(t.x / t.w, t.y / t.w, 0, 0));\n"
literal|"}\n"
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesTexture2DProjLod
condition|)
block|{
name|out
operator|<<
literal|"float4 gl_texture2DProjLod(sampler2D s, float3 t, float lod)\n"
literal|"{\n"
literal|"    return tex2Dlod(s, float4(t.x / t.z, t.y / t.z, 0, lod));\n"
literal|"}\n"
literal|"\n"
literal|"float4 gl_texture2DProjLod(sampler2D s, float4 t, float lod)\n"
literal|"{\n"
literal|"    return tex2Dlod(s, float4(t.x / t.w, t.y / t.w, 0, lod));\n"
literal|"}\n"
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesTextureCube
condition|)
block|{
name|out
operator|<<
literal|"float4 gl_textureCube(samplerCUBE s, float3 t)\n"
literal|"{\n"
literal|"    return texCUBElod(s, float4(t.x, t.y, t.z, 0));\n"
literal|"}\n"
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesTextureCubeLod
condition|)
block|{
name|out
operator|<<
literal|"float4 gl_textureCubeLod(samplerCUBE s, float3 t, float lod)\n"
literal|"{\n"
literal|"    return texCUBElod(s, float4(t.x, t.y, t.z, lod));\n"
literal|"}\n"
literal|"\n"
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mUsesFragCoord
condition|)
block|{
name|out
operator|<<
literal|"#define GL_USES_FRAG_COORD\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesPointCoord
condition|)
block|{
name|out
operator|<<
literal|"#define GL_USES_POINT_COORD\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesFrontFacing
condition|)
block|{
name|out
operator|<<
literal|"#define GL_USES_FRONT_FACING\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesPointSize
condition|)
block|{
name|out
operator|<<
literal|"#define GL_USES_POINT_SIZE\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesDepthRange
condition|)
block|{
name|out
operator|<<
literal|"struct gl_DepthRangeParameters\n"
literal|"{\n"
literal|"    float near;\n"
literal|"    float far;\n"
literal|"    float diff;\n"
literal|"};\n"
literal|"\n"
literal|"uniform float3 dx_DepthRange;"
literal|"static gl_DepthRangeParameters gl_DepthRange = {dx_DepthRange.x, dx_DepthRange.y, dx_DepthRange.z};\n"
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesXor
condition|)
block|{
name|out
operator|<<
literal|"bool xor(bool p, bool q)\n"
literal|"{\n"
literal|"    return (p || q)&& !(p&& q);\n"
literal|"}\n"
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesMod1
condition|)
block|{
name|out
operator|<<
literal|"float mod(float x, float y)\n"
literal|"{\n"
literal|"    return x - y * floor(x / y);\n"
literal|"}\n"
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesMod2v
condition|)
block|{
name|out
operator|<<
literal|"float2 mod(float2 x, float2 y)\n"
literal|"{\n"
literal|"    return x - y * floor(x / y);\n"
literal|"}\n"
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesMod2f
condition|)
block|{
name|out
operator|<<
literal|"float2 mod(float2 x, float y)\n"
literal|"{\n"
literal|"    return x - y * floor(x / y);\n"
literal|"}\n"
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesMod3v
condition|)
block|{
name|out
operator|<<
literal|"float3 mod(float3 x, float3 y)\n"
literal|"{\n"
literal|"    return x - y * floor(x / y);\n"
literal|"}\n"
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesMod3f
condition|)
block|{
name|out
operator|<<
literal|"float3 mod(float3 x, float y)\n"
literal|"{\n"
literal|"    return x - y * floor(x / y);\n"
literal|"}\n"
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesMod4v
condition|)
block|{
name|out
operator|<<
literal|"float4 mod(float4 x, float4 y)\n"
literal|"{\n"
literal|"    return x - y * floor(x / y);\n"
literal|"}\n"
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesMod4f
condition|)
block|{
name|out
operator|<<
literal|"float4 mod(float4 x, float y)\n"
literal|"{\n"
literal|"    return x - y * floor(x / y);\n"
literal|"}\n"
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesFaceforward1
condition|)
block|{
name|out
operator|<<
literal|"float faceforward(float N, float I, float Nref)\n"
literal|"{\n"
literal|"    if(dot(Nref, I)>= 0)\n"
literal|"    {\n"
literal|"        return -N;\n"
literal|"    }\n"
literal|"    else\n"
literal|"    {\n"
literal|"        return N;\n"
literal|"    }\n"
literal|"}\n"
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesFaceforward2
condition|)
block|{
name|out
operator|<<
literal|"float2 faceforward(float2 N, float2 I, float2 Nref)\n"
literal|"{\n"
literal|"    if(dot(Nref, I)>= 0)\n"
literal|"    {\n"
literal|"        return -N;\n"
literal|"    }\n"
literal|"    else\n"
literal|"    {\n"
literal|"        return N;\n"
literal|"    }\n"
literal|"}\n"
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesFaceforward3
condition|)
block|{
name|out
operator|<<
literal|"float3 faceforward(float3 N, float3 I, float3 Nref)\n"
literal|"{\n"
literal|"    if(dot(Nref, I)>= 0)\n"
literal|"    {\n"
literal|"        return -N;\n"
literal|"    }\n"
literal|"    else\n"
literal|"    {\n"
literal|"        return N;\n"
literal|"    }\n"
literal|"}\n"
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesFaceforward4
condition|)
block|{
name|out
operator|<<
literal|"float4 faceforward(float4 N, float4 I, float4 Nref)\n"
literal|"{\n"
literal|"    if(dot(Nref, I)>= 0)\n"
literal|"    {\n"
literal|"        return -N;\n"
literal|"    }\n"
literal|"    else\n"
literal|"    {\n"
literal|"        return N;\n"
literal|"    }\n"
literal|"}\n"
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesEqualMat2
condition|)
block|{
name|out
operator|<<
literal|"bool equal(float2x2 m, float2x2 n)\n"
literal|"{\n"
literal|"    return m[0][0] == n[0][0]&& m[0][1] == n[0][1]&&\n"
literal|"           m[1][0] == n[1][0]&& m[1][1] == n[1][1];\n"
literal|"}\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesEqualMat3
condition|)
block|{
name|out
operator|<<
literal|"bool equal(float3x3 m, float3x3 n)\n"
literal|"{\n"
literal|"    return m[0][0] == n[0][0]&& m[0][1] == n[0][1]&& m[0][2] == n[0][2]&&\n"
literal|"           m[1][0] == n[1][0]&& m[1][1] == n[1][1]&& m[1][2] == n[1][2]&&\n"
literal|"           m[2][0] == n[2][0]&& m[2][1] == n[2][1]&& m[2][2] == n[2][2];\n"
literal|"}\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesEqualMat4
condition|)
block|{
name|out
operator|<<
literal|"bool equal(float4x4 m, float4x4 n)\n"
literal|"{\n"
literal|"    return m[0][0] == n[0][0]&& m[0][1] == n[0][1]&& m[0][2] == n[0][2]&& m[0][3] == n[0][3]&&\n"
literal|"           m[1][0] == n[1][0]&& m[1][1] == n[1][1]&& m[1][2] == n[1][2]&& m[1][3] == n[1][3]&&\n"
literal|"           m[2][0] == n[2][0]&& m[2][1] == n[2][1]&& m[2][2] == n[2][2]&& m[2][3] == n[2][3]&&\n"
literal|"           m[3][0] == n[3][0]&& m[3][1] == n[3][1]&& m[3][2] == n[3][2]&& m[3][3] == n[3][3];\n"
literal|"}\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesEqualVec2
condition|)
block|{
name|out
operator|<<
literal|"bool equal(float2 v, float2 u)\n"
literal|"{\n"
literal|"    return v.x == u.x&& v.y == u.y;\n"
literal|"}\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesEqualVec3
condition|)
block|{
name|out
operator|<<
literal|"bool equal(float3 v, float3 u)\n"
literal|"{\n"
literal|"    return v.x == u.x&& v.y == u.y&& v.z == u.z;\n"
literal|"}\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesEqualVec4
condition|)
block|{
name|out
operator|<<
literal|"bool equal(float4 v, float4 u)\n"
literal|"{\n"
literal|"    return v.x == u.x&& v.y == u.y&& v.z == u.z&& v.w == u.w;\n"
literal|"}\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesEqualIVec2
condition|)
block|{
name|out
operator|<<
literal|"bool equal(int2 v, int2 u)\n"
literal|"{\n"
literal|"    return v.x == u.x&& v.y == u.y;\n"
literal|"}\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesEqualIVec3
condition|)
block|{
name|out
operator|<<
literal|"bool equal(int3 v, int3 u)\n"
literal|"{\n"
literal|"    return v.x == u.x&& v.y == u.y&& v.z == u.z;\n"
literal|"}\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesEqualIVec4
condition|)
block|{
name|out
operator|<<
literal|"bool equal(int4 v, int4 u)\n"
literal|"{\n"
literal|"    return v.x == u.x&& v.y == u.y&& v.z == u.z&& v.w == u.w;\n"
literal|"}\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesEqualBVec2
condition|)
block|{
name|out
operator|<<
literal|"bool equal(bool2 v, bool2 u)\n"
literal|"{\n"
literal|"    return v.x == u.x&& v.y == u.y;\n"
literal|"}\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesEqualBVec3
condition|)
block|{
name|out
operator|<<
literal|"bool equal(bool3 v, bool3 u)\n"
literal|"{\n"
literal|"    return v.x == u.x&& v.y == u.y&& v.z == u.z;\n"
literal|"}\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesEqualBVec4
condition|)
block|{
name|out
operator|<<
literal|"bool equal(bool4 v, bool4 u)\n"
literal|"{\n"
literal|"    return v.x == u.x&& v.y == u.y&& v.z == u.z&& v.w == u.w;\n"
literal|"}\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesAtan2_1
condition|)
block|{
name|out
operator|<<
literal|"float atanyx(float y, float x)\n"
literal|"{\n"
literal|"    if(x == 0&& y == 0) x = 1;\n"
comment|// Avoid producing a NaN
literal|"    return atan2(y, x);\n"
literal|"}\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesAtan2_2
condition|)
block|{
name|out
operator|<<
literal|"float2 atanyx(float2 y, float2 x)\n"
literal|"{\n"
literal|"    if(x[0] == 0&& y[0] == 0) x[0] = 1;\n"
literal|"    if(x[1] == 0&& y[1] == 0) x[1] = 1;\n"
literal|"    return float2(atan2(y[0], x[0]), atan2(y[1], x[1]));\n"
literal|"}\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesAtan2_3
condition|)
block|{
name|out
operator|<<
literal|"float3 atanyx(float3 y, float3 x)\n"
literal|"{\n"
literal|"    if(x[0] == 0&& y[0] == 0) x[0] = 1;\n"
literal|"    if(x[1] == 0&& y[1] == 0) x[1] = 1;\n"
literal|"    if(x[2] == 0&& y[2] == 0) x[2] = 1;\n"
literal|"    return float3(atan2(y[0], x[0]), atan2(y[1], x[1]), atan2(y[2], x[2]));\n"
literal|"}\n"
expr_stmt|;
block|}
if|if
condition|(
name|mUsesAtan2_4
condition|)
block|{
name|out
operator|<<
literal|"float4 atanyx(float4 y, float4 x)\n"
literal|"{\n"
literal|"    if(x[0] == 0&& y[0] == 0) x[0] = 1;\n"
literal|"    if(x[1] == 0&& y[1] == 0) x[1] = 1;\n"
literal|"    if(x[2] == 0&& y[2] == 0) x[2] = 1;\n"
literal|"    if(x[3] == 0&& y[3] == 0) x[3] = 1;\n"
literal|"    return float4(atan2(y[0], x[0]), atan2(y[1], x[1]), atan2(y[2], x[2]), atan2(y[3], x[3]));\n"
literal|"}\n"
expr_stmt|;
block|}
block|}
DECL|function|visitSymbol
name|void
name|OutputHLSL
operator|::
name|visitSymbol
parameter_list|(
name|TIntermSymbol
modifier|*
name|node
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|mBody
decl_stmt|;
name|TString
name|name
init|=
name|node
operator|->
name|getSymbol
argument_list|()
decl_stmt|;
if|if
condition|(
name|name
operator|==
literal|"gl_FragColor"
condition|)
block|{
name|out
operator|<<
literal|"gl_Color[0]"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
literal|"gl_FragData"
condition|)
block|{
name|out
operator|<<
literal|"gl_Color"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
literal|"gl_DepthRange"
condition|)
block|{
name|mUsesDepthRange
operator|=
literal|true
expr_stmt|;
name|out
operator|<<
name|name
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
literal|"gl_FragCoord"
condition|)
block|{
name|mUsesFragCoord
operator|=
literal|true
expr_stmt|;
name|out
operator|<<
name|name
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
literal|"gl_PointCoord"
condition|)
block|{
name|mUsesPointCoord
operator|=
literal|true
expr_stmt|;
name|out
operator|<<
name|name
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
literal|"gl_FrontFacing"
condition|)
block|{
name|mUsesFrontFacing
operator|=
literal|true
expr_stmt|;
name|out
operator|<<
name|name
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
literal|"gl_PointSize"
condition|)
block|{
name|mUsesPointSize
operator|=
literal|true
expr_stmt|;
name|out
operator|<<
name|name
expr_stmt|;
block|}
else|else
block|{
name|TQualifier
name|qualifier
init|=
name|node
operator|->
name|getQualifier
argument_list|()
decl_stmt|;
if|if
condition|(
name|qualifier
operator|==
name|EvqUniform
condition|)
block|{
name|mReferencedUniforms
operator|.
name|insert
argument_list|(
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|<<
name|decorateUniform
argument_list|(
name|name
argument_list|,
name|node
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qualifier
operator|==
name|EvqAttribute
condition|)
block|{
name|mReferencedAttributes
operator|.
name|insert
argument_list|(
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|<<
name|decorate
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qualifier
operator|==
name|EvqVaryingOut
operator|||
name|qualifier
operator|==
name|EvqInvariantVaryingOut
operator|||
name|qualifier
operator|==
name|EvqVaryingIn
operator|||
name|qualifier
operator|==
name|EvqInvariantVaryingIn
condition|)
block|{
name|mReferencedVaryings
operator|.
name|insert
argument_list|(
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|<<
name|decorate
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
name|decorate
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|visitBinary
name|bool
name|OutputHLSL
operator|::
name|visitBinary
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermBinary
modifier|*
name|node
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|mBody
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|getOp
argument_list|()
condition|)
block|{
case|case
name|EOpAssign
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" = "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpInitialize
case|:
if|if
condition|(
name|visit
operator|==
name|PreVisit
condition|)
block|{
comment|// GLSL allows to write things like "float x = x;" where a new variable x is defined
comment|// and the value of an existing variable x is assigned. HLSL uses C semantics (the
comment|// new variable is created before the assignment is evaluated), so we need to convert
comment|// this to "float t = x, x = t;".
name|TIntermSymbol
modifier|*
name|symbolNode
init|=
name|node
operator|->
name|getLeft
argument_list|()
operator|->
name|getAsSymbolNode
argument_list|()
decl_stmt|;
name|TIntermTyped
modifier|*
name|expression
init|=
name|node
operator|->
name|getRight
argument_list|()
decl_stmt|;
name|sh
operator|::
name|SearchSymbol
name|searchSymbol
argument_list|(
name|symbolNode
operator|->
name|getSymbol
argument_list|()
argument_list|)
decl_stmt|;
name|expression
operator|->
name|traverse
argument_list|(
operator|&
name|searchSymbol
argument_list|)
expr_stmt|;
name|bool
name|sameSymbol
init|=
name|searchSymbol
operator|.
name|foundMatch
argument_list|()
decl_stmt|;
if|if
condition|(
name|sameSymbol
condition|)
block|{
comment|// Type already printed
name|out
operator|<<
literal|"t"
operator|+
name|str
argument_list|(
name|mUniqueIndex
argument_list|)
operator|+
literal|" = "
expr_stmt|;
name|expression
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|", "
expr_stmt|;
name|symbolNode
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|" = t"
operator|+
name|str
argument_list|(
name|mUniqueIndex
argument_list|)
expr_stmt|;
name|mUniqueIndex
operator|++
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|visit
operator|==
name|InVisit
condition|)
block|{
name|out
operator|<<
literal|" = "
expr_stmt|;
block|}
break|break;
case|case
name|EOpAddAssign
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" += "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpSubAssign
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" -= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpMulAssign
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" *= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpVectorTimesScalarAssign
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" *= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpMatrixTimesScalarAssign
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" *= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpVectorTimesMatrixAssign
case|:
if|if
condition|(
name|visit
operator|==
name|PreVisit
condition|)
block|{
name|out
operator|<<
literal|"("
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|visit
operator|==
name|InVisit
condition|)
block|{
name|out
operator|<<
literal|" = mul("
expr_stmt|;
name|node
operator|->
name|getLeft
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|", transpose("
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
literal|")))"
expr_stmt|;
block|}
break|break;
case|case
name|EOpMatrixTimesMatrixAssign
case|:
if|if
condition|(
name|visit
operator|==
name|PreVisit
condition|)
block|{
name|out
operator|<<
literal|"("
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|visit
operator|==
name|InVisit
condition|)
block|{
name|out
operator|<<
literal|" = mul("
expr_stmt|;
name|node
operator|->
name|getLeft
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|", "
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
literal|"))"
expr_stmt|;
block|}
break|break;
case|case
name|EOpDivAssign
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" /= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpIndexDirect
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|""
argument_list|,
literal|"["
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpIndexIndirect
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|""
argument_list|,
literal|"["
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpIndexDirectStruct
case|:
if|if
condition|(
name|visit
operator|==
name|InVisit
condition|)
block|{
name|out
operator|<<
literal|"."
operator|+
name|decorateField
argument_list|(
name|node
operator|->
name|getType
argument_list|()
operator|.
name|getFieldName
argument_list|()
argument_list|,
name|node
operator|->
name|getLeft
argument_list|()
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|EOpVectorSwizzle
case|:
if|if
condition|(
name|visit
operator|==
name|InVisit
condition|)
block|{
name|out
operator|<<
literal|"."
expr_stmt|;
name|TIntermAggregate
modifier|*
name|swizzle
init|=
name|node
operator|->
name|getRight
argument_list|()
operator|->
name|getAsAggregate
argument_list|()
decl_stmt|;
if|if
condition|(
name|swizzle
condition|)
block|{
name|TIntermSequence
modifier|&
name|sequence
init|=
name|swizzle
operator|->
name|getSequence
argument_list|()
decl_stmt|;
for|for
control|(
name|TIntermSequence
operator|::
name|iterator
name|sit
init|=
name|sequence
operator|.
name|begin
argument_list|()
init|;
name|sit
operator|!=
name|sequence
operator|.
name|end
argument_list|()
condition|;
name|sit
operator|++
control|)
block|{
name|TIntermConstantUnion
modifier|*
name|element
init|=
operator|(
operator|*
name|sit
operator|)
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
if|if
condition|(
name|element
condition|)
block|{
name|int
name|i
init|=
name|element
operator|->
name|getUnionArrayPointer
argument_list|()
index|[
literal|0
index|]
operator|.
name|getIConst
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
name|out
operator|<<
literal|"x"
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|out
operator|<<
literal|"y"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|out
operator|<<
literal|"z"
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|out
operator|<<
literal|"w"
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
comment|// Fully processed
block|}
break|break;
case|case
name|EOpAdd
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" + "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpSub
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" - "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpMul
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" * "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpDiv
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" / "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpEqual
case|:
case|case
name|EOpNotEqual
case|:
if|if
condition|(
name|node
operator|->
name|getLeft
argument_list|()
operator|->
name|isScalar
argument_list|()
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|getOp
argument_list|()
operator|==
name|EOpEqual
condition|)
block|{
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" == "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" != "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|getLeft
argument_list|()
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtStruct
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|getOp
argument_list|()
operator|==
name|EOpEqual
condition|)
block|{
name|out
operator|<<
literal|"("
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
literal|"!("
expr_stmt|;
block|}
specifier|const
name|TTypeList
modifier|*
name|fields
init|=
name|node
operator|->
name|getLeft
argument_list|()
operator|->
name|getType
argument_list|()
operator|.
name|getStruct
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|->
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|TType
modifier|*
name|fieldType
init|=
operator|(
operator|*
name|fields
operator|)
index|[
name|i
index|]
operator|.
name|type
decl_stmt|;
name|node
operator|->
name|getLeft
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"."
operator|+
name|decorateField
argument_list|(
name|fieldType
operator|->
name|getFieldName
argument_list|()
argument_list|,
name|node
operator|->
name|getLeft
argument_list|()
operator|->
name|getType
argument_list|()
argument_list|)
operator|+
literal|" == "
expr_stmt|;
name|node
operator|->
name|getRight
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"."
operator|+
name|decorateField
argument_list|(
name|fieldType
operator|->
name|getFieldName
argument_list|()
argument_list|,
name|node
operator|->
name|getLeft
argument_list|()
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|fields
operator|->
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
name|out
operator|<<
literal|"&& "
expr_stmt|;
block|}
block|}
name|out
operator|<<
literal|")"
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
if|if
condition|(
name|node
operator|->
name|getLeft
argument_list|()
operator|->
name|isMatrix
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|node
operator|->
name|getLeft
argument_list|()
operator|->
name|getNominalSize
argument_list|()
condition|)
block|{
case|case
literal|2
case|:
name|mUsesEqualMat2
operator|=
literal|true
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|mUsesEqualMat3
operator|=
literal|true
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|mUsesEqualMat4
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|getLeft
argument_list|()
operator|->
name|isVector
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|node
operator|->
name|getLeft
argument_list|()
operator|->
name|getBasicType
argument_list|()
condition|)
block|{
case|case
name|EbtFloat
case|:
switch|switch
condition|(
name|node
operator|->
name|getLeft
argument_list|()
operator|->
name|getNominalSize
argument_list|()
condition|)
block|{
case|case
literal|2
case|:
name|mUsesEqualVec2
operator|=
literal|true
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|mUsesEqualVec3
operator|=
literal|true
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|mUsesEqualVec4
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|EbtInt
case|:
switch|switch
condition|(
name|node
operator|->
name|getLeft
argument_list|()
operator|->
name|getNominalSize
argument_list|()
condition|)
block|{
case|case
literal|2
case|:
name|mUsesEqualIVec2
operator|=
literal|true
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|mUsesEqualIVec3
operator|=
literal|true
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|mUsesEqualIVec4
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|EbtBool
case|:
switch|switch
condition|(
name|node
operator|->
name|getLeft
argument_list|()
operator|->
name|getNominalSize
argument_list|()
condition|)
block|{
case|case
literal|2
case|:
name|mUsesEqualBVec2
operator|=
literal|true
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|mUsesEqualBVec3
operator|=
literal|true
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|mUsesEqualBVec4
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getOp
argument_list|()
operator|==
name|EOpEqual
condition|)
block|{
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"equal("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"!equal("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|EOpLessThan
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|"< "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpGreaterThan
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|"> "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpLessThanEqual
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|"<= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpGreaterThanEqual
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|">= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpVectorTimesScalar
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" * "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpMatrixTimesScalar
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" * "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpVectorTimesMatrix
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"mul("
argument_list|,
literal|", transpose("
argument_list|,
literal|"))"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpMatrixTimesVector
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"mul(transpose("
argument_list|,
literal|"), "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpMatrixTimesMatrix
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"transpose(mul(transpose("
argument_list|,
literal|"), transpose("
argument_list|,
literal|")))"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpLogicalOr
case|:
name|out
operator|<<
literal|"s"
operator|<<
name|mUnfoldShortCircuit
operator|->
name|getNextTemporaryIndex
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
case|case
name|EOpLogicalXor
case|:
name|mUsesXor
operator|=
literal|true
expr_stmt|;
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"xor("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpLogicalAnd
case|:
name|out
operator|<<
literal|"s"
operator|<<
name|mUnfoldShortCircuit
operator|->
name|getNextTemporaryIndex
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|visitUnary
name|bool
name|OutputHLSL
operator|::
name|visitUnary
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermUnary
modifier|*
name|node
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|->
name|getOp
argument_list|()
condition|)
block|{
case|case
name|EOpNegative
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"(-"
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpVectorLogicalNot
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"(!"
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpLogicalNot
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"(!"
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpPostIncrement
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|""
argument_list|,
literal|"++)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpPostDecrement
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|""
argument_list|,
literal|"--)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpPreIncrement
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"(++"
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpPreDecrement
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"(--"
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConvIntToBool
case|:
case|case
name|EOpConvFloatToBool
case|:
switch|switch
condition|(
name|node
operator|->
name|getOperand
argument_list|()
operator|->
name|getType
argument_list|()
operator|.
name|getNominalSize
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"bool("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"bool2("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"bool3("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"bool4("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|EOpConvBoolToFloat
case|:
case|case
name|EOpConvIntToFloat
case|:
switch|switch
condition|(
name|node
operator|->
name|getOperand
argument_list|()
operator|->
name|getType
argument_list|()
operator|.
name|getNominalSize
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"float("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"float2("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"float3("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"float4("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|EOpConvFloatToInt
case|:
case|case
name|EOpConvBoolToInt
case|:
switch|switch
condition|(
name|node
operator|->
name|getOperand
argument_list|()
operator|->
name|getType
argument_list|()
operator|.
name|getNominalSize
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"int("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"int2("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"int3("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"int4("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|EOpRadians
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"radians("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpDegrees
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"degrees("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpSin
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"sin("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpCos
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"cos("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpTan
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"tan("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpAsin
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"asin("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpAcos
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"acos("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpAtan
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"atan("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpExp
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"exp("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpLog
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"log("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpExp2
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"exp2("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpLog2
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"log2("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpSqrt
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"sqrt("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpInverseSqrt
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"rsqrt("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpAbs
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"abs("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpSign
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"sign("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpFloor
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"floor("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpCeil
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"ceil("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpFract
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"frac("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpLength
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"length("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpNormalize
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"normalize("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpDFdx
case|:
if|if
condition|(
name|mInsideDiscontinuousLoop
operator|||
name|mOutputLod0Function
condition|)
block|{
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|""
argument_list|,
literal|", 0.0)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"ddx("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EOpDFdy
case|:
if|if
condition|(
name|mInsideDiscontinuousLoop
operator|||
name|mOutputLod0Function
condition|)
block|{
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|""
argument_list|,
literal|", 0.0)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"ddy("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EOpFwidth
case|:
if|if
condition|(
name|mInsideDiscontinuousLoop
operator|||
name|mOutputLod0Function
condition|)
block|{
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|""
argument_list|,
literal|", 0.0)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"fwidth("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EOpAny
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"any("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpAll
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"all("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|visitAggregate
name|bool
name|OutputHLSL
operator|::
name|visitAggregate
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermAggregate
modifier|*
name|node
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|mBody
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|getOp
argument_list|()
condition|)
block|{
case|case
name|EOpSequence
case|:
block|{
if|if
condition|(
name|mInsideFunction
condition|)
block|{
name|outputLineDirective
argument_list|(
name|node
operator|->
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"{\n"
expr_stmt|;
name|mScopeDepth
operator|++
expr_stmt|;
if|if
condition|(
name|mScopeBracket
operator|.
name|size
argument_list|()
operator|<
name|mScopeDepth
condition|)
block|{
name|mScopeBracket
operator|.
name|push_back
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// New scope level
block|}
else|else
block|{
name|mScopeBracket
index|[
name|mScopeDepth
operator|-
literal|1
index|]
operator|++
expr_stmt|;
comment|// New scope at existing level
block|}
block|}
for|for
control|(
name|TIntermSequence
operator|::
name|iterator
name|sit
init|=
name|node
operator|->
name|getSequence
argument_list|()
operator|.
name|begin
argument_list|()
init|;
name|sit
operator|!=
name|node
operator|->
name|getSequence
argument_list|()
operator|.
name|end
argument_list|()
condition|;
name|sit
operator|++
control|)
block|{
name|outputLineDirective
argument_list|(
operator|(
operator|*
name|sit
operator|)
operator|->
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
name|traverseStatements
argument_list|(
operator|*
name|sit
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|";\n"
expr_stmt|;
block|}
if|if
condition|(
name|mInsideFunction
condition|)
block|{
name|outputLineDirective
argument_list|(
name|node
operator|->
name|getEndLine
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"}\n"
expr_stmt|;
name|mScopeDepth
operator|--
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
case|case
name|EOpDeclaration
case|:
if|if
condition|(
name|visit
operator|==
name|PreVisit
condition|)
block|{
name|TIntermSequence
modifier|&
name|sequence
init|=
name|node
operator|->
name|getSequence
argument_list|()
decl_stmt|;
name|TIntermTyped
modifier|*
name|variable
init|=
name|sequence
index|[
literal|0
index|]
operator|->
name|getAsTyped
argument_list|()
decl_stmt|;
name|bool
name|visit
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|variable
operator|&&
operator|(
name|variable
operator|->
name|getQualifier
argument_list|()
operator|==
name|EvqTemporary
operator|||
name|variable
operator|->
name|getQualifier
argument_list|()
operator|==
name|EvqGlobal
operator|)
condition|)
block|{
if|if
condition|(
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|getStruct
argument_list|()
condition|)
block|{
name|addConstructor
argument_list|(
name|variable
operator|->
name|getType
argument_list|()
argument_list|,
name|scopedStruct
argument_list|(
name|variable
operator|->
name|getType
argument_list|()
operator|.
name|getTypeName
argument_list|()
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|variable
operator|->
name|getAsSymbolNode
argument_list|()
operator|||
name|variable
operator|->
name|getAsSymbolNode
argument_list|()
operator|->
name|getSymbol
argument_list|()
operator|!=
literal|""
condition|)
comment|// Variable declaration
block|{
if|if
condition|(
operator|!
name|mInsideFunction
condition|)
block|{
name|out
operator|<<
literal|"static "
expr_stmt|;
block|}
name|out
operator|<<
name|typeString
argument_list|(
name|variable
operator|->
name|getType
argument_list|()
argument_list|)
operator|+
literal|" "
expr_stmt|;
for|for
control|(
name|TIntermSequence
operator|::
name|iterator
name|sit
init|=
name|sequence
operator|.
name|begin
argument_list|()
init|;
name|sit
operator|!=
name|sequence
operator|.
name|end
argument_list|()
condition|;
name|sit
operator|++
control|)
block|{
name|TIntermSymbol
modifier|*
name|symbol
init|=
operator|(
operator|*
name|sit
operator|)
operator|->
name|getAsSymbolNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|symbol
condition|)
block|{
name|symbol
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
name|arrayString
argument_list|(
name|symbol
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|" = "
operator|+
name|initializer
argument_list|(
name|variable
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|sit
operator|)
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|visit
operator|&&
name|this
operator|->
name|inVisit
condition|)
block|{
if|if
condition|(
operator|*
name|sit
operator|!=
name|sequence
operator|.
name|back
argument_list|()
condition|)
block|{
name|visit
operator|=
name|this
operator|->
name|visitAggregate
argument_list|(
name|InVisit
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|visit
operator|&&
name|this
operator|->
name|postVisit
condition|)
block|{
name|this
operator|->
name|visitAggregate
argument_list|(
name|PostVisit
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|variable
operator|->
name|getAsSymbolNode
argument_list|()
operator|&&
name|variable
operator|->
name|getAsSymbolNode
argument_list|()
operator|->
name|getSymbol
argument_list|()
operator|==
literal|""
condition|)
comment|// Type (struct) declaration
block|{
comment|// Already added to constructor map
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|visit
operator|==
name|InVisit
condition|)
block|{
name|out
operator|<<
literal|", "
expr_stmt|;
block|}
break|break;
case|case
name|EOpPrototype
case|:
if|if
condition|(
name|visit
operator|==
name|PreVisit
condition|)
block|{
name|out
operator|<<
name|typeString
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|)
operator|<<
literal|" "
operator|<<
name|decorate
argument_list|(
name|node
operator|->
name|getName
argument_list|()
argument_list|)
operator|<<
operator|(
name|mOutputLod0Function
condition|?
literal|"Lod0("
else|:
literal|"("
operator|)
expr_stmt|;
name|TIntermSequence
modifier|&
name|arguments
init|=
name|node
operator|->
name|getSequence
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|arguments
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|TIntermSymbol
modifier|*
name|symbol
init|=
name|arguments
index|[
name|i
index|]
operator|->
name|getAsSymbolNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|symbol
condition|)
block|{
name|out
operator|<<
name|argumentString
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|arguments
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
name|out
operator|<<
literal|", "
expr_stmt|;
block|}
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
name|out
operator|<<
literal|");\n"
expr_stmt|;
comment|// Also prototype the Lod0 variant if needed
if|if
condition|(
name|mContainsLoopDiscontinuity
operator|&&
operator|!
name|mOutputLod0Function
condition|)
block|{
name|mOutputLod0Function
operator|=
literal|true
expr_stmt|;
name|node
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|mOutputLod0Function
operator|=
literal|false
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
break|break;
case|case
name|EOpComma
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpFunction
case|:
block|{
name|TString
name|name
init|=
name|TFunction
operator|::
name|unmangleName
argument_list|(
name|node
operator|->
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|out
operator|<<
name|typeString
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|)
operator|<<
literal|" "
expr_stmt|;
if|if
condition|(
name|name
operator|==
literal|"main"
condition|)
block|{
name|out
operator|<<
literal|"gl_main("
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
name|decorate
argument_list|(
name|name
argument_list|)
operator|<<
operator|(
name|mOutputLod0Function
condition|?
literal|"Lod0("
else|:
literal|"("
operator|)
expr_stmt|;
block|}
name|TIntermSequence
modifier|&
name|sequence
init|=
name|node
operator|->
name|getSequence
argument_list|()
decl_stmt|;
name|TIntermSequence
modifier|&
name|arguments
init|=
name|sequence
index|[
literal|0
index|]
operator|->
name|getAsAggregate
argument_list|()
operator|->
name|getSequence
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|arguments
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|TIntermSymbol
modifier|*
name|symbol
init|=
name|arguments
index|[
name|i
index|]
operator|->
name|getAsSymbolNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|symbol
condition|)
block|{
if|if
condition|(
name|symbol
operator|->
name|getType
argument_list|()
operator|.
name|getStruct
argument_list|()
condition|)
block|{
name|addConstructor
argument_list|(
name|symbol
operator|->
name|getType
argument_list|()
argument_list|,
name|scopedStruct
argument_list|(
name|symbol
operator|->
name|getType
argument_list|()
operator|.
name|getTypeName
argument_list|()
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|out
operator|<<
name|argumentString
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|arguments
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
name|out
operator|<<
literal|", "
expr_stmt|;
block|}
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
name|out
operator|<<
literal|")\n"
literal|"{\n"
expr_stmt|;
if|if
condition|(
name|sequence
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|mInsideFunction
operator|=
literal|true
expr_stmt|;
name|sequence
index|[
literal|1
index|]
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|mInsideFunction
operator|=
literal|false
expr_stmt|;
block|}
name|out
operator|<<
literal|"}\n"
expr_stmt|;
if|if
condition|(
name|mContainsLoopDiscontinuity
operator|&&
operator|!
name|mOutputLod0Function
condition|)
block|{
if|if
condition|(
name|name
operator|!=
literal|"main"
condition|)
block|{
name|mOutputLod0Function
operator|=
literal|true
expr_stmt|;
name|node
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|mOutputLod0Function
operator|=
literal|false
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
break|break;
case|case
name|EOpFunctionCall
case|:
block|{
if|if
condition|(
name|visit
operator|==
name|PreVisit
condition|)
block|{
name|TString
name|name
init|=
name|TFunction
operator|::
name|unmangleName
argument_list|(
name|node
operator|->
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|bool
name|lod0
init|=
name|mInsideDiscontinuousLoop
operator|||
name|mOutputLod0Function
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|isUserDefined
argument_list|()
condition|)
block|{
name|out
operator|<<
name|decorate
argument_list|(
name|name
argument_list|)
operator|<<
operator|(
name|lod0
condition|?
literal|"Lod0("
else|:
literal|"("
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|name
operator|==
literal|"texture2D"
condition|)
block|{
if|if
condition|(
operator|!
name|lod0
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|getSequence
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|mUsesTexture2D
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|getSequence
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|3
condition|)
block|{
name|mUsesTexture2D_bias
operator|=
literal|true
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
name|out
operator|<<
literal|"gl_texture2D("
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|node
operator|->
name|getSequence
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|mUsesTexture2DLod0
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|getSequence
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|3
condition|)
block|{
name|mUsesTexture2DLod0_bias
operator|=
literal|true
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
name|out
operator|<<
literal|"gl_texture2DLod0("
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|name
operator|==
literal|"texture2DProj"
condition|)
block|{
if|if
condition|(
operator|!
name|lod0
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|getSequence
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|mUsesTexture2DProj
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|getSequence
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|3
condition|)
block|{
name|mUsesTexture2DProj_bias
operator|=
literal|true
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
name|out
operator|<<
literal|"gl_texture2DProj("
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|node
operator|->
name|getSequence
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|mUsesTexture2DProjLod0
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|getSequence
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|3
condition|)
block|{
name|mUsesTexture2DProjLod0_bias
operator|=
literal|true
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
name|out
operator|<<
literal|"gl_texture2DProjLod0("
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|name
operator|==
literal|"textureCube"
condition|)
block|{
if|if
condition|(
operator|!
name|lod0
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|getSequence
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|mUsesTextureCube
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|getSequence
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|3
condition|)
block|{
name|mUsesTextureCube_bias
operator|=
literal|true
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
name|out
operator|<<
literal|"gl_textureCube("
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|node
operator|->
name|getSequence
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|mUsesTextureCubeLod0
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|getSequence
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|3
condition|)
block|{
name|mUsesTextureCubeLod0_bias
operator|=
literal|true
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
name|out
operator|<<
literal|"gl_textureCubeLod0("
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|name
operator|==
literal|"texture2DLod"
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|getSequence
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|3
condition|)
block|{
name|mUsesTexture2DLod
operator|=
literal|true
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
name|out
operator|<<
literal|"gl_texture2DLod("
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
literal|"texture2DProjLod"
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|getSequence
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|3
condition|)
block|{
name|mUsesTexture2DProjLod
operator|=
literal|true
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
name|out
operator|<<
literal|"gl_texture2DProjLod("
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
literal|"textureCubeLod"
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|getSequence
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|3
condition|)
block|{
name|mUsesTextureCubeLod
operator|=
literal|true
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
name|out
operator|<<
literal|"gl_textureCubeLod("
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|visit
operator|==
name|InVisit
condition|)
block|{
name|out
operator|<<
literal|", "
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
literal|")"
expr_stmt|;
block|}
block|}
break|break;
case|case
name|EOpParameters
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|", "
argument_list|,
literal|")\n{\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructFloat
case|:
name|addConstructor
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|,
literal|"vec1"
argument_list|,
operator|&
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"vec1("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructVec2
case|:
name|addConstructor
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|,
literal|"vec2"
argument_list|,
operator|&
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"vec2("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructVec3
case|:
name|addConstructor
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|,
literal|"vec3"
argument_list|,
operator|&
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"vec3("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructVec4
case|:
name|addConstructor
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|,
literal|"vec4"
argument_list|,
operator|&
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"vec4("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructBool
case|:
name|addConstructor
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|,
literal|"bvec1"
argument_list|,
operator|&
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"bvec1("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructBVec2
case|:
name|addConstructor
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|,
literal|"bvec2"
argument_list|,
operator|&
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"bvec2("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructBVec3
case|:
name|addConstructor
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|,
literal|"bvec3"
argument_list|,
operator|&
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"bvec3("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructBVec4
case|:
name|addConstructor
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|,
literal|"bvec4"
argument_list|,
operator|&
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"bvec4("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructInt
case|:
name|addConstructor
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|,
literal|"ivec1"
argument_list|,
operator|&
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"ivec1("
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructIVec2
case|:
name|addConstructor
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|,
literal|"ivec2"
argument_list|,
operator|&
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"ivec2("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructIVec3
case|:
name|addConstructor
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|,
literal|"ivec3"
argument_list|,
operator|&
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"ivec3("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructIVec4
case|:
name|addConstructor
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|,
literal|"ivec4"
argument_list|,
operator|&
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"ivec4("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructMat2
case|:
name|addConstructor
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|,
literal|"mat2"
argument_list|,
operator|&
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"mat2("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructMat3
case|:
name|addConstructor
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|,
literal|"mat3"
argument_list|,
operator|&
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"mat3("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructMat4
case|:
name|addConstructor
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|,
literal|"mat4"
argument_list|,
operator|&
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"mat4("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpConstructStruct
case|:
name|addConstructor
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|,
name|scopedStruct
argument_list|(
name|node
operator|->
name|getType
argument_list|()
operator|.
name|getTypeName
argument_list|()
argument_list|)
argument_list|,
operator|&
name|node
operator|->
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
name|outputTriplet
argument_list|(
name|visit
argument_list|,
name|structLookup
argument_list|(
name|node
operator|->
name|getType
argument_list|()
operator|.
name|getTypeName
argument_list|()
argument_list|)
operator|+
literal|"_ctor("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpLessThan
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|"< "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpGreaterThan
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|"> "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpLessThanEqual
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|"<= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpGreaterThanEqual
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|">= "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpVectorEqual
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" == "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpVectorNotEqual
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" != "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpMod
case|:
block|{
comment|// We need to look at the number of components in both arguments
switch|switch
condition|(
name|node
operator|->
name|getSequence
argument_list|()
index|[
literal|0
index|]
operator|->
name|getAsTyped
argument_list|()
operator|->
name|getNominalSize
argument_list|()
operator|*
literal|10
operator|+
name|node
operator|->
name|getSequence
argument_list|()
index|[
literal|1
index|]
operator|->
name|getAsTyped
argument_list|()
operator|->
name|getNominalSize
argument_list|()
condition|)
block|{
case|case
literal|11
case|:
name|mUsesMod1
operator|=
literal|true
expr_stmt|;
break|break;
case|case
literal|22
case|:
name|mUsesMod2v
operator|=
literal|true
expr_stmt|;
break|break;
case|case
literal|21
case|:
name|mUsesMod2f
operator|=
literal|true
expr_stmt|;
break|break;
case|case
literal|33
case|:
name|mUsesMod3v
operator|=
literal|true
expr_stmt|;
break|break;
case|case
literal|31
case|:
name|mUsesMod3f
operator|=
literal|true
expr_stmt|;
break|break;
case|case
literal|44
case|:
name|mUsesMod4v
operator|=
literal|true
expr_stmt|;
break|break;
case|case
literal|41
case|:
name|mUsesMod4f
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"mod("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EOpPow
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"pow("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpAtan
case|:
name|ASSERT
argument_list|(
name|node
operator|->
name|getSequence
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|2
argument_list|)
expr_stmt|;
comment|// atan(x) is a unary operator
switch|switch
condition|(
name|node
operator|->
name|getSequence
argument_list|()
index|[
literal|0
index|]
operator|->
name|getAsTyped
argument_list|()
operator|->
name|getNominalSize
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
name|mUsesAtan2_1
operator|=
literal|true
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|mUsesAtan2_2
operator|=
literal|true
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|mUsesAtan2_3
operator|=
literal|true
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|mUsesAtan2_4
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"atanyx("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpMin
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"min("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpMax
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"max("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpClamp
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"clamp("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpMix
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"lerp("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpStep
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"step("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpSmoothStep
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"smoothstep("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpDistance
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"distance("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpDot
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"dot("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpCross
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"cross("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpFaceForward
case|:
block|{
switch|switch
condition|(
name|node
operator|->
name|getSequence
argument_list|()
index|[
literal|0
index|]
operator|->
name|getAsTyped
argument_list|()
operator|->
name|getNominalSize
argument_list|()
condition|)
comment|// Number of components in the first argument
block|{
case|case
literal|1
case|:
name|mUsesFaceforward1
operator|=
literal|true
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|mUsesFaceforward2
operator|=
literal|true
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|mUsesFaceforward3
operator|=
literal|true
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|mUsesFaceforward4
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"faceforward("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EOpReflect
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"reflect("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpRefract
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"refract("
argument_list|,
literal|", "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpMul
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"("
argument_list|,
literal|" * "
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|visitSelection
name|bool
name|OutputHLSL
operator|::
name|visitSelection
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermSelection
modifier|*
name|node
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|mBody
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|usesTernaryOperator
argument_list|()
condition|)
block|{
name|out
operator|<<
literal|"s"
operator|<<
name|mUnfoldShortCircuit
operator|->
name|getNextTemporaryIndex
argument_list|()
expr_stmt|;
block|}
else|else
comment|// if/else statement
block|{
name|mUnfoldShortCircuit
operator|->
name|traverse
argument_list|(
name|node
operator|->
name|getCondition
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"if("
expr_stmt|;
name|node
operator|->
name|getCondition
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|")\n"
expr_stmt|;
name|outputLineDirective
argument_list|(
name|node
operator|->
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"{\n"
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getTrueBlock
argument_list|()
condition|)
block|{
name|traverseStatements
argument_list|(
name|node
operator|->
name|getTrueBlock
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|outputLineDirective
argument_list|(
name|node
operator|->
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|";\n}\n"
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getFalseBlock
argument_list|()
condition|)
block|{
name|out
operator|<<
literal|"else\n"
expr_stmt|;
name|outputLineDirective
argument_list|(
name|node
operator|->
name|getFalseBlock
argument_list|()
operator|->
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"{\n"
expr_stmt|;
name|outputLineDirective
argument_list|(
name|node
operator|->
name|getFalseBlock
argument_list|()
operator|->
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
name|traverseStatements
argument_list|(
name|node
operator|->
name|getFalseBlock
argument_list|()
argument_list|)
expr_stmt|;
name|outputLineDirective
argument_list|(
name|node
operator|->
name|getFalseBlock
argument_list|()
operator|->
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|";\n}\n"
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|function|visitConstantUnion
name|void
name|OutputHLSL
operator|::
name|visitConstantUnion
parameter_list|(
name|TIntermConstantUnion
modifier|*
name|node
parameter_list|)
block|{
name|writeConstantUnion
argument_list|(
name|node
operator|->
name|getType
argument_list|()
argument_list|,
name|node
operator|->
name|getUnionArrayPointer
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|function|visitLoop
name|bool
name|OutputHLSL
operator|::
name|visitLoop
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermLoop
modifier|*
name|node
parameter_list|)
block|{
name|bool
name|wasDiscontinuous
init|=
name|mInsideDiscontinuousLoop
decl_stmt|;
if|if
condition|(
operator|!
name|mInsideDiscontinuousLoop
condition|)
block|{
name|mInsideDiscontinuousLoop
operator|=
name|containsLoopDiscontinuity
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|handleExcessiveLoop
argument_list|(
name|node
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|TInfoSinkBase
modifier|&
name|out
init|=
name|mBody
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|getType
argument_list|()
operator|==
name|ELoopDoWhile
condition|)
block|{
name|out
operator|<<
literal|"{do\n"
expr_stmt|;
name|outputLineDirective
argument_list|(
name|node
operator|->
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"{\n"
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
literal|"{for("
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getInit
argument_list|()
condition|)
block|{
name|node
operator|->
name|getInit
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|out
operator|<<
literal|"; "
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getCondition
argument_list|()
condition|)
block|{
name|node
operator|->
name|getCondition
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|out
operator|<<
literal|"; "
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getExpression
argument_list|()
condition|)
block|{
name|node
operator|->
name|getExpression
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|out
operator|<<
literal|")\n"
expr_stmt|;
name|outputLineDirective
argument_list|(
name|node
operator|->
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"{\n"
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|getBody
argument_list|()
condition|)
block|{
name|traverseStatements
argument_list|(
name|node
operator|->
name|getBody
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|outputLineDirective
argument_list|(
name|node
operator|->
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|";}\n"
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getType
argument_list|()
operator|==
name|ELoopDoWhile
condition|)
block|{
name|outputLineDirective
argument_list|(
name|node
operator|->
name|getCondition
argument_list|()
operator|->
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"while(\n"
expr_stmt|;
name|node
operator|->
name|getCondition
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|");"
expr_stmt|;
block|}
name|out
operator|<<
literal|"}\n"
expr_stmt|;
name|mInsideDiscontinuousLoop
operator|=
name|wasDiscontinuous
expr_stmt|;
return|return
literal|false
return|;
block|}
DECL|function|visitBranch
name|bool
name|OutputHLSL
operator|::
name|visitBranch
parameter_list|(
name|Visit
name|visit
parameter_list|,
name|TIntermBranch
modifier|*
name|node
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|mBody
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|getFlowOp
argument_list|()
condition|)
block|{
case|case
name|EOpKill
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"discard;\n"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpBreak
case|:
if|if
condition|(
name|visit
operator|==
name|PreVisit
condition|)
block|{
if|if
condition|(
name|mExcessiveLoopIndex
condition|)
block|{
name|out
operator|<<
literal|"{Break"
expr_stmt|;
name|mExcessiveLoopIndex
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|" = true; break;}\n"
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
literal|"break;\n"
expr_stmt|;
block|}
block|}
break|break;
case|case
name|EOpContinue
case|:
name|outputTriplet
argument_list|(
name|visit
argument_list|,
literal|"continue;\n"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpReturn
case|:
if|if
condition|(
name|visit
operator|==
name|PreVisit
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|getExpression
argument_list|()
condition|)
block|{
name|out
operator|<<
literal|"return "
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
literal|"return;\n"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|visit
operator|==
name|PostVisit
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|getExpression
argument_list|()
condition|)
block|{
name|out
operator|<<
literal|";\n"
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|traverseStatements
name|void
name|OutputHLSL
operator|::
name|traverseStatements
parameter_list|(
name|TIntermNode
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|isSingleStatement
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|mUnfoldShortCircuit
operator|->
name|traverse
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|node
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
DECL|function|isSingleStatement
name|bool
name|OutputHLSL
operator|::
name|isSingleStatement
parameter_list|(
name|TIntermNode
modifier|*
name|node
parameter_list|)
block|{
name|TIntermAggregate
modifier|*
name|aggregate
init|=
name|node
operator|->
name|getAsAggregate
argument_list|()
decl_stmt|;
if|if
condition|(
name|aggregate
condition|)
block|{
if|if
condition|(
name|aggregate
operator|->
name|getOp
argument_list|()
operator|==
name|EOpSequence
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
for|for
control|(
name|TIntermSequence
operator|::
name|iterator
name|sit
init|=
name|aggregate
operator|->
name|getSequence
argument_list|()
operator|.
name|begin
argument_list|()
init|;
name|sit
operator|!=
name|aggregate
operator|->
name|getSequence
argument_list|()
operator|.
name|end
argument_list|()
condition|;
name|sit
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isSingleStatement
argument_list|(
operator|*
name|sit
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|// Handle loops with more than 254 iterations (unsupported by D3D9) by splitting them
comment|// (The D3D documentation says 255 iterations, but the compiler complains at anything more than 254).
DECL|function|handleExcessiveLoop
name|bool
name|OutputHLSL
operator|::
name|handleExcessiveLoop
parameter_list|(
name|TIntermLoop
modifier|*
name|node
parameter_list|)
block|{
specifier|const
name|int
name|MAX_LOOP_ITERATIONS
init|=
literal|254
decl_stmt|;
name|TInfoSinkBase
modifier|&
name|out
init|=
name|mBody
decl_stmt|;
comment|// Parse loops of the form:
comment|// for(int index = initial; index [comparator] limit; index += increment)
name|TIntermSymbol
modifier|*
name|index
init|=
name|NULL
decl_stmt|;
name|TOperator
name|comparator
init|=
name|EOpNull
decl_stmt|;
name|int
name|initial
init|=
literal|0
decl_stmt|;
name|int
name|limit
init|=
literal|0
decl_stmt|;
name|int
name|increment
init|=
literal|0
decl_stmt|;
comment|// Parse index name and intial value
if|if
condition|(
name|node
operator|->
name|getInit
argument_list|()
condition|)
block|{
name|TIntermAggregate
modifier|*
name|init
init|=
name|node
operator|->
name|getInit
argument_list|()
operator|->
name|getAsAggregate
argument_list|()
decl_stmt|;
if|if
condition|(
name|init
condition|)
block|{
name|TIntermSequence
modifier|&
name|sequence
init|=
name|init
operator|->
name|getSequence
argument_list|()
decl_stmt|;
name|TIntermTyped
modifier|*
name|variable
init|=
name|sequence
index|[
literal|0
index|]
operator|->
name|getAsTyped
argument_list|()
decl_stmt|;
if|if
condition|(
name|variable
operator|&&
name|variable
operator|->
name|getQualifier
argument_list|()
operator|==
name|EvqTemporary
condition|)
block|{
name|TIntermBinary
modifier|*
name|assign
init|=
name|variable
operator|->
name|getAsBinaryNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|assign
operator|->
name|getOp
argument_list|()
operator|==
name|EOpInitialize
condition|)
block|{
name|TIntermSymbol
modifier|*
name|symbol
init|=
name|assign
operator|->
name|getLeft
argument_list|()
operator|->
name|getAsSymbolNode
argument_list|()
decl_stmt|;
name|TIntermConstantUnion
modifier|*
name|constant
init|=
name|assign
operator|->
name|getRight
argument_list|()
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
if|if
condition|(
name|symbol
operator|&&
name|constant
condition|)
block|{
if|if
condition|(
name|constant
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtInt
operator|&&
name|constant
operator|->
name|getNominalSize
argument_list|()
operator|==
literal|1
condition|)
block|{
name|index
operator|=
name|symbol
expr_stmt|;
name|initial
operator|=
name|constant
operator|->
name|getUnionArrayPointer
argument_list|()
index|[
literal|0
index|]
operator|.
name|getIConst
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
comment|// Parse comparator and limit value
if|if
condition|(
name|index
operator|!=
name|NULL
operator|&&
name|node
operator|->
name|getCondition
argument_list|()
condition|)
block|{
name|TIntermBinary
modifier|*
name|test
init|=
name|node
operator|->
name|getCondition
argument_list|()
operator|->
name|getAsBinaryNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|test
operator|&&
name|test
operator|->
name|getLeft
argument_list|()
operator|->
name|getAsSymbolNode
argument_list|()
operator|->
name|getId
argument_list|()
operator|==
name|index
operator|->
name|getId
argument_list|()
condition|)
block|{
name|TIntermConstantUnion
modifier|*
name|constant
init|=
name|test
operator|->
name|getRight
argument_list|()
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
if|if
condition|(
name|constant
condition|)
block|{
if|if
condition|(
name|constant
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtInt
operator|&&
name|constant
operator|->
name|getNominalSize
argument_list|()
operator|==
literal|1
condition|)
block|{
name|comparator
operator|=
name|test
operator|->
name|getOp
argument_list|()
expr_stmt|;
name|limit
operator|=
name|constant
operator|->
name|getUnionArrayPointer
argument_list|()
index|[
literal|0
index|]
operator|.
name|getIConst
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// Parse increment
if|if
condition|(
name|index
operator|!=
name|NULL
operator|&&
name|comparator
operator|!=
name|EOpNull
operator|&&
name|node
operator|->
name|getExpression
argument_list|()
condition|)
block|{
name|TIntermBinary
modifier|*
name|binaryTerminal
init|=
name|node
operator|->
name|getExpression
argument_list|()
operator|->
name|getAsBinaryNode
argument_list|()
decl_stmt|;
name|TIntermUnary
modifier|*
name|unaryTerminal
init|=
name|node
operator|->
name|getExpression
argument_list|()
operator|->
name|getAsUnaryNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|binaryTerminal
condition|)
block|{
name|TOperator
name|op
init|=
name|binaryTerminal
operator|->
name|getOp
argument_list|()
decl_stmt|;
name|TIntermConstantUnion
modifier|*
name|constant
init|=
name|binaryTerminal
operator|->
name|getRight
argument_list|()
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
if|if
condition|(
name|constant
condition|)
block|{
if|if
condition|(
name|constant
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtInt
operator|&&
name|constant
operator|->
name|getNominalSize
argument_list|()
operator|==
literal|1
condition|)
block|{
name|int
name|value
init|=
name|constant
operator|->
name|getUnionArrayPointer
argument_list|()
index|[
literal|0
index|]
operator|.
name|getIConst
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|EOpAddAssign
case|:
name|increment
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|EOpSubAssign
case|:
name|increment
operator|=
operator|-
name|value
expr_stmt|;
break|break;
default|default:
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|unaryTerminal
condition|)
block|{
name|TOperator
name|op
init|=
name|unaryTerminal
operator|->
name|getOp
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|EOpPostIncrement
case|:
name|increment
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|EOpPostDecrement
case|:
name|increment
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|EOpPreIncrement
case|:
name|increment
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|EOpPreDecrement
case|:
name|increment
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|index
operator|!=
name|NULL
operator|&&
name|comparator
operator|!=
name|EOpNull
operator|&&
name|increment
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|comparator
operator|==
name|EOpLessThanEqual
condition|)
block|{
name|comparator
operator|=
name|EOpLessThan
expr_stmt|;
name|limit
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|comparator
operator|==
name|EOpLessThan
condition|)
block|{
name|int
name|iterations
init|=
operator|(
name|limit
operator|-
name|initial
operator|)
operator|/
name|increment
decl_stmt|;
if|if
condition|(
name|iterations
operator|<=
name|MAX_LOOP_ITERATIONS
condition|)
block|{
return|return
literal|false
return|;
comment|// Not an excessive loop
block|}
name|TIntermSymbol
modifier|*
name|restoreIndex
init|=
name|mExcessiveLoopIndex
decl_stmt|;
name|mExcessiveLoopIndex
operator|=
name|index
expr_stmt|;
name|out
operator|<<
literal|"{int "
expr_stmt|;
name|index
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|";\n"
literal|"bool Break"
expr_stmt|;
name|index
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|" = false;\n"
expr_stmt|;
name|bool
name|firstLoopFragment
init|=
literal|true
decl_stmt|;
while|while
condition|(
name|iterations
operator|>
literal|0
condition|)
block|{
name|int
name|clampedLimit
init|=
name|initial
operator|+
name|increment
operator|*
name|std
operator|::
name|min
argument_list|(
name|MAX_LOOP_ITERATIONS
argument_list|,
name|iterations
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|firstLoopFragment
condition|)
block|{
name|out
operator|<<
literal|"if(!Break"
expr_stmt|;
name|index
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|") {\n"
expr_stmt|;
block|}
if|if
condition|(
name|iterations
operator|<=
name|MAX_LOOP_ITERATIONS
condition|)
comment|// Last loop fragment
block|{
name|mExcessiveLoopIndex
operator|=
name|NULL
expr_stmt|;
comment|// Stops setting the Break flag
block|}
comment|// for(int index = initial; index< clampedLimit; index += increment)
name|out
operator|<<
literal|"for("
expr_stmt|;
name|index
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|" = "
expr_stmt|;
name|out
operator|<<
name|initial
expr_stmt|;
name|out
operator|<<
literal|"; "
expr_stmt|;
name|index
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"< "
expr_stmt|;
name|out
operator|<<
name|clampedLimit
expr_stmt|;
name|out
operator|<<
literal|"; "
expr_stmt|;
name|index
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|" += "
expr_stmt|;
name|out
operator|<<
name|increment
expr_stmt|;
name|out
operator|<<
literal|")\n"
expr_stmt|;
name|outputLineDirective
argument_list|(
name|node
operator|->
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"{\n"
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|getBody
argument_list|()
condition|)
block|{
name|node
operator|->
name|getBody
argument_list|()
operator|->
name|traverse
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|outputLineDirective
argument_list|(
name|node
operator|->
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|";}\n"
expr_stmt|;
if|if
condition|(
operator|!
name|firstLoopFragment
condition|)
block|{
name|out
operator|<<
literal|"}\n"
expr_stmt|;
block|}
name|firstLoopFragment
operator|=
literal|false
expr_stmt|;
name|initial
operator|+=
name|MAX_LOOP_ITERATIONS
operator|*
name|increment
expr_stmt|;
name|iterations
operator|-=
name|MAX_LOOP_ITERATIONS
expr_stmt|;
block|}
name|out
operator|<<
literal|"}"
expr_stmt|;
name|mExcessiveLoopIndex
operator|=
name|restoreIndex
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
block|}
return|return
literal|false
return|;
comment|// Not handled as an excessive loop
block|}
DECL|function|outputTriplet
name|void
name|OutputHLSL
operator|::
name|outputTriplet
parameter_list|(
name|Visit
name|visit
parameter_list|,
specifier|const
name|TString
modifier|&
name|preString
parameter_list|,
specifier|const
name|TString
modifier|&
name|inString
parameter_list|,
specifier|const
name|TString
modifier|&
name|postString
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|mBody
decl_stmt|;
if|if
condition|(
name|visit
operator|==
name|PreVisit
condition|)
block|{
name|out
operator|<<
name|preString
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|visit
operator|==
name|InVisit
condition|)
block|{
name|out
operator|<<
name|inString
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|visit
operator|==
name|PostVisit
condition|)
block|{
name|out
operator|<<
name|postString
expr_stmt|;
block|}
block|}
DECL|function|outputLineDirective
name|void
name|OutputHLSL
operator|::
name|outputLineDirective
parameter_list|(
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
operator|(
name|mContext
operator|.
name|compileOptions
operator|&
name|SH_LINE_DIRECTIVES
operator|)
operator|&&
operator|(
name|line
operator|>
literal|0
operator|)
condition|)
block|{
name|mBody
operator|<<
literal|"\n"
expr_stmt|;
name|mBody
operator|<<
literal|"#line "
operator|<<
name|line
expr_stmt|;
if|if
condition|(
name|mContext
operator|.
name|sourcePath
condition|)
block|{
name|mBody
operator|<<
literal|" \""
operator|<<
name|mContext
operator|.
name|sourcePath
operator|<<
literal|"\""
expr_stmt|;
block|}
name|mBody
operator|<<
literal|"\n"
expr_stmt|;
block|}
block|}
DECL|function|argumentString
name|TString
name|OutputHLSL
operator|::
name|argumentString
parameter_list|(
specifier|const
name|TIntermSymbol
modifier|*
name|symbol
parameter_list|)
block|{
name|TQualifier
name|qualifier
init|=
name|symbol
operator|->
name|getQualifier
argument_list|()
decl_stmt|;
specifier|const
name|TType
modifier|&
name|type
init|=
name|symbol
operator|->
name|getType
argument_list|()
decl_stmt|;
name|TString
name|name
init|=
name|symbol
operator|->
name|getSymbol
argument_list|()
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|empty
argument_list|()
condition|)
comment|// HLSL demands named arguments, also for prototypes
block|{
name|name
operator|=
literal|"x"
operator|+
name|str
argument_list|(
name|mUniqueIndex
operator|++
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|decorate
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|qualifierString
argument_list|(
name|qualifier
argument_list|)
operator|+
literal|" "
operator|+
name|typeString
argument_list|(
name|type
argument_list|)
operator|+
literal|" "
operator|+
name|name
operator|+
name|arrayString
argument_list|(
name|type
argument_list|)
return|;
block|}
DECL|function|qualifierString
name|TString
name|OutputHLSL
operator|::
name|qualifierString
parameter_list|(
name|TQualifier
name|qualifier
parameter_list|)
block|{
switch|switch
condition|(
name|qualifier
condition|)
block|{
case|case
name|EvqIn
case|:
return|return
literal|"in"
return|;
case|case
name|EvqOut
case|:
return|return
literal|"out"
return|;
case|case
name|EvqInOut
case|:
return|return
literal|"inout"
return|;
case|case
name|EvqConstReadOnly
case|:
return|return
literal|"const"
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
DECL|function|typeString
name|TString
name|OutputHLSL
operator|::
name|typeString
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtStruct
condition|)
block|{
if|if
condition|(
name|type
operator|.
name|getTypeName
argument_list|()
operator|!=
literal|""
condition|)
block|{
return|return
name|structLookup
argument_list|(
name|type
operator|.
name|getTypeName
argument_list|()
argument_list|)
return|;
block|}
else|else
comment|// Nameless structure, define in place
block|{
specifier|const
name|TTypeList
modifier|&
name|fields
init|=
operator|*
name|type
operator|.
name|getStruct
argument_list|()
decl_stmt|;
name|TString
name|string
init|=
literal|"struct\n"
literal|"{\n"
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|TType
modifier|&
name|field
init|=
operator|*
name|fields
index|[
name|i
index|]
operator|.
name|type
decl_stmt|;
name|string
operator|+=
literal|"    "
operator|+
name|typeString
argument_list|(
name|field
argument_list|)
operator|+
literal|" "
operator|+
name|decorate
argument_list|(
name|field
operator|.
name|getFieldName
argument_list|()
argument_list|)
operator|+
name|arrayString
argument_list|(
name|field
argument_list|)
operator|+
literal|";\n"
expr_stmt|;
block|}
name|string
operator|+=
literal|"} "
expr_stmt|;
return|return
name|string
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|isMatrix
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|type
operator|.
name|getNominalSize
argument_list|()
condition|)
block|{
case|case
literal|2
case|:
return|return
literal|"float2x2"
return|;
case|case
literal|3
case|:
return|return
literal|"float3x3"
return|;
case|case
literal|4
case|:
return|return
literal|"float4x4"
return|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|type
operator|.
name|getBasicType
argument_list|()
condition|)
block|{
case|case
name|EbtFloat
case|:
switch|switch
condition|(
name|type
operator|.
name|getNominalSize
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
return|return
literal|"float"
return|;
case|case
literal|2
case|:
return|return
literal|"float2"
return|;
case|case
literal|3
case|:
return|return
literal|"float3"
return|;
case|case
literal|4
case|:
return|return
literal|"float4"
return|;
block|}
case|case
name|EbtInt
case|:
switch|switch
condition|(
name|type
operator|.
name|getNominalSize
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
return|return
literal|"int"
return|;
case|case
literal|2
case|:
return|return
literal|"int2"
return|;
case|case
literal|3
case|:
return|return
literal|"int3"
return|;
case|case
literal|4
case|:
return|return
literal|"int4"
return|;
block|}
case|case
name|EbtBool
case|:
switch|switch
condition|(
name|type
operator|.
name|getNominalSize
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
return|return
literal|"bool"
return|;
case|case
literal|2
case|:
return|return
literal|"bool2"
return|;
case|case
literal|3
case|:
return|return
literal|"bool3"
return|;
case|case
literal|4
case|:
return|return
literal|"bool4"
return|;
block|}
case|case
name|EbtVoid
case|:
return|return
literal|"void"
return|;
case|case
name|EbtSampler2D
case|:
return|return
literal|"sampler2D"
return|;
case|case
name|EbtSamplerCube
case|:
return|return
literal|"samplerCUBE"
return|;
case|case
name|EbtSamplerExternalOES
case|:
return|return
literal|"sampler2D"
return|;
default|default:
break|break;
block|}
block|}
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
comment|// FIXME
return|return
literal|"<unknown type>"
return|;
block|}
DECL|function|arrayString
name|TString
name|OutputHLSL
operator|::
name|arrayString
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|)
block|{
if|if
condition|(
operator|!
name|type
operator|.
name|isArray
argument_list|()
condition|)
block|{
return|return
literal|""
return|;
block|}
return|return
literal|"["
operator|+
name|str
argument_list|(
name|type
operator|.
name|getArraySize
argument_list|()
argument_list|)
operator|+
literal|"]"
return|;
block|}
DECL|function|initializer
name|TString
name|OutputHLSL
operator|::
name|initializer
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|)
block|{
name|TString
name|string
decl_stmt|;
for|for
control|(
name|int
name|component
init|=
literal|0
init|;
name|component
operator|<
name|type
operator|.
name|getObjectSize
argument_list|()
condition|;
name|component
operator|++
control|)
block|{
name|string
operator|+=
literal|"0"
expr_stmt|;
if|if
condition|(
name|component
operator|<
name|type
operator|.
name|getObjectSize
argument_list|()
operator|-
literal|1
condition|)
block|{
name|string
operator|+=
literal|", "
expr_stmt|;
block|}
block|}
return|return
literal|"{"
operator|+
name|string
operator|+
literal|"}"
return|;
block|}
DECL|function|addConstructor
name|void
name|OutputHLSL
operator|::
name|addConstructor
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|,
specifier|const
name|TString
modifier|&
name|name
parameter_list|,
specifier|const
name|TIntermSequence
modifier|*
name|parameters
parameter_list|)
block|{
if|if
condition|(
name|name
operator|==
literal|""
condition|)
block|{
return|return;
comment|// Nameless structures don't have constructors
block|}
if|if
condition|(
name|type
operator|.
name|getStruct
argument_list|()
operator|&&
name|mStructNames
operator|.
name|find
argument_list|(
name|decorate
argument_list|(
name|name
argument_list|)
argument_list|)
operator|!=
name|mStructNames
operator|.
name|end
argument_list|()
condition|)
block|{
return|return;
comment|// Already added
block|}
name|TType
name|ctorType
init|=
name|type
decl_stmt|;
name|ctorType
operator|.
name|clearArrayness
argument_list|()
expr_stmt|;
name|ctorType
operator|.
name|setPrecision
argument_list|(
name|EbpHigh
argument_list|)
expr_stmt|;
name|ctorType
operator|.
name|setQualifier
argument_list|(
name|EvqTemporary
argument_list|)
expr_stmt|;
name|TString
name|ctorName
init|=
name|type
operator|.
name|getStruct
argument_list|()
condition|?
name|decorate
argument_list|(
name|name
argument_list|)
else|:
name|name
decl_stmt|;
typedef|typedef
name|std
operator|::
name|vector
argument_list|<
name|TType
argument_list|>
name|ParameterArray
typedef|;
name|ParameterArray
name|ctorParameters
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|getStruct
argument_list|()
condition|)
block|{
name|mStructNames
operator|.
name|insert
argument_list|(
name|decorate
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|TString
name|structure
decl_stmt|;
name|structure
operator|+=
literal|"struct "
operator|+
name|decorate
argument_list|(
name|name
argument_list|)
operator|+
literal|"\n"
literal|"{\n"
expr_stmt|;
specifier|const
name|TTypeList
modifier|&
name|fields
init|=
operator|*
name|type
operator|.
name|getStruct
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|TType
modifier|&
name|field
init|=
operator|*
name|fields
index|[
name|i
index|]
operator|.
name|type
decl_stmt|;
name|structure
operator|+=
literal|"    "
operator|+
name|typeString
argument_list|(
name|field
argument_list|)
operator|+
literal|" "
operator|+
name|decorateField
argument_list|(
name|field
operator|.
name|getFieldName
argument_list|()
argument_list|,
name|type
argument_list|)
operator|+
name|arrayString
argument_list|(
name|field
argument_list|)
operator|+
literal|";\n"
expr_stmt|;
block|}
name|structure
operator|+=
literal|"};\n"
expr_stmt|;
if|if
condition|(
name|std
operator|::
name|find
argument_list|(
name|mStructDeclarations
operator|.
name|begin
argument_list|()
argument_list|,
name|mStructDeclarations
operator|.
name|end
argument_list|()
argument_list|,
name|structure
argument_list|)
operator|==
name|mStructDeclarations
operator|.
name|end
argument_list|()
condition|)
block|{
name|mStructDeclarations
operator|.
name|push_back
argument_list|(
name|structure
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ctorParameters
operator|.
name|push_back
argument_list|(
operator|*
name|fields
index|[
name|i
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|parameters
condition|)
block|{
for|for
control|(
name|TIntermSequence
operator|::
name|const_iterator
name|parameter
init|=
name|parameters
operator|->
name|begin
argument_list|()
init|;
name|parameter
operator|!=
name|parameters
operator|->
name|end
argument_list|()
condition|;
name|parameter
operator|++
control|)
block|{
name|ctorParameters
operator|.
name|push_back
argument_list|(
operator|(
operator|*
name|parameter
operator|)
operator|->
name|getAsTyped
argument_list|()
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
name|TString
name|constructor
decl_stmt|;
if|if
condition|(
name|ctorType
operator|.
name|getStruct
argument_list|()
condition|)
block|{
name|constructor
operator|+=
name|ctorName
operator|+
literal|" "
operator|+
name|ctorName
operator|+
literal|"_ctor("
expr_stmt|;
block|}
else|else
comment|// Built-in type
block|{
name|constructor
operator|+=
name|typeString
argument_list|(
name|ctorType
argument_list|)
operator|+
literal|" "
operator|+
name|ctorName
operator|+
literal|"("
expr_stmt|;
block|}
for|for
control|(
name|unsigned
name|int
name|parameter
init|=
literal|0
init|;
name|parameter
operator|<
name|ctorParameters
operator|.
name|size
argument_list|()
condition|;
name|parameter
operator|++
control|)
block|{
specifier|const
name|TType
modifier|&
name|type
init|=
name|ctorParameters
index|[
name|parameter
index|]
decl_stmt|;
name|constructor
operator|+=
name|typeString
argument_list|(
name|type
argument_list|)
operator|+
literal|" x"
operator|+
name|str
argument_list|(
name|parameter
argument_list|)
operator|+
name|arrayString
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|parameter
operator|<
name|ctorParameters
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
name|constructor
operator|+=
literal|", "
expr_stmt|;
block|}
block|}
name|constructor
operator|+=
literal|")\n"
literal|"{\n"
expr_stmt|;
if|if
condition|(
name|ctorType
operator|.
name|getStruct
argument_list|()
condition|)
block|{
name|constructor
operator|+=
literal|"    "
operator|+
name|ctorName
operator|+
literal|" structure = {"
expr_stmt|;
block|}
else|else
block|{
name|constructor
operator|+=
literal|"    return "
operator|+
name|typeString
argument_list|(
name|ctorType
argument_list|)
operator|+
literal|"("
expr_stmt|;
block|}
if|if
condition|(
name|ctorType
operator|.
name|isMatrix
argument_list|()
operator|&&
name|ctorParameters
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|int
name|dim
init|=
name|ctorType
operator|.
name|getNominalSize
argument_list|()
decl_stmt|;
specifier|const
name|TType
modifier|&
name|parameter
init|=
name|ctorParameters
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|parameter
operator|.
name|isScalar
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|row
init|=
literal|0
init|;
name|row
operator|<
name|dim
condition|;
name|row
operator|++
control|)
block|{
for|for
control|(
name|int
name|col
init|=
literal|0
init|;
name|col
operator|<
name|dim
condition|;
name|col
operator|++
control|)
block|{
name|constructor
operator|+=
name|TString
argument_list|(
operator|(
name|row
operator|==
name|col
operator|)
condition|?
literal|"x0"
else|:
literal|"0.0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|row
operator|<
name|dim
operator|-
literal|1
operator|||
name|col
operator|<
name|dim
operator|-
literal|1
condition|)
block|{
name|constructor
operator|+=
literal|", "
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|parameter
operator|.
name|isMatrix
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|row
init|=
literal|0
init|;
name|row
operator|<
name|dim
condition|;
name|row
operator|++
control|)
block|{
for|for
control|(
name|int
name|col
init|=
literal|0
init|;
name|col
operator|<
name|dim
condition|;
name|col
operator|++
control|)
block|{
if|if
condition|(
name|row
operator|<
name|parameter
operator|.
name|getNominalSize
argument_list|()
operator|&&
name|col
operator|<
name|parameter
operator|.
name|getNominalSize
argument_list|()
condition|)
block|{
name|constructor
operator|+=
name|TString
argument_list|(
literal|"x0"
argument_list|)
operator|+
literal|"["
operator|+
name|str
argument_list|(
name|row
argument_list|)
operator|+
literal|"]"
operator|+
literal|"["
operator|+
name|str
argument_list|(
name|col
argument_list|)
operator|+
literal|"]"
expr_stmt|;
block|}
else|else
block|{
name|constructor
operator|+=
name|TString
argument_list|(
operator|(
name|row
operator|==
name|col
operator|)
condition|?
literal|"1.0"
else|:
literal|"0.0"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|row
operator|<
name|dim
operator|-
literal|1
operator|||
name|col
operator|<
name|dim
operator|-
literal|1
condition|)
block|{
name|constructor
operator|+=
literal|", "
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|int
name|remainingComponents
init|=
name|ctorType
operator|.
name|getObjectSize
argument_list|()
decl_stmt|;
name|int
name|parameterIndex
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|remainingComponents
operator|>
literal|0
condition|)
block|{
specifier|const
name|TType
modifier|&
name|parameter
init|=
name|ctorParameters
index|[
name|parameterIndex
index|]
decl_stmt|;
name|bool
name|moreParameters
init|=
name|parameterIndex
operator|<
operator|(
name|int
operator|)
name|ctorParameters
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
name|constructor
operator|+=
literal|"x"
operator|+
name|str
argument_list|(
name|parameterIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|parameter
operator|.
name|isScalar
argument_list|()
condition|)
block|{
name|remainingComponents
operator|-=
name|parameter
operator|.
name|getObjectSize
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parameter
operator|.
name|isVector
argument_list|()
condition|)
block|{
if|if
condition|(
name|remainingComponents
operator|==
name|parameter
operator|.
name|getObjectSize
argument_list|()
operator|||
name|moreParameters
condition|)
block|{
name|remainingComponents
operator|-=
name|parameter
operator|.
name|getObjectSize
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|remainingComponents
operator|<
name|parameter
operator|.
name|getNominalSize
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|remainingComponents
condition|)
block|{
case|case
literal|1
case|:
name|constructor
operator|+=
literal|".x"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|constructor
operator|+=
literal|".xy"
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|constructor
operator|+=
literal|".xyz"
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|constructor
operator|+=
literal|".xyzw"
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
name|remainingComponents
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parameter
operator|.
name|isMatrix
argument_list|()
operator|||
name|parameter
operator|.
name|getStruct
argument_list|()
condition|)
block|{
name|ASSERT
argument_list|(
name|remainingComponents
operator|==
name|parameter
operator|.
name|getObjectSize
argument_list|()
operator|||
name|moreParameters
argument_list|)
expr_stmt|;
name|remainingComponents
operator|-=
name|parameter
operator|.
name|getObjectSize
argument_list|()
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
if|if
condition|(
name|moreParameters
condition|)
block|{
name|parameterIndex
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|remainingComponents
condition|)
block|{
name|constructor
operator|+=
literal|", "
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ctorType
operator|.
name|getStruct
argument_list|()
condition|)
block|{
name|constructor
operator|+=
literal|"};\n"
literal|"    return structure;\n"
literal|"}\n"
expr_stmt|;
block|}
else|else
block|{
name|constructor
operator|+=
literal|");\n"
literal|"}\n"
expr_stmt|;
block|}
name|mConstructors
operator|.
name|insert
argument_list|(
name|constructor
argument_list|)
expr_stmt|;
block|}
DECL|function|writeConstantUnion
specifier|const
name|ConstantUnion
modifier|*
name|OutputHLSL
operator|::
name|writeConstantUnion
parameter_list|(
specifier|const
name|TType
modifier|&
name|type
parameter_list|,
specifier|const
name|ConstantUnion
modifier|*
name|constUnion
parameter_list|)
block|{
name|TInfoSinkBase
modifier|&
name|out
init|=
name|mBody
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtStruct
condition|)
block|{
name|out
operator|<<
name|structLookup
argument_list|(
name|type
operator|.
name|getTypeName
argument_list|()
argument_list|)
operator|+
literal|"_ctor("
expr_stmt|;
specifier|const
name|TTypeList
modifier|*
name|structure
init|=
name|type
operator|.
name|getStruct
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|structure
operator|->
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|TType
modifier|*
name|fieldType
init|=
operator|(
operator|*
name|structure
operator|)
index|[
name|i
index|]
operator|.
name|type
decl_stmt|;
name|constUnion
operator|=
name|writeConstantUnion
argument_list|(
operator|*
name|fieldType
argument_list|,
name|constUnion
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|structure
operator|->
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
name|out
operator|<<
literal|", "
expr_stmt|;
block|}
block|}
name|out
operator|<<
literal|")"
expr_stmt|;
block|}
else|else
block|{
name|int
name|size
init|=
name|type
operator|.
name|getObjectSize
argument_list|()
decl_stmt|;
name|bool
name|writeType
init|=
name|size
operator|>
literal|1
decl_stmt|;
if|if
condition|(
name|writeType
condition|)
block|{
name|out
operator|<<
name|typeString
argument_list|(
name|type
argument_list|)
operator|<<
literal|"("
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
operator|,
name|constUnion
operator|++
control|)
block|{
switch|switch
condition|(
name|constUnion
operator|->
name|getType
argument_list|()
condition|)
block|{
case|case
name|EbtFloat
case|:
name|out
operator|<<
name|constUnion
operator|->
name|getFConst
argument_list|()
expr_stmt|;
break|break;
case|case
name|EbtInt
case|:
name|out
operator|<<
name|constUnion
operator|->
name|getIConst
argument_list|()
expr_stmt|;
break|break;
case|case
name|EbtBool
case|:
name|out
operator|<<
name|constUnion
operator|->
name|getBConst
argument_list|()
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
name|size
operator|-
literal|1
condition|)
block|{
name|out
operator|<<
literal|", "
expr_stmt|;
block|}
block|}
if|if
condition|(
name|writeType
condition|)
block|{
name|out
operator|<<
literal|")"
expr_stmt|;
block|}
block|}
return|return
name|constUnion
return|;
block|}
DECL|function|scopeString
name|TString
name|OutputHLSL
operator|::
name|scopeString
parameter_list|(
name|unsigned
name|int
name|depthLimit
parameter_list|)
block|{
name|TString
name|string
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mScopeBracket
operator|.
name|size
argument_list|()
operator|&&
name|i
operator|<
name|depthLimit
condition|;
name|i
operator|++
control|)
block|{
name|string
operator|+=
literal|"_"
operator|+
name|str
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|string
return|;
block|}
DECL|function|scopedStruct
name|TString
name|OutputHLSL
operator|::
name|scopedStruct
parameter_list|(
specifier|const
name|TString
modifier|&
name|typeName
parameter_list|)
block|{
if|if
condition|(
name|typeName
operator|==
literal|""
condition|)
block|{
return|return
name|typeName
return|;
block|}
return|return
name|typeName
operator|+
name|scopeString
argument_list|(
name|mScopeDepth
argument_list|)
return|;
block|}
DECL|function|structLookup
name|TString
name|OutputHLSL
operator|::
name|structLookup
parameter_list|(
specifier|const
name|TString
modifier|&
name|typeName
parameter_list|)
block|{
for|for
control|(
name|int
name|depth
init|=
name|mScopeDepth
init|;
name|depth
operator|>=
literal|0
condition|;
name|depth
operator|--
control|)
block|{
name|TString
name|scopedName
init|=
name|decorate
argument_list|(
name|typeName
operator|+
name|scopeString
argument_list|(
name|depth
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|StructNames
operator|::
name|iterator
name|structName
init|=
name|mStructNames
operator|.
name|begin
argument_list|()
init|;
name|structName
operator|!=
name|mStructNames
operator|.
name|end
argument_list|()
condition|;
name|structName
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|structName
operator|==
name|scopedName
condition|)
block|{
return|return
name|scopedName
return|;
block|}
block|}
block|}
name|UNREACHABLE
argument_list|()
expr_stmt|;
comment|// Should have found a matching constructor
return|return
name|typeName
return|;
block|}
DECL|function|decorate
name|TString
name|OutputHLSL
operator|::
name|decorate
parameter_list|(
specifier|const
name|TString
modifier|&
name|string
parameter_list|)
block|{
if|if
condition|(
name|string
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|,
literal|"gl_"
argument_list|)
operator|!=
literal|0
operator|&&
name|string
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|,
literal|"dx_"
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
literal|"_"
operator|+
name|string
return|;
block|}
return|return
name|string
return|;
block|}
DECL|function|decorateUniform
name|TString
name|OutputHLSL
operator|::
name|decorateUniform
parameter_list|(
specifier|const
name|TString
modifier|&
name|string
parameter_list|,
specifier|const
name|TType
modifier|&
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|.
name|isArray
argument_list|()
condition|)
block|{
return|return
literal|"ar_"
operator|+
name|string
return|;
comment|// Allows identifying arrays of size 1
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|getBasicType
argument_list|()
operator|==
name|EbtSamplerExternalOES
condition|)
block|{
return|return
literal|"ex_"
operator|+
name|string
return|;
block|}
return|return
name|decorate
argument_list|(
name|string
argument_list|)
return|;
block|}
DECL|function|decorateField
name|TString
name|OutputHLSL
operator|::
name|decorateField
parameter_list|(
specifier|const
name|TString
modifier|&
name|string
parameter_list|,
specifier|const
name|TType
modifier|&
name|structure
parameter_list|)
block|{
if|if
condition|(
name|structure
operator|.
name|getTypeName
argument_list|()
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|,
literal|"gl_"
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
name|decorate
argument_list|(
name|string
argument_list|)
return|;
block|}
return|return
name|string
return|;
block|}
block|}
end_namespace
end_unit
