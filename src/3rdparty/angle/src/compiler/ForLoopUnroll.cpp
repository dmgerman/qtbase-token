begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2013 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|"compiler/ForLoopUnroll.h"
end_include
begin_namespace
namespace|namespace
block|{
DECL|class|IntegerForLoopUnrollMarker
class|class
name|IntegerForLoopUnrollMarker
super|:
specifier|public
name|TIntermTraverser
block|{
public|public:
DECL|function|visitLoop
specifier|virtual
name|bool
name|visitLoop
parameter_list|(
name|Visit
parameter_list|,
name|TIntermLoop
modifier|*
name|node
parameter_list|)
block|{
comment|// This is called after ValidateLimitations pass, so all the ASSERT
comment|// should never fail.
comment|// See ValidateLimitations::validateForLoopInit().
name|ASSERT
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|node
operator|->
name|getType
argument_list|()
operator|==
name|ELoopFor
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|node
operator|->
name|getInit
argument_list|()
argument_list|)
expr_stmt|;
name|TIntermAggregate
modifier|*
name|decl
init|=
name|node
operator|->
name|getInit
argument_list|()
operator|->
name|getAsAggregate
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|decl
operator|&&
name|decl
operator|->
name|getOp
argument_list|()
operator|==
name|EOpDeclaration
argument_list|)
expr_stmt|;
name|TIntermSequence
modifier|&
name|declSeq
init|=
name|decl
operator|->
name|getSequence
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|declSeq
operator|.
name|size
argument_list|()
operator|==
literal|1
argument_list|)
expr_stmt|;
name|TIntermBinary
modifier|*
name|declInit
init|=
name|declSeq
index|[
literal|0
index|]
operator|->
name|getAsBinaryNode
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|declInit
operator|&&
name|declInit
operator|->
name|getOp
argument_list|()
operator|==
name|EOpInitialize
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|declInit
operator|->
name|getLeft
argument_list|()
argument_list|)
expr_stmt|;
name|TIntermSymbol
modifier|*
name|symbol
init|=
name|declInit
operator|->
name|getLeft
argument_list|()
operator|->
name|getAsSymbolNode
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
name|TBasicType
name|type
init|=
name|symbol
operator|->
name|getBasicType
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|type
operator|==
name|EbtInt
operator|||
name|type
operator|==
name|EbtFloat
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|EbtInt
condition|)
name|node
operator|->
name|setUnrollFlag
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
class|;
block|}
end_namespace
begin_comment
comment|// anonymous namepsace
end_comment
begin_function
DECL|function|FillLoopIndexInfo
name|void
name|ForLoopUnroll
operator|::
name|FillLoopIndexInfo
parameter_list|(
name|TIntermLoop
modifier|*
name|node
parameter_list|,
name|TLoopIndexInfo
modifier|&
name|info
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|node
operator|->
name|getType
argument_list|()
operator|==
name|ELoopFor
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|node
operator|->
name|getUnrollFlag
argument_list|()
argument_list|)
expr_stmt|;
name|TIntermNode
modifier|*
name|init
init|=
name|node
operator|->
name|getInit
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|init
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|TIntermAggregate
modifier|*
name|decl
init|=
name|init
operator|->
name|getAsAggregate
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
name|decl
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|decl
operator|->
name|getOp
argument_list|()
operator|==
name|EOpDeclaration
operator|)
argument_list|)
expr_stmt|;
name|TIntermSequence
modifier|&
name|declSeq
init|=
name|decl
operator|->
name|getSequence
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|declSeq
operator|.
name|size
argument_list|()
operator|==
literal|1
argument_list|)
expr_stmt|;
name|TIntermBinary
modifier|*
name|declInit
init|=
name|declSeq
index|[
literal|0
index|]
operator|->
name|getAsBinaryNode
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
name|declInit
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|declInit
operator|->
name|getOp
argument_list|()
operator|==
name|EOpInitialize
operator|)
argument_list|)
expr_stmt|;
name|TIntermSymbol
modifier|*
name|symbol
init|=
name|declInit
operator|->
name|getLeft
argument_list|()
operator|->
name|getAsSymbolNode
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|symbol
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|symbol
operator|->
name|getBasicType
argument_list|()
operator|==
name|EbtInt
argument_list|)
expr_stmt|;
name|info
operator|.
name|id
operator|=
name|symbol
operator|->
name|getId
argument_list|()
expr_stmt|;
name|ASSERT
argument_list|(
name|declInit
operator|->
name|getRight
argument_list|()
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|TIntermConstantUnion
modifier|*
name|initNode
init|=
name|declInit
operator|->
name|getRight
argument_list|()
operator|->
name|getAsConstantUnion
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|initNode
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|info
operator|.
name|initValue
operator|=
name|evaluateIntConstant
argument_list|(
name|initNode
argument_list|)
expr_stmt|;
name|info
operator|.
name|currentValue
operator|=
name|info
operator|.
name|initValue
expr_stmt|;
name|TIntermNode
modifier|*
name|cond
init|=
name|node
operator|->
name|getCondition
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|cond
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|TIntermBinary
modifier|*
name|binOp
init|=
name|cond
operator|->
name|getAsBinaryNode
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|binOp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|binOp
operator|->
name|getRight
argument_list|()
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|binOp
operator|->
name|getRight
argument_list|()
operator|->
name|getAsConstantUnion
argument_list|()
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|info
operator|.
name|incrementValue
operator|=
name|getLoopIncrement
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|info
operator|.
name|stopValue
operator|=
name|evaluateIntConstant
argument_list|(
name|binOp
operator|->
name|getRight
argument_list|()
operator|->
name|getAsConstantUnion
argument_list|()
argument_list|)
expr_stmt|;
name|info
operator|.
name|op
operator|=
name|binOp
operator|->
name|getOp
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|Step
name|void
name|ForLoopUnroll
operator|::
name|Step
parameter_list|()
block|{
name|ASSERT
argument_list|(
name|mLoopIndexStack
operator|.
name|size
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
name|TLoopIndexInfo
modifier|&
name|info
init|=
name|mLoopIndexStack
index|[
name|mLoopIndexStack
operator|.
name|size
argument_list|()
operator|-
literal|1
index|]
decl_stmt|;
name|info
operator|.
name|currentValue
operator|+=
name|info
operator|.
name|incrementValue
expr_stmt|;
block|}
end_function
begin_function
DECL|function|SatisfiesLoopCondition
name|bool
name|ForLoopUnroll
operator|::
name|SatisfiesLoopCondition
parameter_list|()
block|{
name|ASSERT
argument_list|(
name|mLoopIndexStack
operator|.
name|size
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
name|TLoopIndexInfo
modifier|&
name|info
init|=
name|mLoopIndexStack
index|[
name|mLoopIndexStack
operator|.
name|size
argument_list|()
operator|-
literal|1
index|]
decl_stmt|;
comment|// Relational operator is one of:>>=<<= == or !=.
switch|switch
condition|(
name|info
operator|.
name|op
condition|)
block|{
case|case
name|EOpEqual
case|:
return|return
operator|(
name|info
operator|.
name|currentValue
operator|==
name|info
operator|.
name|stopValue
operator|)
return|;
case|case
name|EOpNotEqual
case|:
return|return
operator|(
name|info
operator|.
name|currentValue
operator|!=
name|info
operator|.
name|stopValue
operator|)
return|;
case|case
name|EOpLessThan
case|:
return|return
operator|(
name|info
operator|.
name|currentValue
operator|<
name|info
operator|.
name|stopValue
operator|)
return|;
case|case
name|EOpGreaterThan
case|:
return|return
operator|(
name|info
operator|.
name|currentValue
operator|>
name|info
operator|.
name|stopValue
operator|)
return|;
case|case
name|EOpLessThanEqual
case|:
return|return
operator|(
name|info
operator|.
name|currentValue
operator|<=
name|info
operator|.
name|stopValue
operator|)
return|;
case|case
name|EOpGreaterThanEqual
case|:
return|return
operator|(
name|info
operator|.
name|currentValue
operator|>=
name|info
operator|.
name|stopValue
operator|)
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|NeedsToReplaceSymbolWithValue
name|bool
name|ForLoopUnroll
operator|::
name|NeedsToReplaceSymbolWithValue
parameter_list|(
name|TIntermSymbol
modifier|*
name|symbol
parameter_list|)
block|{
for|for
control|(
name|TVector
argument_list|<
name|TLoopIndexInfo
argument_list|>
operator|::
name|iterator
name|i
init|=
name|mLoopIndexStack
operator|.
name|begin
argument_list|()
init|;
name|i
operator|!=
name|mLoopIndexStack
operator|.
name|end
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|->
name|id
operator|==
name|symbol
operator|->
name|getId
argument_list|()
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|GetLoopIndexValue
name|int
name|ForLoopUnroll
operator|::
name|GetLoopIndexValue
parameter_list|(
name|TIntermSymbol
modifier|*
name|symbol
parameter_list|)
block|{
for|for
control|(
name|TVector
argument_list|<
name|TLoopIndexInfo
argument_list|>
operator|::
name|iterator
name|i
init|=
name|mLoopIndexStack
operator|.
name|begin
argument_list|()
init|;
name|i
operator|!=
name|mLoopIndexStack
operator|.
name|end
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|->
name|id
operator|==
name|symbol
operator|->
name|getId
argument_list|()
condition|)
return|return
name|i
operator|->
name|currentValue
return|;
block|}
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|Push
name|void
name|ForLoopUnroll
operator|::
name|Push
parameter_list|(
name|TLoopIndexInfo
modifier|&
name|info
parameter_list|)
block|{
name|mLoopIndexStack
operator|.
name|push_back
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|Pop
name|void
name|ForLoopUnroll
operator|::
name|Pop
parameter_list|()
block|{
name|mLoopIndexStack
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|// static
end_comment
begin_function
DECL|function|MarkForLoopsWithIntegerIndicesForUnrolling
name|void
name|ForLoopUnroll
operator|::
name|MarkForLoopsWithIntegerIndicesForUnrolling
parameter_list|(
name|TIntermNode
modifier|*
name|root
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|IntegerForLoopUnrollMarker
name|marker
decl_stmt|;
name|root
operator|->
name|traverse
argument_list|(
operator|&
name|marker
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|getLoopIncrement
name|int
name|ForLoopUnroll
operator|::
name|getLoopIncrement
parameter_list|(
name|TIntermLoop
modifier|*
name|node
parameter_list|)
block|{
name|TIntermNode
modifier|*
name|expr
init|=
name|node
operator|->
name|getExpression
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|expr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|// for expression has one of the following forms:
comment|//     loop_index++
comment|//     loop_index--
comment|//     loop_index += constant_expression
comment|//     loop_index -= constant_expression
comment|//     ++loop_index
comment|//     --loop_index
comment|// The last two forms are not specified in the spec, but I am assuming
comment|// its an oversight.
name|TIntermUnary
modifier|*
name|unOp
init|=
name|expr
operator|->
name|getAsUnaryNode
argument_list|()
decl_stmt|;
name|TIntermBinary
modifier|*
name|binOp
init|=
name|unOp
condition|?
name|NULL
else|:
name|expr
operator|->
name|getAsBinaryNode
argument_list|()
decl_stmt|;
name|TOperator
name|op
init|=
name|EOpNull
decl_stmt|;
name|TIntermConstantUnion
modifier|*
name|incrementNode
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|unOp
operator|!=
name|NULL
condition|)
block|{
name|op
operator|=
name|unOp
operator|->
name|getOp
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|binOp
operator|!=
name|NULL
condition|)
block|{
name|op
operator|=
name|binOp
operator|->
name|getOp
argument_list|()
expr_stmt|;
name|ASSERT
argument_list|(
name|binOp
operator|->
name|getRight
argument_list|()
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|incrementNode
operator|=
name|binOp
operator|->
name|getRight
argument_list|()
operator|->
name|getAsConstantUnion
argument_list|()
expr_stmt|;
name|ASSERT
argument_list|(
name|incrementNode
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|int
name|increment
init|=
literal|0
decl_stmt|;
comment|// The operator is one of: ++ -- += -=.
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|EOpPostIncrement
case|:
case|case
name|EOpPreIncrement
case|:
name|ASSERT
argument_list|(
operator|(
name|unOp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|binOp
operator|==
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|increment
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|EOpPostDecrement
case|:
case|case
name|EOpPreDecrement
case|:
name|ASSERT
argument_list|(
operator|(
name|unOp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|binOp
operator|==
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|increment
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|EOpAddAssign
case|:
name|ASSERT
argument_list|(
operator|(
name|unOp
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|binOp
operator|!=
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|increment
operator|=
name|evaluateIntConstant
argument_list|(
name|incrementNode
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOpSubAssign
case|:
name|ASSERT
argument_list|(
operator|(
name|unOp
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|binOp
operator|!=
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|increment
operator|=
operator|-
name|evaluateIntConstant
argument_list|(
name|incrementNode
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
return|return
name|increment
return|;
block|}
end_function
begin_function
DECL|function|evaluateIntConstant
name|int
name|ForLoopUnroll
operator|::
name|evaluateIntConstant
parameter_list|(
name|TIntermConstantUnion
modifier|*
name|node
parameter_list|)
block|{
name|ASSERT
argument_list|(
operator|(
name|node
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|node
operator|->
name|getUnionArrayPointer
argument_list|()
operator|!=
name|NULL
operator|)
argument_list|)
expr_stmt|;
return|return
name|node
operator|->
name|getIConst
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function
end_unit
