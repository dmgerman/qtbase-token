begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2012-2013 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// angletypes.h : Defines a variety of structures and enum types that are used throughout libGLESv2
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|LIBANGLE_ANGLETYPES_H_
end_ifndef
begin_define
DECL|macro|LIBANGLE_ANGLETYPES_H_
define|#
directive|define
name|LIBANGLE_ANGLETYPES_H_
end_define
begin_include
include|#
directive|include
file|"libANGLE/Constants.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/RefCountObject.h"
end_include
begin_include
include|#
directive|include
file|<stdint.h>
end_include
begin_include
include|#
directive|include
file|<float.h>
end_include
begin_decl_stmt
name|namespace
name|gl
block|{
name|class
name|Buffer
decl_stmt|;
name|class
name|State
decl_stmt|;
name|class
name|Program
decl_stmt|;
struct_decl|struct
name|VertexAttribute
struct_decl|;
struct_decl|struct
name|VertexAttribCurrentValueData
struct_decl|;
enum|enum
name|SamplerType
block|{
name|SAMPLER_PIXEL
block|,
name|SAMPLER_VERTEX
block|}
enum|;
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|Color
block|{
name|T
name|red
block|;
name|T
name|green
block|;
name|T
name|blue
block|;
name|T
name|alpha
block|;
name|Color
argument_list|()
operator|:
name|red
argument_list|(
literal|0
argument_list|)
block|,
name|green
argument_list|(
literal|0
argument_list|)
block|,
name|blue
argument_list|(
literal|0
argument_list|)
block|,
name|alpha
argument_list|(
literal|0
argument_list|)
block|{ }
name|Color
argument_list|(
argument|T r
argument_list|,
argument|T g
argument_list|,
argument|T b
argument_list|,
argument|T a
argument_list|)
operator|:
name|red
argument_list|(
name|r
argument_list|)
block|,
name|green
argument_list|(
name|g
argument_list|)
block|,
name|blue
argument_list|(
name|b
argument_list|)
block|,
name|alpha
argument_list|(
argument|a
argument_list|)
block|{ }
block|}
expr_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
name|bool
name|operator
operator|==
operator|(
specifier|const
name|Color
operator|<
name|T
operator|>
operator|&
name|a
operator|,
specifier|const
name|Color
operator|<
name|T
operator|>
operator|&
name|b
operator|)
block|{
return|return
name|a
operator|.
name|red
operator|==
name|b
operator|.
name|red
operator|&&
name|a
operator|.
name|green
operator|==
name|b
operator|.
name|green
operator|&&
name|a
operator|.
name|blue
operator|==
name|b
operator|.
name|blue
operator|&&
name|a
operator|.
name|alpha
operator|==
name|b
operator|.
name|alpha
return|;
block|}
name|template
operator|<
name|typename
name|T
operator|>
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|Color
operator|<
name|T
operator|>
operator|&
name|a
operator|,
specifier|const
name|Color
operator|<
name|T
operator|>
operator|&
name|b
operator|)
block|{
return|return
operator|!
operator|(
name|a
operator|==
name|b
operator|)
return|;
block|}
typedef|typedef
name|Color
operator|<
name|float
operator|>
name|ColorF
expr_stmt|;
typedef|typedef
name|Color
operator|<
name|int
operator|>
name|ColorI
expr_stmt|;
typedef|typedef
name|Color
operator|<
name|unsigned
name|int
operator|>
name|ColorUI
expr_stmt|;
struct|struct
name|Rectangle
block|{
name|int
name|x
decl_stmt|;
name|int
name|y
decl_stmt|;
name|int
name|width
decl_stmt|;
name|int
name|height
decl_stmt|;
name|Rectangle
argument_list|()
operator|:
name|x
argument_list|(
literal|0
argument_list|)
operator|,
name|y
argument_list|(
literal|0
argument_list|)
operator|,
name|width
argument_list|(
literal|0
argument_list|)
operator|,
name|height
argument_list|(
literal|0
argument_list|)
block|{ }
name|Rectangle
argument_list|(
argument|int x_in
argument_list|,
argument|int y_in
argument_list|,
argument|int width_in
argument_list|,
argument|int height_in
argument_list|)
operator|:
name|x
argument_list|(
name|x_in
argument_list|)
operator|,
name|y
argument_list|(
name|y_in
argument_list|)
operator|,
name|width
argument_list|(
name|width_in
argument_list|)
operator|,
name|height
argument_list|(
argument|height_in
argument_list|)
block|{ }
block|}
struct|;
name|bool
name|operator
operator|==
operator|(
specifier|const
name|Rectangle
operator|&
name|a
operator|,
specifier|const
name|Rectangle
operator|&
name|b
operator|)
expr_stmt|;
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|Rectangle
operator|&
name|a
operator|,
specifier|const
name|Rectangle
operator|&
name|b
operator|)
expr_stmt|;
name|bool
name|ClipRectangle
parameter_list|(
specifier|const
name|Rectangle
modifier|&
name|source
parameter_list|,
specifier|const
name|Rectangle
modifier|&
name|clip
parameter_list|,
name|Rectangle
modifier|*
name|intersection
parameter_list|)
function_decl|;
struct|struct
name|Offset
block|{
name|int
name|x
decl_stmt|;
name|int
name|y
decl_stmt|;
name|int
name|z
decl_stmt|;
name|Offset
argument_list|()
operator|:
name|x
argument_list|(
literal|0
argument_list|)
operator|,
name|y
argument_list|(
literal|0
argument_list|)
operator|,
name|z
argument_list|(
literal|0
argument_list|)
block|{ }
name|Offset
argument_list|(
argument|int x_in
argument_list|,
argument|int y_in
argument_list|,
argument|int z_in
argument_list|)
operator|:
name|x
argument_list|(
name|x_in
argument_list|)
operator|,
name|y
argument_list|(
name|y_in
argument_list|)
operator|,
name|z
argument_list|(
argument|z_in
argument_list|)
block|{ }
block|}
struct|;
struct|struct
name|Extents
block|{
name|int
name|width
decl_stmt|;
name|int
name|height
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|Extents
argument_list|()
operator|:
name|width
argument_list|(
literal|0
argument_list|)
operator|,
name|height
argument_list|(
literal|0
argument_list|)
operator|,
name|depth
argument_list|(
literal|0
argument_list|)
block|{ }
name|Extents
argument_list|(
argument|int width_
argument_list|,
argument|int height_
argument_list|,
argument|int depth_
argument_list|)
operator|:
name|width
argument_list|(
name|width_
argument_list|)
operator|,
name|height
argument_list|(
name|height_
argument_list|)
operator|,
name|depth
argument_list|(
argument|depth_
argument_list|)
block|{ }
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
operator|(
name|width
operator|*
name|height
operator|*
name|depth
operator|)
operator|==
literal|0
return|;
block|}
block|}
struct|;
struct|struct
name|Box
block|{
name|int
name|x
decl_stmt|;
name|int
name|y
decl_stmt|;
name|int
name|z
decl_stmt|;
name|int
name|width
decl_stmt|;
name|int
name|height
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|Box
argument_list|()
operator|:
name|x
argument_list|(
literal|0
argument_list|)
operator|,
name|y
argument_list|(
literal|0
argument_list|)
operator|,
name|z
argument_list|(
literal|0
argument_list|)
operator|,
name|width
argument_list|(
literal|0
argument_list|)
operator|,
name|height
argument_list|(
literal|0
argument_list|)
operator|,
name|depth
argument_list|(
literal|0
argument_list|)
block|{ }
name|Box
argument_list|(
argument|int x_in
argument_list|,
argument|int y_in
argument_list|,
argument|int z_in
argument_list|,
argument|int width_in
argument_list|,
argument|int height_in
argument_list|,
argument|int depth_in
argument_list|)
operator|:
name|x
argument_list|(
name|x_in
argument_list|)
operator|,
name|y
argument_list|(
name|y_in
argument_list|)
operator|,
name|z
argument_list|(
name|z_in
argument_list|)
operator|,
name|width
argument_list|(
name|width_in
argument_list|)
operator|,
name|height
argument_list|(
name|height_in
argument_list|)
operator|,
name|depth
argument_list|(
argument|depth_in
argument_list|)
block|{ }
name|Box
argument_list|(
specifier|const
name|Offset
operator|&
name|offset
argument_list|,
specifier|const
name|Extents
operator|&
name|size
argument_list|)
operator|:
name|x
argument_list|(
name|offset
operator|.
name|x
argument_list|)
operator|,
name|y
argument_list|(
name|offset
operator|.
name|y
argument_list|)
operator|,
name|z
argument_list|(
name|offset
operator|.
name|z
argument_list|)
operator|,
name|width
argument_list|(
name|size
operator|.
name|width
argument_list|)
operator|,
name|height
argument_list|(
name|size
operator|.
name|height
argument_list|)
operator|,
name|depth
argument_list|(
argument|size.depth
argument_list|)
block|{ }
name|bool
name|operator
operator|==
operator|(
specifier|const
name|Box
operator|&
name|other
operator|)
specifier|const
expr_stmt|;
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|Box
operator|&
name|other
operator|)
specifier|const
expr_stmt|;
block|}
struct|;
struct|struct
name|RasterizerState
block|{
name|bool
name|cullFace
decl_stmt|;
name|GLenum
name|cullMode
decl_stmt|;
name|GLenum
name|frontFace
decl_stmt|;
name|bool
name|polygonOffsetFill
decl_stmt|;
name|GLfloat
name|polygonOffsetFactor
decl_stmt|;
name|GLfloat
name|polygonOffsetUnits
decl_stmt|;
name|bool
name|pointDrawMode
decl_stmt|;
name|bool
name|multiSample
decl_stmt|;
name|bool
name|rasterizerDiscard
decl_stmt|;
block|}
struct|;
struct|struct
name|BlendState
block|{
name|bool
name|blend
decl_stmt|;
name|GLenum
name|sourceBlendRGB
decl_stmt|;
name|GLenum
name|destBlendRGB
decl_stmt|;
name|GLenum
name|sourceBlendAlpha
decl_stmt|;
name|GLenum
name|destBlendAlpha
decl_stmt|;
name|GLenum
name|blendEquationRGB
decl_stmt|;
name|GLenum
name|blendEquationAlpha
decl_stmt|;
name|bool
name|colorMaskRed
decl_stmt|;
name|bool
name|colorMaskGreen
decl_stmt|;
name|bool
name|colorMaskBlue
decl_stmt|;
name|bool
name|colorMaskAlpha
decl_stmt|;
name|bool
name|sampleAlphaToCoverage
decl_stmt|;
name|bool
name|dither
decl_stmt|;
block|}
struct|;
struct|struct
name|DepthStencilState
block|{
name|bool
name|depthTest
decl_stmt|;
name|GLenum
name|depthFunc
decl_stmt|;
name|bool
name|depthMask
decl_stmt|;
name|bool
name|stencilTest
decl_stmt|;
name|GLenum
name|stencilFunc
decl_stmt|;
name|GLuint
name|stencilMask
decl_stmt|;
name|GLenum
name|stencilFail
decl_stmt|;
name|GLenum
name|stencilPassDepthFail
decl_stmt|;
name|GLenum
name|stencilPassDepthPass
decl_stmt|;
name|GLuint
name|stencilWritemask
decl_stmt|;
name|GLenum
name|stencilBackFunc
decl_stmt|;
name|GLuint
name|stencilBackMask
decl_stmt|;
name|GLenum
name|stencilBackFail
decl_stmt|;
name|GLenum
name|stencilBackPassDepthFail
decl_stmt|;
name|GLenum
name|stencilBackPassDepthPass
decl_stmt|;
name|GLuint
name|stencilBackWritemask
decl_stmt|;
block|}
struct|;
struct|struct
name|SamplerState
block|{
name|SamplerState
argument_list|()
expr_stmt|;
name|GLenum
name|minFilter
decl_stmt|;
name|GLenum
name|magFilter
decl_stmt|;
name|GLenum
name|wrapS
decl_stmt|;
name|GLenum
name|wrapT
decl_stmt|;
name|GLenum
name|wrapR
decl_stmt|;
name|float
name|maxAnisotropy
decl_stmt|;
name|GLint
name|baseLevel
decl_stmt|;
name|GLint
name|maxLevel
decl_stmt|;
name|GLfloat
name|minLod
decl_stmt|;
name|GLfloat
name|maxLod
decl_stmt|;
name|GLenum
name|compareMode
decl_stmt|;
name|GLenum
name|compareFunc
decl_stmt|;
name|GLenum
name|swizzleRed
decl_stmt|;
name|GLenum
name|swizzleGreen
decl_stmt|;
name|GLenum
name|swizzleBlue
decl_stmt|;
name|GLenum
name|swizzleAlpha
decl_stmt|;
name|bool
name|swizzleRequired
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|operator
operator|==
operator|(
specifier|const
name|SamplerState
operator|&
name|other
operator|)
specifier|const
expr_stmt|;
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|SamplerState
operator|&
name|other
operator|)
specifier|const
expr_stmt|;
block|}
struct|;
struct|struct
name|PixelUnpackState
block|{
name|BindingPointer
operator|<
name|Buffer
operator|>
name|pixelBuffer
expr_stmt|;
name|GLint
name|alignment
decl_stmt|;
name|GLint
name|rowLength
decl_stmt|;
name|GLint
name|skipRows
decl_stmt|;
name|GLint
name|skipPixels
decl_stmt|;
name|GLint
name|imageHeight
decl_stmt|;
name|GLint
name|skipImages
decl_stmt|;
name|PixelUnpackState
argument_list|()
operator|:
name|alignment
argument_list|(
literal|4
argument_list|)
operator|,
name|rowLength
argument_list|(
literal|0
argument_list|)
operator|,
name|skipRows
argument_list|(
literal|0
argument_list|)
operator|,
name|skipPixels
argument_list|(
literal|0
argument_list|)
operator|,
name|imageHeight
argument_list|(
literal|0
argument_list|)
operator|,
name|skipImages
argument_list|(
literal|0
argument_list|)
block|{}
name|PixelUnpackState
argument_list|(
argument|GLint alignmentIn
argument_list|,
argument|GLint rowLengthIn
argument_list|)
operator|:
name|alignment
argument_list|(
name|alignmentIn
argument_list|)
operator|,
name|rowLength
argument_list|(
name|rowLengthIn
argument_list|)
operator|,
name|skipRows
argument_list|(
literal|0
argument_list|)
operator|,
name|skipPixels
argument_list|(
literal|0
argument_list|)
operator|,
name|imageHeight
argument_list|(
literal|0
argument_list|)
operator|,
name|skipImages
argument_list|(
literal|0
argument_list|)
block|{}
block|}
struct|;
struct|struct
name|PixelPackState
block|{
name|BindingPointer
operator|<
name|Buffer
operator|>
name|pixelBuffer
expr_stmt|;
name|GLint
name|alignment
decl_stmt|;
name|bool
name|reverseRowOrder
decl_stmt|;
name|GLint
name|rowLength
decl_stmt|;
name|GLint
name|skipRows
decl_stmt|;
name|GLint
name|skipPixels
decl_stmt|;
name|PixelPackState
argument_list|()
operator|:
name|alignment
argument_list|(
literal|4
argument_list|)
operator|,
name|reverseRowOrder
argument_list|(
name|false
argument_list|)
operator|,
name|rowLength
argument_list|(
literal|0
argument_list|)
operator|,
name|skipRows
argument_list|(
literal|0
argument_list|)
operator|,
name|skipPixels
argument_list|(
literal|0
argument_list|)
block|{}
name|explicit
name|PixelPackState
argument_list|(
argument|GLint alignmentIn
argument_list|,
argument|bool reverseRowOrderIn
argument_list|)
operator|:
name|alignment
argument_list|(
name|alignmentIn
argument_list|)
operator|,
name|reverseRowOrder
argument_list|(
name|reverseRowOrderIn
argument_list|)
operator|,
name|rowLength
argument_list|(
literal|0
argument_list|)
operator|,
name|skipRows
argument_list|(
literal|0
argument_list|)
operator|,
name|skipPixels
argument_list|(
literal|0
argument_list|)
block|{}
block|}
struct|;
struct|struct
name|VertexFormat
block|{
name|GLenum
name|mType
decl_stmt|;
name|GLboolean
name|mNormalized
decl_stmt|;
name|GLuint
name|mComponents
decl_stmt|;
name|bool
name|mPureInteger
decl_stmt|;
name|VertexFormat
argument_list|()
expr_stmt|;
name|VertexFormat
argument_list|(
argument|GLenum type
argument_list|,
argument|GLboolean normalized
argument_list|,
argument|GLuint components
argument_list|,
argument|bool pureInteger
argument_list|)
empty_stmt|;
name|explicit
name|VertexFormat
parameter_list|(
specifier|const
name|VertexAttribute
modifier|&
name|attribute
parameter_list|)
function_decl|;
name|VertexFormat
argument_list|(
argument|const VertexAttribute&attribute
argument_list|,
argument|GLenum currentValueType
argument_list|)
empty_stmt|;
specifier|static
name|void
name|GetInputLayout
parameter_list|(
name|VertexFormat
modifier|*
name|inputLayout
parameter_list|,
name|Program
modifier|*
name|program
parameter_list|,
specifier|const
name|State
modifier|&
name|currentValues
parameter_list|)
function_decl|;
name|bool
name|operator
operator|==
operator|(
specifier|const
name|VertexFormat
operator|&
name|other
operator|)
specifier|const
expr_stmt|;
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|VertexFormat
operator|&
name|other
operator|)
specifier|const
expr_stmt|;
name|bool
name|operator
operator|<
operator|(
specifier|const
name|VertexFormat
operator|&
name|other
operator|)
specifier|const
expr_stmt|;
block|}
struct|;
block|}
end_decl_stmt
begin_decl_stmt
name|namespace
name|rx
block|{
enum|enum
name|VendorID
enum|:
name|uint32_t
block|{
name|VENDOR_ID_AMD
init|=
literal|0x1002
block|,
name|VENDOR_ID_INTEL
init|=
literal|0x8086
block|,
name|VENDOR_ID_NVIDIA
init|=
literal|0x10DE
block|, }
enum|;
comment|// Downcast a base implementation object (EG TextureImpl to TextureD3D)
name|template
operator|<
name|typename
name|DestT
operator|,
name|typename
name|SrcT
operator|>
specifier|inline
name|DestT
operator|*
name|GetAs
argument_list|(
argument|SrcT *src
argument_list|)
block|{
name|ASSERT
argument_list|(
name|HAS_DYNAMIC_TYPE
argument_list|(
name|DestT
operator|*
argument_list|,
name|src
argument_list|)
argument_list|)
block|;
return|return
name|static_cast
operator|<
name|DestT
operator|*
operator|>
operator|(
name|src
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|DestT
operator|,
name|typename
name|SrcT
operator|>
specifier|inline
specifier|const
name|DestT
operator|*
name|GetAs
argument_list|(
argument|const SrcT *src
argument_list|)
block|{
name|ASSERT
argument_list|(
name|HAS_DYNAMIC_TYPE
argument_list|(
specifier|const
name|DestT
operator|*
argument_list|,
name|src
argument_list|)
argument_list|)
block|;
return|return
name|static_cast
operator|<
specifier|const
name|DestT
operator|*
operator|>
operator|(
name|src
operator|)
return|;
block|}
comment|// Downcast a GL object to an Impl (EG gl::Texture to rx::TextureD3D)
name|template
operator|<
name|typename
name|DestT
operator|,
name|typename
name|SrcT
operator|>
specifier|inline
name|DestT
operator|*
name|GetImplAs
argument_list|(
argument|SrcT *src
argument_list|)
block|{
return|return
name|GetAs
operator|<
name|DestT
operator|>
operator|(
name|src
operator|->
name|getImplementation
argument_list|()
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|DestT
operator|,
name|typename
name|SrcT
operator|>
specifier|inline
specifier|const
name|DestT
operator|*
name|GetImplAs
argument_list|(
argument|const SrcT *src
argument_list|)
block|{
return|return
name|GetAs
operator|<
specifier|const
name|DestT
operator|>
operator|(
name|src
operator|->
name|getImplementation
argument_list|()
operator|)
return|;
block|}
block|}
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// LIBANGLE_ANGLETYPES_H_
end_comment
end_unit
