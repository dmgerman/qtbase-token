begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2012-2013 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// angletypes.h : Defines a variety of structures and enum types that are used throughout libGLESv2
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|LIBANGLE_ANGLETYPES_H_
end_ifndef
begin_define
DECL|macro|LIBANGLE_ANGLETYPES_H_
define|#
directive|define
name|LIBANGLE_ANGLETYPES_H_
end_define
begin_include
include|#
directive|include
file|"libANGLE/Constants.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/RefCountObject.h"
end_include
begin_include
include|#
directive|include
file|<stdint.h>
end_include
begin_include
include|#
directive|include
file|<bitset>
end_include
begin_decl_stmt
name|namespace
name|gl
block|{
name|class
name|Buffer
decl_stmt|;
name|class
name|State
decl_stmt|;
name|class
name|Program
decl_stmt|;
struct_decl|struct
name|VertexAttribute
struct_decl|;
struct_decl|struct
name|VertexAttribCurrentValueData
struct_decl|;
enum|enum
name|PrimitiveType
block|{
name|PRIMITIVE_POINTS
block|,
name|PRIMITIVE_LINES
block|,
name|PRIMITIVE_LINE_STRIP
block|,
name|PRIMITIVE_LINE_LOOP
block|,
name|PRIMITIVE_TRIANGLES
block|,
name|PRIMITIVE_TRIANGLE_STRIP
block|,
name|PRIMITIVE_TRIANGLE_FAN
block|,
name|PRIMITIVE_TYPE_MAX
block|, }
enum|;
name|PrimitiveType
name|GetPrimitiveType
parameter_list|(
name|GLenum
name|drawMode
parameter_list|)
function_decl|;
enum|enum
name|SamplerType
block|{
name|SAMPLER_PIXEL
block|,
name|SAMPLER_VERTEX
block|}
enum|;
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|Color
block|{
name|T
name|red
block|;
name|T
name|green
block|;
name|T
name|blue
block|;
name|T
name|alpha
block|;
name|Color
argument_list|()
operator|:
name|red
argument_list|(
literal|0
argument_list|)
block|,
name|green
argument_list|(
literal|0
argument_list|)
block|,
name|blue
argument_list|(
literal|0
argument_list|)
block|,
name|alpha
argument_list|(
literal|0
argument_list|)
block|{ }
name|Color
argument_list|(
argument|T r
argument_list|,
argument|T g
argument_list|,
argument|T b
argument_list|,
argument|T a
argument_list|)
operator|:
name|red
argument_list|(
name|r
argument_list|)
block|,
name|green
argument_list|(
name|g
argument_list|)
block|,
name|blue
argument_list|(
name|b
argument_list|)
block|,
name|alpha
argument_list|(
argument|a
argument_list|)
block|{ }
block|}
expr_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
name|bool
name|operator
operator|==
operator|(
specifier|const
name|Color
operator|<
name|T
operator|>
operator|&
name|a
operator|,
specifier|const
name|Color
operator|<
name|T
operator|>
operator|&
name|b
operator|)
expr_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|Color
operator|<
name|T
operator|>
operator|&
name|a
operator|,
specifier|const
name|Color
operator|<
name|T
operator|>
operator|&
name|b
operator|)
expr_stmt|;
typedef|typedef
name|Color
operator|<
name|float
operator|>
name|ColorF
expr_stmt|;
typedef|typedef
name|Color
operator|<
name|int
operator|>
name|ColorI
expr_stmt|;
typedef|typedef
name|Color
operator|<
name|unsigned
name|int
operator|>
name|ColorUI
expr_stmt|;
struct|struct
name|Rectangle
block|{
name|Rectangle
argument_list|()
operator|:
name|x
argument_list|(
literal|0
argument_list|)
operator|,
name|y
argument_list|(
literal|0
argument_list|)
operator|,
name|width
argument_list|(
literal|0
argument_list|)
operator|,
name|height
argument_list|(
literal|0
argument_list|)
block|{}
name|Rectangle
argument_list|(
argument|int x_in
argument_list|,
argument|int y_in
argument_list|,
argument|int width_in
argument_list|,
argument|int height_in
argument_list|)
operator|:
name|x
argument_list|(
name|x_in
argument_list|)
operator|,
name|y
argument_list|(
name|y_in
argument_list|)
operator|,
name|width
argument_list|(
name|width_in
argument_list|)
operator|,
name|height
argument_list|(
argument|height_in
argument_list|)
block|{     }
name|int
name|x0
argument_list|()
specifier|const
block|{
return|return
name|x
return|;
block|}
name|int
name|y0
argument_list|()
specifier|const
block|{
return|return
name|y
return|;
block|}
name|int
name|x1
argument_list|()
specifier|const
block|{
return|return
name|x
operator|+
name|width
return|;
block|}
name|int
name|y1
argument_list|()
specifier|const
block|{
return|return
name|y
operator|+
name|height
return|;
block|}
name|int
name|x
decl_stmt|;
name|int
name|y
decl_stmt|;
name|int
name|width
decl_stmt|;
name|int
name|height
decl_stmt|;
block|}
struct|;
name|bool
name|operator
operator|==
operator|(
specifier|const
name|Rectangle
operator|&
name|a
operator|,
specifier|const
name|Rectangle
operator|&
name|b
operator|)
expr_stmt|;
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|Rectangle
operator|&
name|a
operator|,
specifier|const
name|Rectangle
operator|&
name|b
operator|)
expr_stmt|;
name|bool
name|ClipRectangle
parameter_list|(
specifier|const
name|Rectangle
modifier|&
name|source
parameter_list|,
specifier|const
name|Rectangle
modifier|&
name|clip
parameter_list|,
name|Rectangle
modifier|*
name|intersection
parameter_list|)
function_decl|;
struct|struct
name|Offset
block|{
name|int
name|x
decl_stmt|;
name|int
name|y
decl_stmt|;
name|int
name|z
decl_stmt|;
name|Offset
argument_list|()
operator|:
name|x
argument_list|(
literal|0
argument_list|)
operator|,
name|y
argument_list|(
literal|0
argument_list|)
operator|,
name|z
argument_list|(
literal|0
argument_list|)
block|{ }
name|Offset
argument_list|(
argument|int x_in
argument_list|,
argument|int y_in
argument_list|,
argument|int z_in
argument_list|)
operator|:
name|x
argument_list|(
name|x_in
argument_list|)
operator|,
name|y
argument_list|(
name|y_in
argument_list|)
operator|,
name|z
argument_list|(
argument|z_in
argument_list|)
block|{ }
block|}
struct|;
struct|struct
name|Extents
block|{
name|int
name|width
decl_stmt|;
name|int
name|height
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|Extents
argument_list|()
operator|:
name|width
argument_list|(
literal|0
argument_list|)
operator|,
name|height
argument_list|(
literal|0
argument_list|)
operator|,
name|depth
argument_list|(
literal|0
argument_list|)
block|{ }
name|Extents
argument_list|(
argument|int width_
argument_list|,
argument|int height_
argument_list|,
argument|int depth_
argument_list|)
operator|:
name|width
argument_list|(
name|width_
argument_list|)
operator|,
name|height
argument_list|(
name|height_
argument_list|)
operator|,
name|depth
argument_list|(
argument|depth_
argument_list|)
block|{ }
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
operator|(
name|width
operator|*
name|height
operator|*
name|depth
operator|)
operator|==
literal|0
return|;
block|}
block|}
struct|;
name|bool
name|operator
operator|==
operator|(
specifier|const
name|Extents
operator|&
name|lhs
operator|,
specifier|const
name|Extents
operator|&
name|rhs
operator|)
expr_stmt|;
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|Extents
operator|&
name|lhs
operator|,
specifier|const
name|Extents
operator|&
name|rhs
operator|)
expr_stmt|;
struct|struct
name|Box
block|{
name|int
name|x
decl_stmt|;
name|int
name|y
decl_stmt|;
name|int
name|z
decl_stmt|;
name|int
name|width
decl_stmt|;
name|int
name|height
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|Box
argument_list|()
operator|:
name|x
argument_list|(
literal|0
argument_list|)
operator|,
name|y
argument_list|(
literal|0
argument_list|)
operator|,
name|z
argument_list|(
literal|0
argument_list|)
operator|,
name|width
argument_list|(
literal|0
argument_list|)
operator|,
name|height
argument_list|(
literal|0
argument_list|)
operator|,
name|depth
argument_list|(
literal|0
argument_list|)
block|{ }
name|Box
argument_list|(
argument|int x_in
argument_list|,
argument|int y_in
argument_list|,
argument|int z_in
argument_list|,
argument|int width_in
argument_list|,
argument|int height_in
argument_list|,
argument|int depth_in
argument_list|)
operator|:
name|x
argument_list|(
name|x_in
argument_list|)
operator|,
name|y
argument_list|(
name|y_in
argument_list|)
operator|,
name|z
argument_list|(
name|z_in
argument_list|)
operator|,
name|width
argument_list|(
name|width_in
argument_list|)
operator|,
name|height
argument_list|(
name|height_in
argument_list|)
operator|,
name|depth
argument_list|(
argument|depth_in
argument_list|)
block|{ }
name|Box
argument_list|(
specifier|const
name|Offset
operator|&
name|offset
argument_list|,
specifier|const
name|Extents
operator|&
name|size
argument_list|)
operator|:
name|x
argument_list|(
name|offset
operator|.
name|x
argument_list|)
operator|,
name|y
argument_list|(
name|offset
operator|.
name|y
argument_list|)
operator|,
name|z
argument_list|(
name|offset
operator|.
name|z
argument_list|)
operator|,
name|width
argument_list|(
name|size
operator|.
name|width
argument_list|)
operator|,
name|height
argument_list|(
name|size
operator|.
name|height
argument_list|)
operator|,
name|depth
argument_list|(
argument|size.depth
argument_list|)
block|{ }
name|bool
name|operator
operator|==
operator|(
specifier|const
name|Box
operator|&
name|other
operator|)
specifier|const
expr_stmt|;
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|Box
operator|&
name|other
operator|)
specifier|const
expr_stmt|;
block|}
struct|;
struct|struct
name|RasterizerState
block|{
name|bool
name|cullFace
decl_stmt|;
name|GLenum
name|cullMode
decl_stmt|;
name|GLenum
name|frontFace
decl_stmt|;
name|bool
name|polygonOffsetFill
decl_stmt|;
name|GLfloat
name|polygonOffsetFactor
decl_stmt|;
name|GLfloat
name|polygonOffsetUnits
decl_stmt|;
name|bool
name|pointDrawMode
decl_stmt|;
name|bool
name|multiSample
decl_stmt|;
name|bool
name|rasterizerDiscard
decl_stmt|;
block|}
struct|;
struct|struct
name|BlendState
block|{
name|bool
name|blend
decl_stmt|;
name|GLenum
name|sourceBlendRGB
decl_stmt|;
name|GLenum
name|destBlendRGB
decl_stmt|;
name|GLenum
name|sourceBlendAlpha
decl_stmt|;
name|GLenum
name|destBlendAlpha
decl_stmt|;
name|GLenum
name|blendEquationRGB
decl_stmt|;
name|GLenum
name|blendEquationAlpha
decl_stmt|;
name|bool
name|colorMaskRed
decl_stmt|;
name|bool
name|colorMaskGreen
decl_stmt|;
name|bool
name|colorMaskBlue
decl_stmt|;
name|bool
name|colorMaskAlpha
decl_stmt|;
name|bool
name|sampleAlphaToCoverage
decl_stmt|;
name|bool
name|dither
decl_stmt|;
block|}
struct|;
struct|struct
name|DepthStencilState
block|{
name|bool
name|depthTest
decl_stmt|;
name|GLenum
name|depthFunc
decl_stmt|;
name|bool
name|depthMask
decl_stmt|;
name|bool
name|stencilTest
decl_stmt|;
name|GLenum
name|stencilFunc
decl_stmt|;
name|GLuint
name|stencilMask
decl_stmt|;
name|GLenum
name|stencilFail
decl_stmt|;
name|GLenum
name|stencilPassDepthFail
decl_stmt|;
name|GLenum
name|stencilPassDepthPass
decl_stmt|;
name|GLuint
name|stencilWritemask
decl_stmt|;
name|GLenum
name|stencilBackFunc
decl_stmt|;
name|GLuint
name|stencilBackMask
decl_stmt|;
name|GLenum
name|stencilBackFail
decl_stmt|;
name|GLenum
name|stencilBackPassDepthFail
decl_stmt|;
name|GLenum
name|stencilBackPassDepthPass
decl_stmt|;
name|GLuint
name|stencilBackWritemask
decl_stmt|;
block|}
struct|;
comment|// State from Table 6.10 (state per sampler object)
struct|struct
name|SamplerState
block|{
name|SamplerState
argument_list|()
expr_stmt|;
name|GLenum
name|minFilter
decl_stmt|;
name|GLenum
name|magFilter
decl_stmt|;
name|GLenum
name|wrapS
decl_stmt|;
name|GLenum
name|wrapT
decl_stmt|;
name|GLenum
name|wrapR
decl_stmt|;
comment|// From EXT_texture_filter_anisotropic
name|float
name|maxAnisotropy
decl_stmt|;
name|GLfloat
name|minLod
decl_stmt|;
name|GLfloat
name|maxLod
decl_stmt|;
name|GLenum
name|compareMode
decl_stmt|;
name|GLenum
name|compareFunc
decl_stmt|;
block|}
struct|;
name|bool
name|operator
operator|==
operator|(
specifier|const
name|SamplerState
operator|&
name|a
operator|,
specifier|const
name|SamplerState
operator|&
name|b
operator|)
expr_stmt|;
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|SamplerState
operator|&
name|a
operator|,
specifier|const
name|SamplerState
operator|&
name|b
operator|)
expr_stmt|;
comment|// State from Table 6.9 (state per texture object) in the OpenGL ES 3.0.2 spec.
struct|struct
name|TextureState
block|{
name|TextureState
argument_list|()
expr_stmt|;
name|GLenum
name|swizzleRed
decl_stmt|;
name|GLenum
name|swizzleGreen
decl_stmt|;
name|GLenum
name|swizzleBlue
decl_stmt|;
name|GLenum
name|swizzleAlpha
decl_stmt|;
name|SamplerState
name|samplerState
decl_stmt|;
name|GLuint
name|baseLevel
decl_stmt|;
name|GLuint
name|maxLevel
decl_stmt|;
name|bool
name|immutableFormat
decl_stmt|;
name|GLuint
name|immutableLevels
decl_stmt|;
comment|// From GL_ANGLE_texture_usage
name|GLenum
name|usage
decl_stmt|;
name|bool
name|swizzleRequired
argument_list|()
specifier|const
expr_stmt|;
block|}
struct|;
name|bool
name|operator
operator|==
operator|(
specifier|const
name|TextureState
operator|&
name|a
operator|,
specifier|const
name|TextureState
operator|&
name|b
operator|)
expr_stmt|;
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|TextureState
operator|&
name|a
operator|,
specifier|const
name|TextureState
operator|&
name|b
operator|)
expr_stmt|;
struct|struct
name|PixelUnpackState
block|{
name|BindingPointer
operator|<
name|Buffer
operator|>
name|pixelBuffer
expr_stmt|;
name|GLint
name|alignment
decl_stmt|;
name|GLint
name|rowLength
decl_stmt|;
name|GLint
name|skipRows
decl_stmt|;
name|GLint
name|skipPixels
decl_stmt|;
name|GLint
name|imageHeight
decl_stmt|;
name|GLint
name|skipImages
decl_stmt|;
name|PixelUnpackState
argument_list|()
operator|:
name|alignment
argument_list|(
literal|4
argument_list|)
operator|,
name|rowLength
argument_list|(
literal|0
argument_list|)
operator|,
name|skipRows
argument_list|(
literal|0
argument_list|)
operator|,
name|skipPixels
argument_list|(
literal|0
argument_list|)
operator|,
name|imageHeight
argument_list|(
literal|0
argument_list|)
operator|,
name|skipImages
argument_list|(
literal|0
argument_list|)
block|{}
name|PixelUnpackState
argument_list|(
argument|GLint alignmentIn
argument_list|,
argument|GLint rowLengthIn
argument_list|)
operator|:
name|alignment
argument_list|(
name|alignmentIn
argument_list|)
operator|,
name|rowLength
argument_list|(
name|rowLengthIn
argument_list|)
operator|,
name|skipRows
argument_list|(
literal|0
argument_list|)
operator|,
name|skipPixels
argument_list|(
literal|0
argument_list|)
operator|,
name|imageHeight
argument_list|(
literal|0
argument_list|)
operator|,
name|skipImages
argument_list|(
literal|0
argument_list|)
block|{}
block|}
struct|;
struct|struct
name|PixelPackState
block|{
name|BindingPointer
operator|<
name|Buffer
operator|>
name|pixelBuffer
expr_stmt|;
name|GLint
name|alignment
decl_stmt|;
name|bool
name|reverseRowOrder
decl_stmt|;
name|GLint
name|rowLength
decl_stmt|;
name|GLint
name|skipRows
decl_stmt|;
name|GLint
name|skipPixels
decl_stmt|;
name|PixelPackState
argument_list|()
operator|:
name|alignment
argument_list|(
literal|4
argument_list|)
operator|,
name|reverseRowOrder
argument_list|(
name|false
argument_list|)
operator|,
name|rowLength
argument_list|(
literal|0
argument_list|)
operator|,
name|skipRows
argument_list|(
literal|0
argument_list|)
operator|,
name|skipPixels
argument_list|(
literal|0
argument_list|)
block|{}
name|explicit
name|PixelPackState
argument_list|(
argument|GLint alignmentIn
argument_list|,
argument|bool reverseRowOrderIn
argument_list|)
operator|:
name|alignment
argument_list|(
name|alignmentIn
argument_list|)
operator|,
name|reverseRowOrder
argument_list|(
name|reverseRowOrderIn
argument_list|)
operator|,
name|rowLength
argument_list|(
literal|0
argument_list|)
operator|,
name|skipRows
argument_list|(
literal|0
argument_list|)
operator|,
name|skipPixels
argument_list|(
literal|0
argument_list|)
block|{}
block|}
struct|;
comment|// Used in Program and VertexArray.
typedef|typedef
name|std
operator|::
name|bitset
operator|<
name|MAX_VERTEX_ATTRIBS
operator|>
name|AttributesMask
expr_stmt|;
comment|// Use in Program
typedef|typedef
name|std
operator|::
name|bitset
operator|<
name|IMPLEMENTATION_MAX_COMBINED_SHADER_UNIFORM_BUFFERS
operator|>
name|UniformBlockBindingMask
expr_stmt|;
block|}
end_decl_stmt
begin_decl_stmt
name|namespace
name|rx
block|{
enum|enum
name|VendorID
enum|:
name|uint32_t
block|{
name|VENDOR_ID_UNKNOWN
init|=
literal|0x0
block|,
name|VENDOR_ID_AMD
init|=
literal|0x1002
block|,
name|VENDOR_ID_INTEL
init|=
literal|0x8086
block|,
name|VENDOR_ID_NVIDIA
init|=
literal|0x10DE
block|, }
enum|;
comment|// A macro that determines whether an object has a given runtime type.
if|#
directive|if
name|defined
argument_list|(
name|__clang__
argument_list|)
if|#
directive|if
name|__has_feature
argument_list|(
name|cxx_rtti
argument_list|)
DECL|macro|ANGLE_HAS_DYNAMIC_CAST
define|#
directive|define
name|ANGLE_HAS_DYNAMIC_CAST
value|1
endif|#
directive|endif
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|NDEBUG
argument_list|)
operator|&&
operator|(
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
name|defined
argument_list|(
name|_CPPRTTI
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|||
name|__GNUC__
operator|<
literal|4
operator|||
operator|(
name|__GNUC__
operator|==
literal|4
operator|&&
name|__GNUC_MINOR__
operator|<
literal|3
operator|)
operator|||
name|defined
argument_list|(
name|__GXX_RTTI
argument_list|)
operator|)
define|#
directive|define
name|ANGLE_HAS_DYNAMIC_CAST
value|1
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ANGLE_HAS_DYNAMIC_CAST
DECL|macro|ANGLE_HAS_DYNAMIC_TYPE
define|#
directive|define
name|ANGLE_HAS_DYNAMIC_TYPE
parameter_list|(
name|type
parameter_list|,
name|obj
parameter_list|)
value|(dynamic_cast<type>(obj) != nullptr)
DECL|macro|ANGLE_HAS_DYNAMIC_CAST
undef|#
directive|undef
name|ANGLE_HAS_DYNAMIC_CAST
else|#
directive|else
define|#
directive|define
name|ANGLE_HAS_DYNAMIC_TYPE
parameter_list|(
name|type
parameter_list|,
name|obj
parameter_list|)
value|(obj != nullptr)
endif|#
directive|endif
comment|// Downcast a base implementation object (EG TextureImpl to TextureD3D)
name|template
operator|<
name|typename
name|DestT
operator|,
name|typename
name|SrcT
operator|>
specifier|inline
name|DestT
operator|*
name|GetAs
argument_list|(
argument|SrcT *src
argument_list|)
block|{
name|ASSERT
argument_list|(
name|ANGLE_HAS_DYNAMIC_TYPE
argument_list|(
name|DestT
operator|*
argument_list|,
name|src
argument_list|)
argument_list|)
block|;
return|return
name|static_cast
operator|<
name|DestT
operator|*
operator|>
operator|(
name|src
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|DestT
operator|,
name|typename
name|SrcT
operator|>
specifier|inline
specifier|const
name|DestT
operator|*
name|GetAs
argument_list|(
argument|const SrcT *src
argument_list|)
block|{
name|ASSERT
argument_list|(
name|ANGLE_HAS_DYNAMIC_TYPE
argument_list|(
specifier|const
name|DestT
operator|*
argument_list|,
name|src
argument_list|)
argument_list|)
block|;
return|return
name|static_cast
operator|<
specifier|const
name|DestT
operator|*
operator|>
operator|(
name|src
operator|)
return|;
block|}
DECL|macro|ANGLE_HAS_DYNAMIC_TYPE
undef|#
directive|undef
name|ANGLE_HAS_DYNAMIC_TYPE
comment|// Downcast a GL object to an Impl (EG gl::Texture to rx::TextureD3D)
name|template
operator|<
name|typename
name|DestT
operator|,
name|typename
name|SrcT
operator|>
specifier|inline
name|DestT
operator|*
name|GetImplAs
argument_list|(
argument|SrcT *src
argument_list|)
block|{
return|return
name|GetAs
operator|<
name|DestT
operator|>
operator|(
name|src
operator|->
name|getImplementation
argument_list|()
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|DestT
operator|,
name|typename
name|SrcT
operator|>
specifier|inline
specifier|const
name|DestT
operator|*
name|GetImplAs
argument_list|(
argument|const SrcT *src
argument_list|)
block|{
return|return
name|GetAs
operator|<
specifier|const
name|DestT
operator|>
operator|(
name|src
operator|->
name|getImplementation
argument_list|()
operator|)
return|;
block|}
block|}
end_decl_stmt
begin_include
include|#
directive|include
file|"angletypes.inl"
end_include
begin_decl_stmt
name|namespace
name|angle
block|{
comment|// Zero-based for better array indexing
enum|enum
name|FramebufferBinding
block|{
name|FramebufferBindingRead
init|=
literal|0
block|,
name|FramebufferBindingDraw
block|,
name|FramebufferBindingSingletonMax
block|,
name|FramebufferBindingBoth
init|=
name|FramebufferBindingSingletonMax
block|,
name|FramebufferBindingMax
block|,
name|FramebufferBindingUnknown
init|=
name|FramebufferBindingMax
block|, }
enum|;
specifier|inline
name|FramebufferBinding
name|EnumToFramebufferBinding
parameter_list|(
name|GLenum
name|enumValue
parameter_list|)
block|{
switch|switch
condition|(
name|enumValue
condition|)
block|{
case|case
name|GL_READ_FRAMEBUFFER
case|:
return|return
name|FramebufferBindingRead
return|;
case|case
name|GL_DRAW_FRAMEBUFFER
case|:
return|return
name|FramebufferBindingDraw
return|;
case|case
name|GL_FRAMEBUFFER
case|:
return|return
name|FramebufferBindingBoth
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|FramebufferBindingUnknown
return|;
block|}
block|}
specifier|inline
name|GLenum
name|FramebufferBindingToEnum
parameter_list|(
name|FramebufferBinding
name|binding
parameter_list|)
block|{
switch|switch
condition|(
name|binding
condition|)
block|{
case|case
name|FramebufferBindingRead
case|:
return|return
name|GL_READ_FRAMEBUFFER
return|;
case|case
name|FramebufferBindingDraw
case|:
return|return
name|GL_DRAW_FRAMEBUFFER
return|;
case|case
name|FramebufferBindingBoth
case|:
return|return
name|GL_FRAMEBUFFER
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|GL_NONE
return|;
block|}
block|}
block|}
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// LIBANGLE_ANGLETYPES_H_
end_comment
end_unit
