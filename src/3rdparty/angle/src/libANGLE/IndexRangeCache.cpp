begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2013 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// IndexRangeCache.cpp: Defines the gl::IndexRangeCache class which stores information about
end_comment
begin_comment
comment|// ranges of indices.
end_comment
begin_include
include|#
directive|include
file|"libANGLE/IndexRangeCache.h"
end_include
begin_include
include|#
directive|include
file|"common/debug.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/formatutils.h"
end_include
begin_namespace
DECL|namespace|gl
namespace|namespace
name|gl
block|{
DECL|function|addRange
name|void
name|IndexRangeCache
operator|::
name|addRange
parameter_list|(
name|GLenum
name|type
parameter_list|,
name|size_t
name|offset
parameter_list|,
name|size_t
name|count
parameter_list|,
name|bool
name|primitiveRestartEnabled
parameter_list|,
specifier|const
name|IndexRange
modifier|&
name|range
parameter_list|)
block|{
name|mIndexRangeCache
index|[
name|IndexRangeKey
argument_list|(
name|type
argument_list|,
name|offset
argument_list|,
name|count
argument_list|,
name|primitiveRestartEnabled
argument_list|)
index|]
operator|=
name|range
expr_stmt|;
block|}
DECL|function|findRange
name|bool
name|IndexRangeCache
operator|::
name|findRange
parameter_list|(
name|GLenum
name|type
parameter_list|,
name|size_t
name|offset
parameter_list|,
name|size_t
name|count
parameter_list|,
name|bool
name|primitiveRestartEnabled
parameter_list|,
name|IndexRange
modifier|*
name|outRange
parameter_list|)
specifier|const
block|{
name|auto
name|i
init|=
name|mIndexRangeCache
operator|.
name|find
argument_list|(
name|IndexRangeKey
argument_list|(
name|type
argument_list|,
name|offset
argument_list|,
name|count
argument_list|,
name|primitiveRestartEnabled
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|mIndexRangeCache
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|outRange
condition|)
block|{
operator|*
name|outRange
operator|=
name|i
operator|->
name|second
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
else|else
block|{
if|if
condition|(
name|outRange
condition|)
block|{
operator|*
name|outRange
operator|=
name|IndexRange
argument_list|()
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
block|}
DECL|function|invalidateRange
name|void
name|IndexRangeCache
operator|::
name|invalidateRange
parameter_list|(
name|size_t
name|offset
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|invalidateStart
init|=
name|offset
decl_stmt|;
name|size_t
name|invalidateEnd
init|=
name|offset
operator|+
name|size
decl_stmt|;
name|auto
name|i
init|=
name|mIndexRangeCache
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|mIndexRangeCache
operator|.
name|end
argument_list|()
condition|)
block|{
name|size_t
name|rangeStart
init|=
name|i
operator|->
name|first
operator|.
name|offset
decl_stmt|;
name|size_t
name|rangeEnd
init|=
name|i
operator|->
name|first
operator|.
name|offset
operator|+
operator|(
name|GetTypeInfo
argument_list|(
name|i
operator|->
name|first
operator|.
name|type
argument_list|)
operator|.
name|bytes
operator|*
name|i
operator|->
name|first
operator|.
name|count
operator|)
decl_stmt|;
if|if
condition|(
name|invalidateEnd
argument_list|<
name|rangeStart
operator|||
name|invalidateStart
argument_list|>
name|rangeEnd
condition|)
block|{
operator|++
name|i
expr_stmt|;
block|}
else|else
block|{
name|mIndexRangeCache
operator|.
name|erase
argument_list|(
name|i
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|clear
name|void
name|IndexRangeCache
operator|::
name|clear
parameter_list|()
block|{
name|mIndexRangeCache
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|function|IndexRangeKey
name|IndexRangeCache
operator|::
name|IndexRangeKey
operator|::
name|IndexRangeKey
parameter_list|()
member_init_list|:
name|IndexRangeCache
operator|::
name|IndexRangeKey
argument_list|(
name|GL_NONE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
block|{ }
DECL|function|IndexRangeKey
name|IndexRangeCache
operator|::
name|IndexRangeKey
operator|::
name|IndexRangeKey
parameter_list|(
name|GLenum
name|type_
parameter_list|,
name|size_t
name|offset_
parameter_list|,
name|size_t
name|count_
parameter_list|,
name|bool
name|primitiveRestartEnabled_
parameter_list|)
member_init_list|:
name|type
argument_list|(
name|type_
argument_list|)
member_init_list|,
name|offset
argument_list|(
name|offset_
argument_list|)
member_init_list|,
name|count
argument_list|(
name|count_
argument_list|)
member_init_list|,
name|primitiveRestartEnabled
argument_list|(
name|primitiveRestartEnabled_
argument_list|)
block|{ }
DECL|function|operator <
name|bool
name|IndexRangeCache
operator|::
name|IndexRangeKey
operator|::
name|operator
name|<
parameter_list|(
specifier|const
name|IndexRangeKey
modifier|&
name|rhs
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|type
operator|!=
name|rhs
operator|.
name|type
condition|)
block|{
return|return
name|type
operator|<
name|rhs
operator|.
name|type
return|;
block|}
if|if
condition|(
name|offset
operator|!=
name|rhs
operator|.
name|offset
condition|)
block|{
return|return
name|offset
operator|<
name|rhs
operator|.
name|offset
return|;
block|}
if|if
condition|(
name|count
operator|!=
name|rhs
operator|.
name|count
condition|)
block|{
return|return
name|count
operator|<
name|rhs
operator|.
name|count
return|;
block|}
if|if
condition|(
name|primitiveRestartEnabled
operator|!=
name|rhs
operator|.
name|primitiveRestartEnabled
condition|)
block|{
return|return
name|primitiveRestartEnabled
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
end_namespace
end_unit
