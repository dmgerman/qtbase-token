begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Program.cpp: Implements the gl::Program class. Implements GL program objects
end_comment
begin_comment
comment|// and related functionality. [OpenGL ES 2.0.24] section 2.10.3 page 28.
end_comment
begin_include
include|#
directive|include
file|"libANGLE/Program.h"
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_include
include|#
directive|include
file|"common/debug.h"
end_include
begin_include
include|#
directive|include
file|"common/platform.h"
end_include
begin_include
include|#
directive|include
file|"common/utilities.h"
end_include
begin_include
include|#
directive|include
file|"common/version.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/blocklayout.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Data.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/ResourceManager.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/features.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/Renderer.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/ProgramImpl.h"
end_include
begin_namespace
DECL|namespace|gl
namespace|namespace
name|gl
block|{
DECL|member|g_fakepath
specifier|const
name|char
modifier|*
specifier|const
name|g_fakepath
init|=
literal|"C:\\fakepath"
decl_stmt|;
namespace|namespace
block|{
DECL|function|ParseAndStripArrayIndex
name|unsigned
name|int
name|ParseAndStripArrayIndex
parameter_list|(
name|std
operator|::
name|string
modifier|*
name|name
parameter_list|)
block|{
name|unsigned
name|int
name|subscript
init|=
name|GL_INVALID_INDEX
decl_stmt|;
comment|// Strip any trailing array operator and retrieve the subscript
name|size_t
name|open
init|=
name|name
operator|->
name|find_last_of
argument_list|(
literal|'['
argument_list|)
decl_stmt|;
name|size_t
name|close
init|=
name|name
operator|->
name|find_last_of
argument_list|(
literal|']'
argument_list|)
decl_stmt|;
if|if
condition|(
name|open
operator|!=
name|std
operator|::
name|string
operator|::
name|npos
operator|&&
name|close
operator|==
name|name
operator|->
name|length
argument_list|()
operator|-
literal|1
condition|)
block|{
name|subscript
operator|=
name|atoi
argument_list|(
name|name
operator|->
name|substr
argument_list|(
name|open
operator|+
literal|1
argument_list|)
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|name
operator|->
name|erase
argument_list|(
name|open
argument_list|)
expr_stmt|;
block|}
return|return
name|subscript
return|;
block|}
block|}
DECL|function|AttributeBindings
name|AttributeBindings
operator|::
name|AttributeBindings
parameter_list|()
block|{ }
DECL|function|~AttributeBindings
name|AttributeBindings
operator|::
name|~
name|AttributeBindings
parameter_list|()
block|{ }
DECL|function|InfoLog
name|InfoLog
operator|::
name|InfoLog
parameter_list|()
member_init_list|:
name|mInfoLog
argument_list|(
name|NULL
argument_list|)
block|{ }
DECL|function|~InfoLog
name|InfoLog
operator|::
name|~
name|InfoLog
parameter_list|()
block|{
operator|delete
index|[]
name|mInfoLog
expr_stmt|;
block|}
DECL|function|getLength
name|int
name|InfoLog
operator|::
name|getLength
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|mInfoLog
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|strlen
argument_list|(
name|mInfoLog
argument_list|)
operator|+
literal|1
return|;
block|}
block|}
DECL|function|getLog
name|void
name|InfoLog
operator|::
name|getLog
parameter_list|(
name|GLsizei
name|bufSize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|,
name|char
modifier|*
name|infoLog
parameter_list|)
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bufSize
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|mInfoLog
condition|)
block|{
name|index
operator|=
name|std
operator|::
name|min
argument_list|(
name|bufSize
operator|-
literal|1
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|mInfoLog
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|infoLog
argument_list|,
name|mInfoLog
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
name|infoLog
index|[
name|index
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
name|index
expr_stmt|;
block|}
block|}
comment|// append a santized message to the program info log.
comment|// The D3D compiler includes a fake file path in some of the warning or error
comment|// messages, so lets remove all occurrences of this fake file path from the log.
DECL|function|appendSanitized
name|void
name|InfoLog
operator|::
name|appendSanitized
parameter_list|(
specifier|const
name|char
modifier|*
name|message
parameter_list|)
block|{
name|std
operator|::
name|string
name|msg
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|size_t
name|found
decl_stmt|;
do|do
block|{
name|found
operator|=
name|msg
operator|.
name|find
argument_list|(
name|g_fakepath
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|!=
name|std
operator|::
name|string
operator|::
name|npos
condition|)
block|{
name|msg
operator|.
name|erase
argument_list|(
name|found
argument_list|,
name|strlen
argument_list|(
name|g_fakepath
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|found
operator|!=
name|std
operator|::
name|string
operator|::
name|npos
condition|)
do|;
name|append
argument_list|(
literal|"%s"
argument_list|,
name|msg
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|function|append
name|void
name|InfoLog
operator|::
name|append
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
if|if
condition|(
operator|!
name|format
condition|)
block|{
return|return;
block|}
name|va_list
name|vararg
decl_stmt|;
name|va_start
argument_list|(
name|vararg
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|size_t
name|infoLength
init|=
name|vsnprintf
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|format
argument_list|,
name|vararg
argument_list|)
decl_stmt|;
name|va_end
argument_list|(
name|vararg
argument_list|)
expr_stmt|;
name|char
modifier|*
name|logPointer
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|mInfoLog
condition|)
block|{
name|mInfoLog
operator|=
operator|new
name|char
index|[
name|infoLength
operator|+
literal|2
index|]
expr_stmt|;
name|logPointer
operator|=
name|mInfoLog
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|currentlogLength
init|=
name|strlen
argument_list|(
name|mInfoLog
argument_list|)
decl_stmt|;
name|char
modifier|*
name|newLog
init|=
operator|new
name|char
index|[
name|currentlogLength
operator|+
name|infoLength
operator|+
literal|2
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|newLog
argument_list|,
name|mInfoLog
argument_list|)
expr_stmt|;
operator|delete
index|[]
name|mInfoLog
expr_stmt|;
name|mInfoLog
operator|=
name|newLog
expr_stmt|;
name|logPointer
operator|=
name|mInfoLog
operator|+
name|currentlogLength
expr_stmt|;
block|}
name|va_start
argument_list|(
name|vararg
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|logPointer
argument_list|,
name|infoLength
argument_list|,
name|format
argument_list|,
name|vararg
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vararg
argument_list|)
expr_stmt|;
name|logPointer
index|[
name|infoLength
index|]
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|logPointer
operator|+
name|infoLength
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
DECL|function|reset
name|void
name|InfoLog
operator|::
name|reset
parameter_list|()
block|{
if|if
condition|(
name|mInfoLog
condition|)
block|{
operator|delete
index|[]
name|mInfoLog
expr_stmt|;
name|mInfoLog
operator|=
name|NULL
expr_stmt|;
block|}
block|}
DECL|function|VariableLocation
name|VariableLocation
operator|::
name|VariableLocation
parameter_list|()
member_init_list|:
name|name
argument_list|()
member_init_list|,
name|element
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|index
argument_list|(
literal|0
argument_list|)
block|{ }
DECL|function|VariableLocation
name|VariableLocation
operator|::
name|VariableLocation
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|name
parameter_list|,
name|unsigned
name|int
name|element
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|)
member_init_list|:
name|name
argument_list|(
name|name
argument_list|)
member_init_list|,
name|element
argument_list|(
name|element
argument_list|)
member_init_list|,
name|index
argument_list|(
name|index
argument_list|)
block|{ }
DECL|function|LinkedVarying
name|LinkedVarying
operator|::
name|LinkedVarying
parameter_list|()
block|{ }
DECL|function|LinkedVarying
name|LinkedVarying
operator|::
name|LinkedVarying
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|name
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLsizei
name|size
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|semanticName
parameter_list|,
name|unsigned
name|int
name|semanticIndex
parameter_list|,
name|unsigned
name|int
name|semanticIndexCount
parameter_list|)
member_init_list|:
name|name
argument_list|(
name|name
argument_list|)
member_init_list|,
name|type
argument_list|(
name|type
argument_list|)
member_init_list|,
name|size
argument_list|(
name|size
argument_list|)
member_init_list|,
name|semanticName
argument_list|(
name|semanticName
argument_list|)
member_init_list|,
name|semanticIndex
argument_list|(
name|semanticIndex
argument_list|)
member_init_list|,
name|semanticIndexCount
argument_list|(
name|semanticIndexCount
argument_list|)
block|{ }
DECL|function|Program
name|Program
operator|::
name|Program
parameter_list|(
name|rx
operator|::
name|ProgramImpl
modifier|*
name|impl
parameter_list|,
name|ResourceManager
modifier|*
name|manager
parameter_list|,
name|GLuint
name|handle
parameter_list|)
member_init_list|:
name|mProgram
argument_list|(
name|impl
argument_list|)
member_init_list|,
name|mValidated
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mTransformFeedbackVaryings
argument_list|()
member_init_list|,
name|mTransformFeedbackBufferMode
argument_list|(
name|GL_NONE
argument_list|)
member_init_list|,
name|mFragmentShader
argument_list|(
name|NULL
argument_list|)
member_init_list|,
name|mVertexShader
argument_list|(
name|NULL
argument_list|)
member_init_list|,
name|mLinked
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mDeleteStatus
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mRefCount
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mResourceManager
argument_list|(
name|manager
argument_list|)
member_init_list|,
name|mHandle
argument_list|(
name|handle
argument_list|)
block|{
name|ASSERT
argument_list|(
name|mProgram
argument_list|)
expr_stmt|;
name|resetUniformBlockBindings
argument_list|()
expr_stmt|;
name|unlink
argument_list|()
expr_stmt|;
block|}
DECL|function|~Program
name|Program
operator|::
name|~
name|Program
parameter_list|()
block|{
name|unlink
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|mVertexShader
operator|!=
name|NULL
condition|)
block|{
name|mVertexShader
operator|->
name|release
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|mFragmentShader
operator|!=
name|NULL
condition|)
block|{
name|mFragmentShader
operator|->
name|release
argument_list|()
expr_stmt|;
block|}
name|SafeDelete
argument_list|(
name|mProgram
argument_list|)
expr_stmt|;
block|}
DECL|function|attachShader
name|bool
name|Program
operator|::
name|attachShader
parameter_list|(
name|Shader
modifier|*
name|shader
parameter_list|)
block|{
if|if
condition|(
name|shader
operator|->
name|getType
argument_list|()
operator|==
name|GL_VERTEX_SHADER
condition|)
block|{
if|if
condition|(
name|mVertexShader
condition|)
block|{
return|return
literal|false
return|;
block|}
name|mVertexShader
operator|=
name|shader
expr_stmt|;
name|mVertexShader
operator|->
name|addRef
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shader
operator|->
name|getType
argument_list|()
operator|==
name|GL_FRAGMENT_SHADER
condition|)
block|{
if|if
condition|(
name|mFragmentShader
condition|)
block|{
return|return
literal|false
return|;
block|}
name|mFragmentShader
operator|=
name|shader
expr_stmt|;
name|mFragmentShader
operator|->
name|addRef
argument_list|()
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|detachShader
name|bool
name|Program
operator|::
name|detachShader
parameter_list|(
name|Shader
modifier|*
name|shader
parameter_list|)
block|{
if|if
condition|(
name|shader
operator|->
name|getType
argument_list|()
operator|==
name|GL_VERTEX_SHADER
condition|)
block|{
if|if
condition|(
name|mVertexShader
operator|!=
name|shader
condition|)
block|{
return|return
literal|false
return|;
block|}
name|mVertexShader
operator|->
name|release
argument_list|()
expr_stmt|;
name|mVertexShader
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shader
operator|->
name|getType
argument_list|()
operator|==
name|GL_FRAGMENT_SHADER
condition|)
block|{
if|if
condition|(
name|mFragmentShader
operator|!=
name|shader
condition|)
block|{
return|return
literal|false
return|;
block|}
name|mFragmentShader
operator|->
name|release
argument_list|()
expr_stmt|;
name|mFragmentShader
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|getAttachedShadersCount
name|int
name|Program
operator|::
name|getAttachedShadersCount
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|mVertexShader
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
name|mFragmentShader
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
DECL|function|bindAttributeLocation
name|void
name|AttributeBindings
operator|::
name|bindAttributeLocation
parameter_list|(
name|GLuint
name|index
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|index
operator|<
name|MAX_VERTEX_ATTRIBS
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|i
operator|++
control|)
block|{
name|mAttributeBinding
index|[
name|i
index|]
operator|.
name|erase
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|mAttributeBinding
index|[
name|index
index|]
operator|.
name|insert
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|bindAttributeLocation
name|void
name|Program
operator|::
name|bindAttributeLocation
parameter_list|(
name|GLuint
name|index
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|mAttributeBindings
operator|.
name|bindAttributeLocation
argument_list|(
name|index
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|// Links the HLSL code of the vertex and pixel shader by matching up their varyings,
comment|// compiling them into binaries, determining the attribute mappings, and collecting
comment|// a list of uniforms
DECL|function|link
name|Error
name|Program
operator|::
name|link
parameter_list|(
specifier|const
name|Data
modifier|&
name|data
parameter_list|)
block|{
name|unlink
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|mInfoLog
operator|.
name|reset
argument_list|()
expr_stmt|;
name|resetUniformBlockBindings
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|mFragmentShader
operator|||
operator|!
name|mFragmentShader
operator|->
name|isCompiled
argument_list|()
condition|)
block|{
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|mFragmentShader
operator|->
name|getType
argument_list|()
operator|==
name|GL_FRAGMENT_SHADER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mVertexShader
operator|||
operator|!
name|mVertexShader
operator|->
name|isCompiled
argument_list|()
condition|)
block|{
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|mVertexShader
operator|->
name|getType
argument_list|()
operator|==
name|GL_VERTEX_SHADER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|linkAttributes
argument_list|(
name|mInfoLog
argument_list|,
name|mAttributeBindings
argument_list|,
name|mVertexShader
argument_list|)
condition|)
block|{
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
name|int
name|registers
decl_stmt|;
name|std
operator|::
name|vector
argument_list|<
name|LinkedVarying
argument_list|>
name|linkedVaryings
decl_stmt|;
name|rx
operator|::
name|LinkResult
name|result
init|=
name|mProgram
operator|->
name|link
argument_list|(
name|data
argument_list|,
name|mInfoLog
argument_list|,
name|mFragmentShader
argument_list|,
name|mVertexShader
argument_list|,
name|mTransformFeedbackVaryings
argument_list|,
name|mTransformFeedbackBufferMode
argument_list|,
operator|&
name|registers
argument_list|,
operator|&
name|linkedVaryings
argument_list|,
operator|&
name|mOutputVariables
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|.
name|error
operator|.
name|isError
argument_list|()
operator|||
operator|!
name|result
operator|.
name|linkSuccess
condition|)
block|{
return|return
name|result
operator|.
name|error
return|;
block|}
if|if
condition|(
operator|!
name|mProgram
operator|->
name|linkUniforms
argument_list|(
name|mInfoLog
argument_list|,
operator|*
name|mVertexShader
argument_list|,
operator|*
name|mFragmentShader
argument_list|,
operator|*
name|data
operator|.
name|caps
argument_list|)
condition|)
block|{
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|linkUniformBlocks
argument_list|(
name|mInfoLog
argument_list|,
operator|*
name|mVertexShader
argument_list|,
operator|*
name|mFragmentShader
argument_list|,
operator|*
name|data
operator|.
name|caps
argument_list|)
condition|)
block|{
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|gatherTransformFeedbackLinkedVaryings
argument_list|(
name|mInfoLog
argument_list|,
name|linkedVaryings
argument_list|,
name|mTransformFeedbackVaryings
argument_list|,
name|mTransformFeedbackBufferMode
argument_list|,
operator|&
name|mProgram
operator|->
name|getTransformFeedbackLinkedVaryings
argument_list|()
argument_list|,
operator|*
name|data
operator|.
name|caps
argument_list|)
condition|)
block|{
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
comment|// TODO: The concept of "executables" is D3D only, and as such this belongs in ProgramD3D. It must be called,
comment|// however, last in this function, so it can't simply be moved to ProgramD3D::link without further shuffling.
name|result
operator|=
name|mProgram
operator|->
name|compileProgramExecutables
argument_list|(
name|mInfoLog
argument_list|,
name|mFragmentShader
argument_list|,
name|mVertexShader
argument_list|,
name|registers
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|error
operator|.
name|isError
argument_list|()
operator|||
operator|!
name|result
operator|.
name|linkSuccess
condition|)
block|{
name|mInfoLog
operator|.
name|append
argument_list|(
literal|"Failed to create D3D shaders."
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return
name|result
operator|.
name|error
return|;
block|}
name|mLinked
operator|=
literal|true
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|getAttributeBinding
name|int
name|AttributeBindings
operator|::
name|getAttributeBinding
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|name
parameter_list|)
specifier|const
block|{
for|for
control|(
name|int
name|location
init|=
literal|0
init|;
name|location
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|location
operator|++
control|)
block|{
if|if
condition|(
name|mAttributeBinding
index|[
name|location
index|]
operator|.
name|find
argument_list|(
name|name
argument_list|)
operator|!=
name|mAttributeBinding
index|[
name|location
index|]
operator|.
name|end
argument_list|()
condition|)
block|{
return|return
name|location
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|// Returns the program object to an unlinked state, before re-linking, or at destruction
DECL|function|unlink
name|void
name|Program
operator|::
name|unlink
parameter_list|(
name|bool
name|destroy
parameter_list|)
block|{
if|if
condition|(
name|destroy
condition|)
comment|// Object being destructed
block|{
if|if
condition|(
name|mFragmentShader
condition|)
block|{
name|mFragmentShader
operator|->
name|release
argument_list|()
expr_stmt|;
name|mFragmentShader
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mVertexShader
condition|)
block|{
name|mVertexShader
operator|->
name|release
argument_list|()
expr_stmt|;
name|mVertexShader
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|std
operator|::
name|fill
argument_list|(
name|mLinkedAttribute
argument_list|,
name|mLinkedAttribute
operator|+
name|ArraySize
argument_list|(
name|mLinkedAttribute
argument_list|)
argument_list|,
name|sh
operator|::
name|Attribute
argument_list|()
argument_list|)
expr_stmt|;
name|mOutputVariables
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mProgram
operator|->
name|reset
argument_list|()
expr_stmt|;
name|mValidated
operator|=
literal|false
expr_stmt|;
name|mLinked
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|isLinked
name|bool
name|Program
operator|::
name|isLinked
parameter_list|()
block|{
return|return
name|mLinked
return|;
block|}
DECL|function|loadBinary
name|Error
name|Program
operator|::
name|loadBinary
parameter_list|(
name|GLenum
name|binaryFormat
parameter_list|,
specifier|const
name|void
modifier|*
name|binary
parameter_list|,
name|GLsizei
name|length
parameter_list|)
block|{
name|unlink
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|#
directive|if
name|ANGLE_PROGRAM_BINARY_LOAD
operator|!=
name|ANGLE_ENABLED
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
else|#
directive|else
name|ASSERT
argument_list|(
name|binaryFormat
operator|==
name|mProgram
operator|->
name|getBinaryFormat
argument_list|()
argument_list|)
expr_stmt|;
name|BinaryInputStream
name|stream
argument_list|(
name|binary
argument_list|,
name|length
argument_list|)
decl_stmt|;
name|GLenum
name|format
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|GLenum
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|format
operator|!=
name|mProgram
operator|->
name|getBinaryFormat
argument_list|()
condition|)
block|{
name|mInfoLog
operator|.
name|append
argument_list|(
literal|"Invalid program binary format."
argument_list|)
expr_stmt|;
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
name|int
name|majorVersion
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|int
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|minorVersion
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|int
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|majorVersion
operator|!=
name|ANGLE_MAJOR_VERSION
operator|||
name|minorVersion
operator|!=
name|ANGLE_MINOR_VERSION
condition|)
block|{
name|mInfoLog
operator|.
name|append
argument_list|(
literal|"Invalid program binary version."
argument_list|)
expr_stmt|;
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
name|unsigned
name|char
name|commitString
index|[
name|ANGLE_COMMIT_HASH_SIZE
index|]
decl_stmt|;
name|stream
operator|.
name|readBytes
argument_list|(
name|commitString
argument_list|,
name|ANGLE_COMMIT_HASH_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|commitString
argument_list|,
name|ANGLE_COMMIT_HASH
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
operator|*
name|ANGLE_COMMIT_HASH_SIZE
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mInfoLog
operator|.
name|append
argument_list|(
literal|"Invalid program binary version."
argument_list|)
expr_stmt|;
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
operator|++
name|i
control|)
block|{
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|mLinkedAttribute
index|[
name|i
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readString
argument_list|(
operator|&
name|mLinkedAttribute
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|mProgram
operator|->
name|getShaderAttributes
argument_list|()
index|[
name|i
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readString
argument_list|(
operator|&
name|mProgram
operator|->
name|getShaderAttributes
argument_list|()
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|mProgram
operator|->
name|getSemanticIndexes
argument_list|()
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|rx
operator|::
name|LinkResult
name|result
init|=
name|mProgram
operator|->
name|load
argument_list|(
name|mInfoLog
argument_list|,
operator|&
name|stream
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|.
name|error
operator|.
name|isError
argument_list|()
operator|||
operator|!
name|result
operator|.
name|linkSuccess
condition|)
block|{
return|return
name|result
operator|.
name|error
return|;
block|}
name|mLinked
operator|=
literal|true
expr_stmt|;
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
endif|#
directive|endif
comment|// #if ANGLE_PROGRAM_BINARY_LOAD == ANGLE_ENABLED
block|}
DECL|function|saveBinary
name|Error
name|Program
operator|::
name|saveBinary
parameter_list|(
name|GLenum
modifier|*
name|binaryFormat
parameter_list|,
name|void
modifier|*
name|binary
parameter_list|,
name|GLsizei
name|bufSize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|binaryFormat
condition|)
block|{
operator|*
name|binaryFormat
operator|=
name|mProgram
operator|->
name|getBinaryFormat
argument_list|()
expr_stmt|;
block|}
name|BinaryOutputStream
name|stream
decl_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|mProgram
operator|->
name|getBinaryFormat
argument_list|()
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|ANGLE_MAJOR_VERSION
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|ANGLE_MINOR_VERSION
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeBytes
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|ANGLE_COMMIT_HASH
argument_list|)
argument_list|,
name|ANGLE_COMMIT_HASH_SIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
operator|++
name|i
control|)
block|{
name|stream
operator|.
name|writeInt
argument_list|(
name|mLinkedAttribute
index|[
name|i
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeString
argument_list|(
name|mLinkedAttribute
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|mProgram
operator|->
name|getShaderAttributes
argument_list|()
index|[
name|i
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeString
argument_list|(
name|mProgram
operator|->
name|getShaderAttributes
argument_list|()
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|mProgram
operator|->
name|getSemanticIndexes
argument_list|()
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|gl
operator|::
name|Error
name|error
init|=
name|mProgram
operator|->
name|save
argument_list|(
operator|&
name|stream
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|GLsizei
name|streamLength
init|=
name|stream
operator|.
name|length
argument_list|()
decl_stmt|;
specifier|const
name|void
modifier|*
name|streamData
init|=
name|stream
operator|.
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
name|streamLength
operator|>
name|bufSize
condition|)
block|{
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
literal|0
expr_stmt|;
block|}
comment|// TODO: This should be moved to the validation layer but computing the size of the binary before saving
comment|// it causes the save to happen twice.  It may be possible to write the binary to a separate buffer, validate
comment|// sizes and then copy it.
return|return
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
name|binary
condition|)
block|{
name|char
modifier|*
name|ptr
init|=
cast|reinterpret_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
name|binary
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
name|streamData
argument_list|,
name|streamLength
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|streamLength
expr_stmt|;
name|ASSERT
argument_list|(
name|ptr
operator|-
name|streamLength
operator|==
name|binary
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
name|streamLength
expr_stmt|;
block|}
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|getBinaryLength
name|GLint
name|Program
operator|::
name|getBinaryLength
parameter_list|()
specifier|const
block|{
name|GLint
name|length
decl_stmt|;
name|Error
name|error
init|=
name|saveBinary
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|std
operator|::
name|numeric_limits
argument_list|<
name|GLint
argument_list|>
operator|::
name|max
argument_list|()
argument_list|,
operator|&
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|length
return|;
block|}
DECL|function|release
name|void
name|Program
operator|::
name|release
parameter_list|()
block|{
name|mRefCount
operator|--
expr_stmt|;
if|if
condition|(
name|mRefCount
operator|==
literal|0
operator|&&
name|mDeleteStatus
condition|)
block|{
name|mResourceManager
operator|->
name|deleteProgram
argument_list|(
name|mHandle
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|addRef
name|void
name|Program
operator|::
name|addRef
parameter_list|()
block|{
name|mRefCount
operator|++
expr_stmt|;
block|}
DECL|function|getRefCount
name|unsigned
name|int
name|Program
operator|::
name|getRefCount
parameter_list|()
specifier|const
block|{
return|return
name|mRefCount
return|;
block|}
DECL|function|getInfoLogLength
name|int
name|Program
operator|::
name|getInfoLogLength
parameter_list|()
specifier|const
block|{
return|return
name|mInfoLog
operator|.
name|getLength
argument_list|()
return|;
block|}
DECL|function|getInfoLog
name|void
name|Program
operator|::
name|getInfoLog
parameter_list|(
name|GLsizei
name|bufSize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|,
name|char
modifier|*
name|infoLog
parameter_list|)
block|{
return|return
name|mInfoLog
operator|.
name|getLog
argument_list|(
name|bufSize
argument_list|,
name|length
argument_list|,
name|infoLog
argument_list|)
return|;
block|}
DECL|function|getAttachedShaders
name|void
name|Program
operator|::
name|getAttachedShaders
parameter_list|(
name|GLsizei
name|maxCount
parameter_list|,
name|GLsizei
modifier|*
name|count
parameter_list|,
name|GLuint
modifier|*
name|shaders
parameter_list|)
block|{
name|int
name|total
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mVertexShader
condition|)
block|{
if|if
condition|(
name|total
operator|<
name|maxCount
condition|)
block|{
name|shaders
index|[
name|total
index|]
operator|=
name|mVertexShader
operator|->
name|getHandle
argument_list|()
expr_stmt|;
block|}
name|total
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|mFragmentShader
condition|)
block|{
if|if
condition|(
name|total
operator|<
name|maxCount
condition|)
block|{
name|shaders
index|[
name|total
index|]
operator|=
name|mFragmentShader
operator|->
name|getHandle
argument_list|()
expr_stmt|;
block|}
name|total
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|count
condition|)
block|{
operator|*
name|count
operator|=
name|total
expr_stmt|;
block|}
block|}
DECL|function|getAttributeLocation
name|GLuint
name|Program
operator|::
name|getAttributeLocation
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|name
parameter_list|)
block|{
for|for
control|(
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|mLinkedAttribute
index|[
name|index
index|]
operator|.
name|name
operator|==
name|name
condition|)
block|{
return|return
name|index
return|;
block|}
block|}
return|return
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
operator|-
literal|1
argument_list|)
return|;
block|}
DECL|function|getSemanticIndex
name|int
name|Program
operator|::
name|getSemanticIndex
parameter_list|(
name|int
name|attributeIndex
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|attributeIndex
operator|>=
literal|0
operator|&&
name|attributeIndex
operator|<
name|MAX_VERTEX_ATTRIBS
argument_list|)
expr_stmt|;
return|return
name|mProgram
operator|->
name|getSemanticIndexes
argument_list|()
index|[
name|attributeIndex
index|]
return|;
block|}
DECL|function|getActiveAttribute
name|void
name|Program
operator|::
name|getActiveAttribute
parameter_list|(
name|GLuint
name|index
parameter_list|,
name|GLsizei
name|bufsize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|,
name|GLint
modifier|*
name|size
parameter_list|,
name|GLenum
modifier|*
name|type
parameter_list|,
name|GLchar
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|mLinked
condition|)
block|{
comment|// Skip over inactive attributes
name|unsigned
name|int
name|activeAttribute
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|attribute
decl_stmt|;
for|for
control|(
name|attribute
operator|=
literal|0
init|;
name|attribute
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|attribute
operator|++
control|)
block|{
if|if
condition|(
name|mLinkedAttribute
index|[
name|attribute
index|]
operator|.
name|name
operator|.
name|empty
argument_list|()
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|activeAttribute
operator|==
name|index
condition|)
block|{
break|break;
block|}
name|activeAttribute
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bufsize
operator|>
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|string
init|=
name|mLinkedAttribute
index|[
name|attribute
index|]
operator|.
name|name
operator|.
name|c_str
argument_list|()
decl_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
name|string
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|name
index|[
name|bufsize
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|size
operator|=
literal|1
expr_stmt|;
comment|// Always a single 'type' instance
operator|*
name|type
operator|=
name|mLinkedAttribute
index|[
name|attribute
index|]
operator|.
name|type
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bufsize
operator|>
literal|0
condition|)
block|{
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|type
operator|=
name|GL_NONE
expr_stmt|;
operator|*
name|size
operator|=
literal|1
expr_stmt|;
block|}
block|}
DECL|function|getActiveAttributeCount
name|GLint
name|Program
operator|::
name|getActiveAttributeCount
parameter_list|()
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mLinked
condition|)
block|{
for|for
control|(
name|int
name|attributeIndex
init|=
literal|0
init|;
name|attributeIndex
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|attributeIndex
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|mLinkedAttribute
index|[
name|attributeIndex
index|]
operator|.
name|name
operator|.
name|empty
argument_list|()
condition|)
block|{
name|count
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
name|count
return|;
block|}
DECL|function|getActiveAttributeMaxLength
name|GLint
name|Program
operator|::
name|getActiveAttributeMaxLength
parameter_list|()
block|{
name|int
name|maxLength
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mLinked
condition|)
block|{
for|for
control|(
name|int
name|attributeIndex
init|=
literal|0
init|;
name|attributeIndex
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|attributeIndex
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|mLinkedAttribute
index|[
name|attributeIndex
index|]
operator|.
name|name
operator|.
name|empty
argument_list|()
condition|)
block|{
name|maxLength
operator|=
name|std
operator|::
name|max
argument_list|(
call|(
name|int
call|)
argument_list|(
name|mLinkedAttribute
index|[
name|attributeIndex
index|]
operator|.
name|name
operator|.
name|length
argument_list|()
operator|+
literal|1
argument_list|)
argument_list|,
name|maxLength
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|maxLength
return|;
block|}
comment|// Returns one more than the highest sampler index used.
DECL|function|getUsedSamplerRange
name|GLint
name|Program
operator|::
name|getUsedSamplerRange
parameter_list|(
name|SamplerType
name|type
parameter_list|)
block|{
return|return
name|mProgram
operator|->
name|getUsedSamplerRange
argument_list|(
name|type
argument_list|)
return|;
block|}
DECL|function|usesPointSize
name|bool
name|Program
operator|::
name|usesPointSize
parameter_list|()
specifier|const
block|{
return|return
name|mProgram
operator|->
name|usesPointSize
argument_list|()
return|;
block|}
DECL|function|getSamplerMapping
name|GLint
name|Program
operator|::
name|getSamplerMapping
parameter_list|(
name|SamplerType
name|type
parameter_list|,
name|unsigned
name|int
name|samplerIndex
parameter_list|,
specifier|const
name|Caps
modifier|&
name|caps
parameter_list|)
block|{
return|return
name|mProgram
operator|->
name|getSamplerMapping
argument_list|(
name|type
argument_list|,
name|samplerIndex
argument_list|,
name|caps
argument_list|)
return|;
block|}
DECL|function|getSamplerTextureType
name|GLenum
name|Program
operator|::
name|getSamplerTextureType
parameter_list|(
name|SamplerType
name|type
parameter_list|,
name|unsigned
name|int
name|samplerIndex
parameter_list|)
block|{
return|return
name|mProgram
operator|->
name|getSamplerTextureType
argument_list|(
name|type
argument_list|,
name|samplerIndex
argument_list|)
return|;
block|}
DECL|function|getFragDataLocation
name|GLint
name|Program
operator|::
name|getFragDataLocation
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|name
parameter_list|)
specifier|const
block|{
name|std
operator|::
name|string
name|baseName
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|arrayIndex
init|=
name|ParseAndStripArrayIndex
argument_list|(
operator|&
name|baseName
argument_list|)
decl_stmt|;
for|for
control|(
name|auto
name|locationIt
init|=
name|mOutputVariables
operator|.
name|begin
argument_list|()
init|;
name|locationIt
operator|!=
name|mOutputVariables
operator|.
name|end
argument_list|()
condition|;
name|locationIt
operator|++
control|)
block|{
specifier|const
name|VariableLocation
modifier|&
name|outputVariable
init|=
name|locationIt
operator|->
name|second
decl_stmt|;
if|if
condition|(
name|outputVariable
operator|.
name|name
operator|==
name|baseName
operator|&&
operator|(
name|arrayIndex
operator|==
name|GL_INVALID_INDEX
operator|||
name|arrayIndex
operator|==
name|outputVariable
operator|.
name|element
operator|)
condition|)
block|{
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|locationIt
operator|->
name|first
argument_list|)
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
DECL|function|getActiveUniform
name|void
name|Program
operator|::
name|getActiveUniform
parameter_list|(
name|GLuint
name|index
parameter_list|,
name|GLsizei
name|bufsize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|,
name|GLint
modifier|*
name|size
parameter_list|,
name|GLenum
modifier|*
name|type
parameter_list|,
name|GLchar
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|mLinked
condition|)
block|{
name|ASSERT
argument_list|(
name|index
operator|<
name|mProgram
operator|->
name|getUniforms
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// index must be smaller than getActiveUniformCount()
name|LinkedUniform
modifier|*
name|uniform
init|=
name|mProgram
operator|->
name|getUniforms
argument_list|()
index|[
name|index
index|]
decl_stmt|;
if|if
condition|(
name|bufsize
operator|>
literal|0
condition|)
block|{
name|std
operator|::
name|string
name|string
init|=
name|uniform
operator|->
name|name
decl_stmt|;
if|if
condition|(
name|uniform
operator|->
name|isArray
argument_list|()
condition|)
block|{
name|string
operator|+=
literal|"[0]"
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|name
argument_list|,
name|string
operator|.
name|c_str
argument_list|()
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|name
index|[
name|bufsize
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|size
operator|=
name|uniform
operator|->
name|elementCount
argument_list|()
expr_stmt|;
operator|*
name|type
operator|=
name|uniform
operator|->
name|type
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bufsize
operator|>
literal|0
condition|)
block|{
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|size
operator|=
literal|0
expr_stmt|;
operator|*
name|type
operator|=
name|GL_NONE
expr_stmt|;
block|}
block|}
DECL|function|getActiveUniformCount
name|GLint
name|Program
operator|::
name|getActiveUniformCount
parameter_list|()
block|{
if|if
condition|(
name|mLinked
condition|)
block|{
return|return
name|mProgram
operator|->
name|getUniforms
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
DECL|function|getActiveUniformMaxLength
name|GLint
name|Program
operator|::
name|getActiveUniformMaxLength
parameter_list|()
block|{
name|int
name|maxLength
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mLinked
condition|)
block|{
name|unsigned
name|int
name|numUniforms
init|=
name|mProgram
operator|->
name|getUniforms
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|uniformIndex
init|=
literal|0
init|;
name|uniformIndex
operator|<
name|numUniforms
condition|;
name|uniformIndex
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|mProgram
operator|->
name|getUniforms
argument_list|()
index|[
name|uniformIndex
index|]
operator|->
name|name
operator|.
name|empty
argument_list|()
condition|)
block|{
name|int
name|length
init|=
call|(
name|int
call|)
argument_list|(
name|mProgram
operator|->
name|getUniforms
argument_list|()
index|[
name|uniformIndex
index|]
operator|->
name|name
operator|.
name|length
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|mProgram
operator|->
name|getUniforms
argument_list|()
index|[
name|uniformIndex
index|]
operator|->
name|isArray
argument_list|()
condition|)
block|{
name|length
operator|+=
literal|3
expr_stmt|;
comment|// Counting in "[0]".
block|}
name|maxLength
operator|=
name|std
operator|::
name|max
argument_list|(
name|length
argument_list|,
name|maxLength
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|maxLength
return|;
block|}
DECL|function|getActiveUniformi
name|GLint
name|Program
operator|::
name|getActiveUniformi
parameter_list|(
name|GLuint
name|index
parameter_list|,
name|GLenum
name|pname
parameter_list|)
specifier|const
block|{
specifier|const
name|gl
operator|::
name|LinkedUniform
modifier|&
name|uniform
init|=
operator|*
name|mProgram
operator|->
name|getUniforms
argument_list|()
index|[
name|index
index|]
decl_stmt|;
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_UNIFORM_TYPE
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniform
operator|.
name|type
argument_list|)
return|;
case|case
name|GL_UNIFORM_SIZE
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniform
operator|.
name|elementCount
argument_list|()
argument_list|)
return|;
case|case
name|GL_UNIFORM_NAME_LENGTH
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniform
operator|.
name|name
operator|.
name|size
argument_list|()
operator|+
literal|1
operator|+
operator|(
name|uniform
operator|.
name|isArray
argument_list|()
condition|?
literal|3
else|:
literal|0
operator|)
argument_list|)
return|;
case|case
name|GL_UNIFORM_BLOCK_INDEX
case|:
return|return
name|uniform
operator|.
name|blockIndex
return|;
case|case
name|GL_UNIFORM_OFFSET
case|:
return|return
name|uniform
operator|.
name|blockInfo
operator|.
name|offset
return|;
case|case
name|GL_UNIFORM_ARRAY_STRIDE
case|:
return|return
name|uniform
operator|.
name|blockInfo
operator|.
name|arrayStride
return|;
case|case
name|GL_UNIFORM_MATRIX_STRIDE
case|:
return|return
name|uniform
operator|.
name|blockInfo
operator|.
name|matrixStride
return|;
case|case
name|GL_UNIFORM_IS_ROW_MAJOR
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniform
operator|.
name|blockInfo
operator|.
name|isRowMajorMatrix
argument_list|)
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
DECL|function|isValidUniformLocation
name|bool
name|Program
operator|::
name|isValidUniformLocation
parameter_list|(
name|GLint
name|location
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|rx
operator|::
name|IsIntegerCastSafe
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|mProgram
operator|->
name|getUniformIndices
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|location
operator|>=
literal|0
operator|&&
name|location
operator|<
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|mProgram
operator|->
name|getUniformIndices
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
operator|)
return|;
block|}
DECL|function|getUniformByLocation
name|LinkedUniform
modifier|*
name|Program
operator|::
name|getUniformByLocation
parameter_list|(
name|GLint
name|location
parameter_list|)
specifier|const
block|{
return|return
name|mProgram
operator|->
name|getUniformByLocation
argument_list|(
name|location
argument_list|)
return|;
block|}
DECL|function|getUniformByName
name|LinkedUniform
modifier|*
name|Program
operator|::
name|getUniformByName
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|name
parameter_list|)
specifier|const
block|{
return|return
name|mProgram
operator|->
name|getUniformByName
argument_list|(
name|name
argument_list|)
return|;
block|}
DECL|function|getUniformLocation
name|GLint
name|Program
operator|::
name|getUniformLocation
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|name
parameter_list|)
block|{
return|return
name|mProgram
operator|->
name|getUniformLocation
argument_list|(
name|name
argument_list|)
return|;
block|}
DECL|function|getUniformIndex
name|GLuint
name|Program
operator|::
name|getUniformIndex
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|name
parameter_list|)
block|{
return|return
name|mProgram
operator|->
name|getUniformIndex
argument_list|(
name|name
argument_list|)
return|;
block|}
DECL|function|setUniform1fv
name|void
name|Program
operator|::
name|setUniform1fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniform1fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform2fv
name|void
name|Program
operator|::
name|setUniform2fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniform2fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform3fv
name|void
name|Program
operator|::
name|setUniform3fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniform3fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform4fv
name|void
name|Program
operator|::
name|setUniform4fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniform4fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform1iv
name|void
name|Program
operator|::
name|setUniform1iv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniform1iv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform2iv
name|void
name|Program
operator|::
name|setUniform2iv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniform2iv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform3iv
name|void
name|Program
operator|::
name|setUniform3iv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniform3iv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform4iv
name|void
name|Program
operator|::
name|setUniform4iv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniform4iv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform1uiv
name|void
name|Program
operator|::
name|setUniform1uiv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniform1uiv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform2uiv
name|void
name|Program
operator|::
name|setUniform2uiv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniform2uiv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform3uiv
name|void
name|Program
operator|::
name|setUniform3uiv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniform3uiv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform4uiv
name|void
name|Program
operator|::
name|setUniform4uiv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniform4uiv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix2fv
name|void
name|Program
operator|::
name|setUniformMatrix2fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniformMatrix2fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix3fv
name|void
name|Program
operator|::
name|setUniformMatrix3fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniformMatrix3fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix4fv
name|void
name|Program
operator|::
name|setUniformMatrix4fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniformMatrix4fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix2x3fv
name|void
name|Program
operator|::
name|setUniformMatrix2x3fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniformMatrix2x3fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix2x4fv
name|void
name|Program
operator|::
name|setUniformMatrix2x4fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniformMatrix2x4fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix3x2fv
name|void
name|Program
operator|::
name|setUniformMatrix3x2fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniformMatrix3x2fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix3x4fv
name|void
name|Program
operator|::
name|setUniformMatrix3x4fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniformMatrix3x4fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix4x2fv
name|void
name|Program
operator|::
name|setUniformMatrix4x2fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniformMatrix4x2fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix4x3fv
name|void
name|Program
operator|::
name|setUniformMatrix4x3fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|setUniformMatrix4x3fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|getUniformfv
name|void
name|Program
operator|::
name|getUniformfv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|getUniformfv
argument_list|(
name|location
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|getUniformiv
name|void
name|Program
operator|::
name|getUniformiv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|getUniformiv
argument_list|(
name|location
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|getUniformuiv
name|void
name|Program
operator|::
name|getUniformuiv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLuint
modifier|*
name|v
parameter_list|)
block|{
name|mProgram
operator|->
name|getUniformuiv
argument_list|(
name|location
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
comment|// Applies all the uniforms set for this program object to the renderer
DECL|function|applyUniforms
name|Error
name|Program
operator|::
name|applyUniforms
parameter_list|()
block|{
return|return
name|mProgram
operator|->
name|applyUniforms
argument_list|()
return|;
block|}
DECL|function|applyUniformBuffers
name|Error
name|Program
operator|::
name|applyUniformBuffers
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|)
block|{
return|return
name|mProgram
operator|->
name|applyUniformBuffers
argument_list|(
name|data
argument_list|,
name|mUniformBlockBindings
argument_list|)
return|;
block|}
DECL|function|flagForDeletion
name|void
name|Program
operator|::
name|flagForDeletion
parameter_list|()
block|{
name|mDeleteStatus
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|isFlaggedForDeletion
name|bool
name|Program
operator|::
name|isFlaggedForDeletion
parameter_list|()
specifier|const
block|{
return|return
name|mDeleteStatus
return|;
block|}
DECL|function|validate
name|void
name|Program
operator|::
name|validate
parameter_list|(
specifier|const
name|Caps
modifier|&
name|caps
parameter_list|)
block|{
name|mInfoLog
operator|.
name|reset
argument_list|()
expr_stmt|;
name|mValidated
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|mLinked
condition|)
block|{
name|applyUniforms
argument_list|()
expr_stmt|;
name|mValidated
operator|=
name|mProgram
operator|->
name|validateSamplers
argument_list|(
operator|&
name|mInfoLog
argument_list|,
name|caps
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mInfoLog
operator|.
name|append
argument_list|(
literal|"Program has not been successfully linked."
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|validateSamplers
name|bool
name|Program
operator|::
name|validateSamplers
parameter_list|(
name|InfoLog
modifier|*
name|infoLog
parameter_list|,
specifier|const
name|Caps
modifier|&
name|caps
parameter_list|)
block|{
return|return
name|mProgram
operator|->
name|validateSamplers
argument_list|(
name|infoLog
argument_list|,
name|caps
argument_list|)
return|;
block|}
DECL|function|isValidated
name|bool
name|Program
operator|::
name|isValidated
parameter_list|()
specifier|const
block|{
return|return
name|mValidated
return|;
block|}
DECL|function|updateSamplerMapping
name|void
name|Program
operator|::
name|updateSamplerMapping
parameter_list|()
block|{
return|return
name|mProgram
operator|->
name|updateSamplerMapping
argument_list|()
return|;
block|}
DECL|function|getActiveUniformBlockCount
name|GLuint
name|Program
operator|::
name|getActiveUniformBlockCount
parameter_list|()
block|{
return|return
name|mProgram
operator|->
name|getUniformBlocks
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
DECL|function|getActiveUniformBlockName
name|void
name|Program
operator|::
name|getActiveUniformBlockName
parameter_list|(
name|GLuint
name|uniformBlockIndex
parameter_list|,
name|GLsizei
name|bufSize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|,
name|GLchar
modifier|*
name|uniformBlockName
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|uniformBlockIndex
operator|<
name|mProgram
operator|->
name|getUniformBlocks
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// index must be smaller than getActiveUniformBlockCount()
specifier|const
name|UniformBlock
modifier|&
name|uniformBlock
init|=
operator|*
name|mProgram
operator|->
name|getUniformBlocks
argument_list|()
index|[
name|uniformBlockIndex
index|]
decl_stmt|;
if|if
condition|(
name|bufSize
operator|>
literal|0
condition|)
block|{
name|std
operator|::
name|string
name|string
init|=
name|uniformBlock
operator|.
name|name
decl_stmt|;
if|if
condition|(
name|uniformBlock
operator|.
name|isArrayElement
argument_list|()
condition|)
block|{
name|string
operator|+=
name|ArrayString
argument_list|(
name|uniformBlock
operator|.
name|elementIndex
argument_list|)
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|uniformBlockName
argument_list|,
name|string
operator|.
name|c_str
argument_list|()
argument_list|,
name|bufSize
argument_list|)
expr_stmt|;
name|uniformBlockName
index|[
name|bufSize
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
name|strlen
argument_list|(
name|uniformBlockName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|getActiveUniformBlockiv
name|void
name|Program
operator|::
name|getActiveUniformBlockiv
parameter_list|(
name|GLuint
name|uniformBlockIndex
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLint
modifier|*
name|params
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|uniformBlockIndex
operator|<
name|mProgram
operator|->
name|getUniformBlocks
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// index must be smaller than getActiveUniformBlockCount()
specifier|const
name|UniformBlock
modifier|&
name|uniformBlock
init|=
operator|*
name|mProgram
operator|->
name|getUniformBlocks
argument_list|()
index|[
name|uniformBlockIndex
index|]
decl_stmt|;
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_UNIFORM_BLOCK_DATA_SIZE
case|:
operator|*
name|params
operator|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniformBlock
operator|.
name|dataSize
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_UNIFORM_BLOCK_NAME_LENGTH
case|:
operator|*
name|params
operator|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniformBlock
operator|.
name|name
operator|.
name|size
argument_list|()
operator|+
literal|1
operator|+
operator|(
name|uniformBlock
operator|.
name|isArrayElement
argument_list|()
condition|?
literal|3
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS
case|:
operator|*
name|params
operator|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniformBlock
operator|.
name|memberUniformIndexes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES
case|:
block|{
for|for
control|(
name|unsigned
name|int
name|blockMemberIndex
init|=
literal|0
init|;
name|blockMemberIndex
operator|<
name|uniformBlock
operator|.
name|memberUniformIndexes
operator|.
name|size
argument_list|()
condition|;
name|blockMemberIndex
operator|++
control|)
block|{
name|params
index|[
name|blockMemberIndex
index|]
operator|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniformBlock
operator|.
name|memberUniformIndexes
index|[
name|blockMemberIndex
index|]
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER
case|:
operator|*
name|params
operator|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniformBlock
operator|.
name|isReferencedByVertexShader
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER
case|:
operator|*
name|params
operator|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniformBlock
operator|.
name|isReferencedByFragmentShader
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|getActiveUniformBlockMaxLength
name|GLint
name|Program
operator|::
name|getActiveUniformBlockMaxLength
parameter_list|()
block|{
name|int
name|maxLength
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mLinked
condition|)
block|{
name|unsigned
name|int
name|numUniformBlocks
init|=
name|mProgram
operator|->
name|getUniformBlocks
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|uniformBlockIndex
init|=
literal|0
init|;
name|uniformBlockIndex
operator|<
name|numUniformBlocks
condition|;
name|uniformBlockIndex
operator|++
control|)
block|{
specifier|const
name|UniformBlock
modifier|&
name|uniformBlock
init|=
operator|*
name|mProgram
operator|->
name|getUniformBlocks
argument_list|()
index|[
name|uniformBlockIndex
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|uniformBlock
operator|.
name|name
operator|.
name|empty
argument_list|()
condition|)
block|{
specifier|const
name|int
name|length
init|=
name|uniformBlock
operator|.
name|name
operator|.
name|length
argument_list|()
operator|+
literal|1
decl_stmt|;
comment|// Counting in "[0]".
specifier|const
name|int
name|arrayLength
init|=
operator|(
name|uniformBlock
operator|.
name|isArrayElement
argument_list|()
condition|?
literal|3
else|:
literal|0
operator|)
decl_stmt|;
name|maxLength
operator|=
name|std
operator|::
name|max
argument_list|(
name|length
operator|+
name|arrayLength
argument_list|,
name|maxLength
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|maxLength
return|;
block|}
DECL|function|getUniformBlockIndex
name|GLuint
name|Program
operator|::
name|getUniformBlockIndex
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|name
parameter_list|)
block|{
return|return
name|mProgram
operator|->
name|getUniformBlockIndex
argument_list|(
name|name
argument_list|)
return|;
block|}
DECL|function|getUniformBlockByIndex
specifier|const
name|UniformBlock
modifier|*
name|Program
operator|::
name|getUniformBlockByIndex
parameter_list|(
name|GLuint
name|index
parameter_list|)
specifier|const
block|{
return|return
name|mProgram
operator|->
name|getUniformBlockByIndex
argument_list|(
name|index
argument_list|)
return|;
block|}
DECL|function|bindUniformBlock
name|void
name|Program
operator|::
name|bindUniformBlock
parameter_list|(
name|GLuint
name|uniformBlockIndex
parameter_list|,
name|GLuint
name|uniformBlockBinding
parameter_list|)
block|{
name|mUniformBlockBindings
index|[
name|uniformBlockIndex
index|]
operator|=
name|uniformBlockBinding
expr_stmt|;
block|}
DECL|function|getUniformBlockBinding
name|GLuint
name|Program
operator|::
name|getUniformBlockBinding
parameter_list|(
name|GLuint
name|uniformBlockIndex
parameter_list|)
specifier|const
block|{
return|return
name|mUniformBlockBindings
index|[
name|uniformBlockIndex
index|]
return|;
block|}
DECL|function|resetUniformBlockBindings
name|void
name|Program
operator|::
name|resetUniformBlockBindings
parameter_list|()
block|{
for|for
control|(
name|unsigned
name|int
name|blockId
init|=
literal|0
init|;
name|blockId
operator|<
name|IMPLEMENTATION_MAX_COMBINED_SHADER_UNIFORM_BUFFERS
condition|;
name|blockId
operator|++
control|)
block|{
name|mUniformBlockBindings
index|[
name|blockId
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
DECL|function|setTransformFeedbackVaryings
name|void
name|Program
operator|::
name|setTransformFeedbackVaryings
parameter_list|(
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLchar
modifier|*
specifier|const
modifier|*
name|varyings
parameter_list|,
name|GLenum
name|bufferMode
parameter_list|)
block|{
name|mTransformFeedbackVaryings
operator|.
name|resize
argument_list|(
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|GLsizei
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|mTransformFeedbackVaryings
index|[
name|i
index|]
operator|=
name|varyings
index|[
name|i
index|]
expr_stmt|;
block|}
name|mTransformFeedbackBufferMode
operator|=
name|bufferMode
expr_stmt|;
block|}
DECL|function|getTransformFeedbackVarying
name|void
name|Program
operator|::
name|getTransformFeedbackVarying
parameter_list|(
name|GLuint
name|index
parameter_list|,
name|GLsizei
name|bufSize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|,
name|GLsizei
modifier|*
name|size
parameter_list|,
name|GLenum
modifier|*
name|type
parameter_list|,
name|GLchar
modifier|*
name|name
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|mLinked
condition|)
block|{
name|ASSERT
argument_list|(
name|index
operator|<
name|mProgram
operator|->
name|getTransformFeedbackLinkedVaryings
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|LinkedVarying
modifier|&
name|varying
init|=
name|mProgram
operator|->
name|getTransformFeedbackLinkedVaryings
argument_list|()
index|[
name|index
index|]
decl_stmt|;
name|GLsizei
name|lastNameIdx
init|=
name|std
operator|::
name|min
argument_list|(
name|bufSize
operator|-
literal|1
argument_list|,
cast|static_cast
argument_list|<
name|GLsizei
argument_list|>
argument_list|(
name|varying
operator|.
name|name
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
name|lastNameIdx
expr_stmt|;
block|}
if|if
condition|(
name|size
condition|)
block|{
operator|*
name|size
operator|=
name|varying
operator|.
name|size
expr_stmt|;
block|}
if|if
condition|(
name|type
condition|)
block|{
operator|*
name|type
operator|=
name|varying
operator|.
name|type
expr_stmt|;
block|}
if|if
condition|(
name|name
condition|)
block|{
name|memcpy
argument_list|(
name|name
argument_list|,
name|varying
operator|.
name|name
operator|.
name|c_str
argument_list|()
argument_list|,
name|lastNameIdx
argument_list|)
expr_stmt|;
name|name
index|[
name|lastNameIdx
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
block|}
DECL|function|getTransformFeedbackVaryingCount
name|GLsizei
name|Program
operator|::
name|getTransformFeedbackVaryingCount
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|mLinked
condition|)
block|{
return|return
cast|static_cast
argument_list|<
name|GLsizei
argument_list|>
argument_list|(
name|mProgram
operator|->
name|getTransformFeedbackLinkedVaryings
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
DECL|function|getTransformFeedbackVaryingMaxLength
name|GLsizei
name|Program
operator|::
name|getTransformFeedbackVaryingMaxLength
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|mLinked
condition|)
block|{
name|GLsizei
name|maxSize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mProgram
operator|->
name|getTransformFeedbackLinkedVaryings
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|LinkedVarying
modifier|&
name|varying
init|=
name|mProgram
operator|->
name|getTransformFeedbackLinkedVaryings
argument_list|()
index|[
name|i
index|]
decl_stmt|;
name|maxSize
operator|=
name|std
operator|::
name|max
argument_list|(
name|maxSize
argument_list|,
cast|static_cast
argument_list|<
name|GLsizei
argument_list|>
argument_list|(
name|varying
operator|.
name|name
operator|.
name|length
argument_list|()
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|maxSize
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
DECL|function|getTransformFeedbackBufferMode
name|GLenum
name|Program
operator|::
name|getTransformFeedbackBufferMode
parameter_list|()
specifier|const
block|{
return|return
name|mTransformFeedbackBufferMode
return|;
block|}
DECL|function|linkVaryings
name|bool
name|Program
operator|::
name|linkVaryings
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
name|Shader
modifier|*
name|fragmentShader
parameter_list|,
name|Shader
modifier|*
name|vertexShader
parameter_list|)
block|{
name|std
operator|::
name|vector
argument_list|<
name|PackedVarying
argument_list|>
modifier|&
name|fragmentVaryings
init|=
name|fragmentShader
operator|->
name|getVaryings
argument_list|()
decl_stmt|;
name|std
operator|::
name|vector
argument_list|<
name|PackedVarying
argument_list|>
modifier|&
name|vertexVaryings
init|=
name|vertexShader
operator|->
name|getVaryings
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|fragVaryingIndex
init|=
literal|0
init|;
name|fragVaryingIndex
operator|<
name|fragmentVaryings
operator|.
name|size
argument_list|()
condition|;
name|fragVaryingIndex
operator|++
control|)
block|{
name|PackedVarying
modifier|*
name|input
init|=
operator|&
name|fragmentVaryings
index|[
name|fragVaryingIndex
index|]
decl_stmt|;
name|bool
name|matched
init|=
literal|false
decl_stmt|;
comment|// Built-in varyings obey special rules
if|if
condition|(
name|input
operator|->
name|isBuiltIn
argument_list|()
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|size_t
name|vertVaryingIndex
init|=
literal|0
init|;
name|vertVaryingIndex
operator|<
name|vertexVaryings
operator|.
name|size
argument_list|()
condition|;
name|vertVaryingIndex
operator|++
control|)
block|{
name|PackedVarying
modifier|*
name|output
init|=
operator|&
name|vertexVaryings
index|[
name|vertVaryingIndex
index|]
decl_stmt|;
if|if
condition|(
name|output
operator|->
name|name
operator|==
name|input
operator|->
name|name
condition|)
block|{
if|if
condition|(
operator|!
name|linkValidateVaryings
argument_list|(
name|infoLog
argument_list|,
name|output
operator|->
name|name
argument_list|,
operator|*
name|input
argument_list|,
operator|*
name|output
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|output
operator|->
name|registerIndex
operator|=
name|input
operator|->
name|registerIndex
expr_stmt|;
name|output
operator|->
name|columnIndex
operator|=
name|input
operator|->
name|columnIndex
expr_stmt|;
name|matched
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
comment|// We permit unmatched, unreferenced varyings
if|if
condition|(
operator|!
name|matched
operator|&&
name|input
operator|->
name|staticUse
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Fragment varying %s does not match any vertex varying"
argument_list|,
name|input
operator|->
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|linkValidateInterfaceBlockFields
name|bool
name|Program
operator|::
name|linkValidateInterfaceBlockFields
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|uniformName
parameter_list|,
specifier|const
name|sh
operator|::
name|InterfaceBlockField
modifier|&
name|vertexUniform
parameter_list|,
specifier|const
name|sh
operator|::
name|InterfaceBlockField
modifier|&
name|fragmentUniform
parameter_list|)
block|{
if|if
condition|(
operator|!
name|linkValidateVariablesBase
argument_list|(
name|infoLog
argument_list|,
name|uniformName
argument_list|,
name|vertexUniform
argument_list|,
name|fragmentUniform
argument_list|,
literal|true
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|vertexUniform
operator|.
name|isRowMajorLayout
operator|!=
name|fragmentUniform
operator|.
name|isRowMajorLayout
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Matrix packings for %s differ between vertex and fragment shaders"
argument_list|,
name|uniformName
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|// Determines the mapping between GL attributes and Direct3D 9 vertex stream usage indices
DECL|function|linkAttributes
name|bool
name|Program
operator|::
name|linkAttributes
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|AttributeBindings
modifier|&
name|attributeBindings
parameter_list|,
specifier|const
name|Shader
modifier|*
name|vertexShader
parameter_list|)
block|{
name|unsigned
name|int
name|usedLocations
init|=
literal|0
decl_stmt|;
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|Attribute
argument_list|>
modifier|&
name|shaderAttributes
init|=
name|vertexShader
operator|->
name|getActiveAttributes
argument_list|()
decl_stmt|;
comment|// Link attributes that have a binding location
for|for
control|(
name|unsigned
name|int
name|attributeIndex
init|=
literal|0
init|;
name|attributeIndex
operator|<
name|shaderAttributes
operator|.
name|size
argument_list|()
condition|;
name|attributeIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|Attribute
modifier|&
name|attribute
init|=
name|shaderAttributes
index|[
name|attributeIndex
index|]
decl_stmt|;
name|ASSERT
argument_list|(
name|attribute
operator|.
name|staticUse
argument_list|)
expr_stmt|;
specifier|const
name|int
name|location
init|=
name|attribute
operator|.
name|location
operator|==
operator|-
literal|1
condition|?
name|attributeBindings
operator|.
name|getAttributeBinding
argument_list|(
name|attribute
operator|.
name|name
argument_list|)
else|:
name|attribute
operator|.
name|location
decl_stmt|;
name|mProgram
operator|->
name|getShaderAttributes
argument_list|()
index|[
name|attributeIndex
index|]
operator|=
name|attribute
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
comment|// Set by glBindAttribLocation or by location layout qualifier
block|{
specifier|const
name|int
name|rows
init|=
name|VariableRegisterCount
argument_list|(
name|attribute
operator|.
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|rows
operator|+
name|location
operator|>
name|MAX_VERTEX_ATTRIBS
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Active attribute (%s) at location %d is too big to fit"
argument_list|,
name|attribute
operator|.
name|name
operator|.
name|c_str
argument_list|()
argument_list|,
name|location
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|row
init|=
literal|0
init|;
name|row
operator|<
name|rows
condition|;
name|row
operator|++
control|)
block|{
specifier|const
name|int
name|rowLocation
init|=
name|location
operator|+
name|row
decl_stmt|;
name|sh
operator|::
name|ShaderVariable
modifier|&
name|linkedAttribute
init|=
name|mLinkedAttribute
index|[
name|rowLocation
index|]
decl_stmt|;
comment|// In GLSL 3.00, attribute aliasing produces a link error
comment|// In GLSL 1.00, attribute aliasing is allowed
if|if
condition|(
name|mProgram
operator|->
name|getShaderVersion
argument_list|()
operator|>=
literal|300
condition|)
block|{
if|if
condition|(
operator|!
name|linkedAttribute
operator|.
name|name
operator|.
name|empty
argument_list|()
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Attribute '%s' aliases attribute '%s' at location %d"
argument_list|,
name|attribute
operator|.
name|name
operator|.
name|c_str
argument_list|()
argument_list|,
name|linkedAttribute
operator|.
name|name
operator|.
name|c_str
argument_list|()
argument_list|,
name|rowLocation
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|linkedAttribute
operator|=
name|attribute
expr_stmt|;
name|usedLocations
operator||=
literal|1
operator|<<
name|rowLocation
expr_stmt|;
block|}
block|}
block|}
comment|// Link attributes that don't have a binding location
for|for
control|(
name|unsigned
name|int
name|attributeIndex
init|=
literal|0
init|;
name|attributeIndex
operator|<
name|shaderAttributes
operator|.
name|size
argument_list|()
condition|;
name|attributeIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|Attribute
modifier|&
name|attribute
init|=
name|shaderAttributes
index|[
name|attributeIndex
index|]
decl_stmt|;
name|ASSERT
argument_list|(
name|attribute
operator|.
name|staticUse
argument_list|)
expr_stmt|;
specifier|const
name|int
name|location
init|=
name|attribute
operator|.
name|location
operator|==
operator|-
literal|1
condition|?
name|attributeBindings
operator|.
name|getAttributeBinding
argument_list|(
name|attribute
operator|.
name|name
argument_list|)
else|:
name|attribute
operator|.
name|location
decl_stmt|;
if|if
condition|(
name|location
operator|==
operator|-
literal|1
condition|)
comment|// Not set by glBindAttribLocation or by location layout qualifier
block|{
name|int
name|rows
init|=
name|VariableRegisterCount
argument_list|(
name|attribute
operator|.
name|type
argument_list|)
decl_stmt|;
name|int
name|availableIndex
init|=
name|AllocateFirstFreeBits
argument_list|(
operator|&
name|usedLocations
argument_list|,
name|rows
argument_list|,
name|MAX_VERTEX_ATTRIBS
argument_list|)
decl_stmt|;
if|if
condition|(
name|availableIndex
operator|==
operator|-
literal|1
operator|||
name|availableIndex
operator|+
name|rows
operator|>
name|MAX_VERTEX_ATTRIBS
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Too many active attributes (%s)"
argument_list|,
name|attribute
operator|.
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
comment|// Fail to link
block|}
name|mLinkedAttribute
index|[
name|availableIndex
index|]
operator|=
name|attribute
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|attributeIndex
init|=
literal|0
init|;
name|attributeIndex
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
control|)
block|{
name|int
name|index
init|=
name|vertexShader
operator|->
name|getSemanticIndex
argument_list|(
name|mLinkedAttribute
index|[
name|attributeIndex
index|]
operator|.
name|name
argument_list|)
decl_stmt|;
name|int
name|rows
init|=
name|VariableRegisterCount
argument_list|(
name|mLinkedAttribute
index|[
name|attributeIndex
index|]
operator|.
name|type
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|r
init|=
literal|0
init|;
name|r
operator|<
name|rows
condition|;
name|r
operator|++
control|)
block|{
name|mProgram
operator|->
name|getSemanticIndexes
argument_list|()
index|[
name|attributeIndex
operator|++
index|]
operator|=
name|index
operator|++
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|linkUniformBlocks
name|bool
name|Program
operator|::
name|linkUniformBlocks
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|Shader
modifier|&
name|vertexShader
parameter_list|,
specifier|const
name|Shader
modifier|&
name|fragmentShader
parameter_list|,
specifier|const
name|Caps
modifier|&
name|caps
parameter_list|)
block|{
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|InterfaceBlock
argument_list|>
modifier|&
name|vertexInterfaceBlocks
init|=
name|vertexShader
operator|.
name|getInterfaceBlocks
argument_list|()
decl_stmt|;
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|InterfaceBlock
argument_list|>
modifier|&
name|fragmentInterfaceBlocks
init|=
name|fragmentShader
operator|.
name|getInterfaceBlocks
argument_list|()
decl_stmt|;
comment|// Check that interface blocks defined in the vertex and fragment shaders are identical
typedef|typedef
name|std
operator|::
name|map
argument_list|<
name|std
operator|::
name|string
argument_list|,
specifier|const
name|sh
operator|::
name|InterfaceBlock
operator|*
argument_list|>
name|UniformBlockMap
typedef|;
name|UniformBlockMap
name|linkedUniformBlocks
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|blockIndex
init|=
literal|0
init|;
name|blockIndex
operator|<
name|vertexInterfaceBlocks
operator|.
name|size
argument_list|()
condition|;
name|blockIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|InterfaceBlock
modifier|&
name|vertexInterfaceBlock
init|=
name|vertexInterfaceBlocks
index|[
name|blockIndex
index|]
decl_stmt|;
name|linkedUniformBlocks
index|[
name|vertexInterfaceBlock
operator|.
name|name
index|]
operator|=
operator|&
name|vertexInterfaceBlock
expr_stmt|;
block|}
for|for
control|(
name|unsigned
name|int
name|blockIndex
init|=
literal|0
init|;
name|blockIndex
operator|<
name|fragmentInterfaceBlocks
operator|.
name|size
argument_list|()
condition|;
name|blockIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|InterfaceBlock
modifier|&
name|fragmentInterfaceBlock
init|=
name|fragmentInterfaceBlocks
index|[
name|blockIndex
index|]
decl_stmt|;
name|UniformBlockMap
operator|::
name|const_iterator
name|entry
init|=
name|linkedUniformBlocks
operator|.
name|find
argument_list|(
name|fragmentInterfaceBlock
operator|.
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
name|linkedUniformBlocks
operator|.
name|end
argument_list|()
condition|)
block|{
specifier|const
name|sh
operator|::
name|InterfaceBlock
modifier|&
name|vertexInterfaceBlock
init|=
operator|*
name|entry
operator|->
name|second
decl_stmt|;
if|if
condition|(
operator|!
name|areMatchingInterfaceBlocks
argument_list|(
name|infoLog
argument_list|,
name|vertexInterfaceBlock
argument_list|,
name|fragmentInterfaceBlock
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
for|for
control|(
name|unsigned
name|int
name|blockIndex
init|=
literal|0
init|;
name|blockIndex
operator|<
name|vertexInterfaceBlocks
operator|.
name|size
argument_list|()
condition|;
name|blockIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|InterfaceBlock
modifier|&
name|interfaceBlock
init|=
name|vertexInterfaceBlocks
index|[
name|blockIndex
index|]
decl_stmt|;
comment|// Note: shared and std140 layouts are always considered active
if|if
condition|(
name|interfaceBlock
operator|.
name|staticUse
operator|||
name|interfaceBlock
operator|.
name|layout
operator|!=
name|sh
operator|::
name|BLOCKLAYOUT_PACKED
condition|)
block|{
if|if
condition|(
operator|!
name|mProgram
operator|->
name|defineUniformBlock
argument_list|(
name|infoLog
argument_list|,
name|vertexShader
argument_list|,
name|interfaceBlock
argument_list|,
name|caps
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
for|for
control|(
name|unsigned
name|int
name|blockIndex
init|=
literal|0
init|;
name|blockIndex
operator|<
name|fragmentInterfaceBlocks
operator|.
name|size
argument_list|()
condition|;
name|blockIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|InterfaceBlock
modifier|&
name|interfaceBlock
init|=
name|fragmentInterfaceBlocks
index|[
name|blockIndex
index|]
decl_stmt|;
comment|// Note: shared and std140 layouts are always considered active
if|if
condition|(
name|interfaceBlock
operator|.
name|staticUse
operator|||
name|interfaceBlock
operator|.
name|layout
operator|!=
name|sh
operator|::
name|BLOCKLAYOUT_PACKED
condition|)
block|{
if|if
condition|(
operator|!
name|mProgram
operator|->
name|defineUniformBlock
argument_list|(
name|infoLog
argument_list|,
name|fragmentShader
argument_list|,
name|interfaceBlock
argument_list|,
name|caps
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|areMatchingInterfaceBlocks
name|bool
name|Program
operator|::
name|areMatchingInterfaceBlocks
parameter_list|(
name|gl
operator|::
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|sh
operator|::
name|InterfaceBlock
modifier|&
name|vertexInterfaceBlock
parameter_list|,
specifier|const
name|sh
operator|::
name|InterfaceBlock
modifier|&
name|fragmentInterfaceBlock
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|blockName
init|=
name|vertexInterfaceBlock
operator|.
name|name
operator|.
name|c_str
argument_list|()
decl_stmt|;
comment|// validate blocks for the same member types
if|if
condition|(
name|vertexInterfaceBlock
operator|.
name|fields
operator|.
name|size
argument_list|()
operator|!=
name|fragmentInterfaceBlock
operator|.
name|fields
operator|.
name|size
argument_list|()
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Types for interface block '%s' differ between vertex and fragment shaders"
argument_list|,
name|blockName
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|vertexInterfaceBlock
operator|.
name|arraySize
operator|!=
name|fragmentInterfaceBlock
operator|.
name|arraySize
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Array sizes differ for interface block '%s' between vertex and fragment shaders"
argument_list|,
name|blockName
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|vertexInterfaceBlock
operator|.
name|layout
operator|!=
name|fragmentInterfaceBlock
operator|.
name|layout
operator|||
name|vertexInterfaceBlock
operator|.
name|isRowMajorLayout
operator|!=
name|fragmentInterfaceBlock
operator|.
name|isRowMajorLayout
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Layout qualifiers differ for interface block '%s' between vertex and fragment shaders"
argument_list|,
name|blockName
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|unsigned
name|int
name|numBlockMembers
init|=
name|vertexInterfaceBlock
operator|.
name|fields
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|blockMemberIndex
init|=
literal|0
init|;
name|blockMemberIndex
operator|<
name|numBlockMembers
condition|;
name|blockMemberIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|InterfaceBlockField
modifier|&
name|vertexMember
init|=
name|vertexInterfaceBlock
operator|.
name|fields
index|[
name|blockMemberIndex
index|]
decl_stmt|;
specifier|const
name|sh
operator|::
name|InterfaceBlockField
modifier|&
name|fragmentMember
init|=
name|fragmentInterfaceBlock
operator|.
name|fields
index|[
name|blockMemberIndex
index|]
decl_stmt|;
if|if
condition|(
name|vertexMember
operator|.
name|name
operator|!=
name|fragmentMember
operator|.
name|name
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Name mismatch for field %d of interface block '%s': (in vertex: '%s', in fragment: '%s')"
argument_list|,
name|blockMemberIndex
argument_list|,
name|blockName
argument_list|,
name|vertexMember
operator|.
name|name
operator|.
name|c_str
argument_list|()
argument_list|,
name|fragmentMember
operator|.
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|std
operator|::
name|string
name|memberName
init|=
literal|"interface block '"
operator|+
name|vertexInterfaceBlock
operator|.
name|name
operator|+
literal|"' member '"
operator|+
name|vertexMember
operator|.
name|name
operator|+
literal|"'"
decl_stmt|;
if|if
condition|(
operator|!
name|linkValidateInterfaceBlockFields
argument_list|(
name|infoLog
argument_list|,
name|memberName
argument_list|,
name|vertexMember
argument_list|,
name|fragmentMember
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|linkValidateVariablesBase
name|bool
name|Program
operator|::
name|linkValidateVariablesBase
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|variableName
parameter_list|,
specifier|const
name|sh
operator|::
name|ShaderVariable
modifier|&
name|vertexVariable
parameter_list|,
specifier|const
name|sh
operator|::
name|ShaderVariable
modifier|&
name|fragmentVariable
parameter_list|,
name|bool
name|validatePrecision
parameter_list|)
block|{
if|if
condition|(
name|vertexVariable
operator|.
name|type
operator|!=
name|fragmentVariable
operator|.
name|type
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Types for %s differ between vertex and fragment shaders"
argument_list|,
name|variableName
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|vertexVariable
operator|.
name|arraySize
operator|!=
name|fragmentVariable
operator|.
name|arraySize
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Array sizes for %s differ between vertex and fragment shaders"
argument_list|,
name|variableName
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|validatePrecision
operator|&&
name|vertexVariable
operator|.
name|precision
operator|!=
name|fragmentVariable
operator|.
name|precision
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Precisions for %s differ between vertex and fragment shaders"
argument_list|,
name|variableName
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|vertexVariable
operator|.
name|fields
operator|.
name|size
argument_list|()
operator|!=
name|fragmentVariable
operator|.
name|fields
operator|.
name|size
argument_list|()
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Structure lengths for %s differ between vertex and fragment shaders"
argument_list|,
name|variableName
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|unsigned
name|int
name|numMembers
init|=
name|vertexVariable
operator|.
name|fields
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|memberIndex
init|=
literal|0
init|;
name|memberIndex
operator|<
name|numMembers
condition|;
name|memberIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|ShaderVariable
modifier|&
name|vertexMember
init|=
name|vertexVariable
operator|.
name|fields
index|[
name|memberIndex
index|]
decl_stmt|;
specifier|const
name|sh
operator|::
name|ShaderVariable
modifier|&
name|fragmentMember
init|=
name|fragmentVariable
operator|.
name|fields
index|[
name|memberIndex
index|]
decl_stmt|;
if|if
condition|(
name|vertexMember
operator|.
name|name
operator|!=
name|fragmentMember
operator|.
name|name
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Name mismatch for field '%d' of %s: (in vertex: '%s', in fragment: '%s')"
argument_list|,
name|memberIndex
argument_list|,
name|variableName
operator|.
name|c_str
argument_list|()
argument_list|,
name|vertexMember
operator|.
name|name
operator|.
name|c_str
argument_list|()
argument_list|,
name|fragmentMember
operator|.
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|std
operator|::
name|string
name|memberName
init|=
name|variableName
operator|.
name|substr
argument_list|(
literal|0
argument_list|,
name|variableName
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|+
literal|"."
operator|+
name|vertexMember
operator|.
name|name
operator|+
literal|"'"
decl_stmt|;
if|if
condition|(
operator|!
name|linkValidateVariablesBase
argument_list|(
name|infoLog
argument_list|,
name|vertexMember
operator|.
name|name
argument_list|,
name|vertexMember
argument_list|,
name|fragmentMember
argument_list|,
name|validatePrecision
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|linkValidateUniforms
name|bool
name|Program
operator|::
name|linkValidateUniforms
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|uniformName
parameter_list|,
specifier|const
name|sh
operator|::
name|Uniform
modifier|&
name|vertexUniform
parameter_list|,
specifier|const
name|sh
operator|::
name|Uniform
modifier|&
name|fragmentUniform
parameter_list|)
block|{
if|if
condition|(
operator|!
name|linkValidateVariablesBase
argument_list|(
name|infoLog
argument_list|,
name|uniformName
argument_list|,
name|vertexUniform
argument_list|,
name|fragmentUniform
argument_list|,
literal|true
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|linkValidateVaryings
name|bool
name|Program
operator|::
name|linkValidateVaryings
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|varyingName
parameter_list|,
specifier|const
name|sh
operator|::
name|Varying
modifier|&
name|vertexVarying
parameter_list|,
specifier|const
name|sh
operator|::
name|Varying
modifier|&
name|fragmentVarying
parameter_list|)
block|{
if|if
condition|(
operator|!
name|linkValidateVariablesBase
argument_list|(
name|infoLog
argument_list|,
name|varyingName
argument_list|,
name|vertexVarying
argument_list|,
name|fragmentVarying
argument_list|,
literal|false
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|sh
operator|::
name|InterpolationTypesMatch
argument_list|(
name|vertexVarying
operator|.
name|interpolation
argument_list|,
name|fragmentVarying
operator|.
name|interpolation
argument_list|)
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Interpolation types for %s differ between vertex and fragment shaders"
argument_list|,
name|varyingName
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|gatherTransformFeedbackLinkedVaryings
name|bool
name|Program
operator|::
name|gatherTransformFeedbackLinkedVaryings
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|LinkedVarying
argument_list|>
modifier|&
name|linkedVaryings
parameter_list|,
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|std
operator|::
name|string
argument_list|>
modifier|&
name|transformFeedbackVaryingNames
parameter_list|,
name|GLenum
name|transformFeedbackBufferMode
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|LinkedVarying
argument_list|>
modifier|*
name|outTransformFeedbackLinkedVaryings
parameter_list|,
specifier|const
name|Caps
modifier|&
name|caps
parameter_list|)
specifier|const
block|{
name|size_t
name|totalComponents
init|=
literal|0
decl_stmt|;
comment|// Gather the linked varyings that are used for transform feedback, they should all exist.
name|outTransformFeedbackLinkedVaryings
operator|->
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|transformFeedbackVaryingNames
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|bool
name|found
init|=
literal|false
decl_stmt|;
for|for
control|(
name|size_t
name|j
init|=
literal|0
init|;
name|j
operator|<
name|linkedVaryings
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|transformFeedbackVaryingNames
index|[
name|i
index|]
operator|==
name|linkedVaryings
index|[
name|j
index|]
operator|.
name|name
condition|)
block|{
for|for
control|(
name|size_t
name|k
init|=
literal|0
init|;
name|k
operator|<
name|outTransformFeedbackLinkedVaryings
operator|->
name|size
argument_list|()
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|outTransformFeedbackLinkedVaryings
operator|->
name|at
argument_list|(
name|k
argument_list|)
operator|.
name|name
operator|==
name|linkedVaryings
index|[
name|j
index|]
operator|.
name|name
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Two transform feedback varyings specify the same output variable (%s)."
argument_list|,
name|linkedVaryings
index|[
name|j
index|]
operator|.
name|name
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|size_t
name|componentCount
init|=
name|linkedVaryings
index|[
name|j
index|]
operator|.
name|semanticIndexCount
operator|*
literal|4
decl_stmt|;
if|if
condition|(
name|transformFeedbackBufferMode
operator|==
name|GL_SEPARATE_ATTRIBS
operator|&&
name|componentCount
operator|>
name|caps
operator|.
name|maxTransformFeedbackSeparateComponents
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Transform feedback varying's %s components (%u) exceed the maximum separate components (%u)."
argument_list|,
name|linkedVaryings
index|[
name|j
index|]
operator|.
name|name
operator|.
name|c_str
argument_list|()
argument_list|,
name|componentCount
argument_list|,
name|caps
operator|.
name|maxTransformFeedbackSeparateComponents
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|totalComponents
operator|+=
name|componentCount
expr_stmt|;
name|outTransformFeedbackLinkedVaryings
operator|->
name|push_back
argument_list|(
name|linkedVaryings
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
comment|// All transform feedback varyings are expected to exist since packVaryings checks for them.
name|ASSERT
argument_list|(
name|found
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|transformFeedbackBufferMode
operator|==
name|GL_INTERLEAVED_ATTRIBS
operator|&&
name|totalComponents
operator|>
name|caps
operator|.
name|maxTransformFeedbackInterleavedComponents
condition|)
block|{
name|infoLog
operator|.
name|append
argument_list|(
literal|"Transform feedback varying total components (%u) exceed the maximum interleaved components (%u)."
argument_list|,
name|totalComponents
argument_list|,
name|caps
operator|.
name|maxTransformFeedbackInterleavedComponents
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
block|}
end_namespace
end_unit
