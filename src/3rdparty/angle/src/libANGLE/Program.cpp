begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Program.cpp: Implements the gl::Program class. Implements GL program objects
end_comment
begin_comment
comment|// and related functionality. [OpenGL ES 2.0.24] section 2.10.3 page 28.
end_comment
begin_include
include|#
directive|include
file|"libANGLE/Program.h"
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_include
include|#
directive|include
file|"common/BitSetIterator.h"
end_include
begin_include
include|#
directive|include
file|"common/debug.h"
end_include
begin_include
include|#
directive|include
file|"common/platform.h"
end_include
begin_include
include|#
directive|include
file|"common/utilities.h"
end_include
begin_include
include|#
directive|include
file|"common/version.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/blocklayout.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Data.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/ResourceManager.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/features.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/Renderer.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/ProgramImpl.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/queryconversions.h"
end_include
begin_namespace
DECL|namespace|gl
namespace|namespace
name|gl
block|{
namespace|namespace
block|{
DECL|function|WriteShaderVar
name|void
name|WriteShaderVar
parameter_list|(
name|BinaryOutputStream
modifier|*
name|stream
parameter_list|,
specifier|const
name|sh
operator|::
name|ShaderVariable
modifier|&
name|var
parameter_list|)
block|{
name|stream
operator|->
name|writeInt
argument_list|(
name|var
operator|.
name|type
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|var
operator|.
name|precision
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeString
argument_list|(
name|var
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeString
argument_list|(
name|var
operator|.
name|mappedName
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|var
operator|.
name|arraySize
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|var
operator|.
name|staticUse
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeString
argument_list|(
name|var
operator|.
name|structName
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|var
operator|.
name|fields
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|function|LoadShaderVar
name|void
name|LoadShaderVar
parameter_list|(
name|BinaryInputStream
modifier|*
name|stream
parameter_list|,
name|sh
operator|::
name|ShaderVariable
modifier|*
name|var
parameter_list|)
block|{
name|var
operator|->
name|type
operator|=
name|stream
operator|->
name|readInt
argument_list|<
name|GLenum
argument_list|>
argument_list|()
expr_stmt|;
name|var
operator|->
name|precision
operator|=
name|stream
operator|->
name|readInt
argument_list|<
name|GLenum
argument_list|>
argument_list|()
expr_stmt|;
name|var
operator|->
name|name
operator|=
name|stream
operator|->
name|readString
argument_list|()
expr_stmt|;
name|var
operator|->
name|mappedName
operator|=
name|stream
operator|->
name|readString
argument_list|()
expr_stmt|;
name|var
operator|->
name|arraySize
operator|=
name|stream
operator|->
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
expr_stmt|;
name|var
operator|->
name|staticUse
operator|=
name|stream
operator|->
name|readBool
argument_list|()
expr_stmt|;
name|var
operator|->
name|structName
operator|=
name|stream
operator|->
name|readString
argument_list|()
expr_stmt|;
block|}
comment|// This simplified cast function doesn't need to worry about advanced concepts like
comment|// depth range values, or casting to bool.
template|template
parameter_list|<
name|typename
name|DestT
parameter_list|,
name|typename
name|SrcT
parameter_list|>
name|DestT
name|UniformStateQueryCast
parameter_list|(
name|SrcT
name|value
parameter_list|)
function_decl|;
comment|// From-Float-To-Integer Casts
template|template
parameter_list|<>
DECL|function|UniformStateQueryCast
name|GLint
name|UniformStateQueryCast
parameter_list|(
name|GLfloat
name|value
parameter_list|)
block|{
return|return
name|clampCast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|roundf
argument_list|(
name|value
argument_list|)
argument_list|)
return|;
block|}
template|template
parameter_list|<>
DECL|function|UniformStateQueryCast
name|GLuint
name|UniformStateQueryCast
parameter_list|(
name|GLfloat
name|value
parameter_list|)
block|{
return|return
name|clampCast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|roundf
argument_list|(
name|value
argument_list|)
argument_list|)
return|;
block|}
comment|// From-Integer-to-Integer Casts
template|template
parameter_list|<>
DECL|function|UniformStateQueryCast
name|GLint
name|UniformStateQueryCast
parameter_list|(
name|GLuint
name|value
parameter_list|)
block|{
return|return
name|clampCast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|value
argument_list|)
return|;
block|}
template|template
parameter_list|<>
DECL|function|UniformStateQueryCast
name|GLuint
name|UniformStateQueryCast
parameter_list|(
name|GLint
name|value
parameter_list|)
block|{
return|return
name|clampCast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|// From-Boolean-to-Anything Casts
template|template
parameter_list|<>
DECL|function|UniformStateQueryCast
name|GLfloat
name|UniformStateQueryCast
parameter_list|(
name|GLboolean
name|value
parameter_list|)
block|{
return|return
operator|(
name|value
operator|==
name|GL_TRUE
condition|?
literal|1.0f
else|:
literal|0.0f
operator|)
return|;
block|}
template|template
parameter_list|<>
DECL|function|UniformStateQueryCast
name|GLint
name|UniformStateQueryCast
parameter_list|(
name|GLboolean
name|value
parameter_list|)
block|{
return|return
operator|(
name|value
operator|==
name|GL_TRUE
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
template|template
parameter_list|<>
DECL|function|UniformStateQueryCast
name|GLuint
name|UniformStateQueryCast
parameter_list|(
name|GLboolean
name|value
parameter_list|)
block|{
return|return
operator|(
name|value
operator|==
name|GL_TRUE
condition|?
literal|1u
else|:
literal|0u
operator|)
return|;
block|}
comment|// Default to static_cast
template|template
parameter_list|<
name|typename
name|DestT
parameter_list|,
name|typename
name|SrcT
parameter_list|>
DECL|function|UniformStateQueryCast
name|DestT
name|UniformStateQueryCast
parameter_list|(
name|SrcT
name|value
parameter_list|)
block|{
return|return
cast|static_cast
argument_list|<
name|DestT
argument_list|>
argument_list|(
name|value
argument_list|)
return|;
block|}
template|template
parameter_list|<
name|typename
name|SrcT
parameter_list|,
name|typename
name|DestT
parameter_list|>
DECL|function|UniformStateQueryCastLoop
name|void
name|UniformStateQueryCastLoop
parameter_list|(
name|DestT
modifier|*
name|dataOut
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|srcPointer
parameter_list|,
name|int
name|components
parameter_list|)
block|{
for|for
control|(
name|int
name|comp
init|=
literal|0
init|;
name|comp
operator|<
name|components
condition|;
operator|++
name|comp
control|)
block|{
comment|// We only work with strides of 4 bytes for uniform components. (GLfloat/GLint)
comment|// Don't use SrcT stride directly since GLboolean has a stride of 1 byte.
name|size_t
name|offset
init|=
name|comp
operator|*
literal|4
decl_stmt|;
specifier|const
name|SrcT
modifier|*
name|typedSrcPointer
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|SrcT
operator|*
argument_list|>
argument_list|(
operator|&
name|srcPointer
index|[
name|offset
index|]
argument_list|)
decl_stmt|;
name|dataOut
index|[
name|comp
index|]
operator|=
name|UniformStateQueryCast
argument_list|<
name|DestT
argument_list|>
argument_list|(
operator|*
name|typedSrcPointer
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|UniformInList
name|bool
name|UniformInList
parameter_list|(
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|LinkedUniform
argument_list|>
modifier|&
name|list
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|name
parameter_list|)
block|{
for|for
control|(
specifier|const
name|LinkedUniform
modifier|&
name|uniform
range|:
name|list
control|)
block|{
if|if
condition|(
name|uniform
operator|.
name|name
operator|==
name|name
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
comment|// anonymous namespace
DECL|member|g_fakepath
specifier|const
name|char
modifier|*
specifier|const
name|g_fakepath
init|=
literal|"C:\\fakepath"
decl_stmt|;
DECL|function|AttributeBindings
name|AttributeBindings
operator|::
name|AttributeBindings
parameter_list|()
block|{ }
DECL|function|~AttributeBindings
name|AttributeBindings
operator|::
name|~
name|AttributeBindings
parameter_list|()
block|{ }
DECL|function|InfoLog
name|InfoLog
operator|::
name|InfoLog
parameter_list|()
block|{ }
DECL|function|~InfoLog
name|InfoLog
operator|::
name|~
name|InfoLog
parameter_list|()
block|{ }
DECL|function|getLength
name|size_t
name|InfoLog
operator|::
name|getLength
parameter_list|()
specifier|const
block|{
specifier|const
name|std
operator|::
name|string
modifier|&
name|logString
init|=
name|mStream
operator|.
name|str
argument_list|()
decl_stmt|;
return|return
name|logString
operator|.
name|empty
argument_list|()
condition|?
literal|0
else|:
name|logString
operator|.
name|length
argument_list|()
operator|+
literal|1
return|;
block|}
DECL|function|getLog
name|void
name|InfoLog
operator|::
name|getLog
parameter_list|(
name|GLsizei
name|bufSize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|,
name|char
modifier|*
name|infoLog
parameter_list|)
specifier|const
block|{
name|size_t
name|index
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bufSize
operator|>
literal|0
condition|)
block|{
specifier|const
name|std
operator|::
name|string
name|str
argument_list|(
name|mStream
operator|.
name|str
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|str
operator|.
name|empty
argument_list|()
condition|)
block|{
name|index
operator|=
name|std
operator|::
name|min
argument_list|(
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|bufSize
argument_list|)
operator|-
literal|1
argument_list|,
name|str
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|infoLog
argument_list|,
name|str
operator|.
name|c_str
argument_list|()
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
name|infoLog
index|[
name|index
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
cast|static_cast
argument_list|<
name|GLsizei
argument_list|>
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
block|}
comment|// append a santized message to the program info log.
comment|// The D3D compiler includes a fake file path in some of the warning or error
comment|// messages, so lets remove all occurrences of this fake file path from the log.
DECL|function|appendSanitized
name|void
name|InfoLog
operator|::
name|appendSanitized
parameter_list|(
specifier|const
name|char
modifier|*
name|message
parameter_list|)
block|{
name|std
operator|::
name|string
name|msg
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|size_t
name|found
decl_stmt|;
do|do
block|{
name|found
operator|=
name|msg
operator|.
name|find
argument_list|(
name|g_fakepath
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|!=
name|std
operator|::
name|string
operator|::
name|npos
condition|)
block|{
name|msg
operator|.
name|erase
argument_list|(
name|found
argument_list|,
name|strlen
argument_list|(
name|g_fakepath
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|found
operator|!=
name|std
operator|::
name|string
operator|::
name|npos
condition|)
do|;
name|mStream
operator|<<
name|message
operator|<<
name|std
operator|::
name|endl
expr_stmt|;
block|}
DECL|function|reset
name|void
name|InfoLog
operator|::
name|reset
parameter_list|()
block|{ }
DECL|function|VariableLocation
name|VariableLocation
operator|::
name|VariableLocation
parameter_list|()
member_init_list|:
name|name
argument_list|()
member_init_list|,
name|element
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|index
argument_list|(
literal|0
argument_list|)
block|{ }
DECL|function|VariableLocation
name|VariableLocation
operator|::
name|VariableLocation
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|name
parameter_list|,
name|unsigned
name|int
name|element
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|)
member_init_list|:
name|name
argument_list|(
name|name
argument_list|)
member_init_list|,
name|element
argument_list|(
name|element
argument_list|)
member_init_list|,
name|index
argument_list|(
name|index
argument_list|)
block|{ }
DECL|function|Data
name|Program
operator|::
name|Data
operator|::
name|Data
parameter_list|()
member_init_list|:
name|mLabel
argument_list|()
member_init_list|,
name|mAttachedFragmentShader
argument_list|(
literal|nullptr
argument_list|)
member_init_list|,
name|mAttachedVertexShader
argument_list|(
literal|nullptr
argument_list|)
member_init_list|,
name|mTransformFeedbackBufferMode
argument_list|(
name|GL_INTERLEAVED_ATTRIBS
argument_list|)
member_init_list|,
name|mBinaryRetrieveableHint
argument_list|(
literal|false
argument_list|)
block|{ }
DECL|function|~Data
name|Program
operator|::
name|Data
operator|::
name|~
name|Data
parameter_list|()
block|{
if|if
condition|(
name|mAttachedVertexShader
operator|!=
literal|nullptr
condition|)
block|{
name|mAttachedVertexShader
operator|->
name|release
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|mAttachedFragmentShader
operator|!=
literal|nullptr
condition|)
block|{
name|mAttachedFragmentShader
operator|->
name|release
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|getLabel
specifier|const
name|std
operator|::
name|string
modifier|&
name|Program
operator|::
name|Data
operator|::
name|getLabel
parameter_list|()
block|{
return|return
name|mLabel
return|;
block|}
DECL|function|getUniformByName
specifier|const
name|LinkedUniform
modifier|*
name|Program
operator|::
name|Data
operator|::
name|getUniformByName
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|name
parameter_list|)
specifier|const
block|{
for|for
control|(
specifier|const
name|LinkedUniform
modifier|&
name|linkedUniform
range|:
name|mUniforms
control|)
block|{
if|if
condition|(
name|linkedUniform
operator|.
name|name
operator|==
name|name
condition|)
block|{
return|return
operator|&
name|linkedUniform
return|;
block|}
block|}
return|return
literal|nullptr
return|;
block|}
DECL|function|getUniformLocation
name|GLint
name|Program
operator|::
name|Data
operator|::
name|getUniformLocation
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|name
parameter_list|)
specifier|const
block|{
name|size_t
name|subscript
init|=
name|GL_INVALID_INDEX
decl_stmt|;
name|std
operator|::
name|string
name|baseName
init|=
name|gl
operator|::
name|ParseUniformName
argument_list|(
name|name
argument_list|,
operator|&
name|subscript
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|location
init|=
literal|0
init|;
name|location
operator|<
name|mUniformLocations
operator|.
name|size
argument_list|()
condition|;
operator|++
name|location
control|)
block|{
specifier|const
name|VariableLocation
modifier|&
name|uniformLocation
init|=
name|mUniformLocations
index|[
name|location
index|]
decl_stmt|;
specifier|const
name|LinkedUniform
modifier|&
name|uniform
init|=
name|mUniforms
index|[
name|uniformLocation
operator|.
name|index
index|]
decl_stmt|;
if|if
condition|(
name|uniform
operator|.
name|name
operator|==
name|baseName
condition|)
block|{
if|if
condition|(
operator|(
name|uniform
operator|.
name|isArray
argument_list|()
operator|&&
name|uniformLocation
operator|.
name|element
operator|==
name|subscript
operator|)
operator|||
operator|(
name|subscript
operator|==
name|GL_INVALID_INDEX
operator|)
condition|)
block|{
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|location
argument_list|)
return|;
block|}
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
DECL|function|getUniformIndex
name|GLuint
name|Program
operator|::
name|Data
operator|::
name|getUniformIndex
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|name
parameter_list|)
specifier|const
block|{
name|size_t
name|subscript
init|=
name|GL_INVALID_INDEX
decl_stmt|;
name|std
operator|::
name|string
name|baseName
init|=
name|gl
operator|::
name|ParseUniformName
argument_list|(
name|name
argument_list|,
operator|&
name|subscript
argument_list|)
decl_stmt|;
comment|// The app is not allowed to specify array indices other than 0 for arrays of basic types
if|if
condition|(
name|subscript
operator|!=
literal|0
operator|&&
name|subscript
operator|!=
name|GL_INVALID_INDEX
condition|)
block|{
return|return
name|GL_INVALID_INDEX
return|;
block|}
for|for
control|(
name|size_t
name|index
init|=
literal|0
init|;
name|index
operator|<
name|mUniforms
operator|.
name|size
argument_list|()
condition|;
name|index
operator|++
control|)
block|{
specifier|const
name|LinkedUniform
modifier|&
name|uniform
init|=
name|mUniforms
index|[
name|index
index|]
decl_stmt|;
if|if
condition|(
name|uniform
operator|.
name|name
operator|==
name|baseName
condition|)
block|{
if|if
condition|(
name|uniform
operator|.
name|isArray
argument_list|()
operator|||
name|subscript
operator|==
name|GL_INVALID_INDEX
condition|)
block|{
return|return
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|index
argument_list|)
return|;
block|}
block|}
block|}
return|return
name|GL_INVALID_INDEX
return|;
block|}
DECL|function|Program
name|Program
operator|::
name|Program
parameter_list|(
name|rx
operator|::
name|ImplFactory
modifier|*
name|factory
parameter_list|,
name|ResourceManager
modifier|*
name|manager
parameter_list|,
name|GLuint
name|handle
parameter_list|)
member_init_list|:
name|mProgram
argument_list|(
name|factory
operator|->
name|createProgram
argument_list|(
name|mData
argument_list|)
argument_list|)
member_init_list|,
name|mValidated
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mLinked
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mDeleteStatus
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mRefCount
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mResourceManager
argument_list|(
name|manager
argument_list|)
member_init_list|,
name|mHandle
argument_list|(
name|handle
argument_list|)
member_init_list|,
name|mSamplerUniformRange
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|{
name|ASSERT
argument_list|(
name|mProgram
argument_list|)
expr_stmt|;
name|resetUniformBlockBindings
argument_list|()
expr_stmt|;
name|unlink
argument_list|()
expr_stmt|;
block|}
DECL|function|~Program
name|Program
operator|::
name|~
name|Program
parameter_list|()
block|{
name|unlink
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|SafeDelete
argument_list|(
name|mProgram
argument_list|)
expr_stmt|;
block|}
DECL|function|setLabel
name|void
name|Program
operator|::
name|setLabel
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|label
parameter_list|)
block|{
name|mData
operator|.
name|mLabel
operator|=
name|label
expr_stmt|;
block|}
DECL|function|getLabel
specifier|const
name|std
operator|::
name|string
modifier|&
name|Program
operator|::
name|getLabel
parameter_list|()
specifier|const
block|{
return|return
name|mData
operator|.
name|mLabel
return|;
block|}
DECL|function|attachShader
name|bool
name|Program
operator|::
name|attachShader
parameter_list|(
name|Shader
modifier|*
name|shader
parameter_list|)
block|{
if|if
condition|(
name|shader
operator|->
name|getType
argument_list|()
operator|==
name|GL_VERTEX_SHADER
condition|)
block|{
if|if
condition|(
name|mData
operator|.
name|mAttachedVertexShader
condition|)
block|{
return|return
literal|false
return|;
block|}
name|mData
operator|.
name|mAttachedVertexShader
operator|=
name|shader
expr_stmt|;
name|mData
operator|.
name|mAttachedVertexShader
operator|->
name|addRef
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shader
operator|->
name|getType
argument_list|()
operator|==
name|GL_FRAGMENT_SHADER
condition|)
block|{
if|if
condition|(
name|mData
operator|.
name|mAttachedFragmentShader
condition|)
block|{
return|return
literal|false
return|;
block|}
name|mData
operator|.
name|mAttachedFragmentShader
operator|=
name|shader
expr_stmt|;
name|mData
operator|.
name|mAttachedFragmentShader
operator|->
name|addRef
argument_list|()
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|detachShader
name|bool
name|Program
operator|::
name|detachShader
parameter_list|(
name|Shader
modifier|*
name|shader
parameter_list|)
block|{
if|if
condition|(
name|shader
operator|->
name|getType
argument_list|()
operator|==
name|GL_VERTEX_SHADER
condition|)
block|{
if|if
condition|(
name|mData
operator|.
name|mAttachedVertexShader
operator|!=
name|shader
condition|)
block|{
return|return
literal|false
return|;
block|}
name|shader
operator|->
name|release
argument_list|()
expr_stmt|;
name|mData
operator|.
name|mAttachedVertexShader
operator|=
literal|nullptr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shader
operator|->
name|getType
argument_list|()
operator|==
name|GL_FRAGMENT_SHADER
condition|)
block|{
if|if
condition|(
name|mData
operator|.
name|mAttachedFragmentShader
operator|!=
name|shader
condition|)
block|{
return|return
literal|false
return|;
block|}
name|shader
operator|->
name|release
argument_list|()
expr_stmt|;
name|mData
operator|.
name|mAttachedFragmentShader
operator|=
literal|nullptr
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|getAttachedShadersCount
name|int
name|Program
operator|::
name|getAttachedShadersCount
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|mData
operator|.
name|mAttachedVertexShader
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
name|mData
operator|.
name|mAttachedFragmentShader
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
DECL|function|bindAttributeLocation
name|void
name|AttributeBindings
operator|::
name|bindAttributeLocation
parameter_list|(
name|GLuint
name|index
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|index
operator|<
name|MAX_VERTEX_ATTRIBS
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|i
operator|++
control|)
block|{
name|mAttributeBinding
index|[
name|i
index|]
operator|.
name|erase
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|mAttributeBinding
index|[
name|index
index|]
operator|.
name|insert
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|bindAttributeLocation
name|void
name|Program
operator|::
name|bindAttributeLocation
parameter_list|(
name|GLuint
name|index
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|mAttributeBindings
operator|.
name|bindAttributeLocation
argument_list|(
name|index
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|// Links the HLSL code of the vertex and pixel shader by matching up their varyings,
comment|// compiling them into binaries, determining the attribute mappings, and collecting
comment|// a list of uniforms
DECL|function|link
name|Error
name|Program
operator|::
name|link
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|)
block|{
name|unlink
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|mInfoLog
operator|.
name|reset
argument_list|()
expr_stmt|;
name|resetUniformBlockBindings
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|mData
operator|.
name|mAttachedFragmentShader
operator|||
operator|!
name|mData
operator|.
name|mAttachedFragmentShader
operator|->
name|isCompiled
argument_list|()
condition|)
block|{
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|mData
operator|.
name|mAttachedFragmentShader
operator|->
name|getType
argument_list|()
operator|==
name|GL_FRAGMENT_SHADER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mData
operator|.
name|mAttachedVertexShader
operator|||
operator|!
name|mData
operator|.
name|mAttachedVertexShader
operator|->
name|isCompiled
argument_list|()
condition|)
block|{
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|mData
operator|.
name|mAttachedVertexShader
operator|->
name|getType
argument_list|()
operator|==
name|GL_VERTEX_SHADER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|linkAttributes
argument_list|(
name|data
argument_list|,
name|mInfoLog
argument_list|,
name|mAttributeBindings
argument_list|,
name|mData
operator|.
name|mAttachedVertexShader
argument_list|)
condition|)
block|{
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|linkVaryings
argument_list|(
name|mInfoLog
argument_list|,
name|mData
operator|.
name|mAttachedVertexShader
argument_list|,
name|mData
operator|.
name|mAttachedFragmentShader
argument_list|)
condition|)
block|{
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|linkUniforms
argument_list|(
name|mInfoLog
argument_list|,
operator|*
name|data
operator|.
name|caps
argument_list|)
condition|)
block|{
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|linkUniformBlocks
argument_list|(
name|mInfoLog
argument_list|,
operator|*
name|data
operator|.
name|caps
argument_list|)
condition|)
block|{
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
specifier|const
specifier|auto
modifier|&
name|mergedVaryings
init|=
name|getMergedVaryings
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|linkValidateTransformFeedback
argument_list|(
name|mInfoLog
argument_list|,
name|mergedVaryings
argument_list|,
operator|*
name|data
operator|.
name|caps
argument_list|)
condition|)
block|{
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
name|linkOutputVariables
argument_list|()
expr_stmt|;
name|rx
operator|::
name|LinkResult
name|result
init|=
name|mProgram
operator|->
name|link
argument_list|(
name|data
argument_list|,
name|mInfoLog
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|.
name|error
operator|.
name|isError
argument_list|()
operator|||
operator|!
name|result
operator|.
name|linkSuccess
condition|)
block|{
return|return
name|result
operator|.
name|error
return|;
block|}
name|gatherTransformFeedbackVaryings
argument_list|(
name|mergedVaryings
argument_list|)
expr_stmt|;
name|gatherInterfaceBlockInfo
argument_list|()
expr_stmt|;
name|mLinked
operator|=
literal|true
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|getAttributeBinding
name|int
name|AttributeBindings
operator|::
name|getAttributeBinding
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|name
parameter_list|)
specifier|const
block|{
for|for
control|(
name|int
name|location
init|=
literal|0
init|;
name|location
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|location
operator|++
control|)
block|{
if|if
condition|(
name|mAttributeBinding
index|[
name|location
index|]
operator|.
name|find
argument_list|(
name|name
argument_list|)
operator|!=
name|mAttributeBinding
index|[
name|location
index|]
operator|.
name|end
argument_list|()
condition|)
block|{
return|return
name|location
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|// Returns the program object to an unlinked state, before re-linking, or at destruction
DECL|function|unlink
name|void
name|Program
operator|::
name|unlink
parameter_list|(
name|bool
name|destroy
parameter_list|)
block|{
if|if
condition|(
name|destroy
condition|)
comment|// Object being destructed
block|{
if|if
condition|(
name|mData
operator|.
name|mAttachedFragmentShader
condition|)
block|{
name|mData
operator|.
name|mAttachedFragmentShader
operator|->
name|release
argument_list|()
expr_stmt|;
name|mData
operator|.
name|mAttachedFragmentShader
operator|=
literal|nullptr
expr_stmt|;
block|}
if|if
condition|(
name|mData
operator|.
name|mAttachedVertexShader
condition|)
block|{
name|mData
operator|.
name|mAttachedVertexShader
operator|->
name|release
argument_list|()
expr_stmt|;
name|mData
operator|.
name|mAttachedVertexShader
operator|=
literal|nullptr
expr_stmt|;
block|}
block|}
name|mData
operator|.
name|mAttributes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mData
operator|.
name|mActiveAttribLocationsMask
operator|.
name|reset
argument_list|()
expr_stmt|;
name|mData
operator|.
name|mTransformFeedbackVaryingVars
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mData
operator|.
name|mUniforms
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mData
operator|.
name|mUniformLocations
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mData
operator|.
name|mUniformBlocks
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mData
operator|.
name|mOutputVariables
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mValidated
operator|=
literal|false
expr_stmt|;
name|mLinked
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|isLinked
name|bool
name|Program
operator|::
name|isLinked
parameter_list|()
specifier|const
block|{
return|return
name|mLinked
return|;
block|}
DECL|function|loadBinary
name|Error
name|Program
operator|::
name|loadBinary
parameter_list|(
name|GLenum
name|binaryFormat
parameter_list|,
specifier|const
name|void
modifier|*
name|binary
parameter_list|,
name|GLsizei
name|length
parameter_list|)
block|{
name|unlink
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|#
directive|if
name|ANGLE_PROGRAM_BINARY_LOAD
operator|!=
name|ANGLE_ENABLED
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
else|#
directive|else
name|ASSERT
argument_list|(
name|binaryFormat
operator|==
name|GL_PROGRAM_BINARY_ANGLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|binaryFormat
operator|!=
name|GL_PROGRAM_BINARY_ANGLE
condition|)
block|{
name|mInfoLog
operator|<<
literal|"Invalid program binary format."
expr_stmt|;
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
name|BinaryInputStream
name|stream
argument_list|(
name|binary
argument_list|,
name|length
argument_list|)
decl_stmt|;
name|int
name|majorVersion
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|int
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|minorVersion
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|int
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|majorVersion
operator|!=
name|ANGLE_MAJOR_VERSION
operator|||
name|minorVersion
operator|!=
name|ANGLE_MINOR_VERSION
condition|)
block|{
name|mInfoLog
operator|<<
literal|"Invalid program binary version."
expr_stmt|;
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
name|unsigned
name|char
name|commitString
index|[
name|ANGLE_COMMIT_HASH_SIZE
index|]
decl_stmt|;
name|stream
operator|.
name|readBytes
argument_list|(
name|commitString
argument_list|,
name|ANGLE_COMMIT_HASH_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|commitString
argument_list|,
name|ANGLE_COMMIT_HASH
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
operator|*
name|ANGLE_COMMIT_HASH_SIZE
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mInfoLog
operator|<<
literal|"Invalid program binary version."
expr_stmt|;
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
assert|static_assert
argument_list|(
name|MAX_VERTEX_ATTRIBS
operator|<=
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
operator|*
literal|8
argument_list|,
literal|"Too many vertex attribs for mask"
argument_list|)
assert|;
name|mData
operator|.
name|mActiveAttribLocationsMask
operator|=
name|stream
operator|.
name|readInt
argument_list|<
name|unsigned
name|long
argument_list|>
argument_list|()
expr_stmt|;
name|unsigned
name|int
name|attribCount
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|mData
operator|.
name|mAttributes
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|attribIndex
init|=
literal|0
init|;
name|attribIndex
operator|<
name|attribCount
condition|;
operator|++
name|attribIndex
control|)
block|{
name|sh
operator|::
name|Attribute
name|attrib
decl_stmt|;
name|LoadShaderVar
argument_list|(
operator|&
name|stream
argument_list|,
operator|&
name|attrib
argument_list|)
expr_stmt|;
name|attrib
operator|.
name|location
operator|=
name|stream
operator|.
name|readInt
argument_list|<
name|int
argument_list|>
argument_list|()
expr_stmt|;
name|mData
operator|.
name|mAttributes
operator|.
name|push_back
argument_list|(
name|attrib
argument_list|)
expr_stmt|;
block|}
name|unsigned
name|int
name|uniformCount
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|mData
operator|.
name|mUniforms
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|uniformIndex
init|=
literal|0
init|;
name|uniformIndex
operator|<
name|uniformCount
condition|;
operator|++
name|uniformIndex
control|)
block|{
name|LinkedUniform
name|uniform
decl_stmt|;
name|LoadShaderVar
argument_list|(
operator|&
name|stream
argument_list|,
operator|&
name|uniform
argument_list|)
expr_stmt|;
name|uniform
operator|.
name|blockIndex
operator|=
name|stream
operator|.
name|readInt
argument_list|<
name|int
argument_list|>
argument_list|()
expr_stmt|;
name|uniform
operator|.
name|blockInfo
operator|.
name|offset
operator|=
name|stream
operator|.
name|readInt
argument_list|<
name|int
argument_list|>
argument_list|()
expr_stmt|;
name|uniform
operator|.
name|blockInfo
operator|.
name|arrayStride
operator|=
name|stream
operator|.
name|readInt
argument_list|<
name|int
argument_list|>
argument_list|()
expr_stmt|;
name|uniform
operator|.
name|blockInfo
operator|.
name|matrixStride
operator|=
name|stream
operator|.
name|readInt
argument_list|<
name|int
argument_list|>
argument_list|()
expr_stmt|;
name|uniform
operator|.
name|blockInfo
operator|.
name|isRowMajorMatrix
operator|=
name|stream
operator|.
name|readBool
argument_list|()
expr_stmt|;
name|mData
operator|.
name|mUniforms
operator|.
name|push_back
argument_list|(
name|uniform
argument_list|)
expr_stmt|;
block|}
specifier|const
name|unsigned
name|int
name|uniformIndexCount
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|mData
operator|.
name|mUniformLocations
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|uniformIndexIndex
init|=
literal|0
init|;
name|uniformIndexIndex
operator|<
name|uniformIndexCount
condition|;
name|uniformIndexIndex
operator|++
control|)
block|{
name|VariableLocation
name|variable
decl_stmt|;
name|stream
operator|.
name|readString
argument_list|(
operator|&
name|variable
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|variable
operator|.
name|element
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|variable
operator|.
name|index
argument_list|)
expr_stmt|;
name|mData
operator|.
name|mUniformLocations
operator|.
name|push_back
argument_list|(
name|variable
argument_list|)
expr_stmt|;
block|}
name|unsigned
name|int
name|uniformBlockCount
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|mData
operator|.
name|mUniformBlocks
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|uniformBlockIndex
init|=
literal|0
init|;
name|uniformBlockIndex
operator|<
name|uniformBlockCount
condition|;
operator|++
name|uniformBlockIndex
control|)
block|{
name|UniformBlock
name|uniformBlock
decl_stmt|;
name|stream
operator|.
name|readString
argument_list|(
operator|&
name|uniformBlock
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readBool
argument_list|(
operator|&
name|uniformBlock
operator|.
name|isArray
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|uniformBlock
operator|.
name|arrayElement
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|uniformBlock
operator|.
name|dataSize
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readBool
argument_list|(
operator|&
name|uniformBlock
operator|.
name|vertexStaticUse
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readBool
argument_list|(
operator|&
name|uniformBlock
operator|.
name|fragmentStaticUse
argument_list|)
expr_stmt|;
name|unsigned
name|int
name|numMembers
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|blockMemberIndex
init|=
literal|0
init|;
name|blockMemberIndex
operator|<
name|numMembers
condition|;
name|blockMemberIndex
operator|++
control|)
block|{
name|uniformBlock
operator|.
name|memberUniformIndexes
operator|.
name|push_back
argument_list|(
argument|stream.readInt<unsigned int>()
argument_list|)
expr_stmt|;
block|}
name|mData
operator|.
name|mUniformBlocks
operator|.
name|push_back
argument_list|(
name|uniformBlock
argument_list|)
expr_stmt|;
block|}
name|unsigned
name|int
name|transformFeedbackVaryingCount
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|mData
operator|.
name|mTransformFeedbackVaryingVars
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|transformFeedbackVaryingIndex
init|=
literal|0
init|;
name|transformFeedbackVaryingIndex
operator|<
name|transformFeedbackVaryingCount
condition|;
operator|++
name|transformFeedbackVaryingIndex
control|)
block|{
name|sh
operator|::
name|Varying
name|varying
decl_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|varying
operator|.
name|arraySize
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|varying
operator|.
name|type
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readString
argument_list|(
operator|&
name|varying
operator|.
name|name
argument_list|)
expr_stmt|;
name|mData
operator|.
name|mTransformFeedbackVaryingVars
operator|.
name|push_back
argument_list|(
name|varying
argument_list|)
expr_stmt|;
block|}
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|mData
operator|.
name|mTransformFeedbackBufferMode
argument_list|)
expr_stmt|;
name|unsigned
name|int
name|outputVarCount
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|outputIndex
init|=
literal|0
init|;
name|outputIndex
operator|<
name|outputVarCount
condition|;
operator|++
name|outputIndex
control|)
block|{
name|int
name|locationIndex
init|=
name|stream
operator|.
name|readInt
argument_list|<
name|int
argument_list|>
argument_list|()
decl_stmt|;
name|VariableLocation
name|locationData
decl_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|locationData
operator|.
name|element
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|locationData
operator|.
name|index
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readString
argument_list|(
operator|&
name|locationData
operator|.
name|name
argument_list|)
expr_stmt|;
name|mData
operator|.
name|mOutputVariables
index|[
name|locationIndex
index|]
operator|=
name|locationData
expr_stmt|;
block|}
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|mSamplerUniformRange
operator|.
name|start
argument_list|)
expr_stmt|;
name|stream
operator|.
name|readInt
argument_list|(
operator|&
name|mSamplerUniformRange
operator|.
name|end
argument_list|)
expr_stmt|;
name|rx
operator|::
name|LinkResult
name|result
init|=
name|mProgram
operator|->
name|load
argument_list|(
name|mInfoLog
argument_list|,
operator|&
name|stream
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|.
name|error
operator|.
name|isError
argument_list|()
operator|||
operator|!
name|result
operator|.
name|linkSuccess
condition|)
block|{
return|return
name|result
operator|.
name|error
return|;
block|}
name|mLinked
operator|=
literal|true
expr_stmt|;
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
endif|#
directive|endif
comment|// #if ANGLE_PROGRAM_BINARY_LOAD == ANGLE_ENABLED
block|}
DECL|function|saveBinary
name|Error
name|Program
operator|::
name|saveBinary
parameter_list|(
name|GLenum
modifier|*
name|binaryFormat
parameter_list|,
name|void
modifier|*
name|binary
parameter_list|,
name|GLsizei
name|bufSize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|binaryFormat
condition|)
block|{
operator|*
name|binaryFormat
operator|=
name|GL_PROGRAM_BINARY_ANGLE
expr_stmt|;
block|}
name|BinaryOutputStream
name|stream
decl_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|ANGLE_MAJOR_VERSION
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|ANGLE_MINOR_VERSION
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeBytes
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|ANGLE_COMMIT_HASH
argument_list|)
argument_list|,
name|ANGLE_COMMIT_HASH_SIZE
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|mData
operator|.
name|mActiveAttribLocationsMask
operator|.
name|to_ulong
argument_list|()
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|mData
operator|.
name|mAttributes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
specifier|const
name|sh
operator|::
name|Attribute
modifier|&
name|attrib
range|:
name|mData
operator|.
name|mAttributes
control|)
block|{
name|WriteShaderVar
argument_list|(
operator|&
name|stream
argument_list|,
name|attrib
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|attrib
operator|.
name|location
argument_list|)
expr_stmt|;
block|}
name|stream
operator|.
name|writeInt
argument_list|(
name|mData
operator|.
name|mUniforms
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
specifier|const
name|gl
operator|::
name|LinkedUniform
modifier|&
name|uniform
range|:
name|mData
operator|.
name|mUniforms
control|)
block|{
name|WriteShaderVar
argument_list|(
operator|&
name|stream
argument_list|,
name|uniform
argument_list|)
expr_stmt|;
comment|// FIXME: referenced
name|stream
operator|.
name|writeInt
argument_list|(
name|uniform
operator|.
name|blockIndex
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|uniform
operator|.
name|blockInfo
operator|.
name|offset
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|uniform
operator|.
name|blockInfo
operator|.
name|arrayStride
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|uniform
operator|.
name|blockInfo
operator|.
name|matrixStride
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|uniform
operator|.
name|blockInfo
operator|.
name|isRowMajorMatrix
argument_list|)
expr_stmt|;
block|}
name|stream
operator|.
name|writeInt
argument_list|(
name|mData
operator|.
name|mUniformLocations
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|variable
range|:
name|mData
operator|.
name|mUniformLocations
control|)
block|{
name|stream
operator|.
name|writeString
argument_list|(
name|variable
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|variable
operator|.
name|element
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|variable
operator|.
name|index
argument_list|)
expr_stmt|;
block|}
name|stream
operator|.
name|writeInt
argument_list|(
name|mData
operator|.
name|mUniformBlocks
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
specifier|const
name|UniformBlock
modifier|&
name|uniformBlock
range|:
name|mData
operator|.
name|mUniformBlocks
control|)
block|{
name|stream
operator|.
name|writeString
argument_list|(
name|uniformBlock
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|uniformBlock
operator|.
name|isArray
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|uniformBlock
operator|.
name|arrayElement
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|uniformBlock
operator|.
name|dataSize
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|uniformBlock
operator|.
name|vertexStaticUse
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|uniformBlock
operator|.
name|fragmentStaticUse
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|uniformBlock
operator|.
name|memberUniformIndexes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|memberUniformIndex
range|:
name|uniformBlock
operator|.
name|memberUniformIndexes
control|)
block|{
name|stream
operator|.
name|writeInt
argument_list|(
name|memberUniformIndex
argument_list|)
expr_stmt|;
block|}
block|}
name|stream
operator|.
name|writeInt
argument_list|(
name|mData
operator|.
name|mTransformFeedbackVaryingVars
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
specifier|const
name|sh
operator|::
name|Varying
modifier|&
name|varying
range|:
name|mData
operator|.
name|mTransformFeedbackVaryingVars
control|)
block|{
name|stream
operator|.
name|writeInt
argument_list|(
name|varying
operator|.
name|arraySize
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|varying
operator|.
name|type
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeString
argument_list|(
name|varying
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|stream
operator|.
name|writeInt
argument_list|(
name|mData
operator|.
name|mTransformFeedbackBufferMode
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|mData
operator|.
name|mOutputVariables
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|outputPair
range|:
name|mData
operator|.
name|mOutputVariables
control|)
block|{
name|stream
operator|.
name|writeInt
argument_list|(
name|outputPair
operator|.
name|first
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|outputPair
operator|.
name|second
operator|.
name|element
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|outputPair
operator|.
name|second
operator|.
name|index
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeString
argument_list|(
name|outputPair
operator|.
name|second
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|stream
operator|.
name|writeInt
argument_list|(
name|mSamplerUniformRange
operator|.
name|start
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeInt
argument_list|(
name|mSamplerUniformRange
operator|.
name|end
argument_list|)
expr_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|mProgram
operator|->
name|save
argument_list|(
operator|&
name|stream
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|GLsizei
name|streamLength
init|=
cast|static_cast
argument_list|<
name|GLsizei
argument_list|>
argument_list|(
name|stream
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|void
modifier|*
name|streamData
init|=
name|stream
operator|.
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
name|streamLength
operator|>
name|bufSize
condition|)
block|{
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
literal|0
expr_stmt|;
block|}
comment|// TODO: This should be moved to the validation layer but computing the size of the binary before saving
comment|// it causes the save to happen twice.  It may be possible to write the binary to a separate buffer, validate
comment|// sizes and then copy it.
return|return
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
name|binary
condition|)
block|{
name|char
modifier|*
name|ptr
init|=
cast|reinterpret_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
name|binary
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
name|streamData
argument_list|,
name|streamLength
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|streamLength
expr_stmt|;
name|ASSERT
argument_list|(
name|ptr
operator|-
name|streamLength
operator|==
name|binary
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
name|streamLength
expr_stmt|;
block|}
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|getBinaryLength
name|GLint
name|Program
operator|::
name|getBinaryLength
parameter_list|()
specifier|const
block|{
name|GLint
name|length
decl_stmt|;
name|Error
name|error
init|=
name|saveBinary
argument_list|(
literal|nullptr
argument_list|,
literal|nullptr
argument_list|,
name|std
operator|::
name|numeric_limits
argument_list|<
name|GLint
argument_list|>
operator|::
name|max
argument_list|()
argument_list|,
operator|&
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|length
return|;
block|}
DECL|function|setBinaryRetrievableHint
name|void
name|Program
operator|::
name|setBinaryRetrievableHint
parameter_list|(
name|bool
name|retrievable
parameter_list|)
block|{
comment|// TODO(jmadill) : replace with dirty bits
name|mProgram
operator|->
name|setBinaryRetrievableHint
argument_list|(
name|retrievable
argument_list|)
expr_stmt|;
name|mData
operator|.
name|mBinaryRetrieveableHint
operator|=
name|retrievable
expr_stmt|;
block|}
DECL|function|getBinaryRetrievableHint
name|bool
name|Program
operator|::
name|getBinaryRetrievableHint
parameter_list|()
specifier|const
block|{
return|return
name|mData
operator|.
name|mBinaryRetrieveableHint
return|;
block|}
DECL|function|release
name|void
name|Program
operator|::
name|release
parameter_list|()
block|{
name|mRefCount
operator|--
expr_stmt|;
if|if
condition|(
name|mRefCount
operator|==
literal|0
operator|&&
name|mDeleteStatus
condition|)
block|{
name|mResourceManager
operator|->
name|deleteProgram
argument_list|(
name|mHandle
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|addRef
name|void
name|Program
operator|::
name|addRef
parameter_list|()
block|{
name|mRefCount
operator|++
expr_stmt|;
block|}
DECL|function|getRefCount
name|unsigned
name|int
name|Program
operator|::
name|getRefCount
parameter_list|()
specifier|const
block|{
return|return
name|mRefCount
return|;
block|}
DECL|function|getInfoLogLength
name|int
name|Program
operator|::
name|getInfoLogLength
parameter_list|()
specifier|const
block|{
return|return
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|mInfoLog
operator|.
name|getLength
argument_list|()
argument_list|)
return|;
block|}
DECL|function|getInfoLog
name|void
name|Program
operator|::
name|getInfoLog
parameter_list|(
name|GLsizei
name|bufSize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|,
name|char
modifier|*
name|infoLog
parameter_list|)
specifier|const
block|{
return|return
name|mInfoLog
operator|.
name|getLog
argument_list|(
name|bufSize
argument_list|,
name|length
argument_list|,
name|infoLog
argument_list|)
return|;
block|}
DECL|function|getAttachedShaders
name|void
name|Program
operator|::
name|getAttachedShaders
parameter_list|(
name|GLsizei
name|maxCount
parameter_list|,
name|GLsizei
modifier|*
name|count
parameter_list|,
name|GLuint
modifier|*
name|shaders
parameter_list|)
specifier|const
block|{
name|int
name|total
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mData
operator|.
name|mAttachedVertexShader
condition|)
block|{
if|if
condition|(
name|total
operator|<
name|maxCount
condition|)
block|{
name|shaders
index|[
name|total
index|]
operator|=
name|mData
operator|.
name|mAttachedVertexShader
operator|->
name|getHandle
argument_list|()
expr_stmt|;
block|}
name|total
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|mData
operator|.
name|mAttachedFragmentShader
condition|)
block|{
if|if
condition|(
name|total
operator|<
name|maxCount
condition|)
block|{
name|shaders
index|[
name|total
index|]
operator|=
name|mData
operator|.
name|mAttachedFragmentShader
operator|->
name|getHandle
argument_list|()
expr_stmt|;
block|}
name|total
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|count
condition|)
block|{
operator|*
name|count
operator|=
name|total
expr_stmt|;
block|}
block|}
DECL|function|getAttributeLocation
name|GLuint
name|Program
operator|::
name|getAttributeLocation
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|name
parameter_list|)
specifier|const
block|{
for|for
control|(
specifier|const
name|sh
operator|::
name|Attribute
modifier|&
name|attribute
range|:
name|mData
operator|.
name|mAttributes
control|)
block|{
if|if
condition|(
name|attribute
operator|.
name|name
operator|==
name|name
operator|&&
name|attribute
operator|.
name|staticUse
condition|)
block|{
return|return
name|attribute
operator|.
name|location
return|;
block|}
block|}
return|return
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
operator|-
literal|1
argument_list|)
return|;
block|}
DECL|function|isAttribLocationActive
name|bool
name|Program
operator|::
name|isAttribLocationActive
parameter_list|(
name|size_t
name|attribLocation
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|attribLocation
operator|<
name|mData
operator|.
name|mActiveAttribLocationsMask
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|mData
operator|.
name|mActiveAttribLocationsMask
index|[
name|attribLocation
index|]
return|;
block|}
DECL|function|getActiveAttribute
name|void
name|Program
operator|::
name|getActiveAttribute
parameter_list|(
name|GLuint
name|index
parameter_list|,
name|GLsizei
name|bufsize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|,
name|GLint
modifier|*
name|size
parameter_list|,
name|GLenum
modifier|*
name|type
parameter_list|,
name|GLchar
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mLinked
condition|)
block|{
if|if
condition|(
name|bufsize
operator|>
literal|0
condition|)
block|{
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|type
operator|=
name|GL_NONE
expr_stmt|;
operator|*
name|size
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|size_t
name|attributeIndex
init|=
literal|0
decl_stmt|;
for|for
control|(
specifier|const
name|sh
operator|::
name|Attribute
modifier|&
name|attribute
range|:
name|mData
operator|.
name|mAttributes
control|)
block|{
comment|// Skip over inactive attributes
if|if
condition|(
name|attribute
operator|.
name|staticUse
condition|)
block|{
if|if
condition|(
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|index
argument_list|)
operator|==
name|attributeIndex
condition|)
block|{
break|break;
block|}
name|attributeIndex
operator|++
expr_stmt|;
block|}
block|}
name|ASSERT
argument_list|(
name|index
operator|==
name|attributeIndex
operator|&&
name|attributeIndex
operator|<
name|mData
operator|.
name|mAttributes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|sh
operator|::
name|Attribute
modifier|&
name|attrib
init|=
name|mData
operator|.
name|mAttributes
index|[
name|attributeIndex
index|]
decl_stmt|;
if|if
condition|(
name|bufsize
operator|>
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|string
init|=
name|attrib
operator|.
name|name
operator|.
name|c_str
argument_list|()
decl_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
name|string
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|name
index|[
name|bufsize
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
cast|static_cast
argument_list|<
name|GLsizei
argument_list|>
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Always a single 'type' instance
operator|*
name|size
operator|=
literal|1
expr_stmt|;
operator|*
name|type
operator|=
name|attrib
operator|.
name|type
expr_stmt|;
block|}
DECL|function|getActiveAttributeCount
name|GLint
name|Program
operator|::
name|getActiveAttributeCount
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|mLinked
condition|)
block|{
return|return
literal|0
return|;
block|}
name|GLint
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
specifier|const
name|sh
operator|::
name|Attribute
modifier|&
name|attrib
range|:
name|mData
operator|.
name|mAttributes
control|)
block|{
name|count
operator|+=
operator|(
name|attrib
operator|.
name|staticUse
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
DECL|function|getActiveAttributeMaxLength
name|GLint
name|Program
operator|::
name|getActiveAttributeMaxLength
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|mLinked
condition|)
block|{
return|return
literal|0
return|;
block|}
name|size_t
name|maxLength
init|=
literal|0
decl_stmt|;
for|for
control|(
specifier|const
name|sh
operator|::
name|Attribute
modifier|&
name|attrib
range|:
name|mData
operator|.
name|mAttributes
control|)
block|{
if|if
condition|(
name|attrib
operator|.
name|staticUse
condition|)
block|{
name|maxLength
operator|=
name|std
operator|::
name|max
argument_list|(
name|attrib
operator|.
name|name
operator|.
name|length
argument_list|()
operator|+
literal|1
argument_list|,
name|maxLength
argument_list|)
expr_stmt|;
block|}
block|}
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|maxLength
argument_list|)
return|;
block|}
DECL|function|getFragDataLocation
name|GLint
name|Program
operator|::
name|getFragDataLocation
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|name
parameter_list|)
specifier|const
block|{
name|std
operator|::
name|string
name|baseName
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|arrayIndex
init|=
name|ParseAndStripArrayIndex
argument_list|(
operator|&
name|baseName
argument_list|)
decl_stmt|;
for|for
control|(
name|auto
name|outputPair
range|:
name|mData
operator|.
name|mOutputVariables
control|)
block|{
specifier|const
name|VariableLocation
modifier|&
name|outputVariable
init|=
name|outputPair
operator|.
name|second
decl_stmt|;
if|if
condition|(
name|outputVariable
operator|.
name|name
operator|==
name|baseName
operator|&&
operator|(
name|arrayIndex
operator|==
name|GL_INVALID_INDEX
operator|||
name|arrayIndex
operator|==
name|outputVariable
operator|.
name|element
operator|)
condition|)
block|{
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|outputPair
operator|.
name|first
argument_list|)
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
DECL|function|getActiveUniform
name|void
name|Program
operator|::
name|getActiveUniform
parameter_list|(
name|GLuint
name|index
parameter_list|,
name|GLsizei
name|bufsize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|,
name|GLint
modifier|*
name|size
parameter_list|,
name|GLenum
modifier|*
name|type
parameter_list|,
name|GLchar
modifier|*
name|name
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|mLinked
condition|)
block|{
comment|// index must be smaller than getActiveUniformCount()
name|ASSERT
argument_list|(
name|index
operator|<
name|mData
operator|.
name|mUniforms
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|LinkedUniform
modifier|&
name|uniform
init|=
name|mData
operator|.
name|mUniforms
index|[
name|index
index|]
decl_stmt|;
if|if
condition|(
name|bufsize
operator|>
literal|0
condition|)
block|{
name|std
operator|::
name|string
name|string
init|=
name|uniform
operator|.
name|name
decl_stmt|;
if|if
condition|(
name|uniform
operator|.
name|isArray
argument_list|()
condition|)
block|{
name|string
operator|+=
literal|"[0]"
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|name
argument_list|,
name|string
operator|.
name|c_str
argument_list|()
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|name
index|[
name|bufsize
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
cast|static_cast
argument_list|<
name|GLsizei
argument_list|>
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|size
operator|=
name|uniform
operator|.
name|elementCount
argument_list|()
expr_stmt|;
operator|*
name|type
operator|=
name|uniform
operator|.
name|type
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bufsize
operator|>
literal|0
condition|)
block|{
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|size
operator|=
literal|0
expr_stmt|;
operator|*
name|type
operator|=
name|GL_NONE
expr_stmt|;
block|}
block|}
DECL|function|getActiveUniformCount
name|GLint
name|Program
operator|::
name|getActiveUniformCount
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|mLinked
condition|)
block|{
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|mData
operator|.
name|mUniforms
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
DECL|function|getActiveUniformMaxLength
name|GLint
name|Program
operator|::
name|getActiveUniformMaxLength
parameter_list|()
specifier|const
block|{
name|size_t
name|maxLength
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mLinked
condition|)
block|{
for|for
control|(
specifier|const
name|LinkedUniform
modifier|&
name|uniform
range|:
name|mData
operator|.
name|mUniforms
control|)
block|{
if|if
condition|(
operator|!
name|uniform
operator|.
name|name
operator|.
name|empty
argument_list|()
condition|)
block|{
name|size_t
name|length
init|=
name|uniform
operator|.
name|name
operator|.
name|length
argument_list|()
operator|+
literal|1u
decl_stmt|;
if|if
condition|(
name|uniform
operator|.
name|isArray
argument_list|()
condition|)
block|{
name|length
operator|+=
literal|3
expr_stmt|;
comment|// Counting in "[0]".
block|}
name|maxLength
operator|=
name|std
operator|::
name|max
argument_list|(
name|length
argument_list|,
name|maxLength
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|maxLength
argument_list|)
return|;
block|}
DECL|function|getActiveUniformi
name|GLint
name|Program
operator|::
name|getActiveUniformi
parameter_list|(
name|GLuint
name|index
parameter_list|,
name|GLenum
name|pname
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|index
argument_list|)
operator|<
name|mData
operator|.
name|mUniforms
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|gl
operator|::
name|LinkedUniform
modifier|&
name|uniform
init|=
name|mData
operator|.
name|mUniforms
index|[
name|index
index|]
decl_stmt|;
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_UNIFORM_TYPE
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniform
operator|.
name|type
argument_list|)
return|;
case|case
name|GL_UNIFORM_SIZE
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniform
operator|.
name|elementCount
argument_list|()
argument_list|)
return|;
case|case
name|GL_UNIFORM_NAME_LENGTH
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniform
operator|.
name|name
operator|.
name|size
argument_list|()
operator|+
literal|1
operator|+
operator|(
name|uniform
operator|.
name|isArray
argument_list|()
condition|?
literal|3
else|:
literal|0
operator|)
argument_list|)
return|;
case|case
name|GL_UNIFORM_BLOCK_INDEX
case|:
return|return
name|uniform
operator|.
name|blockIndex
return|;
case|case
name|GL_UNIFORM_OFFSET
case|:
return|return
name|uniform
operator|.
name|blockInfo
operator|.
name|offset
return|;
case|case
name|GL_UNIFORM_ARRAY_STRIDE
case|:
return|return
name|uniform
operator|.
name|blockInfo
operator|.
name|arrayStride
return|;
case|case
name|GL_UNIFORM_MATRIX_STRIDE
case|:
return|return
name|uniform
operator|.
name|blockInfo
operator|.
name|matrixStride
return|;
case|case
name|GL_UNIFORM_IS_ROW_MAJOR
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniform
operator|.
name|blockInfo
operator|.
name|isRowMajorMatrix
argument_list|)
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
DECL|function|isValidUniformLocation
name|bool
name|Program
operator|::
name|isValidUniformLocation
parameter_list|(
name|GLint
name|location
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|rx
operator|::
name|IsIntegerCastSafe
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|mData
operator|.
name|mUniformLocations
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|location
operator|>=
literal|0
operator|&&
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|location
argument_list|)
operator|<
name|mData
operator|.
name|mUniformLocations
operator|.
name|size
argument_list|()
operator|)
return|;
block|}
DECL|function|getUniformByLocation
specifier|const
name|LinkedUniform
modifier|&
name|Program
operator|::
name|getUniformByLocation
parameter_list|(
name|GLint
name|location
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|location
operator|>=
literal|0
operator|&&
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|location
argument_list|)
operator|<
name|mData
operator|.
name|mUniformLocations
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|mData
operator|.
name|mUniforms
index|[
name|mData
operator|.
name|mUniformLocations
index|[
name|location
index|]
operator|.
name|index
index|]
return|;
block|}
DECL|function|getUniformLocation
name|GLint
name|Program
operator|::
name|getUniformLocation
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|name
parameter_list|)
specifier|const
block|{
return|return
name|mData
operator|.
name|getUniformLocation
argument_list|(
name|name
argument_list|)
return|;
block|}
DECL|function|getUniformIndex
name|GLuint
name|Program
operator|::
name|getUniformIndex
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|name
parameter_list|)
specifier|const
block|{
return|return
name|mData
operator|.
name|getUniformIndex
argument_list|(
name|name
argument_list|)
return|;
block|}
DECL|function|setUniform1fv
name|void
name|Program
operator|::
name|setUniform1fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|setUniformInternal
argument_list|(
name|location
argument_list|,
name|count
operator|*
literal|1
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|mProgram
operator|->
name|setUniform1fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform2fv
name|void
name|Program
operator|::
name|setUniform2fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|setUniformInternal
argument_list|(
name|location
argument_list|,
name|count
operator|*
literal|2
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|mProgram
operator|->
name|setUniform2fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform3fv
name|void
name|Program
operator|::
name|setUniform3fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|setUniformInternal
argument_list|(
name|location
argument_list|,
name|count
operator|*
literal|3
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|mProgram
operator|->
name|setUniform3fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform4fv
name|void
name|Program
operator|::
name|setUniform4fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|setUniformInternal
argument_list|(
name|location
argument_list|,
name|count
operator|*
literal|4
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|mProgram
operator|->
name|setUniform4fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform1iv
name|void
name|Program
operator|::
name|setUniform1iv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|setUniformInternal
argument_list|(
name|location
argument_list|,
name|count
operator|*
literal|1
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|mProgram
operator|->
name|setUniform1iv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform2iv
name|void
name|Program
operator|::
name|setUniform2iv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|setUniformInternal
argument_list|(
name|location
argument_list|,
name|count
operator|*
literal|2
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|mProgram
operator|->
name|setUniform2iv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform3iv
name|void
name|Program
operator|::
name|setUniform3iv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|setUniformInternal
argument_list|(
name|location
argument_list|,
name|count
operator|*
literal|3
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|mProgram
operator|->
name|setUniform3iv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform4iv
name|void
name|Program
operator|::
name|setUniform4iv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|setUniformInternal
argument_list|(
name|location
argument_list|,
name|count
operator|*
literal|4
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|mProgram
operator|->
name|setUniform4iv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform1uiv
name|void
name|Program
operator|::
name|setUniform1uiv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|v
parameter_list|)
block|{
name|setUniformInternal
argument_list|(
name|location
argument_list|,
name|count
operator|*
literal|1
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|mProgram
operator|->
name|setUniform1uiv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform2uiv
name|void
name|Program
operator|::
name|setUniform2uiv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|v
parameter_list|)
block|{
name|setUniformInternal
argument_list|(
name|location
argument_list|,
name|count
operator|*
literal|2
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|mProgram
operator|->
name|setUniform2uiv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform3uiv
name|void
name|Program
operator|::
name|setUniform3uiv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|v
parameter_list|)
block|{
name|setUniformInternal
argument_list|(
name|location
argument_list|,
name|count
operator|*
literal|3
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|mProgram
operator|->
name|setUniform3uiv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform4uiv
name|void
name|Program
operator|::
name|setUniform4uiv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|v
parameter_list|)
block|{
name|setUniformInternal
argument_list|(
name|location
argument_list|,
name|count
operator|*
literal|4
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|mProgram
operator|->
name|setUniform4uiv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix2fv
name|void
name|Program
operator|::
name|setUniformMatrix2fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|setMatrixUniformInternal
argument_list|<
literal|2
argument_list|,
literal|2
argument_list|>
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|mProgram
operator|->
name|setUniformMatrix2fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix3fv
name|void
name|Program
operator|::
name|setUniformMatrix3fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|setMatrixUniformInternal
argument_list|<
literal|3
argument_list|,
literal|3
argument_list|>
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|mProgram
operator|->
name|setUniformMatrix3fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix4fv
name|void
name|Program
operator|::
name|setUniformMatrix4fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|setMatrixUniformInternal
argument_list|<
literal|4
argument_list|,
literal|4
argument_list|>
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|mProgram
operator|->
name|setUniformMatrix4fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix2x3fv
name|void
name|Program
operator|::
name|setUniformMatrix2x3fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|setMatrixUniformInternal
argument_list|<
literal|2
argument_list|,
literal|3
argument_list|>
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|mProgram
operator|->
name|setUniformMatrix2x3fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix2x4fv
name|void
name|Program
operator|::
name|setUniformMatrix2x4fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|setMatrixUniformInternal
argument_list|<
literal|2
argument_list|,
literal|4
argument_list|>
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|mProgram
operator|->
name|setUniformMatrix2x4fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix3x2fv
name|void
name|Program
operator|::
name|setUniformMatrix3x2fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|setMatrixUniformInternal
argument_list|<
literal|3
argument_list|,
literal|2
argument_list|>
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|mProgram
operator|->
name|setUniformMatrix3x2fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix3x4fv
name|void
name|Program
operator|::
name|setUniformMatrix3x4fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|setMatrixUniformInternal
argument_list|<
literal|3
argument_list|,
literal|4
argument_list|>
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|mProgram
operator|->
name|setUniformMatrix3x4fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix4x2fv
name|void
name|Program
operator|::
name|setUniformMatrix4x2fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|setMatrixUniformInternal
argument_list|<
literal|4
argument_list|,
literal|2
argument_list|>
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|mProgram
operator|->
name|setUniformMatrix4x2fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix4x3fv
name|void
name|Program
operator|::
name|setUniformMatrix4x3fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|setMatrixUniformInternal
argument_list|<
literal|4
argument_list|,
literal|3
argument_list|>
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|mProgram
operator|->
name|setUniformMatrix4x3fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|getUniformfv
name|void
name|Program
operator|::
name|getUniformfv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLfloat
modifier|*
name|v
parameter_list|)
specifier|const
block|{
name|getUniformInternal
argument_list|(
name|location
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|getUniformiv
name|void
name|Program
operator|::
name|getUniformiv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLint
modifier|*
name|v
parameter_list|)
specifier|const
block|{
name|getUniformInternal
argument_list|(
name|location
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|getUniformuiv
name|void
name|Program
operator|::
name|getUniformuiv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLuint
modifier|*
name|v
parameter_list|)
specifier|const
block|{
name|getUniformInternal
argument_list|(
name|location
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|function|flagForDeletion
name|void
name|Program
operator|::
name|flagForDeletion
parameter_list|()
block|{
name|mDeleteStatus
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|isFlaggedForDeletion
name|bool
name|Program
operator|::
name|isFlaggedForDeletion
parameter_list|()
specifier|const
block|{
return|return
name|mDeleteStatus
return|;
block|}
DECL|function|validate
name|void
name|Program
operator|::
name|validate
parameter_list|(
specifier|const
name|Caps
modifier|&
name|caps
parameter_list|)
block|{
name|mInfoLog
operator|.
name|reset
argument_list|()
expr_stmt|;
if|if
condition|(
name|mLinked
condition|)
block|{
name|mValidated
operator|=
operator|(
name|mProgram
operator|->
name|validate
argument_list|(
name|caps
argument_list|,
operator|&
name|mInfoLog
argument_list|)
operator|==
name|GL_TRUE
operator|)
expr_stmt|;
block|}
else|else
block|{
name|mInfoLog
operator|<<
literal|"Program has not been successfully linked."
expr_stmt|;
block|}
block|}
DECL|function|validateSamplers
name|bool
name|Program
operator|::
name|validateSamplers
parameter_list|(
name|InfoLog
modifier|*
name|infoLog
parameter_list|,
specifier|const
name|Caps
modifier|&
name|caps
parameter_list|)
block|{
comment|// Skip cache if we're using an infolog, so we get the full error.
comment|// Also skip the cache if the sample mapping has changed, or if we haven't ever validated.
if|if
condition|(
name|infoLog
operator|==
literal|nullptr
operator|&&
name|mCachedValidateSamplersResult
operator|.
name|valid
argument_list|()
condition|)
block|{
return|return
name|mCachedValidateSamplersResult
operator|.
name|value
argument_list|()
return|;
block|}
if|if
condition|(
name|mTextureUnitTypesCache
operator|.
name|empty
argument_list|()
condition|)
block|{
name|mTextureUnitTypesCache
operator|.
name|resize
argument_list|(
name|caps
operator|.
name|maxCombinedTextureImageUnits
argument_list|,
name|GL_NONE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|std
operator|::
name|fill
argument_list|(
name|mTextureUnitTypesCache
operator|.
name|begin
argument_list|()
argument_list|,
name|mTextureUnitTypesCache
operator|.
name|end
argument_list|()
argument_list|,
name|GL_NONE
argument_list|)
expr_stmt|;
block|}
comment|// if any two active samplers in a program are of different types, but refer to the same
comment|// texture image unit, and this is the current program, then ValidateProgram will fail, and
comment|// DrawArrays and DrawElements will issue the INVALID_OPERATION error.
for|for
control|(
name|unsigned
name|int
name|samplerIndex
init|=
name|mSamplerUniformRange
operator|.
name|start
init|;
name|samplerIndex
operator|<
name|mSamplerUniformRange
operator|.
name|end
condition|;
operator|++
name|samplerIndex
control|)
block|{
specifier|const
name|LinkedUniform
modifier|&
name|uniform
init|=
name|mData
operator|.
name|mUniforms
index|[
name|samplerIndex
index|]
decl_stmt|;
name|ASSERT
argument_list|(
name|uniform
operator|.
name|isSampler
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|uniform
operator|.
name|staticUse
condition|)
continue|continue;
specifier|const
name|GLuint
modifier|*
name|dataPtr
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|GLuint
operator|*
argument_list|>
argument_list|(
name|uniform
operator|.
name|getDataPtrToElement
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|GLenum
name|textureType
init|=
name|SamplerTypeToTextureType
argument_list|(
name|uniform
operator|.
name|type
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|arrayElement
init|=
literal|0
init|;
name|arrayElement
operator|<
name|uniform
operator|.
name|elementCount
argument_list|()
condition|;
operator|++
name|arrayElement
control|)
block|{
name|GLuint
name|textureUnit
init|=
name|dataPtr
index|[
name|arrayElement
index|]
decl_stmt|;
if|if
condition|(
name|textureUnit
operator|>=
name|caps
operator|.
name|maxCombinedTextureImageUnits
condition|)
block|{
if|if
condition|(
name|infoLog
condition|)
block|{
operator|(
operator|*
name|infoLog
operator|)
operator|<<
literal|"Sampler uniform ("
operator|<<
name|textureUnit
operator|<<
literal|") exceeds GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS ("
operator|<<
name|caps
operator|.
name|maxCombinedTextureImageUnits
operator|<<
literal|")"
expr_stmt|;
block|}
name|mCachedValidateSamplersResult
operator|=
literal|false
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|mTextureUnitTypesCache
index|[
name|textureUnit
index|]
operator|!=
name|GL_NONE
condition|)
block|{
if|if
condition|(
name|textureType
operator|!=
name|mTextureUnitTypesCache
index|[
name|textureUnit
index|]
condition|)
block|{
if|if
condition|(
name|infoLog
condition|)
block|{
operator|(
operator|*
name|infoLog
operator|)
operator|<<
literal|"Samplers of conflicting types refer to the same texture "
literal|"image unit ("
operator|<<
name|textureUnit
operator|<<
literal|")."
expr_stmt|;
block|}
name|mCachedValidateSamplersResult
operator|=
literal|false
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
name|mTextureUnitTypesCache
index|[
name|textureUnit
index|]
operator|=
name|textureType
expr_stmt|;
block|}
block|}
block|}
name|mCachedValidateSamplersResult
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|isValidated
name|bool
name|Program
operator|::
name|isValidated
parameter_list|()
specifier|const
block|{
return|return
name|mValidated
return|;
block|}
DECL|function|getActiveUniformBlockCount
name|GLuint
name|Program
operator|::
name|getActiveUniformBlockCount
parameter_list|()
specifier|const
block|{
return|return
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|mData
operator|.
name|mUniformBlocks
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
DECL|function|getActiveUniformBlockName
name|void
name|Program
operator|::
name|getActiveUniformBlockName
parameter_list|(
name|GLuint
name|uniformBlockIndex
parameter_list|,
name|GLsizei
name|bufSize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|,
name|GLchar
modifier|*
name|uniformBlockName
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|uniformBlockIndex
operator|<
name|mData
operator|.
name|mUniformBlocks
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// index must be smaller than getActiveUniformBlockCount()
specifier|const
name|UniformBlock
modifier|&
name|uniformBlock
init|=
name|mData
operator|.
name|mUniformBlocks
index|[
name|uniformBlockIndex
index|]
decl_stmt|;
if|if
condition|(
name|bufSize
operator|>
literal|0
condition|)
block|{
name|std
operator|::
name|string
name|string
init|=
name|uniformBlock
operator|.
name|name
decl_stmt|;
if|if
condition|(
name|uniformBlock
operator|.
name|isArray
condition|)
block|{
name|string
operator|+=
name|ArrayString
argument_list|(
name|uniformBlock
operator|.
name|arrayElement
argument_list|)
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|uniformBlockName
argument_list|,
name|string
operator|.
name|c_str
argument_list|()
argument_list|,
name|bufSize
argument_list|)
expr_stmt|;
name|uniformBlockName
index|[
name|bufSize
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
cast|static_cast
argument_list|<
name|GLsizei
argument_list|>
argument_list|(
name|strlen
argument_list|(
name|uniformBlockName
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|getActiveUniformBlockiv
name|void
name|Program
operator|::
name|getActiveUniformBlockiv
parameter_list|(
name|GLuint
name|uniformBlockIndex
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLint
modifier|*
name|params
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|uniformBlockIndex
operator|<
name|mData
operator|.
name|mUniformBlocks
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// index must be smaller than getActiveUniformBlockCount()
specifier|const
name|UniformBlock
modifier|&
name|uniformBlock
init|=
name|mData
operator|.
name|mUniformBlocks
index|[
name|uniformBlockIndex
index|]
decl_stmt|;
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_UNIFORM_BLOCK_DATA_SIZE
case|:
operator|*
name|params
operator|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniformBlock
operator|.
name|dataSize
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_UNIFORM_BLOCK_NAME_LENGTH
case|:
operator|*
name|params
operator|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniformBlock
operator|.
name|name
operator|.
name|size
argument_list|()
operator|+
literal|1
operator|+
operator|(
name|uniformBlock
operator|.
name|isArray
condition|?
literal|3
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS
case|:
operator|*
name|params
operator|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniformBlock
operator|.
name|memberUniformIndexes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES
case|:
block|{
for|for
control|(
name|unsigned
name|int
name|blockMemberIndex
init|=
literal|0
init|;
name|blockMemberIndex
operator|<
name|uniformBlock
operator|.
name|memberUniformIndexes
operator|.
name|size
argument_list|()
condition|;
name|blockMemberIndex
operator|++
control|)
block|{
name|params
index|[
name|blockMemberIndex
index|]
operator|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniformBlock
operator|.
name|memberUniformIndexes
index|[
name|blockMemberIndex
index|]
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER
case|:
operator|*
name|params
operator|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniformBlock
operator|.
name|vertexStaticUse
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER
case|:
operator|*
name|params
operator|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|uniformBlock
operator|.
name|fragmentStaticUse
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|getActiveUniformBlockMaxLength
name|GLint
name|Program
operator|::
name|getActiveUniformBlockMaxLength
parameter_list|()
specifier|const
block|{
name|int
name|maxLength
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mLinked
condition|)
block|{
name|unsigned
name|int
name|numUniformBlocks
init|=
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|mData
operator|.
name|mUniformBlocks
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|uniformBlockIndex
init|=
literal|0
init|;
name|uniformBlockIndex
operator|<
name|numUniformBlocks
condition|;
name|uniformBlockIndex
operator|++
control|)
block|{
specifier|const
name|UniformBlock
modifier|&
name|uniformBlock
init|=
name|mData
operator|.
name|mUniformBlocks
index|[
name|uniformBlockIndex
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|uniformBlock
operator|.
name|name
operator|.
name|empty
argument_list|()
condition|)
block|{
specifier|const
name|int
name|length
init|=
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|uniformBlock
operator|.
name|name
operator|.
name|length
argument_list|()
argument_list|)
operator|+
literal|1
decl_stmt|;
comment|// Counting in "[0]".
specifier|const
name|int
name|arrayLength
init|=
operator|(
name|uniformBlock
operator|.
name|isArray
condition|?
literal|3
else|:
literal|0
operator|)
decl_stmt|;
name|maxLength
operator|=
name|std
operator|::
name|max
argument_list|(
name|length
operator|+
name|arrayLength
argument_list|,
name|maxLength
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|maxLength
return|;
block|}
DECL|function|getUniformBlockIndex
name|GLuint
name|Program
operator|::
name|getUniformBlockIndex
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|name
parameter_list|)
specifier|const
block|{
name|size_t
name|subscript
init|=
name|GL_INVALID_INDEX
decl_stmt|;
name|std
operator|::
name|string
name|baseName
init|=
name|gl
operator|::
name|ParseUniformName
argument_list|(
name|name
argument_list|,
operator|&
name|subscript
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|numUniformBlocks
init|=
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|mData
operator|.
name|mUniformBlocks
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|blockIndex
init|=
literal|0
init|;
name|blockIndex
operator|<
name|numUniformBlocks
condition|;
name|blockIndex
operator|++
control|)
block|{
specifier|const
name|gl
operator|::
name|UniformBlock
modifier|&
name|uniformBlock
init|=
name|mData
operator|.
name|mUniformBlocks
index|[
name|blockIndex
index|]
decl_stmt|;
if|if
condition|(
name|uniformBlock
operator|.
name|name
operator|==
name|baseName
condition|)
block|{
specifier|const
name|bool
name|arrayElementZero
init|=
operator|(
name|subscript
operator|==
name|GL_INVALID_INDEX
operator|&&
operator|(
operator|!
name|uniformBlock
operator|.
name|isArray
operator|||
name|uniformBlock
operator|.
name|arrayElement
operator|==
literal|0
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|subscript
operator|==
name|uniformBlock
operator|.
name|arrayElement
operator|||
name|arrayElementZero
condition|)
block|{
return|return
name|blockIndex
return|;
block|}
block|}
block|}
return|return
name|GL_INVALID_INDEX
return|;
block|}
DECL|function|getUniformBlockByIndex
specifier|const
name|UniformBlock
modifier|&
name|Program
operator|::
name|getUniformBlockByIndex
parameter_list|(
name|GLuint
name|index
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|index
operator|<
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|mData
operator|.
name|mUniformBlocks
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|mData
operator|.
name|mUniformBlocks
index|[
name|index
index|]
return|;
block|}
DECL|function|bindUniformBlock
name|void
name|Program
operator|::
name|bindUniformBlock
parameter_list|(
name|GLuint
name|uniformBlockIndex
parameter_list|,
name|GLuint
name|uniformBlockBinding
parameter_list|)
block|{
name|mData
operator|.
name|mUniformBlockBindings
index|[
name|uniformBlockIndex
index|]
operator|=
name|uniformBlockBinding
expr_stmt|;
name|mProgram
operator|->
name|setUniformBlockBinding
argument_list|(
name|uniformBlockIndex
argument_list|,
name|uniformBlockBinding
argument_list|)
expr_stmt|;
block|}
DECL|function|getUniformBlockBinding
name|GLuint
name|Program
operator|::
name|getUniformBlockBinding
parameter_list|(
name|GLuint
name|uniformBlockIndex
parameter_list|)
specifier|const
block|{
return|return
name|mData
operator|.
name|getUniformBlockBinding
argument_list|(
name|uniformBlockIndex
argument_list|)
return|;
block|}
DECL|function|resetUniformBlockBindings
name|void
name|Program
operator|::
name|resetUniformBlockBindings
parameter_list|()
block|{
for|for
control|(
name|unsigned
name|int
name|blockId
init|=
literal|0
init|;
name|blockId
operator|<
name|IMPLEMENTATION_MAX_COMBINED_SHADER_UNIFORM_BUFFERS
condition|;
name|blockId
operator|++
control|)
block|{
name|mData
operator|.
name|mUniformBlockBindings
index|[
name|blockId
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|mData
operator|.
name|mActiveUniformBlockBindings
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
DECL|function|setTransformFeedbackVaryings
name|void
name|Program
operator|::
name|setTransformFeedbackVaryings
parameter_list|(
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLchar
modifier|*
specifier|const
modifier|*
name|varyings
parameter_list|,
name|GLenum
name|bufferMode
parameter_list|)
block|{
name|mData
operator|.
name|mTransformFeedbackVaryingNames
operator|.
name|resize
argument_list|(
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|GLsizei
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|mData
operator|.
name|mTransformFeedbackVaryingNames
index|[
name|i
index|]
operator|=
name|varyings
index|[
name|i
index|]
expr_stmt|;
block|}
name|mData
operator|.
name|mTransformFeedbackBufferMode
operator|=
name|bufferMode
expr_stmt|;
block|}
DECL|function|getTransformFeedbackVarying
name|void
name|Program
operator|::
name|getTransformFeedbackVarying
parameter_list|(
name|GLuint
name|index
parameter_list|,
name|GLsizei
name|bufSize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|,
name|GLsizei
modifier|*
name|size
parameter_list|,
name|GLenum
modifier|*
name|type
parameter_list|,
name|GLchar
modifier|*
name|name
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|mLinked
condition|)
block|{
name|ASSERT
argument_list|(
name|index
operator|<
name|mData
operator|.
name|mTransformFeedbackVaryingVars
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|sh
operator|::
name|Varying
modifier|&
name|varying
init|=
name|mData
operator|.
name|mTransformFeedbackVaryingVars
index|[
name|index
index|]
decl_stmt|;
name|GLsizei
name|lastNameIdx
init|=
name|std
operator|::
name|min
argument_list|(
name|bufSize
operator|-
literal|1
argument_list|,
cast|static_cast
argument_list|<
name|GLsizei
argument_list|>
argument_list|(
name|varying
operator|.
name|name
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
name|lastNameIdx
expr_stmt|;
block|}
if|if
condition|(
name|size
condition|)
block|{
operator|*
name|size
operator|=
name|varying
operator|.
name|elementCount
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|type
condition|)
block|{
operator|*
name|type
operator|=
name|varying
operator|.
name|type
expr_stmt|;
block|}
if|if
condition|(
name|name
condition|)
block|{
name|memcpy
argument_list|(
name|name
argument_list|,
name|varying
operator|.
name|name
operator|.
name|c_str
argument_list|()
argument_list|,
name|lastNameIdx
argument_list|)
expr_stmt|;
name|name
index|[
name|lastNameIdx
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
block|}
DECL|function|getTransformFeedbackVaryingCount
name|GLsizei
name|Program
operator|::
name|getTransformFeedbackVaryingCount
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|mLinked
condition|)
block|{
return|return
cast|static_cast
argument_list|<
name|GLsizei
argument_list|>
argument_list|(
name|mData
operator|.
name|mTransformFeedbackVaryingVars
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
DECL|function|getTransformFeedbackVaryingMaxLength
name|GLsizei
name|Program
operator|::
name|getTransformFeedbackVaryingMaxLength
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|mLinked
condition|)
block|{
name|GLsizei
name|maxSize
init|=
literal|0
decl_stmt|;
for|for
control|(
specifier|const
name|sh
operator|::
name|Varying
modifier|&
name|varying
range|:
name|mData
operator|.
name|mTransformFeedbackVaryingVars
control|)
block|{
name|maxSize
operator|=
name|std
operator|::
name|max
argument_list|(
name|maxSize
argument_list|,
cast|static_cast
argument_list|<
name|GLsizei
argument_list|>
argument_list|(
name|varying
operator|.
name|name
operator|.
name|length
argument_list|()
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|maxSize
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
DECL|function|getTransformFeedbackBufferMode
name|GLenum
name|Program
operator|::
name|getTransformFeedbackBufferMode
parameter_list|()
specifier|const
block|{
return|return
name|mData
operator|.
name|mTransformFeedbackBufferMode
return|;
block|}
comment|// static
DECL|function|linkVaryings
name|bool
name|Program
operator|::
name|linkVaryings
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|Shader
modifier|*
name|vertexShader
parameter_list|,
specifier|const
name|Shader
modifier|*
name|fragmentShader
parameter_list|)
block|{
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|Varying
argument_list|>
modifier|&
name|vertexVaryings
init|=
name|vertexShader
operator|->
name|getVaryings
argument_list|()
decl_stmt|;
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|Varying
argument_list|>
modifier|&
name|fragmentVaryings
init|=
name|fragmentShader
operator|->
name|getVaryings
argument_list|()
decl_stmt|;
for|for
control|(
specifier|const
name|sh
operator|::
name|Varying
modifier|&
name|output
range|:
name|fragmentVaryings
control|)
block|{
name|bool
name|matched
init|=
literal|false
decl_stmt|;
comment|// Built-in varyings obey special rules
if|if
condition|(
name|output
operator|.
name|isBuiltIn
argument_list|()
condition|)
block|{
continue|continue;
block|}
for|for
control|(
specifier|const
name|sh
operator|::
name|Varying
modifier|&
name|input
range|:
name|vertexVaryings
control|)
block|{
if|if
condition|(
name|output
operator|.
name|name
operator|==
name|input
operator|.
name|name
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|input
operator|.
name|isBuiltIn
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|linkValidateVaryings
argument_list|(
name|infoLog
argument_list|,
name|output
operator|.
name|name
argument_list|,
name|input
argument_list|,
name|output
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|matched
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
comment|// We permit unmatched, unreferenced varyings
if|if
condition|(
operator|!
name|matched
operator|&&
name|output
operator|.
name|staticUse
condition|)
block|{
name|infoLog
operator|<<
literal|"Fragment varying "
operator|<<
name|output
operator|.
name|name
operator|<<
literal|" does not match any vertex varying"
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|// TODO(jmadill): verify no unmatched vertex varyings?
return|return
literal|true
return|;
block|}
DECL|function|linkUniforms
name|bool
name|Program
operator|::
name|linkUniforms
parameter_list|(
name|gl
operator|::
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|gl
operator|::
name|Caps
modifier|&
name|caps
parameter_list|)
block|{
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|Uniform
argument_list|>
modifier|&
name|vertexUniforms
init|=
name|mData
operator|.
name|mAttachedVertexShader
operator|->
name|getUniforms
argument_list|()
decl_stmt|;
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|Uniform
argument_list|>
modifier|&
name|fragmentUniforms
init|=
name|mData
operator|.
name|mAttachedFragmentShader
operator|->
name|getUniforms
argument_list|()
decl_stmt|;
comment|// Check that uniforms defined in the vertex and fragment shaders are identical
name|std
operator|::
name|map
argument_list|<
name|std
operator|::
name|string
argument_list|,
name|LinkedUniform
argument_list|>
name|linkedUniforms
decl_stmt|;
for|for
control|(
specifier|const
name|sh
operator|::
name|Uniform
modifier|&
name|vertexUniform
range|:
name|vertexUniforms
control|)
block|{
name|linkedUniforms
index|[
name|vertexUniform
operator|.
name|name
index|]
operator|=
name|LinkedUniform
argument_list|(
name|vertexUniform
argument_list|)
expr_stmt|;
block|}
for|for
control|(
specifier|const
name|sh
operator|::
name|Uniform
modifier|&
name|fragmentUniform
range|:
name|fragmentUniforms
control|)
block|{
name|auto
name|entry
init|=
name|linkedUniforms
operator|.
name|find
argument_list|(
name|fragmentUniform
operator|.
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
name|linkedUniforms
operator|.
name|end
argument_list|()
condition|)
block|{
name|LinkedUniform
modifier|*
name|vertexUniform
init|=
operator|&
name|entry
operator|->
name|second
decl_stmt|;
specifier|const
name|std
operator|::
name|string
modifier|&
name|uniformName
init|=
literal|"uniform '"
operator|+
name|vertexUniform
operator|->
name|name
operator|+
literal|"'"
decl_stmt|;
if|if
condition|(
operator|!
name|linkValidateUniforms
argument_list|(
name|infoLog
argument_list|,
name|uniformName
argument_list|,
operator|*
name|vertexUniform
argument_list|,
name|fragmentUniform
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
comment|// Flatten the uniforms list (nested fields) into a simple list (no nesting).
comment|// Also check the maximum uniform vector and sampler counts.
if|if
condition|(
operator|!
name|flattenUniformsAndCheckCaps
argument_list|(
name|caps
argument_list|,
name|infoLog
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|indexUniforms
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|indexUniforms
name|void
name|Program
operator|::
name|indexUniforms
parameter_list|()
block|{
for|for
control|(
name|size_t
name|uniformIndex
init|=
literal|0
init|;
name|uniformIndex
operator|<
name|mData
operator|.
name|mUniforms
operator|.
name|size
argument_list|()
condition|;
name|uniformIndex
operator|++
control|)
block|{
specifier|const
name|gl
operator|::
name|LinkedUniform
modifier|&
name|uniform
init|=
name|mData
operator|.
name|mUniforms
index|[
name|uniformIndex
index|]
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|arrayIndex
init|=
literal|0
init|;
name|arrayIndex
operator|<
name|uniform
operator|.
name|elementCount
argument_list|()
condition|;
name|arrayIndex
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|uniform
operator|.
name|isBuiltIn
argument_list|()
condition|)
block|{
comment|// Assign in-order uniform locations
name|mData
operator|.
name|mUniformLocations
operator|.
name|push_back
argument_list|(
name|gl
operator|::
name|VariableLocation
argument_list|(
name|uniform
operator|.
name|name
argument_list|,
name|arrayIndex
argument_list|,
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|uniformIndex
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|function|linkValidateInterfaceBlockFields
name|bool
name|Program
operator|::
name|linkValidateInterfaceBlockFields
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|uniformName
parameter_list|,
specifier|const
name|sh
operator|::
name|InterfaceBlockField
modifier|&
name|vertexUniform
parameter_list|,
specifier|const
name|sh
operator|::
name|InterfaceBlockField
modifier|&
name|fragmentUniform
parameter_list|)
block|{
comment|// We don't validate precision on UBO fields. See resolution of Khronos bug 10287.
if|if
condition|(
operator|!
name|linkValidateVariablesBase
argument_list|(
name|infoLog
argument_list|,
name|uniformName
argument_list|,
name|vertexUniform
argument_list|,
name|fragmentUniform
argument_list|,
literal|false
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|vertexUniform
operator|.
name|isRowMajorLayout
operator|!=
name|fragmentUniform
operator|.
name|isRowMajorLayout
condition|)
block|{
name|infoLog
operator|<<
literal|"Matrix packings for "
operator|<<
name|uniformName
operator|<<
literal|" differ between vertex and fragment shaders"
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|// Determines the mapping between GL attributes and Direct3D 9 vertex stream usage indices
DECL|function|linkAttributes
name|bool
name|Program
operator|::
name|linkAttributes
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|AttributeBindings
modifier|&
name|attributeBindings
parameter_list|,
specifier|const
name|Shader
modifier|*
name|vertexShader
parameter_list|)
block|{
name|unsigned
name|int
name|usedLocations
init|=
literal|0
decl_stmt|;
name|mData
operator|.
name|mAttributes
operator|=
name|vertexShader
operator|->
name|getActiveAttributes
argument_list|()
expr_stmt|;
name|GLuint
name|maxAttribs
init|=
name|data
operator|.
name|caps
operator|->
name|maxVertexAttributes
decl_stmt|;
comment|// TODO(jmadill): handle aliasing robustly
if|if
condition|(
name|mData
operator|.
name|mAttributes
operator|.
name|size
argument_list|()
operator|>
name|maxAttribs
condition|)
block|{
name|infoLog
operator|<<
literal|"Too many vertex attributes."
expr_stmt|;
return|return
literal|false
return|;
block|}
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|Attribute
operator|*
argument_list|>
name|usedAttribMap
argument_list|(
name|data
operator|.
name|caps
operator|->
name|maxVertexAttributes
argument_list|,
literal|nullptr
argument_list|)
decl_stmt|;
comment|// Link attributes that have a binding location
for|for
control|(
name|sh
operator|::
name|Attribute
modifier|&
name|attribute
range|:
name|mData
operator|.
name|mAttributes
control|)
block|{
comment|// TODO(jmadill): do staticUse filtering step here, or not at all
name|ASSERT
argument_list|(
name|attribute
operator|.
name|staticUse
argument_list|)
expr_stmt|;
name|int
name|bindingLocation
init|=
name|attributeBindings
operator|.
name|getAttributeBinding
argument_list|(
name|attribute
operator|.
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|attribute
operator|.
name|location
operator|==
operator|-
literal|1
operator|&&
name|bindingLocation
operator|!=
operator|-
literal|1
condition|)
block|{
name|attribute
operator|.
name|location
operator|=
name|bindingLocation
expr_stmt|;
block|}
if|if
condition|(
name|attribute
operator|.
name|location
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// Location is set by glBindAttribLocation or by location layout qualifier
specifier|const
name|int
name|regs
init|=
name|VariableRegisterCount
argument_list|(
name|attribute
operator|.
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|regs
operator|+
name|attribute
operator|.
name|location
argument_list|)
operator|>
name|maxAttribs
condition|)
block|{
name|infoLog
operator|<<
literal|"Active attribute ("
operator|<<
name|attribute
operator|.
name|name
operator|<<
literal|") at location "
operator|<<
name|attribute
operator|.
name|location
operator|<<
literal|" is too big to fit"
expr_stmt|;
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|reg
init|=
literal|0
init|;
name|reg
operator|<
name|regs
condition|;
name|reg
operator|++
control|)
block|{
specifier|const
name|int
name|regLocation
init|=
name|attribute
operator|.
name|location
operator|+
name|reg
decl_stmt|;
name|sh
operator|::
name|ShaderVariable
modifier|*
name|linkedAttribute
init|=
name|usedAttribMap
index|[
name|regLocation
index|]
decl_stmt|;
comment|// In GLSL 3.00, attribute aliasing produces a link error
comment|// In GLSL 1.00, attribute aliasing is allowed, but ANGLE currently has a bug
if|if
condition|(
name|linkedAttribute
condition|)
block|{
comment|// TODO(jmadill): fix aliasing on ES2
comment|// if (mProgram->getShaderVersion()>= 300)
block|{
name|infoLog
operator|<<
literal|"Attribute '"
operator|<<
name|attribute
operator|.
name|name
operator|<<
literal|"' aliases attribute '"
operator|<<
name|linkedAttribute
operator|->
name|name
operator|<<
literal|"' at location "
operator|<<
name|regLocation
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
name|usedAttribMap
index|[
name|regLocation
index|]
operator|=
operator|&
name|attribute
expr_stmt|;
block|}
name|usedLocations
operator||=
literal|1
operator|<<
name|regLocation
expr_stmt|;
block|}
block|}
block|}
comment|// Link attributes that don't have a binding location
for|for
control|(
name|sh
operator|::
name|Attribute
modifier|&
name|attribute
range|:
name|mData
operator|.
name|mAttributes
control|)
block|{
name|ASSERT
argument_list|(
name|attribute
operator|.
name|staticUse
argument_list|)
expr_stmt|;
comment|// Not set by glBindAttribLocation or by location layout qualifier
if|if
condition|(
name|attribute
operator|.
name|location
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|regs
init|=
name|VariableRegisterCount
argument_list|(
name|attribute
operator|.
name|type
argument_list|)
decl_stmt|;
name|int
name|availableIndex
init|=
name|AllocateFirstFreeBits
argument_list|(
operator|&
name|usedLocations
argument_list|,
name|regs
argument_list|,
name|maxAttribs
argument_list|)
decl_stmt|;
if|if
condition|(
name|availableIndex
operator|==
operator|-
literal|1
operator|||
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|availableIndex
operator|+
name|regs
argument_list|)
operator|>
name|maxAttribs
condition|)
block|{
name|infoLog
operator|<<
literal|"Too many active attributes ("
operator|<<
name|attribute
operator|.
name|name
operator|<<
literal|")"
expr_stmt|;
return|return
literal|false
return|;
block|}
name|attribute
operator|.
name|location
operator|=
name|availableIndex
expr_stmt|;
block|}
block|}
for|for
control|(
specifier|const
name|sh
operator|::
name|Attribute
modifier|&
name|attribute
range|:
name|mData
operator|.
name|mAttributes
control|)
block|{
name|ASSERT
argument_list|(
name|attribute
operator|.
name|staticUse
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|attribute
operator|.
name|location
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|regs
init|=
name|VariableRegisterCount
argument_list|(
name|attribute
operator|.
name|type
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|r
init|=
literal|0
init|;
name|r
operator|<
name|regs
condition|;
name|r
operator|++
control|)
block|{
name|mData
operator|.
name|mActiveAttribLocationsMask
operator|.
name|set
argument_list|(
name|attribute
operator|.
name|location
operator|+
name|r
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|linkUniformBlocks
name|bool
name|Program
operator|::
name|linkUniformBlocks
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|Caps
modifier|&
name|caps
parameter_list|)
block|{
specifier|const
name|Shader
modifier|&
name|vertexShader
init|=
operator|*
name|mData
operator|.
name|mAttachedVertexShader
decl_stmt|;
specifier|const
name|Shader
modifier|&
name|fragmentShader
init|=
operator|*
name|mData
operator|.
name|mAttachedFragmentShader
decl_stmt|;
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|InterfaceBlock
argument_list|>
modifier|&
name|vertexInterfaceBlocks
init|=
name|vertexShader
operator|.
name|getInterfaceBlocks
argument_list|()
decl_stmt|;
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|InterfaceBlock
argument_list|>
modifier|&
name|fragmentInterfaceBlocks
init|=
name|fragmentShader
operator|.
name|getInterfaceBlocks
argument_list|()
decl_stmt|;
comment|// Check that interface blocks defined in the vertex and fragment shaders are identical
typedef|typedef
name|std
operator|::
name|map
argument_list|<
name|std
operator|::
name|string
argument_list|,
specifier|const
name|sh
operator|::
name|InterfaceBlock
operator|*
argument_list|>
name|UniformBlockMap
typedef|;
name|UniformBlockMap
name|linkedUniformBlocks
decl_stmt|;
name|GLuint
name|vertexBlockCount
init|=
literal|0
decl_stmt|;
for|for
control|(
specifier|const
name|sh
operator|::
name|InterfaceBlock
modifier|&
name|vertexInterfaceBlock
range|:
name|vertexInterfaceBlocks
control|)
block|{
name|linkedUniformBlocks
index|[
name|vertexInterfaceBlock
operator|.
name|name
index|]
operator|=
operator|&
name|vertexInterfaceBlock
expr_stmt|;
comment|// Note: shared and std140 layouts are always considered active
if|if
condition|(
name|vertexInterfaceBlock
operator|.
name|staticUse
operator|||
name|vertexInterfaceBlock
operator|.
name|layout
operator|!=
name|sh
operator|::
name|BLOCKLAYOUT_PACKED
condition|)
block|{
if|if
condition|(
operator|++
name|vertexBlockCount
operator|>
name|caps
operator|.
name|maxVertexUniformBlocks
condition|)
block|{
name|infoLog
operator|<<
literal|"Vertex shader uniform block count exceed GL_MAX_VERTEX_UNIFORM_BLOCKS ("
operator|<<
name|caps
operator|.
name|maxVertexUniformBlocks
operator|<<
literal|")"
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
name|GLuint
name|fragmentBlockCount
init|=
literal|0
decl_stmt|;
for|for
control|(
specifier|const
name|sh
operator|::
name|InterfaceBlock
modifier|&
name|fragmentInterfaceBlock
range|:
name|fragmentInterfaceBlocks
control|)
block|{
name|auto
name|entry
init|=
name|linkedUniformBlocks
operator|.
name|find
argument_list|(
name|fragmentInterfaceBlock
operator|.
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
name|linkedUniformBlocks
operator|.
name|end
argument_list|()
condition|)
block|{
specifier|const
name|sh
operator|::
name|InterfaceBlock
modifier|&
name|vertexInterfaceBlock
init|=
operator|*
name|entry
operator|->
name|second
decl_stmt|;
if|if
condition|(
operator|!
name|areMatchingInterfaceBlocks
argument_list|(
name|infoLog
argument_list|,
name|vertexInterfaceBlock
argument_list|,
name|fragmentInterfaceBlock
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|// Note: shared and std140 layouts are always considered active
if|if
condition|(
name|fragmentInterfaceBlock
operator|.
name|staticUse
operator|||
name|fragmentInterfaceBlock
operator|.
name|layout
operator|!=
name|sh
operator|::
name|BLOCKLAYOUT_PACKED
condition|)
block|{
if|if
condition|(
operator|++
name|fragmentBlockCount
operator|>
name|caps
operator|.
name|maxFragmentUniformBlocks
condition|)
block|{
name|infoLog
operator|<<
literal|"Fragment shader uniform block count exceed GL_MAX_FRAGMENT_UNIFORM_BLOCKS ("
operator|<<
name|caps
operator|.
name|maxFragmentUniformBlocks
operator|<<
literal|")"
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|areMatchingInterfaceBlocks
name|bool
name|Program
operator|::
name|areMatchingInterfaceBlocks
parameter_list|(
name|gl
operator|::
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|sh
operator|::
name|InterfaceBlock
modifier|&
name|vertexInterfaceBlock
parameter_list|,
specifier|const
name|sh
operator|::
name|InterfaceBlock
modifier|&
name|fragmentInterfaceBlock
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|blockName
init|=
name|vertexInterfaceBlock
operator|.
name|name
operator|.
name|c_str
argument_list|()
decl_stmt|;
comment|// validate blocks for the same member types
if|if
condition|(
name|vertexInterfaceBlock
operator|.
name|fields
operator|.
name|size
argument_list|()
operator|!=
name|fragmentInterfaceBlock
operator|.
name|fields
operator|.
name|size
argument_list|()
condition|)
block|{
name|infoLog
operator|<<
literal|"Types for interface block '"
operator|<<
name|blockName
operator|<<
literal|"' differ between vertex and fragment shaders"
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|vertexInterfaceBlock
operator|.
name|arraySize
operator|!=
name|fragmentInterfaceBlock
operator|.
name|arraySize
condition|)
block|{
name|infoLog
operator|<<
literal|"Array sizes differ for interface block '"
operator|<<
name|blockName
operator|<<
literal|"' between vertex and fragment shaders"
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|vertexInterfaceBlock
operator|.
name|layout
operator|!=
name|fragmentInterfaceBlock
operator|.
name|layout
operator|||
name|vertexInterfaceBlock
operator|.
name|isRowMajorLayout
operator|!=
name|fragmentInterfaceBlock
operator|.
name|isRowMajorLayout
condition|)
block|{
name|infoLog
operator|<<
literal|"Layout qualifiers differ for interface block '"
operator|<<
name|blockName
operator|<<
literal|"' between vertex and fragment shaders"
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|unsigned
name|int
name|numBlockMembers
init|=
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|vertexInterfaceBlock
operator|.
name|fields
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|blockMemberIndex
init|=
literal|0
init|;
name|blockMemberIndex
operator|<
name|numBlockMembers
condition|;
name|blockMemberIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|InterfaceBlockField
modifier|&
name|vertexMember
init|=
name|vertexInterfaceBlock
operator|.
name|fields
index|[
name|blockMemberIndex
index|]
decl_stmt|;
specifier|const
name|sh
operator|::
name|InterfaceBlockField
modifier|&
name|fragmentMember
init|=
name|fragmentInterfaceBlock
operator|.
name|fields
index|[
name|blockMemberIndex
index|]
decl_stmt|;
if|if
condition|(
name|vertexMember
operator|.
name|name
operator|!=
name|fragmentMember
operator|.
name|name
condition|)
block|{
name|infoLog
operator|<<
literal|"Name mismatch for field "
operator|<<
name|blockMemberIndex
operator|<<
literal|" of interface block '"
operator|<<
name|blockName
operator|<<
literal|"': (in vertex: '"
operator|<<
name|vertexMember
operator|.
name|name
operator|<<
literal|"', in fragment: '"
operator|<<
name|fragmentMember
operator|.
name|name
operator|<<
literal|"')"
expr_stmt|;
return|return
literal|false
return|;
block|}
name|std
operator|::
name|string
name|memberName
init|=
literal|"interface block '"
operator|+
name|vertexInterfaceBlock
operator|.
name|name
operator|+
literal|"' member '"
operator|+
name|vertexMember
operator|.
name|name
operator|+
literal|"'"
decl_stmt|;
if|if
condition|(
operator|!
name|linkValidateInterfaceBlockFields
argument_list|(
name|infoLog
argument_list|,
name|memberName
argument_list|,
name|vertexMember
argument_list|,
name|fragmentMember
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|linkValidateVariablesBase
name|bool
name|Program
operator|::
name|linkValidateVariablesBase
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|variableName
parameter_list|,
specifier|const
name|sh
operator|::
name|ShaderVariable
modifier|&
name|vertexVariable
parameter_list|,
specifier|const
name|sh
operator|::
name|ShaderVariable
modifier|&
name|fragmentVariable
parameter_list|,
name|bool
name|validatePrecision
parameter_list|)
block|{
if|if
condition|(
name|vertexVariable
operator|.
name|type
operator|!=
name|fragmentVariable
operator|.
name|type
condition|)
block|{
name|infoLog
operator|<<
literal|"Types for "
operator|<<
name|variableName
operator|<<
literal|" differ between vertex and fragment shaders"
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|vertexVariable
operator|.
name|arraySize
operator|!=
name|fragmentVariable
operator|.
name|arraySize
condition|)
block|{
name|infoLog
operator|<<
literal|"Array sizes for "
operator|<<
name|variableName
operator|<<
literal|" differ between vertex and fragment shaders"
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|validatePrecision
operator|&&
name|vertexVariable
operator|.
name|precision
operator|!=
name|fragmentVariable
operator|.
name|precision
condition|)
block|{
name|infoLog
operator|<<
literal|"Precisions for "
operator|<<
name|variableName
operator|<<
literal|" differ between vertex and fragment shaders"
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|vertexVariable
operator|.
name|fields
operator|.
name|size
argument_list|()
operator|!=
name|fragmentVariable
operator|.
name|fields
operator|.
name|size
argument_list|()
condition|)
block|{
name|infoLog
operator|<<
literal|"Structure lengths for "
operator|<<
name|variableName
operator|<<
literal|" differ between vertex and fragment shaders"
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|unsigned
name|int
name|numMembers
init|=
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|vertexVariable
operator|.
name|fields
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|memberIndex
init|=
literal|0
init|;
name|memberIndex
operator|<
name|numMembers
condition|;
name|memberIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|ShaderVariable
modifier|&
name|vertexMember
init|=
name|vertexVariable
operator|.
name|fields
index|[
name|memberIndex
index|]
decl_stmt|;
specifier|const
name|sh
operator|::
name|ShaderVariable
modifier|&
name|fragmentMember
init|=
name|fragmentVariable
operator|.
name|fields
index|[
name|memberIndex
index|]
decl_stmt|;
if|if
condition|(
name|vertexMember
operator|.
name|name
operator|!=
name|fragmentMember
operator|.
name|name
condition|)
block|{
name|infoLog
operator|<<
literal|"Name mismatch for field '"
operator|<<
name|memberIndex
operator|<<
literal|"' of "
operator|<<
name|variableName
operator|<<
literal|": (in vertex: '"
operator|<<
name|vertexMember
operator|.
name|name
operator|<<
literal|"', in fragment: '"
operator|<<
name|fragmentMember
operator|.
name|name
operator|<<
literal|"')"
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|std
operator|::
name|string
name|memberName
init|=
name|variableName
operator|.
name|substr
argument_list|(
literal|0
argument_list|,
name|variableName
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|+
literal|"."
operator|+
name|vertexMember
operator|.
name|name
operator|+
literal|"'"
decl_stmt|;
if|if
condition|(
operator|!
name|linkValidateVariablesBase
argument_list|(
name|infoLog
argument_list|,
name|vertexMember
operator|.
name|name
argument_list|,
name|vertexMember
argument_list|,
name|fragmentMember
argument_list|,
name|validatePrecision
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|linkValidateUniforms
name|bool
name|Program
operator|::
name|linkValidateUniforms
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|uniformName
parameter_list|,
specifier|const
name|sh
operator|::
name|Uniform
modifier|&
name|vertexUniform
parameter_list|,
specifier|const
name|sh
operator|::
name|Uniform
modifier|&
name|fragmentUniform
parameter_list|)
block|{
if|#
directive|if
name|ANGLE_PROGRAM_LINK_VALIDATE_UNIFORM_PRECISION
operator|==
name|ANGLE_ENABLED
specifier|const
name|bool
name|validatePrecision
init|=
literal|true
decl_stmt|;
else|#
directive|else
specifier|const
name|bool
name|validatePrecision
init|=
literal|false
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|linkValidateVariablesBase
argument_list|(
name|infoLog
argument_list|,
name|uniformName
argument_list|,
name|vertexUniform
argument_list|,
name|fragmentUniform
argument_list|,
name|validatePrecision
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|linkValidateVaryings
name|bool
name|Program
operator|::
name|linkValidateVaryings
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|varyingName
parameter_list|,
specifier|const
name|sh
operator|::
name|Varying
modifier|&
name|vertexVarying
parameter_list|,
specifier|const
name|sh
operator|::
name|Varying
modifier|&
name|fragmentVarying
parameter_list|)
block|{
if|if
condition|(
operator|!
name|linkValidateVariablesBase
argument_list|(
name|infoLog
argument_list|,
name|varyingName
argument_list|,
name|vertexVarying
argument_list|,
name|fragmentVarying
argument_list|,
literal|false
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|sh
operator|::
name|InterpolationTypesMatch
argument_list|(
name|vertexVarying
operator|.
name|interpolation
argument_list|,
name|fragmentVarying
operator|.
name|interpolation
argument_list|)
condition|)
block|{
name|infoLog
operator|<<
literal|"Interpolation types for "
operator|<<
name|varyingName
operator|<<
literal|" differ between vertex and fragment shaders"
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|linkValidateTransformFeedback
name|bool
name|Program
operator|::
name|linkValidateTransformFeedback
parameter_list|(
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|std
operator|::
name|vector
argument_list|<
specifier|const
name|sh
operator|::
name|Varying
operator|*
argument_list|>
modifier|&
name|varyings
parameter_list|,
specifier|const
name|Caps
modifier|&
name|caps
parameter_list|)
specifier|const
block|{
name|size_t
name|totalComponents
init|=
literal|0
decl_stmt|;
name|std
operator|::
name|set
argument_list|<
name|std
operator|::
name|string
argument_list|>
name|uniqueNames
decl_stmt|;
for|for
control|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|tfVaryingName
range|:
name|mData
operator|.
name|mTransformFeedbackVaryingNames
control|)
block|{
name|bool
name|found
init|=
literal|false
decl_stmt|;
for|for
control|(
specifier|const
name|sh
operator|::
name|Varying
modifier|*
name|varying
range|:
name|varyings
control|)
block|{
if|if
condition|(
name|tfVaryingName
operator|==
name|varying
operator|->
name|name
condition|)
block|{
if|if
condition|(
name|uniqueNames
operator|.
name|count
argument_list|(
name|tfVaryingName
argument_list|)
operator|>
literal|0
condition|)
block|{
name|infoLog
operator|<<
literal|"Two transform feedback varyings specify the same output variable ("
operator|<<
name|tfVaryingName
operator|<<
literal|")."
expr_stmt|;
return|return
literal|false
return|;
block|}
name|uniqueNames
operator|.
name|insert
argument_list|(
name|tfVaryingName
argument_list|)
expr_stmt|;
if|if
condition|(
name|varying
operator|->
name|isArray
argument_list|()
condition|)
block|{
name|infoLog
operator|<<
literal|"Capture of arrays is undefined and not supported."
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// TODO(jmadill): Investigate implementation limits on D3D11
name|size_t
name|componentCount
init|=
name|gl
operator|::
name|VariableComponentCount
argument_list|(
name|varying
operator|->
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|mData
operator|.
name|mTransformFeedbackBufferMode
operator|==
name|GL_SEPARATE_ATTRIBS
operator|&&
name|componentCount
operator|>
name|caps
operator|.
name|maxTransformFeedbackSeparateComponents
condition|)
block|{
name|infoLog
operator|<<
literal|"Transform feedback varying's "
operator|<<
name|varying
operator|->
name|name
operator|<<
literal|" components ("
operator|<<
name|componentCount
operator|<<
literal|") exceed the maximum separate components ("
operator|<<
name|caps
operator|.
name|maxTransformFeedbackSeparateComponents
operator|<<
literal|")."
expr_stmt|;
return|return
literal|false
return|;
block|}
name|totalComponents
operator|+=
name|componentCount
expr_stmt|;
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|tfVaryingName
operator|.
name|find
argument_list|(
literal|'['
argument_list|)
operator|!=
name|std
operator|::
name|string
operator|::
name|npos
condition|)
block|{
name|infoLog
operator|<<
literal|"Capture of array elements is undefined and not supported."
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// All transform feedback varyings are expected to exist since packVaryings checks for them.
name|ASSERT
argument_list|(
name|found
argument_list|)
expr_stmt|;
name|UNUSED_ASSERTION_VARIABLE
argument_list|(
name|found
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mData
operator|.
name|mTransformFeedbackBufferMode
operator|==
name|GL_INTERLEAVED_ATTRIBS
operator|&&
name|totalComponents
operator|>
name|caps
operator|.
name|maxTransformFeedbackInterleavedComponents
condition|)
block|{
name|infoLog
operator|<<
literal|"Transform feedback varying total components ("
operator|<<
name|totalComponents
operator|<<
literal|") exceed the maximum interleaved components ("
operator|<<
name|caps
operator|.
name|maxTransformFeedbackInterleavedComponents
operator|<<
literal|")."
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|gatherTransformFeedbackVaryings
name|void
name|Program
operator|::
name|gatherTransformFeedbackVaryings
parameter_list|(
specifier|const
name|std
operator|::
name|vector
argument_list|<
specifier|const
name|sh
operator|::
name|Varying
operator|*
argument_list|>
modifier|&
name|varyings
parameter_list|)
block|{
comment|// Gather the linked varyings that are used for transform feedback, they should all exist.
name|mData
operator|.
name|mTransformFeedbackVaryingVars
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|tfVaryingName
range|:
name|mData
operator|.
name|mTransformFeedbackVaryingNames
control|)
block|{
for|for
control|(
specifier|const
name|sh
operator|::
name|Varying
modifier|*
name|varying
range|:
name|varyings
control|)
block|{
if|if
condition|(
name|tfVaryingName
operator|==
name|varying
operator|->
name|name
condition|)
block|{
name|mData
operator|.
name|mTransformFeedbackVaryingVars
operator|.
name|push_back
argument_list|(
operator|*
name|varying
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
DECL|function|getMergedVaryings
name|std
operator|::
name|vector
argument_list|<
specifier|const
name|sh
operator|::
name|Varying
operator|*
argument_list|>
name|Program
operator|::
name|getMergedVaryings
parameter_list|()
specifier|const
block|{
name|std
operator|::
name|set
argument_list|<
name|std
operator|::
name|string
argument_list|>
name|uniqueNames
decl_stmt|;
name|std
operator|::
name|vector
argument_list|<
specifier|const
name|sh
operator|::
name|Varying
operator|*
argument_list|>
name|varyings
decl_stmt|;
for|for
control|(
specifier|const
name|sh
operator|::
name|Varying
modifier|&
name|varying
range|:
name|mData
operator|.
name|mAttachedVertexShader
operator|->
name|getVaryings
argument_list|()
control|)
block|{
if|if
condition|(
name|uniqueNames
operator|.
name|count
argument_list|(
name|varying
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|uniqueNames
operator|.
name|insert
argument_list|(
name|varying
operator|.
name|name
argument_list|)
expr_stmt|;
name|varyings
operator|.
name|push_back
argument_list|(
operator|&
name|varying
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
specifier|const
name|sh
operator|::
name|Varying
modifier|&
name|varying
range|:
name|mData
operator|.
name|mAttachedFragmentShader
operator|->
name|getVaryings
argument_list|()
control|)
block|{
if|if
condition|(
name|uniqueNames
operator|.
name|count
argument_list|(
name|varying
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|uniqueNames
operator|.
name|insert
argument_list|(
name|varying
operator|.
name|name
argument_list|)
expr_stmt|;
name|varyings
operator|.
name|push_back
argument_list|(
operator|&
name|varying
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|varyings
return|;
block|}
DECL|function|linkOutputVariables
name|void
name|Program
operator|::
name|linkOutputVariables
parameter_list|()
block|{
specifier|const
name|Shader
modifier|*
name|fragmentShader
init|=
name|mData
operator|.
name|mAttachedFragmentShader
decl_stmt|;
name|ASSERT
argument_list|(
name|fragmentShader
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
comment|// Skip this step for GLES2 shaders.
if|if
condition|(
name|fragmentShader
operator|->
name|getShaderVersion
argument_list|()
operator|==
literal|100
condition|)
return|return;
specifier|const
specifier|auto
modifier|&
name|shaderOutputVars
init|=
name|fragmentShader
operator|->
name|getActiveOutputVariables
argument_list|()
decl_stmt|;
comment|// TODO(jmadill): any caps validation here?
for|for
control|(
name|unsigned
name|int
name|outputVariableIndex
init|=
literal|0
init|;
name|outputVariableIndex
operator|<
name|shaderOutputVars
operator|.
name|size
argument_list|()
condition|;
name|outputVariableIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|OutputVariable
modifier|&
name|outputVariable
init|=
name|shaderOutputVars
index|[
name|outputVariableIndex
index|]
decl_stmt|;
comment|// Don't store outputs for gl_FragDepth, gl_FragColor, etc.
if|if
condition|(
name|outputVariable
operator|.
name|isBuiltIn
argument_list|()
condition|)
continue|continue;
comment|// Since multiple output locations must be specified, use 0 for non-specified locations.
name|int
name|baseLocation
init|=
operator|(
name|outputVariable
operator|.
name|location
operator|==
operator|-
literal|1
condition|?
literal|0
else|:
name|outputVariable
operator|.
name|location
operator|)
decl_stmt|;
name|ASSERT
argument_list|(
name|outputVariable
operator|.
name|staticUse
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|elementIndex
init|=
literal|0
init|;
name|elementIndex
operator|<
name|outputVariable
operator|.
name|elementCount
argument_list|()
condition|;
name|elementIndex
operator|++
control|)
block|{
specifier|const
name|int
name|location
init|=
name|baseLocation
operator|+
name|elementIndex
decl_stmt|;
name|ASSERT
argument_list|(
name|mData
operator|.
name|mOutputVariables
operator|.
name|count
argument_list|(
name|location
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|unsigned
name|int
name|element
init|=
name|outputVariable
operator|.
name|isArray
argument_list|()
condition|?
name|elementIndex
else|:
name|GL_INVALID_INDEX
decl_stmt|;
name|mData
operator|.
name|mOutputVariables
index|[
name|location
index|]
operator|=
name|VariableLocation
argument_list|(
name|outputVariable
operator|.
name|name
argument_list|,
name|element
argument_list|,
name|outputVariableIndex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|flattenUniformsAndCheckCaps
name|bool
name|Program
operator|::
name|flattenUniformsAndCheckCaps
parameter_list|(
specifier|const
name|Caps
modifier|&
name|caps
parameter_list|,
name|InfoLog
modifier|&
name|infoLog
parameter_list|)
block|{
specifier|const
name|gl
operator|::
name|Shader
modifier|*
name|vertexShader
init|=
name|mData
operator|.
name|getAttachedVertexShader
argument_list|()
decl_stmt|;
name|VectorAndSamplerCount
name|vsCounts
decl_stmt|;
name|std
operator|::
name|vector
argument_list|<
name|LinkedUniform
argument_list|>
name|samplerUniforms
decl_stmt|;
for|for
control|(
specifier|const
name|sh
operator|::
name|Uniform
modifier|&
name|uniform
range|:
name|vertexShader
operator|->
name|getUniforms
argument_list|()
control|)
block|{
if|if
condition|(
name|uniform
operator|.
name|staticUse
condition|)
block|{
name|vsCounts
operator|+=
name|flattenUniform
argument_list|(
name|uniform
argument_list|,
name|uniform
operator|.
name|name
argument_list|,
operator|&
name|samplerUniforms
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|vsCounts
operator|.
name|vectorCount
operator|>
name|caps
operator|.
name|maxVertexUniformVectors
condition|)
block|{
name|infoLog
operator|<<
literal|"Vertex shader active uniforms exceed MAX_VERTEX_UNIFORM_VECTORS ("
operator|<<
name|caps
operator|.
name|maxVertexUniformVectors
operator|<<
literal|")."
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|vsCounts
operator|.
name|samplerCount
operator|>
name|caps
operator|.
name|maxVertexTextureImageUnits
condition|)
block|{
name|infoLog
operator|<<
literal|"Vertex shader sampler count exceeds MAX_VERTEX_TEXTURE_IMAGE_UNITS ("
operator|<<
name|caps
operator|.
name|maxVertexTextureImageUnits
operator|<<
literal|")."
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|gl
operator|::
name|Shader
modifier|*
name|fragmentShader
init|=
name|mData
operator|.
name|getAttachedFragmentShader
argument_list|()
decl_stmt|;
name|VectorAndSamplerCount
name|fsCounts
decl_stmt|;
for|for
control|(
specifier|const
name|sh
operator|::
name|Uniform
modifier|&
name|uniform
range|:
name|fragmentShader
operator|->
name|getUniforms
argument_list|()
control|)
block|{
if|if
condition|(
name|uniform
operator|.
name|staticUse
condition|)
block|{
name|fsCounts
operator|+=
name|flattenUniform
argument_list|(
name|uniform
argument_list|,
name|uniform
operator|.
name|name
argument_list|,
operator|&
name|samplerUniforms
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fsCounts
operator|.
name|vectorCount
operator|>
name|caps
operator|.
name|maxFragmentUniformVectors
condition|)
block|{
name|infoLog
operator|<<
literal|"Fragment shader active uniforms exceed MAX_FRAGMENT_UNIFORM_VECTORS ("
operator|<<
name|caps
operator|.
name|maxFragmentUniformVectors
operator|<<
literal|")."
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|fsCounts
operator|.
name|samplerCount
operator|>
name|caps
operator|.
name|maxTextureImageUnits
condition|)
block|{
name|infoLog
operator|<<
literal|"Fragment shader sampler count exceeds MAX_TEXTURE_IMAGE_UNITS ("
operator|<<
name|caps
operator|.
name|maxTextureImageUnits
operator|<<
literal|")."
expr_stmt|;
return|return
literal|false
return|;
block|}
name|mSamplerUniformRange
operator|.
name|start
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|mData
operator|.
name|mUniforms
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|mSamplerUniformRange
operator|.
name|end
operator|=
name|mSamplerUniformRange
operator|.
name|start
operator|+
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|samplerUniforms
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|mData
operator|.
name|mUniforms
operator|.
name|insert
argument_list|(
name|mData
operator|.
name|mUniforms
operator|.
name|end
argument_list|()
argument_list|,
name|samplerUniforms
operator|.
name|begin
argument_list|()
argument_list|,
name|samplerUniforms
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|flattenUniform
name|Program
operator|::
name|VectorAndSamplerCount
name|Program
operator|::
name|flattenUniform
parameter_list|(
specifier|const
name|sh
operator|::
name|ShaderVariable
modifier|&
name|uniform
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|fullName
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|LinkedUniform
argument_list|>
modifier|*
name|samplerUniforms
parameter_list|)
block|{
name|VectorAndSamplerCount
name|vectorAndSamplerCount
decl_stmt|;
if|if
condition|(
name|uniform
operator|.
name|isStruct
argument_list|()
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|elementIndex
init|=
literal|0
init|;
name|elementIndex
operator|<
name|uniform
operator|.
name|elementCount
argument_list|()
condition|;
name|elementIndex
operator|++
control|)
block|{
specifier|const
name|std
operator|::
name|string
modifier|&
name|elementString
init|=
operator|(
name|uniform
operator|.
name|isArray
argument_list|()
condition|?
name|ArrayString
argument_list|(
name|elementIndex
argument_list|)
else|:
literal|""
operator|)
decl_stmt|;
for|for
control|(
name|size_t
name|fieldIndex
init|=
literal|0
init|;
name|fieldIndex
operator|<
name|uniform
operator|.
name|fields
operator|.
name|size
argument_list|()
condition|;
name|fieldIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|ShaderVariable
modifier|&
name|field
init|=
name|uniform
operator|.
name|fields
index|[
name|fieldIndex
index|]
decl_stmt|;
specifier|const
name|std
operator|::
name|string
modifier|&
name|fieldFullName
init|=
operator|(
name|fullName
operator|+
name|elementString
operator|+
literal|"."
operator|+
name|field
operator|.
name|name
operator|)
decl_stmt|;
name|vectorAndSamplerCount
operator|+=
name|flattenUniform
argument_list|(
name|field
argument_list|,
name|fieldFullName
argument_list|,
name|samplerUniforms
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|vectorAndSamplerCount
return|;
block|}
comment|// Not a struct
name|bool
name|isSampler
init|=
name|IsSamplerType
argument_list|(
name|uniform
operator|.
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|UniformInList
argument_list|(
name|mData
operator|.
name|getUniforms
argument_list|()
argument_list|,
name|fullName
argument_list|)
operator|&&
operator|!
name|UniformInList
argument_list|(
operator|*
name|samplerUniforms
argument_list|,
name|fullName
argument_list|)
condition|)
block|{
name|gl
operator|::
name|LinkedUniform
name|linkedUniform
argument_list|(
name|uniform
operator|.
name|type
argument_list|,
name|uniform
operator|.
name|precision
argument_list|,
name|fullName
argument_list|,
name|uniform
operator|.
name|arraySize
argument_list|,
operator|-
literal|1
argument_list|,
name|sh
operator|::
name|BlockMemberInfo
operator|::
name|getDefaultBlockInfo
argument_list|()
argument_list|)
decl_stmt|;
name|linkedUniform
operator|.
name|staticUse
operator|=
literal|true
expr_stmt|;
comment|// Store sampler uniforms separately, so we'll append them to the end of the list.
if|if
condition|(
name|isSampler
condition|)
block|{
name|samplerUniforms
operator|->
name|push_back
argument_list|(
name|linkedUniform
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mData
operator|.
name|mUniforms
operator|.
name|push_back
argument_list|(
name|linkedUniform
argument_list|)
expr_stmt|;
block|}
block|}
name|unsigned
name|int
name|elementCount
init|=
name|uniform
operator|.
name|elementCount
argument_list|()
decl_stmt|;
comment|// Samplers aren't "real" uniforms, so they don't count towards register usage.
comment|// Likewise, don't count "real" uniforms towards sampler count.
name|vectorAndSamplerCount
operator|.
name|vectorCount
operator|=
operator|(
name|isSampler
condition|?
literal|0
else|:
operator|(
name|VariableRegisterCount
argument_list|(
name|uniform
operator|.
name|type
argument_list|)
operator|*
name|elementCount
operator|)
operator|)
expr_stmt|;
name|vectorAndSamplerCount
operator|.
name|samplerCount
operator|=
operator|(
name|isSampler
condition|?
name|elementCount
else|:
literal|0
operator|)
expr_stmt|;
return|return
name|vectorAndSamplerCount
return|;
block|}
DECL|function|gatherInterfaceBlockInfo
name|void
name|Program
operator|::
name|gatherInterfaceBlockInfo
parameter_list|()
block|{
name|std
operator|::
name|set
argument_list|<
name|std
operator|::
name|string
argument_list|>
name|visitedList
decl_stmt|;
specifier|const
name|gl
operator|::
name|Shader
modifier|*
name|vertexShader
init|=
name|mData
operator|.
name|getAttachedVertexShader
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|mData
operator|.
name|mUniformBlocks
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
specifier|const
name|sh
operator|::
name|InterfaceBlock
modifier|&
name|vertexBlock
range|:
name|vertexShader
operator|->
name|getInterfaceBlocks
argument_list|()
control|)
block|{
comment|// Only 'packed' blocks are allowed to be considered inacive.
if|if
condition|(
operator|!
name|vertexBlock
operator|.
name|staticUse
operator|&&
name|vertexBlock
operator|.
name|layout
operator|==
name|sh
operator|::
name|BLOCKLAYOUT_PACKED
condition|)
continue|continue;
if|if
condition|(
name|visitedList
operator|.
name|count
argument_list|(
name|vertexBlock
operator|.
name|name
argument_list|)
operator|>
literal|0
condition|)
continue|continue;
name|defineUniformBlock
argument_list|(
name|vertexBlock
argument_list|,
name|GL_VERTEX_SHADER
argument_list|)
expr_stmt|;
name|visitedList
operator|.
name|insert
argument_list|(
name|vertexBlock
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
specifier|const
name|gl
operator|::
name|Shader
modifier|*
name|fragmentShader
init|=
name|mData
operator|.
name|getAttachedFragmentShader
argument_list|()
decl_stmt|;
for|for
control|(
specifier|const
name|sh
operator|::
name|InterfaceBlock
modifier|&
name|fragmentBlock
range|:
name|fragmentShader
operator|->
name|getInterfaceBlocks
argument_list|()
control|)
block|{
comment|// Only 'packed' blocks are allowed to be considered inacive.
if|if
condition|(
operator|!
name|fragmentBlock
operator|.
name|staticUse
operator|&&
name|fragmentBlock
operator|.
name|layout
operator|==
name|sh
operator|::
name|BLOCKLAYOUT_PACKED
condition|)
continue|continue;
if|if
condition|(
name|visitedList
operator|.
name|count
argument_list|(
name|fragmentBlock
operator|.
name|name
argument_list|)
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|gl
operator|::
name|UniformBlock
modifier|&
name|block
range|:
name|mData
operator|.
name|mUniformBlocks
control|)
block|{
if|if
condition|(
name|block
operator|.
name|name
operator|==
name|fragmentBlock
operator|.
name|name
condition|)
block|{
name|block
operator|.
name|fragmentStaticUse
operator|=
name|fragmentBlock
operator|.
name|staticUse
expr_stmt|;
block|}
block|}
continue|continue;
block|}
name|defineUniformBlock
argument_list|(
name|fragmentBlock
argument_list|,
name|GL_FRAGMENT_SHADER
argument_list|)
expr_stmt|;
name|visitedList
operator|.
name|insert
argument_list|(
name|fragmentBlock
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
template|template
parameter_list|<
name|typename
name|VarT
parameter_list|>
DECL|function|defineUniformBlockMembers
name|void
name|Program
operator|::
name|defineUniformBlockMembers
parameter_list|(
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|VarT
argument_list|>
modifier|&
name|fields
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|prefix
parameter_list|,
name|int
name|blockIndex
parameter_list|)
block|{
for|for
control|(
specifier|const
name|VarT
modifier|&
name|field
range|:
name|fields
control|)
block|{
specifier|const
name|std
operator|::
name|string
modifier|&
name|fullName
init|=
operator|(
name|prefix
operator|.
name|empty
argument_list|()
condition|?
name|field
operator|.
name|name
else|:
name|prefix
operator|+
literal|"."
operator|+
name|field
operator|.
name|name
operator|)
decl_stmt|;
if|if
condition|(
name|field
operator|.
name|isStruct
argument_list|()
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|arrayElement
init|=
literal|0
init|;
name|arrayElement
operator|<
name|field
operator|.
name|elementCount
argument_list|()
condition|;
name|arrayElement
operator|++
control|)
block|{
specifier|const
name|std
operator|::
name|string
name|uniformElementName
init|=
name|fullName
operator|+
operator|(
name|field
operator|.
name|isArray
argument_list|()
condition|?
name|ArrayString
argument_list|(
name|arrayElement
argument_list|)
else|:
literal|""
operator|)
decl_stmt|;
name|defineUniformBlockMembers
argument_list|(
name|field
operator|.
name|fields
argument_list|,
name|uniformElementName
argument_list|,
name|blockIndex
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// If getBlockMemberInfo returns false, the uniform is optimized out.
name|sh
operator|::
name|BlockMemberInfo
name|memberInfo
decl_stmt|;
if|if
condition|(
operator|!
name|mProgram
operator|->
name|getUniformBlockMemberInfo
argument_list|(
name|fullName
argument_list|,
operator|&
name|memberInfo
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|LinkedUniform
name|newUniform
argument_list|(
name|field
operator|.
name|type
argument_list|,
name|field
operator|.
name|precision
argument_list|,
name|fullName
argument_list|,
name|field
operator|.
name|arraySize
argument_list|,
name|blockIndex
argument_list|,
name|memberInfo
argument_list|)
decl_stmt|;
comment|// Since block uniforms have no location, we don't need to store them in the uniform
comment|// locations list.
name|mData
operator|.
name|mUniforms
operator|.
name|push_back
argument_list|(
name|newUniform
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|defineUniformBlock
name|void
name|Program
operator|::
name|defineUniformBlock
parameter_list|(
specifier|const
name|sh
operator|::
name|InterfaceBlock
modifier|&
name|interfaceBlock
parameter_list|,
name|GLenum
name|shaderType
parameter_list|)
block|{
name|int
name|blockIndex
init|=
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|mData
operator|.
name|mUniformBlocks
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|size_t
name|blockSize
init|=
literal|0
decl_stmt|;
comment|// Don't define this block at all if it's not active in the implementation.
if|if
condition|(
operator|!
name|mProgram
operator|->
name|getUniformBlockSize
argument_list|(
name|interfaceBlock
operator|.
name|name
argument_list|,
operator|&
name|blockSize
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// Track the first and last uniform index to determine the range of active uniforms in the
comment|// block.
name|size_t
name|firstBlockUniformIndex
init|=
name|mData
operator|.
name|mUniforms
operator|.
name|size
argument_list|()
decl_stmt|;
name|defineUniformBlockMembers
argument_list|(
name|interfaceBlock
operator|.
name|fields
argument_list|,
name|interfaceBlock
operator|.
name|fieldPrefix
argument_list|()
argument_list|,
name|blockIndex
argument_list|)
expr_stmt|;
name|size_t
name|lastBlockUniformIndex
init|=
name|mData
operator|.
name|mUniforms
operator|.
name|size
argument_list|()
decl_stmt|;
name|std
operator|::
name|vector
argument_list|<
name|unsigned
name|int
argument_list|>
name|blockUniformIndexes
decl_stmt|;
for|for
control|(
name|size_t
name|blockUniformIndex
init|=
name|firstBlockUniformIndex
init|;
name|blockUniformIndex
operator|<
name|lastBlockUniformIndex
condition|;
operator|++
name|blockUniformIndex
control|)
block|{
name|blockUniformIndexes
operator|.
name|push_back
argument_list|(
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|blockUniformIndex
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|interfaceBlock
operator|.
name|arraySize
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|arrayElement
init|=
literal|0
init|;
name|arrayElement
operator|<
name|interfaceBlock
operator|.
name|arraySize
condition|;
operator|++
name|arrayElement
control|)
block|{
name|UniformBlock
name|block
argument_list|(
name|interfaceBlock
operator|.
name|name
argument_list|,
literal|true
argument_list|,
name|arrayElement
argument_list|)
decl_stmt|;
name|block
operator|.
name|memberUniformIndexes
operator|=
name|blockUniformIndexes
expr_stmt|;
if|if
condition|(
name|shaderType
operator|==
name|GL_VERTEX_SHADER
condition|)
block|{
name|block
operator|.
name|vertexStaticUse
operator|=
name|interfaceBlock
operator|.
name|staticUse
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|shaderType
operator|==
name|GL_FRAGMENT_SHADER
argument_list|)
expr_stmt|;
name|block
operator|.
name|fragmentStaticUse
operator|=
name|interfaceBlock
operator|.
name|staticUse
expr_stmt|;
block|}
comment|// TODO(jmadill): Determine if we can ever have an inactive array element block.
name|size_t
name|blockElementSize
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|mProgram
operator|->
name|getUniformBlockSize
argument_list|(
name|block
operator|.
name|nameWithArrayIndex
argument_list|()
argument_list|,
operator|&
name|blockElementSize
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|ASSERT
argument_list|(
name|blockElementSize
operator|==
name|blockSize
argument_list|)
expr_stmt|;
name|block
operator|.
name|dataSize
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|blockElementSize
argument_list|)
expr_stmt|;
name|mData
operator|.
name|mUniformBlocks
operator|.
name|push_back
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|UniformBlock
name|block
argument_list|(
name|interfaceBlock
operator|.
name|name
argument_list|,
literal|false
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|block
operator|.
name|memberUniformIndexes
operator|=
name|blockUniformIndexes
expr_stmt|;
if|if
condition|(
name|shaderType
operator|==
name|GL_VERTEX_SHADER
condition|)
block|{
name|block
operator|.
name|vertexStaticUse
operator|=
name|interfaceBlock
operator|.
name|staticUse
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|shaderType
operator|==
name|GL_FRAGMENT_SHADER
argument_list|)
expr_stmt|;
name|block
operator|.
name|fragmentStaticUse
operator|=
name|interfaceBlock
operator|.
name|staticUse
expr_stmt|;
block|}
name|block
operator|.
name|dataSize
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|blockSize
argument_list|)
expr_stmt|;
name|mData
operator|.
name|mUniformBlocks
operator|.
name|push_back
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
block|}
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|setUniformInternal
name|void
name|Program
operator|::
name|setUniformInternal
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|T
modifier|*
name|v
parameter_list|)
block|{
specifier|const
name|VariableLocation
modifier|&
name|locationInfo
init|=
name|mData
operator|.
name|mUniformLocations
index|[
name|location
index|]
decl_stmt|;
name|LinkedUniform
modifier|*
name|linkedUniform
init|=
operator|&
name|mData
operator|.
name|mUniforms
index|[
name|locationInfo
operator|.
name|index
index|]
decl_stmt|;
name|uint8_t
modifier|*
name|destPointer
init|=
name|linkedUniform
operator|->
name|getDataPtrToElement
argument_list|(
name|locationInfo
operator|.
name|element
argument_list|)
decl_stmt|;
if|if
condition|(
name|VariableComponentType
argument_list|(
name|linkedUniform
operator|->
name|type
argument_list|)
operator|==
name|GL_BOOL
condition|)
block|{
comment|// Do a cast conversion for boolean types. From the spec:
comment|// "The uniform is set to FALSE if the input value is 0 or 0.0f, and set to TRUE otherwise."
name|GLint
modifier|*
name|destAsInt
init|=
cast|reinterpret_cast
argument_list|<
name|GLint
operator|*
argument_list|>
argument_list|(
name|destPointer
argument_list|)
decl_stmt|;
for|for
control|(
name|GLsizei
name|component
init|=
literal|0
init|;
name|component
operator|<
name|count
condition|;
operator|++
name|component
control|)
block|{
name|destAsInt
index|[
name|component
index|]
operator|=
operator|(
name|v
index|[
name|component
index|]
operator|!=
cast|static_cast
argument_list|<
name|T
argument_list|>
argument_list|(
literal|0
argument_list|)
condition|?
name|GL_TRUE
else|:
name|GL_FALSE
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Invalide the validation cache if we modify the sampler data.
if|if
condition|(
name|linkedUniform
operator|->
name|isSampler
argument_list|()
operator|&&
name|memcmp
argument_list|(
name|destPointer
argument_list|,
name|v
argument_list|,
sizeof|sizeof
argument_list|(
name|T
argument_list|)
operator|*
name|count
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mCachedValidateSamplersResult
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|destPointer
argument_list|,
name|v
argument_list|,
sizeof|sizeof
argument_list|(
name|T
argument_list|)
operator|*
name|count
argument_list|)
expr_stmt|;
block|}
block|}
template|template
parameter_list|<
name|size_t
name|cols
parameter_list|,
name|size_t
name|rows
parameter_list|,
name|typename
name|T
parameter_list|>
DECL|function|setMatrixUniformInternal
name|void
name|Program
operator|::
name|setMatrixUniformInternal
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|T
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
operator|!
name|transpose
condition|)
block|{
name|setUniformInternal
argument_list|(
name|location
argument_list|,
name|count
operator|*
name|cols
operator|*
name|rows
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Perform a transposing copy.
specifier|const
name|VariableLocation
modifier|&
name|locationInfo
init|=
name|mData
operator|.
name|mUniformLocations
index|[
name|location
index|]
decl_stmt|;
name|LinkedUniform
modifier|*
name|linkedUniform
init|=
operator|&
name|mData
operator|.
name|mUniforms
index|[
name|locationInfo
operator|.
name|index
index|]
decl_stmt|;
name|T
modifier|*
name|destPtr
init|=
cast|reinterpret_cast
argument_list|<
name|T
operator|*
argument_list|>
argument_list|(
name|linkedUniform
operator|->
name|getDataPtrToElement
argument_list|(
name|locationInfo
operator|.
name|element
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|GLsizei
name|element
init|=
literal|0
init|;
name|element
operator|<
name|count
condition|;
operator|++
name|element
control|)
block|{
name|size_t
name|elementOffset
init|=
name|element
operator|*
name|rows
operator|*
name|cols
decl_stmt|;
for|for
control|(
name|size_t
name|row
init|=
literal|0
init|;
name|row
operator|<
name|rows
condition|;
operator|++
name|row
control|)
block|{
for|for
control|(
name|size_t
name|col
init|=
literal|0
init|;
name|col
operator|<
name|cols
condition|;
operator|++
name|col
control|)
block|{
name|destPtr
index|[
name|col
operator|*
name|rows
operator|+
name|row
operator|+
name|elementOffset
index|]
operator|=
name|v
index|[
name|row
operator|*
name|cols
operator|+
name|col
operator|+
name|elementOffset
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
template|template
parameter_list|<
name|typename
name|DestT
parameter_list|>
DECL|function|getUniformInternal
name|void
name|Program
operator|::
name|getUniformInternal
parameter_list|(
name|GLint
name|location
parameter_list|,
name|DestT
modifier|*
name|dataOut
parameter_list|)
specifier|const
block|{
specifier|const
name|VariableLocation
modifier|&
name|locationInfo
init|=
name|mData
operator|.
name|mUniformLocations
index|[
name|location
index|]
decl_stmt|;
specifier|const
name|LinkedUniform
modifier|&
name|uniform
init|=
name|mData
operator|.
name|mUniforms
index|[
name|locationInfo
operator|.
name|index
index|]
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|srcPointer
init|=
name|uniform
operator|.
name|getDataPtrToElement
argument_list|(
name|locationInfo
operator|.
name|element
argument_list|)
decl_stmt|;
name|GLenum
name|componentType
init|=
name|VariableComponentType
argument_list|(
name|uniform
operator|.
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|componentType
operator|==
name|GLTypeToGLenum
argument_list|<
name|DestT
argument_list|>
operator|::
name|value
condition|)
block|{
name|memcpy
argument_list|(
name|dataOut
argument_list|,
name|srcPointer
argument_list|,
name|uniform
operator|.
name|getElementSize
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|components
init|=
name|VariableComponentCount
argument_list|(
name|uniform
operator|.
name|type
argument_list|)
operator|*
name|uniform
operator|.
name|elementCount
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|componentType
condition|)
block|{
case|case
name|GL_INT
case|:
name|UniformStateQueryCastLoop
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|dataOut
argument_list|,
name|srcPointer
argument_list|,
name|components
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_INT
case|:
name|UniformStateQueryCastLoop
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|dataOut
argument_list|,
name|srcPointer
argument_list|,
name|components
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_BOOL
case|:
name|UniformStateQueryCastLoop
argument_list|<
name|GLboolean
argument_list|>
argument_list|(
name|dataOut
argument_list|,
name|srcPointer
argument_list|,
name|components
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_FLOAT
case|:
name|UniformStateQueryCastLoop
argument_list|<
name|GLfloat
argument_list|>
argument_list|(
name|dataOut
argument_list|,
name|srcPointer
argument_list|,
name|components
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_namespace
end_unit
