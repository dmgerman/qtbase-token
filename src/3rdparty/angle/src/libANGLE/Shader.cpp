begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Shader.cpp: Implements the gl::Shader class and its  derived classes
end_comment
begin_comment
comment|// VertexShader and FragmentShader. Implements GL shader objects and related
end_comment
begin_comment
comment|// functionality. [OpenGL ES 2.0.24] section 2.10 page 24 and section 3.8 page 84.
end_comment
begin_include
include|#
directive|include
file|"libANGLE/Shader.h"
end_include
begin_include
include|#
directive|include
file|<sstream>
end_include
begin_include
include|#
directive|include
file|"common/utilities.h"
end_include
begin_include
include|#
directive|include
file|"GLSLANG/ShaderLang.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Compiler.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Constants.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/Renderer.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/ShaderImpl.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/ResourceManager.h"
end_include
begin_namespace
DECL|namespace|gl
namespace|namespace
name|gl
block|{
namespace|namespace
block|{
template|template
parameter_list|<
name|typename
name|VarT
parameter_list|>
DECL|function|GetActiveShaderVariables
name|std
operator|::
name|vector
argument_list|<
name|VarT
argument_list|>
name|GetActiveShaderVariables
parameter_list|(
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|VarT
argument_list|>
modifier|*
name|variableList
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|variableList
argument_list|)
expr_stmt|;
name|std
operator|::
name|vector
argument_list|<
name|VarT
argument_list|>
name|result
decl_stmt|;
for|for
control|(
name|size_t
name|varIndex
init|=
literal|0
init|;
name|varIndex
operator|<
name|variableList
operator|->
name|size
argument_list|()
condition|;
name|varIndex
operator|++
control|)
block|{
specifier|const
name|VarT
modifier|&
name|var
init|=
name|variableList
operator|->
name|at
argument_list|(
name|varIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|var
operator|.
name|staticUse
condition|)
block|{
name|result
operator|.
name|push_back
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
template|template
parameter_list|<
name|typename
name|VarT
parameter_list|>
DECL|function|GetShaderVariables
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|VarT
argument_list|>
modifier|&
name|GetShaderVariables
parameter_list|(
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|VarT
argument_list|>
modifier|*
name|variableList
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|variableList
argument_list|)
expr_stmt|;
return|return
operator|*
name|variableList
return|;
block|}
block|}
comment|// anonymous namespace
comment|// true if varying x has a higher priority in packing than y
DECL|function|CompareShaderVar
name|bool
name|CompareShaderVar
parameter_list|(
specifier|const
name|sh
operator|::
name|ShaderVariable
modifier|&
name|x
parameter_list|,
specifier|const
name|sh
operator|::
name|ShaderVariable
modifier|&
name|y
parameter_list|)
block|{
if|if
condition|(
name|x
operator|.
name|type
operator|==
name|y
operator|.
name|type
condition|)
block|{
return|return
name|x
operator|.
name|arraySize
operator|>
name|y
operator|.
name|arraySize
return|;
block|}
comment|// Special case for handling structs: we sort these to the end of the list
if|if
condition|(
name|x
operator|.
name|type
operator|==
name|GL_STRUCT_ANGLEX
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|y
operator|.
name|type
operator|==
name|GL_STRUCT_ANGLEX
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
name|gl
operator|::
name|VariableSortOrder
argument_list|(
name|x
operator|.
name|type
argument_list|)
operator|<
name|gl
operator|::
name|VariableSortOrder
argument_list|(
name|y
operator|.
name|type
argument_list|)
return|;
block|}
DECL|function|Data
name|Shader
operator|::
name|Data
operator|::
name|Data
parameter_list|(
name|GLenum
name|shaderType
parameter_list|)
member_init_list|:
name|mLabel
argument_list|()
member_init_list|,
name|mShaderType
argument_list|(
name|shaderType
argument_list|)
member_init_list|,
name|mShaderVersion
argument_list|(
literal|100
argument_list|)
block|{ }
DECL|function|~Data
name|Shader
operator|::
name|Data
operator|::
name|~
name|Data
parameter_list|()
block|{ }
DECL|function|Shader
name|Shader
operator|::
name|Shader
parameter_list|(
name|ResourceManager
modifier|*
name|manager
parameter_list|,
name|rx
operator|::
name|ImplFactory
modifier|*
name|implFactory
parameter_list|,
specifier|const
name|gl
operator|::
name|Limitations
modifier|&
name|rendererLimitations
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLuint
name|handle
parameter_list|)
member_init_list|:
name|mData
argument_list|(
name|type
argument_list|)
member_init_list|,
name|mImplementation
argument_list|(
name|implFactory
operator|->
name|createShader
argument_list|(
name|mData
argument_list|)
argument_list|)
member_init_list|,
name|mRendererLimitations
argument_list|(
name|rendererLimitations
argument_list|)
member_init_list|,
name|mHandle
argument_list|(
name|handle
argument_list|)
member_init_list|,
name|mType
argument_list|(
name|type
argument_list|)
member_init_list|,
name|mRefCount
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mDeleteStatus
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mCompiled
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mResourceManager
argument_list|(
name|manager
argument_list|)
block|{
name|ASSERT
argument_list|(
name|mImplementation
argument_list|)
expr_stmt|;
block|}
DECL|function|~Shader
name|Shader
operator|::
name|~
name|Shader
parameter_list|()
block|{
name|SafeDelete
argument_list|(
name|mImplementation
argument_list|)
expr_stmt|;
block|}
DECL|function|setLabel
name|void
name|Shader
operator|::
name|setLabel
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|label
parameter_list|)
block|{
name|mData
operator|.
name|mLabel
operator|=
name|label
expr_stmt|;
block|}
DECL|function|getLabel
specifier|const
name|std
operator|::
name|string
modifier|&
name|Shader
operator|::
name|getLabel
parameter_list|()
specifier|const
block|{
return|return
name|mData
operator|.
name|mLabel
return|;
block|}
DECL|function|getHandle
name|GLuint
name|Shader
operator|::
name|getHandle
parameter_list|()
specifier|const
block|{
return|return
name|mHandle
return|;
block|}
DECL|function|setSource
name|void
name|Shader
operator|::
name|setSource
parameter_list|(
name|GLsizei
name|count
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|string
parameter_list|,
specifier|const
name|GLint
modifier|*
name|length
parameter_list|)
block|{
name|std
operator|::
name|ostringstream
name|stream
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|length
operator|==
literal|nullptr
operator|||
name|length
index|[
name|i
index|]
operator|<
literal|0
condition|)
block|{
name|stream
operator|.
name|write
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
name|strlen
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stream
operator|.
name|write
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
name|length
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|mData
operator|.
name|mSource
operator|=
name|stream
operator|.
name|str
argument_list|()
expr_stmt|;
block|}
DECL|function|getInfoLogLength
name|int
name|Shader
operator|::
name|getInfoLogLength
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|mInfoLog
operator|.
name|empty
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
operator|(
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|mInfoLog
operator|.
name|length
argument_list|()
argument_list|)
operator|+
literal|1
operator|)
return|;
block|}
DECL|function|getInfoLog
name|void
name|Shader
operator|::
name|getInfoLog
parameter_list|(
name|GLsizei
name|bufSize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|,
name|char
modifier|*
name|infoLog
parameter_list|)
specifier|const
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bufSize
operator|>
literal|0
condition|)
block|{
name|index
operator|=
name|std
operator|::
name|min
argument_list|(
name|bufSize
operator|-
literal|1
argument_list|,
cast|static_cast
argument_list|<
name|GLsizei
argument_list|>
argument_list|(
name|mInfoLog
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|infoLog
argument_list|,
name|mInfoLog
operator|.
name|c_str
argument_list|()
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|infoLog
index|[
name|index
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
name|index
expr_stmt|;
block|}
block|}
DECL|function|getSourceLength
name|int
name|Shader
operator|::
name|getSourceLength
parameter_list|()
specifier|const
block|{
return|return
name|mData
operator|.
name|mSource
operator|.
name|empty
argument_list|()
condition|?
literal|0
else|:
operator|(
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|mData
operator|.
name|mSource
operator|.
name|length
argument_list|()
argument_list|)
operator|+
literal|1
operator|)
return|;
block|}
DECL|function|getTranslatedSourceLength
name|int
name|Shader
operator|::
name|getTranslatedSourceLength
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|mData
operator|.
name|mTranslatedSource
operator|.
name|empty
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
operator|(
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|mData
operator|.
name|mTranslatedSource
operator|.
name|length
argument_list|()
argument_list|)
operator|+
literal|1
operator|)
return|;
block|}
DECL|function|getTranslatedSourceWithDebugInfoLength
name|int
name|Shader
operator|::
name|getTranslatedSourceWithDebugInfoLength
parameter_list|()
specifier|const
block|{
specifier|const
name|std
operator|::
name|string
modifier|&
name|debugInfo
init|=
name|mImplementation
operator|->
name|getDebugInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|debugInfo
operator|.
name|empty
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
operator|(
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|debugInfo
operator|.
name|length
argument_list|()
argument_list|)
operator|+
literal|1
operator|)
return|;
block|}
DECL|function|getSourceImpl
name|void
name|Shader
operator|::
name|getSourceImpl
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|source
parameter_list|,
name|GLsizei
name|bufSize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bufSize
operator|>
literal|0
condition|)
block|{
name|index
operator|=
name|std
operator|::
name|min
argument_list|(
name|bufSize
operator|-
literal|1
argument_list|,
cast|static_cast
argument_list|<
name|GLsizei
argument_list|>
argument_list|(
name|source
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|source
operator|.
name|c_str
argument_list|()
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|buffer
index|[
name|index
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|length
condition|)
block|{
operator|*
name|length
operator|=
name|index
expr_stmt|;
block|}
block|}
DECL|function|getSource
name|void
name|Shader
operator|::
name|getSource
parameter_list|(
name|GLsizei
name|bufSize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|)
specifier|const
block|{
name|getSourceImpl
argument_list|(
name|mData
operator|.
name|mSource
argument_list|,
name|bufSize
argument_list|,
name|length
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
DECL|function|getTranslatedSource
name|void
name|Shader
operator|::
name|getTranslatedSource
parameter_list|(
name|GLsizei
name|bufSize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|)
specifier|const
block|{
name|getSourceImpl
argument_list|(
name|mData
operator|.
name|mTranslatedSource
argument_list|,
name|bufSize
argument_list|,
name|length
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
DECL|function|getTranslatedSourceWithDebugInfo
name|void
name|Shader
operator|::
name|getTranslatedSourceWithDebugInfo
parameter_list|(
name|GLsizei
name|bufSize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|)
specifier|const
block|{
specifier|const
name|std
operator|::
name|string
modifier|&
name|debugInfo
init|=
name|mImplementation
operator|->
name|getDebugInfo
argument_list|()
decl_stmt|;
name|getSourceImpl
argument_list|(
name|debugInfo
argument_list|,
name|bufSize
argument_list|,
name|length
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
DECL|function|compile
name|void
name|Shader
operator|::
name|compile
parameter_list|(
name|Compiler
modifier|*
name|compiler
parameter_list|)
block|{
name|mData
operator|.
name|mTranslatedSource
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mInfoLog
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mData
operator|.
name|mShaderVersion
operator|=
literal|100
expr_stmt|;
name|mData
operator|.
name|mVaryings
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mData
operator|.
name|mUniforms
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mData
operator|.
name|mInterfaceBlocks
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mData
operator|.
name|mActiveAttributes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mData
operator|.
name|mActiveOutputVariables
operator|.
name|clear
argument_list|()
expr_stmt|;
name|ShHandle
name|compilerHandle
init|=
name|compiler
operator|->
name|getCompilerHandle
argument_list|(
name|mData
operator|.
name|mShaderType
argument_list|)
decl_stmt|;
name|std
operator|::
name|stringstream
name|sourceStream
decl_stmt|;
name|std
operator|::
name|string
name|sourcePath
decl_stmt|;
name|int
name|additionalOptions
init|=
name|mImplementation
operator|->
name|prepareSourceAndReturnOptions
argument_list|(
operator|&
name|sourceStream
argument_list|,
operator|&
name|sourcePath
argument_list|)
decl_stmt|;
name|int
name|compileOptions
init|=
operator|(
name|SH_OBJECT_CODE
operator||
name|SH_VARIABLES
operator||
name|additionalOptions
operator|)
decl_stmt|;
comment|// Some targets (eg D3D11 Feature Level 9_3 and below) do not support non-constant loop indexes
comment|// in fragment shaders. Shader compilation will fail. To provide a better error message we can
comment|// instruct the compiler to pre-validate.
if|if
condition|(
name|mRendererLimitations
operator|.
name|shadersRequireIndexedLoopValidation
condition|)
block|{
name|compileOptions
operator||=
name|SH_VALIDATE_LOOP_INDEXING
expr_stmt|;
block|}
name|std
operator|::
name|string
name|sourceString
init|=
name|sourceStream
operator|.
name|str
argument_list|()
decl_stmt|;
name|std
operator|::
name|vector
argument_list|<
specifier|const
name|char
modifier|*
argument_list|>
name|sourceCStrings
decl_stmt|;
if|if
condition|(
operator|!
name|sourcePath
operator|.
name|empty
argument_list|()
condition|)
block|{
name|sourceCStrings
operator|.
name|push_back
argument_list|(
name|sourcePath
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|sourceCStrings
operator|.
name|push_back
argument_list|(
name|sourceString
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|bool
name|result
init|=
name|ShCompile
argument_list|(
name|compilerHandle
argument_list|,
operator|&
name|sourceCStrings
index|[
literal|0
index|]
argument_list|,
name|sourceCStrings
operator|.
name|size
argument_list|()
argument_list|,
name|compileOptions
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
block|{
name|mInfoLog
operator|=
name|ShGetInfoLog
argument_list|(
name|compilerHandle
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
literal|"\n%s"
argument_list|,
name|mInfoLog
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|mCompiled
operator|=
literal|false
expr_stmt|;
return|return;
block|}
name|mData
operator|.
name|mTranslatedSource
operator|=
name|ShGetObjectCode
argument_list|(
name|compilerHandle
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NDEBUG
comment|// Prefix translated shader with commented out un-translated shader.
comment|// Useful in diagnostics tools which capture the shader source.
name|std
operator|::
name|ostringstream
name|shaderStream
decl_stmt|;
name|shaderStream
operator|<<
literal|"// GLSL\n"
expr_stmt|;
name|shaderStream
operator|<<
literal|"//\n"
expr_stmt|;
name|size_t
name|curPos
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|curPos
operator|!=
name|std
operator|::
name|string
operator|::
name|npos
condition|)
block|{
name|size_t
name|nextLine
init|=
name|mData
operator|.
name|mSource
operator|.
name|find
argument_list|(
literal|"\n"
argument_list|,
name|curPos
argument_list|)
decl_stmt|;
name|size_t
name|len
init|=
operator|(
name|nextLine
operator|==
name|std
operator|::
name|string
operator|::
name|npos
operator|)
condition|?
name|std
operator|::
name|string
operator|::
name|npos
else|:
operator|(
name|nextLine
operator|-
name|curPos
operator|+
literal|1
operator|)
decl_stmt|;
name|shaderStream
operator|<<
literal|"// "
operator|<<
name|mData
operator|.
name|mSource
operator|.
name|substr
argument_list|(
name|curPos
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|curPos
operator|=
operator|(
name|nextLine
operator|==
name|std
operator|::
name|string
operator|::
name|npos
operator|)
condition|?
name|std
operator|::
name|string
operator|::
name|npos
else|:
operator|(
name|nextLine
operator|+
literal|1
operator|)
expr_stmt|;
block|}
name|shaderStream
operator|<<
literal|"\n\n"
expr_stmt|;
name|shaderStream
operator|<<
name|mData
operator|.
name|mTranslatedSource
expr_stmt|;
name|mData
operator|.
name|mTranslatedSource
operator|=
name|shaderStream
operator|.
name|str
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// Gather the shader information
name|mData
operator|.
name|mShaderVersion
operator|=
name|ShGetShaderVersion
argument_list|(
name|compilerHandle
argument_list|)
expr_stmt|;
name|mData
operator|.
name|mVaryings
operator|=
name|GetShaderVariables
argument_list|(
name|ShGetVaryings
argument_list|(
name|compilerHandle
argument_list|)
argument_list|)
expr_stmt|;
name|mData
operator|.
name|mUniforms
operator|=
name|GetShaderVariables
argument_list|(
name|ShGetUniforms
argument_list|(
name|compilerHandle
argument_list|)
argument_list|)
expr_stmt|;
name|mData
operator|.
name|mInterfaceBlocks
operator|=
name|GetShaderVariables
argument_list|(
name|ShGetInterfaceBlocks
argument_list|(
name|compilerHandle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mData
operator|.
name|mShaderType
operator|==
name|GL_VERTEX_SHADER
condition|)
block|{
name|mData
operator|.
name|mActiveAttributes
operator|=
name|GetActiveShaderVariables
argument_list|(
name|ShGetAttributes
argument_list|(
name|compilerHandle
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|mData
operator|.
name|mShaderType
operator|==
name|GL_FRAGMENT_SHADER
argument_list|)
expr_stmt|;
comment|// TODO(jmadill): Figure out why we only sort in the FS, and if we need to.
name|std
operator|::
name|sort
argument_list|(
name|mData
operator|.
name|mVaryings
operator|.
name|begin
argument_list|()
argument_list|,
name|mData
operator|.
name|mVaryings
operator|.
name|end
argument_list|()
argument_list|,
name|CompareShaderVar
argument_list|)
expr_stmt|;
name|mData
operator|.
name|mActiveOutputVariables
operator|=
name|GetActiveShaderVariables
argument_list|(
name|ShGetOutputVariables
argument_list|(
name|compilerHandle
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
operator|!
name|mData
operator|.
name|mTranslatedSource
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
name|mCompiled
operator|=
name|mImplementation
operator|->
name|postTranslateCompile
argument_list|(
name|compiler
argument_list|,
operator|&
name|mInfoLog
argument_list|)
expr_stmt|;
block|}
DECL|function|addRef
name|void
name|Shader
operator|::
name|addRef
parameter_list|()
block|{
name|mRefCount
operator|++
expr_stmt|;
block|}
DECL|function|release
name|void
name|Shader
operator|::
name|release
parameter_list|()
block|{
name|mRefCount
operator|--
expr_stmt|;
if|if
condition|(
name|mRefCount
operator|==
literal|0
operator|&&
name|mDeleteStatus
condition|)
block|{
name|mResourceManager
operator|->
name|deleteShader
argument_list|(
name|mHandle
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|getRefCount
name|unsigned
name|int
name|Shader
operator|::
name|getRefCount
parameter_list|()
specifier|const
block|{
return|return
name|mRefCount
return|;
block|}
DECL|function|isFlaggedForDeletion
name|bool
name|Shader
operator|::
name|isFlaggedForDeletion
parameter_list|()
specifier|const
block|{
return|return
name|mDeleteStatus
return|;
block|}
DECL|function|flagForDeletion
name|void
name|Shader
operator|::
name|flagForDeletion
parameter_list|()
block|{
name|mDeleteStatus
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|getShaderVersion
name|int
name|Shader
operator|::
name|getShaderVersion
parameter_list|()
specifier|const
block|{
return|return
name|mData
operator|.
name|mShaderVersion
return|;
block|}
DECL|function|getVaryings
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|Varying
argument_list|>
modifier|&
name|Shader
operator|::
name|getVaryings
parameter_list|()
specifier|const
block|{
return|return
name|mData
operator|.
name|getVaryings
argument_list|()
return|;
block|}
DECL|function|getUniforms
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|Uniform
argument_list|>
modifier|&
name|Shader
operator|::
name|getUniforms
parameter_list|()
specifier|const
block|{
return|return
name|mData
operator|.
name|getUniforms
argument_list|()
return|;
block|}
DECL|function|getInterfaceBlocks
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|InterfaceBlock
argument_list|>
modifier|&
name|Shader
operator|::
name|getInterfaceBlocks
parameter_list|()
specifier|const
block|{
return|return
name|mData
operator|.
name|getInterfaceBlocks
argument_list|()
return|;
block|}
DECL|function|getActiveAttributes
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|Attribute
argument_list|>
modifier|&
name|Shader
operator|::
name|getActiveAttributes
parameter_list|()
specifier|const
block|{
return|return
name|mData
operator|.
name|getActiveAttributes
argument_list|()
return|;
block|}
DECL|function|getActiveOutputVariables
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|OutputVariable
argument_list|>
modifier|&
name|Shader
operator|::
name|getActiveOutputVariables
parameter_list|()
specifier|const
block|{
return|return
name|mData
operator|.
name|getActiveOutputVariables
argument_list|()
return|;
block|}
DECL|function|getSemanticIndex
name|int
name|Shader
operator|::
name|getSemanticIndex
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|attributeName
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|attributeName
operator|.
name|empty
argument_list|()
condition|)
block|{
specifier|const
specifier|auto
modifier|&
name|activeAttributes
init|=
name|mData
operator|.
name|getActiveAttributes
argument_list|()
decl_stmt|;
name|int
name|semanticIndex
init|=
literal|0
decl_stmt|;
for|for
control|(
name|size_t
name|attributeIndex
init|=
literal|0
init|;
name|attributeIndex
operator|<
name|activeAttributes
operator|.
name|size
argument_list|()
condition|;
name|attributeIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|ShaderVariable
modifier|&
name|attribute
init|=
name|activeAttributes
index|[
name|attributeIndex
index|]
decl_stmt|;
if|if
condition|(
name|attribute
operator|.
name|name
operator|==
name|attributeName
condition|)
block|{
return|return
name|semanticIndex
return|;
block|}
name|semanticIndex
operator|+=
name|gl
operator|::
name|VariableRegisterCount
argument_list|(
name|attribute
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
block|}
end_namespace
end_unit
