begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Texture.cpp: Implements the gl::Texture class. [OpenGL ES 2.0.24] section 3.7 page 63.
end_comment
begin_include
include|#
directive|include
file|"libANGLE/Texture.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Data.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/formatutils.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Config.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Surface.h"
end_include
begin_include
include|#
directive|include
file|"common/mathutil.h"
end_include
begin_include
include|#
directive|include
file|"common/utilities.h"
end_include
begin_namespace
DECL|namespace|gl
namespace|namespace
name|gl
block|{
DECL|function|IsMipmapFiltered
name|bool
name|IsMipmapFiltered
parameter_list|(
specifier|const
name|gl
operator|::
name|SamplerState
modifier|&
name|samplerState
parameter_list|)
block|{
switch|switch
condition|(
name|samplerState
operator|.
name|minFilter
condition|)
block|{
case|case
name|GL_NEAREST
case|:
case|case
name|GL_LINEAR
case|:
return|return
literal|false
return|;
case|case
name|GL_NEAREST_MIPMAP_NEAREST
case|:
case|case
name|GL_LINEAR_MIPMAP_NEAREST
case|:
case|case
name|GL_NEAREST_MIPMAP_LINEAR
case|:
case|case
name|GL_LINEAR_MIPMAP_LINEAR
case|:
return|return
literal|true
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|IsPointSampled
name|bool
name|IsPointSampled
parameter_list|(
specifier|const
name|gl
operator|::
name|SamplerState
modifier|&
name|samplerState
parameter_list|)
block|{
return|return
operator|(
name|samplerState
operator|.
name|magFilter
operator|==
name|GL_NEAREST
operator|&&
operator|(
name|samplerState
operator|.
name|minFilter
operator|==
name|GL_NEAREST
operator|||
name|samplerState
operator|.
name|minFilter
operator|==
name|GL_NEAREST_MIPMAP_NEAREST
operator|)
operator|)
return|;
block|}
DECL|function|GetImageDescIndex
specifier|static
name|size_t
name|GetImageDescIndex
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|)
block|{
return|return
name|IsCubeMapTextureTarget
argument_list|(
name|target
argument_list|)
condition|?
operator|(
operator|(
name|level
operator|*
literal|6
operator|)
operator|+
name|CubeMapTextureTargetToLayerIndex
argument_list|(
name|target
argument_list|)
operator|)
else|:
name|level
return|;
block|}
DECL|member|mCurrentTextureSerial
name|unsigned
name|int
name|Texture
operator|::
name|mCurrentTextureSerial
init|=
literal|1
decl_stmt|;
DECL|function|Texture
name|Texture
operator|::
name|Texture
parameter_list|(
name|rx
operator|::
name|TextureImpl
modifier|*
name|impl
parameter_list|,
name|GLuint
name|id
parameter_list|,
name|GLenum
name|target
parameter_list|)
member_init_list|:
name|RefCountObject
argument_list|(
name|id
argument_list|)
member_init_list|,
name|mTexture
argument_list|(
name|impl
argument_list|)
member_init_list|,
name|mTextureSerial
argument_list|(
name|issueTextureSerial
argument_list|()
argument_list|)
member_init_list|,
name|mUsage
argument_list|(
name|GL_NONE
argument_list|)
member_init_list|,
name|mImmutableLevelCount
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mTarget
argument_list|(
name|target
argument_list|)
member_init_list|,
name|mImageDescs
argument_list|(
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
operator|*
operator|(
name|target
operator|==
name|GL_TEXTURE_CUBE_MAP
condition|?
literal|6
else|:
literal|1
operator|)
argument_list|)
member_init_list|,
name|mCompletenessCache
argument_list|()
member_init_list|,
name|mBoundSurface
argument_list|(
name|NULL
argument_list|)
block|{ }
DECL|function|~Texture
name|Texture
operator|::
name|~
name|Texture
parameter_list|()
block|{
if|if
condition|(
name|mBoundSurface
condition|)
block|{
name|mBoundSurface
operator|->
name|releaseTexImage
argument_list|(
name|EGL_BACK_BUFFER
argument_list|)
expr_stmt|;
name|mBoundSurface
operator|=
name|NULL
expr_stmt|;
block|}
name|SafeDelete
argument_list|(
name|mTexture
argument_list|)
expr_stmt|;
block|}
DECL|function|getTarget
name|GLenum
name|Texture
operator|::
name|getTarget
parameter_list|()
specifier|const
block|{
return|return
name|mTarget
return|;
block|}
DECL|function|setUsage
name|void
name|Texture
operator|::
name|setUsage
parameter_list|(
name|GLenum
name|usage
parameter_list|)
block|{
name|mUsage
operator|=
name|usage
expr_stmt|;
name|getImplementation
argument_list|()
operator|->
name|setUsage
argument_list|(
name|usage
argument_list|)
expr_stmt|;
block|}
DECL|function|getUsage
name|GLenum
name|Texture
operator|::
name|getUsage
parameter_list|()
specifier|const
block|{
return|return
name|mUsage
return|;
block|}
DECL|function|getWidth
name|size_t
name|Texture
operator|::
name|getWidth
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|mTarget
operator|||
operator|(
name|mTarget
operator|==
name|GL_TEXTURE_CUBE_MAP
operator|&&
name|IsCubeMapTextureTarget
argument_list|(
name|target
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|getImageDesc
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
operator|.
name|size
operator|.
name|width
return|;
block|}
DECL|function|getHeight
name|size_t
name|Texture
operator|::
name|getHeight
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|mTarget
operator|||
operator|(
name|mTarget
operator|==
name|GL_TEXTURE_CUBE_MAP
operator|&&
name|IsCubeMapTextureTarget
argument_list|(
name|target
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|getImageDesc
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
operator|.
name|size
operator|.
name|height
return|;
block|}
DECL|function|getDepth
name|size_t
name|Texture
operator|::
name|getDepth
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|mTarget
operator|||
operator|(
name|mTarget
operator|==
name|GL_TEXTURE_CUBE_MAP
operator|&&
name|IsCubeMapTextureTarget
argument_list|(
name|target
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|getImageDesc
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
operator|.
name|size
operator|.
name|depth
return|;
block|}
DECL|function|getInternalFormat
name|GLenum
name|Texture
operator|::
name|getInternalFormat
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|mTarget
operator|||
operator|(
name|mTarget
operator|==
name|GL_TEXTURE_CUBE_MAP
operator|&&
name|IsCubeMapTextureTarget
argument_list|(
name|target
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|getImageDesc
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
operator|.
name|internalFormat
return|;
block|}
DECL|function|isSamplerComplete
name|bool
name|Texture
operator|::
name|isSamplerComplete
parameter_list|(
specifier|const
name|SamplerState
modifier|&
name|samplerState
parameter_list|,
specifier|const
name|Data
modifier|&
name|data
parameter_list|)
specifier|const
block|{
specifier|const
name|ImageDesc
modifier|&
name|baseImageDesc
init|=
name|getImageDesc
argument_list|(
name|getBaseImageTarget
argument_list|()
argument_list|,
name|samplerState
operator|.
name|baseLevel
argument_list|)
decl_stmt|;
specifier|const
name|TextureCaps
modifier|&
name|textureCaps
init|=
name|data
operator|.
name|textureCaps
operator|->
name|get
argument_list|(
name|baseImageDesc
operator|.
name|internalFormat
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mCompletenessCache
operator|.
name|cacheValid
operator|||
name|mCompletenessCache
operator|.
name|samplerState
operator|!=
name|samplerState
operator|||
name|mCompletenessCache
operator|.
name|filterable
operator|!=
name|textureCaps
operator|.
name|filterable
operator|||
name|mCompletenessCache
operator|.
name|clientVersion
operator|!=
name|data
operator|.
name|clientVersion
operator|||
name|mCompletenessCache
operator|.
name|supportsNPOT
operator|!=
name|data
operator|.
name|extensions
operator|->
name|textureNPOT
condition|)
block|{
name|mCompletenessCache
operator|.
name|cacheValid
operator|=
literal|true
expr_stmt|;
name|mCompletenessCache
operator|.
name|samplerState
operator|=
name|samplerState
expr_stmt|;
name|mCompletenessCache
operator|.
name|filterable
operator|=
name|textureCaps
operator|.
name|filterable
expr_stmt|;
name|mCompletenessCache
operator|.
name|clientVersion
operator|=
name|data
operator|.
name|clientVersion
expr_stmt|;
name|mCompletenessCache
operator|.
name|supportsNPOT
operator|=
name|data
operator|.
name|extensions
operator|->
name|textureNPOT
expr_stmt|;
name|mCompletenessCache
operator|.
name|samplerComplete
operator|=
name|computeSamplerCompleteness
argument_list|(
name|samplerState
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|mCompletenessCache
operator|.
name|samplerComplete
return|;
block|}
comment|// Tests for cube texture completeness. [OpenGL ES 2.0.24] section 3.7.10 page 81.
DECL|function|isCubeComplete
name|bool
name|Texture
operator|::
name|isCubeComplete
parameter_list|()
specifier|const
block|{
name|ASSERT
argument_list|(
name|mTarget
operator|==
name|GL_TEXTURE_CUBE_MAP
argument_list|)
expr_stmt|;
specifier|const
name|ImageDesc
modifier|&
name|baseImageDesc
init|=
name|getImageDesc
argument_list|(
name|FirstCubeMapTextureTarget
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|baseImageDesc
operator|.
name|size
operator|.
name|width
operator|==
literal|0
operator|||
name|baseImageDesc
operator|.
name|size
operator|.
name|width
operator|!=
name|baseImageDesc
operator|.
name|size
operator|.
name|height
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|GLenum
name|face
init|=
name|FirstCubeMapTextureTarget
operator|+
literal|1
init|;
name|face
operator|<=
name|LastCubeMapTextureTarget
condition|;
name|face
operator|++
control|)
block|{
specifier|const
name|ImageDesc
modifier|&
name|faceImageDesc
init|=
name|getImageDesc
argument_list|(
name|face
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|faceImageDesc
operator|.
name|size
operator|.
name|width
operator|!=
name|baseImageDesc
operator|.
name|size
operator|.
name|width
operator|||
name|faceImageDesc
operator|.
name|size
operator|.
name|height
operator|!=
name|baseImageDesc
operator|.
name|size
operator|.
name|height
operator|||
name|faceImageDesc
operator|.
name|internalFormat
operator|!=
name|baseImageDesc
operator|.
name|internalFormat
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|getTextureSerial
name|unsigned
name|int
name|Texture
operator|::
name|getTextureSerial
parameter_list|()
specifier|const
block|{
return|return
name|mTextureSerial
return|;
block|}
DECL|function|issueTextureSerial
name|unsigned
name|int
name|Texture
operator|::
name|issueTextureSerial
parameter_list|()
block|{
return|return
name|mCurrentTextureSerial
operator|++
return|;
block|}
DECL|function|isImmutable
name|bool
name|Texture
operator|::
name|isImmutable
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|mImmutableLevelCount
operator|>
literal|0
operator|)
return|;
block|}
DECL|function|immutableLevelCount
name|int
name|Texture
operator|::
name|immutableLevelCount
parameter_list|()
block|{
return|return
name|mImmutableLevelCount
return|;
block|}
DECL|function|setImage
name|Error
name|Texture
operator|::
name|setImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|,
name|GLenum
name|internalFormat
parameter_list|,
specifier|const
name|Extents
modifier|&
name|size
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|pixels
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|mTarget
operator|||
operator|(
name|mTarget
operator|==
name|GL_TEXTURE_CUBE_MAP
operator|&&
name|IsCubeMapTextureTarget
argument_list|(
name|target
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|Error
name|error
init|=
name|mTexture
operator|->
name|setImage
argument_list|(
name|target
argument_list|,
name|level
argument_list|,
name|internalFormat
argument_list|,
name|size
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|unpack
argument_list|,
name|pixels
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|releaseTexImage
argument_list|()
expr_stmt|;
name|setImageDesc
argument_list|(
name|target
argument_list|,
name|level
argument_list|,
name|ImageDesc
argument_list|(
name|size
argument_list|,
name|GetSizedInternalFormat
argument_list|(
name|internalFormat
argument_list|,
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|setSubImage
name|Error
name|Texture
operator|::
name|setSubImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|,
specifier|const
name|Box
modifier|&
name|area
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|pixels
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|mTarget
operator|||
operator|(
name|mTarget
operator|==
name|GL_TEXTURE_CUBE_MAP
operator|&&
name|IsCubeMapTextureTarget
argument_list|(
name|target
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|mTexture
operator|->
name|setSubImage
argument_list|(
name|target
argument_list|,
name|level
argument_list|,
name|area
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|unpack
argument_list|,
name|pixels
argument_list|)
return|;
block|}
DECL|function|setCompressedImage
name|Error
name|Texture
operator|::
name|setCompressedImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|,
name|GLenum
name|internalFormat
parameter_list|,
specifier|const
name|Extents
modifier|&
name|size
parameter_list|,
specifier|const
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|pixels
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|mTarget
operator|||
operator|(
name|mTarget
operator|==
name|GL_TEXTURE_CUBE_MAP
operator|&&
name|IsCubeMapTextureTarget
argument_list|(
name|target
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|Error
name|error
init|=
name|mTexture
operator|->
name|setCompressedImage
argument_list|(
name|target
argument_list|,
name|level
argument_list|,
name|internalFormat
argument_list|,
name|size
argument_list|,
name|unpack
argument_list|,
name|pixels
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|releaseTexImage
argument_list|()
expr_stmt|;
name|setImageDesc
argument_list|(
name|target
argument_list|,
name|level
argument_list|,
name|ImageDesc
argument_list|(
name|size
argument_list|,
name|GetSizedInternalFormat
argument_list|(
name|internalFormat
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|setCompressedSubImage
name|Error
name|Texture
operator|::
name|setCompressedSubImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|,
specifier|const
name|Box
modifier|&
name|area
parameter_list|,
name|GLenum
name|format
parameter_list|,
specifier|const
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|pixels
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|mTarget
operator|||
operator|(
name|mTarget
operator|==
name|GL_TEXTURE_CUBE_MAP
operator|&&
name|IsCubeMapTextureTarget
argument_list|(
name|target
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|mTexture
operator|->
name|setCompressedSubImage
argument_list|(
name|target
argument_list|,
name|level
argument_list|,
name|area
argument_list|,
name|format
argument_list|,
name|unpack
argument_list|,
name|pixels
argument_list|)
return|;
block|}
DECL|function|copyImage
name|Error
name|Texture
operator|::
name|copyImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|,
specifier|const
name|Rectangle
modifier|&
name|sourceArea
parameter_list|,
name|GLenum
name|internalFormat
parameter_list|,
specifier|const
name|Framebuffer
modifier|*
name|source
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|mTarget
operator|||
operator|(
name|mTarget
operator|==
name|GL_TEXTURE_CUBE_MAP
operator|&&
name|IsCubeMapTextureTarget
argument_list|(
name|target
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|Error
name|error
init|=
name|mTexture
operator|->
name|copyImage
argument_list|(
name|target
argument_list|,
name|level
argument_list|,
name|sourceArea
argument_list|,
name|internalFormat
argument_list|,
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|releaseTexImage
argument_list|()
expr_stmt|;
name|setImageDesc
argument_list|(
name|target
argument_list|,
name|level
argument_list|,
name|ImageDesc
argument_list|(
name|Extents
argument_list|(
name|sourceArea
operator|.
name|width
argument_list|,
name|sourceArea
operator|.
name|height
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GetSizedInternalFormat
argument_list|(
name|internalFormat
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|copySubImage
name|Error
name|Texture
operator|::
name|copySubImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|,
specifier|const
name|Offset
modifier|&
name|destOffset
parameter_list|,
specifier|const
name|Rectangle
modifier|&
name|sourceArea
parameter_list|,
specifier|const
name|Framebuffer
modifier|*
name|source
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|mTarget
operator|||
operator|(
name|mTarget
operator|==
name|GL_TEXTURE_CUBE_MAP
operator|&&
name|IsCubeMapTextureTarget
argument_list|(
name|target
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|mTexture
operator|->
name|copySubImage
argument_list|(
name|target
argument_list|,
name|level
argument_list|,
name|destOffset
argument_list|,
name|sourceArea
argument_list|,
name|source
argument_list|)
return|;
block|}
DECL|function|setStorage
name|Error
name|Texture
operator|::
name|setStorage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|levels
parameter_list|,
name|GLenum
name|internalFormat
parameter_list|,
specifier|const
name|Extents
modifier|&
name|size
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|mTarget
argument_list|)
expr_stmt|;
name|Error
name|error
init|=
name|mTexture
operator|->
name|setStorage
argument_list|(
name|target
argument_list|,
name|levels
argument_list|,
name|internalFormat
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|releaseTexImage
argument_list|()
expr_stmt|;
name|mImmutableLevelCount
operator|=
name|levels
expr_stmt|;
name|clearImageDescs
argument_list|()
expr_stmt|;
name|setImageDescChain
argument_list|(
name|levels
argument_list|,
name|size
argument_list|,
name|internalFormat
argument_list|)
expr_stmt|;
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|generateMipmaps
name|Error
name|Texture
operator|::
name|generateMipmaps
parameter_list|()
block|{
name|Error
name|error
init|=
name|mTexture
operator|->
name|generateMipmaps
argument_list|()
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|releaseTexImage
argument_list|()
expr_stmt|;
specifier|const
name|ImageDesc
modifier|&
name|baseImageInfo
init|=
name|getImageDesc
argument_list|(
name|getBaseImageTarget
argument_list|()
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|size_t
name|mipLevels
init|=
name|log2
argument_list|(
name|std
operator|::
name|max
argument_list|(
name|std
operator|::
name|max
argument_list|(
name|baseImageInfo
operator|.
name|size
operator|.
name|width
argument_list|,
name|baseImageInfo
operator|.
name|size
operator|.
name|height
argument_list|)
argument_list|,
name|baseImageInfo
operator|.
name|size
operator|.
name|depth
argument_list|)
argument_list|)
operator|+
literal|1
decl_stmt|;
name|setImageDescChain
argument_list|(
name|mipLevels
argument_list|,
name|baseImageInfo
operator|.
name|size
argument_list|,
name|baseImageInfo
operator|.
name|internalFormat
argument_list|)
expr_stmt|;
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|setImageDescChain
name|void
name|Texture
operator|::
name|setImageDescChain
parameter_list|(
name|size_t
name|levels
parameter_list|,
name|Extents
name|baseSize
parameter_list|,
name|GLenum
name|sizedInternalFormat
parameter_list|)
block|{
for|for
control|(
name|size_t
name|level
init|=
literal|0
init|;
name|level
operator|<
name|levels
condition|;
name|level
operator|++
control|)
block|{
name|Extents
name|levelSize
argument_list|(
name|std
operator|::
name|max
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|baseSize
operator|.
name|width
operator|>>
name|level
argument_list|,
literal|1
argument_list|)
argument_list|,
name|std
operator|::
name|max
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|baseSize
operator|.
name|height
operator|>>
name|level
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|(
name|mTarget
operator|==
name|GL_TEXTURE_2D_ARRAY
operator|)
condition|?
name|baseSize
operator|.
name|depth
else|:
name|std
operator|::
name|max
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|baseSize
operator|.
name|depth
operator|>>
name|level
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|ImageDesc
name|levelInfo
argument_list|(
name|levelSize
argument_list|,
name|sizedInternalFormat
argument_list|)
decl_stmt|;
if|if
condition|(
name|mTarget
operator|==
name|GL_TEXTURE_CUBE_MAP
condition|)
block|{
for|for
control|(
name|size_t
name|face
init|=
name|FirstCubeMapTextureTarget
init|;
name|face
operator|<=
name|LastCubeMapTextureTarget
condition|;
name|face
operator|++
control|)
block|{
name|setImageDesc
argument_list|(
name|face
argument_list|,
name|level
argument_list|,
name|levelInfo
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|setImageDesc
argument_list|(
name|mTarget
argument_list|,
name|level
argument_list|,
name|levelInfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|ImageDesc
name|Texture
operator|::
name|ImageDesc
operator|::
name|ImageDesc
parameter_list|()
member_init_list|:
name|size
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
member_init_list|,
name|internalFormat
argument_list|(
name|GL_NONE
argument_list|)
block|{ }
DECL|function|ImageDesc
name|Texture
operator|::
name|ImageDesc
operator|::
name|ImageDesc
parameter_list|(
specifier|const
name|Extents
modifier|&
name|size
parameter_list|,
name|GLenum
name|internalFormat
parameter_list|)
member_init_list|:
name|size
argument_list|(
name|size
argument_list|)
member_init_list|,
name|internalFormat
argument_list|(
name|internalFormat
argument_list|)
block|{ }
DECL|function|getImageDesc
specifier|const
name|Texture
operator|::
name|ImageDesc
modifier|&
name|Texture
operator|::
name|getImageDesc
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|)
specifier|const
block|{
name|size_t
name|descIndex
init|=
name|GetImageDescIndex
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|descIndex
operator|<
name|mImageDescs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|mImageDescs
index|[
name|descIndex
index|]
return|;
block|}
DECL|function|setImageDesc
name|void
name|Texture
operator|::
name|setImageDesc
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|,
specifier|const
name|ImageDesc
modifier|&
name|desc
parameter_list|)
block|{
name|size_t
name|descIndex
init|=
name|GetImageDescIndex
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|descIndex
operator|<
name|mImageDescs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|mImageDescs
index|[
name|descIndex
index|]
operator|=
name|desc
expr_stmt|;
name|mCompletenessCache
operator|.
name|cacheValid
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|clearImageDesc
name|void
name|Texture
operator|::
name|clearImageDesc
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|)
block|{
name|setImageDesc
argument_list|(
name|target
argument_list|,
name|level
argument_list|,
name|ImageDesc
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|function|clearImageDescs
name|void
name|Texture
operator|::
name|clearImageDescs
parameter_list|()
block|{
for|for
control|(
name|size_t
name|descIndex
init|=
literal|0
init|;
name|descIndex
operator|<
name|mImageDescs
operator|.
name|size
argument_list|()
condition|;
name|descIndex
operator|++
control|)
block|{
name|mImageDescs
index|[
name|descIndex
index|]
operator|=
name|ImageDesc
argument_list|()
expr_stmt|;
block|}
name|mCompletenessCache
operator|.
name|cacheValid
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|bindTexImage
name|void
name|Texture
operator|::
name|bindTexImage
parameter_list|(
name|egl
operator|::
name|Surface
modifier|*
name|surface
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|surface
argument_list|)
expr_stmt|;
name|releaseTexImage
argument_list|()
expr_stmt|;
name|mTexture
operator|->
name|bindTexImage
argument_list|(
name|surface
argument_list|)
expr_stmt|;
name|mBoundSurface
operator|=
name|surface
expr_stmt|;
comment|// Set the image info to the size and format of the surface
name|ASSERT
argument_list|(
name|mTarget
operator|==
name|GL_TEXTURE_2D
argument_list|)
expr_stmt|;
name|Extents
name|size
argument_list|(
name|surface
operator|->
name|getWidth
argument_list|()
argument_list|,
name|surface
operator|->
name|getHeight
argument_list|()
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|ImageDesc
name|desc
argument_list|(
name|size
argument_list|,
name|surface
operator|->
name|getConfig
argument_list|()
operator|->
name|renderTargetFormat
argument_list|)
decl_stmt|;
name|setImageDesc
argument_list|(
name|mTarget
argument_list|,
literal|0
argument_list|,
name|desc
argument_list|)
expr_stmt|;
block|}
DECL|function|releaseTexImage
name|void
name|Texture
operator|::
name|releaseTexImage
parameter_list|()
block|{
if|if
condition|(
name|mBoundSurface
condition|)
block|{
name|mBoundSurface
operator|=
name|NULL
expr_stmt|;
name|mTexture
operator|->
name|releaseTexImage
argument_list|()
expr_stmt|;
comment|// Erase the image info for level 0
name|ASSERT
argument_list|(
name|mTarget
operator|==
name|GL_TEXTURE_2D
argument_list|)
expr_stmt|;
name|clearImageDesc
argument_list|(
name|mTarget
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|getBaseImageTarget
name|GLenum
name|Texture
operator|::
name|getBaseImageTarget
parameter_list|()
specifier|const
block|{
return|return
name|mTarget
operator|==
name|GL_TEXTURE_CUBE_MAP
condition|?
name|FirstCubeMapTextureTarget
else|:
name|mTarget
return|;
block|}
DECL|function|getExpectedMipLevels
name|size_t
name|Texture
operator|::
name|getExpectedMipLevels
parameter_list|()
specifier|const
block|{
specifier|const
name|ImageDesc
modifier|&
name|baseImageDesc
init|=
name|getImageDesc
argument_list|(
name|getBaseImageTarget
argument_list|()
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|mTarget
operator|==
name|GL_TEXTURE_3D
condition|)
block|{
return|return
name|log2
argument_list|(
name|std
operator|::
name|max
argument_list|(
name|std
operator|::
name|max
argument_list|(
name|baseImageDesc
operator|.
name|size
operator|.
name|width
argument_list|,
name|baseImageDesc
operator|.
name|size
operator|.
name|height
argument_list|)
argument_list|,
name|baseImageDesc
operator|.
name|size
operator|.
name|depth
argument_list|)
argument_list|)
operator|+
literal|1
return|;
block|}
else|else
block|{
return|return
name|log2
argument_list|(
name|std
operator|::
name|max
argument_list|(
name|baseImageDesc
operator|.
name|size
operator|.
name|width
argument_list|,
name|baseImageDesc
operator|.
name|size
operator|.
name|height
argument_list|)
argument_list|)
operator|+
literal|1
return|;
block|}
block|}
DECL|function|computeSamplerCompleteness
name|bool
name|Texture
operator|::
name|computeSamplerCompleteness
parameter_list|(
specifier|const
name|SamplerState
modifier|&
name|samplerState
parameter_list|,
specifier|const
name|Data
modifier|&
name|data
parameter_list|)
specifier|const
block|{
specifier|const
name|ImageDesc
modifier|&
name|baseImageDesc
init|=
name|getImageDesc
argument_list|(
name|getBaseImageTarget
argument_list|()
argument_list|,
name|samplerState
operator|.
name|baseLevel
argument_list|)
decl_stmt|;
if|if
condition|(
name|baseImageDesc
operator|.
name|size
operator|.
name|width
operator|==
literal|0
operator|||
name|baseImageDesc
operator|.
name|size
operator|.
name|height
operator|==
literal|0
operator|||
name|baseImageDesc
operator|.
name|size
operator|.
name|depth
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|mTarget
operator|==
name|GL_TEXTURE_CUBE_MAP
operator|&&
name|baseImageDesc
operator|.
name|size
operator|.
name|width
operator|!=
name|baseImageDesc
operator|.
name|size
operator|.
name|height
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|const
name|TextureCaps
modifier|&
name|textureCaps
init|=
name|data
operator|.
name|textureCaps
operator|->
name|get
argument_list|(
name|baseImageDesc
operator|.
name|internalFormat
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|textureCaps
operator|.
name|filterable
operator|&&
operator|!
name|IsPointSampled
argument_list|(
name|samplerState
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|bool
name|npotSupport
init|=
name|data
operator|.
name|extensions
operator|->
name|textureNPOT
operator|||
name|data
operator|.
name|clientVersion
operator|>=
literal|3
decl_stmt|;
if|if
condition|(
operator|!
name|npotSupport
condition|)
block|{
if|if
condition|(
operator|(
name|samplerState
operator|.
name|wrapS
operator|!=
name|GL_CLAMP_TO_EDGE
operator|&&
operator|!
name|gl
operator|::
name|isPow2
argument_list|(
name|baseImageDesc
operator|.
name|size
operator|.
name|width
argument_list|)
operator|)
operator|||
operator|(
name|samplerState
operator|.
name|wrapT
operator|!=
name|GL_CLAMP_TO_EDGE
operator|&&
operator|!
name|gl
operator|::
name|isPow2
argument_list|(
name|baseImageDesc
operator|.
name|size
operator|.
name|height
argument_list|)
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|IsMipmapFiltered
argument_list|(
name|samplerState
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|npotSupport
condition|)
block|{
if|if
condition|(
operator|!
name|gl
operator|::
name|isPow2
argument_list|(
name|baseImageDesc
operator|.
name|size
operator|.
name|width
argument_list|)
operator|||
operator|!
name|gl
operator|::
name|isPow2
argument_list|(
name|baseImageDesc
operator|.
name|size
operator|.
name|height
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
operator|!
name|computeMipmapCompleteness
argument_list|(
name|samplerState
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|mTarget
operator|==
name|GL_TEXTURE_CUBE_MAP
operator|&&
operator|!
name|isCubeComplete
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|// OpenGLES 3.0.2 spec section 3.8.13 states that a texture is not mipmap complete if:
comment|// The internalformat specified for the texture arrays is a sized internal depth or
comment|// depth and stencil format (see table 3.13), the value of TEXTURE_COMPARE_-
comment|// MODE is NONE, and either the magnification filter is not NEAREST or the mini-
comment|// fication filter is neither NEAREST nor NEAREST_MIPMAP_NEAREST.
specifier|const
name|gl
operator|::
name|InternalFormat
modifier|&
name|formatInfo
init|=
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|baseImageDesc
operator|.
name|internalFormat
argument_list|)
decl_stmt|;
if|if
condition|(
name|formatInfo
operator|.
name|depthBits
operator|>
literal|0
operator|&&
name|data
operator|.
name|clientVersion
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|samplerState
operator|.
name|compareMode
operator|==
name|GL_NONE
condition|)
block|{
if|if
condition|(
operator|(
name|samplerState
operator|.
name|minFilter
operator|!=
name|GL_NEAREST
operator|&&
name|samplerState
operator|.
name|minFilter
operator|!=
name|GL_NEAREST_MIPMAP_NEAREST
operator|)
operator|||
name|samplerState
operator|.
name|magFilter
operator|!=
name|GL_NEAREST
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|computeMipmapCompleteness
name|bool
name|Texture
operator|::
name|computeMipmapCompleteness
parameter_list|(
specifier|const
name|gl
operator|::
name|SamplerState
modifier|&
name|samplerState
parameter_list|)
specifier|const
block|{
name|size_t
name|expectedMipLevels
init|=
name|getExpectedMipLevels
argument_list|()
decl_stmt|;
name|size_t
name|maxLevel
init|=
name|std
operator|::
name|min
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|expectedMipLevels
argument_list|,
name|samplerState
operator|.
name|maxLevel
operator|+
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|level
init|=
name|samplerState
operator|.
name|baseLevel
init|;
name|level
operator|<
name|maxLevel
condition|;
name|level
operator|++
control|)
block|{
if|if
condition|(
name|mTarget
operator|==
name|GL_TEXTURE_CUBE_MAP
condition|)
block|{
for|for
control|(
name|GLenum
name|face
init|=
name|FirstCubeMapTextureTarget
init|;
name|face
operator|<=
name|LastCubeMapTextureTarget
condition|;
name|face
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|computeLevelCompleteness
argument_list|(
name|face
argument_list|,
name|level
argument_list|,
name|samplerState
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|computeLevelCompleteness
argument_list|(
name|mTarget
argument_list|,
name|level
argument_list|,
name|samplerState
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|computeLevelCompleteness
name|bool
name|Texture
operator|::
name|computeLevelCompleteness
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|,
specifier|const
name|gl
operator|::
name|SamplerState
modifier|&
name|samplerState
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|level
operator|<
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
argument_list|)
expr_stmt|;
if|if
condition|(
name|isImmutable
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
specifier|const
name|ImageDesc
modifier|&
name|baseImageDesc
init|=
name|getImageDesc
argument_list|(
name|getBaseImageTarget
argument_list|()
argument_list|,
name|samplerState
operator|.
name|baseLevel
argument_list|)
decl_stmt|;
if|if
condition|(
name|baseImageDesc
operator|.
name|size
operator|.
name|width
operator|==
literal|0
operator|||
name|baseImageDesc
operator|.
name|size
operator|.
name|height
operator|==
literal|0
operator|||
name|baseImageDesc
operator|.
name|size
operator|.
name|depth
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// The base image level is complete if the width and height are positive
if|if
condition|(
name|level
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
specifier|const
name|ImageDesc
modifier|&
name|levelImageDesc
init|=
name|getImageDesc
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
decl_stmt|;
if|if
condition|(
name|levelImageDesc
operator|.
name|internalFormat
operator|!=
name|baseImageDesc
operator|.
name|internalFormat
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|levelImageDesc
operator|.
name|size
operator|.
name|width
operator|!=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|baseImageDesc
operator|.
name|size
operator|.
name|width
operator|>>
name|level
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|levelImageDesc
operator|.
name|size
operator|.
name|height
operator|!=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|baseImageDesc
operator|.
name|size
operator|.
name|height
operator|>>
name|level
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|mTarget
operator|==
name|GL_TEXTURE_3D
condition|)
block|{
if|if
condition|(
name|levelImageDesc
operator|.
name|size
operator|.
name|depth
operator|!=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|baseImageDesc
operator|.
name|size
operator|.
name|depth
operator|>>
name|level
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|mTarget
operator|==
name|GL_TEXTURE_2D_ARRAY
condition|)
block|{
if|if
condition|(
name|levelImageDesc
operator|.
name|size
operator|.
name|depth
operator|!=
name|baseImageDesc
operator|.
name|size
operator|.
name|depth
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|SamplerCompletenessCache
name|Texture
operator|::
name|SamplerCompletenessCache
operator|::
name|SamplerCompletenessCache
parameter_list|()
member_init_list|:
name|cacheValid
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|samplerState
argument_list|()
member_init_list|,
name|filterable
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|clientVersion
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|supportsNPOT
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|samplerComplete
argument_list|(
literal|false
argument_list|)
block|{ }
block|}
end_namespace
end_unit
