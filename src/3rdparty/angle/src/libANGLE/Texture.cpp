begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Texture.cpp: Implements the gl::Texture class. [OpenGL ES 2.0.24] section 3.7 page 63.
end_comment
begin_include
include|#
directive|include
file|"libANGLE/Texture.h"
end_include
begin_include
include|#
directive|include
file|"common/mathutil.h"
end_include
begin_include
include|#
directive|include
file|"common/utilities.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Config.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Context.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Data.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Image.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Surface.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/formatutils.h"
end_include
begin_namespace
DECL|namespace|gl
namespace|namespace
name|gl
block|{
DECL|function|IsMipmapFiltered
name|bool
name|IsMipmapFiltered
parameter_list|(
specifier|const
name|gl
operator|::
name|SamplerState
modifier|&
name|samplerState
parameter_list|)
block|{
switch|switch
condition|(
name|samplerState
operator|.
name|minFilter
condition|)
block|{
case|case
name|GL_NEAREST
case|:
case|case
name|GL_LINEAR
case|:
return|return
literal|false
return|;
case|case
name|GL_NEAREST_MIPMAP_NEAREST
case|:
case|case
name|GL_LINEAR_MIPMAP_NEAREST
case|:
case|case
name|GL_NEAREST_MIPMAP_LINEAR
case|:
case|case
name|GL_LINEAR_MIPMAP_LINEAR
case|:
return|return
literal|true
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|IsPointSampled
name|bool
name|IsPointSampled
parameter_list|(
specifier|const
name|gl
operator|::
name|SamplerState
modifier|&
name|samplerState
parameter_list|)
block|{
return|return
operator|(
name|samplerState
operator|.
name|magFilter
operator|==
name|GL_NEAREST
operator|&&
operator|(
name|samplerState
operator|.
name|minFilter
operator|==
name|GL_NEAREST
operator|||
name|samplerState
operator|.
name|minFilter
operator|==
name|GL_NEAREST_MIPMAP_NEAREST
operator|)
operator|)
return|;
block|}
DECL|function|GetImageDescIndex
specifier|static
name|size_t
name|GetImageDescIndex
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|)
block|{
return|return
name|IsCubeMapTextureTarget
argument_list|(
name|target
argument_list|)
condition|?
operator|(
operator|(
name|level
operator|*
literal|6
operator|)
operator|+
name|CubeMapTextureTargetToLayerIndex
argument_list|(
name|target
argument_list|)
operator|)
else|:
name|level
return|;
block|}
DECL|function|Texture
name|Texture
operator|::
name|Texture
parameter_list|(
name|rx
operator|::
name|TextureImpl
modifier|*
name|impl
parameter_list|,
name|GLuint
name|id
parameter_list|,
name|GLenum
name|target
parameter_list|)
member_init_list|:
name|egl
operator|::
name|ImageSibling
argument_list|(
name|id
argument_list|)
member_init_list|,
name|mTexture
argument_list|(
name|impl
argument_list|)
member_init_list|,
name|mLabel
argument_list|()
member_init_list|,
name|mTextureState
argument_list|()
member_init_list|,
name|mTarget
argument_list|(
name|target
argument_list|)
member_init_list|,
name|mImageDescs
argument_list|(
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
operator|*
operator|(
name|target
operator|==
name|GL_TEXTURE_CUBE_MAP
condition|?
literal|6
else|:
literal|1
operator|)
argument_list|)
member_init_list|,
name|mCompletenessCache
argument_list|()
member_init_list|,
name|mBoundSurface
argument_list|(
name|NULL
argument_list|)
block|{ }
DECL|function|~Texture
name|Texture
operator|::
name|~
name|Texture
parameter_list|()
block|{
if|if
condition|(
name|mBoundSurface
condition|)
block|{
name|mBoundSurface
operator|->
name|releaseTexImage
argument_list|(
name|EGL_BACK_BUFFER
argument_list|)
expr_stmt|;
name|mBoundSurface
operator|=
name|NULL
expr_stmt|;
block|}
name|SafeDelete
argument_list|(
name|mTexture
argument_list|)
expr_stmt|;
block|}
DECL|function|setLabel
name|void
name|Texture
operator|::
name|setLabel
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|label
parameter_list|)
block|{
name|mLabel
operator|=
name|label
expr_stmt|;
block|}
DECL|function|getLabel
specifier|const
name|std
operator|::
name|string
modifier|&
name|Texture
operator|::
name|getLabel
parameter_list|()
specifier|const
block|{
return|return
name|mLabel
return|;
block|}
DECL|function|getTarget
name|GLenum
name|Texture
operator|::
name|getTarget
parameter_list|()
specifier|const
block|{
return|return
name|mTarget
return|;
block|}
DECL|function|setSwizzleRed
name|void
name|Texture
operator|::
name|setSwizzleRed
parameter_list|(
name|GLenum
name|swizzleRed
parameter_list|)
block|{
name|mTextureState
operator|.
name|swizzleRed
operator|=
name|swizzleRed
expr_stmt|;
block|}
DECL|function|getSwizzleRed
name|GLenum
name|Texture
operator|::
name|getSwizzleRed
parameter_list|()
specifier|const
block|{
return|return
name|mTextureState
operator|.
name|swizzleRed
return|;
block|}
DECL|function|setSwizzleGreen
name|void
name|Texture
operator|::
name|setSwizzleGreen
parameter_list|(
name|GLenum
name|swizzleGreen
parameter_list|)
block|{
name|mTextureState
operator|.
name|swizzleGreen
operator|=
name|swizzleGreen
expr_stmt|;
block|}
DECL|function|getSwizzleGreen
name|GLenum
name|Texture
operator|::
name|getSwizzleGreen
parameter_list|()
specifier|const
block|{
return|return
name|mTextureState
operator|.
name|swizzleGreen
return|;
block|}
DECL|function|setSwizzleBlue
name|void
name|Texture
operator|::
name|setSwizzleBlue
parameter_list|(
name|GLenum
name|swizzleBlue
parameter_list|)
block|{
name|mTextureState
operator|.
name|swizzleBlue
operator|=
name|swizzleBlue
expr_stmt|;
block|}
DECL|function|getSwizzleBlue
name|GLenum
name|Texture
operator|::
name|getSwizzleBlue
parameter_list|()
specifier|const
block|{
return|return
name|mTextureState
operator|.
name|swizzleBlue
return|;
block|}
DECL|function|setSwizzleAlpha
name|void
name|Texture
operator|::
name|setSwizzleAlpha
parameter_list|(
name|GLenum
name|swizzleAlpha
parameter_list|)
block|{
name|mTextureState
operator|.
name|swizzleAlpha
operator|=
name|swizzleAlpha
expr_stmt|;
block|}
DECL|function|getSwizzleAlpha
name|GLenum
name|Texture
operator|::
name|getSwizzleAlpha
parameter_list|()
specifier|const
block|{
return|return
name|mTextureState
operator|.
name|swizzleAlpha
return|;
block|}
DECL|function|setMinFilter
name|void
name|Texture
operator|::
name|setMinFilter
parameter_list|(
name|GLenum
name|minFilter
parameter_list|)
block|{
name|mTextureState
operator|.
name|samplerState
operator|.
name|minFilter
operator|=
name|minFilter
expr_stmt|;
block|}
DECL|function|getMinFilter
name|GLenum
name|Texture
operator|::
name|getMinFilter
parameter_list|()
specifier|const
block|{
return|return
name|mTextureState
operator|.
name|samplerState
operator|.
name|minFilter
return|;
block|}
DECL|function|setMagFilter
name|void
name|Texture
operator|::
name|setMagFilter
parameter_list|(
name|GLenum
name|magFilter
parameter_list|)
block|{
name|mTextureState
operator|.
name|samplerState
operator|.
name|magFilter
operator|=
name|magFilter
expr_stmt|;
block|}
DECL|function|getMagFilter
name|GLenum
name|Texture
operator|::
name|getMagFilter
parameter_list|()
specifier|const
block|{
return|return
name|mTextureState
operator|.
name|samplerState
operator|.
name|magFilter
return|;
block|}
DECL|function|setWrapS
name|void
name|Texture
operator|::
name|setWrapS
parameter_list|(
name|GLenum
name|wrapS
parameter_list|)
block|{
name|mTextureState
operator|.
name|samplerState
operator|.
name|wrapS
operator|=
name|wrapS
expr_stmt|;
block|}
DECL|function|getWrapS
name|GLenum
name|Texture
operator|::
name|getWrapS
parameter_list|()
specifier|const
block|{
return|return
name|mTextureState
operator|.
name|samplerState
operator|.
name|wrapS
return|;
block|}
DECL|function|setWrapT
name|void
name|Texture
operator|::
name|setWrapT
parameter_list|(
name|GLenum
name|wrapT
parameter_list|)
block|{
name|mTextureState
operator|.
name|samplerState
operator|.
name|wrapT
operator|=
name|wrapT
expr_stmt|;
block|}
DECL|function|getWrapT
name|GLenum
name|Texture
operator|::
name|getWrapT
parameter_list|()
specifier|const
block|{
return|return
name|mTextureState
operator|.
name|samplerState
operator|.
name|wrapT
return|;
block|}
DECL|function|setWrapR
name|void
name|Texture
operator|::
name|setWrapR
parameter_list|(
name|GLenum
name|wrapR
parameter_list|)
block|{
name|mTextureState
operator|.
name|samplerState
operator|.
name|wrapR
operator|=
name|wrapR
expr_stmt|;
block|}
DECL|function|getWrapR
name|GLenum
name|Texture
operator|::
name|getWrapR
parameter_list|()
specifier|const
block|{
return|return
name|mTextureState
operator|.
name|samplerState
operator|.
name|wrapR
return|;
block|}
DECL|function|setMaxAnisotropy
name|void
name|Texture
operator|::
name|setMaxAnisotropy
parameter_list|(
name|float
name|maxAnisotropy
parameter_list|)
block|{
name|mTextureState
operator|.
name|samplerState
operator|.
name|maxAnisotropy
operator|=
name|maxAnisotropy
expr_stmt|;
block|}
DECL|function|getMaxAnisotropy
name|float
name|Texture
operator|::
name|getMaxAnisotropy
parameter_list|()
specifier|const
block|{
return|return
name|mTextureState
operator|.
name|samplerState
operator|.
name|maxAnisotropy
return|;
block|}
DECL|function|setMinLod
name|void
name|Texture
operator|::
name|setMinLod
parameter_list|(
name|GLfloat
name|minLod
parameter_list|)
block|{
name|mTextureState
operator|.
name|samplerState
operator|.
name|minLod
operator|=
name|minLod
expr_stmt|;
block|}
DECL|function|getMinLod
name|GLfloat
name|Texture
operator|::
name|getMinLod
parameter_list|()
specifier|const
block|{
return|return
name|mTextureState
operator|.
name|samplerState
operator|.
name|minLod
return|;
block|}
DECL|function|setMaxLod
name|void
name|Texture
operator|::
name|setMaxLod
parameter_list|(
name|GLfloat
name|maxLod
parameter_list|)
block|{
name|mTextureState
operator|.
name|samplerState
operator|.
name|maxLod
operator|=
name|maxLod
expr_stmt|;
block|}
DECL|function|getMaxLod
name|GLfloat
name|Texture
operator|::
name|getMaxLod
parameter_list|()
specifier|const
block|{
return|return
name|mTextureState
operator|.
name|samplerState
operator|.
name|maxLod
return|;
block|}
DECL|function|setCompareMode
name|void
name|Texture
operator|::
name|setCompareMode
parameter_list|(
name|GLenum
name|compareMode
parameter_list|)
block|{
name|mTextureState
operator|.
name|samplerState
operator|.
name|compareMode
operator|=
name|compareMode
expr_stmt|;
block|}
DECL|function|getCompareMode
name|GLenum
name|Texture
operator|::
name|getCompareMode
parameter_list|()
specifier|const
block|{
return|return
name|mTextureState
operator|.
name|samplerState
operator|.
name|compareMode
return|;
block|}
DECL|function|setCompareFunc
name|void
name|Texture
operator|::
name|setCompareFunc
parameter_list|(
name|GLenum
name|compareFunc
parameter_list|)
block|{
name|mTextureState
operator|.
name|samplerState
operator|.
name|compareFunc
operator|=
name|compareFunc
expr_stmt|;
block|}
DECL|function|getCompareFunc
name|GLenum
name|Texture
operator|::
name|getCompareFunc
parameter_list|()
specifier|const
block|{
return|return
name|mTextureState
operator|.
name|samplerState
operator|.
name|compareFunc
return|;
block|}
DECL|function|getSamplerState
specifier|const
name|SamplerState
modifier|&
name|Texture
operator|::
name|getSamplerState
parameter_list|()
specifier|const
block|{
return|return
name|mTextureState
operator|.
name|samplerState
return|;
block|}
DECL|function|setBaseLevel
name|void
name|Texture
operator|::
name|setBaseLevel
parameter_list|(
name|GLuint
name|baseLevel
parameter_list|)
block|{
name|mTextureState
operator|.
name|baseLevel
operator|=
name|baseLevel
expr_stmt|;
block|}
DECL|function|getBaseLevel
name|GLuint
name|Texture
operator|::
name|getBaseLevel
parameter_list|()
specifier|const
block|{
return|return
name|mTextureState
operator|.
name|baseLevel
return|;
block|}
DECL|function|setMaxLevel
name|void
name|Texture
operator|::
name|setMaxLevel
parameter_list|(
name|GLuint
name|maxLevel
parameter_list|)
block|{
name|mTextureState
operator|.
name|maxLevel
operator|=
name|maxLevel
expr_stmt|;
block|}
DECL|function|getMaxLevel
name|GLuint
name|Texture
operator|::
name|getMaxLevel
parameter_list|()
specifier|const
block|{
return|return
name|mTextureState
operator|.
name|maxLevel
return|;
block|}
DECL|function|getImmutableFormat
name|bool
name|Texture
operator|::
name|getImmutableFormat
parameter_list|()
specifier|const
block|{
return|return
name|mTextureState
operator|.
name|immutableFormat
return|;
block|}
DECL|function|getImmutableLevels
name|GLuint
name|Texture
operator|::
name|getImmutableLevels
parameter_list|()
specifier|const
block|{
return|return
name|mTextureState
operator|.
name|immutableLevels
return|;
block|}
DECL|function|setUsage
name|void
name|Texture
operator|::
name|setUsage
parameter_list|(
name|GLenum
name|usage
parameter_list|)
block|{
name|mTextureState
operator|.
name|usage
operator|=
name|usage
expr_stmt|;
name|getImplementation
argument_list|()
operator|->
name|setUsage
argument_list|(
name|usage
argument_list|)
expr_stmt|;
block|}
DECL|function|getUsage
name|GLenum
name|Texture
operator|::
name|getUsage
parameter_list|()
specifier|const
block|{
return|return
name|mTextureState
operator|.
name|usage
return|;
block|}
DECL|function|getTextureState
specifier|const
name|TextureState
modifier|&
name|Texture
operator|::
name|getTextureState
parameter_list|()
specifier|const
block|{
return|return
name|mTextureState
return|;
block|}
DECL|function|getWidth
name|size_t
name|Texture
operator|::
name|getWidth
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|mTarget
operator|||
operator|(
name|mTarget
operator|==
name|GL_TEXTURE_CUBE_MAP
operator|&&
name|IsCubeMapTextureTarget
argument_list|(
name|target
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|getImageDesc
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
operator|.
name|size
operator|.
name|width
return|;
block|}
DECL|function|getHeight
name|size_t
name|Texture
operator|::
name|getHeight
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|mTarget
operator|||
operator|(
name|mTarget
operator|==
name|GL_TEXTURE_CUBE_MAP
operator|&&
name|IsCubeMapTextureTarget
argument_list|(
name|target
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|getImageDesc
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
operator|.
name|size
operator|.
name|height
return|;
block|}
DECL|function|getDepth
name|size_t
name|Texture
operator|::
name|getDepth
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|mTarget
operator|||
operator|(
name|mTarget
operator|==
name|GL_TEXTURE_CUBE_MAP
operator|&&
name|IsCubeMapTextureTarget
argument_list|(
name|target
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|getImageDesc
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
operator|.
name|size
operator|.
name|depth
return|;
block|}
DECL|function|getInternalFormat
name|GLenum
name|Texture
operator|::
name|getInternalFormat
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|mTarget
operator|||
operator|(
name|mTarget
operator|==
name|GL_TEXTURE_CUBE_MAP
operator|&&
name|IsCubeMapTextureTarget
argument_list|(
name|target
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|getImageDesc
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
operator|.
name|internalFormat
return|;
block|}
DECL|function|isSamplerComplete
name|bool
name|Texture
operator|::
name|isSamplerComplete
parameter_list|(
specifier|const
name|SamplerState
modifier|&
name|samplerState
parameter_list|,
specifier|const
name|Data
modifier|&
name|data
parameter_list|)
specifier|const
block|{
specifier|const
name|ImageDesc
modifier|&
name|baseImageDesc
init|=
name|getImageDesc
argument_list|(
name|getBaseImageTarget
argument_list|()
argument_list|,
name|mTextureState
operator|.
name|baseLevel
argument_list|)
decl_stmt|;
specifier|const
name|TextureCaps
modifier|&
name|textureCaps
init|=
name|data
operator|.
name|textureCaps
operator|->
name|get
argument_list|(
name|baseImageDesc
operator|.
name|internalFormat
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mCompletenessCache
operator|.
name|cacheValid
operator|||
name|mCompletenessCache
operator|.
name|samplerState
operator|!=
name|samplerState
operator|||
name|mCompletenessCache
operator|.
name|filterable
operator|!=
name|textureCaps
operator|.
name|filterable
operator|||
name|mCompletenessCache
operator|.
name|clientVersion
operator|!=
name|data
operator|.
name|clientVersion
operator|||
name|mCompletenessCache
operator|.
name|supportsNPOT
operator|!=
name|data
operator|.
name|extensions
operator|->
name|textureNPOT
condition|)
block|{
name|mCompletenessCache
operator|.
name|cacheValid
operator|=
literal|true
expr_stmt|;
name|mCompletenessCache
operator|.
name|samplerState
operator|=
name|samplerState
expr_stmt|;
name|mCompletenessCache
operator|.
name|filterable
operator|=
name|textureCaps
operator|.
name|filterable
expr_stmt|;
name|mCompletenessCache
operator|.
name|clientVersion
operator|=
name|data
operator|.
name|clientVersion
expr_stmt|;
name|mCompletenessCache
operator|.
name|supportsNPOT
operator|=
name|data
operator|.
name|extensions
operator|->
name|textureNPOT
expr_stmt|;
name|mCompletenessCache
operator|.
name|samplerComplete
operator|=
name|computeSamplerCompleteness
argument_list|(
name|samplerState
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|mCompletenessCache
operator|.
name|samplerComplete
return|;
block|}
DECL|function|isMipmapComplete
name|bool
name|Texture
operator|::
name|isMipmapComplete
parameter_list|()
specifier|const
block|{
return|return
name|computeMipmapCompleteness
argument_list|()
return|;
block|}
comment|// Tests for cube texture completeness. [OpenGL ES 2.0.24] section 3.7.10 page 81.
DECL|function|isCubeComplete
name|bool
name|Texture
operator|::
name|isCubeComplete
parameter_list|()
specifier|const
block|{
name|ASSERT
argument_list|(
name|mTarget
operator|==
name|GL_TEXTURE_CUBE_MAP
argument_list|)
expr_stmt|;
specifier|const
name|ImageDesc
modifier|&
name|baseImageDesc
init|=
name|getImageDesc
argument_list|(
name|FirstCubeMapTextureTarget
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|baseImageDesc
operator|.
name|size
operator|.
name|width
operator|==
literal|0
operator|||
name|baseImageDesc
operator|.
name|size
operator|.
name|width
operator|!=
name|baseImageDesc
operator|.
name|size
operator|.
name|height
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|GLenum
name|face
init|=
name|FirstCubeMapTextureTarget
operator|+
literal|1
init|;
name|face
operator|<=
name|LastCubeMapTextureTarget
condition|;
name|face
operator|++
control|)
block|{
specifier|const
name|ImageDesc
modifier|&
name|faceImageDesc
init|=
name|getImageDesc
argument_list|(
name|face
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|faceImageDesc
operator|.
name|size
operator|.
name|width
operator|!=
name|baseImageDesc
operator|.
name|size
operator|.
name|width
operator|||
name|faceImageDesc
operator|.
name|size
operator|.
name|height
operator|!=
name|baseImageDesc
operator|.
name|size
operator|.
name|height
operator|||
name|faceImageDesc
operator|.
name|internalFormat
operator|!=
name|baseImageDesc
operator|.
name|internalFormat
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|getMipCompleteLevels
name|size_t
name|Texture
operator|::
name|getMipCompleteLevels
parameter_list|()
specifier|const
block|{
specifier|const
name|ImageDesc
modifier|&
name|baseImageDesc
init|=
name|getImageDesc
argument_list|(
name|getBaseImageTarget
argument_list|()
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|mTarget
operator|==
name|GL_TEXTURE_3D
condition|)
block|{
specifier|const
name|int
name|maxDim
init|=
name|std
operator|::
name|max
argument_list|(
name|std
operator|::
name|max
argument_list|(
name|baseImageDesc
operator|.
name|size
operator|.
name|width
argument_list|,
name|baseImageDesc
operator|.
name|size
operator|.
name|height
argument_list|)
argument_list|,
name|baseImageDesc
operator|.
name|size
operator|.
name|depth
argument_list|)
decl_stmt|;
return|return
name|log2
argument_list|(
name|maxDim
argument_list|)
operator|+
literal|1
return|;
block|}
else|else
block|{
return|return
name|log2
argument_list|(
name|std
operator|::
name|max
argument_list|(
name|baseImageDesc
operator|.
name|size
operator|.
name|width
argument_list|,
name|baseImageDesc
operator|.
name|size
operator|.
name|height
argument_list|)
argument_list|)
operator|+
literal|1
return|;
block|}
block|}
DECL|function|getBoundSurface
name|egl
operator|::
name|Surface
modifier|*
name|Texture
operator|::
name|getBoundSurface
parameter_list|()
specifier|const
block|{
return|return
name|mBoundSurface
return|;
block|}
DECL|function|setImage
name|Error
name|Texture
operator|::
name|setImage
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|,
name|GLenum
name|internalFormat
parameter_list|,
specifier|const
name|Extents
modifier|&
name|size
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|pixels
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|mTarget
operator|||
operator|(
name|mTarget
operator|==
name|GL_TEXTURE_CUBE_MAP
operator|&&
name|IsCubeMapTextureTarget
argument_list|(
name|target
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|// Release from previous calls to eglBindTexImage, to avoid calling the Impl after
name|releaseTexImageInternal
argument_list|()
expr_stmt|;
name|orphanImages
argument_list|()
expr_stmt|;
comment|// Hack: allow nullptr for testing
if|if
condition|(
name|context
operator|!=
literal|nullptr
condition|)
block|{
comment|// Sync the unpack state
name|context
operator|->
name|syncRendererState
argument_list|(
name|context
operator|->
name|getState
argument_list|()
operator|.
name|unpackStateBitMask
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|const
name|PixelUnpackState
name|defaultUnpack
decl_stmt|;
specifier|const
name|PixelUnpackState
modifier|&
name|unpack
init|=
name|context
condition|?
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getUnpackState
argument_list|()
else|:
name|defaultUnpack
decl_stmt|;
name|Error
name|error
init|=
name|mTexture
operator|->
name|setImage
argument_list|(
name|target
argument_list|,
name|level
argument_list|,
name|internalFormat
argument_list|,
name|size
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|unpack
argument_list|,
name|pixels
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|setImageDesc
argument_list|(
name|target
argument_list|,
name|level
argument_list|,
name|ImageDesc
argument_list|(
name|size
argument_list|,
name|GetSizedInternalFormat
argument_list|(
name|internalFormat
argument_list|,
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|setSubImage
name|Error
name|Texture
operator|::
name|setSubImage
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|,
specifier|const
name|Box
modifier|&
name|area
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|pixels
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|mTarget
operator|||
operator|(
name|mTarget
operator|==
name|GL_TEXTURE_CUBE_MAP
operator|&&
name|IsCubeMapTextureTarget
argument_list|(
name|target
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|// Sync the unpack state
name|context
operator|->
name|syncRendererState
argument_list|(
name|context
operator|->
name|getState
argument_list|()
operator|.
name|unpackStateBitMask
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|PixelUnpackState
modifier|&
name|unpack
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getUnpackState
argument_list|()
decl_stmt|;
return|return
name|mTexture
operator|->
name|setSubImage
argument_list|(
name|target
argument_list|,
name|level
argument_list|,
name|area
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|unpack
argument_list|,
name|pixels
argument_list|)
return|;
block|}
DECL|function|setCompressedImage
name|Error
name|Texture
operator|::
name|setCompressedImage
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|,
name|GLenum
name|internalFormat
parameter_list|,
specifier|const
name|Extents
modifier|&
name|size
parameter_list|,
name|size_t
name|imageSize
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|pixels
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|mTarget
operator|||
operator|(
name|mTarget
operator|==
name|GL_TEXTURE_CUBE_MAP
operator|&&
name|IsCubeMapTextureTarget
argument_list|(
name|target
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|// Release from previous calls to eglBindTexImage, to avoid calling the Impl after
name|releaseTexImageInternal
argument_list|()
expr_stmt|;
name|orphanImages
argument_list|()
expr_stmt|;
comment|// Sync the unpack state
name|context
operator|->
name|syncRendererState
argument_list|(
name|context
operator|->
name|getState
argument_list|()
operator|.
name|unpackStateBitMask
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|PixelUnpackState
modifier|&
name|unpack
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getUnpackState
argument_list|()
decl_stmt|;
name|Error
name|error
init|=
name|mTexture
operator|->
name|setCompressedImage
argument_list|(
name|target
argument_list|,
name|level
argument_list|,
name|internalFormat
argument_list|,
name|size
argument_list|,
name|unpack
argument_list|,
name|imageSize
argument_list|,
name|pixels
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|setImageDesc
argument_list|(
name|target
argument_list|,
name|level
argument_list|,
name|ImageDesc
argument_list|(
name|size
argument_list|,
name|GetSizedInternalFormat
argument_list|(
name|internalFormat
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|setCompressedSubImage
name|Error
name|Texture
operator|::
name|setCompressedSubImage
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|,
specifier|const
name|Box
modifier|&
name|area
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|size_t
name|imageSize
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|pixels
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|mTarget
operator|||
operator|(
name|mTarget
operator|==
name|GL_TEXTURE_CUBE_MAP
operator|&&
name|IsCubeMapTextureTarget
argument_list|(
name|target
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|// Sync the unpack state
name|context
operator|->
name|syncRendererState
argument_list|(
name|context
operator|->
name|getState
argument_list|()
operator|.
name|unpackStateBitMask
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|PixelUnpackState
modifier|&
name|unpack
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getUnpackState
argument_list|()
decl_stmt|;
return|return
name|mTexture
operator|->
name|setCompressedSubImage
argument_list|(
name|target
argument_list|,
name|level
argument_list|,
name|area
argument_list|,
name|format
argument_list|,
name|unpack
argument_list|,
name|imageSize
argument_list|,
name|pixels
argument_list|)
return|;
block|}
DECL|function|copyImage
name|Error
name|Texture
operator|::
name|copyImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|,
specifier|const
name|Rectangle
modifier|&
name|sourceArea
parameter_list|,
name|GLenum
name|internalFormat
parameter_list|,
specifier|const
name|Framebuffer
modifier|*
name|source
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|mTarget
operator|||
operator|(
name|mTarget
operator|==
name|GL_TEXTURE_CUBE_MAP
operator|&&
name|IsCubeMapTextureTarget
argument_list|(
name|target
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|// Release from previous calls to eglBindTexImage, to avoid calling the Impl after
name|releaseTexImageInternal
argument_list|()
expr_stmt|;
name|orphanImages
argument_list|()
expr_stmt|;
name|Error
name|error
init|=
name|mTexture
operator|->
name|copyImage
argument_list|(
name|target
argument_list|,
name|level
argument_list|,
name|sourceArea
argument_list|,
name|internalFormat
argument_list|,
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|setImageDesc
argument_list|(
name|target
argument_list|,
name|level
argument_list|,
name|ImageDesc
argument_list|(
name|Extents
argument_list|(
name|sourceArea
operator|.
name|width
argument_list|,
name|sourceArea
operator|.
name|height
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GetSizedInternalFormat
argument_list|(
name|internalFormat
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|copySubImage
name|Error
name|Texture
operator|::
name|copySubImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|,
specifier|const
name|Offset
modifier|&
name|destOffset
parameter_list|,
specifier|const
name|Rectangle
modifier|&
name|sourceArea
parameter_list|,
specifier|const
name|Framebuffer
modifier|*
name|source
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|mTarget
operator|||
operator|(
name|mTarget
operator|==
name|GL_TEXTURE_CUBE_MAP
operator|&&
name|IsCubeMapTextureTarget
argument_list|(
name|target
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|mTexture
operator|->
name|copySubImage
argument_list|(
name|target
argument_list|,
name|level
argument_list|,
name|destOffset
argument_list|,
name|sourceArea
argument_list|,
name|source
argument_list|)
return|;
block|}
DECL|function|setStorage
name|Error
name|Texture
operator|::
name|setStorage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|levels
parameter_list|,
name|GLenum
name|internalFormat
parameter_list|,
specifier|const
name|Extents
modifier|&
name|size
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|mTarget
argument_list|)
expr_stmt|;
comment|// Release from previous calls to eglBindTexImage, to avoid calling the Impl after
name|releaseTexImageInternal
argument_list|()
expr_stmt|;
name|orphanImages
argument_list|()
expr_stmt|;
name|Error
name|error
init|=
name|mTexture
operator|->
name|setStorage
argument_list|(
name|target
argument_list|,
name|levels
argument_list|,
name|internalFormat
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|mTextureState
operator|.
name|immutableFormat
operator|=
literal|true
expr_stmt|;
name|mTextureState
operator|.
name|immutableLevels
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|levels
argument_list|)
expr_stmt|;
name|clearImageDescs
argument_list|()
expr_stmt|;
name|setImageDescChain
argument_list|(
name|levels
argument_list|,
name|size
argument_list|,
name|internalFormat
argument_list|)
expr_stmt|;
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|generateMipmaps
name|Error
name|Texture
operator|::
name|generateMipmaps
parameter_list|()
block|{
comment|// Release from previous calls to eglBindTexImage, to avoid calling the Impl after
name|releaseTexImageInternal
argument_list|()
expr_stmt|;
comment|// EGL_KHR_gl_image states that images are only orphaned when generating mipmaps if the texture
comment|// is not mip complete.
if|if
condition|(
operator|!
name|isMipmapComplete
argument_list|()
condition|)
block|{
name|orphanImages
argument_list|()
expr_stmt|;
block|}
name|Error
name|error
init|=
name|mTexture
operator|->
name|generateMipmaps
argument_list|(
name|mTextureState
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
specifier|const
name|ImageDesc
modifier|&
name|baseImageInfo
init|=
name|getImageDesc
argument_list|(
name|getBaseImageTarget
argument_list|()
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|size_t
name|mipLevels
init|=
name|log2
argument_list|(
name|std
operator|::
name|max
argument_list|(
name|std
operator|::
name|max
argument_list|(
name|baseImageInfo
operator|.
name|size
operator|.
name|width
argument_list|,
name|baseImageInfo
operator|.
name|size
operator|.
name|height
argument_list|)
argument_list|,
name|baseImageInfo
operator|.
name|size
operator|.
name|depth
argument_list|)
argument_list|)
operator|+
literal|1
decl_stmt|;
name|setImageDescChain
argument_list|(
name|mipLevels
argument_list|,
name|baseImageInfo
operator|.
name|size
argument_list|,
name|baseImageInfo
operator|.
name|internalFormat
argument_list|)
expr_stmt|;
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|setImageDescChain
name|void
name|Texture
operator|::
name|setImageDescChain
parameter_list|(
name|size_t
name|levels
parameter_list|,
name|Extents
name|baseSize
parameter_list|,
name|GLenum
name|sizedInternalFormat
parameter_list|)
block|{
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|levels
argument_list|)
condition|;
name|level
operator|++
control|)
block|{
name|Extents
name|levelSize
argument_list|(
name|std
operator|::
name|max
argument_list|<
name|int
argument_list|>
argument_list|(
name|baseSize
operator|.
name|width
operator|>>
name|level
argument_list|,
literal|1
argument_list|)
argument_list|,
name|std
operator|::
name|max
argument_list|<
name|int
argument_list|>
argument_list|(
name|baseSize
operator|.
name|height
operator|>>
name|level
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|(
name|mTarget
operator|==
name|GL_TEXTURE_2D_ARRAY
operator|)
condition|?
name|baseSize
operator|.
name|depth
else|:
name|std
operator|::
name|max
argument_list|<
name|int
argument_list|>
argument_list|(
name|baseSize
operator|.
name|depth
operator|>>
name|level
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|ImageDesc
name|levelInfo
argument_list|(
name|levelSize
argument_list|,
name|sizedInternalFormat
argument_list|)
decl_stmt|;
if|if
condition|(
name|mTarget
operator|==
name|GL_TEXTURE_CUBE_MAP
condition|)
block|{
for|for
control|(
name|GLenum
name|face
init|=
name|FirstCubeMapTextureTarget
init|;
name|face
operator|<=
name|LastCubeMapTextureTarget
condition|;
name|face
operator|++
control|)
block|{
name|setImageDesc
argument_list|(
name|face
argument_list|,
name|level
argument_list|,
name|levelInfo
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|setImageDesc
argument_list|(
name|mTarget
argument_list|,
name|level
argument_list|,
name|levelInfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|ImageDesc
name|Texture
operator|::
name|ImageDesc
operator|::
name|ImageDesc
parameter_list|()
member_init_list|:
name|ImageDesc
argument_list|(
name|Extents
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GL_NONE
argument_list|)
block|{ }
DECL|function|ImageDesc
name|Texture
operator|::
name|ImageDesc
operator|::
name|ImageDesc
parameter_list|(
specifier|const
name|Extents
modifier|&
name|size
parameter_list|,
name|GLenum
name|internalFormat
parameter_list|)
member_init_list|:
name|size
argument_list|(
name|size
argument_list|)
member_init_list|,
name|internalFormat
argument_list|(
name|internalFormat
argument_list|)
block|{ }
DECL|function|getImageDesc
specifier|const
name|Texture
operator|::
name|ImageDesc
modifier|&
name|Texture
operator|::
name|getImageDesc
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|)
specifier|const
block|{
name|size_t
name|descIndex
init|=
name|GetImageDescIndex
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|descIndex
operator|<
name|mImageDescs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|mImageDescs
index|[
name|descIndex
index|]
return|;
block|}
DECL|function|setImageDesc
name|void
name|Texture
operator|::
name|setImageDesc
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|,
specifier|const
name|ImageDesc
modifier|&
name|desc
parameter_list|)
block|{
name|size_t
name|descIndex
init|=
name|GetImageDescIndex
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|descIndex
operator|<
name|mImageDescs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|mImageDescs
index|[
name|descIndex
index|]
operator|=
name|desc
expr_stmt|;
name|mCompletenessCache
operator|.
name|cacheValid
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|clearImageDesc
name|void
name|Texture
operator|::
name|clearImageDesc
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|)
block|{
name|setImageDesc
argument_list|(
name|target
argument_list|,
name|level
argument_list|,
name|ImageDesc
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|function|clearImageDescs
name|void
name|Texture
operator|::
name|clearImageDescs
parameter_list|()
block|{
for|for
control|(
name|size_t
name|descIndex
init|=
literal|0
init|;
name|descIndex
operator|<
name|mImageDescs
operator|.
name|size
argument_list|()
condition|;
name|descIndex
operator|++
control|)
block|{
name|mImageDescs
index|[
name|descIndex
index|]
operator|=
name|ImageDesc
argument_list|()
expr_stmt|;
block|}
name|mCompletenessCache
operator|.
name|cacheValid
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|bindTexImageFromSurface
name|void
name|Texture
operator|::
name|bindTexImageFromSurface
parameter_list|(
name|egl
operator|::
name|Surface
modifier|*
name|surface
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|surface
argument_list|)
expr_stmt|;
if|if
condition|(
name|mBoundSurface
condition|)
block|{
name|releaseTexImageFromSurface
argument_list|()
expr_stmt|;
block|}
name|mTexture
operator|->
name|bindTexImage
argument_list|(
name|surface
argument_list|)
expr_stmt|;
name|mBoundSurface
operator|=
name|surface
expr_stmt|;
comment|// Set the image info to the size and format of the surface
name|ASSERT
argument_list|(
name|mTarget
operator|==
name|GL_TEXTURE_2D
argument_list|)
expr_stmt|;
name|Extents
name|size
argument_list|(
name|surface
operator|->
name|getWidth
argument_list|()
argument_list|,
name|surface
operator|->
name|getHeight
argument_list|()
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|ImageDesc
name|desc
argument_list|(
name|size
argument_list|,
name|surface
operator|->
name|getConfig
argument_list|()
operator|->
name|renderTargetFormat
argument_list|)
decl_stmt|;
name|setImageDesc
argument_list|(
name|mTarget
argument_list|,
literal|0
argument_list|,
name|desc
argument_list|)
expr_stmt|;
block|}
DECL|function|releaseTexImageFromSurface
name|void
name|Texture
operator|::
name|releaseTexImageFromSurface
parameter_list|()
block|{
name|ASSERT
argument_list|(
name|mBoundSurface
argument_list|)
expr_stmt|;
name|mBoundSurface
operator|=
literal|nullptr
expr_stmt|;
name|mTexture
operator|->
name|releaseTexImage
argument_list|()
expr_stmt|;
comment|// Erase the image info for level 0
name|ASSERT
argument_list|(
name|mTarget
operator|==
name|GL_TEXTURE_2D
argument_list|)
expr_stmt|;
name|clearImageDesc
argument_list|(
name|mTarget
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
DECL|function|releaseTexImageInternal
name|void
name|Texture
operator|::
name|releaseTexImageInternal
parameter_list|()
block|{
if|if
condition|(
name|mBoundSurface
condition|)
block|{
comment|// Notify the surface
name|mBoundSurface
operator|->
name|releaseTexImageFromTexture
argument_list|()
expr_stmt|;
comment|// Then, call the same method as from the surface
name|releaseTexImageFromSurface
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|setEGLImageTarget
name|Error
name|Texture
operator|::
name|setEGLImageTarget
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|egl
operator|::
name|Image
modifier|*
name|imageTarget
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|mTarget
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|target
operator|==
name|GL_TEXTURE_2D
argument_list|)
expr_stmt|;
comment|// Release from previous calls to eglBindTexImage, to avoid calling the Impl after
name|releaseTexImageInternal
argument_list|()
expr_stmt|;
name|orphanImages
argument_list|()
expr_stmt|;
name|Error
name|error
init|=
name|mTexture
operator|->
name|setEGLImageTarget
argument_list|(
name|target
argument_list|,
name|imageTarget
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|setTargetImage
argument_list|(
name|imageTarget
argument_list|)
expr_stmt|;
name|Extents
name|size
argument_list|(
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|imageTarget
operator|->
name|getWidth
argument_list|()
argument_list|)
argument_list|,
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|imageTarget
operator|->
name|getHeight
argument_list|()
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|GLenum
name|internalFormat
init|=
name|imageTarget
operator|->
name|getInternalFormat
argument_list|()
decl_stmt|;
name|GLenum
name|type
init|=
name|GetInternalFormatInfo
argument_list|(
name|internalFormat
argument_list|)
operator|.
name|type
decl_stmt|;
name|clearImageDescs
argument_list|()
expr_stmt|;
name|setImageDesc
argument_list|(
name|target
argument_list|,
literal|0
argument_list|,
name|ImageDesc
argument_list|(
name|size
argument_list|,
name|GetSizedInternalFormat
argument_list|(
name|internalFormat
argument_list|,
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|getBaseImageTarget
name|GLenum
name|Texture
operator|::
name|getBaseImageTarget
parameter_list|()
specifier|const
block|{
return|return
name|mTarget
operator|==
name|GL_TEXTURE_CUBE_MAP
condition|?
name|FirstCubeMapTextureTarget
else|:
name|mTarget
return|;
block|}
DECL|function|computeSamplerCompleteness
name|bool
name|Texture
operator|::
name|computeSamplerCompleteness
parameter_list|(
specifier|const
name|SamplerState
modifier|&
name|samplerState
parameter_list|,
specifier|const
name|Data
modifier|&
name|data
parameter_list|)
specifier|const
block|{
specifier|const
name|ImageDesc
modifier|&
name|baseImageDesc
init|=
name|getImageDesc
argument_list|(
name|getBaseImageTarget
argument_list|()
argument_list|,
name|mTextureState
operator|.
name|baseLevel
argument_list|)
decl_stmt|;
if|if
condition|(
name|baseImageDesc
operator|.
name|size
operator|.
name|width
operator|==
literal|0
operator|||
name|baseImageDesc
operator|.
name|size
operator|.
name|height
operator|==
literal|0
operator|||
name|baseImageDesc
operator|.
name|size
operator|.
name|depth
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|mTarget
operator|==
name|GL_TEXTURE_CUBE_MAP
operator|&&
name|baseImageDesc
operator|.
name|size
operator|.
name|width
operator|!=
name|baseImageDesc
operator|.
name|size
operator|.
name|height
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|const
name|TextureCaps
modifier|&
name|textureCaps
init|=
name|data
operator|.
name|textureCaps
operator|->
name|get
argument_list|(
name|baseImageDesc
operator|.
name|internalFormat
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|textureCaps
operator|.
name|filterable
operator|&&
operator|!
name|IsPointSampled
argument_list|(
name|samplerState
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|bool
name|npotSupport
init|=
name|data
operator|.
name|extensions
operator|->
name|textureNPOT
operator|||
name|data
operator|.
name|clientVersion
operator|>=
literal|3
decl_stmt|;
if|if
condition|(
operator|!
name|npotSupport
condition|)
block|{
if|if
condition|(
operator|(
name|samplerState
operator|.
name|wrapS
operator|!=
name|GL_CLAMP_TO_EDGE
operator|&&
operator|!
name|gl
operator|::
name|isPow2
argument_list|(
name|baseImageDesc
operator|.
name|size
operator|.
name|width
argument_list|)
operator|)
operator|||
operator|(
name|samplerState
operator|.
name|wrapT
operator|!=
name|GL_CLAMP_TO_EDGE
operator|&&
operator|!
name|gl
operator|::
name|isPow2
argument_list|(
name|baseImageDesc
operator|.
name|size
operator|.
name|height
argument_list|)
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|IsMipmapFiltered
argument_list|(
name|samplerState
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|npotSupport
condition|)
block|{
if|if
condition|(
operator|!
name|gl
operator|::
name|isPow2
argument_list|(
name|baseImageDesc
operator|.
name|size
operator|.
name|width
argument_list|)
operator|||
operator|!
name|gl
operator|::
name|isPow2
argument_list|(
name|baseImageDesc
operator|.
name|size
operator|.
name|height
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
operator|!
name|computeMipmapCompleteness
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|mTarget
operator|==
name|GL_TEXTURE_CUBE_MAP
operator|&&
operator|!
name|isCubeComplete
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|// OpenGLES 3.0.2 spec section 3.8.13 states that a texture is not mipmap complete if:
comment|// The internalformat specified for the texture arrays is a sized internal depth or
comment|// depth and stencil format (see table 3.13), the value of TEXTURE_COMPARE_-
comment|// MODE is NONE, and either the magnification filter is not NEAREST or the mini-
comment|// fication filter is neither NEAREST nor NEAREST_MIPMAP_NEAREST.
specifier|const
name|gl
operator|::
name|InternalFormat
modifier|&
name|formatInfo
init|=
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|baseImageDesc
operator|.
name|internalFormat
argument_list|)
decl_stmt|;
if|if
condition|(
name|formatInfo
operator|.
name|depthBits
operator|>
literal|0
operator|&&
name|data
operator|.
name|clientVersion
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|samplerState
operator|.
name|compareMode
operator|==
name|GL_NONE
condition|)
block|{
if|if
condition|(
operator|(
name|samplerState
operator|.
name|minFilter
operator|!=
name|GL_NEAREST
operator|&&
name|samplerState
operator|.
name|minFilter
operator|!=
name|GL_NEAREST_MIPMAP_NEAREST
operator|)
operator|||
name|samplerState
operator|.
name|magFilter
operator|!=
name|GL_NEAREST
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|computeMipmapCompleteness
name|bool
name|Texture
operator|::
name|computeMipmapCompleteness
parameter_list|()
specifier|const
block|{
name|size_t
name|expectedMipLevels
init|=
name|getMipCompleteLevels
argument_list|()
decl_stmt|;
name|size_t
name|maxLevel
init|=
name|std
operator|::
name|min
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|expectedMipLevels
argument_list|,
name|mTextureState
operator|.
name|maxLevel
operator|+
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|level
init|=
name|mTextureState
operator|.
name|baseLevel
init|;
name|level
operator|<
name|maxLevel
condition|;
name|level
operator|++
control|)
block|{
if|if
condition|(
name|mTarget
operator|==
name|GL_TEXTURE_CUBE_MAP
condition|)
block|{
for|for
control|(
name|GLenum
name|face
init|=
name|FirstCubeMapTextureTarget
init|;
name|face
operator|<=
name|LastCubeMapTextureTarget
condition|;
name|face
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|computeLevelCompleteness
argument_list|(
name|face
argument_list|,
name|level
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|computeLevelCompleteness
argument_list|(
name|mTarget
argument_list|,
name|level
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|computeLevelCompleteness
name|bool
name|Texture
operator|::
name|computeLevelCompleteness
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|level
operator|<
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
argument_list|)
expr_stmt|;
if|if
condition|(
name|mTextureState
operator|.
name|immutableFormat
condition|)
block|{
return|return
literal|true
return|;
block|}
specifier|const
name|ImageDesc
modifier|&
name|baseImageDesc
init|=
name|getImageDesc
argument_list|(
name|getBaseImageTarget
argument_list|()
argument_list|,
name|mTextureState
operator|.
name|baseLevel
argument_list|)
decl_stmt|;
if|if
condition|(
name|baseImageDesc
operator|.
name|size
operator|.
name|width
operator|==
literal|0
operator|||
name|baseImageDesc
operator|.
name|size
operator|.
name|height
operator|==
literal|0
operator|||
name|baseImageDesc
operator|.
name|size
operator|.
name|depth
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|const
name|ImageDesc
modifier|&
name|levelImageDesc
init|=
name|getImageDesc
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
decl_stmt|;
if|if
condition|(
name|levelImageDesc
operator|.
name|size
operator|.
name|width
operator|==
literal|0
operator|||
name|levelImageDesc
operator|.
name|size
operator|.
name|height
operator|==
literal|0
operator|||
name|levelImageDesc
operator|.
name|size
operator|.
name|depth
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|levelImageDesc
operator|.
name|internalFormat
operator|!=
name|baseImageDesc
operator|.
name|internalFormat
condition|)
block|{
return|return
literal|false
return|;
block|}
name|ASSERT
argument_list|(
name|level
operator|>=
name|mTextureState
operator|.
name|baseLevel
argument_list|)
expr_stmt|;
specifier|const
name|size_t
name|relativeLevel
init|=
name|level
operator|-
name|mTextureState
operator|.
name|baseLevel
decl_stmt|;
if|if
condition|(
name|levelImageDesc
operator|.
name|size
operator|.
name|width
operator|!=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|baseImageDesc
operator|.
name|size
operator|.
name|width
operator|>>
name|relativeLevel
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|levelImageDesc
operator|.
name|size
operator|.
name|height
operator|!=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|baseImageDesc
operator|.
name|size
operator|.
name|height
operator|>>
name|relativeLevel
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|mTarget
operator|==
name|GL_TEXTURE_3D
condition|)
block|{
if|if
condition|(
name|levelImageDesc
operator|.
name|size
operator|.
name|depth
operator|!=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|baseImageDesc
operator|.
name|size
operator|.
name|depth
operator|>>
name|relativeLevel
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|mTarget
operator|==
name|GL_TEXTURE_2D_ARRAY
condition|)
block|{
if|if
condition|(
name|levelImageDesc
operator|.
name|size
operator|.
name|depth
operator|!=
name|baseImageDesc
operator|.
name|size
operator|.
name|depth
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|SamplerCompletenessCache
name|Texture
operator|::
name|SamplerCompletenessCache
operator|::
name|SamplerCompletenessCache
parameter_list|()
member_init_list|:
name|cacheValid
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|samplerState
argument_list|()
member_init_list|,
name|filterable
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|clientVersion
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|supportsNPOT
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|samplerComplete
argument_list|(
literal|false
argument_list|)
block|{ }
DECL|function|getAttachmentSize
name|Extents
name|Texture
operator|::
name|getAttachmentSize
parameter_list|(
specifier|const
name|gl
operator|::
name|FramebufferAttachment
operator|::
name|Target
modifier|&
name|target
parameter_list|)
specifier|const
block|{
return|return
name|getImageDesc
argument_list|(
name|target
operator|.
name|textureIndex
argument_list|()
operator|.
name|type
argument_list|,
name|target
operator|.
name|textureIndex
argument_list|()
operator|.
name|mipIndex
argument_list|)
operator|.
name|size
return|;
block|}
DECL|function|getAttachmentInternalFormat
name|GLenum
name|Texture
operator|::
name|getAttachmentInternalFormat
parameter_list|(
specifier|const
name|gl
operator|::
name|FramebufferAttachment
operator|::
name|Target
modifier|&
name|target
parameter_list|)
specifier|const
block|{
return|return
name|getInternalFormat
argument_list|(
name|target
operator|.
name|textureIndex
argument_list|()
operator|.
name|type
argument_list|,
name|target
operator|.
name|textureIndex
argument_list|()
operator|.
name|mipIndex
argument_list|)
return|;
block|}
DECL|function|getAttachmentSamples
name|GLsizei
name|Texture
operator|::
name|getAttachmentSamples
parameter_list|(
specifier|const
name|gl
operator|::
name|FramebufferAttachment
operator|::
name|Target
modifier|&
comment|/*target*/
parameter_list|)
specifier|const
block|{
comment|// Multisample textures not currently supported
return|return
literal|0
return|;
block|}
DECL|function|onAttach
name|void
name|Texture
operator|::
name|onAttach
parameter_list|()
block|{
name|addRef
argument_list|()
expr_stmt|;
block|}
DECL|function|onDetach
name|void
name|Texture
operator|::
name|onDetach
parameter_list|()
block|{
name|release
argument_list|()
expr_stmt|;
block|}
DECL|function|getId
name|GLuint
name|Texture
operator|::
name|getId
parameter_list|()
specifier|const
block|{
return|return
name|id
argument_list|()
return|;
block|}
block|}
end_namespace
end_unit
