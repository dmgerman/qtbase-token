begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2015 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// validationEGL.cpp: Validation functions for generic EGL entry point parameters
end_comment
begin_include
include|#
directive|include
file|"libANGLE/validationEGL.h"
end_include
begin_include
include|#
directive|include
file|"common/utilities.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Config.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Context.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Device.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Display.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Image.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Surface.h"
end_include
begin_include
include|#
directive|include
file|<EGL/eglext.h>
end_include
begin_namespace
namespace|namespace
block|{
DECL|function|GetMaximumMipLevel
name|size_t
name|GetMaximumMipLevel
parameter_list|(
specifier|const
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|)
block|{
specifier|const
name|gl
operator|::
name|Caps
modifier|&
name|caps
init|=
name|context
operator|->
name|getCaps
argument_list|()
decl_stmt|;
name|size_t
name|maxDimension
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TEXTURE_2D
case|:
name|maxDimension
operator|=
name|caps
operator|.
name|max2DTextureSize
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_CUBE_MAP
case|:
name|maxDimension
operator|=
name|caps
operator|.
name|maxCubeMapTextureSize
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_3D
case|:
name|maxDimension
operator|=
name|caps
operator|.
name|max3DTextureSize
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_2D_ARRAY
case|:
name|maxDimension
operator|=
name|caps
operator|.
name|max2DTextureSize
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|log2
argument_list|(
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|maxDimension
argument_list|)
argument_list|)
return|;
block|}
DECL|function|TextureHasNonZeroMipLevelsSpecified
name|bool
name|TextureHasNonZeroMipLevelsSpecified
parameter_list|(
specifier|const
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
specifier|const
name|gl
operator|::
name|Texture
modifier|*
name|texture
parameter_list|)
block|{
name|size_t
name|maxMip
init|=
name|GetMaximumMipLevel
argument_list|(
name|context
argument_list|,
name|texture
operator|->
name|getTarget
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|level
init|=
literal|1
init|;
name|level
operator|<
name|maxMip
condition|;
name|level
operator|++
control|)
block|{
if|if
condition|(
name|texture
operator|->
name|getTarget
argument_list|()
operator|==
name|GL_TEXTURE_CUBE_MAP
condition|)
block|{
for|for
control|(
name|GLenum
name|face
init|=
name|gl
operator|::
name|FirstCubeMapTextureTarget
init|;
name|face
operator|<=
name|gl
operator|::
name|LastCubeMapTextureTarget
condition|;
name|face
operator|++
control|)
block|{
if|if
condition|(
name|texture
operator|->
name|getInternalFormat
argument_list|(
name|face
argument_list|,
name|level
argument_list|)
operator|!=
name|GL_NONE
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|texture
operator|->
name|getInternalFormat
argument_list|(
name|texture
operator|->
name|getTarget
argument_list|()
argument_list|,
name|level
argument_list|)
operator|!=
name|GL_NONE
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|function|CubeTextureHasUnspecifiedLevel0Face
name|bool
name|CubeTextureHasUnspecifiedLevel0Face
parameter_list|(
specifier|const
name|gl
operator|::
name|Texture
modifier|*
name|texture
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|texture
operator|->
name|getTarget
argument_list|()
operator|==
name|GL_TEXTURE_CUBE_MAP
argument_list|)
expr_stmt|;
for|for
control|(
name|GLenum
name|face
init|=
name|gl
operator|::
name|FirstCubeMapTextureTarget
init|;
name|face
operator|<=
name|gl
operator|::
name|LastCubeMapTextureTarget
condition|;
name|face
operator|++
control|)
block|{
if|if
condition|(
name|texture
operator|->
name|getInternalFormat
argument_list|(
name|face
argument_list|,
literal|0
argument_list|)
operator|==
name|GL_NONE
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
block|}
end_namespace
begin_namespace
DECL|namespace|egl
namespace|namespace
name|egl
block|{
DECL|function|ValidateDisplay
name|Error
name|ValidateDisplay
parameter_list|(
specifier|const
name|Display
modifier|*
name|display
parameter_list|)
block|{
if|if
condition|(
name|display
operator|==
name|EGL_NO_DISPLAY
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_DISPLAY
argument_list|,
literal|"display is EGL_NO_DISPLAY."
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|Display
operator|::
name|isValidDisplay
argument_list|(
name|display
argument_list|)
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_DISPLAY
argument_list|,
literal|"display is not a valid display."
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|display
operator|->
name|isInitialized
argument_list|()
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_NOT_INITIALIZED
argument_list|,
literal|"display is not initialized."
argument_list|)
return|;
block|}
return|return
name|Error
argument_list|(
name|EGL_SUCCESS
argument_list|)
return|;
block|}
DECL|function|ValidateSurface
name|Error
name|ValidateSurface
parameter_list|(
specifier|const
name|Display
modifier|*
name|display
parameter_list|,
name|Surface
modifier|*
name|surface
parameter_list|)
block|{
name|Error
name|error
init|=
name|ValidateDisplay
argument_list|(
name|display
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
operator|!
name|display
operator|->
name|isValidSurface
argument_list|(
name|surface
argument_list|)
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_SURFACE
argument_list|)
return|;
block|}
return|return
name|Error
argument_list|(
name|EGL_SUCCESS
argument_list|)
return|;
block|}
DECL|function|ValidateConfig
name|Error
name|ValidateConfig
parameter_list|(
specifier|const
name|Display
modifier|*
name|display
parameter_list|,
specifier|const
name|Config
modifier|*
name|config
parameter_list|)
block|{
name|Error
name|error
init|=
name|ValidateDisplay
argument_list|(
name|display
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
operator|!
name|display
operator|->
name|isValidConfig
argument_list|(
name|config
argument_list|)
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_CONFIG
argument_list|)
return|;
block|}
return|return
name|Error
argument_list|(
name|EGL_SUCCESS
argument_list|)
return|;
block|}
DECL|function|ValidateContext
name|Error
name|ValidateContext
parameter_list|(
specifier|const
name|Display
modifier|*
name|display
parameter_list|,
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|)
block|{
name|Error
name|error
init|=
name|ValidateDisplay
argument_list|(
name|display
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
operator|!
name|display
operator|->
name|isValidContext
argument_list|(
name|context
argument_list|)
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_CONTEXT
argument_list|)
return|;
block|}
return|return
name|Error
argument_list|(
name|EGL_SUCCESS
argument_list|)
return|;
block|}
DECL|function|ValidateImage
name|Error
name|ValidateImage
parameter_list|(
specifier|const
name|Display
modifier|*
name|display
parameter_list|,
specifier|const
name|Image
modifier|*
name|image
parameter_list|)
block|{
name|Error
name|error
init|=
name|ValidateDisplay
argument_list|(
name|display
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
operator|!
name|display
operator|->
name|isValidImage
argument_list|(
name|image
argument_list|)
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|,
literal|"image is not valid."
argument_list|)
return|;
block|}
return|return
name|Error
argument_list|(
name|EGL_SUCCESS
argument_list|)
return|;
block|}
DECL|function|ValidateCreateContext
name|Error
name|ValidateCreateContext
parameter_list|(
name|Display
modifier|*
name|display
parameter_list|,
name|Config
modifier|*
name|configuration
parameter_list|,
name|gl
operator|::
name|Context
modifier|*
name|shareContext
parameter_list|,
specifier|const
name|AttributeMap
modifier|&
name|attributes
parameter_list|)
block|{
name|Error
name|error
init|=
name|ValidateConfig
argument_list|(
name|display
argument_list|,
name|configuration
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
comment|// Get the requested client version (default is 1) and check it is 2 or 3.
name|EGLint
name|clientMajorVersion
init|=
literal|1
decl_stmt|;
name|EGLint
name|clientMinorVersion
init|=
literal|0
decl_stmt|;
name|EGLint
name|contextFlags
init|=
literal|0
decl_stmt|;
name|bool
name|resetNotification
init|=
literal|false
decl_stmt|;
name|bool
name|robustAccess
init|=
literal|false
decl_stmt|;
for|for
control|(
name|AttributeMap
operator|::
name|const_iterator
name|attributeIter
init|=
name|attributes
operator|.
name|begin
argument_list|()
init|;
name|attributeIter
operator|!=
name|attributes
operator|.
name|end
argument_list|()
condition|;
name|attributeIter
operator|++
control|)
block|{
name|EGLint
name|attribute
init|=
name|attributeIter
operator|->
name|first
decl_stmt|;
name|EGLint
name|value
init|=
name|attributeIter
operator|->
name|second
decl_stmt|;
switch|switch
condition|(
name|attribute
condition|)
block|{
case|case
name|EGL_CONTEXT_CLIENT_VERSION
case|:
name|clientMajorVersion
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|EGL_CONTEXT_MINOR_VERSION
case|:
name|clientMinorVersion
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|EGL_CONTEXT_FLAGS_KHR
case|:
name|contextFlags
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|EGL_CONTEXT_OPENGL_DEBUG
case|:
break|break;
case|case
name|EGL_CONTEXT_OPENGL_PROFILE_MASK_KHR
case|:
comment|// Only valid for OpenGL (non-ES) contexts
return|return
name|Error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|)
return|;
case|case
name|EGL_CONTEXT_OPENGL_ROBUST_ACCESS_EXT
case|:
if|if
condition|(
operator|!
name|display
operator|->
name|getExtensions
argument_list|()
operator|.
name|createContextRobustness
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|)
return|;
block|}
if|if
condition|(
name|value
operator|!=
name|EGL_TRUE
operator|&&
name|value
operator|!=
name|EGL_FALSE
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|)
return|;
block|}
name|robustAccess
operator|=
operator|(
name|value
operator|==
name|EGL_TRUE
operator|)
expr_stmt|;
break|break;
case|case
name|EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_KHR
case|:
assert|static_assert
argument_list|(
name|EGL_LOSE_CONTEXT_ON_RESET_EXT
operator|==
name|EGL_LOSE_CONTEXT_ON_RESET_KHR
argument_list|,
literal|"EGL extension enums not equal."
argument_list|)
assert|;
assert|static_assert
argument_list|(
name|EGL_NO_RESET_NOTIFICATION_EXT
operator|==
name|EGL_NO_RESET_NOTIFICATION_KHR
argument_list|,
literal|"EGL extension enums not equal."
argument_list|)
assert|;
comment|// same as EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_EXT, fall through
case|case
name|EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_EXT
case|:
if|if
condition|(
operator|!
name|display
operator|->
name|getExtensions
argument_list|()
operator|.
name|createContextRobustness
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|)
return|;
block|}
if|if
condition|(
name|value
operator|==
name|EGL_LOSE_CONTEXT_ON_RESET_EXT
condition|)
block|{
name|resetNotification
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
name|EGL_NO_RESET_NOTIFICATION_EXT
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|)
return|;
block|}
break|break;
case|case
name|EGL_CONTEXT_OPENGL_NO_ERROR_KHR
case|:
if|if
condition|(
operator|!
name|display
operator|->
name|getExtensions
argument_list|()
operator|.
name|createContextNoError
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|,
literal|"Invalid Context attribute."
argument_list|)
return|;
block|}
if|if
condition|(
name|value
operator|!=
name|EGL_TRUE
operator|&&
name|value
operator|!=
name|EGL_FALSE
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|,
literal|"Attribute must be EGL_TRUE or EGL_FALSE."
argument_list|)
return|;
block|}
break|break;
default|default:
return|return
name|Error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|clientMajorVersion
operator|!=
literal|2
operator|&&
name|clientMajorVersion
operator|!=
literal|3
operator|)
operator|||
name|clientMinorVersion
operator|!=
literal|0
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_CONFIG
argument_list|)
return|;
block|}
if|if
condition|(
name|clientMajorVersion
operator|==
literal|3
operator|&&
operator|!
operator|(
name|configuration
operator|->
name|conformant
operator|&
name|EGL_OPENGL_ES3_BIT_KHR
operator|)
operator|&&
operator|!
operator|(
name|configuration
operator|->
name|configCaveat
operator|&
name|EGL_NON_CONFORMANT_CONFIG
operator|)
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_CONFIG
argument_list|)
return|;
block|}
comment|// Note: EGL_CONTEXT_OPENGL_FORWARD_COMPATIBLE_BIT_KHR does not apply to ES
specifier|const
name|EGLint
name|validContextFlags
init|=
operator|(
name|EGL_CONTEXT_OPENGL_DEBUG_BIT_KHR
operator||
name|EGL_CONTEXT_OPENGL_ROBUST_ACCESS_BIT_KHR
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|contextFlags
operator|&
operator|~
name|validContextFlags
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|contextFlags
operator|&
name|EGL_CONTEXT_OPENGL_ROBUST_ACCESS_BIT_KHR
operator|)
operator|>
literal|0
condition|)
block|{
name|robustAccess
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|robustAccess
condition|)
block|{
comment|// Unimplemented
return|return
name|Error
argument_list|(
name|EGL_BAD_CONFIG
argument_list|)
return|;
block|}
if|if
condition|(
name|shareContext
condition|)
block|{
comment|// Shared context is invalid or is owned by another display
if|if
condition|(
operator|!
name|display
operator|->
name|isValidContext
argument_list|(
name|shareContext
argument_list|)
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_MATCH
argument_list|)
return|;
block|}
if|if
condition|(
name|shareContext
operator|->
name|isResetNotificationEnabled
argument_list|()
operator|!=
name|resetNotification
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_MATCH
argument_list|)
return|;
block|}
if|if
condition|(
name|shareContext
operator|->
name|getClientVersion
argument_list|()
operator|!=
name|clientMajorVersion
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_CONTEXT
argument_list|)
return|;
block|}
block|}
return|return
name|Error
argument_list|(
name|EGL_SUCCESS
argument_list|)
return|;
block|}
DECL|function|ValidateCreateWindowSurface
name|Error
name|ValidateCreateWindowSurface
parameter_list|(
name|Display
modifier|*
name|display
parameter_list|,
name|Config
modifier|*
name|config
parameter_list|,
name|EGLNativeWindowType
name|window
parameter_list|,
specifier|const
name|AttributeMap
modifier|&
name|attributes
parameter_list|)
block|{
name|Error
name|error
init|=
name|ValidateConfig
argument_list|(
name|display
argument_list|,
name|config
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
operator|!
name|display
operator|->
name|isValidNativeWindow
argument_list|(
name|window
argument_list|)
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_NATIVE_WINDOW
argument_list|)
return|;
block|}
specifier|const
name|DisplayExtensions
modifier|&
name|displayExtensions
init|=
name|display
operator|->
name|getExtensions
argument_list|()
decl_stmt|;
for|for
control|(
name|AttributeMap
operator|::
name|const_iterator
name|attributeIter
init|=
name|attributes
operator|.
name|begin
argument_list|()
init|;
name|attributeIter
operator|!=
name|attributes
operator|.
name|end
argument_list|()
condition|;
name|attributeIter
operator|++
control|)
block|{
name|EGLint
name|attribute
init|=
name|attributeIter
operator|->
name|first
decl_stmt|;
name|EGLint
name|value
init|=
name|attributeIter
operator|->
name|second
decl_stmt|;
switch|switch
condition|(
name|attribute
condition|)
block|{
case|case
name|EGL_RENDER_BUFFER
case|:
switch|switch
condition|(
name|value
condition|)
block|{
case|case
name|EGL_BACK_BUFFER
case|:
break|break;
case|case
name|EGL_SINGLE_BUFFER
case|:
return|return
name|Error
argument_list|(
name|EGL_BAD_MATCH
argument_list|)
return|;
comment|// Rendering directly to front buffer not supported
default|default:
return|return
name|Error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|)
return|;
block|}
break|break;
case|case
name|EGL_POST_SUB_BUFFER_SUPPORTED_NV
case|:
if|if
condition|(
operator|!
name|displayExtensions
operator|.
name|postSubBuffer
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|)
return|;
block|}
break|break;
case|case
name|EGL_FLEXIBLE_SURFACE_COMPATIBILITY_SUPPORTED_ANGLE
case|:
if|if
condition|(
operator|!
name|displayExtensions
operator|.
name|flexibleSurfaceCompatibility
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|)
return|;
block|}
break|break;
case|case
name|EGL_WIDTH
case|:
case|case
name|EGL_HEIGHT
case|:
if|if
condition|(
operator|!
name|displayExtensions
operator|.
name|windowFixedSize
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|)
return|;
block|}
if|if
condition|(
name|value
operator|<
literal|0
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|)
return|;
block|}
break|break;
case|case
name|EGL_FIXED_SIZE_ANGLE
case|:
if|if
condition|(
operator|!
name|displayExtensions
operator|.
name|windowFixedSize
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|)
return|;
block|}
break|break;
case|case
name|EGL_SURFACE_ORIENTATION_ANGLE
case|:
if|if
condition|(
operator|!
name|displayExtensions
operator|.
name|surfaceOrientation
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|,
literal|"EGL_ANGLE_surface_orientation is not enabled."
argument_list|)
return|;
block|}
break|break;
case|case
name|EGL_VG_COLORSPACE
case|:
return|return
name|Error
argument_list|(
name|EGL_BAD_MATCH
argument_list|)
return|;
case|case
name|EGL_VG_ALPHA_FORMAT
case|:
return|return
name|Error
argument_list|(
name|EGL_BAD_MATCH
argument_list|)
return|;
case|case
name|EGL_DIRECT_COMPOSITION_ANGLE
case|:
if|if
condition|(
operator|!
name|displayExtensions
operator|.
name|directComposition
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|)
return|;
block|}
break|break;
default|default:
return|return
name|Error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|Display
operator|::
name|hasExistingWindowSurface
argument_list|(
name|window
argument_list|)
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_ALLOC
argument_list|)
return|;
block|}
return|return
name|Error
argument_list|(
name|EGL_SUCCESS
argument_list|)
return|;
block|}
DECL|function|ValidateCreatePbufferSurface
name|Error
name|ValidateCreatePbufferSurface
parameter_list|(
name|Display
modifier|*
name|display
parameter_list|,
name|Config
modifier|*
name|config
parameter_list|,
specifier|const
name|AttributeMap
modifier|&
name|attributes
parameter_list|)
block|{
name|Error
name|error
init|=
name|ValidateConfig
argument_list|(
name|display
argument_list|,
name|config
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
specifier|const
name|DisplayExtensions
modifier|&
name|displayExtensions
init|=
name|display
operator|->
name|getExtensions
argument_list|()
decl_stmt|;
for|for
control|(
name|AttributeMap
operator|::
name|const_iterator
name|attributeIter
init|=
name|attributes
operator|.
name|begin
argument_list|()
init|;
name|attributeIter
operator|!=
name|attributes
operator|.
name|end
argument_list|()
condition|;
name|attributeIter
operator|++
control|)
block|{
name|EGLint
name|attribute
init|=
name|attributeIter
operator|->
name|first
decl_stmt|;
name|EGLint
name|value
init|=
name|attributeIter
operator|->
name|second
decl_stmt|;
switch|switch
condition|(
name|attribute
condition|)
block|{
case|case
name|EGL_WIDTH
case|:
case|case
name|EGL_HEIGHT
case|:
if|if
condition|(
name|value
operator|<
literal|0
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|)
return|;
block|}
break|break;
case|case
name|EGL_LARGEST_PBUFFER
case|:
break|break;
case|case
name|EGL_TEXTURE_FORMAT
case|:
switch|switch
condition|(
name|value
condition|)
block|{
case|case
name|EGL_NO_TEXTURE
case|:
case|case
name|EGL_TEXTURE_RGB
case|:
case|case
name|EGL_TEXTURE_RGBA
case|:
break|break;
default|default:
return|return
name|Error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|)
return|;
block|}
break|break;
case|case
name|EGL_TEXTURE_TARGET
case|:
switch|switch
condition|(
name|value
condition|)
block|{
case|case
name|EGL_NO_TEXTURE
case|:
case|case
name|EGL_TEXTURE_2D
case|:
break|break;
default|default:
return|return
name|Error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|)
return|;
block|}
break|break;
case|case
name|EGL_MIPMAP_TEXTURE
case|:
break|break;
case|case
name|EGL_VG_COLORSPACE
case|:
break|break;
case|case
name|EGL_VG_ALPHA_FORMAT
case|:
break|break;
case|case
name|EGL_FLEXIBLE_SURFACE_COMPATIBILITY_SUPPORTED_ANGLE
case|:
if|if
condition|(
operator|!
name|displayExtensions
operator|.
name|flexibleSurfaceCompatibility
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|,
literal|"EGL_FLEXIBLE_SURFACE_COMPATIBILITY_SUPPORTED_ANGLE cannot be used without "
literal|"EGL_ANGLE_flexible_surface_compatibility support."
argument_list|)
return|;
block|}
break|break;
default|default:
return|return
name|Error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|)
return|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|config
operator|->
name|surfaceType
operator|&
name|EGL_PBUFFER_BIT
operator|)
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_MATCH
argument_list|)
return|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ANGLE_ENABLE_WINDOWS_STORE
argument_list|)
comment|// On Windows Store, we know the originating texture came from D3D11, so bypass this check
specifier|const
name|Caps
modifier|&
name|caps
init|=
name|display
operator|->
name|getCaps
argument_list|()
decl_stmt|;
name|EGLenum
name|textureFormat
init|=
name|attributes
operator|.
name|get
argument_list|(
name|EGL_TEXTURE_FORMAT
argument_list|,
name|EGL_NO_TEXTURE
argument_list|)
decl_stmt|;
name|EGLenum
name|textureTarget
init|=
name|attributes
operator|.
name|get
argument_list|(
name|EGL_TEXTURE_TARGET
argument_list|,
name|EGL_NO_TEXTURE
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|textureFormat
operator|!=
name|EGL_NO_TEXTURE
operator|&&
name|textureTarget
operator|==
name|EGL_NO_TEXTURE
operator|)
operator|||
operator|(
name|textureFormat
operator|==
name|EGL_NO_TEXTURE
operator|&&
name|textureTarget
operator|!=
name|EGL_NO_TEXTURE
operator|)
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_MATCH
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|textureFormat
operator|==
name|EGL_TEXTURE_RGB
operator|&&
name|config
operator|->
name|bindToTextureRGB
operator|!=
name|EGL_TRUE
operator|)
operator|||
operator|(
name|textureFormat
operator|==
name|EGL_TEXTURE_RGBA
operator|&&
name|config
operator|->
name|bindToTextureRGBA
operator|!=
name|EGL_TRUE
operator|)
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|)
return|;
block|}
name|EGLint
name|width
init|=
name|attributes
operator|.
name|get
argument_list|(
name|EGL_WIDTH
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|EGLint
name|height
init|=
name|attributes
operator|.
name|get
argument_list|(
name|EGL_HEIGHT
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|textureFormat
operator|!=
name|EGL_NO_TEXTURE
operator|&&
operator|!
name|caps
operator|.
name|textureNPOT
operator|&&
operator|(
operator|!
name|gl
operator|::
name|isPow2
argument_list|(
name|width
argument_list|)
operator|||
operator|!
name|gl
operator|::
name|isPow2
argument_list|(
name|height
argument_list|)
operator|)
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_MATCH
argument_list|)
return|;
block|}
endif|#
directive|endif
return|return
name|Error
argument_list|(
name|EGL_SUCCESS
argument_list|)
return|;
block|}
DECL|function|ValidateCreatePbufferFromClientBuffer
name|Error
name|ValidateCreatePbufferFromClientBuffer
parameter_list|(
name|Display
modifier|*
name|display
parameter_list|,
name|EGLenum
name|buftype
parameter_list|,
name|EGLClientBuffer
name|buffer
parameter_list|,
name|Config
modifier|*
name|config
parameter_list|,
specifier|const
name|AttributeMap
modifier|&
name|attributes
parameter_list|)
block|{
name|Error
name|error
init|=
name|ValidateConfig
argument_list|(
name|display
argument_list|,
name|config
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
specifier|const
name|DisplayExtensions
modifier|&
name|displayExtensions
init|=
name|display
operator|->
name|getExtensions
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|buftype
condition|)
block|{
case|case
name|EGL_D3D_TEXTURE_2D_SHARE_HANDLE_ANGLE
case|:
if|if
condition|(
operator|!
name|displayExtensions
operator|.
name|d3dShareHandleClientBuffer
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|)
return|;
block|}
if|if
condition|(
name|buffer
operator|==
literal|nullptr
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|)
return|;
block|}
break|break;
default|default:
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|)
return|;
block|}
for|for
control|(
name|AttributeMap
operator|::
name|const_iterator
name|attributeIter
init|=
name|attributes
operator|.
name|begin
argument_list|()
init|;
name|attributeIter
operator|!=
name|attributes
operator|.
name|end
argument_list|()
condition|;
name|attributeIter
operator|++
control|)
block|{
name|EGLint
name|attribute
init|=
name|attributeIter
operator|->
name|first
decl_stmt|;
name|EGLint
name|value
init|=
name|attributeIter
operator|->
name|second
decl_stmt|;
switch|switch
condition|(
name|attribute
condition|)
block|{
case|case
name|EGL_WIDTH
case|:
case|case
name|EGL_HEIGHT
case|:
if|if
condition|(
operator|!
name|displayExtensions
operator|.
name|d3dShareHandleClientBuffer
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|)
return|;
block|}
if|if
condition|(
name|value
operator|<
literal|0
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|)
return|;
block|}
break|break;
case|case
name|EGL_TEXTURE_FORMAT
case|:
switch|switch
condition|(
name|value
condition|)
block|{
case|case
name|EGL_NO_TEXTURE
case|:
case|case
name|EGL_TEXTURE_RGB
case|:
case|case
name|EGL_TEXTURE_RGBA
case|:
break|break;
default|default:
return|return
name|Error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|)
return|;
block|}
break|break;
case|case
name|EGL_TEXTURE_TARGET
case|:
switch|switch
condition|(
name|value
condition|)
block|{
case|case
name|EGL_NO_TEXTURE
case|:
case|case
name|EGL_TEXTURE_2D
case|:
break|break;
default|default:
return|return
name|Error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|)
return|;
block|}
break|break;
case|case
name|EGL_MIPMAP_TEXTURE
case|:
break|break;
case|case
name|EGL_FLEXIBLE_SURFACE_COMPATIBILITY_SUPPORTED_ANGLE
case|:
if|if
condition|(
operator|!
name|displayExtensions
operator|.
name|flexibleSurfaceCompatibility
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|,
literal|"EGL_FLEXIBLE_SURFACE_COMPATIBILITY_SUPPORTED_ANGLE cannot be used without "
literal|"EGL_ANGLE_flexible_surface_compatibility support."
argument_list|)
return|;
block|}
break|break;
default|default:
return|return
name|Error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|)
return|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|config
operator|->
name|surfaceType
operator|&
name|EGL_PBUFFER_BIT
operator|)
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_MATCH
argument_list|)
return|;
block|}
name|EGLenum
name|textureFormat
init|=
name|attributes
operator|.
name|get
argument_list|(
name|EGL_TEXTURE_FORMAT
argument_list|,
name|EGL_NO_TEXTURE
argument_list|)
decl_stmt|;
name|EGLenum
name|textureTarget
init|=
name|attributes
operator|.
name|get
argument_list|(
name|EGL_TEXTURE_TARGET
argument_list|,
name|EGL_NO_TEXTURE
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|textureFormat
operator|!=
name|EGL_NO_TEXTURE
operator|&&
name|textureTarget
operator|==
name|EGL_NO_TEXTURE
operator|)
operator|||
operator|(
name|textureFormat
operator|==
name|EGL_NO_TEXTURE
operator|&&
name|textureTarget
operator|!=
name|EGL_NO_TEXTURE
operator|)
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_MATCH
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|textureFormat
operator|==
name|EGL_TEXTURE_RGB
operator|&&
name|config
operator|->
name|bindToTextureRGB
operator|!=
name|EGL_TRUE
operator|)
operator|||
operator|(
name|textureFormat
operator|==
name|EGL_TEXTURE_RGBA
operator|&&
name|config
operator|->
name|bindToTextureRGBA
operator|!=
name|EGL_TRUE
operator|)
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|)
return|;
block|}
if|if
condition|(
name|buftype
operator|==
name|EGL_D3D_TEXTURE_2D_SHARE_HANDLE_ANGLE
condition|)
block|{
name|EGLint
name|width
init|=
name|attributes
operator|.
name|get
argument_list|(
name|EGL_WIDTH
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|EGLint
name|height
init|=
name|attributes
operator|.
name|get
argument_list|(
name|EGL_HEIGHT
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|width
operator|==
literal|0
operator|||
name|height
operator|==
literal|0
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|)
return|;
block|}
comment|// On Windows Store, we know the originating texture came from D3D11, so bypass this check
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ANGLE_ENABLE_WINDOWS_STORE
argument_list|)
specifier|const
name|Caps
modifier|&
name|caps
init|=
name|display
operator|->
name|getCaps
argument_list|()
decl_stmt|;
if|if
condition|(
name|textureFormat
operator|!=
name|EGL_NO_TEXTURE
operator|&&
operator|!
name|caps
operator|.
name|textureNPOT
operator|&&
operator|(
operator|!
name|gl
operator|::
name|isPow2
argument_list|(
name|width
argument_list|)
operator|||
operator|!
name|gl
operator|::
name|isPow2
argument_list|(
name|height
argument_list|)
operator|)
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_MATCH
argument_list|)
return|;
block|}
endif|#
directive|endif
block|}
return|return
name|Error
argument_list|(
name|EGL_SUCCESS
argument_list|)
return|;
block|}
DECL|function|ValidateCompatibleConfigs
name|Error
name|ValidateCompatibleConfigs
parameter_list|(
specifier|const
name|Display
modifier|*
name|display
parameter_list|,
specifier|const
name|Config
modifier|*
name|config1
parameter_list|,
specifier|const
name|Surface
modifier|*
name|surface
parameter_list|,
specifier|const
name|Config
modifier|*
name|config2
parameter_list|,
name|EGLint
name|surfaceType
parameter_list|)
block|{
if|if
condition|(
operator|!
name|surface
operator|->
name|flexibleSurfaceCompatibilityRequested
argument_list|()
condition|)
block|{
comment|// Config compatibility is defined in section 2.2 of the EGL 1.5 spec
name|bool
name|colorBufferCompat
init|=
name|config1
operator|->
name|colorBufferType
operator|==
name|config2
operator|->
name|colorBufferType
decl_stmt|;
if|if
condition|(
operator|!
name|colorBufferCompat
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_MATCH
argument_list|,
literal|"Color buffer types are not compatible."
argument_list|)
return|;
block|}
name|bool
name|colorCompat
init|=
name|config1
operator|->
name|redSize
operator|==
name|config2
operator|->
name|redSize
operator|&&
name|config1
operator|->
name|greenSize
operator|==
name|config2
operator|->
name|greenSize
operator|&&
name|config1
operator|->
name|blueSize
operator|==
name|config2
operator|->
name|blueSize
operator|&&
name|config1
operator|->
name|alphaSize
operator|==
name|config2
operator|->
name|alphaSize
operator|&&
name|config1
operator|->
name|luminanceSize
operator|==
name|config2
operator|->
name|luminanceSize
decl_stmt|;
if|if
condition|(
operator|!
name|colorCompat
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_MATCH
argument_list|,
literal|"Color buffer sizes are not compatible."
argument_list|)
return|;
block|}
name|bool
name|dsCompat
init|=
name|config1
operator|->
name|depthSize
operator|==
name|config2
operator|->
name|depthSize
operator|&&
name|config1
operator|->
name|stencilSize
operator|==
name|config2
operator|->
name|stencilSize
decl_stmt|;
if|if
condition|(
operator|!
name|dsCompat
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_MATCH
argument_list|,
literal|"Depth-stencil buffer types are not compatible."
argument_list|)
return|;
block|}
block|}
name|bool
name|surfaceTypeCompat
init|=
operator|(
name|config1
operator|->
name|surfaceType
operator|&
name|config2
operator|->
name|surfaceType
operator|&
name|surfaceType
operator|)
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|surfaceTypeCompat
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_MATCH
argument_list|,
literal|"Surface types are not compatible."
argument_list|)
return|;
block|}
return|return
name|Error
argument_list|(
name|EGL_SUCCESS
argument_list|)
return|;
block|}
DECL|function|ValidateCreateImageKHR
name|Error
name|ValidateCreateImageKHR
parameter_list|(
specifier|const
name|Display
modifier|*
name|display
parameter_list|,
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|EGLenum
name|target
parameter_list|,
name|EGLClientBuffer
name|buffer
parameter_list|,
specifier|const
name|AttributeMap
modifier|&
name|attributes
parameter_list|)
block|{
name|Error
name|error
init|=
name|ValidateContext
argument_list|(
name|display
argument_list|,
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
specifier|const
name|DisplayExtensions
modifier|&
name|displayExtensions
init|=
name|display
operator|->
name|getExtensions
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|displayExtensions
operator|.
name|imageBase
operator|&&
operator|!
name|displayExtensions
operator|.
name|image
condition|)
block|{
comment|// It is out of spec what happens when calling an extension function when the extension is
comment|// not available.
comment|// EGL_BAD_DISPLAY seems like a reasonable error.
return|return
name|Error
argument_list|(
name|EGL_BAD_DISPLAY
argument_list|,
literal|"EGL_KHR_image not supported."
argument_list|)
return|;
block|}
comment|// TODO(geofflang): Complete validation from EGL_KHR_image_base:
comment|// If the resource specified by<dpy>,<ctx>,<target>,<buffer> and<attrib_list> is itself an
comment|// EGLImage sibling, the error EGL_BAD_ACCESS is generated.
for|for
control|(
name|AttributeMap
operator|::
name|const_iterator
name|attributeIter
init|=
name|attributes
operator|.
name|begin
argument_list|()
init|;
name|attributeIter
operator|!=
name|attributes
operator|.
name|end
argument_list|()
condition|;
name|attributeIter
operator|++
control|)
block|{
name|EGLint
name|attribute
init|=
name|attributeIter
operator|->
name|first
decl_stmt|;
name|EGLint
name|value
init|=
name|attributeIter
operator|->
name|second
decl_stmt|;
switch|switch
condition|(
name|attribute
condition|)
block|{
case|case
name|EGL_IMAGE_PRESERVED_KHR
case|:
switch|switch
condition|(
name|value
condition|)
block|{
case|case
name|EGL_TRUE
case|:
case|case
name|EGL_FALSE
case|:
break|break;
default|default:
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|,
literal|"EGL_IMAGE_PRESERVED_KHR must be EGL_TRUE or EGL_FALSE."
argument_list|)
return|;
block|}
break|break;
case|case
name|EGL_GL_TEXTURE_LEVEL_KHR
case|:
if|if
condition|(
operator|!
name|displayExtensions
operator|.
name|glTexture2DImage
operator|&&
operator|!
name|displayExtensions
operator|.
name|glTextureCubemapImage
operator|&&
operator|!
name|displayExtensions
operator|.
name|glTexture3DImage
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|,
literal|"EGL_GL_TEXTURE_LEVEL_KHR cannot be used without "
literal|"KHR_gl_texture_*_image support."
argument_list|)
return|;
block|}
if|if
condition|(
name|value
operator|<
literal|0
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|,
literal|"EGL_GL_TEXTURE_LEVEL_KHR cannot be negative."
argument_list|)
return|;
block|}
break|break;
case|case
name|EGL_GL_TEXTURE_ZOFFSET_KHR
case|:
if|if
condition|(
operator|!
name|displayExtensions
operator|.
name|glTexture3DImage
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|,
literal|"EGL_GL_TEXTURE_ZOFFSET_KHR cannot be used without "
literal|"KHR_gl_texture_3D_image support."
argument_list|)
return|;
block|}
break|break;
default|default:
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|,
literal|"invalid attribute: 0x%X"
argument_list|,
name|attribute
argument_list|)
return|;
block|}
block|}
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|EGL_GL_TEXTURE_2D_KHR
case|:
block|{
if|if
condition|(
operator|!
name|displayExtensions
operator|.
name|glTexture2DImage
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|,
literal|"KHR_gl_texture_2D_image not supported."
argument_list|)
return|;
block|}
if|if
condition|(
name|buffer
operator|==
literal|0
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|,
literal|"buffer cannot reference a 2D texture with the name 0."
argument_list|)
return|;
block|}
specifier|const
name|gl
operator|::
name|Texture
modifier|*
name|texture
init|=
name|context
operator|->
name|getTexture
argument_list|(
name|egl_gl
operator|::
name|EGLClientBufferToGLObjectHandle
argument_list|(
name|buffer
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|texture
operator|==
literal|nullptr
operator|||
name|texture
operator|->
name|getTarget
argument_list|()
operator|!=
name|GL_TEXTURE_2D
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|,
literal|"target is not a 2D texture."
argument_list|)
return|;
block|}
if|if
condition|(
name|texture
operator|->
name|getBoundSurface
argument_list|()
operator|!=
literal|nullptr
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_ACCESS
argument_list|,
literal|"texture has a surface bound to it."
argument_list|)
return|;
block|}
name|EGLint
name|level
init|=
name|attributes
operator|.
name|get
argument_list|(
name|EGL_GL_TEXTURE_LEVEL_KHR
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|texture
operator|->
name|getWidth
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|level
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|texture
operator|->
name|getHeight
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|level
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|,
literal|"target 2D texture does not have a valid size at specified level."
argument_list|)
return|;
block|}
if|if
condition|(
name|level
operator|>
literal|0
operator|&&
operator|(
operator|!
name|texture
operator|->
name|isMipmapComplete
argument_list|()
operator|||
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|level
argument_list|)
operator|>=
name|texture
operator|->
name|getMipCompleteLevels
argument_list|()
operator|)
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|,
literal|"texture must be complete if level is non-zero."
argument_list|)
return|;
block|}
if|if
condition|(
name|level
operator|==
literal|0
operator|&&
operator|!
name|texture
operator|->
name|isMipmapComplete
argument_list|()
operator|&&
name|TextureHasNonZeroMipLevelsSpecified
argument_list|(
name|context
argument_list|,
name|texture
argument_list|)
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|,
literal|"if level is zero and the texture is incomplete, it must have no mip "
literal|"levels specified except zero."
argument_list|)
return|;
block|}
block|}
break|break;
case|case
name|EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_X_KHR
case|:
case|case
name|EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X_KHR
case|:
case|case
name|EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y_KHR
case|:
case|case
name|EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_KHR
case|:
case|case
name|EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z_KHR
case|:
case|case
name|EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_KHR
case|:
block|{
if|if
condition|(
operator|!
name|displayExtensions
operator|.
name|glTextureCubemapImage
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|,
literal|"KHR_gl_texture_cubemap_image not supported."
argument_list|)
return|;
block|}
if|if
condition|(
name|buffer
operator|==
literal|0
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|,
literal|"buffer cannot reference a cubemap texture with the name 0."
argument_list|)
return|;
block|}
specifier|const
name|gl
operator|::
name|Texture
modifier|*
name|texture
init|=
name|context
operator|->
name|getTexture
argument_list|(
name|egl_gl
operator|::
name|EGLClientBufferToGLObjectHandle
argument_list|(
name|buffer
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|texture
operator|==
literal|nullptr
operator|||
name|texture
operator|->
name|getTarget
argument_list|()
operator|!=
name|GL_TEXTURE_CUBE_MAP
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|,
literal|"target is not a cubemap texture."
argument_list|)
return|;
block|}
if|if
condition|(
name|texture
operator|->
name|getBoundSurface
argument_list|()
operator|!=
literal|nullptr
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_ACCESS
argument_list|,
literal|"texture has a surface bound to it."
argument_list|)
return|;
block|}
name|EGLint
name|level
init|=
name|attributes
operator|.
name|get
argument_list|(
name|EGL_GL_TEXTURE_LEVEL_KHR
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|GLenum
name|cubeMapFace
init|=
name|egl_gl
operator|::
name|EGLCubeMapTargetToGLCubeMapTarget
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|texture
operator|->
name|getWidth
argument_list|(
name|cubeMapFace
argument_list|,
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|level
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|texture
operator|->
name|getHeight
argument_list|(
name|cubeMapFace
argument_list|,
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|level
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|,
literal|"target cubemap texture does not have a valid size at specified level "
literal|"and face."
argument_list|)
return|;
block|}
if|if
condition|(
name|level
operator|>
literal|0
operator|&&
operator|(
operator|!
name|texture
operator|->
name|isMipmapComplete
argument_list|()
operator|||
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|level
argument_list|)
operator|>=
name|texture
operator|->
name|getMipCompleteLevels
argument_list|()
operator|)
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|,
literal|"texture must be complete if level is non-zero."
argument_list|)
return|;
block|}
if|if
condition|(
name|level
operator|==
literal|0
operator|&&
operator|!
name|texture
operator|->
name|isMipmapComplete
argument_list|()
operator|&&
name|TextureHasNonZeroMipLevelsSpecified
argument_list|(
name|context
argument_list|,
name|texture
argument_list|)
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|,
literal|"if level is zero and the texture is incomplete, it must have no mip "
literal|"levels specified except zero."
argument_list|)
return|;
block|}
if|if
condition|(
name|level
operator|==
literal|0
operator|&&
operator|!
name|texture
operator|->
name|isMipmapComplete
argument_list|()
operator|&&
name|CubeTextureHasUnspecifiedLevel0Face
argument_list|(
name|texture
argument_list|)
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|,
literal|"if level is zero and the texture is incomplete, it must have all of "
literal|"its faces specified at level zero."
argument_list|)
return|;
block|}
block|}
break|break;
case|case
name|EGL_GL_TEXTURE_3D_KHR
case|:
block|{
if|if
condition|(
operator|!
name|displayExtensions
operator|.
name|glTexture3DImage
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|,
literal|"KHR_gl_texture_3D_image not supported."
argument_list|)
return|;
block|}
if|if
condition|(
name|buffer
operator|==
literal|0
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|,
literal|"buffer cannot reference a 3D texture with the name 0."
argument_list|)
return|;
block|}
specifier|const
name|gl
operator|::
name|Texture
modifier|*
name|texture
init|=
name|context
operator|->
name|getTexture
argument_list|(
name|egl_gl
operator|::
name|EGLClientBufferToGLObjectHandle
argument_list|(
name|buffer
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|texture
operator|==
literal|nullptr
operator|||
name|texture
operator|->
name|getTarget
argument_list|()
operator|!=
name|GL_TEXTURE_3D
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|,
literal|"target is not a 3D texture."
argument_list|)
return|;
block|}
if|if
condition|(
name|texture
operator|->
name|getBoundSurface
argument_list|()
operator|!=
literal|nullptr
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_ACCESS
argument_list|,
literal|"texture has a surface bound to it."
argument_list|)
return|;
block|}
name|EGLint
name|level
init|=
name|attributes
operator|.
name|get
argument_list|(
name|EGL_GL_TEXTURE_LEVEL_KHR
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|EGLint
name|zOffset
init|=
name|attributes
operator|.
name|get
argument_list|(
name|EGL_GL_TEXTURE_ZOFFSET_KHR
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|texture
operator|->
name|getWidth
argument_list|(
name|GL_TEXTURE_3D
argument_list|,
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|level
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|texture
operator|->
name|getHeight
argument_list|(
name|GL_TEXTURE_3D
argument_list|,
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|level
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|texture
operator|->
name|getDepth
argument_list|(
name|GL_TEXTURE_3D
argument_list|,
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|level
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|,
literal|"target 3D texture does not have a valid size at specified level."
argument_list|)
return|;
block|}
if|if
condition|(
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|zOffset
argument_list|)
operator|>=
name|texture
operator|->
name|getDepth
argument_list|(
name|GL_TEXTURE_3D
argument_list|,
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|level
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|,
literal|"target 3D texture does not have enough layers for the specified Z "
literal|"offset at the specified level."
argument_list|)
return|;
block|}
if|if
condition|(
name|level
operator|>
literal|0
operator|&&
operator|(
operator|!
name|texture
operator|->
name|isMipmapComplete
argument_list|()
operator|||
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|level
argument_list|)
operator|>=
name|texture
operator|->
name|getMipCompleteLevels
argument_list|()
operator|)
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|,
literal|"texture must be complete if level is non-zero."
argument_list|)
return|;
block|}
if|if
condition|(
name|level
operator|==
literal|0
operator|&&
operator|!
name|texture
operator|->
name|isMipmapComplete
argument_list|()
operator|&&
name|TextureHasNonZeroMipLevelsSpecified
argument_list|(
name|context
argument_list|,
name|texture
argument_list|)
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|,
literal|"if level is zero and the texture is incomplete, it must have no mip "
literal|"levels specified except zero."
argument_list|)
return|;
block|}
block|}
break|break;
case|case
name|EGL_GL_RENDERBUFFER_KHR
case|:
block|{
if|if
condition|(
operator|!
name|displayExtensions
operator|.
name|glRenderbufferImage
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|,
literal|"KHR_gl_renderbuffer_image not supported."
argument_list|)
return|;
block|}
if|if
condition|(
name|attributes
operator|.
name|contains
argument_list|(
name|EGL_GL_TEXTURE_LEVEL_KHR
argument_list|)
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|,
literal|"EGL_GL_TEXTURE_LEVEL_KHR cannot be used in conjunction with a "
literal|"renderbuffer target."
argument_list|)
return|;
block|}
if|if
condition|(
name|buffer
operator|==
literal|0
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|,
literal|"buffer cannot reference a renderbuffer with the name 0."
argument_list|)
return|;
block|}
specifier|const
name|gl
operator|::
name|Renderbuffer
modifier|*
name|renderbuffer
init|=
name|context
operator|->
name|getRenderbuffer
argument_list|(
name|egl_gl
operator|::
name|EGLClientBufferToGLObjectHandle
argument_list|(
name|buffer
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|renderbuffer
operator|==
literal|nullptr
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|,
literal|"target is not a renderbuffer."
argument_list|)
return|;
block|}
if|if
condition|(
name|renderbuffer
operator|->
name|getSamples
argument_list|()
operator|>
literal|0
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|,
literal|"target renderbuffer cannot be multisampled."
argument_list|)
return|;
block|}
block|}
break|break;
default|default:
return|return
name|Error
argument_list|(
name|EGL_BAD_PARAMETER
argument_list|,
literal|"invalid target: 0x%X"
argument_list|,
name|target
argument_list|)
return|;
block|}
return|return
name|Error
argument_list|(
name|EGL_SUCCESS
argument_list|)
return|;
block|}
DECL|function|ValidateDestroyImageKHR
name|Error
name|ValidateDestroyImageKHR
parameter_list|(
specifier|const
name|Display
modifier|*
name|display
parameter_list|,
specifier|const
name|Image
modifier|*
name|image
parameter_list|)
block|{
name|Error
name|error
init|=
name|ValidateImage
argument_list|(
name|display
argument_list|,
name|image
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
operator|!
name|display
operator|->
name|getExtensions
argument_list|()
operator|.
name|imageBase
operator|&&
operator|!
name|display
operator|->
name|getExtensions
argument_list|()
operator|.
name|image
condition|)
block|{
comment|// It is out of spec what happens when calling an extension function when the extension is
comment|// not available.
comment|// EGL_BAD_DISPLAY seems like a reasonable error.
return|return
name|Error
argument_list|(
name|EGL_BAD_DISPLAY
argument_list|)
return|;
block|}
return|return
name|Error
argument_list|(
name|EGL_SUCCESS
argument_list|)
return|;
block|}
DECL|function|ValidateCreateDeviceANGLE
name|Error
name|ValidateCreateDeviceANGLE
parameter_list|(
name|EGLint
name|device_type
parameter_list|,
name|void
modifier|*
name|native_device
parameter_list|,
specifier|const
name|EGLAttrib
modifier|*
name|attrib_list
parameter_list|)
block|{
specifier|const
name|ClientExtensions
modifier|&
name|clientExtensions
init|=
name|Display
operator|::
name|getClientExtensions
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|clientExtensions
operator|.
name|deviceCreation
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_ACCESS
argument_list|,
literal|"Device creation extension not active"
argument_list|)
return|;
block|}
if|if
condition|(
name|attrib_list
operator|!=
literal|nullptr
operator|&&
name|attrib_list
index|[
literal|0
index|]
operator|!=
name|EGL_NONE
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|,
literal|"Invalid attrib_list parameter"
argument_list|)
return|;
block|}
switch|switch
condition|(
name|device_type
condition|)
block|{
case|case
name|EGL_D3D11_DEVICE_ANGLE
case|:
if|if
condition|(
operator|!
name|clientExtensions
operator|.
name|deviceCreationD3D11
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|,
literal|"D3D11 device creation extension not active"
argument_list|)
return|;
block|}
break|break;
default|default:
return|return
name|Error
argument_list|(
name|EGL_BAD_ATTRIBUTE
argument_list|,
literal|"Invalid device_type parameter"
argument_list|)
return|;
block|}
return|return
name|Error
argument_list|(
name|EGL_SUCCESS
argument_list|)
return|;
block|}
DECL|function|ValidateReleaseDeviceANGLE
name|Error
name|ValidateReleaseDeviceANGLE
parameter_list|(
name|Device
modifier|*
name|device
parameter_list|)
block|{
specifier|const
name|ClientExtensions
modifier|&
name|clientExtensions
init|=
name|Display
operator|::
name|getClientExtensions
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|clientExtensions
operator|.
name|deviceCreation
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_ACCESS
argument_list|,
literal|"Device creation extension not active"
argument_list|)
return|;
block|}
if|if
condition|(
name|device
operator|==
name|EGL_NO_DEVICE_EXT
operator|||
operator|!
name|Device
operator|::
name|IsValidDevice
argument_list|(
name|device
argument_list|)
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_DEVICE_EXT
argument_list|,
literal|"Invalid device parameter"
argument_list|)
return|;
block|}
name|Display
modifier|*
name|owningDisplay
init|=
name|device
operator|->
name|getOwningDisplay
argument_list|()
decl_stmt|;
if|if
condition|(
name|owningDisplay
operator|!=
literal|nullptr
condition|)
block|{
return|return
name|Error
argument_list|(
name|EGL_BAD_DEVICE_EXT
argument_list|,
literal|"Device must have been created using eglCreateDevice"
argument_list|)
return|;
block|}
return|return
name|Error
argument_list|(
name|EGL_SUCCESS
argument_list|)
return|;
block|}
block|}
end_namespace
end_unit
