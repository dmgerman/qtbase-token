begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// State.cpp: Implements the State class, encapsulating raw GL state.
end_comment
begin_include
include|#
directive|include
file|"libANGLE/State.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Context.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Caps.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Framebuffer.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/FramebufferAttachment.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Query.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/VertexArray.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/formatutils.h"
end_include
begin_namespace
DECL|namespace|gl
namespace|namespace
name|gl
block|{
DECL|function|State
name|State
operator|::
name|State
parameter_list|()
block|{
name|mMaxDrawBuffers
operator|=
literal|0
expr_stmt|;
name|mMaxCombinedTextureImageUnits
operator|=
literal|0
expr_stmt|;
block|}
DECL|function|~State
name|State
operator|::
name|~
name|State
parameter_list|()
block|{
name|reset
argument_list|()
expr_stmt|;
block|}
DECL|function|initialize
name|void
name|State
operator|::
name|initialize
parameter_list|(
specifier|const
name|Caps
modifier|&
name|caps
parameter_list|,
name|GLuint
name|clientVersion
parameter_list|)
block|{
name|mMaxDrawBuffers
operator|=
name|caps
operator|.
name|maxDrawBuffers
expr_stmt|;
name|mMaxCombinedTextureImageUnits
operator|=
name|caps
operator|.
name|maxCombinedTextureImageUnits
expr_stmt|;
name|setColorClearValue
argument_list|(
literal|0.0f
argument_list|,
literal|0.0f
argument_list|,
literal|0.0f
argument_list|,
literal|0.0f
argument_list|)
expr_stmt|;
name|mDepthClearValue
operator|=
literal|1.0f
expr_stmt|;
name|mStencilClearValue
operator|=
literal|0
expr_stmt|;
name|mRasterizer
operator|.
name|rasterizerDiscard
operator|=
literal|false
expr_stmt|;
name|mRasterizer
operator|.
name|cullFace
operator|=
literal|false
expr_stmt|;
name|mRasterizer
operator|.
name|cullMode
operator|=
name|GL_BACK
expr_stmt|;
name|mRasterizer
operator|.
name|frontFace
operator|=
name|GL_CCW
expr_stmt|;
name|mRasterizer
operator|.
name|polygonOffsetFill
operator|=
literal|false
expr_stmt|;
name|mRasterizer
operator|.
name|polygonOffsetFactor
operator|=
literal|0.0f
expr_stmt|;
name|mRasterizer
operator|.
name|polygonOffsetUnits
operator|=
literal|0.0f
expr_stmt|;
name|mRasterizer
operator|.
name|pointDrawMode
operator|=
literal|false
expr_stmt|;
name|mRasterizer
operator|.
name|multiSample
operator|=
literal|false
expr_stmt|;
name|mScissorTest
operator|=
literal|false
expr_stmt|;
name|mScissor
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|mScissor
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|mScissor
operator|.
name|width
operator|=
literal|0
expr_stmt|;
name|mScissor
operator|.
name|height
operator|=
literal|0
expr_stmt|;
name|mBlend
operator|.
name|blend
operator|=
literal|false
expr_stmt|;
name|mBlend
operator|.
name|sourceBlendRGB
operator|=
name|GL_ONE
expr_stmt|;
name|mBlend
operator|.
name|sourceBlendAlpha
operator|=
name|GL_ONE
expr_stmt|;
name|mBlend
operator|.
name|destBlendRGB
operator|=
name|GL_ZERO
expr_stmt|;
name|mBlend
operator|.
name|destBlendAlpha
operator|=
name|GL_ZERO
expr_stmt|;
name|mBlend
operator|.
name|blendEquationRGB
operator|=
name|GL_FUNC_ADD
expr_stmt|;
name|mBlend
operator|.
name|blendEquationAlpha
operator|=
name|GL_FUNC_ADD
expr_stmt|;
name|mBlend
operator|.
name|sampleAlphaToCoverage
operator|=
literal|false
expr_stmt|;
name|mBlend
operator|.
name|dither
operator|=
literal|true
expr_stmt|;
name|mBlendColor
operator|.
name|red
operator|=
literal|0
expr_stmt|;
name|mBlendColor
operator|.
name|green
operator|=
literal|0
expr_stmt|;
name|mBlendColor
operator|.
name|blue
operator|=
literal|0
expr_stmt|;
name|mBlendColor
operator|.
name|alpha
operator|=
literal|0
expr_stmt|;
name|mDepthStencil
operator|.
name|depthTest
operator|=
literal|false
expr_stmt|;
name|mDepthStencil
operator|.
name|depthFunc
operator|=
name|GL_LESS
expr_stmt|;
name|mDepthStencil
operator|.
name|depthMask
operator|=
literal|true
expr_stmt|;
name|mDepthStencil
operator|.
name|stencilTest
operator|=
literal|false
expr_stmt|;
name|mDepthStencil
operator|.
name|stencilFunc
operator|=
name|GL_ALWAYS
expr_stmt|;
name|mDepthStencil
operator|.
name|stencilMask
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mDepthStencil
operator|.
name|stencilWritemask
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mDepthStencil
operator|.
name|stencilBackFunc
operator|=
name|GL_ALWAYS
expr_stmt|;
name|mDepthStencil
operator|.
name|stencilBackMask
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mDepthStencil
operator|.
name|stencilBackWritemask
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mDepthStencil
operator|.
name|stencilFail
operator|=
name|GL_KEEP
expr_stmt|;
name|mDepthStencil
operator|.
name|stencilPassDepthFail
operator|=
name|GL_KEEP
expr_stmt|;
name|mDepthStencil
operator|.
name|stencilPassDepthPass
operator|=
name|GL_KEEP
expr_stmt|;
name|mDepthStencil
operator|.
name|stencilBackFail
operator|=
name|GL_KEEP
expr_stmt|;
name|mDepthStencil
operator|.
name|stencilBackPassDepthFail
operator|=
name|GL_KEEP
expr_stmt|;
name|mDepthStencil
operator|.
name|stencilBackPassDepthPass
operator|=
name|GL_KEEP
expr_stmt|;
name|mStencilRef
operator|=
literal|0
expr_stmt|;
name|mStencilBackRef
operator|=
literal|0
expr_stmt|;
name|mSampleCoverage
operator|=
literal|false
expr_stmt|;
name|mSampleCoverageValue
operator|=
literal|1.0f
expr_stmt|;
name|mSampleCoverageInvert
operator|=
literal|false
expr_stmt|;
name|mGenerateMipmapHint
operator|=
name|GL_DONT_CARE
expr_stmt|;
name|mFragmentShaderDerivativeHint
operator|=
name|GL_DONT_CARE
expr_stmt|;
name|mLineWidth
operator|=
literal|1.0f
expr_stmt|;
name|mViewport
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|mViewport
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|mViewport
operator|.
name|width
operator|=
literal|0
expr_stmt|;
name|mViewport
operator|.
name|height
operator|=
literal|0
expr_stmt|;
name|mNearZ
operator|=
literal|0.0f
expr_stmt|;
name|mFarZ
operator|=
literal|1.0f
expr_stmt|;
name|mBlend
operator|.
name|colorMaskRed
operator|=
literal|true
expr_stmt|;
name|mBlend
operator|.
name|colorMaskGreen
operator|=
literal|true
expr_stmt|;
name|mBlend
operator|.
name|colorMaskBlue
operator|=
literal|true
expr_stmt|;
name|mBlend
operator|.
name|colorMaskAlpha
operator|=
literal|true
expr_stmt|;
name|mActiveSampler
operator|=
literal|0
expr_stmt|;
specifier|const
name|GLfloat
name|defaultFloatValues
index|[]
init|=
block|{
literal|0.0f
block|,
literal|0.0f
block|,
literal|0.0f
block|,
literal|1.0f
block|}
decl_stmt|;
name|mVertexAttribCurrentValues
operator|.
name|resize
argument_list|(
name|caps
operator|.
name|maxVertexAttributes
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|attribIndex
init|=
literal|0
init|;
name|attribIndex
operator|<
name|mVertexAttribCurrentValues
operator|.
name|size
argument_list|()
condition|;
operator|++
name|attribIndex
control|)
block|{
name|mVertexAttribCurrentValues
index|[
name|attribIndex
index|]
operator|.
name|setFloatValues
argument_list|(
name|defaultFloatValues
argument_list|)
expr_stmt|;
block|}
name|mUniformBuffers
operator|.
name|resize
argument_list|(
name|caps
operator|.
name|maxCombinedUniformBlocks
argument_list|)
expr_stmt|;
name|mTransformFeedbackBuffers
operator|.
name|resize
argument_list|(
name|caps
operator|.
name|maxTransformFeedbackSeparateAttributes
argument_list|)
expr_stmt|;
name|mSamplerTextures
index|[
name|GL_TEXTURE_2D
index|]
operator|.
name|resize
argument_list|(
name|caps
operator|.
name|maxCombinedTextureImageUnits
argument_list|)
expr_stmt|;
name|mSamplerTextures
index|[
name|GL_TEXTURE_CUBE_MAP
index|]
operator|.
name|resize
argument_list|(
name|caps
operator|.
name|maxCombinedTextureImageUnits
argument_list|)
expr_stmt|;
if|if
condition|(
name|clientVersion
operator|>=
literal|3
condition|)
block|{
comment|// TODO: These could also be enabled via extension
name|mSamplerTextures
index|[
name|GL_TEXTURE_2D_ARRAY
index|]
operator|.
name|resize
argument_list|(
name|caps
operator|.
name|maxCombinedTextureImageUnits
argument_list|)
expr_stmt|;
name|mSamplerTextures
index|[
name|GL_TEXTURE_3D
index|]
operator|.
name|resize
argument_list|(
name|caps
operator|.
name|maxCombinedTextureImageUnits
argument_list|)
expr_stmt|;
block|}
name|mSamplers
operator|.
name|resize
argument_list|(
name|caps
operator|.
name|maxCombinedTextureImageUnits
argument_list|)
expr_stmt|;
name|mActiveQueries
index|[
name|GL_ANY_SAMPLES_PASSED
index|]
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mActiveQueries
index|[
name|GL_ANY_SAMPLES_PASSED_CONSERVATIVE
index|]
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mActiveQueries
index|[
name|GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN
index|]
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mProgram
operator|=
name|NULL
expr_stmt|;
name|mReadFramebuffer
operator|=
name|NULL
expr_stmt|;
name|mDrawFramebuffer
operator|=
name|NULL
expr_stmt|;
name|mPrimitiveRestart
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|reset
name|void
name|State
operator|::
name|reset
parameter_list|()
block|{
for|for
control|(
name|TextureBindingMap
operator|::
name|iterator
name|bindingVec
init|=
name|mSamplerTextures
operator|.
name|begin
argument_list|()
init|;
name|bindingVec
operator|!=
name|mSamplerTextures
operator|.
name|end
argument_list|()
condition|;
name|bindingVec
operator|++
control|)
block|{
name|TextureBindingVector
modifier|&
name|textureVector
init|=
name|bindingVec
operator|->
name|second
decl_stmt|;
for|for
control|(
name|size_t
name|textureIdx
init|=
literal|0
init|;
name|textureIdx
operator|<
name|textureVector
operator|.
name|size
argument_list|()
condition|;
name|textureIdx
operator|++
control|)
block|{
name|textureVector
index|[
name|textureIdx
index|]
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|size_t
name|samplerIdx
init|=
literal|0
init|;
name|samplerIdx
operator|<
name|mSamplers
operator|.
name|size
argument_list|()
condition|;
name|samplerIdx
operator|++
control|)
block|{
name|mSamplers
index|[
name|samplerIdx
index|]
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
name|mArrayBuffer
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mRenderbuffer
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mProgram
condition|)
block|{
name|mProgram
operator|->
name|release
argument_list|()
expr_stmt|;
block|}
name|mProgram
operator|=
name|NULL
expr_stmt|;
name|mTransformFeedback
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|State
operator|::
name|ActiveQueryMap
operator|::
name|iterator
name|i
init|=
name|mActiveQueries
operator|.
name|begin
argument_list|()
init|;
name|i
operator|!=
name|mActiveQueries
operator|.
name|end
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|i
operator|->
name|second
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
name|mGenericUniformBuffer
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mGenericTransformFeedbackBuffer
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|BufferVector
operator|::
name|iterator
name|bufItr
init|=
name|mUniformBuffers
operator|.
name|begin
argument_list|()
init|;
name|bufItr
operator|!=
name|mUniformBuffers
operator|.
name|end
argument_list|()
condition|;
operator|++
name|bufItr
control|)
block|{
name|bufItr
operator|->
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|BufferVector
operator|::
name|iterator
name|bufItr
init|=
name|mTransformFeedbackBuffers
operator|.
name|begin
argument_list|()
init|;
name|bufItr
operator|!=
name|mTransformFeedbackBuffers
operator|.
name|end
argument_list|()
condition|;
operator|++
name|bufItr
control|)
block|{
name|bufItr
operator|->
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
name|mCopyReadBuffer
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mCopyWriteBuffer
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mPack
operator|.
name|pixelBuffer
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mUnpack
operator|.
name|pixelBuffer
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mProgram
operator|=
name|NULL
expr_stmt|;
block|}
DECL|function|getRasterizerState
specifier|const
name|RasterizerState
modifier|&
name|State
operator|::
name|getRasterizerState
parameter_list|()
specifier|const
block|{
return|return
name|mRasterizer
return|;
block|}
DECL|function|getBlendState
specifier|const
name|BlendState
modifier|&
name|State
operator|::
name|getBlendState
parameter_list|()
specifier|const
block|{
return|return
name|mBlend
return|;
block|}
DECL|function|getDepthStencilState
specifier|const
name|DepthStencilState
modifier|&
name|State
operator|::
name|getDepthStencilState
parameter_list|()
specifier|const
block|{
return|return
name|mDepthStencil
return|;
block|}
DECL|function|setColorClearValue
name|void
name|State
operator|::
name|setColorClearValue
parameter_list|(
name|float
name|red
parameter_list|,
name|float
name|green
parameter_list|,
name|float
name|blue
parameter_list|,
name|float
name|alpha
parameter_list|)
block|{
name|mColorClearValue
operator|.
name|red
operator|=
name|red
expr_stmt|;
name|mColorClearValue
operator|.
name|green
operator|=
name|green
expr_stmt|;
name|mColorClearValue
operator|.
name|blue
operator|=
name|blue
expr_stmt|;
name|mColorClearValue
operator|.
name|alpha
operator|=
name|alpha
expr_stmt|;
block|}
DECL|function|setDepthClearValue
name|void
name|State
operator|::
name|setDepthClearValue
parameter_list|(
name|float
name|depth
parameter_list|)
block|{
name|mDepthClearValue
operator|=
name|depth
expr_stmt|;
block|}
DECL|function|setStencilClearValue
name|void
name|State
operator|::
name|setStencilClearValue
parameter_list|(
name|int
name|stencil
parameter_list|)
block|{
name|mStencilClearValue
operator|=
name|stencil
expr_stmt|;
block|}
DECL|function|setColorMask
name|void
name|State
operator|::
name|setColorMask
parameter_list|(
name|bool
name|red
parameter_list|,
name|bool
name|green
parameter_list|,
name|bool
name|blue
parameter_list|,
name|bool
name|alpha
parameter_list|)
block|{
name|mBlend
operator|.
name|colorMaskRed
operator|=
name|red
expr_stmt|;
name|mBlend
operator|.
name|colorMaskGreen
operator|=
name|green
expr_stmt|;
name|mBlend
operator|.
name|colorMaskBlue
operator|=
name|blue
expr_stmt|;
name|mBlend
operator|.
name|colorMaskAlpha
operator|=
name|alpha
expr_stmt|;
block|}
DECL|function|setDepthMask
name|void
name|State
operator|::
name|setDepthMask
parameter_list|(
name|bool
name|mask
parameter_list|)
block|{
name|mDepthStencil
operator|.
name|depthMask
operator|=
name|mask
expr_stmt|;
block|}
DECL|function|isRasterizerDiscardEnabled
name|bool
name|State
operator|::
name|isRasterizerDiscardEnabled
parameter_list|()
specifier|const
block|{
return|return
name|mRasterizer
operator|.
name|rasterizerDiscard
return|;
block|}
DECL|function|setRasterizerDiscard
name|void
name|State
operator|::
name|setRasterizerDiscard
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|mRasterizer
operator|.
name|rasterizerDiscard
operator|=
name|enabled
expr_stmt|;
block|}
DECL|function|isCullFaceEnabled
name|bool
name|State
operator|::
name|isCullFaceEnabled
parameter_list|()
specifier|const
block|{
return|return
name|mRasterizer
operator|.
name|cullFace
return|;
block|}
DECL|function|setCullFace
name|void
name|State
operator|::
name|setCullFace
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|mRasterizer
operator|.
name|cullFace
operator|=
name|enabled
expr_stmt|;
block|}
DECL|function|setCullMode
name|void
name|State
operator|::
name|setCullMode
parameter_list|(
name|GLenum
name|mode
parameter_list|)
block|{
name|mRasterizer
operator|.
name|cullMode
operator|=
name|mode
expr_stmt|;
block|}
DECL|function|setFrontFace
name|void
name|State
operator|::
name|setFrontFace
parameter_list|(
name|GLenum
name|front
parameter_list|)
block|{
name|mRasterizer
operator|.
name|frontFace
operator|=
name|front
expr_stmt|;
block|}
DECL|function|isDepthTestEnabled
name|bool
name|State
operator|::
name|isDepthTestEnabled
parameter_list|()
specifier|const
block|{
return|return
name|mDepthStencil
operator|.
name|depthTest
return|;
block|}
DECL|function|setDepthTest
name|void
name|State
operator|::
name|setDepthTest
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|mDepthStencil
operator|.
name|depthTest
operator|=
name|enabled
expr_stmt|;
block|}
DECL|function|setDepthFunc
name|void
name|State
operator|::
name|setDepthFunc
parameter_list|(
name|GLenum
name|depthFunc
parameter_list|)
block|{
name|mDepthStencil
operator|.
name|depthFunc
operator|=
name|depthFunc
expr_stmt|;
block|}
DECL|function|setDepthRange
name|void
name|State
operator|::
name|setDepthRange
parameter_list|(
name|float
name|zNear
parameter_list|,
name|float
name|zFar
parameter_list|)
block|{
name|mNearZ
operator|=
name|zNear
expr_stmt|;
name|mFarZ
operator|=
name|zFar
expr_stmt|;
block|}
DECL|function|getDepthRange
name|void
name|State
operator|::
name|getDepthRange
parameter_list|(
name|float
modifier|*
name|zNear
parameter_list|,
name|float
modifier|*
name|zFar
parameter_list|)
specifier|const
block|{
operator|*
name|zNear
operator|=
name|mNearZ
expr_stmt|;
operator|*
name|zFar
operator|=
name|mFarZ
expr_stmt|;
block|}
DECL|function|isBlendEnabled
name|bool
name|State
operator|::
name|isBlendEnabled
parameter_list|()
specifier|const
block|{
return|return
name|mBlend
operator|.
name|blend
return|;
block|}
DECL|function|setBlend
name|void
name|State
operator|::
name|setBlend
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|mBlend
operator|.
name|blend
operator|=
name|enabled
expr_stmt|;
block|}
DECL|function|setBlendFactors
name|void
name|State
operator|::
name|setBlendFactors
parameter_list|(
name|GLenum
name|sourceRGB
parameter_list|,
name|GLenum
name|destRGB
parameter_list|,
name|GLenum
name|sourceAlpha
parameter_list|,
name|GLenum
name|destAlpha
parameter_list|)
block|{
name|mBlend
operator|.
name|sourceBlendRGB
operator|=
name|sourceRGB
expr_stmt|;
name|mBlend
operator|.
name|destBlendRGB
operator|=
name|destRGB
expr_stmt|;
name|mBlend
operator|.
name|sourceBlendAlpha
operator|=
name|sourceAlpha
expr_stmt|;
name|mBlend
operator|.
name|destBlendAlpha
operator|=
name|destAlpha
expr_stmt|;
block|}
DECL|function|setBlendColor
name|void
name|State
operator|::
name|setBlendColor
parameter_list|(
name|float
name|red
parameter_list|,
name|float
name|green
parameter_list|,
name|float
name|blue
parameter_list|,
name|float
name|alpha
parameter_list|)
block|{
name|mBlendColor
operator|.
name|red
operator|=
name|red
expr_stmt|;
name|mBlendColor
operator|.
name|green
operator|=
name|green
expr_stmt|;
name|mBlendColor
operator|.
name|blue
operator|=
name|blue
expr_stmt|;
name|mBlendColor
operator|.
name|alpha
operator|=
name|alpha
expr_stmt|;
block|}
DECL|function|setBlendEquation
name|void
name|State
operator|::
name|setBlendEquation
parameter_list|(
name|GLenum
name|rgbEquation
parameter_list|,
name|GLenum
name|alphaEquation
parameter_list|)
block|{
name|mBlend
operator|.
name|blendEquationRGB
operator|=
name|rgbEquation
expr_stmt|;
name|mBlend
operator|.
name|blendEquationAlpha
operator|=
name|alphaEquation
expr_stmt|;
block|}
DECL|function|getBlendColor
specifier|const
name|ColorF
modifier|&
name|State
operator|::
name|getBlendColor
parameter_list|()
specifier|const
block|{
return|return
name|mBlendColor
return|;
block|}
DECL|function|isStencilTestEnabled
name|bool
name|State
operator|::
name|isStencilTestEnabled
parameter_list|()
specifier|const
block|{
return|return
name|mDepthStencil
operator|.
name|stencilTest
return|;
block|}
DECL|function|setStencilTest
name|void
name|State
operator|::
name|setStencilTest
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|mDepthStencil
operator|.
name|stencilTest
operator|=
name|enabled
expr_stmt|;
block|}
DECL|function|setStencilParams
name|void
name|State
operator|::
name|setStencilParams
parameter_list|(
name|GLenum
name|stencilFunc
parameter_list|,
name|GLint
name|stencilRef
parameter_list|,
name|GLuint
name|stencilMask
parameter_list|)
block|{
name|mDepthStencil
operator|.
name|stencilFunc
operator|=
name|stencilFunc
expr_stmt|;
name|mStencilRef
operator|=
operator|(
name|stencilRef
operator|>
literal|0
operator|)
condition|?
name|stencilRef
else|:
literal|0
expr_stmt|;
name|mDepthStencil
operator|.
name|stencilMask
operator|=
name|stencilMask
expr_stmt|;
block|}
DECL|function|setStencilBackParams
name|void
name|State
operator|::
name|setStencilBackParams
parameter_list|(
name|GLenum
name|stencilBackFunc
parameter_list|,
name|GLint
name|stencilBackRef
parameter_list|,
name|GLuint
name|stencilBackMask
parameter_list|)
block|{
name|mDepthStencil
operator|.
name|stencilBackFunc
operator|=
name|stencilBackFunc
expr_stmt|;
name|mStencilBackRef
operator|=
operator|(
name|stencilBackRef
operator|>
literal|0
operator|)
condition|?
name|stencilBackRef
else|:
literal|0
expr_stmt|;
name|mDepthStencil
operator|.
name|stencilBackMask
operator|=
name|stencilBackMask
expr_stmt|;
block|}
DECL|function|setStencilWritemask
name|void
name|State
operator|::
name|setStencilWritemask
parameter_list|(
name|GLuint
name|stencilWritemask
parameter_list|)
block|{
name|mDepthStencil
operator|.
name|stencilWritemask
operator|=
name|stencilWritemask
expr_stmt|;
block|}
DECL|function|setStencilBackWritemask
name|void
name|State
operator|::
name|setStencilBackWritemask
parameter_list|(
name|GLuint
name|stencilBackWritemask
parameter_list|)
block|{
name|mDepthStencil
operator|.
name|stencilBackWritemask
operator|=
name|stencilBackWritemask
expr_stmt|;
block|}
DECL|function|setStencilOperations
name|void
name|State
operator|::
name|setStencilOperations
parameter_list|(
name|GLenum
name|stencilFail
parameter_list|,
name|GLenum
name|stencilPassDepthFail
parameter_list|,
name|GLenum
name|stencilPassDepthPass
parameter_list|)
block|{
name|mDepthStencil
operator|.
name|stencilFail
operator|=
name|stencilFail
expr_stmt|;
name|mDepthStencil
operator|.
name|stencilPassDepthFail
operator|=
name|stencilPassDepthFail
expr_stmt|;
name|mDepthStencil
operator|.
name|stencilPassDepthPass
operator|=
name|stencilPassDepthPass
expr_stmt|;
block|}
DECL|function|setStencilBackOperations
name|void
name|State
operator|::
name|setStencilBackOperations
parameter_list|(
name|GLenum
name|stencilBackFail
parameter_list|,
name|GLenum
name|stencilBackPassDepthFail
parameter_list|,
name|GLenum
name|stencilBackPassDepthPass
parameter_list|)
block|{
name|mDepthStencil
operator|.
name|stencilBackFail
operator|=
name|stencilBackFail
expr_stmt|;
name|mDepthStencil
operator|.
name|stencilBackPassDepthFail
operator|=
name|stencilBackPassDepthFail
expr_stmt|;
name|mDepthStencil
operator|.
name|stencilBackPassDepthPass
operator|=
name|stencilBackPassDepthPass
expr_stmt|;
block|}
DECL|function|getStencilRef
name|GLint
name|State
operator|::
name|getStencilRef
parameter_list|()
specifier|const
block|{
return|return
name|mStencilRef
return|;
block|}
DECL|function|getStencilBackRef
name|GLint
name|State
operator|::
name|getStencilBackRef
parameter_list|()
specifier|const
block|{
return|return
name|mStencilBackRef
return|;
block|}
DECL|function|isPolygonOffsetFillEnabled
name|bool
name|State
operator|::
name|isPolygonOffsetFillEnabled
parameter_list|()
specifier|const
block|{
return|return
name|mRasterizer
operator|.
name|polygonOffsetFill
return|;
block|}
DECL|function|setPolygonOffsetFill
name|void
name|State
operator|::
name|setPolygonOffsetFill
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|mRasterizer
operator|.
name|polygonOffsetFill
operator|=
name|enabled
expr_stmt|;
block|}
DECL|function|setPolygonOffsetParams
name|void
name|State
operator|::
name|setPolygonOffsetParams
parameter_list|(
name|GLfloat
name|factor
parameter_list|,
name|GLfloat
name|units
parameter_list|)
block|{
comment|// An application can pass NaN values here, so handle this gracefully
name|mRasterizer
operator|.
name|polygonOffsetFactor
operator|=
name|factor
operator|!=
name|factor
condition|?
literal|0.0f
else|:
name|factor
expr_stmt|;
name|mRasterizer
operator|.
name|polygonOffsetUnits
operator|=
name|units
operator|!=
name|units
condition|?
literal|0.0f
else|:
name|units
expr_stmt|;
block|}
DECL|function|isSampleAlphaToCoverageEnabled
name|bool
name|State
operator|::
name|isSampleAlphaToCoverageEnabled
parameter_list|()
specifier|const
block|{
return|return
name|mBlend
operator|.
name|sampleAlphaToCoverage
return|;
block|}
DECL|function|setSampleAlphaToCoverage
name|void
name|State
operator|::
name|setSampleAlphaToCoverage
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|mBlend
operator|.
name|sampleAlphaToCoverage
operator|=
name|enabled
expr_stmt|;
block|}
DECL|function|isSampleCoverageEnabled
name|bool
name|State
operator|::
name|isSampleCoverageEnabled
parameter_list|()
specifier|const
block|{
return|return
name|mSampleCoverage
return|;
block|}
DECL|function|setSampleCoverage
name|void
name|State
operator|::
name|setSampleCoverage
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|mSampleCoverage
operator|=
name|enabled
expr_stmt|;
block|}
DECL|function|setSampleCoverageParams
name|void
name|State
operator|::
name|setSampleCoverageParams
parameter_list|(
name|GLclampf
name|value
parameter_list|,
name|bool
name|invert
parameter_list|)
block|{
name|mSampleCoverageValue
operator|=
name|value
expr_stmt|;
name|mSampleCoverageInvert
operator|=
name|invert
expr_stmt|;
block|}
DECL|function|getSampleCoverageParams
name|void
name|State
operator|::
name|getSampleCoverageParams
parameter_list|(
name|GLclampf
modifier|*
name|value
parameter_list|,
name|bool
modifier|*
name|invert
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|value
operator|!=
name|NULL
operator|&&
name|invert
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|value
operator|=
name|mSampleCoverageValue
expr_stmt|;
operator|*
name|invert
operator|=
name|mSampleCoverageInvert
expr_stmt|;
block|}
DECL|function|isScissorTestEnabled
name|bool
name|State
operator|::
name|isScissorTestEnabled
parameter_list|()
specifier|const
block|{
return|return
name|mScissorTest
return|;
block|}
DECL|function|setScissorTest
name|void
name|State
operator|::
name|setScissorTest
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|mScissorTest
operator|=
name|enabled
expr_stmt|;
block|}
DECL|function|setScissorParams
name|void
name|State
operator|::
name|setScissorParams
parameter_list|(
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
name|mScissor
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|mScissor
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|mScissor
operator|.
name|width
operator|=
name|width
expr_stmt|;
name|mScissor
operator|.
name|height
operator|=
name|height
expr_stmt|;
block|}
DECL|function|getScissor
specifier|const
name|Rectangle
modifier|&
name|State
operator|::
name|getScissor
parameter_list|()
specifier|const
block|{
return|return
name|mScissor
return|;
block|}
DECL|function|isDitherEnabled
name|bool
name|State
operator|::
name|isDitherEnabled
parameter_list|()
specifier|const
block|{
return|return
name|mBlend
operator|.
name|dither
return|;
block|}
DECL|function|setDither
name|void
name|State
operator|::
name|setDither
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|mBlend
operator|.
name|dither
operator|=
name|enabled
expr_stmt|;
block|}
DECL|function|isPrimitiveRestartEnabled
name|bool
name|State
operator|::
name|isPrimitiveRestartEnabled
parameter_list|()
specifier|const
block|{
return|return
name|mPrimitiveRestart
return|;
block|}
DECL|function|setPrimitiveRestart
name|void
name|State
operator|::
name|setPrimitiveRestart
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|mPrimitiveRestart
operator|=
name|enabled
expr_stmt|;
block|}
DECL|function|setEnableFeature
name|void
name|State
operator|::
name|setEnableFeature
parameter_list|(
name|GLenum
name|feature
parameter_list|,
name|bool
name|enabled
parameter_list|)
block|{
switch|switch
condition|(
name|feature
condition|)
block|{
case|case
name|GL_CULL_FACE
case|:
name|setCullFace
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_POLYGON_OFFSET_FILL
case|:
name|setPolygonOffsetFill
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_SAMPLE_ALPHA_TO_COVERAGE
case|:
name|setSampleAlphaToCoverage
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_SAMPLE_COVERAGE
case|:
name|setSampleCoverage
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_SCISSOR_TEST
case|:
name|setScissorTest
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_TEST
case|:
name|setStencilTest
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_DEPTH_TEST
case|:
name|setDepthTest
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_BLEND
case|:
name|setBlend
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_DITHER
case|:
name|setDither
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_PRIMITIVE_RESTART_FIXED_INDEX
case|:
name|setPrimitiveRestart
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_RASTERIZER_DISCARD
case|:
name|setRasterizerDiscard
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|getEnableFeature
name|bool
name|State
operator|::
name|getEnableFeature
parameter_list|(
name|GLenum
name|feature
parameter_list|)
block|{
switch|switch
condition|(
name|feature
condition|)
block|{
case|case
name|GL_CULL_FACE
case|:
return|return
name|isCullFaceEnabled
argument_list|()
return|;
case|case
name|GL_POLYGON_OFFSET_FILL
case|:
return|return
name|isPolygonOffsetFillEnabled
argument_list|()
return|;
case|case
name|GL_SAMPLE_ALPHA_TO_COVERAGE
case|:
return|return
name|isSampleAlphaToCoverageEnabled
argument_list|()
return|;
case|case
name|GL_SAMPLE_COVERAGE
case|:
return|return
name|isSampleCoverageEnabled
argument_list|()
return|;
case|case
name|GL_SCISSOR_TEST
case|:
return|return
name|isScissorTestEnabled
argument_list|()
return|;
case|case
name|GL_STENCIL_TEST
case|:
return|return
name|isStencilTestEnabled
argument_list|()
return|;
case|case
name|GL_DEPTH_TEST
case|:
return|return
name|isDepthTestEnabled
argument_list|()
return|;
case|case
name|GL_BLEND
case|:
return|return
name|isBlendEnabled
argument_list|()
return|;
case|case
name|GL_DITHER
case|:
return|return
name|isDitherEnabled
argument_list|()
return|;
case|case
name|GL_PRIMITIVE_RESTART_FIXED_INDEX
case|:
return|return
name|isPrimitiveRestartEnabled
argument_list|()
return|;
case|case
name|GL_RASTERIZER_DISCARD
case|:
return|return
name|isRasterizerDiscardEnabled
argument_list|()
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|setLineWidth
name|void
name|State
operator|::
name|setLineWidth
parameter_list|(
name|GLfloat
name|width
parameter_list|)
block|{
name|mLineWidth
operator|=
name|width
expr_stmt|;
block|}
DECL|function|setGenerateMipmapHint
name|void
name|State
operator|::
name|setGenerateMipmapHint
parameter_list|(
name|GLenum
name|hint
parameter_list|)
block|{
name|mGenerateMipmapHint
operator|=
name|hint
expr_stmt|;
block|}
DECL|function|setFragmentShaderDerivativeHint
name|void
name|State
operator|::
name|setFragmentShaderDerivativeHint
parameter_list|(
name|GLenum
name|hint
parameter_list|)
block|{
name|mFragmentShaderDerivativeHint
operator|=
name|hint
expr_stmt|;
comment|// TODO: Propagate the hint to shader translator so we can write
comment|// ddx, ddx_coarse, or ddx_fine depending on the hint.
comment|// Ignore for now. It is valid for implementations to ignore hint.
block|}
DECL|function|setViewportParams
name|void
name|State
operator|::
name|setViewportParams
parameter_list|(
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
name|mViewport
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|mViewport
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|mViewport
operator|.
name|width
operator|=
name|width
expr_stmt|;
name|mViewport
operator|.
name|height
operator|=
name|height
expr_stmt|;
block|}
DECL|function|getViewport
specifier|const
name|Rectangle
modifier|&
name|State
operator|::
name|getViewport
parameter_list|()
specifier|const
block|{
return|return
name|mViewport
return|;
block|}
DECL|function|setActiveSampler
name|void
name|State
operator|::
name|setActiveSampler
parameter_list|(
name|unsigned
name|int
name|active
parameter_list|)
block|{
name|mActiveSampler
operator|=
name|active
expr_stmt|;
block|}
DECL|function|getActiveSampler
name|unsigned
name|int
name|State
operator|::
name|getActiveSampler
parameter_list|()
specifier|const
block|{
return|return
name|mActiveSampler
return|;
block|}
DECL|function|setSamplerTexture
name|void
name|State
operator|::
name|setSamplerTexture
parameter_list|(
name|GLenum
name|type
parameter_list|,
name|Texture
modifier|*
name|texture
parameter_list|)
block|{
name|mSamplerTextures
index|[
name|type
index|]
index|[
name|mActiveSampler
index|]
operator|.
name|set
argument_list|(
name|texture
argument_list|)
expr_stmt|;
block|}
DECL|function|getSamplerTexture
name|Texture
modifier|*
name|State
operator|::
name|getSamplerTexture
parameter_list|(
name|unsigned
name|int
name|sampler
parameter_list|,
name|GLenum
name|type
parameter_list|)
specifier|const
block|{
specifier|const
specifier|auto
name|it
init|=
name|mSamplerTextures
operator|.
name|find
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|it
operator|!=
name|mSamplerTextures
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|it
operator|->
name|second
index|[
name|sampler
index|]
operator|.
name|get
argument_list|()
return|;
block|}
DECL|function|getSamplerTextureId
name|GLuint
name|State
operator|::
name|getSamplerTextureId
parameter_list|(
name|unsigned
name|int
name|sampler
parameter_list|,
name|GLenum
name|type
parameter_list|)
specifier|const
block|{
specifier|const
specifier|auto
name|it
init|=
name|mSamplerTextures
operator|.
name|find
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|it
operator|!=
name|mSamplerTextures
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|it
operator|->
name|second
index|[
name|sampler
index|]
operator|.
name|id
argument_list|()
return|;
block|}
DECL|function|detachTexture
name|void
name|State
operator|::
name|detachTexture
parameter_list|(
specifier|const
name|TextureMap
modifier|&
name|zeroTextures
parameter_list|,
name|GLuint
name|texture
parameter_list|)
block|{
comment|// Textures have a detach method on State rather than a simple
comment|// removeBinding, because the zero/null texture objects are managed
comment|// separately, and don't have to go through the Context's maps or
comment|// the ResourceManager.
comment|// [OpenGL ES 2.0.24] section 3.8 page 84:
comment|// If a texture object is deleted, it is as if all texture units which are bound to that texture object are
comment|// rebound to texture object zero
for|for
control|(
name|TextureBindingMap
operator|::
name|iterator
name|bindingVec
init|=
name|mSamplerTextures
operator|.
name|begin
argument_list|()
init|;
name|bindingVec
operator|!=
name|mSamplerTextures
operator|.
name|end
argument_list|()
condition|;
name|bindingVec
operator|++
control|)
block|{
name|GLenum
name|textureType
init|=
name|bindingVec
operator|->
name|first
decl_stmt|;
name|TextureBindingVector
modifier|&
name|textureVector
init|=
name|bindingVec
operator|->
name|second
decl_stmt|;
for|for
control|(
name|size_t
name|textureIdx
init|=
literal|0
init|;
name|textureIdx
operator|<
name|textureVector
operator|.
name|size
argument_list|()
condition|;
name|textureIdx
operator|++
control|)
block|{
name|BindingPointer
argument_list|<
name|Texture
argument_list|>
modifier|&
name|binding
init|=
name|textureVector
index|[
name|textureIdx
index|]
decl_stmt|;
if|if
condition|(
name|binding
operator|.
name|id
argument_list|()
operator|==
name|texture
condition|)
block|{
name|auto
name|it
init|=
name|zeroTextures
operator|.
name|find
argument_list|(
name|textureType
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|it
operator|!=
name|zeroTextures
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
comment|// Zero textures are the "default" textures instead of NULL
name|binding
operator|.
name|set
argument_list|(
name|it
operator|->
name|second
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// [OpenGL ES 2.0.24] section 4.4 page 112:
comment|// If a texture object is deleted while its image is attached to the currently bound framebuffer, then it is
comment|// as if Texture2DAttachment had been called, with a texture of 0, for each attachment point to which this
comment|// image was attached in the currently bound framebuffer.
if|if
condition|(
name|mReadFramebuffer
condition|)
block|{
name|mReadFramebuffer
operator|->
name|detachTexture
argument_list|(
name|texture
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mDrawFramebuffer
condition|)
block|{
name|mDrawFramebuffer
operator|->
name|detachTexture
argument_list|(
name|texture
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|initializeZeroTextures
name|void
name|State
operator|::
name|initializeZeroTextures
parameter_list|(
specifier|const
name|TextureMap
modifier|&
name|zeroTextures
parameter_list|)
block|{
for|for
control|(
name|auto
name|it
init|=
name|zeroTextures
operator|.
name|cbegin
argument_list|()
init|;
name|it
operator|!=
name|zeroTextures
operator|.
name|cend
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
specifier|const
specifier|auto
modifier|&
name|zeroTexture
init|=
operator|*
name|it
decl_stmt|;
name|auto
operator|&
name|samplerTextureArray
operator|=
name|mSamplerTextures
index|[
name|zeroTexture
operator|.
name|first
index|]
expr_stmt|;
for|for
control|(
name|size_t
name|textureUnit
init|=
literal|0
init|;
name|textureUnit
operator|<
name|samplerTextureArray
operator|.
name|size
argument_list|()
condition|;
operator|++
name|textureUnit
control|)
block|{
name|samplerTextureArray
index|[
name|textureUnit
index|]
operator|.
name|set
argument_list|(
name|zeroTexture
operator|.
name|second
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|setSamplerBinding
name|void
name|State
operator|::
name|setSamplerBinding
parameter_list|(
name|GLuint
name|textureUnit
parameter_list|,
name|Sampler
modifier|*
name|sampler
parameter_list|)
block|{
name|mSamplers
index|[
name|textureUnit
index|]
operator|.
name|set
argument_list|(
name|sampler
argument_list|)
expr_stmt|;
block|}
DECL|function|getSamplerId
name|GLuint
name|State
operator|::
name|getSamplerId
parameter_list|(
name|GLuint
name|textureUnit
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|textureUnit
operator|<
name|mSamplers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|mSamplers
index|[
name|textureUnit
index|]
operator|.
name|id
argument_list|()
return|;
block|}
DECL|function|getSampler
name|Sampler
modifier|*
name|State
operator|::
name|getSampler
parameter_list|(
name|GLuint
name|textureUnit
parameter_list|)
specifier|const
block|{
return|return
name|mSamplers
index|[
name|textureUnit
index|]
operator|.
name|get
argument_list|()
return|;
block|}
DECL|function|detachSampler
name|void
name|State
operator|::
name|detachSampler
parameter_list|(
name|GLuint
name|sampler
parameter_list|)
block|{
comment|// [OpenGL ES 3.0.2] section 3.8.2 pages 123-124:
comment|// If a sampler object that is currently bound to one or more texture units is
comment|// deleted, it is as though BindSampler is called once for each texture unit to
comment|// which the sampler is bound, with unit set to the texture unit and sampler set to zero.
for|for
control|(
name|size_t
name|textureUnit
init|=
literal|0
init|;
name|textureUnit
operator|<
name|mSamplers
operator|.
name|size
argument_list|()
condition|;
name|textureUnit
operator|++
control|)
block|{
name|BindingPointer
argument_list|<
name|Sampler
argument_list|>
modifier|&
name|samplerBinding
init|=
name|mSamplers
index|[
name|textureUnit
index|]
decl_stmt|;
if|if
condition|(
name|samplerBinding
operator|.
name|id
argument_list|()
operator|==
name|sampler
condition|)
block|{
name|samplerBinding
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|setRenderbufferBinding
name|void
name|State
operator|::
name|setRenderbufferBinding
parameter_list|(
name|Renderbuffer
modifier|*
name|renderbuffer
parameter_list|)
block|{
name|mRenderbuffer
operator|.
name|set
argument_list|(
name|renderbuffer
argument_list|)
expr_stmt|;
block|}
DECL|function|getRenderbufferId
name|GLuint
name|State
operator|::
name|getRenderbufferId
parameter_list|()
specifier|const
block|{
return|return
name|mRenderbuffer
operator|.
name|id
argument_list|()
return|;
block|}
DECL|function|getCurrentRenderbuffer
name|Renderbuffer
modifier|*
name|State
operator|::
name|getCurrentRenderbuffer
parameter_list|()
block|{
return|return
name|mRenderbuffer
operator|.
name|get
argument_list|()
return|;
block|}
DECL|function|detachRenderbuffer
name|void
name|State
operator|::
name|detachRenderbuffer
parameter_list|(
name|GLuint
name|renderbuffer
parameter_list|)
block|{
comment|// [OpenGL ES 2.0.24] section 4.4 page 109:
comment|// If a renderbuffer that is currently bound to RENDERBUFFER is deleted, it is as though BindRenderbuffer
comment|// had been executed with the target RENDERBUFFER and name of zero.
if|if
condition|(
name|mRenderbuffer
operator|.
name|id
argument_list|()
operator|==
name|renderbuffer
condition|)
block|{
name|mRenderbuffer
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|// [OpenGL ES 2.0.24] section 4.4 page 111:
comment|// If a renderbuffer object is deleted while its image is attached to the currently bound framebuffer,
comment|// then it is as if FramebufferRenderbuffer had been called, with a renderbuffer of 0, for each attachment
comment|// point to which this image was attached in the currently bound framebuffer.
name|Framebuffer
modifier|*
name|readFramebuffer
init|=
name|mReadFramebuffer
decl_stmt|;
name|Framebuffer
modifier|*
name|drawFramebuffer
init|=
name|mDrawFramebuffer
decl_stmt|;
if|if
condition|(
name|readFramebuffer
condition|)
block|{
name|readFramebuffer
operator|->
name|detachRenderbuffer
argument_list|(
name|renderbuffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|drawFramebuffer
operator|&&
name|drawFramebuffer
operator|!=
name|readFramebuffer
condition|)
block|{
name|drawFramebuffer
operator|->
name|detachRenderbuffer
argument_list|(
name|renderbuffer
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|setReadFramebufferBinding
name|void
name|State
operator|::
name|setReadFramebufferBinding
parameter_list|(
name|Framebuffer
modifier|*
name|framebuffer
parameter_list|)
block|{
name|mReadFramebuffer
operator|=
name|framebuffer
expr_stmt|;
block|}
DECL|function|setDrawFramebufferBinding
name|void
name|State
operator|::
name|setDrawFramebufferBinding
parameter_list|(
name|Framebuffer
modifier|*
name|framebuffer
parameter_list|)
block|{
name|mDrawFramebuffer
operator|=
name|framebuffer
expr_stmt|;
block|}
DECL|function|getTargetFramebuffer
name|Framebuffer
modifier|*
name|State
operator|::
name|getTargetFramebuffer
parameter_list|(
name|GLenum
name|target
parameter_list|)
specifier|const
block|{
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_READ_FRAMEBUFFER_ANGLE
case|:
return|return
name|mReadFramebuffer
return|;
case|case
name|GL_DRAW_FRAMEBUFFER_ANGLE
case|:
case|case
name|GL_FRAMEBUFFER
case|:
return|return
name|mDrawFramebuffer
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
DECL|function|getReadFramebuffer
name|Framebuffer
modifier|*
name|State
operator|::
name|getReadFramebuffer
parameter_list|()
block|{
return|return
name|mReadFramebuffer
return|;
block|}
DECL|function|getDrawFramebuffer
name|Framebuffer
modifier|*
name|State
operator|::
name|getDrawFramebuffer
parameter_list|()
block|{
return|return
name|mDrawFramebuffer
return|;
block|}
DECL|function|getReadFramebuffer
specifier|const
name|Framebuffer
modifier|*
name|State
operator|::
name|getReadFramebuffer
parameter_list|()
specifier|const
block|{
return|return
name|mReadFramebuffer
return|;
block|}
DECL|function|getDrawFramebuffer
specifier|const
name|Framebuffer
modifier|*
name|State
operator|::
name|getDrawFramebuffer
parameter_list|()
specifier|const
block|{
return|return
name|mDrawFramebuffer
return|;
block|}
DECL|function|removeReadFramebufferBinding
name|bool
name|State
operator|::
name|removeReadFramebufferBinding
parameter_list|(
name|GLuint
name|framebuffer
parameter_list|)
block|{
if|if
condition|(
name|mReadFramebuffer
operator|->
name|id
argument_list|()
operator|==
name|framebuffer
condition|)
block|{
name|mReadFramebuffer
operator|=
name|NULL
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|function|removeDrawFramebufferBinding
name|bool
name|State
operator|::
name|removeDrawFramebufferBinding
parameter_list|(
name|GLuint
name|framebuffer
parameter_list|)
block|{
if|if
condition|(
name|mDrawFramebuffer
operator|->
name|id
argument_list|()
operator|==
name|framebuffer
condition|)
block|{
name|mDrawFramebuffer
operator|=
name|NULL
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|function|setVertexArrayBinding
name|void
name|State
operator|::
name|setVertexArrayBinding
parameter_list|(
name|VertexArray
modifier|*
name|vertexArray
parameter_list|)
block|{
name|mVertexArray
operator|=
name|vertexArray
expr_stmt|;
block|}
DECL|function|getVertexArrayId
name|GLuint
name|State
operator|::
name|getVertexArrayId
parameter_list|()
specifier|const
block|{
name|ASSERT
argument_list|(
name|mVertexArray
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
name|mVertexArray
operator|->
name|id
argument_list|()
return|;
block|}
DECL|function|getVertexArray
name|VertexArray
modifier|*
name|State
operator|::
name|getVertexArray
parameter_list|()
specifier|const
block|{
name|ASSERT
argument_list|(
name|mVertexArray
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
name|mVertexArray
return|;
block|}
DECL|function|removeVertexArrayBinding
name|bool
name|State
operator|::
name|removeVertexArrayBinding
parameter_list|(
name|GLuint
name|vertexArray
parameter_list|)
block|{
if|if
condition|(
name|mVertexArray
operator|->
name|id
argument_list|()
operator|==
name|vertexArray
condition|)
block|{
name|mVertexArray
operator|=
name|NULL
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|function|setProgram
name|void
name|State
operator|::
name|setProgram
parameter_list|(
name|Program
modifier|*
name|newProgram
parameter_list|)
block|{
if|if
condition|(
name|mProgram
operator|!=
name|newProgram
condition|)
block|{
if|if
condition|(
name|mProgram
condition|)
block|{
name|mProgram
operator|->
name|release
argument_list|()
expr_stmt|;
block|}
name|mProgram
operator|=
name|newProgram
expr_stmt|;
if|if
condition|(
name|mProgram
condition|)
block|{
name|newProgram
operator|->
name|addRef
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|function|getProgram
name|Program
modifier|*
name|State
operator|::
name|getProgram
parameter_list|()
specifier|const
block|{
return|return
name|mProgram
return|;
block|}
DECL|function|setTransformFeedbackBinding
name|void
name|State
operator|::
name|setTransformFeedbackBinding
parameter_list|(
name|TransformFeedback
modifier|*
name|transformFeedback
parameter_list|)
block|{
name|mTransformFeedback
operator|.
name|set
argument_list|(
name|transformFeedback
argument_list|)
expr_stmt|;
block|}
DECL|function|getCurrentTransformFeedback
name|TransformFeedback
modifier|*
name|State
operator|::
name|getCurrentTransformFeedback
parameter_list|()
specifier|const
block|{
return|return
name|mTransformFeedback
operator|.
name|get
argument_list|()
return|;
block|}
DECL|function|isTransformFeedbackActiveUnpaused
name|bool
name|State
operator|::
name|isTransformFeedbackActiveUnpaused
parameter_list|()
specifier|const
block|{
name|gl
operator|::
name|TransformFeedback
modifier|*
name|curTransformFeedback
init|=
name|getCurrentTransformFeedback
argument_list|()
decl_stmt|;
return|return
name|curTransformFeedback
operator|&&
name|curTransformFeedback
operator|->
name|isStarted
argument_list|()
operator|&&
operator|!
name|curTransformFeedback
operator|->
name|isPaused
argument_list|()
return|;
block|}
DECL|function|detachTransformFeedback
name|void
name|State
operator|::
name|detachTransformFeedback
parameter_list|(
name|GLuint
name|transformFeedback
parameter_list|)
block|{
if|if
condition|(
name|mTransformFeedback
operator|.
name|id
argument_list|()
operator|==
name|transformFeedback
condition|)
block|{
name|mTransformFeedback
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|isQueryActive
name|bool
name|State
operator|::
name|isQueryActive
parameter_list|()
specifier|const
block|{
for|for
control|(
name|State
operator|::
name|ActiveQueryMap
operator|::
name|const_iterator
name|i
init|=
name|mActiveQueries
operator|.
name|begin
argument_list|()
init|;
name|i
operator|!=
name|mActiveQueries
operator|.
name|end
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|->
name|second
operator|.
name|get
argument_list|()
operator|!=
name|NULL
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|function|setActiveQuery
name|void
name|State
operator|::
name|setActiveQuery
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|Query
modifier|*
name|query
parameter_list|)
block|{
name|mActiveQueries
index|[
name|target
index|]
operator|.
name|set
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
DECL|function|getActiveQueryId
name|GLuint
name|State
operator|::
name|getActiveQueryId
parameter_list|(
name|GLenum
name|target
parameter_list|)
specifier|const
block|{
specifier|const
name|Query
modifier|*
name|query
init|=
name|getActiveQuery
argument_list|(
name|target
argument_list|)
decl_stmt|;
return|return
operator|(
name|query
condition|?
name|query
operator|->
name|id
argument_list|()
else|:
literal|0u
operator|)
return|;
block|}
DECL|function|getActiveQuery
name|Query
modifier|*
name|State
operator|::
name|getActiveQuery
parameter_list|(
name|GLenum
name|target
parameter_list|)
specifier|const
block|{
specifier|const
specifier|auto
name|it
init|=
name|mActiveQueries
operator|.
name|find
argument_list|(
name|target
argument_list|)
decl_stmt|;
comment|// All query types should already exist in the activeQueries map
name|ASSERT
argument_list|(
name|it
operator|!=
name|mActiveQueries
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|it
operator|->
name|second
operator|.
name|get
argument_list|()
return|;
block|}
DECL|function|setArrayBufferBinding
name|void
name|State
operator|::
name|setArrayBufferBinding
parameter_list|(
name|Buffer
modifier|*
name|buffer
parameter_list|)
block|{
name|mArrayBuffer
operator|.
name|set
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
DECL|function|getArrayBufferId
name|GLuint
name|State
operator|::
name|getArrayBufferId
parameter_list|()
specifier|const
block|{
return|return
name|mArrayBuffer
operator|.
name|id
argument_list|()
return|;
block|}
DECL|function|removeArrayBufferBinding
name|bool
name|State
operator|::
name|removeArrayBufferBinding
parameter_list|(
name|GLuint
name|buffer
parameter_list|)
block|{
if|if
condition|(
name|mArrayBuffer
operator|.
name|id
argument_list|()
operator|==
name|buffer
condition|)
block|{
name|mArrayBuffer
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|function|setGenericUniformBufferBinding
name|void
name|State
operator|::
name|setGenericUniformBufferBinding
parameter_list|(
name|Buffer
modifier|*
name|buffer
parameter_list|)
block|{
name|mGenericUniformBuffer
operator|.
name|set
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
DECL|function|setIndexedUniformBufferBinding
name|void
name|State
operator|::
name|setIndexedUniformBufferBinding
parameter_list|(
name|GLuint
name|index
parameter_list|,
name|Buffer
modifier|*
name|buffer
parameter_list|,
name|GLintptr
name|offset
parameter_list|,
name|GLsizeiptr
name|size
parameter_list|)
block|{
name|mUniformBuffers
index|[
name|index
index|]
operator|.
name|set
argument_list|(
name|buffer
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
DECL|function|getIndexedUniformBufferId
name|GLuint
name|State
operator|::
name|getIndexedUniformBufferId
parameter_list|(
name|GLuint
name|index
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|index
argument_list|)
operator|<
name|mUniformBuffers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|mUniformBuffers
index|[
name|index
index|]
operator|.
name|id
argument_list|()
return|;
block|}
DECL|function|getIndexedUniformBuffer
name|Buffer
modifier|*
name|State
operator|::
name|getIndexedUniformBuffer
parameter_list|(
name|GLuint
name|index
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|index
argument_list|)
operator|<
name|mUniformBuffers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|mUniformBuffers
index|[
name|index
index|]
operator|.
name|get
argument_list|()
return|;
block|}
DECL|function|getIndexedUniformBufferOffset
name|GLintptr
name|State
operator|::
name|getIndexedUniformBufferOffset
parameter_list|(
name|GLuint
name|index
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|index
argument_list|)
operator|<
name|mUniformBuffers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|mUniformBuffers
index|[
name|index
index|]
operator|.
name|getOffset
argument_list|()
return|;
block|}
DECL|function|getIndexedUniformBufferSize
name|GLsizeiptr
name|State
operator|::
name|getIndexedUniformBufferSize
parameter_list|(
name|GLuint
name|index
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|index
argument_list|)
operator|<
name|mUniformBuffers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|mUniformBuffers
index|[
name|index
index|]
operator|.
name|getSize
argument_list|()
return|;
block|}
DECL|function|setGenericTransformFeedbackBufferBinding
name|void
name|State
operator|::
name|setGenericTransformFeedbackBufferBinding
parameter_list|(
name|Buffer
modifier|*
name|buffer
parameter_list|)
block|{
name|mGenericTransformFeedbackBuffer
operator|.
name|set
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
DECL|function|setIndexedTransformFeedbackBufferBinding
name|void
name|State
operator|::
name|setIndexedTransformFeedbackBufferBinding
parameter_list|(
name|GLuint
name|index
parameter_list|,
name|Buffer
modifier|*
name|buffer
parameter_list|,
name|GLintptr
name|offset
parameter_list|,
name|GLsizeiptr
name|size
parameter_list|)
block|{
name|mTransformFeedbackBuffers
index|[
name|index
index|]
operator|.
name|set
argument_list|(
name|buffer
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
DECL|function|getIndexedTransformFeedbackBufferId
name|GLuint
name|State
operator|::
name|getIndexedTransformFeedbackBufferId
parameter_list|(
name|GLuint
name|index
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|index
argument_list|)
operator|<
name|mTransformFeedbackBuffers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|mTransformFeedbackBuffers
index|[
name|index
index|]
operator|.
name|id
argument_list|()
return|;
block|}
DECL|function|getIndexedTransformFeedbackBuffer
name|Buffer
modifier|*
name|State
operator|::
name|getIndexedTransformFeedbackBuffer
parameter_list|(
name|GLuint
name|index
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|index
argument_list|)
operator|<
name|mTransformFeedbackBuffers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|mTransformFeedbackBuffers
index|[
name|index
index|]
operator|.
name|get
argument_list|()
return|;
block|}
DECL|function|getIndexedTransformFeedbackBufferOffset
name|GLuint
name|State
operator|::
name|getIndexedTransformFeedbackBufferOffset
parameter_list|(
name|GLuint
name|index
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|index
argument_list|)
operator|<
name|mTransformFeedbackBuffers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|mTransformFeedbackBuffers
index|[
name|index
index|]
operator|.
name|getOffset
argument_list|()
return|;
block|}
DECL|function|getTransformFeedbackBufferIndexRange
name|size_t
name|State
operator|::
name|getTransformFeedbackBufferIndexRange
parameter_list|()
specifier|const
block|{
return|return
name|mTransformFeedbackBuffers
operator|.
name|size
argument_list|()
return|;
block|}
DECL|function|setCopyReadBufferBinding
name|void
name|State
operator|::
name|setCopyReadBufferBinding
parameter_list|(
name|Buffer
modifier|*
name|buffer
parameter_list|)
block|{
name|mCopyReadBuffer
operator|.
name|set
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
DECL|function|setCopyWriteBufferBinding
name|void
name|State
operator|::
name|setCopyWriteBufferBinding
parameter_list|(
name|Buffer
modifier|*
name|buffer
parameter_list|)
block|{
name|mCopyWriteBuffer
operator|.
name|set
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
DECL|function|setPixelPackBufferBinding
name|void
name|State
operator|::
name|setPixelPackBufferBinding
parameter_list|(
name|Buffer
modifier|*
name|buffer
parameter_list|)
block|{
name|mPack
operator|.
name|pixelBuffer
operator|.
name|set
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
DECL|function|setPixelUnpackBufferBinding
name|void
name|State
operator|::
name|setPixelUnpackBufferBinding
parameter_list|(
name|Buffer
modifier|*
name|buffer
parameter_list|)
block|{
name|mUnpack
operator|.
name|pixelBuffer
operator|.
name|set
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
DECL|function|getTargetBuffer
name|Buffer
modifier|*
name|State
operator|::
name|getTargetBuffer
parameter_list|(
name|GLenum
name|target
parameter_list|)
specifier|const
block|{
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_ARRAY_BUFFER
case|:
return|return
name|mArrayBuffer
operator|.
name|get
argument_list|()
return|;
case|case
name|GL_COPY_READ_BUFFER
case|:
return|return
name|mCopyReadBuffer
operator|.
name|get
argument_list|()
return|;
case|case
name|GL_COPY_WRITE_BUFFER
case|:
return|return
name|mCopyWriteBuffer
operator|.
name|get
argument_list|()
return|;
case|case
name|GL_ELEMENT_ARRAY_BUFFER
case|:
return|return
name|getVertexArray
argument_list|()
operator|->
name|getElementArrayBuffer
argument_list|()
return|;
case|case
name|GL_PIXEL_PACK_BUFFER
case|:
return|return
name|mPack
operator|.
name|pixelBuffer
operator|.
name|get
argument_list|()
return|;
case|case
name|GL_PIXEL_UNPACK_BUFFER
case|:
return|return
name|mUnpack
operator|.
name|pixelBuffer
operator|.
name|get
argument_list|()
return|;
case|case
name|GL_TRANSFORM_FEEDBACK_BUFFER
case|:
return|return
name|mGenericTransformFeedbackBuffer
operator|.
name|get
argument_list|()
return|;
case|case
name|GL_UNIFORM_BUFFER
case|:
return|return
name|mGenericUniformBuffer
operator|.
name|get
argument_list|()
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
DECL|function|setEnableVertexAttribArray
name|void
name|State
operator|::
name|setEnableVertexAttribArray
parameter_list|(
name|unsigned
name|int
name|attribNum
parameter_list|,
name|bool
name|enabled
parameter_list|)
block|{
name|getVertexArray
argument_list|()
operator|->
name|enableAttribute
argument_list|(
name|attribNum
argument_list|,
name|enabled
argument_list|)
expr_stmt|;
block|}
DECL|function|setVertexAttribf
name|void
name|State
operator|::
name|setVertexAttribf
parameter_list|(
name|GLuint
name|index
parameter_list|,
specifier|const
name|GLfloat
name|values
index|[
literal|4
index|]
parameter_list|)
block|{
name|ASSERT
argument_list|(
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|index
argument_list|)
operator|<
name|mVertexAttribCurrentValues
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|mVertexAttribCurrentValues
index|[
name|index
index|]
operator|.
name|setFloatValues
argument_list|(
name|values
argument_list|)
expr_stmt|;
block|}
DECL|function|setVertexAttribu
name|void
name|State
operator|::
name|setVertexAttribu
parameter_list|(
name|GLuint
name|index
parameter_list|,
specifier|const
name|GLuint
name|values
index|[
literal|4
index|]
parameter_list|)
block|{
name|ASSERT
argument_list|(
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|index
argument_list|)
operator|<
name|mVertexAttribCurrentValues
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|mVertexAttribCurrentValues
index|[
name|index
index|]
operator|.
name|setUnsignedIntValues
argument_list|(
name|values
argument_list|)
expr_stmt|;
block|}
DECL|function|setVertexAttribi
name|void
name|State
operator|::
name|setVertexAttribi
parameter_list|(
name|GLuint
name|index
parameter_list|,
specifier|const
name|GLint
name|values
index|[
literal|4
index|]
parameter_list|)
block|{
name|ASSERT
argument_list|(
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|index
argument_list|)
operator|<
name|mVertexAttribCurrentValues
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|mVertexAttribCurrentValues
index|[
name|index
index|]
operator|.
name|setIntValues
argument_list|(
name|values
argument_list|)
expr_stmt|;
block|}
DECL|function|setVertexAttribState
name|void
name|State
operator|::
name|setVertexAttribState
parameter_list|(
name|unsigned
name|int
name|attribNum
parameter_list|,
name|Buffer
modifier|*
name|boundBuffer
parameter_list|,
name|GLint
name|size
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|bool
name|normalized
parameter_list|,
name|bool
name|pureInteger
parameter_list|,
name|GLsizei
name|stride
parameter_list|,
specifier|const
name|void
modifier|*
name|pointer
parameter_list|)
block|{
name|getVertexArray
argument_list|()
operator|->
name|setAttributeState
argument_list|(
name|attribNum
argument_list|,
name|boundBuffer
argument_list|,
name|size
argument_list|,
name|type
argument_list|,
name|normalized
argument_list|,
name|pureInteger
argument_list|,
name|stride
argument_list|,
name|pointer
argument_list|)
expr_stmt|;
block|}
DECL|function|getVertexAttribCurrentValue
specifier|const
name|VertexAttribCurrentValueData
modifier|&
name|State
operator|::
name|getVertexAttribCurrentValue
parameter_list|(
name|unsigned
name|int
name|attribNum
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|attribNum
argument_list|)
operator|<
name|mVertexAttribCurrentValues
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|mVertexAttribCurrentValues
index|[
name|attribNum
index|]
return|;
block|}
DECL|function|getVertexAttribPointer
specifier|const
name|void
modifier|*
name|State
operator|::
name|getVertexAttribPointer
parameter_list|(
name|unsigned
name|int
name|attribNum
parameter_list|)
specifier|const
block|{
return|return
name|getVertexArray
argument_list|()
operator|->
name|getVertexAttribute
argument_list|(
name|attribNum
argument_list|)
operator|.
name|pointer
return|;
block|}
DECL|function|setPackAlignment
name|void
name|State
operator|::
name|setPackAlignment
parameter_list|(
name|GLint
name|alignment
parameter_list|)
block|{
name|mPack
operator|.
name|alignment
operator|=
name|alignment
expr_stmt|;
block|}
DECL|function|getPackAlignment
name|GLint
name|State
operator|::
name|getPackAlignment
parameter_list|()
specifier|const
block|{
return|return
name|mPack
operator|.
name|alignment
return|;
block|}
DECL|function|setPackReverseRowOrder
name|void
name|State
operator|::
name|setPackReverseRowOrder
parameter_list|(
name|bool
name|reverseRowOrder
parameter_list|)
block|{
name|mPack
operator|.
name|reverseRowOrder
operator|=
name|reverseRowOrder
expr_stmt|;
block|}
DECL|function|getPackReverseRowOrder
name|bool
name|State
operator|::
name|getPackReverseRowOrder
parameter_list|()
specifier|const
block|{
return|return
name|mPack
operator|.
name|reverseRowOrder
return|;
block|}
DECL|function|getPackState
specifier|const
name|PixelPackState
modifier|&
name|State
operator|::
name|getPackState
parameter_list|()
specifier|const
block|{
return|return
name|mPack
return|;
block|}
DECL|function|getPackState
name|PixelPackState
modifier|&
name|State
operator|::
name|getPackState
parameter_list|()
block|{
return|return
name|mPack
return|;
block|}
DECL|function|setUnpackAlignment
name|void
name|State
operator|::
name|setUnpackAlignment
parameter_list|(
name|GLint
name|alignment
parameter_list|)
block|{
name|mUnpack
operator|.
name|alignment
operator|=
name|alignment
expr_stmt|;
block|}
DECL|function|getUnpackAlignment
name|GLint
name|State
operator|::
name|getUnpackAlignment
parameter_list|()
specifier|const
block|{
return|return
name|mUnpack
operator|.
name|alignment
return|;
block|}
DECL|function|setUnpackRowLength
name|void
name|State
operator|::
name|setUnpackRowLength
parameter_list|(
name|GLint
name|rowLength
parameter_list|)
block|{
name|mUnpack
operator|.
name|rowLength
operator|=
name|rowLength
expr_stmt|;
block|}
DECL|function|getUnpackRowLength
name|GLint
name|State
operator|::
name|getUnpackRowLength
parameter_list|()
specifier|const
block|{
return|return
name|mUnpack
operator|.
name|rowLength
return|;
block|}
DECL|function|getUnpackState
specifier|const
name|PixelUnpackState
modifier|&
name|State
operator|::
name|getUnpackState
parameter_list|()
specifier|const
block|{
return|return
name|mUnpack
return|;
block|}
DECL|function|getUnpackState
name|PixelUnpackState
modifier|&
name|State
operator|::
name|getUnpackState
parameter_list|()
block|{
return|return
name|mUnpack
return|;
block|}
DECL|function|getBooleanv
name|void
name|State
operator|::
name|getBooleanv
parameter_list|(
name|GLenum
name|pname
parameter_list|,
name|GLboolean
modifier|*
name|params
parameter_list|)
block|{
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_SAMPLE_COVERAGE_INVERT
case|:
operator|*
name|params
operator|=
name|mSampleCoverageInvert
expr_stmt|;
break|break;
case|case
name|GL_DEPTH_WRITEMASK
case|:
operator|*
name|params
operator|=
name|mDepthStencil
operator|.
name|depthMask
expr_stmt|;
break|break;
case|case
name|GL_COLOR_WRITEMASK
case|:
name|params
index|[
literal|0
index|]
operator|=
name|mBlend
operator|.
name|colorMaskRed
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|mBlend
operator|.
name|colorMaskGreen
expr_stmt|;
name|params
index|[
literal|2
index|]
operator|=
name|mBlend
operator|.
name|colorMaskBlue
expr_stmt|;
name|params
index|[
literal|3
index|]
operator|=
name|mBlend
operator|.
name|colorMaskAlpha
expr_stmt|;
break|break;
case|case
name|GL_CULL_FACE
case|:
operator|*
name|params
operator|=
name|mRasterizer
operator|.
name|cullFace
expr_stmt|;
break|break;
case|case
name|GL_POLYGON_OFFSET_FILL
case|:
operator|*
name|params
operator|=
name|mRasterizer
operator|.
name|polygonOffsetFill
expr_stmt|;
break|break;
case|case
name|GL_SAMPLE_ALPHA_TO_COVERAGE
case|:
operator|*
name|params
operator|=
name|mBlend
operator|.
name|sampleAlphaToCoverage
expr_stmt|;
break|break;
case|case
name|GL_SAMPLE_COVERAGE
case|:
operator|*
name|params
operator|=
name|mSampleCoverage
expr_stmt|;
break|break;
case|case
name|GL_SCISSOR_TEST
case|:
operator|*
name|params
operator|=
name|mScissorTest
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_TEST
case|:
operator|*
name|params
operator|=
name|mDepthStencil
operator|.
name|stencilTest
expr_stmt|;
break|break;
case|case
name|GL_DEPTH_TEST
case|:
operator|*
name|params
operator|=
name|mDepthStencil
operator|.
name|depthTest
expr_stmt|;
break|break;
case|case
name|GL_BLEND
case|:
operator|*
name|params
operator|=
name|mBlend
operator|.
name|blend
expr_stmt|;
break|break;
case|case
name|GL_DITHER
case|:
operator|*
name|params
operator|=
name|mBlend
operator|.
name|dither
expr_stmt|;
break|break;
case|case
name|GL_TRANSFORM_FEEDBACK_ACTIVE
case|:
operator|*
name|params
operator|=
name|getCurrentTransformFeedback
argument_list|()
operator|->
name|isStarted
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_TRANSFORM_FEEDBACK_PAUSED
case|:
operator|*
name|params
operator|=
name|getCurrentTransformFeedback
argument_list|()
operator|->
name|isPaused
argument_list|()
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
DECL|function|getFloatv
name|void
name|State
operator|::
name|getFloatv
parameter_list|(
name|GLenum
name|pname
parameter_list|,
name|GLfloat
modifier|*
name|params
parameter_list|)
block|{
comment|// Please note: DEPTH_CLEAR_VALUE is included in our internal getFloatv implementation
comment|// because it is stored as a float, despite the fact that the GL ES 2.0 spec names
comment|// GetIntegerv as its native query function. As it would require conversion in any
comment|// case, this should make no difference to the calling application.
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_LINE_WIDTH
case|:
operator|*
name|params
operator|=
name|mLineWidth
expr_stmt|;
break|break;
case|case
name|GL_SAMPLE_COVERAGE_VALUE
case|:
operator|*
name|params
operator|=
name|mSampleCoverageValue
expr_stmt|;
break|break;
case|case
name|GL_DEPTH_CLEAR_VALUE
case|:
operator|*
name|params
operator|=
name|mDepthClearValue
expr_stmt|;
break|break;
case|case
name|GL_POLYGON_OFFSET_FACTOR
case|:
operator|*
name|params
operator|=
name|mRasterizer
operator|.
name|polygonOffsetFactor
expr_stmt|;
break|break;
case|case
name|GL_POLYGON_OFFSET_UNITS
case|:
operator|*
name|params
operator|=
name|mRasterizer
operator|.
name|polygonOffsetUnits
expr_stmt|;
break|break;
case|case
name|GL_DEPTH_RANGE
case|:
name|params
index|[
literal|0
index|]
operator|=
name|mNearZ
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|mFarZ
expr_stmt|;
break|break;
case|case
name|GL_COLOR_CLEAR_VALUE
case|:
name|params
index|[
literal|0
index|]
operator|=
name|mColorClearValue
operator|.
name|red
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|mColorClearValue
operator|.
name|green
expr_stmt|;
name|params
index|[
literal|2
index|]
operator|=
name|mColorClearValue
operator|.
name|blue
expr_stmt|;
name|params
index|[
literal|3
index|]
operator|=
name|mColorClearValue
operator|.
name|alpha
expr_stmt|;
break|break;
case|case
name|GL_BLEND_COLOR
case|:
name|params
index|[
literal|0
index|]
operator|=
name|mBlendColor
operator|.
name|red
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|mBlendColor
operator|.
name|green
expr_stmt|;
name|params
index|[
literal|2
index|]
operator|=
name|mBlendColor
operator|.
name|blue
expr_stmt|;
name|params
index|[
literal|3
index|]
operator|=
name|mBlendColor
operator|.
name|alpha
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
DECL|function|getIntegerv
name|void
name|State
operator|::
name|getIntegerv
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLint
modifier|*
name|params
parameter_list|)
block|{
if|if
condition|(
name|pname
operator|>=
name|GL_DRAW_BUFFER0_EXT
operator|&&
name|pname
operator|<=
name|GL_DRAW_BUFFER15_EXT
condition|)
block|{
name|unsigned
name|int
name|colorAttachment
init|=
operator|(
name|pname
operator|-
name|GL_DRAW_BUFFER0_EXT
operator|)
decl_stmt|;
name|ASSERT
argument_list|(
name|colorAttachment
operator|<
name|mMaxDrawBuffers
argument_list|)
expr_stmt|;
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|mDrawFramebuffer
decl_stmt|;
operator|*
name|params
operator|=
name|framebuffer
operator|->
name|getDrawBufferState
argument_list|(
name|colorAttachment
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Please note: DEPTH_CLEAR_VALUE is not included in our internal getIntegerv implementation
comment|// because it is stored as a float, despite the fact that the GL ES 2.0 spec names
comment|// GetIntegerv as its native query function. As it would require conversion in any
comment|// case, this should make no difference to the calling application. You may find it in
comment|// State::getFloatv.
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_ARRAY_BUFFER_BINDING
case|:
operator|*
name|params
operator|=
name|mArrayBuffer
operator|.
name|id
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_ELEMENT_ARRAY_BUFFER_BINDING
case|:
operator|*
name|params
operator|=
name|getVertexArray
argument_list|()
operator|->
name|getElementArrayBufferId
argument_list|()
expr_stmt|;
break|break;
comment|//case GL_FRAMEBUFFER_BINDING:                    // now equivalent to GL_DRAW_FRAMEBUFFER_BINDING_ANGLE
case|case
name|GL_DRAW_FRAMEBUFFER_BINDING_ANGLE
case|:
operator|*
name|params
operator|=
name|mDrawFramebuffer
operator|->
name|id
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_READ_FRAMEBUFFER_BINDING_ANGLE
case|:
operator|*
name|params
operator|=
name|mReadFramebuffer
operator|->
name|id
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_RENDERBUFFER_BINDING
case|:
operator|*
name|params
operator|=
name|mRenderbuffer
operator|.
name|id
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_VERTEX_ARRAY_BINDING
case|:
operator|*
name|params
operator|=
name|mVertexArray
operator|->
name|id
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_CURRENT_PROGRAM
case|:
operator|*
name|params
operator|=
name|mProgram
condition|?
name|mProgram
operator|->
name|id
argument_list|()
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|GL_PACK_ALIGNMENT
case|:
operator|*
name|params
operator|=
name|mPack
operator|.
name|alignment
expr_stmt|;
break|break;
case|case
name|GL_PACK_REVERSE_ROW_ORDER_ANGLE
case|:
operator|*
name|params
operator|=
name|mPack
operator|.
name|reverseRowOrder
expr_stmt|;
break|break;
case|case
name|GL_UNPACK_ALIGNMENT
case|:
operator|*
name|params
operator|=
name|mUnpack
operator|.
name|alignment
expr_stmt|;
break|break;
case|case
name|GL_UNPACK_ROW_LENGTH
case|:
operator|*
name|params
operator|=
name|mUnpack
operator|.
name|rowLength
expr_stmt|;
break|break;
case|case
name|GL_GENERATE_MIPMAP_HINT
case|:
operator|*
name|params
operator|=
name|mGenerateMipmapHint
expr_stmt|;
break|break;
case|case
name|GL_FRAGMENT_SHADER_DERIVATIVE_HINT_OES
case|:
operator|*
name|params
operator|=
name|mFragmentShaderDerivativeHint
expr_stmt|;
break|break;
case|case
name|GL_ACTIVE_TEXTURE
case|:
operator|*
name|params
operator|=
operator|(
name|mActiveSampler
operator|+
name|GL_TEXTURE0
operator|)
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_FUNC
case|:
operator|*
name|params
operator|=
name|mDepthStencil
operator|.
name|stencilFunc
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_REF
case|:
operator|*
name|params
operator|=
name|mStencilRef
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_VALUE_MASK
case|:
operator|*
name|params
operator|=
name|clampToInt
argument_list|(
name|mDepthStencil
operator|.
name|stencilMask
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_BACK_FUNC
case|:
operator|*
name|params
operator|=
name|mDepthStencil
operator|.
name|stencilBackFunc
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_BACK_REF
case|:
operator|*
name|params
operator|=
name|mStencilBackRef
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_BACK_VALUE_MASK
case|:
operator|*
name|params
operator|=
name|clampToInt
argument_list|(
name|mDepthStencil
operator|.
name|stencilBackMask
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_FAIL
case|:
operator|*
name|params
operator|=
name|mDepthStencil
operator|.
name|stencilFail
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_PASS_DEPTH_FAIL
case|:
operator|*
name|params
operator|=
name|mDepthStencil
operator|.
name|stencilPassDepthFail
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_PASS_DEPTH_PASS
case|:
operator|*
name|params
operator|=
name|mDepthStencil
operator|.
name|stencilPassDepthPass
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_BACK_FAIL
case|:
operator|*
name|params
operator|=
name|mDepthStencil
operator|.
name|stencilBackFail
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_BACK_PASS_DEPTH_FAIL
case|:
operator|*
name|params
operator|=
name|mDepthStencil
operator|.
name|stencilBackPassDepthFail
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_BACK_PASS_DEPTH_PASS
case|:
operator|*
name|params
operator|=
name|mDepthStencil
operator|.
name|stencilBackPassDepthPass
expr_stmt|;
break|break;
case|case
name|GL_DEPTH_FUNC
case|:
operator|*
name|params
operator|=
name|mDepthStencil
operator|.
name|depthFunc
expr_stmt|;
break|break;
case|case
name|GL_BLEND_SRC_RGB
case|:
operator|*
name|params
operator|=
name|mBlend
operator|.
name|sourceBlendRGB
expr_stmt|;
break|break;
case|case
name|GL_BLEND_SRC_ALPHA
case|:
operator|*
name|params
operator|=
name|mBlend
operator|.
name|sourceBlendAlpha
expr_stmt|;
break|break;
case|case
name|GL_BLEND_DST_RGB
case|:
operator|*
name|params
operator|=
name|mBlend
operator|.
name|destBlendRGB
expr_stmt|;
break|break;
case|case
name|GL_BLEND_DST_ALPHA
case|:
operator|*
name|params
operator|=
name|mBlend
operator|.
name|destBlendAlpha
expr_stmt|;
break|break;
case|case
name|GL_BLEND_EQUATION_RGB
case|:
operator|*
name|params
operator|=
name|mBlend
operator|.
name|blendEquationRGB
expr_stmt|;
break|break;
case|case
name|GL_BLEND_EQUATION_ALPHA
case|:
operator|*
name|params
operator|=
name|mBlend
operator|.
name|blendEquationAlpha
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_WRITEMASK
case|:
operator|*
name|params
operator|=
name|clampToInt
argument_list|(
name|mDepthStencil
operator|.
name|stencilWritemask
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_BACK_WRITEMASK
case|:
operator|*
name|params
operator|=
name|clampToInt
argument_list|(
name|mDepthStencil
operator|.
name|stencilBackWritemask
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_CLEAR_VALUE
case|:
operator|*
name|params
operator|=
name|mStencilClearValue
expr_stmt|;
break|break;
case|case
name|GL_IMPLEMENTATION_COLOR_READ_TYPE
case|:
operator|*
name|params
operator|=
name|mReadFramebuffer
operator|->
name|getImplementationColorReadType
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_IMPLEMENTATION_COLOR_READ_FORMAT
case|:
operator|*
name|params
operator|=
name|mReadFramebuffer
operator|->
name|getImplementationColorReadFormat
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_SAMPLE_BUFFERS
case|:
case|case
name|GL_SAMPLES
case|:
block|{
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|mDrawFramebuffer
decl_stmt|;
if|if
condition|(
name|framebuffer
operator|->
name|checkStatus
argument_list|(
name|data
argument_list|)
operator|==
name|GL_FRAMEBUFFER_COMPLETE
condition|)
block|{
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_SAMPLE_BUFFERS
case|:
if|if
condition|(
name|framebuffer
operator|->
name|getSamples
argument_list|(
name|data
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|params
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|params
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|GL_SAMPLES
case|:
operator|*
name|params
operator|=
name|framebuffer
operator|->
name|getSamples
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
operator|*
name|params
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GL_VIEWPORT
case|:
name|params
index|[
literal|0
index|]
operator|=
name|mViewport
operator|.
name|x
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|mViewport
operator|.
name|y
expr_stmt|;
name|params
index|[
literal|2
index|]
operator|=
name|mViewport
operator|.
name|width
expr_stmt|;
name|params
index|[
literal|3
index|]
operator|=
name|mViewport
operator|.
name|height
expr_stmt|;
break|break;
case|case
name|GL_SCISSOR_BOX
case|:
name|params
index|[
literal|0
index|]
operator|=
name|mScissor
operator|.
name|x
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|mScissor
operator|.
name|y
expr_stmt|;
name|params
index|[
literal|2
index|]
operator|=
name|mScissor
operator|.
name|width
expr_stmt|;
name|params
index|[
literal|3
index|]
operator|=
name|mScissor
operator|.
name|height
expr_stmt|;
break|break;
case|case
name|GL_CULL_FACE_MODE
case|:
operator|*
name|params
operator|=
name|mRasterizer
operator|.
name|cullMode
expr_stmt|;
break|break;
case|case
name|GL_FRONT_FACE
case|:
operator|*
name|params
operator|=
name|mRasterizer
operator|.
name|frontFace
expr_stmt|;
break|break;
case|case
name|GL_RED_BITS
case|:
case|case
name|GL_GREEN_BITS
case|:
case|case
name|GL_BLUE_BITS
case|:
case|case
name|GL_ALPHA_BITS
case|:
block|{
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|colorbuffer
init|=
name|framebuffer
operator|->
name|getFirstColorbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|colorbuffer
condition|)
block|{
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_RED_BITS
case|:
operator|*
name|params
operator|=
name|colorbuffer
operator|->
name|getRedSize
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_GREEN_BITS
case|:
operator|*
name|params
operator|=
name|colorbuffer
operator|->
name|getGreenSize
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_BLUE_BITS
case|:
operator|*
name|params
operator|=
name|colorbuffer
operator|->
name|getBlueSize
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_ALPHA_BITS
case|:
operator|*
name|params
operator|=
name|colorbuffer
operator|->
name|getAlphaSize
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
operator|*
name|params
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GL_DEPTH_BITS
case|:
block|{
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|depthbuffer
init|=
name|framebuffer
operator|->
name|getDepthbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|depthbuffer
condition|)
block|{
operator|*
name|params
operator|=
name|depthbuffer
operator|->
name|getDepthSize
argument_list|()
expr_stmt|;
block|}
else|else
block|{
operator|*
name|params
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GL_STENCIL_BITS
case|:
block|{
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|stencilbuffer
init|=
name|framebuffer
operator|->
name|getStencilbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|stencilbuffer
condition|)
block|{
operator|*
name|params
operator|=
name|stencilbuffer
operator|->
name|getStencilSize
argument_list|()
expr_stmt|;
block|}
else|else
block|{
operator|*
name|params
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GL_TEXTURE_BINDING_2D
case|:
name|ASSERT
argument_list|(
name|mActiveSampler
operator|<
name|mMaxCombinedTextureImageUnits
argument_list|)
expr_stmt|;
operator|*
name|params
operator|=
name|getSamplerTextureId
argument_list|(
name|mActiveSampler
argument_list|,
name|GL_TEXTURE_2D
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_BINDING_CUBE_MAP
case|:
name|ASSERT
argument_list|(
name|mActiveSampler
operator|<
name|mMaxCombinedTextureImageUnits
argument_list|)
expr_stmt|;
operator|*
name|params
operator|=
name|getSamplerTextureId
argument_list|(
name|mActiveSampler
argument_list|,
name|GL_TEXTURE_CUBE_MAP
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_BINDING_3D
case|:
name|ASSERT
argument_list|(
name|mActiveSampler
operator|<
name|mMaxCombinedTextureImageUnits
argument_list|)
expr_stmt|;
operator|*
name|params
operator|=
name|getSamplerTextureId
argument_list|(
name|mActiveSampler
argument_list|,
name|GL_TEXTURE_3D
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_BINDING_2D_ARRAY
case|:
name|ASSERT
argument_list|(
name|mActiveSampler
operator|<
name|mMaxCombinedTextureImageUnits
argument_list|)
expr_stmt|;
operator|*
name|params
operator|=
name|getSamplerTextureId
argument_list|(
name|mActiveSampler
argument_list|,
name|GL_TEXTURE_2D_ARRAY
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_UNIFORM_BUFFER_BINDING
case|:
operator|*
name|params
operator|=
name|mGenericUniformBuffer
operator|.
name|id
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_TRANSFORM_FEEDBACK_BUFFER_BINDING
case|:
operator|*
name|params
operator|=
name|mGenericTransformFeedbackBuffer
operator|.
name|id
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_COPY_READ_BUFFER_BINDING
case|:
operator|*
name|params
operator|=
name|mCopyReadBuffer
operator|.
name|id
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_COPY_WRITE_BUFFER_BINDING
case|:
operator|*
name|params
operator|=
name|mCopyWriteBuffer
operator|.
name|id
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_PIXEL_PACK_BUFFER_BINDING
case|:
operator|*
name|params
operator|=
name|mPack
operator|.
name|pixelBuffer
operator|.
name|id
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_PIXEL_UNPACK_BUFFER_BINDING
case|:
operator|*
name|params
operator|=
name|mUnpack
operator|.
name|pixelBuffer
operator|.
name|id
argument_list|()
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
DECL|function|getIndexedIntegerv
name|bool
name|State
operator|::
name|getIndexedIntegerv
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLuint
name|index
parameter_list|,
name|GLint
modifier|*
name|data
parameter_list|)
block|{
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TRANSFORM_FEEDBACK_BUFFER_BINDING
case|:
if|if
condition|(
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|index
argument_list|)
operator|<
name|mTransformFeedbackBuffers
operator|.
name|size
argument_list|()
condition|)
block|{
operator|*
name|data
operator|=
name|mTransformFeedbackBuffers
index|[
name|index
index|]
operator|.
name|id
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|GL_UNIFORM_BUFFER_BINDING
case|:
if|if
condition|(
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|index
argument_list|)
operator|<
name|mUniformBuffers
operator|.
name|size
argument_list|()
condition|)
block|{
operator|*
name|data
operator|=
name|mUniformBuffers
index|[
name|index
index|]
operator|.
name|id
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|getIndexedInteger64v
name|bool
name|State
operator|::
name|getIndexedInteger64v
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLuint
name|index
parameter_list|,
name|GLint64
modifier|*
name|data
parameter_list|)
block|{
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TRANSFORM_FEEDBACK_BUFFER_START
case|:
if|if
condition|(
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|index
argument_list|)
operator|<
name|mTransformFeedbackBuffers
operator|.
name|size
argument_list|()
condition|)
block|{
operator|*
name|data
operator|=
name|mTransformFeedbackBuffers
index|[
name|index
index|]
operator|.
name|getOffset
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|GL_TRANSFORM_FEEDBACK_BUFFER_SIZE
case|:
if|if
condition|(
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|index
argument_list|)
operator|<
name|mTransformFeedbackBuffers
operator|.
name|size
argument_list|()
condition|)
block|{
operator|*
name|data
operator|=
name|mTransformFeedbackBuffers
index|[
name|index
index|]
operator|.
name|getSize
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|GL_UNIFORM_BUFFER_START
case|:
if|if
condition|(
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|index
argument_list|)
operator|<
name|mUniformBuffers
operator|.
name|size
argument_list|()
condition|)
block|{
operator|*
name|data
operator|=
name|mUniformBuffers
index|[
name|index
index|]
operator|.
name|getOffset
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|GL_UNIFORM_BUFFER_SIZE
case|:
if|if
condition|(
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|index
argument_list|)
operator|<
name|mUniformBuffers
operator|.
name|size
argument_list|()
condition|)
block|{
operator|*
name|data
operator|=
name|mUniformBuffers
index|[
name|index
index|]
operator|.
name|getSize
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|hasMappedBuffer
name|bool
name|State
operator|::
name|hasMappedBuffer
parameter_list|(
name|GLenum
name|target
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|target
operator|==
name|GL_ARRAY_BUFFER
condition|)
block|{
specifier|const
name|VertexArray
modifier|*
name|vao
init|=
name|getVertexArray
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|attribIndex
init|=
literal|0
init|;
name|attribIndex
operator|<
name|mVertexAttribCurrentValues
operator|.
name|size
argument_list|()
condition|;
name|attribIndex
operator|++
control|)
block|{
specifier|const
name|gl
operator|::
name|VertexAttribute
modifier|&
name|vertexAttrib
init|=
name|vao
operator|->
name|getVertexAttribute
argument_list|(
name|attribIndex
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Buffer
modifier|*
name|boundBuffer
init|=
name|vertexAttrib
operator|.
name|buffer
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|vertexAttrib
operator|.
name|enabled
operator|&&
name|boundBuffer
operator|&&
name|boundBuffer
operator|->
name|isMapped
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
else|else
block|{
name|Buffer
modifier|*
name|buffer
init|=
name|getTargetBuffer
argument_list|(
name|target
argument_list|)
decl_stmt|;
return|return
operator|(
name|buffer
operator|&&
name|buffer
operator|->
name|isMapped
argument_list|()
operator|)
return|;
block|}
block|}
block|}
end_namespace
end_unit
