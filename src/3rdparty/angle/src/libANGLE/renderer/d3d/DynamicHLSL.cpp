begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// DynamicHLSL.cpp: Implementation for link and run-time HLSL generation
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/DynamicHLSL.h"
end_include
begin_include
include|#
directive|include
file|"common/utilities.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/blocklayoutHLSL.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Program.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Shader.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/formatutils.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/ProgramD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/RendererD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/ShaderD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/VaryingPacking.h"
end_include
begin_using
using|using
namespace|namespace
name|gl
namespace|;
end_using
begin_namespace
DECL|namespace|rx
namespace|namespace
name|rx
block|{
namespace|namespace
block|{
DECL|function|HLSLComponentTypeString
name|std
operator|::
name|string
name|HLSLComponentTypeString
parameter_list|(
name|GLenum
name|componentType
parameter_list|)
block|{
switch|switch
condition|(
name|componentType
condition|)
block|{
case|case
name|GL_UNSIGNED_INT
case|:
return|return
literal|"uint"
return|;
case|case
name|GL_INT
case|:
return|return
literal|"int"
return|;
case|case
name|GL_UNSIGNED_NORMALIZED
case|:
case|case
name|GL_SIGNED_NORMALIZED
case|:
case|case
name|GL_FLOAT
case|:
return|return
literal|"float"
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|"not-component-type"
return|;
block|}
block|}
DECL|function|HLSLComponentTypeString
name|std
operator|::
name|string
name|HLSLComponentTypeString
parameter_list|(
name|GLenum
name|componentType
parameter_list|,
name|int
name|componentCount
parameter_list|)
block|{
return|return
name|HLSLComponentTypeString
argument_list|(
name|componentType
argument_list|)
operator|+
operator|(
name|componentCount
operator|>
literal|1
condition|?
name|Str
argument_list|(
name|componentCount
argument_list|)
else|:
literal|""
operator|)
return|;
block|}
DECL|function|HLSLMatrixTypeString
name|std
operator|::
name|string
name|HLSLMatrixTypeString
parameter_list|(
name|GLenum
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_FLOAT_MAT2
case|:
return|return
literal|"float2x2"
return|;
case|case
name|GL_FLOAT_MAT3
case|:
return|return
literal|"float3x3"
return|;
case|case
name|GL_FLOAT_MAT4
case|:
return|return
literal|"float4x4"
return|;
case|case
name|GL_FLOAT_MAT2x3
case|:
return|return
literal|"float2x3"
return|;
case|case
name|GL_FLOAT_MAT3x2
case|:
return|return
literal|"float3x2"
return|;
case|case
name|GL_FLOAT_MAT2x4
case|:
return|return
literal|"float2x4"
return|;
case|case
name|GL_FLOAT_MAT4x2
case|:
return|return
literal|"float4x2"
return|;
case|case
name|GL_FLOAT_MAT3x4
case|:
return|return
literal|"float3x4"
return|;
case|case
name|GL_FLOAT_MAT4x3
case|:
return|return
literal|"float4x3"
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|"not-matrix-type"
return|;
block|}
block|}
DECL|function|HLSLTypeString
name|std
operator|::
name|string
name|HLSLTypeString
parameter_list|(
name|GLenum
name|type
parameter_list|)
block|{
if|if
condition|(
name|gl
operator|::
name|IsMatrixType
argument_list|(
name|type
argument_list|)
condition|)
block|{
return|return
name|HLSLMatrixTypeString
argument_list|(
name|type
argument_list|)
return|;
block|}
return|return
name|HLSLComponentTypeString
argument_list|(
name|gl
operator|::
name|VariableComponentType
argument_list|(
name|type
argument_list|)
argument_list|,
name|gl
operator|::
name|VariableComponentCount
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
block|}
DECL|function|FindOutputAtLocation
specifier|const
name|PixelShaderOutputVariable
modifier|*
name|FindOutputAtLocation
parameter_list|(
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|PixelShaderOutputVariable
argument_list|>
modifier|&
name|outputVariables
parameter_list|,
name|unsigned
name|int
name|location
parameter_list|)
block|{
for|for
control|(
name|size_t
name|variableIndex
init|=
literal|0
init|;
name|variableIndex
operator|<
name|outputVariables
operator|.
name|size
argument_list|()
condition|;
operator|++
name|variableIndex
control|)
block|{
if|if
condition|(
name|outputVariables
index|[
name|variableIndex
index|]
operator|.
name|outputIndex
operator|==
name|location
condition|)
block|{
return|return
operator|&
name|outputVariables
index|[
name|variableIndex
index|]
return|;
block|}
block|}
return|return
literal|nullptr
return|;
block|}
DECL|function|WriteArrayString
name|void
name|WriteArrayString
parameter_list|(
name|std
operator|::
name|stringstream
modifier|&
name|strstr
parameter_list|,
name|unsigned
name|int
name|i
parameter_list|)
block|{
assert|static_assert
argument_list|(
name|GL_INVALID_INDEX
operator|==
name|UINT_MAX
argument_list|,
literal|"GL_INVALID_INDEX must be equal to the max unsigned int."
argument_list|)
assert|;
if|if
condition|(
name|i
operator|==
name|UINT_MAX
condition|)
block|{
return|return;
block|}
name|strstr
operator|<<
literal|"["
expr_stmt|;
name|strstr
operator|<<
name|i
expr_stmt|;
name|strstr
operator|<<
literal|"]"
expr_stmt|;
block|}
DECL|member|VERTEX_ATTRIBUTE_STUB_STRING
specifier|const
name|std
operator|::
name|string
name|VERTEX_ATTRIBUTE_STUB_STRING
init|=
literal|"@@ VERTEX ATTRIBUTES @@"
decl_stmt|;
DECL|member|PIXEL_OUTPUT_STUB_STRING
specifier|const
name|std
operator|::
name|string
name|PIXEL_OUTPUT_STUB_STRING
init|=
literal|"@@ PIXEL OUTPUT @@"
decl_stmt|;
block|}
comment|// anonymous namespace
DECL|function|GetVaryingSemantic
name|std
operator|::
name|string
name|GetVaryingSemantic
parameter_list|(
name|int
name|majorShaderModel
parameter_list|,
name|bool
name|programUsesPointSize
parameter_list|)
block|{
comment|// SM3 reserves the TEXCOORD semantic for point sprite texcoords (gl_PointCoord)
comment|// In D3D11 we manually compute gl_PointCoord in the GS.
return|return
operator|(
operator|(
name|programUsesPointSize
operator|&&
name|majorShaderModel
operator|<
literal|4
operator|)
condition|?
literal|"COLOR"
else|:
literal|"TEXCOORD"
operator|)
return|;
block|}
comment|// DynamicHLSL implementation
DECL|function|DynamicHLSL
name|DynamicHLSL
operator|::
name|DynamicHLSL
parameter_list|(
name|RendererD3D
modifier|*
specifier|const
name|renderer
parameter_list|)
member_init_list|:
name|mRenderer
argument_list|(
name|renderer
argument_list|)
block|{ }
DECL|function|generateVaryingHLSL
name|void
name|DynamicHLSL
operator|::
name|generateVaryingHLSL
parameter_list|(
specifier|const
name|VaryingPacking
modifier|&
name|varyingPacking
parameter_list|,
name|std
operator|::
name|stringstream
modifier|&
name|hlslStream
parameter_list|)
specifier|const
block|{
name|std
operator|::
name|string
name|varyingSemantic
init|=
name|GetVaryingSemantic
argument_list|(
name|mRenderer
operator|->
name|getMajorShaderModel
argument_list|()
argument_list|,
name|varyingPacking
operator|.
name|usesPointSize
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
specifier|const
name|PackedVaryingRegister
modifier|&
name|registerInfo
range|:
name|varyingPacking
operator|.
name|getRegisterList
argument_list|()
control|)
block|{
specifier|const
specifier|auto
modifier|&
name|varying
init|=
operator|*
name|registerInfo
operator|.
name|packedVarying
operator|->
name|varying
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|varying
operator|.
name|isStruct
argument_list|()
argument_list|)
expr_stmt|;
comment|// TODO: Add checks to ensure D3D interpolation modifiers don't result in too many
comment|// registers being used.
comment|// For example, if there are N registers, and we have N vec3 varyings and 1 float
comment|// varying, then D3D will pack them into N registers.
comment|// If the float varying has the 'nointerpolation' modifier on it then we would need
comment|// N + 1 registers, and D3D compilation will fail.
switch|switch
condition|(
name|registerInfo
operator|.
name|packedVarying
operator|->
name|interpolation
condition|)
block|{
case|case
name|sh
operator|::
name|INTERPOLATION_SMOOTH
case|:
name|hlslStream
operator|<<
literal|"    "
expr_stmt|;
break|break;
case|case
name|sh
operator|::
name|INTERPOLATION_FLAT
case|:
name|hlslStream
operator|<<
literal|"    nointerpolation "
expr_stmt|;
break|break;
case|case
name|sh
operator|::
name|INTERPOLATION_CENTROID
case|:
name|hlslStream
operator|<<
literal|"    centroid "
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
name|GLenum
name|transposedType
init|=
name|gl
operator|::
name|TransposeMatrixType
argument_list|(
name|varying
operator|.
name|type
argument_list|)
decl_stmt|;
name|GLenum
name|componentType
init|=
name|gl
operator|::
name|VariableComponentType
argument_list|(
name|transposedType
argument_list|)
decl_stmt|;
name|int
name|columnCount
init|=
name|gl
operator|::
name|VariableColumnCount
argument_list|(
name|transposedType
argument_list|)
decl_stmt|;
name|hlslStream
operator|<<
name|HLSLComponentTypeString
argument_list|(
name|componentType
argument_list|,
name|columnCount
argument_list|)
expr_stmt|;
name|unsigned
name|int
name|semanticIndex
init|=
name|registerInfo
operator|.
name|semanticIndex
decl_stmt|;
name|hlslStream
operator|<<
literal|" v"
operator|<<
name|semanticIndex
operator|<<
literal|" : "
operator|<<
name|varyingSemantic
operator|<<
name|semanticIndex
operator|<<
literal|";\n"
expr_stmt|;
block|}
block|}
DECL|function|generateVertexShaderForInputLayout
name|std
operator|::
name|string
name|DynamicHLSL
operator|::
name|generateVertexShaderForInputLayout
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|sourceShader
parameter_list|,
specifier|const
name|InputLayout
modifier|&
name|inputLayout
parameter_list|,
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|Attribute
argument_list|>
modifier|&
name|shaderAttributes
parameter_list|)
specifier|const
block|{
name|std
operator|::
name|stringstream
name|structStream
decl_stmt|;
name|std
operator|::
name|stringstream
name|initStream
decl_stmt|;
name|structStream
operator|<<
literal|"struct VS_INPUT\n"
operator|<<
literal|"{\n"
expr_stmt|;
name|int
name|semanticIndex
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|inputIndex
init|=
literal|0
decl_stmt|;
comment|// If gl_PointSize is used in the shader then pointsprites rendering is expected.
comment|// If the renderer does not support Geometry shaders then Instanced PointSprite emulation
comment|// must be used.
name|bool
name|usesPointSize
init|=
name|sourceShader
operator|.
name|find
argument_list|(
literal|"GL_USES_POINT_SIZE"
argument_list|)
operator|!=
name|std
operator|::
name|string
operator|::
name|npos
decl_stmt|;
name|bool
name|useInstancedPointSpriteEmulation
init|=
name|usesPointSize
operator|&&
name|mRenderer
operator|->
name|getWorkarounds
argument_list|()
operator|.
name|useInstancedPointSpriteEmulation
decl_stmt|;
comment|// Instanced PointSprite emulation requires additional entries in the
comment|// VS_INPUT structure to support the vertices that make up the quad vertices.
comment|// These values must be in sync with the cooresponding values added during inputlayout creation
comment|// in InputLayoutCache::applyVertexBuffers().
comment|//
comment|// The additional entries must appear first in the VS_INPUT layout because
comment|// Windows Phone 8 era devices require per vertex data to physically come
comment|// before per instance data in the shader.
if|if
condition|(
name|useInstancedPointSpriteEmulation
condition|)
block|{
name|structStream
operator|<<
literal|"    float3 spriteVertexPos : SPRITEPOSITION0;\n"
operator|<<
literal|"    float2 spriteTexCoord : SPRITETEXCOORD0;\n"
expr_stmt|;
block|}
for|for
control|(
name|size_t
name|attributeIndex
init|=
literal|0
init|;
name|attributeIndex
operator|<
name|shaderAttributes
operator|.
name|size
argument_list|()
condition|;
operator|++
name|attributeIndex
control|)
block|{
specifier|const
name|sh
operator|::
name|Attribute
modifier|&
name|shaderAttribute
init|=
name|shaderAttributes
index|[
name|attributeIndex
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|shaderAttribute
operator|.
name|name
operator|.
name|empty
argument_list|()
condition|)
block|{
name|ASSERT
argument_list|(
name|inputIndex
operator|<
name|MAX_VERTEX_ATTRIBS
argument_list|)
expr_stmt|;
name|VertexFormatType
name|vertexFormatType
init|=
name|inputIndex
operator|<
name|inputLayout
operator|.
name|size
argument_list|()
condition|?
name|inputLayout
index|[
name|inputIndex
index|]
else|:
name|VERTEX_FORMAT_INVALID
decl_stmt|;
comment|// HLSL code for input structure
if|if
condition|(
name|IsMatrixType
argument_list|(
name|shaderAttribute
operator|.
name|type
argument_list|)
condition|)
block|{
comment|// Matrix types are always transposed
name|structStream
operator|<<
literal|"    "
operator|<<
name|HLSLMatrixTypeString
argument_list|(
name|TransposeMatrixType
argument_list|(
name|shaderAttribute
operator|.
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|GLenum
name|componentType
init|=
name|mRenderer
operator|->
name|getVertexComponentType
argument_list|(
name|vertexFormatType
argument_list|)
decl_stmt|;
if|if
condition|(
name|shaderAttribute
operator|.
name|name
operator|==
literal|"gl_InstanceID"
condition|)
block|{
comment|// The input type of the instance ID in HLSL (uint) differs from the one in ESSL
comment|// (int).
name|structStream
operator|<<
literal|" uint"
expr_stmt|;
block|}
else|else
block|{
name|structStream
operator|<<
literal|"    "
operator|<<
name|HLSLComponentTypeString
argument_list|(
name|componentType
argument_list|,
name|VariableComponentCount
argument_list|(
name|shaderAttribute
operator|.
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|structStream
operator|<<
literal|" "
operator|<<
name|decorateVariable
argument_list|(
name|shaderAttribute
operator|.
name|name
argument_list|)
operator|<<
literal|" : "
expr_stmt|;
if|if
condition|(
name|shaderAttribute
operator|.
name|name
operator|==
literal|"gl_InstanceID"
condition|)
block|{
name|structStream
operator|<<
literal|"SV_InstanceID"
expr_stmt|;
block|}
else|else
block|{
name|structStream
operator|<<
literal|"TEXCOORD"
operator|<<
name|semanticIndex
expr_stmt|;
name|semanticIndex
operator|+=
name|VariableRegisterCount
argument_list|(
name|shaderAttribute
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
name|structStream
operator|<<
literal|";\n"
expr_stmt|;
comment|// HLSL code for initialization
name|initStream
operator|<<
literal|"    "
operator|<<
name|decorateVariable
argument_list|(
name|shaderAttribute
operator|.
name|name
argument_list|)
operator|<<
literal|" = "
expr_stmt|;
comment|// Mismatched vertex attribute to vertex input may result in an undefined
comment|// data reinterpretation (eg for pure integer->float, float->pure integer)
comment|// TODO: issue warning with gl debug info extension, when supported
if|if
condition|(
name|IsMatrixType
argument_list|(
name|shaderAttribute
operator|.
name|type
argument_list|)
operator|||
operator|(
name|mRenderer
operator|->
name|getVertexConversionType
argument_list|(
name|vertexFormatType
argument_list|)
operator|&
name|VERTEX_CONVERT_GPU
operator|)
operator|!=
literal|0
condition|)
block|{
name|initStream
operator|<<
name|generateAttributeConversionHLSL
argument_list|(
name|vertexFormatType
argument_list|,
name|shaderAttribute
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|initStream
operator|<<
literal|"input."
operator|<<
name|decorateVariable
argument_list|(
name|shaderAttribute
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|initStream
operator|<<
literal|";\n"
expr_stmt|;
name|inputIndex
operator|+=
name|VariableRowCount
argument_list|(
name|TransposeMatrixType
argument_list|(
name|shaderAttribute
operator|.
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|structStream
operator|<<
literal|"};\n"
literal|"\n"
literal|"void initAttributes(VS_INPUT input)\n"
literal|"{\n"
operator|<<
name|initStream
operator|.
name|str
argument_list|()
operator|<<
literal|"}\n"
expr_stmt|;
name|std
operator|::
name|string
name|vertexHLSL
argument_list|(
name|sourceShader
argument_list|)
decl_stmt|;
name|size_t
name|copyInsertionPos
init|=
name|vertexHLSL
operator|.
name|find
argument_list|(
name|VERTEX_ATTRIBUTE_STUB_STRING
argument_list|)
decl_stmt|;
name|vertexHLSL
operator|.
name|replace
argument_list|(
name|copyInsertionPos
argument_list|,
name|VERTEX_ATTRIBUTE_STUB_STRING
operator|.
name|length
argument_list|()
argument_list|,
name|structStream
operator|.
name|str
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|vertexHLSL
return|;
block|}
DECL|function|generatePixelShaderForOutputSignature
name|std
operator|::
name|string
name|DynamicHLSL
operator|::
name|generatePixelShaderForOutputSignature
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|sourceShader
parameter_list|,
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|PixelShaderOutputVariable
argument_list|>
modifier|&
name|outputVariables
parameter_list|,
name|bool
name|usesFragDepth
parameter_list|,
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|GLenum
argument_list|>
modifier|&
name|outputLayout
parameter_list|)
specifier|const
block|{
specifier|const
name|int
name|shaderModel
init|=
name|mRenderer
operator|->
name|getMajorShaderModel
argument_list|()
decl_stmt|;
name|std
operator|::
name|string
name|targetSemantic
init|=
operator|(
name|shaderModel
operator|>=
literal|4
operator|)
condition|?
literal|"SV_TARGET"
else|:
literal|"COLOR"
decl_stmt|;
name|std
operator|::
name|string
name|depthSemantic
init|=
operator|(
name|shaderModel
operator|>=
literal|4
operator|)
condition|?
literal|"SV_Depth"
else|:
literal|"DEPTH"
decl_stmt|;
name|std
operator|::
name|stringstream
name|declarationStream
decl_stmt|;
name|std
operator|::
name|stringstream
name|copyStream
decl_stmt|;
name|declarationStream
operator|<<
literal|"struct PS_OUTPUT\n"
literal|"{\n"
expr_stmt|;
for|for
control|(
name|size_t
name|layoutIndex
init|=
literal|0
init|;
name|layoutIndex
operator|<
name|outputLayout
operator|.
name|size
argument_list|()
condition|;
operator|++
name|layoutIndex
control|)
block|{
name|GLenum
name|binding
init|=
name|outputLayout
index|[
name|layoutIndex
index|]
decl_stmt|;
if|if
condition|(
name|binding
operator|!=
name|GL_NONE
condition|)
block|{
name|unsigned
name|int
name|location
init|=
operator|(
name|binding
operator|-
name|GL_COLOR_ATTACHMENT0
operator|)
decl_stmt|;
specifier|const
name|PixelShaderOutputVariable
modifier|*
name|outputVariable
init|=
name|FindOutputAtLocation
argument_list|(
name|outputVariables
argument_list|,
name|location
argument_list|)
decl_stmt|;
comment|// OpenGL ES 3.0 spec $4.2.1
comment|// If [...] not all user-defined output variables are written, the values of fragment
comment|// colors
comment|// corresponding to unwritten variables are similarly undefined.
if|if
condition|(
name|outputVariable
condition|)
block|{
name|declarationStream
operator|<<
literal|"    "
operator|+
name|HLSLTypeString
argument_list|(
name|outputVariable
operator|->
name|type
argument_list|)
operator|<<
literal|" "
operator|<<
name|outputVariable
operator|->
name|name
operator|<<
literal|" : "
operator|<<
name|targetSemantic
operator|<<
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|layoutIndex
argument_list|)
operator|<<
literal|";\n"
expr_stmt|;
name|copyStream
operator|<<
literal|"    output."
operator|<<
name|outputVariable
operator|->
name|name
operator|<<
literal|" = "
operator|<<
name|outputVariable
operator|->
name|source
operator|<<
literal|";\n"
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|usesFragDepth
condition|)
block|{
name|declarationStream
operator|<<
literal|"    float gl_Depth : "
operator|<<
name|depthSemantic
operator|<<
literal|";\n"
expr_stmt|;
name|copyStream
operator|<<
literal|"    output.gl_Depth = gl_Depth; \n"
expr_stmt|;
block|}
name|declarationStream
operator|<<
literal|"};\n"
literal|"\n"
literal|"PS_OUTPUT generateOutput()\n"
literal|"{\n"
literal|"    PS_OUTPUT output;\n"
operator|<<
name|copyStream
operator|.
name|str
argument_list|()
operator|<<
literal|"    return output;\n"
literal|"}\n"
expr_stmt|;
name|std
operator|::
name|string
name|pixelHLSL
argument_list|(
name|sourceShader
argument_list|)
decl_stmt|;
name|size_t
name|outputInsertionPos
init|=
name|pixelHLSL
operator|.
name|find
argument_list|(
name|PIXEL_OUTPUT_STUB_STRING
argument_list|)
decl_stmt|;
name|pixelHLSL
operator|.
name|replace
argument_list|(
name|outputInsertionPos
argument_list|,
name|PIXEL_OUTPUT_STUB_STRING
operator|.
name|length
argument_list|()
argument_list|,
name|declarationStream
operator|.
name|str
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|pixelHLSL
return|;
block|}
DECL|function|generateVaryingLinkHLSL
name|void
name|DynamicHLSL
operator|::
name|generateVaryingLinkHLSL
parameter_list|(
name|ShaderType
name|shaderType
parameter_list|,
specifier|const
name|VaryingPacking
modifier|&
name|varyingPacking
parameter_list|,
name|std
operator|::
name|stringstream
modifier|&
name|linkStream
parameter_list|)
specifier|const
block|{
specifier|const
specifier|auto
modifier|&
name|builtins
init|=
name|varyingPacking
operator|.
name|builtins
argument_list|(
name|shaderType
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|builtins
operator|.
name|dxPosition
operator|.
name|enabled
argument_list|)
expr_stmt|;
name|linkStream
operator|<<
literal|"{\n"
operator|<<
literal|"    float4 dx_Position : "
operator|<<
name|builtins
operator|.
name|dxPosition
operator|.
name|str
argument_list|()
operator|<<
literal|";\n"
expr_stmt|;
if|if
condition|(
name|builtins
operator|.
name|glPosition
operator|.
name|enabled
condition|)
block|{
name|linkStream
operator|<<
literal|"    float4 gl_Position : "
operator|<<
name|builtins
operator|.
name|glPosition
operator|.
name|str
argument_list|()
operator|<<
literal|";\n"
expr_stmt|;
block|}
if|if
condition|(
name|builtins
operator|.
name|glFragCoord
operator|.
name|enabled
condition|)
block|{
name|linkStream
operator|<<
literal|"    float4 gl_FragCoord : "
operator|<<
name|builtins
operator|.
name|glFragCoord
operator|.
name|str
argument_list|()
operator|<<
literal|";\n"
expr_stmt|;
block|}
if|if
condition|(
name|builtins
operator|.
name|glPointCoord
operator|.
name|enabled
condition|)
block|{
name|linkStream
operator|<<
literal|"    float2 gl_PointCoord : "
operator|<<
name|builtins
operator|.
name|glPointCoord
operator|.
name|str
argument_list|()
operator|<<
literal|";\n"
expr_stmt|;
block|}
if|if
condition|(
name|builtins
operator|.
name|glPointSize
operator|.
name|enabled
condition|)
block|{
name|linkStream
operator|<<
literal|"    float gl_PointSize : "
operator|<<
name|builtins
operator|.
name|glPointSize
operator|.
name|str
argument_list|()
operator|<<
literal|";\n"
expr_stmt|;
block|}
comment|// Do this after glPointSize, to potentially combine gl_PointCoord and gl_PointSize into the
comment|// same register.
name|generateVaryingHLSL
argument_list|(
name|varyingPacking
argument_list|,
name|linkStream
argument_list|)
expr_stmt|;
name|linkStream
operator|<<
literal|"};\n"
expr_stmt|;
block|}
DECL|function|generateShaderLinkHLSL
name|bool
name|DynamicHLSL
operator|::
name|generateShaderLinkHLSL
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
specifier|const
name|gl
operator|::
name|Program
operator|::
name|Data
modifier|&
name|programData
parameter_list|,
specifier|const
name|ProgramD3DMetadata
modifier|&
name|programMetadata
parameter_list|,
specifier|const
name|VaryingPacking
modifier|&
name|varyingPacking
parameter_list|,
name|std
operator|::
name|string
modifier|*
name|pixelHLSL
parameter_list|,
name|std
operator|::
name|string
modifier|*
name|vertexHLSL
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|pixelHLSL
operator|->
name|empty
argument_list|()
operator|&&
name|vertexHLSL
operator|->
name|empty
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|gl
operator|::
name|Shader
modifier|*
name|vertexShaderGL
init|=
name|programData
operator|.
name|getAttachedVertexShader
argument_list|()
decl_stmt|;
specifier|const
name|ShaderD3D
modifier|*
name|vertexShader
init|=
name|GetImplAs
argument_list|<
name|ShaderD3D
argument_list|>
argument_list|(
name|vertexShaderGL
argument_list|)
decl_stmt|;
specifier|const
name|gl
operator|::
name|Shader
modifier|*
name|fragmentShaderGL
init|=
name|programData
operator|.
name|getAttachedFragmentShader
argument_list|()
decl_stmt|;
specifier|const
name|ShaderD3D
modifier|*
name|fragmentShader
init|=
name|GetImplAs
argument_list|<
name|ShaderD3D
argument_list|>
argument_list|(
name|fragmentShaderGL
argument_list|)
decl_stmt|;
specifier|const
name|int
name|shaderModel
init|=
name|mRenderer
operator|->
name|getMajorShaderModel
argument_list|()
decl_stmt|;
comment|// usesViewScale() isn't supported in the D3D9 renderer
name|ASSERT
argument_list|(
name|shaderModel
operator|>=
literal|4
operator|||
operator|!
name|programMetadata
operator|.
name|usesViewScale
argument_list|()
argument_list|)
expr_stmt|;
name|bool
name|useInstancedPointSpriteEmulation
init|=
name|programMetadata
operator|.
name|usesPointSize
argument_list|()
operator|&&
name|mRenderer
operator|->
name|getWorkarounds
argument_list|()
operator|.
name|useInstancedPointSpriteEmulation
decl_stmt|;
comment|// Validation done in the compiler
name|ASSERT
argument_list|(
operator|!
name|fragmentShader
operator|->
name|usesFragColor
argument_list|()
operator|||
operator|!
name|fragmentShader
operator|->
name|usesFragData
argument_list|()
argument_list|)
expr_stmt|;
name|std
operator|::
name|stringstream
name|vertexStream
decl_stmt|;
name|vertexStream
operator|<<
name|vertexShaderGL
operator|->
name|getTranslatedSource
argument_list|()
expr_stmt|;
comment|// Instanced PointSprite emulation requires additional entries originally generated in the
comment|// GeometryShader HLSL. These include pointsize clamp values.
if|if
condition|(
name|useInstancedPointSpriteEmulation
condition|)
block|{
name|vertexStream
operator|<<
literal|"static float minPointSize = "
operator|<<
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|data
operator|.
name|caps
operator|->
name|minAliasedPointSize
argument_list|)
operator|<<
literal|".0f;\n"
operator|<<
literal|"static float maxPointSize = "
operator|<<
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|data
operator|.
name|caps
operator|->
name|maxAliasedPointSize
argument_list|)
operator|<<
literal|".0f;\n"
expr_stmt|;
block|}
comment|// Add stub string to be replaced when shader is dynamically defined by its layout
name|vertexStream
operator|<<
literal|"\n"
operator|<<
name|VERTEX_ATTRIBUTE_STUB_STRING
operator|+
literal|"\n"
expr_stmt|;
comment|// Write the HLSL input/output declarations
name|vertexStream
operator|<<
literal|"struct VS_OUTPUT\n"
expr_stmt|;
name|generateVaryingLinkHLSL
argument_list|(
name|SHADER_VERTEX
argument_list|,
name|varyingPacking
argument_list|,
name|vertexStream
argument_list|)
expr_stmt|;
name|vertexStream
operator|<<
literal|"\n"
operator|<<
literal|"VS_OUTPUT main(VS_INPUT input)\n"
operator|<<
literal|"{\n"
operator|<<
literal|"    initAttributes(input);\n"
expr_stmt|;
if|if
condition|(
name|vertexShader
operator|->
name|usesDeferredInit
argument_list|()
condition|)
block|{
name|vertexStream
operator|<<
literal|"\n"
operator|<<
literal|"    initializeDeferredGlobals();\n"
expr_stmt|;
block|}
name|vertexStream
operator|<<
literal|"\n"
operator|<<
literal|"    gl_main();\n"
operator|<<
literal|"\n"
operator|<<
literal|"    VS_OUTPUT output;\n"
expr_stmt|;
specifier|const
specifier|auto
modifier|&
name|vertexBuiltins
init|=
name|varyingPacking
operator|.
name|builtins
argument_list|(
name|SHADER_VERTEX
argument_list|)
decl_stmt|;
if|if
condition|(
name|vertexBuiltins
operator|.
name|glPosition
operator|.
name|enabled
condition|)
block|{
name|vertexStream
operator|<<
literal|"    output.gl_Position = gl_Position;\n"
expr_stmt|;
block|}
comment|// On D3D9 or D3D11 Feature Level 9, we need to emulate large viewports using dx_ViewAdjust.
if|if
condition|(
name|shaderModel
operator|>=
literal|4
operator|&&
name|mRenderer
operator|->
name|getShaderModelSuffix
argument_list|()
operator|==
literal|""
condition|)
block|{
name|vertexStream
operator|<<
literal|"    output.dx_Position.x = gl_Position.x;\n"
expr_stmt|;
if|if
condition|(
name|programMetadata
operator|.
name|usesViewScale
argument_list|()
condition|)
block|{
comment|// This code assumes that dx_ViewScale.y = -1.0f when rendering to texture, and +1.0f
comment|// when rendering to the default framebuffer. No other values are valid.
name|vertexStream
operator|<<
literal|"    output.dx_Position.y = dx_ViewScale.y * gl_Position.y;\n"
expr_stmt|;
block|}
else|else
block|{
name|vertexStream
operator|<<
literal|"    output.dx_Position.y = - gl_Position.y;\n"
expr_stmt|;
block|}
name|vertexStream
operator|<<
literal|"    output.dx_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\n"
operator|<<
literal|"    output.dx_Position.w = gl_Position.w;\n"
expr_stmt|;
block|}
else|else
block|{
name|vertexStream
operator|<<
literal|"    output.dx_Position.x = gl_Position.x * dx_ViewAdjust.z + "
literal|"dx_ViewAdjust.x * gl_Position.w;\n"
expr_stmt|;
comment|// If usesViewScale() is true and we're using the D3D11 renderer via Feature Level 9_*,
comment|// then we need to multiply the gl_Position.y by the viewScale.
comment|// usesViewScale() isn't supported when using the D3D9 renderer.
if|if
condition|(
name|programMetadata
operator|.
name|usesViewScale
argument_list|()
operator|&&
operator|(
name|shaderModel
operator|>=
literal|4
operator|&&
name|mRenderer
operator|->
name|getShaderModelSuffix
argument_list|()
operator|!=
literal|""
operator|)
condition|)
block|{
name|vertexStream
operator|<<
literal|"    output.dx_Position.y = dx_ViewScale.y * (gl_Position.y * "
literal|"dx_ViewAdjust.w + dx_ViewAdjust.y * gl_Position.w);\n"
expr_stmt|;
block|}
else|else
block|{
name|vertexStream
operator|<<
literal|"    output.dx_Position.y = -(gl_Position.y * dx_ViewAdjust.w + "
literal|"dx_ViewAdjust.y * gl_Position.w);\n"
expr_stmt|;
block|}
name|vertexStream
operator|<<
literal|"    output.dx_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\n"
operator|<<
literal|"    output.dx_Position.w = gl_Position.w;\n"
expr_stmt|;
block|}
comment|// We don't need to output gl_PointSize if we use are emulating point sprites via instancing.
if|if
condition|(
name|vertexBuiltins
operator|.
name|glPointSize
operator|.
name|enabled
condition|)
block|{
name|vertexStream
operator|<<
literal|"    output.gl_PointSize = gl_PointSize;\n"
expr_stmt|;
block|}
if|if
condition|(
name|vertexBuiltins
operator|.
name|glFragCoord
operator|.
name|enabled
condition|)
block|{
name|vertexStream
operator|<<
literal|"    output.gl_FragCoord = gl_Position;\n"
expr_stmt|;
block|}
for|for
control|(
specifier|const
name|PackedVaryingRegister
modifier|&
name|registerInfo
range|:
name|varyingPacking
operator|.
name|getRegisterList
argument_list|()
control|)
block|{
specifier|const
specifier|auto
modifier|&
name|packedVarying
init|=
operator|*
name|registerInfo
operator|.
name|packedVarying
decl_stmt|;
specifier|const
specifier|auto
modifier|&
name|varying
init|=
operator|*
name|packedVarying
operator|.
name|varying
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|varying
operator|.
name|isStruct
argument_list|()
argument_list|)
expr_stmt|;
name|vertexStream
operator|<<
literal|"    output.v"
operator|<<
name|registerInfo
operator|.
name|semanticIndex
operator|<<
literal|" = "
expr_stmt|;
if|if
condition|(
name|packedVarying
operator|.
name|isStructField
argument_list|()
condition|)
block|{
name|vertexStream
operator|<<
name|decorateVariable
argument_list|(
name|packedVarying
operator|.
name|parentStructName
argument_list|)
operator|<<
literal|"."
expr_stmt|;
block|}
name|vertexStream
operator|<<
name|decorateVariable
argument_list|(
name|varying
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|varying
operator|.
name|isArray
argument_list|()
condition|)
block|{
name|WriteArrayString
argument_list|(
name|vertexStream
argument_list|,
name|registerInfo
operator|.
name|varyingArrayIndex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|VariableRowCount
argument_list|(
name|varying
operator|.
name|type
argument_list|)
operator|>
literal|1
condition|)
block|{
name|WriteArrayString
argument_list|(
name|vertexStream
argument_list|,
name|registerInfo
operator|.
name|varyingRowIndex
argument_list|)
expr_stmt|;
block|}
name|vertexStream
operator|<<
literal|";\n"
expr_stmt|;
block|}
comment|// Instanced PointSprite emulation requires additional entries to calculate
comment|// the final output vertex positions of the quad that represents each sprite.
if|if
condition|(
name|useInstancedPointSpriteEmulation
condition|)
block|{
name|vertexStream
operator|<<
literal|"\n"
operator|<<
literal|"    gl_PointSize = clamp(gl_PointSize, minPointSize, maxPointSize);\n"
expr_stmt|;
name|vertexStream
operator|<<
literal|"    output.dx_Position.x += (input.spriteVertexPos.x * gl_PointSize / "
literal|"(dx_ViewCoords.x*2)) * output.dx_Position.w;"
expr_stmt|;
if|if
condition|(
name|programMetadata
operator|.
name|usesViewScale
argument_list|()
condition|)
block|{
comment|// Multiply by ViewScale to invert the rendering when appropriate
name|vertexStream
operator|<<
literal|"    output.dx_Position.y += (-dx_ViewScale.y * "
literal|"input.spriteVertexPos.y * gl_PointSize / (dx_ViewCoords.y*2)) * "
literal|"output.dx_Position.w;"
expr_stmt|;
block|}
else|else
block|{
name|vertexStream
operator|<<
literal|"    output.dx_Position.y += (input.spriteVertexPos.y * gl_PointSize / "
literal|"(dx_ViewCoords.y*2)) * output.dx_Position.w;"
expr_stmt|;
block|}
name|vertexStream
operator|<<
literal|"    output.dx_Position.z += input.spriteVertexPos.z * output.dx_Position.w;\n"
expr_stmt|;
if|if
condition|(
name|programMetadata
operator|.
name|usesPointCoord
argument_list|()
condition|)
block|{
name|vertexStream
operator|<<
literal|"\n"
operator|<<
literal|"    output.gl_PointCoord = input.spriteTexCoord;\n"
expr_stmt|;
block|}
block|}
comment|// Renderers that enable instanced pointsprite emulation require the vertex shader output member
comment|// gl_PointCoord to be set to a default value if used without gl_PointSize. 0.5,0.5 is the same
comment|// default value used in the generated pixel shader.
if|if
condition|(
name|programMetadata
operator|.
name|usesInsertedPointCoordValue
argument_list|()
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|useInstancedPointSpriteEmulation
argument_list|)
expr_stmt|;
name|vertexStream
operator|<<
literal|"\n"
operator|<<
literal|"    output.gl_PointCoord = float2(0.5, 0.5);\n"
expr_stmt|;
block|}
name|vertexStream
operator|<<
literal|"\n"
operator|<<
literal|"    return output;\n"
operator|<<
literal|"}\n"
expr_stmt|;
name|std
operator|::
name|stringstream
name|pixelStream
decl_stmt|;
name|pixelStream
operator|<<
name|fragmentShaderGL
operator|->
name|getTranslatedSource
argument_list|()
expr_stmt|;
name|pixelStream
operator|<<
literal|"struct PS_INPUT\n"
expr_stmt|;
name|generateVaryingLinkHLSL
argument_list|(
name|SHADER_PIXEL
argument_list|,
name|varyingPacking
argument_list|,
name|pixelStream
argument_list|)
expr_stmt|;
name|pixelStream
operator|<<
literal|"\n"
expr_stmt|;
name|pixelStream
operator|<<
name|PIXEL_OUTPUT_STUB_STRING
operator|+
literal|"\n"
expr_stmt|;
if|if
condition|(
name|fragmentShader
operator|->
name|usesFrontFacing
argument_list|()
condition|)
block|{
if|if
condition|(
name|shaderModel
operator|>=
literal|4
condition|)
block|{
name|pixelStream
operator|<<
literal|"PS_OUTPUT main(PS_INPUT input, bool isFrontFace : SV_IsFrontFace)\n"
operator|<<
literal|"{\n"
expr_stmt|;
block|}
else|else
block|{
name|pixelStream
operator|<<
literal|"PS_OUTPUT main(PS_INPUT input, float vFace : VFACE)\n"
operator|<<
literal|"{\n"
expr_stmt|;
block|}
block|}
else|else
block|{
name|pixelStream
operator|<<
literal|"PS_OUTPUT main(PS_INPUT input)\n"
operator|<<
literal|"{\n"
expr_stmt|;
block|}
specifier|const
specifier|auto
modifier|&
name|pixelBuiltins
init|=
name|varyingPacking
operator|.
name|builtins
argument_list|(
name|SHADER_PIXEL
argument_list|)
decl_stmt|;
if|if
condition|(
name|pixelBuiltins
operator|.
name|glFragCoord
operator|.
name|enabled
condition|)
block|{
name|pixelStream
operator|<<
literal|"    float rhw = 1.0 / input.gl_FragCoord.w;\n"
expr_stmt|;
comment|// Certain Shader Models (4_0+ and 3_0) allow reading from dx_Position in the pixel shader.
comment|// Other Shader Models (4_0_level_9_3 and 2_x) don't support this, so we emulate it using
comment|// dx_ViewCoords.
if|if
condition|(
name|shaderModel
operator|>=
literal|4
operator|&&
name|mRenderer
operator|->
name|getShaderModelSuffix
argument_list|()
operator|==
literal|""
condition|)
block|{
name|pixelStream
operator|<<
literal|"    gl_FragCoord.x = input.dx_Position.x;\n"
operator|<<
literal|"    gl_FragCoord.y = input.dx_Position.y;\n"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shaderModel
operator|==
literal|3
condition|)
block|{
name|pixelStream
operator|<<
literal|"    gl_FragCoord.x = input.dx_Position.x + 0.5;\n"
operator|<<
literal|"    gl_FragCoord.y = input.dx_Position.y + 0.5;\n"
expr_stmt|;
block|}
else|else
block|{
comment|// dx_ViewCoords contains the viewport width/2, height/2, center.x and center.y. See
comment|// Renderer::setViewport()
name|pixelStream
operator|<<
literal|"    gl_FragCoord.x = (input.gl_FragCoord.x * rhw) * dx_ViewCoords.x + "
literal|"dx_ViewCoords.z;\n"
operator|<<
literal|"    gl_FragCoord.y = (input.gl_FragCoord.y * rhw) * dx_ViewCoords.y + "
literal|"dx_ViewCoords.w;\n"
expr_stmt|;
block|}
if|if
condition|(
name|programMetadata
operator|.
name|usesViewScale
argument_list|()
condition|)
block|{
comment|// For Feature Level 9_3 and below, we need to correct gl_FragCoord.y to account
comment|// for dx_ViewScale. On Feature Level 10_0+, gl_FragCoord.y is calculated above using
comment|// dx_ViewCoords and is always correct irrespective of dx_ViewScale's value.
comment|// NOTE: usesViewScale() can only be true on D3D11 (i.e. Shader Model 4.0+).
if|if
condition|(
name|shaderModel
operator|>=
literal|4
operator|&&
name|mRenderer
operator|->
name|getShaderModelSuffix
argument_list|()
operator|==
literal|""
condition|)
block|{
comment|// Some assumptions:
comment|//  - dx_ViewScale.y = -1.0f when rendering to texture
comment|//  - dx_ViewScale.y = +1.0f when rendering to the default framebuffer
comment|//  - gl_FragCoord.y has been set correctly above.
comment|//
comment|// When rendering to the backbuffer, the code inverts gl_FragCoord's y coordinate.
comment|// This involves subtracting the y coordinate from the height of the area being
comment|// rendered to.
comment|//
comment|// First we calculate the height of the area being rendered to:
comment|//    render_area_height = (2.0f / (1.0f - input.gl_FragCoord.y * rhw)) *
comment|//    gl_FragCoord.y
comment|//
comment|// Note that when we're rendering to default FB, we want our output to be
comment|// equivalent to:
comment|//    "gl_FragCoord.y = render_area_height - gl_FragCoord.y"
comment|//
comment|// When we're rendering to a texture, we want our output to be equivalent to:
comment|//    "gl_FragCoord.y = gl_FragCoord.y;"
comment|//
comment|// If we set scale_factor = ((1.0f + dx_ViewScale.y) / 2.0f), then notice that
comment|//  - When rendering to default FB: scale_factor = 1.0f
comment|//  - When rendering to texture:    scale_factor = 0.0f
comment|//
comment|// Therefore, we can get our desired output by setting:
comment|//    "gl_FragCoord.y = scale_factor * render_area_height - dx_ViewScale.y *
comment|//    gl_FragCoord.y"
comment|//
comment|// Simplifying, this becomes:
name|pixelStream
operator|<<
literal|"    gl_FragCoord.y = (1.0f + dx_ViewScale.y) * gl_FragCoord.y /"
literal|"(1.0f - input.gl_FragCoord.y * rhw)  - dx_ViewScale.y * gl_FragCoord.y;\n"
expr_stmt|;
block|}
block|}
name|pixelStream
operator|<<
literal|"    gl_FragCoord.z = (input.gl_FragCoord.z * rhw) * dx_DepthFront.x + "
literal|"dx_DepthFront.y;\n"
operator|<<
literal|"    gl_FragCoord.w = rhw;\n"
expr_stmt|;
block|}
if|if
condition|(
name|pixelBuiltins
operator|.
name|glPointCoord
operator|.
name|enabled
operator|&&
name|shaderModel
operator|>=
literal|3
condition|)
block|{
name|pixelStream
operator|<<
literal|"    gl_PointCoord.x = input.gl_PointCoord.x;\n"
operator|<<
literal|"    gl_PointCoord.y = 1.0 - input.gl_PointCoord.y;\n"
expr_stmt|;
block|}
if|if
condition|(
name|fragmentShader
operator|->
name|usesFrontFacing
argument_list|()
condition|)
block|{
if|if
condition|(
name|shaderModel
operator|<=
literal|3
condition|)
block|{
name|pixelStream
operator|<<
literal|"    gl_FrontFacing = (vFace * dx_DepthFront.z>= 0.0);\n"
expr_stmt|;
block|}
else|else
block|{
name|pixelStream
operator|<<
literal|"    gl_FrontFacing = isFrontFace;\n"
expr_stmt|;
block|}
block|}
for|for
control|(
specifier|const
name|PackedVaryingRegister
modifier|&
name|registerInfo
range|:
name|varyingPacking
operator|.
name|getRegisterList
argument_list|()
control|)
block|{
specifier|const
specifier|auto
modifier|&
name|packedVarying
init|=
operator|*
name|registerInfo
operator|.
name|packedVarying
decl_stmt|;
specifier|const
specifier|auto
modifier|&
name|varying
init|=
operator|*
name|packedVarying
operator|.
name|varying
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|varying
operator|.
name|isBuiltIn
argument_list|()
operator|&&
operator|!
name|varying
operator|.
name|isStruct
argument_list|()
argument_list|)
expr_stmt|;
comment|// Don't reference VS-only transform feedback varyings in the PS.
if|if
condition|(
name|registerInfo
operator|.
name|packedVarying
operator|->
name|vertexOnly
condition|)
continue|continue;
name|pixelStream
operator|<<
literal|"    "
expr_stmt|;
if|if
condition|(
name|packedVarying
operator|.
name|isStructField
argument_list|()
condition|)
block|{
name|pixelStream
operator|<<
name|decorateVariable
argument_list|(
name|packedVarying
operator|.
name|parentStructName
argument_list|)
operator|<<
literal|"."
expr_stmt|;
block|}
name|pixelStream
operator|<<
name|decorateVariable
argument_list|(
name|varying
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|varying
operator|.
name|isArray
argument_list|()
condition|)
block|{
name|WriteArrayString
argument_list|(
name|pixelStream
argument_list|,
name|registerInfo
operator|.
name|varyingArrayIndex
argument_list|)
expr_stmt|;
block|}
name|GLenum
name|transposedType
init|=
name|TransposeMatrixType
argument_list|(
name|varying
operator|.
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|VariableRowCount
argument_list|(
name|transposedType
argument_list|)
operator|>
literal|1
condition|)
block|{
name|WriteArrayString
argument_list|(
name|pixelStream
argument_list|,
name|registerInfo
operator|.
name|varyingRowIndex
argument_list|)
expr_stmt|;
block|}
name|pixelStream
operator|<<
literal|" = input.v"
operator|<<
name|registerInfo
operator|.
name|semanticIndex
expr_stmt|;
switch|switch
condition|(
name|VariableColumnCount
argument_list|(
name|transposedType
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|pixelStream
operator|<<
literal|".x"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|pixelStream
operator|<<
literal|".xy"
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|pixelStream
operator|<<
literal|".xyz"
expr_stmt|;
break|break;
case|case
literal|4
case|:
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
name|pixelStream
operator|<<
literal|";\n"
expr_stmt|;
block|}
if|if
condition|(
name|fragmentShader
operator|->
name|usesDeferredInit
argument_list|()
condition|)
block|{
name|pixelStream
operator|<<
literal|"\n"
operator|<<
literal|"    initializeDeferredGlobals();\n"
expr_stmt|;
block|}
name|pixelStream
operator|<<
literal|"\n"
operator|<<
literal|"    gl_main();\n"
operator|<<
literal|"\n"
operator|<<
literal|"    return generateOutput();\n"
operator|<<
literal|"}\n"
expr_stmt|;
operator|*
name|vertexHLSL
operator|=
name|vertexStream
operator|.
name|str
argument_list|()
expr_stmt|;
operator|*
name|pixelHLSL
operator|=
name|pixelStream
operator|.
name|str
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|generateGeometryShaderPreamble
name|std
operator|::
name|string
name|DynamicHLSL
operator|::
name|generateGeometryShaderPreamble
parameter_list|(
specifier|const
name|VaryingPacking
modifier|&
name|varyingPacking
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|mRenderer
operator|->
name|getMajorShaderModel
argument_list|()
operator|>=
literal|4
argument_list|)
expr_stmt|;
name|std
operator|::
name|stringstream
name|preambleStream
decl_stmt|;
specifier|const
specifier|auto
modifier|&
name|builtins
init|=
name|varyingPacking
operator|.
name|builtins
argument_list|(
name|SHADER_VERTEX
argument_list|)
decl_stmt|;
name|preambleStream
operator|<<
literal|"struct GS_INPUT\n"
expr_stmt|;
name|generateVaryingLinkHLSL
argument_list|(
name|SHADER_VERTEX
argument_list|,
name|varyingPacking
argument_list|,
name|preambleStream
argument_list|)
expr_stmt|;
name|preambleStream
operator|<<
literal|"\n"
operator|<<
literal|"struct GS_OUTPUT\n"
expr_stmt|;
name|generateVaryingLinkHLSL
argument_list|(
name|SHADER_GEOMETRY
argument_list|,
name|varyingPacking
argument_list|,
name|preambleStream
argument_list|)
expr_stmt|;
name|preambleStream
operator|<<
literal|"\n"
operator|<<
literal|"void copyVertex(inout GS_OUTPUT output, GS_INPUT input, GS_INPUT flatinput)\n"
operator|<<
literal|"{\n"
operator|<<
literal|"    output.gl_Position = input.gl_Position;\n"
expr_stmt|;
if|if
condition|(
name|builtins
operator|.
name|glPointSize
operator|.
name|enabled
condition|)
block|{
name|preambleStream
operator|<<
literal|"    output.gl_PointSize = input.gl_PointSize;\n"
expr_stmt|;
block|}
for|for
control|(
specifier|const
name|PackedVaryingRegister
modifier|&
name|varyingRegister
range|:
name|varyingPacking
operator|.
name|getRegisterList
argument_list|()
control|)
block|{
name|preambleStream
operator|<<
literal|"    output.v"
operator|<<
name|varyingRegister
operator|.
name|semanticIndex
operator|<<
literal|" = "
expr_stmt|;
if|if
condition|(
name|varyingRegister
operator|.
name|packedVarying
operator|->
name|interpolation
operator|==
name|sh
operator|::
name|INTERPOLATION_FLAT
condition|)
block|{
name|preambleStream
operator|<<
literal|"flat"
expr_stmt|;
block|}
name|preambleStream
operator|<<
literal|"input.v"
operator|<<
name|varyingRegister
operator|.
name|semanticIndex
operator|<<
literal|"; \n"
expr_stmt|;
block|}
if|if
condition|(
name|builtins
operator|.
name|glFragCoord
operator|.
name|enabled
condition|)
block|{
name|preambleStream
operator|<<
literal|"    output.gl_FragCoord = input.gl_FragCoord;\n"
expr_stmt|;
block|}
comment|// Only write the dx_Position if we aren't using point sprites
name|preambleStream
operator|<<
literal|"#ifndef ANGLE_POINT_SPRITE_SHADER\n"
operator|<<
literal|"    output.dx_Position = input.dx_Position;\n"
operator|<<
literal|"#endif  // ANGLE_POINT_SPRITE_SHADER\n"
operator|<<
literal|"}\n"
expr_stmt|;
return|return
name|preambleStream
operator|.
name|str
argument_list|()
return|;
block|}
DECL|function|generateGeometryShaderHLSL
name|std
operator|::
name|string
name|DynamicHLSL
operator|::
name|generateGeometryShaderHLSL
parameter_list|(
name|gl
operator|::
name|PrimitiveType
name|primitiveType
parameter_list|,
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
specifier|const
name|gl
operator|::
name|Program
operator|::
name|Data
modifier|&
name|programData
parameter_list|,
specifier|const
name|bool
name|useViewScale
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|preambleString
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|mRenderer
operator|->
name|getMajorShaderModel
argument_list|()
operator|>=
literal|4
argument_list|)
expr_stmt|;
name|std
operator|::
name|stringstream
name|shaderStream
decl_stmt|;
specifier|const
name|bool
name|pointSprites
init|=
operator|(
name|primitiveType
operator|==
name|PRIMITIVE_POINTS
operator|)
decl_stmt|;
specifier|const
name|bool
name|usesPointCoord
init|=
name|preambleString
operator|.
name|find
argument_list|(
literal|"gl_PointCoord"
argument_list|)
operator|!=
name|std
operator|::
name|string
operator|::
name|npos
decl_stmt|;
specifier|const
name|char
modifier|*
name|inputPT
init|=
literal|nullptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|outputPT
init|=
literal|nullptr
decl_stmt|;
name|int
name|inputSize
init|=
literal|0
decl_stmt|;
name|int
name|maxVertexOutput
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|primitiveType
condition|)
block|{
case|case
name|PRIMITIVE_POINTS
case|:
name|inputPT
operator|=
literal|"point"
expr_stmt|;
name|outputPT
operator|=
literal|"Triangle"
expr_stmt|;
name|inputSize
operator|=
literal|1
expr_stmt|;
name|maxVertexOutput
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|PRIMITIVE_LINES
case|:
case|case
name|PRIMITIVE_LINE_STRIP
case|:
case|case
name|PRIMITIVE_LINE_LOOP
case|:
name|inputPT
operator|=
literal|"line"
expr_stmt|;
name|outputPT
operator|=
literal|"Line"
expr_stmt|;
name|inputSize
operator|=
literal|2
expr_stmt|;
name|maxVertexOutput
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|PRIMITIVE_TRIANGLES
case|:
case|case
name|PRIMITIVE_TRIANGLE_STRIP
case|:
case|case
name|PRIMITIVE_TRIANGLE_FAN
case|:
name|inputPT
operator|=
literal|"triangle"
expr_stmt|;
name|outputPT
operator|=
literal|"Triangle"
expr_stmt|;
name|inputSize
operator|=
literal|3
expr_stmt|;
name|maxVertexOutput
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pointSprites
condition|)
block|{
name|shaderStream
operator|<<
literal|"#define ANGLE_POINT_SPRITE_SHADER\n"
literal|"\n"
literal|"uniform float4 dx_ViewCoords : register(c1);\n"
expr_stmt|;
if|if
condition|(
name|useViewScale
condition|)
block|{
name|shaderStream
operator|<<
literal|"uniform float2 dx_ViewScale : register(c3);\n"
expr_stmt|;
block|}
name|shaderStream
operator|<<
literal|"\n"
literal|"static float2 pointSpriteCorners[] = \n"
literal|"{\n"
literal|"    float2( 0.5f, -0.5f),\n"
literal|"    float2( 0.5f,  0.5f),\n"
literal|"    float2(-0.5f, -0.5f),\n"
literal|"    float2(-0.5f,  0.5f)\n"
literal|"};\n"
literal|"\n"
literal|"static float2 pointSpriteTexcoords[] = \n"
literal|"{\n"
literal|"    float2(1.0f, 1.0f),\n"
literal|"    float2(1.0f, 0.0f),\n"
literal|"    float2(0.0f, 1.0f),\n"
literal|"    float2(0.0f, 0.0f)\n"
literal|"};\n"
literal|"\n"
literal|"static float minPointSize = "
operator|<<
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|data
operator|.
name|caps
operator|->
name|minAliasedPointSize
argument_list|)
operator|<<
literal|".0f;\n"
literal|"static float maxPointSize = "
operator|<<
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|data
operator|.
name|caps
operator|->
name|maxAliasedPointSize
argument_list|)
operator|<<
literal|".0f;\n"
operator|<<
literal|"\n"
expr_stmt|;
block|}
name|shaderStream
operator|<<
name|preambleString
operator|<<
literal|"\n"
operator|<<
literal|"[maxvertexcount("
operator|<<
name|maxVertexOutput
operator|<<
literal|")]\n"
operator|<<
literal|"void main("
operator|<<
name|inputPT
operator|<<
literal|" GS_INPUT input["
operator|<<
name|inputSize
operator|<<
literal|"], "
expr_stmt|;
if|if
condition|(
name|primitiveType
operator|==
name|PRIMITIVE_TRIANGLE_STRIP
condition|)
block|{
name|shaderStream
operator|<<
literal|"uint primitiveID : SV_PrimitiveID, "
expr_stmt|;
block|}
name|shaderStream
operator|<<
literal|" inout "
operator|<<
name|outputPT
operator|<<
literal|"Stream<GS_OUTPUT> outStream)\n"
operator|<<
literal|"{\n"
operator|<<
literal|"    GS_OUTPUT output = (GS_OUTPUT)0;\n"
expr_stmt|;
if|if
condition|(
name|primitiveType
operator|==
name|PRIMITIVE_TRIANGLE_STRIP
condition|)
block|{
name|shaderStream
operator|<<
literal|"    uint lastVertexIndex = (primitiveID % 2 == 0 ? 2 : 1);\n"
expr_stmt|;
block|}
else|else
block|{
name|shaderStream
operator|<<
literal|"    uint lastVertexIndex = "
operator|<<
operator|(
name|inputSize
operator|-
literal|1
operator|)
operator|<<
literal|";\n"
expr_stmt|;
block|}
for|for
control|(
name|int
name|vertexIndex
init|=
literal|0
init|;
name|vertexIndex
operator|<
name|inputSize
condition|;
operator|++
name|vertexIndex
control|)
block|{
name|shaderStream
operator|<<
literal|"    copyVertex(output, input["
operator|<<
name|vertexIndex
operator|<<
literal|"], input[lastVertexIndex]);\n"
expr_stmt|;
if|if
condition|(
operator|!
name|pointSprites
condition|)
block|{
name|ASSERT
argument_list|(
name|inputSize
operator|==
name|maxVertexOutput
argument_list|)
expr_stmt|;
name|shaderStream
operator|<<
literal|"    outStream.Append(output);\n"
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pointSprites
condition|)
block|{
name|shaderStream
operator|<<
literal|"\n"
literal|"    float4 dx_Position = input[0].dx_Position;\n"
literal|"    float gl_PointSize = clamp(input[0].gl_PointSize, minPointSize, "
literal|"maxPointSize);\n"
literal|"    float2 viewportScale = float2(1.0f / dx_ViewCoords.x, 1.0f / "
literal|"dx_ViewCoords.y) * dx_Position.w;\n"
expr_stmt|;
for|for
control|(
name|int
name|corner
init|=
literal|0
init|;
name|corner
operator|<
literal|4
condition|;
name|corner
operator|++
control|)
block|{
if|if
condition|(
name|useViewScale
condition|)
block|{
name|shaderStream
operator|<<
literal|"    \n"
literal|"    output.dx_Position = dx_Position + float4(1.0f, "
literal|"-dx_ViewScale.y, 1.0f, 1.0f)"
literal|"        * float4(pointSpriteCorners["
operator|<<
name|corner
operator|<<
literal|"] * viewportScale * gl_PointSize, 0.0f, 0.0f);\n"
expr_stmt|;
block|}
else|else
block|{
name|shaderStream
operator|<<
literal|"\n"
literal|"    output.dx_Position = dx_Position + float4(pointSpriteCorners["
operator|<<
name|corner
operator|<<
literal|"] * viewportScale * gl_PointSize, 0.0f, 0.0f);\n"
expr_stmt|;
block|}
if|if
condition|(
name|usesPointCoord
condition|)
block|{
name|shaderStream
operator|<<
literal|"    output.gl_PointCoord = pointSpriteTexcoords["
operator|<<
name|corner
operator|<<
literal|"];\n"
expr_stmt|;
block|}
name|shaderStream
operator|<<
literal|"    outStream.Append(output);\n"
expr_stmt|;
block|}
block|}
name|shaderStream
operator|<<
literal|"    \n"
literal|"    outStream.RestartStrip();\n"
literal|"}\n"
expr_stmt|;
return|return
name|shaderStream
operator|.
name|str
argument_list|()
return|;
block|}
comment|// This method needs to match OutputHLSL::decorate
DECL|function|decorateVariable
name|std
operator|::
name|string
name|DynamicHLSL
operator|::
name|decorateVariable
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|,
literal|"gl_"
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
literal|"_"
operator|+
name|name
return|;
block|}
return|return
name|name
return|;
block|}
DECL|function|generateAttributeConversionHLSL
name|std
operator|::
name|string
name|DynamicHLSL
operator|::
name|generateAttributeConversionHLSL
parameter_list|(
name|gl
operator|::
name|VertexFormatType
name|vertexFormatType
parameter_list|,
specifier|const
name|sh
operator|::
name|ShaderVariable
modifier|&
name|shaderAttrib
parameter_list|)
specifier|const
block|{
specifier|const
name|gl
operator|::
name|VertexFormat
modifier|&
name|vertexFormat
init|=
name|gl
operator|::
name|GetVertexFormatFromType
argument_list|(
name|vertexFormatType
argument_list|)
decl_stmt|;
name|std
operator|::
name|string
name|attribString
init|=
literal|"input."
operator|+
name|decorateVariable
argument_list|(
name|shaderAttrib
operator|.
name|name
argument_list|)
decl_stmt|;
comment|// Matrix
if|if
condition|(
name|IsMatrixType
argument_list|(
name|shaderAttrib
operator|.
name|type
argument_list|)
condition|)
block|{
return|return
literal|"transpose("
operator|+
name|attribString
operator|+
literal|")"
return|;
block|}
name|GLenum
name|shaderComponentType
init|=
name|VariableComponentType
argument_list|(
name|shaderAttrib
operator|.
name|type
argument_list|)
decl_stmt|;
name|int
name|shaderComponentCount
init|=
name|VariableComponentCount
argument_list|(
name|shaderAttrib
operator|.
name|type
argument_list|)
decl_stmt|;
comment|// Perform integer to float conversion (if necessary)
name|bool
name|requiresTypeConversion
init|=
operator|(
name|shaderComponentType
operator|==
name|GL_FLOAT
operator|&&
name|vertexFormat
operator|.
name|type
operator|!=
name|GL_FLOAT
operator|)
decl_stmt|;
if|if
condition|(
name|requiresTypeConversion
condition|)
block|{
comment|// TODO: normalization for 32-bit integer formats
name|ASSERT
argument_list|(
operator|!
name|vertexFormat
operator|.
name|normalized
operator|&&
operator|!
name|vertexFormat
operator|.
name|pureInteger
argument_list|)
expr_stmt|;
return|return
literal|"float"
operator|+
name|Str
argument_list|(
name|shaderComponentCount
argument_list|)
operator|+
literal|"("
operator|+
name|attribString
operator|+
literal|")"
return|;
block|}
comment|// No conversion necessary
return|return
name|attribString
return|;
block|}
DECL|function|getPixelShaderOutputKey
name|void
name|DynamicHLSL
operator|::
name|getPixelShaderOutputKey
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
specifier|const
name|gl
operator|::
name|Program
operator|::
name|Data
modifier|&
name|programData
parameter_list|,
specifier|const
name|ProgramD3DMetadata
modifier|&
name|metadata
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|PixelShaderOutputVariable
argument_list|>
modifier|*
name|outPixelShaderKey
parameter_list|)
block|{
comment|// Two cases when writing to gl_FragColor and using ESSL 1.0:
comment|// - with a 3.0 context, the output color is copied to channel 0
comment|// - with a 2.0 context, the output color is broadcast to all channels
name|bool
name|broadcast
init|=
name|metadata
operator|.
name|usesBroadcast
argument_list|(
name|data
argument_list|)
decl_stmt|;
specifier|const
name|unsigned
name|int
name|numRenderTargets
init|=
operator|(
name|broadcast
operator|||
name|metadata
operator|.
name|usesMultipleFragmentOuts
argument_list|()
condition|?
name|data
operator|.
name|caps
operator|->
name|maxDrawBuffers
else|:
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|metadata
operator|.
name|getMajorShaderVersion
argument_list|()
operator|<
literal|300
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|renderTargetIndex
init|=
literal|0
init|;
name|renderTargetIndex
operator|<
name|numRenderTargets
condition|;
name|renderTargetIndex
operator|++
control|)
block|{
name|PixelShaderOutputVariable
name|outputKeyVariable
decl_stmt|;
name|outputKeyVariable
operator|.
name|type
operator|=
name|GL_FLOAT_VEC4
expr_stmt|;
name|outputKeyVariable
operator|.
name|name
operator|=
literal|"gl_Color"
operator|+
name|Str
argument_list|(
name|renderTargetIndex
argument_list|)
expr_stmt|;
name|outputKeyVariable
operator|.
name|source
operator|=
name|broadcast
condition|?
literal|"gl_Color[0]"
else|:
literal|"gl_Color["
operator|+
name|Str
argument_list|(
name|renderTargetIndex
argument_list|)
operator|+
literal|"]"
expr_stmt|;
name|outputKeyVariable
operator|.
name|outputIndex
operator|=
name|renderTargetIndex
expr_stmt|;
name|outPixelShaderKey
operator|->
name|push_back
argument_list|(
name|outputKeyVariable
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|const
specifier|auto
modifier|&
name|shaderOutputVars
init|=
name|metadata
operator|.
name|getFragmentShader
argument_list|()
operator|->
name|getData
argument_list|()
operator|.
name|getActiveOutputVariables
argument_list|()
decl_stmt|;
for|for
control|(
name|auto
name|outputPair
range|:
name|programData
operator|.
name|getOutputVariables
argument_list|()
control|)
block|{
specifier|const
name|VariableLocation
modifier|&
name|outputLocation
init|=
name|outputPair
operator|.
name|second
decl_stmt|;
specifier|const
name|sh
operator|::
name|ShaderVariable
modifier|&
name|outputVariable
init|=
name|shaderOutputVars
index|[
name|outputLocation
operator|.
name|index
index|]
decl_stmt|;
specifier|const
name|std
operator|::
name|string
modifier|&
name|variableName
init|=
literal|"out_"
operator|+
name|outputLocation
operator|.
name|name
decl_stmt|;
specifier|const
name|std
operator|::
name|string
modifier|&
name|elementString
init|=
operator|(
name|outputLocation
operator|.
name|element
operator|==
name|GL_INVALID_INDEX
condition|?
literal|""
else|:
name|Str
argument_list|(
name|outputLocation
operator|.
name|element
argument_list|)
operator|)
decl_stmt|;
name|ASSERT
argument_list|(
name|outputVariable
operator|.
name|staticUse
argument_list|)
expr_stmt|;
name|PixelShaderOutputVariable
name|outputKeyVariable
decl_stmt|;
name|outputKeyVariable
operator|.
name|type
operator|=
name|outputVariable
operator|.
name|type
expr_stmt|;
name|outputKeyVariable
operator|.
name|name
operator|=
name|variableName
operator|+
name|elementString
expr_stmt|;
name|outputKeyVariable
operator|.
name|source
operator|=
name|variableName
operator|+
name|ArrayString
argument_list|(
name|outputLocation
operator|.
name|element
argument_list|)
expr_stmt|;
name|outputKeyVariable
operator|.
name|outputIndex
operator|=
name|outputPair
operator|.
name|first
expr_stmt|;
name|outPixelShaderKey
operator|->
name|push_back
argument_list|(
name|outputKeyVariable
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_namespace
begin_comment
comment|// namespace rx
end_comment
end_unit
