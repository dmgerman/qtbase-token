begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright 2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// FramebufferD3D.cpp: Implements the DefaultAttachmentD3D and FramebufferD3D classes.
end_comment
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/FramebufferD3D.h"
end_include
begin_include
include|#
directive|include
file|"common/BitSetIterator.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/formatutils.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Framebuffer.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/FramebufferAttachment.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Surface.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/RendererD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/RenderbufferD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/RenderTargetD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/SurfaceD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/SwapChainD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/TextureD3D.h"
end_include
begin_namespace
DECL|namespace|rx
namespace|namespace
name|rx
block|{
namespace|namespace
block|{
DECL|function|GetClearParameters
name|ClearParameters
name|GetClearParameters
parameter_list|(
specifier|const
name|gl
operator|::
name|State
modifier|&
name|state
parameter_list|,
name|GLbitfield
name|mask
parameter_list|)
block|{
name|ClearParameters
name|clearParams
decl_stmt|;
name|memset
argument_list|(
operator|&
name|clearParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ClearParameters
argument_list|)
argument_list|)
expr_stmt|;
specifier|const
specifier|auto
modifier|&
name|blendState
init|=
name|state
operator|.
name|getBlendState
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ArraySize
argument_list|(
name|clearParams
operator|.
name|clearColor
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|clearParams
operator|.
name|clearColor
index|[
name|i
index|]
operator|=
literal|false
expr_stmt|;
block|}
name|clearParams
operator|.
name|colorFClearValue
operator|=
name|state
operator|.
name|getColorClearValue
argument_list|()
expr_stmt|;
name|clearParams
operator|.
name|colorClearType
operator|=
name|GL_FLOAT
expr_stmt|;
name|clearParams
operator|.
name|colorMaskRed
operator|=
name|blendState
operator|.
name|colorMaskRed
expr_stmt|;
name|clearParams
operator|.
name|colorMaskGreen
operator|=
name|blendState
operator|.
name|colorMaskGreen
expr_stmt|;
name|clearParams
operator|.
name|colorMaskBlue
operator|=
name|blendState
operator|.
name|colorMaskBlue
expr_stmt|;
name|clearParams
operator|.
name|colorMaskAlpha
operator|=
name|blendState
operator|.
name|colorMaskAlpha
expr_stmt|;
name|clearParams
operator|.
name|clearDepth
operator|=
literal|false
expr_stmt|;
name|clearParams
operator|.
name|depthClearValue
operator|=
name|state
operator|.
name|getDepthClearValue
argument_list|()
expr_stmt|;
name|clearParams
operator|.
name|clearStencil
operator|=
literal|false
expr_stmt|;
name|clearParams
operator|.
name|stencilClearValue
operator|=
name|state
operator|.
name|getStencilClearValue
argument_list|()
expr_stmt|;
name|clearParams
operator|.
name|stencilWriteMask
operator|=
name|state
operator|.
name|getDepthStencilState
argument_list|()
operator|.
name|stencilWritemask
expr_stmt|;
name|clearParams
operator|.
name|scissorEnabled
operator|=
name|state
operator|.
name|isScissorTestEnabled
argument_list|()
expr_stmt|;
name|clearParams
operator|.
name|scissor
operator|=
name|state
operator|.
name|getScissor
argument_list|()
expr_stmt|;
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebufferObject
init|=
name|state
operator|.
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|mask
operator|&
name|GL_COLOR_BUFFER_BIT
condition|)
block|{
if|if
condition|(
name|framebufferObject
operator|->
name|hasEnabledDrawBuffer
argument_list|()
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ArraySize
argument_list|(
name|clearParams
operator|.
name|clearColor
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|clearParams
operator|.
name|clearColor
index|[
name|i
index|]
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|GL_DEPTH_BUFFER_BIT
condition|)
block|{
if|if
condition|(
name|state
operator|.
name|getDepthStencilState
argument_list|()
operator|.
name|depthMask
operator|&&
name|framebufferObject
operator|->
name|getDepthbuffer
argument_list|()
operator|!=
name|NULL
condition|)
block|{
name|clearParams
operator|.
name|clearDepth
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|GL_STENCIL_BUFFER_BIT
condition|)
block|{
if|if
condition|(
name|framebufferObject
operator|->
name|getStencilbuffer
argument_list|()
operator|!=
name|NULL
operator|&&
name|framebufferObject
operator|->
name|getStencilbuffer
argument_list|()
operator|->
name|getStencilSize
argument_list|()
operator|>
literal|0
condition|)
block|{
name|clearParams
operator|.
name|clearStencil
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|clearParams
return|;
block|}
block|}
DECL|function|FramebufferD3D
name|FramebufferD3D
operator|::
name|FramebufferD3D
parameter_list|(
specifier|const
name|gl
operator|::
name|Framebuffer
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|RendererD3D
modifier|*
name|renderer
parameter_list|)
member_init_list|:
name|FramebufferImpl
argument_list|(
name|data
argument_list|)
member_init_list|,
name|mRenderer
argument_list|(
name|renderer
argument_list|)
block|{ }
DECL|function|~FramebufferD3D
name|FramebufferD3D
operator|::
name|~
name|FramebufferD3D
parameter_list|()
block|{ }
DECL|function|clear
name|gl
operator|::
name|Error
name|FramebufferD3D
operator|::
name|clear
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLbitfield
name|mask
parameter_list|)
block|{
specifier|const
name|gl
operator|::
name|State
modifier|&
name|state
init|=
operator|*
name|data
operator|.
name|state
decl_stmt|;
name|ClearParameters
name|clearParams
init|=
name|GetClearParameters
argument_list|(
name|state
argument_list|,
name|mask
argument_list|)
decl_stmt|;
return|return
name|clear
argument_list|(
name|data
argument_list|,
name|clearParams
argument_list|)
return|;
block|}
DECL|function|clearBufferfv
name|gl
operator|::
name|Error
name|FramebufferD3D
operator|::
name|clearBufferfv
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLenum
name|buffer
parameter_list|,
name|GLint
name|drawbuffer
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|values
parameter_list|)
block|{
comment|// glClearBufferfv can be called to clear the color buffer or depth buffer
name|ClearParameters
name|clearParams
init|=
name|GetClearParameters
argument_list|(
operator|*
name|data
operator|.
name|state
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|buffer
operator|==
name|GL_COLOR
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ArraySize
argument_list|(
name|clearParams
operator|.
name|clearColor
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|clearParams
operator|.
name|clearColor
index|[
name|i
index|]
operator|=
operator|(
name|drawbuffer
operator|==
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|i
argument_list|)
operator|)
expr_stmt|;
block|}
name|clearParams
operator|.
name|colorFClearValue
operator|=
name|gl
operator|::
name|ColorF
argument_list|(
name|values
index|[
literal|0
index|]
argument_list|,
name|values
index|[
literal|1
index|]
argument_list|,
name|values
index|[
literal|2
index|]
argument_list|,
name|values
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|clearParams
operator|.
name|colorClearType
operator|=
name|GL_FLOAT
expr_stmt|;
block|}
if|if
condition|(
name|buffer
operator|==
name|GL_DEPTH
condition|)
block|{
name|clearParams
operator|.
name|clearDepth
operator|=
literal|true
expr_stmt|;
name|clearParams
operator|.
name|depthClearValue
operator|=
name|values
index|[
literal|0
index|]
expr_stmt|;
block|}
return|return
name|clear
argument_list|(
name|data
argument_list|,
name|clearParams
argument_list|)
return|;
block|}
DECL|function|clearBufferuiv
name|gl
operator|::
name|Error
name|FramebufferD3D
operator|::
name|clearBufferuiv
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLenum
name|buffer
parameter_list|,
name|GLint
name|drawbuffer
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|values
parameter_list|)
block|{
comment|// glClearBufferuiv can only be called to clear a color buffer
name|ClearParameters
name|clearParams
init|=
name|GetClearParameters
argument_list|(
operator|*
name|data
operator|.
name|state
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ArraySize
argument_list|(
name|clearParams
operator|.
name|clearColor
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|clearParams
operator|.
name|clearColor
index|[
name|i
index|]
operator|=
operator|(
name|drawbuffer
operator|==
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|i
argument_list|)
operator|)
expr_stmt|;
block|}
name|clearParams
operator|.
name|colorUIClearValue
operator|=
name|gl
operator|::
name|ColorUI
argument_list|(
name|values
index|[
literal|0
index|]
argument_list|,
name|values
index|[
literal|1
index|]
argument_list|,
name|values
index|[
literal|2
index|]
argument_list|,
name|values
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|clearParams
operator|.
name|colorClearType
operator|=
name|GL_UNSIGNED_INT
expr_stmt|;
return|return
name|clear
argument_list|(
name|data
argument_list|,
name|clearParams
argument_list|)
return|;
block|}
DECL|function|clearBufferiv
name|gl
operator|::
name|Error
name|FramebufferD3D
operator|::
name|clearBufferiv
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLenum
name|buffer
parameter_list|,
name|GLint
name|drawbuffer
parameter_list|,
specifier|const
name|GLint
modifier|*
name|values
parameter_list|)
block|{
comment|// glClearBufferiv can be called to clear the color buffer or stencil buffer
name|ClearParameters
name|clearParams
init|=
name|GetClearParameters
argument_list|(
operator|*
name|data
operator|.
name|state
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|buffer
operator|==
name|GL_COLOR
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ArraySize
argument_list|(
name|clearParams
operator|.
name|clearColor
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|clearParams
operator|.
name|clearColor
index|[
name|i
index|]
operator|=
operator|(
name|drawbuffer
operator|==
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|i
argument_list|)
operator|)
expr_stmt|;
block|}
name|clearParams
operator|.
name|colorIClearValue
operator|=
name|gl
operator|::
name|ColorI
argument_list|(
name|values
index|[
literal|0
index|]
argument_list|,
name|values
index|[
literal|1
index|]
argument_list|,
name|values
index|[
literal|2
index|]
argument_list|,
name|values
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|clearParams
operator|.
name|colorClearType
operator|=
name|GL_INT
expr_stmt|;
block|}
if|if
condition|(
name|buffer
operator|==
name|GL_STENCIL
condition|)
block|{
name|clearParams
operator|.
name|clearStencil
operator|=
literal|true
expr_stmt|;
name|clearParams
operator|.
name|stencilClearValue
operator|=
name|values
index|[
literal|1
index|]
expr_stmt|;
block|}
return|return
name|clear
argument_list|(
name|data
argument_list|,
name|clearParams
argument_list|)
return|;
block|}
DECL|function|clearBufferfi
name|gl
operator|::
name|Error
name|FramebufferD3D
operator|::
name|clearBufferfi
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLenum
name|buffer
parameter_list|,
name|GLint
name|drawbuffer
parameter_list|,
name|GLfloat
name|depth
parameter_list|,
name|GLint
name|stencil
parameter_list|)
block|{
comment|// glClearBufferfi can only be called to clear a depth stencil buffer
name|ClearParameters
name|clearParams
init|=
name|GetClearParameters
argument_list|(
operator|*
name|data
operator|.
name|state
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|clearParams
operator|.
name|clearDepth
operator|=
literal|true
expr_stmt|;
name|clearParams
operator|.
name|depthClearValue
operator|=
name|depth
expr_stmt|;
name|clearParams
operator|.
name|clearStencil
operator|=
literal|true
expr_stmt|;
name|clearParams
operator|.
name|stencilClearValue
operator|=
name|stencil
expr_stmt|;
return|return
name|clear
argument_list|(
name|data
argument_list|,
name|clearParams
argument_list|)
return|;
block|}
DECL|function|getImplementationColorReadFormat
name|GLenum
name|FramebufferD3D
operator|::
name|getImplementationColorReadFormat
parameter_list|()
specifier|const
block|{
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|readAttachment
init|=
name|mData
operator|.
name|getReadAttachment
argument_list|()
decl_stmt|;
if|if
condition|(
name|readAttachment
operator|==
literal|nullptr
condition|)
block|{
return|return
name|GL_NONE
return|;
block|}
name|RenderTargetD3D
modifier|*
name|attachmentRenderTarget
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|readAttachment
operator|->
name|getRenderTarget
argument_list|(
operator|&
name|attachmentRenderTarget
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|GL_NONE
return|;
block|}
name|GLenum
name|implementationFormat
init|=
name|getRenderTargetImplementationFormat
argument_list|(
name|attachmentRenderTarget
argument_list|)
decl_stmt|;
specifier|const
name|gl
operator|::
name|InternalFormat
modifier|&
name|implementationFormatInfo
init|=
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|implementationFormat
argument_list|)
decl_stmt|;
return|return
name|implementationFormatInfo
operator|.
name|format
return|;
block|}
DECL|function|getImplementationColorReadType
name|GLenum
name|FramebufferD3D
operator|::
name|getImplementationColorReadType
parameter_list|()
specifier|const
block|{
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|readAttachment
init|=
name|mData
operator|.
name|getReadAttachment
argument_list|()
decl_stmt|;
if|if
condition|(
name|readAttachment
operator|==
literal|nullptr
condition|)
block|{
return|return
name|GL_NONE
return|;
block|}
name|RenderTargetD3D
modifier|*
name|attachmentRenderTarget
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|readAttachment
operator|->
name|getRenderTarget
argument_list|(
operator|&
name|attachmentRenderTarget
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|GL_NONE
return|;
block|}
name|GLenum
name|implementationFormat
init|=
name|getRenderTargetImplementationFormat
argument_list|(
name|attachmentRenderTarget
argument_list|)
decl_stmt|;
specifier|const
name|gl
operator|::
name|InternalFormat
modifier|&
name|implementationFormatInfo
init|=
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|implementationFormat
argument_list|)
decl_stmt|;
return|return
name|implementationFormatInfo
operator|.
name|type
return|;
block|}
DECL|function|readPixels
name|gl
operator|::
name|Error
name|FramebufferD3D
operator|::
name|readPixels
parameter_list|(
specifier|const
name|gl
operator|::
name|State
modifier|&
name|state
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|area
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLvoid
modifier|*
name|pixels
parameter_list|)
specifier|const
block|{
specifier|const
name|gl
operator|::
name|PixelPackState
modifier|&
name|packState
init|=
name|state
operator|.
name|getPackState
argument_list|()
decl_stmt|;
name|GLenum
name|sizedInternalFormat
init|=
name|gl
operator|::
name|GetSizedInternalFormat
argument_list|(
name|format
argument_list|,
name|type
argument_list|)
decl_stmt|;
specifier|const
name|gl
operator|::
name|InternalFormat
modifier|&
name|sizedFormatInfo
init|=
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|sizedInternalFormat
argument_list|)
decl_stmt|;
name|GLuint
name|outputPitch
init|=
name|sizedFormatInfo
operator|.
name|computeRowPitch
argument_list|(
name|type
argument_list|,
name|area
operator|.
name|width
argument_list|,
name|packState
operator|.
name|alignment
argument_list|,
name|packState
operator|.
name|rowLength
argument_list|)
decl_stmt|;
name|GLsizei
name|outputSkipBytes
init|=
name|sizedFormatInfo
operator|.
name|computeSkipPixels
argument_list|(
name|outputPitch
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|packState
operator|.
name|skipRows
argument_list|,
name|packState
operator|.
name|skipPixels
argument_list|)
decl_stmt|;
return|return
name|readPixelsImpl
argument_list|(
name|area
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|outputPitch
argument_list|,
name|packState
argument_list|,
cast|reinterpret_cast
argument_list|<
name|uint8_t
operator|*
argument_list|>
argument_list|(
name|pixels
argument_list|)
operator|+
name|outputSkipBytes
argument_list|)
return|;
block|}
DECL|function|blit
name|gl
operator|::
name|Error
name|FramebufferD3D
operator|::
name|blit
parameter_list|(
specifier|const
name|gl
operator|::
name|State
modifier|&
name|state
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|sourceArea
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|destArea
parameter_list|,
name|GLbitfield
name|mask
parameter_list|,
name|GLenum
name|filter
parameter_list|,
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|sourceFramebuffer
parameter_list|)
block|{
name|bool
name|blitRenderTarget
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|GL_COLOR_BUFFER_BIT
operator|)
operator|&&
name|sourceFramebuffer
operator|->
name|getReadColorbuffer
argument_list|()
operator|!=
literal|nullptr
operator|&&
name|mData
operator|.
name|getFirstColorAttachment
argument_list|()
operator|!=
literal|nullptr
condition|)
block|{
name|blitRenderTarget
operator|=
literal|true
expr_stmt|;
block|}
name|bool
name|blitStencil
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|GL_STENCIL_BUFFER_BIT
operator|)
operator|&&
name|sourceFramebuffer
operator|->
name|getStencilbuffer
argument_list|()
operator|!=
literal|nullptr
operator|&&
name|mData
operator|.
name|getStencilAttachment
argument_list|()
operator|!=
literal|nullptr
condition|)
block|{
name|blitStencil
operator|=
literal|true
expr_stmt|;
block|}
name|bool
name|blitDepth
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|GL_DEPTH_BUFFER_BIT
operator|)
operator|&&
name|sourceFramebuffer
operator|->
name|getDepthbuffer
argument_list|()
operator|!=
literal|nullptr
operator|&&
name|mData
operator|.
name|getDepthAttachment
argument_list|()
operator|!=
literal|nullptr
condition|)
block|{
name|blitDepth
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|blitRenderTarget
operator|||
name|blitDepth
operator|||
name|blitStencil
condition|)
block|{
specifier|const
name|gl
operator|::
name|Rectangle
modifier|*
name|scissor
init|=
name|state
operator|.
name|isScissorTestEnabled
argument_list|()
condition|?
operator|&
name|state
operator|.
name|getScissor
argument_list|()
else|:
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|blit
argument_list|(
name|sourceArea
argument_list|,
name|destArea
argument_list|,
name|scissor
argument_list|,
name|blitRenderTarget
argument_list|,
name|blitDepth
argument_list|,
name|blitStencil
argument_list|,
name|filter
argument_list|,
name|sourceFramebuffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|checkStatus
name|bool
name|FramebufferD3D
operator|::
name|checkStatus
parameter_list|()
specifier|const
block|{
comment|// if we have both a depth and stencil buffer, they must refer to the same object
comment|// since we only support packed_depth_stencil and not separate depth and stencil
if|if
condition|(
name|mData
operator|.
name|getDepthAttachment
argument_list|()
operator|!=
literal|nullptr
operator|&&
name|mData
operator|.
name|getStencilAttachment
argument_list|()
operator|!=
literal|nullptr
operator|&&
name|mData
operator|.
name|getDepthStencilAttachment
argument_list|()
operator|==
literal|nullptr
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// D3D11 does not allow for overlapping RenderTargetViews, so ensure uniqueness
specifier|const
specifier|auto
modifier|&
name|colorAttachments
init|=
name|mData
operator|.
name|getColorAttachments
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|colorAttachment
init|=
literal|0
init|;
name|colorAttachment
operator|<
name|colorAttachments
operator|.
name|size
argument_list|()
condition|;
name|colorAttachment
operator|++
control|)
block|{
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|&
name|attachment
init|=
name|colorAttachments
index|[
name|colorAttachment
index|]
decl_stmt|;
if|if
condition|(
name|attachment
operator|.
name|isAttached
argument_list|()
condition|)
block|{
for|for
control|(
name|size_t
name|prevColorAttachment
init|=
literal|0
init|;
name|prevColorAttachment
operator|<
name|colorAttachment
condition|;
name|prevColorAttachment
operator|++
control|)
block|{
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|&
name|prevAttachment
init|=
name|colorAttachments
index|[
name|prevColorAttachment
index|]
decl_stmt|;
if|if
condition|(
name|prevAttachment
operator|.
name|isAttached
argument_list|()
operator|&&
operator|(
name|attachment
operator|.
name|id
argument_list|()
operator|==
name|prevAttachment
operator|.
name|id
argument_list|()
operator|&&
name|attachment
operator|.
name|type
argument_list|()
operator|==
name|prevAttachment
operator|.
name|type
argument_list|()
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
block|}
comment|// D3D requires all render targets to have the same dimensions.
if|if
condition|(
operator|!
name|mData
operator|.
name|attachmentsHaveSameDimensions
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|syncState
name|void
name|FramebufferD3D
operator|::
name|syncState
parameter_list|(
specifier|const
name|gl
operator|::
name|Framebuffer
operator|::
name|DirtyBits
modifier|&
name|dirtyBits
parameter_list|)
block|{
name|bool
name|invalidateColorAttachmentCache
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|mColorAttachmentsForRender
operator|.
name|valid
argument_list|()
condition|)
block|{
name|invalidateColorAttachmentCache
operator|=
literal|true
expr_stmt|;
block|}
for|for
control|(
name|auto
name|dirtyBit
range|:
name|angle
operator|::
name|IterateBitSet
argument_list|(
name|dirtyBits
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|dirtyBit
operator|>=
name|gl
operator|::
name|Framebuffer
operator|::
name|DIRTY_BIT_COLOR_ATTACHMENT_0
operator|&&
name|dirtyBit
operator|<
name|gl
operator|::
name|Framebuffer
operator|::
name|DIRTY_BIT_COLOR_ATTACHMENT_MAX
operator|)
operator|||
name|dirtyBit
operator|==
name|gl
operator|::
name|Framebuffer
operator|::
name|DIRTY_BIT_DRAW_BUFFERS
condition|)
block|{
name|invalidateColorAttachmentCache
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|invalidateColorAttachmentCache
condition|)
block|{
return|return;
block|}
comment|// Does not actually free memory
name|gl
operator|::
name|AttachmentList
name|colorAttachmentsForRender
decl_stmt|;
specifier|const
specifier|auto
modifier|&
name|colorAttachments
init|=
name|mData
operator|.
name|getColorAttachments
argument_list|()
decl_stmt|;
specifier|const
specifier|auto
modifier|&
name|drawBufferStates
init|=
name|mData
operator|.
name|getDrawBufferStates
argument_list|()
decl_stmt|;
specifier|const
specifier|auto
modifier|&
name|workarounds
init|=
name|mRenderer
operator|->
name|getWorkarounds
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|attachmentIndex
init|=
literal|0
init|;
name|attachmentIndex
operator|<
name|colorAttachments
operator|.
name|size
argument_list|()
condition|;
operator|++
name|attachmentIndex
control|)
block|{
name|GLenum
name|drawBufferState
init|=
name|drawBufferStates
index|[
name|attachmentIndex
index|]
decl_stmt|;
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|&
name|colorAttachment
init|=
name|colorAttachments
index|[
name|attachmentIndex
index|]
decl_stmt|;
if|if
condition|(
name|colorAttachment
operator|.
name|isAttached
argument_list|()
operator|&&
name|drawBufferState
operator|!=
name|GL_NONE
condition|)
block|{
name|ASSERT
argument_list|(
name|drawBufferState
operator|==
name|GL_BACK
operator|||
name|drawBufferState
operator|==
operator|(
name|GL_COLOR_ATTACHMENT0_EXT
operator|+
name|attachmentIndex
operator|)
argument_list|)
expr_stmt|;
name|colorAttachmentsForRender
operator|.
name|push_back
argument_list|(
operator|&
name|colorAttachment
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|workarounds
operator|.
name|mrtPerfWorkaround
condition|)
block|{
name|colorAttachmentsForRender
operator|.
name|push_back
argument_list|(
literal|nullptr
argument_list|)
expr_stmt|;
block|}
block|}
name|mColorAttachmentsForRender
operator|=
name|std
operator|::
name|move
argument_list|(
name|colorAttachmentsForRender
argument_list|)
expr_stmt|;
block|}
DECL|function|getColorAttachmentsForRender
specifier|const
name|gl
operator|::
name|AttachmentList
modifier|&
name|FramebufferD3D
operator|::
name|getColorAttachmentsForRender
parameter_list|()
specifier|const
block|{
name|ASSERT
argument_list|(
name|mColorAttachmentsForRender
operator|.
name|valid
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|mColorAttachmentsForRender
operator|.
name|value
argument_list|()
return|;
block|}
block|}
end_namespace
begin_comment
comment|// namespace rx
end_comment
end_unit
