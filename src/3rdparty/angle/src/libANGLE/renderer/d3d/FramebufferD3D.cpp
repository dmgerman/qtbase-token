begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright 2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// FramebufferD3D.cpp: Implements the DefaultAttachmentD3D and FramebufferD3D classes.
end_comment
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/FramebufferD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/formatutils.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Framebuffer.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/FramebufferAttachment.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Surface.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/RendererD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/RenderbufferD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/RenderTargetD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/SurfaceD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/SwapChainD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/TextureD3D.h"
end_include
begin_namespace
DECL|namespace|rx
namespace|namespace
name|rx
block|{
namespace|namespace
block|{
DECL|function|GetClearParameters
name|ClearParameters
name|GetClearParameters
parameter_list|(
specifier|const
name|gl
operator|::
name|State
modifier|&
name|state
parameter_list|,
name|GLbitfield
name|mask
parameter_list|)
block|{
name|ClearParameters
name|clearParams
decl_stmt|;
name|memset
argument_list|(
operator|&
name|clearParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ClearParameters
argument_list|)
argument_list|)
expr_stmt|;
specifier|const
specifier|auto
modifier|&
name|blendState
init|=
name|state
operator|.
name|getBlendState
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ArraySize
argument_list|(
name|clearParams
operator|.
name|clearColor
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|clearParams
operator|.
name|clearColor
index|[
name|i
index|]
operator|=
literal|false
expr_stmt|;
block|}
name|clearParams
operator|.
name|colorFClearValue
operator|=
name|state
operator|.
name|getColorClearValue
argument_list|()
expr_stmt|;
name|clearParams
operator|.
name|colorClearType
operator|=
name|GL_FLOAT
expr_stmt|;
name|clearParams
operator|.
name|colorMaskRed
operator|=
name|blendState
operator|.
name|colorMaskRed
expr_stmt|;
name|clearParams
operator|.
name|colorMaskGreen
operator|=
name|blendState
operator|.
name|colorMaskGreen
expr_stmt|;
name|clearParams
operator|.
name|colorMaskBlue
operator|=
name|blendState
operator|.
name|colorMaskBlue
expr_stmt|;
name|clearParams
operator|.
name|colorMaskAlpha
operator|=
name|blendState
operator|.
name|colorMaskAlpha
expr_stmt|;
name|clearParams
operator|.
name|clearDepth
operator|=
literal|false
expr_stmt|;
name|clearParams
operator|.
name|depthClearValue
operator|=
name|state
operator|.
name|getDepthClearValue
argument_list|()
expr_stmt|;
name|clearParams
operator|.
name|clearStencil
operator|=
literal|false
expr_stmt|;
name|clearParams
operator|.
name|stencilClearValue
operator|=
name|state
operator|.
name|getStencilClearValue
argument_list|()
expr_stmt|;
name|clearParams
operator|.
name|stencilWriteMask
operator|=
name|state
operator|.
name|getDepthStencilState
argument_list|()
operator|.
name|stencilWritemask
expr_stmt|;
name|clearParams
operator|.
name|scissorEnabled
operator|=
name|state
operator|.
name|isScissorTestEnabled
argument_list|()
expr_stmt|;
name|clearParams
operator|.
name|scissor
operator|=
name|state
operator|.
name|getScissor
argument_list|()
expr_stmt|;
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebufferObject
init|=
name|state
operator|.
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|mask
operator|&
name|GL_COLOR_BUFFER_BIT
condition|)
block|{
if|if
condition|(
name|framebufferObject
operator|->
name|hasEnabledColorAttachment
argument_list|()
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ArraySize
argument_list|(
name|clearParams
operator|.
name|clearColor
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|clearParams
operator|.
name|clearColor
index|[
name|i
index|]
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|GL_DEPTH_BUFFER_BIT
condition|)
block|{
if|if
condition|(
name|state
operator|.
name|getDepthStencilState
argument_list|()
operator|.
name|depthMask
operator|&&
name|framebufferObject
operator|->
name|getDepthbuffer
argument_list|()
operator|!=
name|NULL
condition|)
block|{
name|clearParams
operator|.
name|clearDepth
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|GL_STENCIL_BUFFER_BIT
condition|)
block|{
if|if
condition|(
name|framebufferObject
operator|->
name|getStencilbuffer
argument_list|()
operator|!=
name|NULL
operator|&&
name|framebufferObject
operator|->
name|getStencilbuffer
argument_list|()
operator|->
name|getStencilSize
argument_list|()
operator|>
literal|0
condition|)
block|{
name|clearParams
operator|.
name|clearStencil
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|clearParams
return|;
block|}
block|}
DECL|function|FramebufferD3D
name|FramebufferD3D
operator|::
name|FramebufferD3D
parameter_list|(
specifier|const
name|gl
operator|::
name|Framebuffer
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|RendererD3D
modifier|*
name|renderer
parameter_list|)
member_init_list|:
name|FramebufferImpl
argument_list|(
name|data
argument_list|)
member_init_list|,
name|mRenderer
argument_list|(
name|renderer
argument_list|)
member_init_list|,
name|mColorAttachmentsForRender
argument_list|(
name|mData
operator|.
name|mColorAttachments
operator|.
name|size
argument_list|()
argument_list|,
literal|nullptr
argument_list|)
member_init_list|,
name|mInvalidateColorAttachmentCache
argument_list|(
literal|true
argument_list|)
block|{
name|ASSERT
argument_list|(
name|mRenderer
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
block|}
DECL|function|~FramebufferD3D
name|FramebufferD3D
operator|::
name|~
name|FramebufferD3D
parameter_list|()
block|{ }
DECL|function|setColorAttachment
name|void
name|FramebufferD3D
operator|::
name|setColorAttachment
parameter_list|(
name|size_t
parameter_list|,
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|*
parameter_list|)
block|{
name|mInvalidateColorAttachmentCache
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|setDepthAttachment
name|void
name|FramebufferD3D
operator|::
name|setDepthAttachment
parameter_list|(
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|*
parameter_list|)
block|{ }
DECL|function|setStencilAttachment
name|void
name|FramebufferD3D
operator|::
name|setStencilAttachment
parameter_list|(
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|*
parameter_list|)
block|{ }
DECL|function|setDepthStencilAttachment
name|void
name|FramebufferD3D
operator|::
name|setDepthStencilAttachment
parameter_list|(
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|*
parameter_list|)
block|{ }
DECL|function|setDrawBuffers
name|void
name|FramebufferD3D
operator|::
name|setDrawBuffers
parameter_list|(
name|size_t
parameter_list|,
specifier|const
name|GLenum
modifier|*
parameter_list|)
block|{
name|mInvalidateColorAttachmentCache
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|setReadBuffer
name|void
name|FramebufferD3D
operator|::
name|setReadBuffer
parameter_list|(
name|GLenum
parameter_list|)
block|{ }
DECL|function|invalidate
name|gl
operator|::
name|Error
name|FramebufferD3D
operator|::
name|invalidate
parameter_list|(
name|size_t
parameter_list|,
specifier|const
name|GLenum
modifier|*
parameter_list|)
block|{
comment|// No-op in D3D
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|invalidateSub
name|gl
operator|::
name|Error
name|FramebufferD3D
operator|::
name|invalidateSub
parameter_list|(
name|size_t
parameter_list|,
specifier|const
name|GLenum
modifier|*
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
parameter_list|)
block|{
comment|// No-op in D3D
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|clear
name|gl
operator|::
name|Error
name|FramebufferD3D
operator|::
name|clear
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLbitfield
name|mask
parameter_list|)
block|{
specifier|const
name|gl
operator|::
name|State
modifier|&
name|state
init|=
operator|*
name|data
operator|.
name|state
decl_stmt|;
name|ClearParameters
name|clearParams
init|=
name|GetClearParameters
argument_list|(
name|state
argument_list|,
name|mask
argument_list|)
decl_stmt|;
return|return
name|clear
argument_list|(
name|state
argument_list|,
name|clearParams
argument_list|)
return|;
block|}
DECL|function|clearBufferfv
name|gl
operator|::
name|Error
name|FramebufferD3D
operator|::
name|clearBufferfv
parameter_list|(
specifier|const
name|gl
operator|::
name|State
modifier|&
name|state
parameter_list|,
name|GLenum
name|buffer
parameter_list|,
name|GLint
name|drawbuffer
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|values
parameter_list|)
block|{
comment|// glClearBufferfv can be called to clear the color buffer or depth buffer
name|ClearParameters
name|clearParams
init|=
name|GetClearParameters
argument_list|(
name|state
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|buffer
operator|==
name|GL_COLOR
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ArraySize
argument_list|(
name|clearParams
operator|.
name|clearColor
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|clearParams
operator|.
name|clearColor
index|[
name|i
index|]
operator|=
operator|(
name|drawbuffer
operator|==
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|i
argument_list|)
operator|)
expr_stmt|;
block|}
name|clearParams
operator|.
name|colorFClearValue
operator|=
name|gl
operator|::
name|ColorF
argument_list|(
name|values
index|[
literal|0
index|]
argument_list|,
name|values
index|[
literal|1
index|]
argument_list|,
name|values
index|[
literal|2
index|]
argument_list|,
name|values
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|clearParams
operator|.
name|colorClearType
operator|=
name|GL_FLOAT
expr_stmt|;
block|}
if|if
condition|(
name|buffer
operator|==
name|GL_DEPTH
condition|)
block|{
name|clearParams
operator|.
name|clearDepth
operator|=
literal|true
expr_stmt|;
name|clearParams
operator|.
name|depthClearValue
operator|=
name|values
index|[
literal|0
index|]
expr_stmt|;
block|}
return|return
name|clear
argument_list|(
name|state
argument_list|,
name|clearParams
argument_list|)
return|;
block|}
DECL|function|clearBufferuiv
name|gl
operator|::
name|Error
name|FramebufferD3D
operator|::
name|clearBufferuiv
parameter_list|(
specifier|const
name|gl
operator|::
name|State
modifier|&
name|state
parameter_list|,
name|GLenum
name|buffer
parameter_list|,
name|GLint
name|drawbuffer
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|values
parameter_list|)
block|{
comment|// glClearBufferuiv can only be called to clear a color buffer
name|ClearParameters
name|clearParams
init|=
name|GetClearParameters
argument_list|(
name|state
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ArraySize
argument_list|(
name|clearParams
operator|.
name|clearColor
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|clearParams
operator|.
name|clearColor
index|[
name|i
index|]
operator|=
operator|(
name|drawbuffer
operator|==
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|i
argument_list|)
operator|)
expr_stmt|;
block|}
name|clearParams
operator|.
name|colorUIClearValue
operator|=
name|gl
operator|::
name|ColorUI
argument_list|(
name|values
index|[
literal|0
index|]
argument_list|,
name|values
index|[
literal|1
index|]
argument_list|,
name|values
index|[
literal|2
index|]
argument_list|,
name|values
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|clearParams
operator|.
name|colorClearType
operator|=
name|GL_UNSIGNED_INT
expr_stmt|;
return|return
name|clear
argument_list|(
name|state
argument_list|,
name|clearParams
argument_list|)
return|;
block|}
DECL|function|clearBufferiv
name|gl
operator|::
name|Error
name|FramebufferD3D
operator|::
name|clearBufferiv
parameter_list|(
specifier|const
name|gl
operator|::
name|State
modifier|&
name|state
parameter_list|,
name|GLenum
name|buffer
parameter_list|,
name|GLint
name|drawbuffer
parameter_list|,
specifier|const
name|GLint
modifier|*
name|values
parameter_list|)
block|{
comment|// glClearBufferiv can be called to clear the color buffer or stencil buffer
name|ClearParameters
name|clearParams
init|=
name|GetClearParameters
argument_list|(
name|state
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|buffer
operator|==
name|GL_COLOR
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ArraySize
argument_list|(
name|clearParams
operator|.
name|clearColor
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|clearParams
operator|.
name|clearColor
index|[
name|i
index|]
operator|=
operator|(
name|drawbuffer
operator|==
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|i
argument_list|)
operator|)
expr_stmt|;
block|}
name|clearParams
operator|.
name|colorIClearValue
operator|=
name|gl
operator|::
name|ColorI
argument_list|(
name|values
index|[
literal|0
index|]
argument_list|,
name|values
index|[
literal|1
index|]
argument_list|,
name|values
index|[
literal|2
index|]
argument_list|,
name|values
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|clearParams
operator|.
name|colorClearType
operator|=
name|GL_INT
expr_stmt|;
block|}
if|if
condition|(
name|buffer
operator|==
name|GL_STENCIL
condition|)
block|{
name|clearParams
operator|.
name|clearStencil
operator|=
literal|true
expr_stmt|;
name|clearParams
operator|.
name|stencilClearValue
operator|=
name|values
index|[
literal|1
index|]
expr_stmt|;
block|}
return|return
name|clear
argument_list|(
name|state
argument_list|,
name|clearParams
argument_list|)
return|;
block|}
DECL|function|clearBufferfi
name|gl
operator|::
name|Error
name|FramebufferD3D
operator|::
name|clearBufferfi
parameter_list|(
specifier|const
name|gl
operator|::
name|State
modifier|&
name|state
parameter_list|,
name|GLenum
name|buffer
parameter_list|,
name|GLint
name|drawbuffer
parameter_list|,
name|GLfloat
name|depth
parameter_list|,
name|GLint
name|stencil
parameter_list|)
block|{
comment|// glClearBufferfi can only be called to clear a depth stencil buffer
name|ClearParameters
name|clearParams
init|=
name|GetClearParameters
argument_list|(
name|state
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|clearParams
operator|.
name|clearDepth
operator|=
literal|true
expr_stmt|;
name|clearParams
operator|.
name|depthClearValue
operator|=
name|depth
expr_stmt|;
name|clearParams
operator|.
name|clearStencil
operator|=
literal|true
expr_stmt|;
name|clearParams
operator|.
name|stencilClearValue
operator|=
name|stencil
expr_stmt|;
return|return
name|clear
argument_list|(
name|state
argument_list|,
name|clearParams
argument_list|)
return|;
block|}
DECL|function|getImplementationColorReadFormat
name|GLenum
name|FramebufferD3D
operator|::
name|getImplementationColorReadFormat
parameter_list|()
specifier|const
block|{
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|readAttachment
init|=
name|mData
operator|.
name|getReadAttachment
argument_list|()
decl_stmt|;
if|if
condition|(
name|readAttachment
operator|==
literal|nullptr
condition|)
block|{
return|return
name|GL_NONE
return|;
block|}
name|RenderTargetD3D
modifier|*
name|attachmentRenderTarget
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|GetAttachmentRenderTarget
argument_list|(
name|readAttachment
argument_list|,
operator|&
name|attachmentRenderTarget
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|GL_NONE
return|;
block|}
name|GLenum
name|implementationFormat
init|=
name|getRenderTargetImplementationFormat
argument_list|(
name|attachmentRenderTarget
argument_list|)
decl_stmt|;
specifier|const
name|gl
operator|::
name|InternalFormat
modifier|&
name|implementationFormatInfo
init|=
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|implementationFormat
argument_list|)
decl_stmt|;
return|return
name|implementationFormatInfo
operator|.
name|format
return|;
block|}
DECL|function|getImplementationColorReadType
name|GLenum
name|FramebufferD3D
operator|::
name|getImplementationColorReadType
parameter_list|()
specifier|const
block|{
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|readAttachment
init|=
name|mData
operator|.
name|getReadAttachment
argument_list|()
decl_stmt|;
if|if
condition|(
name|readAttachment
operator|==
literal|nullptr
condition|)
block|{
return|return
name|GL_NONE
return|;
block|}
name|RenderTargetD3D
modifier|*
name|attachmentRenderTarget
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|GetAttachmentRenderTarget
argument_list|(
name|readAttachment
argument_list|,
operator|&
name|attachmentRenderTarget
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|GL_NONE
return|;
block|}
name|GLenum
name|implementationFormat
init|=
name|getRenderTargetImplementationFormat
argument_list|(
name|attachmentRenderTarget
argument_list|)
decl_stmt|;
specifier|const
name|gl
operator|::
name|InternalFormat
modifier|&
name|implementationFormatInfo
init|=
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|implementationFormat
argument_list|)
decl_stmt|;
return|return
name|implementationFormatInfo
operator|.
name|type
return|;
block|}
DECL|function|readPixels
name|gl
operator|::
name|Error
name|FramebufferD3D
operator|::
name|readPixels
parameter_list|(
specifier|const
name|gl
operator|::
name|State
modifier|&
name|state
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|area
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLvoid
modifier|*
name|pixels
parameter_list|)
specifier|const
block|{
specifier|const
name|gl
operator|::
name|PixelPackState
modifier|&
name|packState
init|=
name|state
operator|.
name|getPackState
argument_list|()
decl_stmt|;
if|if
condition|(
name|packState
operator|.
name|rowLength
operator|!=
literal|0
operator|||
name|packState
operator|.
name|skipRows
operator|!=
literal|0
operator|||
name|packState
operator|.
name|skipPixels
operator|!=
literal|0
condition|)
block|{
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"invalid pixel store parameters in readPixels"
argument_list|)
return|;
block|}
name|GLenum
name|sizedInternalFormat
init|=
name|gl
operator|::
name|GetSizedInternalFormat
argument_list|(
name|format
argument_list|,
name|type
argument_list|)
decl_stmt|;
specifier|const
name|gl
operator|::
name|InternalFormat
modifier|&
name|sizedFormatInfo
init|=
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|sizedInternalFormat
argument_list|)
decl_stmt|;
name|GLuint
name|outputPitch
init|=
name|sizedFormatInfo
operator|.
name|computeRowPitch
argument_list|(
name|type
argument_list|,
name|area
operator|.
name|width
argument_list|,
name|packState
operator|.
name|alignment
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
name|readPixels
argument_list|(
name|area
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|outputPitch
argument_list|,
name|packState
argument_list|,
cast|reinterpret_cast
argument_list|<
name|uint8_t
operator|*
argument_list|>
argument_list|(
name|pixels
argument_list|)
argument_list|)
return|;
block|}
DECL|function|blit
name|gl
operator|::
name|Error
name|FramebufferD3D
operator|::
name|blit
parameter_list|(
specifier|const
name|gl
operator|::
name|State
modifier|&
name|state
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|sourceArea
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|destArea
parameter_list|,
name|GLbitfield
name|mask
parameter_list|,
name|GLenum
name|filter
parameter_list|,
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|sourceFramebuffer
parameter_list|)
block|{
name|bool
name|blitRenderTarget
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|GL_COLOR_BUFFER_BIT
operator|)
operator|&&
name|sourceFramebuffer
operator|->
name|getReadColorbuffer
argument_list|()
operator|!=
literal|nullptr
operator|&&
name|mData
operator|.
name|getFirstColorAttachment
argument_list|()
operator|!=
literal|nullptr
condition|)
block|{
name|blitRenderTarget
operator|=
literal|true
expr_stmt|;
block|}
name|bool
name|blitStencil
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|GL_STENCIL_BUFFER_BIT
operator|)
operator|&&
name|sourceFramebuffer
operator|->
name|getStencilbuffer
argument_list|()
operator|!=
literal|nullptr
operator|&&
name|mData
operator|.
name|mStencilAttachment
operator|!=
literal|nullptr
condition|)
block|{
name|blitStencil
operator|=
literal|true
expr_stmt|;
block|}
name|bool
name|blitDepth
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|GL_DEPTH_BUFFER_BIT
operator|)
operator|&&
name|sourceFramebuffer
operator|->
name|getDepthbuffer
argument_list|()
operator|!=
literal|nullptr
operator|&&
name|mData
operator|.
name|mDepthAttachment
operator|!=
literal|nullptr
condition|)
block|{
name|blitDepth
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|blitRenderTarget
operator|||
name|blitDepth
operator|||
name|blitStencil
condition|)
block|{
specifier|const
name|gl
operator|::
name|Rectangle
modifier|*
name|scissor
init|=
name|state
operator|.
name|isScissorTestEnabled
argument_list|()
condition|?
operator|&
name|state
operator|.
name|getScissor
argument_list|()
else|:
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|blit
argument_list|(
name|sourceArea
argument_list|,
name|destArea
argument_list|,
name|scissor
argument_list|,
name|blitRenderTarget
argument_list|,
name|blitDepth
argument_list|,
name|blitStencil
argument_list|,
name|filter
argument_list|,
name|sourceFramebuffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|checkStatus
name|GLenum
name|FramebufferD3D
operator|::
name|checkStatus
parameter_list|()
specifier|const
block|{
comment|// D3D11 does not allow for overlapping RenderTargetViews, so ensure uniqueness
for|for
control|(
name|size_t
name|colorAttachment
init|=
literal|0
init|;
name|colorAttachment
operator|<
name|mData
operator|.
name|mColorAttachments
operator|.
name|size
argument_list|()
condition|;
name|colorAttachment
operator|++
control|)
block|{
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|attachment
init|=
name|mData
operator|.
name|mColorAttachments
index|[
name|colorAttachment
index|]
decl_stmt|;
if|if
condition|(
name|attachment
operator|!=
literal|nullptr
condition|)
block|{
for|for
control|(
name|size_t
name|prevColorAttachment
init|=
literal|0
init|;
name|prevColorAttachment
operator|<
name|colorAttachment
condition|;
name|prevColorAttachment
operator|++
control|)
block|{
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|prevAttachment
init|=
name|mData
operator|.
name|mColorAttachments
index|[
name|prevColorAttachment
index|]
decl_stmt|;
if|if
condition|(
name|prevAttachment
operator|!=
literal|nullptr
operator|&&
operator|(
name|attachment
operator|->
name|id
argument_list|()
operator|==
name|prevAttachment
operator|->
name|id
argument_list|()
operator|&&
name|attachment
operator|->
name|type
argument_list|()
operator|==
name|prevAttachment
operator|->
name|type
argument_list|()
operator|)
condition|)
block|{
return|return
name|GL_FRAMEBUFFER_UNSUPPORTED
return|;
block|}
block|}
block|}
block|}
return|return
name|GL_FRAMEBUFFER_COMPLETE
return|;
block|}
DECL|function|getColorAttachmentsForRender
specifier|const
name|gl
operator|::
name|AttachmentList
modifier|&
name|FramebufferD3D
operator|::
name|getColorAttachmentsForRender
parameter_list|(
specifier|const
name|Workarounds
modifier|&
name|workarounds
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|workarounds
operator|.
name|mrtPerfWorkaround
condition|)
block|{
return|return
name|mData
operator|.
name|mColorAttachments
return|;
block|}
if|if
condition|(
operator|!
name|mInvalidateColorAttachmentCache
condition|)
block|{
return|return
name|mColorAttachmentsForRender
return|;
block|}
comment|// Does not actually free memory
name|mColorAttachmentsForRender
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|size_t
name|attachmentIndex
init|=
literal|0
init|;
name|attachmentIndex
operator|<
name|mData
operator|.
name|mColorAttachments
operator|.
name|size
argument_list|()
condition|;
operator|++
name|attachmentIndex
control|)
block|{
name|GLenum
name|drawBufferState
init|=
name|mData
operator|.
name|mDrawBufferStates
index|[
name|attachmentIndex
index|]
decl_stmt|;
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|colorAttachment
init|=
name|mData
operator|.
name|mColorAttachments
index|[
name|attachmentIndex
index|]
decl_stmt|;
if|if
condition|(
name|colorAttachment
operator|!=
literal|nullptr
operator|&&
name|drawBufferState
operator|!=
name|GL_NONE
condition|)
block|{
name|ASSERT
argument_list|(
name|drawBufferState
operator|==
name|GL_BACK
operator|||
name|drawBufferState
operator|==
operator|(
name|GL_COLOR_ATTACHMENT0_EXT
operator|+
name|attachmentIndex
operator|)
argument_list|)
expr_stmt|;
name|mColorAttachmentsForRender
operator|.
name|push_back
argument_list|(
name|colorAttachment
argument_list|)
expr_stmt|;
block|}
block|}
name|mInvalidateColorAttachmentCache
operator|=
literal|false
expr_stmt|;
return|return
name|mColorAttachmentsForRender
return|;
block|}
DECL|function|GetAttachmentRenderTarget
name|gl
operator|::
name|Error
name|GetAttachmentRenderTarget
parameter_list|(
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|attachment
parameter_list|,
name|RenderTargetD3D
modifier|*
modifier|*
name|outRT
parameter_list|)
block|{
if|if
condition|(
name|attachment
operator|->
name|type
argument_list|()
operator|==
name|GL_TEXTURE
condition|)
block|{
name|gl
operator|::
name|Texture
modifier|*
name|texture
init|=
name|attachment
operator|->
name|getTexture
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|texture
argument_list|)
expr_stmt|;
name|TextureD3D
modifier|*
name|textureD3D
init|=
name|GetImplAs
argument_list|<
name|TextureD3D
argument_list|>
argument_list|(
name|texture
argument_list|)
decl_stmt|;
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|*
name|index
init|=
name|attachment
operator|->
name|getTextureImageIndex
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|index
argument_list|)
expr_stmt|;
return|return
name|textureD3D
operator|->
name|getRenderTarget
argument_list|(
operator|*
name|index
argument_list|,
name|outRT
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|attachment
operator|->
name|type
argument_list|()
operator|==
name|GL_RENDERBUFFER
condition|)
block|{
name|gl
operator|::
name|Renderbuffer
modifier|*
name|renderbuffer
init|=
name|attachment
operator|->
name|getRenderbuffer
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|renderbuffer
argument_list|)
expr_stmt|;
name|RenderbufferD3D
modifier|*
name|renderbufferD3D
init|=
name|RenderbufferD3D
operator|::
name|makeRenderbufferD3D
argument_list|(
name|renderbuffer
operator|->
name|getImplementation
argument_list|()
argument_list|)
decl_stmt|;
operator|*
name|outRT
operator|=
name|renderbufferD3D
operator|->
name|getRenderTarget
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|attachment
operator|->
name|type
argument_list|()
operator|==
name|GL_FRAMEBUFFER_DEFAULT
condition|)
block|{
specifier|const
name|gl
operator|::
name|DefaultAttachment
modifier|*
name|defaultAttachment
init|=
cast|static_cast
argument_list|<
specifier|const
name|gl
operator|::
name|DefaultAttachment
operator|*
argument_list|>
argument_list|(
name|attachment
argument_list|)
decl_stmt|;
specifier|const
name|egl
operator|::
name|Surface
modifier|*
name|surface
init|=
name|defaultAttachment
operator|->
name|getSurface
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|surface
argument_list|)
expr_stmt|;
specifier|const
name|SurfaceD3D
modifier|*
name|surfaceD3D
init|=
name|GetImplAs
argument_list|<
name|SurfaceD3D
argument_list|>
argument_list|(
name|surface
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|surfaceD3D
argument_list|)
expr_stmt|;
if|if
condition|(
name|defaultAttachment
operator|->
name|getBinding
argument_list|()
operator|==
name|GL_BACK
condition|)
block|{
operator|*
name|outRT
operator|=
name|surfaceD3D
operator|->
name|getSwapChain
argument_list|()
operator|->
name|getColorRenderTarget
argument_list|()
expr_stmt|;
block|}
else|else
block|{
operator|*
name|outRT
operator|=
name|surfaceD3D
operator|->
name|getSwapChain
argument_list|()
operator|->
name|getDepthStencilRenderTarget
argument_list|()
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
else|else
block|{
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
block|}
comment|// Note: RenderTarget serials should ideally be in the RenderTargets themselves.
DECL|function|GetAttachmentSerial
name|unsigned
name|int
name|GetAttachmentSerial
parameter_list|(
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|attachment
parameter_list|)
block|{
if|if
condition|(
name|attachment
operator|->
name|type
argument_list|()
operator|==
name|GL_TEXTURE
condition|)
block|{
name|gl
operator|::
name|Texture
modifier|*
name|texture
init|=
name|attachment
operator|->
name|getTexture
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|texture
argument_list|)
expr_stmt|;
name|TextureD3D
modifier|*
name|textureD3D
init|=
name|GetImplAs
argument_list|<
name|TextureD3D
argument_list|>
argument_list|(
name|texture
argument_list|)
decl_stmt|;
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|*
name|index
init|=
name|attachment
operator|->
name|getTextureImageIndex
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|index
argument_list|)
expr_stmt|;
return|return
name|textureD3D
operator|->
name|getRenderTargetSerial
argument_list|(
operator|*
name|index
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|attachment
operator|->
name|type
argument_list|()
operator|==
name|GL_RENDERBUFFER
condition|)
block|{
name|gl
operator|::
name|Renderbuffer
modifier|*
name|renderbuffer
init|=
name|attachment
operator|->
name|getRenderbuffer
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|renderbuffer
argument_list|)
expr_stmt|;
name|RenderbufferD3D
modifier|*
name|renderbufferD3D
init|=
name|RenderbufferD3D
operator|::
name|makeRenderbufferD3D
argument_list|(
name|renderbuffer
operator|->
name|getImplementation
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|renderbufferD3D
operator|->
name|getRenderTargetSerial
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|attachment
operator|->
name|type
argument_list|()
operator|==
name|GL_FRAMEBUFFER_DEFAULT
condition|)
block|{
specifier|const
name|gl
operator|::
name|DefaultAttachment
modifier|*
name|defaultAttachment
init|=
cast|static_cast
argument_list|<
specifier|const
name|gl
operator|::
name|DefaultAttachment
operator|*
argument_list|>
argument_list|(
name|attachment
argument_list|)
decl_stmt|;
specifier|const
name|egl
operator|::
name|Surface
modifier|*
name|surface
init|=
name|defaultAttachment
operator|->
name|getSurface
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|surface
argument_list|)
expr_stmt|;
specifier|const
name|SurfaceD3D
modifier|*
name|surfaceD3D
init|=
name|GetImplAs
argument_list|<
name|SurfaceD3D
argument_list|>
argument_list|(
name|surface
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|surfaceD3D
argument_list|)
expr_stmt|;
if|if
condition|(
name|defaultAttachment
operator|->
name|getBinding
argument_list|()
operator|==
name|GL_BACK
condition|)
block|{
return|return
name|surfaceD3D
operator|->
name|getSwapChain
argument_list|()
operator|->
name|getColorRenderTarget
argument_list|()
operator|->
name|getSerial
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|surfaceD3D
operator|->
name|getSwapChain
argument_list|()
operator|->
name|getDepthStencilRenderTarget
argument_list|()
operator|->
name|getSerial
argument_list|()
return|;
block|}
block|}
else|else
block|{
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
end_namespace
end_unit
