begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// ProgramD3D.cpp: Defines the rx::ProgramD3D class which implements rx::ProgramImpl.
end_comment
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/ProgramD3D.h"
end_include
begin_include
include|#
directive|include
file|"common/BitSetIterator.h"
end_include
begin_include
include|#
directive|include
file|"common/utilities.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Framebuffer.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/FramebufferAttachment.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Program.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/VertexArray.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/features.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/DynamicHLSL.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/FramebufferD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/RendererD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/ShaderD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/ShaderExecutableD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/VaryingPacking.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/VertexDataManager.h"
end_include
begin_namespace
DECL|namespace|rx
namespace|namespace
name|rx
block|{
namespace|namespace
block|{
DECL|function|GetDefaultInputLayoutFromShader
name|gl
operator|::
name|InputLayout
name|GetDefaultInputLayoutFromShader
parameter_list|(
specifier|const
name|gl
operator|::
name|Shader
modifier|*
name|vertexShader
parameter_list|)
block|{
name|gl
operator|::
name|InputLayout
name|defaultLayout
decl_stmt|;
for|for
control|(
specifier|const
name|sh
operator|::
name|Attribute
modifier|&
name|shaderAttr
range|:
name|vertexShader
operator|->
name|getActiveAttributes
argument_list|()
control|)
block|{
if|if
condition|(
name|shaderAttr
operator|.
name|type
operator|!=
name|GL_NONE
condition|)
block|{
name|GLenum
name|transposedType
init|=
name|gl
operator|::
name|TransposeMatrixType
argument_list|(
name|shaderAttr
operator|.
name|type
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|rowIndex
init|=
literal|0
init|;
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|rowIndex
argument_list|)
operator|<
name|gl
operator|::
name|VariableRowCount
argument_list|(
name|transposedType
argument_list|)
condition|;
operator|++
name|rowIndex
control|)
block|{
name|GLenum
name|componentType
init|=
name|gl
operator|::
name|VariableComponentType
argument_list|(
name|transposedType
argument_list|)
decl_stmt|;
name|GLuint
name|components
init|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|gl
operator|::
name|VariableColumnCount
argument_list|(
name|transposedType
argument_list|)
argument_list|)
decl_stmt|;
name|bool
name|pureInt
init|=
operator|(
name|componentType
operator|!=
name|GL_FLOAT
operator|)
decl_stmt|;
name|gl
operator|::
name|VertexFormatType
name|defaultType
init|=
name|gl
operator|::
name|GetVertexFormatType
argument_list|(
name|componentType
argument_list|,
name|GL_FALSE
argument_list|,
name|components
argument_list|,
name|pureInt
argument_list|)
decl_stmt|;
name|defaultLayout
operator|.
name|push_back
argument_list|(
name|defaultType
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|defaultLayout
return|;
block|}
DECL|function|GetDefaultOutputLayoutFromShader
name|std
operator|::
name|vector
argument_list|<
name|GLenum
argument_list|>
name|GetDefaultOutputLayoutFromShader
parameter_list|(
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|PixelShaderOutputVariable
argument_list|>
modifier|&
name|shaderOutputVars
parameter_list|)
block|{
name|std
operator|::
name|vector
argument_list|<
name|GLenum
argument_list|>
name|defaultPixelOutput
decl_stmt|;
if|if
condition|(
operator|!
name|shaderOutputVars
operator|.
name|empty
argument_list|()
condition|)
block|{
name|defaultPixelOutput
operator|.
name|push_back
argument_list|(
name|GL_COLOR_ATTACHMENT0
operator|+
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|shaderOutputVars
index|[
literal|0
index|]
operator|.
name|outputIndex
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|defaultPixelOutput
return|;
block|}
DECL|function|IsRowMajorLayout
name|bool
name|IsRowMajorLayout
parameter_list|(
specifier|const
name|sh
operator|::
name|InterfaceBlockField
modifier|&
name|var
parameter_list|)
block|{
return|return
name|var
operator|.
name|isRowMajorLayout
return|;
block|}
DECL|function|IsRowMajorLayout
name|bool
name|IsRowMajorLayout
parameter_list|(
specifier|const
name|sh
operator|::
name|ShaderVariable
modifier|&
name|var
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
DECL|struct|AttributeSorter
struct|struct
name|AttributeSorter
block|{
DECL|function|AttributeSorter
name|AttributeSorter
parameter_list|(
specifier|const
name|ProgramD3D
operator|::
name|SemanticIndexArray
modifier|&
name|semanticIndices
parameter_list|)
member_init_list|:
name|originalIndices
argument_list|(
operator|&
name|semanticIndices
argument_list|)
block|{     }
DECL|function|operator ()
name|bool
name|operator
name|()
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
name|int
name|indexA
init|=
operator|(
operator|*
name|originalIndices
operator|)
index|[
name|a
index|]
decl_stmt|;
name|int
name|indexB
init|=
operator|(
operator|*
name|originalIndices
operator|)
index|[
name|b
index|]
decl_stmt|;
if|if
condition|(
name|indexA
operator|==
operator|-
literal|1
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|indexB
operator|==
operator|-
literal|1
condition|)
return|return
literal|true
return|;
return|return
operator|(
name|indexA
operator|<
name|indexB
operator|)
return|;
block|}
DECL|member|originalIndices
specifier|const
name|ProgramD3D
operator|::
name|SemanticIndexArray
modifier|*
name|originalIndices
decl_stmt|;
block|}
struct|;
comment|// true if varying x has a higher priority in packing than y
DECL|function|ComparePackedVarying
name|bool
name|ComparePackedVarying
parameter_list|(
specifier|const
name|PackedVarying
modifier|&
name|x
parameter_list|,
specifier|const
name|PackedVarying
modifier|&
name|y
parameter_list|)
block|{
return|return
name|gl
operator|::
name|CompareShaderVar
argument_list|(
operator|*
name|x
operator|.
name|varying
argument_list|,
operator|*
name|y
operator|.
name|varying
argument_list|)
return|;
block|}
DECL|function|MergeVaryings
name|std
operator|::
name|vector
argument_list|<
name|PackedVarying
argument_list|>
name|MergeVaryings
parameter_list|(
specifier|const
name|gl
operator|::
name|Shader
modifier|&
name|vertexShader
parameter_list|,
specifier|const
name|gl
operator|::
name|Shader
modifier|&
name|fragmentShader
parameter_list|,
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|std
operator|::
name|string
argument_list|>
modifier|&
name|tfVaryings
parameter_list|)
block|{
name|std
operator|::
name|vector
argument_list|<
name|PackedVarying
argument_list|>
name|packedVaryings
decl_stmt|;
for|for
control|(
specifier|const
name|sh
operator|::
name|Varying
modifier|&
name|output
range|:
name|vertexShader
operator|.
name|getVaryings
argument_list|()
control|)
block|{
name|bool
name|packed
init|=
literal|false
decl_stmt|;
comment|// Built-in varyings obey special rules
if|if
condition|(
name|output
operator|.
name|isBuiltIn
argument_list|()
condition|)
block|{
continue|continue;
block|}
for|for
control|(
specifier|const
name|sh
operator|::
name|Varying
modifier|&
name|input
range|:
name|fragmentShader
operator|.
name|getVaryings
argument_list|()
control|)
block|{
if|if
condition|(
name|output
operator|.
name|name
operator|==
name|input
operator|.
name|name
condition|)
block|{
if|if
condition|(
name|output
operator|.
name|isStruct
argument_list|()
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|output
operator|.
name|isArray
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|field
range|:
name|output
operator|.
name|fields
control|)
block|{
name|ASSERT
argument_list|(
operator|!
name|field
operator|.
name|isStruct
argument_list|()
operator|&&
operator|!
name|field
operator|.
name|isArray
argument_list|()
argument_list|)
expr_stmt|;
name|packedVaryings
operator|.
name|push_back
argument_list|(
name|PackedVarying
argument_list|(
name|field
argument_list|,
name|input
operator|.
name|interpolation
argument_list|,
name|input
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|packedVaryings
operator|.
name|push_back
argument_list|(
name|PackedVarying
argument_list|(
name|input
argument_list|,
name|input
operator|.
name|interpolation
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|packed
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
comment|// Keep Transform FB varyings in the merged list always.
if|if
condition|(
operator|!
name|packed
condition|)
block|{
for|for
control|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|tfVarying
range|:
name|tfVaryings
control|)
block|{
if|if
condition|(
name|tfVarying
operator|==
name|output
operator|.
name|name
condition|)
block|{
comment|// Transform feedback for varying structs is underspecified.
comment|// See Khronos bug 9856.
comment|// TODO(jmadill): Figure out how to be spec-compliant here.
if|if
condition|(
operator|!
name|output
operator|.
name|isStruct
argument_list|()
condition|)
block|{
name|packedVaryings
operator|.
name|push_back
argument_list|(
name|PackedVarying
argument_list|(
name|output
argument_list|,
name|output
operator|.
name|interpolation
argument_list|)
argument_list|)
expr_stmt|;
name|packedVaryings
operator|.
name|back
argument_list|()
operator|.
name|vertexOnly
operator|=
literal|true
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
block|}
name|std
operator|::
name|sort
argument_list|(
name|packedVaryings
operator|.
name|begin
argument_list|()
argument_list|,
name|packedVaryings
operator|.
name|end
argument_list|()
argument_list|,
name|ComparePackedVarying
argument_list|)
expr_stmt|;
return|return
name|packedVaryings
return|;
block|}
template|template
parameter_list|<
name|typename
name|VarT
parameter_list|>
DECL|function|GetUniformBlockInfo
name|void
name|GetUniformBlockInfo
parameter_list|(
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|VarT
argument_list|>
modifier|&
name|fields
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|prefix
parameter_list|,
name|sh
operator|::
name|BlockLayoutEncoder
modifier|*
name|encoder
parameter_list|,
name|bool
name|inRowMajorLayout
parameter_list|,
name|std
operator|::
name|map
argument_list|<
name|std
operator|::
name|string
argument_list|,
name|sh
operator|::
name|BlockMemberInfo
argument_list|>
modifier|*
name|blockInfoOut
parameter_list|)
block|{
for|for
control|(
specifier|const
name|VarT
modifier|&
name|field
range|:
name|fields
control|)
block|{
specifier|const
name|std
operator|::
name|string
modifier|&
name|fieldName
init|=
operator|(
name|prefix
operator|.
name|empty
argument_list|()
condition|?
name|field
operator|.
name|name
else|:
name|prefix
operator|+
literal|"."
operator|+
name|field
operator|.
name|name
operator|)
decl_stmt|;
if|if
condition|(
name|field
operator|.
name|isStruct
argument_list|()
condition|)
block|{
name|bool
name|rowMajorLayout
init|=
operator|(
name|inRowMajorLayout
operator|||
name|IsRowMajorLayout
argument_list|(
name|field
argument_list|)
operator|)
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|arrayElement
init|=
literal|0
init|;
name|arrayElement
operator|<
name|field
operator|.
name|elementCount
argument_list|()
condition|;
name|arrayElement
operator|++
control|)
block|{
name|encoder
operator|->
name|enterAggregateType
argument_list|()
expr_stmt|;
specifier|const
name|std
operator|::
name|string
name|uniformElementName
init|=
name|fieldName
operator|+
operator|(
name|field
operator|.
name|isArray
argument_list|()
condition|?
name|ArrayString
argument_list|(
name|arrayElement
argument_list|)
else|:
literal|""
operator|)
decl_stmt|;
name|GetUniformBlockInfo
argument_list|(
name|field
operator|.
name|fields
argument_list|,
name|uniformElementName
argument_list|,
name|encoder
argument_list|,
name|rowMajorLayout
argument_list|,
name|blockInfoOut
argument_list|)
expr_stmt|;
name|encoder
operator|->
name|exitAggregateType
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|bool
name|isRowMajorMatrix
init|=
operator|(
name|gl
operator|::
name|IsMatrixType
argument_list|(
name|field
operator|.
name|type
argument_list|)
operator|&&
name|inRowMajorLayout
operator|)
decl_stmt|;
operator|(
operator|*
name|blockInfoOut
operator|)
index|[
name|fieldName
index|]
operator|=
name|encoder
operator|->
name|encodeType
argument_list|(
name|field
operator|.
name|type
argument_list|,
name|field
operator|.
name|arraySize
argument_list|,
name|isRowMajorMatrix
argument_list|)
expr_stmt|;
block|}
block|}
block|}
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|SetIfDirty
specifier|static
specifier|inline
name|void
name|SetIfDirty
parameter_list|(
name|T
modifier|*
name|dest
parameter_list|,
specifier|const
name|T
modifier|&
name|source
parameter_list|,
name|bool
modifier|*
name|dirtyFlag
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|dest
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dirtyFlag
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|dirtyFlag
operator|=
operator|*
name|dirtyFlag
operator|||
operator|(
name|memcmp
argument_list|(
name|dest
argument_list|,
operator|&
name|source
argument_list|,
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
operator|*
name|dest
operator|=
name|source
expr_stmt|;
block|}
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|TransposeMatrix
name|bool
name|TransposeMatrix
parameter_list|(
name|T
modifier|*
name|target
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|,
name|int
name|targetWidth
parameter_list|,
name|int
name|targetHeight
parameter_list|,
name|int
name|srcWidth
parameter_list|,
name|int
name|srcHeight
parameter_list|)
block|{
name|bool
name|dirty
init|=
literal|false
decl_stmt|;
name|int
name|copyWidth
init|=
name|std
operator|::
name|min
argument_list|(
name|targetHeight
argument_list|,
name|srcWidth
argument_list|)
decl_stmt|;
name|int
name|copyHeight
init|=
name|std
operator|::
name|min
argument_list|(
name|targetWidth
argument_list|,
name|srcHeight
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|copyWidth
condition|;
name|x
operator|++
control|)
block|{
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|copyHeight
condition|;
name|y
operator|++
control|)
block|{
name|SetIfDirty
argument_list|(
name|target
operator|+
operator|(
name|x
operator|*
name|targetWidth
operator|+
name|y
operator|)
argument_list|,
cast|static_cast
argument_list|<
name|T
argument_list|>
argument_list|(
name|value
index|[
name|y
operator|*
name|srcWidth
operator|+
name|x
index|]
argument_list|)
argument_list|,
operator|&
name|dirty
argument_list|)
expr_stmt|;
block|}
block|}
comment|// clear unfilled right side
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|copyWidth
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
name|copyHeight
init|;
name|x
operator|<
name|targetWidth
condition|;
name|x
operator|++
control|)
block|{
name|SetIfDirty
argument_list|(
name|target
operator|+
operator|(
name|y
operator|*
name|targetWidth
operator|+
name|x
operator|)
argument_list|,
cast|static_cast
argument_list|<
name|T
argument_list|>
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|dirty
argument_list|)
expr_stmt|;
block|}
block|}
comment|// clear unfilled bottom.
for|for
control|(
name|int
name|y
init|=
name|copyWidth
init|;
name|y
operator|<
name|targetHeight
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|targetWidth
condition|;
name|x
operator|++
control|)
block|{
name|SetIfDirty
argument_list|(
name|target
operator|+
operator|(
name|y
operator|*
name|targetWidth
operator|+
name|x
operator|)
argument_list|,
cast|static_cast
argument_list|<
name|T
argument_list|>
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|dirty
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|dirty
return|;
block|}
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|ExpandMatrix
name|bool
name|ExpandMatrix
parameter_list|(
name|T
modifier|*
name|target
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|,
name|int
name|targetWidth
parameter_list|,
name|int
name|targetHeight
parameter_list|,
name|int
name|srcWidth
parameter_list|,
name|int
name|srcHeight
parameter_list|)
block|{
name|bool
name|dirty
init|=
literal|false
decl_stmt|;
name|int
name|copyWidth
init|=
name|std
operator|::
name|min
argument_list|(
name|targetWidth
argument_list|,
name|srcWidth
argument_list|)
decl_stmt|;
name|int
name|copyHeight
init|=
name|std
operator|::
name|min
argument_list|(
name|targetHeight
argument_list|,
name|srcHeight
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|copyHeight
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|copyWidth
condition|;
name|x
operator|++
control|)
block|{
name|SetIfDirty
argument_list|(
name|target
operator|+
operator|(
name|y
operator|*
name|targetWidth
operator|+
name|x
operator|)
argument_list|,
cast|static_cast
argument_list|<
name|T
argument_list|>
argument_list|(
name|value
index|[
name|y
operator|*
name|srcWidth
operator|+
name|x
index|]
argument_list|)
argument_list|,
operator|&
name|dirty
argument_list|)
expr_stmt|;
block|}
block|}
comment|// clear unfilled right side
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|copyHeight
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
name|copyWidth
init|;
name|x
operator|<
name|targetWidth
condition|;
name|x
operator|++
control|)
block|{
name|SetIfDirty
argument_list|(
name|target
operator|+
operator|(
name|y
operator|*
name|targetWidth
operator|+
name|x
operator|)
argument_list|,
cast|static_cast
argument_list|<
name|T
argument_list|>
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|dirty
argument_list|)
expr_stmt|;
block|}
block|}
comment|// clear unfilled bottom.
for|for
control|(
name|int
name|y
init|=
name|copyHeight
init|;
name|y
operator|<
name|targetHeight
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|targetWidth
condition|;
name|x
operator|++
control|)
block|{
name|SetIfDirty
argument_list|(
name|target
operator|+
operator|(
name|y
operator|*
name|targetWidth
operator|+
name|x
operator|)
argument_list|,
cast|static_cast
argument_list|<
name|T
argument_list|>
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|dirty
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|dirty
return|;
block|}
DECL|function|GetGeometryShaderTypeFromDrawMode
name|gl
operator|::
name|PrimitiveType
name|GetGeometryShaderTypeFromDrawMode
parameter_list|(
name|GLenum
name|drawMode
parameter_list|)
block|{
switch|switch
condition|(
name|drawMode
condition|)
block|{
comment|// Uses the point sprite geometry shader.
case|case
name|GL_POINTS
case|:
return|return
name|gl
operator|::
name|PRIMITIVE_POINTS
return|;
comment|// All line drawing uses the same geometry shader.
case|case
name|GL_LINES
case|:
case|case
name|GL_LINE_STRIP
case|:
case|case
name|GL_LINE_LOOP
case|:
return|return
name|gl
operator|::
name|PRIMITIVE_LINES
return|;
comment|// The triangle fan primitive is emulated with strips in D3D11.
case|case
name|GL_TRIANGLES
case|:
case|case
name|GL_TRIANGLE_FAN
case|:
return|return
name|gl
operator|::
name|PRIMITIVE_TRIANGLES
return|;
comment|// Special case for triangle strips.
case|case
name|GL_TRIANGLE_STRIP
case|:
return|return
name|gl
operator|::
name|PRIMITIVE_TRIANGLE_STRIP
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|PRIMITIVE_TYPE_MAX
return|;
block|}
block|}
block|}
comment|// anonymous namespace
comment|// D3DUniform Implementation
DECL|function|D3DUniform
name|D3DUniform
operator|::
name|D3DUniform
parameter_list|(
name|GLenum
name|typeIn
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|nameIn
parameter_list|,
name|unsigned
name|int
name|arraySizeIn
parameter_list|,
name|bool
name|defaultBlock
parameter_list|)
member_init_list|:
name|type
argument_list|(
name|typeIn
argument_list|)
member_init_list|,
name|name
argument_list|(
name|nameIn
argument_list|)
member_init_list|,
name|arraySize
argument_list|(
name|arraySizeIn
argument_list|)
member_init_list|,
name|data
argument_list|(
literal|nullptr
argument_list|)
member_init_list|,
name|dirty
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|vsRegisterIndex
argument_list|(
name|GL_INVALID_INDEX
argument_list|)
member_init_list|,
name|psRegisterIndex
argument_list|(
name|GL_INVALID_INDEX
argument_list|)
member_init_list|,
name|registerCount
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|registerElement
argument_list|(
literal|0
argument_list|)
block|{
comment|// We use data storage for default block uniforms to cache values that are sent to D3D during
comment|// rendering
comment|// Uniform blocks/buffers are treated separately by the Renderer (ES3 path only)
if|if
condition|(
name|defaultBlock
condition|)
block|{
name|size_t
name|bytes
init|=
name|gl
operator|::
name|VariableInternalSize
argument_list|(
name|type
argument_list|)
operator|*
name|elementCount
argument_list|()
decl_stmt|;
name|data
operator|=
operator|new
name|uint8_t
index|[
name|bytes
index|]
expr_stmt|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
comment|// TODO(jmadill): is this correct with non-square matrices?
name|registerCount
operator|=
name|gl
operator|::
name|VariableRowCount
argument_list|(
name|type
argument_list|)
operator|*
name|elementCount
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|~D3DUniform
name|D3DUniform
operator|::
name|~
name|D3DUniform
parameter_list|()
block|{
name|SafeDeleteArray
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
DECL|function|isSampler
name|bool
name|D3DUniform
operator|::
name|isSampler
parameter_list|()
specifier|const
block|{
return|return
name|gl
operator|::
name|IsSamplerType
argument_list|(
name|type
argument_list|)
return|;
block|}
DECL|function|isReferencedByVertexShader
name|bool
name|D3DUniform
operator|::
name|isReferencedByVertexShader
parameter_list|()
specifier|const
block|{
return|return
name|vsRegisterIndex
operator|!=
name|GL_INVALID_INDEX
return|;
block|}
DECL|function|isReferencedByFragmentShader
name|bool
name|D3DUniform
operator|::
name|isReferencedByFragmentShader
parameter_list|()
specifier|const
block|{
return|return
name|psRegisterIndex
operator|!=
name|GL_INVALID_INDEX
return|;
block|}
comment|// D3DVarying Implementation
DECL|function|D3DVarying
name|D3DVarying
operator|::
name|D3DVarying
parameter_list|()
member_init_list|:
name|semanticIndex
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|componentCount
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|outputSlot
argument_list|(
literal|0
argument_list|)
block|{ }
DECL|function|D3DVarying
name|D3DVarying
operator|::
name|D3DVarying
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|semanticNameIn
parameter_list|,
name|unsigned
name|int
name|semanticIndexIn
parameter_list|,
name|unsigned
name|int
name|componentCountIn
parameter_list|,
name|unsigned
name|int
name|outputSlotIn
parameter_list|)
member_init_list|:
name|semanticName
argument_list|(
name|semanticNameIn
argument_list|)
member_init_list|,
name|semanticIndex
argument_list|(
name|semanticIndexIn
argument_list|)
member_init_list|,
name|componentCount
argument_list|(
name|componentCountIn
argument_list|)
member_init_list|,
name|outputSlot
argument_list|(
name|outputSlotIn
argument_list|)
block|{ }
comment|// ProgramD3DMetadata Implementation
DECL|function|ProgramD3DMetadata
name|ProgramD3DMetadata
operator|::
name|ProgramD3DMetadata
parameter_list|(
name|int
name|rendererMajorShaderModel
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|shaderModelSuffix
parameter_list|,
name|bool
name|usesInstancedPointSpriteEmulation
parameter_list|,
name|bool
name|usesViewScale
parameter_list|,
specifier|const
name|ShaderD3D
modifier|*
name|vertexShader
parameter_list|,
specifier|const
name|ShaderD3D
modifier|*
name|fragmentShader
parameter_list|)
member_init_list|:
name|mRendererMajorShaderModel
argument_list|(
name|rendererMajorShaderModel
argument_list|)
member_init_list|,
name|mShaderModelSuffix
argument_list|(
name|shaderModelSuffix
argument_list|)
member_init_list|,
name|mUsesInstancedPointSpriteEmulation
argument_list|(
name|usesInstancedPointSpriteEmulation
argument_list|)
member_init_list|,
name|mUsesViewScale
argument_list|(
name|usesViewScale
argument_list|)
member_init_list|,
name|mVertexShader
argument_list|(
name|vertexShader
argument_list|)
member_init_list|,
name|mFragmentShader
argument_list|(
name|fragmentShader
argument_list|)
block|{ }
DECL|function|getRendererMajorShaderModel
name|int
name|ProgramD3DMetadata
operator|::
name|getRendererMajorShaderModel
parameter_list|()
specifier|const
block|{
return|return
name|mRendererMajorShaderModel
return|;
block|}
DECL|function|usesBroadcast
name|bool
name|ProgramD3DMetadata
operator|::
name|usesBroadcast
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|mFragmentShader
operator|->
name|usesFragColor
argument_list|()
operator|&&
name|data
operator|.
name|clientVersion
operator|<
literal|3
operator|)
return|;
block|}
DECL|function|usesFragDepth
name|bool
name|ProgramD3DMetadata
operator|::
name|usesFragDepth
parameter_list|(
specifier|const
name|gl
operator|::
name|Program
operator|::
name|Data
modifier|&
name|programData
parameter_list|)
specifier|const
block|{
return|return
name|mFragmentShader
operator|->
name|usesFragDepth
argument_list|()
return|;
block|}
DECL|function|usesPointCoord
name|bool
name|ProgramD3DMetadata
operator|::
name|usesPointCoord
parameter_list|()
specifier|const
block|{
return|return
name|mFragmentShader
operator|->
name|usesPointCoord
argument_list|()
return|;
block|}
DECL|function|usesFragCoord
name|bool
name|ProgramD3DMetadata
operator|::
name|usesFragCoord
parameter_list|()
specifier|const
block|{
return|return
name|mFragmentShader
operator|->
name|usesFragCoord
argument_list|()
return|;
block|}
DECL|function|usesPointSize
name|bool
name|ProgramD3DMetadata
operator|::
name|usesPointSize
parameter_list|()
specifier|const
block|{
return|return
name|mVertexShader
operator|->
name|usesPointSize
argument_list|()
return|;
block|}
DECL|function|usesInsertedPointCoordValue
name|bool
name|ProgramD3DMetadata
operator|::
name|usesInsertedPointCoordValue
parameter_list|()
specifier|const
block|{
return|return
operator|!
name|usesPointSize
argument_list|()
operator|&&
name|usesPointCoord
argument_list|()
operator|&&
name|mRendererMajorShaderModel
operator|>=
literal|4
return|;
block|}
DECL|function|usesViewScale
name|bool
name|ProgramD3DMetadata
operator|::
name|usesViewScale
parameter_list|()
specifier|const
block|{
return|return
name|mUsesViewScale
return|;
block|}
DECL|function|addsPointCoordToVertexShader
name|bool
name|ProgramD3DMetadata
operator|::
name|addsPointCoordToVertexShader
parameter_list|()
specifier|const
block|{
comment|// Instanced PointSprite emulation requires that gl_PointCoord is present in the vertex shader
comment|// VS_OUTPUT structure to ensure compatibility with the generated PS_INPUT of the pixel shader.
comment|// GeometryShader PointSprite emulation does not require this additional entry because the
comment|// GS_OUTPUT of the Geometry shader contains the pointCoord value and already matches the
comment|// PS_INPUT of the generated pixel shader. The Geometry Shader point sprite implementation needs
comment|// gl_PointSize to be in VS_OUTPUT and GS_INPUT. Instanced point sprites doesn't need
comment|// gl_PointSize in VS_OUTPUT.
return|return
operator|(
name|mUsesInstancedPointSpriteEmulation
operator|&&
name|usesPointCoord
argument_list|()
operator|)
operator|||
name|usesInsertedPointCoordValue
argument_list|()
return|;
block|}
DECL|function|usesTransformFeedbackGLPosition
name|bool
name|ProgramD3DMetadata
operator|::
name|usesTransformFeedbackGLPosition
parameter_list|()
specifier|const
block|{
comment|// gl_Position only needs to be outputted from the vertex shader if transform feedback is
comment|// active. This isn't supported on D3D11 Feature Level 9_3, so we don't output gl_Position from
comment|// the vertex shader in this case. This saves us 1 output vector.
return|return
operator|!
operator|(
name|mRendererMajorShaderModel
operator|>=
literal|4
operator|&&
name|mShaderModelSuffix
operator|!=
literal|""
operator|)
return|;
block|}
DECL|function|usesSystemValuePointSize
name|bool
name|ProgramD3DMetadata
operator|::
name|usesSystemValuePointSize
parameter_list|()
specifier|const
block|{
return|return
operator|!
name|mUsesInstancedPointSpriteEmulation
operator|&&
name|usesPointSize
argument_list|()
return|;
block|}
DECL|function|usesMultipleFragmentOuts
name|bool
name|ProgramD3DMetadata
operator|::
name|usesMultipleFragmentOuts
parameter_list|()
specifier|const
block|{
return|return
name|mFragmentShader
operator|->
name|usesMultipleRenderTargets
argument_list|()
return|;
block|}
DECL|function|getMajorShaderVersion
name|GLint
name|ProgramD3DMetadata
operator|::
name|getMajorShaderVersion
parameter_list|()
specifier|const
block|{
return|return
name|mVertexShader
operator|->
name|getData
argument_list|()
operator|.
name|getShaderVersion
argument_list|()
return|;
block|}
DECL|function|getFragmentShader
specifier|const
name|ShaderD3D
modifier|*
name|ProgramD3DMetadata
operator|::
name|getFragmentShader
parameter_list|()
specifier|const
block|{
return|return
name|mFragmentShader
return|;
block|}
comment|// ProgramD3D Implementation
DECL|function|VertexExecutable
name|ProgramD3D
operator|::
name|VertexExecutable
operator|::
name|VertexExecutable
parameter_list|(
specifier|const
name|gl
operator|::
name|InputLayout
modifier|&
name|inputLayout
parameter_list|,
specifier|const
name|Signature
modifier|&
name|signature
parameter_list|,
name|ShaderExecutableD3D
modifier|*
name|shaderExecutable
parameter_list|)
member_init_list|:
name|mInputs
argument_list|(
name|inputLayout
argument_list|)
member_init_list|,
name|mSignature
argument_list|(
name|signature
argument_list|)
member_init_list|,
name|mShaderExecutable
argument_list|(
name|shaderExecutable
argument_list|)
block|{ }
DECL|function|~VertexExecutable
name|ProgramD3D
operator|::
name|VertexExecutable
operator|::
name|~
name|VertexExecutable
parameter_list|()
block|{
name|SafeDelete
argument_list|(
name|mShaderExecutable
argument_list|)
expr_stmt|;
block|}
comment|// static
DECL|function|getSignature
name|void
name|ProgramD3D
operator|::
name|VertexExecutable
operator|::
name|getSignature
parameter_list|(
name|RendererD3D
modifier|*
name|renderer
parameter_list|,
specifier|const
name|gl
operator|::
name|InputLayout
modifier|&
name|inputLayout
parameter_list|,
name|Signature
modifier|*
name|signatureOut
parameter_list|)
block|{
name|signatureOut
operator|->
name|resize
argument_list|(
name|inputLayout
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|index
init|=
literal|0
init|;
name|index
operator|<
name|inputLayout
operator|.
name|size
argument_list|()
condition|;
operator|++
name|index
control|)
block|{
name|gl
operator|::
name|VertexFormatType
name|vertexFormatType
init|=
name|inputLayout
index|[
name|index
index|]
decl_stmt|;
name|bool
name|converted
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|vertexFormatType
operator|!=
name|gl
operator|::
name|VERTEX_FORMAT_INVALID
condition|)
block|{
name|VertexConversionType
name|conversionType
init|=
name|renderer
operator|->
name|getVertexConversionType
argument_list|(
name|vertexFormatType
argument_list|)
decl_stmt|;
name|converted
operator|=
operator|(
operator|(
name|conversionType
operator|&
name|VERTEX_CONVERT_GPU
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
operator|(
operator|*
name|signatureOut
operator|)
index|[
name|index
index|]
operator|=
name|converted
expr_stmt|;
block|}
block|}
DECL|function|matchesSignature
name|bool
name|ProgramD3D
operator|::
name|VertexExecutable
operator|::
name|matchesSignature
parameter_list|(
specifier|const
name|Signature
modifier|&
name|signature
parameter_list|)
specifier|const
block|{
name|size_t
name|limit
init|=
name|std
operator|::
name|max
argument_list|(
name|mSignature
operator|.
name|size
argument_list|()
argument_list|,
name|signature
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|index
init|=
literal|0
init|;
name|index
operator|<
name|limit
condition|;
operator|++
name|index
control|)
block|{
comment|// treat undefined indexes as 'not converted'
name|bool
name|a
init|=
name|index
operator|<
name|signature
operator|.
name|size
argument_list|()
condition|?
name|signature
index|[
name|index
index|]
else|:
literal|false
decl_stmt|;
name|bool
name|b
init|=
name|index
operator|<
name|mSignature
operator|.
name|size
argument_list|()
condition|?
name|mSignature
index|[
name|index
index|]
else|:
literal|false
decl_stmt|;
if|if
condition|(
name|a
operator|!=
name|b
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|PixelExecutable
name|ProgramD3D
operator|::
name|PixelExecutable
operator|::
name|PixelExecutable
parameter_list|(
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|GLenum
argument_list|>
modifier|&
name|outputSignature
parameter_list|,
name|ShaderExecutableD3D
modifier|*
name|shaderExecutable
parameter_list|)
member_init_list|:
name|mOutputSignature
argument_list|(
name|outputSignature
argument_list|)
member_init_list|,
name|mShaderExecutable
argument_list|(
name|shaderExecutable
argument_list|)
block|{ }
DECL|function|~PixelExecutable
name|ProgramD3D
operator|::
name|PixelExecutable
operator|::
name|~
name|PixelExecutable
parameter_list|()
block|{
name|SafeDelete
argument_list|(
name|mShaderExecutable
argument_list|)
expr_stmt|;
block|}
DECL|function|Sampler
name|ProgramD3D
operator|::
name|Sampler
operator|::
name|Sampler
parameter_list|()
member_init_list|:
name|active
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|logicalTextureUnit
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|textureType
argument_list|(
name|GL_TEXTURE_2D
argument_list|)
block|{ }
DECL|member|mCurrentSerial
name|unsigned
name|int
name|ProgramD3D
operator|::
name|mCurrentSerial
init|=
literal|1
decl_stmt|;
DECL|function|ProgramD3D
name|ProgramD3D
operator|::
name|ProgramD3D
parameter_list|(
specifier|const
name|gl
operator|::
name|Program
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|RendererD3D
modifier|*
name|renderer
parameter_list|)
member_init_list|:
name|ProgramImpl
argument_list|(
name|data
argument_list|)
member_init_list|,
name|mRenderer
argument_list|(
name|renderer
argument_list|)
member_init_list|,
name|mDynamicHLSL
argument_list|(
name|NULL
argument_list|)
member_init_list|,
name|mGeometryExecutables
argument_list|(
name|gl
operator|::
name|PRIMITIVE_TYPE_MAX
argument_list|,
literal|nullptr
argument_list|)
member_init_list|,
name|mUsesPointSize
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mUsesFlatInterpolation
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mVertexUniformStorage
argument_list|(
name|NULL
argument_list|)
member_init_list|,
name|mFragmentUniformStorage
argument_list|(
name|NULL
argument_list|)
member_init_list|,
name|mUsedVertexSamplerRange
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mUsedPixelSamplerRange
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mDirtySamplerMapping
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|mSerial
argument_list|(
name|issueSerial
argument_list|()
argument_list|)
block|{
name|mDynamicHLSL
operator|=
operator|new
name|DynamicHLSL
argument_list|(
name|renderer
argument_list|)
expr_stmt|;
block|}
DECL|function|~ProgramD3D
name|ProgramD3D
operator|::
name|~
name|ProgramD3D
parameter_list|()
block|{
name|reset
argument_list|()
expr_stmt|;
name|SafeDelete
argument_list|(
name|mDynamicHLSL
argument_list|)
expr_stmt|;
block|}
DECL|function|usesPointSpriteEmulation
name|bool
name|ProgramD3D
operator|::
name|usesPointSpriteEmulation
parameter_list|()
specifier|const
block|{
return|return
name|mUsesPointSize
operator|&&
name|mRenderer
operator|->
name|getMajorShaderModel
argument_list|()
operator|>=
literal|4
return|;
block|}
DECL|function|usesGeometryShader
name|bool
name|ProgramD3D
operator|::
name|usesGeometryShader
parameter_list|(
name|GLenum
name|drawMode
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|drawMode
operator|!=
name|GL_POINTS
condition|)
block|{
return|return
name|mUsesFlatInterpolation
return|;
block|}
return|return
name|usesPointSpriteEmulation
argument_list|()
operator|&&
operator|!
name|usesInstancedPointSpriteEmulation
argument_list|()
return|;
block|}
DECL|function|usesInstancedPointSpriteEmulation
name|bool
name|ProgramD3D
operator|::
name|usesInstancedPointSpriteEmulation
parameter_list|()
specifier|const
block|{
return|return
name|mRenderer
operator|->
name|getWorkarounds
argument_list|()
operator|.
name|useInstancedPointSpriteEmulation
return|;
block|}
DECL|function|getSamplerMapping
name|GLint
name|ProgramD3D
operator|::
name|getSamplerMapping
parameter_list|(
name|gl
operator|::
name|SamplerType
name|type
parameter_list|,
name|unsigned
name|int
name|samplerIndex
parameter_list|,
specifier|const
name|gl
operator|::
name|Caps
modifier|&
name|caps
parameter_list|)
specifier|const
block|{
name|GLint
name|logicalTextureUnit
init|=
operator|-
literal|1
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|gl
operator|::
name|SAMPLER_PIXEL
case|:
name|ASSERT
argument_list|(
name|samplerIndex
operator|<
name|caps
operator|.
name|maxTextureImageUnits
argument_list|)
expr_stmt|;
if|if
condition|(
name|samplerIndex
operator|<
name|mSamplersPS
operator|.
name|size
argument_list|()
operator|&&
name|mSamplersPS
index|[
name|samplerIndex
index|]
operator|.
name|active
condition|)
block|{
name|logicalTextureUnit
operator|=
name|mSamplersPS
index|[
name|samplerIndex
index|]
operator|.
name|logicalTextureUnit
expr_stmt|;
block|}
break|break;
case|case
name|gl
operator|::
name|SAMPLER_VERTEX
case|:
name|ASSERT
argument_list|(
name|samplerIndex
operator|<
name|caps
operator|.
name|maxVertexTextureImageUnits
argument_list|)
expr_stmt|;
if|if
condition|(
name|samplerIndex
operator|<
name|mSamplersVS
operator|.
name|size
argument_list|()
operator|&&
name|mSamplersVS
index|[
name|samplerIndex
index|]
operator|.
name|active
condition|)
block|{
name|logicalTextureUnit
operator|=
name|mSamplersVS
index|[
name|samplerIndex
index|]
operator|.
name|logicalTextureUnit
expr_stmt|;
block|}
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|logicalTextureUnit
operator|>=
literal|0
operator|&&
name|logicalTextureUnit
operator|<
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|caps
operator|.
name|maxCombinedTextureImageUnits
argument_list|)
condition|)
block|{
return|return
name|logicalTextureUnit
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|// Returns the texture type for a given Direct3D 9 sampler type and
comment|// index (0-15 for the pixel shader and 0-3 for the vertex shader).
DECL|function|getSamplerTextureType
name|GLenum
name|ProgramD3D
operator|::
name|getSamplerTextureType
parameter_list|(
name|gl
operator|::
name|SamplerType
name|type
parameter_list|,
name|unsigned
name|int
name|samplerIndex
parameter_list|)
specifier|const
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|gl
operator|::
name|SAMPLER_PIXEL
case|:
name|ASSERT
argument_list|(
name|samplerIndex
operator|<
name|mSamplersPS
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mSamplersPS
index|[
name|samplerIndex
index|]
operator|.
name|active
argument_list|)
expr_stmt|;
return|return
name|mSamplersPS
index|[
name|samplerIndex
index|]
operator|.
name|textureType
return|;
case|case
name|gl
operator|::
name|SAMPLER_VERTEX
case|:
name|ASSERT
argument_list|(
name|samplerIndex
operator|<
name|mSamplersVS
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mSamplersVS
index|[
name|samplerIndex
index|]
operator|.
name|active
argument_list|)
expr_stmt|;
return|return
name|mSamplersVS
index|[
name|samplerIndex
index|]
operator|.
name|textureType
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
name|GL_TEXTURE_2D
return|;
block|}
DECL|function|getUsedSamplerRange
name|GLint
name|ProgramD3D
operator|::
name|getUsedSamplerRange
parameter_list|(
name|gl
operator|::
name|SamplerType
name|type
parameter_list|)
specifier|const
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|gl
operator|::
name|SAMPLER_PIXEL
case|:
return|return
name|mUsedPixelSamplerRange
return|;
case|case
name|gl
operator|::
name|SAMPLER_VERTEX
case|:
return|return
name|mUsedVertexSamplerRange
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|updateSamplerMapping
name|void
name|ProgramD3D
operator|::
name|updateSamplerMapping
parameter_list|()
block|{
if|if
condition|(
operator|!
name|mDirtySamplerMapping
condition|)
block|{
return|return;
block|}
name|mDirtySamplerMapping
operator|=
literal|false
expr_stmt|;
comment|// Retrieve sampler uniform values
for|for
control|(
specifier|const
name|D3DUniform
modifier|*
name|d3dUniform
range|:
name|mD3DUniforms
control|)
block|{
if|if
condition|(
operator|!
name|d3dUniform
operator|->
name|dirty
condition|)
continue|continue;
if|if
condition|(
operator|!
name|d3dUniform
operator|->
name|isSampler
argument_list|()
condition|)
continue|continue;
name|int
name|count
init|=
name|d3dUniform
operator|->
name|elementCount
argument_list|()
decl_stmt|;
specifier|const
name|GLint
argument_list|(
operator|*
name|v
argument_list|)
index|[
literal|4
index|]
operator|=
expr|reinterpret_cast
operator|<
specifier|const
name|GLint
argument_list|(
operator|*
argument_list|)
index|[
literal|4
index|]
operator|>
operator|(
name|d3dUniform
operator|->
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|d3dUniform
operator|->
name|isReferencedByFragmentShader
argument_list|()
condition|)
block|{
name|unsigned
name|int
name|firstIndex
init|=
name|d3dUniform
operator|->
name|psRegisterIndex
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|samplerIndex
init|=
name|firstIndex
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|samplerIndex
operator|<
name|mSamplersPS
operator|.
name|size
argument_list|()
condition|)
block|{
name|ASSERT
argument_list|(
name|mSamplersPS
index|[
name|samplerIndex
index|]
operator|.
name|active
argument_list|)
expr_stmt|;
name|mSamplersPS
index|[
name|samplerIndex
index|]
operator|.
name|logicalTextureUnit
operator|=
name|v
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|d3dUniform
operator|->
name|isReferencedByVertexShader
argument_list|()
condition|)
block|{
name|unsigned
name|int
name|firstIndex
init|=
name|d3dUniform
operator|->
name|vsRegisterIndex
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|samplerIndex
init|=
name|firstIndex
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|samplerIndex
operator|<
name|mSamplersVS
operator|.
name|size
argument_list|()
condition|)
block|{
name|ASSERT
argument_list|(
name|mSamplersVS
index|[
name|samplerIndex
index|]
operator|.
name|active
argument_list|)
expr_stmt|;
name|mSamplersVS
index|[
name|samplerIndex
index|]
operator|.
name|logicalTextureUnit
operator|=
name|v
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|function|load
name|LinkResult
name|ProgramD3D
operator|::
name|load
parameter_list|(
name|gl
operator|::
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
name|gl
operator|::
name|BinaryInputStream
modifier|*
name|stream
parameter_list|)
block|{
name|reset
argument_list|()
expr_stmt|;
name|DeviceIdentifier
name|binaryDeviceIdentifier
init|=
block|{
literal|0
block|}
decl_stmt|;
name|stream
operator|->
name|readBytes
argument_list|(
cast|reinterpret_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
operator|&
name|binaryDeviceIdentifier
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|DeviceIdentifier
argument_list|)
argument_list|)
expr_stmt|;
name|DeviceIdentifier
name|identifier
init|=
name|mRenderer
operator|->
name|getAdapterIdentifier
argument_list|()
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|identifier
argument_list|,
operator|&
name|binaryDeviceIdentifier
argument_list|,
sizeof|sizeof
argument_list|(
name|DeviceIdentifier
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|infoLog
operator|<<
literal|"Invalid program binary, device configuration has changed."
expr_stmt|;
return|return
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
name|int
name|compileFlags
init|=
name|stream
operator|->
name|readInt
argument_list|<
name|int
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|compileFlags
operator|!=
name|ANGLE_COMPILE_OPTIMIZATION_LEVEL
condition|)
block|{
name|infoLog
operator|<<
literal|"Mismatched compilation flags."
expr_stmt|;
return|return
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
comment|// TODO(jmadill): replace MAX_VERTEX_ATTRIBS
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
condition|;
operator|++
name|i
control|)
block|{
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|mSemanticIndexes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
specifier|const
name|unsigned
name|int
name|psSamplerCount
init|=
name|stream
operator|->
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|psSamplerCount
condition|;
operator|++
name|i
control|)
block|{
name|Sampler
name|sampler
decl_stmt|;
name|stream
operator|->
name|readBool
argument_list|(
operator|&
name|sampler
operator|.
name|active
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|sampler
operator|.
name|logicalTextureUnit
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|sampler
operator|.
name|textureType
argument_list|)
expr_stmt|;
name|mSamplersPS
operator|.
name|push_back
argument_list|(
name|sampler
argument_list|)
expr_stmt|;
block|}
specifier|const
name|unsigned
name|int
name|vsSamplerCount
init|=
name|stream
operator|->
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsSamplerCount
condition|;
operator|++
name|i
control|)
block|{
name|Sampler
name|sampler
decl_stmt|;
name|stream
operator|->
name|readBool
argument_list|(
operator|&
name|sampler
operator|.
name|active
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|sampler
operator|.
name|logicalTextureUnit
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|sampler
operator|.
name|textureType
argument_list|)
expr_stmt|;
name|mSamplersVS
operator|.
name|push_back
argument_list|(
name|sampler
argument_list|)
expr_stmt|;
block|}
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|mUsedVertexSamplerRange
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|mUsedPixelSamplerRange
argument_list|)
expr_stmt|;
specifier|const
name|unsigned
name|int
name|uniformCount
init|=
name|stream
operator|->
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|stream
operator|->
name|error
argument_list|()
condition|)
block|{
name|infoLog
operator|<<
literal|"Invalid program binary."
expr_stmt|;
return|return
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
specifier|const
specifier|auto
modifier|&
name|linkedUniforms
init|=
name|mData
operator|.
name|getUniforms
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|mD3DUniforms
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|uniformIndex
init|=
literal|0
init|;
name|uniformIndex
operator|<
name|uniformCount
condition|;
name|uniformIndex
operator|++
control|)
block|{
specifier|const
name|gl
operator|::
name|LinkedUniform
modifier|&
name|linkedUniform
init|=
name|linkedUniforms
index|[
name|uniformIndex
index|]
decl_stmt|;
name|D3DUniform
modifier|*
name|d3dUniform
init|=
operator|new
name|D3DUniform
argument_list|(
name|linkedUniform
operator|.
name|type
argument_list|,
name|linkedUniform
operator|.
name|name
argument_list|,
name|linkedUniform
operator|.
name|arraySize
argument_list|,
name|linkedUniform
operator|.
name|isInDefaultBlock
argument_list|()
argument_list|)
decl_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|d3dUniform
operator|->
name|psRegisterIndex
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|d3dUniform
operator|->
name|vsRegisterIndex
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|d3dUniform
operator|->
name|registerCount
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|d3dUniform
operator|->
name|registerElement
argument_list|)
expr_stmt|;
name|mD3DUniforms
operator|.
name|push_back
argument_list|(
name|d3dUniform
argument_list|)
expr_stmt|;
block|}
specifier|const
name|unsigned
name|int
name|blockCount
init|=
name|stream
operator|->
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|stream
operator|->
name|error
argument_list|()
condition|)
block|{
name|infoLog
operator|<<
literal|"Invalid program binary."
expr_stmt|;
return|return
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|mD3DUniformBlocks
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|blockIndex
init|=
literal|0
init|;
name|blockIndex
operator|<
name|blockCount
condition|;
operator|++
name|blockIndex
control|)
block|{
name|D3DUniformBlock
name|uniformBlock
decl_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|uniformBlock
operator|.
name|psRegisterIndex
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|uniformBlock
operator|.
name|vsRegisterIndex
argument_list|)
expr_stmt|;
name|mD3DUniformBlocks
operator|.
name|push_back
argument_list|(
name|uniformBlock
argument_list|)
expr_stmt|;
block|}
specifier|const
name|unsigned
name|int
name|streamOutVaryingCount
init|=
name|stream
operator|->
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
name|mStreamOutVaryings
operator|.
name|resize
argument_list|(
name|streamOutVaryingCount
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|varyingIndex
init|=
literal|0
init|;
name|varyingIndex
operator|<
name|streamOutVaryingCount
condition|;
operator|++
name|varyingIndex
control|)
block|{
name|D3DVarying
modifier|*
name|varying
init|=
operator|&
name|mStreamOutVaryings
index|[
name|varyingIndex
index|]
decl_stmt|;
name|stream
operator|->
name|readString
argument_list|(
operator|&
name|varying
operator|->
name|semanticName
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|varying
operator|->
name|semanticIndex
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|varying
operator|->
name|componentCount
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|varying
operator|->
name|outputSlot
argument_list|)
expr_stmt|;
block|}
name|stream
operator|->
name|readString
argument_list|(
operator|&
name|mVertexHLSL
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readBytes
argument_list|(
cast|reinterpret_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
operator|&
name|mVertexWorkarounds
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|D3DCompilerWorkarounds
argument_list|)
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readString
argument_list|(
operator|&
name|mPixelHLSL
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readBytes
argument_list|(
cast|reinterpret_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
operator|&
name|mPixelWorkarounds
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|D3DCompilerWorkarounds
argument_list|)
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readBool
argument_list|(
operator|&
name|mUsesFragDepth
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readBool
argument_list|(
operator|&
name|mUsesPointSize
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readBool
argument_list|(
operator|&
name|mUsesFlatInterpolation
argument_list|)
expr_stmt|;
specifier|const
name|size_t
name|pixelShaderKeySize
init|=
name|stream
operator|->
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
name|mPixelShaderKey
operator|.
name|resize
argument_list|(
name|pixelShaderKeySize
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|pixelShaderKeyIndex
init|=
literal|0
init|;
name|pixelShaderKeyIndex
operator|<
name|pixelShaderKeySize
condition|;
name|pixelShaderKeyIndex
operator|++
control|)
block|{
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|mPixelShaderKey
index|[
name|pixelShaderKeyIndex
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readString
argument_list|(
operator|&
name|mPixelShaderKey
index|[
name|pixelShaderKeyIndex
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readString
argument_list|(
operator|&
name|mPixelShaderKey
index|[
name|pixelShaderKeyIndex
index|]
operator|.
name|source
argument_list|)
expr_stmt|;
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|mPixelShaderKey
index|[
name|pixelShaderKeyIndex
index|]
operator|.
name|outputIndex
argument_list|)
expr_stmt|;
block|}
name|stream
operator|->
name|readString
argument_list|(
operator|&
name|mGeometryShaderPreamble
argument_list|)
expr_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|binary
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|stream
operator|->
name|data
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|unsigned
name|int
name|vertexShaderCount
init|=
name|stream
operator|->
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|vertexShaderIndex
init|=
literal|0
init|;
name|vertexShaderIndex
operator|<
name|vertexShaderCount
condition|;
name|vertexShaderIndex
operator|++
control|)
block|{
name|size_t
name|inputLayoutSize
init|=
name|stream
operator|->
name|readInt
argument_list|<
name|size_t
argument_list|>
argument_list|()
decl_stmt|;
name|gl
operator|::
name|InputLayout
name|inputLayout
argument_list|(
name|inputLayoutSize
argument_list|,
name|gl
operator|::
name|VERTEX_FORMAT_INVALID
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|inputIndex
init|=
literal|0
init|;
name|inputIndex
operator|<
name|inputLayoutSize
condition|;
name|inputIndex
operator|++
control|)
block|{
name|inputLayout
index|[
name|inputIndex
index|]
operator|=
name|stream
operator|->
name|readInt
argument_list|<
name|gl
operator|::
name|VertexFormatType
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|unsigned
name|int
name|vertexShaderSize
init|=
name|stream
operator|->
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|vertexShaderFunction
init|=
name|binary
operator|+
name|stream
operator|->
name|offset
argument_list|()
decl_stmt|;
name|ShaderExecutableD3D
modifier|*
name|shaderExecutable
init|=
literal|nullptr
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|mRenderer
operator|->
name|loadExecutable
argument_list|(
name|vertexShaderFunction
argument_list|,
name|vertexShaderSize
argument_list|,
name|SHADER_VERTEX
argument_list|,
name|mStreamOutVaryings
argument_list|,
operator|(
name|mData
operator|.
name|getTransformFeedbackBufferMode
argument_list|()
operator|==
name|GL_SEPARATE_ATTRIBS
operator|)
argument_list|,
operator|&
name|shaderExecutable
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|error
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|shaderExecutable
condition|)
block|{
name|infoLog
operator|<<
literal|"Could not create vertex shader."
expr_stmt|;
return|return
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
comment|// generated converted input layout
name|VertexExecutable
operator|::
name|Signature
name|signature
decl_stmt|;
name|VertexExecutable
operator|::
name|getSignature
argument_list|(
name|mRenderer
argument_list|,
name|inputLayout
argument_list|,
operator|&
name|signature
argument_list|)
expr_stmt|;
comment|// add new binary
name|mVertexExecutables
operator|.
name|push_back
argument_list|(
operator|new
name|VertexExecutable
argument_list|(
name|inputLayout
argument_list|,
name|signature
argument_list|,
name|shaderExecutable
argument_list|)
argument_list|)
expr_stmt|;
name|stream
operator|->
name|skip
argument_list|(
name|vertexShaderSize
argument_list|)
expr_stmt|;
block|}
specifier|const
name|size_t
name|pixelShaderCount
init|=
name|stream
operator|->
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|pixelShaderIndex
init|=
literal|0
init|;
name|pixelShaderIndex
operator|<
name|pixelShaderCount
condition|;
name|pixelShaderIndex
operator|++
control|)
block|{
specifier|const
name|size_t
name|outputCount
init|=
name|stream
operator|->
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
name|std
operator|::
name|vector
argument_list|<
name|GLenum
argument_list|>
name|outputs
argument_list|(
name|outputCount
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|outputIndex
init|=
literal|0
init|;
name|outputIndex
operator|<
name|outputCount
condition|;
name|outputIndex
operator|++
control|)
block|{
name|stream
operator|->
name|readInt
argument_list|(
operator|&
name|outputs
index|[
name|outputIndex
index|]
argument_list|)
expr_stmt|;
block|}
specifier|const
name|size_t
name|pixelShaderSize
init|=
name|stream
operator|->
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|pixelShaderFunction
init|=
name|binary
operator|+
name|stream
operator|->
name|offset
argument_list|()
decl_stmt|;
name|ShaderExecutableD3D
modifier|*
name|shaderExecutable
init|=
literal|nullptr
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|mRenderer
operator|->
name|loadExecutable
argument_list|(
name|pixelShaderFunction
argument_list|,
name|pixelShaderSize
argument_list|,
name|SHADER_PIXEL
argument_list|,
name|mStreamOutVaryings
argument_list|,
operator|(
name|mData
operator|.
name|getTransformFeedbackBufferMode
argument_list|()
operator|==
name|GL_SEPARATE_ATTRIBS
operator|)
argument_list|,
operator|&
name|shaderExecutable
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|error
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|shaderExecutable
condition|)
block|{
name|infoLog
operator|<<
literal|"Could not create pixel shader."
expr_stmt|;
return|return
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
comment|// add new binary
name|mPixelExecutables
operator|.
name|push_back
argument_list|(
operator|new
name|PixelExecutable
argument_list|(
name|outputs
argument_list|,
name|shaderExecutable
argument_list|)
argument_list|)
expr_stmt|;
name|stream
operator|->
name|skip
argument_list|(
name|pixelShaderSize
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|unsigned
name|int
name|geometryExeIndex
init|=
literal|0
init|;
name|geometryExeIndex
operator|<
name|gl
operator|::
name|PRIMITIVE_TYPE_MAX
condition|;
operator|++
name|geometryExeIndex
control|)
block|{
name|unsigned
name|int
name|geometryShaderSize
init|=
name|stream
operator|->
name|readInt
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|geometryShaderSize
operator|==
literal|0
condition|)
block|{
name|mGeometryExecutables
index|[
name|geometryExeIndex
index|]
operator|=
literal|nullptr
expr_stmt|;
continue|continue;
block|}
specifier|const
name|unsigned
name|char
modifier|*
name|geometryShaderFunction
init|=
name|binary
operator|+
name|stream
operator|->
name|offset
argument_list|()
decl_stmt|;
name|bool
name|splitAttribs
init|=
operator|(
name|mData
operator|.
name|getTransformFeedbackBufferMode
argument_list|()
operator|==
name|GL_SEPARATE_ATTRIBS
operator|)
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|mRenderer
operator|->
name|loadExecutable
argument_list|(
name|geometryShaderFunction
argument_list|,
name|geometryShaderSize
argument_list|,
name|SHADER_GEOMETRY
argument_list|,
name|mStreamOutVaryings
argument_list|,
name|splitAttribs
argument_list|,
operator|&
name|mGeometryExecutables
index|[
name|geometryExeIndex
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|error
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|mGeometryExecutables
index|[
name|geometryExeIndex
index|]
condition|)
block|{
name|infoLog
operator|<<
literal|"Could not create geometry shader."
expr_stmt|;
return|return
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
name|stream
operator|->
name|skip
argument_list|(
name|geometryShaderSize
argument_list|)
expr_stmt|;
block|}
name|initializeUniformStorage
argument_list|()
expr_stmt|;
name|initAttributesByLayout
argument_list|()
expr_stmt|;
return|return
name|LinkResult
argument_list|(
literal|true
argument_list|,
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
DECL|function|save
name|gl
operator|::
name|Error
name|ProgramD3D
operator|::
name|save
parameter_list|(
name|gl
operator|::
name|BinaryOutputStream
modifier|*
name|stream
parameter_list|)
block|{
comment|// Output the DeviceIdentifier before we output any shader code
comment|// When we load the binary again later, we can validate the device identifier before trying to
comment|// compile any HLSL
name|DeviceIdentifier
name|binaryIdentifier
init|=
name|mRenderer
operator|->
name|getAdapterIdentifier
argument_list|()
decl_stmt|;
name|stream
operator|->
name|writeBytes
argument_list|(
cast|reinterpret_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
operator|&
name|binaryIdentifier
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|DeviceIdentifier
argument_list|)
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|ANGLE_COMPILE_OPTIMIZATION_LEVEL
argument_list|)
expr_stmt|;
comment|// TODO(jmadill): replace MAX_VERTEX_ATTRIBS
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
condition|;
operator|++
name|i
control|)
block|{
name|stream
operator|->
name|writeInt
argument_list|(
name|mSemanticIndexes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|stream
operator|->
name|writeInt
argument_list|(
name|mSamplersPS
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mSamplersPS
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|stream
operator|->
name|writeInt
argument_list|(
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|active
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|logicalTextureUnit
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|mSamplersPS
index|[
name|i
index|]
operator|.
name|textureType
argument_list|)
expr_stmt|;
block|}
name|stream
operator|->
name|writeInt
argument_list|(
name|mSamplersVS
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mSamplersVS
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|stream
operator|->
name|writeInt
argument_list|(
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|active
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|logicalTextureUnit
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|mSamplersVS
index|[
name|i
index|]
operator|.
name|textureType
argument_list|)
expr_stmt|;
block|}
name|stream
operator|->
name|writeInt
argument_list|(
name|mUsedVertexSamplerRange
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|mUsedPixelSamplerRange
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|mD3DUniforms
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
specifier|const
name|D3DUniform
modifier|*
name|uniform
range|:
name|mD3DUniforms
control|)
block|{
comment|// Type, name and arraySize are redundant, so aren't stored in the binary.
name|stream
operator|->
name|writeInt
argument_list|(
name|uniform
operator|->
name|psRegisterIndex
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|uniform
operator|->
name|vsRegisterIndex
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|uniform
operator|->
name|registerCount
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|uniform
operator|->
name|registerElement
argument_list|)
expr_stmt|;
block|}
name|stream
operator|->
name|writeInt
argument_list|(
name|mD3DUniformBlocks
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
specifier|const
name|D3DUniformBlock
modifier|&
name|uniformBlock
range|:
name|mD3DUniformBlocks
control|)
block|{
name|stream
operator|->
name|writeInt
argument_list|(
name|uniformBlock
operator|.
name|psRegisterIndex
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|uniformBlock
operator|.
name|vsRegisterIndex
argument_list|)
expr_stmt|;
block|}
name|stream
operator|->
name|writeInt
argument_list|(
name|mStreamOutVaryings
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|varying
range|:
name|mStreamOutVaryings
control|)
block|{
name|stream
operator|->
name|writeString
argument_list|(
name|varying
operator|.
name|semanticName
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|varying
operator|.
name|semanticIndex
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|varying
operator|.
name|componentCount
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|varying
operator|.
name|outputSlot
argument_list|)
expr_stmt|;
block|}
name|stream
operator|->
name|writeString
argument_list|(
name|mVertexHLSL
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeBytes
argument_list|(
cast|reinterpret_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
operator|&
name|mVertexWorkarounds
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|D3DCompilerWorkarounds
argument_list|)
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeString
argument_list|(
name|mPixelHLSL
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeBytes
argument_list|(
cast|reinterpret_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
operator|&
name|mPixelWorkarounds
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|D3DCompilerWorkarounds
argument_list|)
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|mUsesFragDepth
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|mUsesPointSize
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|mUsesFlatInterpolation
argument_list|)
expr_stmt|;
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|PixelShaderOutputVariable
argument_list|>
modifier|&
name|pixelShaderKey
init|=
name|mPixelShaderKey
decl_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|pixelShaderKey
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|pixelShaderKeyIndex
init|=
literal|0
init|;
name|pixelShaderKeyIndex
operator|<
name|pixelShaderKey
operator|.
name|size
argument_list|()
condition|;
name|pixelShaderKeyIndex
operator|++
control|)
block|{
specifier|const
name|PixelShaderOutputVariable
modifier|&
name|variable
init|=
name|pixelShaderKey
index|[
name|pixelShaderKeyIndex
index|]
decl_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|variable
operator|.
name|type
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeString
argument_list|(
name|variable
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeString
argument_list|(
name|variable
operator|.
name|source
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|variable
operator|.
name|outputIndex
argument_list|)
expr_stmt|;
block|}
name|stream
operator|->
name|writeString
argument_list|(
name|mGeometryShaderPreamble
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|mVertexExecutables
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|vertexExecutableIndex
init|=
literal|0
init|;
name|vertexExecutableIndex
operator|<
name|mVertexExecutables
operator|.
name|size
argument_list|()
condition|;
name|vertexExecutableIndex
operator|++
control|)
block|{
name|VertexExecutable
modifier|*
name|vertexExecutable
init|=
name|mVertexExecutables
index|[
name|vertexExecutableIndex
index|]
decl_stmt|;
specifier|const
specifier|auto
modifier|&
name|inputLayout
init|=
name|vertexExecutable
operator|->
name|inputs
argument_list|()
decl_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|inputLayout
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|inputIndex
init|=
literal|0
init|;
name|inputIndex
operator|<
name|inputLayout
operator|.
name|size
argument_list|()
condition|;
name|inputIndex
operator|++
control|)
block|{
name|stream
operator|->
name|writeInt
argument_list|(
name|inputLayout
index|[
name|inputIndex
index|]
argument_list|)
expr_stmt|;
block|}
name|size_t
name|vertexShaderSize
init|=
name|vertexExecutable
operator|->
name|shaderExecutable
argument_list|()
operator|->
name|getLength
argument_list|()
decl_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|vertexShaderSize
argument_list|)
expr_stmt|;
specifier|const
name|uint8_t
modifier|*
name|vertexBlob
init|=
name|vertexExecutable
operator|->
name|shaderExecutable
argument_list|()
operator|->
name|getFunction
argument_list|()
decl_stmt|;
name|stream
operator|->
name|writeBytes
argument_list|(
name|vertexBlob
argument_list|,
name|vertexShaderSize
argument_list|)
expr_stmt|;
block|}
name|stream
operator|->
name|writeInt
argument_list|(
name|mPixelExecutables
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|pixelExecutableIndex
init|=
literal|0
init|;
name|pixelExecutableIndex
operator|<
name|mPixelExecutables
operator|.
name|size
argument_list|()
condition|;
name|pixelExecutableIndex
operator|++
control|)
block|{
name|PixelExecutable
modifier|*
name|pixelExecutable
init|=
name|mPixelExecutables
index|[
name|pixelExecutableIndex
index|]
decl_stmt|;
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|GLenum
argument_list|>
name|outputs
init|=
name|pixelExecutable
operator|->
name|outputSignature
argument_list|()
decl_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|outputs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|outputIndex
init|=
literal|0
init|;
name|outputIndex
operator|<
name|outputs
operator|.
name|size
argument_list|()
condition|;
name|outputIndex
operator|++
control|)
block|{
name|stream
operator|->
name|writeInt
argument_list|(
name|outputs
index|[
name|outputIndex
index|]
argument_list|)
expr_stmt|;
block|}
name|size_t
name|pixelShaderSize
init|=
name|pixelExecutable
operator|->
name|shaderExecutable
argument_list|()
operator|->
name|getLength
argument_list|()
decl_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|pixelShaderSize
argument_list|)
expr_stmt|;
specifier|const
name|uint8_t
modifier|*
name|pixelBlob
init|=
name|pixelExecutable
operator|->
name|shaderExecutable
argument_list|()
operator|->
name|getFunction
argument_list|()
decl_stmt|;
name|stream
operator|->
name|writeBytes
argument_list|(
name|pixelBlob
argument_list|,
name|pixelShaderSize
argument_list|)
expr_stmt|;
block|}
for|for
control|(
specifier|const
name|ShaderExecutableD3D
modifier|*
name|geometryExe
range|:
name|mGeometryExecutables
control|)
block|{
if|if
condition|(
name|geometryExe
operator|==
literal|nullptr
condition|)
block|{
name|stream
operator|->
name|writeInt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|size_t
name|geometryShaderSize
init|=
name|geometryExe
operator|->
name|getLength
argument_list|()
decl_stmt|;
name|stream
operator|->
name|writeInt
argument_list|(
name|geometryShaderSize
argument_list|)
expr_stmt|;
name|stream
operator|->
name|writeBytes
argument_list|(
name|geometryExe
operator|->
name|getFunction
argument_list|()
argument_list|,
name|geometryShaderSize
argument_list|)
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|setBinaryRetrievableHint
name|void
name|ProgramD3D
operator|::
name|setBinaryRetrievableHint
parameter_list|(
name|bool
comment|/* retrievable */
parameter_list|)
block|{ }
DECL|function|getPixelExecutableForFramebuffer
name|gl
operator|::
name|Error
name|ProgramD3D
operator|::
name|getPixelExecutableForFramebuffer
parameter_list|(
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|fbo
parameter_list|,
name|ShaderExecutableD3D
modifier|*
modifier|*
name|outExecutable
parameter_list|)
block|{
name|mPixelShaderOutputFormatCache
operator|.
name|clear
argument_list|()
expr_stmt|;
specifier|const
name|FramebufferD3D
modifier|*
name|fboD3D
init|=
name|GetImplAs
argument_list|<
name|FramebufferD3D
argument_list|>
argument_list|(
name|fbo
argument_list|)
decl_stmt|;
specifier|const
name|gl
operator|::
name|AttachmentList
modifier|&
name|colorbuffers
init|=
name|fboD3D
operator|->
name|getColorAttachmentsForRender
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|colorAttachment
init|=
literal|0
init|;
name|colorAttachment
operator|<
name|colorbuffers
operator|.
name|size
argument_list|()
condition|;
operator|++
name|colorAttachment
control|)
block|{
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|colorbuffer
init|=
name|colorbuffers
index|[
name|colorAttachment
index|]
decl_stmt|;
if|if
condition|(
name|colorbuffer
condition|)
block|{
name|mPixelShaderOutputFormatCache
operator|.
name|push_back
argument_list|(
name|colorbuffer
operator|->
name|getBinding
argument_list|()
operator|==
name|GL_BACK
condition|?
name|GL_COLOR_ATTACHMENT0
else|:
name|colorbuffer
operator|->
name|getBinding
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mPixelShaderOutputFormatCache
operator|.
name|push_back
argument_list|(
name|GL_NONE
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|getPixelExecutableForOutputLayout
argument_list|(
name|mPixelShaderOutputFormatCache
argument_list|,
name|outExecutable
argument_list|,
literal|nullptr
argument_list|)
return|;
block|}
DECL|function|getPixelExecutableForOutputLayout
name|gl
operator|::
name|Error
name|ProgramD3D
operator|::
name|getPixelExecutableForOutputLayout
parameter_list|(
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|GLenum
argument_list|>
modifier|&
name|outputSignature
parameter_list|,
name|ShaderExecutableD3D
modifier|*
modifier|*
name|outExectuable
parameter_list|,
name|gl
operator|::
name|InfoLog
modifier|*
name|infoLog
parameter_list|)
block|{
for|for
control|(
name|size_t
name|executableIndex
init|=
literal|0
init|;
name|executableIndex
operator|<
name|mPixelExecutables
operator|.
name|size
argument_list|()
condition|;
name|executableIndex
operator|++
control|)
block|{
if|if
condition|(
name|mPixelExecutables
index|[
name|executableIndex
index|]
operator|->
name|matchesSignature
argument_list|(
name|outputSignature
argument_list|)
condition|)
block|{
operator|*
name|outExectuable
operator|=
name|mPixelExecutables
index|[
name|executableIndex
index|]
operator|->
name|shaderExecutable
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
block|}
name|std
operator|::
name|string
name|finalPixelHLSL
init|=
name|mDynamicHLSL
operator|->
name|generatePixelShaderForOutputSignature
argument_list|(
name|mPixelHLSL
argument_list|,
name|mPixelShaderKey
argument_list|,
name|mUsesFragDepth
argument_list|,
name|outputSignature
argument_list|)
decl_stmt|;
comment|// Generate new pixel executable
name|ShaderExecutableD3D
modifier|*
name|pixelExecutable
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|InfoLog
name|tempInfoLog
decl_stmt|;
name|gl
operator|::
name|InfoLog
modifier|*
name|currentInfoLog
init|=
name|infoLog
condition|?
name|infoLog
else|:
operator|&
name|tempInfoLog
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|mRenderer
operator|->
name|compileToExecutable
argument_list|(
operator|*
name|currentInfoLog
argument_list|,
name|finalPixelHLSL
argument_list|,
name|SHADER_PIXEL
argument_list|,
name|mStreamOutVaryings
argument_list|,
operator|(
name|mData
operator|.
name|getTransformFeedbackBufferMode
argument_list|()
operator|==
name|GL_SEPARATE_ATTRIBS
operator|)
argument_list|,
name|mPixelWorkarounds
argument_list|,
operator|&
name|pixelExecutable
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
name|pixelExecutable
condition|)
block|{
name|mPixelExecutables
operator|.
name|push_back
argument_list|(
operator|new
name|PixelExecutable
argument_list|(
name|outputSignature
argument_list|,
name|pixelExecutable
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|infoLog
condition|)
block|{
name|std
operator|::
name|vector
argument_list|<
name|char
argument_list|>
name|tempCharBuffer
argument_list|(
name|tempInfoLog
operator|.
name|getLength
argument_list|()
operator|+
literal|3
argument_list|)
decl_stmt|;
name|tempInfoLog
operator|.
name|getLog
argument_list|(
cast|static_cast
argument_list|<
name|GLsizei
argument_list|>
argument_list|(
name|tempInfoLog
operator|.
name|getLength
argument_list|()
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|tempCharBuffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ERR
argument_list|(
literal|"Error compiling dynamic pixel executable:\n%s\n"
argument_list|,
operator|&
name|tempCharBuffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
operator|*
name|outExectuable
operator|=
name|pixelExecutable
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|getVertexExecutableForInputLayout
name|gl
operator|::
name|Error
name|ProgramD3D
operator|::
name|getVertexExecutableForInputLayout
parameter_list|(
specifier|const
name|gl
operator|::
name|InputLayout
modifier|&
name|inputLayout
parameter_list|,
name|ShaderExecutableD3D
modifier|*
modifier|*
name|outExectuable
parameter_list|,
name|gl
operator|::
name|InfoLog
modifier|*
name|infoLog
parameter_list|)
block|{
name|VertexExecutable
operator|::
name|getSignature
argument_list|(
name|mRenderer
argument_list|,
name|inputLayout
argument_list|,
operator|&
name|mCachedVertexSignature
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|executableIndex
init|=
literal|0
init|;
name|executableIndex
operator|<
name|mVertexExecutables
operator|.
name|size
argument_list|()
condition|;
name|executableIndex
operator|++
control|)
block|{
if|if
condition|(
name|mVertexExecutables
index|[
name|executableIndex
index|]
operator|->
name|matchesSignature
argument_list|(
name|mCachedVertexSignature
argument_list|)
condition|)
block|{
operator|*
name|outExectuable
operator|=
name|mVertexExecutables
index|[
name|executableIndex
index|]
operator|->
name|shaderExecutable
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
block|}
comment|// Generate new dynamic layout with attribute conversions
name|std
operator|::
name|string
name|finalVertexHLSL
init|=
name|mDynamicHLSL
operator|->
name|generateVertexShaderForInputLayout
argument_list|(
name|mVertexHLSL
argument_list|,
name|inputLayout
argument_list|,
name|mData
operator|.
name|getAttributes
argument_list|()
argument_list|)
decl_stmt|;
comment|// Generate new vertex executable
name|ShaderExecutableD3D
modifier|*
name|vertexExecutable
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|InfoLog
name|tempInfoLog
decl_stmt|;
name|gl
operator|::
name|InfoLog
modifier|*
name|currentInfoLog
init|=
name|infoLog
condition|?
name|infoLog
else|:
operator|&
name|tempInfoLog
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|mRenderer
operator|->
name|compileToExecutable
argument_list|(
operator|*
name|currentInfoLog
argument_list|,
name|finalVertexHLSL
argument_list|,
name|SHADER_VERTEX
argument_list|,
name|mStreamOutVaryings
argument_list|,
operator|(
name|mData
operator|.
name|getTransformFeedbackBufferMode
argument_list|()
operator|==
name|GL_SEPARATE_ATTRIBS
operator|)
argument_list|,
name|mVertexWorkarounds
argument_list|,
operator|&
name|vertexExecutable
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
name|vertexExecutable
condition|)
block|{
name|mVertexExecutables
operator|.
name|push_back
argument_list|(
operator|new
name|VertexExecutable
argument_list|(
name|inputLayout
argument_list|,
name|mCachedVertexSignature
argument_list|,
name|vertexExecutable
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|infoLog
condition|)
block|{
name|std
operator|::
name|vector
argument_list|<
name|char
argument_list|>
name|tempCharBuffer
argument_list|(
name|tempInfoLog
operator|.
name|getLength
argument_list|()
operator|+
literal|3
argument_list|)
decl_stmt|;
name|tempInfoLog
operator|.
name|getLog
argument_list|(
cast|static_cast
argument_list|<
name|GLsizei
argument_list|>
argument_list|(
name|tempInfoLog
operator|.
name|getLength
argument_list|()
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|tempCharBuffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ERR
argument_list|(
literal|"Error compiling dynamic vertex executable:\n%s\n"
argument_list|,
operator|&
name|tempCharBuffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
operator|*
name|outExectuable
operator|=
name|vertexExecutable
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|getGeometryExecutableForPrimitiveType
name|gl
operator|::
name|Error
name|ProgramD3D
operator|::
name|getGeometryExecutableForPrimitiveType
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLenum
name|drawMode
parameter_list|,
name|ShaderExecutableD3D
modifier|*
modifier|*
name|outExecutable
parameter_list|,
name|gl
operator|::
name|InfoLog
modifier|*
name|infoLog
parameter_list|)
block|{
if|if
condition|(
name|outExecutable
condition|)
block|{
operator|*
name|outExecutable
operator|=
literal|nullptr
expr_stmt|;
block|}
comment|// Return a null shader if the current rendering doesn't use a geometry shader
if|if
condition|(
operator|!
name|usesGeometryShader
argument_list|(
name|drawMode
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
name|gl
operator|::
name|PrimitiveType
name|geometryShaderType
init|=
name|GetGeometryShaderTypeFromDrawMode
argument_list|(
name|drawMode
argument_list|)
decl_stmt|;
if|if
condition|(
name|mGeometryExecutables
index|[
name|geometryShaderType
index|]
operator|!=
literal|nullptr
condition|)
block|{
if|if
condition|(
name|outExecutable
condition|)
block|{
operator|*
name|outExecutable
operator|=
name|mGeometryExecutables
index|[
name|geometryShaderType
index|]
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
name|std
operator|::
name|string
name|geometryHLSL
init|=
name|mDynamicHLSL
operator|->
name|generateGeometryShaderHLSL
argument_list|(
name|geometryShaderType
argument_list|,
name|data
argument_list|,
name|mData
argument_list|,
name|mRenderer
operator|->
name|presentPathFastEnabled
argument_list|()
argument_list|,
name|mGeometryShaderPreamble
argument_list|)
decl_stmt|;
name|gl
operator|::
name|InfoLog
name|tempInfoLog
decl_stmt|;
name|gl
operator|::
name|InfoLog
modifier|*
name|currentInfoLog
init|=
name|infoLog
condition|?
name|infoLog
else|:
operator|&
name|tempInfoLog
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|mRenderer
operator|->
name|compileToExecutable
argument_list|(
operator|*
name|currentInfoLog
argument_list|,
name|geometryHLSL
argument_list|,
name|SHADER_GEOMETRY
argument_list|,
name|mStreamOutVaryings
argument_list|,
operator|(
name|mData
operator|.
name|getTransformFeedbackBufferMode
argument_list|()
operator|==
name|GL_SEPARATE_ATTRIBS
operator|)
argument_list|,
name|D3DCompilerWorkarounds
argument_list|()
argument_list|,
operator|&
name|mGeometryExecutables
index|[
name|geometryShaderType
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|infoLog
operator|&&
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
name|std
operator|::
name|vector
argument_list|<
name|char
argument_list|>
name|tempCharBuffer
argument_list|(
name|tempInfoLog
operator|.
name|getLength
argument_list|()
operator|+
literal|3
argument_list|)
decl_stmt|;
name|tempInfoLog
operator|.
name|getLog
argument_list|(
cast|static_cast
argument_list|<
name|GLsizei
argument_list|>
argument_list|(
name|tempInfoLog
operator|.
name|getLength
argument_list|()
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|tempCharBuffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ERR
argument_list|(
literal|"Error compiling dynamic geometry executable:\n%s\n"
argument_list|,
operator|&
name|tempCharBuffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outExecutable
condition|)
block|{
operator|*
name|outExecutable
operator|=
name|mGeometryExecutables
index|[
name|geometryShaderType
index|]
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
DECL|function|compileProgramExecutables
name|LinkResult
name|ProgramD3D
operator|::
name|compileProgramExecutables
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|gl
operator|::
name|InfoLog
modifier|&
name|infoLog
parameter_list|)
block|{
specifier|const
name|gl
operator|::
name|InputLayout
modifier|&
name|defaultInputLayout
init|=
name|GetDefaultInputLayoutFromShader
argument_list|(
name|mData
operator|.
name|getAttachedVertexShader
argument_list|()
argument_list|)
decl_stmt|;
name|ShaderExecutableD3D
modifier|*
name|defaultVertexExecutable
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|getVertexExecutableForInputLayout
argument_list|(
name|defaultInputLayout
argument_list|,
operator|&
name|defaultVertexExecutable
argument_list|,
operator|&
name|infoLog
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|error
argument_list|)
return|;
block|}
name|std
operator|::
name|vector
argument_list|<
name|GLenum
argument_list|>
name|defaultPixelOutput
init|=
name|GetDefaultOutputLayoutFromShader
argument_list|(
name|getPixelShaderKey
argument_list|()
argument_list|)
decl_stmt|;
name|ShaderExecutableD3D
modifier|*
name|defaultPixelExecutable
init|=
name|NULL
decl_stmt|;
name|error
operator|=
name|getPixelExecutableForOutputLayout
argument_list|(
name|defaultPixelOutput
argument_list|,
operator|&
name|defaultPixelExecutable
argument_list|,
operator|&
name|infoLog
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|error
argument_list|)
return|;
block|}
comment|// Auto-generate the geometry shader here, if we expect to be using point rendering in D3D11.
name|ShaderExecutableD3D
modifier|*
name|pointGS
init|=
literal|nullptr
decl_stmt|;
if|if
condition|(
name|usesGeometryShader
argument_list|(
name|GL_POINTS
argument_list|)
condition|)
block|{
name|getGeometryExecutableForPrimitiveType
argument_list|(
name|data
argument_list|,
name|GL_POINTS
argument_list|,
operator|&
name|pointGS
argument_list|,
operator|&
name|infoLog
argument_list|)
expr_stmt|;
block|}
specifier|const
name|ShaderD3D
modifier|*
name|vertexShaderD3D
init|=
name|GetImplAs
argument_list|<
name|ShaderD3D
argument_list|>
argument_list|(
name|mData
operator|.
name|getAttachedVertexShader
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|usesGeometryShader
argument_list|(
name|GL_POINTS
argument_list|)
operator|&&
name|pointGS
condition|)
block|{
comment|// Geometry shaders are currently only used internally, so there is no corresponding shader
comment|// object at the interface level. For now the geometry shader debug info is prepended to
comment|// the vertex shader.
name|vertexShaderD3D
operator|->
name|appendDebugInfo
argument_list|(
literal|"// GEOMETRY SHADER BEGIN\n\n"
argument_list|)
expr_stmt|;
name|vertexShaderD3D
operator|->
name|appendDebugInfo
argument_list|(
name|pointGS
operator|->
name|getDebugInfo
argument_list|()
argument_list|)
expr_stmt|;
name|vertexShaderD3D
operator|->
name|appendDebugInfo
argument_list|(
literal|"\nGEOMETRY SHADER END\n\n\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|defaultVertexExecutable
condition|)
block|{
name|vertexShaderD3D
operator|->
name|appendDebugInfo
argument_list|(
name|defaultVertexExecutable
operator|->
name|getDebugInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|defaultPixelExecutable
condition|)
block|{
specifier|const
name|ShaderD3D
modifier|*
name|fragmentShaderD3D
init|=
name|GetImplAs
argument_list|<
name|ShaderD3D
argument_list|>
argument_list|(
name|mData
operator|.
name|getAttachedFragmentShader
argument_list|()
argument_list|)
decl_stmt|;
name|fragmentShaderD3D
operator|->
name|appendDebugInfo
argument_list|(
name|defaultPixelExecutable
operator|->
name|getDebugInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|bool
name|linkSuccess
init|=
operator|(
name|defaultVertexExecutable
operator|&&
name|defaultPixelExecutable
operator|&&
operator|(
operator|!
name|usesGeometryShader
argument_list|(
name|GL_POINTS
argument_list|)
operator|||
name|pointGS
operator|)
operator|)
decl_stmt|;
return|return
name|LinkResult
argument_list|(
name|linkSuccess
argument_list|,
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
DECL|function|link
name|LinkResult
name|ProgramD3D
operator|::
name|link
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|gl
operator|::
name|InfoLog
modifier|&
name|infoLog
parameter_list|)
block|{
name|reset
argument_list|()
expr_stmt|;
comment|// TODO(jmadill): structures containing samplers
for|for
control|(
specifier|const
name|gl
operator|::
name|LinkedUniform
modifier|&
name|linkedUniform
range|:
name|mData
operator|.
name|getUniforms
argument_list|()
control|)
block|{
if|if
condition|(
name|linkedUniform
operator|.
name|isSampler
argument_list|()
operator|&&
name|linkedUniform
operator|.
name|isField
argument_list|()
condition|)
block|{
name|infoLog
operator|<<
literal|"Structures containing samplers not currently supported in D3D."
expr_stmt|;
return|return
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
block|}
specifier|const
name|gl
operator|::
name|Shader
modifier|*
name|vertexShader
init|=
name|mData
operator|.
name|getAttachedVertexShader
argument_list|()
decl_stmt|;
specifier|const
name|gl
operator|::
name|Shader
modifier|*
name|fragmentShader
init|=
name|mData
operator|.
name|getAttachedFragmentShader
argument_list|()
decl_stmt|;
specifier|const
name|ShaderD3D
modifier|*
name|vertexShaderD3D
init|=
name|GetImplAs
argument_list|<
name|ShaderD3D
argument_list|>
argument_list|(
name|vertexShader
argument_list|)
decl_stmt|;
specifier|const
name|ShaderD3D
modifier|*
name|fragmentShaderD3D
init|=
name|GetImplAs
argument_list|<
name|ShaderD3D
argument_list|>
argument_list|(
name|fragmentShader
argument_list|)
decl_stmt|;
name|mSamplersVS
operator|.
name|resize
argument_list|(
name|data
operator|.
name|caps
operator|->
name|maxVertexTextureImageUnits
argument_list|)
expr_stmt|;
name|mSamplersPS
operator|.
name|resize
argument_list|(
name|data
operator|.
name|caps
operator|->
name|maxTextureImageUnits
argument_list|)
expr_stmt|;
name|vertexShaderD3D
operator|->
name|generateWorkarounds
argument_list|(
operator|&
name|mVertexWorkarounds
argument_list|)
expr_stmt|;
name|fragmentShaderD3D
operator|->
name|generateWorkarounds
argument_list|(
operator|&
name|mPixelWorkarounds
argument_list|)
expr_stmt|;
if|if
condition|(
name|mRenderer
operator|->
name|getRendererLimitations
argument_list|()
operator|.
name|noFrontFacingSupport
condition|)
block|{
if|if
condition|(
name|fragmentShaderD3D
operator|->
name|usesFrontFacing
argument_list|()
condition|)
block|{
name|infoLog
operator|<<
literal|"The current renderer doesn't support gl_FrontFacing"
expr_stmt|;
return|return
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
block|}
name|std
operator|::
name|vector
argument_list|<
name|PackedVarying
argument_list|>
name|packedVaryings
init|=
name|MergeVaryings
argument_list|(
operator|*
name|vertexShader
argument_list|,
operator|*
name|fragmentShader
argument_list|,
name|mData
operator|.
name|getTransformFeedbackVaryingNames
argument_list|()
argument_list|)
decl_stmt|;
comment|// Map the varyings to the register file
name|VaryingPacking
name|varyingPacking
argument_list|(
name|data
operator|.
name|caps
operator|->
name|maxVaryingVectors
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|varyingPacking
operator|.
name|packVaryings
argument_list|(
name|infoLog
argument_list|,
name|packedVaryings
argument_list|,
name|mData
operator|.
name|getTransformFeedbackVaryingNames
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
name|ProgramD3DMetadata
name|metadata
argument_list|(
name|mRenderer
operator|->
name|getMajorShaderModel
argument_list|()
argument_list|,
name|mRenderer
operator|->
name|getShaderModelSuffix
argument_list|()
argument_list|,
name|usesInstancedPointSpriteEmulation
argument_list|()
argument_list|,
name|mRenderer
operator|->
name|presentPathFastEnabled
argument_list|()
argument_list|,
name|vertexShaderD3D
argument_list|,
name|fragmentShaderD3D
argument_list|)
decl_stmt|;
name|varyingPacking
operator|.
name|enableBuiltins
argument_list|(
name|SHADER_VERTEX
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
name|varyingPacking
operator|.
name|enableBuiltins
argument_list|(
name|SHADER_PIXEL
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
if|if
condition|(
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|varyingPacking
operator|.
name|getRegisterCount
argument_list|()
argument_list|)
operator|>
name|data
operator|.
name|caps
operator|->
name|maxVaryingVectors
condition|)
block|{
name|infoLog
operator|<<
literal|"No varying registers left to support gl_FragCoord/gl_PointCoord"
expr_stmt|;
return|return
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
comment|// TODO(jmadill): Implement more sophisticated component packing in D3D9.
comment|// We can fail here because we use one semantic per GLSL varying. D3D11 can pack varyings
comment|// intelligently, but D3D9 assumes one semantic per register.
if|if
condition|(
name|mRenderer
operator|->
name|getRendererClass
argument_list|()
operator|==
name|RENDERER_D3D9
operator|&&
name|varyingPacking
operator|.
name|getMaxSemanticIndex
argument_list|()
operator|>
name|data
operator|.
name|caps
operator|->
name|maxVaryingVectors
condition|)
block|{
name|infoLog
operator|<<
literal|"Cannot pack these varyings on D3D9."
expr_stmt|;
return|return
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|mDynamicHLSL
operator|->
name|generateShaderLinkHLSL
argument_list|(
name|data
argument_list|,
name|mData
argument_list|,
name|metadata
argument_list|,
name|varyingPacking
argument_list|,
operator|&
name|mPixelHLSL
argument_list|,
operator|&
name|mVertexHLSL
argument_list|)
condition|)
block|{
return|return
name|LinkResult
argument_list|(
literal|false
argument_list|,
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
name|mUsesPointSize
operator|=
name|vertexShaderD3D
operator|->
name|usesPointSize
argument_list|()
expr_stmt|;
name|mDynamicHLSL
operator|->
name|getPixelShaderOutputKey
argument_list|(
name|data
argument_list|,
name|mData
argument_list|,
name|metadata
argument_list|,
operator|&
name|mPixelShaderKey
argument_list|)
expr_stmt|;
name|mUsesFragDepth
operator|=
name|metadata
operator|.
name|usesFragDepth
argument_list|(
name|mData
argument_list|)
expr_stmt|;
comment|// Cache if we use flat shading
name|mUsesFlatInterpolation
operator|=
literal|false
expr_stmt|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|varying
range|:
name|packedVaryings
control|)
block|{
if|if
condition|(
name|varying
operator|.
name|interpolation
operator|==
name|sh
operator|::
name|INTERPOLATION_FLAT
condition|)
block|{
name|mUsesFlatInterpolation
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|mRenderer
operator|->
name|getMajorShaderModel
argument_list|()
operator|>=
literal|4
condition|)
block|{
name|varyingPacking
operator|.
name|enableBuiltins
argument_list|(
name|SHADER_GEOMETRY
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
name|mGeometryShaderPreamble
operator|=
name|mDynamicHLSL
operator|->
name|generateGeometryShaderPreamble
argument_list|(
name|varyingPacking
argument_list|)
expr_stmt|;
block|}
name|initSemanticIndex
argument_list|()
expr_stmt|;
name|defineUniformsAndAssignRegisters
argument_list|()
expr_stmt|;
name|gatherTransformFeedbackVaryings
argument_list|(
name|varyingPacking
argument_list|)
expr_stmt|;
name|LinkResult
name|result
init|=
name|compileProgramExecutables
argument_list|(
name|data
argument_list|,
name|infoLog
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|.
name|error
operator|.
name|isError
argument_list|()
operator|||
operator|!
name|result
operator|.
name|linkSuccess
condition|)
block|{
name|infoLog
operator|<<
literal|"Failed to create D3D shaders."
expr_stmt|;
return|return
name|result
return|;
block|}
name|initUniformBlockInfo
argument_list|()
expr_stmt|;
return|return
name|LinkResult
argument_list|(
literal|true
argument_list|,
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
DECL|function|validate
name|GLboolean
name|ProgramD3D
operator|::
name|validate
parameter_list|(
specifier|const
name|gl
operator|::
name|Caps
modifier|&
comment|/*caps*/
parameter_list|,
name|gl
operator|::
name|InfoLog
modifier|*
comment|/*infoLog*/
parameter_list|)
block|{
comment|// TODO(jmadill): Do something useful here?
return|return
name|GL_TRUE
return|;
block|}
DECL|function|initUniformBlockInfo
name|void
name|ProgramD3D
operator|::
name|initUniformBlockInfo
parameter_list|()
block|{
specifier|const
name|gl
operator|::
name|Shader
modifier|*
name|vertexShader
init|=
name|mData
operator|.
name|getAttachedVertexShader
argument_list|()
decl_stmt|;
for|for
control|(
specifier|const
name|sh
operator|::
name|InterfaceBlock
modifier|&
name|vertexBlock
range|:
name|vertexShader
operator|->
name|getInterfaceBlocks
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|vertexBlock
operator|.
name|staticUse
operator|&&
name|vertexBlock
operator|.
name|layout
operator|==
name|sh
operator|::
name|BLOCKLAYOUT_PACKED
condition|)
continue|continue;
if|if
condition|(
name|mBlockDataSizes
operator|.
name|count
argument_list|(
name|vertexBlock
operator|.
name|name
argument_list|)
operator|>
literal|0
condition|)
continue|continue;
name|size_t
name|dataSize
init|=
name|getUniformBlockInfo
argument_list|(
name|vertexBlock
argument_list|)
decl_stmt|;
name|mBlockDataSizes
index|[
name|vertexBlock
operator|.
name|name
index|]
operator|=
name|dataSize
expr_stmt|;
block|}
specifier|const
name|gl
operator|::
name|Shader
modifier|*
name|fragmentShader
init|=
name|mData
operator|.
name|getAttachedFragmentShader
argument_list|()
decl_stmt|;
for|for
control|(
specifier|const
name|sh
operator|::
name|InterfaceBlock
modifier|&
name|fragmentBlock
range|:
name|fragmentShader
operator|->
name|getInterfaceBlocks
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|fragmentBlock
operator|.
name|staticUse
operator|&&
name|fragmentBlock
operator|.
name|layout
operator|==
name|sh
operator|::
name|BLOCKLAYOUT_PACKED
condition|)
continue|continue;
if|if
condition|(
name|mBlockDataSizes
operator|.
name|count
argument_list|(
name|fragmentBlock
operator|.
name|name
argument_list|)
operator|>
literal|0
condition|)
continue|continue;
name|size_t
name|dataSize
init|=
name|getUniformBlockInfo
argument_list|(
name|fragmentBlock
argument_list|)
decl_stmt|;
name|mBlockDataSizes
index|[
name|fragmentBlock
operator|.
name|name
index|]
operator|=
name|dataSize
expr_stmt|;
block|}
block|}
DECL|function|assignUniformBlockRegisters
name|void
name|ProgramD3D
operator|::
name|assignUniformBlockRegisters
parameter_list|()
block|{
name|mD3DUniformBlocks
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Assign registers and update sizes.
specifier|const
name|ShaderD3D
modifier|*
name|vertexShaderD3D
init|=
name|GetImplAs
argument_list|<
name|ShaderD3D
argument_list|>
argument_list|(
name|mData
operator|.
name|getAttachedVertexShader
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|ShaderD3D
modifier|*
name|fragmentShaderD3D
init|=
name|GetImplAs
argument_list|<
name|ShaderD3D
argument_list|>
argument_list|(
name|mData
operator|.
name|getAttachedFragmentShader
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
specifier|const
name|gl
operator|::
name|UniformBlock
modifier|&
name|uniformBlock
range|:
name|mData
operator|.
name|getUniformBlocks
argument_list|()
control|)
block|{
name|unsigned
name|int
name|uniformBlockElement
init|=
name|uniformBlock
operator|.
name|isArray
condition|?
name|uniformBlock
operator|.
name|arrayElement
else|:
literal|0
decl_stmt|;
name|D3DUniformBlock
name|d3dUniformBlock
decl_stmt|;
if|if
condition|(
name|uniformBlock
operator|.
name|vertexStaticUse
condition|)
block|{
name|unsigned
name|int
name|baseRegister
init|=
name|vertexShaderD3D
operator|->
name|getInterfaceBlockRegister
argument_list|(
name|uniformBlock
operator|.
name|name
argument_list|)
decl_stmt|;
name|d3dUniformBlock
operator|.
name|vsRegisterIndex
operator|=
name|baseRegister
operator|+
name|uniformBlockElement
expr_stmt|;
block|}
if|if
condition|(
name|uniformBlock
operator|.
name|fragmentStaticUse
condition|)
block|{
name|unsigned
name|int
name|baseRegister
init|=
name|fragmentShaderD3D
operator|->
name|getInterfaceBlockRegister
argument_list|(
name|uniformBlock
operator|.
name|name
argument_list|)
decl_stmt|;
name|d3dUniformBlock
operator|.
name|psRegisterIndex
operator|=
name|baseRegister
operator|+
name|uniformBlockElement
expr_stmt|;
block|}
name|mD3DUniformBlocks
operator|.
name|push_back
argument_list|(
name|d3dUniformBlock
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|initializeUniformStorage
name|void
name|ProgramD3D
operator|::
name|initializeUniformStorage
parameter_list|()
block|{
comment|// Compute total default block size
name|unsigned
name|int
name|vertexRegisters
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|fragmentRegisters
init|=
literal|0
decl_stmt|;
for|for
control|(
specifier|const
name|D3DUniform
modifier|*
name|d3dUniform
range|:
name|mD3DUniforms
control|)
block|{
if|if
condition|(
operator|!
name|d3dUniform
operator|->
name|isSampler
argument_list|()
condition|)
block|{
if|if
condition|(
name|d3dUniform
operator|->
name|isReferencedByVertexShader
argument_list|()
condition|)
block|{
name|vertexRegisters
operator|=
name|std
operator|::
name|max
argument_list|(
name|vertexRegisters
argument_list|,
name|d3dUniform
operator|->
name|vsRegisterIndex
operator|+
name|d3dUniform
operator|->
name|registerCount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d3dUniform
operator|->
name|isReferencedByFragmentShader
argument_list|()
condition|)
block|{
name|fragmentRegisters
operator|=
name|std
operator|::
name|max
argument_list|(
name|fragmentRegisters
argument_list|,
name|d3dUniform
operator|->
name|psRegisterIndex
operator|+
name|d3dUniform
operator|->
name|registerCount
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|mVertexUniformStorage
operator|=
name|mRenderer
operator|->
name|createUniformStorage
argument_list|(
name|vertexRegisters
operator|*
literal|16u
argument_list|)
expr_stmt|;
name|mFragmentUniformStorage
operator|=
name|mRenderer
operator|->
name|createUniformStorage
argument_list|(
name|fragmentRegisters
operator|*
literal|16u
argument_list|)
expr_stmt|;
block|}
DECL|function|applyUniforms
name|gl
operator|::
name|Error
name|ProgramD3D
operator|::
name|applyUniforms
parameter_list|(
name|GLenum
name|drawMode
parameter_list|)
block|{
name|ASSERT
argument_list|(
operator|!
name|mDirtySamplerMapping
argument_list|)
expr_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|mRenderer
operator|->
name|applyUniforms
argument_list|(
operator|*
name|this
argument_list|,
name|drawMode
argument_list|,
name|mD3DUniforms
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
for|for
control|(
name|D3DUniform
modifier|*
name|d3dUniform
range|:
name|mD3DUniforms
control|)
block|{
name|d3dUniform
operator|->
name|dirty
operator|=
literal|false
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|applyUniformBuffers
name|gl
operator|::
name|Error
name|ProgramD3D
operator|::
name|applyUniformBuffers
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|)
block|{
if|if
condition|(
name|mData
operator|.
name|getUniformBlocks
argument_list|()
operator|.
name|empty
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
comment|// Lazy init.
if|if
condition|(
name|mD3DUniformBlocks
operator|.
name|empty
argument_list|()
condition|)
block|{
name|assignUniformBlockRegisters
argument_list|()
expr_stmt|;
block|}
name|mVertexUBOCache
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mFragmentUBOCache
operator|.
name|clear
argument_list|()
expr_stmt|;
specifier|const
name|unsigned
name|int
name|reservedBuffersInVS
init|=
name|mRenderer
operator|->
name|getReservedVertexUniformBuffers
argument_list|()
decl_stmt|;
specifier|const
name|unsigned
name|int
name|reservedBuffersInFS
init|=
name|mRenderer
operator|->
name|getReservedFragmentUniformBuffers
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|uniformBlockIndex
init|=
literal|0
init|;
name|uniformBlockIndex
operator|<
name|mD3DUniformBlocks
operator|.
name|size
argument_list|()
condition|;
name|uniformBlockIndex
operator|++
control|)
block|{
specifier|const
name|D3DUniformBlock
modifier|&
name|uniformBlock
init|=
name|mD3DUniformBlocks
index|[
name|uniformBlockIndex
index|]
decl_stmt|;
name|GLuint
name|blockBinding
init|=
name|mData
operator|.
name|getUniformBlockBinding
argument_list|(
name|uniformBlockIndex
argument_list|)
decl_stmt|;
comment|// Unnecessary to apply an unreferenced standard or shared UBO
if|if
condition|(
operator|!
name|uniformBlock
operator|.
name|vertexStaticUse
argument_list|()
operator|&&
operator|!
name|uniformBlock
operator|.
name|fragmentStaticUse
argument_list|()
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|uniformBlock
operator|.
name|vertexStaticUse
argument_list|()
condition|)
block|{
name|unsigned
name|int
name|registerIndex
init|=
name|uniformBlock
operator|.
name|vsRegisterIndex
operator|-
name|reservedBuffersInVS
decl_stmt|;
name|ASSERT
argument_list|(
name|registerIndex
operator|<
name|data
operator|.
name|caps
operator|->
name|maxVertexUniformBlocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|mVertexUBOCache
operator|.
name|size
argument_list|()
operator|<=
name|registerIndex
condition|)
block|{
name|mVertexUBOCache
operator|.
name|resize
argument_list|(
name|registerIndex
operator|+
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|mVertexUBOCache
index|[
name|registerIndex
index|]
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mVertexUBOCache
index|[
name|registerIndex
index|]
operator|=
name|blockBinding
expr_stmt|;
block|}
if|if
condition|(
name|uniformBlock
operator|.
name|fragmentStaticUse
argument_list|()
condition|)
block|{
name|unsigned
name|int
name|registerIndex
init|=
name|uniformBlock
operator|.
name|psRegisterIndex
operator|-
name|reservedBuffersInFS
decl_stmt|;
name|ASSERT
argument_list|(
name|registerIndex
operator|<
name|data
operator|.
name|caps
operator|->
name|maxFragmentUniformBlocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|mFragmentUBOCache
operator|.
name|size
argument_list|()
operator|<=
name|registerIndex
condition|)
block|{
name|mFragmentUBOCache
operator|.
name|resize
argument_list|(
name|registerIndex
operator|+
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|mFragmentUBOCache
index|[
name|registerIndex
index|]
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mFragmentUBOCache
index|[
name|registerIndex
index|]
operator|=
name|blockBinding
expr_stmt|;
block|}
block|}
return|return
name|mRenderer
operator|->
name|setUniformBuffers
argument_list|(
name|data
argument_list|,
name|mVertexUBOCache
argument_list|,
name|mFragmentUBOCache
argument_list|)
return|;
block|}
DECL|function|dirtyAllUniforms
name|void
name|ProgramD3D
operator|::
name|dirtyAllUniforms
parameter_list|()
block|{
for|for
control|(
name|D3DUniform
modifier|*
name|d3dUniform
range|:
name|mD3DUniforms
control|)
block|{
name|d3dUniform
operator|->
name|dirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|setUniform1fv
name|void
name|ProgramD3D
operator|::
name|setUniform1fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|setUniform
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|,
name|GL_FLOAT
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform2fv
name|void
name|ProgramD3D
operator|::
name|setUniform2fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|setUniform
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|,
name|GL_FLOAT_VEC2
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform3fv
name|void
name|ProgramD3D
operator|::
name|setUniform3fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|setUniform
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|,
name|GL_FLOAT_VEC3
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform4fv
name|void
name|ProgramD3D
operator|::
name|setUniform4fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|setUniform
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|,
name|GL_FLOAT_VEC4
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix2fv
name|void
name|ProgramD3D
operator|::
name|setUniformMatrix2fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
name|setUniformMatrixfv
argument_list|<
literal|2
argument_list|,
literal|2
argument_list|>
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|value
argument_list|,
name|GL_FLOAT_MAT2
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix3fv
name|void
name|ProgramD3D
operator|::
name|setUniformMatrix3fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
name|setUniformMatrixfv
argument_list|<
literal|3
argument_list|,
literal|3
argument_list|>
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|value
argument_list|,
name|GL_FLOAT_MAT3
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix4fv
name|void
name|ProgramD3D
operator|::
name|setUniformMatrix4fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
name|setUniformMatrixfv
argument_list|<
literal|4
argument_list|,
literal|4
argument_list|>
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|value
argument_list|,
name|GL_FLOAT_MAT4
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix2x3fv
name|void
name|ProgramD3D
operator|::
name|setUniformMatrix2x3fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
name|setUniformMatrixfv
argument_list|<
literal|2
argument_list|,
literal|3
argument_list|>
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|value
argument_list|,
name|GL_FLOAT_MAT2x3
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix3x2fv
name|void
name|ProgramD3D
operator|::
name|setUniformMatrix3x2fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
name|setUniformMatrixfv
argument_list|<
literal|3
argument_list|,
literal|2
argument_list|>
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|value
argument_list|,
name|GL_FLOAT_MAT3x2
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix2x4fv
name|void
name|ProgramD3D
operator|::
name|setUniformMatrix2x4fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
name|setUniformMatrixfv
argument_list|<
literal|2
argument_list|,
literal|4
argument_list|>
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|value
argument_list|,
name|GL_FLOAT_MAT2x4
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix4x2fv
name|void
name|ProgramD3D
operator|::
name|setUniformMatrix4x2fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
name|setUniformMatrixfv
argument_list|<
literal|4
argument_list|,
literal|2
argument_list|>
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|value
argument_list|,
name|GL_FLOAT_MAT4x2
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix3x4fv
name|void
name|ProgramD3D
operator|::
name|setUniformMatrix3x4fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
name|setUniformMatrixfv
argument_list|<
literal|3
argument_list|,
literal|4
argument_list|>
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|value
argument_list|,
name|GL_FLOAT_MAT3x4
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformMatrix4x3fv
name|void
name|ProgramD3D
operator|::
name|setUniformMatrix4x3fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
name|setUniformMatrixfv
argument_list|<
literal|4
argument_list|,
literal|3
argument_list|>
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|value
argument_list|,
name|GL_FLOAT_MAT4x3
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform1iv
name|void
name|ProgramD3D
operator|::
name|setUniform1iv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|setUniform
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|,
name|GL_INT
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform2iv
name|void
name|ProgramD3D
operator|::
name|setUniform2iv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|setUniform
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|,
name|GL_INT_VEC2
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform3iv
name|void
name|ProgramD3D
operator|::
name|setUniform3iv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|setUniform
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|,
name|GL_INT_VEC3
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform4iv
name|void
name|ProgramD3D
operator|::
name|setUniform4iv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|setUniform
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|,
name|GL_INT_VEC4
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform1uiv
name|void
name|ProgramD3D
operator|::
name|setUniform1uiv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|v
parameter_list|)
block|{
name|setUniform
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|,
name|GL_UNSIGNED_INT
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform2uiv
name|void
name|ProgramD3D
operator|::
name|setUniform2uiv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|v
parameter_list|)
block|{
name|setUniform
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|,
name|GL_UNSIGNED_INT_VEC2
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform3uiv
name|void
name|ProgramD3D
operator|::
name|setUniform3uiv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|v
parameter_list|)
block|{
name|setUniform
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|,
name|GL_UNSIGNED_INT_VEC3
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniform4uiv
name|void
name|ProgramD3D
operator|::
name|setUniform4uiv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|v
parameter_list|)
block|{
name|setUniform
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|,
name|GL_UNSIGNED_INT_VEC4
argument_list|)
expr_stmt|;
block|}
DECL|function|setUniformBlockBinding
name|void
name|ProgramD3D
operator|::
name|setUniformBlockBinding
parameter_list|(
name|GLuint
comment|/*uniformBlockIndex*/
parameter_list|,
name|GLuint
comment|/*uniformBlockBinding*/
parameter_list|)
block|{ }
DECL|function|defineUniformsAndAssignRegisters
name|void
name|ProgramD3D
operator|::
name|defineUniformsAndAssignRegisters
parameter_list|()
block|{
name|D3DUniformMap
name|uniformMap
decl_stmt|;
specifier|const
name|gl
operator|::
name|Shader
modifier|*
name|vertexShader
init|=
name|mData
operator|.
name|getAttachedVertexShader
argument_list|()
decl_stmt|;
for|for
control|(
specifier|const
name|sh
operator|::
name|Uniform
modifier|&
name|vertexUniform
range|:
name|vertexShader
operator|->
name|getUniforms
argument_list|()
control|)
block|{
if|if
condition|(
name|vertexUniform
operator|.
name|staticUse
condition|)
block|{
name|defineUniformBase
argument_list|(
name|vertexShader
argument_list|,
name|vertexUniform
argument_list|,
operator|&
name|uniformMap
argument_list|)
expr_stmt|;
block|}
block|}
specifier|const
name|gl
operator|::
name|Shader
modifier|*
name|fragmentShader
init|=
name|mData
operator|.
name|getAttachedFragmentShader
argument_list|()
decl_stmt|;
for|for
control|(
specifier|const
name|sh
operator|::
name|Uniform
modifier|&
name|fragmentUniform
range|:
name|fragmentShader
operator|->
name|getUniforms
argument_list|()
control|)
block|{
if|if
condition|(
name|fragmentUniform
operator|.
name|staticUse
condition|)
block|{
name|defineUniformBase
argument_list|(
name|fragmentShader
argument_list|,
name|fragmentUniform
argument_list|,
operator|&
name|uniformMap
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Initialize the D3DUniform list to mirror the indexing of the GL layer.
for|for
control|(
specifier|const
name|gl
operator|::
name|LinkedUniform
modifier|&
name|glUniform
range|:
name|mData
operator|.
name|getUniforms
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|glUniform
operator|.
name|isInDefaultBlock
argument_list|()
condition|)
continue|continue;
name|auto
name|mapEntry
init|=
name|uniformMap
operator|.
name|find
argument_list|(
name|glUniform
operator|.
name|name
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|mapEntry
operator|!=
name|uniformMap
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|mD3DUniforms
operator|.
name|push_back
argument_list|(
name|mapEntry
operator|->
name|second
argument_list|)
expr_stmt|;
block|}
name|assignAllSamplerRegisters
argument_list|()
expr_stmt|;
name|initializeUniformStorage
argument_list|()
expr_stmt|;
block|}
DECL|function|defineUniformBase
name|void
name|ProgramD3D
operator|::
name|defineUniformBase
parameter_list|(
specifier|const
name|gl
operator|::
name|Shader
modifier|*
name|shader
parameter_list|,
specifier|const
name|sh
operator|::
name|Uniform
modifier|&
name|uniform
parameter_list|,
name|D3DUniformMap
modifier|*
name|uniformMap
parameter_list|)
block|{
if|if
condition|(
name|uniform
operator|.
name|isBuiltIn
argument_list|()
condition|)
block|{
name|defineUniform
argument_list|(
name|shader
operator|->
name|getType
argument_list|()
argument_list|,
name|uniform
argument_list|,
name|uniform
operator|.
name|name
argument_list|,
literal|nullptr
argument_list|,
name|uniformMap
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|const
name|ShaderD3D
modifier|*
name|shaderD3D
init|=
name|GetImplAs
argument_list|<
name|ShaderD3D
argument_list|>
argument_list|(
name|shader
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|startRegister
init|=
name|shaderD3D
operator|->
name|getUniformRegister
argument_list|(
name|uniform
operator|.
name|name
argument_list|)
decl_stmt|;
name|ShShaderOutput
name|outputType
init|=
name|shaderD3D
operator|->
name|getCompilerOutputType
argument_list|()
decl_stmt|;
name|sh
operator|::
name|HLSLBlockEncoder
name|encoder
argument_list|(
name|sh
operator|::
name|HLSLBlockEncoder
operator|::
name|GetStrategyFor
argument_list|(
name|outputType
argument_list|)
argument_list|)
decl_stmt|;
name|encoder
operator|.
name|skipRegisters
argument_list|(
name|startRegister
argument_list|)
expr_stmt|;
name|defineUniform
argument_list|(
name|shader
operator|->
name|getType
argument_list|()
argument_list|,
name|uniform
argument_list|,
name|uniform
operator|.
name|name
argument_list|,
operator|&
name|encoder
argument_list|,
name|uniformMap
argument_list|)
expr_stmt|;
block|}
DECL|function|getD3DUniformByName
name|D3DUniform
modifier|*
name|ProgramD3D
operator|::
name|getD3DUniformByName
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|name
parameter_list|)
block|{
for|for
control|(
name|D3DUniform
modifier|*
name|d3dUniform
range|:
name|mD3DUniforms
control|)
block|{
if|if
condition|(
name|d3dUniform
operator|->
name|name
operator|==
name|name
condition|)
block|{
return|return
name|d3dUniform
return|;
block|}
block|}
return|return
literal|nullptr
return|;
block|}
DECL|function|defineUniform
name|void
name|ProgramD3D
operator|::
name|defineUniform
parameter_list|(
name|GLenum
name|shaderType
parameter_list|,
specifier|const
name|sh
operator|::
name|ShaderVariable
modifier|&
name|uniform
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|fullName
parameter_list|,
name|sh
operator|::
name|HLSLBlockEncoder
modifier|*
name|encoder
parameter_list|,
name|D3DUniformMap
modifier|*
name|uniformMap
parameter_list|)
block|{
if|if
condition|(
name|uniform
operator|.
name|isStruct
argument_list|()
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|elementIndex
init|=
literal|0
init|;
name|elementIndex
operator|<
name|uniform
operator|.
name|elementCount
argument_list|()
condition|;
name|elementIndex
operator|++
control|)
block|{
specifier|const
name|std
operator|::
name|string
modifier|&
name|elementString
init|=
operator|(
name|uniform
operator|.
name|isArray
argument_list|()
condition|?
name|ArrayString
argument_list|(
name|elementIndex
argument_list|)
else|:
literal|""
operator|)
decl_stmt|;
if|if
condition|(
name|encoder
condition|)
name|encoder
operator|->
name|enterAggregateType
argument_list|()
expr_stmt|;
for|for
control|(
name|size_t
name|fieldIndex
init|=
literal|0
init|;
name|fieldIndex
operator|<
name|uniform
operator|.
name|fields
operator|.
name|size
argument_list|()
condition|;
name|fieldIndex
operator|++
control|)
block|{
specifier|const
name|sh
operator|::
name|ShaderVariable
modifier|&
name|field
init|=
name|uniform
operator|.
name|fields
index|[
name|fieldIndex
index|]
decl_stmt|;
specifier|const
name|std
operator|::
name|string
modifier|&
name|fieldFullName
init|=
operator|(
name|fullName
operator|+
name|elementString
operator|+
literal|"."
operator|+
name|field
operator|.
name|name
operator|)
decl_stmt|;
name|defineUniform
argument_list|(
name|shaderType
argument_list|,
name|field
argument_list|,
name|fieldFullName
argument_list|,
name|encoder
argument_list|,
name|uniformMap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|encoder
condition|)
name|encoder
operator|->
name|exitAggregateType
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
comment|// Not a struct. Arrays are treated as aggregate types.
if|if
condition|(
name|uniform
operator|.
name|isArray
argument_list|()
operator|&&
name|encoder
condition|)
block|{
name|encoder
operator|->
name|enterAggregateType
argument_list|()
expr_stmt|;
block|}
comment|// Advance the uniform offset, to track registers allocation for structs
name|sh
operator|::
name|BlockMemberInfo
name|blockInfo
init|=
name|encoder
condition|?
name|encoder
operator|->
name|encodeType
argument_list|(
name|uniform
operator|.
name|type
argument_list|,
name|uniform
operator|.
name|arraySize
argument_list|,
literal|false
argument_list|)
else|:
name|sh
operator|::
name|BlockMemberInfo
operator|::
name|getDefaultBlockInfo
argument_list|()
decl_stmt|;
name|auto
name|uniformMapEntry
init|=
name|uniformMap
operator|->
name|find
argument_list|(
name|fullName
argument_list|)
decl_stmt|;
name|D3DUniform
modifier|*
name|d3dUniform
init|=
literal|nullptr
decl_stmt|;
if|if
condition|(
name|uniformMapEntry
operator|!=
name|uniformMap
operator|->
name|end
argument_list|()
condition|)
block|{
name|d3dUniform
operator|=
name|uniformMapEntry
operator|->
name|second
expr_stmt|;
block|}
else|else
block|{
name|d3dUniform
operator|=
operator|new
name|D3DUniform
argument_list|(
name|uniform
operator|.
name|type
argument_list|,
name|fullName
argument_list|,
name|uniform
operator|.
name|arraySize
argument_list|,
literal|true
argument_list|)
expr_stmt|;
operator|(
operator|*
name|uniformMap
operator|)
index|[
name|fullName
index|]
operator|=
name|d3dUniform
expr_stmt|;
block|}
if|if
condition|(
name|encoder
condition|)
block|{
name|d3dUniform
operator|->
name|registerElement
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|sh
operator|::
name|HLSLBlockEncoder
operator|::
name|getBlockRegisterElement
argument_list|(
name|blockInfo
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned
name|int
name|reg
init|=
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|sh
operator|::
name|HLSLBlockEncoder
operator|::
name|getBlockRegister
argument_list|(
name|blockInfo
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|shaderType
operator|==
name|GL_FRAGMENT_SHADER
condition|)
block|{
name|d3dUniform
operator|->
name|psRegisterIndex
operator|=
name|reg
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|shaderType
operator|==
name|GL_VERTEX_SHADER
argument_list|)
expr_stmt|;
name|d3dUniform
operator|->
name|vsRegisterIndex
operator|=
name|reg
expr_stmt|;
block|}
comment|// Arrays are treated as aggregate types
if|if
condition|(
name|uniform
operator|.
name|isArray
argument_list|()
condition|)
block|{
name|encoder
operator|->
name|exitAggregateType
argument_list|()
expr_stmt|;
block|}
block|}
block|}
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|setUniform
name|void
name|ProgramD3D
operator|::
name|setUniform
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|countIn
parameter_list|,
specifier|const
name|T
modifier|*
name|v
parameter_list|,
name|GLenum
name|targetUniformType
parameter_list|)
block|{
specifier|const
name|int
name|components
init|=
name|gl
operator|::
name|VariableComponentCount
argument_list|(
name|targetUniformType
argument_list|)
decl_stmt|;
specifier|const
name|GLenum
name|targetBoolType
init|=
name|gl
operator|::
name|VariableBoolVectorType
argument_list|(
name|targetUniformType
argument_list|)
decl_stmt|;
name|D3DUniform
modifier|*
name|targetUniform
init|=
name|getD3DUniformFromLocation
argument_list|(
name|location
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|elementCount
init|=
name|targetUniform
operator|->
name|elementCount
argument_list|()
decl_stmt|;
name|unsigned
name|int
name|arrayElement
init|=
name|mData
operator|.
name|getUniformLocations
argument_list|()
index|[
name|location
index|]
operator|.
name|element
decl_stmt|;
name|unsigned
name|int
name|count
init|=
name|std
operator|::
name|min
argument_list|(
name|elementCount
operator|-
name|arrayElement
argument_list|,
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|countIn
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|targetUniformType
condition|)
block|{
name|T
modifier|*
name|target
init|=
cast|reinterpret_cast
argument_list|<
name|T
operator|*
argument_list|>
argument_list|(
name|targetUniform
operator|->
name|data
argument_list|)
operator|+
name|arrayElement
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|T
modifier|*
name|dest
init|=
name|target
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
decl_stmt|;
specifier|const
name|T
modifier|*
name|source
init|=
name|v
operator|+
operator|(
name|i
operator|*
name|components
operator|)
decl_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|components
condition|;
name|c
operator|++
control|)
block|{
name|SetIfDirty
argument_list|(
name|dest
operator|+
name|c
argument_list|,
name|source
index|[
name|c
index|]
argument_list|,
operator|&
name|targetUniform
operator|->
name|dirty
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|c
init|=
name|components
init|;
name|c
operator|<
literal|4
condition|;
name|c
operator|++
control|)
block|{
name|SetIfDirty
argument_list|(
name|dest
operator|+
name|c
argument_list|,
name|T
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|targetUniform
operator|->
name|dirty
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|targetUniform
operator|->
name|type
operator|==
name|targetBoolType
condition|)
block|{
name|GLint
modifier|*
name|boolParams
init|=
cast|reinterpret_cast
argument_list|<
name|GLint
operator|*
argument_list|>
argument_list|(
name|targetUniform
operator|->
name|data
argument_list|)
operator|+
name|arrayElement
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|GLint
modifier|*
name|dest
init|=
name|boolParams
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
decl_stmt|;
specifier|const
name|T
modifier|*
name|source
init|=
name|v
operator|+
operator|(
name|i
operator|*
name|components
operator|)
decl_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|components
condition|;
name|c
operator|++
control|)
block|{
name|SetIfDirty
argument_list|(
name|dest
operator|+
name|c
argument_list|,
operator|(
name|source
index|[
name|c
index|]
operator|==
cast|static_cast
argument_list|<
name|T
argument_list|>
argument_list|(
literal|0
argument_list|)
operator|)
condition|?
name|GL_FALSE
else|:
name|GL_TRUE
argument_list|,
operator|&
name|targetUniform
operator|->
name|dirty
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|c
init|=
name|components
init|;
name|c
operator|<
literal|4
condition|;
name|c
operator|++
control|)
block|{
name|SetIfDirty
argument_list|(
name|dest
operator|+
name|c
argument_list|,
name|GL_FALSE
argument_list|,
operator|&
name|targetUniform
operator|->
name|dirty
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|targetUniform
operator|->
name|isSampler
argument_list|()
condition|)
block|{
name|ASSERT
argument_list|(
name|targetUniformType
operator|==
name|GL_INT
argument_list|)
expr_stmt|;
name|GLint
modifier|*
name|target
init|=
cast|reinterpret_cast
argument_list|<
name|GLint
operator|*
argument_list|>
argument_list|(
name|targetUniform
operator|->
name|data
argument_list|)
operator|+
name|arrayElement
operator|*
literal|4
decl_stmt|;
name|bool
name|wasDirty
init|=
name|targetUniform
operator|->
name|dirty
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|GLint
modifier|*
name|dest
init|=
name|target
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
decl_stmt|;
specifier|const
name|GLint
modifier|*
name|source
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|GLint
operator|*
argument_list|>
argument_list|(
name|v
argument_list|)
operator|+
operator|(
name|i
operator|*
name|components
operator|)
decl_stmt|;
name|SetIfDirty
argument_list|(
name|dest
operator|+
literal|0
argument_list|,
name|source
index|[
literal|0
index|]
argument_list|,
operator|&
name|targetUniform
operator|->
name|dirty
argument_list|)
expr_stmt|;
name|SetIfDirty
argument_list|(
name|dest
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|targetUniform
operator|->
name|dirty
argument_list|)
expr_stmt|;
name|SetIfDirty
argument_list|(
name|dest
operator|+
literal|2
argument_list|,
literal|0
argument_list|,
operator|&
name|targetUniform
operator|->
name|dirty
argument_list|)
expr_stmt|;
name|SetIfDirty
argument_list|(
name|dest
operator|+
literal|3
argument_list|,
literal|0
argument_list|,
operator|&
name|targetUniform
operator|->
name|dirty
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|wasDirty
operator|&&
name|targetUniform
operator|->
name|dirty
condition|)
block|{
name|mDirtySamplerMapping
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
template|template
parameter_list|<
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|>
DECL|function|setUniformMatrixfv
name|void
name|ProgramD3D
operator|::
name|setUniformMatrixfv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|countIn
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|,
name|GLenum
name|targetUniformType
parameter_list|)
block|{
name|D3DUniform
modifier|*
name|targetUniform
init|=
name|getD3DUniformFromLocation
argument_list|(
name|location
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|elementCount
init|=
name|targetUniform
operator|->
name|elementCount
argument_list|()
decl_stmt|;
name|unsigned
name|int
name|arrayElement
init|=
name|mData
operator|.
name|getUniformLocations
argument_list|()
index|[
name|location
index|]
operator|.
name|element
decl_stmt|;
name|unsigned
name|int
name|count
init|=
name|std
operator|::
name|min
argument_list|(
name|elementCount
operator|-
name|arrayElement
argument_list|,
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|countIn
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|unsigned
name|int
name|targetMatrixStride
init|=
operator|(
literal|4
operator|*
name|rows
operator|)
decl_stmt|;
name|GLfloat
modifier|*
name|target
init|=
operator|(
name|GLfloat
operator|*
operator|)
operator|(
name|targetUniform
operator|->
name|data
operator|+
name|arrayElement
operator|*
sizeof|sizeof
argument_list|(
name|GLfloat
argument_list|)
operator|*
name|targetMatrixStride
operator|)
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|// Internally store matrices as transposed versions to accomodate HLSL matrix indexing
if|if
condition|(
name|transpose
operator|==
name|GL_FALSE
condition|)
block|{
name|targetUniform
operator|->
name|dirty
operator|=
name|TransposeMatrix
argument_list|<
name|GLfloat
argument_list|>
argument_list|(
name|target
argument_list|,
name|value
argument_list|,
literal|4
argument_list|,
name|rows
argument_list|,
name|rows
argument_list|,
name|cols
argument_list|)
operator|||
name|targetUniform
operator|->
name|dirty
expr_stmt|;
block|}
else|else
block|{
name|targetUniform
operator|->
name|dirty
operator|=
name|ExpandMatrix
argument_list|<
name|GLfloat
argument_list|>
argument_list|(
name|target
argument_list|,
name|value
argument_list|,
literal|4
argument_list|,
name|rows
argument_list|,
name|cols
argument_list|,
name|rows
argument_list|)
operator|||
name|targetUniform
operator|->
name|dirty
expr_stmt|;
block|}
name|target
operator|+=
name|targetMatrixStride
expr_stmt|;
name|value
operator|+=
name|cols
operator|*
name|rows
expr_stmt|;
block|}
block|}
DECL|function|getUniformBlockInfo
name|size_t
name|ProgramD3D
operator|::
name|getUniformBlockInfo
parameter_list|(
specifier|const
name|sh
operator|::
name|InterfaceBlock
modifier|&
name|interfaceBlock
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|interfaceBlock
operator|.
name|staticUse
operator|||
name|interfaceBlock
operator|.
name|layout
operator|!=
name|sh
operator|::
name|BLOCKLAYOUT_PACKED
argument_list|)
expr_stmt|;
comment|// define member uniforms
name|sh
operator|::
name|Std140BlockEncoder
name|std140Encoder
decl_stmt|;
name|sh
operator|::
name|HLSLBlockEncoder
name|hlslEncoder
argument_list|(
name|sh
operator|::
name|HLSLBlockEncoder
operator|::
name|ENCODE_PACKED
argument_list|)
decl_stmt|;
name|sh
operator|::
name|BlockLayoutEncoder
modifier|*
name|encoder
init|=
literal|nullptr
decl_stmt|;
if|if
condition|(
name|interfaceBlock
operator|.
name|layout
operator|==
name|sh
operator|::
name|BLOCKLAYOUT_STANDARD
condition|)
block|{
name|encoder
operator|=
operator|&
name|std140Encoder
expr_stmt|;
block|}
else|else
block|{
name|encoder
operator|=
operator|&
name|hlslEncoder
expr_stmt|;
block|}
name|GetUniformBlockInfo
argument_list|(
name|interfaceBlock
operator|.
name|fields
argument_list|,
name|interfaceBlock
operator|.
name|fieldPrefix
argument_list|()
argument_list|,
name|encoder
argument_list|,
name|interfaceBlock
operator|.
name|isRowMajorLayout
argument_list|,
operator|&
name|mBlockInfo
argument_list|)
expr_stmt|;
return|return
name|encoder
operator|->
name|getBlockSize
argument_list|()
return|;
block|}
DECL|function|assignAllSamplerRegisters
name|void
name|ProgramD3D
operator|::
name|assignAllSamplerRegisters
parameter_list|()
block|{
for|for
control|(
specifier|const
name|D3DUniform
modifier|*
name|d3dUniform
range|:
name|mD3DUniforms
control|)
block|{
if|if
condition|(
name|d3dUniform
operator|->
name|isSampler
argument_list|()
condition|)
block|{
name|assignSamplerRegisters
argument_list|(
name|d3dUniform
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|assignSamplerRegisters
name|void
name|ProgramD3D
operator|::
name|assignSamplerRegisters
parameter_list|(
specifier|const
name|D3DUniform
modifier|*
name|d3dUniform
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|d3dUniform
operator|->
name|isSampler
argument_list|()
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|d3dUniform
operator|->
name|vsRegisterIndex
operator|!=
name|GL_INVALID_INDEX
operator|||
name|d3dUniform
operator|->
name|psRegisterIndex
operator|!=
name|GL_INVALID_INDEX
argument_list|)
expr_stmt|;
if|if
condition|(
name|d3dUniform
operator|->
name|vsRegisterIndex
operator|!=
name|GL_INVALID_INDEX
condition|)
block|{
name|AssignSamplers
argument_list|(
name|d3dUniform
operator|->
name|vsRegisterIndex
argument_list|,
name|d3dUniform
operator|->
name|type
argument_list|,
name|d3dUniform
operator|->
name|arraySize
argument_list|,
name|mSamplersVS
argument_list|,
operator|&
name|mUsedVertexSamplerRange
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d3dUniform
operator|->
name|psRegisterIndex
operator|!=
name|GL_INVALID_INDEX
condition|)
block|{
name|AssignSamplers
argument_list|(
name|d3dUniform
operator|->
name|psRegisterIndex
argument_list|,
name|d3dUniform
operator|->
name|type
argument_list|,
name|d3dUniform
operator|->
name|arraySize
argument_list|,
name|mSamplersPS
argument_list|,
operator|&
name|mUsedPixelSamplerRange
argument_list|)
expr_stmt|;
block|}
block|}
comment|// static
DECL|function|AssignSamplers
name|void
name|ProgramD3D
operator|::
name|AssignSamplers
parameter_list|(
name|unsigned
name|int
name|startSamplerIndex
parameter_list|,
name|GLenum
name|samplerType
parameter_list|,
name|unsigned
name|int
name|samplerCount
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|Sampler
argument_list|>
modifier|&
name|outSamplers
parameter_list|,
name|GLuint
modifier|*
name|outUsedRange
parameter_list|)
block|{
name|unsigned
name|int
name|samplerIndex
init|=
name|startSamplerIndex
decl_stmt|;
do|do
block|{
name|ASSERT
argument_list|(
name|samplerIndex
operator|<
name|outSamplers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Sampler
modifier|*
name|sampler
init|=
operator|&
name|outSamplers
index|[
name|samplerIndex
index|]
decl_stmt|;
name|sampler
operator|->
name|active
operator|=
literal|true
expr_stmt|;
name|sampler
operator|->
name|textureType
operator|=
name|gl
operator|::
name|SamplerTypeToTextureType
argument_list|(
name|samplerType
argument_list|)
expr_stmt|;
name|sampler
operator|->
name|logicalTextureUnit
operator|=
literal|0
expr_stmt|;
operator|*
name|outUsedRange
operator|=
name|std
operator|::
name|max
argument_list|(
name|samplerIndex
operator|+
literal|1
argument_list|,
operator|*
name|outUsedRange
argument_list|)
expr_stmt|;
name|samplerIndex
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|samplerIndex
operator|<
name|startSamplerIndex
operator|+
name|samplerCount
condition|)
do|;
block|}
DECL|function|reset
name|void
name|ProgramD3D
operator|::
name|reset
parameter_list|()
block|{
name|SafeDeleteContainer
argument_list|(
name|mVertexExecutables
argument_list|)
expr_stmt|;
name|SafeDeleteContainer
argument_list|(
name|mPixelExecutables
argument_list|)
expr_stmt|;
for|for
control|(
name|auto
operator|&
name|element
operator|:
name|mGeometryExecutables
control|)
block|{
name|SafeDelete
argument_list|(
name|element
argument_list|)
expr_stmt|;
block|}
name|mVertexHLSL
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mVertexWorkarounds
operator|=
name|D3DCompilerWorkarounds
argument_list|()
expr_stmt|;
name|mPixelHLSL
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mPixelWorkarounds
operator|=
name|D3DCompilerWorkarounds
argument_list|()
expr_stmt|;
name|mUsesFragDepth
operator|=
literal|false
expr_stmt|;
name|mPixelShaderKey
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mUsesPointSize
operator|=
literal|false
expr_stmt|;
name|mUsesFlatInterpolation
operator|=
literal|false
expr_stmt|;
name|SafeDeleteContainer
argument_list|(
name|mD3DUniforms
argument_list|)
expr_stmt|;
name|mD3DUniformBlocks
operator|.
name|clear
argument_list|()
expr_stmt|;
name|SafeDelete
argument_list|(
name|mVertexUniformStorage
argument_list|)
expr_stmt|;
name|SafeDelete
argument_list|(
name|mFragmentUniformStorage
argument_list|)
expr_stmt|;
name|mSamplersPS
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mSamplersVS
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mUsedVertexSamplerRange
operator|=
literal|0
expr_stmt|;
name|mUsedPixelSamplerRange
operator|=
literal|0
expr_stmt|;
name|mDirtySamplerMapping
operator|=
literal|true
expr_stmt|;
name|std
operator|::
name|fill
argument_list|(
name|mSemanticIndexes
argument_list|,
name|mSemanticIndexes
operator|+
name|ArraySize
argument_list|(
name|mSemanticIndexes
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|std
operator|::
name|fill
argument_list|(
name|mAttributesByLayout
argument_list|,
name|mAttributesByLayout
operator|+
name|ArraySize
argument_list|(
name|mAttributesByLayout
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mStreamOutVaryings
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mGeometryShaderPreamble
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|function|getSerial
name|unsigned
name|int
name|ProgramD3D
operator|::
name|getSerial
parameter_list|()
specifier|const
block|{
return|return
name|mSerial
return|;
block|}
DECL|function|issueSerial
name|unsigned
name|int
name|ProgramD3D
operator|::
name|issueSerial
parameter_list|()
block|{
return|return
name|mCurrentSerial
operator|++
return|;
block|}
DECL|function|initSemanticIndex
name|void
name|ProgramD3D
operator|::
name|initSemanticIndex
parameter_list|()
block|{
specifier|const
name|gl
operator|::
name|Shader
modifier|*
name|vertexShader
init|=
name|mData
operator|.
name|getAttachedVertexShader
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|vertexShader
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
comment|// Init semantic index
for|for
control|(
specifier|const
name|sh
operator|::
name|Attribute
modifier|&
name|attribute
range|:
name|mData
operator|.
name|getAttributes
argument_list|()
control|)
block|{
name|int
name|attributeIndex
init|=
name|attribute
operator|.
name|location
decl_stmt|;
name|int
name|index
init|=
name|vertexShader
operator|->
name|getSemanticIndex
argument_list|(
name|attribute
operator|.
name|name
argument_list|)
decl_stmt|;
name|int
name|regs
init|=
name|gl
operator|::
name|VariableRegisterCount
argument_list|(
name|attribute
operator|.
name|type
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|reg
init|=
literal|0
init|;
name|reg
operator|<
name|regs
condition|;
operator|++
name|reg
control|)
block|{
name|mSemanticIndexes
index|[
name|attributeIndex
operator|+
name|reg
index|]
operator|=
name|index
operator|+
name|reg
expr_stmt|;
block|}
block|}
name|initAttributesByLayout
argument_list|()
expr_stmt|;
block|}
DECL|function|initAttributesByLayout
name|void
name|ProgramD3D
operator|::
name|initAttributesByLayout
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
condition|;
name|i
operator|++
control|)
block|{
name|mAttributesByLayout
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
name|std
operator|::
name|sort
argument_list|(
operator|&
name|mAttributesByLayout
index|[
literal|0
index|]
argument_list|,
operator|&
name|mAttributesByLayout
index|[
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
index|]
argument_list|,
name|AttributeSorter
argument_list|(
name|mSemanticIndexes
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|sortAttributesByLayout
name|void
name|ProgramD3D
operator|::
name|sortAttributesByLayout
parameter_list|(
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|TranslatedAttribute
argument_list|>
modifier|&
name|unsortedAttributes
parameter_list|,
name|int
name|sortedSemanticIndicesOut
index|[
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
index|]
parameter_list|,
specifier|const
name|rx
operator|::
name|TranslatedAttribute
modifier|*
name|sortedAttributesOut
index|[
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
index|]
parameter_list|)
specifier|const
block|{
for|for
control|(
name|size_t
name|attribIndex
init|=
literal|0
init|;
name|attribIndex
operator|<
name|unsortedAttributes
operator|.
name|size
argument_list|()
condition|;
operator|++
name|attribIndex
control|)
block|{
name|int
name|oldIndex
init|=
name|mAttributesByLayout
index|[
name|attribIndex
index|]
decl_stmt|;
name|sortedSemanticIndicesOut
index|[
name|attribIndex
index|]
operator|=
name|mSemanticIndexes
index|[
name|oldIndex
index|]
expr_stmt|;
name|sortedAttributesOut
index|[
name|attribIndex
index|]
operator|=
operator|&
name|unsortedAttributes
index|[
name|oldIndex
index|]
expr_stmt|;
block|}
block|}
DECL|function|updateCachedInputLayout
name|void
name|ProgramD3D
operator|::
name|updateCachedInputLayout
parameter_list|(
specifier|const
name|gl
operator|::
name|State
modifier|&
name|state
parameter_list|)
block|{
name|mCachedInputLayout
operator|.
name|clear
argument_list|()
expr_stmt|;
specifier|const
specifier|auto
modifier|&
name|vertexAttributes
init|=
name|state
operator|.
name|getVertexArray
argument_list|()
operator|->
name|getVertexAttributes
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|attributeIndex
range|:
name|angle
operator|::
name|IterateBitSet
argument_list|(
name|mData
operator|.
name|getActiveAttribLocationsMask
argument_list|()
argument_list|)
control|)
block|{
name|int
name|semanticIndex
init|=
name|mSemanticIndexes
index|[
name|attributeIndex
index|]
decl_stmt|;
if|if
condition|(
name|semanticIndex
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|mCachedInputLayout
operator|.
name|size
argument_list|()
operator|<
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|semanticIndex
operator|+
literal|1
argument_list|)
condition|)
block|{
name|mCachedInputLayout
operator|.
name|resize
argument_list|(
name|semanticIndex
operator|+
literal|1
argument_list|,
name|gl
operator|::
name|VERTEX_FORMAT_INVALID
argument_list|)
expr_stmt|;
block|}
name|mCachedInputLayout
index|[
name|semanticIndex
index|]
operator|=
name|GetVertexFormatType
argument_list|(
name|vertexAttributes
index|[
name|attributeIndex
index|]
argument_list|,
name|state
operator|.
name|getVertexAttribCurrentValue
argument_list|(
name|attributeIndex
argument_list|)
operator|.
name|Type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|gatherTransformFeedbackVaryings
name|void
name|ProgramD3D
operator|::
name|gatherTransformFeedbackVaryings
parameter_list|(
specifier|const
name|VaryingPacking
modifier|&
name|varyingPacking
parameter_list|)
block|{
specifier|const
specifier|auto
modifier|&
name|builtins
init|=
name|varyingPacking
operator|.
name|builtins
argument_list|(
name|SHADER_VERTEX
argument_list|)
decl_stmt|;
specifier|const
name|std
operator|::
name|string
modifier|&
name|varyingSemantic
init|=
name|GetVaryingSemantic
argument_list|(
name|mRenderer
operator|->
name|getMajorShaderModel
argument_list|()
argument_list|,
name|usesPointSize
argument_list|()
argument_list|)
decl_stmt|;
comment|// Gather the linked varyings that are used for transform feedback, they should all exist.
name|mStreamOutVaryings
operator|.
name|clear
argument_list|()
expr_stmt|;
specifier|const
specifier|auto
modifier|&
name|tfVaryingNames
init|=
name|mData
operator|.
name|getTransformFeedbackVaryingNames
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|outputSlot
init|=
literal|0
init|;
name|outputSlot
operator|<
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|tfVaryingNames
operator|.
name|size
argument_list|()
argument_list|)
condition|;
operator|++
name|outputSlot
control|)
block|{
specifier|const
specifier|auto
modifier|&
name|tfVaryingName
init|=
name|tfVaryingNames
index|[
name|outputSlot
index|]
decl_stmt|;
if|if
condition|(
name|tfVaryingName
operator|==
literal|"gl_Position"
condition|)
block|{
if|if
condition|(
name|builtins
operator|.
name|glPosition
operator|.
name|enabled
condition|)
block|{
name|mStreamOutVaryings
operator|.
name|push_back
argument_list|(
name|D3DVarying
argument_list|(
name|builtins
operator|.
name|glPosition
operator|.
name|semantic
argument_list|,
name|builtins
operator|.
name|glPosition
operator|.
name|index
argument_list|,
literal|4
argument_list|,
name|outputSlot
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tfVaryingName
operator|==
literal|"gl_FragCoord"
condition|)
block|{
if|if
condition|(
name|builtins
operator|.
name|glFragCoord
operator|.
name|enabled
condition|)
block|{
name|mStreamOutVaryings
operator|.
name|push_back
argument_list|(
name|D3DVarying
argument_list|(
name|builtins
operator|.
name|glFragCoord
operator|.
name|semantic
argument_list|,
name|builtins
operator|.
name|glFragCoord
operator|.
name|index
argument_list|,
literal|4
argument_list|,
name|outputSlot
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tfVaryingName
operator|==
literal|"gl_PointSize"
condition|)
block|{
if|if
condition|(
name|builtins
operator|.
name|glPointSize
operator|.
name|enabled
condition|)
block|{
name|mStreamOutVaryings
operator|.
name|push_back
argument_list|(
name|D3DVarying
argument_list|(
literal|"PSIZE"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|outputSlot
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
specifier|const
name|PackedVaryingRegister
modifier|&
name|registerInfo
range|:
name|varyingPacking
operator|.
name|getRegisterList
argument_list|()
control|)
block|{
specifier|const
specifier|auto
modifier|&
name|varying
init|=
operator|*
name|registerInfo
operator|.
name|packedVarying
operator|->
name|varying
decl_stmt|;
name|GLenum
name|transposedType
init|=
name|gl
operator|::
name|TransposeMatrixType
argument_list|(
name|varying
operator|.
name|type
argument_list|)
decl_stmt|;
name|int
name|componentCount
init|=
name|gl
operator|::
name|VariableColumnCount
argument_list|(
name|transposedType
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|varying
operator|.
name|isBuiltIn
argument_list|()
argument_list|)
expr_stmt|;
comment|// Transform feedback for varying structs is underspecified.
comment|// See Khronos bug 9856.
comment|// TODO(jmadill): Figure out how to be spec-compliant here.
if|if
condition|(
name|registerInfo
operator|.
name|packedVarying
operator|->
name|isStructField
argument_list|()
operator|||
name|varying
operator|.
name|isStruct
argument_list|()
condition|)
continue|continue;
comment|// There can be more than one register assigned to a particular varying, and each
comment|// register needs its own stream out entry.
if|if
condition|(
name|tfVaryingName
operator|==
name|varying
operator|.
name|name
condition|)
block|{
name|mStreamOutVaryings
operator|.
name|push_back
argument_list|(
name|D3DVarying
argument_list|(
name|varyingSemantic
argument_list|,
name|registerInfo
operator|.
name|semanticIndex
argument_list|,
name|componentCount
argument_list|,
name|outputSlot
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|function|getD3DUniformFromLocation
name|D3DUniform
modifier|*
name|ProgramD3D
operator|::
name|getD3DUniformFromLocation
parameter_list|(
name|GLint
name|location
parameter_list|)
block|{
return|return
name|mD3DUniforms
index|[
name|mData
operator|.
name|getUniformLocations
argument_list|()
index|[
name|location
index|]
operator|.
name|index
index|]
return|;
block|}
DECL|function|getUniformBlockSize
name|bool
name|ProgramD3D
operator|::
name|getUniformBlockSize
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|blockName
parameter_list|,
name|size_t
modifier|*
name|sizeOut
parameter_list|)
specifier|const
block|{
name|std
operator|::
name|string
name|baseName
init|=
name|blockName
decl_stmt|;
name|gl
operator|::
name|ParseAndStripArrayIndex
argument_list|(
operator|&
name|baseName
argument_list|)
expr_stmt|;
name|auto
name|sizeIter
init|=
name|mBlockDataSizes
operator|.
name|find
argument_list|(
name|baseName
argument_list|)
decl_stmt|;
if|if
condition|(
name|sizeIter
operator|==
name|mBlockDataSizes
operator|.
name|end
argument_list|()
condition|)
block|{
operator|*
name|sizeOut
operator|=
literal|0
expr_stmt|;
return|return
literal|false
return|;
block|}
operator|*
name|sizeOut
operator|=
name|sizeIter
operator|->
name|second
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|getUniformBlockMemberInfo
name|bool
name|ProgramD3D
operator|::
name|getUniformBlockMemberInfo
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|memberUniformName
parameter_list|,
name|sh
operator|::
name|BlockMemberInfo
modifier|*
name|memberInfoOut
parameter_list|)
specifier|const
block|{
name|auto
name|infoIter
init|=
name|mBlockInfo
operator|.
name|find
argument_list|(
name|memberUniformName
argument_list|)
decl_stmt|;
if|if
condition|(
name|infoIter
operator|==
name|mBlockInfo
operator|.
name|end
argument_list|()
condition|)
block|{
operator|*
name|memberInfoOut
operator|=
name|sh
operator|::
name|BlockMemberInfo
operator|::
name|getDefaultBlockInfo
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
operator|*
name|memberInfoOut
operator|=
name|infoIter
operator|->
name|second
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
end_namespace
end_unit
