begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright 2015 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// VaryingPacking:
end_comment
begin_comment
comment|//   Class which describes a mapping from varyings to registers in D3D
end_comment
begin_comment
comment|//   for linking between shader stages.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/VaryingPacking.h"
end_include
begin_include
include|#
directive|include
file|"common/utilities.h"
end_include
begin_include
include|#
directive|include
file|"compiler/translator/blocklayoutHLSL.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/DynamicHLSL.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/ProgramD3D.h"
end_include
begin_namespace
DECL|namespace|rx
namespace|namespace
name|rx
block|{
comment|// Implementation of VaryingPacking::BuiltinVarying
DECL|function|BuiltinVarying
name|VaryingPacking
operator|::
name|BuiltinVarying
operator|::
name|BuiltinVarying
parameter_list|()
member_init_list|:
name|enabled
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|index
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|systemValue
argument_list|(
literal|false
argument_list|)
block|{ }
DECL|function|str
name|std
operator|::
name|string
name|VaryingPacking
operator|::
name|BuiltinVarying
operator|::
name|str
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|systemValue
condition|?
name|semantic
else|:
operator|(
name|semantic
operator|+
name|Str
argument_list|(
name|index
argument_list|)
operator|)
operator|)
return|;
block|}
DECL|function|enableSystem
name|void
name|VaryingPacking
operator|::
name|BuiltinVarying
operator|::
name|enableSystem
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|systemValueSemantic
parameter_list|)
block|{
name|enabled
operator|=
literal|true
expr_stmt|;
name|semantic
operator|=
name|systemValueSemantic
expr_stmt|;
name|systemValue
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|enable
name|void
name|VaryingPacking
operator|::
name|BuiltinVarying
operator|::
name|enable
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|semanticVal
parameter_list|,
name|unsigned
name|int
name|indexVal
parameter_list|)
block|{
name|enabled
operator|=
literal|true
expr_stmt|;
name|semantic
operator|=
name|semanticVal
expr_stmt|;
name|index
operator|=
name|indexVal
expr_stmt|;
block|}
comment|// Implementation of VaryingPacking
DECL|function|VaryingPacking
name|VaryingPacking
operator|::
name|VaryingPacking
parameter_list|(
name|GLuint
name|maxVaryingVectors
parameter_list|)
member_init_list|:
name|mRegisterMap
argument_list|(
name|maxVaryingVectors
argument_list|)
member_init_list|,
name|mBuiltinInfo
argument_list|(
name|SHADER_TYPE_MAX
argument_list|)
block|{ }
comment|// Packs varyings into generic varying registers, using the algorithm from
comment|// See [OpenGL ES Shading Language 1.00 rev. 17] appendix A section 7 page 111
comment|// Also [OpenGL ES Shading Language 3.00 rev. 4] Section 11 page 119
comment|// Returns false if unsuccessful.
DECL|function|packVarying
name|bool
name|VaryingPacking
operator|::
name|packVarying
parameter_list|(
specifier|const
name|PackedVarying
modifier|&
name|packedVarying
parameter_list|)
block|{
name|unsigned
name|int
name|varyingRows
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|varyingColumns
init|=
literal|0
decl_stmt|;
specifier|const
specifier|auto
modifier|&
name|varying
init|=
operator|*
name|packedVarying
operator|.
name|varying
decl_stmt|;
comment|// "Non - square matrices of type matCxR consume the same space as a square matrix of type matN
comment|// where N is the greater of C and R.Variables of type mat2 occupies 2 complete rows."
comment|// Here we are a bit more conservative and allow packing non-square matrices more tightly.
comment|// Make sure we use transposed matrix types to count registers correctly.
name|ASSERT
argument_list|(
operator|!
name|varying
operator|.
name|isStruct
argument_list|()
argument_list|)
expr_stmt|;
name|GLenum
name|transposedType
init|=
name|gl
operator|::
name|TransposeMatrixType
argument_list|(
name|varying
operator|.
name|type
argument_list|)
decl_stmt|;
name|varyingRows
operator|=
name|gl
operator|::
name|VariableRowCount
argument_list|(
name|transposedType
argument_list|)
expr_stmt|;
name|varyingColumns
operator|=
name|gl
operator|::
name|VariableColumnCount
argument_list|(
name|transposedType
argument_list|)
expr_stmt|;
comment|// "Arrays of size N are assumed to take N times the size of the base type"
name|varyingRows
operator|*=
name|varying
operator|.
name|elementCount
argument_list|()
expr_stmt|;
name|unsigned
name|int
name|maxVaryingVectors
init|=
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|mRegisterMap
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|// "For 2, 3 and 4 component variables packing is started using the 1st column of the 1st row.
comment|// Variables are then allocated to successive rows, aligning them to the 1st column."
if|if
condition|(
name|varyingColumns
operator|>=
literal|2
operator|&&
name|varyingColumns
operator|<=
literal|4
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|row
init|=
literal|0
init|;
name|row
operator|<=
name|maxVaryingVectors
operator|-
name|varyingRows
condition|;
operator|++
name|row
control|)
block|{
if|if
condition|(
name|isFree
argument_list|(
name|row
argument_list|,
literal|0
argument_list|,
name|varyingRows
argument_list|,
name|varyingColumns
argument_list|)
condition|)
block|{
name|insert
argument_list|(
name|row
argument_list|,
literal|0
argument_list|,
name|packedVarying
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
comment|// "For 2 component variables, when there are no spare rows, the strategy is switched to
comment|// using the highest numbered row and the lowest numbered column where the variable will
comment|// fit."
if|if
condition|(
name|varyingColumns
operator|==
literal|2
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|r
init|=
name|maxVaryingVectors
operator|-
name|varyingRows
operator|+
literal|1
init|;
name|r
operator|--
operator|>=
literal|1
condition|;
control|)
block|{
if|if
condition|(
name|isFree
argument_list|(
name|r
argument_list|,
literal|2
argument_list|,
name|varyingRows
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|insert
argument_list|(
name|r
argument_list|,
literal|2
argument_list|,
name|packedVarying
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|// "1 component variables have their own packing rule. They are packed in order of size, largest
comment|// first. Each variable is placed in the column that leaves the least amount of space in the
comment|// column and aligned to the lowest available rows within that column."
name|ASSERT
argument_list|(
name|varyingColumns
operator|==
literal|1
argument_list|)
expr_stmt|;
name|unsigned
name|int
name|contiguousSpace
index|[
literal|4
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|unsigned
name|int
name|bestContiguousSpace
index|[
literal|4
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|unsigned
name|int
name|totalSpace
index|[
literal|4
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|row
init|=
literal|0
init|;
name|row
operator|<
name|maxVaryingVectors
condition|;
operator|++
name|row
control|)
block|{
for|for
control|(
name|unsigned
name|int
name|column
init|=
literal|0
init|;
name|column
operator|<
literal|4
condition|;
operator|++
name|column
control|)
block|{
if|if
condition|(
name|mRegisterMap
index|[
name|row
index|]
index|[
name|column
index|]
condition|)
block|{
name|contiguousSpace
index|[
name|column
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|contiguousSpace
index|[
name|column
index|]
operator|++
expr_stmt|;
name|totalSpace
index|[
name|column
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|contiguousSpace
index|[
name|column
index|]
operator|>
name|bestContiguousSpace
index|[
name|column
index|]
condition|)
block|{
name|bestContiguousSpace
index|[
name|column
index|]
operator|=
name|contiguousSpace
index|[
name|column
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
name|unsigned
name|int
name|bestColumn
init|=
literal|0
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|column
init|=
literal|1
init|;
name|column
operator|<
literal|4
condition|;
operator|++
name|column
control|)
block|{
if|if
condition|(
name|bestContiguousSpace
index|[
name|column
index|]
operator|>=
name|varyingRows
operator|&&
operator|(
name|bestContiguousSpace
index|[
name|bestColumn
index|]
operator|<
name|varyingRows
operator|||
name|totalSpace
index|[
name|column
index|]
operator|<
name|totalSpace
index|[
name|bestColumn
index|]
operator|)
condition|)
block|{
name|bestColumn
operator|=
name|column
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bestContiguousSpace
index|[
name|bestColumn
index|]
operator|>=
name|varyingRows
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|row
init|=
literal|0
init|;
name|row
operator|<
name|maxVaryingVectors
condition|;
name|row
operator|++
control|)
block|{
if|if
condition|(
name|isFree
argument_list|(
name|row
argument_list|,
name|bestColumn
argument_list|,
name|varyingRows
argument_list|,
literal|1
argument_list|)
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|arrayIndex
init|=
literal|0
init|;
name|arrayIndex
operator|<
name|varyingRows
condition|;
operator|++
name|arrayIndex
control|)
block|{
comment|// If varyingRows> 1, it must be an array.
name|PackedVaryingRegister
name|registerInfo
decl_stmt|;
name|registerInfo
operator|.
name|packedVarying
operator|=
operator|&
name|packedVarying
expr_stmt|;
name|registerInfo
operator|.
name|registerRow
operator|=
name|row
operator|+
name|arrayIndex
expr_stmt|;
name|registerInfo
operator|.
name|registerColumn
operator|=
name|bestColumn
expr_stmt|;
name|registerInfo
operator|.
name|varyingArrayIndex
operator|=
name|arrayIndex
expr_stmt|;
name|registerInfo
operator|.
name|varyingRowIndex
operator|=
literal|0
expr_stmt|;
name|mRegisterList
operator|.
name|push_back
argument_list|(
name|registerInfo
argument_list|)
expr_stmt|;
name|mRegisterMap
index|[
name|row
operator|+
name|arrayIndex
index|]
index|[
name|bestColumn
index|]
operator|=
literal|true
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|function|isFree
name|bool
name|VaryingPacking
operator|::
name|isFree
parameter_list|(
name|unsigned
name|int
name|registerRow
parameter_list|,
name|unsigned
name|int
name|registerColumn
parameter_list|,
name|unsigned
name|int
name|varyingRows
parameter_list|,
name|unsigned
name|int
name|varyingColumns
parameter_list|)
specifier|const
block|{
for|for
control|(
name|unsigned
name|int
name|row
init|=
literal|0
init|;
name|row
operator|<
name|varyingRows
condition|;
operator|++
name|row
control|)
block|{
name|ASSERT
argument_list|(
name|registerRow
operator|+
name|row
operator|<
name|mRegisterMap
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|column
init|=
literal|0
init|;
name|column
operator|<
name|varyingColumns
condition|;
operator|++
name|column
control|)
block|{
name|ASSERT
argument_list|(
name|registerColumn
operator|+
name|column
operator|<
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|mRegisterMap
index|[
name|registerRow
operator|+
name|row
index|]
index|[
name|registerColumn
operator|+
name|column
index|]
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|insert
name|void
name|VaryingPacking
operator|::
name|insert
parameter_list|(
name|unsigned
name|int
name|registerRow
parameter_list|,
name|unsigned
name|int
name|registerColumn
parameter_list|,
specifier|const
name|PackedVarying
modifier|&
name|packedVarying
parameter_list|)
block|{
name|unsigned
name|int
name|varyingRows
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|varyingColumns
init|=
literal|0
decl_stmt|;
specifier|const
specifier|auto
modifier|&
name|varying
init|=
operator|*
name|packedVarying
operator|.
name|varying
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|varying
operator|.
name|isStruct
argument_list|()
argument_list|)
expr_stmt|;
name|GLenum
name|transposedType
init|=
name|gl
operator|::
name|TransposeMatrixType
argument_list|(
name|varying
operator|.
name|type
argument_list|)
decl_stmt|;
name|varyingRows
operator|=
name|gl
operator|::
name|VariableRowCount
argument_list|(
name|transposedType
argument_list|)
expr_stmt|;
name|varyingColumns
operator|=
name|gl
operator|::
name|VariableColumnCount
argument_list|(
name|transposedType
argument_list|)
expr_stmt|;
name|PackedVaryingRegister
name|registerInfo
decl_stmt|;
name|registerInfo
operator|.
name|packedVarying
operator|=
operator|&
name|packedVarying
expr_stmt|;
name|registerInfo
operator|.
name|registerColumn
operator|=
name|registerColumn
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|arrayElement
init|=
literal|0
init|;
name|arrayElement
operator|<
name|varying
operator|.
name|elementCount
argument_list|()
condition|;
operator|++
name|arrayElement
control|)
block|{
for|for
control|(
name|unsigned
name|int
name|varyingRow
init|=
literal|0
init|;
name|varyingRow
operator|<
name|varyingRows
condition|;
operator|++
name|varyingRow
control|)
block|{
name|registerInfo
operator|.
name|registerRow
operator|=
name|registerRow
operator|+
operator|(
name|arrayElement
operator|*
name|varyingRows
operator|)
operator|+
name|varyingRow
expr_stmt|;
name|registerInfo
operator|.
name|varyingRowIndex
operator|=
name|varyingRow
expr_stmt|;
name|registerInfo
operator|.
name|varyingArrayIndex
operator|=
name|arrayElement
expr_stmt|;
name|mRegisterList
operator|.
name|push_back
argument_list|(
name|registerInfo
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|columnIndex
init|=
literal|0
init|;
name|columnIndex
operator|<
name|varyingColumns
condition|;
operator|++
name|columnIndex
control|)
block|{
name|mRegisterMap
index|[
name|registerInfo
operator|.
name|registerRow
index|]
index|[
name|registerColumn
operator|+
name|columnIndex
index|]
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// See comment on packVarying.
DECL|function|packVaryings
name|bool
name|VaryingPacking
operator|::
name|packVaryings
parameter_list|(
name|gl
operator|::
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|PackedVarying
argument_list|>
modifier|&
name|packedVaryings
parameter_list|,
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|std
operator|::
name|string
argument_list|>
modifier|&
name|transformFeedbackVaryings
parameter_list|)
block|{
name|std
operator|::
name|set
argument_list|<
name|std
operator|::
name|string
argument_list|>
name|uniqueVaryingNames
decl_stmt|;
comment|// "Variables are packed into the registers one at a time so that they each occupy a contiguous
comment|// subrectangle. No splitting of variables is permitted."
for|for
control|(
specifier|const
name|PackedVarying
modifier|&
name|packedVarying
range|:
name|packedVaryings
control|)
block|{
specifier|const
specifier|auto
modifier|&
name|varying
init|=
operator|*
name|packedVarying
operator|.
name|varying
decl_stmt|;
comment|// Do not assign registers to built-in or unreferenced varyings
if|if
condition|(
name|varying
operator|.
name|isBuiltIn
argument_list|()
operator|||
operator|(
operator|!
name|varying
operator|.
name|staticUse
operator|&&
operator|!
name|packedVarying
operator|.
name|isStructField
argument_list|()
operator|)
condition|)
block|{
continue|continue;
block|}
name|ASSERT
argument_list|(
operator|!
name|varying
operator|.
name|isStruct
argument_list|()
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|uniqueVaryingNames
operator|.
name|count
argument_list|(
name|varying
operator|.
name|name
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|packVarying
argument_list|(
name|packedVarying
argument_list|)
condition|)
block|{
name|uniqueVaryingNames
operator|.
name|insert
argument_list|(
name|varying
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|infoLog
operator|<<
literal|"Could not pack varying "
operator|<<
name|varying
operator|.
name|name
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
for|for
control|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|transformFeedbackVaryingName
range|:
name|transformFeedbackVaryings
control|)
block|{
if|if
condition|(
name|transformFeedbackVaryingName
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|,
literal|"gl_"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// do not pack builtin XFB varyings
continue|continue;
block|}
for|for
control|(
specifier|const
name|PackedVarying
modifier|&
name|packedVarying
range|:
name|packedVaryings
control|)
block|{
specifier|const
specifier|auto
modifier|&
name|varying
init|=
operator|*
name|packedVarying
operator|.
name|varying
decl_stmt|;
comment|// Make sure transform feedback varyings aren't optimized out.
if|if
condition|(
name|uniqueVaryingNames
operator|.
name|count
argument_list|(
name|transformFeedbackVaryingName
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bool
name|found
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|transformFeedbackVaryingName
operator|==
name|varying
operator|.
name|name
condition|)
block|{
if|if
condition|(
operator|!
name|packVarying
argument_list|(
name|packedVarying
argument_list|)
condition|)
block|{
name|infoLog
operator|<<
literal|"Could not pack varying "
operator|<<
name|varying
operator|.
name|name
expr_stmt|;
return|return
literal|false
return|;
block|}
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|infoLog
operator|<<
literal|"Transform feedback varying "
operator|<<
name|transformFeedbackVaryingName
operator|<<
literal|" does not exist in the vertex shader."
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
block|}
comment|// Sort the packed register list
name|std
operator|::
name|sort
argument_list|(
name|mRegisterList
operator|.
name|begin
argument_list|()
argument_list|,
name|mRegisterList
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
comment|// Assign semantic indices
for|for
control|(
name|unsigned
name|int
name|semanticIndex
init|=
literal|0
init|;
name|semanticIndex
operator|<
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|mRegisterList
operator|.
name|size
argument_list|()
argument_list|)
condition|;
operator|++
name|semanticIndex
control|)
block|{
name|mRegisterList
index|[
name|semanticIndex
index|]
operator|.
name|semanticIndex
operator|=
name|semanticIndex
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|getRegisterCount
name|unsigned
name|int
name|VaryingPacking
operator|::
name|getRegisterCount
parameter_list|()
specifier|const
block|{
name|unsigned
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
specifier|const
name|Register
modifier|&
name|reg
range|:
name|mRegisterMap
control|)
block|{
if|if
condition|(
name|reg
operator|.
name|data
index|[
literal|0
index|]
operator|||
name|reg
operator|.
name|data
index|[
literal|1
index|]
operator|||
name|reg
operator|.
name|data
index|[
literal|2
index|]
operator|||
name|reg
operator|.
name|data
index|[
literal|3
index|]
condition|)
block|{
operator|++
name|count
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mBuiltinInfo
index|[
name|SHADER_PIXEL
index|]
operator|.
name|glFragCoord
operator|.
name|enabled
condition|)
block|{
operator|++
name|count
expr_stmt|;
block|}
if|if
condition|(
name|mBuiltinInfo
index|[
name|SHADER_PIXEL
index|]
operator|.
name|glPointCoord
operator|.
name|enabled
condition|)
block|{
operator|++
name|count
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
DECL|function|enableBuiltins
name|void
name|VaryingPacking
operator|::
name|enableBuiltins
parameter_list|(
name|ShaderType
name|shaderType
parameter_list|,
specifier|const
name|ProgramD3DMetadata
modifier|&
name|programMetadata
parameter_list|)
block|{
name|int
name|majorShaderModel
init|=
name|programMetadata
operator|.
name|getRendererMajorShaderModel
argument_list|()
decl_stmt|;
name|bool
name|position
init|=
name|programMetadata
operator|.
name|usesTransformFeedbackGLPosition
argument_list|()
decl_stmt|;
name|bool
name|fragCoord
init|=
name|programMetadata
operator|.
name|usesFragCoord
argument_list|()
decl_stmt|;
name|bool
name|pointCoord
init|=
name|shaderType
operator|==
name|SHADER_VERTEX
condition|?
name|programMetadata
operator|.
name|addsPointCoordToVertexShader
argument_list|()
else|:
name|programMetadata
operator|.
name|usesPointCoord
argument_list|()
decl_stmt|;
name|bool
name|pointSize
init|=
name|programMetadata
operator|.
name|usesSystemValuePointSize
argument_list|()
decl_stmt|;
name|bool
name|hlsl4
init|=
operator|(
name|majorShaderModel
operator|>=
literal|4
operator|)
decl_stmt|;
specifier|const
name|std
operator|::
name|string
modifier|&
name|userSemantic
init|=
name|GetVaryingSemantic
argument_list|(
name|majorShaderModel
argument_list|,
name|pointSize
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|reservedSemanticIndex
init|=
name|getMaxSemanticIndex
argument_list|()
decl_stmt|;
name|BuiltinInfo
modifier|*
name|builtins
init|=
operator|&
name|mBuiltinInfo
index|[
name|shaderType
index|]
decl_stmt|;
if|if
condition|(
name|hlsl4
condition|)
block|{
name|builtins
operator|->
name|dxPosition
operator|.
name|enableSystem
argument_list|(
literal|"SV_Position"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shaderType
operator|==
name|SHADER_PIXEL
condition|)
block|{
name|builtins
operator|->
name|dxPosition
operator|.
name|enableSystem
argument_list|(
literal|"VPOS"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|builtins
operator|->
name|dxPosition
operator|.
name|enableSystem
argument_list|(
literal|"POSITION"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|position
condition|)
block|{
name|builtins
operator|->
name|glPosition
operator|.
name|enable
argument_list|(
name|userSemantic
argument_list|,
name|reservedSemanticIndex
operator|++
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fragCoord
condition|)
block|{
name|builtins
operator|->
name|glFragCoord
operator|.
name|enable
argument_list|(
name|userSemantic
argument_list|,
name|reservedSemanticIndex
operator|++
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pointCoord
condition|)
block|{
comment|// SM3 reserves the TEXCOORD semantic for point sprite texcoords (gl_PointCoord)
comment|// In D3D11 we manually compute gl_PointCoord in the GS.
if|if
condition|(
name|hlsl4
condition|)
block|{
name|builtins
operator|->
name|glPointCoord
operator|.
name|enable
argument_list|(
name|userSemantic
argument_list|,
name|reservedSemanticIndex
operator|++
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|builtins
operator|->
name|glPointCoord
operator|.
name|enable
argument_list|(
literal|"TEXCOORD"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Special case: do not include PSIZE semantic in HLSL 3 pixel shaders
if|if
condition|(
name|pointSize
operator|&&
operator|(
name|shaderType
operator|!=
name|SHADER_PIXEL
operator|||
name|hlsl4
operator|)
condition|)
block|{
name|builtins
operator|->
name|glPointSize
operator|.
name|enableSystem
argument_list|(
literal|"PSIZE"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_namespace
begin_comment
comment|// namespace rx
end_comment
end_unit
