begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright 2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// TextureD3D.cpp: Implementations of the Texture interfaces shared betweeen the D3D backends.
end_comment
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/TextureD3D.h"
end_include
begin_include
include|#
directive|include
file|"common/mathutil.h"
end_include
begin_include
include|#
directive|include
file|"common/utilities.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Buffer.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Config.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Framebuffer.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Image.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Surface.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Texture.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/formatutils.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/BufferImpl.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/BufferD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/EGLImageD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/ImageD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/RendererD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/RenderTargetD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/SurfaceD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/TextureStorage.h"
end_include
begin_namespace
DECL|namespace|rx
namespace|namespace
name|rx
block|{
namespace|namespace
block|{
DECL|function|GetUnpackPointer
name|gl
operator|::
name|Error
name|GetUnpackPointer
parameter_list|(
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|pixels
parameter_list|,
name|ptrdiff_t
name|layerOffset
parameter_list|,
specifier|const
name|uint8_t
modifier|*
modifier|*
name|pointerOut
parameter_list|)
block|{
if|if
condition|(
name|unpack
operator|.
name|pixelBuffer
operator|.
name|id
argument_list|()
operator|!=
literal|0
condition|)
block|{
comment|// Do a CPU readback here, if we have an unpack buffer bound and the fast GPU path is not supported
name|gl
operator|::
name|Buffer
modifier|*
name|pixelBuffer
init|=
name|unpack
operator|.
name|pixelBuffer
operator|.
name|get
argument_list|()
decl_stmt|;
name|ptrdiff_t
name|offset
init|=
cast|reinterpret_cast
argument_list|<
name|ptrdiff_t
argument_list|>
argument_list|(
name|pixels
argument_list|)
decl_stmt|;
comment|// TODO: this is the only place outside of renderer that asks for a buffers raw data.
comment|// This functionality should be moved into renderer and the getData method of BufferImpl removed.
name|BufferD3D
modifier|*
name|bufferD3D
init|=
name|GetImplAs
argument_list|<
name|BufferD3D
argument_list|>
argument_list|(
name|pixelBuffer
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|bufferD3D
argument_list|)
expr_stmt|;
specifier|const
name|uint8_t
modifier|*
name|bufferData
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|bufferD3D
operator|->
name|getData
argument_list|(
operator|&
name|bufferData
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
operator|*
name|pointerOut
operator|=
name|bufferData
operator|+
name|offset
expr_stmt|;
block|}
else|else
block|{
operator|*
name|pointerOut
operator|=
name|pixels
expr_stmt|;
block|}
comment|// Offset the pointer for 2D array layer (if it's valid)
if|if
condition|(
operator|*
name|pointerOut
operator|!=
literal|nullptr
condition|)
block|{
operator|*
name|pointerOut
operator|+=
name|layerOffset
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|IsRenderTargetUsage
name|bool
name|IsRenderTargetUsage
parameter_list|(
name|GLenum
name|usage
parameter_list|)
block|{
return|return
operator|(
name|usage
operator|==
name|GL_FRAMEBUFFER_ATTACHMENT_ANGLE
operator|)
return|;
block|}
block|}
DECL|function|TextureD3D
name|TextureD3D
operator|::
name|TextureD3D
parameter_list|(
name|RendererD3D
modifier|*
name|renderer
parameter_list|)
member_init_list|:
name|mRenderer
argument_list|(
name|renderer
argument_list|)
member_init_list|,
name|mUsage
argument_list|(
name|GL_NONE
argument_list|)
member_init_list|,
name|mDirtyImages
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|mImmutable
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mTexStorage
argument_list|(
name|NULL
argument_list|)
block|{ }
DECL|function|~TextureD3D
name|TextureD3D
operator|::
name|~
name|TextureD3D
parameter_list|()
block|{ }
DECL|function|getNativeTexture
name|gl
operator|::
name|Error
name|TextureD3D
operator|::
name|getNativeTexture
parameter_list|(
name|TextureStorage
modifier|*
modifier|*
name|outStorage
parameter_list|)
block|{
comment|// ensure the underlying texture is created
name|gl
operator|::
name|Error
name|error
init|=
name|initializeStorage
argument_list|(
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
name|mTexStorage
condition|)
block|{
name|error
operator|=
name|updateStorage
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
name|ASSERT
argument_list|(
name|outStorage
argument_list|)
expr_stmt|;
operator|*
name|outStorage
operator|=
name|mTexStorage
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|getBaseLevelWidth
name|GLint
name|TextureD3D
operator|::
name|getBaseLevelWidth
parameter_list|()
specifier|const
block|{
specifier|const
name|ImageD3D
modifier|*
name|baseImage
init|=
name|getBaseLevelImage
argument_list|()
decl_stmt|;
return|return
operator|(
name|baseImage
condition|?
name|baseImage
operator|->
name|getWidth
argument_list|()
else|:
literal|0
operator|)
return|;
block|}
DECL|function|getBaseLevelHeight
name|GLint
name|TextureD3D
operator|::
name|getBaseLevelHeight
parameter_list|()
specifier|const
block|{
specifier|const
name|ImageD3D
modifier|*
name|baseImage
init|=
name|getBaseLevelImage
argument_list|()
decl_stmt|;
return|return
operator|(
name|baseImage
condition|?
name|baseImage
operator|->
name|getHeight
argument_list|()
else|:
literal|0
operator|)
return|;
block|}
DECL|function|getBaseLevelDepth
name|GLint
name|TextureD3D
operator|::
name|getBaseLevelDepth
parameter_list|()
specifier|const
block|{
specifier|const
name|ImageD3D
modifier|*
name|baseImage
init|=
name|getBaseLevelImage
argument_list|()
decl_stmt|;
return|return
operator|(
name|baseImage
condition|?
name|baseImage
operator|->
name|getDepth
argument_list|()
else|:
literal|0
operator|)
return|;
block|}
comment|// Note: "base level image" is loosely defined to be any image from the base level,
comment|// where in the base of 2D array textures and cube maps there are several. Don't use
comment|// the base level image for anything except querying texture format and size.
DECL|function|getBaseLevelInternalFormat
name|GLenum
name|TextureD3D
operator|::
name|getBaseLevelInternalFormat
parameter_list|()
specifier|const
block|{
specifier|const
name|ImageD3D
modifier|*
name|baseImage
init|=
name|getBaseLevelImage
argument_list|()
decl_stmt|;
return|return
operator|(
name|baseImage
condition|?
name|baseImage
operator|->
name|getInternalFormat
argument_list|()
else|:
name|GL_NONE
operator|)
return|;
block|}
DECL|function|shouldUseSetData
name|bool
name|TextureD3D
operator|::
name|shouldUseSetData
parameter_list|(
specifier|const
name|ImageD3D
modifier|*
name|image
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|mRenderer
operator|->
name|getWorkarounds
argument_list|()
operator|.
name|setDataFasterThanImageUpload
condition|)
block|{
return|return
literal|false
return|;
block|}
name|gl
operator|::
name|InternalFormat
name|internalFormat
init|=
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|image
operator|->
name|getInternalFormat
argument_list|()
argument_list|)
decl_stmt|;
comment|// We can only handle full updates for depth-stencil textures, so to avoid complications
comment|// disable them entirely.
if|if
condition|(
name|internalFormat
operator|.
name|depthBits
operator|>
literal|0
operator|||
name|internalFormat
operator|.
name|stencilBits
operator|>
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// TODO(jmadill): Handle compressed internal formats
return|return
operator|(
name|mTexStorage
operator|&&
operator|!
name|internalFormat
operator|.
name|compressed
operator|)
return|;
block|}
DECL|function|setImageImpl
name|gl
operator|::
name|Error
name|TextureD3D
operator|::
name|setImageImpl
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|pixels
parameter_list|,
name|ptrdiff_t
name|layerOffset
parameter_list|)
block|{
name|ImageD3D
modifier|*
name|image
init|=
name|getImage
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|image
argument_list|)
expr_stmt|;
comment|// No-op
if|if
condition|(
name|image
operator|->
name|getWidth
argument_list|()
operator|==
literal|0
operator|||
name|image
operator|->
name|getHeight
argument_list|()
operator|==
literal|0
operator|||
name|image
operator|->
name|getDepth
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
comment|// We no longer need the "GLenum format" parameter to TexImage to determine what data format "pixels" contains.
comment|// From our image internal format we know how many channels to expect, and "type" gives the format of pixel's components.
specifier|const
name|uint8_t
modifier|*
name|pixelData
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|GetUnpackPointer
argument_list|(
name|unpack
argument_list|,
name|pixels
argument_list|,
name|layerOffset
argument_list|,
operator|&
name|pixelData
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
name|pixelData
operator|!=
literal|nullptr
condition|)
block|{
if|if
condition|(
name|shouldUseSetData
argument_list|(
name|image
argument_list|)
condition|)
block|{
name|error
operator|=
name|mTexStorage
operator|->
name|setData
argument_list|(
name|index
argument_list|,
name|image
argument_list|,
name|NULL
argument_list|,
name|type
argument_list|,
name|unpack
argument_list|,
name|pixelData
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gl
operator|::
name|Box
name|fullImageArea
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|image
operator|->
name|getWidth
argument_list|()
argument_list|,
name|image
operator|->
name|getHeight
argument_list|()
argument_list|,
name|image
operator|->
name|getDepth
argument_list|()
argument_list|)
decl_stmt|;
name|error
operator|=
name|image
operator|->
name|loadData
argument_list|(
name|fullImageArea
argument_list|,
name|unpack
argument_list|,
name|type
argument_list|,
name|pixelData
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|subImage
name|gl
operator|::
name|Error
name|TextureD3D
operator|::
name|subImage
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|,
specifier|const
name|gl
operator|::
name|Box
modifier|&
name|area
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|pixels
parameter_list|,
name|ptrdiff_t
name|layerOffset
parameter_list|)
block|{
comment|// CPU readback& copy where direct GPU copy is not supported
specifier|const
name|uint8_t
modifier|*
name|pixelData
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|GetUnpackPointer
argument_list|(
name|unpack
argument_list|,
name|pixels
argument_list|,
name|layerOffset
argument_list|,
operator|&
name|pixelData
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
name|pixelData
operator|!=
name|NULL
condition|)
block|{
name|ImageD3D
modifier|*
name|image
init|=
name|getImage
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|image
argument_list|)
expr_stmt|;
if|if
condition|(
name|shouldUseSetData
argument_list|(
name|image
argument_list|)
condition|)
block|{
return|return
name|mTexStorage
operator|->
name|setData
argument_list|(
name|index
argument_list|,
name|image
argument_list|,
operator|&
name|area
argument_list|,
name|type
argument_list|,
name|unpack
argument_list|,
name|pixelData
argument_list|)
return|;
block|}
name|error
operator|=
name|image
operator|->
name|loadData
argument_list|(
name|area
argument_list|,
name|unpack
argument_list|,
name|type
argument_list|,
name|pixelData
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|commitRegion
argument_list|(
name|index
argument_list|,
name|area
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|setCompressedImageImpl
name|gl
operator|::
name|Error
name|TextureD3D
operator|::
name|setCompressedImageImpl
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|,
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|pixels
parameter_list|,
name|ptrdiff_t
name|layerOffset
parameter_list|)
block|{
comment|// We no longer need the "GLenum format" parameter to TexImage to determine what data format "pixels" contains.
comment|// From our image internal format we know how many channels to expect, and "type" gives the format of pixel's components.
specifier|const
name|uint8_t
modifier|*
name|pixelData
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|GetUnpackPointer
argument_list|(
name|unpack
argument_list|,
name|pixels
argument_list|,
name|layerOffset
argument_list|,
operator|&
name|pixelData
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
name|pixelData
operator|!=
name|NULL
condition|)
block|{
name|ImageD3D
modifier|*
name|image
init|=
name|getImage
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|gl
operator|::
name|Box
name|fullImageArea
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|image
operator|->
name|getWidth
argument_list|()
argument_list|,
name|image
operator|->
name|getHeight
argument_list|()
argument_list|,
name|image
operator|->
name|getDepth
argument_list|()
argument_list|)
decl_stmt|;
name|error
operator|=
name|image
operator|->
name|loadCompressedData
argument_list|(
name|fullImageArea
argument_list|,
name|pixelData
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|subImageCompressed
name|gl
operator|::
name|Error
name|TextureD3D
operator|::
name|subImageCompressed
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|,
specifier|const
name|gl
operator|::
name|Box
modifier|&
name|area
parameter_list|,
name|GLenum
name|format
parameter_list|,
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|pixels
parameter_list|,
name|ptrdiff_t
name|layerOffset
parameter_list|)
block|{
specifier|const
name|uint8_t
modifier|*
name|pixelData
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|GetUnpackPointer
argument_list|(
name|unpack
argument_list|,
name|pixels
argument_list|,
name|layerOffset
argument_list|,
operator|&
name|pixelData
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
name|pixelData
operator|!=
name|NULL
condition|)
block|{
name|ImageD3D
modifier|*
name|image
init|=
name|getImage
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|error
operator|=
name|image
operator|->
name|loadCompressedData
argument_list|(
name|area
argument_list|,
name|pixelData
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|isFastUnpackable
name|bool
name|TextureD3D
operator|::
name|isFastUnpackable
parameter_list|(
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
name|GLenum
name|sizedInternalFormat
parameter_list|)
block|{
return|return
name|unpack
operator|.
name|pixelBuffer
operator|.
name|id
argument_list|()
operator|!=
literal|0
operator|&&
name|mRenderer
operator|->
name|supportsFastCopyBufferToTexture
argument_list|(
name|sizedInternalFormat
argument_list|)
return|;
block|}
DECL|function|fastUnpackPixels
name|gl
operator|::
name|Error
name|TextureD3D
operator|::
name|fastUnpackPixels
parameter_list|(
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|pixels
parameter_list|,
specifier|const
name|gl
operator|::
name|Box
modifier|&
name|destArea
parameter_list|,
name|GLenum
name|sizedInternalFormat
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|RenderTargetD3D
modifier|*
name|destRenderTarget
parameter_list|)
block|{
if|if
condition|(
name|unpack
operator|.
name|skipRows
operator|!=
literal|0
operator|||
name|unpack
operator|.
name|skipPixels
operator|!=
literal|0
operator|||
name|unpack
operator|.
name|imageHeight
operator|!=
literal|0
operator|||
name|unpack
operator|.
name|skipImages
operator|!=
literal|0
condition|)
block|{
comment|// TODO(jmadill): additional unpack parameters
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"Unimplemented pixel store parameters in fastUnpackPixels"
argument_list|)
return|;
block|}
comment|// No-op
if|if
condition|(
name|destArea
operator|.
name|width
operator|<=
literal|0
operator|&&
name|destArea
operator|.
name|height
operator|<=
literal|0
operator|&&
name|destArea
operator|.
name|depth
operator|<=
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
comment|// In order to perform the fast copy through the shader, we must have the right format, and be able
comment|// to create a render target.
name|ASSERT
argument_list|(
name|mRenderer
operator|->
name|supportsFastCopyBufferToTexture
argument_list|(
name|sizedInternalFormat
argument_list|)
argument_list|)
expr_stmt|;
name|uintptr_t
name|offset
init|=
cast|reinterpret_cast
argument_list|<
name|uintptr_t
argument_list|>
argument_list|(
name|pixels
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|mRenderer
operator|->
name|fastCopyBufferToTexture
argument_list|(
name|unpack
argument_list|,
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|offset
argument_list|)
argument_list|,
name|destRenderTarget
argument_list|,
name|sizedInternalFormat
argument_list|,
name|type
argument_list|,
name|destArea
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|creationLevels
name|GLint
name|TextureD3D
operator|::
name|creationLevels
parameter_list|(
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|depth
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|(
name|gl
operator|::
name|isPow2
argument_list|(
name|width
argument_list|)
operator|&&
name|gl
operator|::
name|isPow2
argument_list|(
name|height
argument_list|)
operator|&&
name|gl
operator|::
name|isPow2
argument_list|(
name|depth
argument_list|)
operator|)
operator|||
name|mRenderer
operator|->
name|getRendererExtensions
argument_list|()
operator|.
name|textureNPOT
condition|)
block|{
comment|// Maximum number of levels
return|return
name|gl
operator|::
name|log2
argument_list|(
name|std
operator|::
name|max
argument_list|(
name|std
operator|::
name|max
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
argument_list|,
name|depth
argument_list|)
argument_list|)
operator|+
literal|1
return|;
block|}
else|else
block|{
comment|// OpenGL ES 2.0 without GL_OES_texture_npot does not permit NPOT mipmaps.
return|return
literal|1
return|;
block|}
block|}
DECL|function|mipLevels
name|int
name|TextureD3D
operator|::
name|mipLevels
parameter_list|()
specifier|const
block|{
return|return
name|gl
operator|::
name|log2
argument_list|(
name|std
operator|::
name|max
argument_list|(
name|std
operator|::
name|max
argument_list|(
name|getBaseLevelWidth
argument_list|()
argument_list|,
name|getBaseLevelHeight
argument_list|()
argument_list|)
argument_list|,
name|getBaseLevelDepth
argument_list|()
argument_list|)
argument_list|)
operator|+
literal|1
return|;
block|}
DECL|function|getStorage
name|TextureStorage
modifier|*
name|TextureD3D
operator|::
name|getStorage
parameter_list|()
block|{
name|ASSERT
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
return|return
name|mTexStorage
return|;
block|}
DECL|function|getBaseLevelImage
name|ImageD3D
modifier|*
name|TextureD3D
operator|::
name|getBaseLevelImage
parameter_list|()
specifier|const
block|{
return|return
name|getImage
argument_list|(
name|getImageIndex
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
DECL|function|generateMipmaps
name|gl
operator|::
name|Error
name|TextureD3D
operator|::
name|generateMipmaps
parameter_list|(
specifier|const
name|gl
operator|::
name|TextureState
modifier|&
name|textureState
parameter_list|)
block|{
name|GLint
name|mipCount
init|=
name|mipLevels
argument_list|()
decl_stmt|;
if|if
condition|(
name|mipCount
operator|==
literal|1
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
comment|// no-op
block|}
if|if
condition|(
name|mTexStorage
operator|&&
name|mRenderer
operator|->
name|getWorkarounds
argument_list|()
operator|.
name|zeroMaxLodWorkaround
condition|)
block|{
comment|// Switch to using the mipmapped texture.
name|TextureStorage
modifier|*
name|textureStorage
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|getNativeTexture
argument_list|(
operator|&
name|textureStorage
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|textureStorage
operator|->
name|useLevelZeroWorkaroundTexture
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
comment|// Set up proper mipmap chain in our Image array.
name|initMipmapsImages
argument_list|()
expr_stmt|;
if|if
condition|(
name|mTexStorage
operator|&&
name|mTexStorage
operator|->
name|supportsNativeMipmapFunction
argument_list|()
condition|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|updateStorage
argument_list|()
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
comment|// Generate the mipmap chain using the ad-hoc DirectX function.
name|error
operator|=
name|mRenderer
operator|->
name|generateMipmapsUsingD3D
argument_list|(
name|mTexStorage
argument_list|,
name|textureState
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
else|else
block|{
comment|// Generate the mipmap chain, one level at a time.
name|gl
operator|::
name|Error
name|error
init|=
name|generateMipmapsUsingImages
argument_list|()
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|generateMipmapsUsingImages
name|gl
operator|::
name|Error
name|TextureD3D
operator|::
name|generateMipmapsUsingImages
parameter_list|()
block|{
name|GLint
name|mipCount
init|=
name|mipLevels
argument_list|()
decl_stmt|;
comment|// We know that all layers have the same dimension, for the texture to be complete
name|GLint
name|layerCount
init|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|getLayerCount
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|// When making mipmaps with the setData workaround enabled, the texture storage has
comment|// the image data already. For non-render-target storage, we have to pull it out into
comment|// an image layer.
if|if
condition|(
name|mRenderer
operator|->
name|getWorkarounds
argument_list|()
operator|.
name|setDataFasterThanImageUpload
operator|&&
name|mTexStorage
condition|)
block|{
if|if
condition|(
operator|!
name|mTexStorage
operator|->
name|isRenderTarget
argument_list|()
condition|)
block|{
comment|// Copy from the storage mip 0 to Image mip 0
for|for
control|(
name|GLint
name|layer
init|=
literal|0
init|;
name|layer
operator|<
name|layerCount
condition|;
operator|++
name|layer
control|)
block|{
name|gl
operator|::
name|ImageIndex
name|srcIndex
init|=
name|getImageIndex
argument_list|(
literal|0
argument_list|,
name|layer
argument_list|)
decl_stmt|;
name|ImageD3D
modifier|*
name|image
init|=
name|getImage
argument_list|(
name|srcIndex
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|image
operator|->
name|copyFromTexStorage
argument_list|(
name|srcIndex
argument_list|,
name|mTexStorage
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
block|}
else|else
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|updateStorage
argument_list|()
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
block|}
comment|// TODO: Decouple this from zeroMaxLodWorkaround. This is a 9_3 restriction, unrelated to zeroMaxLodWorkaround.
comment|// The restriction is because Feature Level 9_3 can't create SRVs on individual levels of the texture.
comment|// As a result, even if the storage is a rendertarget, we can't use the GPU to generate the mipmaps without further work.
comment|// The D3D9 renderer works around this by copying each level of the texture into its own single-layer GPU texture (in Blit9::boxFilter).
comment|// Feature Level 9_3 could do something similar, or it could continue to use CPU-side mipmap generation, or something else.
name|bool
name|renderableStorage
init|=
operator|(
name|mTexStorage
operator|&&
name|mTexStorage
operator|->
name|isRenderTarget
argument_list|()
operator|&&
operator|!
operator|(
name|mRenderer
operator|->
name|getWorkarounds
argument_list|()
operator|.
name|zeroMaxLodWorkaround
operator|)
operator|)
decl_stmt|;
for|for
control|(
name|GLint
name|layer
init|=
literal|0
init|;
name|layer
operator|<
name|layerCount
condition|;
operator|++
name|layer
control|)
block|{
for|for
control|(
name|GLint
name|mip
init|=
literal|1
init|;
name|mip
operator|<
name|mipCount
condition|;
operator|++
name|mip
control|)
block|{
name|ASSERT
argument_list|(
name|getLayerCount
argument_list|(
name|mip
argument_list|)
operator|==
name|layerCount
argument_list|)
expr_stmt|;
name|gl
operator|::
name|ImageIndex
name|sourceIndex
init|=
name|getImageIndex
argument_list|(
name|mip
operator|-
literal|1
argument_list|,
name|layer
argument_list|)
decl_stmt|;
name|gl
operator|::
name|ImageIndex
name|destIndex
init|=
name|getImageIndex
argument_list|(
name|mip
argument_list|,
name|layer
argument_list|)
decl_stmt|;
if|if
condition|(
name|renderableStorage
condition|)
block|{
comment|// GPU-side mipmapping
name|gl
operator|::
name|Error
name|error
init|=
name|mTexStorage
operator|->
name|generateMipmap
argument_list|(
name|sourceIndex
argument_list|,
name|destIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
else|else
block|{
comment|// CPU-side mipmapping
name|gl
operator|::
name|Error
name|error
init|=
name|mRenderer
operator|->
name|generateMipmap
argument_list|(
name|getImage
argument_list|(
name|destIndex
argument_list|)
argument_list|,
name|getImage
argument_list|(
name|sourceIndex
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|mTexStorage
condition|)
block|{
name|updateStorage
argument_list|()
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|isBaseImageZeroSize
name|bool
name|TextureD3D
operator|::
name|isBaseImageZeroSize
parameter_list|()
specifier|const
block|{
name|ImageD3D
modifier|*
name|baseImage
init|=
name|getBaseLevelImage
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|baseImage
operator|||
name|baseImage
operator|->
name|getWidth
argument_list|()
operator|<=
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|gl
operator|::
name|IsCubeMapTextureTarget
argument_list|(
name|baseImage
operator|->
name|getTarget
argument_list|()
argument_list|)
operator|&&
name|baseImage
operator|->
name|getHeight
argument_list|()
operator|<=
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|baseImage
operator|->
name|getTarget
argument_list|()
operator|==
name|GL_TEXTURE_3D
operator|&&
name|baseImage
operator|->
name|getDepth
argument_list|()
operator|<=
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|baseImage
operator|->
name|getTarget
argument_list|()
operator|==
name|GL_TEXTURE_2D_ARRAY
operator|&&
name|getLayerCount
argument_list|(
literal|0
argument_list|)
operator|<=
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|function|ensureRenderTarget
name|gl
operator|::
name|Error
name|TextureD3D
operator|::
name|ensureRenderTarget
parameter_list|()
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|initializeStorage
argument_list|(
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
operator|!
name|isBaseImageZeroSize
argument_list|()
condition|)
block|{
name|ASSERT
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mTexStorage
operator|->
name|isRenderTarget
argument_list|()
condition|)
block|{
name|TextureStorage
modifier|*
name|newRenderTargetStorage
init|=
name|NULL
decl_stmt|;
name|error
operator|=
name|createCompleteStorage
argument_list|(
literal|true
argument_list|,
operator|&
name|newRenderTargetStorage
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|mTexStorage
operator|->
name|copyToStorage
argument_list|(
name|newRenderTargetStorage
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
name|SafeDelete
argument_list|(
name|newRenderTargetStorage
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|setCompleteTexStorage
argument_list|(
name|newRenderTargetStorage
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
name|SafeDelete
argument_list|(
name|newRenderTargetStorage
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|canCreateRenderTargetForImage
name|bool
name|TextureD3D
operator|::
name|canCreateRenderTargetForImage
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
name|ImageD3D
modifier|*
name|image
init|=
name|getImage
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|bool
name|levelsComplete
init|=
operator|(
name|isImageComplete
argument_list|(
name|index
argument_list|)
operator|&&
name|isImageComplete
argument_list|(
name|getImageIndex
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
decl_stmt|;
return|return
operator|(
name|image
operator|->
name|isRenderableFormat
argument_list|()
operator|&&
name|levelsComplete
operator|)
return|;
block|}
DECL|function|commitRegion
name|gl
operator|::
name|Error
name|TextureD3D
operator|::
name|commitRegion
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|,
specifier|const
name|gl
operator|::
name|Box
modifier|&
name|region
parameter_list|)
block|{
if|if
condition|(
name|mTexStorage
condition|)
block|{
name|ASSERT
argument_list|(
name|isValidIndex
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|ImageD3D
modifier|*
name|image
init|=
name|getImage
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|image
operator|->
name|copyToStorage
argument_list|(
name|mTexStorage
argument_list|,
name|index
argument_list|,
name|region
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|image
operator|->
name|markClean
argument_list|()
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|getAttachmentRenderTarget
name|gl
operator|::
name|Error
name|TextureD3D
operator|::
name|getAttachmentRenderTarget
parameter_list|(
specifier|const
name|gl
operator|::
name|FramebufferAttachment
operator|::
name|Target
modifier|&
name|target
parameter_list|,
name|FramebufferAttachmentRenderTarget
modifier|*
modifier|*
name|rtOut
parameter_list|)
block|{
name|RenderTargetD3D
modifier|*
name|rtD3D
init|=
literal|nullptr
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|getRenderTarget
argument_list|(
name|target
operator|.
name|textureIndex
argument_list|()
argument_list|,
operator|&
name|rtD3D
argument_list|)
decl_stmt|;
operator|*
name|rtOut
operator|=
cast|static_cast
argument_list|<
name|FramebufferAttachmentRenderTarget
operator|*
argument_list|>
argument_list|(
name|rtD3D
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
DECL|function|TextureD3D_2D
name|TextureD3D_2D
operator|::
name|TextureD3D_2D
parameter_list|(
name|RendererD3D
modifier|*
name|renderer
parameter_list|)
member_init_list|:
name|TextureD3D
argument_list|(
name|renderer
argument_list|)
block|{
name|mEGLImageTarget
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
operator|++
name|i
control|)
block|{
name|mImageArray
index|[
name|i
index|]
operator|=
name|renderer
operator|->
name|createImage
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|~TextureD3D_2D
name|TextureD3D_2D
operator|::
name|~
name|TextureD3D_2D
parameter_list|()
block|{
comment|// Delete the Images before the TextureStorage.
comment|// Images might be relying on the TextureStorage for some of their data.
comment|// If TextureStorage is deleted before the Images, then their data will be wastefully copied back from the GPU before we delete the Images.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
operator|++
name|i
control|)
block|{
operator|delete
name|mImageArray
index|[
name|i
index|]
expr_stmt|;
block|}
name|SafeDelete
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
block|}
DECL|function|getImage
name|ImageD3D
modifier|*
name|TextureD3D_2D
operator|::
name|getImage
parameter_list|(
name|int
name|level
parameter_list|,
name|int
name|layer
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|layer
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
name|mImageArray
index|[
name|level
index|]
return|;
block|}
DECL|function|getImage
name|ImageD3D
modifier|*
name|TextureD3D_2D
operator|::
name|getImage
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|index
operator|.
name|mipIndex
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|index
operator|.
name|hasLayer
argument_list|()
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|index
operator|.
name|type
operator|==
name|GL_TEXTURE_2D
argument_list|)
expr_stmt|;
return|return
name|mImageArray
index|[
name|index
operator|.
name|mipIndex
index|]
return|;
block|}
DECL|function|getLayerCount
name|GLsizei
name|TextureD3D_2D
operator|::
name|getLayerCount
parameter_list|(
name|int
name|level
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
DECL|function|getWidth
name|GLsizei
name|TextureD3D_2D
operator|::
name|getWidth
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
return|return
name|mImageArray
index|[
name|level
index|]
operator|->
name|getWidth
argument_list|()
return|;
else|else
return|return
literal|0
return|;
block|}
DECL|function|getHeight
name|GLsizei
name|TextureD3D_2D
operator|::
name|getHeight
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
return|return
name|mImageArray
index|[
name|level
index|]
operator|->
name|getHeight
argument_list|()
return|;
else|else
return|return
literal|0
return|;
block|}
DECL|function|getInternalFormat
name|GLenum
name|TextureD3D_2D
operator|::
name|getInternalFormat
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
return|return
name|mImageArray
index|[
name|level
index|]
operator|->
name|getInternalFormat
argument_list|()
return|;
else|else
return|return
name|GL_NONE
return|;
block|}
DECL|function|isDepth
name|bool
name|TextureD3D_2D
operator|::
name|isDepth
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
return|return
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|getInternalFormat
argument_list|(
name|level
argument_list|)
argument_list|)
operator|.
name|depthBits
operator|>
literal|0
return|;
block|}
DECL|function|setImage
name|gl
operator|::
name|Error
name|TextureD3D_2D
operator|::
name|setImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|imageLevel
parameter_list|,
name|GLenum
name|internalFormat
parameter_list|,
specifier|const
name|gl
operator|::
name|Extents
modifier|&
name|size
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|pixels
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|GL_TEXTURE_2D
operator|&&
name|size
operator|.
name|depth
operator|==
literal|1
argument_list|)
expr_stmt|;
name|GLenum
name|sizedInternalFormat
init|=
name|gl
operator|::
name|GetSizedInternalFormat
argument_list|(
name|internalFormat
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|bool
name|fastUnpacked
init|=
literal|false
decl_stmt|;
name|GLint
name|level
init|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|imageLevel
argument_list|)
decl_stmt|;
name|redefineImage
argument_list|(
name|level
argument_list|,
name|sizedInternalFormat
argument_list|,
name|size
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|gl
operator|::
name|ImageIndex
name|index
init|=
name|gl
operator|::
name|ImageIndex
operator|::
name|Make2D
argument_list|(
name|level
argument_list|)
decl_stmt|;
comment|// Attempt a fast gpu copy of the pixel data to the surface
if|if
condition|(
name|isFastUnpackable
argument_list|(
name|unpack
argument_list|,
name|sizedInternalFormat
argument_list|)
operator|&&
name|isLevelComplete
argument_list|(
name|level
argument_list|)
condition|)
block|{
comment|// Will try to create RT storage if it does not exist
name|RenderTargetD3D
modifier|*
name|destRenderTarget
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|getRenderTarget
argument_list|(
name|index
argument_list|,
operator|&
name|destRenderTarget
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|gl
operator|::
name|Box
name|destArea
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|getWidth
argument_list|(
name|level
argument_list|)
argument_list|,
name|getHeight
argument_list|(
name|level
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|error
operator|=
name|fastUnpackPixels
argument_list|(
name|unpack
argument_list|,
name|pixels
argument_list|,
name|destArea
argument_list|,
name|sizedInternalFormat
argument_list|,
name|type
argument_list|,
name|destRenderTarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
comment|// Ensure we don't overwrite our newly initialized data
name|mImageArray
index|[
name|level
index|]
operator|->
name|markClean
argument_list|()
expr_stmt|;
name|fastUnpacked
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fastUnpacked
condition|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|setImageImpl
argument_list|(
name|index
argument_list|,
name|type
argument_list|,
name|unpack
argument_list|,
name|pixels
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|setSubImage
name|gl
operator|::
name|Error
name|TextureD3D_2D
operator|::
name|setSubImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|imageLevel
parameter_list|,
specifier|const
name|gl
operator|::
name|Box
modifier|&
name|area
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|pixels
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|GL_TEXTURE_2D
operator|&&
name|area
operator|.
name|depth
operator|==
literal|1
operator|&&
name|area
operator|.
name|z
operator|==
literal|0
argument_list|)
expr_stmt|;
name|GLint
name|level
init|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|imageLevel
argument_list|)
decl_stmt|;
name|gl
operator|::
name|ImageIndex
name|index
init|=
name|gl
operator|::
name|ImageIndex
operator|::
name|Make2D
argument_list|(
name|level
argument_list|)
decl_stmt|;
if|if
condition|(
name|isFastUnpackable
argument_list|(
name|unpack
argument_list|,
name|getInternalFormat
argument_list|(
name|level
argument_list|)
argument_list|)
operator|&&
name|isLevelComplete
argument_list|(
name|level
argument_list|)
condition|)
block|{
name|RenderTargetD3D
modifier|*
name|renderTarget
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|getRenderTarget
argument_list|(
name|index
argument_list|,
operator|&
name|renderTarget
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
operator|!
name|mImageArray
index|[
name|level
index|]
operator|->
name|isDirty
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|fastUnpackPixels
argument_list|(
name|unpack
argument_list|,
name|pixels
argument_list|,
name|area
argument_list|,
name|getInternalFormat
argument_list|(
name|level
argument_list|)
argument_list|,
name|type
argument_list|,
name|renderTarget
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|TextureD3D
operator|::
name|subImage
argument_list|(
name|index
argument_list|,
name|area
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|unpack
argument_list|,
name|pixels
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
DECL|function|setCompressedImage
name|gl
operator|::
name|Error
name|TextureD3D_2D
operator|::
name|setCompressedImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|imageLevel
parameter_list|,
name|GLenum
name|internalFormat
parameter_list|,
specifier|const
name|gl
operator|::
name|Extents
modifier|&
name|size
parameter_list|,
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
name|size_t
name|imageSize
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|pixels
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|GL_TEXTURE_2D
operator|&&
name|size
operator|.
name|depth
operator|==
literal|1
argument_list|)
expr_stmt|;
name|GLint
name|level
init|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|imageLevel
argument_list|)
decl_stmt|;
comment|// compressed formats don't have separate sized internal formats-- we can just use the compressed format directly
name|redefineImage
argument_list|(
name|level
argument_list|,
name|internalFormat
argument_list|,
name|size
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
name|setCompressedImageImpl
argument_list|(
name|gl
operator|::
name|ImageIndex
operator|::
name|Make2D
argument_list|(
name|level
argument_list|)
argument_list|,
name|unpack
argument_list|,
name|pixels
argument_list|,
literal|0
argument_list|)
return|;
block|}
DECL|function|setCompressedSubImage
name|gl
operator|::
name|Error
name|TextureD3D_2D
operator|::
name|setCompressedSubImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|,
specifier|const
name|gl
operator|::
name|Box
modifier|&
name|area
parameter_list|,
name|GLenum
name|format
parameter_list|,
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
name|size_t
name|imageSize
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|pixels
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|GL_TEXTURE_2D
operator|&&
name|area
operator|.
name|depth
operator|==
literal|1
operator|&&
name|area
operator|.
name|z
operator|==
literal|0
argument_list|)
expr_stmt|;
name|gl
operator|::
name|ImageIndex
name|index
init|=
name|gl
operator|::
name|ImageIndex
operator|::
name|Make2D
argument_list|(
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|level
argument_list|)
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|TextureD3D
operator|::
name|subImageCompressed
argument_list|(
name|index
argument_list|,
name|area
argument_list|,
name|format
argument_list|,
name|unpack
argument_list|,
name|pixels
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
return|return
name|commitRegion
argument_list|(
name|index
argument_list|,
name|area
argument_list|)
return|;
block|}
DECL|function|copyImage
name|gl
operator|::
name|Error
name|TextureD3D_2D
operator|::
name|copyImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|imageLevel
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|sourceArea
parameter_list|,
name|GLenum
name|internalFormat
parameter_list|,
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|source
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|GL_TEXTURE_2D
argument_list|)
expr_stmt|;
name|GLint
name|level
init|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|imageLevel
argument_list|)
decl_stmt|;
name|GLenum
name|sizedInternalFormat
init|=
name|gl
operator|::
name|GetSizedInternalFormat
argument_list|(
name|internalFormat
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|)
decl_stmt|;
name|redefineImage
argument_list|(
name|level
argument_list|,
name|sizedInternalFormat
argument_list|,
name|gl
operator|::
name|Extents
argument_list|(
name|sourceArea
operator|.
name|width
argument_list|,
name|sourceArea
operator|.
name|height
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|gl
operator|::
name|ImageIndex
name|index
init|=
name|gl
operator|::
name|ImageIndex
operator|::
name|Make2D
argument_list|(
name|level
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Offset
name|destOffset
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|// If the zero max LOD workaround is active, then we can't sample from individual layers of the framebuffer in shaders,
comment|// so we should use the non-rendering copy path.
if|if
condition|(
operator|!
name|canCreateRenderTargetForImage
argument_list|(
name|index
argument_list|)
operator|||
name|mRenderer
operator|->
name|getWorkarounds
argument_list|()
operator|.
name|zeroMaxLodWorkaround
condition|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|mImageArray
index|[
name|level
index|]
operator|->
name|copyFromFramebuffer
argument_list|(
name|destOffset
argument_list|,
name|sourceArea
argument_list|,
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|ensureRenderTarget
argument_list|()
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|mImageArray
index|[
name|level
index|]
operator|->
name|markClean
argument_list|()
expr_stmt|;
if|if
condition|(
name|sourceArea
operator|.
name|width
operator|!=
literal|0
operator|&&
name|sourceArea
operator|.
name|height
operator|!=
literal|0
operator|&&
name|isValidLevel
argument_list|(
name|level
argument_list|)
condition|)
block|{
name|error
operator|=
name|mRenderer
operator|->
name|copyImage2D
argument_list|(
name|source
argument_list|,
name|sourceArea
argument_list|,
name|internalFormat
argument_list|,
name|destOffset
argument_list|,
name|mTexStorage
argument_list|,
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|copySubImage
name|gl
operator|::
name|Error
name|TextureD3D_2D
operator|::
name|copySubImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|imageLevel
parameter_list|,
specifier|const
name|gl
operator|::
name|Offset
modifier|&
name|destOffset
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|sourceArea
parameter_list|,
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|source
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|GL_TEXTURE_2D
operator|&&
name|destOffset
operator|.
name|z
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|// can only make our texture storage to a render target if level 0 is defined (with a width& height) and
comment|// the current level we're copying to is defined (with appropriate format, width& height)
name|GLint
name|level
init|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|imageLevel
argument_list|)
decl_stmt|;
name|gl
operator|::
name|ImageIndex
name|index
init|=
name|gl
operator|::
name|ImageIndex
operator|::
name|Make2D
argument_list|(
name|level
argument_list|)
decl_stmt|;
comment|// If the zero max LOD workaround is active, then we can't sample from individual layers of the framebuffer in shaders,
comment|// so we should use the non-rendering copy path.
if|if
condition|(
operator|!
name|canCreateRenderTargetForImage
argument_list|(
name|index
argument_list|)
operator|||
name|mRenderer
operator|->
name|getWorkarounds
argument_list|()
operator|.
name|zeroMaxLodWorkaround
condition|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|mImageArray
index|[
name|level
index|]
operator|->
name|copyFromFramebuffer
argument_list|(
name|destOffset
argument_list|,
name|sourceArea
argument_list|,
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|ensureRenderTarget
argument_list|()
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
name|isValidLevel
argument_list|(
name|level
argument_list|)
condition|)
block|{
name|error
operator|=
name|updateStorageLevel
argument_list|(
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|mRenderer
operator|->
name|copyImage2D
argument_list|(
name|source
argument_list|,
name|sourceArea
argument_list|,
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|getBaseLevelInternalFormat
argument_list|()
argument_list|)
operator|.
name|format
argument_list|,
name|destOffset
argument_list|,
name|mTexStorage
argument_list|,
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|setStorage
name|gl
operator|::
name|Error
name|TextureD3D_2D
operator|::
name|setStorage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|levels
parameter_list|,
name|GLenum
name|internalFormat
parameter_list|,
specifier|const
name|gl
operator|::
name|Extents
modifier|&
name|size
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|GL_TEXTURE_2D
operator|&&
name|size
operator|.
name|depth
operator|==
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|level
init|=
literal|0
init|;
name|level
operator|<
name|levels
condition|;
name|level
operator|++
control|)
block|{
name|gl
operator|::
name|Extents
name|levelSize
argument_list|(
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|size
operator|.
name|width
operator|>>
name|level
argument_list|)
argument_list|,
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|size
operator|.
name|height
operator|>>
name|level
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|redefineImage
argument_list|(
name|level
argument_list|,
name|internalFormat
argument_list|,
name|levelSize
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|size_t
name|level
init|=
name|levels
init|;
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|level
operator|++
control|)
block|{
name|redefineImage
argument_list|(
name|level
argument_list|,
name|GL_NONE
argument_list|,
name|gl
operator|::
name|Extents
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// TODO(geofflang): Verify storage creation had no errors
name|bool
name|renderTarget
init|=
name|IsRenderTargetUsage
argument_list|(
name|mUsage
argument_list|)
decl_stmt|;
name|TextureStorage
modifier|*
name|storage
init|=
name|mRenderer
operator|->
name|createTextureStorage2D
argument_list|(
name|internalFormat
argument_list|,
name|renderTarget
argument_list|,
name|size
operator|.
name|width
argument_list|,
name|size
operator|.
name|height
argument_list|,
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|levels
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|setCompleteTexStorage
argument_list|(
name|storage
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
name|SafeDelete
argument_list|(
name|storage
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|updateStorage
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|mImmutable
operator|=
literal|true
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|bindTexImage
name|void
name|TextureD3D_2D
operator|::
name|bindTexImage
parameter_list|(
name|egl
operator|::
name|Surface
modifier|*
name|surface
parameter_list|)
block|{
name|GLenum
name|internalformat
init|=
name|surface
operator|->
name|getConfig
argument_list|()
operator|->
name|renderTargetFormat
decl_stmt|;
name|gl
operator|::
name|Extents
name|size
argument_list|(
name|surface
operator|->
name|getWidth
argument_list|()
argument_list|,
name|surface
operator|->
name|getHeight
argument_list|()
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|redefineImage
argument_list|(
literal|0
argument_list|,
name|internalformat
argument_list|,
name|size
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|mTexStorage
condition|)
block|{
name|SafeDelete
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
block|}
name|SurfaceD3D
modifier|*
name|surfaceD3D
init|=
name|GetImplAs
argument_list|<
name|SurfaceD3D
argument_list|>
argument_list|(
name|surface
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|surfaceD3D
argument_list|)
expr_stmt|;
name|mTexStorage
operator|=
name|mRenderer
operator|->
name|createTextureStorage2D
argument_list|(
name|surfaceD3D
operator|->
name|getSwapChain
argument_list|()
argument_list|)
expr_stmt|;
name|mEGLImageTarget
operator|=
literal|false
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|releaseTexImage
name|void
name|TextureD3D_2D
operator|::
name|releaseTexImage
parameter_list|()
block|{
if|if
condition|(
name|mTexStorage
condition|)
block|{
name|SafeDelete
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|i
operator|++
control|)
block|{
name|redefineImage
argument_list|(
name|i
argument_list|,
name|GL_NONE
argument_list|,
name|gl
operator|::
name|Extents
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|setEGLImageTarget
name|gl
operator|::
name|Error
name|TextureD3D_2D
operator|::
name|setEGLImageTarget
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|egl
operator|::
name|Image
modifier|*
name|image
parameter_list|)
block|{
name|EGLImageD3D
modifier|*
name|eglImaged3d
init|=
name|GetImplAs
argument_list|<
name|EGLImageD3D
argument_list|>
argument_list|(
name|image
argument_list|)
decl_stmt|;
comment|// Set the properties of the base mip level from the EGL image
name|GLenum
name|internalformat
init|=
name|image
operator|->
name|getInternalFormat
argument_list|()
decl_stmt|;
name|gl
operator|::
name|Extents
name|size
argument_list|(
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|image
operator|->
name|getWidth
argument_list|()
argument_list|)
argument_list|,
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|image
operator|->
name|getHeight
argument_list|()
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|redefineImage
argument_list|(
literal|0
argument_list|,
name|internalformat
argument_list|,
name|size
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Clear all other images.
for|for
control|(
name|size_t
name|level
init|=
literal|1
init|;
name|level
operator|<
name|ArraySize
argument_list|(
name|mImageArray
argument_list|)
condition|;
name|level
operator|++
control|)
block|{
name|redefineImage
argument_list|(
name|level
argument_list|,
name|GL_NONE
argument_list|,
name|gl
operator|::
name|Extents
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|SafeDelete
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
name|mImageArray
index|[
literal|0
index|]
operator|->
name|markClean
argument_list|()
expr_stmt|;
name|mTexStorage
operator|=
name|mRenderer
operator|->
name|createTextureStorageEGLImage
argument_list|(
name|eglImaged3d
argument_list|)
expr_stmt|;
name|mEGLImageTarget
operator|=
literal|true
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|initMipmapsImages
name|void
name|TextureD3D_2D
operator|::
name|initMipmapsImages
parameter_list|()
block|{
comment|// Purge array levels 1 through q and reset them to represent the generated mipmap levels.
name|int
name|levelCount
init|=
name|mipLevels
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<
name|levelCount
condition|;
name|level
operator|++
control|)
block|{
name|gl
operator|::
name|Extents
name|levelSize
argument_list|(
name|std
operator|::
name|max
argument_list|(
name|getBaseLevelWidth
argument_list|()
operator|>>
name|level
argument_list|,
literal|1
argument_list|)
argument_list|,
name|std
operator|::
name|max
argument_list|(
name|getBaseLevelHeight
argument_list|()
operator|>>
name|level
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|redefineImage
argument_list|(
name|level
argument_list|,
name|getBaseLevelInternalFormat
argument_list|()
argument_list|,
name|levelSize
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|getRenderTarget
name|gl
operator|::
name|Error
name|TextureD3D_2D
operator|::
name|getRenderTarget
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|,
name|RenderTargetD3D
modifier|*
modifier|*
name|outRT
parameter_list|)
block|{
name|ASSERT
argument_list|(
operator|!
name|index
operator|.
name|hasLayer
argument_list|()
argument_list|)
expr_stmt|;
comment|// ensure the underlying texture is created
name|gl
operator|::
name|Error
name|error
init|=
name|ensureRenderTarget
argument_list|()
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|updateStorageLevel
argument_list|(
name|index
operator|.
name|mipIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
return|return
name|mTexStorage
operator|->
name|getRenderTarget
argument_list|(
name|index
argument_list|,
name|outRT
argument_list|)
return|;
block|}
DECL|function|isValidLevel
name|bool
name|TextureD3D_2D
operator|::
name|isValidLevel
parameter_list|(
name|int
name|level
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|mTexStorage
condition|?
operator|(
name|level
operator|>=
literal|0
operator|&&
name|level
operator|<
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
operator|)
else|:
literal|false
operator|)
return|;
block|}
DECL|function|isLevelComplete
name|bool
name|TextureD3D_2D
operator|::
name|isLevelComplete
parameter_list|(
name|int
name|level
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isImmutable
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
specifier|const
name|ImageD3D
modifier|*
name|baseImage
init|=
name|getBaseLevelImage
argument_list|()
decl_stmt|;
name|GLsizei
name|width
init|=
name|baseImage
operator|->
name|getWidth
argument_list|()
decl_stmt|;
name|GLsizei
name|height
init|=
name|baseImage
operator|->
name|getHeight
argument_list|()
decl_stmt|;
if|if
condition|(
name|width
operator|<=
literal|0
operator|||
name|height
operator|<=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// The base image level is complete if the width and height are positive
if|if
condition|(
name|level
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
name|ASSERT
argument_list|(
name|level
operator|>=
literal|1
operator|&&
name|level
operator|<=
operator|(
name|int
operator|)
name|ArraySize
argument_list|(
name|mImageArray
argument_list|)
operator|&&
name|mImageArray
index|[
name|level
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ImageD3D
modifier|*
name|image
init|=
name|mImageArray
index|[
name|level
index|]
decl_stmt|;
if|if
condition|(
name|image
operator|->
name|getInternalFormat
argument_list|()
operator|!=
name|baseImage
operator|->
name|getInternalFormat
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|image
operator|->
name|getWidth
argument_list|()
operator|!=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|width
operator|>>
name|level
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|image
operator|->
name|getHeight
argument_list|()
operator|!=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|height
operator|>>
name|level
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|isImageComplete
name|bool
name|TextureD3D_2D
operator|::
name|isImageComplete
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
return|return
name|isLevelComplete
argument_list|(
name|index
operator|.
name|mipIndex
argument_list|)
return|;
block|}
comment|// Constructs a native texture resource from the texture images
DECL|function|initializeStorage
name|gl
operator|::
name|Error
name|TextureD3D_2D
operator|::
name|initializeStorage
parameter_list|(
name|bool
name|renderTarget
parameter_list|)
block|{
comment|// Only initialize the first time this texture is used as a render target or shader resource
if|if
condition|(
name|mTexStorage
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
comment|// do not attempt to create storage for nonexistant data
if|if
condition|(
operator|!
name|isLevelComplete
argument_list|(
literal|0
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
name|bool
name|createRenderTarget
init|=
operator|(
name|renderTarget
operator|||
name|IsRenderTargetUsage
argument_list|(
name|mUsage
argument_list|)
operator|)
decl_stmt|;
name|TextureStorage
modifier|*
name|storage
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|createCompleteStorage
argument_list|(
name|createRenderTarget
argument_list|,
operator|&
name|storage
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|setCompleteTexStorage
argument_list|(
name|storage
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
name|SafeDelete
argument_list|(
name|storage
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
comment|// flush image data to the storage
name|error
operator|=
name|updateStorage
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|createCompleteStorage
name|gl
operator|::
name|Error
name|TextureD3D_2D
operator|::
name|createCompleteStorage
parameter_list|(
name|bool
name|renderTarget
parameter_list|,
name|TextureStorage
modifier|*
modifier|*
name|outTexStorage
parameter_list|)
specifier|const
block|{
name|GLsizei
name|width
init|=
name|getBaseLevelWidth
argument_list|()
decl_stmt|;
name|GLsizei
name|height
init|=
name|getBaseLevelHeight
argument_list|()
decl_stmt|;
name|GLenum
name|internalFormat
init|=
name|getBaseLevelInternalFormat
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|width
operator|>
literal|0
operator|&&
name|height
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|// use existing storage level count, when previously specified by TexStorage*D
name|GLint
name|levels
init|=
operator|(
name|mTexStorage
condition|?
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
else|:
name|creationLevels
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
literal|1
argument_list|)
operator|)
decl_stmt|;
name|bool
name|hintLevelZeroOnly
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|mRenderer
operator|->
name|getWorkarounds
argument_list|()
operator|.
name|zeroMaxLodWorkaround
condition|)
block|{
comment|// If any of the CPU images (levels>= 1) are dirty, then the textureStorage2D should use the mipped texture to begin with.
comment|// Otherwise, it should use the level-zero-only texture.
name|hintLevelZeroOnly
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<
name|levels
operator|&&
name|hintLevelZeroOnly
condition|;
name|level
operator|++
control|)
block|{
name|hintLevelZeroOnly
operator|=
operator|!
operator|(
name|mImageArray
index|[
name|level
index|]
operator|->
name|isDirty
argument_list|()
operator|&&
name|isLevelComplete
argument_list|(
name|level
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
comment|// TODO(geofflang): Determine if the texture creation succeeded
operator|*
name|outTexStorage
operator|=
name|mRenderer
operator|->
name|createTextureStorage2D
argument_list|(
name|internalFormat
argument_list|,
name|renderTarget
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|levels
argument_list|,
name|hintLevelZeroOnly
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|setCompleteTexStorage
name|gl
operator|::
name|Error
name|TextureD3D_2D
operator|::
name|setCompleteTexStorage
parameter_list|(
name|TextureStorage
modifier|*
name|newCompleteTexStorage
parameter_list|)
block|{
if|if
condition|(
name|newCompleteTexStorage
operator|&&
name|newCompleteTexStorage
operator|->
name|isManaged
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|newCompleteTexStorage
operator|->
name|getLevelCount
argument_list|()
condition|;
name|level
operator|++
control|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|mImageArray
index|[
name|level
index|]
operator|->
name|setManagedSurface2D
argument_list|(
name|newCompleteTexStorage
argument_list|,
name|level
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
block|}
name|SafeDelete
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
name|mTexStorage
operator|=
name|newCompleteTexStorage
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|updateStorage
name|gl
operator|::
name|Error
name|TextureD3D_2D
operator|::
name|updateStorage
parameter_list|()
block|{
name|ASSERT
argument_list|(
name|mTexStorage
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|GLint
name|storageLevels
init|=
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|storageLevels
condition|;
name|level
operator|++
control|)
block|{
if|if
condition|(
name|mImageArray
index|[
name|level
index|]
operator|->
name|isDirty
argument_list|()
operator|&&
name|isLevelComplete
argument_list|(
name|level
argument_list|)
condition|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|updateStorageLevel
argument_list|(
name|level
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|updateStorageLevel
name|gl
operator|::
name|Error
name|TextureD3D_2D
operator|::
name|updateStorageLevel
parameter_list|(
name|int
name|level
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|level
operator|<=
operator|(
name|int
operator|)
name|ArraySize
argument_list|(
name|mImageArray
argument_list|)
operator|&&
name|mImageArray
index|[
name|level
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|isLevelComplete
argument_list|(
name|level
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mImageArray
index|[
name|level
index|]
operator|->
name|isDirty
argument_list|()
condition|)
block|{
name|gl
operator|::
name|ImageIndex
name|index
init|=
name|gl
operator|::
name|ImageIndex
operator|::
name|Make2D
argument_list|(
name|level
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Box
name|region
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|getWidth
argument_list|(
name|level
argument_list|)
argument_list|,
name|getHeight
argument_list|(
name|level
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|commitRegion
argument_list|(
name|index
argument_list|,
name|region
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|redefineImage
name|void
name|TextureD3D_2D
operator|::
name|redefineImage
parameter_list|(
name|size_t
name|level
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
specifier|const
name|gl
operator|::
name|Extents
modifier|&
name|size
parameter_list|,
name|bool
name|forceRelease
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|size
operator|.
name|depth
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|// If there currently is a corresponding storage texture image, it has these parameters
specifier|const
name|int
name|storageWidth
init|=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|getBaseLevelWidth
argument_list|()
operator|>>
name|level
argument_list|)
decl_stmt|;
specifier|const
name|int
name|storageHeight
init|=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|getBaseLevelHeight
argument_list|()
operator|>>
name|level
argument_list|)
decl_stmt|;
specifier|const
name|GLenum
name|storageFormat
init|=
name|getBaseLevelInternalFormat
argument_list|()
decl_stmt|;
name|mImageArray
index|[
name|level
index|]
operator|->
name|redefine
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|internalformat
argument_list|,
name|size
argument_list|,
name|forceRelease
argument_list|)
expr_stmt|;
if|if
condition|(
name|mTexStorage
condition|)
block|{
specifier|const
name|size_t
name|storageLevels
init|=
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
decl_stmt|;
comment|// If the storage was from an EGL image, copy it back into local images to preserve it
comment|// while orphaning
if|if
condition|(
name|level
operator|!=
literal|0
operator|&&
name|mEGLImageTarget
condition|)
block|{
comment|// TODO(jmadill): Don't discard error.
name|mImageArray
index|[
literal|0
index|]
operator|->
name|copyFromTexStorage
argument_list|(
name|gl
operator|::
name|ImageIndex
operator|::
name|Make2D
argument_list|(
literal|0
argument_list|)
argument_list|,
name|mTexStorage
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|level
operator|>=
name|storageLevels
operator|&&
name|storageLevels
operator|!=
literal|0
operator|)
operator|||
name|size
operator|.
name|width
operator|!=
name|storageWidth
operator|||
name|size
operator|.
name|height
operator|!=
name|storageHeight
operator|||
name|internalformat
operator|!=
name|storageFormat
condition|)
comment|// Discard mismatched storage
block|{
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|i
operator|++
control|)
block|{
name|mImageArray
index|[
name|i
index|]
operator|->
name|markDirty
argument_list|()
expr_stmt|;
block|}
name|SafeDelete
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// Can't be an EGL image target after being redefined
name|mEGLImageTarget
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|imageIterator
name|gl
operator|::
name|ImageIndexIterator
name|TextureD3D_2D
operator|::
name|imageIterator
parameter_list|()
specifier|const
block|{
return|return
name|gl
operator|::
name|ImageIndexIterator
operator|::
name|Make2D
argument_list|(
literal|0
argument_list|,
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
argument_list|)
return|;
block|}
DECL|function|getImageIndex
name|gl
operator|::
name|ImageIndex
name|TextureD3D_2D
operator|::
name|getImageIndex
parameter_list|(
name|GLint
name|mip
parameter_list|,
name|GLint
comment|/*layer*/
parameter_list|)
specifier|const
block|{
comment|// "layer" does not apply to 2D Textures.
return|return
name|gl
operator|::
name|ImageIndex
operator|::
name|Make2D
argument_list|(
name|mip
argument_list|)
return|;
block|}
DECL|function|isValidIndex
name|bool
name|TextureD3D_2D
operator|::
name|isValidIndex
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|mTexStorage
operator|&&
name|index
operator|.
name|type
operator|==
name|GL_TEXTURE_2D
operator|&&
name|index
operator|.
name|mipIndex
operator|>=
literal|0
operator|&&
name|index
operator|.
name|mipIndex
operator|<
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
operator|)
return|;
block|}
DECL|function|TextureD3D_Cube
name|TextureD3D_Cube
operator|::
name|TextureD3D_Cube
parameter_list|(
name|RendererD3D
modifier|*
name|renderer
parameter_list|)
member_init_list|:
name|TextureD3D
argument_list|(
name|renderer
argument_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
operator|++
name|j
control|)
block|{
name|mImageArray
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|renderer
operator|->
name|createImage
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|function|~TextureD3D_Cube
name|TextureD3D_Cube
operator|::
name|~
name|TextureD3D_Cube
parameter_list|()
block|{
comment|// Delete the Images before the TextureStorage.
comment|// Images might be relying on the TextureStorage for some of their data.
comment|// If TextureStorage is deleted before the Images, then their data will be wastefully copied back from the GPU before we delete the Images.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
operator|++
name|j
control|)
block|{
name|SafeDelete
argument_list|(
name|mImageArray
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|SafeDelete
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
block|}
DECL|function|getImage
name|ImageD3D
modifier|*
name|TextureD3D_Cube
operator|::
name|getImage
parameter_list|(
name|int
name|level
parameter_list|,
name|int
name|layer
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|layer
operator|>=
literal|0
operator|&&
name|layer
operator|<
literal|6
argument_list|)
expr_stmt|;
return|return
name|mImageArray
index|[
name|layer
index|]
index|[
name|level
index|]
return|;
block|}
DECL|function|getImage
name|ImageD3D
modifier|*
name|TextureD3D_Cube
operator|::
name|getImage
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|index
operator|.
name|mipIndex
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|index
operator|.
name|layerIndex
operator|>=
literal|0
operator|&&
name|index
operator|.
name|layerIndex
operator|<
literal|6
argument_list|)
expr_stmt|;
return|return
name|mImageArray
index|[
name|index
operator|.
name|layerIndex
index|]
index|[
name|index
operator|.
name|mipIndex
index|]
return|;
block|}
DECL|function|getLayerCount
name|GLsizei
name|TextureD3D_Cube
operator|::
name|getLayerCount
parameter_list|(
name|int
name|level
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
argument_list|)
expr_stmt|;
return|return
literal|6
return|;
block|}
DECL|function|getInternalFormat
name|GLenum
name|TextureD3D_Cube
operator|::
name|getInternalFormat
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLint
name|layer
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
return|return
name|mImageArray
index|[
name|layer
index|]
index|[
name|level
index|]
operator|->
name|getInternalFormat
argument_list|()
return|;
else|else
return|return
name|GL_NONE
return|;
block|}
DECL|function|isDepth
name|bool
name|TextureD3D_Cube
operator|::
name|isDepth
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLint
name|layer
parameter_list|)
specifier|const
block|{
return|return
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|getInternalFormat
argument_list|(
name|level
argument_list|,
name|layer
argument_list|)
argument_list|)
operator|.
name|depthBits
operator|>
literal|0
return|;
block|}
DECL|function|setEGLImageTarget
name|gl
operator|::
name|Error
name|TextureD3D_Cube
operator|::
name|setEGLImageTarget
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|egl
operator|::
name|Image
modifier|*
name|image
parameter_list|)
block|{
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
DECL|function|setImage
name|gl
operator|::
name|Error
name|TextureD3D_Cube
operator|::
name|setImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|,
name|GLenum
name|internalFormat
parameter_list|,
specifier|const
name|gl
operator|::
name|Extents
modifier|&
name|size
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|pixels
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|size
operator|.
name|depth
operator|==
literal|1
argument_list|)
expr_stmt|;
name|GLenum
name|sizedInternalFormat
init|=
name|gl
operator|::
name|GetSizedInternalFormat
argument_list|(
name|internalFormat
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|gl
operator|::
name|ImageIndex
name|index
init|=
name|gl
operator|::
name|ImageIndex
operator|::
name|MakeCube
argument_list|(
name|target
argument_list|,
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|level
argument_list|)
argument_list|)
decl_stmt|;
name|redefineImage
argument_list|(
name|index
operator|.
name|layerIndex
argument_list|,
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|level
argument_list|)
argument_list|,
name|sizedInternalFormat
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|setImageImpl
argument_list|(
name|index
argument_list|,
name|type
argument_list|,
name|unpack
argument_list|,
name|pixels
argument_list|,
literal|0
argument_list|)
return|;
block|}
DECL|function|setSubImage
name|gl
operator|::
name|Error
name|TextureD3D_Cube
operator|::
name|setSubImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|,
specifier|const
name|gl
operator|::
name|Box
modifier|&
name|area
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|pixels
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|area
operator|.
name|depth
operator|==
literal|1
operator|&&
name|area
operator|.
name|z
operator|==
literal|0
argument_list|)
expr_stmt|;
name|gl
operator|::
name|ImageIndex
name|index
init|=
name|gl
operator|::
name|ImageIndex
operator|::
name|MakeCube
argument_list|(
name|target
argument_list|,
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|level
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|TextureD3D
operator|::
name|subImage
argument_list|(
name|index
argument_list|,
name|area
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|unpack
argument_list|,
name|pixels
argument_list|,
literal|0
argument_list|)
return|;
block|}
DECL|function|setCompressedImage
name|gl
operator|::
name|Error
name|TextureD3D_Cube
operator|::
name|setCompressedImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|,
name|GLenum
name|internalFormat
parameter_list|,
specifier|const
name|gl
operator|::
name|Extents
modifier|&
name|size
parameter_list|,
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
name|size_t
name|imageSize
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|pixels
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|size
operator|.
name|depth
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|// compressed formats don't have separate sized internal formats-- we can just use the compressed format directly
name|size_t
name|faceIndex
init|=
name|gl
operator|::
name|CubeMapTextureTargetToLayerIndex
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|redefineImage
argument_list|(
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|faceIndex
argument_list|)
argument_list|,
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|level
argument_list|)
argument_list|,
name|internalFormat
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|gl
operator|::
name|ImageIndex
name|index
init|=
name|gl
operator|::
name|ImageIndex
operator|::
name|MakeCube
argument_list|(
name|target
argument_list|,
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|level
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|setCompressedImageImpl
argument_list|(
name|index
argument_list|,
name|unpack
argument_list|,
name|pixels
argument_list|,
literal|0
argument_list|)
return|;
block|}
DECL|function|setCompressedSubImage
name|gl
operator|::
name|Error
name|TextureD3D_Cube
operator|::
name|setCompressedSubImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|,
specifier|const
name|gl
operator|::
name|Box
modifier|&
name|area
parameter_list|,
name|GLenum
name|format
parameter_list|,
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
name|size_t
name|imageSize
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|pixels
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|area
operator|.
name|depth
operator|==
literal|1
operator|&&
name|area
operator|.
name|z
operator|==
literal|0
argument_list|)
expr_stmt|;
name|gl
operator|::
name|ImageIndex
name|index
init|=
name|gl
operator|::
name|ImageIndex
operator|::
name|MakeCube
argument_list|(
name|target
argument_list|,
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|level
argument_list|)
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|TextureD3D
operator|::
name|subImageCompressed
argument_list|(
name|index
argument_list|,
name|area
argument_list|,
name|format
argument_list|,
name|unpack
argument_list|,
name|pixels
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
return|return
name|commitRegion
argument_list|(
name|index
argument_list|,
name|area
argument_list|)
return|;
block|}
DECL|function|copyImage
name|gl
operator|::
name|Error
name|TextureD3D_Cube
operator|::
name|copyImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|imageLevel
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|sourceArea
parameter_list|,
name|GLenum
name|internalFormat
parameter_list|,
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|source
parameter_list|)
block|{
name|int
name|faceIndex
init|=
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|gl
operator|::
name|CubeMapTextureTargetToLayerIndex
argument_list|(
name|target
argument_list|)
argument_list|)
decl_stmt|;
name|GLenum
name|sizedInternalFormat
init|=
name|gl
operator|::
name|GetSizedInternalFormat
argument_list|(
name|internalFormat
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|)
decl_stmt|;
name|GLint
name|level
init|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|imageLevel
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Extents
name|size
argument_list|(
name|sourceArea
operator|.
name|width
argument_list|,
name|sourceArea
operator|.
name|height
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|redefineImage
argument_list|(
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|faceIndex
argument_list|)
argument_list|,
name|level
argument_list|,
name|sizedInternalFormat
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|gl
operator|::
name|ImageIndex
name|index
init|=
name|gl
operator|::
name|ImageIndex
operator|::
name|MakeCube
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Offset
name|destOffset
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|// If the zero max LOD workaround is active, then we can't sample from individual layers of the framebuffer in shaders,
comment|// so we should use the non-rendering copy path.
if|if
condition|(
operator|!
name|canCreateRenderTargetForImage
argument_list|(
name|index
argument_list|)
operator|||
name|mRenderer
operator|->
name|getWorkarounds
argument_list|()
operator|.
name|zeroMaxLodWorkaround
condition|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|mImageArray
index|[
name|faceIndex
index|]
index|[
name|level
index|]
operator|->
name|copyFromFramebuffer
argument_list|(
name|destOffset
argument_list|,
name|sourceArea
argument_list|,
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|ensureRenderTarget
argument_list|()
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|mImageArray
index|[
name|faceIndex
index|]
index|[
name|level
index|]
operator|->
name|markClean
argument_list|()
expr_stmt|;
name|ASSERT
argument_list|(
name|size
operator|.
name|width
operator|==
name|size
operator|.
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|.
name|width
operator|>
literal|0
operator|&&
name|isValidFaceLevel
argument_list|(
name|faceIndex
argument_list|,
name|level
argument_list|)
condition|)
block|{
name|error
operator|=
name|mRenderer
operator|->
name|copyImageCube
argument_list|(
name|source
argument_list|,
name|sourceArea
argument_list|,
name|internalFormat
argument_list|,
name|destOffset
argument_list|,
name|mTexStorage
argument_list|,
name|target
argument_list|,
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|copySubImage
name|gl
operator|::
name|Error
name|TextureD3D_Cube
operator|::
name|copySubImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|imageLevel
parameter_list|,
specifier|const
name|gl
operator|::
name|Offset
modifier|&
name|destOffset
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|sourceArea
parameter_list|,
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|source
parameter_list|)
block|{
name|int
name|faceIndex
init|=
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|gl
operator|::
name|CubeMapTextureTargetToLayerIndex
argument_list|(
name|target
argument_list|)
argument_list|)
decl_stmt|;
name|GLint
name|level
init|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|imageLevel
argument_list|)
decl_stmt|;
name|gl
operator|::
name|ImageIndex
name|index
init|=
name|gl
operator|::
name|ImageIndex
operator|::
name|MakeCube
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
decl_stmt|;
comment|// If the zero max LOD workaround is active, then we can't sample from individual layers of the framebuffer in shaders,
comment|// so we should use the non-rendering copy path.
if|if
condition|(
operator|!
name|canCreateRenderTargetForImage
argument_list|(
name|index
argument_list|)
operator|||
name|mRenderer
operator|->
name|getWorkarounds
argument_list|()
operator|.
name|zeroMaxLodWorkaround
condition|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|mImageArray
index|[
name|faceIndex
index|]
index|[
name|level
index|]
operator|->
name|copyFromFramebuffer
argument_list|(
name|destOffset
argument_list|,
name|sourceArea
argument_list|,
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|ensureRenderTarget
argument_list|()
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
name|isValidFaceLevel
argument_list|(
name|faceIndex
argument_list|,
name|level
argument_list|)
condition|)
block|{
name|error
operator|=
name|updateStorageFaceLevel
argument_list|(
name|faceIndex
argument_list|,
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|mRenderer
operator|->
name|copyImageCube
argument_list|(
name|source
argument_list|,
name|sourceArea
argument_list|,
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|getBaseLevelInternalFormat
argument_list|()
argument_list|)
operator|.
name|format
argument_list|,
name|destOffset
argument_list|,
name|mTexStorage
argument_list|,
name|target
argument_list|,
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|setStorage
name|gl
operator|::
name|Error
name|TextureD3D_Cube
operator|::
name|setStorage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|levels
parameter_list|,
name|GLenum
name|internalFormat
parameter_list|,
specifier|const
name|gl
operator|::
name|Extents
modifier|&
name|size
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|size
operator|.
name|width
operator|==
name|size
operator|.
name|height
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|size
operator|.
name|depth
operator|==
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|level
init|=
literal|0
init|;
name|level
operator|<
name|levels
condition|;
name|level
operator|++
control|)
block|{
name|GLsizei
name|mipSize
init|=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|size
operator|.
name|width
operator|>>
name|level
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|faceIndex
init|=
literal|0
init|;
name|faceIndex
operator|<
literal|6
condition|;
name|faceIndex
operator|++
control|)
block|{
name|mImageArray
index|[
name|faceIndex
index|]
index|[
name|level
index|]
operator|->
name|redefine
argument_list|(
name|GL_TEXTURE_CUBE_MAP
argument_list|,
name|internalFormat
argument_list|,
name|gl
operator|::
name|Extents
argument_list|(
name|mipSize
argument_list|,
name|mipSize
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|size_t
name|level
init|=
name|levels
init|;
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|level
operator|++
control|)
block|{
for|for
control|(
name|int
name|faceIndex
init|=
literal|0
init|;
name|faceIndex
operator|<
literal|6
condition|;
name|faceIndex
operator|++
control|)
block|{
name|mImageArray
index|[
name|faceIndex
index|]
index|[
name|level
index|]
operator|->
name|redefine
argument_list|(
name|GL_TEXTURE_CUBE_MAP
argument_list|,
name|GL_NONE
argument_list|,
name|gl
operator|::
name|Extents
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO(geofflang): Verify storage creation had no errors
name|bool
name|renderTarget
init|=
name|IsRenderTargetUsage
argument_list|(
name|mUsage
argument_list|)
decl_stmt|;
name|TextureStorage
modifier|*
name|storage
init|=
name|mRenderer
operator|->
name|createTextureStorageCube
argument_list|(
name|internalFormat
argument_list|,
name|renderTarget
argument_list|,
name|size
operator|.
name|width
argument_list|,
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|levels
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|setCompleteTexStorage
argument_list|(
name|storage
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
name|SafeDelete
argument_list|(
name|storage
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|updateStorage
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|mImmutable
operator|=
literal|true
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
comment|// Tests for cube texture completeness. [OpenGL ES 2.0.24] section 3.7.10 page 81.
DECL|function|isCubeComplete
name|bool
name|TextureD3D_Cube
operator|::
name|isCubeComplete
parameter_list|()
specifier|const
block|{
name|int
name|baseWidth
init|=
name|getBaseLevelWidth
argument_list|()
decl_stmt|;
name|int
name|baseHeight
init|=
name|getBaseLevelHeight
argument_list|()
decl_stmt|;
name|GLenum
name|baseFormat
init|=
name|getBaseLevelInternalFormat
argument_list|()
decl_stmt|;
if|if
condition|(
name|baseWidth
operator|<=
literal|0
operator|||
name|baseWidth
operator|!=
name|baseHeight
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|faceIndex
init|=
literal|1
init|;
name|faceIndex
operator|<
literal|6
condition|;
name|faceIndex
operator|++
control|)
block|{
specifier|const
name|ImageD3D
modifier|&
name|faceBaseImage
init|=
operator|*
name|mImageArray
index|[
name|faceIndex
index|]
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|faceBaseImage
operator|.
name|getWidth
argument_list|()
operator|!=
name|baseWidth
operator|||
name|faceBaseImage
operator|.
name|getHeight
argument_list|()
operator|!=
name|baseHeight
operator|||
name|faceBaseImage
operator|.
name|getInternalFormat
argument_list|()
operator|!=
name|baseFormat
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|bindTexImage
name|void
name|TextureD3D_Cube
operator|::
name|bindTexImage
parameter_list|(
name|egl
operator|::
name|Surface
modifier|*
name|surface
parameter_list|)
block|{
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
DECL|function|releaseTexImage
name|void
name|TextureD3D_Cube
operator|::
name|releaseTexImage
parameter_list|()
block|{
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
DECL|function|initMipmapsImages
name|void
name|TextureD3D_Cube
operator|::
name|initMipmapsImages
parameter_list|()
block|{
comment|// Purge array levels 1 through q and reset them to represent the generated mipmap levels.
name|int
name|levelCount
init|=
name|mipLevels
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|faceIndex
init|=
literal|0
init|;
name|faceIndex
operator|<
literal|6
condition|;
name|faceIndex
operator|++
control|)
block|{
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<
name|levelCount
condition|;
name|level
operator|++
control|)
block|{
name|int
name|faceLevelSize
init|=
operator|(
name|std
operator|::
name|max
argument_list|(
name|mImageArray
index|[
name|faceIndex
index|]
index|[
literal|0
index|]
operator|->
name|getWidth
argument_list|()
operator|>>
name|level
argument_list|,
literal|1
argument_list|)
operator|)
decl_stmt|;
name|redefineImage
argument_list|(
name|faceIndex
argument_list|,
name|level
argument_list|,
name|mImageArray
index|[
name|faceIndex
index|]
index|[
literal|0
index|]
operator|->
name|getInternalFormat
argument_list|()
argument_list|,
name|gl
operator|::
name|Extents
argument_list|(
name|faceLevelSize
argument_list|,
name|faceLevelSize
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|getRenderTarget
name|gl
operator|::
name|Error
name|TextureD3D_Cube
operator|::
name|getRenderTarget
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|,
name|RenderTargetD3D
modifier|*
modifier|*
name|outRT
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|gl
operator|::
name|IsCubeMapTextureTarget
argument_list|(
name|index
operator|.
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|// ensure the underlying texture is created
name|gl
operator|::
name|Error
name|error
init|=
name|ensureRenderTarget
argument_list|()
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|updateStorageFaceLevel
argument_list|(
name|index
operator|.
name|layerIndex
argument_list|,
name|index
operator|.
name|mipIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
return|return
name|mTexStorage
operator|->
name|getRenderTarget
argument_list|(
name|index
argument_list|,
name|outRT
argument_list|)
return|;
block|}
DECL|function|initializeStorage
name|gl
operator|::
name|Error
name|TextureD3D_Cube
operator|::
name|initializeStorage
parameter_list|(
name|bool
name|renderTarget
parameter_list|)
block|{
comment|// Only initialize the first time this texture is used as a render target or shader resource
if|if
condition|(
name|mTexStorage
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
comment|// do not attempt to create storage for nonexistant data
if|if
condition|(
operator|!
name|isFaceLevelComplete
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
name|bool
name|createRenderTarget
init|=
operator|(
name|renderTarget
operator|||
name|IsRenderTargetUsage
argument_list|(
name|mUsage
argument_list|)
operator|)
decl_stmt|;
name|TextureStorage
modifier|*
name|storage
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|createCompleteStorage
argument_list|(
name|createRenderTarget
argument_list|,
operator|&
name|storage
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|setCompleteTexStorage
argument_list|(
name|storage
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
name|SafeDelete
argument_list|(
name|storage
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
comment|// flush image data to the storage
name|error
operator|=
name|updateStorage
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|createCompleteStorage
name|gl
operator|::
name|Error
name|TextureD3D_Cube
operator|::
name|createCompleteStorage
parameter_list|(
name|bool
name|renderTarget
parameter_list|,
name|TextureStorage
modifier|*
modifier|*
name|outTexStorage
parameter_list|)
specifier|const
block|{
name|GLsizei
name|size
init|=
name|getBaseLevelWidth
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|// use existing storage level count, when previously specified by TexStorage*D
name|GLint
name|levels
init|=
operator|(
name|mTexStorage
condition|?
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
else|:
name|creationLevels
argument_list|(
name|size
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
operator|)
decl_stmt|;
name|bool
name|hintLevelZeroOnly
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|mRenderer
operator|->
name|getWorkarounds
argument_list|()
operator|.
name|zeroMaxLodWorkaround
condition|)
block|{
comment|// If any of the CPU images (levels>= 1) are dirty, then the textureStorage should use the mipped texture to begin with.
comment|// Otherwise, it should use the level-zero-only texture.
name|hintLevelZeroOnly
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|int
name|faceIndex
init|=
literal|0
init|;
name|faceIndex
operator|<
literal|6
operator|&&
name|hintLevelZeroOnly
condition|;
name|faceIndex
operator|++
control|)
block|{
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<
name|levels
operator|&&
name|hintLevelZeroOnly
condition|;
name|level
operator|++
control|)
block|{
name|hintLevelZeroOnly
operator|=
operator|!
operator|(
name|mImageArray
index|[
name|faceIndex
index|]
index|[
name|level
index|]
operator|->
name|isDirty
argument_list|()
operator|&&
name|isFaceLevelComplete
argument_list|(
name|faceIndex
argument_list|,
name|level
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
block|}
comment|// TODO (geofflang): detect if storage creation succeeded
operator|*
name|outTexStorage
operator|=
name|mRenderer
operator|->
name|createTextureStorageCube
argument_list|(
name|getBaseLevelInternalFormat
argument_list|()
argument_list|,
name|renderTarget
argument_list|,
name|size
argument_list|,
name|levels
argument_list|,
name|hintLevelZeroOnly
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|setCompleteTexStorage
name|gl
operator|::
name|Error
name|TextureD3D_Cube
operator|::
name|setCompleteTexStorage
parameter_list|(
name|TextureStorage
modifier|*
name|newCompleteTexStorage
parameter_list|)
block|{
if|if
condition|(
name|newCompleteTexStorage
operator|&&
name|newCompleteTexStorage
operator|->
name|isManaged
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|faceIndex
init|=
literal|0
init|;
name|faceIndex
operator|<
literal|6
condition|;
name|faceIndex
operator|++
control|)
block|{
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|newCompleteTexStorage
operator|->
name|getLevelCount
argument_list|()
condition|;
name|level
operator|++
control|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|mImageArray
index|[
name|faceIndex
index|]
index|[
name|level
index|]
operator|->
name|setManagedSurfaceCube
argument_list|(
name|newCompleteTexStorage
argument_list|,
name|faceIndex
argument_list|,
name|level
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
block|}
block|}
name|SafeDelete
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
name|mTexStorage
operator|=
name|newCompleteTexStorage
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|updateStorage
name|gl
operator|::
name|Error
name|TextureD3D_Cube
operator|::
name|updateStorage
parameter_list|()
block|{
name|ASSERT
argument_list|(
name|mTexStorage
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|GLint
name|storageLevels
init|=
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|face
init|=
literal|0
init|;
name|face
operator|<
literal|6
condition|;
name|face
operator|++
control|)
block|{
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|storageLevels
condition|;
name|level
operator|++
control|)
block|{
if|if
condition|(
name|mImageArray
index|[
name|face
index|]
index|[
name|level
index|]
operator|->
name|isDirty
argument_list|()
operator|&&
name|isFaceLevelComplete
argument_list|(
name|face
argument_list|,
name|level
argument_list|)
condition|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|updateStorageFaceLevel
argument_list|(
name|face
argument_list|,
name|level
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|isValidFaceLevel
name|bool
name|TextureD3D_Cube
operator|::
name|isValidFaceLevel
parameter_list|(
name|int
name|faceIndex
parameter_list|,
name|int
name|level
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|mTexStorage
condition|?
operator|(
name|level
operator|>=
literal|0
operator|&&
name|level
operator|<
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
operator|)
else|:
literal|0
operator|)
return|;
block|}
DECL|function|isFaceLevelComplete
name|bool
name|TextureD3D_Cube
operator|::
name|isFaceLevelComplete
parameter_list|(
name|int
name|faceIndex
parameter_list|,
name|int
name|level
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|level
operator|>=
literal|0
operator|&&
name|faceIndex
operator|<
literal|6
operator|&&
name|level
operator|<
operator|(
name|int
operator|)
name|ArraySize
argument_list|(
name|mImageArray
index|[
name|faceIndex
index|]
argument_list|)
operator|&&
name|mImageArray
index|[
name|faceIndex
index|]
index|[
name|level
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isImmutable
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
name|int
name|baseSize
init|=
name|getBaseLevelWidth
argument_list|()
decl_stmt|;
if|if
condition|(
name|baseSize
operator|<=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// "isCubeComplete" checks for base level completeness and we must call that
comment|// to determine if any face at level 0 is complete. We omit that check here
comment|// to avoid re-checking cube-completeness for every face at level 0.
if|if
condition|(
name|level
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// Check that non-zero levels are consistent with the base level.
specifier|const
name|ImageD3D
modifier|*
name|faceLevelImage
init|=
name|mImageArray
index|[
name|faceIndex
index|]
index|[
name|level
index|]
decl_stmt|;
if|if
condition|(
name|faceLevelImage
operator|->
name|getInternalFormat
argument_list|()
operator|!=
name|getBaseLevelInternalFormat
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|faceLevelImage
operator|->
name|getWidth
argument_list|()
operator|!=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|baseSize
operator|>>
name|level
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|isImageComplete
name|bool
name|TextureD3D_Cube
operator|::
name|isImageComplete
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
return|return
name|isFaceLevelComplete
argument_list|(
name|index
operator|.
name|layerIndex
argument_list|,
name|index
operator|.
name|mipIndex
argument_list|)
return|;
block|}
DECL|function|updateStorageFaceLevel
name|gl
operator|::
name|Error
name|TextureD3D_Cube
operator|::
name|updateStorageFaceLevel
parameter_list|(
name|int
name|faceIndex
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|level
operator|>=
literal|0
operator|&&
name|faceIndex
operator|<
literal|6
operator|&&
name|level
operator|<
operator|(
name|int
operator|)
name|ArraySize
argument_list|(
name|mImageArray
index|[
name|faceIndex
index|]
argument_list|)
operator|&&
name|mImageArray
index|[
name|faceIndex
index|]
index|[
name|level
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ImageD3D
modifier|*
name|image
init|=
name|mImageArray
index|[
name|faceIndex
index|]
index|[
name|level
index|]
decl_stmt|;
if|if
condition|(
name|image
operator|->
name|isDirty
argument_list|()
condition|)
block|{
name|GLenum
name|faceTarget
init|=
name|gl
operator|::
name|LayerIndexToCubeMapTextureTarget
argument_list|(
name|faceIndex
argument_list|)
decl_stmt|;
name|gl
operator|::
name|ImageIndex
name|index
init|=
name|gl
operator|::
name|ImageIndex
operator|::
name|MakeCube
argument_list|(
name|faceTarget
argument_list|,
name|level
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Box
name|region
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|image
operator|->
name|getWidth
argument_list|()
argument_list|,
name|image
operator|->
name|getHeight
argument_list|()
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|commitRegion
argument_list|(
name|index
argument_list|,
name|region
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|redefineImage
name|void
name|TextureD3D_Cube
operator|::
name|redefineImage
parameter_list|(
name|int
name|faceIndex
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
specifier|const
name|gl
operator|::
name|Extents
modifier|&
name|size
parameter_list|)
block|{
comment|// If there currently is a corresponding storage texture image, it has these parameters
specifier|const
name|int
name|storageWidth
init|=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|getBaseLevelWidth
argument_list|()
operator|>>
name|level
argument_list|)
decl_stmt|;
specifier|const
name|int
name|storageHeight
init|=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|getBaseLevelHeight
argument_list|()
operator|>>
name|level
argument_list|)
decl_stmt|;
specifier|const
name|GLenum
name|storageFormat
init|=
name|getBaseLevelInternalFormat
argument_list|()
decl_stmt|;
name|mImageArray
index|[
name|faceIndex
index|]
index|[
name|level
index|]
operator|->
name|redefine
argument_list|(
name|GL_TEXTURE_CUBE_MAP
argument_list|,
name|internalformat
argument_list|,
name|size
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|mTexStorage
condition|)
block|{
specifier|const
name|int
name|storageLevels
init|=
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|level
operator|>=
name|storageLevels
operator|&&
name|storageLevels
operator|!=
literal|0
operator|)
operator|||
name|size
operator|.
name|width
operator|!=
name|storageWidth
operator|||
name|size
operator|.
name|height
operator|!=
name|storageHeight
operator|||
name|internalformat
operator|!=
name|storageFormat
condition|)
comment|// Discard mismatched storage
block|{
for|for
control|(
name|int
name|dirtyLevel
init|=
literal|0
init|;
name|dirtyLevel
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|dirtyLevel
operator|++
control|)
block|{
for|for
control|(
name|int
name|dirtyFace
init|=
literal|0
init|;
name|dirtyFace
operator|<
literal|6
condition|;
name|dirtyFace
operator|++
control|)
block|{
name|mImageArray
index|[
name|dirtyFace
index|]
index|[
name|dirtyLevel
index|]
operator|->
name|markDirty
argument_list|()
expr_stmt|;
block|}
block|}
name|SafeDelete
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
DECL|function|imageIterator
name|gl
operator|::
name|ImageIndexIterator
name|TextureD3D_Cube
operator|::
name|imageIterator
parameter_list|()
specifier|const
block|{
return|return
name|gl
operator|::
name|ImageIndexIterator
operator|::
name|MakeCube
argument_list|(
literal|0
argument_list|,
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
argument_list|)
return|;
block|}
DECL|function|getImageIndex
name|gl
operator|::
name|ImageIndex
name|TextureD3D_Cube
operator|::
name|getImageIndex
parameter_list|(
name|GLint
name|mip
parameter_list|,
name|GLint
name|layer
parameter_list|)
specifier|const
block|{
comment|// The "layer" of the image index corresponds to the cube face
return|return
name|gl
operator|::
name|ImageIndex
operator|::
name|MakeCube
argument_list|(
name|gl
operator|::
name|LayerIndexToCubeMapTextureTarget
argument_list|(
name|layer
argument_list|)
argument_list|,
name|mip
argument_list|)
return|;
block|}
DECL|function|isValidIndex
name|bool
name|TextureD3D_Cube
operator|::
name|isValidIndex
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|mTexStorage
operator|&&
name|gl
operator|::
name|IsCubeMapTextureTarget
argument_list|(
name|index
operator|.
name|type
argument_list|)
operator|&&
name|index
operator|.
name|mipIndex
operator|>=
literal|0
operator|&&
name|index
operator|.
name|mipIndex
operator|<
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
operator|)
return|;
block|}
DECL|function|TextureD3D_3D
name|TextureD3D_3D
operator|::
name|TextureD3D_3D
parameter_list|(
name|RendererD3D
modifier|*
name|renderer
parameter_list|)
member_init_list|:
name|TextureD3D
argument_list|(
name|renderer
argument_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
operator|++
name|i
control|)
block|{
name|mImageArray
index|[
name|i
index|]
operator|=
name|renderer
operator|->
name|createImage
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|~TextureD3D_3D
name|TextureD3D_3D
operator|::
name|~
name|TextureD3D_3D
parameter_list|()
block|{
comment|// Delete the Images before the TextureStorage.
comment|// Images might be relying on the TextureStorage for some of their data.
comment|// If TextureStorage is deleted before the Images, then their data will be wastefully copied back from the GPU before we delete the Images.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
operator|++
name|i
control|)
block|{
operator|delete
name|mImageArray
index|[
name|i
index|]
expr_stmt|;
block|}
name|SafeDelete
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
block|}
DECL|function|getImage
name|ImageD3D
modifier|*
name|TextureD3D_3D
operator|::
name|getImage
parameter_list|(
name|int
name|level
parameter_list|,
name|int
name|layer
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|layer
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
name|mImageArray
index|[
name|level
index|]
return|;
block|}
DECL|function|getImage
name|ImageD3D
modifier|*
name|TextureD3D_3D
operator|::
name|getImage
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|index
operator|.
name|mipIndex
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|index
operator|.
name|hasLayer
argument_list|()
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|index
operator|.
name|type
operator|==
name|GL_TEXTURE_3D
argument_list|)
expr_stmt|;
return|return
name|mImageArray
index|[
name|index
operator|.
name|mipIndex
index|]
return|;
block|}
DECL|function|getLayerCount
name|GLsizei
name|TextureD3D_3D
operator|::
name|getLayerCount
parameter_list|(
name|int
name|level
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
DECL|function|getWidth
name|GLsizei
name|TextureD3D_3D
operator|::
name|getWidth
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
return|return
name|mImageArray
index|[
name|level
index|]
operator|->
name|getWidth
argument_list|()
return|;
else|else
return|return
literal|0
return|;
block|}
DECL|function|getHeight
name|GLsizei
name|TextureD3D_3D
operator|::
name|getHeight
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
return|return
name|mImageArray
index|[
name|level
index|]
operator|->
name|getHeight
argument_list|()
return|;
else|else
return|return
literal|0
return|;
block|}
DECL|function|getDepth
name|GLsizei
name|TextureD3D_3D
operator|::
name|getDepth
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
return|return
name|mImageArray
index|[
name|level
index|]
operator|->
name|getDepth
argument_list|()
return|;
else|else
return|return
literal|0
return|;
block|}
DECL|function|getInternalFormat
name|GLenum
name|TextureD3D_3D
operator|::
name|getInternalFormat
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
return|return
name|mImageArray
index|[
name|level
index|]
operator|->
name|getInternalFormat
argument_list|()
return|;
else|else
return|return
name|GL_NONE
return|;
block|}
DECL|function|isDepth
name|bool
name|TextureD3D_3D
operator|::
name|isDepth
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
return|return
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|getInternalFormat
argument_list|(
name|level
argument_list|)
argument_list|)
operator|.
name|depthBits
operator|>
literal|0
return|;
block|}
DECL|function|setEGLImageTarget
name|gl
operator|::
name|Error
name|TextureD3D_3D
operator|::
name|setEGLImageTarget
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|egl
operator|::
name|Image
modifier|*
name|image
parameter_list|)
block|{
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
DECL|function|setImage
name|gl
operator|::
name|Error
name|TextureD3D_3D
operator|::
name|setImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|imageLevel
parameter_list|,
name|GLenum
name|internalFormat
parameter_list|,
specifier|const
name|gl
operator|::
name|Extents
modifier|&
name|size
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|pixels
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|GL_TEXTURE_3D
argument_list|)
expr_stmt|;
name|GLenum
name|sizedInternalFormat
init|=
name|gl
operator|::
name|GetSizedInternalFormat
argument_list|(
name|internalFormat
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|GLint
name|level
init|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|imageLevel
argument_list|)
decl_stmt|;
name|redefineImage
argument_list|(
name|level
argument_list|,
name|sizedInternalFormat
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|bool
name|fastUnpacked
init|=
literal|false
decl_stmt|;
name|gl
operator|::
name|ImageIndex
name|index
init|=
name|gl
operator|::
name|ImageIndex
operator|::
name|Make3D
argument_list|(
name|level
argument_list|)
decl_stmt|;
comment|// Attempt a fast gpu copy of the pixel data to the surface if the app bound an unpack buffer
if|if
condition|(
name|isFastUnpackable
argument_list|(
name|unpack
argument_list|,
name|sizedInternalFormat
argument_list|)
operator|&&
operator|!
name|size
operator|.
name|empty
argument_list|()
condition|)
block|{
comment|// Will try to create RT storage if it does not exist
name|RenderTargetD3D
modifier|*
name|destRenderTarget
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|getRenderTarget
argument_list|(
name|index
argument_list|,
operator|&
name|destRenderTarget
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|gl
operator|::
name|Box
name|destArea
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|getWidth
argument_list|(
name|level
argument_list|)
argument_list|,
name|getHeight
argument_list|(
name|level
argument_list|)
argument_list|,
name|getDepth
argument_list|(
name|level
argument_list|)
argument_list|)
decl_stmt|;
name|error
operator|=
name|fastUnpackPixels
argument_list|(
name|unpack
argument_list|,
name|pixels
argument_list|,
name|destArea
argument_list|,
name|sizedInternalFormat
argument_list|,
name|type
argument_list|,
name|destRenderTarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
comment|// Ensure we don't overwrite our newly initialized data
name|mImageArray
index|[
name|level
index|]
operator|->
name|markClean
argument_list|()
expr_stmt|;
name|fastUnpacked
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fastUnpacked
condition|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|setImageImpl
argument_list|(
name|index
argument_list|,
name|type
argument_list|,
name|unpack
argument_list|,
name|pixels
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|setSubImage
name|gl
operator|::
name|Error
name|TextureD3D_3D
operator|::
name|setSubImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|imageLevel
parameter_list|,
specifier|const
name|gl
operator|::
name|Box
modifier|&
name|area
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|pixels
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|GL_TEXTURE_3D
argument_list|)
expr_stmt|;
name|GLint
name|level
init|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|imageLevel
argument_list|)
decl_stmt|;
name|gl
operator|::
name|ImageIndex
name|index
init|=
name|gl
operator|::
name|ImageIndex
operator|::
name|Make3D
argument_list|(
name|level
argument_list|)
decl_stmt|;
comment|// Attempt a fast gpu copy of the pixel data to the surface if the app bound an unpack buffer
if|if
condition|(
name|isFastUnpackable
argument_list|(
name|unpack
argument_list|,
name|getInternalFormat
argument_list|(
name|level
argument_list|)
argument_list|)
condition|)
block|{
name|RenderTargetD3D
modifier|*
name|destRenderTarget
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|getRenderTarget
argument_list|(
name|index
argument_list|,
operator|&
name|destRenderTarget
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
operator|!
name|mImageArray
index|[
name|level
index|]
operator|->
name|isDirty
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|fastUnpackPixels
argument_list|(
name|unpack
argument_list|,
name|pixels
argument_list|,
name|area
argument_list|,
name|getInternalFormat
argument_list|(
name|level
argument_list|)
argument_list|,
name|type
argument_list|,
name|destRenderTarget
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|TextureD3D
operator|::
name|subImage
argument_list|(
name|index
argument_list|,
name|area
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|unpack
argument_list|,
name|pixels
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
DECL|function|setCompressedImage
name|gl
operator|::
name|Error
name|TextureD3D_3D
operator|::
name|setCompressedImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|imageLevel
parameter_list|,
name|GLenum
name|internalFormat
parameter_list|,
specifier|const
name|gl
operator|::
name|Extents
modifier|&
name|size
parameter_list|,
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
name|size_t
name|imageSize
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|pixels
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|GL_TEXTURE_3D
argument_list|)
expr_stmt|;
name|GLint
name|level
init|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|imageLevel
argument_list|)
decl_stmt|;
comment|// compressed formats don't have separate sized internal formats-- we can just use the compressed format directly
name|redefineImage
argument_list|(
name|level
argument_list|,
name|internalFormat
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|gl
operator|::
name|ImageIndex
name|index
init|=
name|gl
operator|::
name|ImageIndex
operator|::
name|Make3D
argument_list|(
name|level
argument_list|)
decl_stmt|;
return|return
name|setCompressedImageImpl
argument_list|(
name|index
argument_list|,
name|unpack
argument_list|,
name|pixels
argument_list|,
literal|0
argument_list|)
return|;
block|}
DECL|function|setCompressedSubImage
name|gl
operator|::
name|Error
name|TextureD3D_3D
operator|::
name|setCompressedSubImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|,
specifier|const
name|gl
operator|::
name|Box
modifier|&
name|area
parameter_list|,
name|GLenum
name|format
parameter_list|,
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
name|size_t
name|imageSize
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|pixels
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|GL_TEXTURE_3D
argument_list|)
expr_stmt|;
name|gl
operator|::
name|ImageIndex
name|index
init|=
name|gl
operator|::
name|ImageIndex
operator|::
name|Make3D
argument_list|(
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|level
argument_list|)
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|TextureD3D
operator|::
name|subImageCompressed
argument_list|(
name|index
argument_list|,
name|area
argument_list|,
name|format
argument_list|,
name|unpack
argument_list|,
name|pixels
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
return|return
name|commitRegion
argument_list|(
name|index
argument_list|,
name|area
argument_list|)
return|;
block|}
DECL|function|copyImage
name|gl
operator|::
name|Error
name|TextureD3D_3D
operator|::
name|copyImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|sourceArea
parameter_list|,
name|GLenum
name|internalFormat
parameter_list|,
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|source
parameter_list|)
block|{
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"Copying 3D textures is unimplemented."
argument_list|)
return|;
block|}
DECL|function|copySubImage
name|gl
operator|::
name|Error
name|TextureD3D_3D
operator|::
name|copySubImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|imageLevel
parameter_list|,
specifier|const
name|gl
operator|::
name|Offset
modifier|&
name|destOffset
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|sourceArea
parameter_list|,
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|source
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|GL_TEXTURE_3D
argument_list|)
expr_stmt|;
name|GLint
name|level
init|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|imageLevel
argument_list|)
decl_stmt|;
name|gl
operator|::
name|ImageIndex
name|index
init|=
name|gl
operator|::
name|ImageIndex
operator|::
name|Make3D
argument_list|(
name|level
argument_list|)
decl_stmt|;
if|if
condition|(
name|canCreateRenderTargetForImage
argument_list|(
name|index
argument_list|)
condition|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|mImageArray
index|[
name|level
index|]
operator|->
name|copyFromFramebuffer
argument_list|(
name|destOffset
argument_list|,
name|sourceArea
argument_list|,
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|ensureRenderTarget
argument_list|()
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
name|isValidLevel
argument_list|(
name|level
argument_list|)
condition|)
block|{
name|error
operator|=
name|updateStorageLevel
argument_list|(
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|mRenderer
operator|->
name|copyImage3D
argument_list|(
name|source
argument_list|,
name|sourceArea
argument_list|,
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|getBaseLevelInternalFormat
argument_list|()
argument_list|)
operator|.
name|format
argument_list|,
name|destOffset
argument_list|,
name|mTexStorage
argument_list|,
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|setStorage
name|gl
operator|::
name|Error
name|TextureD3D_3D
operator|::
name|setStorage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|levels
parameter_list|,
name|GLenum
name|internalFormat
parameter_list|,
specifier|const
name|gl
operator|::
name|Extents
modifier|&
name|size
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|GL_TEXTURE_3D
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|level
init|=
literal|0
init|;
name|level
operator|<
name|levels
condition|;
name|level
operator|++
control|)
block|{
name|gl
operator|::
name|Extents
name|levelSize
argument_list|(
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|size
operator|.
name|width
operator|>>
name|level
argument_list|)
argument_list|,
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|size
operator|.
name|height
operator|>>
name|level
argument_list|)
argument_list|,
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|size
operator|.
name|depth
operator|>>
name|level
argument_list|)
argument_list|)
decl_stmt|;
name|mImageArray
index|[
name|level
index|]
operator|->
name|redefine
argument_list|(
name|GL_TEXTURE_3D
argument_list|,
name|internalFormat
argument_list|,
name|levelSize
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|size_t
name|level
init|=
name|levels
init|;
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|level
operator|++
control|)
block|{
name|mImageArray
index|[
name|level
index|]
operator|->
name|redefine
argument_list|(
name|GL_TEXTURE_3D
argument_list|,
name|GL_NONE
argument_list|,
name|gl
operator|::
name|Extents
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// TODO(geofflang): Verify storage creation had no errors
name|bool
name|renderTarget
init|=
name|IsRenderTargetUsage
argument_list|(
name|mUsage
argument_list|)
decl_stmt|;
name|TextureStorage
modifier|*
name|storage
init|=
name|mRenderer
operator|->
name|createTextureStorage3D
argument_list|(
name|internalFormat
argument_list|,
name|renderTarget
argument_list|,
name|size
operator|.
name|width
argument_list|,
name|size
operator|.
name|height
argument_list|,
name|size
operator|.
name|depth
argument_list|,
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|levels
argument_list|)
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|setCompleteTexStorage
argument_list|(
name|storage
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
name|SafeDelete
argument_list|(
name|storage
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|updateStorage
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|mImmutable
operator|=
literal|true
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|bindTexImage
name|void
name|TextureD3D_3D
operator|::
name|bindTexImage
parameter_list|(
name|egl
operator|::
name|Surface
modifier|*
name|surface
parameter_list|)
block|{
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
DECL|function|releaseTexImage
name|void
name|TextureD3D_3D
operator|::
name|releaseTexImage
parameter_list|()
block|{
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
DECL|function|initMipmapsImages
name|void
name|TextureD3D_3D
operator|::
name|initMipmapsImages
parameter_list|()
block|{
comment|// Purge array levels 1 through q and reset them to represent the generated mipmap levels.
name|int
name|levelCount
init|=
name|mipLevels
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<
name|levelCount
condition|;
name|level
operator|++
control|)
block|{
name|gl
operator|::
name|Extents
name|levelSize
argument_list|(
name|std
operator|::
name|max
argument_list|(
name|getBaseLevelWidth
argument_list|()
operator|>>
name|level
argument_list|,
literal|1
argument_list|)
argument_list|,
name|std
operator|::
name|max
argument_list|(
name|getBaseLevelHeight
argument_list|()
operator|>>
name|level
argument_list|,
literal|1
argument_list|)
argument_list|,
name|std
operator|::
name|max
argument_list|(
name|getBaseLevelDepth
argument_list|()
operator|>>
name|level
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|redefineImage
argument_list|(
name|level
argument_list|,
name|getBaseLevelInternalFormat
argument_list|()
argument_list|,
name|levelSize
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|getRenderTarget
name|gl
operator|::
name|Error
name|TextureD3D_3D
operator|::
name|getRenderTarget
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|,
name|RenderTargetD3D
modifier|*
modifier|*
name|outRT
parameter_list|)
block|{
comment|// ensure the underlying texture is created
name|gl
operator|::
name|Error
name|error
init|=
name|ensureRenderTarget
argument_list|()
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
name|index
operator|.
name|hasLayer
argument_list|()
condition|)
block|{
name|error
operator|=
name|updateStorage
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
else|else
block|{
name|error
operator|=
name|updateStorageLevel
argument_list|(
name|index
operator|.
name|mipIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
return|return
name|mTexStorage
operator|->
name|getRenderTarget
argument_list|(
name|index
argument_list|,
name|outRT
argument_list|)
return|;
block|}
DECL|function|initializeStorage
name|gl
operator|::
name|Error
name|TextureD3D_3D
operator|::
name|initializeStorage
parameter_list|(
name|bool
name|renderTarget
parameter_list|)
block|{
comment|// Only initialize the first time this texture is used as a render target or shader resource
if|if
condition|(
name|mTexStorage
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
comment|// do not attempt to create storage for nonexistant data
if|if
condition|(
operator|!
name|isLevelComplete
argument_list|(
literal|0
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
name|bool
name|createRenderTarget
init|=
operator|(
name|renderTarget
operator|||
name|IsRenderTargetUsage
argument_list|(
name|mUsage
argument_list|)
operator|)
decl_stmt|;
name|TextureStorage
modifier|*
name|storage
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|createCompleteStorage
argument_list|(
name|createRenderTarget
argument_list|,
operator|&
name|storage
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|setCompleteTexStorage
argument_list|(
name|storage
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
name|SafeDelete
argument_list|(
name|storage
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
comment|// flush image data to the storage
name|error
operator|=
name|updateStorage
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|createCompleteStorage
name|gl
operator|::
name|Error
name|TextureD3D_3D
operator|::
name|createCompleteStorage
parameter_list|(
name|bool
name|renderTarget
parameter_list|,
name|TextureStorage
modifier|*
modifier|*
name|outStorage
parameter_list|)
specifier|const
block|{
name|GLsizei
name|width
init|=
name|getBaseLevelWidth
argument_list|()
decl_stmt|;
name|GLsizei
name|height
init|=
name|getBaseLevelHeight
argument_list|()
decl_stmt|;
name|GLsizei
name|depth
init|=
name|getBaseLevelDepth
argument_list|()
decl_stmt|;
name|GLenum
name|internalFormat
init|=
name|getBaseLevelInternalFormat
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|width
operator|>
literal|0
operator|&&
name|height
operator|>
literal|0
operator|&&
name|depth
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|// use existing storage level count, when previously specified by TexStorage*D
name|GLint
name|levels
init|=
operator|(
name|mTexStorage
condition|?
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
else|:
name|creationLevels
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|)
operator|)
decl_stmt|;
comment|// TODO: Verify creation of the storage succeeded
operator|*
name|outStorage
operator|=
name|mRenderer
operator|->
name|createTextureStorage3D
argument_list|(
name|internalFormat
argument_list|,
name|renderTarget
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|,
name|levels
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|setCompleteTexStorage
name|gl
operator|::
name|Error
name|TextureD3D_3D
operator|::
name|setCompleteTexStorage
parameter_list|(
name|TextureStorage
modifier|*
name|newCompleteTexStorage
parameter_list|)
block|{
name|SafeDelete
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
name|mTexStorage
operator|=
name|newCompleteTexStorage
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
comment|// We do not support managed 3D storage, as that is D3D9/ES2-only
name|ASSERT
argument_list|(
operator|!
name|mTexStorage
operator|->
name|isManaged
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|updateStorage
name|gl
operator|::
name|Error
name|TextureD3D_3D
operator|::
name|updateStorage
parameter_list|()
block|{
name|ASSERT
argument_list|(
name|mTexStorage
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|GLint
name|storageLevels
init|=
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|storageLevels
condition|;
name|level
operator|++
control|)
block|{
if|if
condition|(
name|mImageArray
index|[
name|level
index|]
operator|->
name|isDirty
argument_list|()
operator|&&
name|isLevelComplete
argument_list|(
name|level
argument_list|)
condition|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|updateStorageLevel
argument_list|(
name|level
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|isValidLevel
name|bool
name|TextureD3D_3D
operator|::
name|isValidLevel
parameter_list|(
name|int
name|level
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|mTexStorage
condition|?
operator|(
name|level
operator|>=
literal|0
operator|&&
name|level
operator|<
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
operator|)
else|:
literal|0
operator|)
return|;
block|}
DECL|function|isLevelComplete
name|bool
name|TextureD3D_3D
operator|::
name|isLevelComplete
parameter_list|(
name|int
name|level
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|level
operator|>=
literal|0
operator|&&
name|level
operator|<
operator|(
name|int
operator|)
name|ArraySize
argument_list|(
name|mImageArray
argument_list|)
operator|&&
name|mImageArray
index|[
name|level
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isImmutable
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
name|GLsizei
name|width
init|=
name|getBaseLevelWidth
argument_list|()
decl_stmt|;
name|GLsizei
name|height
init|=
name|getBaseLevelHeight
argument_list|()
decl_stmt|;
name|GLsizei
name|depth
init|=
name|getBaseLevelDepth
argument_list|()
decl_stmt|;
if|if
condition|(
name|width
operator|<=
literal|0
operator|||
name|height
operator|<=
literal|0
operator|||
name|depth
operator|<=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|level
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
name|ImageD3D
modifier|*
name|levelImage
init|=
name|mImageArray
index|[
name|level
index|]
decl_stmt|;
if|if
condition|(
name|levelImage
operator|->
name|getInternalFormat
argument_list|()
operator|!=
name|getBaseLevelInternalFormat
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|levelImage
operator|->
name|getWidth
argument_list|()
operator|!=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|width
operator|>>
name|level
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|levelImage
operator|->
name|getHeight
argument_list|()
operator|!=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|height
operator|>>
name|level
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|levelImage
operator|->
name|getDepth
argument_list|()
operator|!=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|depth
operator|>>
name|level
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|isImageComplete
name|bool
name|TextureD3D_3D
operator|::
name|isImageComplete
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
return|return
name|isLevelComplete
argument_list|(
name|index
operator|.
name|mipIndex
argument_list|)
return|;
block|}
DECL|function|updateStorageLevel
name|gl
operator|::
name|Error
name|TextureD3D_3D
operator|::
name|updateStorageLevel
parameter_list|(
name|int
name|level
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|level
operator|>=
literal|0
operator|&&
name|level
operator|<
operator|(
name|int
operator|)
name|ArraySize
argument_list|(
name|mImageArray
argument_list|)
operator|&&
name|mImageArray
index|[
name|level
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|isLevelComplete
argument_list|(
name|level
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mImageArray
index|[
name|level
index|]
operator|->
name|isDirty
argument_list|()
condition|)
block|{
name|gl
operator|::
name|ImageIndex
name|index
init|=
name|gl
operator|::
name|ImageIndex
operator|::
name|Make3D
argument_list|(
name|level
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Box
name|region
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|getWidth
argument_list|(
name|level
argument_list|)
argument_list|,
name|getHeight
argument_list|(
name|level
argument_list|)
argument_list|,
name|getDepth
argument_list|(
name|level
argument_list|)
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|commitRegion
argument_list|(
name|index
argument_list|,
name|region
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|redefineImage
name|void
name|TextureD3D_3D
operator|::
name|redefineImage
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
specifier|const
name|gl
operator|::
name|Extents
modifier|&
name|size
parameter_list|)
block|{
comment|// If there currently is a corresponding storage texture image, it has these parameters
specifier|const
name|int
name|storageWidth
init|=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|getBaseLevelWidth
argument_list|()
operator|>>
name|level
argument_list|)
decl_stmt|;
specifier|const
name|int
name|storageHeight
init|=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|getBaseLevelHeight
argument_list|()
operator|>>
name|level
argument_list|)
decl_stmt|;
specifier|const
name|int
name|storageDepth
init|=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|getBaseLevelDepth
argument_list|()
operator|>>
name|level
argument_list|)
decl_stmt|;
specifier|const
name|GLenum
name|storageFormat
init|=
name|getBaseLevelInternalFormat
argument_list|()
decl_stmt|;
name|mImageArray
index|[
name|level
index|]
operator|->
name|redefine
argument_list|(
name|GL_TEXTURE_3D
argument_list|,
name|internalformat
argument_list|,
name|size
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|mTexStorage
condition|)
block|{
specifier|const
name|int
name|storageLevels
init|=
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|level
operator|>=
name|storageLevels
operator|&&
name|storageLevels
operator|!=
literal|0
operator|)
operator|||
name|size
operator|.
name|width
operator|!=
name|storageWidth
operator|||
name|size
operator|.
name|height
operator|!=
name|storageHeight
operator|||
name|size
operator|.
name|depth
operator|!=
name|storageDepth
operator|||
name|internalformat
operator|!=
name|storageFormat
condition|)
comment|// Discard mismatched storage
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|i
operator|++
control|)
block|{
name|mImageArray
index|[
name|i
index|]
operator|->
name|markDirty
argument_list|()
expr_stmt|;
block|}
name|SafeDelete
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
DECL|function|imageIterator
name|gl
operator|::
name|ImageIndexIterator
name|TextureD3D_3D
operator|::
name|imageIterator
parameter_list|()
specifier|const
block|{
return|return
name|gl
operator|::
name|ImageIndexIterator
operator|::
name|Make3D
argument_list|(
literal|0
argument_list|,
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
argument_list|,
name|gl
operator|::
name|ImageIndex
operator|::
name|ENTIRE_LEVEL
argument_list|,
name|gl
operator|::
name|ImageIndex
operator|::
name|ENTIRE_LEVEL
argument_list|)
return|;
block|}
DECL|function|getImageIndex
name|gl
operator|::
name|ImageIndex
name|TextureD3D_3D
operator|::
name|getImageIndex
parameter_list|(
name|GLint
name|mip
parameter_list|,
name|GLint
comment|/*layer*/
parameter_list|)
specifier|const
block|{
comment|// The "layer" here does not apply to 3D images. We use one Image per mip.
return|return
name|gl
operator|::
name|ImageIndex
operator|::
name|Make3D
argument_list|(
name|mip
argument_list|)
return|;
block|}
DECL|function|isValidIndex
name|bool
name|TextureD3D_3D
operator|::
name|isValidIndex
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|mTexStorage
operator|&&
name|index
operator|.
name|type
operator|==
name|GL_TEXTURE_3D
operator|&&
name|index
operator|.
name|mipIndex
operator|>=
literal|0
operator|&&
name|index
operator|.
name|mipIndex
operator|<
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
operator|)
return|;
block|}
DECL|function|TextureD3D_2DArray
name|TextureD3D_2DArray
operator|::
name|TextureD3D_2DArray
parameter_list|(
name|RendererD3D
modifier|*
name|renderer
parameter_list|)
member_init_list|:
name|TextureD3D
argument_list|(
name|renderer
argument_list|)
block|{
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
operator|++
name|level
control|)
block|{
name|mLayerCounts
index|[
name|level
index|]
operator|=
literal|0
expr_stmt|;
name|mImageArray
index|[
name|level
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
DECL|function|~TextureD3D_2DArray
name|TextureD3D_2DArray
operator|::
name|~
name|TextureD3D_2DArray
parameter_list|()
block|{
comment|// Delete the Images before the TextureStorage.
comment|// Images might be relying on the TextureStorage for some of their data.
comment|// If TextureStorage is deleted before the Images, then their data will be wastefully copied back from the GPU before we delete the Images.
name|deleteImages
argument_list|()
expr_stmt|;
name|SafeDelete
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
block|}
DECL|function|getImage
name|ImageD3D
modifier|*
name|TextureD3D_2DArray
operator|::
name|getImage
parameter_list|(
name|int
name|level
parameter_list|,
name|int
name|layer
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|layer
operator|==
literal|0
operator|&&
name|mLayerCounts
index|[
name|level
index|]
operator|==
literal|0
operator|)
operator|||
name|layer
operator|<
name|mLayerCounts
index|[
name|level
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|mImageArray
index|[
name|level
index|]
condition|?
name|mImageArray
index|[
name|level
index|]
index|[
name|layer
index|]
else|:
name|NULL
operator|)
return|;
block|}
DECL|function|getImage
name|ImageD3D
modifier|*
name|TextureD3D_2DArray
operator|::
name|getImage
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|index
operator|.
name|mipIndex
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|index
operator|.
name|layerIndex
operator|==
literal|0
operator|&&
name|mLayerCounts
index|[
name|index
operator|.
name|mipIndex
index|]
operator|==
literal|0
operator|)
operator|||
name|index
operator|.
name|layerIndex
operator|<
name|mLayerCounts
index|[
name|index
operator|.
name|mipIndex
index|]
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|index
operator|.
name|type
operator|==
name|GL_TEXTURE_2D_ARRAY
argument_list|)
expr_stmt|;
return|return
operator|(
name|mImageArray
index|[
name|index
operator|.
name|mipIndex
index|]
condition|?
name|mImageArray
index|[
name|index
operator|.
name|mipIndex
index|]
index|[
name|index
operator|.
name|layerIndex
index|]
else|:
name|NULL
operator|)
return|;
block|}
DECL|function|getLayerCount
name|GLsizei
name|TextureD3D_2DArray
operator|::
name|getLayerCount
parameter_list|(
name|int
name|level
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
argument_list|)
expr_stmt|;
return|return
name|mLayerCounts
index|[
name|level
index|]
return|;
block|}
DECL|function|getWidth
name|GLsizei
name|TextureD3D_2DArray
operator|::
name|getWidth
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|level
argument_list|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
operator|&&
name|mLayerCounts
index|[
name|level
index|]
argument_list|>
literal|0
operator|)
condition|?
name|mImageArray
index|[
name|level
index|]
index|[
literal|0
index|]
operator|->
name|getWidth
argument_list|()
else|:
literal|0
return|;
block|}
DECL|function|getHeight
name|GLsizei
name|TextureD3D_2DArray
operator|::
name|getHeight
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|level
argument_list|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
operator|&&
name|mLayerCounts
index|[
name|level
index|]
argument_list|>
literal|0
operator|)
condition|?
name|mImageArray
index|[
name|level
index|]
index|[
literal|0
index|]
operator|->
name|getHeight
argument_list|()
else|:
literal|0
return|;
block|}
DECL|function|getInternalFormat
name|GLenum
name|TextureD3D_2DArray
operator|::
name|getInternalFormat
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|level
argument_list|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
operator|&&
name|mLayerCounts
index|[
name|level
index|]
argument_list|>
literal|0
operator|)
condition|?
name|mImageArray
index|[
name|level
index|]
index|[
literal|0
index|]
operator|->
name|getInternalFormat
argument_list|()
else|:
name|GL_NONE
return|;
block|}
DECL|function|isDepth
name|bool
name|TextureD3D_2DArray
operator|::
name|isDepth
parameter_list|(
name|GLint
name|level
parameter_list|)
specifier|const
block|{
return|return
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|getInternalFormat
argument_list|(
name|level
argument_list|)
argument_list|)
operator|.
name|depthBits
operator|>
literal|0
return|;
block|}
DECL|function|setEGLImageTarget
name|gl
operator|::
name|Error
name|TextureD3D_2DArray
operator|::
name|setEGLImageTarget
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|egl
operator|::
name|Image
modifier|*
name|image
parameter_list|)
block|{
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
DECL|function|setImage
name|gl
operator|::
name|Error
name|TextureD3D_2DArray
operator|::
name|setImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|imageLevel
parameter_list|,
name|GLenum
name|internalFormat
parameter_list|,
specifier|const
name|gl
operator|::
name|Extents
modifier|&
name|size
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|pixels
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|GL_TEXTURE_2D_ARRAY
argument_list|)
expr_stmt|;
name|GLenum
name|sizedInternalFormat
init|=
name|gl
operator|::
name|GetSizedInternalFormat
argument_list|(
name|internalFormat
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|GLint
name|level
init|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|imageLevel
argument_list|)
decl_stmt|;
name|redefineImage
argument_list|(
name|level
argument_list|,
name|sizedInternalFormat
argument_list|,
name|size
argument_list|)
expr_stmt|;
specifier|const
name|gl
operator|::
name|InternalFormat
modifier|&
name|formatInfo
init|=
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|sizedInternalFormat
argument_list|)
decl_stmt|;
name|GLsizei
name|inputDepthPitch
init|=
name|formatInfo
operator|.
name|computeDepthPitch
argument_list|(
name|type
argument_list|,
name|size
operator|.
name|width
argument_list|,
name|size
operator|.
name|height
argument_list|,
name|unpack
operator|.
name|alignment
argument_list|,
name|unpack
operator|.
name|rowLength
argument_list|,
name|unpack
operator|.
name|imageHeight
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
operator|.
name|depth
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|ptrdiff_t
name|layerOffset
init|=
operator|(
name|inputDepthPitch
operator|*
name|i
operator|)
decl_stmt|;
name|gl
operator|::
name|ImageIndex
name|index
init|=
name|gl
operator|::
name|ImageIndex
operator|::
name|Make2DArray
argument_list|(
name|level
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|setImageImpl
argument_list|(
name|index
argument_list|,
name|type
argument_list|,
name|unpack
argument_list|,
name|pixels
argument_list|,
name|layerOffset
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|setSubImage
name|gl
operator|::
name|Error
name|TextureD3D_2DArray
operator|::
name|setSubImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|imageLevel
parameter_list|,
specifier|const
name|gl
operator|::
name|Box
modifier|&
name|area
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|pixels
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|GL_TEXTURE_2D_ARRAY
argument_list|)
expr_stmt|;
name|GLint
name|level
init|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|imageLevel
argument_list|)
decl_stmt|;
specifier|const
name|gl
operator|::
name|InternalFormat
modifier|&
name|formatInfo
init|=
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|getInternalFormat
argument_list|(
name|level
argument_list|)
argument_list|)
decl_stmt|;
name|GLsizei
name|inputDepthPitch
init|=
name|formatInfo
operator|.
name|computeDepthPitch
argument_list|(
name|type
argument_list|,
name|area
operator|.
name|width
argument_list|,
name|area
operator|.
name|height
argument_list|,
name|unpack
operator|.
name|alignment
argument_list|,
name|unpack
operator|.
name|rowLength
argument_list|,
name|unpack
operator|.
name|imageHeight
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|area
operator|.
name|depth
condition|;
name|i
operator|++
control|)
block|{
name|int
name|layer
init|=
name|area
operator|.
name|z
operator|+
name|i
decl_stmt|;
specifier|const
name|ptrdiff_t
name|layerOffset
init|=
operator|(
name|inputDepthPitch
operator|*
name|i
operator|)
decl_stmt|;
name|gl
operator|::
name|Box
name|layerArea
argument_list|(
name|area
operator|.
name|x
argument_list|,
name|area
operator|.
name|y
argument_list|,
literal|0
argument_list|,
name|area
operator|.
name|width
argument_list|,
name|area
operator|.
name|height
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gl
operator|::
name|ImageIndex
name|index
init|=
name|gl
operator|::
name|ImageIndex
operator|::
name|Make2DArray
argument_list|(
name|level
argument_list|,
name|layer
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|TextureD3D
operator|::
name|subImage
argument_list|(
name|index
argument_list|,
name|layerArea
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|unpack
argument_list|,
name|pixels
argument_list|,
name|layerOffset
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|setCompressedImage
name|gl
operator|::
name|Error
name|TextureD3D_2DArray
operator|::
name|setCompressedImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|imageLevel
parameter_list|,
name|GLenum
name|internalFormat
parameter_list|,
specifier|const
name|gl
operator|::
name|Extents
modifier|&
name|size
parameter_list|,
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
name|size_t
name|imageSize
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|pixels
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|GL_TEXTURE_2D_ARRAY
argument_list|)
expr_stmt|;
name|GLint
name|level
init|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|imageLevel
argument_list|)
decl_stmt|;
comment|// compressed formats don't have separate sized internal formats-- we can just use the compressed format directly
name|redefineImage
argument_list|(
name|level
argument_list|,
name|internalFormat
argument_list|,
name|size
argument_list|)
expr_stmt|;
specifier|const
name|gl
operator|::
name|InternalFormat
modifier|&
name|formatInfo
init|=
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|internalFormat
argument_list|)
decl_stmt|;
name|GLsizei
name|inputDepthPitch
init|=
name|formatInfo
operator|.
name|computeDepthPitch
argument_list|(
name|GL_UNSIGNED_BYTE
argument_list|,
name|size
operator|.
name|width
argument_list|,
name|size
operator|.
name|height
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
operator|.
name|depth
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|ptrdiff_t
name|layerOffset
init|=
operator|(
name|inputDepthPitch
operator|*
name|i
operator|)
decl_stmt|;
name|gl
operator|::
name|ImageIndex
name|index
init|=
name|gl
operator|::
name|ImageIndex
operator|::
name|Make2DArray
argument_list|(
name|level
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|setCompressedImageImpl
argument_list|(
name|index
argument_list|,
name|unpack
argument_list|,
name|pixels
argument_list|,
name|layerOffset
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|setCompressedSubImage
name|gl
operator|::
name|Error
name|TextureD3D_2DArray
operator|::
name|setCompressedSubImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|,
specifier|const
name|gl
operator|::
name|Box
modifier|&
name|area
parameter_list|,
name|GLenum
name|format
parameter_list|,
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
name|size_t
name|imageSize
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|pixels
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|GL_TEXTURE_2D_ARRAY
argument_list|)
expr_stmt|;
specifier|const
name|gl
operator|::
name|InternalFormat
modifier|&
name|formatInfo
init|=
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|format
argument_list|)
decl_stmt|;
name|GLsizei
name|inputDepthPitch
init|=
name|formatInfo
operator|.
name|computeDepthPitch
argument_list|(
name|GL_UNSIGNED_BYTE
argument_list|,
name|area
operator|.
name|width
argument_list|,
name|area
operator|.
name|height
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|area
operator|.
name|depth
condition|;
name|i
operator|++
control|)
block|{
name|int
name|layer
init|=
name|area
operator|.
name|z
operator|+
name|i
decl_stmt|;
specifier|const
name|ptrdiff_t
name|layerOffset
init|=
operator|(
name|inputDepthPitch
operator|*
name|i
operator|)
decl_stmt|;
name|gl
operator|::
name|Box
name|layerArea
argument_list|(
name|area
operator|.
name|x
argument_list|,
name|area
operator|.
name|y
argument_list|,
literal|0
argument_list|,
name|area
operator|.
name|width
argument_list|,
name|area
operator|.
name|height
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gl
operator|::
name|ImageIndex
name|index
init|=
name|gl
operator|::
name|ImageIndex
operator|::
name|Make2DArray
argument_list|(
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|level
argument_list|)
argument_list|,
name|layer
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|TextureD3D
operator|::
name|subImageCompressed
argument_list|(
name|index
argument_list|,
name|layerArea
argument_list|,
name|format
argument_list|,
name|unpack
argument_list|,
name|pixels
argument_list|,
name|layerOffset
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|commitRegion
argument_list|(
name|index
argument_list|,
name|layerArea
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|copyImage
name|gl
operator|::
name|Error
name|TextureD3D_2DArray
operator|::
name|copyImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|level
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|sourceArea
parameter_list|,
name|GLenum
name|internalFormat
parameter_list|,
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|source
parameter_list|)
block|{
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"Copying 2D array textures is unimplemented."
argument_list|)
return|;
block|}
DECL|function|copySubImage
name|gl
operator|::
name|Error
name|TextureD3D_2DArray
operator|::
name|copySubImage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|imageLevel
parameter_list|,
specifier|const
name|gl
operator|::
name|Offset
modifier|&
name|destOffset
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|sourceArea
parameter_list|,
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|source
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|GL_TEXTURE_2D_ARRAY
argument_list|)
expr_stmt|;
name|GLint
name|level
init|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|imageLevel
argument_list|)
decl_stmt|;
name|gl
operator|::
name|ImageIndex
name|index
init|=
name|gl
operator|::
name|ImageIndex
operator|::
name|Make2DArray
argument_list|(
name|level
argument_list|,
name|destOffset
operator|.
name|z
argument_list|)
decl_stmt|;
if|if
condition|(
name|canCreateRenderTargetForImage
argument_list|(
name|index
argument_list|)
condition|)
block|{
name|gl
operator|::
name|Offset
name|destLayerOffset
argument_list|(
name|destOffset
operator|.
name|x
argument_list|,
name|destOffset
operator|.
name|y
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|mImageArray
index|[
name|level
index|]
index|[
name|destOffset
operator|.
name|z
index|]
operator|->
name|copyFromFramebuffer
argument_list|(
name|destLayerOffset
argument_list|,
name|sourceArea
argument_list|,
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|ensureRenderTarget
argument_list|()
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
name|isValidLevel
argument_list|(
name|level
argument_list|)
condition|)
block|{
name|error
operator|=
name|updateStorageLevel
argument_list|(
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|mRenderer
operator|->
name|copyImage2DArray
argument_list|(
name|source
argument_list|,
name|sourceArea
argument_list|,
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|getInternalFormat
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|format
argument_list|,
name|destOffset
argument_list|,
name|mTexStorage
argument_list|,
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|setStorage
name|gl
operator|::
name|Error
name|TextureD3D_2DArray
operator|::
name|setStorage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|size_t
name|levels
parameter_list|,
name|GLenum
name|internalFormat
parameter_list|,
specifier|const
name|gl
operator|::
name|Extents
modifier|&
name|size
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|GL_TEXTURE_2D_ARRAY
argument_list|)
expr_stmt|;
name|deleteImages
argument_list|()
expr_stmt|;
for|for
control|(
name|size_t
name|level
init|=
literal|0
init|;
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|level
operator|++
control|)
block|{
name|gl
operator|::
name|Extents
name|levelLayerSize
argument_list|(
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|size
operator|.
name|width
operator|>>
name|level
argument_list|)
argument_list|,
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|size
operator|.
name|height
operator|>>
name|level
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|mLayerCounts
index|[
name|level
index|]
operator|=
operator|(
name|level
operator|<
name|levels
condition|?
name|size
operator|.
name|depth
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|mLayerCounts
index|[
name|level
index|]
operator|>
literal|0
condition|)
block|{
comment|// Create new images for this level
name|mImageArray
index|[
name|level
index|]
operator|=
operator|new
name|ImageD3D
operator|*
index|[
name|mLayerCounts
index|[
name|level
index|]
index|]
expr_stmt|;
for|for
control|(
name|int
name|layer
init|=
literal|0
init|;
name|layer
operator|<
name|mLayerCounts
index|[
name|level
index|]
condition|;
name|layer
operator|++
control|)
block|{
name|mImageArray
index|[
name|level
index|]
index|[
name|layer
index|]
operator|=
name|mRenderer
operator|->
name|createImage
argument_list|()
expr_stmt|;
name|mImageArray
index|[
name|level
index|]
index|[
name|layer
index|]
operator|->
name|redefine
argument_list|(
name|GL_TEXTURE_2D_ARRAY
argument_list|,
name|internalFormat
argument_list|,
name|levelLayerSize
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// TODO(geofflang): Verify storage creation had no errors
name|bool
name|renderTarget
init|=
name|IsRenderTargetUsage
argument_list|(
name|mUsage
argument_list|)
decl_stmt|;
name|TextureStorage
modifier|*
name|storage
init|=
name|mRenderer
operator|->
name|createTextureStorage2DArray
argument_list|(
name|internalFormat
argument_list|,
name|renderTarget
argument_list|,
name|size
operator|.
name|width
argument_list|,
name|size
operator|.
name|height
argument_list|,
name|size
operator|.
name|depth
argument_list|,
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|levels
argument_list|)
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|setCompleteTexStorage
argument_list|(
name|storage
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
name|SafeDelete
argument_list|(
name|storage
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|updateStorage
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|mImmutable
operator|=
literal|true
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|bindTexImage
name|void
name|TextureD3D_2DArray
operator|::
name|bindTexImage
parameter_list|(
name|egl
operator|::
name|Surface
modifier|*
name|surface
parameter_list|)
block|{
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
DECL|function|releaseTexImage
name|void
name|TextureD3D_2DArray
operator|::
name|releaseTexImage
parameter_list|()
block|{
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
DECL|function|initMipmapsImages
name|void
name|TextureD3D_2DArray
operator|::
name|initMipmapsImages
parameter_list|()
block|{
name|int
name|baseWidth
init|=
name|getBaseLevelWidth
argument_list|()
decl_stmt|;
name|int
name|baseHeight
init|=
name|getBaseLevelHeight
argument_list|()
decl_stmt|;
name|int
name|baseDepth
init|=
name|getLayerCount
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|GLenum
name|baseFormat
init|=
name|getBaseLevelInternalFormat
argument_list|()
decl_stmt|;
comment|// Purge array levels 1 through q and reset them to represent the generated mipmap levels.
name|int
name|levelCount
init|=
name|mipLevels
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<
name|levelCount
condition|;
name|level
operator|++
control|)
block|{
name|gl
operator|::
name|Extents
name|levelLayerSize
argument_list|(
name|std
operator|::
name|max
argument_list|(
name|baseWidth
operator|>>
name|level
argument_list|,
literal|1
argument_list|)
argument_list|,
name|std
operator|::
name|max
argument_list|(
name|baseHeight
operator|>>
name|level
argument_list|,
literal|1
argument_list|)
argument_list|,
name|baseDepth
argument_list|)
decl_stmt|;
name|redefineImage
argument_list|(
name|level
argument_list|,
name|baseFormat
argument_list|,
name|levelLayerSize
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|getRenderTarget
name|gl
operator|::
name|Error
name|TextureD3D_2DArray
operator|::
name|getRenderTarget
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|,
name|RenderTargetD3D
modifier|*
modifier|*
name|outRT
parameter_list|)
block|{
comment|// ensure the underlying texture is created
name|gl
operator|::
name|Error
name|error
init|=
name|ensureRenderTarget
argument_list|()
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|updateStorageLevel
argument_list|(
name|index
operator|.
name|mipIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
return|return
name|mTexStorage
operator|->
name|getRenderTarget
argument_list|(
name|index
argument_list|,
name|outRT
argument_list|)
return|;
block|}
DECL|function|initializeStorage
name|gl
operator|::
name|Error
name|TextureD3D_2DArray
operator|::
name|initializeStorage
parameter_list|(
name|bool
name|renderTarget
parameter_list|)
block|{
comment|// Only initialize the first time this texture is used as a render target or shader resource
if|if
condition|(
name|mTexStorage
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
comment|// do not attempt to create storage for nonexistant data
if|if
condition|(
operator|!
name|isLevelComplete
argument_list|(
literal|0
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
name|bool
name|createRenderTarget
init|=
operator|(
name|renderTarget
operator|||
name|IsRenderTargetUsage
argument_list|(
name|mUsage
argument_list|)
operator|)
decl_stmt|;
name|TextureStorage
modifier|*
name|storage
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|createCompleteStorage
argument_list|(
name|createRenderTarget
argument_list|,
operator|&
name|storage
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|setCompleteTexStorage
argument_list|(
name|storage
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
name|SafeDelete
argument_list|(
name|storage
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
comment|// flush image data to the storage
name|error
operator|=
name|updateStorage
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|createCompleteStorage
name|gl
operator|::
name|Error
name|TextureD3D_2DArray
operator|::
name|createCompleteStorage
parameter_list|(
name|bool
name|renderTarget
parameter_list|,
name|TextureStorage
modifier|*
modifier|*
name|outStorage
parameter_list|)
specifier|const
block|{
name|GLsizei
name|width
init|=
name|getBaseLevelWidth
argument_list|()
decl_stmt|;
name|GLsizei
name|height
init|=
name|getBaseLevelHeight
argument_list|()
decl_stmt|;
name|GLsizei
name|depth
init|=
name|getLayerCount
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|GLenum
name|internalFormat
init|=
name|getBaseLevelInternalFormat
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|width
operator|>
literal|0
operator|&&
name|height
operator|>
literal|0
operator|&&
name|depth
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|// use existing storage level count, when previously specified by TexStorage*D
name|GLint
name|levels
init|=
operator|(
name|mTexStorage
condition|?
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
else|:
name|creationLevels
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
literal|1
argument_list|)
operator|)
decl_stmt|;
comment|// TODO(geofflang): Verify storage creation succeeds
operator|*
name|outStorage
operator|=
name|mRenderer
operator|->
name|createTextureStorage2DArray
argument_list|(
name|internalFormat
argument_list|,
name|renderTarget
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|,
name|levels
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|setCompleteTexStorage
name|gl
operator|::
name|Error
name|TextureD3D_2DArray
operator|::
name|setCompleteTexStorage
parameter_list|(
name|TextureStorage
modifier|*
name|newCompleteTexStorage
parameter_list|)
block|{
name|SafeDelete
argument_list|(
name|mTexStorage
argument_list|)
expr_stmt|;
name|mTexStorage
operator|=
name|newCompleteTexStorage
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
comment|// We do not support managed 2D array storage, as managed storage is ES2/D3D9 only
name|ASSERT
argument_list|(
operator|!
name|mTexStorage
operator|->
name|isManaged
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|updateStorage
name|gl
operator|::
name|Error
name|TextureD3D_2DArray
operator|::
name|updateStorage
parameter_list|()
block|{
name|ASSERT
argument_list|(
name|mTexStorage
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|GLint
name|storageLevels
init|=
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|storageLevels
condition|;
name|level
operator|++
control|)
block|{
if|if
condition|(
name|isLevelComplete
argument_list|(
name|level
argument_list|)
condition|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|updateStorageLevel
argument_list|(
name|level
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|isValidLevel
name|bool
name|TextureD3D_2DArray
operator|::
name|isValidLevel
parameter_list|(
name|int
name|level
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|mTexStorage
condition|?
operator|(
name|level
operator|>=
literal|0
operator|&&
name|level
operator|<
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
operator|)
else|:
literal|0
operator|)
return|;
block|}
DECL|function|isLevelComplete
name|bool
name|TextureD3D_2DArray
operator|::
name|isLevelComplete
parameter_list|(
name|int
name|level
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|level
operator|>=
literal|0
operator|&&
name|level
operator|<
operator|(
name|int
operator|)
name|ArraySize
argument_list|(
name|mImageArray
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isImmutable
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
name|GLsizei
name|width
init|=
name|getBaseLevelWidth
argument_list|()
decl_stmt|;
name|GLsizei
name|height
init|=
name|getBaseLevelHeight
argument_list|()
decl_stmt|;
name|GLsizei
name|layers
init|=
name|getLayerCount
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|width
operator|<=
literal|0
operator|||
name|height
operator|<=
literal|0
operator|||
name|layers
operator|<=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|level
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|getInternalFormat
argument_list|(
name|level
argument_list|)
operator|!=
name|getInternalFormat
argument_list|(
literal|0
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|getWidth
argument_list|(
name|level
argument_list|)
operator|!=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|width
operator|>>
name|level
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|getHeight
argument_list|(
name|level
argument_list|)
operator|!=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|height
operator|>>
name|level
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|getLayerCount
argument_list|(
name|level
argument_list|)
operator|!=
name|layers
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|isImageComplete
name|bool
name|TextureD3D_2DArray
operator|::
name|isImageComplete
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
return|return
name|isLevelComplete
argument_list|(
name|index
operator|.
name|mipIndex
argument_list|)
return|;
block|}
DECL|function|updateStorageLevel
name|gl
operator|::
name|Error
name|TextureD3D_2DArray
operator|::
name|updateStorageLevel
parameter_list|(
name|int
name|level
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|level
operator|>=
literal|0
operator|&&
name|level
operator|<
operator|(
name|int
operator|)
name|ArraySize
argument_list|(
name|mLayerCounts
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|isLevelComplete
argument_list|(
name|level
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|layer
init|=
literal|0
init|;
name|layer
operator|<
name|mLayerCounts
index|[
name|level
index|]
condition|;
name|layer
operator|++
control|)
block|{
name|ASSERT
argument_list|(
name|mImageArray
index|[
name|level
index|]
operator|!=
name|NULL
operator|&&
name|mImageArray
index|[
name|level
index|]
index|[
name|layer
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mImageArray
index|[
name|level
index|]
index|[
name|layer
index|]
operator|->
name|isDirty
argument_list|()
condition|)
block|{
name|gl
operator|::
name|ImageIndex
name|index
init|=
name|gl
operator|::
name|ImageIndex
operator|::
name|Make2DArray
argument_list|(
name|level
argument_list|,
name|layer
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Box
name|region
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|getWidth
argument_list|(
name|level
argument_list|)
argument_list|,
name|getHeight
argument_list|(
name|level
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|commitRegion
argument_list|(
name|index
argument_list|,
name|region
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|deleteImages
name|void
name|TextureD3D_2DArray
operator|::
name|deleteImages
parameter_list|()
block|{
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
operator|++
name|level
control|)
block|{
for|for
control|(
name|int
name|layer
init|=
literal|0
init|;
name|layer
operator|<
name|mLayerCounts
index|[
name|level
index|]
condition|;
operator|++
name|layer
control|)
block|{
operator|delete
name|mImageArray
index|[
name|level
index|]
index|[
name|layer
index|]
expr_stmt|;
block|}
operator|delete
index|[]
name|mImageArray
index|[
name|level
index|]
expr_stmt|;
name|mImageArray
index|[
name|level
index|]
operator|=
name|NULL
expr_stmt|;
name|mLayerCounts
index|[
name|level
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
DECL|function|redefineImage
name|void
name|TextureD3D_2DArray
operator|::
name|redefineImage
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
specifier|const
name|gl
operator|::
name|Extents
modifier|&
name|size
parameter_list|)
block|{
comment|// If there currently is a corresponding storage texture image, it has these parameters
specifier|const
name|int
name|storageWidth
init|=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|getBaseLevelWidth
argument_list|()
operator|>>
name|level
argument_list|)
decl_stmt|;
specifier|const
name|int
name|storageHeight
init|=
name|std
operator|::
name|max
argument_list|(
literal|1
argument_list|,
name|getBaseLevelHeight
argument_list|()
operator|>>
name|level
argument_list|)
decl_stmt|;
specifier|const
name|int
name|storageDepth
init|=
name|getLayerCount
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|const
name|GLenum
name|storageFormat
init|=
name|getBaseLevelInternalFormat
argument_list|()
decl_stmt|;
comment|// Only reallocate the layers if the size doesn't match
if|if
condition|(
name|size
operator|.
name|depth
operator|!=
name|mLayerCounts
index|[
name|level
index|]
condition|)
block|{
for|for
control|(
name|int
name|layer
init|=
literal|0
init|;
name|layer
operator|<
name|mLayerCounts
index|[
name|level
index|]
condition|;
name|layer
operator|++
control|)
block|{
name|SafeDelete
argument_list|(
name|mImageArray
index|[
name|level
index|]
index|[
name|layer
index|]
argument_list|)
expr_stmt|;
block|}
name|SafeDeleteArray
argument_list|(
name|mImageArray
index|[
name|level
index|]
argument_list|)
expr_stmt|;
name|mLayerCounts
index|[
name|level
index|]
operator|=
name|size
operator|.
name|depth
expr_stmt|;
if|if
condition|(
name|size
operator|.
name|depth
operator|>
literal|0
condition|)
block|{
name|mImageArray
index|[
name|level
index|]
operator|=
operator|new
name|ImageD3D
operator|*
index|[
name|size
operator|.
name|depth
index|]
expr_stmt|;
for|for
control|(
name|int
name|layer
init|=
literal|0
init|;
name|layer
operator|<
name|mLayerCounts
index|[
name|level
index|]
condition|;
name|layer
operator|++
control|)
block|{
name|mImageArray
index|[
name|level
index|]
index|[
name|layer
index|]
operator|=
name|mRenderer
operator|->
name|createImage
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|size
operator|.
name|depth
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|layer
init|=
literal|0
init|;
name|layer
operator|<
name|mLayerCounts
index|[
name|level
index|]
condition|;
name|layer
operator|++
control|)
block|{
name|mImageArray
index|[
name|level
index|]
index|[
name|layer
index|]
operator|->
name|redefine
argument_list|(
name|GL_TEXTURE_2D_ARRAY
argument_list|,
name|internalformat
argument_list|,
name|gl
operator|::
name|Extents
argument_list|(
name|size
operator|.
name|width
argument_list|,
name|size
operator|.
name|height
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mTexStorage
condition|)
block|{
specifier|const
name|int
name|storageLevels
init|=
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|level
operator|>=
name|storageLevels
operator|&&
name|storageLevels
operator|!=
literal|0
operator|)
operator|||
name|size
operator|.
name|width
operator|!=
name|storageWidth
operator|||
name|size
operator|.
name|height
operator|!=
name|storageHeight
operator|||
name|size
operator|.
name|depth
operator|!=
name|storageDepth
operator|||
name|internalformat
operator|!=
name|storageFormat
condition|)
comment|// Discard mismatched storage
block|{
for|for
control|(
name|int
name|dirtyLevel
init|=
literal|0
init|;
name|dirtyLevel
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|dirtyLevel
operator|++
control|)
block|{
for|for
control|(
name|int
name|dirtyLayer
init|=
literal|0
init|;
name|dirtyLayer
operator|<
name|mLayerCounts
index|[
name|dirtyLevel
index|]
condition|;
name|dirtyLayer
operator|++
control|)
block|{
name|mImageArray
index|[
name|dirtyLevel
index|]
index|[
name|dirtyLayer
index|]
operator|->
name|markDirty
argument_list|()
expr_stmt|;
block|}
block|}
operator|delete
name|mTexStorage
expr_stmt|;
name|mTexStorage
operator|=
name|NULL
expr_stmt|;
name|mDirtyImages
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
DECL|function|imageIterator
name|gl
operator|::
name|ImageIndexIterator
name|TextureD3D_2DArray
operator|::
name|imageIterator
parameter_list|()
specifier|const
block|{
return|return
name|gl
operator|::
name|ImageIndexIterator
operator|::
name|Make2DArray
argument_list|(
literal|0
argument_list|,
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
argument_list|,
name|mLayerCounts
argument_list|)
return|;
block|}
DECL|function|getImageIndex
name|gl
operator|::
name|ImageIndex
name|TextureD3D_2DArray
operator|::
name|getImageIndex
parameter_list|(
name|GLint
name|mip
parameter_list|,
name|GLint
name|layer
parameter_list|)
specifier|const
block|{
return|return
name|gl
operator|::
name|ImageIndex
operator|::
name|Make2DArray
argument_list|(
name|mip
argument_list|,
name|layer
argument_list|)
return|;
block|}
DECL|function|isValidIndex
name|bool
name|TextureD3D_2DArray
operator|::
name|isValidIndex
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
comment|// Check for having a storage and the right type of index
if|if
condition|(
operator|!
name|mTexStorage
operator|||
name|index
operator|.
name|type
operator|!=
name|GL_TEXTURE_2D_ARRAY
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Check the mip index
if|if
condition|(
name|index
operator|.
name|mipIndex
operator|<
literal|0
operator|||
name|index
operator|.
name|mipIndex
operator|>=
name|mTexStorage
operator|->
name|getLevelCount
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Check the layer index
return|return
operator|(
operator|!
name|index
operator|.
name|hasLayer
argument_list|()
operator|||
operator|(
name|index
operator|.
name|layerIndex
operator|>=
literal|0
operator|&&
name|index
operator|.
name|layerIndex
operator|<
name|mLayerCounts
index|[
name|index
operator|.
name|mipIndex
index|]
operator|)
operator|)
return|;
block|}
block|}
end_namespace
end_unit
