begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// RendererD3D.cpp: Implementation of the base D3D Renderer.
end_comment
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/RendererD3D.h"
end_include
begin_include
include|#
directive|include
file|"common/debug.h"
end_include
begin_include
include|#
directive|include
file|"common/MemoryBuffer.h"
end_include
begin_include
include|#
directive|include
file|"common/utilities.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Display.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/formatutils.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Framebuffer.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/FramebufferAttachment.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/BufferD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/DeviceD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/DisplayD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/IndexDataManager.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/ProgramD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/SamplerD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/ResourceManager.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/State.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/VertexArray.h"
end_include
begin_namespace
DECL|namespace|rx
namespace|namespace
name|rx
block|{
namespace|namespace
block|{
comment|// If we request a scratch buffer requesting a smaller size this many times,
comment|// release and recreate the scratch buffer. This ensures we don't have a
comment|// degenerate case where we are stuck hogging memory.
DECL|member|ScratchMemoryBufferLifetime
specifier|const
name|int
name|ScratchMemoryBufferLifetime
init|=
literal|1000
decl_stmt|;
block|}
comment|// anonymous namespace
DECL|function|RendererD3D
name|RendererD3D
operator|::
name|RendererD3D
parameter_list|(
name|egl
operator|::
name|Display
modifier|*
name|display
parameter_list|)
member_init_list|:
name|mDisplay
argument_list|(
name|display
argument_list|)
member_init_list|,
name|mDeviceLost
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mAnnotator
argument_list|(
literal|nullptr
argument_list|)
member_init_list|,
name|mPresentPathFastEnabled
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mScratchMemoryBufferResetCounter
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mWorkaroundsInitialized
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mDisjoint
argument_list|(
literal|false
argument_list|)
block|{ }
DECL|function|~RendererD3D
name|RendererD3D
operator|::
name|~
name|RendererD3D
parameter_list|()
block|{
name|cleanup
argument_list|()
expr_stmt|;
block|}
DECL|function|cleanup
name|void
name|RendererD3D
operator|::
name|cleanup
parameter_list|()
block|{
name|mScratchMemoryBuffer
operator|.
name|resize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|auto
operator|&
name|incompleteTexture
operator|:
name|mIncompleteTextures
control|)
block|{
name|incompleteTexture
operator|.
name|second
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
name|mIncompleteTextures
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|mAnnotator
operator|!=
literal|nullptr
condition|)
block|{
name|gl
operator|::
name|UninitializeDebugAnnotations
argument_list|()
expr_stmt|;
name|SafeDelete
argument_list|(
name|mAnnotator
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|createSampler
name|SamplerImpl
modifier|*
name|RendererD3D
operator|::
name|createSampler
parameter_list|()
block|{
return|return
operator|new
name|SamplerD3D
argument_list|()
return|;
block|}
DECL|function|drawArrays
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|drawArrays
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLint
name|first
parameter_list|,
name|GLsizei
name|count
parameter_list|)
block|{
return|return
name|genericDrawArrays
argument_list|(
name|data
argument_list|,
name|mode
argument_list|,
name|first
argument_list|,
name|count
argument_list|,
literal|0
argument_list|)
return|;
block|}
DECL|function|drawArraysInstanced
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|drawArraysInstanced
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLint
name|first
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLsizei
name|instanceCount
parameter_list|)
block|{
return|return
name|genericDrawArrays
argument_list|(
name|data
argument_list|,
name|mode
argument_list|,
name|first
argument_list|,
name|count
argument_list|,
name|instanceCount
argument_list|)
return|;
block|}
DECL|function|drawElements
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|drawElements
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
specifier|const
name|gl
operator|::
name|IndexRange
modifier|&
name|indexRange
parameter_list|)
block|{
return|return
name|genericDrawElements
argument_list|(
name|data
argument_list|,
name|mode
argument_list|,
name|count
argument_list|,
name|type
argument_list|,
name|indices
argument_list|,
literal|0
argument_list|,
name|indexRange
argument_list|)
return|;
block|}
DECL|function|drawElementsInstanced
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|drawElementsInstanced
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|GLsizei
name|instances
parameter_list|,
specifier|const
name|gl
operator|::
name|IndexRange
modifier|&
name|indexRange
parameter_list|)
block|{
return|return
name|genericDrawElements
argument_list|(
name|data
argument_list|,
name|mode
argument_list|,
name|count
argument_list|,
name|type
argument_list|,
name|indices
argument_list|,
name|instances
argument_list|,
name|indexRange
argument_list|)
return|;
block|}
DECL|function|drawRangeElements
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|drawRangeElements
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLuint
name|start
parameter_list|,
name|GLuint
name|end
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
specifier|const
name|gl
operator|::
name|IndexRange
modifier|&
name|indexRange
parameter_list|)
block|{
return|return
name|genericDrawElements
argument_list|(
name|data
argument_list|,
name|mode
argument_list|,
name|count
argument_list|,
name|type
argument_list|,
name|indices
argument_list|,
literal|0
argument_list|,
name|indexRange
argument_list|)
return|;
block|}
DECL|function|genericDrawElements
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|genericDrawElements
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|GLsizei
name|instances
parameter_list|,
specifier|const
name|gl
operator|::
name|IndexRange
modifier|&
name|indexRange
parameter_list|)
block|{
name|gl
operator|::
name|Program
modifier|*
name|program
init|=
name|data
operator|.
name|state
operator|->
name|getProgram
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|program
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
name|ProgramD3D
modifier|*
name|programD3D
init|=
name|GetImplAs
argument_list|<
name|ProgramD3D
argument_list|>
argument_list|(
name|program
argument_list|)
decl_stmt|;
name|bool
name|usesPointSize
init|=
name|programD3D
operator|->
name|usesPointSize
argument_list|()
decl_stmt|;
name|programD3D
operator|->
name|updateSamplerMapping
argument_list|()
expr_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|generateSwizzles
argument_list|(
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
operator|!
name|applyPrimitiveType
argument_list|(
name|mode
argument_list|,
name|count
argument_list|,
name|usesPointSize
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
name|error
operator|=
name|updateState
argument_list|(
name|data
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|TranslatedIndexData
name|indexInfo
decl_stmt|;
name|indexInfo
operator|.
name|indexRange
operator|=
name|indexRange
expr_stmt|;
name|error
operator|=
name|applyIndexBuffer
argument_list|(
name|data
argument_list|,
name|indices
argument_list|,
name|count
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
operator|&
name|indexInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|applyTransformFeedbackBuffers
argument_list|(
operator|*
name|data
operator|.
name|state
argument_list|)
expr_stmt|;
comment|// Transform feedback is not allowed for DrawElements, this error should have been caught at the API validation
comment|// layer.
name|ASSERT
argument_list|(
operator|!
name|data
operator|.
name|state
operator|->
name|isTransformFeedbackActiveUnpaused
argument_list|()
argument_list|)
expr_stmt|;
name|size_t
name|vertexCount
init|=
name|indexInfo
operator|.
name|indexRange
operator|.
name|vertexCount
argument_list|()
decl_stmt|;
name|error
operator|=
name|applyVertexBuffer
argument_list|(
operator|*
name|data
operator|.
name|state
argument_list|,
name|mode
argument_list|,
cast|static_cast
argument_list|<
name|GLsizei
argument_list|>
argument_list|(
name|indexInfo
operator|.
name|indexRange
operator|.
name|start
argument_list|)
argument_list|,
cast|static_cast
argument_list|<
name|GLsizei
argument_list|>
argument_list|(
name|vertexCount
argument_list|)
argument_list|,
name|instances
argument_list|,
operator|&
name|indexInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|applyTextures
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|applyShaders
argument_list|(
name|data
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|programD3D
operator|->
name|applyUniformBuffers
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
operator|!
name|skipDraw
argument_list|(
name|data
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|error
operator|=
name|drawElementsImpl
argument_list|(
name|data
argument_list|,
name|indexInfo
argument_list|,
name|mode
argument_list|,
name|count
argument_list|,
name|type
argument_list|,
name|indices
argument_list|,
name|instances
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|genericDrawArrays
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|genericDrawArrays
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLint
name|first
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLsizei
name|instances
parameter_list|)
block|{
name|gl
operator|::
name|Program
modifier|*
name|program
init|=
name|data
operator|.
name|state
operator|->
name|getProgram
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|program
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
name|ProgramD3D
modifier|*
name|programD3D
init|=
name|GetImplAs
argument_list|<
name|ProgramD3D
argument_list|>
argument_list|(
name|program
argument_list|)
decl_stmt|;
name|bool
name|usesPointSize
init|=
name|programD3D
operator|->
name|usesPointSize
argument_list|()
decl_stmt|;
name|programD3D
operator|->
name|updateSamplerMapping
argument_list|()
expr_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|generateSwizzles
argument_list|(
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
operator|!
name|applyPrimitiveType
argument_list|(
name|mode
argument_list|,
name|count
argument_list|,
name|usesPointSize
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
name|error
operator|=
name|updateState
argument_list|(
name|data
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|applyTransformFeedbackBuffers
argument_list|(
operator|*
name|data
operator|.
name|state
argument_list|)
expr_stmt|;
name|error
operator|=
name|applyVertexBuffer
argument_list|(
operator|*
name|data
operator|.
name|state
argument_list|,
name|mode
argument_list|,
name|first
argument_list|,
name|count
argument_list|,
name|instances
argument_list|,
literal|nullptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|applyTextures
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|applyShaders
argument_list|(
name|data
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|programD3D
operator|->
name|applyUniformBuffers
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
operator|!
name|skipDraw
argument_list|(
name|data
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|error
operator|=
name|drawArraysImpl
argument_list|(
name|data
argument_list|,
name|mode
argument_list|,
name|count
argument_list|,
name|instances
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
name|data
operator|.
name|state
operator|->
name|isTransformFeedbackActiveUnpaused
argument_list|()
condition|)
block|{
name|markTransformFeedbackUsage
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|generateSwizzles
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|generateSwizzles
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|gl
operator|::
name|SamplerType
name|type
parameter_list|)
block|{
name|ProgramD3D
modifier|*
name|programD3D
init|=
name|GetImplAs
argument_list|<
name|ProgramD3D
argument_list|>
argument_list|(
name|data
operator|.
name|state
operator|->
name|getProgram
argument_list|()
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|samplerRange
init|=
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|programD3D
operator|->
name|getUsedSamplerRange
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|samplerRange
condition|;
name|i
operator|++
control|)
block|{
name|GLenum
name|textureType
init|=
name|programD3D
operator|->
name|getSamplerTextureType
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|GLint
name|textureUnit
init|=
name|programD3D
operator|->
name|getSamplerMapping
argument_list|(
name|type
argument_list|,
name|i
argument_list|,
operator|*
name|data
operator|.
name|caps
argument_list|)
decl_stmt|;
if|if
condition|(
name|textureUnit
operator|!=
operator|-
literal|1
condition|)
block|{
name|gl
operator|::
name|Texture
modifier|*
name|texture
init|=
name|data
operator|.
name|state
operator|->
name|getSamplerTexture
argument_list|(
name|textureUnit
argument_list|,
name|textureType
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|texture
argument_list|)
expr_stmt|;
if|if
condition|(
name|texture
operator|->
name|getTextureState
argument_list|()
operator|.
name|swizzleRequired
argument_list|()
condition|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|generateSwizzle
argument_list|(
name|texture
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|generateSwizzles
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|generateSwizzles
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|generateSwizzles
argument_list|(
name|data
argument_list|,
name|gl
operator|::
name|SAMPLER_VERTEX
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|generateSwizzles
argument_list|(
name|data
argument_list|,
name|gl
operator|::
name|SAMPLER_PIXEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|GetBlendSampleMask
name|unsigned
name|int
name|RendererD3D
operator|::
name|GetBlendSampleMask
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|int
name|samples
parameter_list|)
block|{
name|unsigned
name|int
name|mask
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|data
operator|.
name|state
operator|->
name|isSampleCoverageEnabled
argument_list|()
condition|)
block|{
name|GLclampf
name|coverageValue
init|=
name|data
operator|.
name|state
operator|->
name|getSampleCoverageValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|coverageValue
operator|!=
literal|0
condition|)
block|{
name|float
name|threshold
init|=
literal|0.5f
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|samples
condition|;
operator|++
name|i
control|)
block|{
name|mask
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|coverageValue
operator|>=
name|threshold
condition|)
block|{
name|threshold
operator|+=
literal|1.0f
expr_stmt|;
name|mask
operator||=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|bool
name|coverageInvert
init|=
name|data
operator|.
name|state
operator|->
name|getSampleCoverageInvert
argument_list|()
decl_stmt|;
if|if
condition|(
name|coverageInvert
condition|)
block|{
name|mask
operator|=
operator|~
name|mask
expr_stmt|;
block|}
block|}
else|else
block|{
name|mask
operator|=
literal|0xFFFFFFFF
expr_stmt|;
block|}
return|return
name|mask
return|;
block|}
comment|// Applies the shaders and shader constants to the Direct3D device
DECL|function|applyShaders
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|applyShaders
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLenum
name|drawMode
parameter_list|)
block|{
name|gl
operator|::
name|Program
modifier|*
name|program
init|=
name|data
operator|.
name|state
operator|->
name|getProgram
argument_list|()
decl_stmt|;
name|ProgramD3D
modifier|*
name|programD3D
init|=
name|GetImplAs
argument_list|<
name|ProgramD3D
argument_list|>
argument_list|(
name|program
argument_list|)
decl_stmt|;
name|programD3D
operator|->
name|updateCachedInputLayout
argument_list|(
operator|*
name|data
operator|.
name|state
argument_list|)
expr_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|applyShadersImpl
argument_list|(
name|data
argument_list|,
name|drawMode
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
return|return
name|programD3D
operator|->
name|applyUniforms
argument_list|(
name|drawMode
argument_list|)
return|;
block|}
comment|// For each Direct3D sampler of either the pixel or vertex stage,
comment|// looks up the corresponding OpenGL texture image unit and texture type,
comment|// and sets the texture and its addressing/filtering state (or NULL when inactive).
comment|// Sampler mapping needs to be up-to-date on the program object before this is called.
DECL|function|applyTextures
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|applyTextures
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|gl
operator|::
name|SamplerType
name|shaderType
parameter_list|,
specifier|const
name|FramebufferTextureArray
modifier|&
name|framebufferTextures
parameter_list|,
name|size_t
name|framebufferTextureCount
parameter_list|)
block|{
name|ProgramD3D
modifier|*
name|programD3D
init|=
name|GetImplAs
argument_list|<
name|ProgramD3D
argument_list|>
argument_list|(
name|data
operator|.
name|state
operator|->
name|getProgram
argument_list|()
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|programD3D
operator|->
name|isSamplerMappingDirty
argument_list|()
argument_list|)
expr_stmt|;
name|unsigned
name|int
name|samplerRange
init|=
name|programD3D
operator|->
name|getUsedSamplerRange
argument_list|(
name|shaderType
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|samplerIndex
init|=
literal|0
init|;
name|samplerIndex
operator|<
name|samplerRange
condition|;
name|samplerIndex
operator|++
control|)
block|{
name|GLenum
name|textureType
init|=
name|programD3D
operator|->
name|getSamplerTextureType
argument_list|(
name|shaderType
argument_list|,
name|samplerIndex
argument_list|)
decl_stmt|;
name|GLint
name|textureUnit
init|=
name|programD3D
operator|->
name|getSamplerMapping
argument_list|(
name|shaderType
argument_list|,
name|samplerIndex
argument_list|,
operator|*
name|data
operator|.
name|caps
argument_list|)
decl_stmt|;
if|if
condition|(
name|textureUnit
operator|!=
operator|-
literal|1
condition|)
block|{
name|gl
operator|::
name|Texture
modifier|*
name|texture
init|=
name|data
operator|.
name|state
operator|->
name|getSamplerTexture
argument_list|(
name|textureUnit
argument_list|,
name|textureType
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|texture
argument_list|)
expr_stmt|;
name|gl
operator|::
name|Sampler
modifier|*
name|samplerObject
init|=
name|data
operator|.
name|state
operator|->
name|getSampler
argument_list|(
name|textureUnit
argument_list|)
decl_stmt|;
specifier|const
name|gl
operator|::
name|SamplerState
modifier|&
name|samplerState
init|=
name|samplerObject
condition|?
name|samplerObject
operator|->
name|getSamplerState
argument_list|()
else|:
name|texture
operator|->
name|getSamplerState
argument_list|()
decl_stmt|;
comment|// TODO: std::binary_search may become unavailable using older versions of GCC
if|if
condition|(
name|texture
operator|->
name|isSamplerComplete
argument_list|(
name|samplerState
argument_list|,
name|data
argument_list|)
operator|&&
operator|!
name|std
operator|::
name|binary_search
argument_list|(
name|framebufferTextures
operator|.
name|begin
argument_list|()
argument_list|,
name|framebufferTextures
operator|.
name|begin
argument_list|()
operator|+
name|framebufferTextureCount
argument_list|,
name|texture
argument_list|)
condition|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|setSamplerState
argument_list|(
name|shaderType
argument_list|,
name|samplerIndex
argument_list|,
name|texture
argument_list|,
name|samplerState
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|setTexture
argument_list|(
name|shaderType
argument_list|,
name|samplerIndex
argument_list|,
name|texture
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
else|else
block|{
comment|// Texture is not sampler complete or it is in use by the framebuffer.  Bind the incomplete texture.
name|gl
operator|::
name|Texture
modifier|*
name|incompleteTexture
init|=
name|getIncompleteTexture
argument_list|(
name|textureType
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|setSamplerState
argument_list|(
name|shaderType
argument_list|,
name|samplerIndex
argument_list|,
name|incompleteTexture
argument_list|,
name|incompleteTexture
operator|->
name|getSamplerState
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|setTexture
argument_list|(
name|shaderType
argument_list|,
name|samplerIndex
argument_list|,
name|incompleteTexture
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
block|}
else|else
block|{
comment|// No texture bound to this slot even though it is used by the shader, bind a NULL texture
name|gl
operator|::
name|Error
name|error
init|=
name|setTexture
argument_list|(
name|shaderType
argument_list|,
name|samplerIndex
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
block|}
comment|// Set all the remaining textures to NULL
name|size_t
name|samplerCount
init|=
operator|(
name|shaderType
operator|==
name|gl
operator|::
name|SAMPLER_PIXEL
operator|)
condition|?
name|data
operator|.
name|caps
operator|->
name|maxTextureImageUnits
else|:
name|data
operator|.
name|caps
operator|->
name|maxVertexTextureImageUnits
decl_stmt|;
name|clearTextures
argument_list|(
name|shaderType
argument_list|,
name|samplerRange
argument_list|,
name|samplerCount
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|applyTextures
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|applyTextures
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|)
block|{
name|FramebufferTextureArray
name|framebufferTextures
decl_stmt|;
name|size_t
name|framebufferSerialCount
init|=
name|getBoundFramebufferTextures
argument_list|(
name|data
argument_list|,
operator|&
name|framebufferTextures
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|applyTextures
argument_list|(
name|data
argument_list|,
name|gl
operator|::
name|SAMPLER_VERTEX
argument_list|,
name|framebufferTextures
argument_list|,
name|framebufferSerialCount
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|applyTextures
argument_list|(
name|data
argument_list|,
name|gl
operator|::
name|SAMPLER_PIXEL
argument_list|,
name|framebufferTextures
argument_list|,
name|framebufferSerialCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|skipDraw
name|bool
name|RendererD3D
operator|::
name|skipDraw
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLenum
name|drawMode
parameter_list|)
block|{
specifier|const
name|gl
operator|::
name|State
modifier|&
name|state
init|=
operator|*
name|data
operator|.
name|state
decl_stmt|;
if|if
condition|(
name|drawMode
operator|==
name|GL_POINTS
condition|)
block|{
name|bool
name|usesPointSize
init|=
name|GetImplAs
argument_list|<
name|ProgramD3D
argument_list|>
argument_list|(
name|state
operator|.
name|getProgram
argument_list|()
argument_list|)
operator|->
name|usesPointSize
argument_list|()
decl_stmt|;
comment|// ProgramBinary assumes non-point rendering if gl_PointSize isn't written,
comment|// which affects varying interpolation. Since the value of gl_PointSize is
comment|// undefined when not written, just skip drawing to avoid unexpected results.
if|if
condition|(
operator|!
name|usesPointSize
operator|&&
operator|!
name|state
operator|.
name|isTransformFeedbackActiveUnpaused
argument_list|()
condition|)
block|{
comment|// This is stictly speaking not an error, but developers should be
comment|// notified of risking undefined behavior.
name|ERR
argument_list|(
literal|"Point rendering without writing to gl_PointSize."
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|gl
operator|::
name|IsTriangleMode
argument_list|(
name|drawMode
argument_list|)
condition|)
block|{
if|if
condition|(
name|state
operator|.
name|getRasterizerState
argument_list|()
operator|.
name|cullFace
operator|&&
name|state
operator|.
name|getRasterizerState
argument_list|()
operator|.
name|cullMode
operator|==
name|GL_FRONT_AND_BACK
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|function|markTransformFeedbackUsage
name|void
name|RendererD3D
operator|::
name|markTransformFeedbackUsage
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|)
block|{
specifier|const
name|gl
operator|::
name|TransformFeedback
modifier|*
name|transformFeedback
init|=
name|data
operator|.
name|state
operator|->
name|getCurrentTransformFeedback
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|transformFeedback
operator|->
name|getIndexedBufferCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|OffsetBindingPointer
argument_list|<
name|gl
operator|::
name|Buffer
argument_list|>
modifier|&
name|binding
init|=
name|transformFeedback
operator|->
name|getIndexedBuffer
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|binding
operator|.
name|get
argument_list|()
operator|!=
literal|nullptr
condition|)
block|{
name|BufferD3D
modifier|*
name|bufferD3D
init|=
name|GetImplAs
argument_list|<
name|BufferD3D
argument_list|>
argument_list|(
name|binding
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
name|bufferD3D
operator|->
name|markTransformFeedbackUsage
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|function|getBoundFramebufferTextures
name|size_t
name|RendererD3D
operator|::
name|getBoundFramebufferTextures
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|FramebufferTextureArray
modifier|*
name|outTextureArray
parameter_list|)
block|{
name|size_t
name|textureCount
init|=
literal|0
decl_stmt|;
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|drawFramebuffer
init|=
name|data
operator|.
name|state
operator|->
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|drawFramebuffer
operator|->
name|getNumColorBuffers
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|attachment
init|=
name|drawFramebuffer
operator|->
name|getColorbuffer
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|attachment
operator|&&
name|attachment
operator|->
name|type
argument_list|()
operator|==
name|GL_TEXTURE
condition|)
block|{
operator|(
operator|*
name|outTextureArray
operator|)
index|[
name|textureCount
operator|++
index|]
operator|=
name|attachment
operator|->
name|getTexture
argument_list|()
expr_stmt|;
block|}
block|}
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|depthStencilAttachment
init|=
name|drawFramebuffer
operator|->
name|getDepthOrStencilbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|depthStencilAttachment
operator|&&
name|depthStencilAttachment
operator|->
name|type
argument_list|()
operator|==
name|GL_TEXTURE
condition|)
block|{
operator|(
operator|*
name|outTextureArray
operator|)
index|[
name|textureCount
operator|++
index|]
operator|=
name|depthStencilAttachment
operator|->
name|getTexture
argument_list|()
expr_stmt|;
block|}
name|std
operator|::
name|sort
argument_list|(
name|outTextureArray
operator|->
name|begin
argument_list|()
argument_list|,
name|outTextureArray
operator|->
name|begin
argument_list|()
operator|+
name|textureCount
argument_list|)
expr_stmt|;
return|return
name|textureCount
return|;
block|}
DECL|function|getIncompleteTexture
name|gl
operator|::
name|Texture
modifier|*
name|RendererD3D
operator|::
name|getIncompleteTexture
parameter_list|(
name|GLenum
name|type
parameter_list|)
block|{
if|if
condition|(
name|mIncompleteTextures
operator|.
name|find
argument_list|(
name|type
argument_list|)
operator|==
name|mIncompleteTextures
operator|.
name|end
argument_list|()
condition|)
block|{
specifier|const
name|GLubyte
name|color
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|255
block|}
decl_stmt|;
specifier|const
name|gl
operator|::
name|Extents
name|colorSize
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|const
name|gl
operator|::
name|PixelUnpackState
name|unpack
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|const
name|gl
operator|::
name|Box
name|area
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|// Skip the API layer to avoid needing to pass the Context and mess with dirty bits.
name|gl
operator|::
name|Texture
modifier|*
name|t
init|=
operator|new
name|gl
operator|::
name|Texture
argument_list|(
name|createTexture
argument_list|(
name|type
argument_list|)
argument_list|,
name|std
operator|::
name|numeric_limits
argument_list|<
name|GLuint
argument_list|>
operator|::
name|max
argument_list|()
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|t
operator|->
name|setStorage
argument_list|(
name|type
argument_list|,
literal|1
argument_list|,
name|GL_RGBA8
argument_list|,
name|colorSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|GL_TEXTURE_CUBE_MAP
condition|)
block|{
for|for
control|(
name|GLenum
name|face
init|=
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
init|;
name|face
operator|<=
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
condition|;
name|face
operator|++
control|)
block|{
name|t
operator|->
name|getImplementation
argument_list|()
operator|->
name|setSubImage
argument_list|(
name|face
argument_list|,
literal|0
argument_list|,
name|area
argument_list|,
name|GL_RGBA8
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
name|unpack
argument_list|,
name|color
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|t
operator|->
name|getImplementation
argument_list|()
operator|->
name|setSubImage
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|area
argument_list|,
name|GL_RGBA8
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
name|unpack
argument_list|,
name|color
argument_list|)
expr_stmt|;
block|}
name|mIncompleteTextures
index|[
name|type
index|]
operator|.
name|set
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|mIncompleteTextures
index|[
name|type
index|]
operator|.
name|get
argument_list|()
return|;
block|}
DECL|function|isDeviceLost
name|bool
name|RendererD3D
operator|::
name|isDeviceLost
parameter_list|()
specifier|const
block|{
return|return
name|mDeviceLost
return|;
block|}
DECL|function|notifyDeviceLost
name|void
name|RendererD3D
operator|::
name|notifyDeviceLost
parameter_list|()
block|{
name|mDeviceLost
operator|=
literal|true
expr_stmt|;
name|mDisplay
operator|->
name|notifyDeviceLost
argument_list|()
expr_stmt|;
block|}
DECL|function|getVendorString
name|std
operator|::
name|string
name|RendererD3D
operator|::
name|getVendorString
parameter_list|()
specifier|const
block|{
name|LUID
name|adapterLuid
init|=
block|{
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|getLUID
argument_list|(
operator|&
name|adapterLuid
argument_list|)
condition|)
block|{
name|char
name|adapterLuidString
index|[
literal|64
index|]
decl_stmt|;
name|sprintf_s
argument_list|(
name|adapterLuidString
argument_list|,
sizeof|sizeof
argument_list|(
name|adapterLuidString
argument_list|)
argument_list|,
literal|"(adapter LUID: %08x%08x)"
argument_list|,
name|adapterLuid
operator|.
name|HighPart
argument_list|,
name|adapterLuid
operator|.
name|LowPart
argument_list|)
expr_stmt|;
return|return
name|std
operator|::
name|string
argument_list|(
name|adapterLuidString
argument_list|)
return|;
block|}
return|return
name|std
operator|::
name|string
argument_list|(
literal|""
argument_list|)
return|;
block|}
DECL|function|getScratchMemoryBuffer
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|getScratchMemoryBuffer
parameter_list|(
name|size_t
name|requestedSize
parameter_list|,
name|MemoryBuffer
modifier|*
modifier|*
name|bufferOut
parameter_list|)
block|{
if|if
condition|(
name|mScratchMemoryBuffer
operator|.
name|size
argument_list|()
operator|==
name|requestedSize
condition|)
block|{
name|mScratchMemoryBufferResetCounter
operator|=
name|ScratchMemoryBufferLifetime
expr_stmt|;
operator|*
name|bufferOut
operator|=
operator|&
name|mScratchMemoryBuffer
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
if|if
condition|(
name|mScratchMemoryBuffer
operator|.
name|size
argument_list|()
operator|>
name|requestedSize
condition|)
block|{
name|mScratchMemoryBufferResetCounter
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|mScratchMemoryBufferResetCounter
operator|<=
literal|0
operator|||
name|mScratchMemoryBuffer
operator|.
name|size
argument_list|()
operator|<
name|requestedSize
condition|)
block|{
name|mScratchMemoryBuffer
operator|.
name|resize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mScratchMemoryBuffer
operator|.
name|resize
argument_list|(
name|requestedSize
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to allocate internal buffer."
argument_list|)
return|;
block|}
name|mScratchMemoryBufferResetCounter
operator|=
name|ScratchMemoryBufferLifetime
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|mScratchMemoryBuffer
operator|.
name|size
argument_list|()
operator|>=
name|requestedSize
argument_list|)
expr_stmt|;
operator|*
name|bufferOut
operator|=
operator|&
name|mScratchMemoryBuffer
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|insertEventMarker
name|void
name|RendererD3D
operator|::
name|insertEventMarker
parameter_list|(
name|GLsizei
name|length
parameter_list|,
specifier|const
name|char
modifier|*
name|marker
parameter_list|)
block|{
name|std
operator|::
name|vector
argument_list|<
name|wchar_t
argument_list|>
name|wcstring
argument_list|(
name|length
operator|+
literal|1
argument_list|)
decl_stmt|;
name|size_t
name|convertedChars
init|=
literal|0
decl_stmt|;
name|errno_t
name|err
init|=
name|mbstowcs_s
argument_list|(
operator|&
name|convertedChars
argument_list|,
name|wcstring
operator|.
name|data
argument_list|()
argument_list|,
name|length
operator|+
literal|1
argument_list|,
name|marker
argument_list|,
name|_TRUNCATE
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|getAnnotator
argument_list|()
operator|->
name|setMarker
argument_list|(
name|wcstring
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|pushGroupMarker
name|void
name|RendererD3D
operator|::
name|pushGroupMarker
parameter_list|(
name|GLsizei
name|length
parameter_list|,
specifier|const
name|char
modifier|*
name|marker
parameter_list|)
block|{
name|std
operator|::
name|vector
argument_list|<
name|wchar_t
argument_list|>
name|wcstring
argument_list|(
name|length
operator|+
literal|1
argument_list|)
decl_stmt|;
name|size_t
name|convertedChars
init|=
literal|0
decl_stmt|;
name|errno_t
name|err
init|=
name|mbstowcs_s
argument_list|(
operator|&
name|convertedChars
argument_list|,
name|wcstring
operator|.
name|data
argument_list|()
argument_list|,
name|length
operator|+
literal|1
argument_list|,
name|marker
argument_list|,
name|_TRUNCATE
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|getAnnotator
argument_list|()
operator|->
name|beginEvent
argument_list|(
name|wcstring
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|popGroupMarker
name|void
name|RendererD3D
operator|::
name|popGroupMarker
parameter_list|()
block|{
name|getAnnotator
argument_list|()
operator|->
name|endEvent
argument_list|()
expr_stmt|;
block|}
DECL|function|setGPUDisjoint
name|void
name|RendererD3D
operator|::
name|setGPUDisjoint
parameter_list|()
block|{
name|mDisjoint
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|getGPUDisjoint
name|GLint
name|RendererD3D
operator|::
name|getGPUDisjoint
parameter_list|()
block|{
name|bool
name|disjoint
init|=
name|mDisjoint
decl_stmt|;
comment|// Disjoint flag is cleared when read
name|mDisjoint
operator|=
literal|false
expr_stmt|;
return|return
name|disjoint
return|;
block|}
DECL|function|getTimestamp
name|GLint64
name|RendererD3D
operator|::
name|getTimestamp
parameter_list|()
block|{
comment|// D3D has no way to get an actual timestamp reliably so 0 is returned
return|return
literal|0
return|;
block|}
DECL|function|onMakeCurrent
name|void
name|RendererD3D
operator|::
name|onMakeCurrent
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|)
block|{ }
DECL|function|initializeDebugAnnotator
name|void
name|RendererD3D
operator|::
name|initializeDebugAnnotator
parameter_list|()
block|{
name|createAnnotator
argument_list|()
expr_stmt|;
name|ASSERT
argument_list|(
name|mAnnotator
argument_list|)
expr_stmt|;
name|gl
operator|::
name|InitializeDebugAnnotations
argument_list|(
name|mAnnotator
argument_list|)
expr_stmt|;
block|}
DECL|function|getAnnotator
name|gl
operator|::
name|DebugAnnotator
modifier|*
name|RendererD3D
operator|::
name|getAnnotator
parameter_list|()
block|{
name|ASSERT
argument_list|(
name|mAnnotator
argument_list|)
expr_stmt|;
return|return
name|mAnnotator
return|;
block|}
block|}
end_namespace
end_unit
