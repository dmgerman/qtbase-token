begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// RendererD3D.cpp: Implementation of the base D3D Renderer.
end_comment
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/RendererD3D.h"
end_include
begin_include
include|#
directive|include
file|"common/MemoryBuffer.h"
end_include
begin_include
include|#
directive|include
file|"common/utilities.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Display.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Framebuffer.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/FramebufferAttachment.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/ResourceManager.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/State.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/VertexArray.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/formatutils.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/BufferD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/DisplayD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/IndexDataManager.h"
end_include
begin_namespace
DECL|namespace|rx
namespace|namespace
name|rx
block|{
namespace|namespace
block|{
comment|// If we request a scratch buffer requesting a smaller size this many times,
comment|// release and recreate the scratch buffer. This ensures we don't have a
comment|// degenerate case where we are stuck hogging memory.
DECL|member|ScratchMemoryBufferLifetime
specifier|const
name|int
name|ScratchMemoryBufferLifetime
init|=
literal|1000
decl_stmt|;
block|}
DECL|function|RendererD3D
name|RendererD3D
operator|::
name|RendererD3D
parameter_list|(
name|egl
operator|::
name|Display
modifier|*
name|display
parameter_list|)
member_init_list|:
name|mDisplay
argument_list|(
name|display
argument_list|)
member_init_list|,
name|mDeviceLost
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mScratchMemoryBufferResetCounter
argument_list|(
literal|0
argument_list|)
block|{ }
DECL|function|~RendererD3D
name|RendererD3D
operator|::
name|~
name|RendererD3D
parameter_list|()
block|{
name|cleanup
argument_list|()
expr_stmt|;
block|}
DECL|function|cleanup
name|void
name|RendererD3D
operator|::
name|cleanup
parameter_list|()
block|{
name|mScratchMemoryBuffer
operator|.
name|resize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|auto
name|it
init|=
name|mIncompleteTextures
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|mIncompleteTextures
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|it
operator|->
name|second
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
name|mIncompleteTextures
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|// static
DECL|function|makeRendererD3D
name|RendererD3D
modifier|*
name|RendererD3D
operator|::
name|makeRendererD3D
parameter_list|(
name|Renderer
modifier|*
name|renderer
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|HAS_DYNAMIC_TYPE
argument_list|(
name|RendererD3D
operator|*
argument_list|,
name|renderer
argument_list|)
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|RendererD3D
operator|*
argument_list|>
argument_list|(
name|renderer
argument_list|)
return|;
block|}
DECL|function|drawElements
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|drawElements
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|GLsizei
name|instances
parameter_list|,
specifier|const
name|RangeUI
modifier|&
name|indexRange
parameter_list|)
block|{
if|if
condition|(
name|data
operator|.
name|state
operator|->
name|isPrimitiveRestartEnabled
argument_list|()
condition|)
block|{
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"Primitive restart not implemented"
argument_list|)
return|;
block|}
name|gl
operator|::
name|Program
modifier|*
name|program
init|=
name|data
operator|.
name|state
operator|->
name|getProgram
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|program
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|program
operator|->
name|updateSamplerMapping
argument_list|()
expr_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|generateSwizzles
argument_list|(
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
operator|!
name|applyPrimitiveType
argument_list|(
name|mode
argument_list|,
name|count
argument_list|,
name|program
operator|->
name|usesPointSize
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
name|error
operator|=
name|applyRenderTarget
argument_list|(
name|data
argument_list|,
name|mode
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|applyState
argument_list|(
name|data
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|gl
operator|::
name|VertexArray
modifier|*
name|vao
init|=
name|data
operator|.
name|state
operator|->
name|getVertexArray
argument_list|()
decl_stmt|;
name|TranslatedIndexData
name|indexInfo
decl_stmt|;
name|indexInfo
operator|.
name|indexRange
operator|=
name|indexRange
expr_stmt|;
name|error
operator|=
name|applyIndexBuffer
argument_list|(
name|indices
argument_list|,
name|vao
operator|->
name|getElementArrayBuffer
argument_list|()
argument_list|,
name|count
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
operator|&
name|indexInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|applyTransformFeedbackBuffers
argument_list|(
operator|*
name|data
operator|.
name|state
argument_list|)
expr_stmt|;
comment|// Transform feedback is not allowed for DrawElements, this error should have been caught at the API validation
comment|// layer.
name|ASSERT
argument_list|(
operator|!
name|data
operator|.
name|state
operator|->
name|isTransformFeedbackActiveUnpaused
argument_list|()
argument_list|)
expr_stmt|;
name|GLsizei
name|vertexCount
init|=
name|indexInfo
operator|.
name|indexRange
operator|.
name|length
argument_list|()
operator|+
literal|1
decl_stmt|;
name|error
operator|=
name|applyVertexBuffer
argument_list|(
operator|*
name|data
operator|.
name|state
argument_list|,
name|mode
argument_list|,
name|indexInfo
operator|.
name|indexRange
operator|.
name|start
argument_list|,
name|vertexCount
argument_list|,
name|instances
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|applyShaders
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|applyTextures
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|program
operator|->
name|applyUniformBuffers
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
operator|!
name|skipDraw
argument_list|(
name|data
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|error
operator|=
name|drawElements
argument_list|(
name|mode
argument_list|,
name|count
argument_list|,
name|type
argument_list|,
name|indices
argument_list|,
name|vao
operator|->
name|getElementArrayBuffer
argument_list|()
argument_list|,
name|indexInfo
argument_list|,
name|instances
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|drawArrays
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|drawArrays
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLint
name|first
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLsizei
name|instances
parameter_list|)
block|{
name|gl
operator|::
name|Program
modifier|*
name|program
init|=
name|data
operator|.
name|state
operator|->
name|getProgram
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|program
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|program
operator|->
name|updateSamplerMapping
argument_list|()
expr_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|generateSwizzles
argument_list|(
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
operator|!
name|applyPrimitiveType
argument_list|(
name|mode
argument_list|,
name|count
argument_list|,
name|program
operator|->
name|usesPointSize
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
name|error
operator|=
name|applyRenderTarget
argument_list|(
name|data
argument_list|,
name|mode
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|applyState
argument_list|(
name|data
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|applyTransformFeedbackBuffers
argument_list|(
operator|*
name|data
operator|.
name|state
argument_list|)
expr_stmt|;
name|error
operator|=
name|applyVertexBuffer
argument_list|(
operator|*
name|data
operator|.
name|state
argument_list|,
name|mode
argument_list|,
name|first
argument_list|,
name|count
argument_list|,
name|instances
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|applyShaders
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|applyTextures
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|program
operator|->
name|applyUniformBuffers
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
operator|!
name|skipDraw
argument_list|(
name|data
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|error
operator|=
name|drawArrays
argument_list|(
name|data
argument_list|,
name|mode
argument_list|,
name|count
argument_list|,
name|instances
argument_list|,
name|program
operator|->
name|usesPointSize
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
name|data
operator|.
name|state
operator|->
name|isTransformFeedbackActiveUnpaused
argument_list|()
condition|)
block|{
name|markTransformFeedbackUsage
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|generateSwizzles
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|generateSwizzles
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|gl
operator|::
name|SamplerType
name|type
parameter_list|)
block|{
name|gl
operator|::
name|Program
modifier|*
name|program
init|=
name|data
operator|.
name|state
operator|->
name|getProgram
argument_list|()
decl_stmt|;
name|size_t
name|samplerRange
init|=
name|program
operator|->
name|getUsedSamplerRange
argument_list|(
name|type
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|samplerRange
condition|;
name|i
operator|++
control|)
block|{
name|GLenum
name|textureType
init|=
name|program
operator|->
name|getSamplerTextureType
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|GLint
name|textureUnit
init|=
name|program
operator|->
name|getSamplerMapping
argument_list|(
name|type
argument_list|,
name|i
argument_list|,
operator|*
name|data
operator|.
name|caps
argument_list|)
decl_stmt|;
if|if
condition|(
name|textureUnit
operator|!=
operator|-
literal|1
condition|)
block|{
name|gl
operator|::
name|Texture
modifier|*
name|texture
init|=
name|data
operator|.
name|state
operator|->
name|getSamplerTexture
argument_list|(
name|textureUnit
argument_list|,
name|textureType
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|texture
argument_list|)
expr_stmt|;
if|if
condition|(
name|texture
operator|->
name|getSamplerState
argument_list|()
operator|.
name|swizzleRequired
argument_list|()
condition|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|generateSwizzle
argument_list|(
name|texture
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|generateSwizzles
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|generateSwizzles
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|generateSwizzles
argument_list|(
name|data
argument_list|,
name|gl
operator|::
name|SAMPLER_VERTEX
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|generateSwizzles
argument_list|(
name|data
argument_list|,
name|gl
operator|::
name|SAMPLER_PIXEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
comment|// Applies the render target surface, depth stencil surface, viewport rectangle and
comment|// scissor rectangle to the renderer
DECL|function|applyRenderTarget
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|applyRenderTarget
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLenum
name|drawMode
parameter_list|,
name|bool
name|ignoreViewport
parameter_list|)
block|{
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebufferObject
init|=
name|data
operator|.
name|state
operator|->
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|framebufferObject
operator|&&
name|framebufferObject
operator|->
name|checkStatus
argument_list|(
name|data
argument_list|)
operator|==
name|GL_FRAMEBUFFER_COMPLETE
argument_list|)
expr_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|applyRenderTarget
argument_list|(
name|framebufferObject
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|float
name|nearZ
decl_stmt|,
name|farZ
decl_stmt|;
name|data
operator|.
name|state
operator|->
name|getDepthRange
argument_list|(
operator|&
name|nearZ
argument_list|,
operator|&
name|farZ
argument_list|)
expr_stmt|;
name|setViewport
argument_list|(
name|data
operator|.
name|state
operator|->
name|getViewport
argument_list|()
argument_list|,
name|nearZ
argument_list|,
name|farZ
argument_list|,
name|drawMode
argument_list|,
name|data
operator|.
name|state
operator|->
name|getRasterizerState
argument_list|()
operator|.
name|frontFace
argument_list|,
name|ignoreViewport
argument_list|)
expr_stmt|;
name|setScissorRectangle
argument_list|(
name|data
operator|.
name|state
operator|->
name|getScissor
argument_list|()
argument_list|,
name|data
operator|.
name|state
operator|->
name|isScissorTestEnabled
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
comment|// Applies the fixed-function state (culling, depth test, alpha blending, stenciling, etc) to the Direct3D device
DECL|function|applyState
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|applyState
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLenum
name|drawMode
parameter_list|)
block|{
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebufferObject
init|=
name|data
operator|.
name|state
operator|->
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
name|int
name|samples
init|=
name|framebufferObject
operator|->
name|getSamples
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|gl
operator|::
name|RasterizerState
name|rasterizer
init|=
name|data
operator|.
name|state
operator|->
name|getRasterizerState
argument_list|()
decl_stmt|;
name|rasterizer
operator|.
name|pointDrawMode
operator|=
operator|(
name|drawMode
operator|==
name|GL_POINTS
operator|)
expr_stmt|;
name|rasterizer
operator|.
name|multiSample
operator|=
operator|(
name|samples
operator|!=
literal|0
operator|)
expr_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|setRasterizerState
argument_list|(
name|rasterizer
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|unsigned
name|int
name|mask
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|data
operator|.
name|state
operator|->
name|isSampleCoverageEnabled
argument_list|()
condition|)
block|{
name|GLclampf
name|coverageValue
decl_stmt|;
name|bool
name|coverageInvert
init|=
literal|false
decl_stmt|;
name|data
operator|.
name|state
operator|->
name|getSampleCoverageParams
argument_list|(
operator|&
name|coverageValue
argument_list|,
operator|&
name|coverageInvert
argument_list|)
expr_stmt|;
if|if
condition|(
name|coverageValue
operator|!=
literal|0
condition|)
block|{
name|float
name|threshold
init|=
literal|0.5f
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|samples
condition|;
operator|++
name|i
control|)
block|{
name|mask
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|coverageValue
operator|>=
name|threshold
condition|)
block|{
name|threshold
operator|+=
literal|1.0f
expr_stmt|;
name|mask
operator||=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|coverageInvert
condition|)
block|{
name|mask
operator|=
operator|~
name|mask
expr_stmt|;
block|}
block|}
else|else
block|{
name|mask
operator|=
literal|0xFFFFFFFF
expr_stmt|;
block|}
name|error
operator|=
name|setBlendState
argument_list|(
name|framebufferObject
argument_list|,
name|data
operator|.
name|state
operator|->
name|getBlendState
argument_list|()
argument_list|,
name|data
operator|.
name|state
operator|->
name|getBlendColor
argument_list|()
argument_list|,
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|setDepthStencilState
argument_list|(
name|data
operator|.
name|state
operator|->
name|getDepthStencilState
argument_list|()
argument_list|,
name|data
operator|.
name|state
operator|->
name|getStencilRef
argument_list|()
argument_list|,
name|data
operator|.
name|state
operator|->
name|getStencilBackRef
argument_list|()
argument_list|,
name|rasterizer
operator|.
name|frontFace
operator|==
name|GL_CCW
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
comment|// Applies the shaders and shader constants to the Direct3D device
DECL|function|applyShaders
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|applyShaders
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|)
block|{
name|gl
operator|::
name|Program
modifier|*
name|program
init|=
name|data
operator|.
name|state
operator|->
name|getProgram
argument_list|()
decl_stmt|;
name|gl
operator|::
name|VertexFormat
name|inputLayout
index|[
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
index|]
decl_stmt|;
name|gl
operator|::
name|VertexFormat
operator|::
name|GetInputLayout
argument_list|(
name|inputLayout
argument_list|,
name|program
argument_list|,
operator|*
name|data
operator|.
name|state
argument_list|)
expr_stmt|;
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|fbo
init|=
name|data
operator|.
name|state
operator|->
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|applyShaders
argument_list|(
name|program
argument_list|,
name|inputLayout
argument_list|,
name|fbo
argument_list|,
name|data
operator|.
name|state
operator|->
name|getRasterizerState
argument_list|()
operator|.
name|rasterizerDiscard
argument_list|,
name|data
operator|.
name|state
operator|->
name|isTransformFeedbackActiveUnpaused
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
return|return
name|program
operator|->
name|applyUniforms
argument_list|()
return|;
block|}
comment|// For each Direct3D sampler of either the pixel or vertex stage,
comment|// looks up the corresponding OpenGL texture image unit and texture type,
comment|// and sets the texture and its addressing/filtering state (or NULL when inactive).
DECL|function|applyTextures
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|applyTextures
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|gl
operator|::
name|SamplerType
name|shaderType
parameter_list|,
specifier|const
name|FramebufferTextureSerialArray
modifier|&
name|framebufferSerials
parameter_list|,
name|size_t
name|framebufferSerialCount
parameter_list|)
block|{
name|gl
operator|::
name|Program
modifier|*
name|program
init|=
name|data
operator|.
name|state
operator|->
name|getProgram
argument_list|()
decl_stmt|;
name|size_t
name|samplerRange
init|=
name|program
operator|->
name|getUsedSamplerRange
argument_list|(
name|shaderType
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|samplerIndex
init|=
literal|0
init|;
name|samplerIndex
operator|<
name|samplerRange
condition|;
name|samplerIndex
operator|++
control|)
block|{
name|GLenum
name|textureType
init|=
name|program
operator|->
name|getSamplerTextureType
argument_list|(
name|shaderType
argument_list|,
name|samplerIndex
argument_list|)
decl_stmt|;
name|GLint
name|textureUnit
init|=
name|program
operator|->
name|getSamplerMapping
argument_list|(
name|shaderType
argument_list|,
name|samplerIndex
argument_list|,
operator|*
name|data
operator|.
name|caps
argument_list|)
decl_stmt|;
if|if
condition|(
name|textureUnit
operator|!=
operator|-
literal|1
condition|)
block|{
name|gl
operator|::
name|Texture
modifier|*
name|texture
init|=
name|data
operator|.
name|state
operator|->
name|getSamplerTexture
argument_list|(
name|textureUnit
argument_list|,
name|textureType
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|texture
argument_list|)
expr_stmt|;
name|gl
operator|::
name|SamplerState
name|sampler
init|=
name|texture
operator|->
name|getSamplerState
argument_list|()
decl_stmt|;
name|gl
operator|::
name|Sampler
modifier|*
name|samplerObject
init|=
name|data
operator|.
name|state
operator|->
name|getSampler
argument_list|(
name|textureUnit
argument_list|)
decl_stmt|;
if|if
condition|(
name|samplerObject
condition|)
block|{
name|samplerObject
operator|->
name|getState
argument_list|(
operator|&
name|sampler
argument_list|)
expr_stmt|;
block|}
comment|// TODO: std::binary_search may become unavailable using older versions of GCC
if|if
condition|(
name|texture
operator|->
name|isSamplerComplete
argument_list|(
name|sampler
argument_list|,
name|data
argument_list|)
operator|&&
operator|!
name|std
operator|::
name|binary_search
argument_list|(
name|framebufferSerials
operator|.
name|begin
argument_list|()
argument_list|,
name|framebufferSerials
operator|.
name|begin
argument_list|()
operator|+
name|framebufferSerialCount
argument_list|,
name|texture
operator|->
name|getTextureSerial
argument_list|()
argument_list|)
condition|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|setSamplerState
argument_list|(
name|shaderType
argument_list|,
name|samplerIndex
argument_list|,
name|texture
argument_list|,
name|sampler
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|setTexture
argument_list|(
name|shaderType
argument_list|,
name|samplerIndex
argument_list|,
name|texture
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
else|else
block|{
comment|// Texture is not sampler complete or it is in use by the framebuffer.  Bind the incomplete texture.
name|gl
operator|::
name|Texture
modifier|*
name|incompleteTexture
init|=
name|getIncompleteTexture
argument_list|(
name|textureType
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|setTexture
argument_list|(
name|shaderType
argument_list|,
name|samplerIndex
argument_list|,
name|incompleteTexture
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
block|}
else|else
block|{
comment|// No texture bound to this slot even though it is used by the shader, bind a NULL texture
name|gl
operator|::
name|Error
name|error
init|=
name|setTexture
argument_list|(
name|shaderType
argument_list|,
name|samplerIndex
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
block|}
comment|// Set all the remaining textures to NULL
name|size_t
name|samplerCount
init|=
operator|(
name|shaderType
operator|==
name|gl
operator|::
name|SAMPLER_PIXEL
operator|)
condition|?
name|data
operator|.
name|caps
operator|->
name|maxTextureImageUnits
else|:
name|data
operator|.
name|caps
operator|->
name|maxVertexTextureImageUnits
decl_stmt|;
for|for
control|(
name|size_t
name|samplerIndex
init|=
name|samplerRange
init|;
name|samplerIndex
operator|<
name|samplerCount
condition|;
name|samplerIndex
operator|++
control|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|setTexture
argument_list|(
name|shaderType
argument_list|,
name|samplerIndex
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|applyTextures
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|applyTextures
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|)
block|{
name|FramebufferTextureSerialArray
name|framebufferSerials
decl_stmt|;
name|size_t
name|framebufferSerialCount
init|=
name|getBoundFramebufferTextureSerials
argument_list|(
name|data
argument_list|,
operator|&
name|framebufferSerials
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|applyTextures
argument_list|(
name|data
argument_list|,
name|gl
operator|::
name|SAMPLER_VERTEX
argument_list|,
name|framebufferSerials
argument_list|,
name|framebufferSerialCount
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|applyTextures
argument_list|(
name|data
argument_list|,
name|gl
operator|::
name|SAMPLER_PIXEL
argument_list|,
name|framebufferSerials
argument_list|,
name|framebufferSerialCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|skipDraw
name|bool
name|RendererD3D
operator|::
name|skipDraw
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLenum
name|drawMode
parameter_list|)
block|{
if|if
condition|(
name|drawMode
operator|==
name|GL_POINTS
condition|)
block|{
comment|// ProgramBinary assumes non-point rendering if gl_PointSize isn't written,
comment|// which affects varying interpolation. Since the value of gl_PointSize is
comment|// undefined when not written, just skip drawing to avoid unexpected results.
if|if
condition|(
operator|!
name|data
operator|.
name|state
operator|->
name|getProgram
argument_list|()
operator|->
name|usesPointSize
argument_list|()
operator|&&
operator|!
name|data
operator|.
name|state
operator|->
name|isTransformFeedbackActiveUnpaused
argument_list|()
condition|)
block|{
comment|// This is stictly speaking not an error, but developers should be
comment|// notified of risking undefined behavior.
name|ERR
argument_list|(
literal|"Point rendering without writing to gl_PointSize."
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|gl
operator|::
name|IsTriangleMode
argument_list|(
name|drawMode
argument_list|)
condition|)
block|{
if|if
condition|(
name|data
operator|.
name|state
operator|->
name|getRasterizerState
argument_list|()
operator|.
name|cullFace
operator|&&
name|data
operator|.
name|state
operator|->
name|getRasterizerState
argument_list|()
operator|.
name|cullMode
operator|==
name|GL_FRONT_AND_BACK
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|function|markTransformFeedbackUsage
name|void
name|RendererD3D
operator|::
name|markTransformFeedbackUsage
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|)
block|{
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|data
operator|.
name|caps
operator|->
name|maxTransformFeedbackSeparateAttributes
condition|;
name|i
operator|++
control|)
block|{
name|gl
operator|::
name|Buffer
modifier|*
name|buffer
init|=
name|data
operator|.
name|state
operator|->
name|getIndexedTransformFeedbackBuffer
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|buffer
condition|)
block|{
name|BufferD3D
modifier|*
name|bufferD3D
init|=
name|GetImplAs
argument_list|<
name|BufferD3D
argument_list|>
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
name|bufferD3D
operator|->
name|markTransformFeedbackUsage
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|function|getBoundFramebufferTextureSerials
name|size_t
name|RendererD3D
operator|::
name|getBoundFramebufferTextureSerials
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|FramebufferTextureSerialArray
modifier|*
name|outSerialArray
parameter_list|)
block|{
name|size_t
name|serialCount
init|=
literal|0
decl_stmt|;
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|drawFramebuffer
init|=
name|data
operator|.
name|state
operator|->
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|data
operator|.
name|caps
operator|->
name|maxColorAttachments
condition|;
name|i
operator|++
control|)
block|{
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|attachment
init|=
name|drawFramebuffer
operator|->
name|getColorbuffer
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|attachment
operator|&&
name|attachment
operator|->
name|type
argument_list|()
operator|==
name|GL_TEXTURE
condition|)
block|{
name|gl
operator|::
name|Texture
modifier|*
name|texture
init|=
name|attachment
operator|->
name|getTexture
argument_list|()
decl_stmt|;
operator|(
operator|*
name|outSerialArray
operator|)
index|[
name|serialCount
operator|++
index|]
operator|=
name|texture
operator|->
name|getTextureSerial
argument_list|()
expr_stmt|;
block|}
block|}
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|depthStencilAttachment
init|=
name|drawFramebuffer
operator|->
name|getDepthOrStencilbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|depthStencilAttachment
operator|&&
name|depthStencilAttachment
operator|->
name|type
argument_list|()
operator|==
name|GL_TEXTURE
condition|)
block|{
name|gl
operator|::
name|Texture
modifier|*
name|depthStencilTexture
init|=
name|depthStencilAttachment
operator|->
name|getTexture
argument_list|()
decl_stmt|;
operator|(
operator|*
name|outSerialArray
operator|)
index|[
name|serialCount
operator|++
index|]
operator|=
name|depthStencilTexture
operator|->
name|getTextureSerial
argument_list|()
expr_stmt|;
block|}
name|std
operator|::
name|sort
argument_list|(
name|outSerialArray
operator|->
name|begin
argument_list|()
argument_list|,
name|outSerialArray
operator|->
name|begin
argument_list|()
operator|+
name|serialCount
argument_list|)
expr_stmt|;
return|return
name|serialCount
return|;
block|}
DECL|function|getIncompleteTexture
name|gl
operator|::
name|Texture
modifier|*
name|RendererD3D
operator|::
name|getIncompleteTexture
parameter_list|(
name|GLenum
name|type
parameter_list|)
block|{
if|if
condition|(
name|mIncompleteTextures
operator|.
name|find
argument_list|(
name|type
argument_list|)
operator|==
name|mIncompleteTextures
operator|.
name|end
argument_list|()
condition|)
block|{
specifier|const
name|GLubyte
name|color
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|255
block|}
decl_stmt|;
specifier|const
name|gl
operator|::
name|Extents
name|colorSize
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|const
name|gl
operator|::
name|PixelUnpackState
name|incompleteUnpackState
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Texture
modifier|*
name|t
init|=
operator|new
name|gl
operator|::
name|Texture
argument_list|(
name|createTexture
argument_list|(
name|type
argument_list|)
argument_list|,
name|gl
operator|::
name|Texture
operator|::
name|INCOMPLETE_TEXTURE_ID
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|GL_TEXTURE_CUBE_MAP
condition|)
block|{
for|for
control|(
name|GLenum
name|face
init|=
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
init|;
name|face
operator|<=
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
condition|;
name|face
operator|++
control|)
block|{
name|t
operator|->
name|setImage
argument_list|(
name|face
argument_list|,
literal|0
argument_list|,
name|GL_RGBA
argument_list|,
name|colorSize
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
name|incompleteUnpackState
argument_list|,
name|color
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|t
operator|->
name|setImage
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|GL_RGBA
argument_list|,
name|colorSize
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
name|incompleteUnpackState
argument_list|,
name|color
argument_list|)
expr_stmt|;
block|}
name|mIncompleteTextures
index|[
name|type
index|]
operator|.
name|set
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|mIncompleteTextures
index|[
name|type
index|]
operator|.
name|get
argument_list|()
return|;
block|}
DECL|function|isDeviceLost
name|bool
name|RendererD3D
operator|::
name|isDeviceLost
parameter_list|()
specifier|const
block|{
return|return
name|mDeviceLost
return|;
block|}
DECL|function|notifyDeviceLost
name|void
name|RendererD3D
operator|::
name|notifyDeviceLost
parameter_list|()
block|{
name|mDeviceLost
operator|=
literal|true
expr_stmt|;
name|mDisplay
operator|->
name|notifyDeviceLost
argument_list|()
expr_stmt|;
block|}
DECL|function|getVendorString
name|std
operator|::
name|string
name|RendererD3D
operator|::
name|getVendorString
parameter_list|()
specifier|const
block|{
name|LUID
name|adapterLuid
init|=
block|{
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|getLUID
argument_list|(
operator|&
name|adapterLuid
argument_list|)
condition|)
block|{
name|char
name|adapterLuidString
index|[
literal|64
index|]
decl_stmt|;
name|sprintf_s
argument_list|(
name|adapterLuidString
argument_list|,
sizeof|sizeof
argument_list|(
name|adapterLuidString
argument_list|)
argument_list|,
literal|"(adapter LUID: %08x%08x)"
argument_list|,
name|adapterLuid
operator|.
name|HighPart
argument_list|,
name|adapterLuid
operator|.
name|LowPart
argument_list|)
expr_stmt|;
return|return
name|std
operator|::
name|string
argument_list|(
name|adapterLuidString
argument_list|)
return|;
block|}
return|return
name|std
operator|::
name|string
argument_list|(
literal|""
argument_list|)
return|;
block|}
DECL|function|getScratchMemoryBuffer
name|gl
operator|::
name|Error
name|RendererD3D
operator|::
name|getScratchMemoryBuffer
parameter_list|(
name|size_t
name|requestedSize
parameter_list|,
name|MemoryBuffer
modifier|*
modifier|*
name|bufferOut
parameter_list|)
block|{
if|if
condition|(
name|mScratchMemoryBuffer
operator|.
name|size
argument_list|()
operator|==
name|requestedSize
condition|)
block|{
name|mScratchMemoryBufferResetCounter
operator|=
name|ScratchMemoryBufferLifetime
expr_stmt|;
operator|*
name|bufferOut
operator|=
operator|&
name|mScratchMemoryBuffer
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
if|if
condition|(
name|mScratchMemoryBuffer
operator|.
name|size
argument_list|()
operator|>
name|requestedSize
condition|)
block|{
name|mScratchMemoryBufferResetCounter
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|mScratchMemoryBufferResetCounter
operator|<=
literal|0
operator|||
name|mScratchMemoryBuffer
operator|.
name|size
argument_list|()
operator|<
name|requestedSize
condition|)
block|{
name|mScratchMemoryBuffer
operator|.
name|resize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mScratchMemoryBuffer
operator|.
name|resize
argument_list|(
name|requestedSize
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to allocate internal buffer."
argument_list|)
return|;
block|}
name|mScratchMemoryBufferResetCounter
operator|=
name|ScratchMemoryBufferLifetime
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|mScratchMemoryBuffer
operator|.
name|size
argument_list|()
operator|>=
name|requestedSize
argument_list|)
expr_stmt|;
operator|*
name|bufferOut
operator|=
operator|&
name|mScratchMemoryBuffer
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
block|}
end_namespace
end_unit
