begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2013-2015 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// loadimage_etc.cpp: Decodes ETC and EAC encoded textures.
end_comment
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/loadimage_etc.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/loadimage.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/imageformats.h"
end_include
begin_namespace
DECL|namespace|rx
namespace|namespace
name|rx
block|{
namespace|namespace
block|{
comment|// Table 3.17.2 sorted according to table 3.17.3
comment|// clang-format off
DECL|member|intensityModifierDefault
specifier|static
specifier|const
name|int
name|intensityModifierDefault
index|[]
index|[
literal|4
index|]
init|=
block|{
block|{
literal|2
block|,
literal|8
block|,
operator|-
literal|2
block|,
operator|-
literal|8
block|}
block|,
block|{
literal|5
block|,
literal|17
block|,
operator|-
literal|5
block|,
operator|-
literal|17
block|}
block|,
block|{
literal|9
block|,
literal|29
block|,
operator|-
literal|9
block|,
operator|-
literal|29
block|}
block|,
block|{
literal|13
block|,
literal|42
block|,
operator|-
literal|13
block|,
operator|-
literal|42
block|}
block|,
block|{
literal|18
block|,
literal|60
block|,
operator|-
literal|18
block|,
operator|-
literal|60
block|}
block|,
block|{
literal|24
block|,
literal|80
block|,
operator|-
literal|24
block|,
operator|-
literal|80
block|}
block|,
block|{
literal|33
block|,
literal|106
block|,
operator|-
literal|33
block|,
operator|-
literal|106
block|}
block|,
block|{
literal|47
block|,
literal|183
block|,
operator|-
literal|47
block|,
operator|-
literal|183
block|}
block|, }
decl_stmt|;
comment|// clang-format on
comment|// Table C.12, intensity modifier for non opaque punchthrough alpha
comment|// clang-format off
DECL|member|intensityModifierNonOpaque
specifier|static
specifier|const
name|int
name|intensityModifierNonOpaque
index|[]
index|[
literal|4
index|]
init|=
block|{
block|{
literal|0
block|,
literal|8
block|,
literal|0
block|,
operator|-
literal|8
block|}
block|,
block|{
literal|0
block|,
literal|17
block|,
literal|0
block|,
operator|-
literal|17
block|}
block|,
block|{
literal|0
block|,
literal|29
block|,
literal|0
block|,
operator|-
literal|29
block|}
block|,
block|{
literal|0
block|,
literal|42
block|,
literal|0
block|,
operator|-
literal|42
block|}
block|,
block|{
literal|0
block|,
literal|60
block|,
literal|0
block|,
operator|-
literal|60
block|}
block|,
block|{
literal|0
block|,
literal|80
block|,
literal|0
block|,
operator|-
literal|80
block|}
block|,
block|{
literal|0
block|,
literal|106
block|,
literal|0
block|,
operator|-
literal|106
block|}
block|,
block|{
literal|0
block|,
literal|183
block|,
literal|0
block|,
operator|-
literal|183
block|}
block|, }
decl_stmt|;
comment|// clang-format on
comment|// Table C.7, mapping from pixel index values to modifier value orders
comment|// clang-format off
DECL|member|valueMappingTable
specifier|static
specifier|const
name|int
name|valueMappingTable
index|[]
init|=
block|{
literal|2
block|,
literal|3
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
comment|// clang-format on
DECL|struct|ETC2Block
struct|struct
name|ETC2Block
block|{
comment|// Decodes unsigned single or dual channel block to bytes
DECL|function|decodeAsSingleChannel
name|void
name|decodeAsSingleChannel
parameter_list|(
name|uint8_t
modifier|*
name|dest
parameter_list|,
name|size_t
name|x
parameter_list|,
name|size_t
name|y
parameter_list|,
name|size_t
name|w
parameter_list|,
name|size_t
name|h
parameter_list|,
name|size_t
name|destPixelStride
parameter_list|,
name|size_t
name|destRowPitch
parameter_list|,
name|bool
name|isSigned
parameter_list|)
specifier|const
block|{
for|for
control|(
name|size_t
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|4
operator|&&
operator|(
name|y
operator|+
name|j
operator|)
operator|<
name|h
condition|;
name|j
operator|++
control|)
block|{
name|uint8_t
modifier|*
name|row
init|=
name|dest
operator|+
operator|(
name|j
operator|*
name|destRowPitch
operator|)
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
operator|&&
operator|(
name|x
operator|+
name|i
operator|)
operator|<
name|w
condition|;
name|i
operator|++
control|)
block|{
name|uint8_t
modifier|*
name|pixel
init|=
name|row
operator|+
operator|(
name|i
operator|*
name|destPixelStride
operator|)
decl_stmt|;
if|if
condition|(
name|isSigned
condition|)
block|{
operator|*
name|pixel
operator|=
name|clampSByte
argument_list|(
name|getSingleChannel
argument_list|(
name|i
argument_list|,
name|j
argument_list|,
name|isSigned
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|pixel
operator|=
name|clampByte
argument_list|(
name|getSingleChannel
argument_list|(
name|i
argument_list|,
name|j
argument_list|,
name|isSigned
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// Decodes RGB block to rgba8
DECL|function|decodeAsRGB
name|void
name|decodeAsRGB
parameter_list|(
name|uint8_t
modifier|*
name|dest
parameter_list|,
name|size_t
name|x
parameter_list|,
name|size_t
name|y
parameter_list|,
name|size_t
name|w
parameter_list|,
name|size_t
name|h
parameter_list|,
name|size_t
name|destRowPitch
parameter_list|,
specifier|const
name|uint8_t
name|alphaValues
index|[
literal|4
index|]
index|[
literal|4
index|]
parameter_list|,
name|bool
name|punchThroughAlpha
parameter_list|)
specifier|const
block|{
name|bool
name|opaqueBit
init|=
name|u
operator|.
name|idht
operator|.
name|mode
operator|.
name|idm
operator|.
name|diffbit
decl_stmt|;
name|bool
name|nonOpaquePunchThroughAlpha
init|=
name|punchThroughAlpha
operator|&&
operator|!
name|opaqueBit
decl_stmt|;
comment|// Select mode
if|if
condition|(
name|u
operator|.
name|idht
operator|.
name|mode
operator|.
name|idm
operator|.
name|diffbit
operator|||
name|punchThroughAlpha
condition|)
block|{
specifier|const
specifier|auto
modifier|&
name|block
init|=
name|u
operator|.
name|idht
operator|.
name|mode
operator|.
name|idm
operator|.
name|colors
operator|.
name|diff
decl_stmt|;
name|int
name|r
init|=
operator|(
name|block
operator|.
name|R
operator|+
name|block
operator|.
name|dR
operator|)
decl_stmt|;
name|int
name|g
init|=
operator|(
name|block
operator|.
name|G
operator|+
name|block
operator|.
name|dG
operator|)
decl_stmt|;
name|int
name|b
init|=
operator|(
name|block
operator|.
name|B
operator|+
name|block
operator|.
name|dB
operator|)
decl_stmt|;
if|if
condition|(
name|r
argument_list|<
literal|0
operator|||
name|r
argument_list|>
literal|31
condition|)
block|{
name|decodeTBlock
argument_list|(
name|dest
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|destRowPitch
argument_list|,
name|alphaValues
argument_list|,
name|nonOpaquePunchThroughAlpha
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|g
argument_list|<
literal|0
operator|||
name|g
argument_list|>
literal|31
condition|)
block|{
name|decodeHBlock
argument_list|(
name|dest
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|destRowPitch
argument_list|,
name|alphaValues
argument_list|,
name|nonOpaquePunchThroughAlpha
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
argument_list|<
literal|0
operator|||
name|b
argument_list|>
literal|31
condition|)
block|{
name|decodePlanarBlock
argument_list|(
name|dest
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|destRowPitch
argument_list|,
name|alphaValues
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|decodeDifferentialBlock
argument_list|(
name|dest
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|destRowPitch
argument_list|,
name|alphaValues
argument_list|,
name|nonOpaquePunchThroughAlpha
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|decodeIndividualBlock
argument_list|(
name|dest
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|destRowPitch
argument_list|,
name|alphaValues
argument_list|,
name|nonOpaquePunchThroughAlpha
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Transcodes RGB block to BC1
DECL|function|transcodeAsBC1
name|void
name|transcodeAsBC1
parameter_list|(
name|uint8_t
modifier|*
name|dest
parameter_list|,
name|size_t
name|x
parameter_list|,
name|size_t
name|y
parameter_list|,
name|size_t
name|w
parameter_list|,
name|size_t
name|h
parameter_list|,
specifier|const
name|uint8_t
name|alphaValues
index|[
literal|4
index|]
index|[
literal|4
index|]
parameter_list|,
name|bool
name|punchThroughAlpha
parameter_list|)
specifier|const
block|{
name|bool
name|opaqueBit
init|=
name|u
operator|.
name|idht
operator|.
name|mode
operator|.
name|idm
operator|.
name|diffbit
decl_stmt|;
name|bool
name|nonOpaquePunchThroughAlpha
init|=
name|punchThroughAlpha
operator|&&
operator|!
name|opaqueBit
decl_stmt|;
comment|// Select mode
if|if
condition|(
name|u
operator|.
name|idht
operator|.
name|mode
operator|.
name|idm
operator|.
name|diffbit
operator|||
name|punchThroughAlpha
condition|)
block|{
specifier|const
specifier|auto
modifier|&
name|block
init|=
name|u
operator|.
name|idht
operator|.
name|mode
operator|.
name|idm
operator|.
name|colors
operator|.
name|diff
decl_stmt|;
name|int
name|r
init|=
operator|(
name|block
operator|.
name|R
operator|+
name|block
operator|.
name|dR
operator|)
decl_stmt|;
name|int
name|g
init|=
operator|(
name|block
operator|.
name|G
operator|+
name|block
operator|.
name|dG
operator|)
decl_stmt|;
name|int
name|b
init|=
operator|(
name|block
operator|.
name|B
operator|+
name|block
operator|.
name|dB
operator|)
decl_stmt|;
if|if
condition|(
name|r
argument_list|<
literal|0
operator|||
name|r
argument_list|>
literal|31
condition|)
block|{
name|transcodeTBlockToBC1
argument_list|(
name|dest
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|alphaValues
argument_list|,
name|nonOpaquePunchThroughAlpha
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|g
argument_list|<
literal|0
operator|||
name|g
argument_list|>
literal|31
condition|)
block|{
name|transcodeHBlockToBC1
argument_list|(
name|dest
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|alphaValues
argument_list|,
name|nonOpaquePunchThroughAlpha
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
argument_list|<
literal|0
operator|||
name|b
argument_list|>
literal|31
condition|)
block|{
name|transcodePlanarBlockToBC1
argument_list|(
name|dest
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|alphaValues
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|transcodeDifferentialBlockToBC1
argument_list|(
name|dest
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|alphaValues
argument_list|,
name|nonOpaquePunchThroughAlpha
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|transcodeIndividualBlockToBC1
argument_list|(
name|dest
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|alphaValues
argument_list|,
name|nonOpaquePunchThroughAlpha
argument_list|)
expr_stmt|;
block|}
block|}
private|private:
union|union
block|{
comment|// Individual, differential, H and T modes
struct|struct
block|{
union|union
block|{
comment|// Individual and differential modes
struct|struct
block|{
union|union
block|{
struct|struct
comment|// Individual colors
block|{
DECL|member|R2
name|unsigned
name|char
name|R2
range|:
literal|4
decl_stmt|;
DECL|member|R1
name|unsigned
name|char
name|R1
range|:
literal|4
decl_stmt|;
DECL|member|G2
name|unsigned
name|char
name|G2
range|:
literal|4
decl_stmt|;
DECL|member|G1
name|unsigned
name|char
name|G1
range|:
literal|4
decl_stmt|;
DECL|member|B2
name|unsigned
name|char
name|B2
range|:
literal|4
decl_stmt|;
DECL|member|B1
name|unsigned
name|char
name|B1
range|:
literal|4
decl_stmt|;
DECL|member|indiv
block|}
name|indiv
struct|;
struct|struct
comment|// Differential colors
block|{
DECL|member|dR
name|signed
name|char
name|dR
range|:
literal|3
decl_stmt|;
DECL|member|R
name|unsigned
name|char
name|R
range|:
literal|5
decl_stmt|;
DECL|member|dG
name|signed
name|char
name|dG
range|:
literal|3
decl_stmt|;
DECL|member|G
name|unsigned
name|char
name|G
range|:
literal|5
decl_stmt|;
DECL|member|dB
name|signed
name|char
name|dB
range|:
literal|3
decl_stmt|;
DECL|member|B
name|unsigned
name|char
name|B
range|:
literal|5
decl_stmt|;
DECL|member|diff
block|}
name|diff
struct|;
DECL|member|colors
block|}
name|colors
union|;
DECL|member|flipbit
name|bool
name|flipbit
range|:
literal|1
decl_stmt|;
DECL|member|diffbit
name|bool
name|diffbit
range|:
literal|1
decl_stmt|;
DECL|member|cw2
name|unsigned
name|char
name|cw2
range|:
literal|3
decl_stmt|;
DECL|member|cw1
name|unsigned
name|char
name|cw1
range|:
literal|3
decl_stmt|;
DECL|member|idm
block|}
name|idm
struct|;
comment|// T mode
struct|struct
block|{
comment|// Byte 1
DECL|member|TR1b
name|unsigned
name|char
name|TR1b
range|:
literal|2
decl_stmt|;
DECL|member|TdummyB
name|unsigned
name|char
name|TdummyB
range|:
literal|1
decl_stmt|;
DECL|member|TR1a
name|unsigned
name|char
name|TR1a
range|:
literal|2
decl_stmt|;
DECL|member|TdummyA
name|unsigned
name|char
name|TdummyA
range|:
literal|3
decl_stmt|;
comment|// Byte 2
DECL|member|TB1
name|unsigned
name|char
name|TB1
range|:
literal|4
decl_stmt|;
DECL|member|TG1
name|unsigned
name|char
name|TG1
range|:
literal|4
decl_stmt|;
comment|// Byte 3
DECL|member|TG2
name|unsigned
name|char
name|TG2
range|:
literal|4
decl_stmt|;
DECL|member|TR2
name|unsigned
name|char
name|TR2
range|:
literal|4
decl_stmt|;
comment|// Byte 4
DECL|member|Tdb
name|unsigned
name|char
name|Tdb
range|:
literal|1
decl_stmt|;
DECL|member|Tflipbit
name|bool
name|Tflipbit
range|:
literal|1
decl_stmt|;
DECL|member|Tda
name|unsigned
name|char
name|Tda
range|:
literal|2
decl_stmt|;
DECL|member|TB2
name|unsigned
name|char
name|TB2
range|:
literal|4
decl_stmt|;
DECL|member|tm
block|}
name|tm
struct|;
comment|// H mode
struct|struct
block|{
comment|// Byte 1
DECL|member|HG1a
name|unsigned
name|char
name|HG1a
range|:
literal|3
decl_stmt|;
DECL|member|HR1
name|unsigned
name|char
name|HR1
range|:
literal|4
decl_stmt|;
DECL|member|HdummyA
name|unsigned
name|char
name|HdummyA
range|:
literal|1
decl_stmt|;
comment|// Byte 2
DECL|member|HB1b
name|unsigned
name|char
name|HB1b
range|:
literal|2
decl_stmt|;
DECL|member|HdummyC
name|unsigned
name|char
name|HdummyC
range|:
literal|1
decl_stmt|;
DECL|member|HB1a
name|unsigned
name|char
name|HB1a
range|:
literal|1
decl_stmt|;
DECL|member|HG1b
name|unsigned
name|char
name|HG1b
range|:
literal|1
decl_stmt|;
DECL|member|HdummyB
name|unsigned
name|char
name|HdummyB
range|:
literal|3
decl_stmt|;
comment|// Byte 3
DECL|member|HG2a
name|unsigned
name|char
name|HG2a
range|:
literal|3
decl_stmt|;
DECL|member|HR2
name|unsigned
name|char
name|HR2
range|:
literal|4
decl_stmt|;
DECL|member|HB1c
name|unsigned
name|char
name|HB1c
range|:
literal|1
decl_stmt|;
comment|// Byte 4
DECL|member|Hdb
name|unsigned
name|char
name|Hdb
range|:
literal|1
decl_stmt|;
DECL|member|Hflipbit
name|bool
name|Hflipbit
range|:
literal|1
decl_stmt|;
DECL|member|Hda
name|unsigned
name|char
name|Hda
range|:
literal|1
decl_stmt|;
DECL|member|HB2
name|unsigned
name|char
name|HB2
range|:
literal|4
decl_stmt|;
DECL|member|HG2b
name|unsigned
name|char
name|HG2b
range|:
literal|1
decl_stmt|;
DECL|member|hm
block|}
name|hm
struct|;
DECL|member|mode
block|}
name|mode
union|;
DECL|member|pixelIndexMSB
name|unsigned
name|char
name|pixelIndexMSB
index|[
literal|2
index|]
decl_stmt|;
DECL|member|pixelIndexLSB
name|unsigned
name|char
name|pixelIndexLSB
index|[
literal|2
index|]
decl_stmt|;
DECL|member|idht
block|}
name|idht
struct|;
comment|// planar mode
struct|struct
block|{
comment|// Byte 1
DECL|member|GO1
name|unsigned
name|char
name|GO1
range|:
literal|1
decl_stmt|;
DECL|member|RO
name|unsigned
name|char
name|RO
range|:
literal|6
decl_stmt|;
DECL|member|PdummyA
name|unsigned
name|char
name|PdummyA
range|:
literal|1
decl_stmt|;
comment|// Byte 2
DECL|member|BO1
name|unsigned
name|char
name|BO1
range|:
literal|1
decl_stmt|;
DECL|member|GO2
name|unsigned
name|char
name|GO2
range|:
literal|6
decl_stmt|;
DECL|member|PdummyB
name|unsigned
name|char
name|PdummyB
range|:
literal|1
decl_stmt|;
comment|// Byte 3
DECL|member|BO3a
name|unsigned
name|char
name|BO3a
range|:
literal|2
decl_stmt|;
DECL|member|PdummyD
name|unsigned
name|char
name|PdummyD
range|:
literal|1
decl_stmt|;
DECL|member|BO2
name|unsigned
name|char
name|BO2
range|:
literal|2
decl_stmt|;
DECL|member|PdummyC
name|unsigned
name|char
name|PdummyC
range|:
literal|3
decl_stmt|;
comment|// Byte 4
DECL|member|RH2
name|unsigned
name|char
name|RH2
range|:
literal|1
decl_stmt|;
DECL|member|Pflipbit
name|bool
name|Pflipbit
range|:
literal|1
decl_stmt|;
DECL|member|RH1
name|unsigned
name|char
name|RH1
range|:
literal|5
decl_stmt|;
DECL|member|BO3b
name|unsigned
name|char
name|BO3b
range|:
literal|1
decl_stmt|;
comment|// Byte 5
DECL|member|BHa
name|unsigned
name|char
name|BHa
range|:
literal|1
decl_stmt|;
DECL|member|GH
name|unsigned
name|char
name|GH
range|:
literal|7
decl_stmt|;
comment|// Byte 6
DECL|member|RVa
name|unsigned
name|char
name|RVa
range|:
literal|3
decl_stmt|;
DECL|member|BHb
name|unsigned
name|char
name|BHb
range|:
literal|5
decl_stmt|;
comment|// Byte 7
DECL|member|GVa
name|unsigned
name|char
name|GVa
range|:
literal|5
decl_stmt|;
DECL|member|RVb
name|unsigned
name|char
name|RVb
range|:
literal|3
decl_stmt|;
comment|// Byte 8
DECL|member|BV
name|unsigned
name|char
name|BV
range|:
literal|6
decl_stmt|;
DECL|member|GVb
name|unsigned
name|char
name|GVb
range|:
literal|2
decl_stmt|;
DECL|member|pblk
block|}
name|pblk
struct|;
comment|// Single channel block
struct|struct
block|{
union|union
block|{
DECL|member|us
name|unsigned
name|char
name|us
decl_stmt|;
DECL|member|s
name|signed
name|char
name|s
decl_stmt|;
DECL|member|base_codeword
block|}
name|base_codeword
union|;
DECL|member|table_index
name|unsigned
name|char
name|table_index
range|:
literal|4
decl_stmt|;
DECL|member|multiplier
name|unsigned
name|char
name|multiplier
range|:
literal|4
decl_stmt|;
DECL|member|mc1
name|unsigned
name|char
name|mc1
range|:
literal|2
decl_stmt|;
DECL|member|mb
name|unsigned
name|char
name|mb
range|:
literal|3
decl_stmt|;
DECL|member|ma
name|unsigned
name|char
name|ma
range|:
literal|3
decl_stmt|;
DECL|member|mf1
name|unsigned
name|char
name|mf1
range|:
literal|1
decl_stmt|;
DECL|member|me
name|unsigned
name|char
name|me
range|:
literal|3
decl_stmt|;
DECL|member|md
name|unsigned
name|char
name|md
range|:
literal|3
decl_stmt|;
DECL|member|mc2
name|unsigned
name|char
name|mc2
range|:
literal|1
decl_stmt|;
DECL|member|mh
name|unsigned
name|char
name|mh
range|:
literal|3
decl_stmt|;
DECL|member|mg
name|unsigned
name|char
name|mg
range|:
literal|3
decl_stmt|;
DECL|member|mf2
name|unsigned
name|char
name|mf2
range|:
literal|2
decl_stmt|;
DECL|member|mk1
name|unsigned
name|char
name|mk1
range|:
literal|2
decl_stmt|;
DECL|member|mj
name|unsigned
name|char
name|mj
range|:
literal|3
decl_stmt|;
DECL|member|mi
name|unsigned
name|char
name|mi
range|:
literal|3
decl_stmt|;
DECL|member|mn1
name|unsigned
name|char
name|mn1
range|:
literal|1
decl_stmt|;
DECL|member|mm
name|unsigned
name|char
name|mm
range|:
literal|3
decl_stmt|;
DECL|member|ml
name|unsigned
name|char
name|ml
range|:
literal|3
decl_stmt|;
DECL|member|mk2
name|unsigned
name|char
name|mk2
range|:
literal|1
decl_stmt|;
DECL|member|mp
name|unsigned
name|char
name|mp
range|:
literal|3
decl_stmt|;
DECL|member|mo
name|unsigned
name|char
name|mo
range|:
literal|3
decl_stmt|;
DECL|member|mn2
name|unsigned
name|char
name|mn2
range|:
literal|2
decl_stmt|;
DECL|member|scblk
block|}
name|scblk
struct|;
DECL|member|u
block|}
name|u
union|;
DECL|function|clampByte
specifier|static
name|unsigned
name|char
name|clampByte
parameter_list|(
name|int
name|value
parameter_list|)
block|{
return|return
cast|static_cast
argument_list|<
name|unsigned
name|char
argument_list|>
argument_list|(
name|gl
operator|::
name|clamp
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
argument_list|)
return|;
block|}
DECL|function|clampSByte
specifier|static
name|signed
name|char
name|clampSByte
parameter_list|(
name|int
name|value
parameter_list|)
block|{
return|return
cast|static_cast
argument_list|<
name|signed
name|char
argument_list|>
argument_list|(
name|gl
operator|::
name|clamp
argument_list|(
name|value
argument_list|,
operator|-
literal|128
argument_list|,
literal|127
argument_list|)
argument_list|)
return|;
block|}
DECL|function|createRGBA
specifier|static
name|R8G8B8A8
name|createRGBA
parameter_list|(
name|int
name|red
parameter_list|,
name|int
name|green
parameter_list|,
name|int
name|blue
parameter_list|,
name|int
name|alpha
parameter_list|)
block|{
name|R8G8B8A8
name|rgba
decl_stmt|;
name|rgba
operator|.
name|R
operator|=
name|clampByte
argument_list|(
name|red
argument_list|)
expr_stmt|;
name|rgba
operator|.
name|G
operator|=
name|clampByte
argument_list|(
name|green
argument_list|)
expr_stmt|;
name|rgba
operator|.
name|B
operator|=
name|clampByte
argument_list|(
name|blue
argument_list|)
expr_stmt|;
name|rgba
operator|.
name|A
operator|=
name|clampByte
argument_list|(
name|alpha
argument_list|)
expr_stmt|;
return|return
name|rgba
return|;
block|}
DECL|function|createRGBA
specifier|static
name|R8G8B8A8
name|createRGBA
parameter_list|(
name|int
name|red
parameter_list|,
name|int
name|green
parameter_list|,
name|int
name|blue
parameter_list|)
block|{
return|return
name|createRGBA
argument_list|(
name|red
argument_list|,
name|green
argument_list|,
name|blue
argument_list|,
literal|255
argument_list|)
return|;
block|}
DECL|function|extend_4to8bits
specifier|static
name|int
name|extend_4to8bits
parameter_list|(
name|int
name|x
parameter_list|)
block|{
return|return
operator|(
name|x
operator|<<
literal|4
operator|)
operator||
name|x
return|;
block|}
DECL|function|extend_5to8bits
specifier|static
name|int
name|extend_5to8bits
parameter_list|(
name|int
name|x
parameter_list|)
block|{
return|return
operator|(
name|x
operator|<<
literal|3
operator|)
operator||
operator|(
name|x
operator|>>
literal|2
operator|)
return|;
block|}
DECL|function|extend_6to8bits
specifier|static
name|int
name|extend_6to8bits
parameter_list|(
name|int
name|x
parameter_list|)
block|{
return|return
operator|(
name|x
operator|<<
literal|2
operator|)
operator||
operator|(
name|x
operator|>>
literal|4
operator|)
return|;
block|}
DECL|function|extend_7to8bits
specifier|static
name|int
name|extend_7to8bits
parameter_list|(
name|int
name|x
parameter_list|)
block|{
return|return
operator|(
name|x
operator|<<
literal|1
operator|)
operator||
operator|(
name|x
operator|>>
literal|6
operator|)
return|;
block|}
DECL|function|decodeIndividualBlock
name|void
name|decodeIndividualBlock
parameter_list|(
name|uint8_t
modifier|*
name|dest
parameter_list|,
name|size_t
name|x
parameter_list|,
name|size_t
name|y
parameter_list|,
name|size_t
name|w
parameter_list|,
name|size_t
name|h
parameter_list|,
name|size_t
name|destRowPitch
parameter_list|,
specifier|const
name|uint8_t
name|alphaValues
index|[
literal|4
index|]
index|[
literal|4
index|]
parameter_list|,
name|bool
name|nonOpaquePunchThroughAlpha
parameter_list|)
specifier|const
block|{
specifier|const
specifier|auto
modifier|&
name|block
init|=
name|u
operator|.
name|idht
operator|.
name|mode
operator|.
name|idm
operator|.
name|colors
operator|.
name|indiv
decl_stmt|;
name|int
name|r1
init|=
name|extend_4to8bits
argument_list|(
name|block
operator|.
name|R1
argument_list|)
decl_stmt|;
name|int
name|g1
init|=
name|extend_4to8bits
argument_list|(
name|block
operator|.
name|G1
argument_list|)
decl_stmt|;
name|int
name|b1
init|=
name|extend_4to8bits
argument_list|(
name|block
operator|.
name|B1
argument_list|)
decl_stmt|;
name|int
name|r2
init|=
name|extend_4to8bits
argument_list|(
name|block
operator|.
name|R2
argument_list|)
decl_stmt|;
name|int
name|g2
init|=
name|extend_4to8bits
argument_list|(
name|block
operator|.
name|G2
argument_list|)
decl_stmt|;
name|int
name|b2
init|=
name|extend_4to8bits
argument_list|(
name|block
operator|.
name|B2
argument_list|)
decl_stmt|;
name|decodeIndividualOrDifferentialBlock
argument_list|(
name|dest
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|destRowPitch
argument_list|,
name|r1
argument_list|,
name|g1
argument_list|,
name|b1
argument_list|,
name|r2
argument_list|,
name|g2
argument_list|,
name|b2
argument_list|,
name|alphaValues
argument_list|,
name|nonOpaquePunchThroughAlpha
argument_list|)
expr_stmt|;
block|}
DECL|function|decodeDifferentialBlock
name|void
name|decodeDifferentialBlock
parameter_list|(
name|uint8_t
modifier|*
name|dest
parameter_list|,
name|size_t
name|x
parameter_list|,
name|size_t
name|y
parameter_list|,
name|size_t
name|w
parameter_list|,
name|size_t
name|h
parameter_list|,
name|size_t
name|destRowPitch
parameter_list|,
specifier|const
name|uint8_t
name|alphaValues
index|[
literal|4
index|]
index|[
literal|4
index|]
parameter_list|,
name|bool
name|nonOpaquePunchThroughAlpha
parameter_list|)
specifier|const
block|{
specifier|const
specifier|auto
modifier|&
name|block
init|=
name|u
operator|.
name|idht
operator|.
name|mode
operator|.
name|idm
operator|.
name|colors
operator|.
name|diff
decl_stmt|;
name|int
name|b1
init|=
name|extend_5to8bits
argument_list|(
name|block
operator|.
name|B
argument_list|)
decl_stmt|;
name|int
name|g1
init|=
name|extend_5to8bits
argument_list|(
name|block
operator|.
name|G
argument_list|)
decl_stmt|;
name|int
name|r1
init|=
name|extend_5to8bits
argument_list|(
name|block
operator|.
name|R
argument_list|)
decl_stmt|;
name|int
name|r2
init|=
name|extend_5to8bits
argument_list|(
name|block
operator|.
name|R
operator|+
name|block
operator|.
name|dR
argument_list|)
decl_stmt|;
name|int
name|g2
init|=
name|extend_5to8bits
argument_list|(
name|block
operator|.
name|G
operator|+
name|block
operator|.
name|dG
argument_list|)
decl_stmt|;
name|int
name|b2
init|=
name|extend_5to8bits
argument_list|(
name|block
operator|.
name|B
operator|+
name|block
operator|.
name|dB
argument_list|)
decl_stmt|;
name|decodeIndividualOrDifferentialBlock
argument_list|(
name|dest
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|destRowPitch
argument_list|,
name|r1
argument_list|,
name|g1
argument_list|,
name|b1
argument_list|,
name|r2
argument_list|,
name|g2
argument_list|,
name|b2
argument_list|,
name|alphaValues
argument_list|,
name|nonOpaquePunchThroughAlpha
argument_list|)
expr_stmt|;
block|}
DECL|function|decodeIndividualOrDifferentialBlock
name|void
name|decodeIndividualOrDifferentialBlock
parameter_list|(
name|uint8_t
modifier|*
name|dest
parameter_list|,
name|size_t
name|x
parameter_list|,
name|size_t
name|y
parameter_list|,
name|size_t
name|w
parameter_list|,
name|size_t
name|h
parameter_list|,
name|size_t
name|destRowPitch
parameter_list|,
name|int
name|r1
parameter_list|,
name|int
name|g1
parameter_list|,
name|int
name|b1
parameter_list|,
name|int
name|r2
parameter_list|,
name|int
name|g2
parameter_list|,
name|int
name|b2
parameter_list|,
specifier|const
name|uint8_t
name|alphaValues
index|[
literal|4
index|]
index|[
literal|4
index|]
parameter_list|,
name|bool
name|nonOpaquePunchThroughAlpha
parameter_list|)
specifier|const
block|{
specifier|const
specifier|auto
name|intensityModifier
init|=
name|nonOpaquePunchThroughAlpha
condition|?
name|intensityModifierNonOpaque
else|:
name|intensityModifierDefault
decl_stmt|;
name|R8G8B8A8
name|subblockColors0
index|[
literal|4
index|]
decl_stmt|;
name|R8G8B8A8
name|subblockColors1
index|[
literal|4
index|]
decl_stmt|;
for|for
control|(
name|size_t
name|modifierIdx
init|=
literal|0
init|;
name|modifierIdx
operator|<
literal|4
condition|;
name|modifierIdx
operator|++
control|)
block|{
specifier|const
name|int
name|i1
init|=
name|intensityModifier
index|[
name|u
operator|.
name|idht
operator|.
name|mode
operator|.
name|idm
operator|.
name|cw1
index|]
index|[
name|modifierIdx
index|]
decl_stmt|;
name|subblockColors0
index|[
name|modifierIdx
index|]
operator|=
name|createRGBA
argument_list|(
name|r1
operator|+
name|i1
argument_list|,
name|g1
operator|+
name|i1
argument_list|,
name|b1
operator|+
name|i1
argument_list|)
expr_stmt|;
specifier|const
name|int
name|i2
init|=
name|intensityModifier
index|[
name|u
operator|.
name|idht
operator|.
name|mode
operator|.
name|idm
operator|.
name|cw2
index|]
index|[
name|modifierIdx
index|]
decl_stmt|;
name|subblockColors1
index|[
name|modifierIdx
index|]
operator|=
name|createRGBA
argument_list|(
name|r2
operator|+
name|i2
argument_list|,
name|g2
operator|+
name|i2
argument_list|,
name|b2
operator|+
name|i2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|u
operator|.
name|idht
operator|.
name|mode
operator|.
name|idm
operator|.
name|flipbit
condition|)
block|{
name|uint8_t
modifier|*
name|curPixel
init|=
name|dest
decl_stmt|;
for|for
control|(
name|size_t
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|2
operator|&&
operator|(
name|y
operator|+
name|j
operator|)
operator|<
name|h
condition|;
name|j
operator|++
control|)
block|{
name|R8G8B8A8
modifier|*
name|row
init|=
cast|reinterpret_cast
argument_list|<
name|R8G8B8A8
operator|*
argument_list|>
argument_list|(
name|curPixel
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
operator|&&
operator|(
name|x
operator|+
name|i
operator|)
operator|<
name|w
condition|;
name|i
operator|++
control|)
block|{
name|row
index|[
name|i
index|]
operator|=
name|subblockColors0
index|[
name|getIndex
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
index|]
expr_stmt|;
name|row
index|[
name|i
index|]
operator|.
name|A
operator|=
name|alphaValues
index|[
name|j
index|]
index|[
name|i
index|]
expr_stmt|;
block|}
name|curPixel
operator|+=
name|destRowPitch
expr_stmt|;
block|}
for|for
control|(
name|size_t
name|j
init|=
literal|2
init|;
name|j
operator|<
literal|4
operator|&&
operator|(
name|y
operator|+
name|j
operator|)
operator|<
name|h
condition|;
name|j
operator|++
control|)
block|{
name|R8G8B8A8
modifier|*
name|row
init|=
cast|reinterpret_cast
argument_list|<
name|R8G8B8A8
operator|*
argument_list|>
argument_list|(
name|curPixel
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
operator|&&
operator|(
name|x
operator|+
name|i
operator|)
operator|<
name|w
condition|;
name|i
operator|++
control|)
block|{
name|row
index|[
name|i
index|]
operator|=
name|subblockColors1
index|[
name|getIndex
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
index|]
expr_stmt|;
name|row
index|[
name|i
index|]
operator|.
name|A
operator|=
name|alphaValues
index|[
name|j
index|]
index|[
name|i
index|]
expr_stmt|;
block|}
name|curPixel
operator|+=
name|destRowPitch
expr_stmt|;
block|}
block|}
else|else
block|{
name|uint8_t
modifier|*
name|curPixel
init|=
name|dest
decl_stmt|;
for|for
control|(
name|size_t
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|4
operator|&&
operator|(
name|y
operator|+
name|j
operator|)
operator|<
name|h
condition|;
name|j
operator|++
control|)
block|{
name|R8G8B8A8
modifier|*
name|row
init|=
cast|reinterpret_cast
argument_list|<
name|R8G8B8A8
operator|*
argument_list|>
argument_list|(
name|curPixel
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|2
operator|&&
operator|(
name|x
operator|+
name|i
operator|)
operator|<
name|w
condition|;
name|i
operator|++
control|)
block|{
name|row
index|[
name|i
index|]
operator|=
name|subblockColors0
index|[
name|getIndex
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
index|]
expr_stmt|;
name|row
index|[
name|i
index|]
operator|.
name|A
operator|=
name|alphaValues
index|[
name|j
index|]
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|size_t
name|i
init|=
literal|2
init|;
name|i
operator|<
literal|4
operator|&&
operator|(
name|x
operator|+
name|i
operator|)
operator|<
name|w
condition|;
name|i
operator|++
control|)
block|{
name|row
index|[
name|i
index|]
operator|=
name|subblockColors1
index|[
name|getIndex
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
index|]
expr_stmt|;
name|row
index|[
name|i
index|]
operator|.
name|A
operator|=
name|alphaValues
index|[
name|j
index|]
index|[
name|i
index|]
expr_stmt|;
block|}
name|curPixel
operator|+=
name|destRowPitch
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nonOpaquePunchThroughAlpha
condition|)
block|{
name|decodePunchThroughAlphaBlock
argument_list|(
name|dest
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|destRowPitch
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|decodeTBlock
name|void
name|decodeTBlock
parameter_list|(
name|uint8_t
modifier|*
name|dest
parameter_list|,
name|size_t
name|x
parameter_list|,
name|size_t
name|y
parameter_list|,
name|size_t
name|w
parameter_list|,
name|size_t
name|h
parameter_list|,
name|size_t
name|destRowPitch
parameter_list|,
specifier|const
name|uint8_t
name|alphaValues
index|[
literal|4
index|]
index|[
literal|4
index|]
parameter_list|,
name|bool
name|nonOpaquePunchThroughAlpha
parameter_list|)
specifier|const
block|{
comment|// Table C.8, distance index for T and H modes
specifier|const
specifier|auto
modifier|&
name|block
init|=
name|u
operator|.
name|idht
operator|.
name|mode
operator|.
name|tm
decl_stmt|;
name|int
name|r1
init|=
name|extend_4to8bits
argument_list|(
name|block
operator|.
name|TR1a
operator|<<
literal|2
operator||
name|block
operator|.
name|TR1b
argument_list|)
decl_stmt|;
name|int
name|g1
init|=
name|extend_4to8bits
argument_list|(
name|block
operator|.
name|TG1
argument_list|)
decl_stmt|;
name|int
name|b1
init|=
name|extend_4to8bits
argument_list|(
name|block
operator|.
name|TB1
argument_list|)
decl_stmt|;
name|int
name|r2
init|=
name|extend_4to8bits
argument_list|(
name|block
operator|.
name|TR2
argument_list|)
decl_stmt|;
name|int
name|g2
init|=
name|extend_4to8bits
argument_list|(
name|block
operator|.
name|TG2
argument_list|)
decl_stmt|;
name|int
name|b2
init|=
name|extend_4to8bits
argument_list|(
name|block
operator|.
name|TB2
argument_list|)
decl_stmt|;
specifier|static
name|int
name|distance
index|[
literal|8
index|]
init|=
block|{
literal|3
block|,
literal|6
block|,
literal|11
block|,
literal|16
block|,
literal|23
block|,
literal|32
block|,
literal|41
block|,
literal|64
block|}
decl_stmt|;
specifier|const
name|int
name|d
init|=
name|distance
index|[
name|block
operator|.
name|Tda
operator|<<
literal|1
operator||
name|block
operator|.
name|Tdb
index|]
decl_stmt|;
specifier|const
name|R8G8B8A8
name|paintColors
index|[
literal|4
index|]
init|=
block|{
name|createRGBA
argument_list|(
name|r1
argument_list|,
name|g1
argument_list|,
name|b1
argument_list|)
block|,
name|createRGBA
argument_list|(
name|r2
operator|+
name|d
argument_list|,
name|g2
operator|+
name|d
argument_list|,
name|b2
operator|+
name|d
argument_list|)
block|,
name|createRGBA
argument_list|(
name|r2
argument_list|,
name|g2
argument_list|,
name|b2
argument_list|)
block|,
name|createRGBA
argument_list|(
name|r2
operator|-
name|d
argument_list|,
name|g2
operator|-
name|d
argument_list|,
name|b2
operator|-
name|d
argument_list|)
block|,         }
decl_stmt|;
name|uint8_t
modifier|*
name|curPixel
init|=
name|dest
decl_stmt|;
for|for
control|(
name|size_t
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|4
operator|&&
operator|(
name|y
operator|+
name|j
operator|)
operator|<
name|h
condition|;
name|j
operator|++
control|)
block|{
name|R8G8B8A8
modifier|*
name|row
init|=
cast|reinterpret_cast
argument_list|<
name|R8G8B8A8
operator|*
argument_list|>
argument_list|(
name|curPixel
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
operator|&&
operator|(
name|x
operator|+
name|i
operator|)
operator|<
name|w
condition|;
name|i
operator|++
control|)
block|{
name|row
index|[
name|i
index|]
operator|=
name|paintColors
index|[
name|getIndex
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
index|]
expr_stmt|;
name|row
index|[
name|i
index|]
operator|.
name|A
operator|=
name|alphaValues
index|[
name|j
index|]
index|[
name|i
index|]
expr_stmt|;
block|}
name|curPixel
operator|+=
name|destRowPitch
expr_stmt|;
block|}
if|if
condition|(
name|nonOpaquePunchThroughAlpha
condition|)
block|{
name|decodePunchThroughAlphaBlock
argument_list|(
name|dest
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|destRowPitch
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|decodeHBlock
name|void
name|decodeHBlock
parameter_list|(
name|uint8_t
modifier|*
name|dest
parameter_list|,
name|size_t
name|x
parameter_list|,
name|size_t
name|y
parameter_list|,
name|size_t
name|w
parameter_list|,
name|size_t
name|h
parameter_list|,
name|size_t
name|destRowPitch
parameter_list|,
specifier|const
name|uint8_t
name|alphaValues
index|[
literal|4
index|]
index|[
literal|4
index|]
parameter_list|,
name|bool
name|nonOpaquePunchThroughAlpha
parameter_list|)
specifier|const
block|{
comment|// Table C.8, distance index for T and H modes
specifier|const
specifier|auto
modifier|&
name|block
init|=
name|u
operator|.
name|idht
operator|.
name|mode
operator|.
name|hm
decl_stmt|;
name|int
name|r1
init|=
name|extend_4to8bits
argument_list|(
name|block
operator|.
name|HR1
argument_list|)
decl_stmt|;
name|int
name|g1
init|=
name|extend_4to8bits
argument_list|(
name|block
operator|.
name|HG1a
operator|<<
literal|1
operator||
name|block
operator|.
name|HG1b
argument_list|)
decl_stmt|;
name|int
name|b1
init|=
name|extend_4to8bits
argument_list|(
name|block
operator|.
name|HB1a
operator|<<
literal|3
operator||
name|block
operator|.
name|HB1b
operator|<<
literal|1
operator||
name|block
operator|.
name|HB1c
argument_list|)
decl_stmt|;
name|int
name|r2
init|=
name|extend_4to8bits
argument_list|(
name|block
operator|.
name|HR2
argument_list|)
decl_stmt|;
name|int
name|g2
init|=
name|extend_4to8bits
argument_list|(
name|block
operator|.
name|HG2a
operator|<<
literal|1
operator||
name|block
operator|.
name|HG2b
argument_list|)
decl_stmt|;
name|int
name|b2
init|=
name|extend_4to8bits
argument_list|(
name|block
operator|.
name|HB2
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|int
name|distance
index|[
literal|8
index|]
init|=
block|{
literal|3
block|,
literal|6
block|,
literal|11
block|,
literal|16
block|,
literal|23
block|,
literal|32
block|,
literal|41
block|,
literal|64
block|}
decl_stmt|;
specifier|const
name|int
name|d
init|=
name|distance
index|[
operator|(
name|block
operator|.
name|Hda
operator|<<
literal|2
operator|)
operator||
operator|(
name|block
operator|.
name|Hdb
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|r1
operator|<<
literal|16
operator||
name|g1
operator|<<
literal|8
operator||
name|b1
operator|)
operator|>=
operator|(
name|r2
operator|<<
literal|16
operator||
name|g2
operator|<<
literal|8
operator||
name|b2
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
index|]
decl_stmt|;
specifier|const
name|R8G8B8A8
name|paintColors
index|[
literal|4
index|]
init|=
block|{
name|createRGBA
argument_list|(
name|r1
operator|+
name|d
argument_list|,
name|g1
operator|+
name|d
argument_list|,
name|b1
operator|+
name|d
argument_list|)
block|,
name|createRGBA
argument_list|(
name|r1
operator|-
name|d
argument_list|,
name|g1
operator|-
name|d
argument_list|,
name|b1
operator|-
name|d
argument_list|)
block|,
name|createRGBA
argument_list|(
name|r2
operator|+
name|d
argument_list|,
name|g2
operator|+
name|d
argument_list|,
name|b2
operator|+
name|d
argument_list|)
block|,
name|createRGBA
argument_list|(
name|r2
operator|-
name|d
argument_list|,
name|g2
operator|-
name|d
argument_list|,
name|b2
operator|-
name|d
argument_list|)
block|,         }
decl_stmt|;
name|uint8_t
modifier|*
name|curPixel
init|=
name|dest
decl_stmt|;
for|for
control|(
name|size_t
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|4
operator|&&
operator|(
name|y
operator|+
name|j
operator|)
operator|<
name|h
condition|;
name|j
operator|++
control|)
block|{
name|R8G8B8A8
modifier|*
name|row
init|=
cast|reinterpret_cast
argument_list|<
name|R8G8B8A8
operator|*
argument_list|>
argument_list|(
name|curPixel
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
operator|&&
operator|(
name|x
operator|+
name|i
operator|)
operator|<
name|w
condition|;
name|i
operator|++
control|)
block|{
name|row
index|[
name|i
index|]
operator|=
name|paintColors
index|[
name|getIndex
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
index|]
expr_stmt|;
name|row
index|[
name|i
index|]
operator|.
name|A
operator|=
name|alphaValues
index|[
name|j
index|]
index|[
name|i
index|]
expr_stmt|;
block|}
name|curPixel
operator|+=
name|destRowPitch
expr_stmt|;
block|}
if|if
condition|(
name|nonOpaquePunchThroughAlpha
condition|)
block|{
name|decodePunchThroughAlphaBlock
argument_list|(
name|dest
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|destRowPitch
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|decodePlanarBlock
name|void
name|decodePlanarBlock
parameter_list|(
name|uint8_t
modifier|*
name|dest
parameter_list|,
name|size_t
name|x
parameter_list|,
name|size_t
name|y
parameter_list|,
name|size_t
name|w
parameter_list|,
name|size_t
name|h
parameter_list|,
name|size_t
name|pitch
parameter_list|,
specifier|const
name|uint8_t
name|alphaValues
index|[
literal|4
index|]
index|[
literal|4
index|]
parameter_list|)
specifier|const
block|{
name|int
name|ro
init|=
name|extend_6to8bits
argument_list|(
name|u
operator|.
name|pblk
operator|.
name|RO
argument_list|)
decl_stmt|;
name|int
name|go
init|=
name|extend_7to8bits
argument_list|(
name|u
operator|.
name|pblk
operator|.
name|GO1
operator|<<
literal|6
operator||
name|u
operator|.
name|pblk
operator|.
name|GO2
argument_list|)
decl_stmt|;
name|int
name|bo
init|=
name|extend_6to8bits
argument_list|(
name|u
operator|.
name|pblk
operator|.
name|BO1
operator|<<
literal|5
operator||
name|u
operator|.
name|pblk
operator|.
name|BO2
operator|<<
literal|3
operator||
name|u
operator|.
name|pblk
operator|.
name|BO3a
operator|<<
literal|1
operator||
name|u
operator|.
name|pblk
operator|.
name|BO3b
argument_list|)
decl_stmt|;
name|int
name|rh
init|=
name|extend_6to8bits
argument_list|(
name|u
operator|.
name|pblk
operator|.
name|RH1
operator|<<
literal|1
operator||
name|u
operator|.
name|pblk
operator|.
name|RH2
argument_list|)
decl_stmt|;
name|int
name|gh
init|=
name|extend_7to8bits
argument_list|(
name|u
operator|.
name|pblk
operator|.
name|GH
argument_list|)
decl_stmt|;
name|int
name|bh
init|=
name|extend_6to8bits
argument_list|(
name|u
operator|.
name|pblk
operator|.
name|BHa
operator|<<
literal|5
operator||
name|u
operator|.
name|pblk
operator|.
name|BHb
argument_list|)
decl_stmt|;
name|int
name|rv
init|=
name|extend_6to8bits
argument_list|(
name|u
operator|.
name|pblk
operator|.
name|RVa
operator|<<
literal|3
operator||
name|u
operator|.
name|pblk
operator|.
name|RVb
argument_list|)
decl_stmt|;
name|int
name|gv
init|=
name|extend_7to8bits
argument_list|(
name|u
operator|.
name|pblk
operator|.
name|GVa
operator|<<
literal|2
operator||
name|u
operator|.
name|pblk
operator|.
name|GVb
argument_list|)
decl_stmt|;
name|int
name|bv
init|=
name|extend_6to8bits
argument_list|(
name|u
operator|.
name|pblk
operator|.
name|BV
argument_list|)
decl_stmt|;
name|uint8_t
modifier|*
name|curPixel
init|=
name|dest
decl_stmt|;
for|for
control|(
name|size_t
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|4
operator|&&
operator|(
name|y
operator|+
name|j
operator|)
operator|<
name|h
condition|;
name|j
operator|++
control|)
block|{
name|R8G8B8A8
modifier|*
name|row
init|=
cast|reinterpret_cast
argument_list|<
name|R8G8B8A8
operator|*
argument_list|>
argument_list|(
name|curPixel
argument_list|)
decl_stmt|;
name|int
name|ry
init|=
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|j
argument_list|)
operator|*
operator|(
name|rv
operator|-
name|ro
operator|)
operator|+
literal|2
decl_stmt|;
name|int
name|gy
init|=
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|j
argument_list|)
operator|*
operator|(
name|gv
operator|-
name|go
operator|)
operator|+
literal|2
decl_stmt|;
name|int
name|by
init|=
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|j
argument_list|)
operator|*
operator|(
name|bv
operator|-
name|bo
operator|)
operator|+
literal|2
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
operator|&&
operator|(
name|x
operator|+
name|i
operator|)
operator|<
name|w
condition|;
name|i
operator|++
control|)
block|{
name|row
index|[
name|i
index|]
operator|=
name|createRGBA
argument_list|(
operator|(
operator|(
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|i
argument_list|)
operator|*
operator|(
name|rh
operator|-
name|ro
operator|)
operator|+
name|ry
operator|)
operator|>>
literal|2
operator|)
operator|+
name|ro
argument_list|,
operator|(
operator|(
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|i
argument_list|)
operator|*
operator|(
name|gh
operator|-
name|go
operator|)
operator|+
name|gy
operator|)
operator|>>
literal|2
operator|)
operator|+
name|go
argument_list|,
operator|(
operator|(
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|i
argument_list|)
operator|*
operator|(
name|bh
operator|-
name|bo
operator|)
operator|+
name|by
operator|)
operator|>>
literal|2
operator|)
operator|+
name|bo
argument_list|,
name|alphaValues
index|[
name|j
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|curPixel
operator|+=
name|pitch
expr_stmt|;
block|}
block|}
comment|// Index for individual, differential, H and T modes
DECL|function|getIndex
name|size_t
name|getIndex
parameter_list|(
name|size_t
name|x
parameter_list|,
name|size_t
name|y
parameter_list|)
specifier|const
block|{
name|size_t
name|bitIndex
init|=
name|x
operator|*
literal|4
operator|+
name|y
decl_stmt|;
name|size_t
name|bitOffset
init|=
name|bitIndex
operator|&
literal|7
decl_stmt|;
name|size_t
name|lsb
init|=
operator|(
name|u
operator|.
name|idht
operator|.
name|pixelIndexLSB
index|[
literal|1
operator|-
operator|(
name|bitIndex
operator|>>
literal|3
operator|)
index|]
operator|>>
name|bitOffset
operator|)
operator|&
literal|1
decl_stmt|;
name|size_t
name|msb
init|=
operator|(
name|u
operator|.
name|idht
operator|.
name|pixelIndexMSB
index|[
literal|1
operator|-
operator|(
name|bitIndex
operator|>>
literal|3
operator|)
index|]
operator|>>
name|bitOffset
operator|)
operator|&
literal|1
decl_stmt|;
return|return
operator|(
name|msb
operator|<<
literal|1
operator|)
operator||
name|lsb
return|;
block|}
DECL|function|decodePunchThroughAlphaBlock
name|void
name|decodePunchThroughAlphaBlock
parameter_list|(
name|uint8_t
modifier|*
name|dest
parameter_list|,
name|size_t
name|x
parameter_list|,
name|size_t
name|y
parameter_list|,
name|size_t
name|w
parameter_list|,
name|size_t
name|h
parameter_list|,
name|size_t
name|destRowPitch
parameter_list|)
specifier|const
block|{
name|uint8_t
modifier|*
name|curPixel
init|=
name|dest
decl_stmt|;
for|for
control|(
name|size_t
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|4
operator|&&
operator|(
name|y
operator|+
name|j
operator|)
operator|<
name|h
condition|;
name|j
operator|++
control|)
block|{
name|R8G8B8A8
modifier|*
name|row
init|=
cast|reinterpret_cast
argument_list|<
name|R8G8B8A8
operator|*
argument_list|>
argument_list|(
name|curPixel
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
operator|&&
operator|(
name|x
operator|+
name|i
operator|)
operator|<
name|w
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|getIndex
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
operator|==
literal|2
condition|)
comment|//  msb == 1&& lsb == 0
block|{
name|row
index|[
name|i
index|]
operator|=
name|createRGBA
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|curPixel
operator|+=
name|destRowPitch
expr_stmt|;
block|}
block|}
DECL|function|RGB8ToRGB565
name|uint16_t
name|RGB8ToRGB565
parameter_list|(
specifier|const
name|R8G8B8A8
modifier|&
name|rgba
parameter_list|)
specifier|const
block|{
return|return
operator|(
cast|static_cast
argument_list|<
name|uint16_t
argument_list|>
argument_list|(
name|rgba
operator|.
name|R
operator|>>
literal|3
argument_list|)
operator|<<
literal|11
operator|)
operator||
operator|(
cast|static_cast
argument_list|<
name|uint16_t
argument_list|>
argument_list|(
name|rgba
operator|.
name|G
operator|>>
literal|2
argument_list|)
operator|<<
literal|5
operator|)
operator||
operator|(
cast|static_cast
argument_list|<
name|uint16_t
argument_list|>
argument_list|(
name|rgba
operator|.
name|B
operator|>>
literal|3
argument_list|)
operator|<<
literal|0
operator|)
return|;
block|}
DECL|function|matchBC1Bits
name|uint32_t
name|matchBC1Bits
parameter_list|(
specifier|const
name|R8G8B8A8
modifier|*
name|rgba
parameter_list|,
specifier|const
name|R8G8B8A8
modifier|&
name|minColor
parameter_list|,
specifier|const
name|R8G8B8A8
modifier|&
name|maxColor
parameter_list|,
name|bool
name|opaque
parameter_list|)
specifier|const
block|{
comment|// Project each pixel on the (maxColor, minColor) line to decide which
comment|// BC1 code to assign to it.
name|uint8_t
name|decodedColors
index|[
literal|2
index|]
index|[
literal|3
index|]
init|=
block|{
block|{
name|maxColor
operator|.
name|R
block|,
name|maxColor
operator|.
name|G
block|,
name|maxColor
operator|.
name|B
block|}
block|,
block|{
name|minColor
operator|.
name|R
block|,
name|minColor
operator|.
name|G
block|,
name|minColor
operator|.
name|B
block|}
block|}
decl_stmt|;
name|int
name|direction
index|[
literal|3
index|]
decl_stmt|;
for|for
control|(
name|int
name|ch
init|=
literal|0
init|;
name|ch
operator|<
literal|3
condition|;
name|ch
operator|++
control|)
block|{
name|direction
index|[
name|ch
index|]
operator|=
name|decodedColors
index|[
literal|0
index|]
index|[
name|ch
index|]
operator|-
name|decodedColors
index|[
literal|1
index|]
index|[
name|ch
index|]
expr_stmt|;
block|}
name|int
name|stops
index|[
literal|2
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|stops
index|[
name|i
index|]
operator|=
name|decodedColors
index|[
name|i
index|]
index|[
literal|0
index|]
operator|*
name|direction
index|[
literal|0
index|]
operator|+
name|decodedColors
index|[
name|i
index|]
index|[
literal|1
index|]
operator|*
name|direction
index|[
literal|1
index|]
operator|+
name|decodedColors
index|[
name|i
index|]
index|[
literal|2
index|]
operator|*
name|direction
index|[
literal|2
index|]
expr_stmt|;
block|}
name|uint32_t
name|bits
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|opaque
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|15
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|// In opaque mode, the code is from 0 to 3.
name|bits
operator|<<=
literal|2
expr_stmt|;
specifier|const
name|int
name|dot
init|=
name|rgba
index|[
name|i
index|]
operator|.
name|R
operator|*
name|direction
index|[
literal|0
index|]
operator|+
name|rgba
index|[
name|i
index|]
operator|.
name|G
operator|*
name|direction
index|[
literal|1
index|]
operator|+
name|rgba
index|[
name|i
index|]
operator|.
name|B
operator|*
name|direction
index|[
literal|2
index|]
decl_stmt|;
specifier|const
name|int
name|factor
init|=
name|gl
operator|::
name|clamp
argument_list|(
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
operator|(
cast|static_cast
argument_list|<
name|float
argument_list|>
argument_list|(
name|dot
operator|-
name|stops
index|[
literal|1
index|]
argument_list|)
operator|/
operator|(
name|stops
index|[
literal|0
index|]
operator|-
name|stops
index|[
literal|1
index|]
operator|)
operator|)
operator|*
literal|3
operator|+
literal|0.5f
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|factor
condition|)
block|{
case|case
literal|0
case|:
name|bits
operator||=
literal|1
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|bits
operator||=
literal|3
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|bits
operator||=
literal|2
expr_stmt|;
break|break;
case|case
literal|3
case|:
default|default:
name|bits
operator||=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|15
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|// In non-opaque mode, 3 is for tranparent pixels.
name|bits
operator|<<=
literal|2
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|rgba
index|[
name|i
index|]
operator|.
name|A
condition|)
block|{
name|bits
operator||=
literal|3
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|int
name|dot
init|=
name|rgba
index|[
name|i
index|]
operator|.
name|R
operator|*
name|direction
index|[
literal|0
index|]
operator|+
name|rgba
index|[
name|i
index|]
operator|.
name|G
operator|*
name|direction
index|[
literal|1
index|]
operator|+
name|rgba
index|[
name|i
index|]
operator|.
name|B
operator|*
name|direction
index|[
literal|2
index|]
decl_stmt|;
specifier|const
name|int
name|factor
init|=
name|gl
operator|::
name|clamp
argument_list|(
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
operator|(
cast|static_cast
argument_list|<
name|float
argument_list|>
argument_list|(
name|dot
operator|-
name|stops
index|[
literal|1
index|]
argument_list|)
operator|/
operator|(
name|stops
index|[
literal|0
index|]
operator|-
name|stops
index|[
literal|1
index|]
operator|)
operator|)
operator|*
literal|2
operator|+
literal|0.5f
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|factor
condition|)
block|{
case|case
literal|0
case|:
name|bits
operator||=
literal|0
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|bits
operator||=
literal|2
expr_stmt|;
break|break;
case|case
literal|2
case|:
default|default:
name|bits
operator||=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
return|return
name|bits
return|;
block|}
DECL|function|packBC1
name|void
name|packBC1
parameter_list|(
name|void
modifier|*
name|bc1
parameter_list|,
specifier|const
name|R8G8B8A8
modifier|*
name|rgba
parameter_list|,
name|R8G8B8A8
modifier|&
name|minColor
parameter_list|,
name|R8G8B8A8
modifier|&
name|maxColor
parameter_list|,
name|bool
name|opaque
parameter_list|)
specifier|const
block|{
name|uint32_t
name|bits
decl_stmt|;
name|uint16_t
name|max16
init|=
name|RGB8ToRGB565
argument_list|(
name|maxColor
argument_list|)
decl_stmt|;
name|uint16_t
name|min16
init|=
name|RGB8ToRGB565
argument_list|(
name|minColor
argument_list|)
decl_stmt|;
if|if
condition|(
name|max16
operator|!=
name|min16
condition|)
block|{
comment|// Find the best BC1 code for each pixel
name|bits
operator|=
name|matchBC1Bits
argument_list|(
name|rgba
argument_list|,
name|minColor
argument_list|,
name|maxColor
argument_list|,
name|opaque
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Same colors, BC1 index 0 is the color in both opaque and transparent mode
name|bits
operator|=
literal|0
expr_stmt|;
comment|// BC1 index 3 is transparent
if|if
condition|(
operator|!
name|opaque
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
literal|0
operator|==
name|rgba
index|[
name|i
index|]
operator|.
name|A
condition|)
block|{
name|bits
operator||=
operator|(
literal|3
operator|<<
operator|(
name|i
operator|*
literal|2
operator|)
operator|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|max16
operator|<
name|min16
condition|)
block|{
name|std
operator|::
name|swap
argument_list|(
name|max16
argument_list|,
name|min16
argument_list|)
expr_stmt|;
name|uint32_t
name|xorMask
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|opaque
condition|)
block|{
comment|// In opaque mode switching the two colors is doing the
comment|// following code swaps: 0<-> 1 and 2<-> 3. This is
comment|// equivalent to flipping the first bit of each code
comment|// (5 = 0b0101)
name|xorMask
operator|=
literal|0x55555555
expr_stmt|;
block|}
else|else
block|{
comment|// In transparent mode switching the colors is doing the
comment|// following code swap: 0<-> 1. 0xA selects the second bit of
comment|// each code, bits>> 1 selects the first bit of the code when
comment|// the seconds bit is set (case 2 and 3). We invert all the
comment|// non-selected bits, that is the first bit when the code is
comment|// 0 or 1.
name|xorMask
operator|=
operator|~
operator|(
operator|(
name|bits
operator|>>
literal|1
operator|)
operator||
literal|0xAAAAAAAA
operator|)
expr_stmt|;
block|}
name|bits
operator|^=
name|xorMask
expr_stmt|;
block|}
struct|struct
name|BC1Block
block|{
name|uint16_t
name|color0
decl_stmt|;
name|uint16_t
name|color1
decl_stmt|;
name|uint32_t
name|bits
decl_stmt|;
block|}
struct|;
comment|// Encode the opaqueness in the order of the two BC1 colors
name|BC1Block
modifier|*
name|dest
init|=
cast|reinterpret_cast
argument_list|<
name|BC1Block
operator|*
argument_list|>
argument_list|(
name|bc1
argument_list|)
decl_stmt|;
if|if
condition|(
name|opaque
condition|)
block|{
name|dest
operator|->
name|color0
operator|=
name|max16
expr_stmt|;
name|dest
operator|->
name|color1
operator|=
name|min16
expr_stmt|;
block|}
else|else
block|{
name|dest
operator|->
name|color0
operator|=
name|min16
expr_stmt|;
name|dest
operator|->
name|color1
operator|=
name|max16
expr_stmt|;
block|}
name|dest
operator|->
name|bits
operator|=
name|bits
expr_stmt|;
block|}
DECL|function|transcodeIndividualBlockToBC1
name|void
name|transcodeIndividualBlockToBC1
parameter_list|(
name|uint8_t
modifier|*
name|dest
parameter_list|,
name|size_t
name|x
parameter_list|,
name|size_t
name|y
parameter_list|,
name|size_t
name|w
parameter_list|,
name|size_t
name|h
parameter_list|,
specifier|const
name|uint8_t
name|alphaValues
index|[
literal|4
index|]
index|[
literal|4
index|]
parameter_list|,
name|bool
name|nonOpaquePunchThroughAlpha
parameter_list|)
specifier|const
block|{
specifier|const
specifier|auto
modifier|&
name|block
init|=
name|u
operator|.
name|idht
operator|.
name|mode
operator|.
name|idm
operator|.
name|colors
operator|.
name|indiv
decl_stmt|;
name|int
name|r1
init|=
name|extend_4to8bits
argument_list|(
name|block
operator|.
name|R1
argument_list|)
decl_stmt|;
name|int
name|g1
init|=
name|extend_4to8bits
argument_list|(
name|block
operator|.
name|G1
argument_list|)
decl_stmt|;
name|int
name|b1
init|=
name|extend_4to8bits
argument_list|(
name|block
operator|.
name|B1
argument_list|)
decl_stmt|;
name|int
name|r2
init|=
name|extend_4to8bits
argument_list|(
name|block
operator|.
name|R2
argument_list|)
decl_stmt|;
name|int
name|g2
init|=
name|extend_4to8bits
argument_list|(
name|block
operator|.
name|G2
argument_list|)
decl_stmt|;
name|int
name|b2
init|=
name|extend_4to8bits
argument_list|(
name|block
operator|.
name|B2
argument_list|)
decl_stmt|;
name|transcodeIndividualOrDifferentialBlockToBC1
argument_list|(
name|dest
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|r1
argument_list|,
name|g1
argument_list|,
name|b1
argument_list|,
name|r2
argument_list|,
name|g2
argument_list|,
name|b2
argument_list|,
name|alphaValues
argument_list|,
name|nonOpaquePunchThroughAlpha
argument_list|)
expr_stmt|;
block|}
DECL|function|transcodeDifferentialBlockToBC1
name|void
name|transcodeDifferentialBlockToBC1
parameter_list|(
name|uint8_t
modifier|*
name|dest
parameter_list|,
name|size_t
name|x
parameter_list|,
name|size_t
name|y
parameter_list|,
name|size_t
name|w
parameter_list|,
name|size_t
name|h
parameter_list|,
specifier|const
name|uint8_t
name|alphaValues
index|[
literal|4
index|]
index|[
literal|4
index|]
parameter_list|,
name|bool
name|nonOpaquePunchThroughAlpha
parameter_list|)
specifier|const
block|{
specifier|const
specifier|auto
modifier|&
name|block
init|=
name|u
operator|.
name|idht
operator|.
name|mode
operator|.
name|idm
operator|.
name|colors
operator|.
name|diff
decl_stmt|;
name|int
name|b1
init|=
name|extend_5to8bits
argument_list|(
name|block
operator|.
name|B
argument_list|)
decl_stmt|;
name|int
name|g1
init|=
name|extend_5to8bits
argument_list|(
name|block
operator|.
name|G
argument_list|)
decl_stmt|;
name|int
name|r1
init|=
name|extend_5to8bits
argument_list|(
name|block
operator|.
name|R
argument_list|)
decl_stmt|;
name|int
name|r2
init|=
name|extend_5to8bits
argument_list|(
name|block
operator|.
name|R
operator|+
name|block
operator|.
name|dR
argument_list|)
decl_stmt|;
name|int
name|g2
init|=
name|extend_5to8bits
argument_list|(
name|block
operator|.
name|G
operator|+
name|block
operator|.
name|dG
argument_list|)
decl_stmt|;
name|int
name|b2
init|=
name|extend_5to8bits
argument_list|(
name|block
operator|.
name|B
operator|+
name|block
operator|.
name|dB
argument_list|)
decl_stmt|;
name|transcodeIndividualOrDifferentialBlockToBC1
argument_list|(
name|dest
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|r1
argument_list|,
name|g1
argument_list|,
name|b1
argument_list|,
name|r2
argument_list|,
name|g2
argument_list|,
name|b2
argument_list|,
name|alphaValues
argument_list|,
name|nonOpaquePunchThroughAlpha
argument_list|)
expr_stmt|;
block|}
DECL|function|decodeSubblock
name|void
name|decodeSubblock
parameter_list|(
name|R8G8B8A8
modifier|*
name|rgbaBlock
parameter_list|,
name|size_t
name|pixelRange
index|[
literal|2
index|]
index|[
literal|2
index|]
parameter_list|,
name|size_t
name|x
parameter_list|,
name|size_t
name|y
parameter_list|,
name|size_t
name|w
parameter_list|,
name|size_t
name|h
parameter_list|,
specifier|const
name|uint8_t
name|alphaValues
index|[
literal|4
index|]
index|[
literal|4
index|]
parameter_list|,
name|bool
name|flipbit
parameter_list|,
name|size_t
name|subblockIdx
parameter_list|,
specifier|const
name|R8G8B8A8
name|subblockColors
index|[
literal|2
index|]
index|[
literal|4
index|]
parameter_list|)
specifier|const
block|{
name|size_t
name|dxBegin
init|=
literal|0
decl_stmt|;
name|size_t
name|dxEnd
init|=
literal|4
decl_stmt|;
name|size_t
name|dyBegin
init|=
name|subblockIdx
operator|*
literal|2
decl_stmt|;
name|size_t
name|dyEnd
init|=
name|dyBegin
operator|+
literal|2
decl_stmt|;
if|if
condition|(
operator|!
name|flipbit
condition|)
block|{
name|std
operator|::
name|swap
argument_list|(
name|dxBegin
argument_list|,
name|dyBegin
argument_list|)
expr_stmt|;
name|std
operator|::
name|swap
argument_list|(
name|dxEnd
argument_list|,
name|dyEnd
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|size_t
name|j
init|=
name|dyBegin
init|;
name|j
operator|<
name|dyEnd
operator|&&
operator|(
name|y
operator|+
name|j
operator|)
operator|<
name|h
condition|;
name|j
operator|++
control|)
block|{
name|R8G8B8A8
modifier|*
name|row
init|=
operator|&
name|rgbaBlock
index|[
name|j
operator|*
literal|4
index|]
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
name|dxBegin
init|;
name|i
operator|<
name|dxEnd
operator|&&
operator|(
name|x
operator|+
name|i
operator|)
operator|<
name|w
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|size_t
name|pixelIndex
init|=
name|getIndex
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|valueMappingTable
index|[
name|pixelIndex
index|]
operator|<
name|valueMappingTable
index|[
name|pixelRange
index|[
name|subblockIdx
index|]
index|[
literal|0
index|]
index|]
condition|)
block|{
name|pixelRange
index|[
name|subblockIdx
index|]
index|[
literal|0
index|]
operator|=
name|pixelIndex
expr_stmt|;
block|}
if|if
condition|(
name|valueMappingTable
index|[
name|pixelIndex
index|]
operator|>
name|valueMappingTable
index|[
name|pixelRange
index|[
name|subblockIdx
index|]
index|[
literal|1
index|]
index|]
condition|)
block|{
name|pixelRange
index|[
name|subblockIdx
index|]
index|[
literal|1
index|]
operator|=
name|pixelIndex
expr_stmt|;
block|}
name|row
index|[
name|i
index|]
operator|=
name|subblockColors
index|[
name|subblockIdx
index|]
index|[
name|pixelIndex
index|]
expr_stmt|;
name|row
index|[
name|i
index|]
operator|.
name|A
operator|=
name|alphaValues
index|[
name|j
index|]
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
DECL|function|transcodeIndividualOrDifferentialBlockToBC1
name|void
name|transcodeIndividualOrDifferentialBlockToBC1
parameter_list|(
name|uint8_t
modifier|*
name|dest
parameter_list|,
name|size_t
name|x
parameter_list|,
name|size_t
name|y
parameter_list|,
name|size_t
name|w
parameter_list|,
name|size_t
name|h
parameter_list|,
name|int
name|r1
parameter_list|,
name|int
name|g1
parameter_list|,
name|int
name|b1
parameter_list|,
name|int
name|r2
parameter_list|,
name|int
name|g2
parameter_list|,
name|int
name|b2
parameter_list|,
specifier|const
name|uint8_t
name|alphaValues
index|[
literal|4
index|]
index|[
literal|4
index|]
parameter_list|,
name|bool
name|nonOpaquePunchThroughAlpha
parameter_list|)
specifier|const
block|{
comment|// A BC1 block has 2 endpoints, pixels is encoded as linear
comment|// interpolations of them. A ETC1/ETC2 individual or differential block
comment|// has 2 subblocks. Each subblock has one color and a modifier. We
comment|// compute the max intensity and min intensity pixel values to use as
comment|// our two BC1 endpoints and then map pixels to BC1 by projecting on the
comment|// line between the two endpoints and choosing the right fraction.
comment|//
comment|// In the future, we have 2 potential improvements to this algorithm.
comment|// 1. We don't actually need to decode ETC blocks to RGBs. Instead,
comment|//    the subblock colors and pixel indices alreay contains enough
comment|//    information for transcode. A direct mapping would be more
comment|//    efficient here.
comment|// 2. Currently the BC1 endpoints come from the max and min intensity
comment|//    of ETC colors. A principal component analysis (PCA) on them might
comment|//    give us better quality results, with limited costs
specifier|const
specifier|auto
name|intensityModifier
init|=
name|nonOpaquePunchThroughAlpha
condition|?
name|intensityModifierNonOpaque
else|:
name|intensityModifierDefault
decl_stmt|;
comment|// Compute the colors that pixels can have in each subblock both for
comment|// the decoding of the RGBA data and BC1 encoding
name|R8G8B8A8
name|subblockColors
index|[
literal|2
index|]
index|[
literal|4
index|]
decl_stmt|;
for|for
control|(
name|size_t
name|modifierIdx
init|=
literal|0
init|;
name|modifierIdx
operator|<
literal|4
condition|;
name|modifierIdx
operator|++
control|)
block|{
specifier|const
name|int
name|i1
init|=
name|intensityModifier
index|[
name|u
operator|.
name|idht
operator|.
name|mode
operator|.
name|idm
operator|.
name|cw1
index|]
index|[
name|modifierIdx
index|]
decl_stmt|;
name|subblockColors
index|[
literal|0
index|]
index|[
name|modifierIdx
index|]
operator|=
name|createRGBA
argument_list|(
name|r1
operator|+
name|i1
argument_list|,
name|g1
operator|+
name|i1
argument_list|,
name|b1
operator|+
name|i1
argument_list|)
expr_stmt|;
specifier|const
name|int
name|i2
init|=
name|intensityModifier
index|[
name|u
operator|.
name|idht
operator|.
name|mode
operator|.
name|idm
operator|.
name|cw2
index|]
index|[
name|modifierIdx
index|]
decl_stmt|;
name|subblockColors
index|[
literal|1
index|]
index|[
name|modifierIdx
index|]
operator|=
name|createRGBA
argument_list|(
name|r2
operator|+
name|i2
argument_list|,
name|g2
operator|+
name|i2
argument_list|,
name|b2
operator|+
name|i2
argument_list|)
expr_stmt|;
block|}
comment|// 1 and 3 are the argmax and argmin of valueMappingTable
name|size_t
name|pixelRange
index|[
literal|2
index|]
index|[
literal|2
index|]
init|=
block|{
block|{
literal|1
block|,
literal|3
block|}
block|,
block|{
literal|1
block|,
literal|3
block|}
block|}
decl_stmt|;
name|R8G8B8A8
name|rgbaBlock
index|[
literal|16
index|]
decl_stmt|;
comment|// Decode the block in rgbaBlock and store the inverse valueTableMapping
comment|// of {min(modifier index), max(modifier index)}
for|for
control|(
name|size_t
name|blockIdx
init|=
literal|0
init|;
name|blockIdx
operator|<
literal|2
condition|;
name|blockIdx
operator|++
control|)
block|{
name|decodeSubblock
argument_list|(
name|rgbaBlock
argument_list|,
name|pixelRange
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|alphaValues
argument_list|,
name|u
operator|.
name|idht
operator|.
name|mode
operator|.
name|idm
operator|.
name|flipbit
argument_list|,
name|blockIdx
argument_list|,
name|subblockColors
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nonOpaquePunchThroughAlpha
condition|)
block|{
name|decodePunchThroughAlphaBlock
argument_list|(
cast|reinterpret_cast
argument_list|<
name|uint8_t
operator|*
argument_list|>
argument_list|(
name|rgbaBlock
argument_list|)
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
sizeof|sizeof
argument_list|(
name|R8G8B8A8
argument_list|)
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
comment|// Get the "min" and "max" pixel colors that have been used.
name|R8G8B8A8
name|minColor
decl_stmt|;
specifier|const
name|R8G8B8A8
modifier|&
name|minColor0
init|=
name|subblockColors
index|[
literal|0
index|]
index|[
name|pixelRange
index|[
literal|0
index|]
index|[
literal|0
index|]
index|]
decl_stmt|;
specifier|const
name|R8G8B8A8
modifier|&
name|minColor1
init|=
name|subblockColors
index|[
literal|1
index|]
index|[
name|pixelRange
index|[
literal|1
index|]
index|[
literal|0
index|]
index|]
decl_stmt|;
if|if
condition|(
name|minColor0
operator|.
name|R
operator|+
name|minColor0
operator|.
name|G
operator|+
name|minColor0
operator|.
name|B
operator|<
name|minColor1
operator|.
name|R
operator|+
name|minColor1
operator|.
name|G
operator|+
name|minColor1
operator|.
name|B
condition|)
block|{
name|minColor
operator|=
name|minColor0
expr_stmt|;
block|}
else|else
block|{
name|minColor
operator|=
name|minColor1
expr_stmt|;
block|}
name|R8G8B8A8
name|maxColor
decl_stmt|;
specifier|const
name|R8G8B8A8
modifier|&
name|maxColor0
init|=
name|subblockColors
index|[
literal|0
index|]
index|[
name|pixelRange
index|[
literal|0
index|]
index|[
literal|1
index|]
index|]
decl_stmt|;
specifier|const
name|R8G8B8A8
modifier|&
name|maxColor1
init|=
name|subblockColors
index|[
literal|1
index|]
index|[
name|pixelRange
index|[
literal|1
index|]
index|[
literal|1
index|]
index|]
decl_stmt|;
if|if
condition|(
name|maxColor0
operator|.
name|R
operator|+
name|maxColor0
operator|.
name|G
operator|+
name|maxColor0
operator|.
name|B
operator|<
name|maxColor1
operator|.
name|R
operator|+
name|maxColor1
operator|.
name|G
operator|+
name|maxColor1
operator|.
name|B
condition|)
block|{
name|maxColor
operator|=
name|maxColor1
expr_stmt|;
block|}
else|else
block|{
name|maxColor
operator|=
name|maxColor0
expr_stmt|;
block|}
name|packBC1
argument_list|(
name|dest
argument_list|,
name|rgbaBlock
argument_list|,
name|minColor
argument_list|,
name|maxColor
argument_list|,
operator|!
name|nonOpaquePunchThroughAlpha
argument_list|)
expr_stmt|;
block|}
DECL|function|transcodeTBlockToBC1
name|void
name|transcodeTBlockToBC1
parameter_list|(
name|uint8_t
modifier|*
name|dest
parameter_list|,
name|size_t
name|x
parameter_list|,
name|size_t
name|y
parameter_list|,
name|size_t
name|w
parameter_list|,
name|size_t
name|h
parameter_list|,
specifier|const
name|uint8_t
name|alphaValues
index|[
literal|4
index|]
index|[
literal|4
index|]
parameter_list|,
name|bool
name|nonOpaquePunchThroughAlpha
parameter_list|)
specifier|const
block|{
comment|// TODO (mgong): Will be implemented soon
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
block|}
DECL|function|transcodeHBlockToBC1
name|void
name|transcodeHBlockToBC1
parameter_list|(
name|uint8_t
modifier|*
name|dest
parameter_list|,
name|size_t
name|x
parameter_list|,
name|size_t
name|y
parameter_list|,
name|size_t
name|w
parameter_list|,
name|size_t
name|h
parameter_list|,
specifier|const
name|uint8_t
name|alphaValues
index|[
literal|4
index|]
index|[
literal|4
index|]
parameter_list|,
name|bool
name|nonOpaquePunchThroughAlpha
parameter_list|)
specifier|const
block|{
comment|// TODO (mgong): Will be implemented soon
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
block|}
DECL|function|transcodePlanarBlockToBC1
name|void
name|transcodePlanarBlockToBC1
parameter_list|(
name|uint8_t
modifier|*
name|dest
parameter_list|,
name|size_t
name|x
parameter_list|,
name|size_t
name|y
parameter_list|,
name|size_t
name|w
parameter_list|,
name|size_t
name|h
parameter_list|,
specifier|const
name|uint8_t
name|alphaValues
index|[
literal|4
index|]
index|[
literal|4
index|]
parameter_list|)
specifier|const
block|{
comment|// TODO (mgong): Will be implemented soon
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
block|}
comment|// Single channel utility functions
DECL|function|getSingleChannel
name|int
name|getSingleChannel
parameter_list|(
name|size_t
name|x
parameter_list|,
name|size_t
name|y
parameter_list|,
name|bool
name|isSigned
parameter_list|)
specifier|const
block|{
name|int
name|codeword
init|=
name|isSigned
condition|?
name|u
operator|.
name|scblk
operator|.
name|base_codeword
operator|.
name|s
else|:
name|u
operator|.
name|scblk
operator|.
name|base_codeword
operator|.
name|us
decl_stmt|;
return|return
name|codeword
operator|+
name|getSingleChannelModifier
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|*
name|u
operator|.
name|scblk
operator|.
name|multiplier
return|;
block|}
DECL|function|getSingleChannelIndex
name|int
name|getSingleChannelIndex
parameter_list|(
name|size_t
name|x
parameter_list|,
name|size_t
name|y
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|x
operator|<
literal|4
operator|&&
name|y
operator|<
literal|4
argument_list|)
expr_stmt|;
comment|// clang-format off
switch|switch
condition|(
name|x
operator|*
literal|4
operator|+
name|y
condition|)
block|{
case|case
literal|0
case|:
return|return
name|u
operator|.
name|scblk
operator|.
name|ma
return|;
case|case
literal|1
case|:
return|return
name|u
operator|.
name|scblk
operator|.
name|mb
return|;
case|case
literal|2
case|:
return|return
name|u
operator|.
name|scblk
operator|.
name|mc1
operator|<<
literal|1
operator||
name|u
operator|.
name|scblk
operator|.
name|mc2
return|;
case|case
literal|3
case|:
return|return
name|u
operator|.
name|scblk
operator|.
name|md
return|;
case|case
literal|4
case|:
return|return
name|u
operator|.
name|scblk
operator|.
name|me
return|;
case|case
literal|5
case|:
return|return
name|u
operator|.
name|scblk
operator|.
name|mf1
operator|<<
literal|2
operator||
name|u
operator|.
name|scblk
operator|.
name|mf2
return|;
case|case
literal|6
case|:
return|return
name|u
operator|.
name|scblk
operator|.
name|mg
return|;
case|case
literal|7
case|:
return|return
name|u
operator|.
name|scblk
operator|.
name|mh
return|;
case|case
literal|8
case|:
return|return
name|u
operator|.
name|scblk
operator|.
name|mi
return|;
case|case
literal|9
case|:
return|return
name|u
operator|.
name|scblk
operator|.
name|mj
return|;
case|case
literal|10
case|:
return|return
name|u
operator|.
name|scblk
operator|.
name|mk1
operator|<<
literal|1
operator||
name|u
operator|.
name|scblk
operator|.
name|mk2
return|;
case|case
literal|11
case|:
return|return
name|u
operator|.
name|scblk
operator|.
name|ml
return|;
case|case
literal|12
case|:
return|return
name|u
operator|.
name|scblk
operator|.
name|mm
return|;
case|case
literal|13
case|:
return|return
name|u
operator|.
name|scblk
operator|.
name|mn1
operator|<<
literal|2
operator||
name|u
operator|.
name|scblk
operator|.
name|mn2
return|;
case|case
literal|14
case|:
return|return
name|u
operator|.
name|scblk
operator|.
name|mo
return|;
case|case
literal|15
case|:
return|return
name|u
operator|.
name|scblk
operator|.
name|mp
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|// clang-format on
block|}
DECL|function|getSingleChannelModifier
name|int
name|getSingleChannelModifier
parameter_list|(
name|size_t
name|x
parameter_list|,
name|size_t
name|y
parameter_list|)
specifier|const
block|{
comment|// clang-format off
specifier|static
specifier|const
name|int
name|modifierTable
index|[
literal|16
index|]
index|[
literal|8
index|]
init|=
block|{
block|{
operator|-
literal|3
block|,
operator|-
literal|6
block|,
operator|-
literal|9
block|,
operator|-
literal|15
block|,
literal|2
block|,
literal|5
block|,
literal|8
block|,
literal|14
block|}
block|,
block|{
operator|-
literal|3
block|,
operator|-
literal|7
block|,
operator|-
literal|10
block|,
operator|-
literal|13
block|,
literal|2
block|,
literal|6
block|,
literal|9
block|,
literal|12
block|}
block|,
block|{
operator|-
literal|2
block|,
operator|-
literal|5
block|,
operator|-
literal|8
block|,
operator|-
literal|13
block|,
literal|1
block|,
literal|4
block|,
literal|7
block|,
literal|12
block|}
block|,
block|{
operator|-
literal|2
block|,
operator|-
literal|4
block|,
operator|-
literal|6
block|,
operator|-
literal|13
block|,
literal|1
block|,
literal|3
block|,
literal|5
block|,
literal|12
block|}
block|,
block|{
operator|-
literal|3
block|,
operator|-
literal|6
block|,
operator|-
literal|8
block|,
operator|-
literal|12
block|,
literal|2
block|,
literal|5
block|,
literal|7
block|,
literal|11
block|}
block|,
block|{
operator|-
literal|3
block|,
operator|-
literal|7
block|,
operator|-
literal|9
block|,
operator|-
literal|11
block|,
literal|2
block|,
literal|6
block|,
literal|8
block|,
literal|10
block|}
block|,
block|{
operator|-
literal|4
block|,
operator|-
literal|7
block|,
operator|-
literal|8
block|,
operator|-
literal|11
block|,
literal|3
block|,
literal|6
block|,
literal|7
block|,
literal|10
block|}
block|,
block|{
operator|-
literal|3
block|,
operator|-
literal|5
block|,
operator|-
literal|8
block|,
operator|-
literal|11
block|,
literal|2
block|,
literal|4
block|,
literal|7
block|,
literal|10
block|}
block|,
block|{
operator|-
literal|2
block|,
operator|-
literal|6
block|,
operator|-
literal|8
block|,
operator|-
literal|10
block|,
literal|1
block|,
literal|5
block|,
literal|7
block|,
literal|9
block|}
block|,
block|{
operator|-
literal|2
block|,
operator|-
literal|5
block|,
operator|-
literal|8
block|,
operator|-
literal|10
block|,
literal|1
block|,
literal|4
block|,
literal|7
block|,
literal|9
block|}
block|,
block|{
operator|-
literal|2
block|,
operator|-
literal|4
block|,
operator|-
literal|8
block|,
operator|-
literal|10
block|,
literal|1
block|,
literal|3
block|,
literal|7
block|,
literal|9
block|}
block|,
block|{
operator|-
literal|2
block|,
operator|-
literal|5
block|,
operator|-
literal|7
block|,
operator|-
literal|10
block|,
literal|1
block|,
literal|4
block|,
literal|6
block|,
literal|9
block|}
block|,
block|{
operator|-
literal|3
block|,
operator|-
literal|4
block|,
operator|-
literal|7
block|,
operator|-
literal|10
block|,
literal|2
block|,
literal|3
block|,
literal|6
block|,
literal|9
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|2
block|,
operator|-
literal|3
block|,
operator|-
literal|10
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|9
block|}
block|,
block|{
operator|-
literal|4
block|,
operator|-
literal|6
block|,
operator|-
literal|8
block|,
operator|-
literal|9
block|,
literal|3
block|,
literal|5
block|,
literal|7
block|,
literal|8
block|}
block|,
block|{
operator|-
literal|3
block|,
operator|-
literal|5
block|,
operator|-
literal|7
block|,
operator|-
literal|9
block|,
literal|2
block|,
literal|4
block|,
literal|6
block|,
literal|8
block|}
block|}
decl_stmt|;
comment|// clang-format on
return|return
name|modifierTable
index|[
name|u
operator|.
name|scblk
operator|.
name|table_index
index|]
index|[
name|getSingleChannelIndex
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
index|]
return|;
block|}
block|}
struct|;
comment|// clang-format off
DECL|member|DefaultETCAlphaValues
specifier|static
specifier|const
name|uint8_t
name|DefaultETCAlphaValues
index|[
literal|4
index|]
index|[
literal|4
index|]
init|=
block|{
block|{
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|}
block|,
block|{
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|}
block|,
block|{
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|}
block|,
block|{
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|}
block|, }
decl_stmt|;
comment|// clang-format on
DECL|function|LoadR11EACToR8
name|void
name|LoadR11EACToR8
parameter_list|(
name|size_t
name|width
parameter_list|,
name|size_t
name|height
parameter_list|,
name|size_t
name|depth
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|input
parameter_list|,
name|size_t
name|inputRowPitch
parameter_list|,
name|size_t
name|inputDepthPitch
parameter_list|,
name|uint8_t
modifier|*
name|output
parameter_list|,
name|size_t
name|outputRowPitch
parameter_list|,
name|size_t
name|outputDepthPitch
parameter_list|,
name|bool
name|isSigned
parameter_list|)
block|{
for|for
control|(
name|size_t
name|z
init|=
literal|0
init|;
name|z
operator|<
name|depth
condition|;
name|z
operator|++
control|)
block|{
for|for
control|(
name|size_t
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|+=
literal|4
control|)
block|{
specifier|const
name|ETC2Block
modifier|*
name|sourceRow
init|=
name|OffsetDataPointer
argument_list|<
name|ETC2Block
argument_list|>
argument_list|(
name|input
argument_list|,
name|y
operator|/
literal|4
argument_list|,
name|z
argument_list|,
name|inputRowPitch
argument_list|,
name|inputDepthPitch
argument_list|)
decl_stmt|;
name|uint8_t
modifier|*
name|destRow
init|=
name|OffsetDataPointer
argument_list|<
name|uint8_t
argument_list|>
argument_list|(
name|output
argument_list|,
name|y
argument_list|,
name|z
argument_list|,
name|outputRowPitch
argument_list|,
name|outputDepthPitch
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|+=
literal|4
control|)
block|{
specifier|const
name|ETC2Block
modifier|*
name|sourceBlock
init|=
name|sourceRow
operator|+
operator|(
name|x
operator|/
literal|4
operator|)
decl_stmt|;
name|uint8_t
modifier|*
name|destPixels
init|=
name|destRow
operator|+
name|x
decl_stmt|;
name|sourceBlock
operator|->
name|decodeAsSingleChannel
argument_list|(
name|destPixels
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|1
argument_list|,
name|outputRowPitch
argument_list|,
name|isSigned
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|function|LoadRG11EACToRG8
name|void
name|LoadRG11EACToRG8
parameter_list|(
name|size_t
name|width
parameter_list|,
name|size_t
name|height
parameter_list|,
name|size_t
name|depth
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|input
parameter_list|,
name|size_t
name|inputRowPitch
parameter_list|,
name|size_t
name|inputDepthPitch
parameter_list|,
name|uint8_t
modifier|*
name|output
parameter_list|,
name|size_t
name|outputRowPitch
parameter_list|,
name|size_t
name|outputDepthPitch
parameter_list|,
name|bool
name|isSigned
parameter_list|)
block|{
for|for
control|(
name|size_t
name|z
init|=
literal|0
init|;
name|z
operator|<
name|depth
condition|;
name|z
operator|++
control|)
block|{
for|for
control|(
name|size_t
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|+=
literal|4
control|)
block|{
specifier|const
name|ETC2Block
modifier|*
name|sourceRow
init|=
name|OffsetDataPointer
argument_list|<
name|ETC2Block
argument_list|>
argument_list|(
name|input
argument_list|,
name|y
operator|/
literal|4
argument_list|,
name|z
argument_list|,
name|inputRowPitch
argument_list|,
name|inputDepthPitch
argument_list|)
decl_stmt|;
name|uint8_t
modifier|*
name|destRow
init|=
name|OffsetDataPointer
argument_list|<
name|uint8_t
argument_list|>
argument_list|(
name|output
argument_list|,
name|y
argument_list|,
name|z
argument_list|,
name|outputRowPitch
argument_list|,
name|outputDepthPitch
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|+=
literal|4
control|)
block|{
name|uint8_t
modifier|*
name|destPixelsRed
init|=
name|destRow
operator|+
operator|(
name|x
operator|*
literal|2
operator|)
decl_stmt|;
specifier|const
name|ETC2Block
modifier|*
name|sourceBlockRed
init|=
name|sourceRow
operator|+
operator|(
name|x
operator|/
literal|2
operator|)
decl_stmt|;
name|sourceBlockRed
operator|->
name|decodeAsSingleChannel
argument_list|(
name|destPixelsRed
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|2
argument_list|,
name|outputRowPitch
argument_list|,
name|isSigned
argument_list|)
expr_stmt|;
name|uint8_t
modifier|*
name|destPixelsGreen
init|=
name|destPixelsRed
operator|+
literal|1
decl_stmt|;
specifier|const
name|ETC2Block
modifier|*
name|sourceBlockGreen
init|=
name|sourceBlockRed
operator|+
literal|1
decl_stmt|;
name|sourceBlockGreen
operator|->
name|decodeAsSingleChannel
argument_list|(
name|destPixelsGreen
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|2
argument_list|,
name|outputRowPitch
argument_list|,
name|isSigned
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|function|LoadETC2RGB8ToRGBA8
name|void
name|LoadETC2RGB8ToRGBA8
parameter_list|(
name|size_t
name|width
parameter_list|,
name|size_t
name|height
parameter_list|,
name|size_t
name|depth
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|input
parameter_list|,
name|size_t
name|inputRowPitch
parameter_list|,
name|size_t
name|inputDepthPitch
parameter_list|,
name|uint8_t
modifier|*
name|output
parameter_list|,
name|size_t
name|outputRowPitch
parameter_list|,
name|size_t
name|outputDepthPitch
parameter_list|,
name|bool
name|punchthroughAlpha
parameter_list|)
block|{
for|for
control|(
name|size_t
name|z
init|=
literal|0
init|;
name|z
operator|<
name|depth
condition|;
name|z
operator|++
control|)
block|{
for|for
control|(
name|size_t
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|+=
literal|4
control|)
block|{
specifier|const
name|ETC2Block
modifier|*
name|sourceRow
init|=
name|OffsetDataPointer
argument_list|<
name|ETC2Block
argument_list|>
argument_list|(
name|input
argument_list|,
name|y
operator|/
literal|4
argument_list|,
name|z
argument_list|,
name|inputRowPitch
argument_list|,
name|inputDepthPitch
argument_list|)
decl_stmt|;
name|uint8_t
modifier|*
name|destRow
init|=
name|OffsetDataPointer
argument_list|<
name|uint8_t
argument_list|>
argument_list|(
name|output
argument_list|,
name|y
argument_list|,
name|z
argument_list|,
name|outputRowPitch
argument_list|,
name|outputDepthPitch
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|+=
literal|4
control|)
block|{
specifier|const
name|ETC2Block
modifier|*
name|sourceBlock
init|=
name|sourceRow
operator|+
operator|(
name|x
operator|/
literal|4
operator|)
decl_stmt|;
name|uint8_t
modifier|*
name|destPixels
init|=
name|destRow
operator|+
operator|(
name|x
operator|*
literal|4
operator|)
decl_stmt|;
name|sourceBlock
operator|->
name|decodeAsRGB
argument_list|(
name|destPixels
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|outputRowPitch
argument_list|,
name|DefaultETCAlphaValues
argument_list|,
name|punchthroughAlpha
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|function|LoadETC2RGB8ToBC1
name|void
name|LoadETC2RGB8ToBC1
parameter_list|(
name|size_t
name|width
parameter_list|,
name|size_t
name|height
parameter_list|,
name|size_t
name|depth
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|input
parameter_list|,
name|size_t
name|inputRowPitch
parameter_list|,
name|size_t
name|inputDepthPitch
parameter_list|,
name|uint8_t
modifier|*
name|output
parameter_list|,
name|size_t
name|outputRowPitch
parameter_list|,
name|size_t
name|outputDepthPitch
parameter_list|,
name|bool
name|punchthroughAlpha
parameter_list|)
block|{
for|for
control|(
name|size_t
name|z
init|=
literal|0
init|;
name|z
operator|<
name|depth
condition|;
name|z
operator|++
control|)
block|{
for|for
control|(
name|size_t
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|+=
literal|4
control|)
block|{
specifier|const
name|ETC2Block
modifier|*
name|sourceRow
init|=
name|OffsetDataPointer
argument_list|<
name|ETC2Block
argument_list|>
argument_list|(
name|input
argument_list|,
name|y
operator|/
literal|4
argument_list|,
name|z
argument_list|,
name|inputRowPitch
argument_list|,
name|inputDepthPitch
argument_list|)
decl_stmt|;
name|uint8_t
modifier|*
name|destRow
init|=
name|OffsetDataPointer
argument_list|<
name|uint8_t
argument_list|>
argument_list|(
name|output
argument_list|,
name|y
operator|/
literal|4
argument_list|,
name|z
argument_list|,
name|outputRowPitch
argument_list|,
name|outputDepthPitch
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|+=
literal|4
control|)
block|{
specifier|const
name|ETC2Block
modifier|*
name|sourceBlock
init|=
name|sourceRow
operator|+
operator|(
name|x
operator|/
literal|4
operator|)
decl_stmt|;
name|uint8_t
modifier|*
name|destPixels
init|=
name|destRow
operator|+
operator|(
name|x
operator|*
literal|2
operator|)
decl_stmt|;
name|sourceBlock
operator|->
name|transcodeAsBC1
argument_list|(
name|destPixels
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|DefaultETCAlphaValues
argument_list|,
name|punchthroughAlpha
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|function|LoadETC2RGBA8ToRGBA8
name|void
name|LoadETC2RGBA8ToRGBA8
parameter_list|(
name|size_t
name|width
parameter_list|,
name|size_t
name|height
parameter_list|,
name|size_t
name|depth
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|input
parameter_list|,
name|size_t
name|inputRowPitch
parameter_list|,
name|size_t
name|inputDepthPitch
parameter_list|,
name|uint8_t
modifier|*
name|output
parameter_list|,
name|size_t
name|outputRowPitch
parameter_list|,
name|size_t
name|outputDepthPitch
parameter_list|,
name|bool
name|srgb
parameter_list|)
block|{
name|uint8_t
name|decodedAlphaValues
index|[
literal|4
index|]
index|[
literal|4
index|]
decl_stmt|;
for|for
control|(
name|size_t
name|z
init|=
literal|0
init|;
name|z
operator|<
name|depth
condition|;
name|z
operator|++
control|)
block|{
for|for
control|(
name|size_t
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|+=
literal|4
control|)
block|{
specifier|const
name|ETC2Block
modifier|*
name|sourceRow
init|=
name|OffsetDataPointer
argument_list|<
name|ETC2Block
argument_list|>
argument_list|(
name|input
argument_list|,
name|y
operator|/
literal|4
argument_list|,
name|z
argument_list|,
name|inputRowPitch
argument_list|,
name|inputDepthPitch
argument_list|)
decl_stmt|;
name|uint8_t
modifier|*
name|destRow
init|=
name|OffsetDataPointer
argument_list|<
name|uint8_t
argument_list|>
argument_list|(
name|output
argument_list|,
name|y
argument_list|,
name|z
argument_list|,
name|outputRowPitch
argument_list|,
name|outputDepthPitch
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|+=
literal|4
control|)
block|{
specifier|const
name|ETC2Block
modifier|*
name|sourceBlockAlpha
init|=
name|sourceRow
operator|+
operator|(
name|x
operator|/
literal|2
operator|)
decl_stmt|;
name|sourceBlockAlpha
operator|->
name|decodeAsSingleChannel
argument_list|(
cast|reinterpret_cast
argument_list|<
name|uint8_t
operator|*
argument_list|>
argument_list|(
name|decodedAlphaValues
argument_list|)
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|uint8_t
modifier|*
name|destPixels
init|=
name|destRow
operator|+
operator|(
name|x
operator|*
literal|4
operator|)
decl_stmt|;
specifier|const
name|ETC2Block
modifier|*
name|sourceBlockRGB
init|=
name|sourceBlockAlpha
operator|+
literal|1
decl_stmt|;
name|sourceBlockRGB
operator|->
name|decodeAsRGB
argument_list|(
name|destPixels
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|outputRowPitch
argument_list|,
name|decodedAlphaValues
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|// anonymous namespace
DECL|function|LoadETC1RGB8ToRGBA8
name|void
name|LoadETC1RGB8ToRGBA8
parameter_list|(
name|size_t
name|width
parameter_list|,
name|size_t
name|height
parameter_list|,
name|size_t
name|depth
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|input
parameter_list|,
name|size_t
name|inputRowPitch
parameter_list|,
name|size_t
name|inputDepthPitch
parameter_list|,
name|uint8_t
modifier|*
name|output
parameter_list|,
name|size_t
name|outputRowPitch
parameter_list|,
name|size_t
name|outputDepthPitch
parameter_list|)
block|{
name|LoadETC2RGB8ToRGBA8
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|,
name|input
argument_list|,
name|inputRowPitch
argument_list|,
name|inputDepthPitch
argument_list|,
name|output
argument_list|,
name|outputRowPitch
argument_list|,
name|outputDepthPitch
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|function|LoadETC1RGB8ToBC1
name|void
name|LoadETC1RGB8ToBC1
parameter_list|(
name|size_t
name|width
parameter_list|,
name|size_t
name|height
parameter_list|,
name|size_t
name|depth
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|input
parameter_list|,
name|size_t
name|inputRowPitch
parameter_list|,
name|size_t
name|inputDepthPitch
parameter_list|,
name|uint8_t
modifier|*
name|output
parameter_list|,
name|size_t
name|outputRowPitch
parameter_list|,
name|size_t
name|outputDepthPitch
parameter_list|)
block|{
name|LoadETC2RGB8ToBC1
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|,
name|input
argument_list|,
name|inputRowPitch
argument_list|,
name|inputDepthPitch
argument_list|,
name|output
argument_list|,
name|outputRowPitch
argument_list|,
name|outputDepthPitch
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|function|LoadEACR11ToR8
name|void
name|LoadEACR11ToR8
parameter_list|(
name|size_t
name|width
parameter_list|,
name|size_t
name|height
parameter_list|,
name|size_t
name|depth
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|input
parameter_list|,
name|size_t
name|inputRowPitch
parameter_list|,
name|size_t
name|inputDepthPitch
parameter_list|,
name|uint8_t
modifier|*
name|output
parameter_list|,
name|size_t
name|outputRowPitch
parameter_list|,
name|size_t
name|outputDepthPitch
parameter_list|)
block|{
name|LoadR11EACToR8
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|,
name|input
argument_list|,
name|inputRowPitch
argument_list|,
name|inputDepthPitch
argument_list|,
name|output
argument_list|,
name|outputRowPitch
argument_list|,
name|outputDepthPitch
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|function|LoadEACR11SToR8
name|void
name|LoadEACR11SToR8
parameter_list|(
name|size_t
name|width
parameter_list|,
name|size_t
name|height
parameter_list|,
name|size_t
name|depth
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|input
parameter_list|,
name|size_t
name|inputRowPitch
parameter_list|,
name|size_t
name|inputDepthPitch
parameter_list|,
name|uint8_t
modifier|*
name|output
parameter_list|,
name|size_t
name|outputRowPitch
parameter_list|,
name|size_t
name|outputDepthPitch
parameter_list|)
block|{
name|LoadR11EACToR8
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|,
name|input
argument_list|,
name|inputRowPitch
argument_list|,
name|inputDepthPitch
argument_list|,
name|output
argument_list|,
name|outputRowPitch
argument_list|,
name|outputDepthPitch
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|function|LoadEACRG11ToRG8
name|void
name|LoadEACRG11ToRG8
parameter_list|(
name|size_t
name|width
parameter_list|,
name|size_t
name|height
parameter_list|,
name|size_t
name|depth
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|input
parameter_list|,
name|size_t
name|inputRowPitch
parameter_list|,
name|size_t
name|inputDepthPitch
parameter_list|,
name|uint8_t
modifier|*
name|output
parameter_list|,
name|size_t
name|outputRowPitch
parameter_list|,
name|size_t
name|outputDepthPitch
parameter_list|)
block|{
name|LoadRG11EACToRG8
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|,
name|input
argument_list|,
name|inputRowPitch
argument_list|,
name|inputDepthPitch
argument_list|,
name|output
argument_list|,
name|outputRowPitch
argument_list|,
name|outputDepthPitch
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|function|LoadEACRG11SToRG8
name|void
name|LoadEACRG11SToRG8
parameter_list|(
name|size_t
name|width
parameter_list|,
name|size_t
name|height
parameter_list|,
name|size_t
name|depth
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|input
parameter_list|,
name|size_t
name|inputRowPitch
parameter_list|,
name|size_t
name|inputDepthPitch
parameter_list|,
name|uint8_t
modifier|*
name|output
parameter_list|,
name|size_t
name|outputRowPitch
parameter_list|,
name|size_t
name|outputDepthPitch
parameter_list|)
block|{
name|LoadRG11EACToRG8
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|,
name|input
argument_list|,
name|inputRowPitch
argument_list|,
name|inputDepthPitch
argument_list|,
name|output
argument_list|,
name|outputRowPitch
argument_list|,
name|outputDepthPitch
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|function|LoadETC2RGB8ToRGBA8
name|void
name|LoadETC2RGB8ToRGBA8
parameter_list|(
name|size_t
name|width
parameter_list|,
name|size_t
name|height
parameter_list|,
name|size_t
name|depth
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|input
parameter_list|,
name|size_t
name|inputRowPitch
parameter_list|,
name|size_t
name|inputDepthPitch
parameter_list|,
name|uint8_t
modifier|*
name|output
parameter_list|,
name|size_t
name|outputRowPitch
parameter_list|,
name|size_t
name|outputDepthPitch
parameter_list|)
block|{
name|LoadETC2RGB8ToRGBA8
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|,
name|input
argument_list|,
name|inputRowPitch
argument_list|,
name|inputDepthPitch
argument_list|,
name|output
argument_list|,
name|outputRowPitch
argument_list|,
name|outputDepthPitch
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|function|LoadETC2SRGB8ToRGBA8
name|void
name|LoadETC2SRGB8ToRGBA8
parameter_list|(
name|size_t
name|width
parameter_list|,
name|size_t
name|height
parameter_list|,
name|size_t
name|depth
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|input
parameter_list|,
name|size_t
name|inputRowPitch
parameter_list|,
name|size_t
name|inputDepthPitch
parameter_list|,
name|uint8_t
modifier|*
name|output
parameter_list|,
name|size_t
name|outputRowPitch
parameter_list|,
name|size_t
name|outputDepthPitch
parameter_list|)
block|{
name|LoadETC2RGB8ToRGBA8
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|,
name|input
argument_list|,
name|inputRowPitch
argument_list|,
name|inputDepthPitch
argument_list|,
name|output
argument_list|,
name|outputRowPitch
argument_list|,
name|outputDepthPitch
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|function|LoadETC2RGB8A1ToRGBA8
name|void
name|LoadETC2RGB8A1ToRGBA8
parameter_list|(
name|size_t
name|width
parameter_list|,
name|size_t
name|height
parameter_list|,
name|size_t
name|depth
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|input
parameter_list|,
name|size_t
name|inputRowPitch
parameter_list|,
name|size_t
name|inputDepthPitch
parameter_list|,
name|uint8_t
modifier|*
name|output
parameter_list|,
name|size_t
name|outputRowPitch
parameter_list|,
name|size_t
name|outputDepthPitch
parameter_list|)
block|{
name|LoadETC2RGB8ToRGBA8
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|,
name|input
argument_list|,
name|inputRowPitch
argument_list|,
name|inputDepthPitch
argument_list|,
name|output
argument_list|,
name|outputRowPitch
argument_list|,
name|outputDepthPitch
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|function|LoadETC2SRGB8A1ToRGBA8
name|void
name|LoadETC2SRGB8A1ToRGBA8
parameter_list|(
name|size_t
name|width
parameter_list|,
name|size_t
name|height
parameter_list|,
name|size_t
name|depth
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|input
parameter_list|,
name|size_t
name|inputRowPitch
parameter_list|,
name|size_t
name|inputDepthPitch
parameter_list|,
name|uint8_t
modifier|*
name|output
parameter_list|,
name|size_t
name|outputRowPitch
parameter_list|,
name|size_t
name|outputDepthPitch
parameter_list|)
block|{
name|LoadETC2RGB8ToRGBA8
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|,
name|input
argument_list|,
name|inputRowPitch
argument_list|,
name|inputDepthPitch
argument_list|,
name|output
argument_list|,
name|outputRowPitch
argument_list|,
name|outputDepthPitch
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|function|LoadETC2RGBA8ToRGBA8
name|void
name|LoadETC2RGBA8ToRGBA8
parameter_list|(
name|size_t
name|width
parameter_list|,
name|size_t
name|height
parameter_list|,
name|size_t
name|depth
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|input
parameter_list|,
name|size_t
name|inputRowPitch
parameter_list|,
name|size_t
name|inputDepthPitch
parameter_list|,
name|uint8_t
modifier|*
name|output
parameter_list|,
name|size_t
name|outputRowPitch
parameter_list|,
name|size_t
name|outputDepthPitch
parameter_list|)
block|{
name|LoadETC2RGBA8ToRGBA8
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|,
name|input
argument_list|,
name|inputRowPitch
argument_list|,
name|inputDepthPitch
argument_list|,
name|output
argument_list|,
name|outputRowPitch
argument_list|,
name|outputDepthPitch
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|function|LoadETC2SRGBA8ToSRGBA8
name|void
name|LoadETC2SRGBA8ToSRGBA8
parameter_list|(
name|size_t
name|width
parameter_list|,
name|size_t
name|height
parameter_list|,
name|size_t
name|depth
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|input
parameter_list|,
name|size_t
name|inputRowPitch
parameter_list|,
name|size_t
name|inputDepthPitch
parameter_list|,
name|uint8_t
modifier|*
name|output
parameter_list|,
name|size_t
name|outputRowPitch
parameter_list|,
name|size_t
name|outputDepthPitch
parameter_list|)
block|{
name|LoadETC2RGBA8ToRGBA8
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|,
name|input
argument_list|,
name|inputRowPitch
argument_list|,
name|inputDepthPitch
argument_list|,
name|output
argument_list|,
name|outputRowPitch
argument_list|,
name|outputDepthPitch
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
end_namespace
begin_comment
comment|// namespace rx
end_comment
end_unit
