begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2012 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// InputLayoutCache.cpp: Defines InputLayoutCache, a class that builds and caches
end_comment
begin_comment
comment|// D3D11 input layouts.
end_comment
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/InputLayoutCache.h"
end_include
begin_include
include|#
directive|include
file|"common/utilities.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Program.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/VertexAttribute.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/IndexDataManager.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/ProgramD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/VertexDataManager.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/Buffer11.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/ShaderExecutable11.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/VertexBuffer11.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/formatutils11.h"
end_include
begin_include
include|#
directive|include
file|"third_party/murmurhash/MurmurHash3.h"
end_include
begin_namespace
DECL|namespace|rx
namespace|namespace
name|rx
block|{
namespace|namespace
block|{
DECL|function|GetReservedBufferCount
name|size_t
name|GetReservedBufferCount
parameter_list|(
name|bool
name|usesPointSpriteEmulation
parameter_list|)
block|{
return|return
name|usesPointSpriteEmulation
condition|?
literal|1
else|:
literal|0
return|;
block|}
DECL|function|GetInputLayout
name|gl
operator|::
name|InputLayout
name|GetInputLayout
parameter_list|(
specifier|const
name|SortedAttribArray
modifier|&
name|translatedAttributes
parameter_list|,
name|size_t
name|attributeCount
parameter_list|)
block|{
name|gl
operator|::
name|InputLayout
name|inputLayout
argument_list|(
name|attributeCount
argument_list|,
name|gl
operator|::
name|VERTEX_FORMAT_INVALID
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|attributeIndex
init|=
literal|0
init|;
name|attributeIndex
operator|<
name|attributeCount
condition|;
operator|++
name|attributeIndex
control|)
block|{
specifier|const
name|TranslatedAttribute
modifier|*
name|translatedAttribute
init|=
name|translatedAttributes
index|[
name|attributeIndex
index|]
decl_stmt|;
if|if
condition|(
name|translatedAttribute
operator|->
name|active
condition|)
block|{
name|inputLayout
index|[
name|attributeIndex
index|]
operator|=
name|gl
operator|::
name|GetVertexFormatType
argument_list|(
operator|*
name|translatedAttribute
operator|->
name|attribute
argument_list|,
name|translatedAttribute
operator|->
name|currentValueType
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|inputLayout
return|;
block|}
DECL|function|GetGLSLAttributeType
name|GLenum
name|GetGLSLAttributeType
parameter_list|(
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|Attribute
argument_list|>
modifier|&
name|shaderAttributes
parameter_list|,
name|int
name|index
parameter_list|)
block|{
comment|// Count matrices differently
for|for
control|(
specifier|const
name|sh
operator|::
name|Attribute
modifier|&
name|attrib
range|:
name|shaderAttributes
control|)
block|{
if|if
condition|(
name|attrib
operator|.
name|location
operator|==
operator|-
literal|1
condition|)
block|{
continue|continue;
block|}
name|GLenum
name|transposedType
init|=
name|gl
operator|::
name|TransposeMatrixType
argument_list|(
name|attrib
operator|.
name|type
argument_list|)
decl_stmt|;
name|int
name|rows
init|=
name|gl
operator|::
name|VariableRowCount
argument_list|(
name|transposedType
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|>=
name|attrib
operator|.
name|location
operator|&&
name|index
operator|<
name|attrib
operator|.
name|location
operator|+
name|rows
condition|)
block|{
return|return
name|transposedType
return|;
block|}
block|}
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|GL_NONE
return|;
block|}
DECL|member|kDefaultCacheSize
specifier|const
name|unsigned
name|int
name|kDefaultCacheSize
init|=
literal|1024
decl_stmt|;
DECL|struct|PackedAttribute
struct|struct
name|PackedAttribute
block|{
DECL|member|attribType
name|uint8_t
name|attribType
decl_stmt|;
DECL|member|semanticIndex
name|uint8_t
name|semanticIndex
decl_stmt|;
DECL|member|vertexFormatType
name|uint8_t
name|vertexFormatType
decl_stmt|;
DECL|member|divisor
name|uint8_t
name|divisor
decl_stmt|;
block|}
struct|;
DECL|function|FindFirstNonInstanced
name|Optional
argument_list|<
name|size_t
argument_list|>
name|FindFirstNonInstanced
parameter_list|(
specifier|const
name|SortedAttribArray
modifier|&
name|sortedAttributes
parameter_list|,
name|size_t
name|maxIndex
parameter_list|)
block|{
for|for
control|(
name|size_t
name|index
init|=
literal|0
init|;
name|index
operator|<
name|maxIndex
condition|;
operator|++
name|index
control|)
block|{
if|if
condition|(
name|sortedAttributes
index|[
name|index
index|]
operator|->
name|divisor
operator|==
literal|0
condition|)
block|{
return|return
name|Optional
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|index
argument_list|)
return|;
block|}
block|}
return|return
name|Optional
argument_list|<
name|size_t
argument_list|>
operator|::
name|Invalid
argument_list|()
return|;
block|}
block|}
comment|// anonymous namespace
DECL|function|addAttributeData
name|void
name|InputLayoutCache
operator|::
name|PackedAttributeLayout
operator|::
name|addAttributeData
parameter_list|(
name|GLenum
name|glType
parameter_list|,
name|UINT
name|semanticIndex
parameter_list|,
name|gl
operator|::
name|VertexFormatType
name|vertexFormatType
parameter_list|,
name|unsigned
name|int
name|divisor
parameter_list|)
block|{
name|gl
operator|::
name|AttributeType
name|attribType
init|=
name|gl
operator|::
name|GetAttributeType
argument_list|(
name|glType
argument_list|)
decl_stmt|;
name|PackedAttribute
name|packedAttrib
decl_stmt|;
name|packedAttrib
operator|.
name|attribType
operator|=
cast|static_cast
argument_list|<
name|uint8_t
argument_list|>
argument_list|(
name|attribType
argument_list|)
expr_stmt|;
name|packedAttrib
operator|.
name|semanticIndex
operator|=
cast|static_cast
argument_list|<
name|uint8_t
argument_list|>
argument_list|(
name|semanticIndex
argument_list|)
expr_stmt|;
name|packedAttrib
operator|.
name|vertexFormatType
operator|=
cast|static_cast
argument_list|<
name|uint8_t
argument_list|>
argument_list|(
name|vertexFormatType
argument_list|)
expr_stmt|;
name|packedAttrib
operator|.
name|divisor
operator|=
cast|static_cast
argument_list|<
name|uint8_t
argument_list|>
argument_list|(
name|divisor
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
cast|static_cast
argument_list|<
name|gl
operator|::
name|AttributeType
argument_list|>
argument_list|(
name|packedAttrib
operator|.
name|attribType
argument_list|)
operator|==
name|attribType
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|packedAttrib
operator|.
name|semanticIndex
argument_list|)
operator|==
name|semanticIndex
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
cast|static_cast
argument_list|<
name|gl
operator|::
name|VertexFormatType
argument_list|>
argument_list|(
name|packedAttrib
operator|.
name|vertexFormatType
argument_list|)
operator|==
name|vertexFormatType
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|packedAttrib
operator|.
name|divisor
argument_list|)
operator|==
name|divisor
argument_list|)
expr_stmt|;
assert|static_assert
argument_list|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|PackedAttribute
argument_list|)
argument_list|,
literal|"PackedAttributes must be 32-bits exactly."
argument_list|)
assert|;
name|attributeData
index|[
name|numAttributes
operator|++
index|]
operator|=
name|gl
operator|::
name|bitCast
argument_list|<
name|uint32_t
argument_list|>
argument_list|(
name|packedAttrib
argument_list|)
expr_stmt|;
block|}
DECL|function|operator <
name|bool
name|InputLayoutCache
operator|::
name|PackedAttributeLayout
operator|::
name|operator
name|<
parameter_list|(
specifier|const
name|PackedAttributeLayout
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|numAttributes
operator|!=
name|other
operator|.
name|numAttributes
condition|)
block|{
return|return
name|numAttributes
operator|<
name|other
operator|.
name|numAttributes
return|;
block|}
if|if
condition|(
name|flags
operator|!=
name|other
operator|.
name|flags
condition|)
block|{
return|return
name|flags
operator|<
name|other
operator|.
name|flags
return|;
block|}
return|return
name|memcmp
argument_list|(
name|attributeData
argument_list|,
name|other
operator|.
name|attributeData
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|numAttributes
argument_list|)
operator|<
literal|0
return|;
block|}
DECL|function|InputLayoutCache
name|InputLayoutCache
operator|::
name|InputLayoutCache
parameter_list|()
member_init_list|:
name|mUnsortedAttributesCount
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mCacheSize
argument_list|(
name|kDefaultCacheSize
argument_list|)
block|{
name|mCounter
operator|=
literal|0
expr_stmt|;
name|mDevice
operator|=
name|NULL
expr_stmt|;
name|mDeviceContext
operator|=
name|NULL
expr_stmt|;
name|mCurrentIL
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
condition|;
name|i
operator|++
control|)
block|{
name|mCurrentBuffers
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|mCurrentVertexStrides
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mCurrentVertexOffsets
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|mPointSpriteVertexBuffer
operator|=
name|NULL
expr_stmt|;
name|mPointSpriteIndexBuffer
operator|=
name|NULL
expr_stmt|;
block|}
DECL|function|~InputLayoutCache
name|InputLayoutCache
operator|::
name|~
name|InputLayoutCache
parameter_list|()
block|{
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|function|initialize
name|void
name|InputLayoutCache
operator|::
name|initialize
parameter_list|(
name|ID3D11Device
modifier|*
name|device
parameter_list|,
name|ID3D11DeviceContext
modifier|*
name|context
parameter_list|)
block|{
name|clear
argument_list|()
expr_stmt|;
name|mDevice
operator|=
name|device
expr_stmt|;
name|mDeviceContext
operator|=
name|context
expr_stmt|;
name|mFeatureLevel
operator|=
name|device
operator|->
name|GetFeatureLevel
argument_list|()
expr_stmt|;
block|}
DECL|function|clear
name|void
name|InputLayoutCache
operator|::
name|clear
parameter_list|()
block|{
for|for
control|(
name|auto
operator|&
name|layout
operator|:
name|mLayoutMap
control|)
block|{
name|SafeRelease
argument_list|(
name|layout
operator|.
name|second
argument_list|)
expr_stmt|;
block|}
name|mLayoutMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|SafeRelease
argument_list|(
name|mPointSpriteVertexBuffer
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mPointSpriteIndexBuffer
argument_list|)
expr_stmt|;
name|markDirty
argument_list|()
expr_stmt|;
block|}
DECL|function|markDirty
name|void
name|InputLayoutCache
operator|::
name|markDirty
parameter_list|()
block|{
name|mCurrentIL
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
condition|;
name|i
operator|++
control|)
block|{
name|mCurrentBuffers
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|mCurrentVertexStrides
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mCurrentVertexOffsets
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|mUnsortedAttributesCount
operator|=
literal|0
expr_stmt|;
block|}
DECL|function|applyVertexBuffers
name|gl
operator|::
name|Error
name|InputLayoutCache
operator|::
name|applyVertexBuffers
parameter_list|(
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|TranslatedAttribute
argument_list|>
modifier|&
name|unsortedAttributes
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|gl
operator|::
name|Program
modifier|*
name|program
parameter_list|,
name|TranslatedIndexData
modifier|*
name|indexInfo
parameter_list|,
name|GLsizei
name|numIndicesPerInstance
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|mDevice
operator|&&
name|mDeviceContext
argument_list|)
expr_stmt|;
name|ProgramD3D
modifier|*
name|programD3D
init|=
name|GetImplAs
argument_list|<
name|ProgramD3D
argument_list|>
argument_list|(
name|program
argument_list|)
decl_stmt|;
name|bool
name|programUsesInstancedPointSprites
init|=
name|programD3D
operator|->
name|usesPointSize
argument_list|()
operator|&&
name|programD3D
operator|->
name|usesInstancedPointSpriteEmulation
argument_list|()
decl_stmt|;
name|bool
name|instancedPointSpritesActive
init|=
name|programUsesInstancedPointSprites
operator|&&
operator|(
name|mode
operator|==
name|GL_POINTS
operator|)
decl_stmt|;
name|SortedIndexArray
name|sortedSemanticIndices
decl_stmt|;
name|mSortedAttributes
operator|.
name|fill
argument_list|(
literal|nullptr
argument_list|)
expr_stmt|;
name|mUnsortedAttributesCount
operator|=
name|unsortedAttributes
operator|.
name|size
argument_list|()
expr_stmt|;
name|programD3D
operator|->
name|sortAttributesByLayout
argument_list|(
name|unsortedAttributes
argument_list|,
name|sortedSemanticIndices
operator|.
name|data
argument_list|()
argument_list|,
name|mSortedAttributes
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
comment|// If we are using FL 9_3, make sure the first attribute is not instanced
if|if
condition|(
name|mFeatureLevel
operator|<=
name|D3D_FEATURE_LEVEL_9_3
operator|&&
operator|!
name|unsortedAttributes
operator|.
name|empty
argument_list|()
condition|)
block|{
if|if
condition|(
name|mSortedAttributes
index|[
literal|0
index|]
operator|->
name|divisor
operator|>
literal|0
condition|)
block|{
name|Optional
argument_list|<
name|size_t
argument_list|>
name|firstNonInstancedIndex
init|=
name|FindFirstNonInstanced
argument_list|(
name|mSortedAttributes
argument_list|,
name|unsortedAttributes
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|firstNonInstancedIndex
operator|.
name|valid
argument_list|()
condition|)
block|{
name|size_t
name|index
init|=
name|firstNonInstancedIndex
operator|.
name|value
argument_list|()
decl_stmt|;
name|std
operator|::
name|swap
argument_list|(
name|mSortedAttributes
index|[
literal|0
index|]
argument_list|,
name|mSortedAttributes
index|[
name|index
index|]
argument_list|)
expr_stmt|;
name|std
operator|::
name|swap
argument_list|(
name|sortedSemanticIndices
index|[
literal|0
index|]
argument_list|,
name|sortedSemanticIndices
index|[
name|index
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|gl
operator|::
name|Error
name|error
init|=
name|updateInputLayout
argument_list|(
name|program
argument_list|,
name|mode
argument_list|,
name|mSortedAttributes
argument_list|,
name|sortedSemanticIndices
argument_list|,
name|unsortedAttributes
operator|.
name|size
argument_list|()
argument_list|,
name|numIndicesPerInstance
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|bool
name|dirtyBuffers
init|=
literal|false
decl_stmt|;
name|size_t
name|minDiff
init|=
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
decl_stmt|;
name|size_t
name|maxDiff
init|=
literal|0
decl_stmt|;
comment|// Note that if we use instance emulation, we reserve the first buffer slot.
name|size_t
name|reservedBuffers
init|=
name|GetReservedBufferCount
argument_list|(
name|programUsesInstancedPointSprites
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|attribIndex
init|=
literal|0
init|;
name|attribIndex
operator|<
operator|(
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
operator|-
name|reservedBuffers
operator|)
condition|;
operator|++
name|attribIndex
control|)
block|{
name|ID3D11Buffer
modifier|*
name|buffer
init|=
name|NULL
decl_stmt|;
name|UINT
name|vertexStride
init|=
literal|0
decl_stmt|;
name|UINT
name|vertexOffset
init|=
literal|0
decl_stmt|;
specifier|const
specifier|auto
modifier|&
name|attrib
init|=
operator|*
name|mSortedAttributes
index|[
name|attribIndex
index|]
decl_stmt|;
if|if
condition|(
name|attribIndex
operator|<
name|unsortedAttributes
operator|.
name|size
argument_list|()
operator|&&
name|attrib
operator|.
name|active
condition|)
block|{
name|VertexBuffer11
modifier|*
name|vertexBuffer
init|=
name|GetAs
argument_list|<
name|VertexBuffer11
argument_list|>
argument_list|(
name|attrib
operator|.
name|vertexBuffer
argument_list|)
decl_stmt|;
name|Buffer11
modifier|*
name|bufferStorage
init|=
name|attrib
operator|.
name|storage
condition|?
name|GetAs
argument_list|<
name|Buffer11
argument_list|>
argument_list|(
name|attrib
operator|.
name|storage
argument_list|)
else|:
literal|nullptr
decl_stmt|;
comment|// If indexed pointsprite emulation is active, then we need to take a less efficent code path.
comment|// Emulated indexed pointsprite rendering requires that the vertex buffers match exactly to
comment|// the indices passed by the caller.  This could expand or shrink the vertex buffer depending
comment|// on the number of points indicated by the index list or how many duplicates are found on the index list.
if|if
condition|(
name|bufferStorage
operator|==
literal|nullptr
condition|)
block|{
name|buffer
operator|=
name|vertexBuffer
operator|->
name|getBuffer
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instancedPointSpritesActive
operator|&&
operator|(
name|indexInfo
operator|!=
literal|nullptr
operator|)
condition|)
block|{
if|if
condition|(
name|indexInfo
operator|->
name|srcIndexData
operator|.
name|srcBuffer
operator|!=
literal|nullptr
condition|)
block|{
specifier|const
name|uint8_t
modifier|*
name|bufferData
init|=
literal|nullptr
decl_stmt|;
name|error
operator|=
name|indexInfo
operator|->
name|srcIndexData
operator|.
name|srcBuffer
operator|->
name|getData
argument_list|(
operator|&
name|bufferData
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|bufferData
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
name|ptrdiff_t
name|offset
init|=
cast|reinterpret_cast
argument_list|<
name|ptrdiff_t
argument_list|>
argument_list|(
name|indexInfo
operator|->
name|srcIndexData
operator|.
name|srcIndices
argument_list|)
decl_stmt|;
name|indexInfo
operator|->
name|srcIndexData
operator|.
name|srcBuffer
operator|=
literal|nullptr
expr_stmt|;
name|indexInfo
operator|->
name|srcIndexData
operator|.
name|srcIndices
operator|=
name|bufferData
operator|+
name|offset
expr_stmt|;
block|}
name|buffer
operator|=
name|bufferStorage
operator|->
name|getEmulatedIndexedBuffer
argument_list|(
operator|&
name|indexInfo
operator|->
name|srcIndexData
argument_list|,
operator|&
name|attrib
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buffer
operator|=
name|bufferStorage
operator|->
name|getBuffer
argument_list|(
name|BUFFER_USAGE_VERTEX_OR_TRANSFORM_FEEDBACK
argument_list|)
expr_stmt|;
block|}
name|vertexStride
operator|=
name|attrib
operator|.
name|stride
expr_stmt|;
name|vertexOffset
operator|=
name|attrib
operator|.
name|offset
expr_stmt|;
block|}
name|size_t
name|bufferIndex
init|=
name|reservedBuffers
operator|+
name|attribIndex
decl_stmt|;
if|if
condition|(
name|buffer
operator|!=
name|mCurrentBuffers
index|[
name|bufferIndex
index|]
operator|||
name|vertexStride
operator|!=
name|mCurrentVertexStrides
index|[
name|bufferIndex
index|]
operator|||
name|vertexOffset
operator|!=
name|mCurrentVertexOffsets
index|[
name|bufferIndex
index|]
condition|)
block|{
name|dirtyBuffers
operator|=
literal|true
expr_stmt|;
name|minDiff
operator|=
name|std
operator|::
name|min
argument_list|(
name|minDiff
argument_list|,
name|bufferIndex
argument_list|)
expr_stmt|;
name|maxDiff
operator|=
name|std
operator|::
name|max
argument_list|(
name|maxDiff
argument_list|,
name|bufferIndex
argument_list|)
expr_stmt|;
name|mCurrentBuffers
index|[
name|bufferIndex
index|]
operator|=
name|buffer
expr_stmt|;
name|mCurrentVertexStrides
index|[
name|bufferIndex
index|]
operator|=
name|vertexStride
expr_stmt|;
name|mCurrentVertexOffsets
index|[
name|bufferIndex
index|]
operator|=
name|vertexOffset
expr_stmt|;
block|}
block|}
comment|// Instanced PointSprite emulation requires two additional ID3D11Buffers. A vertex buffer needs
comment|// to be created and added to the list of current buffers, strides and offsets collections.
comment|// This buffer contains the vertices for a single PointSprite quad.
comment|// An index buffer also needs to be created and applied because rendering instanced data on
comment|// D3D11 FL9_3 requires DrawIndexedInstanced() to be used. Shaders that contain gl_PointSize and
comment|// used without the GL_POINTS rendering mode require a vertex buffer because some drivers cannot
comment|// handle missing vertex data and will TDR the system.
if|if
condition|(
name|programUsesInstancedPointSprites
condition|)
block|{
name|HRESULT
name|result
init|=
name|S_OK
decl_stmt|;
specifier|const
name|UINT
name|pointSpriteVertexStride
init|=
sizeof|sizeof
argument_list|(
name|float
argument_list|)
operator|*
literal|5
decl_stmt|;
if|if
condition|(
operator|!
name|mPointSpriteVertexBuffer
condition|)
block|{
specifier|static
specifier|const
name|float
name|pointSpriteVertices
index|[]
init|=
block|{
comment|// Position        // TexCoord
operator|-
literal|1.0f
block|,
operator|-
literal|1.0f
block|,
literal|0.0f
block|,
literal|0.0f
block|,
literal|1.0f
block|,
operator|-
literal|1.0f
block|,
literal|1.0f
block|,
literal|0.0f
block|,
literal|0.0f
block|,
literal|0.0f
block|,
literal|1.0f
block|,
literal|1.0f
block|,
literal|0.0f
block|,
literal|1.0f
block|,
literal|0.0f
block|,
literal|1.0f
block|,
operator|-
literal|1.0f
block|,
literal|0.0f
block|,
literal|1.0f
block|,
literal|1.0f
block|,
operator|-
literal|1.0f
block|,
operator|-
literal|1.0f
block|,
literal|0.0f
block|,
literal|0.0f
block|,
literal|1.0f
block|,
literal|1.0f
block|,
literal|1.0f
block|,
literal|0.0f
block|,
literal|1.0f
block|,
literal|0.0f
block|,             }
decl_stmt|;
name|D3D11_SUBRESOURCE_DATA
name|vertexBufferData
init|=
block|{
name|pointSpriteVertices
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|D3D11_BUFFER_DESC
name|vertexBufferDesc
decl_stmt|;
name|vertexBufferDesc
operator|.
name|ByteWidth
operator|=
sizeof|sizeof
argument_list|(
name|pointSpriteVertices
argument_list|)
expr_stmt|;
name|vertexBufferDesc
operator|.
name|BindFlags
operator|=
name|D3D11_BIND_VERTEX_BUFFER
expr_stmt|;
name|vertexBufferDesc
operator|.
name|Usage
operator|=
name|D3D11_USAGE_IMMUTABLE
expr_stmt|;
name|vertexBufferDesc
operator|.
name|CPUAccessFlags
operator|=
literal|0
expr_stmt|;
name|vertexBufferDesc
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|vertexBufferDesc
operator|.
name|StructureByteStride
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|CreateBuffer
argument_list|(
operator|&
name|vertexBufferDesc
argument_list|,
operator|&
name|vertexBufferData
argument_list|,
operator|&
name|mPointSpriteVertexBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create instanced pointsprite emulation vertex buffer, HRESULT: 0x%08x"
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
name|mCurrentBuffers
index|[
literal|0
index|]
operator|=
name|mPointSpriteVertexBuffer
expr_stmt|;
comment|// Set the stride to 0 if GL_POINTS mode is not being used to instruct the driver to avoid
comment|// indexing into the vertex buffer.
name|mCurrentVertexStrides
index|[
literal|0
index|]
operator|=
name|instancedPointSpritesActive
condition|?
name|pointSpriteVertexStride
else|:
literal|0
expr_stmt|;
name|mCurrentVertexOffsets
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|// Update maxDiff to include the additional point sprite vertex buffer
comment|// to ensure that IASetVertexBuffers uses the correct buffer count.
name|minDiff
operator|=
literal|0
expr_stmt|;
name|maxDiff
operator|=
name|std
operator|::
name|max
argument_list|(
name|maxDiff
argument_list|,
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mPointSpriteIndexBuffer
condition|)
block|{
comment|// Create an index buffer and set it for pointsprite rendering
specifier|static
specifier|const
name|unsigned
name|short
name|pointSpriteIndices
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,             }
decl_stmt|;
name|D3D11_SUBRESOURCE_DATA
name|indexBufferData
init|=
block|{
name|pointSpriteIndices
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|D3D11_BUFFER_DESC
name|indexBufferDesc
decl_stmt|;
name|indexBufferDesc
operator|.
name|ByteWidth
operator|=
sizeof|sizeof
argument_list|(
name|pointSpriteIndices
argument_list|)
expr_stmt|;
name|indexBufferDesc
operator|.
name|BindFlags
operator|=
name|D3D11_BIND_INDEX_BUFFER
expr_stmt|;
name|indexBufferDesc
operator|.
name|Usage
operator|=
name|D3D11_USAGE_IMMUTABLE
expr_stmt|;
name|indexBufferDesc
operator|.
name|CPUAccessFlags
operator|=
literal|0
expr_stmt|;
name|indexBufferDesc
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|indexBufferDesc
operator|.
name|StructureByteStride
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|CreateBuffer
argument_list|(
operator|&
name|indexBufferDesc
argument_list|,
operator|&
name|indexBufferData
argument_list|,
operator|&
name|mPointSpriteIndexBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|SafeRelease
argument_list|(
name|mPointSpriteVertexBuffer
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create instanced pointsprite emulation index buffer, HRESULT: 0x%08x"
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|instancedPointSpritesActive
condition|)
block|{
comment|// The index buffer is applied here because Instanced PointSprite emulation uses the a
comment|// non-indexed rendering path in ANGLE (DrawArrays). This means that applyIndexBuffer()
comment|// on the renderer will not be called and setting this buffer here ensures that the
comment|// rendering path will contain the correct index buffers.
name|mDeviceContext
operator|->
name|IASetIndexBuffer
argument_list|(
name|mPointSpriteIndexBuffer
argument_list|,
name|DXGI_FORMAT_R16_UINT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dirtyBuffers
condition|)
block|{
name|ASSERT
argument_list|(
name|minDiff
operator|<=
name|maxDiff
operator|&&
name|maxDiff
operator|<
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
argument_list|)
expr_stmt|;
name|mDeviceContext
operator|->
name|IASetVertexBuffers
argument_list|(
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|minDiff
argument_list|)
argument_list|,
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|maxDiff
operator|-
name|minDiff
operator|+
literal|1
argument_list|)
argument_list|,
name|mCurrentBuffers
operator|+
name|minDiff
argument_list|,
name|mCurrentVertexStrides
operator|+
name|minDiff
argument_list|,
name|mCurrentVertexOffsets
operator|+
name|minDiff
argument_list|)
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|updateVertexOffsetsForPointSpritesEmulation
name|gl
operator|::
name|Error
name|InputLayoutCache
operator|::
name|updateVertexOffsetsForPointSpritesEmulation
parameter_list|(
name|GLsizei
name|emulatedInstanceId
parameter_list|)
block|{
name|size_t
name|reservedBuffers
init|=
name|GetReservedBufferCount
argument_list|(
literal|true
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|attribIndex
init|=
literal|0
init|;
name|attribIndex
operator|<
name|mUnsortedAttributesCount
condition|;
operator|++
name|attribIndex
control|)
block|{
specifier|const
specifier|auto
modifier|&
name|attrib
init|=
operator|*
name|mSortedAttributes
index|[
name|attribIndex
index|]
decl_stmt|;
name|size_t
name|bufferIndex
init|=
name|reservedBuffers
operator|+
name|attribIndex
decl_stmt|;
if|if
condition|(
name|attrib
operator|.
name|active
operator|&&
name|attrib
operator|.
name|divisor
operator|>
literal|0
condition|)
block|{
name|mCurrentVertexOffsets
index|[
name|bufferIndex
index|]
operator|=
name|attrib
operator|.
name|offset
operator|+
operator|(
name|attrib
operator|.
name|stride
operator|*
operator|(
name|emulatedInstanceId
operator|/
name|attrib
operator|.
name|divisor
operator|)
operator|)
expr_stmt|;
block|}
block|}
name|mDeviceContext
operator|->
name|IASetVertexBuffers
argument_list|(
literal|0
argument_list|,
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
argument_list|,
name|mCurrentBuffers
argument_list|,
name|mCurrentVertexStrides
argument_list|,
name|mCurrentVertexOffsets
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|updateInputLayout
name|gl
operator|::
name|Error
name|InputLayoutCache
operator|::
name|updateInputLayout
parameter_list|(
name|gl
operator|::
name|Program
modifier|*
name|program
parameter_list|,
name|GLenum
name|mode
parameter_list|,
specifier|const
name|SortedAttribArray
modifier|&
name|sortedAttributes
parameter_list|,
specifier|const
name|SortedIndexArray
modifier|&
name|sortedSemanticIndices
parameter_list|,
name|size_t
name|attribCount
parameter_list|,
name|GLsizei
name|numIndicesPerInstance
parameter_list|)
block|{
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|sh
operator|::
name|Attribute
argument_list|>
modifier|&
name|shaderAttributes
init|=
name|program
operator|->
name|getAttributes
argument_list|()
decl_stmt|;
name|PackedAttributeLayout
name|layout
decl_stmt|;
name|ProgramD3D
modifier|*
name|programD3D
init|=
name|GetImplAs
argument_list|<
name|ProgramD3D
argument_list|>
argument_list|(
name|program
argument_list|)
decl_stmt|;
name|bool
name|programUsesInstancedPointSprites
init|=
name|programD3D
operator|->
name|usesPointSize
argument_list|()
operator|&&
name|programD3D
operator|->
name|usesInstancedPointSpriteEmulation
argument_list|()
decl_stmt|;
name|bool
name|instancedPointSpritesActive
init|=
name|programUsesInstancedPointSprites
operator|&&
operator|(
name|mode
operator|==
name|GL_POINTS
operator|)
decl_stmt|;
if|if
condition|(
name|programUsesInstancedPointSprites
condition|)
block|{
name|layout
operator|.
name|flags
operator||=
name|PackedAttributeLayout
operator|::
name|FLAG_USES_INSTANCED_SPRITES
expr_stmt|;
block|}
if|if
condition|(
name|instancedPointSpritesActive
condition|)
block|{
name|layout
operator|.
name|flags
operator||=
name|PackedAttributeLayout
operator|::
name|FLAG_INSTANCED_SPRITES_ACTIVE
expr_stmt|;
block|}
if|if
condition|(
name|numIndicesPerInstance
operator|>
literal|0
condition|)
block|{
name|layout
operator|.
name|flags
operator||=
name|PackedAttributeLayout
operator|::
name|FLAG_INSTANCED_RENDERING_ACTIVE
expr_stmt|;
block|}
specifier|const
specifier|auto
modifier|&
name|semanticToLocation
init|=
name|programD3D
operator|->
name|getAttributesByLayout
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|attribIndex
init|=
literal|0
init|;
name|attribIndex
operator|<
name|attribCount
condition|;
operator|++
name|attribIndex
control|)
block|{
specifier|const
specifier|auto
modifier|&
name|attrib
init|=
operator|*
name|sortedAttributes
index|[
name|attribIndex
index|]
decl_stmt|;
name|int
name|sortedIndex
init|=
name|sortedSemanticIndices
index|[
name|attribIndex
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|attrib
operator|.
name|active
condition|)
continue|continue;
name|gl
operator|::
name|VertexFormatType
name|vertexFormatType
init|=
name|gl
operator|::
name|GetVertexFormatType
argument_list|(
operator|*
name|attrib
operator|.
name|attribute
argument_list|,
name|attrib
operator|.
name|currentValueType
argument_list|)
decl_stmt|;
comment|// Record the type of the associated vertex shader vector in our key
comment|// This will prevent mismatched vertex shaders from using the same input layout
name|GLenum
name|glslElementType
init|=
name|GetGLSLAttributeType
argument_list|(
name|shaderAttributes
argument_list|,
name|semanticToLocation
index|[
name|sortedIndex
index|]
argument_list|)
decl_stmt|;
name|layout
operator|.
name|addAttributeData
argument_list|(
name|glslElementType
argument_list|,
name|sortedIndex
argument_list|,
name|vertexFormatType
argument_list|,
name|attrib
operator|.
name|divisor
argument_list|)
expr_stmt|;
block|}
name|ID3D11InputLayout
modifier|*
name|inputLayout
init|=
literal|nullptr
decl_stmt|;
if|if
condition|(
name|layout
operator|.
name|numAttributes
operator|>
literal|0
operator|||
name|layout
operator|.
name|flags
operator|!=
literal|0
condition|)
block|{
name|auto
name|layoutMapIt
init|=
name|mLayoutMap
operator|.
name|find
argument_list|(
name|layout
argument_list|)
decl_stmt|;
if|if
condition|(
name|layoutMapIt
operator|!=
name|mLayoutMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|inputLayout
operator|=
name|layoutMapIt
operator|->
name|second
expr_stmt|;
block|}
else|else
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|createInputLayout
argument_list|(
name|sortedAttributes
argument_list|,
name|sortedSemanticIndices
argument_list|,
name|attribCount
argument_list|,
name|mode
argument_list|,
name|program
argument_list|,
name|numIndicesPerInstance
argument_list|,
operator|&
name|inputLayout
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
name|mLayoutMap
operator|.
name|size
argument_list|()
operator|>=
name|mCacheSize
condition|)
block|{
name|TRACE
argument_list|(
literal|"Overflowed the limit of %u input layouts, purging half the cache."
argument_list|,
name|mCacheSize
argument_list|)
expr_stmt|;
comment|// Randomly release every second element
name|auto
name|it
init|=
name|mLayoutMap
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|mLayoutMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|it
operator|++
expr_stmt|;
if|if
condition|(
name|it
operator|!=
name|mLayoutMap
operator|.
name|end
argument_list|()
condition|)
block|{
comment|// c++11 erase allows us to easily delete the current iterator.
name|SafeRelease
argument_list|(
name|it
operator|->
name|second
argument_list|)
expr_stmt|;
name|it
operator|=
name|mLayoutMap
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|mLayoutMap
index|[
name|layout
index|]
operator|=
name|inputLayout
expr_stmt|;
block|}
block|}
if|if
condition|(
name|inputLayout
operator|!=
name|mCurrentIL
condition|)
block|{
name|mDeviceContext
operator|->
name|IASetInputLayout
argument_list|(
name|inputLayout
argument_list|)
expr_stmt|;
name|mCurrentIL
operator|=
name|inputLayout
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|createInputLayout
name|gl
operator|::
name|Error
name|InputLayoutCache
operator|::
name|createInputLayout
parameter_list|(
specifier|const
name|SortedAttribArray
modifier|&
name|sortedAttributes
parameter_list|,
specifier|const
name|SortedIndexArray
modifier|&
name|sortedSemanticIndices
parameter_list|,
name|size_t
name|attribCount
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|gl
operator|::
name|Program
modifier|*
name|program
parameter_list|,
name|GLsizei
name|numIndicesPerInstance
parameter_list|,
name|ID3D11InputLayout
modifier|*
modifier|*
name|inputLayoutOut
parameter_list|)
block|{
name|ProgramD3D
modifier|*
name|programD3D
init|=
name|GetImplAs
argument_list|<
name|ProgramD3D
argument_list|>
argument_list|(
name|program
argument_list|)
decl_stmt|;
name|bool
name|programUsesInstancedPointSprites
init|=
name|programD3D
operator|->
name|usesPointSize
argument_list|()
operator|&&
name|programD3D
operator|->
name|usesInstancedPointSpriteEmulation
argument_list|()
decl_stmt|;
name|unsigned
name|int
name|inputElementCount
init|=
literal|0
decl_stmt|;
name|std
operator|::
name|array
argument_list|<
name|D3D11_INPUT_ELEMENT_DESC
argument_list|,
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
argument_list|>
name|inputElements
decl_stmt|;
for|for
control|(
name|size_t
name|attribIndex
init|=
literal|0
init|;
name|attribIndex
operator|<
name|attribCount
condition|;
operator|++
name|attribIndex
control|)
block|{
specifier|const
specifier|auto
modifier|&
name|attrib
init|=
operator|*
name|sortedAttributes
index|[
name|attribIndex
index|]
decl_stmt|;
specifier|const
name|int
name|sortedIndex
init|=
name|sortedSemanticIndices
index|[
name|attribIndex
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|attrib
operator|.
name|active
condition|)
continue|continue;
name|D3D11_INPUT_CLASSIFICATION
name|inputClass
init|=
name|attrib
operator|.
name|divisor
operator|>
literal|0
condition|?
name|D3D11_INPUT_PER_INSTANCE_DATA
else|:
name|D3D11_INPUT_PER_VERTEX_DATA
decl_stmt|;
specifier|const
specifier|auto
modifier|&
name|vertexFormatType
init|=
name|gl
operator|::
name|GetVertexFormatType
argument_list|(
operator|*
name|attrib
operator|.
name|attribute
argument_list|,
name|attrib
operator|.
name|currentValueType
argument_list|)
decl_stmt|;
specifier|const
specifier|auto
modifier|&
name|vertexFormatInfo
init|=
name|d3d11
operator|::
name|GetVertexFormatInfo
argument_list|(
name|vertexFormatType
argument_list|,
name|mFeatureLevel
argument_list|)
decl_stmt|;
name|auto
operator|*
name|inputElement
operator|=
operator|&
name|inputElements
index|[
name|inputElementCount
index|]
expr_stmt|;
name|inputElement
operator|->
name|SemanticName
operator|=
literal|"TEXCOORD"
expr_stmt|;
name|inputElement
operator|->
name|SemanticIndex
operator|=
name|sortedIndex
expr_stmt|;
name|inputElement
operator|->
name|Format
operator|=
name|vertexFormatInfo
operator|.
name|nativeFormat
expr_stmt|;
name|inputElement
operator|->
name|InputSlot
operator|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|attribIndex
argument_list|)
expr_stmt|;
name|inputElement
operator|->
name|AlignedByteOffset
operator|=
literal|0
expr_stmt|;
name|inputElement
operator|->
name|InputSlotClass
operator|=
name|inputClass
expr_stmt|;
name|inputElement
operator|->
name|InstanceDataStepRate
operator|=
name|attrib
operator|.
name|divisor
expr_stmt|;
name|inputElementCount
operator|++
expr_stmt|;
block|}
comment|// Instanced PointSprite emulation requires additional entries in the
comment|// inputlayout to support the vertices that make up the pointsprite quad.
comment|// We do this even if mode != GL_POINTS, since the shader signature has these inputs, and the
comment|// input layout must match the shader
if|if
condition|(
name|programUsesInstancedPointSprites
condition|)
block|{
comment|// On 9_3, we must ensure that slot 0 contains non-instanced data.
comment|// If slot 0 currently contains instanced data then we swap it with a non-instanced element.
comment|// Note that instancing is only available on 9_3 via ANGLE_instanced_arrays, since 9_3
comment|// doesn't support OpenGL ES 3.0.
comment|// As per the spec for ANGLE_instanced_arrays, not all attributes can be instanced
comment|// simultaneously, so a non-instanced element must exist.
for|for
control|(
name|size_t
name|elementIndex
init|=
literal|0
init|;
name|elementIndex
operator|<
name|inputElementCount
condition|;
operator|++
name|elementIndex
control|)
block|{
if|if
condition|(
name|sortedAttributes
index|[
name|elementIndex
index|]
operator|->
name|active
condition|)
block|{
comment|// If rendering points and instanced pointsprite emulation is being used, the
comment|// inputClass is required to be configured as per instance data
if|if
condition|(
name|mode
operator|==
name|GL_POINTS
condition|)
block|{
name|inputElements
index|[
name|elementIndex
index|]
operator|.
name|InputSlotClass
operator|=
name|D3D11_INPUT_PER_INSTANCE_DATA
expr_stmt|;
name|inputElements
index|[
name|elementIndex
index|]
operator|.
name|InstanceDataStepRate
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|numIndicesPerInstance
operator|>
literal|0
operator|&&
name|sortedAttributes
index|[
name|elementIndex
index|]
operator|->
name|divisor
operator|>
literal|0
condition|)
block|{
name|inputElements
index|[
name|elementIndex
index|]
operator|.
name|InstanceDataStepRate
operator|=
name|numIndicesPerInstance
expr_stmt|;
block|}
block|}
name|inputElements
index|[
name|elementIndex
index|]
operator|.
name|InputSlot
operator|++
expr_stmt|;
block|}
block|}
name|inputElements
index|[
name|inputElementCount
index|]
operator|.
name|SemanticName
operator|=
literal|"SPRITEPOSITION"
expr_stmt|;
name|inputElements
index|[
name|inputElementCount
index|]
operator|.
name|SemanticIndex
operator|=
literal|0
expr_stmt|;
name|inputElements
index|[
name|inputElementCount
index|]
operator|.
name|Format
operator|=
name|DXGI_FORMAT_R32G32B32_FLOAT
expr_stmt|;
name|inputElements
index|[
name|inputElementCount
index|]
operator|.
name|InputSlot
operator|=
literal|0
expr_stmt|;
name|inputElements
index|[
name|inputElementCount
index|]
operator|.
name|AlignedByteOffset
operator|=
literal|0
expr_stmt|;
name|inputElements
index|[
name|inputElementCount
index|]
operator|.
name|InputSlotClass
operator|=
name|D3D11_INPUT_PER_VERTEX_DATA
expr_stmt|;
name|inputElements
index|[
name|inputElementCount
index|]
operator|.
name|InstanceDataStepRate
operator|=
literal|0
expr_stmt|;
name|inputElementCount
operator|++
expr_stmt|;
name|inputElements
index|[
name|inputElementCount
index|]
operator|.
name|SemanticName
operator|=
literal|"SPRITETEXCOORD"
expr_stmt|;
name|inputElements
index|[
name|inputElementCount
index|]
operator|.
name|SemanticIndex
operator|=
literal|0
expr_stmt|;
name|inputElements
index|[
name|inputElementCount
index|]
operator|.
name|Format
operator|=
name|DXGI_FORMAT_R32G32_FLOAT
expr_stmt|;
name|inputElements
index|[
name|inputElementCount
index|]
operator|.
name|InputSlot
operator|=
literal|0
expr_stmt|;
name|inputElements
index|[
name|inputElementCount
index|]
operator|.
name|AlignedByteOffset
operator|=
sizeof|sizeof
argument_list|(
name|float
argument_list|)
operator|*
literal|3
expr_stmt|;
name|inputElements
index|[
name|inputElementCount
index|]
operator|.
name|InputSlotClass
operator|=
name|D3D11_INPUT_PER_VERTEX_DATA
expr_stmt|;
name|inputElements
index|[
name|inputElementCount
index|]
operator|.
name|InstanceDataStepRate
operator|=
literal|0
expr_stmt|;
name|inputElementCount
operator|++
expr_stmt|;
block|}
specifier|const
name|gl
operator|::
name|InputLayout
modifier|&
name|shaderInputLayout
init|=
name|GetInputLayout
argument_list|(
name|sortedAttributes
argument_list|,
name|attribCount
argument_list|)
decl_stmt|;
name|ShaderExecutableD3D
modifier|*
name|shader
init|=
literal|nullptr
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|programD3D
operator|->
name|getVertexExecutableForInputLayout
argument_list|(
name|shaderInputLayout
argument_list|,
operator|&
name|shader
argument_list|,
literal|nullptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ShaderExecutableD3D
modifier|*
name|shader11
init|=
name|GetAs
argument_list|<
name|ShaderExecutable11
argument_list|>
argument_list|(
name|shader
argument_list|)
decl_stmt|;
name|HRESULT
name|result
init|=
name|mDevice
operator|->
name|CreateInputLayout
argument_list|(
name|inputElements
operator|.
name|data
argument_list|()
argument_list|,
name|inputElementCount
argument_list|,
name|shader11
operator|->
name|getFunction
argument_list|()
argument_list|,
name|shader11
operator|->
name|getLength
argument_list|()
argument_list|,
name|inputLayoutOut
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create internal input layout, HRESULT: 0x%08x"
argument_list|,
name|result
argument_list|)
return|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
block|}
end_namespace
begin_comment
comment|// namespace rx
end_comment
end_unit
