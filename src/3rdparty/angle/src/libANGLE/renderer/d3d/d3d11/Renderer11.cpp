begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2012-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Renderer11.cpp: Implements a back-end specific class for the D3D11 renderer.
end_comment
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/Renderer11.h"
end_include
begin_include
include|#
directive|include
file|<EGL/eglext.h>
end_include
begin_include
include|#
directive|include
file|<sstream>
end_include
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ANGLE_MINGW32_COMPAT
argument_list|)
operator|&&
name|WINAPI_FAMILY
operator|!=
name|WINAPI_FAMILY_PHONE_APP
end_if
begin_include
include|#
directive|include
file|<VersionHelpers.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"common/tls.h"
end_include
begin_include
include|#
directive|include
file|"common/utilities.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Buffer.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Display.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/formatutils.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Framebuffer.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/FramebufferAttachment.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/histogram_macros.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Program.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/CompilerD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/Blit11.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/Buffer11.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/Clear11.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/dxgi_support_table.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/Fence11.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/formatutils11.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/Framebuffer11.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/Image11.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/IndexBuffer11.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/PixelTransfer11.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/Query11.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/renderer11_utils.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/RenderTarget11.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/ShaderExecutable11.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/SwapChain11.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/texture_format_table.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/TextureStorage11.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/Trim11.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/VertexArray11.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/VertexBuffer11.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/CompilerD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/DeviceD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/FramebufferD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/IndexDataManager.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/ProgramD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/RenderbufferD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/ShaderD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/SurfaceD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/TextureD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/TransformFeedbackD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/VertexDataManager.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/State.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Surface.h"
end_include
begin_include
include|#
directive|include
file|"third_party/trace_event/trace_event.h"
end_include
begin_comment
comment|// Include the D3D9 debug annotator header for use by the desktop D3D11 renderer
end_comment
begin_comment
comment|// because the D3D11 interface method ID3DUserDefinedAnnotation::GetStatus
end_comment
begin_comment
comment|// doesn't work with the Graphics Diagnostics tools in Visual Studio 2013.
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|ANGLE_ENABLE_D3D9
end_ifdef
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d9/DebugAnnotator9.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// Enable ANGLE_SKIP_DXGI_1_2_CHECK if there is not a possibility of using cross-process
end_comment
begin_comment
comment|// HWNDs or the Windows 7 Platform Update (KB2670838) is expected to be installed.
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|ANGLE_SKIP_DXGI_1_2_CHECK
end_ifndef
begin_define
DECL|macro|ANGLE_SKIP_DXGI_1_2_CHECK
define|#
directive|define
name|ANGLE_SKIP_DXGI_1_2_CHECK
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|_DEBUG
end_ifdef
begin_comment
comment|// this flag enables suppressing some spurious warnings that pop up in certain WebGL samples
end_comment
begin_comment
comment|// and conformance tests. to enable all warnings, remove this define.
end_comment
begin_define
DECL|macro|ANGLE_SUPPRESS_D3D11_HAZARD_WARNINGS
define|#
directive|define
name|ANGLE_SUPPRESS_D3D11_HAZARD_WARNINGS
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_namespace
DECL|namespace|rx
namespace|namespace
name|rx
block|{
namespace|namespace
block|{
enum|enum
block|{
DECL|enumerator|MAX_TEXTURE_IMAGE_UNITS_VTF_SM4
name|MAX_TEXTURE_IMAGE_UNITS_VTF_SM4
init|=
literal|16
block|}
enum|;
if|#
directive|if
name|defined
argument_list|(
name|ANGLE_ENABLE_D3D11_1
argument_list|)
DECL|function|CalculateConstantBufferParams
name|void
name|CalculateConstantBufferParams
parameter_list|(
name|GLintptr
name|offset
parameter_list|,
name|GLsizeiptr
name|size
parameter_list|,
name|UINT
modifier|*
name|outFirstConstant
parameter_list|,
name|UINT
modifier|*
name|outNumConstants
parameter_list|)
block|{
comment|// The offset must be aligned to 256 bytes (should have been enforced by glBindBufferRange).
name|ASSERT
argument_list|(
name|offset
operator|%
literal|256
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|// firstConstant and numConstants are expressed in constants of 16-bytes. Furthermore they must be a multiple of 16 constants.
operator|*
name|outFirstConstant
operator|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|offset
operator|/
literal|16
argument_list|)
expr_stmt|;
comment|// The GL size is not required to be aligned to a 256 bytes boundary.
comment|// Round the size up to a 256 bytes boundary then express the results in constants of 16-bytes.
operator|*
name|outNumConstants
operator|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|rx
operator|::
name|roundUp
argument_list|(
name|size
argument_list|,
cast|static_cast
argument_list|<
name|GLsizeiptr
argument_list|>
argument_list|(
literal|256
argument_list|)
argument_list|)
operator|/
literal|16
argument_list|)
expr_stmt|;
comment|// Since the size is rounded up, firstConstant + numConstants may be bigger than the actual size of the buffer.
comment|// This behaviour is explictly allowed according to the documentation on ID3D11DeviceContext1::PSSetConstantBuffers1
comment|// https://msdn.microsoft.com/en-us/library/windows/desktop/hh404649%28v=vs.85%29.aspx
block|}
endif|#
directive|endif
DECL|enum|ANGLEFeatureLevel
enum|enum
name|ANGLEFeatureLevel
block|{
DECL|enumerator|ANGLE_FEATURE_LEVEL_INVALID
name|ANGLE_FEATURE_LEVEL_INVALID
block|,
DECL|enumerator|ANGLE_FEATURE_LEVEL_9_3
name|ANGLE_FEATURE_LEVEL_9_3
block|,
DECL|enumerator|ANGLE_FEATURE_LEVEL_10_0
name|ANGLE_FEATURE_LEVEL_10_0
block|,
DECL|enumerator|ANGLE_FEATURE_LEVEL_10_1
name|ANGLE_FEATURE_LEVEL_10_1
block|,
DECL|enumerator|ANGLE_FEATURE_LEVEL_11_0
name|ANGLE_FEATURE_LEVEL_11_0
block|,
DECL|enumerator|ANGLE_FEATURE_LEVEL_11_1
name|ANGLE_FEATURE_LEVEL_11_1
block|,
DECL|enumerator|NUM_ANGLE_FEATURE_LEVELS
name|NUM_ANGLE_FEATURE_LEVELS
block|}
enum|;
DECL|function|GetANGLEFeatureLevel
name|ANGLEFeatureLevel
name|GetANGLEFeatureLevel
parameter_list|(
name|D3D_FEATURE_LEVEL
name|d3dFeatureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|d3dFeatureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
return|return
name|ANGLE_FEATURE_LEVEL_9_3
return|;
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|ANGLE_FEATURE_LEVEL_10_0
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
return|return
name|ANGLE_FEATURE_LEVEL_10_1
return|;
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|ANGLE_FEATURE_LEVEL_11_0
return|;
comment|// Note: we don't ever request a 11_1 device, because this gives
comment|// an E_INVALIDARG error on systems that don't have the platform update.
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
return|return
name|ANGLE_FEATURE_LEVEL_11_1
return|;
default|default:
return|return
name|ANGLE_FEATURE_LEVEL_INVALID
return|;
block|}
block|}
DECL|function|SetLineLoopIndices
name|void
name|SetLineLoopIndices
parameter_list|(
name|GLuint
modifier|*
name|dest
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|dest
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|dest
index|[
name|count
index|]
operator|=
literal|0
expr_stmt|;
block|}
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|CopyLineLoopIndices
name|void
name|CopyLineLoopIndices
parameter_list|(
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|GLuint
modifier|*
name|dest
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
specifier|const
name|T
modifier|*
name|srcPtr
init|=
cast|static_cast
argument_list|<
specifier|const
name|T
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|dest
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|srcPtr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|dest
index|[
name|count
index|]
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|srcPtr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
DECL|function|SetTriangleFanIndices
name|void
name|SetTriangleFanIndices
parameter_list|(
name|GLuint
modifier|*
name|destPtr
parameter_list|,
name|size_t
name|numTris
parameter_list|)
block|{
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numTris
condition|;
name|i
operator|++
control|)
block|{
name|destPtr
index|[
name|i
operator|*
literal|3
operator|+
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|destPtr
index|[
name|i
operator|*
literal|3
operator|+
literal|1
index|]
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|i
argument_list|)
operator|+
literal|1
expr_stmt|;
name|destPtr
index|[
name|i
operator|*
literal|3
operator|+
literal|2
index|]
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|i
argument_list|)
operator|+
literal|2
expr_stmt|;
block|}
block|}
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|CopyLineLoopIndicesWithRestart
name|void
name|CopyLineLoopIndicesWithRestart
parameter_list|(
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|size_t
name|count
parameter_list|,
name|GLenum
name|indexType
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|GLuint
argument_list|>
modifier|*
name|bufferOut
parameter_list|)
block|{
name|GLuint
name|restartIndex
init|=
name|gl
operator|::
name|GetPrimitiveRestartIndex
argument_list|(
name|indexType
argument_list|)
decl_stmt|;
name|GLuint
name|d3dRestartIndex
init|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|d3d11
operator|::
name|GetPrimitiveRestartIndex
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|T
modifier|*
name|srcPtr
init|=
cast|static_cast
argument_list|<
specifier|const
name|T
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
decl_stmt|;
name|Optional
argument_list|<
name|GLuint
argument_list|>
name|currentLoopStart
decl_stmt|;
name|bufferOut
operator|->
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|size_t
name|indexIdx
init|=
literal|0
init|;
name|indexIdx
operator|<
name|count
condition|;
operator|++
name|indexIdx
control|)
block|{
name|GLuint
name|value
init|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|srcPtr
index|[
name|indexIdx
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
name|restartIndex
condition|)
block|{
if|if
condition|(
name|currentLoopStart
operator|.
name|valid
argument_list|()
condition|)
block|{
name|bufferOut
operator|->
name|push_back
argument_list|(
name|currentLoopStart
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|bufferOut
operator|->
name|push_back
argument_list|(
name|d3dRestartIndex
argument_list|)
expr_stmt|;
name|currentLoopStart
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|bufferOut
operator|->
name|push_back
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|currentLoopStart
operator|.
name|valid
argument_list|()
condition|)
block|{
name|currentLoopStart
operator|=
name|value
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|currentLoopStart
operator|.
name|valid
argument_list|()
condition|)
block|{
name|bufferOut
operator|->
name|push_back
argument_list|(
name|currentLoopStart
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|GetLineLoopIndices
name|void
name|GetLineLoopIndices
parameter_list|(
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|GLenum
name|indexType
parameter_list|,
name|GLuint
name|count
parameter_list|,
name|bool
name|usePrimitiveRestartFixedIndex
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|GLuint
argument_list|>
modifier|*
name|bufferOut
parameter_list|)
block|{
if|if
condition|(
name|indexType
operator|!=
name|GL_NONE
operator|&&
name|usePrimitiveRestartFixedIndex
condition|)
block|{
switch|switch
condition|(
name|indexType
condition|)
block|{
case|case
name|GL_UNSIGNED_BYTE
case|:
name|CopyLineLoopIndicesWithRestart
argument_list|<
name|GLubyte
argument_list|>
argument_list|(
name|indices
argument_list|,
name|count
argument_list|,
name|indexType
argument_list|,
name|bufferOut
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_SHORT
case|:
name|CopyLineLoopIndicesWithRestart
argument_list|<
name|GLushort
argument_list|>
argument_list|(
name|indices
argument_list|,
name|count
argument_list|,
name|indexType
argument_list|,
name|bufferOut
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_INT
case|:
name|CopyLineLoopIndicesWithRestart
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|indices
argument_list|,
name|count
argument_list|,
name|indexType
argument_list|,
name|bufferOut
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
return|return;
block|}
comment|// For non-primitive-restart draws, the index count is static.
name|bufferOut
operator|->
name|resize
argument_list|(
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|count
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|indexType
condition|)
block|{
comment|// Non-indexed draw
case|case
name|GL_NONE
case|:
name|SetLineLoopIndices
argument_list|(
operator|&
operator|(
operator|*
name|bufferOut
operator|)
index|[
literal|0
index|]
argument_list|,
name|count
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_BYTE
case|:
name|CopyLineLoopIndices
argument_list|<
name|GLubyte
argument_list|>
argument_list|(
name|indices
argument_list|,
operator|&
operator|(
operator|*
name|bufferOut
operator|)
index|[
literal|0
index|]
argument_list|,
name|count
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_SHORT
case|:
name|CopyLineLoopIndices
argument_list|<
name|GLushort
argument_list|>
argument_list|(
name|indices
argument_list|,
operator|&
operator|(
operator|*
name|bufferOut
operator|)
index|[
literal|0
index|]
argument_list|,
name|count
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_INT
case|:
name|CopyLineLoopIndices
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|indices
argument_list|,
operator|&
operator|(
operator|*
name|bufferOut
operator|)
index|[
literal|0
index|]
argument_list|,
name|count
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|CopyTriangleFanIndices
name|void
name|CopyTriangleFanIndices
parameter_list|(
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|GLuint
modifier|*
name|destPtr
parameter_list|,
name|size_t
name|numTris
parameter_list|)
block|{
specifier|const
name|T
modifier|*
name|srcPtr
init|=
cast|static_cast
argument_list|<
specifier|const
name|T
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numTris
condition|;
name|i
operator|++
control|)
block|{
name|destPtr
index|[
name|i
operator|*
literal|3
operator|+
literal|0
index|]
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|srcPtr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|destPtr
index|[
name|i
operator|*
literal|3
operator|+
literal|1
index|]
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|srcPtr
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|destPtr
index|[
name|i
operator|*
literal|3
operator|+
literal|2
index|]
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|srcPtr
index|[
name|i
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|CopyTriangleFanIndicesWithRestart
name|void
name|CopyTriangleFanIndicesWithRestart
parameter_list|(
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|GLuint
name|indexCount
parameter_list|,
name|GLenum
name|indexType
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|GLuint
argument_list|>
modifier|*
name|bufferOut
parameter_list|)
block|{
name|GLuint
name|restartIndex
init|=
name|gl
operator|::
name|GetPrimitiveRestartIndex
argument_list|(
name|indexType
argument_list|)
decl_stmt|;
name|GLuint
name|d3dRestartIndex
init|=
name|gl
operator|::
name|GetPrimitiveRestartIndex
argument_list|(
name|GL_UNSIGNED_INT
argument_list|)
decl_stmt|;
specifier|const
name|T
modifier|*
name|srcPtr
init|=
cast|static_cast
argument_list|<
specifier|const
name|T
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
decl_stmt|;
name|Optional
argument_list|<
name|GLuint
argument_list|>
name|vertexA
decl_stmt|;
name|Optional
argument_list|<
name|GLuint
argument_list|>
name|vertexB
decl_stmt|;
name|bufferOut
operator|->
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|size_t
name|indexIdx
init|=
literal|0
init|;
name|indexIdx
operator|<
name|indexCount
condition|;
operator|++
name|indexIdx
control|)
block|{
name|GLuint
name|value
init|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|srcPtr
index|[
name|indexIdx
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
name|restartIndex
condition|)
block|{
name|bufferOut
operator|->
name|push_back
argument_list|(
name|d3dRestartIndex
argument_list|)
expr_stmt|;
name|vertexA
operator|.
name|reset
argument_list|()
expr_stmt|;
name|vertexB
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|vertexA
operator|.
name|valid
argument_list|()
condition|)
block|{
name|vertexA
operator|=
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|vertexB
operator|.
name|valid
argument_list|()
condition|)
block|{
name|vertexB
operator|=
name|value
expr_stmt|;
block|}
else|else
block|{
name|bufferOut
operator|->
name|push_back
argument_list|(
name|vertexA
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|bufferOut
operator|->
name|push_back
argument_list|(
name|vertexB
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|bufferOut
operator|->
name|push_back
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|vertexB
operator|=
name|value
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|function|GetTriFanIndices
name|void
name|GetTriFanIndices
parameter_list|(
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|GLenum
name|indexType
parameter_list|,
name|GLuint
name|count
parameter_list|,
name|bool
name|usePrimitiveRestartFixedIndex
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|GLuint
argument_list|>
modifier|*
name|bufferOut
parameter_list|)
block|{
if|if
condition|(
name|indexType
operator|!=
name|GL_NONE
operator|&&
name|usePrimitiveRestartFixedIndex
condition|)
block|{
switch|switch
condition|(
name|indexType
condition|)
block|{
case|case
name|GL_UNSIGNED_BYTE
case|:
name|CopyTriangleFanIndicesWithRestart
argument_list|<
name|GLubyte
argument_list|>
argument_list|(
name|indices
argument_list|,
name|count
argument_list|,
name|indexType
argument_list|,
name|bufferOut
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_SHORT
case|:
name|CopyTriangleFanIndicesWithRestart
argument_list|<
name|GLushort
argument_list|>
argument_list|(
name|indices
argument_list|,
name|count
argument_list|,
name|indexType
argument_list|,
name|bufferOut
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_INT
case|:
name|CopyTriangleFanIndicesWithRestart
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|indices
argument_list|,
name|count
argument_list|,
name|indexType
argument_list|,
name|bufferOut
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
return|return;
block|}
comment|// For non-primitive-restart draws, the index count is static.
name|GLuint
name|numTris
init|=
name|count
operator|-
literal|2
decl_stmt|;
name|bufferOut
operator|->
name|resize
argument_list|(
name|numTris
operator|*
literal|3
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|indexType
condition|)
block|{
comment|// Non-indexed draw
case|case
name|GL_NONE
case|:
name|SetTriangleFanIndices
argument_list|(
operator|&
operator|(
operator|*
name|bufferOut
operator|)
index|[
literal|0
index|]
argument_list|,
name|numTris
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_BYTE
case|:
name|CopyTriangleFanIndices
argument_list|<
name|GLubyte
argument_list|>
argument_list|(
name|indices
argument_list|,
operator|&
operator|(
operator|*
name|bufferOut
operator|)
index|[
literal|0
index|]
argument_list|,
name|numTris
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_SHORT
case|:
name|CopyTriangleFanIndices
argument_list|<
name|GLushort
argument_list|>
argument_list|(
name|indices
argument_list|,
operator|&
operator|(
operator|*
name|bufferOut
operator|)
index|[
literal|0
index|]
argument_list|,
name|numTris
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_INT
case|:
name|CopyTriangleFanIndices
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|indices
argument_list|,
operator|&
operator|(
operator|*
name|bufferOut
operator|)
index|[
literal|0
index|]
argument_list|,
name|numTris
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|// anonymous namespace
DECL|function|Renderer11
name|Renderer11
operator|::
name|Renderer11
parameter_list|(
name|egl
operator|::
name|Display
modifier|*
name|display
parameter_list|)
member_init_list|:
name|RendererD3D
argument_list|(
name|display
argument_list|)
member_init_list|,
name|mStateCache
argument_list|(
name|this
argument_list|)
member_init_list|,
name|mStateManager
argument_list|(
name|this
argument_list|)
member_init_list|,
name|mLastHistogramUpdateTime
argument_list|(
name|ANGLEPlatformCurrent
argument_list|()
operator|->
name|monotonicallyIncreasingTime
argument_list|()
argument_list|)
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ANGLE_MINGW32_COMPAT
argument_list|)
member_init_list|,
name|mDebug
argument_list|(
literal|nullptr
argument_list|)
endif|#
directive|endif
block|{
name|mVertexDataManager
operator|=
name|NULL
expr_stmt|;
name|mIndexDataManager
operator|=
name|NULL
expr_stmt|;
name|mLineLoopIB
operator|=
name|NULL
expr_stmt|;
name|mTriangleFanIB
operator|=
name|NULL
expr_stmt|;
name|mAppliedIBChanged
operator|=
literal|false
expr_stmt|;
name|mBlit
operator|=
name|NULL
expr_stmt|;
name|mPixelTransfer
operator|=
name|NULL
expr_stmt|;
name|mClear
operator|=
name|NULL
expr_stmt|;
name|mTrim
operator|=
name|NULL
expr_stmt|;
name|mSyncQuery
operator|=
name|NULL
expr_stmt|;
name|mRenderer11DeviceCaps
operator|.
name|supportsClearView
operator|=
literal|false
expr_stmt|;
name|mRenderer11DeviceCaps
operator|.
name|supportsConstantBufferOffsets
operator|=
literal|false
expr_stmt|;
name|mRenderer11DeviceCaps
operator|.
name|supportsDXGI1_2
operator|=
literal|false
expr_stmt|;
name|mRenderer11DeviceCaps
operator|.
name|B5G6R5support
operator|=
literal|0
expr_stmt|;
name|mRenderer11DeviceCaps
operator|.
name|B4G4R4A4support
operator|=
literal|0
expr_stmt|;
name|mRenderer11DeviceCaps
operator|.
name|B5G5R5A1support
operator|=
literal|0
expr_stmt|;
name|mD3d11Module
operator|=
name|NULL
expr_stmt|;
name|mDxgiModule
operator|=
name|NULL
expr_stmt|;
name|mDCompModule
operator|=
name|NULL
expr_stmt|;
name|mCreatedWithDeviceEXT
operator|=
literal|false
expr_stmt|;
name|mEGLDevice
operator|=
literal|nullptr
expr_stmt|;
name|mDevice
operator|=
name|NULL
expr_stmt|;
name|mDeviceContext
operator|=
name|NULL
expr_stmt|;
name|mDeviceContext1
operator|=
name|NULL
expr_stmt|;
name|mDxgiAdapter
operator|=
name|NULL
expr_stmt|;
name|mDxgiFactory
operator|=
name|NULL
expr_stmt|;
name|mDriverConstantBufferVS
operator|=
name|NULL
expr_stmt|;
name|mDriverConstantBufferPS
operator|=
name|NULL
expr_stmt|;
name|mAppliedVertexShader
operator|=
name|NULL
expr_stmt|;
name|mAppliedGeometryShader
operator|=
name|NULL
expr_stmt|;
name|mAppliedPixelShader
operator|=
name|NULL
expr_stmt|;
name|mAppliedNumXFBBindings
operator|=
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ZeroMemory
argument_list|(
operator|&
name|mAdapterDescription
argument_list|,
sizeof|sizeof
argument_list|(
name|mAdapterDescription
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mDisplay
operator|->
name|getPlatform
argument_list|()
operator|==
name|EGL_PLATFORM_ANGLE_ANGLE
condition|)
block|{
specifier|const
specifier|auto
modifier|&
name|attributes
init|=
name|mDisplay
operator|->
name|getAttributeMap
argument_list|()
decl_stmt|;
name|EGLint
name|requestedMajorVersion
init|=
name|attributes
operator|.
name|get
argument_list|(
name|EGL_PLATFORM_ANGLE_MAX_VERSION_MAJOR_ANGLE
argument_list|,
name|EGL_DONT_CARE
argument_list|)
decl_stmt|;
name|EGLint
name|requestedMinorVersion
init|=
name|attributes
operator|.
name|get
argument_list|(
name|EGL_PLATFORM_ANGLE_MAX_VERSION_MINOR_ANGLE
argument_list|,
name|EGL_DONT_CARE
argument_list|)
decl_stmt|;
if|if
condition|(
name|requestedMajorVersion
operator|==
name|EGL_DONT_CARE
operator|||
name|requestedMajorVersion
operator|>=
literal|11
condition|)
block|{
if|if
condition|(
name|requestedMinorVersion
operator|==
name|EGL_DONT_CARE
operator|||
name|requestedMinorVersion
operator|>=
literal|0
condition|)
block|{
name|mAvailableFeatureLevels
operator|.
name|push_back
argument_list|(
name|D3D_FEATURE_LEVEL_11_0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|requestedMajorVersion
operator|==
name|EGL_DONT_CARE
operator|||
name|requestedMajorVersion
operator|>=
literal|10
condition|)
block|{
if|if
condition|(
name|requestedMinorVersion
operator|==
name|EGL_DONT_CARE
operator|||
name|requestedMinorVersion
operator|>=
literal|1
condition|)
block|{
name|mAvailableFeatureLevels
operator|.
name|push_back
argument_list|(
name|D3D_FEATURE_LEVEL_10_1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|requestedMinorVersion
operator|==
name|EGL_DONT_CARE
operator|||
name|requestedMinorVersion
operator|>=
literal|0
condition|)
block|{
name|mAvailableFeatureLevels
operator|.
name|push_back
argument_list|(
name|D3D_FEATURE_LEVEL_10_0
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|ANGLE_ENABLE_WINDOWS_STORE
argument_list|)
if|if
condition|(
name|requestedMajorVersion
operator|==
name|EGL_DONT_CARE
operator|||
name|requestedMajorVersion
operator|>=
literal|9
condition|)
else|#
directive|else
if|if
condition|(
name|requestedMajorVersion
operator|==
literal|9
operator|&&
name|requestedMinorVersion
operator|==
literal|3
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
name|requestedMinorVersion
operator|==
name|EGL_DONT_CARE
operator|||
name|requestedMinorVersion
operator|>=
literal|3
condition|)
block|{
name|mAvailableFeatureLevels
operator|.
name|push_back
argument_list|(
name|D3D_FEATURE_LEVEL_9_3
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|ANGLE_ENABLE_WINDOWS_STORE
argument_list|)
if|if
condition|(
name|requestedMinorVersion
operator|==
name|EGL_DONT_CARE
operator|||
name|requestedMinorVersion
operator|>=
literal|2
condition|)
block|{
name|mAvailableFeatureLevels
operator|.
name|push_back
argument_list|(
name|D3D_FEATURE_LEVEL_9_2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|requestedMinorVersion
operator|==
name|EGL_DONT_CARE
operator|||
name|requestedMinorVersion
operator|>=
literal|1
condition|)
block|{
name|mAvailableFeatureLevels
operator|.
name|push_back
argument_list|(
name|D3D_FEATURE_LEVEL_9_1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|EGLint
name|requestedDeviceType
init|=
name|attributes
operator|.
name|get
argument_list|(
name|EGL_PLATFORM_ANGLE_DEVICE_TYPE_ANGLE
argument_list|,
name|EGL_PLATFORM_ANGLE_DEVICE_TYPE_HARDWARE_ANGLE
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|requestedDeviceType
condition|)
block|{
case|case
name|EGL_PLATFORM_ANGLE_DEVICE_TYPE_HARDWARE_ANGLE
case|:
name|mRequestedDriverType
operator|=
name|D3D_DRIVER_TYPE_HARDWARE
expr_stmt|;
break|break;
case|case
name|EGL_PLATFORM_ANGLE_DEVICE_TYPE_WARP_ANGLE
case|:
name|mRequestedDriverType
operator|=
name|D3D_DRIVER_TYPE_WARP
expr_stmt|;
break|break;
case|case
name|EGL_PLATFORM_ANGLE_DEVICE_TYPE_REFERENCE_ANGLE
case|:
name|mRequestedDriverType
operator|=
name|D3D_DRIVER_TYPE_REFERENCE
expr_stmt|;
break|break;
case|case
name|EGL_PLATFORM_ANGLE_DEVICE_TYPE_NULL_ANGLE
case|:
name|mRequestedDriverType
operator|=
name|D3D_DRIVER_TYPE_NULL
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
specifier|const
name|EGLenum
name|presentPath
init|=
name|attributes
operator|.
name|get
argument_list|(
name|EGL_EXPERIMENTAL_PRESENT_PATH_ANGLE
argument_list|,
name|EGL_EXPERIMENTAL_PRESENT_PATH_COPY_ANGLE
argument_list|)
decl_stmt|;
name|mPresentPathFastEnabled
operator|=
operator|(
name|presentPath
operator|==
name|EGL_EXPERIMENTAL_PRESENT_PATH_FAST_ANGLE
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|display
operator|->
name|getPlatform
argument_list|()
operator|==
name|EGL_PLATFORM_DEVICE_EXT
condition|)
block|{
name|mEGLDevice
operator|=
name|GetImplAs
argument_list|<
name|DeviceD3D
argument_list|>
argument_list|(
name|display
operator|->
name|getDevice
argument_list|()
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mEGLDevice
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
name|mCreatedWithDeviceEXT
operator|=
literal|true
expr_stmt|;
comment|// Also set EGL_PLATFORM_ANGLE_ANGLE variables, in case they're used elsewhere in ANGLE
comment|// mAvailableFeatureLevels defaults to empty
name|mRequestedDriverType
operator|=
name|D3D_DRIVER_TYPE_UNKNOWN
expr_stmt|;
name|mPresentPathFastEnabled
operator|=
literal|false
expr_stmt|;
block|}
name|initializeDebugAnnotator
argument_list|()
expr_stmt|;
block|}
DECL|function|~Renderer11
name|Renderer11
operator|::
name|~
name|Renderer11
parameter_list|()
block|{
name|release
argument_list|()
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|__d3d11_1_h__
DECL|macro|D3D11_MESSAGE_ID_DEVICE_DRAW_RENDERTARGETVIEW_NOT_SET
define|#
directive|define
name|D3D11_MESSAGE_ID_DEVICE_DRAW_RENDERTARGETVIEW_NOT_SET
value|((D3D11_MESSAGE_ID)3146081)
endif|#
directive|endif
DECL|function|initialize
name|egl
operator|::
name|Error
name|Renderer11
operator|::
name|initialize
parameter_list|()
block|{
name|HRESULT
name|result
init|=
name|S_OK
decl_stmt|;
name|egl
operator|::
name|Error
name|error
init|=
name|initializeD3DDevice
argument_list|()
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ANGLE_ENABLE_WINDOWS_STORE
argument_list|)
if|#
directive|if
operator|!
name|ANGLE_SKIP_DXGI_1_2_CHECK
block|{
name|TRACE_EVENT0
argument_list|(
literal|"gpu.angle"
argument_list|,
literal|"Renderer11::initialize (DXGICheck)"
argument_list|)
expr_stmt|;
comment|// In order to create a swap chain for an HWND owned by another process, DXGI 1.2 is required.
comment|// The easiest way to check is to query for a IDXGIDevice2.
name|bool
name|requireDXGI1_2
init|=
literal|false
decl_stmt|;
name|HWND
name|hwnd
init|=
name|WindowFromDC
argument_list|(
name|mDisplay
operator|->
name|getNativeDisplayId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|hwnd
condition|)
block|{
name|DWORD
name|currentProcessId
init|=
name|GetCurrentProcessId
argument_list|()
decl_stmt|;
name|DWORD
name|wndProcessId
decl_stmt|;
name|GetWindowThreadProcessId
argument_list|(
name|hwnd
argument_list|,
operator|&
name|wndProcessId
argument_list|)
expr_stmt|;
name|requireDXGI1_2
operator|=
operator|(
name|currentProcessId
operator|!=
name|wndProcessId
operator|)
expr_stmt|;
block|}
else|else
block|{
name|requireDXGI1_2
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|requireDXGI1_2
condition|)
block|{
name|IDXGIDevice2
modifier|*
name|dxgiDevice2
init|=
name|NULL
decl_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|QueryInterface
argument_list|(
name|__uuidof
argument_list|(
name|IDXGIDevice2
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dxgiDevice2
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|egl
operator|::
name|Error
argument_list|(
name|EGL_NOT_INITIALIZED
argument_list|,
name|D3D11_INIT_INCOMPATIBLE_DXGI
argument_list|,
literal|"DXGI 1.2 required to present to HWNDs owned by another process."
argument_list|)
return|;
block|}
name|SafeRelease
argument_list|(
name|dxgiDevice2
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
endif|#
directive|endif
block|{
name|TRACE_EVENT0
argument_list|(
literal|"gpu.angle"
argument_list|,
literal|"Renderer11::initialize (ComQueries)"
argument_list|)
expr_stmt|;
comment|// Cast the DeviceContext to a DeviceContext1.
comment|// This could fail on Windows 7 without the Platform Update.
comment|// Don't error in this case- just don't use mDeviceContext1.
if|#
directive|if
name|defined
argument_list|(
name|ANGLE_ENABLE_D3D11_1
argument_list|)
name|mDeviceContext1
operator|=
name|d3d11
operator|::
name|DynamicCastComObject
argument_list|<
name|ID3D11DeviceContext1
argument_list|>
argument_list|(
name|mDeviceContext
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|IDXGIDevice
modifier|*
name|dxgiDevice
init|=
name|NULL
decl_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|QueryInterface
argument_list|(
name|__uuidof
argument_list|(
name|IDXGIDevice
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dxgiDevice
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|egl
operator|::
name|Error
argument_list|(
name|EGL_NOT_INITIALIZED
argument_list|,
name|D3D11_INIT_OTHER_ERROR
argument_list|,
literal|"Could not query DXGI device."
argument_list|)
return|;
block|}
name|result
operator|=
name|dxgiDevice
operator|->
name|GetParent
argument_list|(
name|__uuidof
argument_list|(
name|IDXGIAdapter
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|mDxgiAdapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|egl
operator|::
name|Error
argument_list|(
name|EGL_NOT_INITIALIZED
argument_list|,
name|D3D11_INIT_OTHER_ERROR
argument_list|,
literal|"Could not retrieve DXGI adapter"
argument_list|)
return|;
block|}
name|SafeRelease
argument_list|(
name|dxgiDevice
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ANGLE_ENABLE_D3D11_1
argument_list|)
name|IDXGIAdapter2
modifier|*
name|dxgiAdapter2
init|=
name|d3d11
operator|::
name|DynamicCastComObject
argument_list|<
name|IDXGIAdapter2
argument_list|>
argument_list|(
name|mDxgiAdapter
argument_list|)
decl_stmt|;
comment|// On D3D_FEATURE_LEVEL_9_*, IDXGIAdapter::GetDesc returns "Software Adapter" for the description string.
comment|// If DXGI1.2 is available then IDXGIAdapter2::GetDesc2 can be used to get the actual hardware values.
if|if
condition|(
name|mRenderer11DeviceCaps
operator|.
name|featureLevel
operator|<=
name|D3D_FEATURE_LEVEL_9_3
operator|&&
name|dxgiAdapter2
operator|!=
name|NULL
condition|)
block|{
name|DXGI_ADAPTER_DESC2
name|adapterDesc2
init|=
block|{}
decl_stmt|;
name|result
operator|=
name|dxgiAdapter2
operator|->
name|GetDesc2
argument_list|(
operator|&
name|adapterDesc2
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
condition|)
block|{
comment|// Copy the contents of the DXGI_ADAPTER_DESC2 into mAdapterDescription (a DXGI_ADAPTER_DESC).
name|memcpy
argument_list|(
name|mAdapterDescription
operator|.
name|Description
argument_list|,
name|adapterDesc2
operator|.
name|Description
argument_list|,
sizeof|sizeof
argument_list|(
name|mAdapterDescription
operator|.
name|Description
argument_list|)
argument_list|)
expr_stmt|;
name|mAdapterDescription
operator|.
name|VendorId
operator|=
name|adapterDesc2
operator|.
name|VendorId
expr_stmt|;
name|mAdapterDescription
operator|.
name|DeviceId
operator|=
name|adapterDesc2
operator|.
name|DeviceId
expr_stmt|;
name|mAdapterDescription
operator|.
name|SubSysId
operator|=
name|adapterDesc2
operator|.
name|SubSysId
expr_stmt|;
name|mAdapterDescription
operator|.
name|Revision
operator|=
name|adapterDesc2
operator|.
name|Revision
expr_stmt|;
name|mAdapterDescription
operator|.
name|DedicatedVideoMemory
operator|=
name|adapterDesc2
operator|.
name|DedicatedVideoMemory
expr_stmt|;
name|mAdapterDescription
operator|.
name|DedicatedSystemMemory
operator|=
name|adapterDesc2
operator|.
name|DedicatedSystemMemory
expr_stmt|;
name|mAdapterDescription
operator|.
name|SharedSystemMemory
operator|=
name|adapterDesc2
operator|.
name|SharedSystemMemory
expr_stmt|;
name|mAdapterDescription
operator|.
name|AdapterLuid
operator|=
name|adapterDesc2
operator|.
name|AdapterLuid
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
name|result
operator|=
name|mDxgiAdapter
operator|->
name|GetDesc
argument_list|(
operator|&
name|mAdapterDescription
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|ANGLE_ENABLE_D3D11_1
argument_list|)
name|SafeRelease
argument_list|(
name|dxgiAdapter2
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|egl
operator|::
name|Error
argument_list|(
name|EGL_NOT_INITIALIZED
argument_list|,
name|D3D11_INIT_OTHER_ERROR
argument_list|,
literal|"Could not read DXGI adaptor description."
argument_list|)
return|;
block|}
name|memset
argument_list|(
name|mDescription
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mDescription
argument_list|)
argument_list|)
expr_stmt|;
name|wcstombs
argument_list|(
name|mDescription
argument_list|,
name|mAdapterDescription
operator|.
name|Description
argument_list|,
sizeof|sizeof
argument_list|(
name|mDescription
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|mDxgiAdapter
operator|->
name|GetParent
argument_list|(
name|__uuidof
argument_list|(
name|IDXGIFactory
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|mDxgiFactory
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mDxgiFactory
operator|||
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|egl
operator|::
name|Error
argument_list|(
name|EGL_NOT_INITIALIZED
argument_list|,
name|D3D11_INIT_OTHER_ERROR
argument_list|,
literal|"Could not create DXGI factory."
argument_list|)
return|;
block|}
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ANGLE_MINGW32_COMPAT
argument_list|)
comment|// Disable some spurious D3D11 debug warnings to prevent them from flooding the output log
if|#
directive|if
name|defined
argument_list|(
name|ANGLE_SUPPRESS_D3D11_HAZARD_WARNINGS
argument_list|)
operator|&&
name|defined
argument_list|(
name|_DEBUG
argument_list|)
block|{
name|TRACE_EVENT0
argument_list|(
literal|"gpu.angle"
argument_list|,
literal|"Renderer11::initialize (HideWarnings)"
argument_list|)
expr_stmt|;
name|ID3D11InfoQueue
modifier|*
name|infoQueue
decl_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|QueryInterface
argument_list|(
name|__uuidof
argument_list|(
name|ID3D11InfoQueue
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|infoQueue
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|D3D11_MESSAGE_ID
name|hideMessages
index|[]
init|=
block|{
name|D3D11_MESSAGE_ID_DEVICE_DRAW_RENDERTARGETVIEW_NOT_SET
block|}
decl_stmt|;
name|D3D11_INFO_QUEUE_FILTER
name|filter
init|=
block|{}
decl_stmt|;
name|filter
operator|.
name|DenyList
operator|.
name|NumIDs
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|ArraySize
argument_list|(
name|hideMessages
argument_list|)
argument_list|)
expr_stmt|;
name|filter
operator|.
name|DenyList
operator|.
name|pIDList
operator|=
name|hideMessages
expr_stmt|;
name|infoQueue
operator|->
name|AddStorageFilterEntries
argument_list|(
operator|&
name|filter
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|infoQueue
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NDEBUG
argument_list|)
name|mDebug
operator|=
name|d3d11
operator|::
name|DynamicCastComObject
argument_list|<
name|ID3D11Debug
argument_list|>
argument_list|(
name|mDevice
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|// !ANGLE_MINGW32_COMPAT
name|initializeDevice
argument_list|()
expr_stmt|;
return|return
name|egl
operator|::
name|Error
argument_list|(
name|EGL_SUCCESS
argument_list|)
return|;
block|}
DECL|function|initializeD3DDevice
name|egl
operator|::
name|Error
name|Renderer11
operator|::
name|initializeD3DDevice
parameter_list|()
block|{
name|HRESULT
name|result
init|=
name|S_OK
decl_stmt|;
if|if
condition|(
operator|!
name|mCreatedWithDeviceEXT
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ANGLE_ENABLE_WINDOWS_STORE
argument_list|)
name|PFN_D3D11_CREATE_DEVICE
name|D3D11CreateDevice
init|=
literal|nullptr
decl_stmt|;
block|{
name|SCOPED_ANGLE_HISTOGRAM_TIMER
argument_list|(
literal|"GPU.ANGLE.Renderer11InitializeDLLsMS"
argument_list|)
expr_stmt|;
name|TRACE_EVENT0
argument_list|(
literal|"gpu.angle"
argument_list|,
literal|"Renderer11::initialize (Load DLLs)"
argument_list|)
expr_stmt|;
name|mDxgiModule
operator|=
name|LoadLibrary
argument_list|(
name|TEXT
argument_list|(
literal|"dxgi.dll"
argument_list|)
argument_list|)
expr_stmt|;
name|mD3d11Module
operator|=
name|LoadLibrary
argument_list|(
name|TEXT
argument_list|(
literal|"d3d11.dll"
argument_list|)
argument_list|)
expr_stmt|;
name|mDCompModule
operator|=
name|LoadLibrary
argument_list|(
name|TEXT
argument_list|(
literal|"dcomp.dll"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mD3d11Module
operator|==
literal|nullptr
operator|||
name|mDxgiModule
operator|==
literal|nullptr
condition|)
block|{
return|return
name|egl
operator|::
name|Error
argument_list|(
name|EGL_NOT_INITIALIZED
argument_list|,
name|D3D11_INIT_MISSING_DEP
argument_list|,
literal|"Could not load D3D11 or DXGI library."
argument_list|)
return|;
block|}
comment|// create the D3D11 device
name|ASSERT
argument_list|(
name|mDevice
operator|==
literal|nullptr
argument_list|)
expr_stmt|;
name|D3D11CreateDevice
operator|=
cast|reinterpret_cast
argument_list|<
name|PFN_D3D11_CREATE_DEVICE
argument_list|>
argument_list|(
name|GetProcAddress
argument_list|(
name|mD3d11Module
argument_list|,
literal|"D3D11CreateDevice"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|D3D11CreateDevice
operator|==
literal|nullptr
condition|)
block|{
return|return
name|egl
operator|::
name|Error
argument_list|(
name|EGL_NOT_INITIALIZED
argument_list|,
name|D3D11_INIT_MISSING_DEP
argument_list|,
literal|"Could not retrieve D3D11CreateDevice address."
argument_list|)
return|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_DEBUG
block|{
name|TRACE_EVENT0
argument_list|(
literal|"gpu.angle"
argument_list|,
literal|"D3D11CreateDevice (Debug)"
argument_list|)
expr_stmt|;
name|result
operator|=
name|D3D11CreateDevice
argument_list|(
literal|nullptr
argument_list|,
name|mRequestedDriverType
argument_list|,
literal|nullptr
argument_list|,
name|D3D11_CREATE_DEVICE_DEBUG
argument_list|,
name|mAvailableFeatureLevels
operator|.
name|data
argument_list|()
argument_list|,
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|mAvailableFeatureLevels
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
name|D3D11_SDK_VERSION
argument_list|,
operator|&
name|mDevice
argument_list|,
operator|&
operator|(
name|mRenderer11DeviceCaps
operator|.
name|featureLevel
operator|)
argument_list|,
operator|&
name|mDeviceContext
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mDevice
operator|||
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed creating Debug D3D11 device - falling back to release runtime.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mDevice
operator|||
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
endif|#
directive|endif
block|{
name|SCOPED_ANGLE_HISTOGRAM_TIMER
argument_list|(
literal|"GPU.ANGLE.D3D11CreateDeviceMS"
argument_list|)
expr_stmt|;
name|TRACE_EVENT0
argument_list|(
literal|"gpu.angle"
argument_list|,
literal|"D3D11CreateDevice"
argument_list|)
expr_stmt|;
name|result
operator|=
name|D3D11CreateDevice
argument_list|(
literal|nullptr
argument_list|,
name|mRequestedDriverType
argument_list|,
literal|nullptr
argument_list|,
literal|0
argument_list|,
name|mAvailableFeatureLevels
operator|.
name|data
argument_list|()
argument_list|,
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|mAvailableFeatureLevels
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
name|D3D11_SDK_VERSION
argument_list|,
operator|&
name|mDevice
argument_list|,
operator|&
operator|(
name|mRenderer11DeviceCaps
operator|.
name|featureLevel
operator|)
argument_list|,
operator|&
name|mDeviceContext
argument_list|)
expr_stmt|;
comment|// Cleanup done by destructor
if|if
condition|(
operator|!
name|mDevice
operator|||
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ANGLE_HISTOGRAM_SPARSE_SLOWLY
argument_list|(
literal|"GPU.ANGLE.D3D11CreateDeviceError"
argument_list|,
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|egl
operator|::
name|Error
argument_list|(
name|EGL_NOT_INITIALIZED
argument_list|,
name|D3D11_INIT_CREATEDEVICE_ERROR
argument_list|,
literal|"Could not create D3D11 device."
argument_list|)
return|;
block|}
block|}
block|}
else|else
block|{
comment|// We should use the inputted D3D11 device instead
name|void
modifier|*
name|device
init|=
literal|nullptr
decl_stmt|;
name|egl
operator|::
name|Error
name|error
init|=
name|mEGLDevice
operator|->
name|getDevice
argument_list|(
operator|&
name|device
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ID3D11Device
modifier|*
name|d3dDevice
init|=
cast|reinterpret_cast
argument_list|<
name|ID3D11Device
operator|*
argument_list|>
argument_list|(
name|device
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|d3dDevice
operator|->
name|GetDeviceRemovedReason
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|egl
operator|::
name|Error
argument_list|(
name|EGL_NOT_INITIALIZED
argument_list|,
literal|"Inputted D3D11 device has been lost."
argument_list|)
return|;
block|}
if|if
condition|(
name|d3dDevice
operator|->
name|GetFeatureLevel
argument_list|()
operator|<
name|D3D_FEATURE_LEVEL_9_3
condition|)
block|{
return|return
name|egl
operator|::
name|Error
argument_list|(
name|EGL_NOT_INITIALIZED
argument_list|,
literal|"Inputted D3D11 device must be Feature Level 9_3 or greater."
argument_list|)
return|;
block|}
comment|// The Renderer11 adds a ref to the inputted D3D11 device, like D3D11CreateDevice does.
name|mDevice
operator|=
name|d3dDevice
expr_stmt|;
name|mDevice
operator|->
name|AddRef
argument_list|()
expr_stmt|;
name|mDevice
operator|->
name|GetImmediateContext
argument_list|(
operator|&
name|mDeviceContext
argument_list|)
expr_stmt|;
name|mRenderer11DeviceCaps
operator|.
name|featureLevel
operator|=
name|mDevice
operator|->
name|GetFeatureLevel
argument_list|()
expr_stmt|;
block|}
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mDeviceContext
argument_list|,
literal|"DeviceContext"
argument_list|)
expr_stmt|;
return|return
name|egl
operator|::
name|Error
argument_list|(
name|EGL_SUCCESS
argument_list|)
return|;
block|}
comment|// do any one-time device initialization
comment|// NOTE: this is also needed after a device lost/reset
comment|// to reset the scene status and ensure the default states are reset.
DECL|function|initializeDevice
name|void
name|Renderer11
operator|::
name|initializeDevice
parameter_list|()
block|{
name|SCOPED_ANGLE_HISTOGRAM_TIMER
argument_list|(
literal|"GPU.ANGLE.Renderer11InitializeDeviceMS"
argument_list|)
expr_stmt|;
name|TRACE_EVENT0
argument_list|(
literal|"gpu.angle"
argument_list|,
literal|"Renderer11::initializeDevice"
argument_list|)
expr_stmt|;
name|populateRenderer11DeviceCaps
argument_list|()
expr_stmt|;
name|mStateCache
operator|.
name|initialize
argument_list|(
name|mDevice
argument_list|)
expr_stmt|;
name|mInputLayoutCache
operator|.
name|initialize
argument_list|(
name|mDevice
argument_list|,
name|mDeviceContext
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|mVertexDataManager
operator|&&
operator|!
name|mIndexDataManager
argument_list|)
expr_stmt|;
name|mVertexDataManager
operator|=
operator|new
name|VertexDataManager
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|mIndexDataManager
operator|=
operator|new
name|IndexDataManager
argument_list|(
name|this
argument_list|,
name|getRendererClass
argument_list|()
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|mBlit
argument_list|)
expr_stmt|;
name|mBlit
operator|=
operator|new
name|Blit11
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|mClear
argument_list|)
expr_stmt|;
name|mClear
operator|=
operator|new
name|Clear11
argument_list|(
name|this
argument_list|)
expr_stmt|;
specifier|const
specifier|auto
modifier|&
name|attributes
init|=
name|mDisplay
operator|->
name|getAttributeMap
argument_list|()
decl_stmt|;
comment|// If automatic trim is enabled, DXGIDevice3::Trim( ) is called for the application
comment|// automatically when an application is suspended by the OS. This feature is currently
comment|// only supported for Windows Store applications.
name|EGLint
name|enableAutoTrim
init|=
name|attributes
operator|.
name|get
argument_list|(
name|EGL_PLATFORM_ANGLE_ENABLE_AUTOMATIC_TRIM_ANGLE
argument_list|,
name|EGL_FALSE
argument_list|)
decl_stmt|;
if|if
condition|(
name|enableAutoTrim
operator|==
name|EGL_TRUE
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|mTrim
argument_list|)
expr_stmt|;
name|mTrim
operator|=
operator|new
name|Trim11
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
operator|!
name|mPixelTransfer
argument_list|)
expr_stmt|;
name|mPixelTransfer
operator|=
operator|new
name|PixelTransfer11
argument_list|(
name|this
argument_list|)
expr_stmt|;
specifier|const
name|gl
operator|::
name|Caps
modifier|&
name|rendererCaps
init|=
name|getRendererCaps
argument_list|()
decl_stmt|;
name|mStateManager
operator|.
name|initialize
argument_list|(
name|rendererCaps
argument_list|)
expr_stmt|;
name|mForceSetVertexSamplerStates
operator|.
name|resize
argument_list|(
name|rendererCaps
operator|.
name|maxVertexTextureImageUnits
argument_list|)
expr_stmt|;
name|mCurVertexSamplerStates
operator|.
name|resize
argument_list|(
name|rendererCaps
operator|.
name|maxVertexTextureImageUnits
argument_list|)
expr_stmt|;
name|mForceSetPixelSamplerStates
operator|.
name|resize
argument_list|(
name|rendererCaps
operator|.
name|maxTextureImageUnits
argument_list|)
expr_stmt|;
name|mCurPixelSamplerStates
operator|.
name|resize
argument_list|(
name|rendererCaps
operator|.
name|maxTextureImageUnits
argument_list|)
expr_stmt|;
name|mStateManager
operator|.
name|initialize
argument_list|(
name|rendererCaps
argument_list|)
expr_stmt|;
name|markAllStateDirty
argument_list|()
expr_stmt|;
comment|// Gather stats on DXGI and D3D feature level
name|ANGLE_HISTOGRAM_BOOLEAN
argument_list|(
literal|"GPU.ANGLE.SupportsDXGI1_2"
argument_list|,
name|mRenderer11DeviceCaps
operator|.
name|supportsDXGI1_2
argument_list|)
expr_stmt|;
name|ANGLEFeatureLevel
name|angleFeatureLevel
init|=
name|GetANGLEFeatureLevel
argument_list|(
name|mRenderer11DeviceCaps
operator|.
name|featureLevel
argument_list|)
decl_stmt|;
comment|// We don't actually request a 11_1 device, because of complications with the platform
comment|// update. Instead we check if the mDeviceContext1 pointer cast succeeded.
comment|// Note: we should support D3D11_0 always, but we aren't guaranteed to be at FL11_0
comment|// because the app can specify a lower version (such as 9_3) on Display creation.
if|if
condition|(
name|mDeviceContext1
operator|!=
literal|nullptr
condition|)
block|{
name|angleFeatureLevel
operator|=
name|ANGLE_FEATURE_LEVEL_11_1
expr_stmt|;
block|}
name|ANGLE_HISTOGRAM_ENUMERATION
argument_list|(
literal|"GPU.ANGLE.D3D11FeatureLevel"
argument_list|,
name|angleFeatureLevel
argument_list|,
name|NUM_ANGLE_FEATURE_LEVELS
argument_list|)
expr_stmt|;
comment|// TODO(jmadill): use context caps, and place in common D3D location
name|mTranslatedAttribCache
operator|.
name|resize
argument_list|(
name|getRendererCaps
argument_list|()
operator|.
name|maxVertexAttributes
argument_list|)
expr_stmt|;
block|}
DECL|function|populateRenderer11DeviceCaps
name|void
name|Renderer11
operator|::
name|populateRenderer11DeviceCaps
parameter_list|()
block|{
name|HRESULT
name|hr
init|=
name|S_OK
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ANGLE_ENABLE_D3D11_1
argument_list|)
if|if
condition|(
name|mDeviceContext1
condition|)
block|{
name|D3D11_FEATURE_DATA_D3D11_OPTIONS
name|d3d11Options
decl_stmt|;
name|HRESULT
name|result
init|=
name|mDevice
operator|->
name|CheckFeatureSupport
argument_list|(
name|D3D11_FEATURE_D3D11_OPTIONS
argument_list|,
operator|&
name|d3d11Options
argument_list|,
sizeof|sizeof
argument_list|(
name|D3D11_FEATURE_DATA_D3D11_OPTIONS
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|mRenderer11DeviceCaps
operator|.
name|supportsClearView
operator|=
operator|(
name|d3d11Options
operator|.
name|ClearView
operator|!=
name|FALSE
operator|)
expr_stmt|;
name|mRenderer11DeviceCaps
operator|.
name|supportsConstantBufferOffsets
operator|=
operator|(
name|d3d11Options
operator|.
name|ConstantBufferOffsetting
operator|!=
name|FALSE
operator|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|hr
operator|=
name|mDevice
operator|->
name|CheckFormatSupport
argument_list|(
name|DXGI_FORMAT_B5G6R5_UNORM
argument_list|,
operator|&
operator|(
name|mRenderer11DeviceCaps
operator|.
name|B5G6R5support
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|hr
argument_list|)
condition|)
block|{
name|mRenderer11DeviceCaps
operator|.
name|B5G6R5support
operator|=
literal|0
expr_stmt|;
block|}
name|hr
operator|=
name|mDevice
operator|->
name|CheckFormatSupport
argument_list|(
name|DXGI_FORMAT_B4G4R4A4_UNORM
argument_list|,
operator|&
operator|(
name|mRenderer11DeviceCaps
operator|.
name|B4G4R4A4support
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|hr
argument_list|)
condition|)
block|{
name|mRenderer11DeviceCaps
operator|.
name|B4G4R4A4support
operator|=
literal|0
expr_stmt|;
block|}
name|hr
operator|=
name|mDevice
operator|->
name|CheckFormatSupport
argument_list|(
name|DXGI_FORMAT_B5G5R5A1_UNORM
argument_list|,
operator|&
operator|(
name|mRenderer11DeviceCaps
operator|.
name|B5G5R5A1support
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|hr
argument_list|)
condition|)
block|{
name|mRenderer11DeviceCaps
operator|.
name|B5G5R5A1support
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|ANGLE_ENABLE_D3D11_1
argument_list|)
name|IDXGIAdapter2
modifier|*
name|dxgiAdapter2
init|=
name|d3d11
operator|::
name|DynamicCastComObject
argument_list|<
name|IDXGIAdapter2
argument_list|>
argument_list|(
name|mDxgiAdapter
argument_list|)
decl_stmt|;
name|mRenderer11DeviceCaps
operator|.
name|supportsDXGI1_2
operator|=
operator|(
name|dxgiAdapter2
operator|!=
literal|nullptr
operator|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|dxgiAdapter2
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
DECL|function|generateConfigs
name|egl
operator|::
name|ConfigSet
name|Renderer11
operator|::
name|generateConfigs
parameter_list|()
specifier|const
block|{
name|std
operator|::
name|vector
argument_list|<
name|GLenum
argument_list|>
name|colorBufferFormats
decl_stmt|;
comment|// 32-bit supported formats
name|colorBufferFormats
operator|.
name|push_back
argument_list|(
name|GL_BGRA8_EXT
argument_list|)
expr_stmt|;
name|colorBufferFormats
operator|.
name|push_back
argument_list|(
name|GL_RGBA8_OES
argument_list|)
expr_stmt|;
comment|// 24-bit supported formats
name|colorBufferFormats
operator|.
name|push_back
argument_list|(
name|GL_RGB8_OES
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mPresentPathFastEnabled
condition|)
block|{
comment|// 16-bit supported formats
comment|// These aren't valid D3D11 swapchain formats, so don't expose them as configs
comment|// if present path fast is active
name|colorBufferFormats
operator|.
name|push_back
argument_list|(
name|GL_RGBA4
argument_list|)
expr_stmt|;
name|colorBufferFormats
operator|.
name|push_back
argument_list|(
name|GL_RGB5_A1
argument_list|)
expr_stmt|;
name|colorBufferFormats
operator|.
name|push_back
argument_list|(
name|GL_RGB565
argument_list|)
expr_stmt|;
block|}
specifier|static
specifier|const
name|GLenum
name|depthStencilBufferFormats
index|[]
init|=
block|{
name|GL_NONE
block|,
name|GL_DEPTH24_STENCIL8_OES
block|,
name|GL_DEPTH_COMPONENT16
block|,     }
decl_stmt|;
specifier|const
name|gl
operator|::
name|Caps
modifier|&
name|rendererCaps
init|=
name|getRendererCaps
argument_list|()
decl_stmt|;
specifier|const
name|gl
operator|::
name|TextureCapsMap
modifier|&
name|rendererTextureCaps
init|=
name|getRendererTextureCaps
argument_list|()
decl_stmt|;
specifier|const
name|EGLint
name|optimalSurfaceOrientation
init|=
name|mPresentPathFastEnabled
condition|?
literal|0
else|:
name|EGL_SURFACE_ORIENTATION_INVERT_Y_ANGLE
decl_stmt|;
name|egl
operator|::
name|ConfigSet
name|configs
decl_stmt|;
for|for
control|(
name|GLenum
name|colorBufferInternalFormat
range|:
name|colorBufferFormats
control|)
block|{
specifier|const
name|gl
operator|::
name|TextureCaps
modifier|&
name|colorBufferFormatCaps
init|=
name|rendererTextureCaps
operator|.
name|get
argument_list|(
name|colorBufferInternalFormat
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|colorBufferFormatCaps
operator|.
name|renderable
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|GLenum
name|depthStencilBufferInternalFormat
range|:
name|depthStencilBufferFormats
control|)
block|{
specifier|const
name|gl
operator|::
name|TextureCaps
modifier|&
name|depthStencilBufferFormatCaps
init|=
name|rendererTextureCaps
operator|.
name|get
argument_list|(
name|depthStencilBufferInternalFormat
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|depthStencilBufferFormatCaps
operator|.
name|renderable
operator|&&
name|depthStencilBufferInternalFormat
operator|!=
name|GL_NONE
condition|)
block|{
continue|continue;
block|}
specifier|const
name|gl
operator|::
name|InternalFormat
modifier|&
name|colorBufferFormatInfo
init|=
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|colorBufferInternalFormat
argument_list|)
decl_stmt|;
specifier|const
name|gl
operator|::
name|InternalFormat
modifier|&
name|depthStencilBufferFormatInfo
init|=
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|depthStencilBufferInternalFormat
argument_list|)
decl_stmt|;
name|egl
operator|::
name|Config
name|config
decl_stmt|;
name|config
operator|.
name|renderTargetFormat
operator|=
name|colorBufferInternalFormat
expr_stmt|;
name|config
operator|.
name|depthStencilFormat
operator|=
name|depthStencilBufferInternalFormat
expr_stmt|;
name|config
operator|.
name|bufferSize
operator|=
name|colorBufferFormatInfo
operator|.
name|pixelBytes
operator|*
literal|8
expr_stmt|;
name|config
operator|.
name|redSize
operator|=
name|colorBufferFormatInfo
operator|.
name|redBits
expr_stmt|;
name|config
operator|.
name|greenSize
operator|=
name|colorBufferFormatInfo
operator|.
name|greenBits
expr_stmt|;
name|config
operator|.
name|blueSize
operator|=
name|colorBufferFormatInfo
operator|.
name|blueBits
expr_stmt|;
name|config
operator|.
name|luminanceSize
operator|=
name|colorBufferFormatInfo
operator|.
name|luminanceBits
expr_stmt|;
name|config
operator|.
name|alphaSize
operator|=
name|colorBufferFormatInfo
operator|.
name|alphaBits
expr_stmt|;
name|config
operator|.
name|alphaMaskSize
operator|=
literal|0
expr_stmt|;
name|config
operator|.
name|bindToTextureRGB
operator|=
operator|(
name|colorBufferFormatInfo
operator|.
name|format
operator|==
name|GL_RGB
operator|)
expr_stmt|;
name|config
operator|.
name|bindToTextureRGBA
operator|=
operator|(
name|colorBufferFormatInfo
operator|.
name|format
operator|==
name|GL_RGBA
operator|||
name|colorBufferFormatInfo
operator|.
name|format
operator|==
name|GL_BGRA_EXT
operator|)
expr_stmt|;
name|config
operator|.
name|colorBufferType
operator|=
name|EGL_RGB_BUFFER
expr_stmt|;
name|config
operator|.
name|configID
operator|=
cast|static_cast
argument_list|<
name|EGLint
argument_list|>
argument_list|(
name|configs
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// Can only support a conformant ES2 with feature level greater than 10.0.
name|config
operator|.
name|conformant
operator|=
operator|(
name|mRenderer11DeviceCaps
operator|.
name|featureLevel
operator|>=
name|D3D_FEATURE_LEVEL_10_0
operator|)
condition|?
operator|(
name|EGL_OPENGL_ES2_BIT
operator||
name|EGL_OPENGL_ES3_BIT_KHR
operator|)
else|:
literal|0
expr_stmt|;
name|config
operator|.
name|configCaveat
operator|=
name|config
operator|.
name|conformant
operator|==
name|EGL_NONE
condition|?
name|EGL_NON_CONFORMANT_CONFIG
else|:
name|EGL_NONE
expr_stmt|;
comment|// PresentPathFast may not be conformant
if|if
condition|(
name|mPresentPathFastEnabled
condition|)
block|{
name|config
operator|.
name|conformant
operator|=
literal|0
expr_stmt|;
block|}
name|config
operator|.
name|depthSize
operator|=
name|depthStencilBufferFormatInfo
operator|.
name|depthBits
expr_stmt|;
name|config
operator|.
name|level
operator|=
literal|0
expr_stmt|;
name|config
operator|.
name|matchNativePixmap
operator|=
name|EGL_NONE
expr_stmt|;
name|config
operator|.
name|maxPBufferWidth
operator|=
name|rendererCaps
operator|.
name|max2DTextureSize
expr_stmt|;
name|config
operator|.
name|maxPBufferHeight
operator|=
name|rendererCaps
operator|.
name|max2DTextureSize
expr_stmt|;
name|config
operator|.
name|maxPBufferPixels
operator|=
name|rendererCaps
operator|.
name|max2DTextureSize
operator|*
name|rendererCaps
operator|.
name|max2DTextureSize
expr_stmt|;
name|config
operator|.
name|maxSwapInterval
operator|=
literal|4
expr_stmt|;
name|config
operator|.
name|minSwapInterval
operator|=
literal|0
expr_stmt|;
name|config
operator|.
name|nativeRenderable
operator|=
name|EGL_FALSE
expr_stmt|;
name|config
operator|.
name|nativeVisualID
operator|=
literal|0
expr_stmt|;
name|config
operator|.
name|nativeVisualType
operator|=
name|EGL_NONE
expr_stmt|;
comment|// Can't support ES3 at all without feature level 10.0
name|config
operator|.
name|renderableType
operator|=
name|EGL_OPENGL_ES2_BIT
operator||
operator|(
operator|(
name|mRenderer11DeviceCaps
operator|.
name|featureLevel
operator|>=
name|D3D_FEATURE_LEVEL_10_0
operator|)
condition|?
name|EGL_OPENGL_ES3_BIT_KHR
else|:
literal|0
operator|)
expr_stmt|;
name|config
operator|.
name|sampleBuffers
operator|=
literal|0
expr_stmt|;
comment|// FIXME: enumerate multi-sampling
name|config
operator|.
name|samples
operator|=
literal|0
expr_stmt|;
name|config
operator|.
name|stencilSize
operator|=
name|depthStencilBufferFormatInfo
operator|.
name|stencilBits
expr_stmt|;
name|config
operator|.
name|surfaceType
operator|=
name|EGL_PBUFFER_BIT
operator||
name|EGL_WINDOW_BIT
operator||
name|EGL_SWAP_BEHAVIOR_PRESERVED_BIT
expr_stmt|;
name|config
operator|.
name|transparentType
operator|=
name|EGL_NONE
expr_stmt|;
name|config
operator|.
name|transparentRedValue
operator|=
literal|0
expr_stmt|;
name|config
operator|.
name|transparentGreenValue
operator|=
literal|0
expr_stmt|;
name|config
operator|.
name|transparentBlueValue
operator|=
literal|0
expr_stmt|;
name|config
operator|.
name|optimalOrientation
operator|=
name|optimalSurfaceOrientation
expr_stmt|;
name|configs
operator|.
name|add
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
block|}
name|ASSERT
argument_list|(
name|configs
operator|.
name|size
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
return|return
name|configs
return|;
block|}
DECL|function|generateDisplayExtensions
name|void
name|Renderer11
operator|::
name|generateDisplayExtensions
parameter_list|(
name|egl
operator|::
name|DisplayExtensions
modifier|*
name|outExtensions
parameter_list|)
specifier|const
block|{
name|outExtensions
operator|->
name|createContextRobustness
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|getShareHandleSupport
argument_list|()
condition|)
block|{
name|outExtensions
operator|->
name|d3dShareHandleClientBuffer
operator|=
literal|true
expr_stmt|;
name|outExtensions
operator|->
name|surfaceD3DTexture2DShareHandle
operator|=
literal|true
expr_stmt|;
block|}
name|outExtensions
operator|->
name|keyedMutex
operator|=
literal|true
expr_stmt|;
name|outExtensions
operator|->
name|querySurfacePointer
operator|=
literal|true
expr_stmt|;
name|outExtensions
operator|->
name|windowFixedSize
operator|=
literal|true
expr_stmt|;
comment|// If present path fast is active then the surface orientation extension isn't supported
name|outExtensions
operator|->
name|surfaceOrientation
operator|=
operator|!
name|mPresentPathFastEnabled
expr_stmt|;
comment|// D3D11 does not support present with dirty rectangles until DXGI 1.2.
name|outExtensions
operator|->
name|postSubBuffer
operator|=
name|mRenderer11DeviceCaps
operator|.
name|supportsDXGI1_2
expr_stmt|;
name|outExtensions
operator|->
name|createContext
operator|=
literal|true
expr_stmt|;
name|outExtensions
operator|->
name|deviceQuery
operator|=
literal|true
expr_stmt|;
name|outExtensions
operator|->
name|createContextNoError
operator|=
literal|true
expr_stmt|;
name|outExtensions
operator|->
name|image
operator|=
literal|true
expr_stmt|;
name|outExtensions
operator|->
name|imageBase
operator|=
literal|true
expr_stmt|;
name|outExtensions
operator|->
name|glTexture2DImage
operator|=
literal|true
expr_stmt|;
name|outExtensions
operator|->
name|glTextureCubemapImage
operator|=
literal|true
expr_stmt|;
name|outExtensions
operator|->
name|glRenderbufferImage
operator|=
literal|true
expr_stmt|;
name|outExtensions
operator|->
name|flexibleSurfaceCompatibility
operator|=
literal|true
expr_stmt|;
name|outExtensions
operator|->
name|directComposition
operator|=
operator|!
operator|!
name|mDCompModule
expr_stmt|;
block|}
DECL|function|flush
name|gl
operator|::
name|Error
name|Renderer11
operator|::
name|flush
parameter_list|()
block|{
name|mDeviceContext
operator|->
name|Flush
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|finish
name|gl
operator|::
name|Error
name|Renderer11
operator|::
name|finish
parameter_list|()
block|{
name|HRESULT
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|mSyncQuery
condition|)
block|{
name|D3D11_QUERY_DESC
name|queryDesc
decl_stmt|;
name|queryDesc
operator|.
name|Query
operator|=
name|D3D11_QUERY_EVENT
expr_stmt|;
name|queryDesc
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|CreateQuery
argument_list|(
operator|&
name|queryDesc
argument_list|,
operator|&
name|mSyncQuery
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create event query, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
name|mDeviceContext
operator|->
name|End
argument_list|(
name|mSyncQuery
argument_list|)
expr_stmt|;
name|mDeviceContext
operator|->
name|Flush
argument_list|()
expr_stmt|;
do|do
block|{
name|result
operator|=
name|mDeviceContext
operator|->
name|GetData
argument_list|(
name|mSyncQuery
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|D3D11_ASYNC_GETDATA_DONOTFLUSH
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to get event query data, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
comment|// Keep polling, but allow other threads to do something useful first
name|ScheduleYield
argument_list|()
expr_stmt|;
if|if
condition|(
name|testDeviceLost
argument_list|()
condition|)
block|{
name|mDisplay
operator|->
name|notifyDeviceLost
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Device was lost while waiting for sync."
argument_list|)
return|;
block|}
block|}
do|while
condition|(
name|result
operator|==
name|S_FALSE
condition|)
do|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|createSwapChain
name|SwapChainD3D
modifier|*
name|Renderer11
operator|::
name|createSwapChain
parameter_list|(
name|NativeWindow
name|nativeWindow
parameter_list|,
name|HANDLE
name|shareHandle
parameter_list|,
name|GLenum
name|backBufferFormat
parameter_list|,
name|GLenum
name|depthBufferFormat
parameter_list|,
name|EGLint
name|orientation
parameter_list|)
block|{
return|return
operator|new
name|SwapChain11
argument_list|(
name|this
argument_list|,
name|nativeWindow
argument_list|,
name|shareHandle
argument_list|,
name|backBufferFormat
argument_list|,
name|depthBufferFormat
argument_list|,
name|orientation
argument_list|)
return|;
block|}
DECL|function|createCompiler
name|CompilerImpl
modifier|*
name|Renderer11
operator|::
name|createCompiler
parameter_list|()
block|{
if|if
condition|(
name|mRenderer11DeviceCaps
operator|.
name|featureLevel
operator|<=
name|D3D_FEATURE_LEVEL_9_3
condition|)
block|{
return|return
operator|new
name|CompilerD3D
argument_list|(
name|SH_HLSL_4_0_FL9_3_OUTPUT
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|CompilerD3D
argument_list|(
name|SH_HLSL_4_1_OUTPUT
argument_list|)
return|;
block|}
block|}
DECL|function|getD3DDevice
name|void
modifier|*
name|Renderer11
operator|::
name|getD3DDevice
parameter_list|()
block|{
return|return
cast|reinterpret_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
name|mDevice
argument_list|)
return|;
block|}
DECL|function|generateSwizzle
name|gl
operator|::
name|Error
name|Renderer11
operator|::
name|generateSwizzle
parameter_list|(
name|gl
operator|::
name|Texture
modifier|*
name|texture
parameter_list|)
block|{
if|if
condition|(
name|texture
condition|)
block|{
name|TextureD3D
modifier|*
name|textureD3D
init|=
name|GetImplAs
argument_list|<
name|TextureD3D
argument_list|>
argument_list|(
name|texture
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|textureD3D
argument_list|)
expr_stmt|;
name|TextureStorage
modifier|*
name|texStorage
init|=
literal|nullptr
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|textureD3D
operator|->
name|getNativeTexture
argument_list|(
operator|&
name|texStorage
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
name|texStorage
condition|)
block|{
name|TextureStorage11
modifier|*
name|storage11
init|=
name|GetAs
argument_list|<
name|TextureStorage11
argument_list|>
argument_list|(
name|texStorage
argument_list|)
decl_stmt|;
specifier|const
name|gl
operator|::
name|TextureState
modifier|&
name|textureState
init|=
name|texture
operator|->
name|getTextureState
argument_list|()
decl_stmt|;
name|error
operator|=
name|storage11
operator|->
name|generateSwizzles
argument_list|(
name|textureState
operator|.
name|swizzleRed
argument_list|,
name|textureState
operator|.
name|swizzleGreen
argument_list|,
name|textureState
operator|.
name|swizzleBlue
argument_list|,
name|textureState
operator|.
name|swizzleAlpha
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|setSamplerState
name|gl
operator|::
name|Error
name|Renderer11
operator|::
name|setSamplerState
parameter_list|(
name|gl
operator|::
name|SamplerType
name|type
parameter_list|,
name|int
name|index
parameter_list|,
name|gl
operator|::
name|Texture
modifier|*
name|texture
parameter_list|,
specifier|const
name|gl
operator|::
name|SamplerState
modifier|&
name|samplerState
parameter_list|)
block|{
comment|// Make sure to add the level offset for our tiny compressed texture workaround
name|TextureD3D
modifier|*
name|textureD3D
init|=
name|GetImplAs
argument_list|<
name|TextureD3D
argument_list|>
argument_list|(
name|texture
argument_list|)
decl_stmt|;
name|TextureStorage
modifier|*
name|storage
init|=
literal|nullptr
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|textureD3D
operator|->
name|getNativeTexture
argument_list|(
operator|&
name|storage
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
comment|// Storage should exist, texture should be complete
name|ASSERT
argument_list|(
name|storage
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|gl
operator|::
name|SAMPLER_PIXEL
condition|)
block|{
name|ASSERT
argument_list|(
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|index
argument_list|)
operator|<
name|getRendererCaps
argument_list|()
operator|.
name|maxTextureImageUnits
argument_list|)
expr_stmt|;
if|if
condition|(
name|mForceSetPixelSamplerStates
index|[
name|index
index|]
operator|||
name|memcmp
argument_list|(
operator|&
name|samplerState
argument_list|,
operator|&
name|mCurPixelSamplerStates
index|[
name|index
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|gl
operator|::
name|SamplerState
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ID3D11SamplerState
modifier|*
name|dxSamplerState
init|=
name|NULL
decl_stmt|;
name|error
operator|=
name|mStateCache
operator|.
name|getSamplerState
argument_list|(
name|samplerState
argument_list|,
operator|&
name|dxSamplerState
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|dxSamplerState
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|mDeviceContext
operator|->
name|PSSetSamplers
argument_list|(
name|index
argument_list|,
literal|1
argument_list|,
operator|&
name|dxSamplerState
argument_list|)
expr_stmt|;
name|mCurPixelSamplerStates
index|[
name|index
index|]
operator|=
name|samplerState
expr_stmt|;
block|}
name|mForceSetPixelSamplerStates
index|[
name|index
index|]
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|gl
operator|::
name|SAMPLER_VERTEX
condition|)
block|{
name|ASSERT
argument_list|(
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|index
argument_list|)
operator|<
name|getRendererCaps
argument_list|()
operator|.
name|maxVertexTextureImageUnits
argument_list|)
expr_stmt|;
if|if
condition|(
name|mForceSetVertexSamplerStates
index|[
name|index
index|]
operator|||
name|memcmp
argument_list|(
operator|&
name|samplerState
argument_list|,
operator|&
name|mCurVertexSamplerStates
index|[
name|index
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|gl
operator|::
name|SamplerState
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ID3D11SamplerState
modifier|*
name|dxSamplerState
init|=
name|NULL
decl_stmt|;
name|error
operator|=
name|mStateCache
operator|.
name|getSamplerState
argument_list|(
name|samplerState
argument_list|,
operator|&
name|dxSamplerState
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|dxSamplerState
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|mDeviceContext
operator|->
name|VSSetSamplers
argument_list|(
name|index
argument_list|,
literal|1
argument_list|,
operator|&
name|dxSamplerState
argument_list|)
expr_stmt|;
name|mCurVertexSamplerStates
index|[
name|index
index|]
operator|=
name|samplerState
expr_stmt|;
block|}
name|mForceSetVertexSamplerStates
index|[
name|index
index|]
operator|=
literal|false
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|setTexture
name|gl
operator|::
name|Error
name|Renderer11
operator|::
name|setTexture
parameter_list|(
name|gl
operator|::
name|SamplerType
name|type
parameter_list|,
name|int
name|index
parameter_list|,
name|gl
operator|::
name|Texture
modifier|*
name|texture
parameter_list|)
block|{
name|ID3D11ShaderResourceView
modifier|*
name|textureSRV
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|texture
condition|)
block|{
name|TextureD3D
modifier|*
name|textureImpl
init|=
name|GetImplAs
argument_list|<
name|TextureD3D
argument_list|>
argument_list|(
name|texture
argument_list|)
decl_stmt|;
name|TextureStorage
modifier|*
name|texStorage
init|=
literal|nullptr
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|textureImpl
operator|->
name|getNativeTexture
argument_list|(
operator|&
name|texStorage
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
comment|// Texture should be complete and have a storage
name|ASSERT
argument_list|(
name|texStorage
argument_list|)
expr_stmt|;
name|TextureStorage11
modifier|*
name|storage11
init|=
name|GetAs
argument_list|<
name|TextureStorage11
argument_list|>
argument_list|(
name|texStorage
argument_list|)
decl_stmt|;
comment|// Make sure to add the level offset for our tiny compressed texture workaround
name|gl
operator|::
name|TextureState
name|textureState
init|=
name|texture
operator|->
name|getTextureState
argument_list|()
decl_stmt|;
name|textureState
operator|.
name|baseLevel
operator|+=
name|storage11
operator|->
name|getTopLevel
argument_list|()
expr_stmt|;
name|error
operator|=
name|storage11
operator|->
name|getSRV
argument_list|(
name|textureState
argument_list|,
operator|&
name|textureSRV
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
comment|// If we get NULL back from getSRV here, something went wrong in the texture class and we're unexpectedly
comment|// missing the shader resource view
name|ASSERT
argument_list|(
name|textureSRV
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|textureImpl
operator|->
name|resetDirty
argument_list|()
expr_stmt|;
block|}
name|ASSERT
argument_list|(
operator|(
name|type
operator|==
name|gl
operator|::
name|SAMPLER_PIXEL
operator|&&
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|index
argument_list|)
operator|<
name|getRendererCaps
argument_list|()
operator|.
name|maxTextureImageUnits
operator|)
operator|||
operator|(
name|type
operator|==
name|gl
operator|::
name|SAMPLER_VERTEX
operator|&&
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|index
argument_list|)
operator|<
name|getRendererCaps
argument_list|()
operator|.
name|maxVertexTextureImageUnits
operator|)
argument_list|)
expr_stmt|;
name|mStateManager
operator|.
name|setShaderResource
argument_list|(
name|type
argument_list|,
name|index
argument_list|,
name|textureSRV
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|setUniformBuffers
name|gl
operator|::
name|Error
name|Renderer11
operator|::
name|setUniformBuffers
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|GLint
argument_list|>
modifier|&
name|vertexUniformBuffers
parameter_list|,
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|GLint
argument_list|>
modifier|&
name|fragmentUniformBuffers
parameter_list|)
block|{
for|for
control|(
name|size_t
name|uniformBufferIndex
init|=
literal|0
init|;
name|uniformBufferIndex
operator|<
name|vertexUniformBuffers
operator|.
name|size
argument_list|()
condition|;
name|uniformBufferIndex
operator|++
control|)
block|{
name|GLint
name|binding
init|=
name|vertexUniformBuffers
index|[
name|uniformBufferIndex
index|]
decl_stmt|;
if|if
condition|(
name|binding
operator|==
operator|-
literal|1
condition|)
block|{
continue|continue;
block|}
specifier|const
name|OffsetBindingPointer
argument_list|<
name|gl
operator|::
name|Buffer
argument_list|>
modifier|&
name|uniformBuffer
init|=
name|data
operator|.
name|state
operator|->
name|getIndexedUniformBuffer
argument_list|(
name|binding
argument_list|)
decl_stmt|;
name|GLintptr
name|uniformBufferOffset
init|=
name|uniformBuffer
operator|.
name|getOffset
argument_list|()
decl_stmt|;
name|GLsizeiptr
name|uniformBufferSize
init|=
name|uniformBuffer
operator|.
name|getSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|uniformBuffer
operator|.
name|get
argument_list|()
operator|!=
literal|nullptr
condition|)
block|{
name|Buffer11
modifier|*
name|bufferStorage
init|=
name|GetImplAs
argument_list|<
name|Buffer11
argument_list|>
argument_list|(
name|uniformBuffer
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
name|ID3D11Buffer
modifier|*
name|constantBuffer
decl_stmt|;
if|if
condition|(
name|mRenderer11DeviceCaps
operator|.
name|supportsConstantBufferOffsets
condition|)
block|{
name|constantBuffer
operator|=
name|bufferStorage
operator|->
name|getBuffer
argument_list|(
name|BUFFER_USAGE_UNIFORM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|constantBuffer
operator|=
name|bufferStorage
operator|->
name|getConstantBufferRange
argument_list|(
name|uniformBufferOffset
argument_list|,
name|uniformBufferSize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|constantBuffer
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
if|if
condition|(
name|mCurrentConstantBufferVS
index|[
name|uniformBufferIndex
index|]
operator|!=
name|bufferStorage
operator|->
name|getSerial
argument_list|()
operator|||
name|mCurrentConstantBufferVSOffset
index|[
name|uniformBufferIndex
index|]
operator|!=
name|uniformBufferOffset
operator|||
name|mCurrentConstantBufferVSSize
index|[
name|uniformBufferIndex
index|]
operator|!=
name|uniformBufferSize
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|ANGLE_ENABLE_D3D11_1
argument_list|)
if|if
condition|(
name|mRenderer11DeviceCaps
operator|.
name|supportsConstantBufferOffsets
operator|&&
name|uniformBufferSize
operator|!=
literal|0
condition|)
block|{
name|UINT
name|firstConstant
init|=
literal|0
decl_stmt|,
name|numConstants
init|=
literal|0
decl_stmt|;
name|CalculateConstantBufferParams
argument_list|(
name|uniformBufferOffset
argument_list|,
name|uniformBufferSize
argument_list|,
operator|&
name|firstConstant
argument_list|,
operator|&
name|numConstants
argument_list|)
expr_stmt|;
name|mDeviceContext1
operator|->
name|VSSetConstantBuffers1
argument_list|(
name|getReservedVertexUniformBuffers
argument_list|()
operator|+
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|uniformBufferIndex
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|constantBuffer
argument_list|,
operator|&
name|firstConstant
argument_list|,
operator|&
name|numConstants
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|mDeviceContext
operator|->
name|VSSetConstantBuffers
argument_list|(
name|getReservedVertexUniformBuffers
argument_list|()
operator|+
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|uniformBufferIndex
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|constantBuffer
argument_list|)
expr_stmt|;
block|}
name|mCurrentConstantBufferVS
index|[
name|uniformBufferIndex
index|]
operator|=
name|bufferStorage
operator|->
name|getSerial
argument_list|()
expr_stmt|;
name|mCurrentConstantBufferVSOffset
index|[
name|uniformBufferIndex
index|]
operator|=
name|uniformBufferOffset
expr_stmt|;
name|mCurrentConstantBufferVSSize
index|[
name|uniformBufferIndex
index|]
operator|=
name|uniformBufferSize
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|size_t
name|uniformBufferIndex
init|=
literal|0
init|;
name|uniformBufferIndex
operator|<
name|fragmentUniformBuffers
operator|.
name|size
argument_list|()
condition|;
name|uniformBufferIndex
operator|++
control|)
block|{
name|GLint
name|binding
init|=
name|fragmentUniformBuffers
index|[
name|uniformBufferIndex
index|]
decl_stmt|;
if|if
condition|(
name|binding
operator|==
operator|-
literal|1
condition|)
block|{
continue|continue;
block|}
specifier|const
name|OffsetBindingPointer
argument_list|<
name|gl
operator|::
name|Buffer
argument_list|>
modifier|&
name|uniformBuffer
init|=
name|data
operator|.
name|state
operator|->
name|getIndexedUniformBuffer
argument_list|(
name|binding
argument_list|)
decl_stmt|;
name|GLintptr
name|uniformBufferOffset
init|=
name|uniformBuffer
operator|.
name|getOffset
argument_list|()
decl_stmt|;
name|GLsizeiptr
name|uniformBufferSize
init|=
name|uniformBuffer
operator|.
name|getSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|uniformBuffer
operator|.
name|get
argument_list|()
operator|!=
literal|nullptr
condition|)
block|{
name|Buffer11
modifier|*
name|bufferStorage
init|=
name|GetImplAs
argument_list|<
name|Buffer11
argument_list|>
argument_list|(
name|uniformBuffer
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
name|ID3D11Buffer
modifier|*
name|constantBuffer
decl_stmt|;
if|if
condition|(
name|mRenderer11DeviceCaps
operator|.
name|supportsConstantBufferOffsets
condition|)
block|{
name|constantBuffer
operator|=
name|bufferStorage
operator|->
name|getBuffer
argument_list|(
name|BUFFER_USAGE_UNIFORM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|constantBuffer
operator|=
name|bufferStorage
operator|->
name|getConstantBufferRange
argument_list|(
name|uniformBufferOffset
argument_list|,
name|uniformBufferSize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|constantBuffer
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
if|if
condition|(
name|mCurrentConstantBufferPS
index|[
name|uniformBufferIndex
index|]
operator|!=
name|bufferStorage
operator|->
name|getSerial
argument_list|()
operator|||
name|mCurrentConstantBufferPSOffset
index|[
name|uniformBufferIndex
index|]
operator|!=
name|uniformBufferOffset
operator|||
name|mCurrentConstantBufferPSSize
index|[
name|uniformBufferIndex
index|]
operator|!=
name|uniformBufferSize
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|ANGLE_ENABLE_D3D11_1
argument_list|)
if|if
condition|(
name|mRenderer11DeviceCaps
operator|.
name|supportsConstantBufferOffsets
operator|&&
name|uniformBufferSize
operator|!=
literal|0
condition|)
block|{
name|UINT
name|firstConstant
init|=
literal|0
decl_stmt|,
name|numConstants
init|=
literal|0
decl_stmt|;
name|CalculateConstantBufferParams
argument_list|(
name|uniformBufferOffset
argument_list|,
name|uniformBufferSize
argument_list|,
operator|&
name|firstConstant
argument_list|,
operator|&
name|numConstants
argument_list|)
expr_stmt|;
name|mDeviceContext1
operator|->
name|PSSetConstantBuffers1
argument_list|(
name|getReservedFragmentUniformBuffers
argument_list|()
operator|+
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|uniformBufferIndex
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|constantBuffer
argument_list|,
operator|&
name|firstConstant
argument_list|,
operator|&
name|numConstants
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|mDeviceContext
operator|->
name|PSSetConstantBuffers
argument_list|(
name|getReservedFragmentUniformBuffers
argument_list|()
operator|+
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|uniformBufferIndex
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|constantBuffer
argument_list|)
expr_stmt|;
block|}
name|mCurrentConstantBufferPS
index|[
name|uniformBufferIndex
index|]
operator|=
name|bufferStorage
operator|->
name|getSerial
argument_list|()
expr_stmt|;
name|mCurrentConstantBufferPSOffset
index|[
name|uniformBufferIndex
index|]
operator|=
name|uniformBufferOffset
expr_stmt|;
name|mCurrentConstantBufferPSSize
index|[
name|uniformBufferIndex
index|]
operator|=
name|uniformBufferSize
expr_stmt|;
block|}
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|updateState
name|gl
operator|::
name|Error
name|Renderer11
operator|::
name|updateState
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLenum
name|drawMode
parameter_list|)
block|{
comment|// Applies the render target surface, depth stencil surface, viewport rectangle and
comment|// scissor rectangle to the renderer
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebufferObject
init|=
name|data
operator|.
name|state
operator|->
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|framebufferObject
operator|&&
name|framebufferObject
operator|->
name|checkStatus
argument_list|(
name|data
argument_list|)
operator|==
name|GL_FRAMEBUFFER_COMPLETE
argument_list|)
expr_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|applyRenderTarget
argument_list|(
name|framebufferObject
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
comment|// Set the present path state
specifier|const
name|bool
name|presentPathFastActive
init|=
name|UsePresentPathFast
argument_list|(
name|this
argument_list|,
name|framebufferObject
operator|->
name|getFirstColorbuffer
argument_list|()
argument_list|)
decl_stmt|;
name|mStateManager
operator|.
name|updatePresentPath
argument_list|(
name|presentPathFastActive
argument_list|,
name|framebufferObject
operator|->
name|getFirstColorbuffer
argument_list|()
argument_list|)
expr_stmt|;
comment|// Setting viewport state
name|mStateManager
operator|.
name|setViewport
argument_list|(
name|data
operator|.
name|caps
argument_list|,
name|data
operator|.
name|state
operator|->
name|getViewport
argument_list|()
argument_list|,
name|data
operator|.
name|state
operator|->
name|getNearPlane
argument_list|()
argument_list|,
name|data
operator|.
name|state
operator|->
name|getFarPlane
argument_list|()
argument_list|)
expr_stmt|;
comment|// Setting scissor state
name|mStateManager
operator|.
name|setScissorRectangle
argument_list|(
name|data
operator|.
name|state
operator|->
name|getScissor
argument_list|()
argument_list|,
name|data
operator|.
name|state
operator|->
name|isScissorTestEnabled
argument_list|()
argument_list|)
expr_stmt|;
comment|// Applying rasterizer state to D3D11 device
name|int
name|samples
init|=
name|framebufferObject
operator|->
name|getSamples
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|gl
operator|::
name|RasterizerState
name|rasterizer
init|=
name|data
operator|.
name|state
operator|->
name|getRasterizerState
argument_list|()
decl_stmt|;
name|rasterizer
operator|.
name|pointDrawMode
operator|=
operator|(
name|drawMode
operator|==
name|GL_POINTS
operator|)
expr_stmt|;
name|rasterizer
operator|.
name|multiSample
operator|=
operator|(
name|samples
operator|!=
literal|0
operator|)
expr_stmt|;
name|error
operator|=
name|mStateManager
operator|.
name|setRasterizerState
argument_list|(
name|rasterizer
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
comment|// Setting blend state
name|unsigned
name|int
name|mask
init|=
name|GetBlendSampleMask
argument_list|(
name|data
argument_list|,
name|samples
argument_list|)
decl_stmt|;
name|error
operator|=
name|mStateManager
operator|.
name|setBlendState
argument_list|(
name|framebufferObject
argument_list|,
name|data
operator|.
name|state
operator|->
name|getBlendState
argument_list|()
argument_list|,
name|data
operator|.
name|state
operator|->
name|getBlendColor
argument_list|()
argument_list|,
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
comment|// Setting depth stencil state
name|error
operator|=
name|mStateManager
operator|.
name|setDepthStencilState
argument_list|(
operator|*
name|data
operator|.
name|state
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
DECL|function|syncState
name|void
name|Renderer11
operator|::
name|syncState
parameter_list|(
specifier|const
name|gl
operator|::
name|State
modifier|&
name|state
parameter_list|,
specifier|const
name|gl
operator|::
name|State
operator|::
name|DirtyBits
modifier|&
name|bitmask
parameter_list|)
block|{
name|mStateManager
operator|.
name|syncState
argument_list|(
name|state
argument_list|,
name|bitmask
argument_list|)
expr_stmt|;
block|}
DECL|function|applyPrimitiveType
name|bool
name|Renderer11
operator|::
name|applyPrimitiveType
parameter_list|(
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|bool
name|usesPointSize
parameter_list|)
block|{
name|D3D11_PRIMITIVE_TOPOLOGY
name|primitiveTopology
init|=
name|D3D_PRIMITIVE_TOPOLOGY_UNDEFINED
decl_stmt|;
name|GLsizei
name|minCount
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|GL_POINTS
case|:
name|primitiveTopology
operator|=
name|D3D11_PRIMITIVE_TOPOLOGY_POINTLIST
expr_stmt|;
name|minCount
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|GL_LINES
case|:
name|primitiveTopology
operator|=
name|D3D_PRIMITIVE_TOPOLOGY_LINELIST
expr_stmt|;
name|minCount
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|GL_LINE_LOOP
case|:
name|primitiveTopology
operator|=
name|D3D_PRIMITIVE_TOPOLOGY_LINESTRIP
expr_stmt|;
name|minCount
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|GL_LINE_STRIP
case|:
name|primitiveTopology
operator|=
name|D3D_PRIMITIVE_TOPOLOGY_LINESTRIP
expr_stmt|;
name|minCount
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|GL_TRIANGLES
case|:
name|primitiveTopology
operator|=
name|D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST
expr_stmt|;
name|minCount
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|GL_TRIANGLE_STRIP
case|:
name|primitiveTopology
operator|=
name|D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP
expr_stmt|;
name|minCount
operator|=
literal|3
expr_stmt|;
break|break;
comment|// emulate fans via rewriting index buffer
case|case
name|GL_TRIANGLE_FAN
case|:
name|primitiveTopology
operator|=
name|D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST
expr_stmt|;
name|minCount
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// If instanced pointsprite emulation is being used and  If gl_PointSize is used in the shader,
comment|// GL_POINTS mode is expected to render pointsprites.
comment|// Instanced PointSprite emulation requires that the topology to be D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST.
if|if
condition|(
name|mode
operator|==
name|GL_POINTS
operator|&&
name|usesPointSize
operator|&&
name|getWorkarounds
argument_list|()
operator|.
name|useInstancedPointSpriteEmulation
condition|)
block|{
name|primitiveTopology
operator|=
name|D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST
expr_stmt|;
block|}
if|if
condition|(
name|primitiveTopology
operator|!=
name|mCurrentPrimitiveTopology
condition|)
block|{
name|mDeviceContext
operator|->
name|IASetPrimitiveTopology
argument_list|(
name|primitiveTopology
argument_list|)
expr_stmt|;
name|mCurrentPrimitiveTopology
operator|=
name|primitiveTopology
expr_stmt|;
block|}
return|return
name|count
operator|>=
name|minCount
return|;
block|}
DECL|function|applyRenderTarget
name|gl
operator|::
name|Error
name|Renderer11
operator|::
name|applyRenderTarget
parameter_list|(
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
parameter_list|)
block|{
return|return
name|mStateManager
operator|.
name|syncFramebuffer
argument_list|(
name|framebuffer
argument_list|)
return|;
block|}
DECL|function|applyVertexBuffer
name|gl
operator|::
name|Error
name|Renderer11
operator|::
name|applyVertexBuffer
parameter_list|(
specifier|const
name|gl
operator|::
name|State
modifier|&
name|state
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLint
name|first
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLsizei
name|instances
parameter_list|,
name|TranslatedIndexData
modifier|*
name|indexInfo
parameter_list|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|mVertexDataManager
operator|->
name|prepareVertexData
argument_list|(
name|state
argument_list|,
name|first
argument_list|,
name|count
argument_list|,
operator|&
name|mTranslatedAttribCache
argument_list|,
name|instances
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
comment|// If index information is passed, mark it with the current changed status.
if|if
condition|(
name|indexInfo
condition|)
block|{
name|indexInfo
operator|->
name|srcIndexData
operator|.
name|srcIndicesChanged
operator|=
name|mAppliedIBChanged
expr_stmt|;
block|}
name|GLsizei
name|numIndicesPerInstance
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|instances
operator|>
literal|0
condition|)
block|{
name|numIndicesPerInstance
operator|=
name|count
expr_stmt|;
block|}
return|return
name|mInputLayoutCache
operator|.
name|applyVertexBuffers
argument_list|(
name|mTranslatedAttribCache
argument_list|,
name|mode
argument_list|,
name|state
operator|.
name|getProgram
argument_list|()
argument_list|,
name|indexInfo
argument_list|,
name|numIndicesPerInstance
argument_list|)
return|;
block|}
DECL|function|applyIndexBuffer
name|gl
operator|::
name|Error
name|Renderer11
operator|::
name|applyIndexBuffer
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|TranslatedIndexData
modifier|*
name|indexInfo
parameter_list|)
block|{
name|gl
operator|::
name|VertexArray
modifier|*
name|vao
init|=
name|data
operator|.
name|state
operator|->
name|getVertexArray
argument_list|()
decl_stmt|;
name|gl
operator|::
name|Buffer
modifier|*
name|elementArrayBuffer
init|=
name|vao
operator|->
name|getElementArrayBuffer
argument_list|()
operator|.
name|get
argument_list|()
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|mIndexDataManager
operator|->
name|prepareIndexData
argument_list|(
name|type
argument_list|,
name|count
argument_list|,
name|elementArrayBuffer
argument_list|,
name|indices
argument_list|,
name|indexInfo
argument_list|,
name|data
operator|.
name|state
operator|->
name|isPrimitiveRestartEnabled
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ID3D11Buffer
modifier|*
name|buffer
init|=
name|NULL
decl_stmt|;
name|DXGI_FORMAT
name|bufferFormat
init|=
operator|(
name|indexInfo
operator|->
name|indexType
operator|==
name|GL_UNSIGNED_INT
operator|)
condition|?
name|DXGI_FORMAT_R32_UINT
else|:
name|DXGI_FORMAT_R16_UINT
decl_stmt|;
if|if
condition|(
name|indexInfo
operator|->
name|storage
condition|)
block|{
name|Buffer11
modifier|*
name|storage
init|=
name|GetAs
argument_list|<
name|Buffer11
argument_list|>
argument_list|(
name|indexInfo
operator|->
name|storage
argument_list|)
decl_stmt|;
name|buffer
operator|=
name|storage
operator|->
name|getBuffer
argument_list|(
name|BUFFER_USAGE_INDEX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IndexBuffer11
modifier|*
name|indexBuffer
init|=
name|GetAs
argument_list|<
name|IndexBuffer11
argument_list|>
argument_list|(
name|indexInfo
operator|->
name|indexBuffer
argument_list|)
decl_stmt|;
name|buffer
operator|=
name|indexBuffer
operator|->
name|getBuffer
argument_list|()
expr_stmt|;
block|}
name|mAppliedIBChanged
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|buffer
operator|!=
name|mAppliedIB
operator|||
name|bufferFormat
operator|!=
name|mAppliedIBFormat
operator|||
name|indexInfo
operator|->
name|startOffset
operator|!=
name|mAppliedIBOffset
condition|)
block|{
name|mDeviceContext
operator|->
name|IASetIndexBuffer
argument_list|(
name|buffer
argument_list|,
name|bufferFormat
argument_list|,
name|indexInfo
operator|->
name|startOffset
argument_list|)
expr_stmt|;
name|mAppliedIB
operator|=
name|buffer
expr_stmt|;
name|mAppliedIBFormat
operator|=
name|bufferFormat
expr_stmt|;
name|mAppliedIBOffset
operator|=
name|indexInfo
operator|->
name|startOffset
expr_stmt|;
name|mAppliedIBChanged
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|applyTransformFeedbackBuffers
name|void
name|Renderer11
operator|::
name|applyTransformFeedbackBuffers
parameter_list|(
specifier|const
name|gl
operator|::
name|State
modifier|&
name|state
parameter_list|)
block|{
name|size_t
name|numXFBBindings
init|=
literal|0
decl_stmt|;
name|bool
name|requiresUpdate
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|state
operator|.
name|isTransformFeedbackActiveUnpaused
argument_list|()
condition|)
block|{
specifier|const
name|gl
operator|::
name|TransformFeedback
modifier|*
name|transformFeedback
init|=
name|state
operator|.
name|getCurrentTransformFeedback
argument_list|()
decl_stmt|;
name|numXFBBindings
operator|=
name|transformFeedback
operator|->
name|getIndexedBufferCount
argument_list|()
expr_stmt|;
name|ASSERT
argument_list|(
name|numXFBBindings
operator|<=
name|gl
operator|::
name|IMPLEMENTATION_MAX_TRANSFORM_FEEDBACK_BUFFERS
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numXFBBindings
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|OffsetBindingPointer
argument_list|<
name|gl
operator|::
name|Buffer
argument_list|>
modifier|&
name|binding
init|=
name|transformFeedback
operator|->
name|getIndexedBuffer
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ID3D11Buffer
modifier|*
name|d3dBuffer
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|binding
operator|.
name|get
argument_list|()
operator|!=
literal|nullptr
condition|)
block|{
name|Buffer11
modifier|*
name|storage
init|=
name|GetImplAs
argument_list|<
name|Buffer11
argument_list|>
argument_list|(
name|binding
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
name|d3dBuffer
operator|=
name|storage
operator|->
name|getBuffer
argument_list|(
name|BUFFER_USAGE_VERTEX_OR_TRANSFORM_FEEDBACK
argument_list|)
expr_stmt|;
block|}
comment|// TODO: mAppliedTFBuffers and friends should also be kept in a vector.
if|if
condition|(
name|d3dBuffer
operator|!=
name|mAppliedTFBuffers
index|[
name|i
index|]
operator|||
name|binding
operator|.
name|getOffset
argument_list|()
operator|!=
name|mAppliedTFOffsets
index|[
name|i
index|]
condition|)
block|{
name|requiresUpdate
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|requiresUpdate
operator|||
name|numXFBBindings
operator|!=
name|mAppliedNumXFBBindings
condition|)
block|{
specifier|const
name|gl
operator|::
name|TransformFeedback
modifier|*
name|transformFeedback
init|=
name|state
operator|.
name|getCurrentTransformFeedback
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numXFBBindings
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|OffsetBindingPointer
argument_list|<
name|gl
operator|::
name|Buffer
argument_list|>
modifier|&
name|binding
init|=
name|transformFeedback
operator|->
name|getIndexedBuffer
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|binding
operator|.
name|get
argument_list|()
operator|!=
literal|nullptr
condition|)
block|{
name|Buffer11
modifier|*
name|storage
init|=
name|GetImplAs
argument_list|<
name|Buffer11
argument_list|>
argument_list|(
name|binding
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
name|ID3D11Buffer
modifier|*
name|d3dBuffer
init|=
name|storage
operator|->
name|getBuffer
argument_list|(
name|BUFFER_USAGE_VERTEX_OR_TRANSFORM_FEEDBACK
argument_list|)
decl_stmt|;
name|mCurrentD3DOffsets
index|[
name|i
index|]
operator|=
operator|(
name|mAppliedTFBuffers
index|[
name|i
index|]
operator|!=
name|d3dBuffer
operator|||
name|mAppliedTFOffsets
index|[
name|i
index|]
operator|!=
name|binding
operator|.
name|getOffset
argument_list|()
operator|)
condition|?
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|binding
operator|.
name|getOffset
argument_list|()
argument_list|)
else|:
operator|-
literal|1
expr_stmt|;
name|mAppliedTFBuffers
index|[
name|i
index|]
operator|=
name|d3dBuffer
expr_stmt|;
block|}
else|else
block|{
name|mAppliedTFBuffers
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|mCurrentD3DOffsets
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|mAppliedTFOffsets
index|[
name|i
index|]
operator|=
name|binding
operator|.
name|getOffset
argument_list|()
expr_stmt|;
block|}
name|mAppliedNumXFBBindings
operator|=
name|numXFBBindings
expr_stmt|;
name|mDeviceContext
operator|->
name|SOSetTargets
argument_list|(
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|numXFBBindings
argument_list|)
argument_list|,
name|mAppliedTFBuffers
argument_list|,
name|mCurrentD3DOffsets
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|drawArraysImpl
name|gl
operator|::
name|Error
name|Renderer11
operator|::
name|drawArraysImpl
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLsizei
name|instances
parameter_list|)
block|{
name|ProgramD3D
modifier|*
name|programD3D
init|=
name|GetImplAs
argument_list|<
name|ProgramD3D
argument_list|>
argument_list|(
name|data
operator|.
name|state
operator|->
name|getProgram
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|programD3D
operator|->
name|usesGeometryShader
argument_list|(
name|mode
argument_list|)
operator|&&
name|data
operator|.
name|state
operator|->
name|isTransformFeedbackActiveUnpaused
argument_list|()
condition|)
block|{
comment|// Since we use a geometry if-and-only-if we rewrite vertex streams, transform feedback
comment|// won't get the correct output. To work around this, draw with *only* the stream out
comment|// first (no pixel shader) to feed the stream out buffers and then draw again with the
comment|// geometry shader + pixel shader to rasterize the primitives.
name|mDeviceContext
operator|->
name|PSSetShader
argument_list|(
literal|nullptr
argument_list|,
literal|nullptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|instances
operator|>
literal|0
condition|)
block|{
name|mDeviceContext
operator|->
name|DrawInstanced
argument_list|(
name|count
argument_list|,
name|instances
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mDeviceContext
operator|->
name|Draw
argument_list|(
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|rx
operator|::
name|ShaderExecutableD3D
modifier|*
name|pixelExe
init|=
literal|nullptr
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|programD3D
operator|->
name|getPixelExecutableForFramebuffer
argument_list|(
name|data
operator|.
name|state
operator|->
name|getDrawFramebuffer
argument_list|()
argument_list|,
operator|&
name|pixelExe
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
comment|// Skip the draw call if rasterizer discard is enabled (or no fragment shader).
if|if
condition|(
operator|!
name|pixelExe
operator|||
name|data
operator|.
name|state
operator|->
name|getRasterizerState
argument_list|()
operator|.
name|rasterizerDiscard
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
name|ID3D11PixelShader
modifier|*
name|pixelShader
init|=
name|GetAs
argument_list|<
name|ShaderExecutable11
argument_list|>
argument_list|(
name|pixelExe
argument_list|)
operator|->
name|getPixelShader
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
cast|reinterpret_cast
argument_list|<
name|uintptr_t
argument_list|>
argument_list|(
name|pixelShader
argument_list|)
operator|==
name|mAppliedPixelShader
argument_list|)
expr_stmt|;
name|mDeviceContext
operator|->
name|PSSetShader
argument_list|(
name|pixelShader
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Retrieve the geometry shader.
name|rx
operator|::
name|ShaderExecutableD3D
modifier|*
name|geometryExe
init|=
literal|nullptr
decl_stmt|;
name|error
operator|=
name|programD3D
operator|->
name|getGeometryExecutableForPrimitiveType
argument_list|(
name|data
argument_list|,
name|mode
argument_list|,
operator|&
name|geometryExe
argument_list|,
literal|nullptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ID3D11GeometryShader
modifier|*
name|geometryShader
init|=
operator|(
name|geometryExe
condition|?
name|GetAs
argument_list|<
name|ShaderExecutable11
argument_list|>
argument_list|(
name|geometryExe
argument_list|)
operator|->
name|getGeometryShader
argument_list|()
else|:
name|NULL
operator|)
decl_stmt|;
name|mAppliedGeometryShader
operator|=
cast|reinterpret_cast
argument_list|<
name|uintptr_t
argument_list|>
argument_list|(
name|geometryShader
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|geometryShader
argument_list|)
expr_stmt|;
name|mDeviceContext
operator|->
name|GSSetShader
argument_list|(
name|geometryShader
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|instances
operator|>
literal|0
condition|)
block|{
name|mDeviceContext
operator|->
name|DrawInstanced
argument_list|(
name|count
argument_list|,
name|instances
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mDeviceContext
operator|->
name|Draw
argument_list|(
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
if|if
condition|(
name|mode
operator|==
name|GL_LINE_LOOP
condition|)
block|{
return|return
name|drawLineLoop
argument_list|(
name|data
argument_list|,
name|count
argument_list|,
name|GL_NONE
argument_list|,
literal|nullptr
argument_list|,
literal|nullptr
argument_list|,
name|instances
argument_list|)
return|;
block|}
if|if
condition|(
name|mode
operator|==
name|GL_TRIANGLE_FAN
condition|)
block|{
return|return
name|drawTriangleFan
argument_list|(
name|data
argument_list|,
name|count
argument_list|,
name|GL_NONE
argument_list|,
literal|nullptr
argument_list|,
literal|0
argument_list|,
name|instances
argument_list|)
return|;
block|}
name|bool
name|useInstancedPointSpriteEmulation
init|=
name|programD3D
operator|->
name|usesPointSize
argument_list|()
operator|&&
name|getWorkarounds
argument_list|()
operator|.
name|useInstancedPointSpriteEmulation
decl_stmt|;
if|if
condition|(
name|instances
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|GL_POINTS
operator|&&
name|useInstancedPointSpriteEmulation
condition|)
block|{
comment|// If pointsprite emulation is used with glDrawArraysInstanced then we need to take a
comment|// less efficent code path.
comment|// Instanced rendering of emulated pointsprites requires a loop to draw each batch of
comment|// points. An offset into the instanced data buffer is calculated and applied on each
comment|// iteration to ensure all instances are rendered correctly.
comment|// Each instance being rendered requires the inputlayout cache to reapply buffers and
comment|// offsets.
for|for
control|(
name|GLsizei
name|i
init|=
literal|0
init|;
name|i
operator|<
name|instances
condition|;
name|i
operator|++
control|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|mInputLayoutCache
operator|.
name|updateVertexOffsetsForPointSpritesEmulation
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|mDeviceContext
operator|->
name|DrawIndexedInstanced
argument_list|(
literal|6
argument_list|,
name|count
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|mDeviceContext
operator|->
name|DrawInstanced
argument_list|(
name|count
argument_list|,
name|instances
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
comment|// If the shader is writing to gl_PointSize, then pointsprites are being rendered.
comment|// Emulating instanced point sprites for FL9_3 requires the topology to be
comment|// D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST and DrawIndexedInstanced is called instead.
if|if
condition|(
name|mode
operator|==
name|GL_POINTS
operator|&&
name|useInstancedPointSpriteEmulation
condition|)
block|{
name|mDeviceContext
operator|->
name|DrawIndexedInstanced
argument_list|(
literal|6
argument_list|,
name|count
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mDeviceContext
operator|->
name|Draw
argument_list|(
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|drawElementsImpl
name|gl
operator|::
name|Error
name|Renderer11
operator|::
name|drawElementsImpl
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
specifier|const
name|TranslatedIndexData
modifier|&
name|indexInfo
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|GLsizei
name|instances
parameter_list|)
block|{
name|int
name|minIndex
init|=
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|indexInfo
operator|.
name|indexRange
operator|.
name|start
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|GL_LINE_LOOP
condition|)
block|{
return|return
name|drawLineLoop
argument_list|(
name|data
argument_list|,
name|count
argument_list|,
name|type
argument_list|,
name|indices
argument_list|,
operator|&
name|indexInfo
argument_list|,
name|instances
argument_list|)
return|;
block|}
if|if
condition|(
name|mode
operator|==
name|GL_TRIANGLE_FAN
condition|)
block|{
return|return
name|drawTriangleFan
argument_list|(
name|data
argument_list|,
name|count
argument_list|,
name|type
argument_list|,
name|indices
argument_list|,
name|minIndex
argument_list|,
name|instances
argument_list|)
return|;
block|}
specifier|const
name|ProgramD3D
modifier|*
name|programD3D
init|=
name|GetImplAs
argument_list|<
name|ProgramD3D
argument_list|>
argument_list|(
name|data
operator|.
name|state
operator|->
name|getProgram
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|instances
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|GL_POINTS
operator|&&
name|programD3D
operator|->
name|usesInstancedPointSpriteEmulation
argument_list|()
condition|)
block|{
comment|// If pointsprite emulation is used with glDrawElementsInstanced then we need to take a
comment|// less efficent code path.
comment|// Instanced rendering of emulated pointsprites requires a loop to draw each batch of
comment|// points. An offset into the instanced data buffer is calculated and applied on each
comment|// iteration to ensure all instances are rendered correctly.
name|GLsizei
name|elementsToRender
init|=
cast|static_cast
argument_list|<
name|GLsizei
argument_list|>
argument_list|(
name|indexInfo
operator|.
name|indexRange
operator|.
name|vertexCount
argument_list|()
argument_list|)
decl_stmt|;
comment|// Each instance being rendered requires the inputlayout cache to reapply buffers and
comment|// offsets.
for|for
control|(
name|GLsizei
name|i
init|=
literal|0
init|;
name|i
operator|<
name|instances
condition|;
name|i
operator|++
control|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|mInputLayoutCache
operator|.
name|updateVertexOffsetsForPointSpritesEmulation
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|mDeviceContext
operator|->
name|DrawIndexedInstanced
argument_list|(
literal|6
argument_list|,
name|elementsToRender
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|mDeviceContext
operator|->
name|DrawIndexedInstanced
argument_list|(
name|count
argument_list|,
name|instances
argument_list|,
literal|0
argument_list|,
operator|-
name|minIndex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
comment|// If the shader is writing to gl_PointSize, then pointsprites are being rendered.
comment|// Emulating instanced point sprites for FL9_3 requires the topology to be
comment|// D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST and DrawIndexedInstanced is called instead.
if|if
condition|(
name|mode
operator|==
name|GL_POINTS
operator|&&
name|programD3D
operator|->
name|usesInstancedPointSpriteEmulation
argument_list|()
condition|)
block|{
comment|// The count parameter passed to drawElements represents the total number of instances
comment|// to be rendered. Each instance is referenced by the bound index buffer from the
comment|// the caller.
comment|//
comment|// Indexed pointsprite emulation replicates data for duplicate entries found
comment|// in the index buffer.
comment|// This is not an efficent rendering mechanism and is only used on downlevel renderers
comment|// that do not support geometry shaders.
name|mDeviceContext
operator|->
name|DrawIndexedInstanced
argument_list|(
literal|6
argument_list|,
name|count
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mDeviceContext
operator|->
name|DrawIndexed
argument_list|(
name|count
argument_list|,
literal|0
argument_list|,
operator|-
name|minIndex
argument_list|)
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|drawLineLoop
name|gl
operator|::
name|Error
name|Renderer11
operator|::
name|drawLineLoop
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indexPointer
parameter_list|,
specifier|const
name|TranslatedIndexData
modifier|*
name|indexInfo
parameter_list|,
name|int
name|instances
parameter_list|)
block|{
name|gl
operator|::
name|VertexArray
modifier|*
name|vao
init|=
name|data
operator|.
name|state
operator|->
name|getVertexArray
argument_list|()
decl_stmt|;
name|gl
operator|::
name|Buffer
modifier|*
name|elementArrayBuffer
init|=
name|vao
operator|->
name|getElementArrayBuffer
argument_list|()
operator|.
name|get
argument_list|()
decl_stmt|;
specifier|const
name|GLvoid
modifier|*
name|indices
init|=
name|indexPointer
decl_stmt|;
comment|// Get the raw indices for an indexed draw
if|if
condition|(
name|type
operator|!=
name|GL_NONE
operator|&&
name|elementArrayBuffer
condition|)
block|{
name|BufferD3D
modifier|*
name|storage
init|=
name|GetImplAs
argument_list|<
name|BufferD3D
argument_list|>
argument_list|(
name|elementArrayBuffer
argument_list|)
decl_stmt|;
name|intptr_t
name|offset
init|=
cast|reinterpret_cast
argument_list|<
name|intptr_t
argument_list|>
argument_list|(
name|indices
argument_list|)
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|bufferData
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|storage
operator|->
name|getData
argument_list|(
operator|&
name|bufferData
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|indices
operator|=
name|bufferData
operator|+
name|offset
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mLineLoopIB
condition|)
block|{
name|mLineLoopIB
operator|=
operator|new
name|StreamingIndexBufferInterface
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|mLineLoopIB
operator|->
name|reserveBufferSpace
argument_list|(
name|INITIAL_INDEX_BUFFER_SIZE
argument_list|,
name|GL_UNSIGNED_INT
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
name|SafeDelete
argument_list|(
name|mLineLoopIB
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
comment|// Checked by Renderer11::applyPrimitiveType
name|ASSERT
argument_list|(
name|count
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|count
argument_list|)
operator|+
literal|1
operator|>
operator|(
name|std
operator|::
name|numeric_limits
argument_list|<
name|unsigned
name|int
argument_list|>
operator|::
name|max
argument_list|()
operator|/
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
operator|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create a 32-bit looping index buffer for GL_LINE_LOOP, too many indices required."
argument_list|)
return|;
block|}
name|GetLineLoopIndices
argument_list|(
name|indices
argument_list|,
name|type
argument_list|,
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|count
argument_list|)
argument_list|,
name|data
operator|.
name|state
operator|->
name|isPrimitiveRestartEnabled
argument_list|()
argument_list|,
operator|&
name|mScratchIndexDataBuffer
argument_list|)
expr_stmt|;
name|unsigned
name|int
name|spaceNeeded
init|=
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
sizeof|sizeof
argument_list|(
name|GLuint
argument_list|)
operator|*
name|mScratchIndexDataBuffer
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|mLineLoopIB
operator|->
name|reserveBufferSpace
argument_list|(
name|spaceNeeded
argument_list|,
name|GL_UNSIGNED_INT
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|void
modifier|*
name|mappedMemory
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
name|error
operator|=
name|mLineLoopIB
operator|->
name|mapBuffer
argument_list|(
name|spaceNeeded
argument_list|,
operator|&
name|mappedMemory
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
comment|// Copy over the converted index data.
name|memcpy
argument_list|(
name|mappedMemory
argument_list|,
operator|&
name|mScratchIndexDataBuffer
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|GLuint
argument_list|)
operator|*
name|mScratchIndexDataBuffer
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|error
operator|=
name|mLineLoopIB
operator|->
name|unmapBuffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|IndexBuffer11
modifier|*
name|indexBuffer
init|=
name|GetAs
argument_list|<
name|IndexBuffer11
argument_list|>
argument_list|(
name|mLineLoopIB
operator|->
name|getIndexBuffer
argument_list|()
argument_list|)
decl_stmt|;
name|ID3D11Buffer
modifier|*
name|d3dIndexBuffer
init|=
name|indexBuffer
operator|->
name|getBuffer
argument_list|()
decl_stmt|;
name|DXGI_FORMAT
name|indexFormat
init|=
name|indexBuffer
operator|->
name|getIndexFormat
argument_list|()
decl_stmt|;
if|if
condition|(
name|mAppliedIB
operator|!=
name|d3dIndexBuffer
operator|||
name|mAppliedIBFormat
operator|!=
name|indexFormat
operator|||
name|mAppliedIBOffset
operator|!=
name|offset
condition|)
block|{
name|mDeviceContext
operator|->
name|IASetIndexBuffer
argument_list|(
name|d3dIndexBuffer
argument_list|,
name|indexFormat
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|mAppliedIB
operator|=
name|d3dIndexBuffer
expr_stmt|;
name|mAppliedIBFormat
operator|=
name|indexFormat
expr_stmt|;
name|mAppliedIBOffset
operator|=
name|offset
expr_stmt|;
block|}
name|INT
name|baseVertexLocation
init|=
operator|(
name|indexInfo
condition|?
operator|-
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|indexInfo
operator|->
name|indexRange
operator|.
name|start
argument_list|)
else|:
literal|0
operator|)
decl_stmt|;
name|UINT
name|indexCount
init|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|mScratchIndexDataBuffer
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|instances
operator|>
literal|0
condition|)
block|{
name|mDeviceContext
operator|->
name|DrawIndexedInstanced
argument_list|(
name|indexCount
argument_list|,
name|instances
argument_list|,
literal|0
argument_list|,
name|baseVertexLocation
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mDeviceContext
operator|->
name|DrawIndexed
argument_list|(
name|indexCount
argument_list|,
literal|0
argument_list|,
name|baseVertexLocation
argument_list|)
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|drawTriangleFan
name|gl
operator|::
name|Error
name|Renderer11
operator|::
name|drawTriangleFan
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|int
name|minIndex
parameter_list|,
name|int
name|instances
parameter_list|)
block|{
name|gl
operator|::
name|VertexArray
modifier|*
name|vao
init|=
name|data
operator|.
name|state
operator|->
name|getVertexArray
argument_list|()
decl_stmt|;
name|gl
operator|::
name|Buffer
modifier|*
name|elementArrayBuffer
init|=
name|vao
operator|->
name|getElementArrayBuffer
argument_list|()
operator|.
name|get
argument_list|()
decl_stmt|;
specifier|const
name|GLvoid
modifier|*
name|indexPointer
init|=
name|indices
decl_stmt|;
comment|// Get the raw indices for an indexed draw
if|if
condition|(
name|type
operator|!=
name|GL_NONE
operator|&&
name|elementArrayBuffer
condition|)
block|{
name|BufferD3D
modifier|*
name|storage
init|=
name|GetImplAs
argument_list|<
name|BufferD3D
argument_list|>
argument_list|(
name|elementArrayBuffer
argument_list|)
decl_stmt|;
name|intptr_t
name|offset
init|=
cast|reinterpret_cast
argument_list|<
name|intptr_t
argument_list|>
argument_list|(
name|indices
argument_list|)
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|bufferData
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|storage
operator|->
name|getData
argument_list|(
operator|&
name|bufferData
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|indexPointer
operator|=
name|bufferData
operator|+
name|offset
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mTriangleFanIB
condition|)
block|{
name|mTriangleFanIB
operator|=
operator|new
name|StreamingIndexBufferInterface
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|mTriangleFanIB
operator|->
name|reserveBufferSpace
argument_list|(
name|INITIAL_INDEX_BUFFER_SIZE
argument_list|,
name|GL_UNSIGNED_INT
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
name|SafeDelete
argument_list|(
name|mTriangleFanIB
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
comment|// Checked by Renderer11::applyPrimitiveType
name|ASSERT
argument_list|(
name|count
operator|>=
literal|3
argument_list|)
expr_stmt|;
specifier|const
name|GLuint
name|numTris
init|=
name|count
operator|-
literal|2
decl_stmt|;
if|if
condition|(
name|numTris
operator|>
operator|(
name|std
operator|::
name|numeric_limits
argument_list|<
name|unsigned
name|int
argument_list|>
operator|::
name|max
argument_list|()
operator|/
operator|(
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
operator|*
literal|3
operator|)
operator|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create a scratch index buffer for GL_TRIANGLE_FAN, too many indices required."
argument_list|)
return|;
block|}
name|GetTriFanIndices
argument_list|(
name|indexPointer
argument_list|,
name|type
argument_list|,
name|count
argument_list|,
name|data
operator|.
name|state
operator|->
name|isPrimitiveRestartEnabled
argument_list|()
argument_list|,
operator|&
name|mScratchIndexDataBuffer
argument_list|)
expr_stmt|;
specifier|const
name|unsigned
name|int
name|spaceNeeded
init|=
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|mScratchIndexDataBuffer
operator|.
name|size
argument_list|()
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|mTriangleFanIB
operator|->
name|reserveBufferSpace
argument_list|(
name|spaceNeeded
argument_list|,
name|GL_UNSIGNED_INT
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|void
modifier|*
name|mappedMemory
init|=
literal|nullptr
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
name|error
operator|=
name|mTriangleFanIB
operator|->
name|mapBuffer
argument_list|(
name|spaceNeeded
argument_list|,
operator|&
name|mappedMemory
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|memcpy
argument_list|(
name|mappedMemory
argument_list|,
operator|&
name|mScratchIndexDataBuffer
index|[
literal|0
index|]
argument_list|,
name|spaceNeeded
argument_list|)
expr_stmt|;
name|error
operator|=
name|mTriangleFanIB
operator|->
name|unmapBuffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|IndexBuffer11
modifier|*
name|indexBuffer
init|=
name|GetAs
argument_list|<
name|IndexBuffer11
argument_list|>
argument_list|(
name|mTriangleFanIB
operator|->
name|getIndexBuffer
argument_list|()
argument_list|)
decl_stmt|;
name|ID3D11Buffer
modifier|*
name|d3dIndexBuffer
init|=
name|indexBuffer
operator|->
name|getBuffer
argument_list|()
decl_stmt|;
name|DXGI_FORMAT
name|indexFormat
init|=
name|indexBuffer
operator|->
name|getIndexFormat
argument_list|()
decl_stmt|;
if|if
condition|(
name|mAppliedIB
operator|!=
name|d3dIndexBuffer
operator|||
name|mAppliedIBFormat
operator|!=
name|indexFormat
operator|||
name|mAppliedIBOffset
operator|!=
name|offset
condition|)
block|{
name|mDeviceContext
operator|->
name|IASetIndexBuffer
argument_list|(
name|d3dIndexBuffer
argument_list|,
name|indexFormat
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|mAppliedIB
operator|=
name|d3dIndexBuffer
expr_stmt|;
name|mAppliedIBFormat
operator|=
name|indexFormat
expr_stmt|;
name|mAppliedIBOffset
operator|=
name|offset
expr_stmt|;
block|}
name|UINT
name|indexCount
init|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|mScratchIndexDataBuffer
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|instances
operator|>
literal|0
condition|)
block|{
name|mDeviceContext
operator|->
name|DrawIndexedInstanced
argument_list|(
name|indexCount
argument_list|,
name|instances
argument_list|,
literal|0
argument_list|,
operator|-
name|minIndex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mDeviceContext
operator|->
name|DrawIndexed
argument_list|(
name|indexCount
argument_list|,
literal|0
argument_list|,
operator|-
name|minIndex
argument_list|)
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|applyShadersImpl
name|gl
operator|::
name|Error
name|Renderer11
operator|::
name|applyShadersImpl
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLenum
name|drawMode
parameter_list|)
block|{
name|ProgramD3D
modifier|*
name|programD3D
init|=
name|GetImplAs
argument_list|<
name|ProgramD3D
argument_list|>
argument_list|(
name|data
operator|.
name|state
operator|->
name|getProgram
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
specifier|auto
modifier|&
name|inputLayout
init|=
name|programD3D
operator|->
name|getCachedInputLayout
argument_list|()
decl_stmt|;
name|ShaderExecutableD3D
modifier|*
name|vertexExe
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|programD3D
operator|->
name|getVertexExecutableForInputLayout
argument_list|(
name|inputLayout
argument_list|,
operator|&
name|vertexExe
argument_list|,
literal|nullptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|drawFramebuffer
init|=
name|data
operator|.
name|state
operator|->
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
name|ShaderExecutableD3D
modifier|*
name|pixelExe
init|=
name|NULL
decl_stmt|;
name|error
operator|=
name|programD3D
operator|->
name|getPixelExecutableForFramebuffer
argument_list|(
name|drawFramebuffer
argument_list|,
operator|&
name|pixelExe
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ShaderExecutableD3D
modifier|*
name|geometryExe
init|=
literal|nullptr
decl_stmt|;
name|error
operator|=
name|programD3D
operator|->
name|getGeometryExecutableForPrimitiveType
argument_list|(
name|data
argument_list|,
name|drawMode
argument_list|,
operator|&
name|geometryExe
argument_list|,
literal|nullptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ID3D11VertexShader
modifier|*
name|vertexShader
init|=
operator|(
name|vertexExe
condition|?
name|GetAs
argument_list|<
name|ShaderExecutable11
argument_list|>
argument_list|(
name|vertexExe
argument_list|)
operator|->
name|getVertexShader
argument_list|()
else|:
name|NULL
operator|)
decl_stmt|;
name|ID3D11PixelShader
modifier|*
name|pixelShader
init|=
name|NULL
decl_stmt|;
comment|// Skip pixel shader if we're doing rasterizer discard.
name|bool
name|rasterizerDiscard
init|=
name|data
operator|.
name|state
operator|->
name|getRasterizerState
argument_list|()
operator|.
name|rasterizerDiscard
decl_stmt|;
if|if
condition|(
operator|!
name|rasterizerDiscard
condition|)
block|{
name|pixelShader
operator|=
operator|(
name|pixelExe
condition|?
name|GetAs
argument_list|<
name|ShaderExecutable11
argument_list|>
argument_list|(
name|pixelExe
argument_list|)
operator|->
name|getPixelShader
argument_list|()
else|:
name|NULL
operator|)
expr_stmt|;
block|}
name|ID3D11GeometryShader
modifier|*
name|geometryShader
init|=
name|NULL
decl_stmt|;
name|bool
name|transformFeedbackActive
init|=
name|data
operator|.
name|state
operator|->
name|isTransformFeedbackActiveUnpaused
argument_list|()
decl_stmt|;
if|if
condition|(
name|transformFeedbackActive
condition|)
block|{
name|geometryShader
operator|=
operator|(
name|vertexExe
condition|?
name|GetAs
argument_list|<
name|ShaderExecutable11
argument_list|>
argument_list|(
name|vertexExe
argument_list|)
operator|->
name|getStreamOutShader
argument_list|()
else|:
name|NULL
operator|)
expr_stmt|;
block|}
else|else
block|{
name|geometryShader
operator|=
operator|(
name|geometryExe
condition|?
name|GetAs
argument_list|<
name|ShaderExecutable11
argument_list|>
argument_list|(
name|geometryExe
argument_list|)
operator|->
name|getGeometryShader
argument_list|()
else|:
name|NULL
operator|)
expr_stmt|;
block|}
name|bool
name|dirtyUniforms
init|=
literal|false
decl_stmt|;
if|if
condition|(
cast|reinterpret_cast
argument_list|<
name|uintptr_t
argument_list|>
argument_list|(
name|vertexShader
argument_list|)
operator|!=
name|mAppliedVertexShader
condition|)
block|{
name|mDeviceContext
operator|->
name|VSSetShader
argument_list|(
name|vertexShader
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mAppliedVertexShader
operator|=
cast|reinterpret_cast
argument_list|<
name|uintptr_t
argument_list|>
argument_list|(
name|vertexShader
argument_list|)
expr_stmt|;
name|dirtyUniforms
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
cast|reinterpret_cast
argument_list|<
name|uintptr_t
argument_list|>
argument_list|(
name|geometryShader
argument_list|)
operator|!=
name|mAppliedGeometryShader
condition|)
block|{
name|mDeviceContext
operator|->
name|GSSetShader
argument_list|(
name|geometryShader
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mAppliedGeometryShader
operator|=
cast|reinterpret_cast
argument_list|<
name|uintptr_t
argument_list|>
argument_list|(
name|geometryShader
argument_list|)
expr_stmt|;
name|dirtyUniforms
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
cast|reinterpret_cast
argument_list|<
name|uintptr_t
argument_list|>
argument_list|(
name|pixelShader
argument_list|)
operator|!=
name|mAppliedPixelShader
condition|)
block|{
name|mDeviceContext
operator|->
name|PSSetShader
argument_list|(
name|pixelShader
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mAppliedPixelShader
operator|=
cast|reinterpret_cast
argument_list|<
name|uintptr_t
argument_list|>
argument_list|(
name|pixelShader
argument_list|)
expr_stmt|;
name|dirtyUniforms
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|dirtyUniforms
condition|)
block|{
name|programD3D
operator|->
name|dirtyAllUniforms
argument_list|()
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|applyUniforms
name|gl
operator|::
name|Error
name|Renderer11
operator|::
name|applyUniforms
parameter_list|(
specifier|const
name|ProgramD3D
modifier|&
name|programD3D
parameter_list|,
name|GLenum
name|drawMode
parameter_list|,
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|D3DUniform
modifier|*
argument_list|>
modifier|&
name|uniformArray
parameter_list|)
block|{
name|unsigned
name|int
name|totalRegisterCountVS
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|totalRegisterCountPS
init|=
literal|0
decl_stmt|;
name|bool
name|vertexUniformsDirty
init|=
literal|false
decl_stmt|;
name|bool
name|pixelUniformsDirty
init|=
literal|false
decl_stmt|;
for|for
control|(
specifier|const
name|D3DUniform
modifier|*
name|uniform
range|:
name|uniformArray
control|)
block|{
if|if
condition|(
name|uniform
operator|->
name|isReferencedByVertexShader
argument_list|()
operator|&&
operator|!
name|uniform
operator|->
name|isSampler
argument_list|()
condition|)
block|{
name|totalRegisterCountVS
operator|+=
name|uniform
operator|->
name|registerCount
expr_stmt|;
name|vertexUniformsDirty
operator|=
operator|(
name|vertexUniformsDirty
operator|||
name|uniform
operator|->
name|dirty
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|uniform
operator|->
name|isReferencedByFragmentShader
argument_list|()
operator|&&
operator|!
name|uniform
operator|->
name|isSampler
argument_list|()
condition|)
block|{
name|totalRegisterCountPS
operator|+=
name|uniform
operator|->
name|registerCount
expr_stmt|;
name|pixelUniformsDirty
operator|=
operator|(
name|pixelUniformsDirty
operator|||
name|uniform
operator|->
name|dirty
operator|)
expr_stmt|;
block|}
block|}
specifier|const
name|UniformStorage11
modifier|*
name|vertexUniformStorage
init|=
name|GetAs
argument_list|<
name|UniformStorage11
argument_list|>
argument_list|(
operator|&
name|programD3D
operator|.
name|getVertexUniformStorage
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|UniformStorage11
modifier|*
name|fragmentUniformStorage
init|=
name|GetAs
argument_list|<
name|UniformStorage11
argument_list|>
argument_list|(
operator|&
name|programD3D
operator|.
name|getFragmentUniformStorage
argument_list|()
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|vertexUniformStorage
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|fragmentUniformStorage
argument_list|)
expr_stmt|;
name|ID3D11Buffer
modifier|*
name|vertexConstantBuffer
init|=
name|vertexUniformStorage
operator|->
name|getConstantBuffer
argument_list|()
decl_stmt|;
name|ID3D11Buffer
modifier|*
name|pixelConstantBuffer
init|=
name|fragmentUniformStorage
operator|->
name|getConstantBuffer
argument_list|()
decl_stmt|;
name|float
argument_list|(
operator|*
name|mapVS
argument_list|)
index|[
literal|4
index|]
operator|=
name|NULL
expr_stmt|;
name|float
argument_list|(
operator|*
name|mapPS
argument_list|)
index|[
literal|4
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|totalRegisterCountVS
operator|>
literal|0
operator|&&
name|vertexUniformsDirty
condition|)
block|{
name|D3D11_MAPPED_SUBRESOURCE
name|map
init|=
block|{
literal|0
block|}
decl_stmt|;
name|HRESULT
name|result
init|=
name|mDeviceContext
operator|->
name|Map
argument_list|(
name|vertexConstantBuffer
argument_list|,
literal|0
argument_list|,
name|D3D11_MAP_WRITE_DISCARD
argument_list|,
literal|0
argument_list|,
operator|&
name|map
argument_list|)
decl_stmt|;
name|UNUSED_ASSERTION_VARIABLE
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|mapVS
operator|=
operator|(
name|float
argument_list|(
operator|*
argument_list|)
index|[
literal|4
index|]
operator|)
name|map
operator|.
name|pData
expr_stmt|;
block|}
if|if
condition|(
name|totalRegisterCountPS
operator|>
literal|0
operator|&&
name|pixelUniformsDirty
condition|)
block|{
name|D3D11_MAPPED_SUBRESOURCE
name|map
init|=
block|{
literal|0
block|}
decl_stmt|;
name|HRESULT
name|result
init|=
name|mDeviceContext
operator|->
name|Map
argument_list|(
name|pixelConstantBuffer
argument_list|,
literal|0
argument_list|,
name|D3D11_MAP_WRITE_DISCARD
argument_list|,
literal|0
argument_list|,
operator|&
name|map
argument_list|)
decl_stmt|;
name|UNUSED_ASSERTION_VARIABLE
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|mapPS
operator|=
operator|(
name|float
argument_list|(
operator|*
argument_list|)
index|[
literal|4
index|]
operator|)
name|map
operator|.
name|pData
expr_stmt|;
block|}
for|for
control|(
specifier|const
name|D3DUniform
modifier|*
name|uniform
range|:
name|uniformArray
control|)
block|{
if|if
condition|(
name|uniform
operator|->
name|isSampler
argument_list|()
condition|)
continue|continue;
name|unsigned
name|int
name|componentCount
init|=
operator|(
literal|4
operator|-
name|uniform
operator|->
name|registerElement
operator|)
decl_stmt|;
comment|// we assume that uniforms from structs are arranged in struct order in our uniforms list.
comment|// otherwise we would overwrite previously written regions of memory.
if|if
condition|(
name|uniform
operator|->
name|isReferencedByVertexShader
argument_list|()
operator|&&
name|mapVS
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|mapVS
index|[
name|uniform
operator|->
name|vsRegisterIndex
index|]
index|[
name|uniform
operator|->
name|registerElement
index|]
argument_list|,
name|uniform
operator|->
name|data
argument_list|,
name|uniform
operator|->
name|registerCount
operator|*
sizeof|sizeof
argument_list|(
name|float
argument_list|)
operator|*
name|componentCount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uniform
operator|->
name|isReferencedByFragmentShader
argument_list|()
operator|&&
name|mapPS
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|mapPS
index|[
name|uniform
operator|->
name|psRegisterIndex
index|]
index|[
name|uniform
operator|->
name|registerElement
index|]
argument_list|,
name|uniform
operator|->
name|data
argument_list|,
name|uniform
operator|->
name|registerCount
operator|*
sizeof|sizeof
argument_list|(
name|float
argument_list|)
operator|*
name|componentCount
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mapVS
condition|)
block|{
name|mDeviceContext
operator|->
name|Unmap
argument_list|(
name|vertexConstantBuffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mapPS
condition|)
block|{
name|mDeviceContext
operator|->
name|Unmap
argument_list|(
name|pixelConstantBuffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mCurrentVertexConstantBuffer
operator|!=
name|vertexConstantBuffer
condition|)
block|{
name|mDeviceContext
operator|->
name|VSSetConstantBuffers
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|vertexConstantBuffer
argument_list|)
expr_stmt|;
name|mCurrentVertexConstantBuffer
operator|=
name|vertexConstantBuffer
expr_stmt|;
block|}
if|if
condition|(
name|mCurrentPixelConstantBuffer
operator|!=
name|pixelConstantBuffer
condition|)
block|{
name|mDeviceContext
operator|->
name|PSSetConstantBuffers
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|pixelConstantBuffer
argument_list|)
expr_stmt|;
name|mCurrentPixelConstantBuffer
operator|=
name|pixelConstantBuffer
expr_stmt|;
block|}
comment|// Driver uniforms
if|if
condition|(
operator|!
name|mDriverConstantBufferVS
condition|)
block|{
name|D3D11_BUFFER_DESC
name|constantBufferDescription
init|=
block|{
literal|0
block|}
decl_stmt|;
name|constantBufferDescription
operator|.
name|ByteWidth
operator|=
sizeof|sizeof
argument_list|(
name|dx_VertexConstants11
argument_list|)
expr_stmt|;
name|constantBufferDescription
operator|.
name|Usage
operator|=
name|D3D11_USAGE_DEFAULT
expr_stmt|;
name|constantBufferDescription
operator|.
name|BindFlags
operator|=
name|D3D11_BIND_CONSTANT_BUFFER
expr_stmt|;
name|constantBufferDescription
operator|.
name|CPUAccessFlags
operator|=
literal|0
expr_stmt|;
name|constantBufferDescription
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|constantBufferDescription
operator|.
name|StructureByteStride
operator|=
literal|0
expr_stmt|;
name|HRESULT
name|result
init|=
name|mDevice
operator|->
name|CreateBuffer
argument_list|(
operator|&
name|constantBufferDescription
argument_list|,
name|NULL
argument_list|,
operator|&
name|mDriverConstantBufferVS
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create vertex shader constant buffer, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
name|mDeviceContext
operator|->
name|VSSetConstantBuffers
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
operator|&
name|mDriverConstantBufferVS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mDriverConstantBufferPS
condition|)
block|{
name|D3D11_BUFFER_DESC
name|constantBufferDescription
init|=
block|{
literal|0
block|}
decl_stmt|;
name|constantBufferDescription
operator|.
name|ByteWidth
operator|=
sizeof|sizeof
argument_list|(
name|dx_PixelConstants11
argument_list|)
expr_stmt|;
name|constantBufferDescription
operator|.
name|Usage
operator|=
name|D3D11_USAGE_DEFAULT
expr_stmt|;
name|constantBufferDescription
operator|.
name|BindFlags
operator|=
name|D3D11_BIND_CONSTANT_BUFFER
expr_stmt|;
name|constantBufferDescription
operator|.
name|CPUAccessFlags
operator|=
literal|0
expr_stmt|;
name|constantBufferDescription
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|constantBufferDescription
operator|.
name|StructureByteStride
operator|=
literal|0
expr_stmt|;
name|HRESULT
name|result
init|=
name|mDevice
operator|->
name|CreateBuffer
argument_list|(
operator|&
name|constantBufferDescription
argument_list|,
name|NULL
argument_list|,
operator|&
name|mDriverConstantBufferPS
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create pixel shader constant buffer, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
name|mDeviceContext
operator|->
name|PSSetConstantBuffers
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
operator|&
name|mDriverConstantBufferPS
argument_list|)
expr_stmt|;
block|}
specifier|const
name|dx_VertexConstants11
modifier|&
name|vertexConstants
init|=
name|mStateManager
operator|.
name|getVertexConstants
argument_list|()
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|vertexConstants
argument_list|,
operator|&
name|mAppliedVertexConstants
argument_list|,
sizeof|sizeof
argument_list|(
name|dx_VertexConstants11
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|mDriverConstantBufferVS
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mDriverConstantBufferVS
condition|)
block|{
name|mDeviceContext
operator|->
name|UpdateSubresource
argument_list|(
name|mDriverConstantBufferVS
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|vertexConstants
argument_list|,
literal|16
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|mAppliedVertexConstants
argument_list|,
operator|&
name|vertexConstants
argument_list|,
sizeof|sizeof
argument_list|(
name|dx_VertexConstants11
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|const
name|dx_PixelConstants11
modifier|&
name|pixelConstants
init|=
name|mStateManager
operator|.
name|getPixelConstants
argument_list|()
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|pixelConstants
argument_list|,
operator|&
name|mAppliedPixelConstants
argument_list|,
sizeof|sizeof
argument_list|(
name|dx_PixelConstants11
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|mDriverConstantBufferPS
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mDriverConstantBufferPS
condition|)
block|{
name|mDeviceContext
operator|->
name|UpdateSubresource
argument_list|(
name|mDriverConstantBufferPS
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|pixelConstants
argument_list|,
literal|16
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|mAppliedPixelConstants
argument_list|,
operator|&
name|pixelConstants
argument_list|,
sizeof|sizeof
argument_list|(
name|dx_PixelConstants11
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// GSSetConstantBuffers triggers device removal on 9_3, so we should only call it if necessary
if|if
condition|(
name|programD3D
operator|.
name|usesGeometryShader
argument_list|(
name|drawMode
argument_list|)
condition|)
block|{
comment|// needed for the point sprite geometry shader
if|if
condition|(
name|mCurrentGeometryConstantBuffer
operator|!=
name|mDriverConstantBufferPS
condition|)
block|{
name|ASSERT
argument_list|(
name|mDriverConstantBufferPS
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mDriverConstantBufferPS
condition|)
block|{
name|mDeviceContext
operator|->
name|GSSetConstantBuffers
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|mDriverConstantBufferPS
argument_list|)
expr_stmt|;
name|mCurrentGeometryConstantBuffer
operator|=
name|mDriverConstantBufferPS
expr_stmt|;
block|}
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|markAllStateDirty
name|void
name|Renderer11
operator|::
name|markAllStateDirty
parameter_list|()
block|{
name|TRACE_EVENT0
argument_list|(
literal|"gpu.angle"
argument_list|,
literal|"Renderer11::markAllStateDirty"
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|vsamplerId
init|=
literal|0
init|;
name|vsamplerId
operator|<
name|mForceSetVertexSamplerStates
operator|.
name|size
argument_list|()
condition|;
operator|++
name|vsamplerId
control|)
block|{
name|mForceSetVertexSamplerStates
index|[
name|vsamplerId
index|]
operator|=
literal|true
expr_stmt|;
block|}
for|for
control|(
name|size_t
name|fsamplerId
init|=
literal|0
init|;
name|fsamplerId
operator|<
name|mForceSetPixelSamplerStates
operator|.
name|size
argument_list|()
condition|;
operator|++
name|fsamplerId
control|)
block|{
name|mForceSetPixelSamplerStates
index|[
name|fsamplerId
index|]
operator|=
literal|true
expr_stmt|;
block|}
name|mStateManager
operator|.
name|invalidateEverything
argument_list|()
expr_stmt|;
name|mAppliedIB
operator|=
name|NULL
expr_stmt|;
name|mAppliedIBFormat
operator|=
name|DXGI_FORMAT_UNKNOWN
expr_stmt|;
name|mAppliedIBOffset
operator|=
literal|0
expr_stmt|;
name|mAppliedVertexShader
operator|=
name|angle
operator|::
name|DirtyPointer
expr_stmt|;
name|mAppliedGeometryShader
operator|=
name|angle
operator|::
name|DirtyPointer
expr_stmt|;
name|mAppliedPixelShader
operator|=
name|angle
operator|::
name|DirtyPointer
expr_stmt|;
name|mAppliedNumXFBBindings
operator|=
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TRANSFORM_FEEDBACK_BUFFERS
condition|;
name|i
operator|++
control|)
block|{
name|mAppliedTFBuffers
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|mAppliedTFOffsets
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|mAppliedVertexConstants
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dx_VertexConstants11
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|mAppliedPixelConstants
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dx_PixelConstants11
argument_list|)
argument_list|)
expr_stmt|;
name|mInputLayoutCache
operator|.
name|markDirty
argument_list|()
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_VERTEX_SHADER_UNIFORM_BUFFERS
condition|;
name|i
operator|++
control|)
block|{
name|mCurrentConstantBufferVS
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mCurrentConstantBufferVSOffset
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|mCurrentConstantBufferVSSize
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|mCurrentConstantBufferPS
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mCurrentConstantBufferPSOffset
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|mCurrentConstantBufferPSSize
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|mCurrentVertexConstantBuffer
operator|=
name|NULL
expr_stmt|;
name|mCurrentPixelConstantBuffer
operator|=
name|NULL
expr_stmt|;
name|mCurrentGeometryConstantBuffer
operator|=
name|NULL
expr_stmt|;
name|mCurrentPrimitiveTopology
operator|=
name|D3D_PRIMITIVE_TOPOLOGY_UNDEFINED
expr_stmt|;
block|}
DECL|function|releaseDeviceResources
name|void
name|Renderer11
operator|::
name|releaseDeviceResources
parameter_list|()
block|{
name|mStateCache
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mInputLayoutCache
operator|.
name|clear
argument_list|()
expr_stmt|;
name|SafeDelete
argument_list|(
name|mVertexDataManager
argument_list|)
expr_stmt|;
name|SafeDelete
argument_list|(
name|mIndexDataManager
argument_list|)
expr_stmt|;
name|SafeDelete
argument_list|(
name|mLineLoopIB
argument_list|)
expr_stmt|;
name|SafeDelete
argument_list|(
name|mTriangleFanIB
argument_list|)
expr_stmt|;
name|SafeDelete
argument_list|(
name|mBlit
argument_list|)
expr_stmt|;
name|SafeDelete
argument_list|(
name|mClear
argument_list|)
expr_stmt|;
name|SafeDelete
argument_list|(
name|mTrim
argument_list|)
expr_stmt|;
name|SafeDelete
argument_list|(
name|mPixelTransfer
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mDriverConstantBufferVS
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mDriverConstantBufferPS
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mSyncQuery
argument_list|)
expr_stmt|;
block|}
comment|// set notify to true to broadcast a message to all contexts of the device loss
DECL|function|testDeviceLost
name|bool
name|Renderer11
operator|::
name|testDeviceLost
parameter_list|()
block|{
name|bool
name|isLost
init|=
literal|false
decl_stmt|;
comment|// GetRemovedReason is used to test if the device is removed
name|HRESULT
name|result
init|=
name|mDevice
operator|->
name|GetDeviceRemovedReason
argument_list|()
decl_stmt|;
name|isLost
operator|=
name|d3d11
operator|::
name|isDeviceLostError
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|isLost
condition|)
block|{
comment|// Log error if this is a new device lost event
if|if
condition|(
name|mDeviceLost
operator|==
literal|false
condition|)
block|{
name|ERR
argument_list|(
literal|"The D3D11 device was removed: 0x%08X"
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
comment|// ensure we note the device loss --
comment|// we'll probably get this done again by notifyDeviceLost
comment|// but best to remember it!
comment|// Note that we don't want to clear the device loss status here
comment|// -- this needs to be done by resetDevice
name|mDeviceLost
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|isLost
return|;
block|}
DECL|function|testDeviceResettable
name|bool
name|Renderer11
operator|::
name|testDeviceResettable
parameter_list|()
block|{
comment|// determine if the device is resettable by creating a dummy device
name|PFN_D3D11_CREATE_DEVICE
name|D3D11CreateDevice
init|=
operator|(
name|PFN_D3D11_CREATE_DEVICE
operator|)
name|GetProcAddress
argument_list|(
name|mD3d11Module
argument_list|,
literal|"D3D11CreateDevice"
argument_list|)
decl_stmt|;
if|if
condition|(
name|D3D11CreateDevice
operator|==
name|NULL
condition|)
block|{
return|return
literal|false
return|;
block|}
name|ID3D11Device
modifier|*
name|dummyDevice
decl_stmt|;
name|D3D_FEATURE_LEVEL
name|dummyFeatureLevel
decl_stmt|;
name|ID3D11DeviceContext
modifier|*
name|dummyContext
decl_stmt|;
name|ASSERT
argument_list|(
name|mRequestedDriverType
operator|!=
name|D3D_DRIVER_TYPE_UNKNOWN
argument_list|)
expr_stmt|;
name|HRESULT
name|result
init|=
name|D3D11CreateDevice
argument_list|(
name|NULL
argument_list|,
name|mRequestedDriverType
argument_list|,
name|NULL
argument_list|,
if|#
directive|if
name|defined
argument_list|(
name|_DEBUG
argument_list|)
name|D3D11_CREATE_DEVICE_DEBUG
argument_list|,
else|#
directive|else
literal|0
argument_list|,
endif|#
directive|endif
name|mAvailableFeatureLevels
operator|.
name|data
argument_list|()
argument_list|,
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|mAvailableFeatureLevels
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
name|D3D11_SDK_VERSION
argument_list|,
operator|&
name|dummyDevice
argument_list|,
operator|&
name|dummyFeatureLevel
argument_list|,
operator|&
name|dummyContext
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mDevice
operator|||
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|SafeRelease
argument_list|(
name|dummyContext
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|dummyDevice
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|release
name|void
name|Renderer11
operator|::
name|release
parameter_list|()
block|{
name|RendererD3D
operator|::
name|cleanup
argument_list|()
expr_stmt|;
name|releaseDeviceResources
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|mCreatedWithDeviceEXT
condition|)
block|{
comment|// Only delete the device if the Renderer11 owns it
comment|// Otherwise we should keep it around in case we try to reinitialize the renderer later
name|SafeDelete
argument_list|(
name|mEGLDevice
argument_list|)
expr_stmt|;
block|}
name|SafeRelease
argument_list|(
name|mDxgiFactory
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mDxgiAdapter
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ANGLE_ENABLE_D3D11_1
argument_list|)
name|SafeRelease
argument_list|(
name|mDeviceContext1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|mDeviceContext
condition|)
block|{
name|mDeviceContext
operator|->
name|ClearState
argument_list|()
expr_stmt|;
name|mDeviceContext
operator|->
name|Flush
argument_list|()
expr_stmt|;
name|SafeRelease
argument_list|(
name|mDeviceContext
argument_list|)
expr_stmt|;
block|}
name|SafeRelease
argument_list|(
name|mDevice
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ANGLE_MINGW32_COMPAT
argument_list|)
name|SafeRelease
argument_list|(
name|mDebug
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|mD3d11Module
condition|)
block|{
name|FreeLibrary
argument_list|(
name|mD3d11Module
argument_list|)
expr_stmt|;
name|mD3d11Module
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mDxgiModule
condition|)
block|{
name|FreeLibrary
argument_list|(
name|mDxgiModule
argument_list|)
expr_stmt|;
name|mDxgiModule
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mDCompModule
condition|)
block|{
name|FreeLibrary
argument_list|(
name|mDCompModule
argument_list|)
expr_stmt|;
name|mDCompModule
operator|=
name|NULL
expr_stmt|;
block|}
name|mCompiler
operator|.
name|release
argument_list|()
expr_stmt|;
name|mSupportsShareHandles
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
DECL|function|resetDevice
name|bool
name|Renderer11
operator|::
name|resetDevice
parameter_list|()
block|{
comment|// recreate everything
name|release
argument_list|()
expr_stmt|;
name|egl
operator|::
name|Error
name|result
init|=
name|initialize
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
operator|.
name|isError
argument_list|()
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not reinitialize D3D11 device: %08X"
argument_list|,
name|result
operator|.
name|getCode
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|mDeviceLost
operator|=
literal|false
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|getRendererDescription
name|std
operator|::
name|string
name|Renderer11
operator|::
name|getRendererDescription
parameter_list|()
specifier|const
block|{
name|std
operator|::
name|ostringstream
name|rendererString
decl_stmt|;
name|rendererString
operator|<<
name|mDescription
expr_stmt|;
name|rendererString
operator|<<
literal|" Direct3D11"
expr_stmt|;
name|rendererString
operator|<<
literal|" vs_"
operator|<<
name|getMajorShaderModel
argument_list|()
operator|<<
literal|"_"
operator|<<
name|getMinorShaderModel
argument_list|()
operator|<<
name|getShaderModelSuffix
argument_list|()
expr_stmt|;
name|rendererString
operator|<<
literal|" ps_"
operator|<<
name|getMajorShaderModel
argument_list|()
operator|<<
literal|"_"
operator|<<
name|getMinorShaderModel
argument_list|()
operator|<<
name|getShaderModelSuffix
argument_list|()
expr_stmt|;
return|return
name|rendererString
operator|.
name|str
argument_list|()
return|;
block|}
DECL|function|getAdapterIdentifier
name|DeviceIdentifier
name|Renderer11
operator|::
name|getAdapterIdentifier
parameter_list|()
specifier|const
block|{
comment|// Don't use the AdapterLuid here, since that doesn't persist across reboot.
name|DeviceIdentifier
name|deviceIdentifier
init|=
block|{
literal|0
block|}
decl_stmt|;
name|deviceIdentifier
operator|.
name|VendorId
operator|=
name|mAdapterDescription
operator|.
name|VendorId
expr_stmt|;
name|deviceIdentifier
operator|.
name|DeviceId
operator|=
name|mAdapterDescription
operator|.
name|DeviceId
expr_stmt|;
name|deviceIdentifier
operator|.
name|SubSysId
operator|=
name|mAdapterDescription
operator|.
name|SubSysId
expr_stmt|;
name|deviceIdentifier
operator|.
name|Revision
operator|=
name|mAdapterDescription
operator|.
name|Revision
expr_stmt|;
name|deviceIdentifier
operator|.
name|FeatureLevel
operator|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|mRenderer11DeviceCaps
operator|.
name|featureLevel
argument_list|)
expr_stmt|;
return|return
name|deviceIdentifier
return|;
block|}
DECL|function|getReservedVertexUniformVectors
name|unsigned
name|int
name|Renderer11
operator|::
name|getReservedVertexUniformVectors
parameter_list|()
specifier|const
block|{
comment|// Driver uniforms are stored in a separate constant buffer
return|return
name|d3d11_gl
operator|::
name|GetReservedVertexUniformVectors
argument_list|(
name|mRenderer11DeviceCaps
operator|.
name|featureLevel
argument_list|)
return|;
block|}
DECL|function|getReservedFragmentUniformVectors
name|unsigned
name|int
name|Renderer11
operator|::
name|getReservedFragmentUniformVectors
parameter_list|()
specifier|const
block|{
comment|// Driver uniforms are stored in a separate constant buffer
return|return
name|d3d11_gl
operator|::
name|GetReservedFragmentUniformVectors
argument_list|(
name|mRenderer11DeviceCaps
operator|.
name|featureLevel
argument_list|)
return|;
block|}
DECL|function|getReservedVertexUniformBuffers
name|unsigned
name|int
name|Renderer11
operator|::
name|getReservedVertexUniformBuffers
parameter_list|()
specifier|const
block|{
comment|// we reserve one buffer for the application uniforms, and one for driver uniforms
return|return
literal|2
return|;
block|}
DECL|function|getReservedFragmentUniformBuffers
name|unsigned
name|int
name|Renderer11
operator|::
name|getReservedFragmentUniformBuffers
parameter_list|()
specifier|const
block|{
comment|// we reserve one buffer for the application uniforms, and one for driver uniforms
return|return
literal|2
return|;
block|}
DECL|function|getDeviceType
name|d3d11
operator|::
name|ANGLED3D11DeviceType
name|Renderer11
operator|::
name|getDeviceType
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|mCreatedWithDeviceEXT
condition|)
block|{
return|return
name|d3d11
operator|::
name|GetDeviceType
argument_list|(
name|mDevice
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|mRequestedDriverType
operator|==
name|D3D_DRIVER_TYPE_SOFTWARE
operator|)
operator|||
operator|(
name|mRequestedDriverType
operator|==
name|D3D_DRIVER_TYPE_REFERENCE
operator|)
operator|||
operator|(
name|mRequestedDriverType
operator|==
name|D3D_DRIVER_TYPE_NULL
operator|)
condition|)
block|{
return|return
name|d3d11
operator|::
name|ANGLE_D3D11_DEVICE_TYPE_SOFTWARE_REF_OR_NULL
return|;
block|}
if|if
condition|(
name|mRequestedDriverType
operator|==
name|D3D_DRIVER_TYPE_WARP
condition|)
block|{
return|return
name|d3d11
operator|::
name|ANGLE_D3D11_DEVICE_TYPE_WARP
return|;
block|}
return|return
name|d3d11
operator|::
name|ANGLE_D3D11_DEVICE_TYPE_HARDWARE
return|;
block|}
DECL|function|getShareHandleSupport
name|bool
name|Renderer11
operator|::
name|getShareHandleSupport
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|mSupportsShareHandles
operator|.
name|valid
argument_list|()
condition|)
block|{
return|return
name|mSupportsShareHandles
operator|.
name|value
argument_list|()
return|;
block|}
comment|// We only currently support share handles with BGRA surfaces, because
comment|// chrome needs BGRA. Once chrome fixes this, we should always support them.
if|if
condition|(
operator|!
name|getRendererExtensions
argument_list|()
operator|.
name|textureFormatBGRA8888
condition|)
block|{
name|mSupportsShareHandles
operator|=
literal|false
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// PIX doesn't seem to support using share handles, so disable them.
if|if
condition|(
name|gl
operator|::
name|DebugAnnotationsActive
argument_list|()
condition|)
block|{
name|mSupportsShareHandles
operator|=
literal|false
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Also disable share handles on Feature Level 9_3, since it doesn't support share handles on RGBA8 textures/swapchains.
if|if
condition|(
name|mRenderer11DeviceCaps
operator|.
name|featureLevel
operator|<=
name|D3D_FEATURE_LEVEL_9_3
condition|)
block|{
name|mSupportsShareHandles
operator|=
literal|false
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Find out which type of D3D11 device the Renderer11 is using
name|d3d11
operator|::
name|ANGLED3D11DeviceType
name|deviceType
init|=
name|getDeviceType
argument_list|()
decl_stmt|;
if|if
condition|(
name|deviceType
operator|==
name|d3d11
operator|::
name|ANGLE_D3D11_DEVICE_TYPE_UNKNOWN
condition|)
block|{
name|mSupportsShareHandles
operator|=
literal|false
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|deviceType
operator|==
name|d3d11
operator|::
name|ANGLE_D3D11_DEVICE_TYPE_SOFTWARE_REF_OR_NULL
condition|)
block|{
comment|// Software/Reference/NULL devices don't support share handles
name|mSupportsShareHandles
operator|=
literal|false
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|deviceType
operator|==
name|d3d11
operator|::
name|ANGLE_D3D11_DEVICE_TYPE_WARP
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ANGLE_ENABLE_WINDOWS_STORE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
if|if
condition|(
operator|!
name|IsWindows8OrGreater
argument_list|()
condition|)
block|{
comment|// WARP on Windows 7 doesn't support shared handles
name|mSupportsShareHandles
operator|=
literal|false
expr_stmt|;
return|return
literal|false
return|;
block|}
endif|#
directive|endif
comment|// ANGLE_ENABLE_WINDOWS_STORE
comment|// WARP on Windows 8.0+ supports shared handles when shared with another WARP device
comment|// TODO: allow applications to query for HARDWARE or WARP-specific share handles,
comment|//       to prevent them trying to use a WARP share handle with an a HW device (or
comment|//       vice-versa)
comment|//       e.g. by creating EGL_D3D11_[HARDWARE/WARP]_DEVICE_SHARE_HANDLE_ANGLE
name|mSupportsShareHandles
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
name|ASSERT
argument_list|(
name|mCreatedWithDeviceEXT
operator|||
name|mRequestedDriverType
operator|==
name|D3D_DRIVER_TYPE_HARDWARE
argument_list|)
expr_stmt|;
name|mSupportsShareHandles
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|getMajorShaderModel
name|int
name|Renderer11
operator|::
name|getMajorShaderModel
parameter_list|()
specifier|const
block|{
switch|switch
condition|(
name|mRenderer11DeviceCaps
operator|.
name|featureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_SHADER_MAJOR_VERSION
return|;
comment|// 5
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
return|return
name|D3D10_1_SHADER_MAJOR_VERSION
return|;
comment|// 4
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_SHADER_MAJOR_VERSION
return|;
comment|// 4
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
return|return
name|D3D10_SHADER_MAJOR_VERSION
return|;
comment|// 4
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|getMinorShaderModel
name|int
name|Renderer11
operator|::
name|getMinorShaderModel
parameter_list|()
specifier|const
block|{
switch|switch
condition|(
name|mRenderer11DeviceCaps
operator|.
name|featureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_SHADER_MINOR_VERSION
return|;
comment|// 0
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
return|return
name|D3D10_1_SHADER_MINOR_VERSION
return|;
comment|// 1
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_SHADER_MINOR_VERSION
return|;
comment|// 0
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
return|return
name|D3D10_SHADER_MINOR_VERSION
return|;
comment|// 0
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|getShaderModelSuffix
name|std
operator|::
name|string
name|Renderer11
operator|::
name|getShaderModelSuffix
parameter_list|()
specifier|const
block|{
switch|switch
condition|(
name|mRenderer11DeviceCaps
operator|.
name|featureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
literal|""
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
return|return
literal|""
return|;
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
literal|""
return|;
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
return|return
literal|"_level_9_3"
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|""
return|;
block|}
block|}
DECL|function|getWorkarounds
specifier|const
name|WorkaroundsD3D
modifier|&
name|RendererD3D
operator|::
name|getWorkarounds
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|mWorkaroundsInitialized
condition|)
block|{
name|mWorkarounds
operator|=
name|generateWorkarounds
argument_list|()
expr_stmt|;
name|mWorkaroundsInitialized
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|mWorkarounds
return|;
block|}
DECL|function|copyImage2D
name|gl
operator|::
name|Error
name|Renderer11
operator|::
name|copyImage2D
parameter_list|(
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|sourceRect
parameter_list|,
name|GLenum
name|destFormat
parameter_list|,
specifier|const
name|gl
operator|::
name|Offset
modifier|&
name|destOffset
parameter_list|,
name|TextureStorage
modifier|*
name|storage
parameter_list|,
name|GLint
name|level
parameter_list|)
block|{
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|colorbuffer
init|=
name|framebuffer
operator|->
name|getReadColorbuffer
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|colorbuffer
argument_list|)
expr_stmt|;
name|RenderTarget11
modifier|*
name|sourceRenderTarget
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|colorbuffer
operator|->
name|getRenderTarget
argument_list|(
operator|&
name|sourceRenderTarget
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|sourceRenderTarget
argument_list|)
expr_stmt|;
name|ID3D11ShaderResourceView
modifier|*
name|source
init|=
name|sourceRenderTarget
operator|->
name|getShaderResourceView
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|TextureStorage11_2D
modifier|*
name|storage11
init|=
name|GetAs
argument_list|<
name|TextureStorage11_2D
argument_list|>
argument_list|(
name|storage
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|storage11
argument_list|)
expr_stmt|;
name|gl
operator|::
name|ImageIndex
name|index
init|=
name|gl
operator|::
name|ImageIndex
operator|::
name|Make2D
argument_list|(
name|level
argument_list|)
decl_stmt|;
name|RenderTargetD3D
modifier|*
name|destRenderTarget
init|=
name|NULL
decl_stmt|;
name|error
operator|=
name|storage11
operator|->
name|getRenderTarget
argument_list|(
name|index
argument_list|,
operator|&
name|destRenderTarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|destRenderTarget
argument_list|)
expr_stmt|;
name|ID3D11RenderTargetView
modifier|*
name|dest
init|=
name|GetAs
argument_list|<
name|RenderTarget11
argument_list|>
argument_list|(
name|destRenderTarget
argument_list|)
operator|->
name|getRenderTargetView
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|gl
operator|::
name|Box
name|sourceArea
argument_list|(
name|sourceRect
operator|.
name|x
argument_list|,
name|sourceRect
operator|.
name|y
argument_list|,
literal|0
argument_list|,
name|sourceRect
operator|.
name|width
argument_list|,
name|sourceRect
operator|.
name|height
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Extents
name|sourceSize
argument_list|(
name|sourceRenderTarget
operator|->
name|getWidth
argument_list|()
argument_list|,
name|sourceRenderTarget
operator|->
name|getHeight
argument_list|()
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|invertSource
init|=
name|UsePresentPathFast
argument_list|(
name|this
argument_list|,
name|colorbuffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|invertSource
condition|)
block|{
name|sourceArea
operator|.
name|y
operator|=
name|sourceSize
operator|.
name|height
operator|-
name|sourceRect
operator|.
name|y
expr_stmt|;
name|sourceArea
operator|.
name|height
operator|=
operator|-
name|sourceArea
operator|.
name|height
expr_stmt|;
block|}
name|gl
operator|::
name|Box
name|destArea
argument_list|(
name|destOffset
operator|.
name|x
argument_list|,
name|destOffset
operator|.
name|y
argument_list|,
literal|0
argument_list|,
name|sourceRect
operator|.
name|width
argument_list|,
name|sourceRect
operator|.
name|height
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Extents
name|destSize
argument_list|(
name|destRenderTarget
operator|->
name|getWidth
argument_list|()
argument_list|,
name|destRenderTarget
operator|->
name|getHeight
argument_list|()
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|// Use nearest filtering because source and destination are the same size for the direct
comment|// copy
name|error
operator|=
name|mBlit
operator|->
name|copyTexture
argument_list|(
name|source
argument_list|,
name|sourceArea
argument_list|,
name|sourceSize
argument_list|,
name|dest
argument_list|,
name|destArea
argument_list|,
name|destSize
argument_list|,
name|NULL
argument_list|,
name|destFormat
argument_list|,
name|GL_NEAREST
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|storage11
operator|->
name|invalidateSwizzleCacheLevel
argument_list|(
name|level
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|copyImageCube
name|gl
operator|::
name|Error
name|Renderer11
operator|::
name|copyImageCube
parameter_list|(
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|sourceRect
parameter_list|,
name|GLenum
name|destFormat
parameter_list|,
specifier|const
name|gl
operator|::
name|Offset
modifier|&
name|destOffset
parameter_list|,
name|TextureStorage
modifier|*
name|storage
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|)
block|{
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|colorbuffer
init|=
name|framebuffer
operator|->
name|getReadColorbuffer
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|colorbuffer
argument_list|)
expr_stmt|;
name|RenderTarget11
modifier|*
name|sourceRenderTarget
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|colorbuffer
operator|->
name|getRenderTarget
argument_list|(
operator|&
name|sourceRenderTarget
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|sourceRenderTarget
argument_list|)
expr_stmt|;
name|ID3D11ShaderResourceView
modifier|*
name|source
init|=
name|sourceRenderTarget
operator|->
name|getShaderResourceView
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|TextureStorage11_Cube
modifier|*
name|storage11
init|=
name|GetAs
argument_list|<
name|TextureStorage11_Cube
argument_list|>
argument_list|(
name|storage
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|storage11
argument_list|)
expr_stmt|;
name|gl
operator|::
name|ImageIndex
name|index
init|=
name|gl
operator|::
name|ImageIndex
operator|::
name|MakeCube
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
decl_stmt|;
name|RenderTargetD3D
modifier|*
name|destRenderTarget
init|=
name|NULL
decl_stmt|;
name|error
operator|=
name|storage11
operator|->
name|getRenderTarget
argument_list|(
name|index
argument_list|,
operator|&
name|destRenderTarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|destRenderTarget
argument_list|)
expr_stmt|;
name|ID3D11RenderTargetView
modifier|*
name|dest
init|=
name|GetAs
argument_list|<
name|RenderTarget11
argument_list|>
argument_list|(
name|destRenderTarget
argument_list|)
operator|->
name|getRenderTargetView
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|gl
operator|::
name|Box
name|sourceArea
argument_list|(
name|sourceRect
operator|.
name|x
argument_list|,
name|sourceRect
operator|.
name|y
argument_list|,
literal|0
argument_list|,
name|sourceRect
operator|.
name|width
argument_list|,
name|sourceRect
operator|.
name|height
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Extents
name|sourceSize
argument_list|(
name|sourceRenderTarget
operator|->
name|getWidth
argument_list|()
argument_list|,
name|sourceRenderTarget
operator|->
name|getHeight
argument_list|()
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|invertSource
init|=
name|UsePresentPathFast
argument_list|(
name|this
argument_list|,
name|colorbuffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|invertSource
condition|)
block|{
name|sourceArea
operator|.
name|y
operator|=
name|sourceSize
operator|.
name|height
operator|-
name|sourceRect
operator|.
name|y
expr_stmt|;
name|sourceArea
operator|.
name|height
operator|=
operator|-
name|sourceArea
operator|.
name|height
expr_stmt|;
block|}
name|gl
operator|::
name|Box
name|destArea
argument_list|(
name|destOffset
operator|.
name|x
argument_list|,
name|destOffset
operator|.
name|y
argument_list|,
literal|0
argument_list|,
name|sourceRect
operator|.
name|width
argument_list|,
name|sourceRect
operator|.
name|height
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Extents
name|destSize
argument_list|(
name|destRenderTarget
operator|->
name|getWidth
argument_list|()
argument_list|,
name|destRenderTarget
operator|->
name|getHeight
argument_list|()
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|// Use nearest filtering because source and destination are the same size for the direct
comment|// copy
name|error
operator|=
name|mBlit
operator|->
name|copyTexture
argument_list|(
name|source
argument_list|,
name|sourceArea
argument_list|,
name|sourceSize
argument_list|,
name|dest
argument_list|,
name|destArea
argument_list|,
name|destSize
argument_list|,
name|NULL
argument_list|,
name|destFormat
argument_list|,
name|GL_NEAREST
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|storage11
operator|->
name|invalidateSwizzleCacheLevel
argument_list|(
name|level
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|copyImage3D
name|gl
operator|::
name|Error
name|Renderer11
operator|::
name|copyImage3D
parameter_list|(
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|sourceRect
parameter_list|,
name|GLenum
name|destFormat
parameter_list|,
specifier|const
name|gl
operator|::
name|Offset
modifier|&
name|destOffset
parameter_list|,
name|TextureStorage
modifier|*
name|storage
parameter_list|,
name|GLint
name|level
parameter_list|)
block|{
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|colorbuffer
init|=
name|framebuffer
operator|->
name|getReadColorbuffer
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|colorbuffer
argument_list|)
expr_stmt|;
name|RenderTarget11
modifier|*
name|sourceRenderTarget
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|colorbuffer
operator|->
name|getRenderTarget
argument_list|(
operator|&
name|sourceRenderTarget
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|sourceRenderTarget
argument_list|)
expr_stmt|;
name|ID3D11ShaderResourceView
modifier|*
name|source
init|=
name|sourceRenderTarget
operator|->
name|getShaderResourceView
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|TextureStorage11_3D
modifier|*
name|storage11
init|=
name|GetAs
argument_list|<
name|TextureStorage11_3D
argument_list|>
argument_list|(
name|storage
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|storage11
argument_list|)
expr_stmt|;
name|gl
operator|::
name|ImageIndex
name|index
init|=
name|gl
operator|::
name|ImageIndex
operator|::
name|Make3D
argument_list|(
name|level
argument_list|,
name|destOffset
operator|.
name|z
argument_list|)
decl_stmt|;
name|RenderTargetD3D
modifier|*
name|destRenderTarget
init|=
name|NULL
decl_stmt|;
name|error
operator|=
name|storage11
operator|->
name|getRenderTarget
argument_list|(
name|index
argument_list|,
operator|&
name|destRenderTarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|destRenderTarget
argument_list|)
expr_stmt|;
name|ID3D11RenderTargetView
modifier|*
name|dest
init|=
name|GetAs
argument_list|<
name|RenderTarget11
argument_list|>
argument_list|(
name|destRenderTarget
argument_list|)
operator|->
name|getRenderTargetView
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|gl
operator|::
name|Box
name|sourceArea
argument_list|(
name|sourceRect
operator|.
name|x
argument_list|,
name|sourceRect
operator|.
name|y
argument_list|,
literal|0
argument_list|,
name|sourceRect
operator|.
name|width
argument_list|,
name|sourceRect
operator|.
name|height
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Extents
name|sourceSize
argument_list|(
name|sourceRenderTarget
operator|->
name|getWidth
argument_list|()
argument_list|,
name|sourceRenderTarget
operator|->
name|getHeight
argument_list|()
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Box
name|destArea
argument_list|(
name|destOffset
operator|.
name|x
argument_list|,
name|destOffset
operator|.
name|y
argument_list|,
literal|0
argument_list|,
name|sourceRect
operator|.
name|width
argument_list|,
name|sourceRect
operator|.
name|height
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Extents
name|destSize
argument_list|(
name|destRenderTarget
operator|->
name|getWidth
argument_list|()
argument_list|,
name|destRenderTarget
operator|->
name|getHeight
argument_list|()
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|// Use nearest filtering because source and destination are the same size for the direct
comment|// copy
name|error
operator|=
name|mBlit
operator|->
name|copyTexture
argument_list|(
name|source
argument_list|,
name|sourceArea
argument_list|,
name|sourceSize
argument_list|,
name|dest
argument_list|,
name|destArea
argument_list|,
name|destSize
argument_list|,
name|NULL
argument_list|,
name|destFormat
argument_list|,
name|GL_NEAREST
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|storage11
operator|->
name|invalidateSwizzleCacheLevel
argument_list|(
name|level
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|copyImage2DArray
name|gl
operator|::
name|Error
name|Renderer11
operator|::
name|copyImage2DArray
parameter_list|(
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|sourceRect
parameter_list|,
name|GLenum
name|destFormat
parameter_list|,
specifier|const
name|gl
operator|::
name|Offset
modifier|&
name|destOffset
parameter_list|,
name|TextureStorage
modifier|*
name|storage
parameter_list|,
name|GLint
name|level
parameter_list|)
block|{
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|colorbuffer
init|=
name|framebuffer
operator|->
name|getReadColorbuffer
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|colorbuffer
argument_list|)
expr_stmt|;
name|RenderTarget11
modifier|*
name|sourceRenderTarget
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|colorbuffer
operator|->
name|getRenderTarget
argument_list|(
operator|&
name|sourceRenderTarget
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|sourceRenderTarget
argument_list|)
expr_stmt|;
name|ID3D11ShaderResourceView
modifier|*
name|source
init|=
name|sourceRenderTarget
operator|->
name|getShaderResourceView
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|TextureStorage11_2DArray
modifier|*
name|storage11
init|=
name|GetAs
argument_list|<
name|TextureStorage11_2DArray
argument_list|>
argument_list|(
name|storage
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|storage11
argument_list|)
expr_stmt|;
name|gl
operator|::
name|ImageIndex
name|index
init|=
name|gl
operator|::
name|ImageIndex
operator|::
name|Make2DArray
argument_list|(
name|level
argument_list|,
name|destOffset
operator|.
name|z
argument_list|)
decl_stmt|;
name|RenderTargetD3D
modifier|*
name|destRenderTarget
init|=
name|NULL
decl_stmt|;
name|error
operator|=
name|storage11
operator|->
name|getRenderTarget
argument_list|(
name|index
argument_list|,
operator|&
name|destRenderTarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|destRenderTarget
argument_list|)
expr_stmt|;
name|ID3D11RenderTargetView
modifier|*
name|dest
init|=
name|GetAs
argument_list|<
name|RenderTarget11
argument_list|>
argument_list|(
name|destRenderTarget
argument_list|)
operator|->
name|getRenderTargetView
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|gl
operator|::
name|Box
name|sourceArea
argument_list|(
name|sourceRect
operator|.
name|x
argument_list|,
name|sourceRect
operator|.
name|y
argument_list|,
literal|0
argument_list|,
name|sourceRect
operator|.
name|width
argument_list|,
name|sourceRect
operator|.
name|height
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Extents
name|sourceSize
argument_list|(
name|sourceRenderTarget
operator|->
name|getWidth
argument_list|()
argument_list|,
name|sourceRenderTarget
operator|->
name|getHeight
argument_list|()
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Box
name|destArea
argument_list|(
name|destOffset
operator|.
name|x
argument_list|,
name|destOffset
operator|.
name|y
argument_list|,
literal|0
argument_list|,
name|sourceRect
operator|.
name|width
argument_list|,
name|sourceRect
operator|.
name|height
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Extents
name|destSize
argument_list|(
name|destRenderTarget
operator|->
name|getWidth
argument_list|()
argument_list|,
name|destRenderTarget
operator|->
name|getHeight
argument_list|()
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|// Use nearest filtering because source and destination are the same size for the direct
comment|// copy
name|error
operator|=
name|mBlit
operator|->
name|copyTexture
argument_list|(
name|source
argument_list|,
name|sourceArea
argument_list|,
name|sourceSize
argument_list|,
name|dest
argument_list|,
name|destArea
argument_list|,
name|destSize
argument_list|,
name|NULL
argument_list|,
name|destFormat
argument_list|,
name|GL_NEAREST
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|storage11
operator|->
name|invalidateSwizzleCacheLevel
argument_list|(
name|level
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|unapplyRenderTargets
name|void
name|Renderer11
operator|::
name|unapplyRenderTargets
parameter_list|()
block|{
name|setOneTimeRenderTarget
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|// When finished with this rendertarget, markAllStateDirty must be called.
DECL|function|setOneTimeRenderTarget
name|void
name|Renderer11
operator|::
name|setOneTimeRenderTarget
parameter_list|(
name|ID3D11RenderTargetView
modifier|*
name|renderTargetView
parameter_list|)
block|{
name|ID3D11RenderTargetView
modifier|*
name|rtvArray
index|[
name|gl
operator|::
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
index|]
init|=
block|{
name|NULL
block|}
decl_stmt|;
name|rtvArray
index|[
literal|0
index|]
operator|=
name|renderTargetView
expr_stmt|;
name|mDeviceContext
operator|->
name|OMSetRenderTargets
argument_list|(
name|getRendererCaps
argument_list|()
operator|.
name|maxDrawBuffers
argument_list|,
name|rtvArray
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|// Do not preserve the serial for this one-time-use render target
for|for
control|(
name|size_t
name|rtIndex
init|=
literal|0
init|;
name|rtIndex
operator|<
name|ArraySize
argument_list|(
name|mAppliedRTVs
argument_list|)
condition|;
name|rtIndex
operator|++
control|)
block|{
name|mAppliedRTVs
index|[
name|rtIndex
index|]
operator|=
name|angle
operator|::
name|DirtyPointer
expr_stmt|;
block|}
name|mAppliedDSV
operator|=
name|angle
operator|::
name|DirtyPointer
expr_stmt|;
block|}
DECL|function|createRenderTarget
name|gl
operator|::
name|Error
name|Renderer11
operator|::
name|createRenderTarget
parameter_list|(
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLsizei
name|samples
parameter_list|,
name|RenderTargetD3D
modifier|*
modifier|*
name|outRT
parameter_list|)
block|{
specifier|const
name|d3d11
operator|::
name|TextureFormat
modifier|&
name|formatInfo
init|=
name|d3d11
operator|::
name|GetTextureFormatInfo
argument_list|(
name|format
argument_list|,
name|mRenderer11DeviceCaps
argument_list|)
decl_stmt|;
specifier|const
name|gl
operator|::
name|TextureCaps
modifier|&
name|textureCaps
init|=
name|getRendererTextureCaps
argument_list|()
operator|.
name|get
argument_list|(
name|format
argument_list|)
decl_stmt|;
name|GLuint
name|supportedSamples
init|=
name|textureCaps
operator|.
name|getNearestSamples
argument_list|(
name|samples
argument_list|)
decl_stmt|;
if|if
condition|(
name|width
operator|>
literal|0
operator|&&
name|height
operator|>
literal|0
condition|)
block|{
comment|// Create texture resource
name|D3D11_TEXTURE2D_DESC
name|desc
decl_stmt|;
name|desc
operator|.
name|Width
operator|=
name|width
expr_stmt|;
name|desc
operator|.
name|Height
operator|=
name|height
expr_stmt|;
name|desc
operator|.
name|MipLevels
operator|=
literal|1
expr_stmt|;
name|desc
operator|.
name|ArraySize
operator|=
literal|1
expr_stmt|;
name|desc
operator|.
name|Format
operator|=
name|formatInfo
operator|.
name|texFormat
expr_stmt|;
name|desc
operator|.
name|SampleDesc
operator|.
name|Count
operator|=
operator|(
name|supportedSamples
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
name|supportedSamples
expr_stmt|;
name|desc
operator|.
name|SampleDesc
operator|.
name|Quality
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|Usage
operator|=
name|D3D11_USAGE_DEFAULT
expr_stmt|;
name|desc
operator|.
name|CPUAccessFlags
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
comment|// If a rendertarget or depthstencil format exists for this texture format,
comment|// we'll flag it to allow binding that way. Shader resource views are a little
comment|// more complicated.
name|bool
name|bindRTV
init|=
literal|false
decl_stmt|,
name|bindDSV
init|=
literal|false
decl_stmt|,
name|bindSRV
init|=
literal|false
decl_stmt|;
name|bindRTV
operator|=
operator|(
name|formatInfo
operator|.
name|rtvFormat
operator|!=
name|DXGI_FORMAT_UNKNOWN
operator|)
expr_stmt|;
name|bindDSV
operator|=
operator|(
name|formatInfo
operator|.
name|dsvFormat
operator|!=
name|DXGI_FORMAT_UNKNOWN
operator|)
expr_stmt|;
if|if
condition|(
name|formatInfo
operator|.
name|srvFormat
operator|!=
name|DXGI_FORMAT_UNKNOWN
condition|)
block|{
comment|// Multisample targets flagged for binding as depth stencil cannot also be
comment|// flagged for binding as SRV, so make certain not to add the SRV flag for
comment|// these targets.
name|bindSRV
operator|=
operator|!
operator|(
name|formatInfo
operator|.
name|dsvFormat
operator|!=
name|DXGI_FORMAT_UNKNOWN
operator|&&
name|desc
operator|.
name|SampleDesc
operator|.
name|Count
operator|>
literal|1
operator|)
expr_stmt|;
block|}
name|desc
operator|.
name|BindFlags
operator|=
operator|(
name|bindRTV
condition|?
name|D3D11_BIND_RENDER_TARGET
else|:
literal|0
operator|)
operator||
operator|(
name|bindDSV
condition|?
name|D3D11_BIND_DEPTH_STENCIL
else|:
literal|0
operator|)
operator||
operator|(
name|bindSRV
condition|?
name|D3D11_BIND_SHADER_RESOURCE
else|:
literal|0
operator|)
expr_stmt|;
comment|// The format must be either an RTV or a DSV
name|ASSERT
argument_list|(
name|bindRTV
operator|!=
name|bindDSV
argument_list|)
expr_stmt|;
name|ID3D11Texture2D
modifier|*
name|texture
init|=
name|NULL
decl_stmt|;
name|HRESULT
name|result
init|=
name|mDevice
operator|->
name|CreateTexture2D
argument_list|(
operator|&
name|desc
argument_list|,
name|NULL
argument_list|,
operator|&
name|texture
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|result
operator|==
name|E_OUTOFMEMORY
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create render target texture, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
name|ID3D11ShaderResourceView
modifier|*
name|srv
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|bindSRV
condition|)
block|{
name|D3D11_SHADER_RESOURCE_VIEW_DESC
name|srvDesc
decl_stmt|;
name|srvDesc
operator|.
name|Format
operator|=
name|formatInfo
operator|.
name|srvFormat
expr_stmt|;
name|srvDesc
operator|.
name|ViewDimension
operator|=
operator|(
name|supportedSamples
operator|==
literal|0
operator|)
condition|?
name|D3D11_SRV_DIMENSION_TEXTURE2D
else|:
name|D3D11_SRV_DIMENSION_TEXTURE2DMS
expr_stmt|;
name|srvDesc
operator|.
name|Texture2D
operator|.
name|MostDetailedMip
operator|=
literal|0
expr_stmt|;
name|srvDesc
operator|.
name|Texture2D
operator|.
name|MipLevels
operator|=
literal|1
expr_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|CreateShaderResourceView
argument_list|(
name|texture
argument_list|,
operator|&
name|srvDesc
argument_list|,
operator|&
name|srv
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|result
operator|==
name|E_OUTOFMEMORY
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|texture
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create render target shader resource view, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|bindDSV
condition|)
block|{
name|D3D11_DEPTH_STENCIL_VIEW_DESC
name|dsvDesc
decl_stmt|;
name|dsvDesc
operator|.
name|Format
operator|=
name|formatInfo
operator|.
name|dsvFormat
expr_stmt|;
name|dsvDesc
operator|.
name|ViewDimension
operator|=
operator|(
name|supportedSamples
operator|==
literal|0
operator|)
condition|?
name|D3D11_DSV_DIMENSION_TEXTURE2D
else|:
name|D3D11_DSV_DIMENSION_TEXTURE2DMS
expr_stmt|;
name|dsvDesc
operator|.
name|Texture2D
operator|.
name|MipSlice
operator|=
literal|0
expr_stmt|;
name|dsvDesc
operator|.
name|Flags
operator|=
literal|0
expr_stmt|;
name|ID3D11DepthStencilView
modifier|*
name|dsv
init|=
name|NULL
decl_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|CreateDepthStencilView
argument_list|(
name|texture
argument_list|,
operator|&
name|dsvDesc
argument_list|,
operator|&
name|dsv
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|result
operator|==
name|E_OUTOFMEMORY
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|texture
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|srv
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create render target depth stencil view, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
operator|*
name|outRT
operator|=
operator|new
name|TextureRenderTarget11
argument_list|(
name|dsv
argument_list|,
name|texture
argument_list|,
name|srv
argument_list|,
name|format
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|1
argument_list|,
name|supportedSamples
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|dsv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bindRTV
condition|)
block|{
name|D3D11_RENDER_TARGET_VIEW_DESC
name|rtvDesc
decl_stmt|;
name|rtvDesc
operator|.
name|Format
operator|=
name|formatInfo
operator|.
name|rtvFormat
expr_stmt|;
name|rtvDesc
operator|.
name|ViewDimension
operator|=
operator|(
name|supportedSamples
operator|==
literal|0
operator|)
condition|?
name|D3D11_RTV_DIMENSION_TEXTURE2D
else|:
name|D3D11_RTV_DIMENSION_TEXTURE2DMS
expr_stmt|;
name|rtvDesc
operator|.
name|Texture2D
operator|.
name|MipSlice
operator|=
literal|0
expr_stmt|;
name|ID3D11RenderTargetView
modifier|*
name|rtv
init|=
name|NULL
decl_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|CreateRenderTargetView
argument_list|(
name|texture
argument_list|,
operator|&
name|rtvDesc
argument_list|,
operator|&
name|rtv
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|result
operator|==
name|E_OUTOFMEMORY
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|texture
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|srv
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create render target render target view, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
if|if
condition|(
name|formatInfo
operator|.
name|dataInitializerFunction
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|float
name|clearValues
index|[
literal|4
index|]
init|=
block|{
literal|0.0f
block|,
literal|0.0f
block|,
literal|0.0f
block|,
literal|1.0f
block|}
decl_stmt|;
name|mDeviceContext
operator|->
name|ClearRenderTargetView
argument_list|(
name|rtv
argument_list|,
name|clearValues
argument_list|)
expr_stmt|;
block|}
operator|*
name|outRT
operator|=
operator|new
name|TextureRenderTarget11
argument_list|(
name|rtv
argument_list|,
name|texture
argument_list|,
name|srv
argument_list|,
name|format
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|1
argument_list|,
name|supportedSamples
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|rtv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
name|SafeRelease
argument_list|(
name|texture
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|srv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|outRT
operator|=
operator|new
name|TextureRenderTarget11
argument_list|(
cast|reinterpret_cast
argument_list|<
name|ID3D11RenderTargetView
operator|*
argument_list|>
argument_list|(
name|NULL
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|format
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|1
argument_list|,
name|supportedSamples
argument_list|)
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|createRenderTargetCopy
name|gl
operator|::
name|Error
name|Renderer11
operator|::
name|createRenderTargetCopy
parameter_list|(
name|RenderTargetD3D
modifier|*
name|source
parameter_list|,
name|RenderTargetD3D
modifier|*
modifier|*
name|outRT
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|source
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
name|RenderTargetD3D
modifier|*
name|newRT
init|=
literal|nullptr
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|createRenderTarget
argument_list|(
name|source
operator|->
name|getWidth
argument_list|()
argument_list|,
name|source
operator|->
name|getHeight
argument_list|()
argument_list|,
name|source
operator|->
name|getInternalFormat
argument_list|()
argument_list|,
name|source
operator|->
name|getSamples
argument_list|()
argument_list|,
operator|&
name|newRT
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|RenderTarget11
modifier|*
name|source11
init|=
name|GetAs
argument_list|<
name|RenderTarget11
argument_list|>
argument_list|(
name|source
argument_list|)
decl_stmt|;
name|RenderTarget11
modifier|*
name|dest11
init|=
name|GetAs
argument_list|<
name|RenderTarget11
argument_list|>
argument_list|(
name|newRT
argument_list|)
decl_stmt|;
name|mDeviceContext
operator|->
name|CopySubresourceRegion
argument_list|(
name|dest11
operator|->
name|getTexture
argument_list|()
argument_list|,
name|dest11
operator|->
name|getSubresourceIndex
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|source11
operator|->
name|getTexture
argument_list|()
argument_list|,
name|source11
operator|->
name|getSubresourceIndex
argument_list|()
argument_list|,
literal|nullptr
argument_list|)
expr_stmt|;
operator|*
name|outRT
operator|=
name|newRT
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|createFramebuffer
name|FramebufferImpl
modifier|*
name|Renderer11
operator|::
name|createFramebuffer
parameter_list|(
specifier|const
name|gl
operator|::
name|Framebuffer
operator|::
name|Data
modifier|&
name|data
parameter_list|)
block|{
return|return
operator|new
name|Framebuffer11
argument_list|(
name|data
argument_list|,
name|this
argument_list|)
return|;
block|}
DECL|function|createShader
name|ShaderImpl
modifier|*
name|Renderer11
operator|::
name|createShader
parameter_list|(
specifier|const
name|gl
operator|::
name|Shader
operator|::
name|Data
modifier|&
name|data
parameter_list|)
block|{
return|return
operator|new
name|ShaderD3D
argument_list|(
name|data
argument_list|)
return|;
block|}
DECL|function|createProgram
name|ProgramImpl
modifier|*
name|Renderer11
operator|::
name|createProgram
parameter_list|(
specifier|const
name|gl
operator|::
name|Program
operator|::
name|Data
modifier|&
name|data
parameter_list|)
block|{
return|return
operator|new
name|ProgramD3D
argument_list|(
name|data
argument_list|,
name|this
argument_list|)
return|;
block|}
DECL|function|loadExecutable
name|gl
operator|::
name|Error
name|Renderer11
operator|::
name|loadExecutable
parameter_list|(
specifier|const
name|void
modifier|*
name|function
parameter_list|,
name|size_t
name|length
parameter_list|,
name|ShaderType
name|type
parameter_list|,
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|D3DVarying
argument_list|>
modifier|&
name|streamOutVaryings
parameter_list|,
name|bool
name|separatedOutputBuffers
parameter_list|,
name|ShaderExecutableD3D
modifier|*
modifier|*
name|outExecutable
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SHADER_VERTEX
case|:
block|{
name|ID3D11VertexShader
modifier|*
name|vertexShader
init|=
name|NULL
decl_stmt|;
name|ID3D11GeometryShader
modifier|*
name|streamOutShader
init|=
name|NULL
decl_stmt|;
name|HRESULT
name|result
init|=
name|mDevice
operator|->
name|CreateVertexShader
argument_list|(
name|function
argument_list|,
name|length
argument_list|,
name|NULL
argument_list|,
operator|&
name|vertexShader
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create vertex shader, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|streamOutVaryings
operator|.
name|empty
argument_list|()
condition|)
block|{
name|std
operator|::
name|vector
argument_list|<
name|D3D11_SO_DECLARATION_ENTRY
argument_list|>
name|soDeclaration
decl_stmt|;
name|soDeclaration
operator|.
name|reserve
argument_list|(
name|streamOutVaryings
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|streamOutVarying
range|:
name|streamOutVaryings
control|)
block|{
name|D3D11_SO_DECLARATION_ENTRY
name|entry
init|=
block|{
literal|0
block|}
decl_stmt|;
name|entry
operator|.
name|Stream
operator|=
literal|0
expr_stmt|;
name|entry
operator|.
name|SemanticName
operator|=
name|streamOutVarying
operator|.
name|semanticName
operator|.
name|c_str
argument_list|()
expr_stmt|;
name|entry
operator|.
name|SemanticIndex
operator|=
name|streamOutVarying
operator|.
name|semanticIndex
expr_stmt|;
name|entry
operator|.
name|StartComponent
operator|=
literal|0
expr_stmt|;
name|entry
operator|.
name|ComponentCount
operator|=
cast|static_cast
argument_list|<
name|BYTE
argument_list|>
argument_list|(
name|streamOutVarying
operator|.
name|componentCount
argument_list|)
expr_stmt|;
name|entry
operator|.
name|OutputSlot
operator|=
cast|static_cast
argument_list|<
name|BYTE
argument_list|>
argument_list|(
operator|(
name|separatedOutputBuffers
condition|?
name|streamOutVarying
operator|.
name|outputSlot
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|soDeclaration
operator|.
name|push_back
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|mDevice
operator|->
name|CreateGeometryShaderWithStreamOutput
argument_list|(
name|function
argument_list|,
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|length
argument_list|)
argument_list|,
name|soDeclaration
operator|.
name|data
argument_list|()
argument_list|,
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|soDeclaration
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|streamOutShader
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create steam output shader, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
operator|*
name|outExecutable
operator|=
operator|new
name|ShaderExecutable11
argument_list|(
name|function
argument_list|,
name|length
argument_list|,
name|vertexShader
argument_list|,
name|streamOutShader
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SHADER_PIXEL
case|:
block|{
name|ID3D11PixelShader
modifier|*
name|pixelShader
init|=
name|NULL
decl_stmt|;
name|HRESULT
name|result
init|=
name|mDevice
operator|->
name|CreatePixelShader
argument_list|(
name|function
argument_list|,
name|length
argument_list|,
name|NULL
argument_list|,
operator|&
name|pixelShader
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create pixel shader, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
operator|*
name|outExecutable
operator|=
operator|new
name|ShaderExecutable11
argument_list|(
name|function
argument_list|,
name|length
argument_list|,
name|pixelShader
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SHADER_GEOMETRY
case|:
block|{
name|ID3D11GeometryShader
modifier|*
name|geometryShader
init|=
name|NULL
decl_stmt|;
name|HRESULT
name|result
init|=
name|mDevice
operator|->
name|CreateGeometryShader
argument_list|(
name|function
argument_list|,
name|length
argument_list|,
name|NULL
argument_list|,
operator|&
name|geometryShader
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create geometry shader, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
operator|*
name|outExecutable
operator|=
operator|new
name|ShaderExecutable11
argument_list|(
name|function
argument_list|,
name|length
argument_list|,
name|geometryShader
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|compileToExecutable
name|gl
operator|::
name|Error
name|Renderer11
operator|::
name|compileToExecutable
parameter_list|(
name|gl
operator|::
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|shaderHLSL
parameter_list|,
name|ShaderType
name|type
parameter_list|,
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|D3DVarying
argument_list|>
modifier|&
name|streamOutVaryings
parameter_list|,
name|bool
name|separatedOutputBuffers
parameter_list|,
specifier|const
name|D3DCompilerWorkarounds
modifier|&
name|workarounds
parameter_list|,
name|ShaderExecutableD3D
modifier|*
modifier|*
name|outExectuable
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|profileType
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SHADER_VERTEX
case|:
name|profileType
operator|=
literal|"vs"
expr_stmt|;
break|break;
case|case
name|SHADER_PIXEL
case|:
name|profileType
operator|=
literal|"ps"
expr_stmt|;
break|break;
case|case
name|SHADER_GEOMETRY
case|:
name|profileType
operator|=
literal|"gs"
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|std
operator|::
name|string
name|profile
init|=
name|FormatString
argument_list|(
literal|"%s_%d_%d%s"
argument_list|,
name|profileType
argument_list|,
name|getMajorShaderModel
argument_list|()
argument_list|,
name|getMinorShaderModel
argument_list|()
argument_list|,
name|getShaderModelSuffix
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|)
decl_stmt|;
name|UINT
name|flags
init|=
name|D3DCOMPILE_OPTIMIZATION_LEVEL2
decl_stmt|;
if|if
condition|(
name|gl
operator|::
name|DebugAnnotationsActive
argument_list|()
condition|)
block|{
ifndef|#
directive|ifndef
name|NDEBUG
name|flags
operator|=
name|D3DCOMPILE_SKIP_OPTIMIZATION
expr_stmt|;
endif|#
directive|endif
name|flags
operator||=
name|D3DCOMPILE_DEBUG
expr_stmt|;
block|}
if|if
condition|(
name|workarounds
operator|.
name|enableIEEEStrictness
condition|)
name|flags
operator||=
name|D3DCOMPILE_IEEE_STRICTNESS
expr_stmt|;
comment|// Sometimes D3DCompile will fail with the default compilation flags for complicated shaders when it would otherwise pass with alternative options.
comment|// Try the default flags first and if compilation fails, try some alternatives.
name|std
operator|::
name|vector
argument_list|<
name|CompileConfig
argument_list|>
name|configs
decl_stmt|;
name|configs
operator|.
name|push_back
argument_list|(
name|CompileConfig
argument_list|(
name|flags
argument_list|,
literal|"default"
argument_list|)
argument_list|)
expr_stmt|;
name|configs
operator|.
name|push_back
argument_list|(
name|CompileConfig
argument_list|(
name|flags
operator||
name|D3DCOMPILE_SKIP_VALIDATION
argument_list|,
literal|"skip validation"
argument_list|)
argument_list|)
expr_stmt|;
name|configs
operator|.
name|push_back
argument_list|(
name|CompileConfig
argument_list|(
name|flags
operator||
name|D3DCOMPILE_SKIP_OPTIMIZATION
argument_list|,
literal|"skip optimization"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|getMajorShaderModel
argument_list|()
operator|==
literal|4
operator|&&
name|getShaderModelSuffix
argument_list|()
operator|!=
literal|""
condition|)
block|{
comment|// Some shaders might cause a "blob content mismatch between level9 and d3d10 shader".
comment|// e.g. dEQP-GLES2.functional.shaders.struct.local.loop_nested_struct_array_*.
comment|// Using the [unroll] directive works around this, as does this D3DCompile flag.
name|configs
operator|.
name|push_back
argument_list|(
name|CompileConfig
argument_list|(
name|flags
operator||
name|D3DCOMPILE_AVOID_FLOW_CONTROL
argument_list|,
literal|"avoid flow control"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|D3D_SHADER_MACRO
name|loopMacros
index|[]
init|=
block|{
block|{
literal|"ANGLE_ENABLE_LOOP_FLATTEN"
block|,
literal|"1"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
name|ID3DBlob
modifier|*
name|binary
init|=
name|NULL
decl_stmt|;
name|std
operator|::
name|string
name|debugInfo
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|mCompiler
operator|.
name|compileToBinary
argument_list|(
name|infoLog
argument_list|,
name|shaderHLSL
argument_list|,
name|profile
argument_list|,
name|configs
argument_list|,
name|loopMacros
argument_list|,
operator|&
name|binary
argument_list|,
operator|&
name|debugInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
comment|// It's possible that binary is NULL if the compiler failed in all configurations.  Set the executable to NULL
comment|// and return GL_NO_ERROR to signify that there was a link error but the internal state is still OK.
if|if
condition|(
operator|!
name|binary
condition|)
block|{
operator|*
name|outExectuable
operator|=
name|NULL
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
name|error
operator|=
name|loadExecutable
argument_list|(
name|binary
operator|->
name|GetBufferPointer
argument_list|()
argument_list|,
name|binary
operator|->
name|GetBufferSize
argument_list|()
argument_list|,
name|type
argument_list|,
name|streamOutVaryings
argument_list|,
name|separatedOutputBuffers
argument_list|,
name|outExectuable
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|binary
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
operator|!
name|debugInfo
operator|.
name|empty
argument_list|()
condition|)
block|{
operator|(
operator|*
name|outExectuable
operator|)
operator|->
name|appendDebugInfo
argument_list|(
name|debugInfo
argument_list|)
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|createUniformStorage
name|UniformStorageD3D
modifier|*
name|Renderer11
operator|::
name|createUniformStorage
parameter_list|(
name|size_t
name|storageSize
parameter_list|)
block|{
return|return
operator|new
name|UniformStorage11
argument_list|(
name|this
argument_list|,
name|storageSize
argument_list|)
return|;
block|}
DECL|function|createVertexBuffer
name|VertexBuffer
modifier|*
name|Renderer11
operator|::
name|createVertexBuffer
parameter_list|()
block|{
return|return
operator|new
name|VertexBuffer11
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|function|createIndexBuffer
name|IndexBuffer
modifier|*
name|Renderer11
operator|::
name|createIndexBuffer
parameter_list|()
block|{
return|return
operator|new
name|IndexBuffer11
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|function|createBuffer
name|BufferImpl
modifier|*
name|Renderer11
operator|::
name|createBuffer
parameter_list|()
block|{
name|Buffer11
modifier|*
name|buffer
init|=
operator|new
name|Buffer11
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|mAliveBuffers
operator|.
name|insert
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
DECL|function|createVertexArray
name|VertexArrayImpl
modifier|*
name|Renderer11
operator|::
name|createVertexArray
parameter_list|(
specifier|const
name|gl
operator|::
name|VertexArray
operator|::
name|Data
modifier|&
name|data
parameter_list|)
block|{
return|return
operator|new
name|VertexArray11
argument_list|(
name|data
argument_list|)
return|;
block|}
DECL|function|createQuery
name|QueryImpl
modifier|*
name|Renderer11
operator|::
name|createQuery
parameter_list|(
name|GLenum
name|type
parameter_list|)
block|{
return|return
operator|new
name|Query11
argument_list|(
name|this
argument_list|,
name|type
argument_list|)
return|;
block|}
DECL|function|createFenceNV
name|FenceNVImpl
modifier|*
name|Renderer11
operator|::
name|createFenceNV
parameter_list|()
block|{
return|return
operator|new
name|FenceNV11
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|function|createFenceSync
name|FenceSyncImpl
modifier|*
name|Renderer11
operator|::
name|createFenceSync
parameter_list|()
block|{
return|return
operator|new
name|FenceSync11
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|function|createTransformFeedback
name|TransformFeedbackImpl
modifier|*
name|Renderer11
operator|::
name|createTransformFeedback
parameter_list|()
block|{
return|return
operator|new
name|TransformFeedbackD3D
argument_list|()
return|;
block|}
DECL|function|supportsFastCopyBufferToTexture
name|bool
name|Renderer11
operator|::
name|supportsFastCopyBufferToTexture
parameter_list|(
name|GLenum
name|internalFormat
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|getRendererExtensions
argument_list|()
operator|.
name|pixelBufferObject
argument_list|)
expr_stmt|;
specifier|const
name|gl
operator|::
name|InternalFormat
modifier|&
name|internalFormatInfo
init|=
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|internalFormat
argument_list|)
decl_stmt|;
specifier|const
name|d3d11
operator|::
name|TextureFormat
modifier|&
name|d3d11FormatInfo
init|=
name|d3d11
operator|::
name|GetTextureFormatInfo
argument_list|(
name|internalFormat
argument_list|,
name|mRenderer11DeviceCaps
argument_list|)
decl_stmt|;
specifier|const
name|d3d11
operator|::
name|DXGIFormat
modifier|&
name|dxgiFormatInfo
init|=
name|d3d11
operator|::
name|GetDXGIFormatInfo
argument_list|(
name|d3d11FormatInfo
operator|.
name|texFormat
argument_list|)
decl_stmt|;
comment|// sRGB formats do not work with D3D11 buffer SRVs
if|if
condition|(
name|internalFormatInfo
operator|.
name|colorEncoding
operator|==
name|GL_SRGB
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// We cannot support direct copies to non-color-renderable formats
if|if
condition|(
name|d3d11FormatInfo
operator|.
name|rtvFormat
operator|==
name|DXGI_FORMAT_UNKNOWN
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// We skip all 3-channel formats since sometimes format support is missing
if|if
condition|(
name|internalFormatInfo
operator|.
name|componentCount
operator|==
literal|3
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// We don't support formats which we can't represent without conversion
if|if
condition|(
name|dxgiFormatInfo
operator|.
name|internalFormat
operator|!=
name|internalFormat
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|fastCopyBufferToTexture
name|gl
operator|::
name|Error
name|Renderer11
operator|::
name|fastCopyBufferToTexture
parameter_list|(
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
name|unsigned
name|int
name|offset
parameter_list|,
name|RenderTargetD3D
modifier|*
name|destRenderTarget
parameter_list|,
name|GLenum
name|destinationFormat
parameter_list|,
name|GLenum
name|sourcePixelsType
parameter_list|,
specifier|const
name|gl
operator|::
name|Box
modifier|&
name|destArea
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|supportsFastCopyBufferToTexture
argument_list|(
name|destinationFormat
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|mPixelTransfer
operator|->
name|copyBufferToTexture
argument_list|(
name|unpack
argument_list|,
name|offset
argument_list|,
name|destRenderTarget
argument_list|,
name|destinationFormat
argument_list|,
name|sourcePixelsType
argument_list|,
name|destArea
argument_list|)
return|;
block|}
DECL|function|createImage
name|ImageD3D
modifier|*
name|Renderer11
operator|::
name|createImage
parameter_list|()
block|{
return|return
operator|new
name|Image11
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|function|generateMipmap
name|gl
operator|::
name|Error
name|Renderer11
operator|::
name|generateMipmap
parameter_list|(
name|ImageD3D
modifier|*
name|dest
parameter_list|,
name|ImageD3D
modifier|*
name|src
parameter_list|)
block|{
name|Image11
modifier|*
name|dest11
init|=
name|GetAs
argument_list|<
name|Image11
argument_list|>
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|Image11
modifier|*
name|src11
init|=
name|GetAs
argument_list|<
name|Image11
argument_list|>
argument_list|(
name|src
argument_list|)
decl_stmt|;
return|return
name|Image11
operator|::
name|generateMipmap
argument_list|(
name|dest11
argument_list|,
name|src11
argument_list|)
return|;
block|}
DECL|function|generateMipmapsUsingD3D
name|gl
operator|::
name|Error
name|Renderer11
operator|::
name|generateMipmapsUsingD3D
parameter_list|(
name|TextureStorage
modifier|*
name|storage
parameter_list|,
specifier|const
name|gl
operator|::
name|TextureState
modifier|&
name|textureState
parameter_list|)
block|{
name|TextureStorage11
modifier|*
name|storage11
init|=
name|GetAs
argument_list|<
name|TextureStorage11
argument_list|>
argument_list|(
name|storage
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|storage11
operator|->
name|isRenderTarget
argument_list|()
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|storage11
operator|->
name|supportsNativeMipmapFunction
argument_list|()
argument_list|)
expr_stmt|;
name|ID3D11ShaderResourceView
modifier|*
name|srv
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|storage11
operator|->
name|getSRVLevels
argument_list|(
name|textureState
operator|.
name|baseLevel
argument_list|,
name|textureState
operator|.
name|maxLevel
argument_list|,
operator|&
name|srv
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|mDeviceContext
operator|->
name|GenerateMips
argument_list|(
name|srv
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|createTextureStorage2D
name|TextureStorage
modifier|*
name|Renderer11
operator|::
name|createTextureStorage2D
parameter_list|(
name|SwapChainD3D
modifier|*
name|swapChain
parameter_list|)
block|{
name|SwapChain11
modifier|*
name|swapChain11
init|=
name|GetAs
argument_list|<
name|SwapChain11
argument_list|>
argument_list|(
name|swapChain
argument_list|)
decl_stmt|;
return|return
operator|new
name|TextureStorage11_2D
argument_list|(
name|this
argument_list|,
name|swapChain11
argument_list|)
return|;
block|}
DECL|function|createTextureStorageEGLImage
name|TextureStorage
modifier|*
name|Renderer11
operator|::
name|createTextureStorageEGLImage
parameter_list|(
name|EGLImageD3D
modifier|*
name|eglImage
parameter_list|)
block|{
return|return
operator|new
name|TextureStorage11_EGLImage
argument_list|(
name|this
argument_list|,
name|eglImage
argument_list|)
return|;
block|}
DECL|function|createTextureStorage2D
name|TextureStorage
modifier|*
name|Renderer11
operator|::
name|createTextureStorage2D
parameter_list|(
name|GLenum
name|internalformat
parameter_list|,
name|bool
name|renderTarget
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|int
name|levels
parameter_list|,
name|bool
name|hintLevelZeroOnly
parameter_list|)
block|{
return|return
operator|new
name|TextureStorage11_2D
argument_list|(
name|this
argument_list|,
name|internalformat
argument_list|,
name|renderTarget
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|levels
argument_list|,
name|hintLevelZeroOnly
argument_list|)
return|;
block|}
DECL|function|createTextureStorageCube
name|TextureStorage
modifier|*
name|Renderer11
operator|::
name|createTextureStorageCube
parameter_list|(
name|GLenum
name|internalformat
parameter_list|,
name|bool
name|renderTarget
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|levels
parameter_list|,
name|bool
name|hintLevelZeroOnly
parameter_list|)
block|{
return|return
operator|new
name|TextureStorage11_Cube
argument_list|(
name|this
argument_list|,
name|internalformat
argument_list|,
name|renderTarget
argument_list|,
name|size
argument_list|,
name|levels
argument_list|,
name|hintLevelZeroOnly
argument_list|)
return|;
block|}
DECL|function|createTextureStorage3D
name|TextureStorage
modifier|*
name|Renderer11
operator|::
name|createTextureStorage3D
parameter_list|(
name|GLenum
name|internalformat
parameter_list|,
name|bool
name|renderTarget
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|depth
parameter_list|,
name|int
name|levels
parameter_list|)
block|{
return|return
operator|new
name|TextureStorage11_3D
argument_list|(
name|this
argument_list|,
name|internalformat
argument_list|,
name|renderTarget
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|,
name|levels
argument_list|)
return|;
block|}
DECL|function|createTextureStorage2DArray
name|TextureStorage
modifier|*
name|Renderer11
operator|::
name|createTextureStorage2DArray
parameter_list|(
name|GLenum
name|internalformat
parameter_list|,
name|bool
name|renderTarget
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|depth
parameter_list|,
name|int
name|levels
parameter_list|)
block|{
return|return
operator|new
name|TextureStorage11_2DArray
argument_list|(
name|this
argument_list|,
name|internalformat
argument_list|,
name|renderTarget
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|,
name|levels
argument_list|)
return|;
block|}
DECL|function|createTexture
name|TextureImpl
modifier|*
name|Renderer11
operator|::
name|createTexture
parameter_list|(
name|GLenum
name|target
parameter_list|)
block|{
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TEXTURE_2D
case|:
return|return
operator|new
name|TextureD3D_2D
argument_list|(
name|this
argument_list|)
return|;
case|case
name|GL_TEXTURE_CUBE_MAP
case|:
return|return
operator|new
name|TextureD3D_Cube
argument_list|(
name|this
argument_list|)
return|;
case|case
name|GL_TEXTURE_3D
case|:
return|return
operator|new
name|TextureD3D_3D
argument_list|(
name|this
argument_list|)
return|;
case|case
name|GL_TEXTURE_2D_ARRAY
case|:
return|return
operator|new
name|TextureD3D_2DArray
argument_list|(
name|this
argument_list|)
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
DECL|function|createRenderbuffer
name|RenderbufferImpl
modifier|*
name|Renderer11
operator|::
name|createRenderbuffer
parameter_list|()
block|{
name|RenderbufferD3D
modifier|*
name|renderbuffer
init|=
operator|new
name|RenderbufferD3D
argument_list|(
name|this
argument_list|)
decl_stmt|;
return|return
name|renderbuffer
return|;
block|}
DECL|function|readFromAttachment
name|gl
operator|::
name|Error
name|Renderer11
operator|::
name|readFromAttachment
parameter_list|(
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|&
name|srcAttachment
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|sourceArea
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLuint
name|outputPitch
parameter_list|,
specifier|const
name|gl
operator|::
name|PixelPackState
modifier|&
name|pack
parameter_list|,
name|uint8_t
modifier|*
name|pixelsOut
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|sourceArea
operator|.
name|width
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|sourceArea
operator|.
name|height
operator|>=
literal|0
argument_list|)
expr_stmt|;
specifier|const
name|bool
name|invertTexture
init|=
name|UsePresentPathFast
argument_list|(
name|this
argument_list|,
operator|&
name|srcAttachment
argument_list|)
decl_stmt|;
name|RenderTargetD3D
modifier|*
name|renderTarget
init|=
literal|nullptr
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|srcAttachment
operator|.
name|getRenderTarget
argument_list|(
operator|&
name|renderTarget
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|RenderTarget11
modifier|*
name|rt11
init|=
name|GetAs
argument_list|<
name|RenderTarget11
argument_list|>
argument_list|(
name|renderTarget
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|rt11
operator|->
name|getTexture
argument_list|()
argument_list|)
expr_stmt|;
name|TextureHelper11
name|textureHelper
init|=
name|TextureHelper11
operator|::
name|MakeAndReference
argument_list|(
name|rt11
operator|->
name|getTexture
argument_list|()
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|sourceSubResource
init|=
name|rt11
operator|->
name|getSubresourceIndex
argument_list|()
decl_stmt|;
specifier|const
name|gl
operator|::
name|Extents
modifier|&
name|texSize
init|=
name|textureHelper
operator|.
name|getExtents
argument_list|()
decl_stmt|;
name|gl
operator|::
name|Rectangle
name|actualArea
init|=
name|sourceArea
decl_stmt|;
if|if
condition|(
name|invertTexture
condition|)
block|{
name|actualArea
operator|.
name|y
operator|=
name|texSize
operator|.
name|height
operator|-
name|actualArea
operator|.
name|y
operator|-
name|actualArea
operator|.
name|height
expr_stmt|;
block|}
comment|// Clamp read region to the defined texture boundaries, preventing out of bounds reads
comment|// and reads of uninitialized data.
name|gl
operator|::
name|Rectangle
name|safeArea
decl_stmt|;
name|safeArea
operator|.
name|x
operator|=
name|gl
operator|::
name|clamp
argument_list|(
name|actualArea
operator|.
name|x
argument_list|,
literal|0
argument_list|,
name|texSize
operator|.
name|width
argument_list|)
expr_stmt|;
name|safeArea
operator|.
name|y
operator|=
name|gl
operator|::
name|clamp
argument_list|(
name|actualArea
operator|.
name|y
argument_list|,
literal|0
argument_list|,
name|texSize
operator|.
name|height
argument_list|)
expr_stmt|;
name|safeArea
operator|.
name|width
operator|=
name|gl
operator|::
name|clamp
argument_list|(
name|actualArea
operator|.
name|width
operator|+
name|std
operator|::
name|min
argument_list|(
name|actualArea
operator|.
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|texSize
operator|.
name|width
operator|-
name|safeArea
operator|.
name|x
argument_list|)
expr_stmt|;
name|safeArea
operator|.
name|height
operator|=
name|gl
operator|::
name|clamp
argument_list|(
name|actualArea
operator|.
name|height
operator|+
name|std
operator|::
name|min
argument_list|(
name|actualArea
operator|.
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|texSize
operator|.
name|height
operator|-
name|safeArea
operator|.
name|y
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|safeArea
operator|.
name|x
operator|>=
literal|0
operator|&&
name|safeArea
operator|.
name|y
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|safeArea
operator|.
name|x
operator|+
name|safeArea
operator|.
name|width
operator|<=
name|texSize
operator|.
name|width
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|safeArea
operator|.
name|y
operator|+
name|safeArea
operator|.
name|height
operator|<=
name|texSize
operator|.
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|safeArea
operator|.
name|width
operator|==
literal|0
operator|||
name|safeArea
operator|.
name|height
operator|==
literal|0
condition|)
block|{
comment|// no work to do
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
name|gl
operator|::
name|Extents
name|safeSize
argument_list|(
name|safeArea
operator|.
name|width
argument_list|,
name|safeArea
operator|.
name|height
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|auto
name|errorOrResult
init|=
name|CreateStagingTexture
argument_list|(
name|textureHelper
operator|.
name|getTextureType
argument_list|()
argument_list|,
name|textureHelper
operator|.
name|getFormat
argument_list|()
argument_list|,
name|safeSize
argument_list|,
name|mDevice
argument_list|)
decl_stmt|;
if|if
condition|(
name|errorOrResult
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|errorOrResult
operator|.
name|getError
argument_list|()
return|;
block|}
name|TextureHelper11
name|stagingHelper
argument_list|(
name|errorOrResult
operator|.
name|getResult
argument_list|()
argument_list|)
decl_stmt|;
name|TextureHelper11
name|resolvedTextureHelper
decl_stmt|;
comment|// "srcTexture" usually points to the source texture.
comment|// For 2D multisampled textures, it points to the multisampled resolve texture.
specifier|const
name|TextureHelper11
modifier|*
name|srcTexture
init|=
operator|&
name|textureHelper
decl_stmt|;
if|if
condition|(
name|textureHelper
operator|.
name|getTextureType
argument_list|()
operator|==
name|GL_TEXTURE_2D
operator|&&
name|textureHelper
operator|.
name|getSampleCount
argument_list|()
operator|>
literal|1
condition|)
block|{
name|D3D11_TEXTURE2D_DESC
name|resolveDesc
decl_stmt|;
name|resolveDesc
operator|.
name|Width
operator|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|texSize
operator|.
name|width
argument_list|)
expr_stmt|;
name|resolveDesc
operator|.
name|Height
operator|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|texSize
operator|.
name|height
argument_list|)
expr_stmt|;
name|resolveDesc
operator|.
name|MipLevels
operator|=
literal|1
expr_stmt|;
name|resolveDesc
operator|.
name|ArraySize
operator|=
literal|1
expr_stmt|;
name|resolveDesc
operator|.
name|Format
operator|=
name|textureHelper
operator|.
name|getFormat
argument_list|()
expr_stmt|;
name|resolveDesc
operator|.
name|SampleDesc
operator|.
name|Count
operator|=
literal|1
expr_stmt|;
name|resolveDesc
operator|.
name|SampleDesc
operator|.
name|Quality
operator|=
literal|0
expr_stmt|;
name|resolveDesc
operator|.
name|Usage
operator|=
name|D3D11_USAGE_DEFAULT
expr_stmt|;
name|resolveDesc
operator|.
name|BindFlags
operator|=
literal|0
expr_stmt|;
name|resolveDesc
operator|.
name|CPUAccessFlags
operator|=
literal|0
expr_stmt|;
name|resolveDesc
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|ID3D11Texture2D
modifier|*
name|resolveTex2D
init|=
literal|nullptr
decl_stmt|;
name|HRESULT
name|result
init|=
name|mDevice
operator|->
name|CreateTexture2D
argument_list|(
operator|&
name|resolveDesc
argument_list|,
literal|nullptr
argument_list|,
operator|&
name|resolveTex2D
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Renderer11::readTextureData failed to create internal resolve "
literal|"texture for ReadPixels, HRESULT: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
name|mDeviceContext
operator|->
name|ResolveSubresource
argument_list|(
name|resolveTex2D
argument_list|,
literal|0
argument_list|,
name|textureHelper
operator|.
name|getTexture2D
argument_list|()
argument_list|,
name|sourceSubResource
argument_list|,
name|textureHelper
operator|.
name|getFormat
argument_list|()
argument_list|)
expr_stmt|;
name|resolvedTextureHelper
operator|=
name|TextureHelper11
operator|::
name|MakeAndReference
argument_list|(
name|resolveTex2D
argument_list|)
expr_stmt|;
name|sourceSubResource
operator|=
literal|0
expr_stmt|;
name|srcTexture
operator|=
operator|&
name|resolvedTextureHelper
expr_stmt|;
block|}
name|D3D11_BOX
name|srcBox
decl_stmt|;
name|srcBox
operator|.
name|left
operator|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|safeArea
operator|.
name|x
argument_list|)
expr_stmt|;
name|srcBox
operator|.
name|right
operator|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|safeArea
operator|.
name|x
operator|+
name|safeArea
operator|.
name|width
argument_list|)
expr_stmt|;
name|srcBox
operator|.
name|top
operator|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|safeArea
operator|.
name|y
argument_list|)
expr_stmt|;
name|srcBox
operator|.
name|bottom
operator|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|safeArea
operator|.
name|y
operator|+
name|safeArea
operator|.
name|height
argument_list|)
expr_stmt|;
comment|// Select the correct layer from a 3D attachment
name|srcBox
operator|.
name|front
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|textureHelper
operator|.
name|getTextureType
argument_list|()
operator|==
name|GL_TEXTURE_3D
condition|)
block|{
name|srcBox
operator|.
name|front
operator|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|srcAttachment
operator|.
name|layer
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|srcBox
operator|.
name|back
operator|=
name|srcBox
operator|.
name|front
operator|+
literal|1
expr_stmt|;
name|mDeviceContext
operator|->
name|CopySubresourceRegion
argument_list|(
name|stagingHelper
operator|.
name|getResource
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|srcTexture
operator|->
name|getResource
argument_list|()
argument_list|,
name|sourceSubResource
argument_list|,
operator|&
name|srcBox
argument_list|)
expr_stmt|;
if|if
condition|(
name|invertTexture
condition|)
block|{
name|gl
operator|::
name|PixelPackState
name|invertTexturePack
decl_stmt|;
comment|// Create a new PixelPackState with reversed row order. Note that we can't just assign
comment|// 'invertTexturePack' to be 'pack' (or memcpy) since that breaks the ref counting/object
comment|// tracking in the 'pixelBuffer' members, causing leaks. Instead we must use
comment|// pixelBuffer.set() twice, which performs the addRef/release correctly
name|invertTexturePack
operator|.
name|alignment
operator|=
name|pack
operator|.
name|alignment
expr_stmt|;
name|invertTexturePack
operator|.
name|pixelBuffer
operator|.
name|set
argument_list|(
name|pack
operator|.
name|pixelBuffer
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|invertTexturePack
operator|.
name|reverseRowOrder
operator|=
operator|!
name|pack
operator|.
name|reverseRowOrder
expr_stmt|;
name|PackPixelsParams
name|packParams
argument_list|(
name|safeArea
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|outputPitch
argument_list|,
name|invertTexturePack
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|error
operator|=
name|packPixels
argument_list|(
name|stagingHelper
argument_list|,
name|packParams
argument_list|,
name|pixelsOut
argument_list|)
expr_stmt|;
name|invertTexturePack
operator|.
name|pixelBuffer
operator|.
name|set
argument_list|(
literal|nullptr
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
else|else
block|{
name|PackPixelsParams
name|packParams
argument_list|(
name|safeArea
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|outputPitch
argument_list|,
name|pack
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
name|packPixels
argument_list|(
name|stagingHelper
argument_list|,
name|packParams
argument_list|,
name|pixelsOut
argument_list|)
return|;
block|}
block|}
DECL|function|packPixels
name|gl
operator|::
name|Error
name|Renderer11
operator|::
name|packPixels
parameter_list|(
specifier|const
name|TextureHelper11
modifier|&
name|textureHelper
parameter_list|,
specifier|const
name|PackPixelsParams
modifier|&
name|params
parameter_list|,
name|uint8_t
modifier|*
name|pixelsOut
parameter_list|)
block|{
name|ID3D11Resource
modifier|*
name|readResource
init|=
name|textureHelper
operator|.
name|getResource
argument_list|()
decl_stmt|;
name|D3D11_MAPPED_SUBRESOURCE
name|mapping
decl_stmt|;
name|HRESULT
name|hr
init|=
name|mDeviceContext
operator|->
name|Map
argument_list|(
name|readResource
argument_list|,
literal|0
argument_list|,
name|D3D11_MAP_READ
argument_list|,
literal|0
argument_list|,
operator|&
name|mapping
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|hr
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|hr
operator|==
name|E_OUTOFMEMORY
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to map internal texture for reading, result: 0x%X."
argument_list|,
name|hr
argument_list|)
return|;
block|}
name|uint8_t
modifier|*
name|source
decl_stmt|;
name|int
name|inputPitch
decl_stmt|;
if|if
condition|(
name|params
operator|.
name|pack
operator|.
name|reverseRowOrder
condition|)
block|{
name|source
operator|=
cast|static_cast
argument_list|<
name|uint8_t
operator|*
argument_list|>
argument_list|(
name|mapping
operator|.
name|pData
argument_list|)
operator|+
name|mapping
operator|.
name|RowPitch
operator|*
operator|(
name|params
operator|.
name|area
operator|.
name|height
operator|-
literal|1
operator|)
expr_stmt|;
name|inputPitch
operator|=
operator|-
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|mapping
operator|.
name|RowPitch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|source
operator|=
cast|static_cast
argument_list|<
name|uint8_t
operator|*
argument_list|>
argument_list|(
name|mapping
operator|.
name|pData
argument_list|)
expr_stmt|;
name|inputPitch
operator|=
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|mapping
operator|.
name|RowPitch
argument_list|)
expr_stmt|;
block|}
specifier|const
name|d3d11
operator|::
name|DXGIFormat
modifier|&
name|dxgiFormatInfo
init|=
name|d3d11
operator|::
name|GetDXGIFormatInfo
argument_list|(
name|textureHelper
operator|.
name|getFormat
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|gl
operator|::
name|InternalFormat
modifier|&
name|sourceFormatInfo
init|=
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|dxgiFormatInfo
operator|.
name|internalFormat
argument_list|)
decl_stmt|;
if|if
condition|(
name|sourceFormatInfo
operator|.
name|format
operator|==
name|params
operator|.
name|format
operator|&&
name|sourceFormatInfo
operator|.
name|type
operator|==
name|params
operator|.
name|type
condition|)
block|{
name|uint8_t
modifier|*
name|dest
init|=
name|pixelsOut
operator|+
name|params
operator|.
name|offset
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|params
operator|.
name|area
operator|.
name|height
condition|;
name|y
operator|++
control|)
block|{
name|memcpy
argument_list|(
name|dest
operator|+
name|y
operator|*
name|params
operator|.
name|outputPitch
argument_list|,
name|source
operator|+
name|y
operator|*
name|inputPitch
argument_list|,
name|params
operator|.
name|area
operator|.
name|width
operator|*
name|sourceFormatInfo
operator|.
name|pixelBytes
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ColorCopyFunction
name|fastCopyFunc
init|=
name|dxgiFormatInfo
operator|.
name|getFastCopyFunction
argument_list|(
name|params
operator|.
name|format
argument_list|,
name|params
operator|.
name|type
argument_list|)
decl_stmt|;
name|GLenum
name|sizedDestInternalFormat
init|=
name|gl
operator|::
name|GetSizedInternalFormat
argument_list|(
name|params
operator|.
name|format
argument_list|,
name|params
operator|.
name|type
argument_list|)
decl_stmt|;
specifier|const
name|gl
operator|::
name|InternalFormat
modifier|&
name|destFormatInfo
init|=
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|sizedDestInternalFormat
argument_list|)
decl_stmt|;
if|if
condition|(
name|fastCopyFunc
condition|)
block|{
comment|// Fast copy is possible through some special function
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|params
operator|.
name|area
operator|.
name|height
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|params
operator|.
name|area
operator|.
name|width
condition|;
name|x
operator|++
control|)
block|{
name|uint8_t
modifier|*
name|dest
init|=
name|pixelsOut
operator|+
name|params
operator|.
name|offset
operator|+
name|y
operator|*
name|params
operator|.
name|outputPitch
operator|+
name|x
operator|*
name|destFormatInfo
operator|.
name|pixelBytes
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|src
init|=
name|source
operator|+
name|y
operator|*
name|inputPitch
operator|+
name|x
operator|*
name|sourceFormatInfo
operator|.
name|pixelBytes
decl_stmt|;
name|fastCopyFunc
argument_list|(
name|src
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|ColorReadFunction
name|colorReadFunction
init|=
name|dxgiFormatInfo
operator|.
name|colorReadFunction
decl_stmt|;
name|ColorWriteFunction
name|colorWriteFunction
init|=
name|GetColorWriteFunction
argument_list|(
name|params
operator|.
name|format
argument_list|,
name|params
operator|.
name|type
argument_list|)
decl_stmt|;
name|uint8_t
name|temp
index|[
literal|16
index|]
decl_stmt|;
comment|// Maximum size of any Color<T> type used.
assert|static_assert
argument_list|(
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|gl
operator|::
name|ColorF
argument_list|)
operator|&&
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|gl
operator|::
name|ColorUI
argument_list|)
operator|&&
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|gl
operator|::
name|ColorI
argument_list|)
argument_list|,
literal|"Unexpected size of gl::Color struct."
argument_list|)
assert|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|params
operator|.
name|area
operator|.
name|height
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|params
operator|.
name|area
operator|.
name|width
condition|;
name|x
operator|++
control|)
block|{
name|uint8_t
modifier|*
name|dest
init|=
name|pixelsOut
operator|+
name|params
operator|.
name|offset
operator|+
name|y
operator|*
name|params
operator|.
name|outputPitch
operator|+
name|x
operator|*
name|destFormatInfo
operator|.
name|pixelBytes
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|src
init|=
name|source
operator|+
name|y
operator|*
name|inputPitch
operator|+
name|x
operator|*
name|sourceFormatInfo
operator|.
name|pixelBytes
decl_stmt|;
comment|// readFunc and writeFunc will be using the same type of color, CopyTexImage
comment|// will not allow the copy otherwise.
name|colorReadFunction
argument_list|(
name|src
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|colorWriteFunction
argument_list|(
name|temp
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|mDeviceContext
operator|->
name|Unmap
argument_list|(
name|readResource
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|blitRenderbufferRect
name|gl
operator|::
name|Error
name|Renderer11
operator|::
name|blitRenderbufferRect
parameter_list|(
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|readRectIn
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|drawRectIn
parameter_list|,
name|RenderTargetD3D
modifier|*
name|readRenderTarget
parameter_list|,
name|RenderTargetD3D
modifier|*
name|drawRenderTarget
parameter_list|,
name|GLenum
name|filter
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|*
name|scissor
parameter_list|,
name|bool
name|colorBlit
parameter_list|,
name|bool
name|depthBlit
parameter_list|,
name|bool
name|stencilBlit
parameter_list|)
block|{
comment|// Since blitRenderbufferRect is called for each render buffer that needs to be blitted,
comment|// it should never be the case that both color and depth/stencil need to be blitted at
comment|// at the same time.
name|ASSERT
argument_list|(
name|colorBlit
operator|!=
operator|(
name|depthBlit
operator|||
name|stencilBlit
operator|)
argument_list|)
expr_stmt|;
name|RenderTarget11
modifier|*
name|drawRenderTarget11
init|=
name|GetAs
argument_list|<
name|RenderTarget11
argument_list|>
argument_list|(
name|drawRenderTarget
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|drawRenderTarget
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to retrieve the internal draw render target from the draw framebuffer."
argument_list|)
return|;
block|}
name|ID3D11Resource
modifier|*
name|drawTexture
init|=
name|drawRenderTarget11
operator|->
name|getTexture
argument_list|()
decl_stmt|;
name|unsigned
name|int
name|drawSubresource
init|=
name|drawRenderTarget11
operator|->
name|getSubresourceIndex
argument_list|()
decl_stmt|;
name|ID3D11RenderTargetView
modifier|*
name|drawRTV
init|=
name|drawRenderTarget11
operator|->
name|getRenderTargetView
argument_list|()
decl_stmt|;
name|ID3D11DepthStencilView
modifier|*
name|drawDSV
init|=
name|drawRenderTarget11
operator|->
name|getDepthStencilView
argument_list|()
decl_stmt|;
name|RenderTarget11
modifier|*
name|readRenderTarget11
init|=
name|GetAs
argument_list|<
name|RenderTarget11
argument_list|>
argument_list|(
name|readRenderTarget
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|readRenderTarget
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to retrieve the internal read render target from the read framebuffer."
argument_list|)
return|;
block|}
name|ID3D11Resource
modifier|*
name|readTexture
init|=
name|NULL
decl_stmt|;
name|ID3D11ShaderResourceView
modifier|*
name|readSRV
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|readSubresource
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|readRenderTarget
operator|->
name|getSamples
argument_list|()
operator|>
literal|0
condition|)
block|{
name|ID3D11Resource
modifier|*
name|unresolvedResource
init|=
name|readRenderTarget11
operator|->
name|getTexture
argument_list|()
decl_stmt|;
name|ID3D11Texture2D
modifier|*
name|unresolvedTexture
init|=
name|d3d11
operator|::
name|DynamicCastComObject
argument_list|<
name|ID3D11Texture2D
argument_list|>
argument_list|(
name|unresolvedResource
argument_list|)
decl_stmt|;
if|if
condition|(
name|unresolvedTexture
condition|)
block|{
name|readTexture
operator|=
name|resolveMultisampledTexture
argument_list|(
name|unresolvedTexture
argument_list|,
name|readRenderTarget11
operator|->
name|getSubresourceIndex
argument_list|()
argument_list|)
expr_stmt|;
name|readSubresource
operator|=
literal|0
expr_stmt|;
name|SafeRelease
argument_list|(
name|unresolvedTexture
argument_list|)
expr_stmt|;
name|HRESULT
name|hresult
init|=
name|mDevice
operator|->
name|CreateShaderResourceView
argument_list|(
name|readTexture
argument_list|,
name|NULL
argument_list|,
operator|&
name|readSRV
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|hresult
argument_list|)
condition|)
block|{
name|SafeRelease
argument_list|(
name|readTexture
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create shader resource view to resolve multisampled framebuffer."
argument_list|)
return|;
block|}
block|}
block|}
else|else
block|{
name|readTexture
operator|=
name|readRenderTarget11
operator|->
name|getTexture
argument_list|()
expr_stmt|;
name|readTexture
operator|->
name|AddRef
argument_list|()
expr_stmt|;
name|readSubresource
operator|=
name|readRenderTarget11
operator|->
name|getSubresourceIndex
argument_list|()
expr_stmt|;
name|readSRV
operator|=
name|readRenderTarget11
operator|->
name|getShaderResourceView
argument_list|()
expr_stmt|;
name|readSRV
operator|->
name|AddRef
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|readTexture
operator|||
operator|!
name|readSRV
condition|)
block|{
name|SafeRelease
argument_list|(
name|readTexture
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|readSRV
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to retrieve the internal read render target view from the read render target."
argument_list|)
return|;
block|}
name|gl
operator|::
name|Extents
name|readSize
argument_list|(
name|readRenderTarget
operator|->
name|getWidth
argument_list|()
argument_list|,
name|readRenderTarget
operator|->
name|getHeight
argument_list|()
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Extents
name|drawSize
argument_list|(
name|drawRenderTarget
operator|->
name|getWidth
argument_list|()
argument_list|,
name|drawRenderTarget
operator|->
name|getHeight
argument_list|()
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|// From the spec:
comment|// "The actual region taken from the read framebuffer is limited to the intersection of the
comment|// source buffers being transferred, which may include the color buffer selected by the read
comment|// buffer, the depth buffer, and / or the stencil buffer depending on mask."
comment|// This means negative x and y are out of bounds, and not to be read from. We handle this here
comment|// by internally scaling the read and draw rectangles.
name|gl
operator|::
name|Rectangle
name|readRect
init|=
name|readRectIn
decl_stmt|;
name|gl
operator|::
name|Rectangle
name|drawRect
init|=
name|drawRectIn
decl_stmt|;
name|auto
name|readToDrawX
init|=
capture|[
modifier|&
name|drawRectIn
capture|,
modifier|&
name|readRectIn
capture|]
parameter_list|(
name|int
name|readOffset
parameter_list|)
block|{
name|double
name|readToDrawScale
init|=
cast|static_cast
argument_list|<
name|double
argument_list|>
argument_list|(
name|drawRectIn
operator|.
name|width
argument_list|)
operator|/
cast|static_cast
argument_list|<
name|double
argument_list|>
argument_list|(
name|readRectIn
operator|.
name|width
argument_list|)
decl_stmt|;
return|return
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|round
argument_list|(
cast|static_cast
argument_list|<
name|double
argument_list|>
argument_list|(
name|readOffset
argument_list|)
operator|*
name|readToDrawScale
argument_list|)
argument_list|)
return|;
block|}
decl_stmt|;
if|if
condition|(
name|readRect
operator|.
name|x
operator|<
literal|0
condition|)
block|{
name|int
name|readOffset
init|=
operator|-
name|readRect
operator|.
name|x
decl_stmt|;
name|readRect
operator|.
name|x
operator|+=
name|readOffset
expr_stmt|;
name|readRect
operator|.
name|width
operator|-=
name|readOffset
expr_stmt|;
name|int
name|drawOffset
init|=
name|readToDrawX
argument_list|(
name|readOffset
argument_list|)
decl_stmt|;
name|drawRect
operator|.
name|x
operator|+=
name|drawOffset
expr_stmt|;
name|drawRect
operator|.
name|width
operator|-=
name|drawOffset
expr_stmt|;
block|}
name|auto
name|readToDrawY
init|=
capture|[
modifier|&
name|drawRectIn
capture|,
modifier|&
name|readRectIn
capture|]
parameter_list|(
name|int
name|readOffset
parameter_list|)
block|{
name|double
name|readToDrawScale
init|=
cast|static_cast
argument_list|<
name|double
argument_list|>
argument_list|(
name|drawRectIn
operator|.
name|height
argument_list|)
operator|/
cast|static_cast
argument_list|<
name|double
argument_list|>
argument_list|(
name|readRectIn
operator|.
name|height
argument_list|)
decl_stmt|;
return|return
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|round
argument_list|(
cast|static_cast
argument_list|<
name|double
argument_list|>
argument_list|(
name|readOffset
argument_list|)
operator|*
name|readToDrawScale
argument_list|)
argument_list|)
return|;
block|}
decl_stmt|;
if|if
condition|(
name|readRect
operator|.
name|y
operator|<
literal|0
condition|)
block|{
name|int
name|readOffset
init|=
operator|-
name|readRect
operator|.
name|y
decl_stmt|;
name|readRect
operator|.
name|y
operator|+=
name|readOffset
expr_stmt|;
name|readRect
operator|.
name|height
operator|-=
name|readOffset
expr_stmt|;
name|int
name|drawOffset
init|=
name|readToDrawY
argument_list|(
name|readOffset
argument_list|)
decl_stmt|;
name|drawRect
operator|.
name|y
operator|+=
name|drawOffset
expr_stmt|;
name|drawRect
operator|.
name|height
operator|-=
name|drawOffset
expr_stmt|;
block|}
if|if
condition|(
name|readRect
operator|.
name|x1
argument_list|()
operator|<
literal|0
condition|)
block|{
name|int
name|readOffset
init|=
operator|-
name|readRect
operator|.
name|x1
argument_list|()
decl_stmt|;
name|readRect
operator|.
name|width
operator|+=
name|readOffset
expr_stmt|;
name|int
name|drawOffset
init|=
name|readToDrawX
argument_list|(
name|readOffset
argument_list|)
decl_stmt|;
name|drawRect
operator|.
name|width
operator|+=
name|drawOffset
expr_stmt|;
block|}
if|if
condition|(
name|readRect
operator|.
name|y1
argument_list|()
operator|<
literal|0
condition|)
block|{
name|int
name|readOffset
init|=
operator|-
name|readRect
operator|.
name|y1
argument_list|()
decl_stmt|;
name|readRect
operator|.
name|height
operator|+=
name|readOffset
expr_stmt|;
name|int
name|drawOffset
init|=
name|readToDrawY
argument_list|(
name|readOffset
argument_list|)
decl_stmt|;
name|drawRect
operator|.
name|height
operator|+=
name|drawOffset
expr_stmt|;
block|}
name|bool
name|scissorNeeded
init|=
name|scissor
operator|&&
name|gl
operator|::
name|ClipRectangle
argument_list|(
name|drawRect
argument_list|,
operator|*
name|scissor
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
specifier|const
specifier|auto
modifier|&
name|destFormatInfo
init|=
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|drawRenderTarget
operator|->
name|getInternalFormat
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
specifier|auto
modifier|&
name|srcFormatInfo
init|=
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|readRenderTarget
operator|->
name|getInternalFormat
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
specifier|auto
modifier|&
name|dxgiFormatInfo
init|=
name|d3d11
operator|::
name|GetDXGIFormatInfo
argument_list|(
name|drawRenderTarget11
operator|->
name|getDXGIFormat
argument_list|()
argument_list|)
decl_stmt|;
comment|// Some blits require masking off emulated texture channels. eg: from RGBA8 to RGB8, we
comment|// emulate RGB8 with RGBA8, so we need to mask off the alpha channel when we copy.
name|gl
operator|::
name|Color
argument_list|<
name|bool
argument_list|>
name|colorMask
decl_stmt|;
name|colorMask
operator|.
name|red
operator|=
operator|(
name|srcFormatInfo
operator|.
name|redBits
operator|>
literal|0
operator|)
operator|&&
operator|(
name|destFormatInfo
operator|.
name|redBits
operator|==
literal|0
operator|)
operator|&&
operator|(
name|dxgiFormatInfo
operator|.
name|redBits
operator|>
literal|0
operator|)
expr_stmt|;
name|colorMask
operator|.
name|green
operator|=
operator|(
name|srcFormatInfo
operator|.
name|greenBits
operator|>
literal|0
operator|)
operator|&&
operator|(
name|destFormatInfo
operator|.
name|greenBits
operator|==
literal|0
operator|)
operator|&&
operator|(
name|dxgiFormatInfo
operator|.
name|greenBits
operator|>
literal|0
operator|)
expr_stmt|;
name|colorMask
operator|.
name|blue
operator|=
operator|(
name|srcFormatInfo
operator|.
name|blueBits
operator|>
literal|0
operator|)
operator|&&
operator|(
name|destFormatInfo
operator|.
name|blueBits
operator|==
literal|0
operator|)
operator|&&
operator|(
name|dxgiFormatInfo
operator|.
name|blueBits
operator|>
literal|0
operator|)
expr_stmt|;
name|colorMask
operator|.
name|alpha
operator|=
operator|(
name|srcFormatInfo
operator|.
name|alphaBits
operator|>
literal|0
operator|)
operator|&&
operator|(
name|destFormatInfo
operator|.
name|alphaBits
operator|==
literal|0
operator|)
operator|&&
operator|(
name|dxgiFormatInfo
operator|.
name|alphaBits
operator|>
literal|0
operator|)
expr_stmt|;
comment|// We only currently support masking off the alpha channel.
name|bool
name|colorMaskingNeeded
init|=
name|colorMask
operator|.
name|alpha
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|colorMask
operator|.
name|red
operator|&&
operator|!
name|colorMask
operator|.
name|green
operator|&&
operator|!
name|colorMask
operator|.
name|blue
argument_list|)
expr_stmt|;
name|bool
name|wholeBufferCopy
init|=
operator|!
name|scissorNeeded
operator|&&
operator|!
name|colorMaskingNeeded
operator|&&
name|readRect
operator|.
name|x
operator|==
literal|0
operator|&&
name|readRect
operator|.
name|width
operator|==
name|readSize
operator|.
name|width
operator|&&
name|readRect
operator|.
name|y
operator|==
literal|0
operator|&&
name|readRect
operator|.
name|height
operator|==
name|readSize
operator|.
name|height
operator|&&
name|drawRect
operator|.
name|x
operator|==
literal|0
operator|&&
name|drawRect
operator|.
name|width
operator|==
name|drawSize
operator|.
name|width
operator|&&
name|drawRect
operator|.
name|y
operator|==
literal|0
operator|&&
name|drawRect
operator|.
name|height
operator|==
name|drawSize
operator|.
name|height
decl_stmt|;
name|bool
name|stretchRequired
init|=
name|readRect
operator|.
name|width
operator|!=
name|drawRect
operator|.
name|width
operator|||
name|readRect
operator|.
name|height
operator|!=
name|drawRect
operator|.
name|height
decl_stmt|;
name|bool
name|flipRequired
init|=
name|readRect
operator|.
name|width
operator|<
literal|0
operator|||
name|readRect
operator|.
name|height
operator|<
literal|0
operator|||
name|drawRect
operator|.
name|width
operator|<
literal|0
operator|||
name|drawRect
operator|.
name|height
operator|<
literal|0
decl_stmt|;
name|bool
name|outOfBounds
init|=
name|readRect
operator|.
name|x
argument_list|<
literal|0
operator|||
name|readRect
operator|.
name|x
operator|+
name|readRect
operator|.
name|width
argument_list|>
name|readSize
operator|.
name|width
operator|||
name|readRect
operator|.
name|y
argument_list|<
literal|0
operator|||
name|readRect
operator|.
name|y
operator|+
name|readRect
operator|.
name|height
argument_list|>
name|readSize
operator|.
name|height
operator|||
name|drawRect
operator|.
name|x
argument_list|<
literal|0
operator|||
name|drawRect
operator|.
name|x
operator|+
name|drawRect
operator|.
name|width
argument_list|>
name|drawSize
operator|.
name|width
operator|||
name|drawRect
operator|.
name|y
argument_list|<
literal|0
operator|||
name|drawRect
operator|.
name|y
operator|+
name|drawRect
operator|.
name|height
argument_list|>
name|drawSize
operator|.
name|height
decl_stmt|;
name|bool
name|partialDSBlit
init|=
operator|(
name|dxgiFormatInfo
operator|.
name|depthBits
operator|>
literal|0
operator|&&
name|depthBlit
operator|)
operator|!=
operator|(
name|dxgiFormatInfo
operator|.
name|stencilBits
operator|>
literal|0
operator|&&
name|stencilBlit
operator|)
decl_stmt|;
name|gl
operator|::
name|Error
name|result
argument_list|(
name|GL_NO_ERROR
argument_list|)
decl_stmt|;
if|if
condition|(
name|readRenderTarget11
operator|->
name|getDXGIFormat
argument_list|()
operator|==
name|drawRenderTarget11
operator|->
name|getDXGIFormat
argument_list|()
operator|&&
operator|!
name|stretchRequired
operator|&&
operator|!
name|outOfBounds
operator|&&
operator|!
name|flipRequired
operator|&&
operator|!
name|partialDSBlit
operator|&&
operator|!
name|colorMaskingNeeded
operator|&&
operator|(
operator|!
operator|(
name|depthBlit
operator|||
name|stencilBlit
operator|)
operator|||
name|wholeBufferCopy
operator|)
condition|)
block|{
name|UINT
name|dstX
init|=
name|drawRect
operator|.
name|x
decl_stmt|;
name|UINT
name|dstY
init|=
name|drawRect
operator|.
name|y
decl_stmt|;
name|D3D11_BOX
name|readBox
decl_stmt|;
name|readBox
operator|.
name|left
operator|=
name|readRect
operator|.
name|x
expr_stmt|;
name|readBox
operator|.
name|right
operator|=
name|readRect
operator|.
name|x
operator|+
name|readRect
operator|.
name|width
expr_stmt|;
name|readBox
operator|.
name|top
operator|=
name|readRect
operator|.
name|y
expr_stmt|;
name|readBox
operator|.
name|bottom
operator|=
name|readRect
operator|.
name|y
operator|+
name|readRect
operator|.
name|height
expr_stmt|;
name|readBox
operator|.
name|front
operator|=
literal|0
expr_stmt|;
name|readBox
operator|.
name|back
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|scissorNeeded
condition|)
block|{
comment|// drawRect is guaranteed to have positive width and height because stretchRequired is false.
name|ASSERT
argument_list|(
name|drawRect
operator|.
name|width
operator|>=
literal|0
operator|||
name|drawRect
operator|.
name|height
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|drawRect
operator|.
name|x
operator|<
name|scissor
operator|->
name|x
condition|)
block|{
name|dstX
operator|=
name|scissor
operator|->
name|x
expr_stmt|;
name|readBox
operator|.
name|left
operator|+=
operator|(
name|scissor
operator|->
name|x
operator|-
name|drawRect
operator|.
name|x
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|drawRect
operator|.
name|y
operator|<
name|scissor
operator|->
name|y
condition|)
block|{
name|dstY
operator|=
name|scissor
operator|->
name|y
expr_stmt|;
name|readBox
operator|.
name|top
operator|+=
operator|(
name|scissor
operator|->
name|y
operator|-
name|drawRect
operator|.
name|y
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|drawRect
operator|.
name|x
operator|+
name|drawRect
operator|.
name|width
operator|>
name|scissor
operator|->
name|x
operator|+
name|scissor
operator|->
name|width
condition|)
block|{
name|readBox
operator|.
name|right
operator|-=
operator|(
operator|(
name|drawRect
operator|.
name|x
operator|+
name|drawRect
operator|.
name|width
operator|)
operator|-
operator|(
name|scissor
operator|->
name|x
operator|+
name|scissor
operator|->
name|width
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|drawRect
operator|.
name|y
operator|+
name|drawRect
operator|.
name|height
operator|>
name|scissor
operator|->
name|y
operator|+
name|scissor
operator|->
name|height
condition|)
block|{
name|readBox
operator|.
name|bottom
operator|-=
operator|(
operator|(
name|drawRect
operator|.
name|y
operator|+
name|drawRect
operator|.
name|height
operator|)
operator|-
operator|(
name|scissor
operator|->
name|y
operator|+
name|scissor
operator|->
name|height
operator|)
operator|)
expr_stmt|;
block|}
block|}
comment|// D3D11 needs depth-stencil CopySubresourceRegions to have a NULL pSrcBox
comment|// We also require complete framebuffer copies for depth-stencil blit.
name|D3D11_BOX
modifier|*
name|pSrcBox
init|=
name|wholeBufferCopy
condition|?
name|NULL
else|:
operator|&
name|readBox
decl_stmt|;
name|mDeviceContext
operator|->
name|CopySubresourceRegion
argument_list|(
name|drawTexture
argument_list|,
name|drawSubresource
argument_list|,
name|dstX
argument_list|,
name|dstY
argument_list|,
literal|0
argument_list|,
name|readTexture
argument_list|,
name|readSubresource
argument_list|,
name|pSrcBox
argument_list|)
expr_stmt|;
name|result
operator|=
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gl
operator|::
name|Box
name|readArea
argument_list|(
name|readRect
operator|.
name|x
argument_list|,
name|readRect
operator|.
name|y
argument_list|,
literal|0
argument_list|,
name|readRect
operator|.
name|width
argument_list|,
name|readRect
operator|.
name|height
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Box
name|drawArea
argument_list|(
name|drawRect
operator|.
name|x
argument_list|,
name|drawRect
operator|.
name|y
argument_list|,
literal|0
argument_list|,
name|drawRect
operator|.
name|width
argument_list|,
name|drawRect
operator|.
name|height
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|depthBlit
operator|&&
name|stencilBlit
condition|)
block|{
name|result
operator|=
name|mBlit
operator|->
name|copyDepthStencil
argument_list|(
name|readTexture
argument_list|,
name|readSubresource
argument_list|,
name|readArea
argument_list|,
name|readSize
argument_list|,
name|drawTexture
argument_list|,
name|drawSubresource
argument_list|,
name|drawArea
argument_list|,
name|drawSize
argument_list|,
name|scissor
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|depthBlit
condition|)
block|{
name|result
operator|=
name|mBlit
operator|->
name|copyDepth
argument_list|(
name|readSRV
argument_list|,
name|readArea
argument_list|,
name|readSize
argument_list|,
name|drawDSV
argument_list|,
name|drawArea
argument_list|,
name|drawSize
argument_list|,
name|scissor
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stencilBlit
condition|)
block|{
name|result
operator|=
name|mBlit
operator|->
name|copyStencil
argument_list|(
name|readTexture
argument_list|,
name|readSubresource
argument_list|,
name|readArea
argument_list|,
name|readSize
argument_list|,
name|drawTexture
argument_list|,
name|drawSubresource
argument_list|,
name|drawArea
argument_list|,
name|drawSize
argument_list|,
name|scissor
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// We don't currently support masking off any other channel than alpha
name|bool
name|maskOffAlpha
init|=
name|colorMaskingNeeded
operator|&&
name|colorMask
operator|.
name|alpha
decl_stmt|;
name|result
operator|=
name|mBlit
operator|->
name|copyTexture
argument_list|(
name|readSRV
argument_list|,
name|readArea
argument_list|,
name|readSize
argument_list|,
name|drawRTV
argument_list|,
name|drawArea
argument_list|,
name|drawSize
argument_list|,
name|scissor
argument_list|,
name|destFormatInfo
operator|.
name|format
argument_list|,
name|filter
argument_list|,
name|maskOffAlpha
argument_list|)
expr_stmt|;
block|}
block|}
name|SafeRelease
argument_list|(
name|readTexture
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|readSRV
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
DECL|function|isES3Capable
name|bool
name|Renderer11
operator|::
name|isES3Capable
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|d3d11_gl
operator|::
name|GetMaximumClientVersion
argument_list|(
name|mRenderer11DeviceCaps
operator|.
name|featureLevel
argument_list|)
operator|>
literal|2
operator|)
return|;
block|}
empty_stmt|;
DECL|function|onSwap
name|void
name|Renderer11
operator|::
name|onSwap
parameter_list|()
block|{
comment|// Send histogram updates every half hour
specifier|const
name|double
name|kHistogramUpdateInterval
init|=
literal|30
operator|*
literal|60
decl_stmt|;
specifier|const
name|double
name|currentTime
init|=
name|ANGLEPlatformCurrent
argument_list|()
operator|->
name|monotonicallyIncreasingTime
argument_list|()
decl_stmt|;
specifier|const
name|double
name|timeSinceLastUpdate
init|=
name|currentTime
operator|-
name|mLastHistogramUpdateTime
decl_stmt|;
if|if
condition|(
name|timeSinceLastUpdate
operator|>
name|kHistogramUpdateInterval
condition|)
block|{
name|updateHistograms
argument_list|()
expr_stmt|;
name|mLastHistogramUpdateTime
operator|=
name|currentTime
expr_stmt|;
block|}
block|}
DECL|function|updateHistograms
name|void
name|Renderer11
operator|::
name|updateHistograms
parameter_list|()
block|{
comment|// Update the buffer CPU memory histogram
block|{
name|size_t
name|sizeSum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|auto
operator|&
name|buffer
operator|:
name|mAliveBuffers
control|)
block|{
name|sizeSum
operator|+=
name|buffer
operator|->
name|getTotalCPUBufferMemoryBytes
argument_list|()
expr_stmt|;
block|}
specifier|const
name|int
name|kOneMegaByte
init|=
literal|1024
operator|*
literal|1024
decl_stmt|;
name|ANGLE_HISTOGRAM_MEMORY_MB
argument_list|(
literal|"GPU.ANGLE.Buffer11CPUMemoryMB"
argument_list|,
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|sizeSum
argument_list|)
operator|/
name|kOneMegaByte
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|onBufferDelete
name|void
name|Renderer11
operator|::
name|onBufferDelete
parameter_list|(
specifier|const
name|Buffer11
modifier|*
name|deleted
parameter_list|)
block|{
name|mAliveBuffers
operator|.
name|erase
argument_list|(
name|deleted
argument_list|)
expr_stmt|;
block|}
DECL|function|resolveMultisampledTexture
name|ID3D11Texture2D
modifier|*
name|Renderer11
operator|::
name|resolveMultisampledTexture
parameter_list|(
name|ID3D11Texture2D
modifier|*
name|source
parameter_list|,
name|unsigned
name|int
name|subresource
parameter_list|)
block|{
name|D3D11_TEXTURE2D_DESC
name|textureDesc
decl_stmt|;
name|source
operator|->
name|GetDesc
argument_list|(
operator|&
name|textureDesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|textureDesc
operator|.
name|SampleDesc
operator|.
name|Count
operator|>
literal|1
condition|)
block|{
name|D3D11_TEXTURE2D_DESC
name|resolveDesc
decl_stmt|;
name|resolveDesc
operator|.
name|Width
operator|=
name|textureDesc
operator|.
name|Width
expr_stmt|;
name|resolveDesc
operator|.
name|Height
operator|=
name|textureDesc
operator|.
name|Height
expr_stmt|;
name|resolveDesc
operator|.
name|MipLevels
operator|=
literal|1
expr_stmt|;
name|resolveDesc
operator|.
name|ArraySize
operator|=
literal|1
expr_stmt|;
name|resolveDesc
operator|.
name|Format
operator|=
name|textureDesc
operator|.
name|Format
expr_stmt|;
name|resolveDesc
operator|.
name|SampleDesc
operator|.
name|Count
operator|=
literal|1
expr_stmt|;
name|resolveDesc
operator|.
name|SampleDesc
operator|.
name|Quality
operator|=
literal|0
expr_stmt|;
name|resolveDesc
operator|.
name|Usage
operator|=
name|textureDesc
operator|.
name|Usage
expr_stmt|;
name|resolveDesc
operator|.
name|BindFlags
operator|=
name|textureDesc
operator|.
name|BindFlags
expr_stmt|;
name|resolveDesc
operator|.
name|CPUAccessFlags
operator|=
literal|0
expr_stmt|;
name|resolveDesc
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|ID3D11Texture2D
modifier|*
name|resolveTexture
init|=
name|NULL
decl_stmt|;
name|HRESULT
name|result
init|=
name|mDevice
operator|->
name|CreateTexture2D
argument_list|(
operator|&
name|resolveDesc
argument_list|,
name|NULL
argument_list|,
operator|&
name|resolveTexture
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to create a multisample resolve texture, HRESULT: 0x%X."
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|mDeviceContext
operator|->
name|ResolveSubresource
argument_list|(
name|resolveTexture
argument_list|,
literal|0
argument_list|,
name|source
argument_list|,
name|subresource
argument_list|,
name|textureDesc
operator|.
name|Format
argument_list|)
expr_stmt|;
return|return
name|resolveTexture
return|;
block|}
else|else
block|{
name|source
operator|->
name|AddRef
argument_list|()
expr_stmt|;
return|return
name|source
return|;
block|}
block|}
DECL|function|getLUID
name|bool
name|Renderer11
operator|::
name|getLUID
parameter_list|(
name|LUID
modifier|*
name|adapterLuid
parameter_list|)
specifier|const
block|{
name|adapterLuid
operator|->
name|HighPart
operator|=
literal|0
expr_stmt|;
name|adapterLuid
operator|->
name|LowPart
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|mDxgiAdapter
condition|)
block|{
return|return
literal|false
return|;
block|}
name|DXGI_ADAPTER_DESC
name|adapterDesc
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|mDxgiAdapter
operator|->
name|GetDesc
argument_list|(
operator|&
name|adapterDesc
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
operator|*
name|adapterLuid
operator|=
name|adapterDesc
operator|.
name|AdapterLuid
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|getVertexConversionType
name|VertexConversionType
name|Renderer11
operator|::
name|getVertexConversionType
parameter_list|(
name|gl
operator|::
name|VertexFormatType
name|vertexFormatType
parameter_list|)
specifier|const
block|{
return|return
name|d3d11
operator|::
name|GetVertexFormatInfo
argument_list|(
name|vertexFormatType
argument_list|,
name|mRenderer11DeviceCaps
operator|.
name|featureLevel
argument_list|)
operator|.
name|conversionType
return|;
block|}
DECL|function|getVertexComponentType
name|GLenum
name|Renderer11
operator|::
name|getVertexComponentType
parameter_list|(
name|gl
operator|::
name|VertexFormatType
name|vertexFormatType
parameter_list|)
specifier|const
block|{
return|return
name|d3d11
operator|::
name|GetDXGIFormatInfo
argument_list|(
name|d3d11
operator|::
name|GetVertexFormatInfo
argument_list|(
name|vertexFormatType
argument_list|,
name|mRenderer11DeviceCaps
operator|.
name|featureLevel
argument_list|)
operator|.
name|nativeFormat
argument_list|)
operator|.
name|componentType
return|;
block|}
DECL|function|generateCaps
name|void
name|Renderer11
operator|::
name|generateCaps
parameter_list|(
name|gl
operator|::
name|Caps
modifier|*
name|outCaps
parameter_list|,
name|gl
operator|::
name|TextureCapsMap
modifier|*
name|outTextureCaps
parameter_list|,
name|gl
operator|::
name|Extensions
modifier|*
name|outExtensions
parameter_list|,
name|gl
operator|::
name|Limitations
modifier|*
name|outLimitations
parameter_list|)
specifier|const
block|{
name|d3d11_gl
operator|::
name|GenerateCaps
argument_list|(
name|mDevice
argument_list|,
name|mDeviceContext
argument_list|,
name|mRenderer11DeviceCaps
argument_list|,
name|outCaps
argument_list|,
name|outTextureCaps
argument_list|,
name|outExtensions
argument_list|,
name|outLimitations
argument_list|)
expr_stmt|;
block|}
DECL|function|generateWorkarounds
name|WorkaroundsD3D
name|Renderer11
operator|::
name|generateWorkarounds
parameter_list|()
specifier|const
block|{
return|return
name|d3d11
operator|::
name|GenerateWorkarounds
argument_list|(
name|mRenderer11DeviceCaps
operator|.
name|featureLevel
argument_list|)
return|;
block|}
DECL|function|createAnnotator
name|void
name|Renderer11
operator|::
name|createAnnotator
parameter_list|()
block|{
comment|// The D3D11 renderer must choose the D3D9 debug annotator because the D3D11 interface
comment|// method ID3DUserDefinedAnnotation::GetStatus on desktop builds doesn't work with the Graphics
comment|// Diagnostics tools in Visual Studio 2013.
comment|// The D3D9 annotator works properly for both D3D11 and D3D9.
comment|// Incorrect status reporting can cause ANGLE to log unnecessary debug events.
ifdef|#
directive|ifdef
name|ANGLE_ENABLE_D3D9
name|mAnnotator
operator|=
operator|new
name|DebugAnnotator9
argument_list|()
expr_stmt|;
else|#
directive|else
name|mAnnotator
operator|=
operator|new
name|DebugAnnotator11
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
DECL|function|clearTextures
name|gl
operator|::
name|Error
name|Renderer11
operator|::
name|clearTextures
parameter_list|(
name|gl
operator|::
name|SamplerType
name|samplerType
parameter_list|,
name|size_t
name|rangeStart
parameter_list|,
name|size_t
name|rangeEnd
parameter_list|)
block|{
return|return
name|mStateManager
operator|.
name|clearTextures
argument_list|(
name|samplerType
argument_list|,
name|rangeStart
argument_list|,
name|rangeEnd
argument_list|)
return|;
block|}
DECL|function|getEGLDevice
name|egl
operator|::
name|Error
name|Renderer11
operator|::
name|getEGLDevice
parameter_list|(
name|DeviceImpl
modifier|*
modifier|*
name|device
parameter_list|)
block|{
if|if
condition|(
name|mEGLDevice
operator|==
literal|nullptr
condition|)
block|{
name|ASSERT
argument_list|(
name|mDevice
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
name|mEGLDevice
operator|=
operator|new
name|DeviceD3D
argument_list|()
expr_stmt|;
name|egl
operator|::
name|Error
name|error
init|=
name|mEGLDevice
operator|->
name|initialize
argument_list|(
cast|reinterpret_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
name|mDevice
argument_list|)
argument_list|,
name|EGL_D3D11_DEVICE_ANGLE
argument_list|,
name|EGL_FALSE
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
name|SafeDelete
argument_list|(
name|mEGLDevice
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
operator|*
name|device
operator|=
cast|static_cast
argument_list|<
name|DeviceImpl
operator|*
argument_list|>
argument_list|(
name|mEGLDevice
argument_list|)
expr_stmt|;
return|return
name|egl
operator|::
name|Error
argument_list|(
name|EGL_SUCCESS
argument_list|)
return|;
block|}
block|}
end_namespace
end_unit
