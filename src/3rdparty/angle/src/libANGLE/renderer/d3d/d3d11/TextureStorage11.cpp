begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2012-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// TextureStorage11.cpp: Implements the abstract rx::TextureStorage11 class and its concrete derived
end_comment
begin_comment
comment|// classes TextureStorage11_2D and TextureStorage11_Cube, which act as the interface to the D3D11 texture.
end_comment
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/TextureStorage11.h"
end_include
begin_include
include|#
directive|include
file|<tuple>
end_include
begin_include
include|#
directive|include
file|"common/MemoryBuffer.h"
end_include
begin_include
include|#
directive|include
file|"common/utilities.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/ImageIndex.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/formatutils.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/TextureD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/Blit11.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/Image11.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/RenderTarget11.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/Renderer11.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/SwapChain11.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/formatutils11.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/renderer11_utils.h"
end_include
begin_namespace
DECL|namespace|rx
namespace|namespace
name|rx
block|{
DECL|function|SwizzleCacheValue
name|TextureStorage11
operator|::
name|SwizzleCacheValue
operator|::
name|SwizzleCacheValue
parameter_list|()
member_init_list|:
name|swizzleRed
argument_list|(
name|GL_NONE
argument_list|)
member_init_list|,
name|swizzleGreen
argument_list|(
name|GL_NONE
argument_list|)
member_init_list|,
name|swizzleBlue
argument_list|(
name|GL_NONE
argument_list|)
member_init_list|,
name|swizzleAlpha
argument_list|(
name|GL_NONE
argument_list|)
block|{ }
DECL|function|SwizzleCacheValue
name|TextureStorage11
operator|::
name|SwizzleCacheValue
operator|::
name|SwizzleCacheValue
parameter_list|(
name|GLenum
name|red
parameter_list|,
name|GLenum
name|green
parameter_list|,
name|GLenum
name|blue
parameter_list|,
name|GLenum
name|alpha
parameter_list|)
member_init_list|:
name|swizzleRed
argument_list|(
name|red
argument_list|)
member_init_list|,
name|swizzleGreen
argument_list|(
name|green
argument_list|)
member_init_list|,
name|swizzleBlue
argument_list|(
name|blue
argument_list|)
member_init_list|,
name|swizzleAlpha
argument_list|(
name|alpha
argument_list|)
block|{ }
DECL|function|operator ==
name|bool
name|TextureStorage11
operator|::
name|SwizzleCacheValue
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|SwizzleCacheValue
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
name|swizzleRed
operator|==
name|other
operator|.
name|swizzleRed
operator|&&
name|swizzleGreen
operator|==
name|other
operator|.
name|swizzleGreen
operator|&&
name|swizzleBlue
operator|==
name|other
operator|.
name|swizzleBlue
operator|&&
name|swizzleAlpha
operator|==
name|other
operator|.
name|swizzleAlpha
return|;
block|}
DECL|function|operator !=
name|bool
name|TextureStorage11
operator|::
name|SwizzleCacheValue
operator|::
name|operator
name|!=
parameter_list|(
specifier|const
name|SwizzleCacheValue
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|other
operator|)
return|;
block|}
DECL|function|SRVKey
name|TextureStorage11
operator|::
name|SRVKey
operator|::
name|SRVKey
parameter_list|(
name|int
name|baseLevel
parameter_list|,
name|int
name|mipLevels
parameter_list|,
name|bool
name|swizzle
parameter_list|)
member_init_list|:
name|baseLevel
argument_list|(
name|baseLevel
argument_list|)
member_init_list|,
name|mipLevels
argument_list|(
name|mipLevels
argument_list|)
member_init_list|,
name|swizzle
argument_list|(
name|swizzle
argument_list|)
block|{ }
DECL|function|operator <
name|bool
name|TextureStorage11
operator|::
name|SRVKey
operator|::
name|operator
name|<
parameter_list|(
specifier|const
name|SRVKey
modifier|&
name|rhs
parameter_list|)
specifier|const
block|{
return|return
name|std
operator|::
name|tie
argument_list|(
name|baseLevel
argument_list|,
name|mipLevels
argument_list|,
name|swizzle
argument_list|)
operator|<
name|std
operator|::
name|tie
argument_list|(
name|rhs
operator|.
name|baseLevel
argument_list|,
name|rhs
operator|.
name|mipLevels
argument_list|,
name|rhs
operator|.
name|swizzle
argument_list|)
return|;
block|}
DECL|function|TextureStorage11
name|TextureStorage11
operator|::
name|TextureStorage11
parameter_list|(
name|Renderer11
modifier|*
name|renderer
parameter_list|,
name|UINT
name|bindFlags
parameter_list|)
member_init_list|:
name|mBindFlags
argument_list|(
name|bindFlags
argument_list|)
member_init_list|,
name|mTopLevel
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mMipLevels
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mInternalFormat
argument_list|(
name|GL_NONE
argument_list|)
member_init_list|,
name|mTextureFormat
argument_list|(
name|DXGI_FORMAT_UNKNOWN
argument_list|)
member_init_list|,
name|mShaderResourceFormat
argument_list|(
name|DXGI_FORMAT_UNKNOWN
argument_list|)
member_init_list|,
name|mRenderTargetFormat
argument_list|(
name|DXGI_FORMAT_UNKNOWN
argument_list|)
member_init_list|,
name|mDepthStencilFormat
argument_list|(
name|DXGI_FORMAT_UNKNOWN
argument_list|)
member_init_list|,
name|mTextureWidth
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mTextureHeight
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mTextureDepth
argument_list|(
literal|0
argument_list|)
block|{
name|mRenderer
operator|=
name|Renderer11
operator|::
name|makeRenderer11
argument_list|(
name|renderer
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|i
operator|++
control|)
block|{
name|mLevelSRVs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
DECL|function|~TextureStorage11
name|TextureStorage11
operator|::
name|~
name|TextureStorage11
parameter_list|()
block|{
for|for
control|(
name|unsigned
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|level
operator|++
control|)
block|{
name|SafeRelease
argument_list|(
name|mLevelSRVs
index|[
name|level
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|SRVCache
operator|::
name|iterator
name|i
init|=
name|mSrvCache
operator|.
name|begin
argument_list|()
init|;
name|i
operator|!=
name|mSrvCache
operator|.
name|end
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|SafeRelease
argument_list|(
name|i
operator|->
name|second
argument_list|)
expr_stmt|;
block|}
name|mSrvCache
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|function|makeTextureStorage11
name|TextureStorage11
modifier|*
name|TextureStorage11
operator|::
name|makeTextureStorage11
parameter_list|(
name|TextureStorage
modifier|*
name|storage
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|HAS_DYNAMIC_TYPE
argument_list|(
name|TextureStorage11
operator|*
argument_list|,
name|storage
argument_list|)
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|TextureStorage11
operator|*
argument_list|>
argument_list|(
name|storage
argument_list|)
return|;
block|}
DECL|function|GetTextureBindFlags
name|DWORD
name|TextureStorage11
operator|::
name|GetTextureBindFlags
parameter_list|(
name|GLenum
name|internalFormat
parameter_list|,
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|,
name|bool
name|renderTarget
parameter_list|)
block|{
name|UINT
name|bindFlags
init|=
literal|0
decl_stmt|;
specifier|const
name|d3d11
operator|::
name|TextureFormat
modifier|&
name|formatInfo
init|=
name|d3d11
operator|::
name|GetTextureFormatInfo
argument_list|(
name|internalFormat
argument_list|,
name|featureLevel
argument_list|)
decl_stmt|;
if|if
condition|(
name|formatInfo
operator|.
name|srvFormat
operator|!=
name|DXGI_FORMAT_UNKNOWN
condition|)
block|{
name|bindFlags
operator||=
name|D3D11_BIND_SHADER_RESOURCE
expr_stmt|;
block|}
if|if
condition|(
name|formatInfo
operator|.
name|dsvFormat
operator|!=
name|DXGI_FORMAT_UNKNOWN
condition|)
block|{
name|bindFlags
operator||=
name|D3D11_BIND_DEPTH_STENCIL
expr_stmt|;
block|}
if|if
condition|(
name|formatInfo
operator|.
name|rtvFormat
operator|!=
name|DXGI_FORMAT_UNKNOWN
operator|&&
name|renderTarget
condition|)
block|{
name|bindFlags
operator||=
name|D3D11_BIND_RENDER_TARGET
expr_stmt|;
block|}
return|return
name|bindFlags
return|;
block|}
DECL|function|getBindFlags
name|UINT
name|TextureStorage11
operator|::
name|getBindFlags
parameter_list|()
specifier|const
block|{
return|return
name|mBindFlags
return|;
block|}
DECL|function|getTopLevel
name|int
name|TextureStorage11
operator|::
name|getTopLevel
parameter_list|()
specifier|const
block|{
return|return
name|mTopLevel
return|;
block|}
DECL|function|isRenderTarget
name|bool
name|TextureStorage11
operator|::
name|isRenderTarget
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|mBindFlags
operator|&
operator|(
name|D3D11_BIND_RENDER_TARGET
operator||
name|D3D11_BIND_DEPTH_STENCIL
operator|)
operator|)
operator|!=
literal|0
return|;
block|}
DECL|function|isManaged
name|bool
name|TextureStorage11
operator|::
name|isManaged
parameter_list|()
specifier|const
block|{
return|return
literal|false
return|;
block|}
DECL|function|getLevelCount
name|int
name|TextureStorage11
operator|::
name|getLevelCount
parameter_list|()
specifier|const
block|{
return|return
name|mMipLevels
operator|-
name|mTopLevel
return|;
block|}
DECL|function|getLevelWidth
name|int
name|TextureStorage11
operator|::
name|getLevelWidth
parameter_list|(
name|int
name|mipLevel
parameter_list|)
specifier|const
block|{
return|return
name|std
operator|::
name|max
argument_list|(
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|mTextureWidth
argument_list|)
operator|>>
name|mipLevel
argument_list|,
literal|1
argument_list|)
return|;
block|}
DECL|function|getLevelHeight
name|int
name|TextureStorage11
operator|::
name|getLevelHeight
parameter_list|(
name|int
name|mipLevel
parameter_list|)
specifier|const
block|{
return|return
name|std
operator|::
name|max
argument_list|(
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|mTextureHeight
argument_list|)
operator|>>
name|mipLevel
argument_list|,
literal|1
argument_list|)
return|;
block|}
DECL|function|getLevelDepth
name|int
name|TextureStorage11
operator|::
name|getLevelDepth
parameter_list|(
name|int
name|mipLevel
parameter_list|)
specifier|const
block|{
return|return
name|std
operator|::
name|max
argument_list|(
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|mTextureDepth
argument_list|)
operator|>>
name|mipLevel
argument_list|,
literal|1
argument_list|)
return|;
block|}
DECL|function|getSubresourceIndex
name|UINT
name|TextureStorage11
operator|::
name|getSubresourceIndex
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
name|UINT
name|mipSlice
init|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|index
operator|.
name|mipIndex
operator|+
name|mTopLevel
argument_list|)
decl_stmt|;
name|UINT
name|arraySlice
init|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|index
operator|.
name|hasLayer
argument_list|()
condition|?
name|index
operator|.
name|layerIndex
else|:
literal|0
argument_list|)
decl_stmt|;
name|UINT
name|subresource
init|=
name|D3D11CalcSubresource
argument_list|(
name|mipSlice
argument_list|,
name|arraySlice
argument_list|,
name|mMipLevels
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|subresource
operator|!=
name|std
operator|::
name|numeric_limits
argument_list|<
name|UINT
argument_list|>
operator|::
name|max
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|subresource
return|;
block|}
DECL|function|getSRV
name|gl
operator|::
name|Error
name|TextureStorage11
operator|::
name|getSRV
parameter_list|(
specifier|const
name|gl
operator|::
name|SamplerState
modifier|&
name|samplerState
parameter_list|,
name|ID3D11ShaderResourceView
modifier|*
modifier|*
name|outSRV
parameter_list|)
block|{
name|bool
name|swizzleRequired
init|=
name|samplerState
operator|.
name|swizzleRequired
argument_list|()
decl_stmt|;
name|bool
name|mipmapping
init|=
name|gl
operator|::
name|IsMipmapFiltered
argument_list|(
name|samplerState
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|mipLevels
init|=
name|mipmapping
condition|?
operator|(
name|samplerState
operator|.
name|maxLevel
operator|-
name|samplerState
operator|.
name|baseLevel
operator|+
literal|1
operator|)
else|:
literal|1
decl_stmt|;
comment|// Make sure there's 'mipLevels' mipmap levels below the base level (offset by the top level,  which corresponds to GL level 0)
name|mipLevels
operator|=
name|std
operator|::
name|min
argument_list|(
name|mipLevels
argument_list|,
name|mMipLevels
operator|-
name|mTopLevel
operator|-
name|samplerState
operator|.
name|baseLevel
argument_list|)
expr_stmt|;
if|if
condition|(
name|mRenderer
operator|->
name|getFeatureLevel
argument_list|()
operator|<=
name|D3D_FEATURE_LEVEL_9_3
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|swizzleRequired
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mipLevels
operator|==
literal|1
operator|||
name|mipLevels
operator|==
name|mMipLevels
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mRenderer
operator|->
name|getWorkarounds
argument_list|()
operator|.
name|zeroMaxLodWorkaround
condition|)
block|{
comment|// We must ensure that the level zero texture is in sync with mipped texture.
name|gl
operator|::
name|Error
name|error
init|=
name|useLevelZeroWorkaroundTexture
argument_list|(
name|mipLevels
operator|==
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
if|if
condition|(
name|swizzleRequired
condition|)
block|{
name|verifySwizzleExists
argument_list|(
name|samplerState
operator|.
name|swizzleRed
argument_list|,
name|samplerState
operator|.
name|swizzleGreen
argument_list|,
name|samplerState
operator|.
name|swizzleBlue
argument_list|,
name|samplerState
operator|.
name|swizzleAlpha
argument_list|)
expr_stmt|;
block|}
name|SRVKey
name|key
argument_list|(
name|samplerState
operator|.
name|baseLevel
argument_list|,
name|mipLevels
argument_list|,
name|swizzleRequired
argument_list|)
decl_stmt|;
name|SRVCache
operator|::
name|const_iterator
name|iter
init|=
name|mSrvCache
operator|.
name|find
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|iter
operator|!=
name|mSrvCache
operator|.
name|end
argument_list|()
condition|)
block|{
operator|*
name|outSRV
operator|=
name|iter
operator|->
name|second
expr_stmt|;
block|}
else|else
block|{
name|ID3D11Resource
modifier|*
name|texture
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|swizzleRequired
condition|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|getSwizzleTexture
argument_list|(
operator|&
name|texture
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
else|else
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|getResource
argument_list|(
operator|&
name|texture
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
name|ID3D11ShaderResourceView
modifier|*
name|srv
init|=
name|NULL
decl_stmt|;
name|DXGI_FORMAT
name|format
init|=
operator|(
name|swizzleRequired
condition|?
name|mSwizzleShaderResourceFormat
else|:
name|mShaderResourceFormat
operator|)
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|createSRV
argument_list|(
name|samplerState
operator|.
name|baseLevel
argument_list|,
name|mipLevels
argument_list|,
name|format
argument_list|,
name|texture
argument_list|,
operator|&
name|srv
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|mSrvCache
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|key
argument_list|,
name|srv
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|outSRV
operator|=
name|srv
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|getSRVLevel
name|gl
operator|::
name|Error
name|TextureStorage11
operator|::
name|getSRVLevel
parameter_list|(
name|int
name|mipLevel
parameter_list|,
name|ID3D11ShaderResourceView
modifier|*
modifier|*
name|outSRV
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|mipLevel
operator|>=
literal|0
operator|&&
name|mipLevel
operator|<
name|getLevelCount
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mLevelSRVs
index|[
name|mipLevel
index|]
condition|)
block|{
name|ID3D11Resource
modifier|*
name|resource
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|getResource
argument_list|(
operator|&
name|resource
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|createSRV
argument_list|(
name|mipLevel
argument_list|,
literal|1
argument_list|,
name|mShaderResourceFormat
argument_list|,
name|resource
argument_list|,
operator|&
name|mLevelSRVs
index|[
name|mipLevel
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
operator|*
name|outSRV
operator|=
name|mLevelSRVs
index|[
name|mipLevel
index|]
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|generateSwizzles
name|gl
operator|::
name|Error
name|TextureStorage11
operator|::
name|generateSwizzles
parameter_list|(
name|GLenum
name|swizzleRed
parameter_list|,
name|GLenum
name|swizzleGreen
parameter_list|,
name|GLenum
name|swizzleBlue
parameter_list|,
name|GLenum
name|swizzleAlpha
parameter_list|)
block|{
name|SwizzleCacheValue
name|swizzleTarget
argument_list|(
name|swizzleRed
argument_list|,
name|swizzleGreen
argument_list|,
name|swizzleBlue
argument_list|,
name|swizzleAlpha
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|getLevelCount
argument_list|()
condition|;
name|level
operator|++
control|)
block|{
comment|// Check if the swizzle for this level is out of date
if|if
condition|(
name|mSwizzleCache
index|[
name|level
index|]
operator|!=
name|swizzleTarget
condition|)
block|{
comment|// Need to re-render the swizzle for this level
name|ID3D11ShaderResourceView
modifier|*
name|sourceSRV
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|getSRVLevel
argument_list|(
name|level
argument_list|,
operator|&
name|sourceSRV
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ID3D11RenderTargetView
modifier|*
name|destRTV
init|=
name|NULL
decl_stmt|;
name|error
operator|=
name|getSwizzleRenderTarget
argument_list|(
name|level
argument_list|,
operator|&
name|destRTV
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|gl
operator|::
name|Extents
name|size
argument_list|(
name|getLevelWidth
argument_list|(
name|level
argument_list|)
argument_list|,
name|getLevelHeight
argument_list|(
name|level
argument_list|)
argument_list|,
name|getLevelDepth
argument_list|(
name|level
argument_list|)
argument_list|)
decl_stmt|;
name|Blit11
modifier|*
name|blitter
init|=
name|mRenderer
operator|->
name|getBlitter
argument_list|()
decl_stmt|;
name|error
operator|=
name|blitter
operator|->
name|swizzleTexture
argument_list|(
name|sourceSRV
argument_list|,
name|destRTV
argument_list|,
name|size
argument_list|,
name|swizzleRed
argument_list|,
name|swizzleGreen
argument_list|,
name|swizzleBlue
argument_list|,
name|swizzleAlpha
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|mSwizzleCache
index|[
name|level
index|]
operator|=
name|swizzleTarget
expr_stmt|;
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|invalidateSwizzleCacheLevel
name|void
name|TextureStorage11
operator|::
name|invalidateSwizzleCacheLevel
parameter_list|(
name|int
name|mipLevel
parameter_list|)
block|{
if|if
condition|(
name|mipLevel
operator|>=
literal|0
operator|&&
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|mipLevel
argument_list|)
operator|<
name|ArraySize
argument_list|(
name|mSwizzleCache
argument_list|)
condition|)
block|{
comment|// The default constructor of SwizzleCacheValue has GL_NONE for all channels which is not a
comment|// valid swizzle combination
name|mSwizzleCache
index|[
name|mipLevel
index|]
operator|=
name|SwizzleCacheValue
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|invalidateSwizzleCache
name|void
name|TextureStorage11
operator|::
name|invalidateSwizzleCache
parameter_list|()
block|{
for|for
control|(
name|unsigned
name|int
name|mipLevel
init|=
literal|0
init|;
name|mipLevel
operator|<
name|ArraySize
argument_list|(
name|mSwizzleCache
argument_list|)
condition|;
name|mipLevel
operator|++
control|)
block|{
name|invalidateSwizzleCacheLevel
argument_list|(
name|mipLevel
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|updateSubresourceLevel
name|gl
operator|::
name|Error
name|TextureStorage11
operator|::
name|updateSubresourceLevel
parameter_list|(
name|ID3D11Resource
modifier|*
name|srcTexture
parameter_list|,
name|unsigned
name|int
name|sourceSubresource
parameter_list|,
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|,
specifier|const
name|gl
operator|::
name|Box
modifier|&
name|copyArea
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|srcTexture
argument_list|)
expr_stmt|;
name|GLint
name|level
init|=
name|index
operator|.
name|mipIndex
decl_stmt|;
name|invalidateSwizzleCacheLevel
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|gl
operator|::
name|Extents
name|texSize
argument_list|(
name|getLevelWidth
argument_list|(
name|level
argument_list|)
argument_list|,
name|getLevelHeight
argument_list|(
name|level
argument_list|)
argument_list|,
name|getLevelDepth
argument_list|(
name|level
argument_list|)
argument_list|)
decl_stmt|;
name|bool
name|fullCopy
init|=
name|copyArea
operator|.
name|x
operator|==
literal|0
operator|&&
name|copyArea
operator|.
name|y
operator|==
literal|0
operator|&&
name|copyArea
operator|.
name|z
operator|==
literal|0
operator|&&
name|copyArea
operator|.
name|width
operator|==
name|texSize
operator|.
name|width
operator|&&
name|copyArea
operator|.
name|height
operator|==
name|texSize
operator|.
name|height
operator|&&
name|copyArea
operator|.
name|depth
operator|==
name|texSize
operator|.
name|depth
decl_stmt|;
name|ID3D11Resource
modifier|*
name|dstTexture
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
argument_list|(
name|GL_NO_ERROR
argument_list|)
decl_stmt|;
comment|// If the zero-LOD workaround is active and we want to update a level greater than zero, then we should
comment|// update the mipmapped texture, even if mapmaps are currently disabled.
if|if
condition|(
name|index
operator|.
name|mipIndex
operator|>
literal|0
operator|&&
name|mRenderer
operator|->
name|getWorkarounds
argument_list|()
operator|.
name|zeroMaxLodWorkaround
condition|)
block|{
name|error
operator|=
name|getMippedResource
argument_list|(
operator|&
name|dstTexture
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|getResource
argument_list|(
operator|&
name|dstTexture
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|unsigned
name|int
name|dstSubresource
init|=
name|getSubresourceIndex
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|dstTexture
argument_list|)
expr_stmt|;
specifier|const
name|d3d11
operator|::
name|DXGIFormat
modifier|&
name|dxgiFormatInfo
init|=
name|d3d11
operator|::
name|GetDXGIFormatInfo
argument_list|(
name|mTextureFormat
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fullCopy
operator|&&
operator|(
name|dxgiFormatInfo
operator|.
name|depthBits
operator|>
literal|0
operator|||
name|dxgiFormatInfo
operator|.
name|stencilBits
operator|>
literal|0
operator|)
condition|)
block|{
comment|// CopySubresourceRegion cannot copy partial depth stencils, use the blitter instead
name|Blit11
modifier|*
name|blitter
init|=
name|mRenderer
operator|->
name|getBlitter
argument_list|()
decl_stmt|;
return|return
name|blitter
operator|->
name|copyDepthStencil
argument_list|(
name|srcTexture
argument_list|,
name|sourceSubresource
argument_list|,
name|copyArea
argument_list|,
name|texSize
argument_list|,
name|dstTexture
argument_list|,
name|dstSubresource
argument_list|,
name|copyArea
argument_list|,
name|texSize
argument_list|,
name|NULL
argument_list|)
return|;
block|}
else|else
block|{
name|D3D11_BOX
name|srcBox
decl_stmt|;
name|srcBox
operator|.
name|left
operator|=
name|copyArea
operator|.
name|x
expr_stmt|;
name|srcBox
operator|.
name|top
operator|=
name|copyArea
operator|.
name|y
expr_stmt|;
name|srcBox
operator|.
name|right
operator|=
name|copyArea
operator|.
name|x
operator|+
name|roundUp
argument_list|(
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|copyArea
operator|.
name|width
argument_list|)
argument_list|,
name|dxgiFormatInfo
operator|.
name|blockWidth
argument_list|)
expr_stmt|;
name|srcBox
operator|.
name|bottom
operator|=
name|copyArea
operator|.
name|y
operator|+
name|roundUp
argument_list|(
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|copyArea
operator|.
name|height
argument_list|)
argument_list|,
name|dxgiFormatInfo
operator|.
name|blockHeight
argument_list|)
expr_stmt|;
name|srcBox
operator|.
name|front
operator|=
name|copyArea
operator|.
name|z
expr_stmt|;
name|srcBox
operator|.
name|back
operator|=
name|copyArea
operator|.
name|z
operator|+
name|copyArea
operator|.
name|depth
expr_stmt|;
name|ID3D11DeviceContext
modifier|*
name|context
init|=
name|mRenderer
operator|->
name|getDeviceContext
argument_list|()
decl_stmt|;
name|context
operator|->
name|CopySubresourceRegion
argument_list|(
name|dstTexture
argument_list|,
name|dstSubresource
argument_list|,
name|copyArea
operator|.
name|x
argument_list|,
name|copyArea
operator|.
name|y
argument_list|,
name|copyArea
operator|.
name|z
argument_list|,
name|srcTexture
argument_list|,
name|sourceSubresource
argument_list|,
name|fullCopy
condition|?
name|NULL
else|:
operator|&
name|srcBox
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
block|}
DECL|function|copySubresourceLevel
name|gl
operator|::
name|Error
name|TextureStorage11
operator|::
name|copySubresourceLevel
parameter_list|(
name|ID3D11Resource
modifier|*
name|dstTexture
parameter_list|,
name|unsigned
name|int
name|dstSubresource
parameter_list|,
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|,
specifier|const
name|gl
operator|::
name|Box
modifier|&
name|region
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|dstTexture
argument_list|)
expr_stmt|;
name|ID3D11Resource
modifier|*
name|srcTexture
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
argument_list|(
name|GL_NO_ERROR
argument_list|)
decl_stmt|;
comment|// If the zero-LOD workaround is active and we want to update a level greater than zero, then we should
comment|// update the mipmapped texture, even if mapmaps are currently disabled.
if|if
condition|(
name|index
operator|.
name|mipIndex
operator|>
literal|0
operator|&&
name|mRenderer
operator|->
name|getWorkarounds
argument_list|()
operator|.
name|zeroMaxLodWorkaround
condition|)
block|{
name|error
operator|=
name|getMippedResource
argument_list|(
operator|&
name|srcTexture
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|getResource
argument_list|(
operator|&
name|srcTexture
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|srcTexture
argument_list|)
expr_stmt|;
name|unsigned
name|int
name|srcSubresource
init|=
name|getSubresourceIndex
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|ID3D11DeviceContext
modifier|*
name|context
init|=
name|mRenderer
operator|->
name|getDeviceContext
argument_list|()
decl_stmt|;
comment|// D3D11 can't perform partial CopySubresourceRegion on depth/stencil textures, so pSrcBox should be NULL.
name|D3D11_BOX
name|srcBox
decl_stmt|;
name|D3D11_BOX
modifier|*
name|pSrcBox
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|mRenderer
operator|->
name|getFeatureLevel
argument_list|()
operator|<=
name|D3D_FEATURE_LEVEL_9_3
condition|)
block|{
comment|// However, D3D10Level9 doesn't always perform CopySubresourceRegion correctly unless the source box
comment|// is specified. This is okay, since we don't perform CopySubresourceRegion on depth/stencil
comment|// textures on 9_3.
name|ASSERT
argument_list|(
name|d3d11
operator|::
name|GetDXGIFormatInfo
argument_list|(
name|mTextureFormat
argument_list|)
operator|.
name|depthBits
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|d3d11
operator|::
name|GetDXGIFormatInfo
argument_list|(
name|mTextureFormat
argument_list|)
operator|.
name|stencilBits
operator|==
literal|0
argument_list|)
expr_stmt|;
name|srcBox
operator|.
name|left
operator|=
name|region
operator|.
name|x
expr_stmt|;
name|srcBox
operator|.
name|right
operator|=
name|region
operator|.
name|x
operator|+
name|region
operator|.
name|width
expr_stmt|;
name|srcBox
operator|.
name|top
operator|=
name|region
operator|.
name|y
expr_stmt|;
name|srcBox
operator|.
name|bottom
operator|=
name|region
operator|.
name|y
operator|+
name|region
operator|.
name|height
expr_stmt|;
name|srcBox
operator|.
name|front
operator|=
name|region
operator|.
name|z
expr_stmt|;
name|srcBox
operator|.
name|back
operator|=
name|region
operator|.
name|z
operator|+
name|region
operator|.
name|depth
expr_stmt|;
name|pSrcBox
operator|=
operator|&
name|srcBox
expr_stmt|;
block|}
name|context
operator|->
name|CopySubresourceRegion
argument_list|(
name|dstTexture
argument_list|,
name|dstSubresource
argument_list|,
name|region
operator|.
name|x
argument_list|,
name|region
operator|.
name|y
argument_list|,
name|region
operator|.
name|z
argument_list|,
name|srcTexture
argument_list|,
name|srcSubresource
argument_list|,
name|pSrcBox
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|generateMipmap
name|gl
operator|::
name|Error
name|TextureStorage11
operator|::
name|generateMipmap
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|sourceIndex
parameter_list|,
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|destIndex
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|sourceIndex
operator|.
name|layerIndex
operator|==
name|destIndex
operator|.
name|layerIndex
argument_list|)
expr_stmt|;
name|invalidateSwizzleCacheLevel
argument_list|(
name|destIndex
operator|.
name|mipIndex
argument_list|)
expr_stmt|;
name|RenderTargetD3D
modifier|*
name|source
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|getRenderTarget
argument_list|(
name|sourceIndex
argument_list|,
operator|&
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|RenderTargetD3D
modifier|*
name|dest
init|=
name|NULL
decl_stmt|;
name|error
operator|=
name|getRenderTarget
argument_list|(
name|destIndex
argument_list|,
operator|&
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ID3D11ShaderResourceView
modifier|*
name|sourceSRV
init|=
name|RenderTarget11
operator|::
name|makeRenderTarget11
argument_list|(
name|source
argument_list|)
operator|->
name|getShaderResourceView
argument_list|()
decl_stmt|;
name|ID3D11RenderTargetView
modifier|*
name|destRTV
init|=
name|RenderTarget11
operator|::
name|makeRenderTarget11
argument_list|(
name|dest
argument_list|)
operator|->
name|getRenderTargetView
argument_list|()
decl_stmt|;
name|gl
operator|::
name|Box
name|sourceArea
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|source
operator|->
name|getWidth
argument_list|()
argument_list|,
name|source
operator|->
name|getHeight
argument_list|()
argument_list|,
name|source
operator|->
name|getDepth
argument_list|()
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Extents
name|sourceSize
argument_list|(
name|source
operator|->
name|getWidth
argument_list|()
argument_list|,
name|source
operator|->
name|getHeight
argument_list|()
argument_list|,
name|source
operator|->
name|getDepth
argument_list|()
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Box
name|destArea
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dest
operator|->
name|getWidth
argument_list|()
argument_list|,
name|dest
operator|->
name|getHeight
argument_list|()
argument_list|,
name|dest
operator|->
name|getDepth
argument_list|()
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Extents
name|destSize
argument_list|(
name|dest
operator|->
name|getWidth
argument_list|()
argument_list|,
name|dest
operator|->
name|getHeight
argument_list|()
argument_list|,
name|dest
operator|->
name|getDepth
argument_list|()
argument_list|)
decl_stmt|;
name|Blit11
modifier|*
name|blitter
init|=
name|mRenderer
operator|->
name|getBlitter
argument_list|()
decl_stmt|;
return|return
name|blitter
operator|->
name|copyTexture
argument_list|(
name|sourceSRV
argument_list|,
name|sourceArea
argument_list|,
name|sourceSize
argument_list|,
name|destRTV
argument_list|,
name|destArea
argument_list|,
name|destSize
argument_list|,
name|NULL
argument_list|,
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|source
operator|->
name|getInternalFormat
argument_list|()
argument_list|)
operator|.
name|format
argument_list|,
name|GL_LINEAR
argument_list|)
return|;
block|}
DECL|function|verifySwizzleExists
name|void
name|TextureStorage11
operator|::
name|verifySwizzleExists
parameter_list|(
name|GLenum
name|swizzleRed
parameter_list|,
name|GLenum
name|swizzleGreen
parameter_list|,
name|GLenum
name|swizzleBlue
parameter_list|,
name|GLenum
name|swizzleAlpha
parameter_list|)
block|{
name|SwizzleCacheValue
name|swizzleTarget
argument_list|(
name|swizzleRed
argument_list|,
name|swizzleGreen
argument_list|,
name|swizzleBlue
argument_list|,
name|swizzleAlpha
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|mMipLevels
condition|;
name|level
operator|++
control|)
block|{
name|ASSERT
argument_list|(
name|mSwizzleCache
index|[
name|level
index|]
operator|==
name|swizzleTarget
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|copyToStorage
name|gl
operator|::
name|Error
name|TextureStorage11
operator|::
name|copyToStorage
parameter_list|(
name|TextureStorage
modifier|*
name|destStorage
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|destStorage
argument_list|)
expr_stmt|;
name|ID3D11Resource
modifier|*
name|sourceResouce
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|getResource
argument_list|(
operator|&
name|sourceResouce
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|TextureStorage11
modifier|*
name|dest11
init|=
name|TextureStorage11
operator|::
name|makeTextureStorage11
argument_list|(
name|destStorage
argument_list|)
decl_stmt|;
name|ID3D11Resource
modifier|*
name|destResource
init|=
name|NULL
decl_stmt|;
name|error
operator|=
name|dest11
operator|->
name|getResource
argument_list|(
operator|&
name|destResource
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ID3D11DeviceContext
modifier|*
name|immediateContext
init|=
name|mRenderer
operator|->
name|getDeviceContext
argument_list|()
decl_stmt|;
name|immediateContext
operator|->
name|CopyResource
argument_list|(
name|destResource
argument_list|,
name|sourceResouce
argument_list|)
expr_stmt|;
name|dest11
operator|->
name|invalidateSwizzleCache
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|setData
name|gl
operator|::
name|Error
name|TextureStorage11
operator|::
name|setData
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|,
name|ImageD3D
modifier|*
name|image
parameter_list|,
specifier|const
name|gl
operator|::
name|Box
modifier|*
name|destBox
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|pixelData
parameter_list|)
block|{
name|ASSERT
argument_list|(
operator|!
name|image
operator|->
name|isDirty
argument_list|()
argument_list|)
expr_stmt|;
name|ID3D11Resource
modifier|*
name|resource
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|getResource
argument_list|(
operator|&
name|resource
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|resource
argument_list|)
expr_stmt|;
name|UINT
name|destSubresource
init|=
name|getSubresourceIndex
argument_list|(
name|index
argument_list|)
decl_stmt|;
specifier|const
name|gl
operator|::
name|InternalFormat
modifier|&
name|internalFormatInfo
init|=
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|image
operator|->
name|getInternalFormat
argument_list|()
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Box
name|levelBox
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|getLevelWidth
argument_list|(
name|index
operator|.
name|mipIndex
argument_list|)
argument_list|,
name|getLevelHeight
argument_list|(
name|index
operator|.
name|mipIndex
argument_list|)
argument_list|,
name|getLevelDepth
argument_list|(
name|index
operator|.
name|mipIndex
argument_list|)
argument_list|)
decl_stmt|;
name|bool
name|fullUpdate
init|=
operator|(
name|destBox
operator|==
name|NULL
operator|||
operator|*
name|destBox
operator|==
name|levelBox
operator|)
decl_stmt|;
name|ASSERT
argument_list|(
name|internalFormatInfo
operator|.
name|depthBits
operator|==
literal|0
operator|||
name|fullUpdate
argument_list|)
expr_stmt|;
comment|// TODO(jmadill): Handle compressed formats
comment|// Compressed formats have different load syntax, so we'll have to handle them with slightly
comment|// different logic. Will implemnent this in a follow-up patch, and ensure we do not use SetData
comment|// with compressed formats in the calling logic.
name|ASSERT
argument_list|(
operator|!
name|internalFormatInfo
operator|.
name|compressed
argument_list|)
expr_stmt|;
name|int
name|width
init|=
name|destBox
condition|?
name|destBox
operator|->
name|width
else|:
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|image
operator|->
name|getWidth
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|height
init|=
name|destBox
condition|?
name|destBox
operator|->
name|height
else|:
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|image
operator|->
name|getHeight
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|depth
init|=
name|destBox
condition|?
name|destBox
operator|->
name|depth
else|:
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|image
operator|->
name|getDepth
argument_list|()
argument_list|)
decl_stmt|;
name|UINT
name|srcRowPitch
init|=
name|internalFormatInfo
operator|.
name|computeRowPitch
argument_list|(
name|type
argument_list|,
name|width
argument_list|,
name|unpack
operator|.
name|alignment
argument_list|,
name|unpack
operator|.
name|rowLength
argument_list|)
decl_stmt|;
name|UINT
name|srcDepthPitch
init|=
name|internalFormatInfo
operator|.
name|computeDepthPitch
argument_list|(
name|type
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|unpack
operator|.
name|alignment
argument_list|,
name|unpack
operator|.
name|rowLength
argument_list|)
decl_stmt|;
specifier|const
name|d3d11
operator|::
name|TextureFormat
modifier|&
name|d3d11Format
init|=
name|d3d11
operator|::
name|GetTextureFormatInfo
argument_list|(
name|image
operator|->
name|getInternalFormat
argument_list|()
argument_list|,
name|mRenderer
operator|->
name|getFeatureLevel
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|d3d11
operator|::
name|DXGIFormat
modifier|&
name|dxgiFormatInfo
init|=
name|d3d11
operator|::
name|GetDXGIFormatInfo
argument_list|(
name|d3d11Format
operator|.
name|texFormat
argument_list|)
decl_stmt|;
name|size_t
name|outputPixelSize
init|=
name|dxgiFormatInfo
operator|.
name|pixelBytes
decl_stmt|;
name|UINT
name|bufferRowPitch
init|=
name|outputPixelSize
operator|*
name|width
decl_stmt|;
name|UINT
name|bufferDepthPitch
init|=
name|bufferRowPitch
operator|*
name|height
decl_stmt|;
name|size_t
name|neededSize
init|=
name|bufferDepthPitch
operator|*
name|depth
decl_stmt|;
name|MemoryBuffer
modifier|*
name|conversionBuffer
init|=
name|NULL
decl_stmt|;
name|error
operator|=
name|mRenderer
operator|->
name|getScratchMemoryBuffer
argument_list|(
name|neededSize
argument_list|,
operator|&
name|conversionBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
comment|// TODO: fast path
name|LoadImageFunction
name|loadFunction
init|=
name|d3d11Format
operator|.
name|loadFunctions
operator|.
name|at
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|loadFunction
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|,
name|pixelData
argument_list|,
name|srcRowPitch
argument_list|,
name|srcDepthPitch
argument_list|,
name|conversionBuffer
operator|->
name|data
argument_list|()
argument_list|,
name|bufferRowPitch
argument_list|,
name|bufferDepthPitch
argument_list|)
expr_stmt|;
name|ID3D11DeviceContext
modifier|*
name|immediateContext
init|=
name|mRenderer
operator|->
name|getDeviceContext
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|fullUpdate
condition|)
block|{
name|ASSERT
argument_list|(
name|destBox
argument_list|)
expr_stmt|;
name|D3D11_BOX
name|destD3DBox
decl_stmt|;
name|destD3DBox
operator|.
name|left
operator|=
name|destBox
operator|->
name|x
expr_stmt|;
name|destD3DBox
operator|.
name|right
operator|=
name|destBox
operator|->
name|x
operator|+
name|destBox
operator|->
name|width
expr_stmt|;
name|destD3DBox
operator|.
name|top
operator|=
name|destBox
operator|->
name|y
expr_stmt|;
name|destD3DBox
operator|.
name|bottom
operator|=
name|destBox
operator|->
name|y
operator|+
name|destBox
operator|->
name|height
expr_stmt|;
name|destD3DBox
operator|.
name|front
operator|=
name|destBox
operator|->
name|z
expr_stmt|;
name|destD3DBox
operator|.
name|back
operator|=
name|destBox
operator|->
name|z
operator|+
name|destBox
operator|->
name|depth
expr_stmt|;
name|immediateContext
operator|->
name|UpdateSubresource
argument_list|(
name|resource
argument_list|,
name|destSubresource
argument_list|,
operator|&
name|destD3DBox
argument_list|,
name|conversionBuffer
operator|->
name|data
argument_list|()
argument_list|,
name|bufferRowPitch
argument_list|,
name|bufferDepthPitch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|immediateContext
operator|->
name|UpdateSubresource
argument_list|(
name|resource
argument_list|,
name|destSubresource
argument_list|,
name|NULL
argument_list|,
name|conversionBuffer
operator|->
name|data
argument_list|()
argument_list|,
name|bufferRowPitch
argument_list|,
name|bufferDepthPitch
argument_list|)
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|TextureStorage11_2D
name|TextureStorage11_2D
operator|::
name|TextureStorage11_2D
parameter_list|(
name|Renderer11
modifier|*
name|renderer
parameter_list|,
name|SwapChain11
modifier|*
name|swapchain
parameter_list|)
member_init_list|:
name|TextureStorage11
argument_list|(
name|renderer
argument_list|,
name|D3D11_BIND_RENDER_TARGET
operator||
name|D3D11_BIND_SHADER_RESOURCE
argument_list|)
member_init_list|,
name|mTexture
argument_list|(
name|swapchain
operator|->
name|getOffscreenTexture
argument_list|()
argument_list|)
member_init_list|,
name|mSwizzleTexture
argument_list|(
name|NULL
argument_list|)
member_init_list|,
name|mLevelZeroTexture
argument_list|(
name|NULL
argument_list|)
member_init_list|,
name|mLevelZeroRenderTarget
argument_list|(
name|NULL
argument_list|)
member_init_list|,
name|mUseLevelZeroTexture
argument_list|(
literal|false
argument_list|)
block|{
name|mTexture
operator|->
name|AddRef
argument_list|()
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|i
operator|++
control|)
block|{
name|mAssociatedImages
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|mRenderTarget
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|mSwizzleRenderTargets
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|D3D11_TEXTURE2D_DESC
name|texDesc
decl_stmt|;
name|mTexture
operator|->
name|GetDesc
argument_list|(
operator|&
name|texDesc
argument_list|)
expr_stmt|;
name|mMipLevels
operator|=
name|texDesc
operator|.
name|MipLevels
expr_stmt|;
name|mTextureFormat
operator|=
name|texDesc
operator|.
name|Format
expr_stmt|;
name|mTextureWidth
operator|=
name|texDesc
operator|.
name|Width
expr_stmt|;
name|mTextureHeight
operator|=
name|texDesc
operator|.
name|Height
expr_stmt|;
name|mTextureDepth
operator|=
literal|1
expr_stmt|;
name|mInternalFormat
operator|=
name|swapchain
operator|->
name|GetBackBufferInternalFormat
argument_list|()
expr_stmt|;
name|ID3D11ShaderResourceView
modifier|*
name|srv
init|=
name|swapchain
operator|->
name|getRenderTargetShaderResource
argument_list|()
decl_stmt|;
name|D3D11_SHADER_RESOURCE_VIEW_DESC
name|srvDesc
decl_stmt|;
name|srv
operator|->
name|GetDesc
argument_list|(
operator|&
name|srvDesc
argument_list|)
expr_stmt|;
name|mShaderResourceFormat
operator|=
name|srvDesc
operator|.
name|Format
expr_stmt|;
name|ID3D11RenderTargetView
modifier|*
name|offscreenRTV
init|=
name|swapchain
operator|->
name|getRenderTarget
argument_list|()
decl_stmt|;
name|D3D11_RENDER_TARGET_VIEW_DESC
name|rtvDesc
decl_stmt|;
name|offscreenRTV
operator|->
name|GetDesc
argument_list|(
operator|&
name|rtvDesc
argument_list|)
expr_stmt|;
name|mRenderTargetFormat
operator|=
name|rtvDesc
operator|.
name|Format
expr_stmt|;
specifier|const
name|d3d11
operator|::
name|DXGIFormat
modifier|&
name|dxgiFormatInfo
init|=
name|d3d11
operator|::
name|GetDXGIFormatInfo
argument_list|(
name|mTextureFormat
argument_list|)
decl_stmt|;
specifier|const
name|d3d11
operator|::
name|TextureFormat
modifier|&
name|formatInfo
init|=
name|d3d11
operator|::
name|GetTextureFormatInfo
argument_list|(
name|dxgiFormatInfo
operator|.
name|internalFormat
argument_list|,
name|mRenderer
operator|->
name|getFeatureLevel
argument_list|()
argument_list|)
decl_stmt|;
name|mSwizzleTextureFormat
operator|=
name|formatInfo
operator|.
name|swizzleTexFormat
expr_stmt|;
name|mSwizzleShaderResourceFormat
operator|=
name|formatInfo
operator|.
name|swizzleSRVFormat
expr_stmt|;
name|mSwizzleRenderTargetFormat
operator|=
name|formatInfo
operator|.
name|swizzleRTVFormat
expr_stmt|;
name|mDepthStencilFormat
operator|=
name|DXGI_FORMAT_UNKNOWN
expr_stmt|;
name|initializeSerials
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|function|TextureStorage11_2D
name|TextureStorage11_2D
operator|::
name|TextureStorage11_2D
parameter_list|(
name|Renderer11
modifier|*
name|renderer
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|bool
name|renderTarget
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|int
name|levels
parameter_list|,
name|bool
name|hintLevelZeroOnly
parameter_list|)
member_init_list|:
name|TextureStorage11
argument_list|(
name|renderer
argument_list|,
name|GetTextureBindFlags
argument_list|(
name|internalformat
argument_list|,
name|renderer
operator|->
name|getFeatureLevel
argument_list|()
argument_list|,
name|renderTarget
argument_list|)
argument_list|)
member_init_list|,
name|mTexture
argument_list|(
name|NULL
argument_list|)
member_init_list|,
name|mSwizzleTexture
argument_list|(
name|NULL
argument_list|)
member_init_list|,
name|mLevelZeroTexture
argument_list|(
name|NULL
argument_list|)
member_init_list|,
name|mLevelZeroRenderTarget
argument_list|(
name|NULL
argument_list|)
member_init_list|,
name|mUseLevelZeroTexture
argument_list|(
literal|false
argument_list|)
block|{
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|i
operator|++
control|)
block|{
name|mAssociatedImages
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|mRenderTarget
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|mSwizzleRenderTargets
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|mInternalFormat
operator|=
name|internalformat
expr_stmt|;
specifier|const
name|d3d11
operator|::
name|TextureFormat
modifier|&
name|formatInfo
init|=
name|d3d11
operator|::
name|GetTextureFormatInfo
argument_list|(
name|internalformat
argument_list|,
name|renderer
operator|->
name|getFeatureLevel
argument_list|()
argument_list|)
decl_stmt|;
name|mTextureFormat
operator|=
name|formatInfo
operator|.
name|texFormat
expr_stmt|;
name|mShaderResourceFormat
operator|=
name|formatInfo
operator|.
name|srvFormat
expr_stmt|;
name|mDepthStencilFormat
operator|=
name|formatInfo
operator|.
name|dsvFormat
expr_stmt|;
name|mRenderTargetFormat
operator|=
name|formatInfo
operator|.
name|rtvFormat
expr_stmt|;
name|mSwizzleTextureFormat
operator|=
name|formatInfo
operator|.
name|swizzleTexFormat
expr_stmt|;
name|mSwizzleShaderResourceFormat
operator|=
name|formatInfo
operator|.
name|swizzleSRVFormat
expr_stmt|;
name|mSwizzleRenderTargetFormat
operator|=
name|formatInfo
operator|.
name|swizzleRTVFormat
expr_stmt|;
name|d3d11
operator|::
name|MakeValidSize
argument_list|(
literal|false
argument_list|,
name|mTextureFormat
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|height
argument_list|,
operator|&
name|mTopLevel
argument_list|)
expr_stmt|;
name|mMipLevels
operator|=
name|mTopLevel
operator|+
name|levels
expr_stmt|;
name|mTextureWidth
operator|=
name|width
expr_stmt|;
name|mTextureHeight
operator|=
name|height
expr_stmt|;
name|mTextureDepth
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|hintLevelZeroOnly
operator|&&
name|levels
operator|>
literal|1
condition|)
block|{
comment|//The LevelZeroOnly hint should only be true if the zero max LOD workaround is active.
name|ASSERT
argument_list|(
name|mRenderer
operator|->
name|getWorkarounds
argument_list|()
operator|.
name|zeroMaxLodWorkaround
argument_list|)
expr_stmt|;
name|mUseLevelZeroTexture
operator|=
literal|true
expr_stmt|;
block|}
name|initializeSerials
argument_list|(
name|getLevelCount
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|function|~TextureStorage11_2D
name|TextureStorage11_2D
operator|::
name|~
name|TextureStorage11_2D
parameter_list|()
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mAssociatedImages
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|bool
name|imageAssociationCorrect
init|=
name|mAssociatedImages
index|[
name|i
index|]
operator|->
name|isAssociatedStorageValid
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|imageAssociationCorrect
argument_list|)
expr_stmt|;
if|if
condition|(
name|imageAssociationCorrect
condition|)
block|{
comment|// We must let the Images recover their data before we delete it from the TextureStorage.
name|gl
operator|::
name|Error
name|error
init|=
name|mAssociatedImages
index|[
name|i
index|]
operator|->
name|recoverFromAssociatedStorage
argument_list|()
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
comment|// TODO: Find a way to report this back to the context
block|}
block|}
block|}
block|}
name|SafeRelease
argument_list|(
name|mTexture
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mSwizzleTexture
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mLevelZeroTexture
argument_list|)
expr_stmt|;
name|SafeDelete
argument_list|(
name|mLevelZeroRenderTarget
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|i
operator|++
control|)
block|{
name|SafeDelete
argument_list|(
name|mRenderTarget
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mSwizzleRenderTargets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|makeTextureStorage11_2D
name|TextureStorage11_2D
modifier|*
name|TextureStorage11_2D
operator|::
name|makeTextureStorage11_2D
parameter_list|(
name|TextureStorage
modifier|*
name|storage
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|HAS_DYNAMIC_TYPE
argument_list|(
name|TextureStorage11_2D
operator|*
argument_list|,
name|storage
argument_list|)
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|TextureStorage11_2D
operator|*
argument_list|>
argument_list|(
name|storage
argument_list|)
return|;
block|}
DECL|function|copyToStorage
name|gl
operator|::
name|Error
name|TextureStorage11_2D
operator|::
name|copyToStorage
parameter_list|(
name|TextureStorage
modifier|*
name|destStorage
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|destStorage
argument_list|)
expr_stmt|;
name|TextureStorage11_2D
modifier|*
name|dest11
init|=
name|TextureStorage11_2D
operator|::
name|makeTextureStorage11_2D
argument_list|(
name|destStorage
argument_list|)
decl_stmt|;
if|if
condition|(
name|mRenderer
operator|->
name|getWorkarounds
argument_list|()
operator|.
name|zeroMaxLodWorkaround
condition|)
block|{
name|ID3D11DeviceContext
modifier|*
name|immediateContext
init|=
name|mRenderer
operator|->
name|getDeviceContext
argument_list|()
decl_stmt|;
comment|// If either mTexture or mLevelZeroTexture exist, then we need to copy them into the corresponding textures in destStorage.
if|if
condition|(
name|mTexture
condition|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|dest11
operator|->
name|useLevelZeroWorkaroundTexture
argument_list|(
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ID3D11Resource
modifier|*
name|destResource
init|=
name|NULL
decl_stmt|;
name|error
operator|=
name|dest11
operator|->
name|getResource
argument_list|(
operator|&
name|destResource
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|immediateContext
operator|->
name|CopyResource
argument_list|(
name|destResource
argument_list|,
name|mTexture
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mLevelZeroTexture
condition|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|dest11
operator|->
name|useLevelZeroWorkaroundTexture
argument_list|(
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ID3D11Resource
modifier|*
name|destResource
init|=
name|NULL
decl_stmt|;
name|error
operator|=
name|dest11
operator|->
name|getResource
argument_list|(
operator|&
name|destResource
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|immediateContext
operator|->
name|CopyResource
argument_list|(
name|destResource
argument_list|,
name|mLevelZeroTexture
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ID3D11Resource
modifier|*
name|sourceResouce
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|getResource
argument_list|(
operator|&
name|sourceResouce
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ID3D11Resource
modifier|*
name|destResource
init|=
name|NULL
decl_stmt|;
name|error
operator|=
name|dest11
operator|->
name|getResource
argument_list|(
operator|&
name|destResource
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ID3D11DeviceContext
modifier|*
name|immediateContext
init|=
name|mRenderer
operator|->
name|getDeviceContext
argument_list|()
decl_stmt|;
name|immediateContext
operator|->
name|CopyResource
argument_list|(
name|destResource
argument_list|,
name|sourceResouce
argument_list|)
expr_stmt|;
block|}
name|dest11
operator|->
name|invalidateSwizzleCache
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|useLevelZeroWorkaroundTexture
name|gl
operator|::
name|Error
name|TextureStorage11_2D
operator|::
name|useLevelZeroWorkaroundTexture
parameter_list|(
name|bool
name|useLevelZeroTexture
parameter_list|)
block|{
if|if
condition|(
name|useLevelZeroTexture
operator|&&
name|mMipLevels
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|mUseLevelZeroTexture
operator|&&
name|mTexture
condition|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|ensureTextureExists
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
comment|// Pull data back from the mipped texture if necessary.
name|ASSERT
argument_list|(
name|mLevelZeroTexture
argument_list|)
expr_stmt|;
name|ID3D11DeviceContext
modifier|*
name|context
init|=
name|mRenderer
operator|->
name|getDeviceContext
argument_list|()
decl_stmt|;
name|context
operator|->
name|CopySubresourceRegion
argument_list|(
name|mLevelZeroTexture
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|mTexture
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|mUseLevelZeroTexture
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mUseLevelZeroTexture
operator|&&
name|mLevelZeroTexture
condition|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|ensureTextureExists
argument_list|(
name|mMipLevels
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
comment|// Pull data back from the level zero texture if necessary.
name|ASSERT
argument_list|(
name|mTexture
argument_list|)
expr_stmt|;
name|ID3D11DeviceContext
modifier|*
name|context
init|=
name|mRenderer
operator|->
name|getDeviceContext
argument_list|()
decl_stmt|;
name|context
operator|->
name|CopySubresourceRegion
argument_list|(
name|mTexture
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|mLevelZeroTexture
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|mUseLevelZeroTexture
operator|=
literal|false
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|associateImage
name|void
name|TextureStorage11_2D
operator|::
name|associateImage
parameter_list|(
name|Image11
modifier|*
name|image
parameter_list|,
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|)
block|{
name|GLint
name|level
init|=
name|index
operator|.
name|mipIndex
decl_stmt|;
name|ASSERT
argument_list|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
block|{
name|mAssociatedImages
index|[
name|level
index|]
operator|=
name|image
expr_stmt|;
block|}
block|}
DECL|function|isAssociatedImageValid
name|bool
name|TextureStorage11_2D
operator|::
name|isAssociatedImageValid
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|,
name|Image11
modifier|*
name|expectedImage
parameter_list|)
block|{
name|GLint
name|level
init|=
name|index
operator|.
name|mipIndex
decl_stmt|;
if|if
condition|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
block|{
comment|// This validation check should never return false. It means the Image/TextureStorage association is broken.
name|bool
name|retValue
init|=
operator|(
name|mAssociatedImages
index|[
name|level
index|]
operator|==
name|expectedImage
operator|)
decl_stmt|;
name|ASSERT
argument_list|(
name|retValue
argument_list|)
expr_stmt|;
return|return
name|retValue
return|;
block|}
return|return
literal|false
return|;
block|}
comment|// disassociateImage allows an Image to end its association with a Storage.
DECL|function|disassociateImage
name|void
name|TextureStorage11_2D
operator|::
name|disassociateImage
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|,
name|Image11
modifier|*
name|expectedImage
parameter_list|)
block|{
name|GLint
name|level
init|=
name|index
operator|.
name|mipIndex
decl_stmt|;
name|ASSERT
argument_list|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
block|{
name|ASSERT
argument_list|(
name|mAssociatedImages
index|[
name|level
index|]
operator|==
name|expectedImage
argument_list|)
expr_stmt|;
if|if
condition|(
name|mAssociatedImages
index|[
name|level
index|]
operator|==
name|expectedImage
condition|)
block|{
name|mAssociatedImages
index|[
name|level
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
comment|// releaseAssociatedImage prepares the Storage for a new Image association. It lets the old Image recover its data before ending the association.
DECL|function|releaseAssociatedImage
name|gl
operator|::
name|Error
name|TextureStorage11_2D
operator|::
name|releaseAssociatedImage
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|,
name|Image11
modifier|*
name|incomingImage
parameter_list|)
block|{
name|GLint
name|level
init|=
name|index
operator|.
name|mipIndex
decl_stmt|;
name|ASSERT
argument_list|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
block|{
comment|// No need to let the old Image recover its data, if it is also the incoming Image.
if|if
condition|(
name|mAssociatedImages
index|[
name|level
index|]
operator|!=
name|NULL
operator|&&
name|mAssociatedImages
index|[
name|level
index|]
operator|!=
name|incomingImage
condition|)
block|{
comment|// Ensure that the Image is still associated with this TextureStorage. This should be true.
name|bool
name|imageAssociationCorrect
init|=
name|mAssociatedImages
index|[
name|level
index|]
operator|->
name|isAssociatedStorageValid
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|imageAssociationCorrect
argument_list|)
expr_stmt|;
if|if
condition|(
name|imageAssociationCorrect
condition|)
block|{
comment|// Force the image to recover from storage before its data is overwritten.
comment|// This will reset mAssociatedImages[level] to NULL too.
name|gl
operator|::
name|Error
name|error
init|=
name|mAssociatedImages
index|[
name|level
index|]
operator|->
name|recoverFromAssociatedStorage
argument_list|()
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|getResource
name|gl
operator|::
name|Error
name|TextureStorage11_2D
operator|::
name|getResource
parameter_list|(
name|ID3D11Resource
modifier|*
modifier|*
name|outResource
parameter_list|)
block|{
if|if
condition|(
name|mUseLevelZeroTexture
operator|&&
name|mMipLevels
operator|>
literal|1
condition|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|ensureTextureExists
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
operator|*
name|outResource
operator|=
name|mLevelZeroTexture
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
else|else
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|ensureTextureExists
argument_list|(
name|mMipLevels
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
operator|*
name|outResource
operator|=
name|mTexture
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
block|}
DECL|function|getMippedResource
name|gl
operator|::
name|Error
name|TextureStorage11_2D
operator|::
name|getMippedResource
parameter_list|(
name|ID3D11Resource
modifier|*
modifier|*
name|outResource
parameter_list|)
block|{
comment|// This shouldn't be called unless the zero max LOD workaround is active.
name|ASSERT
argument_list|(
name|mRenderer
operator|->
name|getWorkarounds
argument_list|()
operator|.
name|zeroMaxLodWorkaround
argument_list|)
expr_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|ensureTextureExists
argument_list|(
name|mMipLevels
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
operator|*
name|outResource
operator|=
name|mTexture
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|ensureTextureExists
name|gl
operator|::
name|Error
name|TextureStorage11_2D
operator|::
name|ensureTextureExists
parameter_list|(
name|int
name|mipLevels
parameter_list|)
block|{
comment|// If mMipLevels = 1 then always use mTexture rather than mLevelZeroTexture.
name|bool
name|useLevelZeroTexture
init|=
name|mRenderer
operator|->
name|getWorkarounds
argument_list|()
operator|.
name|zeroMaxLodWorkaround
condition|?
operator|(
name|mipLevels
operator|==
literal|1
operator|)
operator|&&
operator|(
name|mMipLevels
operator|>
literal|1
operator|)
else|:
literal|false
decl_stmt|;
name|ID3D11Texture2D
modifier|*
modifier|*
name|outputTexture
init|=
name|useLevelZeroTexture
condition|?
operator|&
name|mLevelZeroTexture
else|:
operator|&
name|mTexture
decl_stmt|;
comment|// if the width or height is not positive this should be treated as an incomplete texture
comment|// we handle that here by skipping the d3d texture creation
if|if
condition|(
operator|*
name|outputTexture
operator|==
name|NULL
operator|&&
name|mTextureWidth
operator|>
literal|0
operator|&&
name|mTextureHeight
operator|>
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|mipLevels
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|D3D11_TEXTURE2D_DESC
name|desc
decl_stmt|;
name|desc
operator|.
name|Width
operator|=
name|mTextureWidth
expr_stmt|;
comment|// Compressed texture size constraints?
name|desc
operator|.
name|Height
operator|=
name|mTextureHeight
expr_stmt|;
name|desc
operator|.
name|MipLevels
operator|=
name|mipLevels
expr_stmt|;
name|desc
operator|.
name|ArraySize
operator|=
literal|1
expr_stmt|;
name|desc
operator|.
name|Format
operator|=
name|mTextureFormat
expr_stmt|;
name|desc
operator|.
name|SampleDesc
operator|.
name|Count
operator|=
literal|1
expr_stmt|;
name|desc
operator|.
name|SampleDesc
operator|.
name|Quality
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|Usage
operator|=
name|D3D11_USAGE_DEFAULT
expr_stmt|;
name|desc
operator|.
name|BindFlags
operator|=
name|getBindFlags
argument_list|()
expr_stmt|;
name|desc
operator|.
name|CPUAccessFlags
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateTexture2D
argument_list|(
operator|&
name|desc
argument_list|,
name|NULL
argument_list|,
name|outputTexture
argument_list|)
decl_stmt|;
comment|// this can happen from windows TDR
if|if
condition|(
name|d3d11
operator|::
name|isDeviceLostError
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|mRenderer
operator|->
name|notifyDeviceLost
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create 2D texture storage, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|result
operator|==
name|E_OUTOFMEMORY
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create 2D texture storage, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|getRenderTarget
name|gl
operator|::
name|Error
name|TextureStorage11_2D
operator|::
name|getRenderTarget
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|,
name|RenderTargetD3D
modifier|*
modifier|*
name|outRT
parameter_list|)
block|{
name|ASSERT
argument_list|(
operator|!
name|index
operator|.
name|hasLayer
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|level
init|=
name|index
operator|.
name|mipIndex
decl_stmt|;
name|ASSERT
argument_list|(
name|level
operator|>=
literal|0
operator|&&
name|level
operator|<
name|getLevelCount
argument_list|()
argument_list|)
expr_stmt|;
comment|// In GL ES 2.0, the application can only render to level zero of the texture (Section 4.4.3 of the GLES 2.0 spec, page 113 of version 2.0.25).
comment|// Other parts of TextureStorage11_2D could create RTVs on non-zero levels of the texture (e.g. generateMipmap).
comment|// On Feature Level 9_3, this is unlikely to be useful. The renderer can't create SRVs on the individual levels of the texture,
comment|// so methods like generateMipmap can't do anything useful with non-zero-level RTVs.
comment|// Therefore if level> 0 on 9_3 then there's almost certainly something wrong.
name|ASSERT
argument_list|(
operator|!
operator|(
name|mRenderer
operator|->
name|getFeatureLevel
argument_list|()
operator|<=
name|D3D_FEATURE_LEVEL_9_3
operator|&&
name|level
operator|>
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mRenderTarget
index|[
name|level
index|]
condition|)
block|{
name|ID3D11Resource
modifier|*
name|texture
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|getResource
argument_list|(
operator|&
name|texture
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ID3D11ShaderResourceView
modifier|*
name|srv
init|=
name|NULL
decl_stmt|;
name|error
operator|=
name|getSRVLevel
argument_list|(
name|level
argument_list|,
operator|&
name|srv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
name|mUseLevelZeroTexture
condition|)
block|{
if|if
condition|(
operator|!
name|mLevelZeroRenderTarget
condition|)
block|{
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|D3D11_RENDER_TARGET_VIEW_DESC
name|rtvDesc
decl_stmt|;
name|rtvDesc
operator|.
name|Format
operator|=
name|mRenderTargetFormat
expr_stmt|;
name|rtvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_RTV_DIMENSION_TEXTURE2D
expr_stmt|;
name|rtvDesc
operator|.
name|Texture2D
operator|.
name|MipSlice
operator|=
name|mTopLevel
operator|+
name|level
expr_stmt|;
name|ID3D11RenderTargetView
modifier|*
name|rtv
decl_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateRenderTargetView
argument_list|(
name|mLevelZeroTexture
argument_list|,
operator|&
name|rtvDesc
argument_list|,
operator|&
name|rtv
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|E_OUTOFMEMORY
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create internal render target view for texture storage, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|mLevelZeroRenderTarget
operator|=
operator|new
name|TextureRenderTarget11
argument_list|(
name|rtv
argument_list|,
name|mLevelZeroTexture
argument_list|,
name|NULL
argument_list|,
name|mInternalFormat
argument_list|,
name|getLevelWidth
argument_list|(
name|level
argument_list|)
argument_list|,
name|getLevelHeight
argument_list|(
name|level
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// RenderTarget will take ownership of these resources
name|SafeRelease
argument_list|(
name|rtv
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|outRT
argument_list|)
expr_stmt|;
operator|*
name|outRT
operator|=
name|mLevelZeroRenderTarget
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
if|if
condition|(
name|mRenderTargetFormat
operator|!=
name|DXGI_FORMAT_UNKNOWN
condition|)
block|{
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|D3D11_RENDER_TARGET_VIEW_DESC
name|rtvDesc
decl_stmt|;
name|rtvDesc
operator|.
name|Format
operator|=
name|mRenderTargetFormat
expr_stmt|;
name|rtvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_RTV_DIMENSION_TEXTURE2D
expr_stmt|;
name|rtvDesc
operator|.
name|Texture2D
operator|.
name|MipSlice
operator|=
name|mTopLevel
operator|+
name|level
expr_stmt|;
name|ID3D11RenderTargetView
modifier|*
name|rtv
decl_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateRenderTargetView
argument_list|(
name|texture
argument_list|,
operator|&
name|rtvDesc
argument_list|,
operator|&
name|rtv
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|result
operator|==
name|E_OUTOFMEMORY
operator|||
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create internal render target view for texture storage, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
name|mRenderTarget
index|[
name|level
index|]
operator|=
operator|new
name|TextureRenderTarget11
argument_list|(
name|rtv
argument_list|,
name|texture
argument_list|,
name|srv
argument_list|,
name|mInternalFormat
argument_list|,
name|getLevelWidth
argument_list|(
name|level
argument_list|)
argument_list|,
name|getLevelHeight
argument_list|(
name|level
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// RenderTarget will take ownership of these resources
name|SafeRelease
argument_list|(
name|rtv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mDepthStencilFormat
operator|!=
name|DXGI_FORMAT_UNKNOWN
condition|)
block|{
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|D3D11_DEPTH_STENCIL_VIEW_DESC
name|dsvDesc
decl_stmt|;
name|dsvDesc
operator|.
name|Format
operator|=
name|mDepthStencilFormat
expr_stmt|;
name|dsvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_DSV_DIMENSION_TEXTURE2D
expr_stmt|;
name|dsvDesc
operator|.
name|Texture2D
operator|.
name|MipSlice
operator|=
name|mTopLevel
operator|+
name|level
expr_stmt|;
name|dsvDesc
operator|.
name|Flags
operator|=
literal|0
expr_stmt|;
name|ID3D11DepthStencilView
modifier|*
name|dsv
decl_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateDepthStencilView
argument_list|(
name|texture
argument_list|,
operator|&
name|dsvDesc
argument_list|,
operator|&
name|dsv
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|result
operator|==
name|E_OUTOFMEMORY
operator|||
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create internal depth stencil view for texture storage, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
name|mRenderTarget
index|[
name|level
index|]
operator|=
operator|new
name|TextureRenderTarget11
argument_list|(
name|dsv
argument_list|,
name|texture
argument_list|,
name|srv
argument_list|,
name|mInternalFormat
argument_list|,
name|getLevelWidth
argument_list|(
name|level
argument_list|)
argument_list|,
name|getLevelHeight
argument_list|(
name|level
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// RenderTarget will take ownership of these resources
name|SafeRelease
argument_list|(
name|dsv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
name|ASSERT
argument_list|(
name|outRT
argument_list|)
expr_stmt|;
operator|*
name|outRT
operator|=
name|mRenderTarget
index|[
name|level
index|]
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|createSRV
name|gl
operator|::
name|Error
name|TextureStorage11_2D
operator|::
name|createSRV
parameter_list|(
name|int
name|baseLevel
parameter_list|,
name|int
name|mipLevels
parameter_list|,
name|DXGI_FORMAT
name|format
parameter_list|,
name|ID3D11Resource
modifier|*
name|texture
parameter_list|,
name|ID3D11ShaderResourceView
modifier|*
modifier|*
name|outSRV
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|outSRV
argument_list|)
expr_stmt|;
name|D3D11_SHADER_RESOURCE_VIEW_DESC
name|srvDesc
decl_stmt|;
name|srvDesc
operator|.
name|Format
operator|=
name|format
expr_stmt|;
name|srvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_SRV_DIMENSION_TEXTURE2D
expr_stmt|;
name|srvDesc
operator|.
name|Texture2D
operator|.
name|MostDetailedMip
operator|=
name|mTopLevel
operator|+
name|baseLevel
expr_stmt|;
name|srvDesc
operator|.
name|Texture2D
operator|.
name|MipLevels
operator|=
name|mipLevels
expr_stmt|;
name|ID3D11Resource
modifier|*
name|srvTexture
init|=
name|texture
decl_stmt|;
if|if
condition|(
name|mRenderer
operator|->
name|getWorkarounds
argument_list|()
operator|.
name|zeroMaxLodWorkaround
condition|)
block|{
name|ASSERT
argument_list|(
name|mTopLevel
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|baseLevel
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|// This code also assumes that the incoming texture equals either mLevelZeroTexture or mTexture.
if|if
condition|(
name|mipLevels
operator|==
literal|1
operator|&&
name|mMipLevels
operator|>
literal|1
condition|)
block|{
comment|// We must use a SRV on the level-zero-only texture.
name|ASSERT
argument_list|(
name|mLevelZeroTexture
operator|!=
name|NULL
operator|&&
name|texture
operator|==
name|mLevelZeroTexture
argument_list|)
expr_stmt|;
name|srvTexture
operator|=
name|mLevelZeroTexture
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|mipLevels
operator|==
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|mMipLevels
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mTexture
operator|!=
name|NULL
operator|&&
name|texture
operator|==
name|mTexture
argument_list|)
expr_stmt|;
name|srvTexture
operator|=
name|mTexture
expr_stmt|;
block|}
block|}
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateShaderResourceView
argument_list|(
name|srvTexture
argument_list|,
operator|&
name|srvDesc
argument_list|,
name|outSRV
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|result
operator|==
name|E_OUTOFMEMORY
operator|||
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create internal texture storage SRV, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|getSwizzleTexture
name|gl
operator|::
name|Error
name|TextureStorage11_2D
operator|::
name|getSwizzleTexture
parameter_list|(
name|ID3D11Resource
modifier|*
modifier|*
name|outTexture
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|outTexture
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mSwizzleTexture
condition|)
block|{
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|D3D11_TEXTURE2D_DESC
name|desc
decl_stmt|;
name|desc
operator|.
name|Width
operator|=
name|mTextureWidth
expr_stmt|;
name|desc
operator|.
name|Height
operator|=
name|mTextureHeight
expr_stmt|;
name|desc
operator|.
name|MipLevels
operator|=
name|mMipLevels
expr_stmt|;
name|desc
operator|.
name|ArraySize
operator|=
literal|1
expr_stmt|;
name|desc
operator|.
name|Format
operator|=
name|mSwizzleTextureFormat
expr_stmt|;
name|desc
operator|.
name|SampleDesc
operator|.
name|Count
operator|=
literal|1
expr_stmt|;
name|desc
operator|.
name|SampleDesc
operator|.
name|Quality
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|Usage
operator|=
name|D3D11_USAGE_DEFAULT
expr_stmt|;
name|desc
operator|.
name|BindFlags
operator|=
name|D3D11_BIND_SHADER_RESOURCE
operator||
name|D3D11_BIND_RENDER_TARGET
expr_stmt|;
name|desc
operator|.
name|CPUAccessFlags
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateTexture2D
argument_list|(
operator|&
name|desc
argument_list|,
name|NULL
argument_list|,
operator|&
name|mSwizzleTexture
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|result
operator|==
name|E_OUTOFMEMORY
operator|||
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create internal swizzle texture, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
operator|*
name|outTexture
operator|=
name|mSwizzleTexture
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|getSwizzleRenderTarget
name|gl
operator|::
name|Error
name|TextureStorage11_2D
operator|::
name|getSwizzleRenderTarget
parameter_list|(
name|int
name|mipLevel
parameter_list|,
name|ID3D11RenderTargetView
modifier|*
modifier|*
name|outRTV
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|mipLevel
operator|>=
literal|0
operator|&&
name|mipLevel
operator|<
name|getLevelCount
argument_list|()
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|outRTV
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mSwizzleRenderTargets
index|[
name|mipLevel
index|]
condition|)
block|{
name|ID3D11Resource
modifier|*
name|swizzleTexture
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|getSwizzleTexture
argument_list|(
operator|&
name|swizzleTexture
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|D3D11_RENDER_TARGET_VIEW_DESC
name|rtvDesc
decl_stmt|;
name|rtvDesc
operator|.
name|Format
operator|=
name|mSwizzleRenderTargetFormat
expr_stmt|;
name|rtvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_RTV_DIMENSION_TEXTURE2D
expr_stmt|;
name|rtvDesc
operator|.
name|Texture2D
operator|.
name|MipSlice
operator|=
name|mTopLevel
operator|+
name|mipLevel
expr_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateRenderTargetView
argument_list|(
name|mSwizzleTexture
argument_list|,
operator|&
name|rtvDesc
argument_list|,
operator|&
name|mSwizzleRenderTargets
index|[
name|mipLevel
index|]
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|result
operator|==
name|E_OUTOFMEMORY
operator|||
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create internal swizzle render target view, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
operator|*
name|outRTV
operator|=
name|mSwizzleRenderTargets
index|[
name|mipLevel
index|]
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|TextureStorage11_Cube
name|TextureStorage11_Cube
operator|::
name|TextureStorage11_Cube
parameter_list|(
name|Renderer11
modifier|*
name|renderer
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|bool
name|renderTarget
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|levels
parameter_list|,
name|bool
name|hintLevelZeroOnly
parameter_list|)
member_init_list|:
name|TextureStorage11
argument_list|(
name|renderer
argument_list|,
name|GetTextureBindFlags
argument_list|(
name|internalformat
argument_list|,
name|renderer
operator|->
name|getFeatureLevel
argument_list|()
argument_list|,
name|renderTarget
argument_list|)
argument_list|)
block|{
name|mTexture
operator|=
name|NULL
expr_stmt|;
name|mSwizzleTexture
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|level
operator|++
control|)
block|{
name|mSwizzleRenderTargets
index|[
name|level
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|face
init|=
literal|0
init|;
name|face
operator|<
name|CUBE_FACE_COUNT
condition|;
name|face
operator|++
control|)
block|{
name|mAssociatedImages
index|[
name|face
index|]
index|[
name|level
index|]
operator|=
name|NULL
expr_stmt|;
name|mRenderTarget
index|[
name|face
index|]
index|[
name|level
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|mLevelZeroTexture
operator|=
name|NULL
expr_stmt|;
name|mUseLevelZeroTexture
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|face
init|=
literal|0
init|;
name|face
operator|<
name|CUBE_FACE_COUNT
condition|;
name|face
operator|++
control|)
block|{
name|mLevelZeroRenderTarget
index|[
name|face
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|mInternalFormat
operator|=
name|internalformat
expr_stmt|;
specifier|const
name|d3d11
operator|::
name|TextureFormat
modifier|&
name|formatInfo
init|=
name|d3d11
operator|::
name|GetTextureFormatInfo
argument_list|(
name|internalformat
argument_list|,
name|renderer
operator|->
name|getFeatureLevel
argument_list|()
argument_list|)
decl_stmt|;
name|mTextureFormat
operator|=
name|formatInfo
operator|.
name|texFormat
expr_stmt|;
name|mShaderResourceFormat
operator|=
name|formatInfo
operator|.
name|srvFormat
expr_stmt|;
name|mDepthStencilFormat
operator|=
name|formatInfo
operator|.
name|dsvFormat
expr_stmt|;
name|mRenderTargetFormat
operator|=
name|formatInfo
operator|.
name|rtvFormat
expr_stmt|;
name|mSwizzleTextureFormat
operator|=
name|formatInfo
operator|.
name|swizzleTexFormat
expr_stmt|;
name|mSwizzleShaderResourceFormat
operator|=
name|formatInfo
operator|.
name|swizzleSRVFormat
expr_stmt|;
name|mSwizzleRenderTargetFormat
operator|=
name|formatInfo
operator|.
name|swizzleRTVFormat
expr_stmt|;
comment|// adjust size if needed for compressed textures
name|int
name|height
init|=
name|size
decl_stmt|;
name|d3d11
operator|::
name|MakeValidSize
argument_list|(
literal|false
argument_list|,
name|mTextureFormat
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|height
argument_list|,
operator|&
name|mTopLevel
argument_list|)
expr_stmt|;
name|mMipLevels
operator|=
name|mTopLevel
operator|+
name|levels
expr_stmt|;
name|mTextureWidth
operator|=
name|size
expr_stmt|;
name|mTextureHeight
operator|=
name|size
expr_stmt|;
name|mTextureDepth
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|hintLevelZeroOnly
operator|&&
name|levels
operator|>
literal|1
condition|)
block|{
comment|//The LevelZeroOnly hint should only be true if the zero max LOD workaround is active.
name|ASSERT
argument_list|(
name|mRenderer
operator|->
name|getWorkarounds
argument_list|()
operator|.
name|zeroMaxLodWorkaround
argument_list|)
expr_stmt|;
name|mUseLevelZeroTexture
operator|=
literal|true
expr_stmt|;
block|}
name|initializeSerials
argument_list|(
name|getLevelCount
argument_list|()
operator|*
name|CUBE_FACE_COUNT
argument_list|,
name|CUBE_FACE_COUNT
argument_list|)
expr_stmt|;
block|}
DECL|function|~TextureStorage11_Cube
name|TextureStorage11_Cube
operator|::
name|~
name|TextureStorage11_Cube
parameter_list|()
block|{
for|for
control|(
name|unsigned
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|level
operator|++
control|)
block|{
for|for
control|(
name|unsigned
name|int
name|face
init|=
literal|0
init|;
name|face
operator|<
name|CUBE_FACE_COUNT
condition|;
name|face
operator|++
control|)
block|{
if|if
condition|(
name|mAssociatedImages
index|[
name|face
index|]
index|[
name|level
index|]
operator|!=
name|NULL
condition|)
block|{
name|bool
name|imageAssociationCorrect
init|=
name|mAssociatedImages
index|[
name|face
index|]
index|[
name|level
index|]
operator|->
name|isAssociatedStorageValid
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|imageAssociationCorrect
argument_list|)
expr_stmt|;
if|if
condition|(
name|imageAssociationCorrect
condition|)
block|{
comment|// We must let the Images recover their data before we delete it from the TextureStorage.
name|mAssociatedImages
index|[
name|face
index|]
index|[
name|level
index|]
operator|->
name|recoverFromAssociatedStorage
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
name|SafeRelease
argument_list|(
name|mTexture
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mSwizzleTexture
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mLevelZeroTexture
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|face
init|=
literal|0
init|;
name|face
operator|<
name|CUBE_FACE_COUNT
condition|;
name|face
operator|++
control|)
block|{
name|SafeDelete
argument_list|(
name|mLevelZeroRenderTarget
index|[
name|face
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|unsigned
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|level
operator|++
control|)
block|{
name|SafeRelease
argument_list|(
name|mSwizzleRenderTargets
index|[
name|level
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|face
init|=
literal|0
init|;
name|face
operator|<
name|CUBE_FACE_COUNT
condition|;
name|face
operator|++
control|)
block|{
name|SafeDelete
argument_list|(
name|mRenderTarget
index|[
name|face
index|]
index|[
name|level
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|makeTextureStorage11_Cube
name|TextureStorage11_Cube
modifier|*
name|TextureStorage11_Cube
operator|::
name|makeTextureStorage11_Cube
parameter_list|(
name|TextureStorage
modifier|*
name|storage
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|HAS_DYNAMIC_TYPE
argument_list|(
name|TextureStorage11_Cube
operator|*
argument_list|,
name|storage
argument_list|)
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|TextureStorage11_Cube
operator|*
argument_list|>
argument_list|(
name|storage
argument_list|)
return|;
block|}
DECL|function|getSubresourceIndex
name|UINT
name|TextureStorage11_Cube
operator|::
name|getSubresourceIndex
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|mRenderer
operator|->
name|getWorkarounds
argument_list|()
operator|.
name|zeroMaxLodWorkaround
operator|&&
name|mUseLevelZeroTexture
operator|&&
name|index
operator|.
name|mipIndex
operator|==
literal|0
condition|)
block|{
name|UINT
name|arraySlice
init|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|index
operator|.
name|hasLayer
argument_list|()
condition|?
name|index
operator|.
name|layerIndex
else|:
literal|0
argument_list|)
decl_stmt|;
name|UINT
name|subresource
init|=
name|D3D11CalcSubresource
argument_list|(
literal|0
argument_list|,
name|arraySlice
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|subresource
operator|!=
name|std
operator|::
name|numeric_limits
argument_list|<
name|UINT
argument_list|>
operator|::
name|max
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|subresource
return|;
block|}
else|else
block|{
name|UINT
name|mipSlice
init|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|index
operator|.
name|mipIndex
operator|+
name|mTopLevel
argument_list|)
decl_stmt|;
name|UINT
name|arraySlice
init|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|index
operator|.
name|hasLayer
argument_list|()
condition|?
name|index
operator|.
name|layerIndex
else|:
literal|0
argument_list|)
decl_stmt|;
name|UINT
name|subresource
init|=
name|D3D11CalcSubresource
argument_list|(
name|mipSlice
argument_list|,
name|arraySlice
argument_list|,
name|mMipLevels
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|subresource
operator|!=
name|std
operator|::
name|numeric_limits
argument_list|<
name|UINT
argument_list|>
operator|::
name|max
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|subresource
return|;
block|}
block|}
DECL|function|copyToStorage
name|gl
operator|::
name|Error
name|TextureStorage11_Cube
operator|::
name|copyToStorage
parameter_list|(
name|TextureStorage
modifier|*
name|destStorage
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|destStorage
argument_list|)
expr_stmt|;
name|TextureStorage11_Cube
modifier|*
name|dest11
init|=
name|TextureStorage11_Cube
operator|::
name|makeTextureStorage11_Cube
argument_list|(
name|destStorage
argument_list|)
decl_stmt|;
if|if
condition|(
name|mRenderer
operator|->
name|getWorkarounds
argument_list|()
operator|.
name|zeroMaxLodWorkaround
condition|)
block|{
name|ID3D11DeviceContext
modifier|*
name|immediateContext
init|=
name|mRenderer
operator|->
name|getDeviceContext
argument_list|()
decl_stmt|;
comment|// If either mTexture or mLevelZeroTexture exist, then we need to copy them into the corresponding textures in destStorage.
if|if
condition|(
name|mTexture
condition|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|dest11
operator|->
name|useLevelZeroWorkaroundTexture
argument_list|(
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ID3D11Resource
modifier|*
name|destResource
init|=
name|NULL
decl_stmt|;
name|error
operator|=
name|dest11
operator|->
name|getResource
argument_list|(
operator|&
name|destResource
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|immediateContext
operator|->
name|CopyResource
argument_list|(
name|destResource
argument_list|,
name|mTexture
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mLevelZeroTexture
condition|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|dest11
operator|->
name|useLevelZeroWorkaroundTexture
argument_list|(
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ID3D11Resource
modifier|*
name|destResource
init|=
name|NULL
decl_stmt|;
name|error
operator|=
name|dest11
operator|->
name|getResource
argument_list|(
operator|&
name|destResource
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|immediateContext
operator|->
name|CopyResource
argument_list|(
name|destResource
argument_list|,
name|mLevelZeroTexture
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ID3D11Resource
modifier|*
name|sourceResouce
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|getResource
argument_list|(
operator|&
name|sourceResouce
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ID3D11Resource
modifier|*
name|destResource
init|=
name|NULL
decl_stmt|;
name|error
operator|=
name|dest11
operator|->
name|getResource
argument_list|(
operator|&
name|destResource
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ID3D11DeviceContext
modifier|*
name|immediateContext
init|=
name|mRenderer
operator|->
name|getDeviceContext
argument_list|()
decl_stmt|;
name|immediateContext
operator|->
name|CopyResource
argument_list|(
name|destResource
argument_list|,
name|sourceResouce
argument_list|)
expr_stmt|;
block|}
name|dest11
operator|->
name|invalidateSwizzleCache
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|useLevelZeroWorkaroundTexture
name|gl
operator|::
name|Error
name|TextureStorage11_Cube
operator|::
name|useLevelZeroWorkaroundTexture
parameter_list|(
name|bool
name|useLevelZeroTexture
parameter_list|)
block|{
if|if
condition|(
name|useLevelZeroTexture
operator|&&
name|mMipLevels
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|mUseLevelZeroTexture
operator|&&
name|mTexture
condition|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|ensureTextureExists
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
comment|// Pull data back from the mipped texture if necessary.
name|ASSERT
argument_list|(
name|mLevelZeroTexture
argument_list|)
expr_stmt|;
name|ID3D11DeviceContext
modifier|*
name|context
init|=
name|mRenderer
operator|->
name|getDeviceContext
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|face
init|=
literal|0
init|;
name|face
operator|<
literal|6
condition|;
name|face
operator|++
control|)
block|{
name|context
operator|->
name|CopySubresourceRegion
argument_list|(
name|mLevelZeroTexture
argument_list|,
name|D3D11CalcSubresource
argument_list|(
literal|0
argument_list|,
name|face
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|mTexture
argument_list|,
name|face
operator|*
name|mMipLevels
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|mUseLevelZeroTexture
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mUseLevelZeroTexture
operator|&&
name|mLevelZeroTexture
condition|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|ensureTextureExists
argument_list|(
name|mMipLevels
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
comment|// Pull data back from the level zero texture if necessary.
name|ASSERT
argument_list|(
name|mTexture
argument_list|)
expr_stmt|;
name|ID3D11DeviceContext
modifier|*
name|context
init|=
name|mRenderer
operator|->
name|getDeviceContext
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|face
init|=
literal|0
init|;
name|face
operator|<
literal|6
condition|;
name|face
operator|++
control|)
block|{
name|context
operator|->
name|CopySubresourceRegion
argument_list|(
name|mTexture
argument_list|,
name|D3D11CalcSubresource
argument_list|(
literal|0
argument_list|,
name|face
argument_list|,
name|mMipLevels
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|mLevelZeroTexture
argument_list|,
name|face
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|mUseLevelZeroTexture
operator|=
literal|false
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|associateImage
name|void
name|TextureStorage11_Cube
operator|::
name|associateImage
parameter_list|(
name|Image11
modifier|*
name|image
parameter_list|,
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|)
block|{
name|GLint
name|level
init|=
name|index
operator|.
name|mipIndex
decl_stmt|;
name|GLint
name|layerTarget
init|=
name|index
operator|.
name|layerIndex
decl_stmt|;
name|ASSERT
argument_list|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
literal|0
operator|<=
name|layerTarget
operator|&&
name|layerTarget
operator|<
name|CUBE_FACE_COUNT
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
block|{
if|if
condition|(
literal|0
operator|<=
name|layerTarget
operator|&&
name|layerTarget
operator|<
name|CUBE_FACE_COUNT
condition|)
block|{
name|mAssociatedImages
index|[
name|layerTarget
index|]
index|[
name|level
index|]
operator|=
name|image
expr_stmt|;
block|}
block|}
block|}
DECL|function|isAssociatedImageValid
name|bool
name|TextureStorage11_Cube
operator|::
name|isAssociatedImageValid
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|,
name|Image11
modifier|*
name|expectedImage
parameter_list|)
block|{
name|GLint
name|level
init|=
name|index
operator|.
name|mipIndex
decl_stmt|;
name|GLint
name|layerTarget
init|=
name|index
operator|.
name|layerIndex
decl_stmt|;
if|if
condition|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
block|{
if|if
condition|(
literal|0
operator|<=
name|layerTarget
operator|&&
name|layerTarget
operator|<
name|CUBE_FACE_COUNT
condition|)
block|{
comment|// This validation check should never return false. It means the Image/TextureStorage association is broken.
name|bool
name|retValue
init|=
operator|(
name|mAssociatedImages
index|[
name|layerTarget
index|]
index|[
name|level
index|]
operator|==
name|expectedImage
operator|)
decl_stmt|;
name|ASSERT
argument_list|(
name|retValue
argument_list|)
expr_stmt|;
return|return
name|retValue
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|// disassociateImage allows an Image to end its association with a Storage.
DECL|function|disassociateImage
name|void
name|TextureStorage11_Cube
operator|::
name|disassociateImage
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|,
name|Image11
modifier|*
name|expectedImage
parameter_list|)
block|{
name|GLint
name|level
init|=
name|index
operator|.
name|mipIndex
decl_stmt|;
name|GLint
name|layerTarget
init|=
name|index
operator|.
name|layerIndex
decl_stmt|;
name|ASSERT
argument_list|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
literal|0
operator|<=
name|layerTarget
operator|&&
name|layerTarget
operator|<
name|CUBE_FACE_COUNT
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
block|{
if|if
condition|(
literal|0
operator|<=
name|layerTarget
operator|&&
name|layerTarget
operator|<
name|CUBE_FACE_COUNT
condition|)
block|{
name|ASSERT
argument_list|(
name|mAssociatedImages
index|[
name|layerTarget
index|]
index|[
name|level
index|]
operator|==
name|expectedImage
argument_list|)
expr_stmt|;
if|if
condition|(
name|mAssociatedImages
index|[
name|layerTarget
index|]
index|[
name|level
index|]
operator|==
name|expectedImage
condition|)
block|{
name|mAssociatedImages
index|[
name|layerTarget
index|]
index|[
name|level
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// releaseAssociatedImage prepares the Storage for a new Image association. It lets the old Image recover its data before ending the association.
DECL|function|releaseAssociatedImage
name|gl
operator|::
name|Error
name|TextureStorage11_Cube
operator|::
name|releaseAssociatedImage
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|,
name|Image11
modifier|*
name|incomingImage
parameter_list|)
block|{
name|GLint
name|level
init|=
name|index
operator|.
name|mipIndex
decl_stmt|;
name|GLint
name|layerTarget
init|=
name|index
operator|.
name|layerIndex
decl_stmt|;
name|ASSERT
argument_list|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
literal|0
operator|<=
name|layerTarget
operator|&&
name|layerTarget
operator|<
name|CUBE_FACE_COUNT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
operator|)
condition|)
block|{
if|if
condition|(
literal|0
operator|<=
name|layerTarget
operator|&&
name|layerTarget
operator|<
name|CUBE_FACE_COUNT
condition|)
block|{
comment|// No need to let the old Image recover its data, if it is also the incoming Image.
if|if
condition|(
name|mAssociatedImages
index|[
name|layerTarget
index|]
index|[
name|level
index|]
operator|!=
name|NULL
operator|&&
name|mAssociatedImages
index|[
name|layerTarget
index|]
index|[
name|level
index|]
operator|!=
name|incomingImage
condition|)
block|{
comment|// Ensure that the Image is still associated with this TextureStorage. This should be true.
name|bool
name|imageAssociationCorrect
init|=
name|mAssociatedImages
index|[
name|layerTarget
index|]
index|[
name|level
index|]
operator|->
name|isAssociatedStorageValid
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|imageAssociationCorrect
argument_list|)
expr_stmt|;
if|if
condition|(
name|imageAssociationCorrect
condition|)
block|{
comment|// Force the image to recover from storage before its data is overwritten.
comment|// This will reset mAssociatedImages[level] to NULL too.
name|gl
operator|::
name|Error
name|error
init|=
name|mAssociatedImages
index|[
name|layerTarget
index|]
index|[
name|level
index|]
operator|->
name|recoverFromAssociatedStorage
argument_list|()
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
block|}
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|getResource
name|gl
operator|::
name|Error
name|TextureStorage11_Cube
operator|::
name|getResource
parameter_list|(
name|ID3D11Resource
modifier|*
modifier|*
name|outResource
parameter_list|)
block|{
if|if
condition|(
name|mUseLevelZeroTexture
operator|&&
name|mMipLevels
operator|>
literal|1
condition|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|ensureTextureExists
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
operator|*
name|outResource
operator|=
name|mLevelZeroTexture
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
else|else
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|ensureTextureExists
argument_list|(
name|mMipLevels
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
operator|*
name|outResource
operator|=
name|mTexture
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
block|}
DECL|function|getMippedResource
name|gl
operator|::
name|Error
name|TextureStorage11_Cube
operator|::
name|getMippedResource
parameter_list|(
name|ID3D11Resource
modifier|*
modifier|*
name|outResource
parameter_list|)
block|{
comment|// This shouldn't be called unless the zero max LOD workaround is active.
name|ASSERT
argument_list|(
name|mRenderer
operator|->
name|getWorkarounds
argument_list|()
operator|.
name|zeroMaxLodWorkaround
argument_list|)
expr_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|ensureTextureExists
argument_list|(
name|mMipLevels
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
operator|*
name|outResource
operator|=
name|mTexture
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|ensureTextureExists
name|gl
operator|::
name|Error
name|TextureStorage11_Cube
operator|::
name|ensureTextureExists
parameter_list|(
name|int
name|mipLevels
parameter_list|)
block|{
comment|// If mMipLevels = 1 then always use mTexture rather than mLevelZeroTexture.
name|bool
name|useLevelZeroTexture
init|=
name|mRenderer
operator|->
name|getWorkarounds
argument_list|()
operator|.
name|zeroMaxLodWorkaround
condition|?
operator|(
name|mipLevels
operator|==
literal|1
operator|)
operator|&&
operator|(
name|mMipLevels
operator|>
literal|1
operator|)
else|:
literal|false
decl_stmt|;
name|ID3D11Texture2D
modifier|*
modifier|*
name|outputTexture
init|=
name|useLevelZeroTexture
condition|?
operator|&
name|mLevelZeroTexture
else|:
operator|&
name|mTexture
decl_stmt|;
comment|// if the size is not positive this should be treated as an incomplete texture
comment|// we handle that here by skipping the d3d texture creation
if|if
condition|(
operator|*
name|outputTexture
operator|==
name|NULL
operator|&&
name|mTextureWidth
operator|>
literal|0
operator|&&
name|mTextureHeight
operator|>
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|mMipLevels
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|D3D11_TEXTURE2D_DESC
name|desc
decl_stmt|;
name|desc
operator|.
name|Width
operator|=
name|mTextureWidth
expr_stmt|;
name|desc
operator|.
name|Height
operator|=
name|mTextureHeight
expr_stmt|;
name|desc
operator|.
name|MipLevels
operator|=
name|mipLevels
expr_stmt|;
name|desc
operator|.
name|ArraySize
operator|=
name|CUBE_FACE_COUNT
expr_stmt|;
name|desc
operator|.
name|Format
operator|=
name|mTextureFormat
expr_stmt|;
name|desc
operator|.
name|SampleDesc
operator|.
name|Count
operator|=
literal|1
expr_stmt|;
name|desc
operator|.
name|SampleDesc
operator|.
name|Quality
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|Usage
operator|=
name|D3D11_USAGE_DEFAULT
expr_stmt|;
name|desc
operator|.
name|BindFlags
operator|=
name|getBindFlags
argument_list|()
expr_stmt|;
name|desc
operator|.
name|CPUAccessFlags
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|MiscFlags
operator|=
name|D3D11_RESOURCE_MISC_TEXTURECUBE
expr_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateTexture2D
argument_list|(
operator|&
name|desc
argument_list|,
name|NULL
argument_list|,
name|outputTexture
argument_list|)
decl_stmt|;
comment|// this can happen from windows TDR
if|if
condition|(
name|d3d11
operator|::
name|isDeviceLostError
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|mRenderer
operator|->
name|notifyDeviceLost
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create cube texture storage, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|result
operator|==
name|E_OUTOFMEMORY
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create cube texture storage, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|getRenderTarget
name|gl
operator|::
name|Error
name|TextureStorage11_Cube
operator|::
name|getRenderTarget
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|,
name|RenderTargetD3D
modifier|*
modifier|*
name|outRT
parameter_list|)
block|{
name|int
name|faceIndex
init|=
name|index
operator|.
name|layerIndex
decl_stmt|;
name|int
name|level
init|=
name|index
operator|.
name|mipIndex
decl_stmt|;
name|ASSERT
argument_list|(
name|level
operator|>=
literal|0
operator|&&
name|level
operator|<
name|getLevelCount
argument_list|()
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|faceIndex
operator|>=
literal|0
operator|&&
name|faceIndex
operator|<
name|CUBE_FACE_COUNT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mRenderTarget
index|[
name|faceIndex
index|]
index|[
name|level
index|]
condition|)
block|{
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|HRESULT
name|result
decl_stmt|;
name|ID3D11Resource
modifier|*
name|texture
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|getResource
argument_list|(
operator|&
name|texture
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
name|mUseLevelZeroTexture
condition|)
block|{
if|if
condition|(
operator|!
name|mLevelZeroRenderTarget
index|[
name|faceIndex
index|]
condition|)
block|{
name|D3D11_RENDER_TARGET_VIEW_DESC
name|rtvDesc
decl_stmt|;
name|rtvDesc
operator|.
name|Format
operator|=
name|mRenderTargetFormat
expr_stmt|;
name|rtvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_RTV_DIMENSION_TEXTURE2DARRAY
expr_stmt|;
name|rtvDesc
operator|.
name|Texture2DArray
operator|.
name|MipSlice
operator|=
name|mTopLevel
operator|+
name|level
expr_stmt|;
name|rtvDesc
operator|.
name|Texture2DArray
operator|.
name|FirstArraySlice
operator|=
name|faceIndex
expr_stmt|;
name|rtvDesc
operator|.
name|Texture2DArray
operator|.
name|ArraySize
operator|=
literal|1
expr_stmt|;
name|ID3D11RenderTargetView
modifier|*
name|rtv
decl_stmt|;
name|result
operator|=
name|device
operator|->
name|CreateRenderTargetView
argument_list|(
name|mLevelZeroTexture
argument_list|,
operator|&
name|rtvDesc
argument_list|,
operator|&
name|rtv
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|E_OUTOFMEMORY
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create internal render target view for texture storage, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|mLevelZeroRenderTarget
index|[
name|faceIndex
index|]
operator|=
operator|new
name|TextureRenderTarget11
argument_list|(
name|rtv
argument_list|,
name|mLevelZeroTexture
argument_list|,
name|NULL
argument_list|,
name|mInternalFormat
argument_list|,
name|getLevelWidth
argument_list|(
name|level
argument_list|)
argument_list|,
name|getLevelHeight
argument_list|(
name|level
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// RenderTarget will take ownership of these resources
name|SafeRelease
argument_list|(
name|rtv
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|outRT
argument_list|)
expr_stmt|;
operator|*
name|outRT
operator|=
name|mLevelZeroRenderTarget
index|[
name|faceIndex
index|]
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
name|D3D11_SHADER_RESOURCE_VIEW_DESC
name|srvDesc
decl_stmt|;
name|srvDesc
operator|.
name|Format
operator|=
name|mShaderResourceFormat
expr_stmt|;
name|srvDesc
operator|.
name|Texture2DArray
operator|.
name|MostDetailedMip
operator|=
name|mTopLevel
operator|+
name|level
expr_stmt|;
name|srvDesc
operator|.
name|Texture2DArray
operator|.
name|MipLevels
operator|=
literal|1
expr_stmt|;
name|srvDesc
operator|.
name|Texture2DArray
operator|.
name|FirstArraySlice
operator|=
name|faceIndex
expr_stmt|;
name|srvDesc
operator|.
name|Texture2DArray
operator|.
name|ArraySize
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mRenderer
operator|->
name|getFeatureLevel
argument_list|()
operator|<=
name|D3D_FEATURE_LEVEL_9_3
condition|)
block|{
name|srvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_SRV_DIMENSION_TEXTURECUBE
expr_stmt|;
block|}
else|else
block|{
name|srvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_SRV_DIMENSION_TEXTURE2DARRAY
expr_stmt|;
comment|// Will be used with Texture2D sampler, not TextureCube
block|}
name|ID3D11ShaderResourceView
modifier|*
name|srv
decl_stmt|;
name|result
operator|=
name|device
operator|->
name|CreateShaderResourceView
argument_list|(
name|texture
argument_list|,
operator|&
name|srvDesc
argument_list|,
operator|&
name|srv
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|result
operator|==
name|E_OUTOFMEMORY
operator|||
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create internal shader resource view for texture storage, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
if|if
condition|(
name|mRenderTargetFormat
operator|!=
name|DXGI_FORMAT_UNKNOWN
condition|)
block|{
name|D3D11_RENDER_TARGET_VIEW_DESC
name|rtvDesc
decl_stmt|;
name|rtvDesc
operator|.
name|Format
operator|=
name|mRenderTargetFormat
expr_stmt|;
name|rtvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_RTV_DIMENSION_TEXTURE2DARRAY
expr_stmt|;
name|rtvDesc
operator|.
name|Texture2DArray
operator|.
name|MipSlice
operator|=
name|mTopLevel
operator|+
name|level
expr_stmt|;
name|rtvDesc
operator|.
name|Texture2DArray
operator|.
name|FirstArraySlice
operator|=
name|faceIndex
expr_stmt|;
name|rtvDesc
operator|.
name|Texture2DArray
operator|.
name|ArraySize
operator|=
literal|1
expr_stmt|;
name|ID3D11RenderTargetView
modifier|*
name|rtv
decl_stmt|;
name|result
operator|=
name|device
operator|->
name|CreateRenderTargetView
argument_list|(
name|texture
argument_list|,
operator|&
name|rtvDesc
argument_list|,
operator|&
name|rtv
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|result
operator|==
name|E_OUTOFMEMORY
operator|||
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|SafeRelease
argument_list|(
name|srv
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create internal render target view for texture storage, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
name|mRenderTarget
index|[
name|faceIndex
index|]
index|[
name|level
index|]
operator|=
operator|new
name|TextureRenderTarget11
argument_list|(
name|rtv
argument_list|,
name|texture
argument_list|,
name|srv
argument_list|,
name|mInternalFormat
argument_list|,
name|getLevelWidth
argument_list|(
name|level
argument_list|)
argument_list|,
name|getLevelHeight
argument_list|(
name|level
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// RenderTarget will take ownership of these resources
name|SafeRelease
argument_list|(
name|rtv
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|srv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mDepthStencilFormat
operator|!=
name|DXGI_FORMAT_UNKNOWN
condition|)
block|{
name|D3D11_DEPTH_STENCIL_VIEW_DESC
name|dsvDesc
decl_stmt|;
name|dsvDesc
operator|.
name|Format
operator|=
name|mDepthStencilFormat
expr_stmt|;
name|dsvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_DSV_DIMENSION_TEXTURE2DARRAY
expr_stmt|;
name|dsvDesc
operator|.
name|Flags
operator|=
literal|0
expr_stmt|;
name|dsvDesc
operator|.
name|Texture2DArray
operator|.
name|MipSlice
operator|=
name|mTopLevel
operator|+
name|level
expr_stmt|;
name|dsvDesc
operator|.
name|Texture2DArray
operator|.
name|FirstArraySlice
operator|=
name|faceIndex
expr_stmt|;
name|dsvDesc
operator|.
name|Texture2DArray
operator|.
name|ArraySize
operator|=
literal|1
expr_stmt|;
name|ID3D11DepthStencilView
modifier|*
name|dsv
decl_stmt|;
name|result
operator|=
name|device
operator|->
name|CreateDepthStencilView
argument_list|(
name|texture
argument_list|,
operator|&
name|dsvDesc
argument_list|,
operator|&
name|dsv
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|result
operator|==
name|E_OUTOFMEMORY
operator|||
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|SafeRelease
argument_list|(
name|srv
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create internal depth stencil view for texture storage, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
name|mRenderTarget
index|[
name|faceIndex
index|]
index|[
name|level
index|]
operator|=
operator|new
name|TextureRenderTarget11
argument_list|(
name|dsv
argument_list|,
name|texture
argument_list|,
name|srv
argument_list|,
name|mInternalFormat
argument_list|,
name|getLevelWidth
argument_list|(
name|level
argument_list|)
argument_list|,
name|getLevelHeight
argument_list|(
name|level
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// RenderTarget will take ownership of these resources
name|SafeRelease
argument_list|(
name|dsv
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|srv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
name|ASSERT
argument_list|(
name|outRT
argument_list|)
expr_stmt|;
operator|*
name|outRT
operator|=
name|mRenderTarget
index|[
name|faceIndex
index|]
index|[
name|level
index|]
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|createSRV
name|gl
operator|::
name|Error
name|TextureStorage11_Cube
operator|::
name|createSRV
parameter_list|(
name|int
name|baseLevel
parameter_list|,
name|int
name|mipLevels
parameter_list|,
name|DXGI_FORMAT
name|format
parameter_list|,
name|ID3D11Resource
modifier|*
name|texture
parameter_list|,
name|ID3D11ShaderResourceView
modifier|*
modifier|*
name|outSRV
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|outSRV
argument_list|)
expr_stmt|;
name|D3D11_SHADER_RESOURCE_VIEW_DESC
name|srvDesc
decl_stmt|;
name|srvDesc
operator|.
name|Format
operator|=
name|format
expr_stmt|;
comment|// Unnormalized integer cube maps are not supported by DX11; we emulate them as an array of six 2D textures
specifier|const
name|d3d11
operator|::
name|DXGIFormat
modifier|&
name|dxgiFormatInfo
init|=
name|d3d11
operator|::
name|GetDXGIFormatInfo
argument_list|(
name|format
argument_list|)
decl_stmt|;
if|if
condition|(
name|dxgiFormatInfo
operator|.
name|componentType
operator|==
name|GL_INT
operator|||
name|dxgiFormatInfo
operator|.
name|componentType
operator|==
name|GL_UNSIGNED_INT
condition|)
block|{
name|srvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_SRV_DIMENSION_TEXTURE2DARRAY
expr_stmt|;
name|srvDesc
operator|.
name|Texture2DArray
operator|.
name|MostDetailedMip
operator|=
name|mTopLevel
operator|+
name|baseLevel
expr_stmt|;
name|srvDesc
operator|.
name|Texture2DArray
operator|.
name|MipLevels
operator|=
literal|1
expr_stmt|;
name|srvDesc
operator|.
name|Texture2DArray
operator|.
name|FirstArraySlice
operator|=
literal|0
expr_stmt|;
name|srvDesc
operator|.
name|Texture2DArray
operator|.
name|ArraySize
operator|=
name|CUBE_FACE_COUNT
expr_stmt|;
block|}
else|else
block|{
name|srvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_SRV_DIMENSION_TEXTURECUBE
expr_stmt|;
name|srvDesc
operator|.
name|TextureCube
operator|.
name|MipLevels
operator|=
name|mipLevels
expr_stmt|;
name|srvDesc
operator|.
name|TextureCube
operator|.
name|MostDetailedMip
operator|=
name|mTopLevel
operator|+
name|baseLevel
expr_stmt|;
block|}
name|ID3D11Resource
modifier|*
name|srvTexture
init|=
name|texture
decl_stmt|;
if|if
condition|(
name|mRenderer
operator|->
name|getWorkarounds
argument_list|()
operator|.
name|zeroMaxLodWorkaround
condition|)
block|{
name|ASSERT
argument_list|(
name|mTopLevel
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|baseLevel
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|// This code also assumes that the incoming texture equals either mLevelZeroTexture or mTexture.
if|if
condition|(
name|mipLevels
operator|==
literal|1
operator|&&
name|mMipLevels
operator|>
literal|1
condition|)
block|{
comment|// We must use a SRV on the level-zero-only texture.
name|ASSERT
argument_list|(
name|mLevelZeroTexture
operator|!=
name|NULL
operator|&&
name|texture
operator|==
name|mLevelZeroTexture
argument_list|)
expr_stmt|;
name|srvTexture
operator|=
name|mLevelZeroTexture
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|mipLevels
operator|==
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|mMipLevels
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mTexture
operator|!=
name|NULL
operator|&&
name|texture
operator|==
name|mTexture
argument_list|)
expr_stmt|;
name|srvTexture
operator|=
name|mTexture
expr_stmt|;
block|}
block|}
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateShaderResourceView
argument_list|(
name|srvTexture
argument_list|,
operator|&
name|srvDesc
argument_list|,
name|outSRV
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|result
operator|==
name|E_OUTOFMEMORY
operator|||
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create internal texture storage SRV, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|getSwizzleTexture
name|gl
operator|::
name|Error
name|TextureStorage11_Cube
operator|::
name|getSwizzleTexture
parameter_list|(
name|ID3D11Resource
modifier|*
modifier|*
name|outTexture
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|outTexture
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mSwizzleTexture
condition|)
block|{
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|D3D11_TEXTURE2D_DESC
name|desc
decl_stmt|;
name|desc
operator|.
name|Width
operator|=
name|mTextureWidth
expr_stmt|;
name|desc
operator|.
name|Height
operator|=
name|mTextureHeight
expr_stmt|;
name|desc
operator|.
name|MipLevels
operator|=
name|mMipLevels
expr_stmt|;
name|desc
operator|.
name|ArraySize
operator|=
name|CUBE_FACE_COUNT
expr_stmt|;
name|desc
operator|.
name|Format
operator|=
name|mSwizzleTextureFormat
expr_stmt|;
name|desc
operator|.
name|SampleDesc
operator|.
name|Count
operator|=
literal|1
expr_stmt|;
name|desc
operator|.
name|SampleDesc
operator|.
name|Quality
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|Usage
operator|=
name|D3D11_USAGE_DEFAULT
expr_stmt|;
name|desc
operator|.
name|BindFlags
operator|=
name|D3D11_BIND_SHADER_RESOURCE
operator||
name|D3D11_BIND_RENDER_TARGET
expr_stmt|;
name|desc
operator|.
name|CPUAccessFlags
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|MiscFlags
operator|=
name|D3D11_RESOURCE_MISC_TEXTURECUBE
expr_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateTexture2D
argument_list|(
operator|&
name|desc
argument_list|,
name|NULL
argument_list|,
operator|&
name|mSwizzleTexture
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|result
operator|==
name|E_OUTOFMEMORY
operator|||
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create internal swizzle texture, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
operator|*
name|outTexture
operator|=
name|mSwizzleTexture
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|getSwizzleRenderTarget
name|gl
operator|::
name|Error
name|TextureStorage11_Cube
operator|::
name|getSwizzleRenderTarget
parameter_list|(
name|int
name|mipLevel
parameter_list|,
name|ID3D11RenderTargetView
modifier|*
modifier|*
name|outRTV
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|mipLevel
operator|>=
literal|0
operator|&&
name|mipLevel
operator|<
name|getLevelCount
argument_list|()
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|outRTV
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mSwizzleRenderTargets
index|[
name|mipLevel
index|]
condition|)
block|{
name|ID3D11Resource
modifier|*
name|swizzleTexture
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|getSwizzleTexture
argument_list|(
operator|&
name|swizzleTexture
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|D3D11_RENDER_TARGET_VIEW_DESC
name|rtvDesc
decl_stmt|;
name|rtvDesc
operator|.
name|Format
operator|=
name|mSwizzleRenderTargetFormat
expr_stmt|;
name|rtvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_RTV_DIMENSION_TEXTURE2DARRAY
expr_stmt|;
name|rtvDesc
operator|.
name|Texture2DArray
operator|.
name|MipSlice
operator|=
name|mTopLevel
operator|+
name|mipLevel
expr_stmt|;
name|rtvDesc
operator|.
name|Texture2DArray
operator|.
name|FirstArraySlice
operator|=
literal|0
expr_stmt|;
name|rtvDesc
operator|.
name|Texture2DArray
operator|.
name|ArraySize
operator|=
name|CUBE_FACE_COUNT
expr_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateRenderTargetView
argument_list|(
name|mSwizzleTexture
argument_list|,
operator|&
name|rtvDesc
argument_list|,
operator|&
name|mSwizzleRenderTargets
index|[
name|mipLevel
index|]
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|result
operator|==
name|E_OUTOFMEMORY
operator|||
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create internal swizzle render target view, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
operator|*
name|outRTV
operator|=
name|mSwizzleRenderTargets
index|[
name|mipLevel
index|]
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|TextureStorage11_3D
name|TextureStorage11_3D
operator|::
name|TextureStorage11_3D
parameter_list|(
name|Renderer11
modifier|*
name|renderer
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|bool
name|renderTarget
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|depth
parameter_list|,
name|int
name|levels
parameter_list|)
member_init_list|:
name|TextureStorage11
argument_list|(
name|renderer
argument_list|,
name|GetTextureBindFlags
argument_list|(
name|internalformat
argument_list|,
name|renderer
operator|->
name|getFeatureLevel
argument_list|()
argument_list|,
name|renderTarget
argument_list|)
argument_list|)
block|{
name|mTexture
operator|=
name|NULL
expr_stmt|;
name|mSwizzleTexture
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|i
operator|++
control|)
block|{
name|mAssociatedImages
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|mLevelRenderTargets
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|mSwizzleRenderTargets
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|mInternalFormat
operator|=
name|internalformat
expr_stmt|;
specifier|const
name|d3d11
operator|::
name|TextureFormat
modifier|&
name|formatInfo
init|=
name|d3d11
operator|::
name|GetTextureFormatInfo
argument_list|(
name|internalformat
argument_list|,
name|renderer
operator|->
name|getFeatureLevel
argument_list|()
argument_list|)
decl_stmt|;
name|mTextureFormat
operator|=
name|formatInfo
operator|.
name|texFormat
expr_stmt|;
name|mShaderResourceFormat
operator|=
name|formatInfo
operator|.
name|srvFormat
expr_stmt|;
name|mDepthStencilFormat
operator|=
name|formatInfo
operator|.
name|dsvFormat
expr_stmt|;
name|mRenderTargetFormat
operator|=
name|formatInfo
operator|.
name|rtvFormat
expr_stmt|;
name|mSwizzleTextureFormat
operator|=
name|formatInfo
operator|.
name|swizzleTexFormat
expr_stmt|;
name|mSwizzleShaderResourceFormat
operator|=
name|formatInfo
operator|.
name|swizzleSRVFormat
expr_stmt|;
name|mSwizzleRenderTargetFormat
operator|=
name|formatInfo
operator|.
name|swizzleRTVFormat
expr_stmt|;
comment|// adjust size if needed for compressed textures
name|d3d11
operator|::
name|MakeValidSize
argument_list|(
literal|false
argument_list|,
name|mTextureFormat
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|height
argument_list|,
operator|&
name|mTopLevel
argument_list|)
expr_stmt|;
name|mMipLevels
operator|=
name|mTopLevel
operator|+
name|levels
expr_stmt|;
name|mTextureWidth
operator|=
name|width
expr_stmt|;
name|mTextureHeight
operator|=
name|height
expr_stmt|;
name|mTextureDepth
operator|=
name|depth
expr_stmt|;
name|initializeSerials
argument_list|(
name|getLevelCount
argument_list|()
operator|*
name|depth
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
DECL|function|~TextureStorage11_3D
name|TextureStorage11_3D
operator|::
name|~
name|TextureStorage11_3D
parameter_list|()
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mAssociatedImages
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|bool
name|imageAssociationCorrect
init|=
name|mAssociatedImages
index|[
name|i
index|]
operator|->
name|isAssociatedStorageValid
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|imageAssociationCorrect
argument_list|)
expr_stmt|;
if|if
condition|(
name|imageAssociationCorrect
condition|)
block|{
comment|// We must let the Images recover their data before we delete it from the TextureStorage.
name|mAssociatedImages
index|[
name|i
index|]
operator|->
name|recoverFromAssociatedStorage
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|SafeRelease
argument_list|(
name|mTexture
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mSwizzleTexture
argument_list|)
expr_stmt|;
for|for
control|(
name|RenderTargetMap
operator|::
name|iterator
name|i
init|=
name|mLevelLayerRenderTargets
operator|.
name|begin
argument_list|()
init|;
name|i
operator|!=
name|mLevelLayerRenderTargets
operator|.
name|end
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|SafeDelete
argument_list|(
name|i
operator|->
name|second
argument_list|)
expr_stmt|;
block|}
name|mLevelLayerRenderTargets
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|i
operator|++
control|)
block|{
name|SafeDelete
argument_list|(
name|mLevelRenderTargets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mSwizzleRenderTargets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|makeTextureStorage11_3D
name|TextureStorage11_3D
modifier|*
name|TextureStorage11_3D
operator|::
name|makeTextureStorage11_3D
parameter_list|(
name|TextureStorage
modifier|*
name|storage
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|HAS_DYNAMIC_TYPE
argument_list|(
name|TextureStorage11_3D
operator|*
argument_list|,
name|storage
argument_list|)
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|TextureStorage11_3D
operator|*
argument_list|>
argument_list|(
name|storage
argument_list|)
return|;
block|}
DECL|function|associateImage
name|void
name|TextureStorage11_3D
operator|::
name|associateImage
parameter_list|(
name|Image11
modifier|*
name|image
parameter_list|,
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|)
block|{
name|GLint
name|level
init|=
name|index
operator|.
name|mipIndex
decl_stmt|;
name|ASSERT
argument_list|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
block|{
name|mAssociatedImages
index|[
name|level
index|]
operator|=
name|image
expr_stmt|;
block|}
block|}
DECL|function|isAssociatedImageValid
name|bool
name|TextureStorage11_3D
operator|::
name|isAssociatedImageValid
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|,
name|Image11
modifier|*
name|expectedImage
parameter_list|)
block|{
name|GLint
name|level
init|=
name|index
operator|.
name|mipIndex
decl_stmt|;
if|if
condition|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
block|{
comment|// This validation check should never return false. It means the Image/TextureStorage association is broken.
name|bool
name|retValue
init|=
operator|(
name|mAssociatedImages
index|[
name|level
index|]
operator|==
name|expectedImage
operator|)
decl_stmt|;
name|ASSERT
argument_list|(
name|retValue
argument_list|)
expr_stmt|;
return|return
name|retValue
return|;
block|}
return|return
literal|false
return|;
block|}
comment|// disassociateImage allows an Image to end its association with a Storage.
DECL|function|disassociateImage
name|void
name|TextureStorage11_3D
operator|::
name|disassociateImage
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|,
name|Image11
modifier|*
name|expectedImage
parameter_list|)
block|{
name|GLint
name|level
init|=
name|index
operator|.
name|mipIndex
decl_stmt|;
name|ASSERT
argument_list|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
block|{
name|ASSERT
argument_list|(
name|mAssociatedImages
index|[
name|level
index|]
operator|==
name|expectedImage
argument_list|)
expr_stmt|;
if|if
condition|(
name|mAssociatedImages
index|[
name|level
index|]
operator|==
name|expectedImage
condition|)
block|{
name|mAssociatedImages
index|[
name|level
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
comment|// releaseAssociatedImage prepares the Storage for a new Image association. It lets the old Image recover its data before ending the association.
DECL|function|releaseAssociatedImage
name|gl
operator|::
name|Error
name|TextureStorage11_3D
operator|::
name|releaseAssociatedImage
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|,
name|Image11
modifier|*
name|incomingImage
parameter_list|)
block|{
name|GLint
name|level
init|=
name|index
operator|.
name|mipIndex
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|)
block|{
comment|// No need to let the old Image recover its data, if it is also the incoming Image.
if|if
condition|(
name|mAssociatedImages
index|[
name|level
index|]
operator|!=
name|NULL
operator|&&
name|mAssociatedImages
index|[
name|level
index|]
operator|!=
name|incomingImage
condition|)
block|{
comment|// Ensure that the Image is still associated with this TextureStorage. This should be true.
name|bool
name|imageAssociationCorrect
init|=
name|mAssociatedImages
index|[
name|level
index|]
operator|->
name|isAssociatedStorageValid
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|imageAssociationCorrect
argument_list|)
expr_stmt|;
if|if
condition|(
name|imageAssociationCorrect
condition|)
block|{
comment|// Force the image to recover from storage before its data is overwritten.
comment|// This will reset mAssociatedImages[level] to NULL too.
name|gl
operator|::
name|Error
name|error
init|=
name|mAssociatedImages
index|[
name|level
index|]
operator|->
name|recoverFromAssociatedStorage
argument_list|()
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|getResource
name|gl
operator|::
name|Error
name|TextureStorage11_3D
operator|::
name|getResource
parameter_list|(
name|ID3D11Resource
modifier|*
modifier|*
name|outResource
parameter_list|)
block|{
comment|// If the width, height or depth are not positive this should be treated as an incomplete texture
comment|// we handle that here by skipping the d3d texture creation
if|if
condition|(
name|mTexture
operator|==
name|NULL
operator|&&
name|mTextureWidth
operator|>
literal|0
operator|&&
name|mTextureHeight
operator|>
literal|0
operator|&&
name|mTextureDepth
operator|>
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|mMipLevels
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|D3D11_TEXTURE3D_DESC
name|desc
decl_stmt|;
name|desc
operator|.
name|Width
operator|=
name|mTextureWidth
expr_stmt|;
name|desc
operator|.
name|Height
operator|=
name|mTextureHeight
expr_stmt|;
name|desc
operator|.
name|Depth
operator|=
name|mTextureDepth
expr_stmt|;
name|desc
operator|.
name|MipLevels
operator|=
name|mMipLevels
expr_stmt|;
name|desc
operator|.
name|Format
operator|=
name|mTextureFormat
expr_stmt|;
name|desc
operator|.
name|Usage
operator|=
name|D3D11_USAGE_DEFAULT
expr_stmt|;
name|desc
operator|.
name|BindFlags
operator|=
name|getBindFlags
argument_list|()
expr_stmt|;
name|desc
operator|.
name|CPUAccessFlags
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateTexture3D
argument_list|(
operator|&
name|desc
argument_list|,
name|NULL
argument_list|,
operator|&
name|mTexture
argument_list|)
decl_stmt|;
comment|// this can happen from windows TDR
if|if
condition|(
name|d3d11
operator|::
name|isDeviceLostError
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|mRenderer
operator|->
name|notifyDeviceLost
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create 3D texture storage, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|result
operator|==
name|E_OUTOFMEMORY
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create 3D texture storage, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
operator|*
name|outResource
operator|=
name|mTexture
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|createSRV
name|gl
operator|::
name|Error
name|TextureStorage11_3D
operator|::
name|createSRV
parameter_list|(
name|int
name|baseLevel
parameter_list|,
name|int
name|mipLevels
parameter_list|,
name|DXGI_FORMAT
name|format
parameter_list|,
name|ID3D11Resource
modifier|*
name|texture
parameter_list|,
name|ID3D11ShaderResourceView
modifier|*
modifier|*
name|outSRV
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|outSRV
argument_list|)
expr_stmt|;
name|D3D11_SHADER_RESOURCE_VIEW_DESC
name|srvDesc
decl_stmt|;
name|srvDesc
operator|.
name|Format
operator|=
name|format
expr_stmt|;
name|srvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_SRV_DIMENSION_TEXTURE3D
expr_stmt|;
name|srvDesc
operator|.
name|Texture3D
operator|.
name|MostDetailedMip
operator|=
name|baseLevel
expr_stmt|;
name|srvDesc
operator|.
name|Texture3D
operator|.
name|MipLevels
operator|=
name|mipLevels
expr_stmt|;
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateShaderResourceView
argument_list|(
name|texture
argument_list|,
operator|&
name|srvDesc
argument_list|,
name|outSRV
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|result
operator|==
name|E_OUTOFMEMORY
operator|||
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create internal texture storage SRV, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|getRenderTarget
name|gl
operator|::
name|Error
name|TextureStorage11_3D
operator|::
name|getRenderTarget
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|,
name|RenderTargetD3D
modifier|*
modifier|*
name|outRT
parameter_list|)
block|{
name|int
name|mipLevel
init|=
name|index
operator|.
name|mipIndex
decl_stmt|;
name|ASSERT
argument_list|(
name|mipLevel
operator|>=
literal|0
operator|&&
name|mipLevel
operator|<
name|getLevelCount
argument_list|()
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mRenderTargetFormat
operator|!=
name|DXGI_FORMAT_UNKNOWN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|index
operator|.
name|hasLayer
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|mLevelRenderTargets
index|[
name|mipLevel
index|]
condition|)
block|{
name|ID3D11Resource
modifier|*
name|texture
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|getResource
argument_list|(
operator|&
name|texture
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ID3D11ShaderResourceView
modifier|*
name|srv
init|=
name|NULL
decl_stmt|;
name|error
operator|=
name|getSRVLevel
argument_list|(
name|mipLevel
argument_list|,
operator|&
name|srv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|D3D11_RENDER_TARGET_VIEW_DESC
name|rtvDesc
decl_stmt|;
name|rtvDesc
operator|.
name|Format
operator|=
name|mRenderTargetFormat
expr_stmt|;
name|rtvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_RTV_DIMENSION_TEXTURE3D
expr_stmt|;
name|rtvDesc
operator|.
name|Texture3D
operator|.
name|MipSlice
operator|=
name|mTopLevel
operator|+
name|mipLevel
expr_stmt|;
name|rtvDesc
operator|.
name|Texture3D
operator|.
name|FirstWSlice
operator|=
literal|0
expr_stmt|;
name|rtvDesc
operator|.
name|Texture3D
operator|.
name|WSize
operator|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ID3D11RenderTargetView
modifier|*
name|rtv
decl_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateRenderTargetView
argument_list|(
name|texture
argument_list|,
operator|&
name|rtvDesc
argument_list|,
operator|&
name|rtv
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|result
operator|==
name|E_OUTOFMEMORY
operator|||
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|SafeRelease
argument_list|(
name|srv
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create internal render target view for texture storage, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
name|mLevelRenderTargets
index|[
name|mipLevel
index|]
operator|=
operator|new
name|TextureRenderTarget11
argument_list|(
name|rtv
argument_list|,
name|texture
argument_list|,
name|srv
argument_list|,
name|mInternalFormat
argument_list|,
name|getLevelWidth
argument_list|(
name|mipLevel
argument_list|)
argument_list|,
name|getLevelHeight
argument_list|(
name|mipLevel
argument_list|)
argument_list|,
name|getLevelDepth
argument_list|(
name|mipLevel
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// RenderTarget will take ownership of these resources
name|SafeRelease
argument_list|(
name|rtv
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|outRT
argument_list|)
expr_stmt|;
operator|*
name|outRT
operator|=
name|mLevelRenderTargets
index|[
name|mipLevel
index|]
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
else|else
block|{
name|int
name|layer
init|=
name|index
operator|.
name|layerIndex
decl_stmt|;
name|LevelLayerKey
name|key
argument_list|(
name|mipLevel
argument_list|,
name|layer
argument_list|)
decl_stmt|;
if|if
condition|(
name|mLevelLayerRenderTargets
operator|.
name|find
argument_list|(
name|key
argument_list|)
operator|==
name|mLevelLayerRenderTargets
operator|.
name|end
argument_list|()
condition|)
block|{
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|HRESULT
name|result
decl_stmt|;
name|ID3D11Resource
modifier|*
name|texture
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|getResource
argument_list|(
operator|&
name|texture
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
comment|// TODO, what kind of SRV is expected here?
name|ID3D11ShaderResourceView
modifier|*
name|srv
init|=
name|NULL
decl_stmt|;
name|D3D11_RENDER_TARGET_VIEW_DESC
name|rtvDesc
decl_stmt|;
name|rtvDesc
operator|.
name|Format
operator|=
name|mRenderTargetFormat
expr_stmt|;
name|rtvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_RTV_DIMENSION_TEXTURE3D
expr_stmt|;
name|rtvDesc
operator|.
name|Texture3D
operator|.
name|MipSlice
operator|=
name|mTopLevel
operator|+
name|mipLevel
expr_stmt|;
name|rtvDesc
operator|.
name|Texture3D
operator|.
name|FirstWSlice
operator|=
name|layer
expr_stmt|;
name|rtvDesc
operator|.
name|Texture3D
operator|.
name|WSize
operator|=
literal|1
expr_stmt|;
name|ID3D11RenderTargetView
modifier|*
name|rtv
decl_stmt|;
name|result
operator|=
name|device
operator|->
name|CreateRenderTargetView
argument_list|(
name|texture
argument_list|,
operator|&
name|rtvDesc
argument_list|,
operator|&
name|rtv
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|result
operator|==
name|E_OUTOFMEMORY
operator|||
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|SafeRelease
argument_list|(
name|srv
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create internal render target view for texture storage, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|mLevelLayerRenderTargets
index|[
name|key
index|]
operator|=
operator|new
name|TextureRenderTarget11
argument_list|(
name|rtv
argument_list|,
name|texture
argument_list|,
name|srv
argument_list|,
name|mInternalFormat
argument_list|,
name|getLevelWidth
argument_list|(
name|mipLevel
argument_list|)
argument_list|,
name|getLevelHeight
argument_list|(
name|mipLevel
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// RenderTarget will take ownership of these resources
name|SafeRelease
argument_list|(
name|rtv
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|outRT
argument_list|)
expr_stmt|;
operator|*
name|outRT
operator|=
name|mLevelLayerRenderTargets
index|[
name|key
index|]
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
block|}
DECL|function|getSwizzleTexture
name|gl
operator|::
name|Error
name|TextureStorage11_3D
operator|::
name|getSwizzleTexture
parameter_list|(
name|ID3D11Resource
modifier|*
modifier|*
name|outTexture
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|outTexture
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mSwizzleTexture
condition|)
block|{
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|D3D11_TEXTURE3D_DESC
name|desc
decl_stmt|;
name|desc
operator|.
name|Width
operator|=
name|mTextureWidth
expr_stmt|;
name|desc
operator|.
name|Height
operator|=
name|mTextureHeight
expr_stmt|;
name|desc
operator|.
name|Depth
operator|=
name|mTextureDepth
expr_stmt|;
name|desc
operator|.
name|MipLevels
operator|=
name|mMipLevels
expr_stmt|;
name|desc
operator|.
name|Format
operator|=
name|mSwizzleTextureFormat
expr_stmt|;
name|desc
operator|.
name|Usage
operator|=
name|D3D11_USAGE_DEFAULT
expr_stmt|;
name|desc
operator|.
name|BindFlags
operator|=
name|D3D11_BIND_SHADER_RESOURCE
operator||
name|D3D11_BIND_RENDER_TARGET
expr_stmt|;
name|desc
operator|.
name|CPUAccessFlags
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateTexture3D
argument_list|(
operator|&
name|desc
argument_list|,
name|NULL
argument_list|,
operator|&
name|mSwizzleTexture
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|result
operator|==
name|E_OUTOFMEMORY
operator|||
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create internal swizzle texture, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
operator|*
name|outTexture
operator|=
name|mSwizzleTexture
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|getSwizzleRenderTarget
name|gl
operator|::
name|Error
name|TextureStorage11_3D
operator|::
name|getSwizzleRenderTarget
parameter_list|(
name|int
name|mipLevel
parameter_list|,
name|ID3D11RenderTargetView
modifier|*
modifier|*
name|outRTV
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|mipLevel
operator|>=
literal|0
operator|&&
name|mipLevel
operator|<
name|getLevelCount
argument_list|()
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|outRTV
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mSwizzleRenderTargets
index|[
name|mipLevel
index|]
condition|)
block|{
name|ID3D11Resource
modifier|*
name|swizzleTexture
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|getSwizzleTexture
argument_list|(
operator|&
name|swizzleTexture
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|D3D11_RENDER_TARGET_VIEW_DESC
name|rtvDesc
decl_stmt|;
name|rtvDesc
operator|.
name|Format
operator|=
name|mSwizzleRenderTargetFormat
expr_stmt|;
name|rtvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_RTV_DIMENSION_TEXTURE3D
expr_stmt|;
name|rtvDesc
operator|.
name|Texture3D
operator|.
name|MipSlice
operator|=
name|mTopLevel
operator|+
name|mipLevel
expr_stmt|;
name|rtvDesc
operator|.
name|Texture3D
operator|.
name|FirstWSlice
operator|=
literal|0
expr_stmt|;
name|rtvDesc
operator|.
name|Texture3D
operator|.
name|WSize
operator|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateRenderTargetView
argument_list|(
name|mSwizzleTexture
argument_list|,
operator|&
name|rtvDesc
argument_list|,
operator|&
name|mSwizzleRenderTargets
index|[
name|mipLevel
index|]
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|result
operator|==
name|E_OUTOFMEMORY
operator|||
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create internal swizzle render target view, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
operator|*
name|outRTV
operator|=
name|mSwizzleRenderTargets
index|[
name|mipLevel
index|]
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|TextureStorage11_2DArray
name|TextureStorage11_2DArray
operator|::
name|TextureStorage11_2DArray
parameter_list|(
name|Renderer11
modifier|*
name|renderer
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|bool
name|renderTarget
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|depth
parameter_list|,
name|int
name|levels
parameter_list|)
member_init_list|:
name|TextureStorage11
argument_list|(
name|renderer
argument_list|,
name|GetTextureBindFlags
argument_list|(
name|internalformat
argument_list|,
name|renderer
operator|->
name|getFeatureLevel
argument_list|()
argument_list|,
name|renderTarget
argument_list|)
argument_list|)
block|{
name|mTexture
operator|=
name|NULL
expr_stmt|;
name|mSwizzleTexture
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|level
operator|++
control|)
block|{
name|mSwizzleRenderTargets
index|[
name|level
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|mInternalFormat
operator|=
name|internalformat
expr_stmt|;
specifier|const
name|d3d11
operator|::
name|TextureFormat
modifier|&
name|formatInfo
init|=
name|d3d11
operator|::
name|GetTextureFormatInfo
argument_list|(
name|internalformat
argument_list|,
name|renderer
operator|->
name|getFeatureLevel
argument_list|()
argument_list|)
decl_stmt|;
name|mTextureFormat
operator|=
name|formatInfo
operator|.
name|texFormat
expr_stmt|;
name|mShaderResourceFormat
operator|=
name|formatInfo
operator|.
name|srvFormat
expr_stmt|;
name|mDepthStencilFormat
operator|=
name|formatInfo
operator|.
name|dsvFormat
expr_stmt|;
name|mRenderTargetFormat
operator|=
name|formatInfo
operator|.
name|rtvFormat
expr_stmt|;
name|mSwizzleTextureFormat
operator|=
name|formatInfo
operator|.
name|swizzleTexFormat
expr_stmt|;
name|mSwizzleShaderResourceFormat
operator|=
name|formatInfo
operator|.
name|swizzleSRVFormat
expr_stmt|;
name|mSwizzleRenderTargetFormat
operator|=
name|formatInfo
operator|.
name|swizzleRTVFormat
expr_stmt|;
comment|// adjust size if needed for compressed textures
name|d3d11
operator|::
name|MakeValidSize
argument_list|(
literal|false
argument_list|,
name|mTextureFormat
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|height
argument_list|,
operator|&
name|mTopLevel
argument_list|)
expr_stmt|;
name|mMipLevels
operator|=
name|mTopLevel
operator|+
name|levels
expr_stmt|;
name|mTextureWidth
operator|=
name|width
expr_stmt|;
name|mTextureHeight
operator|=
name|height
expr_stmt|;
name|mTextureDepth
operator|=
name|depth
expr_stmt|;
name|initializeSerials
argument_list|(
name|getLevelCount
argument_list|()
operator|*
name|depth
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
DECL|function|~TextureStorage11_2DArray
name|TextureStorage11_2DArray
operator|::
name|~
name|TextureStorage11_2DArray
parameter_list|()
block|{
for|for
control|(
name|ImageMap
operator|::
name|iterator
name|i
init|=
name|mAssociatedImages
operator|.
name|begin
argument_list|()
init|;
name|i
operator|!=
name|mAssociatedImages
operator|.
name|end
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|->
name|second
condition|)
block|{
name|bool
name|imageAssociationCorrect
init|=
name|i
operator|->
name|second
operator|->
name|isAssociatedStorageValid
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|imageAssociationCorrect
argument_list|)
expr_stmt|;
if|if
condition|(
name|imageAssociationCorrect
condition|)
block|{
comment|// We must let the Images recover their data before we delete it from the TextureStorage.
name|i
operator|->
name|second
operator|->
name|recoverFromAssociatedStorage
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|mAssociatedImages
operator|.
name|clear
argument_list|()
expr_stmt|;
name|SafeRelease
argument_list|(
name|mTexture
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mSwizzleTexture
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_LEVELS
condition|;
name|level
operator|++
control|)
block|{
name|SafeRelease
argument_list|(
name|mSwizzleRenderTargets
index|[
name|level
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|RenderTargetMap
operator|::
name|iterator
name|i
init|=
name|mRenderTargets
operator|.
name|begin
argument_list|()
init|;
name|i
operator|!=
name|mRenderTargets
operator|.
name|end
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|SafeDelete
argument_list|(
name|i
operator|->
name|second
argument_list|)
expr_stmt|;
block|}
name|mRenderTargets
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|function|makeTextureStorage11_2DArray
name|TextureStorage11_2DArray
modifier|*
name|TextureStorage11_2DArray
operator|::
name|makeTextureStorage11_2DArray
parameter_list|(
name|TextureStorage
modifier|*
name|storage
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|HAS_DYNAMIC_TYPE
argument_list|(
name|TextureStorage11_2DArray
operator|*
argument_list|,
name|storage
argument_list|)
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|TextureStorage11_2DArray
operator|*
argument_list|>
argument_list|(
name|storage
argument_list|)
return|;
block|}
DECL|function|associateImage
name|void
name|TextureStorage11_2DArray
operator|::
name|associateImage
parameter_list|(
name|Image11
modifier|*
name|image
parameter_list|,
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|)
block|{
name|GLint
name|level
init|=
name|index
operator|.
name|mipIndex
decl_stmt|;
name|GLint
name|layerTarget
init|=
name|index
operator|.
name|layerIndex
decl_stmt|;
name|ASSERT
argument_list|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|getLevelCount
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|level
operator|&&
name|level
operator|<
name|getLevelCount
argument_list|()
condition|)
block|{
name|LevelLayerKey
name|key
argument_list|(
name|level
argument_list|,
name|layerTarget
argument_list|)
decl_stmt|;
name|mAssociatedImages
index|[
name|key
index|]
operator|=
name|image
expr_stmt|;
block|}
block|}
DECL|function|isAssociatedImageValid
name|bool
name|TextureStorage11_2DArray
operator|::
name|isAssociatedImageValid
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|,
name|Image11
modifier|*
name|expectedImage
parameter_list|)
block|{
name|GLint
name|level
init|=
name|index
operator|.
name|mipIndex
decl_stmt|;
name|GLint
name|layerTarget
init|=
name|index
operator|.
name|layerIndex
decl_stmt|;
name|LevelLayerKey
name|key
argument_list|(
name|level
argument_list|,
name|layerTarget
argument_list|)
decl_stmt|;
comment|// This validation check should never return false. It means the Image/TextureStorage association is broken.
name|bool
name|retValue
init|=
operator|(
name|mAssociatedImages
operator|.
name|find
argument_list|(
name|key
argument_list|)
operator|!=
name|mAssociatedImages
operator|.
name|end
argument_list|()
operator|&&
operator|(
name|mAssociatedImages
index|[
name|key
index|]
operator|==
name|expectedImage
operator|)
operator|)
decl_stmt|;
name|ASSERT
argument_list|(
name|retValue
argument_list|)
expr_stmt|;
return|return
name|retValue
return|;
block|}
comment|// disassociateImage allows an Image to end its association with a Storage.
DECL|function|disassociateImage
name|void
name|TextureStorage11_2DArray
operator|::
name|disassociateImage
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|,
name|Image11
modifier|*
name|expectedImage
parameter_list|)
block|{
name|GLint
name|level
init|=
name|index
operator|.
name|mipIndex
decl_stmt|;
name|GLint
name|layerTarget
init|=
name|index
operator|.
name|layerIndex
decl_stmt|;
name|LevelLayerKey
name|key
argument_list|(
name|level
argument_list|,
name|layerTarget
argument_list|)
decl_stmt|;
name|bool
name|imageAssociationCorrect
init|=
operator|(
name|mAssociatedImages
operator|.
name|find
argument_list|(
name|key
argument_list|)
operator|!=
name|mAssociatedImages
operator|.
name|end
argument_list|()
operator|&&
operator|(
name|mAssociatedImages
index|[
name|key
index|]
operator|==
name|expectedImage
operator|)
operator|)
decl_stmt|;
name|ASSERT
argument_list|(
name|imageAssociationCorrect
argument_list|)
expr_stmt|;
if|if
condition|(
name|imageAssociationCorrect
condition|)
block|{
name|mAssociatedImages
index|[
name|key
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|// releaseAssociatedImage prepares the Storage for a new Image association. It lets the old Image recover its data before ending the association.
DECL|function|releaseAssociatedImage
name|gl
operator|::
name|Error
name|TextureStorage11_2DArray
operator|::
name|releaseAssociatedImage
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|,
name|Image11
modifier|*
name|incomingImage
parameter_list|)
block|{
name|GLint
name|level
init|=
name|index
operator|.
name|mipIndex
decl_stmt|;
name|GLint
name|layerTarget
init|=
name|index
operator|.
name|layerIndex
decl_stmt|;
name|LevelLayerKey
name|key
argument_list|(
name|level
argument_list|,
name|layerTarget
argument_list|)
decl_stmt|;
if|if
condition|(
name|mAssociatedImages
operator|.
name|find
argument_list|(
name|key
argument_list|)
operator|!=
name|mAssociatedImages
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|mAssociatedImages
index|[
name|key
index|]
operator|!=
name|NULL
operator|&&
name|mAssociatedImages
index|[
name|key
index|]
operator|!=
name|incomingImage
condition|)
block|{
comment|// Ensure that the Image is still associated with this TextureStorage. This should be true.
name|bool
name|imageAssociationCorrect
init|=
name|mAssociatedImages
index|[
name|key
index|]
operator|->
name|isAssociatedStorageValid
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|imageAssociationCorrect
argument_list|)
expr_stmt|;
if|if
condition|(
name|imageAssociationCorrect
condition|)
block|{
comment|// Force the image to recover from storage before its data is overwritten.
comment|// This will reset mAssociatedImages[level] to NULL too.
name|gl
operator|::
name|Error
name|error
init|=
name|mAssociatedImages
index|[
name|key
index|]
operator|->
name|recoverFromAssociatedStorage
argument_list|()
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|getResource
name|gl
operator|::
name|Error
name|TextureStorage11_2DArray
operator|::
name|getResource
parameter_list|(
name|ID3D11Resource
modifier|*
modifier|*
name|outResource
parameter_list|)
block|{
comment|// if the width, height or depth is not positive this should be treated as an incomplete texture
comment|// we handle that here by skipping the d3d texture creation
if|if
condition|(
name|mTexture
operator|==
name|NULL
operator|&&
name|mTextureWidth
operator|>
literal|0
operator|&&
name|mTextureHeight
operator|>
literal|0
operator|&&
name|mTextureDepth
operator|>
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|mMipLevels
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|D3D11_TEXTURE2D_DESC
name|desc
decl_stmt|;
name|desc
operator|.
name|Width
operator|=
name|mTextureWidth
expr_stmt|;
name|desc
operator|.
name|Height
operator|=
name|mTextureHeight
expr_stmt|;
name|desc
operator|.
name|MipLevels
operator|=
name|mMipLevels
expr_stmt|;
name|desc
operator|.
name|ArraySize
operator|=
name|mTextureDepth
expr_stmt|;
name|desc
operator|.
name|Format
operator|=
name|mTextureFormat
expr_stmt|;
name|desc
operator|.
name|SampleDesc
operator|.
name|Count
operator|=
literal|1
expr_stmt|;
name|desc
operator|.
name|SampleDesc
operator|.
name|Quality
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|Usage
operator|=
name|D3D11_USAGE_DEFAULT
expr_stmt|;
name|desc
operator|.
name|BindFlags
operator|=
name|getBindFlags
argument_list|()
expr_stmt|;
name|desc
operator|.
name|CPUAccessFlags
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateTexture2D
argument_list|(
operator|&
name|desc
argument_list|,
name|NULL
argument_list|,
operator|&
name|mTexture
argument_list|)
decl_stmt|;
comment|// this can happen from windows TDR
if|if
condition|(
name|d3d11
operator|::
name|isDeviceLostError
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|mRenderer
operator|->
name|notifyDeviceLost
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create 2D array texture storage, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|result
operator|==
name|E_OUTOFMEMORY
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create 2D array texture storage, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
operator|*
name|outResource
operator|=
name|mTexture
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|createSRV
name|gl
operator|::
name|Error
name|TextureStorage11_2DArray
operator|::
name|createSRV
parameter_list|(
name|int
name|baseLevel
parameter_list|,
name|int
name|mipLevels
parameter_list|,
name|DXGI_FORMAT
name|format
parameter_list|,
name|ID3D11Resource
modifier|*
name|texture
parameter_list|,
name|ID3D11ShaderResourceView
modifier|*
modifier|*
name|outSRV
parameter_list|)
specifier|const
block|{
name|D3D11_SHADER_RESOURCE_VIEW_DESC
name|srvDesc
decl_stmt|;
name|srvDesc
operator|.
name|Format
operator|=
name|format
expr_stmt|;
name|srvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_SRV_DIMENSION_TEXTURE2DARRAY
expr_stmt|;
name|srvDesc
operator|.
name|Texture2DArray
operator|.
name|MostDetailedMip
operator|=
name|mTopLevel
operator|+
name|baseLevel
expr_stmt|;
name|srvDesc
operator|.
name|Texture2DArray
operator|.
name|MipLevels
operator|=
name|mipLevels
expr_stmt|;
name|srvDesc
operator|.
name|Texture2DArray
operator|.
name|FirstArraySlice
operator|=
literal|0
expr_stmt|;
name|srvDesc
operator|.
name|Texture2DArray
operator|.
name|ArraySize
operator|=
name|mTextureDepth
expr_stmt|;
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateShaderResourceView
argument_list|(
name|texture
argument_list|,
operator|&
name|srvDesc
argument_list|,
name|outSRV
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|result
operator|==
name|E_OUTOFMEMORY
operator|||
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create internal texture storage SRV, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|getRenderTarget
name|gl
operator|::
name|Error
name|TextureStorage11_2DArray
operator|::
name|getRenderTarget
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|,
name|RenderTargetD3D
modifier|*
modifier|*
name|outRT
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|index
operator|.
name|hasLayer
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|mipLevel
init|=
name|index
operator|.
name|mipIndex
decl_stmt|;
name|int
name|layer
init|=
name|index
operator|.
name|layerIndex
decl_stmt|;
name|ASSERT
argument_list|(
name|mipLevel
operator|>=
literal|0
operator|&&
name|mipLevel
operator|<
name|getLevelCount
argument_list|()
argument_list|)
expr_stmt|;
name|LevelLayerKey
name|key
argument_list|(
name|mipLevel
argument_list|,
name|layer
argument_list|)
decl_stmt|;
if|if
condition|(
name|mRenderTargets
operator|.
name|find
argument_list|(
name|key
argument_list|)
operator|==
name|mRenderTargets
operator|.
name|end
argument_list|()
condition|)
block|{
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|HRESULT
name|result
decl_stmt|;
name|ID3D11Resource
modifier|*
name|texture
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|getResource
argument_list|(
operator|&
name|texture
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|D3D11_SHADER_RESOURCE_VIEW_DESC
name|srvDesc
decl_stmt|;
name|srvDesc
operator|.
name|Format
operator|=
name|mShaderResourceFormat
expr_stmt|;
name|srvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_SRV_DIMENSION_TEXTURE2DARRAY
expr_stmt|;
name|srvDesc
operator|.
name|Texture2DArray
operator|.
name|MostDetailedMip
operator|=
name|mTopLevel
operator|+
name|mipLevel
expr_stmt|;
name|srvDesc
operator|.
name|Texture2DArray
operator|.
name|MipLevels
operator|=
literal|1
expr_stmt|;
name|srvDesc
operator|.
name|Texture2DArray
operator|.
name|FirstArraySlice
operator|=
name|layer
expr_stmt|;
name|srvDesc
operator|.
name|Texture2DArray
operator|.
name|ArraySize
operator|=
literal|1
expr_stmt|;
name|ID3D11ShaderResourceView
modifier|*
name|srv
decl_stmt|;
name|result
operator|=
name|device
operator|->
name|CreateShaderResourceView
argument_list|(
name|texture
argument_list|,
operator|&
name|srvDesc
argument_list|,
operator|&
name|srv
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|result
operator|==
name|E_OUTOFMEMORY
operator|||
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create internal shader resource view for texture storage, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
if|if
condition|(
name|mRenderTargetFormat
operator|!=
name|DXGI_FORMAT_UNKNOWN
condition|)
block|{
name|D3D11_RENDER_TARGET_VIEW_DESC
name|rtvDesc
decl_stmt|;
name|rtvDesc
operator|.
name|Format
operator|=
name|mRenderTargetFormat
expr_stmt|;
name|rtvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_RTV_DIMENSION_TEXTURE2DARRAY
expr_stmt|;
name|rtvDesc
operator|.
name|Texture2DArray
operator|.
name|MipSlice
operator|=
name|mTopLevel
operator|+
name|mipLevel
expr_stmt|;
name|rtvDesc
operator|.
name|Texture2DArray
operator|.
name|FirstArraySlice
operator|=
name|layer
expr_stmt|;
name|rtvDesc
operator|.
name|Texture2DArray
operator|.
name|ArraySize
operator|=
literal|1
expr_stmt|;
name|ID3D11RenderTargetView
modifier|*
name|rtv
decl_stmt|;
name|result
operator|=
name|device
operator|->
name|CreateRenderTargetView
argument_list|(
name|texture
argument_list|,
operator|&
name|rtvDesc
argument_list|,
operator|&
name|rtv
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|result
operator|==
name|E_OUTOFMEMORY
operator|||
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|SafeRelease
argument_list|(
name|srv
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create internal render target view for texture storage, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
name|mRenderTargets
index|[
name|key
index|]
operator|=
operator|new
name|TextureRenderTarget11
argument_list|(
name|rtv
argument_list|,
name|texture
argument_list|,
name|srv
argument_list|,
name|mInternalFormat
argument_list|,
name|getLevelWidth
argument_list|(
name|mipLevel
argument_list|)
argument_list|,
name|getLevelHeight
argument_list|(
name|mipLevel
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// RenderTarget will take ownership of these resources
name|SafeRelease
argument_list|(
name|rtv
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|srv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
name|ASSERT
argument_list|(
name|outRT
argument_list|)
expr_stmt|;
operator|*
name|outRT
operator|=
name|mRenderTargets
index|[
name|key
index|]
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|getSwizzleTexture
name|gl
operator|::
name|Error
name|TextureStorage11_2DArray
operator|::
name|getSwizzleTexture
parameter_list|(
name|ID3D11Resource
modifier|*
modifier|*
name|outTexture
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mSwizzleTexture
condition|)
block|{
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|D3D11_TEXTURE2D_DESC
name|desc
decl_stmt|;
name|desc
operator|.
name|Width
operator|=
name|mTextureWidth
expr_stmt|;
name|desc
operator|.
name|Height
operator|=
name|mTextureHeight
expr_stmt|;
name|desc
operator|.
name|MipLevels
operator|=
name|mMipLevels
expr_stmt|;
name|desc
operator|.
name|ArraySize
operator|=
name|mTextureDepth
expr_stmt|;
name|desc
operator|.
name|Format
operator|=
name|mSwizzleTextureFormat
expr_stmt|;
name|desc
operator|.
name|SampleDesc
operator|.
name|Count
operator|=
literal|1
expr_stmt|;
name|desc
operator|.
name|SampleDesc
operator|.
name|Quality
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|Usage
operator|=
name|D3D11_USAGE_DEFAULT
expr_stmt|;
name|desc
operator|.
name|BindFlags
operator|=
name|D3D11_BIND_SHADER_RESOURCE
operator||
name|D3D11_BIND_RENDER_TARGET
expr_stmt|;
name|desc
operator|.
name|CPUAccessFlags
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateTexture2D
argument_list|(
operator|&
name|desc
argument_list|,
name|NULL
argument_list|,
operator|&
name|mSwizzleTexture
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|result
operator|==
name|E_OUTOFMEMORY
operator|||
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create internal swizzle texture, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
operator|*
name|outTexture
operator|=
name|mSwizzleTexture
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|getSwizzleRenderTarget
name|gl
operator|::
name|Error
name|TextureStorage11_2DArray
operator|::
name|getSwizzleRenderTarget
parameter_list|(
name|int
name|mipLevel
parameter_list|,
name|ID3D11RenderTargetView
modifier|*
modifier|*
name|outRTV
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|mipLevel
operator|>=
literal|0
operator|&&
name|mipLevel
operator|<
name|getLevelCount
argument_list|()
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|outRTV
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mSwizzleRenderTargets
index|[
name|mipLevel
index|]
condition|)
block|{
name|ID3D11Resource
modifier|*
name|swizzleTexture
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|getSwizzleTexture
argument_list|(
operator|&
name|swizzleTexture
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|D3D11_RENDER_TARGET_VIEW_DESC
name|rtvDesc
decl_stmt|;
name|rtvDesc
operator|.
name|Format
operator|=
name|mSwizzleRenderTargetFormat
expr_stmt|;
name|rtvDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_RTV_DIMENSION_TEXTURE2DARRAY
expr_stmt|;
name|rtvDesc
operator|.
name|Texture2DArray
operator|.
name|MipSlice
operator|=
name|mTopLevel
operator|+
name|mipLevel
expr_stmt|;
name|rtvDesc
operator|.
name|Texture2DArray
operator|.
name|FirstArraySlice
operator|=
literal|0
expr_stmt|;
name|rtvDesc
operator|.
name|Texture2DArray
operator|.
name|ArraySize
operator|=
name|mTextureDepth
expr_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateRenderTargetView
argument_list|(
name|mSwizzleTexture
argument_list|,
operator|&
name|rtvDesc
argument_list|,
operator|&
name|mSwizzleRenderTargets
index|[
name|mipLevel
index|]
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|result
operator|==
name|E_OUTOFMEMORY
operator|||
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create internal swizzle render target view, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
operator|*
name|outRTV
operator|=
name|mSwizzleRenderTargets
index|[
name|mipLevel
index|]
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
block|}
end_namespace
end_unit
