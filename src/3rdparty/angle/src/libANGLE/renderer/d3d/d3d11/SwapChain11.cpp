begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2012-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// SwapChain11.cpp: Implements a back-end specific class for the D3D11 swap chain.
end_comment
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/SwapChain11.h"
end_include
begin_include
include|#
directive|include
file|<EGL/eglext.h>
end_include
begin_include
include|#
directive|include
file|"libANGLE/features.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/formatutils11.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/NativeWindow.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/Renderer11.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/renderer11_utils.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/texture_format_table.h"
end_include
begin_include
include|#
directive|include
file|"third_party/trace_event/trace_event.h"
end_include
begin_comment
comment|// Precompiled shaders
end_comment
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/shaders/compiled/passthrough2d11vs.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/shaders/compiled/passthroughrgba2d11ps.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|ANGLE_ENABLE_KEYEDMUTEX
end_ifdef
begin_define
DECL|macro|ANGLE_RESOURCE_SHARE_TYPE
define|#
directive|define
name|ANGLE_RESOURCE_SHARE_TYPE
value|D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|ANGLE_RESOURCE_SHARE_TYPE
define|#
directive|define
name|ANGLE_RESOURCE_SHARE_TYPE
value|D3D11_RESOURCE_MISC_SHARED
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_namespace
DECL|namespace|rx
namespace|namespace
name|rx
block|{
namespace|namespace
block|{
DECL|function|NeedsOffscreenTexture
name|bool
name|NeedsOffscreenTexture
parameter_list|(
name|Renderer11
modifier|*
name|renderer
parameter_list|,
name|NativeWindow
name|nativeWindow
parameter_list|,
name|EGLint
name|orientation
parameter_list|)
block|{
comment|// We don't need an offscreen texture if either orientation = INVERT_Y,
comment|// or present path fast is enabled and we're not rendering onto an offscreen surface.
return|return
name|orientation
operator|!=
name|EGL_SURFACE_ORIENTATION_INVERT_Y_ANGLE
operator|&&
operator|!
operator|(
name|renderer
operator|->
name|presentPathFastEnabled
argument_list|()
operator|&&
name|nativeWindow
operator|.
name|getNativeWindow
argument_list|()
operator|)
return|;
block|}
block|}
comment|// anonymous namespace
DECL|function|SwapChain11
name|SwapChain11
operator|::
name|SwapChain11
parameter_list|(
name|Renderer11
modifier|*
name|renderer
parameter_list|,
name|NativeWindow
name|nativeWindow
parameter_list|,
name|HANDLE
name|shareHandle
parameter_list|,
name|GLenum
name|backBufferFormat
parameter_list|,
name|GLenum
name|depthBufferFormat
parameter_list|,
name|EGLint
name|orientation
parameter_list|)
member_init_list|:
name|SwapChainD3D
argument_list|(
name|nativeWindow
argument_list|,
name|shareHandle
argument_list|,
name|backBufferFormat
argument_list|,
name|depthBufferFormat
argument_list|)
member_init_list|,
name|mRenderer
argument_list|(
name|renderer
argument_list|)
member_init_list|,
name|mWidth
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|mHeight
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|mOrientation
argument_list|(
name|orientation
argument_list|)
member_init_list|,
name|mAppCreatedShareHandle
argument_list|(
name|mShareHandle
operator|!=
literal|nullptr
argument_list|)
member_init_list|,
name|mSwapInterval
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mPassThroughResourcesInit
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mFirstSwap
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|mSwapChain
argument_list|(
literal|nullptr
argument_list|)
member_init_list|,
if|#
directive|if
name|defined
argument_list|(
name|ANGLE_ENABLE_D3D11_1
argument_list|)
name|mSwapChain1
argument_list|(
literal|nullptr
argument_list|)
member_init_list|,
endif|#
directive|endif
name|mKeyedMutex
argument_list|(
literal|nullptr
argument_list|)
member_init_list|,
name|mBackBufferTexture
argument_list|(
literal|nullptr
argument_list|)
member_init_list|,
name|mBackBufferRTView
argument_list|(
literal|nullptr
argument_list|)
member_init_list|,
name|mBackBufferSRView
argument_list|(
literal|nullptr
argument_list|)
member_init_list|,
name|mNeedsOffscreenTexture
argument_list|(
name|NeedsOffscreenTexture
argument_list|(
name|renderer
argument_list|,
name|nativeWindow
argument_list|,
name|orientation
argument_list|)
argument_list|)
member_init_list|,
name|mOffscreenTexture
argument_list|(
literal|nullptr
argument_list|)
member_init_list|,
name|mOffscreenRTView
argument_list|(
literal|nullptr
argument_list|)
member_init_list|,
name|mOffscreenSRView
argument_list|(
literal|nullptr
argument_list|)
member_init_list|,
name|mDepthStencilTexture
argument_list|(
literal|nullptr
argument_list|)
member_init_list|,
name|mDepthStencilDSView
argument_list|(
literal|nullptr
argument_list|)
member_init_list|,
name|mDepthStencilSRView
argument_list|(
literal|nullptr
argument_list|)
member_init_list|,
name|mQuadVB
argument_list|(
literal|nullptr
argument_list|)
member_init_list|,
name|mPassThroughSampler
argument_list|(
literal|nullptr
argument_list|)
member_init_list|,
name|mPassThroughIL
argument_list|(
literal|nullptr
argument_list|)
member_init_list|,
name|mPassThroughVS
argument_list|(
literal|nullptr
argument_list|)
member_init_list|,
name|mPassThroughPS
argument_list|(
literal|nullptr
argument_list|)
member_init_list|,
name|mPassThroughRS
argument_list|(
literal|nullptr
argument_list|)
member_init_list|,
name|mColorRenderTarget
argument_list|(
name|this
argument_list|,
name|renderer
argument_list|,
literal|false
argument_list|)
member_init_list|,
name|mDepthStencilRenderTarget
argument_list|(
name|this
argument_list|,
name|renderer
argument_list|,
literal|true
argument_list|)
block|{
comment|// Sanity check that if present path fast is active then we're using the default orientation
name|ASSERT
argument_list|(
operator|!
name|mRenderer
operator|->
name|presentPathFastEnabled
argument_list|()
operator|||
name|orientation
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
DECL|function|~SwapChain11
name|SwapChain11
operator|::
name|~
name|SwapChain11
parameter_list|()
block|{
name|release
argument_list|()
expr_stmt|;
block|}
DECL|function|release
name|void
name|SwapChain11
operator|::
name|release
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|ANGLE_ENABLE_D3D11_1
argument_list|)
name|SafeRelease
argument_list|(
name|mSwapChain1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SafeRelease
argument_list|(
name|mSwapChain
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mKeyedMutex
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mBackBufferTexture
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mBackBufferRTView
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mBackBufferSRView
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mOffscreenTexture
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mOffscreenRTView
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mOffscreenSRView
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mDepthStencilTexture
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mDepthStencilDSView
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mDepthStencilSRView
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mQuadVB
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mPassThroughSampler
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mPassThroughIL
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mPassThroughVS
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mPassThroughPS
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mPassThroughRS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mAppCreatedShareHandle
condition|)
block|{
name|mShareHandle
operator|=
name|NULL
expr_stmt|;
block|}
block|}
DECL|function|releaseOffscreenColorBuffer
name|void
name|SwapChain11
operator|::
name|releaseOffscreenColorBuffer
parameter_list|()
block|{
name|SafeRelease
argument_list|(
name|mOffscreenTexture
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mOffscreenRTView
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mOffscreenSRView
argument_list|)
expr_stmt|;
block|}
DECL|function|releaseOffscreenDepthBuffer
name|void
name|SwapChain11
operator|::
name|releaseOffscreenDepthBuffer
parameter_list|()
block|{
name|SafeRelease
argument_list|(
name|mDepthStencilTexture
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mDepthStencilDSView
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mDepthStencilSRView
argument_list|)
expr_stmt|;
block|}
DECL|function|resetOffscreenBuffers
name|EGLint
name|SwapChain11
operator|::
name|resetOffscreenBuffers
parameter_list|(
name|int
name|backbufferWidth
parameter_list|,
name|int
name|backbufferHeight
parameter_list|)
block|{
if|if
condition|(
name|mNeedsOffscreenTexture
condition|)
block|{
name|EGLint
name|result
init|=
name|resetOffscreenColorBuffer
argument_list|(
name|backbufferWidth
argument_list|,
name|backbufferHeight
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
name|EGL_SUCCESS
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
name|EGLint
name|result
init|=
name|resetOffscreenDepthBuffer
argument_list|(
name|backbufferWidth
argument_list|,
name|backbufferHeight
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
name|EGL_SUCCESS
condition|)
block|{
return|return
name|result
return|;
block|}
name|mWidth
operator|=
name|backbufferWidth
expr_stmt|;
name|mHeight
operator|=
name|backbufferHeight
expr_stmt|;
return|return
name|EGL_SUCCESS
return|;
block|}
DECL|function|resetOffscreenColorBuffer
name|EGLint
name|SwapChain11
operator|::
name|resetOffscreenColorBuffer
parameter_list|(
name|int
name|backbufferWidth
parameter_list|,
name|int
name|backbufferHeight
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|mNeedsOffscreenTexture
argument_list|)
expr_stmt|;
name|TRACE_EVENT0
argument_list|(
literal|"gpu.angle"
argument_list|,
literal|"SwapChain11::resetOffscreenTexture"
argument_list|)
expr_stmt|;
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|device
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|// D3D11 does not allow zero size textures
name|ASSERT
argument_list|(
name|backbufferWidth
operator|>=
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|backbufferHeight
operator|>=
literal|1
argument_list|)
expr_stmt|;
comment|// Preserve the render target content
name|ID3D11Texture2D
modifier|*
name|previousOffscreenTexture
init|=
name|mOffscreenTexture
decl_stmt|;
if|if
condition|(
name|previousOffscreenTexture
condition|)
block|{
name|previousOffscreenTexture
operator|->
name|AddRef
argument_list|()
expr_stmt|;
block|}
specifier|const
name|int
name|previousWidth
init|=
name|mWidth
decl_stmt|;
specifier|const
name|int
name|previousHeight
init|=
name|mHeight
decl_stmt|;
name|releaseOffscreenColorBuffer
argument_list|()
expr_stmt|;
specifier|const
name|d3d11
operator|::
name|TextureFormat
modifier|&
name|backbufferFormatInfo
init|=
name|d3d11
operator|::
name|GetTextureFormatInfo
argument_list|(
name|mOffscreenRenderTargetFormat
argument_list|,
name|mRenderer
operator|->
name|getRenderer11DeviceCaps
argument_list|()
argument_list|)
decl_stmt|;
comment|// If the app passed in a share handle, open the resource
comment|// See EGL_ANGLE_d3d_share_handle_client_buffer
if|if
condition|(
name|mAppCreatedShareHandle
condition|)
block|{
name|ID3D11Resource
modifier|*
name|tempResource11
decl_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|OpenSharedResource
argument_list|(
name|mShareHandle
argument_list|,
name|__uuidof
argument_list|(
name|ID3D11Resource
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|tempResource11
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to open the swap chain pbuffer share handle: %08lX"
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|release
argument_list|()
expr_stmt|;
return|return
name|EGL_BAD_PARAMETER
return|;
block|}
name|result
operator|=
name|tempResource11
operator|->
name|QueryInterface
argument_list|(
name|__uuidof
argument_list|(
name|ID3D11Texture2D
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|mOffscreenTexture
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|tempResource11
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to query texture2d interface in pbuffer share handle: %08lX"
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|release
argument_list|()
expr_stmt|;
return|return
name|EGL_BAD_PARAMETER
return|;
block|}
comment|// Validate offscreen texture parameters
name|D3D11_TEXTURE2D_DESC
name|offscreenTextureDesc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|mOffscreenTexture
operator|->
name|GetDesc
argument_list|(
operator|&
name|offscreenTextureDesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|offscreenTextureDesc
operator|.
name|Width
operator|!=
operator|(
name|UINT
operator|)
name|backbufferWidth
operator|||
name|offscreenTextureDesc
operator|.
name|Height
operator|!=
operator|(
name|UINT
operator|)
name|backbufferHeight
operator|||
name|offscreenTextureDesc
operator|.
name|Format
operator|!=
name|backbufferFormatInfo
operator|.
name|texFormat
operator|||
name|offscreenTextureDesc
operator|.
name|MipLevels
operator|!=
literal|1
operator|||
name|offscreenTextureDesc
operator|.
name|ArraySize
operator|!=
literal|1
condition|)
block|{
name|ERR
argument_list|(
literal|"Invalid texture parameters in the shared offscreen texture pbuffer"
argument_list|)
expr_stmt|;
name|release
argument_list|()
expr_stmt|;
return|return
name|EGL_BAD_PARAMETER
return|;
block|}
block|}
else|else
block|{
specifier|const
name|bool
name|useSharedResource
init|=
operator|!
name|mNativeWindow
operator|.
name|getNativeWindow
argument_list|()
operator|&&
name|mRenderer
operator|->
name|getShareHandleSupport
argument_list|()
decl_stmt|;
name|D3D11_TEXTURE2D_DESC
name|offscreenTextureDesc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|offscreenTextureDesc
operator|.
name|Width
operator|=
name|backbufferWidth
expr_stmt|;
name|offscreenTextureDesc
operator|.
name|Height
operator|=
name|backbufferHeight
expr_stmt|;
name|offscreenTextureDesc
operator|.
name|Format
operator|=
name|backbufferFormatInfo
operator|.
name|texFormat
expr_stmt|;
name|offscreenTextureDesc
operator|.
name|MipLevels
operator|=
literal|1
expr_stmt|;
name|offscreenTextureDesc
operator|.
name|ArraySize
operator|=
literal|1
expr_stmt|;
name|offscreenTextureDesc
operator|.
name|SampleDesc
operator|.
name|Count
operator|=
literal|1
expr_stmt|;
name|offscreenTextureDesc
operator|.
name|SampleDesc
operator|.
name|Quality
operator|=
literal|0
expr_stmt|;
name|offscreenTextureDesc
operator|.
name|Usage
operator|=
name|D3D11_USAGE_DEFAULT
expr_stmt|;
name|offscreenTextureDesc
operator|.
name|BindFlags
operator|=
name|D3D11_BIND_RENDER_TARGET
operator||
name|D3D11_BIND_SHADER_RESOURCE
expr_stmt|;
name|offscreenTextureDesc
operator|.
name|CPUAccessFlags
operator|=
literal|0
expr_stmt|;
name|offscreenTextureDesc
operator|.
name|MiscFlags
operator|=
name|useSharedResource
condition|?
name|ANGLE_RESOURCE_SHARE_TYPE
else|:
literal|0
expr_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateTexture2D
argument_list|(
operator|&
name|offscreenTextureDesc
argument_list|,
name|NULL
argument_list|,
operator|&
name|mOffscreenTexture
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not create offscreen texture: %08lX"
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|release
argument_list|()
expr_stmt|;
if|if
condition|(
name|d3d11
operator|::
name|isDeviceLostError
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|EGL_CONTEXT_LOST
return|;
block|}
else|else
block|{
return|return
name|EGL_BAD_ALLOC
return|;
block|}
block|}
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mOffscreenTexture
argument_list|,
literal|"Offscreen back buffer texture"
argument_list|)
expr_stmt|;
comment|// EGL_ANGLE_surface_d3d_texture_2d_share_handle requires that we store a share handle for the client
if|if
condition|(
name|useSharedResource
condition|)
block|{
name|IDXGIResource
modifier|*
name|offscreenTextureResource
init|=
name|NULL
decl_stmt|;
name|result
operator|=
name|mOffscreenTexture
operator|->
name|QueryInterface
argument_list|(
name|__uuidof
argument_list|(
name|IDXGIResource
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|offscreenTextureResource
argument_list|)
expr_stmt|;
comment|// Fall back to no share handle on failure
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not query offscreen texture resource: %08lX"
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|offscreenTextureResource
operator|->
name|GetSharedHandle
argument_list|(
operator|&
name|mShareHandle
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|offscreenTextureResource
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|mShareHandle
operator|=
name|NULL
expr_stmt|;
name|ERR
argument_list|(
literal|"Could not get offscreen texture shared handle: %08lX"
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// This may return null if the original texture was created without a keyed mutex.
name|mKeyedMutex
operator|=
name|d3d11
operator|::
name|DynamicCastComObject
argument_list|<
name|IDXGIKeyedMutex
argument_list|>
argument_list|(
name|mOffscreenTexture
argument_list|)
expr_stmt|;
name|D3D11_RENDER_TARGET_VIEW_DESC
name|offscreenRTVDesc
decl_stmt|;
name|offscreenRTVDesc
operator|.
name|Format
operator|=
name|backbufferFormatInfo
operator|.
name|rtvFormat
expr_stmt|;
name|offscreenRTVDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_RTV_DIMENSION_TEXTURE2D
expr_stmt|;
name|offscreenRTVDesc
operator|.
name|Texture2D
operator|.
name|MipSlice
operator|=
literal|0
expr_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateRenderTargetView
argument_list|(
name|mOffscreenTexture
argument_list|,
operator|&
name|offscreenRTVDesc
argument_list|,
operator|&
name|mOffscreenRTView
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mOffscreenRTView
argument_list|,
literal|"Offscreen back buffer render target"
argument_list|)
expr_stmt|;
name|D3D11_SHADER_RESOURCE_VIEW_DESC
name|offscreenSRVDesc
decl_stmt|;
name|offscreenSRVDesc
operator|.
name|Format
operator|=
name|backbufferFormatInfo
operator|.
name|srvFormat
expr_stmt|;
name|offscreenSRVDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_SRV_DIMENSION_TEXTURE2D
expr_stmt|;
name|offscreenSRVDesc
operator|.
name|Texture2D
operator|.
name|MostDetailedMip
operator|=
literal|0
expr_stmt|;
name|offscreenSRVDesc
operator|.
name|Texture2D
operator|.
name|MipLevels
operator|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|device
operator|->
name|CreateShaderResourceView
argument_list|(
name|mOffscreenTexture
argument_list|,
operator|&
name|offscreenSRVDesc
argument_list|,
operator|&
name|mOffscreenSRView
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mOffscreenSRView
argument_list|,
literal|"Offscreen back buffer shader resource"
argument_list|)
expr_stmt|;
if|if
condition|(
name|previousOffscreenTexture
operator|!=
literal|nullptr
condition|)
block|{
name|D3D11_BOX
name|sourceBox
init|=
block|{
literal|0
block|}
decl_stmt|;
name|sourceBox
operator|.
name|left
operator|=
literal|0
expr_stmt|;
name|sourceBox
operator|.
name|right
operator|=
name|std
operator|::
name|min
argument_list|(
name|previousWidth
argument_list|,
name|backbufferWidth
argument_list|)
expr_stmt|;
name|sourceBox
operator|.
name|top
operator|=
name|std
operator|::
name|max
argument_list|(
name|previousHeight
operator|-
name|backbufferHeight
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sourceBox
operator|.
name|bottom
operator|=
name|previousHeight
expr_stmt|;
name|sourceBox
operator|.
name|front
operator|=
literal|0
expr_stmt|;
name|sourceBox
operator|.
name|back
operator|=
literal|1
expr_stmt|;
name|ID3D11DeviceContext
modifier|*
name|deviceContext
init|=
name|mRenderer
operator|->
name|getDeviceContext
argument_list|()
decl_stmt|;
specifier|const
name|int
name|yoffset
init|=
name|std
operator|::
name|max
argument_list|(
name|backbufferHeight
operator|-
name|previousHeight
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|deviceContext
operator|->
name|CopySubresourceRegion
argument_list|(
name|mOffscreenTexture
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|yoffset
argument_list|,
literal|0
argument_list|,
name|previousOffscreenTexture
argument_list|,
literal|0
argument_list|,
operator|&
name|sourceBox
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|previousOffscreenTexture
argument_list|)
expr_stmt|;
if|if
condition|(
name|mSwapChain
condition|)
block|{
name|swapRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|backbufferWidth
argument_list|,
name|backbufferHeight
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|EGL_SUCCESS
return|;
block|}
DECL|function|resetOffscreenDepthBuffer
name|EGLint
name|SwapChain11
operator|::
name|resetOffscreenDepthBuffer
parameter_list|(
name|int
name|backbufferWidth
parameter_list|,
name|int
name|backbufferHeight
parameter_list|)
block|{
name|releaseOffscreenDepthBuffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|mDepthBufferFormat
operator|!=
name|GL_NONE
condition|)
block|{
specifier|const
name|d3d11
operator|::
name|TextureFormat
modifier|&
name|depthBufferFormatInfo
init|=
name|d3d11
operator|::
name|GetTextureFormatInfo
argument_list|(
name|mDepthBufferFormat
argument_list|,
name|mRenderer
operator|->
name|getRenderer11DeviceCaps
argument_list|()
argument_list|)
decl_stmt|;
name|D3D11_TEXTURE2D_DESC
name|depthStencilTextureDesc
decl_stmt|;
name|depthStencilTextureDesc
operator|.
name|Width
operator|=
name|backbufferWidth
expr_stmt|;
name|depthStencilTextureDesc
operator|.
name|Height
operator|=
name|backbufferHeight
expr_stmt|;
name|depthStencilTextureDesc
operator|.
name|Format
operator|=
name|depthBufferFormatInfo
operator|.
name|texFormat
expr_stmt|;
name|depthStencilTextureDesc
operator|.
name|MipLevels
operator|=
literal|1
expr_stmt|;
name|depthStencilTextureDesc
operator|.
name|ArraySize
operator|=
literal|1
expr_stmt|;
name|depthStencilTextureDesc
operator|.
name|SampleDesc
operator|.
name|Count
operator|=
literal|1
expr_stmt|;
name|depthStencilTextureDesc
operator|.
name|SampleDesc
operator|.
name|Quality
operator|=
literal|0
expr_stmt|;
name|depthStencilTextureDesc
operator|.
name|Usage
operator|=
name|D3D11_USAGE_DEFAULT
expr_stmt|;
name|depthStencilTextureDesc
operator|.
name|BindFlags
operator|=
name|D3D11_BIND_DEPTH_STENCIL
expr_stmt|;
if|if
condition|(
name|depthBufferFormatInfo
operator|.
name|srvFormat
operator|!=
name|DXGI_FORMAT_UNKNOWN
condition|)
block|{
name|depthStencilTextureDesc
operator|.
name|BindFlags
operator||=
name|D3D11_BIND_SHADER_RESOURCE
expr_stmt|;
block|}
name|depthStencilTextureDesc
operator|.
name|CPUAccessFlags
operator|=
literal|0
expr_stmt|;
name|depthStencilTextureDesc
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateTexture2D
argument_list|(
operator|&
name|depthStencilTextureDesc
argument_list|,
name|NULL
argument_list|,
operator|&
name|mDepthStencilTexture
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not create depthstencil surface for new swap chain: 0x%08X"
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|release
argument_list|()
expr_stmt|;
if|if
condition|(
name|d3d11
operator|::
name|isDeviceLostError
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|EGL_CONTEXT_LOST
return|;
block|}
else|else
block|{
return|return
name|EGL_BAD_ALLOC
return|;
block|}
block|}
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mDepthStencilTexture
argument_list|,
literal|"Offscreen depth stencil texture"
argument_list|)
expr_stmt|;
name|D3D11_DEPTH_STENCIL_VIEW_DESC
name|depthStencilDesc
decl_stmt|;
name|depthStencilDesc
operator|.
name|Format
operator|=
name|depthBufferFormatInfo
operator|.
name|dsvFormat
expr_stmt|;
name|depthStencilDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_DSV_DIMENSION_TEXTURE2D
expr_stmt|;
name|depthStencilDesc
operator|.
name|Flags
operator|=
literal|0
expr_stmt|;
name|depthStencilDesc
operator|.
name|Texture2D
operator|.
name|MipSlice
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|device
operator|->
name|CreateDepthStencilView
argument_list|(
name|mDepthStencilTexture
argument_list|,
operator|&
name|depthStencilDesc
argument_list|,
operator|&
name|mDepthStencilDSView
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mDepthStencilDSView
argument_list|,
literal|"Offscreen depth stencil view"
argument_list|)
expr_stmt|;
if|if
condition|(
name|depthBufferFormatInfo
operator|.
name|srvFormat
operator|!=
name|DXGI_FORMAT_UNKNOWN
condition|)
block|{
name|D3D11_SHADER_RESOURCE_VIEW_DESC
name|depthStencilSRVDesc
decl_stmt|;
name|depthStencilSRVDesc
operator|.
name|Format
operator|=
name|depthBufferFormatInfo
operator|.
name|srvFormat
expr_stmt|;
name|depthStencilSRVDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_SRV_DIMENSION_TEXTURE2D
expr_stmt|;
name|depthStencilSRVDesc
operator|.
name|Texture2D
operator|.
name|MostDetailedMip
operator|=
literal|0
expr_stmt|;
name|depthStencilSRVDesc
operator|.
name|Texture2D
operator|.
name|MipLevels
operator|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|device
operator|->
name|CreateShaderResourceView
argument_list|(
name|mDepthStencilTexture
argument_list|,
operator|&
name|depthStencilSRVDesc
argument_list|,
operator|&
name|mDepthStencilSRView
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mDepthStencilSRView
argument_list|,
literal|"Offscreen depth stencil shader resource"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|EGL_SUCCESS
return|;
block|}
DECL|function|resize
name|EGLint
name|SwapChain11
operator|::
name|resize
parameter_list|(
name|EGLint
name|backbufferWidth
parameter_list|,
name|EGLint
name|backbufferHeight
parameter_list|)
block|{
name|TRACE_EVENT0
argument_list|(
literal|"gpu.angle"
argument_list|,
literal|"SwapChain11::resize"
argument_list|)
expr_stmt|;
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
if|if
condition|(
name|device
operator|==
name|NULL
condition|)
block|{
return|return
name|EGL_BAD_ACCESS
return|;
block|}
comment|// EGL allows creating a surface with 0x0 dimension, however, DXGI does not like 0x0 swapchains
if|if
condition|(
name|backbufferWidth
operator|<
literal|1
operator|||
name|backbufferHeight
operator|<
literal|1
condition|)
block|{
return|return
name|EGL_SUCCESS
return|;
block|}
comment|// Don't resize unnecessarily
if|if
condition|(
name|mWidth
operator|==
name|backbufferWidth
operator|&&
name|mHeight
operator|==
name|backbufferHeight
condition|)
block|{
return|return
name|EGL_SUCCESS
return|;
block|}
comment|// Can only call resize if we have already created our swap buffer and resources
name|ASSERT
argument_list|(
name|mSwapChain
operator|&&
name|mBackBufferTexture
operator|&&
name|mBackBufferRTView
operator|&&
name|mBackBufferSRView
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mBackBufferTexture
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mBackBufferRTView
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mBackBufferSRView
argument_list|)
expr_stmt|;
comment|// Resize swap chain
name|DXGI_SWAP_CHAIN_DESC
name|desc
decl_stmt|;
name|HRESULT
name|result
init|=
name|mSwapChain
operator|->
name|GetDesc
argument_list|(
operator|&
name|desc
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Error reading swap chain description: 0x%08X"
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|release
argument_list|()
expr_stmt|;
return|return
name|EGL_BAD_ALLOC
return|;
block|}
name|result
operator|=
name|mSwapChain
operator|->
name|ResizeBuffers
argument_list|(
name|desc
operator|.
name|BufferCount
argument_list|,
name|backbufferWidth
argument_list|,
name|backbufferHeight
argument_list|,
name|getSwapChainNativeFormat
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Error resizing swap chain buffers: 0x%08X"
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|release
argument_list|()
expr_stmt|;
if|if
condition|(
name|d3d11
operator|::
name|isDeviceLostError
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|EGL_CONTEXT_LOST
return|;
block|}
else|else
block|{
return|return
name|EGL_BAD_ALLOC
return|;
block|}
block|}
name|result
operator|=
name|mSwapChain
operator|->
name|GetBuffer
argument_list|(
literal|0
argument_list|,
name|__uuidof
argument_list|(
name|ID3D11Texture2D
argument_list|)
argument_list|,
operator|(
name|LPVOID
operator|*
operator|)
operator|&
name|mBackBufferTexture
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mBackBufferTexture
argument_list|,
literal|"Back buffer texture"
argument_list|)
expr_stmt|;
name|result
operator|=
name|device
operator|->
name|CreateRenderTargetView
argument_list|(
name|mBackBufferTexture
argument_list|,
name|NULL
argument_list|,
operator|&
name|mBackBufferRTView
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mBackBufferRTView
argument_list|,
literal|"Back buffer render target"
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|device
operator|->
name|CreateShaderResourceView
argument_list|(
name|mBackBufferTexture
argument_list|,
literal|nullptr
argument_list|,
operator|&
name|mBackBufferSRView
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mBackBufferSRView
argument_list|,
literal|"Back buffer shader resource"
argument_list|)
expr_stmt|;
block|}
block|}
name|mFirstSwap
operator|=
literal|true
expr_stmt|;
return|return
name|resetOffscreenBuffers
argument_list|(
name|backbufferWidth
argument_list|,
name|backbufferHeight
argument_list|)
return|;
block|}
DECL|function|getSwapChainNativeFormat
name|DXGI_FORMAT
name|SwapChain11
operator|::
name|getSwapChainNativeFormat
parameter_list|()
specifier|const
block|{
comment|// Return a render target format for offscreen rendering is supported by IDXGISwapChain.
comment|// MSDN https://msdn.microsoft.com/en-us/library/windows/desktop/bb173064(v=vs.85).aspx
return|return
operator|(
name|mOffscreenRenderTargetFormat
operator|==
name|GL_BGRA8_EXT
operator|)
condition|?
name|DXGI_FORMAT_B8G8R8A8_UNORM
else|:
name|DXGI_FORMAT_R8G8B8A8_UNORM
return|;
block|}
DECL|function|reset
name|EGLint
name|SwapChain11
operator|::
name|reset
parameter_list|(
name|int
name|backbufferWidth
parameter_list|,
name|int
name|backbufferHeight
parameter_list|,
name|EGLint
name|swapInterval
parameter_list|)
block|{
name|mSwapInterval
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|swapInterval
argument_list|)
expr_stmt|;
if|if
condition|(
name|mSwapInterval
operator|>
literal|4
condition|)
block|{
comment|// IDXGISwapChain::Present documentation states that valid sync intervals are in the [0,4]
comment|// range
return|return
name|EGL_BAD_PARAMETER
return|;
block|}
comment|// If the swap chain already exists, just resize
if|if
condition|(
name|mSwapChain
operator|!=
literal|nullptr
condition|)
block|{
return|return
name|resize
argument_list|(
name|backbufferWidth
argument_list|,
name|backbufferHeight
argument_list|)
return|;
block|}
name|TRACE_EVENT0
argument_list|(
literal|"gpu.angle"
argument_list|,
literal|"SwapChain11::reset"
argument_list|)
expr_stmt|;
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
if|if
condition|(
name|device
operator|==
name|NULL
condition|)
block|{
return|return
name|EGL_BAD_ACCESS
return|;
block|}
comment|// Release specific resources to free up memory for the new render target, while the
comment|// old render target still exists for the purpose of preserving its contents.
if|#
directive|if
name|defined
argument_list|(
name|ANGLE_ENABLE_D3D11_1
argument_list|)
name|SafeRelease
argument_list|(
name|mSwapChain1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SafeRelease
argument_list|(
name|mSwapChain
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mBackBufferTexture
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mBackBufferRTView
argument_list|)
expr_stmt|;
comment|// EGL allows creating a surface with 0x0 dimension, however, DXGI does not like 0x0 swapchains
if|if
condition|(
name|backbufferWidth
operator|<
literal|1
operator|||
name|backbufferHeight
operator|<
literal|1
condition|)
block|{
name|releaseOffscreenColorBuffer
argument_list|()
expr_stmt|;
return|return
name|EGL_SUCCESS
return|;
block|}
if|if
condition|(
name|mNativeWindow
operator|.
name|getNativeWindow
argument_list|()
condition|)
block|{
name|HRESULT
name|result
init|=
name|mNativeWindow
operator|.
name|createSwapChain
argument_list|(
name|device
argument_list|,
name|mRenderer
operator|->
name|getDxgiFactory
argument_list|()
argument_list|,
name|getSwapChainNativeFormat
argument_list|()
argument_list|,
name|backbufferWidth
argument_list|,
name|backbufferHeight
argument_list|,
operator|&
name|mSwapChain
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not create additional swap chains or offscreen surfaces: %08lX"
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|release
argument_list|()
expr_stmt|;
if|if
condition|(
name|d3d11
operator|::
name|isDeviceLostError
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|EGL_CONTEXT_LOST
return|;
block|}
else|else
block|{
return|return
name|EGL_BAD_ALLOC
return|;
block|}
block|}
if|if
condition|(
name|mRenderer
operator|->
name|getRenderer11DeviceCaps
argument_list|()
operator|.
name|supportsDXGI1_2
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|ANGLE_ENABLE_D3D11_1
argument_list|)
name|mSwapChain1
operator|=
name|d3d11
operator|::
name|DynamicCastComObject
argument_list|<
name|IDXGISwapChain1
argument_list|>
argument_list|(
name|mSwapChain
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|result
operator|=
name|mSwapChain
operator|->
name|GetBuffer
argument_list|(
literal|0
argument_list|,
name|__uuidof
argument_list|(
name|ID3D11Texture2D
argument_list|)
argument_list|,
operator|(
name|LPVOID
operator|*
operator|)
operator|&
name|mBackBufferTexture
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mBackBufferTexture
argument_list|,
literal|"Back buffer texture"
argument_list|)
expr_stmt|;
name|result
operator|=
name|device
operator|->
name|CreateRenderTargetView
argument_list|(
name|mBackBufferTexture
argument_list|,
name|NULL
argument_list|,
operator|&
name|mBackBufferRTView
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mBackBufferRTView
argument_list|,
literal|"Back buffer render target"
argument_list|)
expr_stmt|;
name|result
operator|=
name|device
operator|->
name|CreateShaderResourceView
argument_list|(
name|mBackBufferTexture
argument_list|,
literal|nullptr
argument_list|,
operator|&
name|mBackBufferSRView
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mBackBufferSRView
argument_list|,
literal|"Back buffer shader resource view"
argument_list|)
expr_stmt|;
block|}
name|mFirstSwap
operator|=
literal|true
expr_stmt|;
return|return
name|resetOffscreenBuffers
argument_list|(
name|backbufferWidth
argument_list|,
name|backbufferHeight
argument_list|)
return|;
block|}
DECL|function|initPassThroughResources
name|void
name|SwapChain11
operator|::
name|initPassThroughResources
parameter_list|()
block|{
if|if
condition|(
name|mPassThroughResourcesInit
condition|)
block|{
return|return;
block|}
name|TRACE_EVENT0
argument_list|(
literal|"gpu.angle"
argument_list|,
literal|"SwapChain11::initPassThroughResources"
argument_list|)
expr_stmt|;
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|device
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|// Make sure our resources are all not allocated, when we create
name|ASSERT
argument_list|(
name|mQuadVB
operator|==
name|NULL
operator|&&
name|mPassThroughSampler
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mPassThroughIL
operator|==
name|NULL
operator|&&
name|mPassThroughVS
operator|==
name|NULL
operator|&&
name|mPassThroughPS
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|D3D11_BUFFER_DESC
name|vbDesc
decl_stmt|;
name|vbDesc
operator|.
name|ByteWidth
operator|=
sizeof|sizeof
argument_list|(
name|d3d11
operator|::
name|PositionTexCoordVertex
argument_list|)
operator|*
literal|4
expr_stmt|;
name|vbDesc
operator|.
name|Usage
operator|=
name|D3D11_USAGE_DYNAMIC
expr_stmt|;
name|vbDesc
operator|.
name|BindFlags
operator|=
name|D3D11_BIND_VERTEX_BUFFER
expr_stmt|;
name|vbDesc
operator|.
name|CPUAccessFlags
operator|=
name|D3D11_CPU_ACCESS_WRITE
expr_stmt|;
name|vbDesc
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|vbDesc
operator|.
name|StructureByteStride
operator|=
literal|0
expr_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateBuffer
argument_list|(
operator|&
name|vbDesc
argument_list|,
name|NULL
argument_list|,
operator|&
name|mQuadVB
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mQuadVB
argument_list|,
literal|"Swap chain quad vertex buffer"
argument_list|)
expr_stmt|;
name|D3D11_SAMPLER_DESC
name|samplerDesc
decl_stmt|;
name|samplerDesc
operator|.
name|Filter
operator|=
name|D3D11_FILTER_MIN_MAG_MIP_POINT
expr_stmt|;
name|samplerDesc
operator|.
name|AddressU
operator|=
name|D3D11_TEXTURE_ADDRESS_CLAMP
expr_stmt|;
name|samplerDesc
operator|.
name|AddressV
operator|=
name|D3D11_TEXTURE_ADDRESS_CLAMP
expr_stmt|;
name|samplerDesc
operator|.
name|AddressW
operator|=
name|D3D11_TEXTURE_ADDRESS_CLAMP
expr_stmt|;
name|samplerDesc
operator|.
name|MipLODBias
operator|=
literal|0.0f
expr_stmt|;
name|samplerDesc
operator|.
name|MaxAnisotropy
operator|=
literal|0
expr_stmt|;
name|samplerDesc
operator|.
name|ComparisonFunc
operator|=
name|D3D11_COMPARISON_NEVER
expr_stmt|;
name|samplerDesc
operator|.
name|BorderColor
index|[
literal|0
index|]
operator|=
literal|0.0f
expr_stmt|;
name|samplerDesc
operator|.
name|BorderColor
index|[
literal|1
index|]
operator|=
literal|0.0f
expr_stmt|;
name|samplerDesc
operator|.
name|BorderColor
index|[
literal|2
index|]
operator|=
literal|0.0f
expr_stmt|;
name|samplerDesc
operator|.
name|BorderColor
index|[
literal|3
index|]
operator|=
literal|0.0f
expr_stmt|;
name|samplerDesc
operator|.
name|MinLOD
operator|=
literal|0
expr_stmt|;
name|samplerDesc
operator|.
name|MaxLOD
operator|=
name|D3D11_FLOAT32_MAX
expr_stmt|;
name|result
operator|=
name|device
operator|->
name|CreateSamplerState
argument_list|(
operator|&
name|samplerDesc
argument_list|,
operator|&
name|mPassThroughSampler
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mPassThroughSampler
argument_list|,
literal|"Swap chain pass through sampler"
argument_list|)
expr_stmt|;
name|D3D11_INPUT_ELEMENT_DESC
name|quadLayout
index|[]
init|=
block|{
block|{
literal|"POSITION"
block|,
literal|0
block|,
name|DXGI_FORMAT_R32G32_FLOAT
block|,
literal|0
block|,
literal|0
block|,
name|D3D11_INPUT_PER_VERTEX_DATA
block|,
literal|0
block|}
block|,
block|{
literal|"TEXCOORD"
block|,
literal|0
block|,
name|DXGI_FORMAT_R32G32_FLOAT
block|,
literal|0
block|,
literal|8
block|,
name|D3D11_INPUT_PER_VERTEX_DATA
block|,
literal|0
block|}
block|,     }
decl_stmt|;
name|result
operator|=
name|device
operator|->
name|CreateInputLayout
argument_list|(
name|quadLayout
argument_list|,
literal|2
argument_list|,
name|g_VS_Passthrough2D
argument_list|,
sizeof|sizeof
argument_list|(
name|g_VS_Passthrough2D
argument_list|)
argument_list|,
operator|&
name|mPassThroughIL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mPassThroughIL
argument_list|,
literal|"Swap chain pass through layout"
argument_list|)
expr_stmt|;
name|result
operator|=
name|device
operator|->
name|CreateVertexShader
argument_list|(
name|g_VS_Passthrough2D
argument_list|,
sizeof|sizeof
argument_list|(
name|g_VS_Passthrough2D
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|mPassThroughVS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mPassThroughVS
argument_list|,
literal|"Swap chain pass through vertex shader"
argument_list|)
expr_stmt|;
name|result
operator|=
name|device
operator|->
name|CreatePixelShader
argument_list|(
name|g_PS_PassthroughRGBA2D
argument_list|,
sizeof|sizeof
argument_list|(
name|g_PS_PassthroughRGBA2D
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|mPassThroughPS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mPassThroughPS
argument_list|,
literal|"Swap chain pass through pixel shader"
argument_list|)
expr_stmt|;
comment|// Use the default rasterizer state but without culling
name|D3D11_RASTERIZER_DESC
name|rasterizerDesc
decl_stmt|;
name|rasterizerDesc
operator|.
name|FillMode
operator|=
name|D3D11_FILL_SOLID
expr_stmt|;
name|rasterizerDesc
operator|.
name|CullMode
operator|=
name|D3D11_CULL_NONE
expr_stmt|;
name|rasterizerDesc
operator|.
name|FrontCounterClockwise
operator|=
name|FALSE
expr_stmt|;
name|rasterizerDesc
operator|.
name|DepthBias
operator|=
literal|0
expr_stmt|;
name|rasterizerDesc
operator|.
name|SlopeScaledDepthBias
operator|=
literal|0.0f
expr_stmt|;
name|rasterizerDesc
operator|.
name|DepthBiasClamp
operator|=
literal|0.0f
expr_stmt|;
name|rasterizerDesc
operator|.
name|DepthClipEnable
operator|=
name|TRUE
expr_stmt|;
name|rasterizerDesc
operator|.
name|ScissorEnable
operator|=
name|FALSE
expr_stmt|;
name|rasterizerDesc
operator|.
name|MultisampleEnable
operator|=
name|FALSE
expr_stmt|;
name|rasterizerDesc
operator|.
name|AntialiasedLineEnable
operator|=
name|FALSE
expr_stmt|;
name|result
operator|=
name|device
operator|->
name|CreateRasterizerState
argument_list|(
operator|&
name|rasterizerDesc
argument_list|,
operator|&
name|mPassThroughRS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mPassThroughRS
argument_list|,
literal|"Swap chain pass through rasterizer state"
argument_list|)
expr_stmt|;
name|mPassThroughResourcesInit
operator|=
literal|true
expr_stmt|;
block|}
comment|// parameters should be validated/clamped by caller
DECL|function|swapRect
name|EGLint
name|SwapChain11
operator|::
name|swapRect
parameter_list|(
name|EGLint
name|x
parameter_list|,
name|EGLint
name|y
parameter_list|,
name|EGLint
name|width
parameter_list|,
name|EGLint
name|height
parameter_list|)
block|{
if|if
condition|(
name|mNeedsOffscreenTexture
condition|)
block|{
name|EGLint
name|result
init|=
name|copyOffscreenToBackbuffer
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
name|EGL_SUCCESS
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
name|EGLint
name|result
init|=
name|present
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
name|EGL_SUCCESS
condition|)
block|{
return|return
name|result
return|;
block|}
name|mRenderer
operator|->
name|onSwap
argument_list|()
expr_stmt|;
return|return
name|EGL_SUCCESS
return|;
block|}
DECL|function|copyOffscreenToBackbuffer
name|EGLint
name|SwapChain11
operator|::
name|copyOffscreenToBackbuffer
parameter_list|(
name|EGLint
name|x
parameter_list|,
name|EGLint
name|y
parameter_list|,
name|EGLint
name|width
parameter_list|,
name|EGLint
name|height
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mSwapChain
condition|)
block|{
return|return
name|EGL_SUCCESS
return|;
block|}
name|initPassThroughResources
argument_list|()
expr_stmt|;
name|ID3D11DeviceContext
modifier|*
name|deviceContext
init|=
name|mRenderer
operator|->
name|getDeviceContext
argument_list|()
decl_stmt|;
comment|// Set vertices
name|D3D11_MAPPED_SUBRESOURCE
name|mappedResource
decl_stmt|;
name|HRESULT
name|result
init|=
name|deviceContext
operator|->
name|Map
argument_list|(
name|mQuadVB
argument_list|,
literal|0
argument_list|,
name|D3D11_MAP_WRITE_DISCARD
argument_list|,
literal|0
argument_list|,
operator|&
name|mappedResource
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|EGL_BAD_ACCESS
return|;
block|}
name|d3d11
operator|::
name|PositionTexCoordVertex
modifier|*
name|vertices
init|=
cast|static_cast
argument_list|<
name|d3d11
operator|::
name|PositionTexCoordVertex
operator|*
argument_list|>
argument_list|(
name|mappedResource
operator|.
name|pData
argument_list|)
decl_stmt|;
comment|// Create a quad in homogeneous coordinates
name|float
name|x1
init|=
operator|(
name|x
operator|/
name|float
argument_list|(
name|mWidth
argument_list|)
operator|)
operator|*
literal|2.0f
operator|-
literal|1.0f
decl_stmt|;
name|float
name|y1
init|=
operator|(
name|y
operator|/
name|float
argument_list|(
name|mHeight
argument_list|)
operator|)
operator|*
literal|2.0f
operator|-
literal|1.0f
decl_stmt|;
name|float
name|x2
init|=
operator|(
operator|(
name|x
operator|+
name|width
operator|)
operator|/
name|float
argument_list|(
name|mWidth
argument_list|)
operator|)
operator|*
literal|2.0f
operator|-
literal|1.0f
decl_stmt|;
name|float
name|y2
init|=
operator|(
operator|(
name|y
operator|+
name|height
operator|)
operator|/
name|float
argument_list|(
name|mHeight
argument_list|)
operator|)
operator|*
literal|2.0f
operator|-
literal|1.0f
decl_stmt|;
name|float
name|u1
init|=
name|x
operator|/
name|float
argument_list|(
name|mWidth
argument_list|)
decl_stmt|;
name|float
name|v1
init|=
name|y
operator|/
name|float
argument_list|(
name|mHeight
argument_list|)
decl_stmt|;
name|float
name|u2
init|=
operator|(
name|x
operator|+
name|width
operator|)
operator|/
name|float
argument_list|(
name|mWidth
argument_list|)
decl_stmt|;
name|float
name|v2
init|=
operator|(
name|y
operator|+
name|height
operator|)
operator|/
name|float
argument_list|(
name|mHeight
argument_list|)
decl_stmt|;
comment|// Invert the quad vertices depending on the surface orientation.
if|if
condition|(
operator|(
name|mOrientation
operator|&
name|EGL_SURFACE_ORIENTATION_INVERT_X_ANGLE
operator|)
operator|!=
literal|0
condition|)
block|{
name|std
operator|::
name|swap
argument_list|(
name|x1
argument_list|,
name|x2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mOrientation
operator|&
name|EGL_SURFACE_ORIENTATION_INVERT_Y_ANGLE
operator|)
operator|!=
literal|0
condition|)
block|{
name|std
operator|::
name|swap
argument_list|(
name|y1
argument_list|,
name|y2
argument_list|)
expr_stmt|;
block|}
name|d3d11
operator|::
name|SetPositionTexCoordVertex
argument_list|(
operator|&
name|vertices
index|[
literal|0
index|]
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|u1
argument_list|,
name|v1
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetPositionTexCoordVertex
argument_list|(
operator|&
name|vertices
index|[
literal|1
index|]
argument_list|,
name|x1
argument_list|,
name|y2
argument_list|,
name|u1
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetPositionTexCoordVertex
argument_list|(
operator|&
name|vertices
index|[
literal|2
index|]
argument_list|,
name|x2
argument_list|,
name|y1
argument_list|,
name|u2
argument_list|,
name|v1
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetPositionTexCoordVertex
argument_list|(
operator|&
name|vertices
index|[
literal|3
index|]
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|u2
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|deviceContext
operator|->
name|Unmap
argument_list|(
name|mQuadVB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
specifier|static
name|UINT
name|stride
init|=
sizeof|sizeof
argument_list|(
name|d3d11
operator|::
name|PositionTexCoordVertex
argument_list|)
decl_stmt|;
specifier|static
name|UINT
name|startIdx
init|=
literal|0
decl_stmt|;
name|deviceContext
operator|->
name|IASetVertexBuffers
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|mQuadVB
argument_list|,
operator|&
name|stride
argument_list|,
operator|&
name|startIdx
argument_list|)
expr_stmt|;
comment|// Apply state
name|deviceContext
operator|->
name|OMSetDepthStencilState
argument_list|(
name|NULL
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
specifier|static
specifier|const
name|float
name|blendFactor
index|[
literal|4
index|]
init|=
block|{
literal|1.0f
block|,
literal|1.0f
block|,
literal|1.0f
block|,
literal|1.0f
block|}
decl_stmt|;
name|deviceContext
operator|->
name|OMSetBlendState
argument_list|(
name|NULL
argument_list|,
name|blendFactor
argument_list|,
literal|0xFFFFFFF
argument_list|)
expr_stmt|;
name|deviceContext
operator|->
name|RSSetState
argument_list|(
name|mPassThroughRS
argument_list|)
expr_stmt|;
comment|// Apply shaders
name|deviceContext
operator|->
name|IASetInputLayout
argument_list|(
name|mPassThroughIL
argument_list|)
expr_stmt|;
name|deviceContext
operator|->
name|IASetPrimitiveTopology
argument_list|(
name|D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP
argument_list|)
expr_stmt|;
name|deviceContext
operator|->
name|VSSetShader
argument_list|(
name|mPassThroughVS
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|deviceContext
operator|->
name|PSSetShader
argument_list|(
name|mPassThroughPS
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|deviceContext
operator|->
name|GSSetShader
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Apply render targets
name|mRenderer
operator|->
name|setOneTimeRenderTarget
argument_list|(
name|mBackBufferRTView
argument_list|)
expr_stmt|;
comment|// Set the viewport
name|D3D11_VIEWPORT
name|viewport
decl_stmt|;
name|viewport
operator|.
name|TopLeftX
operator|=
literal|0
expr_stmt|;
name|viewport
operator|.
name|TopLeftY
operator|=
literal|0
expr_stmt|;
name|viewport
operator|.
name|Width
operator|=
cast|static_cast
argument_list|<
name|FLOAT
argument_list|>
argument_list|(
name|mWidth
argument_list|)
expr_stmt|;
name|viewport
operator|.
name|Height
operator|=
cast|static_cast
argument_list|<
name|FLOAT
argument_list|>
argument_list|(
name|mHeight
argument_list|)
expr_stmt|;
name|viewport
operator|.
name|MinDepth
operator|=
literal|0.0f
expr_stmt|;
name|viewport
operator|.
name|MaxDepth
operator|=
literal|1.0f
expr_stmt|;
name|deviceContext
operator|->
name|RSSetViewports
argument_list|(
literal|1
argument_list|,
operator|&
name|viewport
argument_list|)
expr_stmt|;
comment|// Apply textures
name|auto
name|stateManager
init|=
name|mRenderer
operator|->
name|getStateManager
argument_list|()
decl_stmt|;
name|stateManager
operator|->
name|setShaderResource
argument_list|(
name|gl
operator|::
name|SAMPLER_PIXEL
argument_list|,
literal|0
argument_list|,
name|mOffscreenSRView
argument_list|)
expr_stmt|;
name|deviceContext
operator|->
name|PSSetSamplers
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|mPassThroughSampler
argument_list|)
expr_stmt|;
comment|// Draw
name|deviceContext
operator|->
name|Draw
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Rendering to the swapchain is now complete. Now we can call Present().
comment|// Before that, we perform any cleanup on the D3D device. We do this before Present() to make sure the
comment|// cleanup is caught under the current eglSwapBuffers() PIX/Graphics Diagnostics call rather than the next one.
name|stateManager
operator|->
name|setShaderResource
argument_list|(
name|gl
operator|::
name|SAMPLER_PIXEL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mRenderer
operator|->
name|unapplyRenderTargets
argument_list|()
expr_stmt|;
name|mRenderer
operator|->
name|markAllStateDirty
argument_list|()
expr_stmt|;
return|return
name|EGL_SUCCESS
return|;
block|}
DECL|function|present
name|EGLint
name|SwapChain11
operator|::
name|present
parameter_list|(
name|EGLint
name|x
parameter_list|,
name|EGLint
name|y
parameter_list|,
name|EGLint
name|width
parameter_list|,
name|EGLint
name|height
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mSwapChain
condition|)
block|{
return|return
name|EGL_SUCCESS
return|;
block|}
name|UINT
name|swapInterval
init|=
name|mSwapInterval
decl_stmt|;
if|#
directive|if
name|ANGLE_VSYNC
operator|==
name|ANGLE_DISABLED
name|swapInterval
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|HRESULT
name|result
init|=
name|S_OK
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ANGLE_ENABLE_D3D11_1
argument_list|)
comment|// Use IDXGISwapChain1::Present1 with a dirty rect if DXGI 1.2 is available.
if|if
condition|(
name|mSwapChain1
operator|!=
literal|nullptr
condition|)
block|{
if|if
condition|(
name|mFirstSwap
condition|)
block|{
comment|// Can't swap with a dirty rect if this swap chain has never swapped before
name|DXGI_PRESENT_PARAMETERS
name|params
init|=
block|{
literal|0
block|,
literal|nullptr
block|,
literal|nullptr
block|,
literal|nullptr
block|}
decl_stmt|;
name|result
operator|=
name|mSwapChain1
operator|->
name|Present1
argument_list|(
name|swapInterval
argument_list|,
literal|0
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RECT
name|rect
init|=
block|{
cast|static_cast
argument_list|<
name|LONG
argument_list|>
argument_list|(
name|x
argument_list|)
block|,
cast|static_cast
argument_list|<
name|LONG
argument_list|>
argument_list|(
name|mHeight
operator|-
name|y
operator|-
name|height
argument_list|)
block|,
cast|static_cast
argument_list|<
name|LONG
argument_list|>
argument_list|(
name|x
operator|+
name|width
argument_list|)
block|,
expr|static_cast
operator|<
name|LONG
operator|>
operator|(
name|mHeight
operator|-
name|y
operator|)
block|}
decl_stmt|;
name|DXGI_PRESENT_PARAMETERS
name|params
init|=
block|{
literal|1
block|,
operator|&
name|rect
block|,
literal|nullptr
block|,
literal|nullptr
block|}
decl_stmt|;
name|result
operator|=
name|mSwapChain1
operator|->
name|Present1
argument_list|(
name|swapInterval
argument_list|,
literal|0
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
name|result
operator|=
name|mSwapChain
operator|->
name|Present
argument_list|(
name|swapInterval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mFirstSwap
operator|=
literal|false
expr_stmt|;
comment|// Some swapping mechanisms such as DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL unbind the current render
comment|// target.  Mark it dirty.
name|mRenderer
operator|->
name|getStateManager
argument_list|()
operator|->
name|invalidateRenderTarget
argument_list|()
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DXGI_ERROR_DEVICE_REMOVED
condition|)
block|{
name|ERR
argument_list|(
literal|"Present failed: the D3D11 device was removed: 0x%08X"
argument_list|,
name|mRenderer
operator|->
name|getDevice
argument_list|()
operator|->
name|GetDeviceRemovedReason
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|EGL_CONTEXT_LOST
return|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|DXGI_ERROR_DEVICE_RESET
condition|)
block|{
name|ERR
argument_list|(
literal|"Present failed: the D3D11 device was reset from a bad command."
argument_list|)
expr_stmt|;
return|return
name|EGL_CONTEXT_LOST
return|;
block|}
elseif|else
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Present failed with error code 0x%08X"
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
name|mNativeWindow
operator|.
name|commitChange
argument_list|()
expr_stmt|;
return|return
name|EGL_SUCCESS
return|;
block|}
DECL|function|getOffscreenTexture
name|ID3D11Texture2D
modifier|*
name|SwapChain11
operator|::
name|getOffscreenTexture
parameter_list|()
block|{
return|return
name|mNeedsOffscreenTexture
condition|?
name|mOffscreenTexture
else|:
name|mBackBufferTexture
return|;
block|}
DECL|function|getRenderTarget
name|ID3D11RenderTargetView
modifier|*
name|SwapChain11
operator|::
name|getRenderTarget
parameter_list|()
block|{
return|return
name|mNeedsOffscreenTexture
condition|?
name|mOffscreenRTView
else|:
name|mBackBufferRTView
return|;
block|}
DECL|function|getRenderTargetShaderResource
name|ID3D11ShaderResourceView
modifier|*
name|SwapChain11
operator|::
name|getRenderTargetShaderResource
parameter_list|()
block|{
return|return
name|mNeedsOffscreenTexture
condition|?
name|mOffscreenSRView
else|:
name|mBackBufferSRView
return|;
block|}
DECL|function|getDepthStencil
name|ID3D11DepthStencilView
modifier|*
name|SwapChain11
operator|::
name|getDepthStencil
parameter_list|()
block|{
return|return
name|mDepthStencilDSView
return|;
block|}
DECL|function|getDepthStencilShaderResource
name|ID3D11ShaderResourceView
modifier|*
name|SwapChain11
operator|::
name|getDepthStencilShaderResource
parameter_list|()
block|{
return|return
name|mDepthStencilSRView
return|;
block|}
DECL|function|getDepthStencilTexture
name|ID3D11Texture2D
modifier|*
name|SwapChain11
operator|::
name|getDepthStencilTexture
parameter_list|()
block|{
return|return
name|mDepthStencilTexture
return|;
block|}
DECL|function|recreate
name|void
name|SwapChain11
operator|::
name|recreate
parameter_list|()
block|{
comment|// possibly should use this method instead of reset
block|}
DECL|function|getDevice
name|void
modifier|*
name|rx
operator|::
name|SwapChain11
operator|::
name|getDevice
parameter_list|()
block|{
return|return
name|mRenderer
operator|->
name|getDevice
argument_list|()
return|;
block|}
block|}
end_namespace
end_unit
