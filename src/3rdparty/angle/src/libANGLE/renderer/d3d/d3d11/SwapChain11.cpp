begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2012-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// SwapChain11.cpp: Implements a back-end specific class for the D3D11 swap chain.
end_comment
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/SwapChain11.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/renderer11_utils.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/formatutils11.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/Renderer11.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/NativeWindow.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/features.h"
end_include
begin_comment
comment|// Precompiled shaders
end_comment
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/shaders/compiled/passthrough2d11vs.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/shaders/compiled/passthroughrgba2d11ps.h"
end_include
begin_namespace
DECL|namespace|rx
namespace|namespace
name|rx
block|{
DECL|function|SwapChain11
name|SwapChain11
operator|::
name|SwapChain11
parameter_list|(
name|Renderer11
modifier|*
name|renderer
parameter_list|,
name|NativeWindow
name|nativeWindow
parameter_list|,
name|HANDLE
name|shareHandle
parameter_list|,
name|GLenum
name|backBufferFormat
parameter_list|,
name|GLenum
name|depthBufferFormat
parameter_list|)
member_init_list|:
name|mRenderer
argument_list|(
name|renderer
argument_list|)
member_init_list|,
name|SwapChainD3D
argument_list|(
name|nativeWindow
argument_list|,
name|shareHandle
argument_list|,
name|backBufferFormat
argument_list|,
name|depthBufferFormat
argument_list|)
member_init_list|,
name|mColorRenderTarget
argument_list|(
name|this
argument_list|,
name|renderer
argument_list|,
literal|false
argument_list|)
member_init_list|,
name|mDepthStencilRenderTarget
argument_list|(
name|this
argument_list|,
name|renderer
argument_list|,
literal|true
argument_list|)
block|{
name|mSwapChain
operator|=
name|NULL
expr_stmt|;
name|mBackBufferTexture
operator|=
name|NULL
expr_stmt|;
name|mBackBufferRTView
operator|=
name|NULL
expr_stmt|;
name|mOffscreenTexture
operator|=
name|NULL
expr_stmt|;
name|mOffscreenRTView
operator|=
name|NULL
expr_stmt|;
name|mOffscreenSRView
operator|=
name|NULL
expr_stmt|;
name|mDepthStencilTexture
operator|=
name|NULL
expr_stmt|;
name|mDepthStencilDSView
operator|=
name|NULL
expr_stmt|;
name|mDepthStencilSRView
operator|=
name|NULL
expr_stmt|;
name|mQuadVB
operator|=
name|NULL
expr_stmt|;
name|mPassThroughSampler
operator|=
name|NULL
expr_stmt|;
name|mPassThroughIL
operator|=
name|NULL
expr_stmt|;
name|mPassThroughVS
operator|=
name|NULL
expr_stmt|;
name|mPassThroughPS
operator|=
name|NULL
expr_stmt|;
name|mWidth
operator|=
operator|-
literal|1
expr_stmt|;
name|mHeight
operator|=
operator|-
literal|1
expr_stmt|;
name|mSwapInterval
operator|=
literal|0
expr_stmt|;
name|mAppCreatedShareHandle
operator|=
name|mShareHandle
operator|!=
name|NULL
expr_stmt|;
name|mPassThroughResourcesInit
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|~SwapChain11
name|SwapChain11
operator|::
name|~
name|SwapChain11
parameter_list|()
block|{
name|release
argument_list|()
expr_stmt|;
block|}
DECL|function|release
name|void
name|SwapChain11
operator|::
name|release
parameter_list|()
block|{
name|SafeRelease
argument_list|(
name|mSwapChain
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mBackBufferTexture
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mBackBufferRTView
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mOffscreenTexture
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mOffscreenRTView
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mOffscreenSRView
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mDepthStencilTexture
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mDepthStencilDSView
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mDepthStencilSRView
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mQuadVB
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mPassThroughSampler
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mPassThroughIL
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mPassThroughVS
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mPassThroughPS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mAppCreatedShareHandle
condition|)
block|{
name|mShareHandle
operator|=
name|NULL
expr_stmt|;
block|}
block|}
DECL|function|releaseOffscreenTexture
name|void
name|SwapChain11
operator|::
name|releaseOffscreenTexture
parameter_list|()
block|{
name|SafeRelease
argument_list|(
name|mOffscreenTexture
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mOffscreenRTView
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mOffscreenSRView
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mDepthStencilTexture
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mDepthStencilDSView
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mDepthStencilSRView
argument_list|)
expr_stmt|;
block|}
DECL|function|resetOffscreenTexture
name|EGLint
name|SwapChain11
operator|::
name|resetOffscreenTexture
parameter_list|(
name|int
name|backbufferWidth
parameter_list|,
name|int
name|backbufferHeight
parameter_list|)
block|{
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|device
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|// D3D11 does not allow zero size textures
name|ASSERT
argument_list|(
name|backbufferWidth
operator|>=
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|backbufferHeight
operator|>=
literal|1
argument_list|)
expr_stmt|;
comment|// Preserve the render target content
name|ID3D11Texture2D
modifier|*
name|previousOffscreenTexture
init|=
name|mOffscreenTexture
decl_stmt|;
if|if
condition|(
name|previousOffscreenTexture
condition|)
block|{
name|previousOffscreenTexture
operator|->
name|AddRef
argument_list|()
expr_stmt|;
block|}
specifier|const
name|int
name|previousWidth
init|=
name|mWidth
decl_stmt|;
specifier|const
name|int
name|previousHeight
init|=
name|mHeight
decl_stmt|;
name|releaseOffscreenTexture
argument_list|()
expr_stmt|;
specifier|const
name|d3d11
operator|::
name|TextureFormat
modifier|&
name|backbufferFormatInfo
init|=
name|d3d11
operator|::
name|GetTextureFormatInfo
argument_list|(
name|mBackBufferFormat
argument_list|,
name|mRenderer
operator|->
name|getFeatureLevel
argument_list|()
argument_list|)
decl_stmt|;
comment|// If the app passed in a share handle, open the resource
comment|// See EGL_ANGLE_d3d_share_handle_client_buffer
if|if
condition|(
name|mAppCreatedShareHandle
condition|)
block|{
name|ID3D11Resource
modifier|*
name|tempResource11
decl_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|OpenSharedResource
argument_list|(
name|mShareHandle
argument_list|,
name|__uuidof
argument_list|(
name|ID3D11Resource
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|tempResource11
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to open the swap chain pbuffer share handle: %08lX"
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|release
argument_list|()
expr_stmt|;
return|return
name|EGL_BAD_PARAMETER
return|;
block|}
name|result
operator|=
name|tempResource11
operator|->
name|QueryInterface
argument_list|(
name|__uuidof
argument_list|(
name|ID3D11Texture2D
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|mOffscreenTexture
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|tempResource11
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Failed to query texture2d interface in pbuffer share handle: %08lX"
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|release
argument_list|()
expr_stmt|;
return|return
name|EGL_BAD_PARAMETER
return|;
block|}
comment|// Validate offscreen texture parameters
name|D3D11_TEXTURE2D_DESC
name|offscreenTextureDesc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|mOffscreenTexture
operator|->
name|GetDesc
argument_list|(
operator|&
name|offscreenTextureDesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|offscreenTextureDesc
operator|.
name|Width
operator|!=
operator|(
name|UINT
operator|)
name|backbufferWidth
operator|||
name|offscreenTextureDesc
operator|.
name|Height
operator|!=
operator|(
name|UINT
operator|)
name|backbufferHeight
operator|||
name|offscreenTextureDesc
operator|.
name|Format
operator|!=
name|backbufferFormatInfo
operator|.
name|texFormat
operator|||
name|offscreenTextureDesc
operator|.
name|MipLevels
operator|!=
literal|1
operator|||
name|offscreenTextureDesc
operator|.
name|ArraySize
operator|!=
literal|1
condition|)
block|{
name|ERR
argument_list|(
literal|"Invalid texture parameters in the shared offscreen texture pbuffer"
argument_list|)
expr_stmt|;
name|release
argument_list|()
expr_stmt|;
return|return
name|EGL_BAD_PARAMETER
return|;
block|}
block|}
else|else
block|{
specifier|const
name|bool
name|useSharedResource
init|=
operator|!
name|mNativeWindow
operator|.
name|getNativeWindow
argument_list|()
operator|&&
name|mRenderer
operator|->
name|getShareHandleSupport
argument_list|()
decl_stmt|;
name|D3D11_TEXTURE2D_DESC
name|offscreenTextureDesc
init|=
block|{
literal|0
block|}
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ANGLE_ENABLE_WINDOWS_STORE
argument_list|)
operator|&&
operator|(
name|WINAPI_FAMILY
operator|==
name|WINAPI_FAMILY_PHONE_APP
operator|)
specifier|const
name|int
name|textureLength
init|=
name|std
operator|::
name|max
argument_list|(
name|backbufferWidth
argument_list|,
name|backbufferHeight
argument_list|)
decl_stmt|;
name|offscreenTextureDesc
operator|.
name|Width
operator|=
name|textureLength
expr_stmt|;
name|offscreenTextureDesc
operator|.
name|Height
operator|=
name|textureLength
expr_stmt|;
else|#
directive|else
name|offscreenTextureDesc
operator|.
name|Width
operator|=
name|backbufferWidth
expr_stmt|;
name|offscreenTextureDesc
operator|.
name|Height
operator|=
name|backbufferHeight
expr_stmt|;
endif|#
directive|endif
name|offscreenTextureDesc
operator|.
name|Format
operator|=
name|backbufferFormatInfo
operator|.
name|texFormat
expr_stmt|;
name|offscreenTextureDesc
operator|.
name|MipLevels
operator|=
literal|1
expr_stmt|;
name|offscreenTextureDesc
operator|.
name|ArraySize
operator|=
literal|1
expr_stmt|;
name|offscreenTextureDesc
operator|.
name|SampleDesc
operator|.
name|Count
operator|=
literal|1
expr_stmt|;
name|offscreenTextureDesc
operator|.
name|SampleDesc
operator|.
name|Quality
operator|=
literal|0
expr_stmt|;
name|offscreenTextureDesc
operator|.
name|Usage
operator|=
name|D3D11_USAGE_DEFAULT
expr_stmt|;
name|offscreenTextureDesc
operator|.
name|BindFlags
operator|=
name|D3D11_BIND_RENDER_TARGET
operator||
name|D3D11_BIND_SHADER_RESOURCE
expr_stmt|;
name|offscreenTextureDesc
operator|.
name|CPUAccessFlags
operator|=
literal|0
expr_stmt|;
name|offscreenTextureDesc
operator|.
name|MiscFlags
operator|=
name|useSharedResource
condition|?
name|D3D11_RESOURCE_MISC_SHARED
else|:
literal|0
expr_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateTexture2D
argument_list|(
operator|&
name|offscreenTextureDesc
argument_list|,
name|NULL
argument_list|,
operator|&
name|mOffscreenTexture
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not create offscreen texture: %08lX"
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|release
argument_list|()
expr_stmt|;
if|if
condition|(
name|d3d11
operator|::
name|isDeviceLostError
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|EGL_CONTEXT_LOST
return|;
block|}
else|else
block|{
return|return
name|EGL_BAD_ALLOC
return|;
block|}
block|}
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mOffscreenTexture
argument_list|,
literal|"Offscreen back buffer texture"
argument_list|)
expr_stmt|;
comment|// EGL_ANGLE_surface_d3d_texture_2d_share_handle requires that we store a share handle for the client
if|if
condition|(
name|useSharedResource
condition|)
block|{
name|IDXGIResource
modifier|*
name|offscreenTextureResource
init|=
name|NULL
decl_stmt|;
name|result
operator|=
name|mOffscreenTexture
operator|->
name|QueryInterface
argument_list|(
name|__uuidof
argument_list|(
name|IDXGIResource
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|offscreenTextureResource
argument_list|)
expr_stmt|;
comment|// Fall back to no share handle on failure
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not query offscreen texture resource: %08lX"
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|offscreenTextureResource
operator|->
name|GetSharedHandle
argument_list|(
operator|&
name|mShareHandle
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|offscreenTextureResource
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|mShareHandle
operator|=
name|NULL
expr_stmt|;
name|ERR
argument_list|(
literal|"Could not get offscreen texture shared handle: %08lX"
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|D3D11_RENDER_TARGET_VIEW_DESC
name|offscreenRTVDesc
decl_stmt|;
name|offscreenRTVDesc
operator|.
name|Format
operator|=
name|backbufferFormatInfo
operator|.
name|rtvFormat
expr_stmt|;
name|offscreenRTVDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_RTV_DIMENSION_TEXTURE2D
expr_stmt|;
name|offscreenRTVDesc
operator|.
name|Texture2D
operator|.
name|MipSlice
operator|=
literal|0
expr_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateRenderTargetView
argument_list|(
name|mOffscreenTexture
argument_list|,
operator|&
name|offscreenRTVDesc
argument_list|,
operator|&
name|mOffscreenRTView
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mOffscreenRTView
argument_list|,
literal|"Offscreen back buffer render target"
argument_list|)
expr_stmt|;
name|D3D11_SHADER_RESOURCE_VIEW_DESC
name|offscreenSRVDesc
decl_stmt|;
name|offscreenSRVDesc
operator|.
name|Format
operator|=
name|backbufferFormatInfo
operator|.
name|srvFormat
expr_stmt|;
name|offscreenSRVDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_SRV_DIMENSION_TEXTURE2D
expr_stmt|;
name|offscreenSRVDesc
operator|.
name|Texture2D
operator|.
name|MostDetailedMip
operator|=
literal|0
expr_stmt|;
name|offscreenSRVDesc
operator|.
name|Texture2D
operator|.
name|MipLevels
operator|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|device
operator|->
name|CreateShaderResourceView
argument_list|(
name|mOffscreenTexture
argument_list|,
operator|&
name|offscreenSRVDesc
argument_list|,
operator|&
name|mOffscreenSRView
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mOffscreenSRView
argument_list|,
literal|"Offscreen back buffer shader resource"
argument_list|)
expr_stmt|;
specifier|const
name|d3d11
operator|::
name|TextureFormat
modifier|&
name|depthBufferFormatInfo
init|=
name|d3d11
operator|::
name|GetTextureFormatInfo
argument_list|(
name|mDepthBufferFormat
argument_list|,
name|mRenderer
operator|->
name|getFeatureLevel
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|mDepthBufferFormat
operator|!=
name|GL_NONE
condition|)
block|{
name|D3D11_TEXTURE2D_DESC
name|depthStencilTextureDesc
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ANGLE_ENABLE_WINDOWS_STORE
argument_list|)
operator|&&
operator|(
name|WINAPI_FAMILY
operator|==
name|WINAPI_FAMILY_PHONE_APP
operator|)
specifier|const
name|int
name|textureLength
init|=
name|std
operator|::
name|max
argument_list|(
name|backbufferWidth
argument_list|,
name|backbufferHeight
argument_list|)
decl_stmt|;
name|depthStencilTextureDesc
operator|.
name|Width
operator|=
name|textureLength
expr_stmt|;
name|depthStencilTextureDesc
operator|.
name|Height
operator|=
name|textureLength
expr_stmt|;
else|#
directive|else
name|depthStencilTextureDesc
operator|.
name|Width
operator|=
name|backbufferWidth
expr_stmt|;
name|depthStencilTextureDesc
operator|.
name|Height
operator|=
name|backbufferHeight
expr_stmt|;
endif|#
directive|endif
name|depthStencilTextureDesc
operator|.
name|Format
operator|=
name|depthBufferFormatInfo
operator|.
name|texFormat
expr_stmt|;
name|depthStencilTextureDesc
operator|.
name|MipLevels
operator|=
literal|1
expr_stmt|;
name|depthStencilTextureDesc
operator|.
name|ArraySize
operator|=
literal|1
expr_stmt|;
name|depthStencilTextureDesc
operator|.
name|SampleDesc
operator|.
name|Count
operator|=
literal|1
expr_stmt|;
name|depthStencilTextureDesc
operator|.
name|SampleDesc
operator|.
name|Quality
operator|=
literal|0
expr_stmt|;
name|depthStencilTextureDesc
operator|.
name|Usage
operator|=
name|D3D11_USAGE_DEFAULT
expr_stmt|;
name|depthStencilTextureDesc
operator|.
name|BindFlags
operator|=
name|D3D11_BIND_DEPTH_STENCIL
expr_stmt|;
if|if
condition|(
name|depthBufferFormatInfo
operator|.
name|srvFormat
operator|!=
name|DXGI_FORMAT_UNKNOWN
condition|)
block|{
name|depthStencilTextureDesc
operator|.
name|BindFlags
operator||=
name|D3D11_BIND_SHADER_RESOURCE
expr_stmt|;
block|}
name|depthStencilTextureDesc
operator|.
name|CPUAccessFlags
operator|=
literal|0
expr_stmt|;
name|depthStencilTextureDesc
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|device
operator|->
name|CreateTexture2D
argument_list|(
operator|&
name|depthStencilTextureDesc
argument_list|,
name|NULL
argument_list|,
operator|&
name|mDepthStencilTexture
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not create depthstencil surface for new swap chain: 0x%08X"
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|release
argument_list|()
expr_stmt|;
if|if
condition|(
name|d3d11
operator|::
name|isDeviceLostError
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|EGL_CONTEXT_LOST
return|;
block|}
else|else
block|{
return|return
name|EGL_BAD_ALLOC
return|;
block|}
block|}
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mDepthStencilTexture
argument_list|,
literal|"Offscreen depth stencil texture"
argument_list|)
expr_stmt|;
name|D3D11_DEPTH_STENCIL_VIEW_DESC
name|depthStencilDesc
decl_stmt|;
name|depthStencilDesc
operator|.
name|Format
operator|=
name|depthBufferFormatInfo
operator|.
name|dsvFormat
expr_stmt|;
name|depthStencilDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_DSV_DIMENSION_TEXTURE2D
expr_stmt|;
name|depthStencilDesc
operator|.
name|Flags
operator|=
literal|0
expr_stmt|;
name|depthStencilDesc
operator|.
name|Texture2D
operator|.
name|MipSlice
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|device
operator|->
name|CreateDepthStencilView
argument_list|(
name|mDepthStencilTexture
argument_list|,
operator|&
name|depthStencilDesc
argument_list|,
operator|&
name|mDepthStencilDSView
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mDepthStencilDSView
argument_list|,
literal|"Offscreen depth stencil view"
argument_list|)
expr_stmt|;
if|if
condition|(
name|depthBufferFormatInfo
operator|.
name|srvFormat
operator|!=
name|DXGI_FORMAT_UNKNOWN
condition|)
block|{
name|D3D11_SHADER_RESOURCE_VIEW_DESC
name|depthStencilSRVDesc
decl_stmt|;
name|depthStencilSRVDesc
operator|.
name|Format
operator|=
name|depthBufferFormatInfo
operator|.
name|srvFormat
expr_stmt|;
name|depthStencilSRVDesc
operator|.
name|ViewDimension
operator|=
name|D3D11_SRV_DIMENSION_TEXTURE2D
expr_stmt|;
name|depthStencilSRVDesc
operator|.
name|Texture2D
operator|.
name|MostDetailedMip
operator|=
literal|0
expr_stmt|;
name|depthStencilSRVDesc
operator|.
name|Texture2D
operator|.
name|MipLevels
operator|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|device
operator|->
name|CreateShaderResourceView
argument_list|(
name|mDepthStencilTexture
argument_list|,
operator|&
name|depthStencilSRVDesc
argument_list|,
operator|&
name|mDepthStencilSRView
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mDepthStencilSRView
argument_list|,
literal|"Offscreen depth stencil shader resource"
argument_list|)
expr_stmt|;
block|}
block|}
name|mWidth
operator|=
name|backbufferWidth
expr_stmt|;
name|mHeight
operator|=
name|backbufferHeight
expr_stmt|;
if|if
condition|(
name|previousOffscreenTexture
operator|!=
name|NULL
condition|)
block|{
name|D3D11_BOX
name|sourceBox
init|=
block|{
literal|0
block|}
decl_stmt|;
name|sourceBox
operator|.
name|left
operator|=
literal|0
expr_stmt|;
name|sourceBox
operator|.
name|right
operator|=
name|std
operator|::
name|min
argument_list|(
name|previousWidth
argument_list|,
name|mWidth
argument_list|)
expr_stmt|;
name|sourceBox
operator|.
name|top
operator|=
name|std
operator|::
name|max
argument_list|(
name|previousHeight
operator|-
name|mHeight
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sourceBox
operator|.
name|bottom
operator|=
name|previousHeight
expr_stmt|;
name|sourceBox
operator|.
name|front
operator|=
literal|0
expr_stmt|;
name|sourceBox
operator|.
name|back
operator|=
literal|1
expr_stmt|;
name|ID3D11DeviceContext
modifier|*
name|deviceContext
init|=
name|mRenderer
operator|->
name|getDeviceContext
argument_list|()
decl_stmt|;
specifier|const
name|int
name|yoffset
init|=
name|std
operator|::
name|max
argument_list|(
name|mHeight
operator|-
name|previousHeight
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|deviceContext
operator|->
name|CopySubresourceRegion
argument_list|(
name|mOffscreenTexture
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|yoffset
argument_list|,
literal|0
argument_list|,
name|previousOffscreenTexture
argument_list|,
literal|0
argument_list|,
operator|&
name|sourceBox
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|previousOffscreenTexture
argument_list|)
expr_stmt|;
if|if
condition|(
name|mSwapChain
condition|)
block|{
name|swapRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|mWidth
argument_list|,
name|mHeight
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|EGL_SUCCESS
return|;
block|}
DECL|function|resize
name|EGLint
name|SwapChain11
operator|::
name|resize
parameter_list|(
name|EGLint
name|backbufferWidth
parameter_list|,
name|EGLint
name|backbufferHeight
parameter_list|)
block|{
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
if|if
condition|(
name|device
operator|==
name|NULL
condition|)
block|{
return|return
name|EGL_BAD_ACCESS
return|;
block|}
comment|// EGL allows creating a surface with 0x0 dimension, however, DXGI does not like 0x0 swapchains
if|if
condition|(
name|backbufferWidth
operator|<
literal|1
operator|||
name|backbufferHeight
operator|<
literal|1
condition|)
block|{
return|return
name|EGL_SUCCESS
return|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ANGLE_ENABLE_WINDOWS_STORE
argument_list|)
operator|||
operator|(
name|WINAPI_FAMILY
operator|!=
name|WINAPI_FAMILY_PHONE_APP
operator|)
comment|// Can only call resize if we have already created our swap buffer and resources
name|ASSERT
argument_list|(
name|mSwapChain
operator|&&
name|mBackBufferTexture
operator|&&
name|mBackBufferRTView
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mBackBufferTexture
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mBackBufferRTView
argument_list|)
expr_stmt|;
comment|// Resize swap chain
name|DXGI_SWAP_CHAIN_DESC
name|desc
decl_stmt|;
name|mSwapChain
operator|->
name|GetDesc
argument_list|(
operator|&
name|desc
argument_list|)
expr_stmt|;
specifier|const
name|d3d11
operator|::
name|TextureFormat
modifier|&
name|backbufferFormatInfo
init|=
name|d3d11
operator|::
name|GetTextureFormatInfo
argument_list|(
name|mBackBufferFormat
argument_list|,
name|mRenderer
operator|->
name|getFeatureLevel
argument_list|()
argument_list|)
decl_stmt|;
name|HRESULT
name|result
init|=
name|mSwapChain
operator|->
name|ResizeBuffers
argument_list|(
name|desc
operator|.
name|BufferCount
argument_list|,
name|backbufferWidth
argument_list|,
name|backbufferHeight
argument_list|,
name|backbufferFormatInfo
operator|.
name|texFormat
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Error resizing swap chain buffers: 0x%08X"
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|release
argument_list|()
expr_stmt|;
if|if
condition|(
name|d3d11
operator|::
name|isDeviceLostError
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|EGL_CONTEXT_LOST
return|;
block|}
else|else
block|{
return|return
name|EGL_BAD_ALLOC
return|;
block|}
block|}
name|result
operator|=
name|mSwapChain
operator|->
name|GetBuffer
argument_list|(
literal|0
argument_list|,
name|__uuidof
argument_list|(
name|ID3D11Texture2D
argument_list|)
argument_list|,
operator|(
name|LPVOID
operator|*
operator|)
operator|&
name|mBackBufferTexture
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mBackBufferTexture
argument_list|,
literal|"Back buffer texture"
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|device
operator|->
name|CreateRenderTargetView
argument_list|(
name|mBackBufferTexture
argument_list|,
name|NULL
argument_list|,
operator|&
name|mBackBufferRTView
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mBackBufferRTView
argument_list|,
literal|"Back buffer render target"
argument_list|)
expr_stmt|;
block|}
return|return
name|resetOffscreenTexture
argument_list|(
name|backbufferWidth
argument_list|,
name|backbufferHeight
argument_list|)
return|;
else|#
directive|else
comment|// Do nothing on Windows Phone apart from updating the internal buffer/width height
name|mWidth
operator|=
name|backbufferWidth
expr_stmt|;
name|mHeight
operator|=
name|backbufferHeight
expr_stmt|;
return|return
name|EGL_SUCCESS
return|;
endif|#
directive|endif
block|}
DECL|function|reset
name|EGLint
name|SwapChain11
operator|::
name|reset
parameter_list|(
name|int
name|backbufferWidth
parameter_list|,
name|int
name|backbufferHeight
parameter_list|,
name|EGLint
name|swapInterval
parameter_list|)
block|{
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
if|if
condition|(
name|device
operator|==
name|NULL
condition|)
block|{
return|return
name|EGL_BAD_ACCESS
return|;
block|}
comment|// Release specific resources to free up memory for the new render target, while the
comment|// old render target still exists for the purpose of preserving its contents.
name|SafeRelease
argument_list|(
name|mSwapChain
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mBackBufferTexture
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mBackBufferRTView
argument_list|)
expr_stmt|;
name|mSwapInterval
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|swapInterval
argument_list|)
expr_stmt|;
if|if
condition|(
name|mSwapInterval
operator|>
literal|4
condition|)
block|{
comment|// IDXGISwapChain::Present documentation states that valid sync intervals are in the [0,4] range
return|return
name|EGL_BAD_PARAMETER
return|;
block|}
comment|// EGL allows creating a surface with 0x0 dimension, however, DXGI does not like 0x0 swapchains
if|if
condition|(
name|backbufferWidth
operator|<
literal|1
operator|||
name|backbufferHeight
operator|<
literal|1
condition|)
block|{
name|releaseOffscreenTexture
argument_list|()
expr_stmt|;
return|return
name|EGL_SUCCESS
return|;
block|}
if|if
condition|(
name|mNativeWindow
operator|.
name|getNativeWindow
argument_list|()
condition|)
block|{
specifier|const
name|d3d11
operator|::
name|TextureFormat
modifier|&
name|backbufferFormatInfo
init|=
name|d3d11
operator|::
name|GetTextureFormatInfo
argument_list|(
name|mBackBufferFormat
argument_list|,
name|mRenderer
operator|->
name|getFeatureLevel
argument_list|()
argument_list|)
decl_stmt|;
name|HRESULT
name|result
init|=
name|mNativeWindow
operator|.
name|createSwapChain
argument_list|(
name|device
argument_list|,
name|mRenderer
operator|->
name|getDxgiFactory
argument_list|()
argument_list|,
name|backbufferFormatInfo
operator|.
name|texFormat
argument_list|,
name|backbufferWidth
argument_list|,
name|backbufferHeight
argument_list|,
operator|&
name|mSwapChain
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Could not create additional swap chains or offscreen surfaces: %08lX"
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|release
argument_list|()
expr_stmt|;
if|if
condition|(
name|d3d11
operator|::
name|isDeviceLostError
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|EGL_CONTEXT_LOST
return|;
block|}
else|else
block|{
return|return
name|EGL_BAD_ALLOC
return|;
block|}
block|}
name|result
operator|=
name|mSwapChain
operator|->
name|GetBuffer
argument_list|(
literal|0
argument_list|,
name|__uuidof
argument_list|(
name|ID3D11Texture2D
argument_list|)
argument_list|,
operator|(
name|LPVOID
operator|*
operator|)
operator|&
name|mBackBufferTexture
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mBackBufferTexture
argument_list|,
literal|"Back buffer texture"
argument_list|)
expr_stmt|;
name|result
operator|=
name|device
operator|->
name|CreateRenderTargetView
argument_list|(
name|mBackBufferTexture
argument_list|,
name|NULL
argument_list|,
operator|&
name|mBackBufferRTView
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mBackBufferRTView
argument_list|,
literal|"Back buffer render target"
argument_list|)
expr_stmt|;
block|}
comment|// If we are resizing the swap chain, we don't wish to recreate all the static resources
if|if
condition|(
operator|!
name|mPassThroughResourcesInit
condition|)
block|{
name|mPassThroughResourcesInit
operator|=
literal|true
expr_stmt|;
name|initPassThroughResources
argument_list|()
expr_stmt|;
block|}
return|return
name|resetOffscreenTexture
argument_list|(
name|backbufferWidth
argument_list|,
name|backbufferHeight
argument_list|)
return|;
block|}
DECL|function|initPassThroughResources
name|void
name|SwapChain11
operator|::
name|initPassThroughResources
parameter_list|()
block|{
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|device
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|// Make sure our resources are all not allocated, when we create
name|ASSERT
argument_list|(
name|mQuadVB
operator|==
name|NULL
operator|&&
name|mPassThroughSampler
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mPassThroughIL
operator|==
name|NULL
operator|&&
name|mPassThroughVS
operator|==
name|NULL
operator|&&
name|mPassThroughPS
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|D3D11_BUFFER_DESC
name|vbDesc
decl_stmt|;
name|vbDesc
operator|.
name|ByteWidth
operator|=
sizeof|sizeof
argument_list|(
name|d3d11
operator|::
name|PositionTexCoordVertex
argument_list|)
operator|*
literal|4
expr_stmt|;
name|vbDesc
operator|.
name|Usage
operator|=
name|D3D11_USAGE_DYNAMIC
expr_stmt|;
name|vbDesc
operator|.
name|BindFlags
operator|=
name|D3D11_BIND_VERTEX_BUFFER
expr_stmt|;
name|vbDesc
operator|.
name|CPUAccessFlags
operator|=
name|D3D11_CPU_ACCESS_WRITE
expr_stmt|;
name|vbDesc
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|vbDesc
operator|.
name|StructureByteStride
operator|=
literal|0
expr_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateBuffer
argument_list|(
operator|&
name|vbDesc
argument_list|,
name|NULL
argument_list|,
operator|&
name|mQuadVB
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mQuadVB
argument_list|,
literal|"Swap chain quad vertex buffer"
argument_list|)
expr_stmt|;
name|D3D11_SAMPLER_DESC
name|samplerDesc
decl_stmt|;
name|samplerDesc
operator|.
name|Filter
operator|=
name|D3D11_FILTER_MIN_MAG_MIP_POINT
expr_stmt|;
name|samplerDesc
operator|.
name|AddressU
operator|=
name|D3D11_TEXTURE_ADDRESS_CLAMP
expr_stmt|;
name|samplerDesc
operator|.
name|AddressV
operator|=
name|D3D11_TEXTURE_ADDRESS_CLAMP
expr_stmt|;
name|samplerDesc
operator|.
name|AddressW
operator|=
name|D3D11_TEXTURE_ADDRESS_CLAMP
expr_stmt|;
name|samplerDesc
operator|.
name|MipLODBias
operator|=
literal|0.0f
expr_stmt|;
name|samplerDesc
operator|.
name|MaxAnisotropy
operator|=
literal|0
expr_stmt|;
name|samplerDesc
operator|.
name|ComparisonFunc
operator|=
name|D3D11_COMPARISON_NEVER
expr_stmt|;
name|samplerDesc
operator|.
name|BorderColor
index|[
literal|0
index|]
operator|=
literal|0.0f
expr_stmt|;
name|samplerDesc
operator|.
name|BorderColor
index|[
literal|1
index|]
operator|=
literal|0.0f
expr_stmt|;
name|samplerDesc
operator|.
name|BorderColor
index|[
literal|2
index|]
operator|=
literal|0.0f
expr_stmt|;
name|samplerDesc
operator|.
name|BorderColor
index|[
literal|3
index|]
operator|=
literal|0.0f
expr_stmt|;
name|samplerDesc
operator|.
name|MinLOD
operator|=
literal|0
expr_stmt|;
name|samplerDesc
operator|.
name|MaxLOD
operator|=
name|D3D11_FLOAT32_MAX
expr_stmt|;
name|result
operator|=
name|device
operator|->
name|CreateSamplerState
argument_list|(
operator|&
name|samplerDesc
argument_list|,
operator|&
name|mPassThroughSampler
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mPassThroughSampler
argument_list|,
literal|"Swap chain pass through sampler"
argument_list|)
expr_stmt|;
name|D3D11_INPUT_ELEMENT_DESC
name|quadLayout
index|[]
init|=
block|{
block|{
literal|"POSITION"
block|,
literal|0
block|,
name|DXGI_FORMAT_R32G32_FLOAT
block|,
literal|0
block|,
literal|0
block|,
name|D3D11_INPUT_PER_VERTEX_DATA
block|,
literal|0
block|}
block|,
block|{
literal|"TEXCOORD"
block|,
literal|0
block|,
name|DXGI_FORMAT_R32G32_FLOAT
block|,
literal|0
block|,
literal|8
block|,
name|D3D11_INPUT_PER_VERTEX_DATA
block|,
literal|0
block|}
block|,     }
decl_stmt|;
name|result
operator|=
name|device
operator|->
name|CreateInputLayout
argument_list|(
name|quadLayout
argument_list|,
literal|2
argument_list|,
name|g_VS_Passthrough2D
argument_list|,
sizeof|sizeof
argument_list|(
name|g_VS_Passthrough2D
argument_list|)
argument_list|,
operator|&
name|mPassThroughIL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mPassThroughIL
argument_list|,
literal|"Swap chain pass through layout"
argument_list|)
expr_stmt|;
name|result
operator|=
name|device
operator|->
name|CreateVertexShader
argument_list|(
name|g_VS_Passthrough2D
argument_list|,
sizeof|sizeof
argument_list|(
name|g_VS_Passthrough2D
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|mPassThroughVS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mPassThroughVS
argument_list|,
literal|"Swap chain pass through vertex shader"
argument_list|)
expr_stmt|;
name|result
operator|=
name|device
operator|->
name|CreatePixelShader
argument_list|(
name|g_PS_PassthroughRGBA2D
argument_list|,
sizeof|sizeof
argument_list|(
name|g_PS_PassthroughRGBA2D
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|mPassThroughPS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mPassThroughPS
argument_list|,
literal|"Swap chain pass through pixel shader"
argument_list|)
expr_stmt|;
block|}
comment|// parameters should be validated/clamped by caller
DECL|function|swapRect
name|EGLint
name|SwapChain11
operator|::
name|swapRect
parameter_list|(
name|EGLint
name|x
parameter_list|,
name|EGLint
name|y
parameter_list|,
name|EGLint
name|width
parameter_list|,
name|EGLint
name|height
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mSwapChain
condition|)
block|{
return|return
name|EGL_SUCCESS
return|;
block|}
name|ID3D11Device
modifier|*
name|device
init|=
name|mRenderer
operator|->
name|getDevice
argument_list|()
decl_stmt|;
name|ID3D11DeviceContext
modifier|*
name|deviceContext
init|=
name|mRenderer
operator|->
name|getDeviceContext
argument_list|()
decl_stmt|;
comment|// Set vertices
name|D3D11_MAPPED_SUBRESOURCE
name|mappedResource
decl_stmt|;
name|HRESULT
name|result
init|=
name|deviceContext
operator|->
name|Map
argument_list|(
name|mQuadVB
argument_list|,
literal|0
argument_list|,
name|D3D11_MAP_WRITE_DISCARD
argument_list|,
literal|0
argument_list|,
operator|&
name|mappedResource
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|EGL_BAD_ACCESS
return|;
block|}
name|d3d11
operator|::
name|PositionTexCoordVertex
modifier|*
name|vertices
init|=
cast|static_cast
argument_list|<
name|d3d11
operator|::
name|PositionTexCoordVertex
operator|*
argument_list|>
argument_list|(
name|mappedResource
operator|.
name|pData
argument_list|)
decl_stmt|;
comment|// Create a quad in homogeneous coordinates
name|float
name|x1
init|=
operator|(
name|x
operator|/
name|float
argument_list|(
name|mWidth
argument_list|)
operator|)
operator|*
literal|2.0f
operator|-
literal|1.0f
decl_stmt|;
name|float
name|y1
init|=
operator|(
name|y
operator|/
name|float
argument_list|(
name|mHeight
argument_list|)
operator|)
operator|*
literal|2.0f
operator|-
literal|1.0f
decl_stmt|;
name|float
name|x2
init|=
operator|(
operator|(
name|x
operator|+
name|width
operator|)
operator|/
name|float
argument_list|(
name|mWidth
argument_list|)
operator|)
operator|*
literal|2.0f
operator|-
literal|1.0f
decl_stmt|;
name|float
name|y2
init|=
operator|(
operator|(
name|y
operator|+
name|height
operator|)
operator|/
name|float
argument_list|(
name|mHeight
argument_list|)
operator|)
operator|*
literal|2.0f
operator|-
literal|1.0f
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ANGLE_ENABLE_WINDOWS_STORE
argument_list|)
operator|&&
operator|(
name|WINAPI_FAMILY
operator|==
name|WINAPI_FAMILY_PHONE_APP
operator|)
specifier|const
name|float
name|dim
init|=
name|std
operator|::
name|max
argument_list|(
name|mWidth
argument_list|,
name|mHeight
argument_list|)
decl_stmt|;
name|float
name|u1
init|=
name|x
operator|/
name|dim
decl_stmt|;
name|float
name|v1
init|=
name|y
operator|/
name|dim
decl_stmt|;
name|float
name|u2
init|=
operator|(
name|x
operator|+
name|width
operator|)
operator|/
name|dim
decl_stmt|;
name|float
name|v2
init|=
operator|(
name|y
operator|+
name|height
operator|)
operator|/
name|dim
decl_stmt|;
specifier|const
name|NativeWindow
operator|::
name|RotationFlags
name|flags
init|=
name|mNativeWindow
operator|.
name|rotationFlags
argument_list|()
decl_stmt|;
specifier|const
name|bool
name|rotateL
init|=
name|flags
operator|==
name|NativeWindow
operator|::
name|RotateLeft
decl_stmt|;
specifier|const
name|bool
name|rotateR
init|=
name|flags
operator|==
name|NativeWindow
operator|::
name|RotateRight
decl_stmt|;
name|d3d11
operator|::
name|SetPositionTexCoordVertex
argument_list|(
operator|&
name|vertices
index|[
literal|0
index|]
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|rotateL
condition|?
name|u2
else|:
name|u1
argument_list|,
name|rotateR
condition|?
name|v2
else|:
name|v1
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetPositionTexCoordVertex
argument_list|(
operator|&
name|vertices
index|[
literal|1
index|]
argument_list|,
name|x1
argument_list|,
name|y2
argument_list|,
name|rotateR
condition|?
name|u2
else|:
name|u1
argument_list|,
name|rotateL
condition|?
name|v1
else|:
name|v2
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetPositionTexCoordVertex
argument_list|(
operator|&
name|vertices
index|[
literal|2
index|]
argument_list|,
name|x2
argument_list|,
name|y1
argument_list|,
name|rotateR
condition|?
name|u1
else|:
name|u2
argument_list|,
name|rotateL
condition|?
name|v2
else|:
name|v1
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetPositionTexCoordVertex
argument_list|(
operator|&
name|vertices
index|[
literal|3
index|]
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|rotateL
condition|?
name|u1
else|:
name|u2
argument_list|,
name|rotateR
condition|?
name|v1
else|:
name|v2
argument_list|)
expr_stmt|;
else|#
directive|else
name|float
name|u1
init|=
name|x
operator|/
name|float
argument_list|(
name|mWidth
argument_list|)
decl_stmt|;
name|float
name|v1
init|=
name|y
operator|/
name|float
argument_list|(
name|mHeight
argument_list|)
decl_stmt|;
name|float
name|u2
init|=
operator|(
name|x
operator|+
name|width
operator|)
operator|/
name|float
argument_list|(
name|mWidth
argument_list|)
decl_stmt|;
name|float
name|v2
init|=
operator|(
name|y
operator|+
name|height
operator|)
operator|/
name|float
argument_list|(
name|mHeight
argument_list|)
decl_stmt|;
name|d3d11
operator|::
name|SetPositionTexCoordVertex
argument_list|(
operator|&
name|vertices
index|[
literal|0
index|]
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|u1
argument_list|,
name|v1
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetPositionTexCoordVertex
argument_list|(
operator|&
name|vertices
index|[
literal|1
index|]
argument_list|,
name|x1
argument_list|,
name|y2
argument_list|,
name|u1
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetPositionTexCoordVertex
argument_list|(
operator|&
name|vertices
index|[
literal|2
index|]
argument_list|,
name|x2
argument_list|,
name|y1
argument_list|,
name|u2
argument_list|,
name|v1
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetPositionTexCoordVertex
argument_list|(
operator|&
name|vertices
index|[
literal|3
index|]
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|u2
argument_list|,
name|v2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|deviceContext
operator|->
name|Unmap
argument_list|(
name|mQuadVB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
specifier|static
name|UINT
name|stride
init|=
sizeof|sizeof
argument_list|(
name|d3d11
operator|::
name|PositionTexCoordVertex
argument_list|)
decl_stmt|;
specifier|static
name|UINT
name|startIdx
init|=
literal|0
decl_stmt|;
name|deviceContext
operator|->
name|IASetVertexBuffers
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|mQuadVB
argument_list|,
operator|&
name|stride
argument_list|,
operator|&
name|startIdx
argument_list|)
expr_stmt|;
comment|// Apply state
name|deviceContext
operator|->
name|OMSetDepthStencilState
argument_list|(
name|NULL
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
specifier|static
specifier|const
name|float
name|blendFactor
index|[
literal|4
index|]
init|=
block|{
literal|1.0f
block|,
literal|1.0f
block|,
literal|1.0f
block|,
literal|1.0f
block|}
decl_stmt|;
name|deviceContext
operator|->
name|OMSetBlendState
argument_list|(
name|NULL
argument_list|,
name|blendFactor
argument_list|,
literal|0xFFFFFFF
argument_list|)
expr_stmt|;
name|deviceContext
operator|->
name|RSSetState
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|// Apply shaders
name|deviceContext
operator|->
name|IASetInputLayout
argument_list|(
name|mPassThroughIL
argument_list|)
expr_stmt|;
name|deviceContext
operator|->
name|IASetPrimitiveTopology
argument_list|(
name|D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP
argument_list|)
expr_stmt|;
name|deviceContext
operator|->
name|VSSetShader
argument_list|(
name|mPassThroughVS
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|deviceContext
operator|->
name|PSSetShader
argument_list|(
name|mPassThroughPS
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|deviceContext
operator|->
name|GSSetShader
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Apply render targets
name|mRenderer
operator|->
name|setOneTimeRenderTarget
argument_list|(
name|mBackBufferRTView
argument_list|)
expr_stmt|;
comment|// Set the viewport
name|D3D11_VIEWPORT
name|viewport
decl_stmt|;
name|viewport
operator|.
name|TopLeftX
operator|=
literal|0
expr_stmt|;
name|viewport
operator|.
name|TopLeftY
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ANGLE_ENABLE_WINDOWS_STORE
argument_list|)
operator|&&
operator|(
name|WINAPI_FAMILY
operator|==
name|WINAPI_FAMILY_PHONE_APP
operator|)
name|viewport
operator|.
name|Width
operator|=
operator|(
name|rotateL
operator|||
name|rotateR
operator|)
condition|?
name|mHeight
else|:
name|mWidth
expr_stmt|;
name|viewport
operator|.
name|Height
operator|=
operator|(
name|rotateL
operator|||
name|rotateR
operator|)
condition|?
name|mWidth
else|:
name|mHeight
expr_stmt|;
else|#
directive|else
name|viewport
operator|.
name|Width
operator|=
name|mWidth
expr_stmt|;
name|viewport
operator|.
name|Height
operator|=
name|mHeight
expr_stmt|;
endif|#
directive|endif
name|viewport
operator|.
name|MinDepth
operator|=
literal|0.0f
expr_stmt|;
name|viewport
operator|.
name|MaxDepth
operator|=
literal|1.0f
expr_stmt|;
name|deviceContext
operator|->
name|RSSetViewports
argument_list|(
literal|1
argument_list|,
operator|&
name|viewport
argument_list|)
expr_stmt|;
comment|// Apply textures
name|mRenderer
operator|->
name|setShaderResource
argument_list|(
name|gl
operator|::
name|SAMPLER_PIXEL
argument_list|,
literal|0
argument_list|,
name|mOffscreenSRView
argument_list|)
expr_stmt|;
name|deviceContext
operator|->
name|PSSetSamplers
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|mPassThroughSampler
argument_list|)
expr_stmt|;
comment|// Draw
name|deviceContext
operator|->
name|Draw
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|ANGLE_VSYNC
operator|==
name|ANGLE_DISABLED
name|result
operator|=
name|mSwapChain
operator|->
name|Present
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|result
operator|=
name|mSwapChain
operator|->
name|Present
argument_list|(
name|mSwapInterval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|result
operator|==
name|DXGI_ERROR_DEVICE_REMOVED
condition|)
block|{
name|HRESULT
name|removedReason
init|=
name|device
operator|->
name|GetDeviceRemovedReason
argument_list|()
decl_stmt|;
name|UNUSED_TRACE_VARIABLE
argument_list|(
name|removedReason
argument_list|)
expr_stmt|;
name|ERR
argument_list|(
literal|"Present failed: the D3D11 device was removed: 0x%08X"
argument_list|,
name|removedReason
argument_list|)
expr_stmt|;
return|return
name|EGL_CONTEXT_LOST
return|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|DXGI_ERROR_DEVICE_RESET
condition|)
block|{
name|ERR
argument_list|(
literal|"Present failed: the D3D11 device was reset from a bad command."
argument_list|)
expr_stmt|;
return|return
name|EGL_CONTEXT_LOST
return|;
block|}
elseif|else
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Present failed with error code 0x%08X"
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
comment|// Unbind
name|mRenderer
operator|->
name|setShaderResource
argument_list|(
name|gl
operator|::
name|SAMPLER_PIXEL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mRenderer
operator|->
name|unapplyRenderTargets
argument_list|()
expr_stmt|;
name|mRenderer
operator|->
name|markAllStateDirty
argument_list|()
expr_stmt|;
return|return
name|EGL_SUCCESS
return|;
block|}
DECL|function|getOffscreenTexture
name|ID3D11Texture2D
modifier|*
name|SwapChain11
operator|::
name|getOffscreenTexture
parameter_list|()
block|{
return|return
name|mOffscreenTexture
return|;
block|}
DECL|function|getRenderTarget
name|ID3D11RenderTargetView
modifier|*
name|SwapChain11
operator|::
name|getRenderTarget
parameter_list|()
block|{
return|return
name|mOffscreenRTView
return|;
block|}
DECL|function|getRenderTargetShaderResource
name|ID3D11ShaderResourceView
modifier|*
name|SwapChain11
operator|::
name|getRenderTargetShaderResource
parameter_list|()
block|{
return|return
name|mOffscreenSRView
return|;
block|}
DECL|function|getDepthStencil
name|ID3D11DepthStencilView
modifier|*
name|SwapChain11
operator|::
name|getDepthStencil
parameter_list|()
block|{
return|return
name|mDepthStencilDSView
return|;
block|}
DECL|function|getDepthStencilShaderResource
name|ID3D11ShaderResourceView
modifier|*
name|SwapChain11
operator|::
name|getDepthStencilShaderResource
parameter_list|()
block|{
return|return
name|mDepthStencilSRView
return|;
block|}
DECL|function|getDepthStencilTexture
name|ID3D11Texture2D
modifier|*
name|SwapChain11
operator|::
name|getDepthStencilTexture
parameter_list|()
block|{
return|return
name|mDepthStencilTexture
return|;
block|}
DECL|function|makeSwapChain11
name|SwapChain11
modifier|*
name|SwapChain11
operator|::
name|makeSwapChain11
parameter_list|(
name|SwapChainD3D
modifier|*
name|swapChain
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|HAS_DYNAMIC_TYPE
argument_list|(
name|SwapChain11
operator|*
argument_list|,
name|swapChain
argument_list|)
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|SwapChain11
operator|*
argument_list|>
argument_list|(
name|swapChain
argument_list|)
return|;
block|}
DECL|function|recreate
name|void
name|SwapChain11
operator|::
name|recreate
parameter_list|()
block|{
comment|// possibly should use this method instead of reset
block|}
DECL|function|getDevice
name|void
modifier|*
name|rx
operator|::
name|SwapChain11
operator|::
name|getDevice
parameter_list|()
block|{
return|return
name|mRenderer
operator|->
name|getDevice
argument_list|()
return|;
block|}
block|}
end_namespace
end_unit
