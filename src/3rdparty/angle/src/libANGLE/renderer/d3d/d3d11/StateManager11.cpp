begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2015 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// StateManager11.cpp: Defines a class for caching D3D11 state
end_comment
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/StateManager11.h"
end_include
begin_include
include|#
directive|include
file|"common/BitSetIterator.h"
end_include
begin_include
include|#
directive|include
file|"common/utilities.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/Framebuffer11.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/Renderer11.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/RenderTarget11.h"
end_include
begin_namespace
DECL|namespace|rx
namespace|namespace
name|rx
block|{
namespace|namespace
block|{
DECL|function|ImageIndexConflictsWithSRV
name|bool
name|ImageIndexConflictsWithSRV
parameter_list|(
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|,
name|D3D11_SHADER_RESOURCE_VIEW_DESC
name|desc
parameter_list|)
block|{
name|unsigned
name|mipLevel
init|=
name|index
operator|.
name|mipIndex
decl_stmt|;
name|unsigned
name|layerIndex
init|=
name|index
operator|.
name|layerIndex
decl_stmt|;
name|GLenum
name|type
init|=
name|index
operator|.
name|type
decl_stmt|;
switch|switch
condition|(
name|desc
operator|.
name|ViewDimension
condition|)
block|{
case|case
name|D3D11_SRV_DIMENSION_TEXTURE2D
case|:
block|{
name|unsigned
name|maxSrvMip
init|=
name|desc
operator|.
name|Texture2D
operator|.
name|MipLevels
operator|+
name|desc
operator|.
name|Texture2D
operator|.
name|MostDetailedMip
decl_stmt|;
name|maxSrvMip
operator|=
operator|(
name|desc
operator|.
name|Texture2D
operator|.
name|MipLevels
operator|==
operator|-
literal|1
operator|)
condition|?
name|INT_MAX
else|:
name|maxSrvMip
expr_stmt|;
name|unsigned
name|mipMin
init|=
name|index
operator|.
name|mipIndex
decl_stmt|;
name|unsigned
name|mipMax
init|=
operator|(
name|layerIndex
operator|==
operator|-
literal|1
operator|)
condition|?
name|INT_MAX
else|:
name|layerIndex
decl_stmt|;
return|return
name|type
operator|==
name|GL_TEXTURE_2D
operator|&&
name|gl
operator|::
name|RangeUI
argument_list|(
name|mipMin
argument_list|,
name|mipMax
argument_list|)
operator|.
name|intersects
argument_list|(
name|gl
operator|::
name|RangeUI
argument_list|(
name|desc
operator|.
name|Texture2D
operator|.
name|MostDetailedMip
argument_list|,
name|maxSrvMip
argument_list|)
argument_list|)
return|;
block|}
case|case
name|D3D11_SRV_DIMENSION_TEXTURE2DARRAY
case|:
block|{
name|unsigned
name|maxSrvMip
init|=
name|desc
operator|.
name|Texture2DArray
operator|.
name|MipLevels
operator|+
name|desc
operator|.
name|Texture2DArray
operator|.
name|MostDetailedMip
decl_stmt|;
name|maxSrvMip
operator|=
operator|(
name|desc
operator|.
name|Texture2DArray
operator|.
name|MipLevels
operator|==
operator|-
literal|1
operator|)
condition|?
name|INT_MAX
else|:
name|maxSrvMip
expr_stmt|;
name|unsigned
name|maxSlice
init|=
name|desc
operator|.
name|Texture2DArray
operator|.
name|FirstArraySlice
operator|+
name|desc
operator|.
name|Texture2DArray
operator|.
name|ArraySize
decl_stmt|;
comment|// Cube maps can be mapped to Texture2DArray SRVs
return|return
operator|(
name|type
operator|==
name|GL_TEXTURE_2D_ARRAY
operator|||
name|gl
operator|::
name|IsCubeMapTextureTarget
argument_list|(
name|type
argument_list|)
operator|)
operator|&&
name|desc
operator|.
name|Texture2DArray
operator|.
name|MostDetailedMip
operator|<=
name|mipLevel
operator|&&
name|mipLevel
operator|<
name|maxSrvMip
operator|&&
name|desc
operator|.
name|Texture2DArray
operator|.
name|FirstArraySlice
operator|<=
name|layerIndex
operator|&&
name|layerIndex
operator|<
name|maxSlice
return|;
block|}
case|case
name|D3D11_SRV_DIMENSION_TEXTURECUBE
case|:
block|{
name|unsigned
name|maxSrvMip
init|=
name|desc
operator|.
name|TextureCube
operator|.
name|MipLevels
operator|+
name|desc
operator|.
name|TextureCube
operator|.
name|MostDetailedMip
decl_stmt|;
name|maxSrvMip
operator|=
operator|(
name|desc
operator|.
name|TextureCube
operator|.
name|MipLevels
operator|==
operator|-
literal|1
operator|)
condition|?
name|INT_MAX
else|:
name|maxSrvMip
expr_stmt|;
return|return
name|gl
operator|::
name|IsCubeMapTextureTarget
argument_list|(
name|type
argument_list|)
operator|&&
name|desc
operator|.
name|TextureCube
operator|.
name|MostDetailedMip
operator|<=
name|mipLevel
operator|&&
name|mipLevel
operator|<
name|maxSrvMip
return|;
block|}
case|case
name|D3D11_SRV_DIMENSION_TEXTURE3D
case|:
block|{
name|unsigned
name|maxSrvMip
init|=
name|desc
operator|.
name|Texture3D
operator|.
name|MipLevels
operator|+
name|desc
operator|.
name|Texture3D
operator|.
name|MostDetailedMip
decl_stmt|;
name|maxSrvMip
operator|=
operator|(
name|desc
operator|.
name|Texture3D
operator|.
name|MipLevels
operator|==
operator|-
literal|1
operator|)
condition|?
name|INT_MAX
else|:
name|maxSrvMip
expr_stmt|;
return|return
name|type
operator|==
name|GL_TEXTURE_3D
operator|&&
name|desc
operator|.
name|Texture3D
operator|.
name|MostDetailedMip
operator|<=
name|mipLevel
operator|&&
name|mipLevel
operator|<
name|maxSrvMip
return|;
block|}
default|default:
comment|// We only handle the cases corresponding to valid image indexes
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|// Does *not* increment the resource ref count!!
DECL|function|GetViewResource
name|ID3D11Resource
modifier|*
name|GetViewResource
parameter_list|(
name|ID3D11View
modifier|*
name|view
parameter_list|)
block|{
name|ID3D11Resource
modifier|*
name|resource
init|=
name|NULL
decl_stmt|;
name|ASSERT
argument_list|(
name|view
argument_list|)
expr_stmt|;
name|view
operator|->
name|GetResource
argument_list|(
operator|&
name|resource
argument_list|)
expr_stmt|;
name|resource
operator|->
name|Release
argument_list|()
expr_stmt|;
return|return
name|resource
return|;
block|}
block|}
comment|// anonymous namespace
DECL|function|update
name|void
name|StateManager11
operator|::
name|SRVCache
operator|::
name|update
parameter_list|(
name|size_t
name|resourceIndex
parameter_list|,
name|ID3D11ShaderResourceView
modifier|*
name|srv
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|resourceIndex
operator|<
name|mCurrentSRVs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|SRVRecord
modifier|*
name|record
init|=
operator|&
name|mCurrentSRVs
index|[
name|resourceIndex
index|]
decl_stmt|;
name|record
operator|->
name|srv
operator|=
cast|reinterpret_cast
argument_list|<
name|uintptr_t
argument_list|>
argument_list|(
name|srv
argument_list|)
expr_stmt|;
if|if
condition|(
name|srv
condition|)
block|{
name|record
operator|->
name|resource
operator|=
cast|reinterpret_cast
argument_list|<
name|uintptr_t
argument_list|>
argument_list|(
name|GetViewResource
argument_list|(
name|srv
argument_list|)
argument_list|)
expr_stmt|;
name|srv
operator|->
name|GetDesc
argument_list|(
operator|&
name|record
operator|->
name|desc
argument_list|)
expr_stmt|;
name|mHighestUsedSRV
operator|=
name|std
operator|::
name|max
argument_list|(
name|resourceIndex
operator|+
literal|1
argument_list|,
name|mHighestUsedSRV
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|record
operator|->
name|resource
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|resourceIndex
operator|+
literal|1
operator|==
name|mHighestUsedSRV
condition|)
block|{
do|do
block|{
operator|--
name|mHighestUsedSRV
expr_stmt|;
block|}
do|while
condition|(
name|mHighestUsedSRV
operator|>
literal|0
operator|&&
name|mCurrentSRVs
index|[
name|mHighestUsedSRV
index|]
operator|.
name|srv
operator|==
literal|0
condition|)
do|;
block|}
block|}
block|}
DECL|function|clear
name|void
name|StateManager11
operator|::
name|SRVCache
operator|::
name|clear
parameter_list|()
block|{
if|if
condition|(
name|mCurrentSRVs
operator|.
name|empty
argument_list|()
condition|)
block|{
return|return;
block|}
name|memset
argument_list|(
operator|&
name|mCurrentSRVs
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|SRVRecord
argument_list|)
operator|*
name|mCurrentSRVs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|mHighestUsedSRV
operator|=
literal|0
expr_stmt|;
block|}
DECL|function|StateManager11
name|StateManager11
operator|::
name|StateManager11
parameter_list|(
name|Renderer11
modifier|*
name|renderer
parameter_list|)
member_init_list|:
name|mRenderer
argument_list|(
name|renderer
argument_list|)
member_init_list|,
name|mBlendStateIsDirty
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mCurBlendColor
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
member_init_list|,
name|mCurSampleMask
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mDepthStencilStateIsDirty
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mCurStencilRef
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mCurStencilBackRef
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mCurStencilSize
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mRasterizerStateIsDirty
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mScissorStateIsDirty
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mCurScissorEnabled
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mCurScissorRect
argument_list|()
member_init_list|,
name|mViewportStateIsDirty
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mCurViewport
argument_list|()
member_init_list|,
name|mCurNear
argument_list|(
literal|0.0f
argument_list|)
member_init_list|,
name|mCurFar
argument_list|(
literal|0.0f
argument_list|)
member_init_list|,
name|mViewportBounds
argument_list|()
member_init_list|,
name|mCurPresentPathFastEnabled
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mCurPresentPathFastColorBufferHeight
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mAppliedDSV
argument_list|(
name|angle
operator|::
name|DirtyPointer
argument_list|)
block|{
name|mCurBlendState
operator|.
name|blend
operator|=
literal|false
expr_stmt|;
name|mCurBlendState
operator|.
name|sourceBlendRGB
operator|=
name|GL_ONE
expr_stmt|;
name|mCurBlendState
operator|.
name|destBlendRGB
operator|=
name|GL_ZERO
expr_stmt|;
name|mCurBlendState
operator|.
name|sourceBlendAlpha
operator|=
name|GL_ONE
expr_stmt|;
name|mCurBlendState
operator|.
name|destBlendAlpha
operator|=
name|GL_ZERO
expr_stmt|;
name|mCurBlendState
operator|.
name|blendEquationRGB
operator|=
name|GL_FUNC_ADD
expr_stmt|;
name|mCurBlendState
operator|.
name|blendEquationAlpha
operator|=
name|GL_FUNC_ADD
expr_stmt|;
name|mCurBlendState
operator|.
name|colorMaskRed
operator|=
literal|true
expr_stmt|;
name|mCurBlendState
operator|.
name|colorMaskBlue
operator|=
literal|true
expr_stmt|;
name|mCurBlendState
operator|.
name|colorMaskGreen
operator|=
literal|true
expr_stmt|;
name|mCurBlendState
operator|.
name|colorMaskAlpha
operator|=
literal|true
expr_stmt|;
name|mCurBlendState
operator|.
name|sampleAlphaToCoverage
operator|=
literal|false
expr_stmt|;
name|mCurBlendState
operator|.
name|dither
operator|=
literal|false
expr_stmt|;
name|mCurDepthStencilState
operator|.
name|depthTest
operator|=
literal|false
expr_stmt|;
name|mCurDepthStencilState
operator|.
name|depthFunc
operator|=
name|GL_LESS
expr_stmt|;
name|mCurDepthStencilState
operator|.
name|depthMask
operator|=
literal|true
expr_stmt|;
name|mCurDepthStencilState
operator|.
name|stencilTest
operator|=
literal|false
expr_stmt|;
name|mCurDepthStencilState
operator|.
name|stencilMask
operator|=
literal|true
expr_stmt|;
name|mCurDepthStencilState
operator|.
name|stencilFail
operator|=
name|GL_KEEP
expr_stmt|;
name|mCurDepthStencilState
operator|.
name|stencilPassDepthFail
operator|=
name|GL_KEEP
expr_stmt|;
name|mCurDepthStencilState
operator|.
name|stencilPassDepthPass
operator|=
name|GL_KEEP
expr_stmt|;
name|mCurDepthStencilState
operator|.
name|stencilWritemask
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mCurDepthStencilState
operator|.
name|stencilBackFunc
operator|=
name|GL_ALWAYS
expr_stmt|;
name|mCurDepthStencilState
operator|.
name|stencilBackMask
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mCurDepthStencilState
operator|.
name|stencilBackFail
operator|=
name|GL_KEEP
expr_stmt|;
name|mCurDepthStencilState
operator|.
name|stencilBackPassDepthFail
operator|=
name|GL_KEEP
expr_stmt|;
name|mCurDepthStencilState
operator|.
name|stencilBackPassDepthPass
operator|=
name|GL_KEEP
expr_stmt|;
name|mCurDepthStencilState
operator|.
name|stencilBackWritemask
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mCurRasterState
operator|.
name|rasterizerDiscard
operator|=
literal|false
expr_stmt|;
name|mCurRasterState
operator|.
name|cullFace
operator|=
literal|false
expr_stmt|;
name|mCurRasterState
operator|.
name|cullMode
operator|=
name|GL_BACK
expr_stmt|;
name|mCurRasterState
operator|.
name|frontFace
operator|=
name|GL_CCW
expr_stmt|;
name|mCurRasterState
operator|.
name|polygonOffsetFill
operator|=
literal|false
expr_stmt|;
name|mCurRasterState
operator|.
name|polygonOffsetFactor
operator|=
literal|0.0f
expr_stmt|;
name|mCurRasterState
operator|.
name|polygonOffsetUnits
operator|=
literal|0.0f
expr_stmt|;
name|mCurRasterState
operator|.
name|pointDrawMode
operator|=
literal|false
expr_stmt|;
name|mCurRasterState
operator|.
name|multiSample
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|~StateManager11
name|StateManager11
operator|::
name|~
name|StateManager11
parameter_list|()
block|{ }
DECL|function|updateStencilSizeIfChanged
name|void
name|StateManager11
operator|::
name|updateStencilSizeIfChanged
parameter_list|(
name|bool
name|depthStencilInitialized
parameter_list|,
name|unsigned
name|int
name|stencilSize
parameter_list|)
block|{
if|if
condition|(
operator|!
name|depthStencilInitialized
operator|||
name|stencilSize
operator|!=
name|mCurStencilSize
condition|)
block|{
name|mCurStencilSize
operator|=
name|stencilSize
expr_stmt|;
name|mDepthStencilStateIsDirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|setViewportBounds
name|void
name|StateManager11
operator|::
name|setViewportBounds
parameter_list|(
specifier|const
name|int
name|width
parameter_list|,
specifier|const
name|int
name|height
parameter_list|)
block|{
if|if
condition|(
name|mRenderer
operator|->
name|getRenderer11DeviceCaps
argument_list|()
operator|.
name|featureLevel
operator|<=
name|D3D_FEATURE_LEVEL_9_3
operator|&&
operator|(
name|mViewportBounds
operator|.
name|width
operator|!=
name|width
operator|||
name|mViewportBounds
operator|.
name|height
operator|!=
name|height
operator|)
condition|)
block|{
name|mViewportBounds
operator|=
name|gl
operator|::
name|Extents
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mViewportStateIsDirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|updatePresentPath
name|void
name|StateManager11
operator|::
name|updatePresentPath
parameter_list|(
name|bool
name|presentPathFastActive
parameter_list|,
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|framebufferAttachment
parameter_list|)
block|{
specifier|const
name|int
name|colorBufferHeight
init|=
name|framebufferAttachment
condition|?
name|framebufferAttachment
operator|->
name|getSize
argument_list|()
operator|.
name|height
else|:
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|mCurPresentPathFastEnabled
operator|!=
name|presentPathFastActive
operator|)
operator|||
operator|(
name|presentPathFastActive
operator|&&
operator|(
name|colorBufferHeight
operator|!=
name|mCurPresentPathFastColorBufferHeight
operator|)
operator|)
condition|)
block|{
name|mCurPresentPathFastEnabled
operator|=
name|presentPathFastActive
expr_stmt|;
name|mCurPresentPathFastColorBufferHeight
operator|=
name|colorBufferHeight
expr_stmt|;
name|mViewportStateIsDirty
operator|=
literal|true
expr_stmt|;
comment|// Viewport may need to be vertically inverted
name|mScissorStateIsDirty
operator|=
literal|true
expr_stmt|;
comment|// Scissor rect may need to be vertically inverted
name|mRasterizerStateIsDirty
operator|=
literal|true
expr_stmt|;
comment|// Cull Mode may need to be inverted
block|}
block|}
DECL|function|syncState
name|void
name|StateManager11
operator|::
name|syncState
parameter_list|(
specifier|const
name|gl
operator|::
name|State
modifier|&
name|state
parameter_list|,
specifier|const
name|gl
operator|::
name|State
operator|::
name|DirtyBits
modifier|&
name|dirtyBits
parameter_list|)
block|{
if|if
condition|(
operator|!
name|dirtyBits
operator|.
name|any
argument_list|()
condition|)
block|{
return|return;
block|}
for|for
control|(
name|unsigned
name|int
name|dirtyBit
range|:
name|angle
operator|::
name|IterateBitSet
argument_list|(
name|dirtyBits
argument_list|)
control|)
block|{
switch|switch
condition|(
name|dirtyBit
condition|)
block|{
case|case
name|gl
operator|::
name|State
operator|::
name|DIRTY_BIT_BLEND_EQUATIONS
case|:
block|{
specifier|const
name|gl
operator|::
name|BlendState
modifier|&
name|blendState
init|=
name|state
operator|.
name|getBlendState
argument_list|()
decl_stmt|;
if|if
condition|(
name|blendState
operator|.
name|blendEquationRGB
operator|!=
name|mCurBlendState
operator|.
name|blendEquationRGB
operator|||
name|blendState
operator|.
name|blendEquationAlpha
operator|!=
name|mCurBlendState
operator|.
name|blendEquationAlpha
condition|)
block|{
name|mBlendStateIsDirty
operator|=
literal|true
expr_stmt|;
block|}
break|break;
block|}
case|case
name|gl
operator|::
name|State
operator|::
name|DIRTY_BIT_BLEND_FUNCS
case|:
block|{
specifier|const
name|gl
operator|::
name|BlendState
modifier|&
name|blendState
init|=
name|state
operator|.
name|getBlendState
argument_list|()
decl_stmt|;
if|if
condition|(
name|blendState
operator|.
name|sourceBlendRGB
operator|!=
name|mCurBlendState
operator|.
name|sourceBlendRGB
operator|||
name|blendState
operator|.
name|destBlendRGB
operator|!=
name|mCurBlendState
operator|.
name|destBlendRGB
operator|||
name|blendState
operator|.
name|sourceBlendAlpha
operator|!=
name|mCurBlendState
operator|.
name|sourceBlendAlpha
operator|||
name|blendState
operator|.
name|destBlendAlpha
operator|!=
name|mCurBlendState
operator|.
name|destBlendAlpha
condition|)
block|{
name|mBlendStateIsDirty
operator|=
literal|true
expr_stmt|;
block|}
break|break;
block|}
case|case
name|gl
operator|::
name|State
operator|::
name|DIRTY_BIT_BLEND_ENABLED
case|:
if|if
condition|(
name|state
operator|.
name|getBlendState
argument_list|()
operator|.
name|blend
operator|!=
name|mCurBlendState
operator|.
name|blend
condition|)
block|{
name|mBlendStateIsDirty
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|gl
operator|::
name|State
operator|::
name|DIRTY_BIT_SAMPLE_ALPHA_TO_COVERAGE_ENABLED
case|:
if|if
condition|(
name|state
operator|.
name|getBlendState
argument_list|()
operator|.
name|sampleAlphaToCoverage
operator|!=
name|mCurBlendState
operator|.
name|sampleAlphaToCoverage
condition|)
block|{
name|mBlendStateIsDirty
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|gl
operator|::
name|State
operator|::
name|DIRTY_BIT_DITHER_ENABLED
case|:
if|if
condition|(
name|state
operator|.
name|getBlendState
argument_list|()
operator|.
name|dither
operator|!=
name|mCurBlendState
operator|.
name|dither
condition|)
block|{
name|mBlendStateIsDirty
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|gl
operator|::
name|State
operator|::
name|DIRTY_BIT_COLOR_MASK
case|:
block|{
specifier|const
name|gl
operator|::
name|BlendState
modifier|&
name|blendState
init|=
name|state
operator|.
name|getBlendState
argument_list|()
decl_stmt|;
if|if
condition|(
name|blendState
operator|.
name|colorMaskRed
operator|!=
name|mCurBlendState
operator|.
name|colorMaskRed
operator|||
name|blendState
operator|.
name|colorMaskGreen
operator|!=
name|mCurBlendState
operator|.
name|colorMaskGreen
operator|||
name|blendState
operator|.
name|colorMaskBlue
operator|!=
name|mCurBlendState
operator|.
name|colorMaskBlue
operator|||
name|blendState
operator|.
name|colorMaskAlpha
operator|!=
name|mCurBlendState
operator|.
name|colorMaskAlpha
condition|)
block|{
name|mBlendStateIsDirty
operator|=
literal|true
expr_stmt|;
block|}
break|break;
block|}
case|case
name|gl
operator|::
name|State
operator|::
name|DIRTY_BIT_BLEND_COLOR
case|:
if|if
condition|(
name|state
operator|.
name|getBlendColor
argument_list|()
operator|!=
name|mCurBlendColor
condition|)
block|{
name|mBlendStateIsDirty
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|gl
operator|::
name|State
operator|::
name|DIRTY_BIT_DEPTH_MASK
case|:
if|if
condition|(
name|state
operator|.
name|getDepthStencilState
argument_list|()
operator|.
name|depthMask
operator|!=
name|mCurDepthStencilState
operator|.
name|depthMask
condition|)
block|{
name|mDepthStencilStateIsDirty
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|gl
operator|::
name|State
operator|::
name|DIRTY_BIT_DEPTH_TEST_ENABLED
case|:
if|if
condition|(
name|state
operator|.
name|getDepthStencilState
argument_list|()
operator|.
name|depthTest
operator|!=
name|mCurDepthStencilState
operator|.
name|depthTest
condition|)
block|{
name|mDepthStencilStateIsDirty
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|gl
operator|::
name|State
operator|::
name|DIRTY_BIT_DEPTH_FUNC
case|:
if|if
condition|(
name|state
operator|.
name|getDepthStencilState
argument_list|()
operator|.
name|depthFunc
operator|!=
name|mCurDepthStencilState
operator|.
name|depthFunc
condition|)
block|{
name|mDepthStencilStateIsDirty
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|gl
operator|::
name|State
operator|::
name|DIRTY_BIT_STENCIL_TEST_ENABLED
case|:
if|if
condition|(
name|state
operator|.
name|getDepthStencilState
argument_list|()
operator|.
name|stencilTest
operator|!=
name|mCurDepthStencilState
operator|.
name|stencilTest
condition|)
block|{
name|mDepthStencilStateIsDirty
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|gl
operator|::
name|State
operator|::
name|DIRTY_BIT_STENCIL_FUNCS_FRONT
case|:
block|{
specifier|const
name|gl
operator|::
name|DepthStencilState
modifier|&
name|depthStencil
init|=
name|state
operator|.
name|getDepthStencilState
argument_list|()
decl_stmt|;
if|if
condition|(
name|depthStencil
operator|.
name|stencilFunc
operator|!=
name|mCurDepthStencilState
operator|.
name|stencilFunc
operator|||
name|depthStencil
operator|.
name|stencilMask
operator|!=
name|mCurDepthStencilState
operator|.
name|stencilMask
operator|||
name|state
operator|.
name|getStencilRef
argument_list|()
operator|!=
name|mCurStencilRef
condition|)
block|{
name|mDepthStencilStateIsDirty
operator|=
literal|true
expr_stmt|;
block|}
break|break;
block|}
case|case
name|gl
operator|::
name|State
operator|::
name|DIRTY_BIT_STENCIL_FUNCS_BACK
case|:
block|{
specifier|const
name|gl
operator|::
name|DepthStencilState
modifier|&
name|depthStencil
init|=
name|state
operator|.
name|getDepthStencilState
argument_list|()
decl_stmt|;
if|if
condition|(
name|depthStencil
operator|.
name|stencilBackFunc
operator|!=
name|mCurDepthStencilState
operator|.
name|stencilBackFunc
operator|||
name|depthStencil
operator|.
name|stencilBackMask
operator|!=
name|mCurDepthStencilState
operator|.
name|stencilBackMask
operator|||
name|state
operator|.
name|getStencilBackRef
argument_list|()
operator|!=
name|mCurStencilBackRef
condition|)
block|{
name|mDepthStencilStateIsDirty
operator|=
literal|true
expr_stmt|;
block|}
break|break;
block|}
case|case
name|gl
operator|::
name|State
operator|::
name|DIRTY_BIT_STENCIL_WRITEMASK_FRONT
case|:
if|if
condition|(
name|state
operator|.
name|getDepthStencilState
argument_list|()
operator|.
name|stencilWritemask
operator|!=
name|mCurDepthStencilState
operator|.
name|stencilWritemask
condition|)
block|{
name|mDepthStencilStateIsDirty
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|gl
operator|::
name|State
operator|::
name|DIRTY_BIT_STENCIL_WRITEMASK_BACK
case|:
if|if
condition|(
name|state
operator|.
name|getDepthStencilState
argument_list|()
operator|.
name|stencilBackWritemask
operator|!=
name|mCurDepthStencilState
operator|.
name|stencilBackWritemask
condition|)
block|{
name|mDepthStencilStateIsDirty
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|gl
operator|::
name|State
operator|::
name|DIRTY_BIT_STENCIL_OPS_FRONT
case|:
block|{
specifier|const
name|gl
operator|::
name|DepthStencilState
modifier|&
name|depthStencil
init|=
name|state
operator|.
name|getDepthStencilState
argument_list|()
decl_stmt|;
if|if
condition|(
name|depthStencil
operator|.
name|stencilFail
operator|!=
name|mCurDepthStencilState
operator|.
name|stencilFail
operator|||
name|depthStencil
operator|.
name|stencilPassDepthFail
operator|!=
name|mCurDepthStencilState
operator|.
name|stencilPassDepthFail
operator|||
name|depthStencil
operator|.
name|stencilPassDepthPass
operator|!=
name|mCurDepthStencilState
operator|.
name|stencilPassDepthPass
condition|)
block|{
name|mDepthStencilStateIsDirty
operator|=
literal|true
expr_stmt|;
block|}
break|break;
block|}
case|case
name|gl
operator|::
name|State
operator|::
name|DIRTY_BIT_STENCIL_OPS_BACK
case|:
block|{
specifier|const
name|gl
operator|::
name|DepthStencilState
modifier|&
name|depthStencil
init|=
name|state
operator|.
name|getDepthStencilState
argument_list|()
decl_stmt|;
if|if
condition|(
name|depthStencil
operator|.
name|stencilBackFail
operator|!=
name|mCurDepthStencilState
operator|.
name|stencilBackFail
operator|||
name|depthStencil
operator|.
name|stencilBackPassDepthFail
operator|!=
name|mCurDepthStencilState
operator|.
name|stencilBackPassDepthFail
operator|||
name|depthStencil
operator|.
name|stencilBackPassDepthPass
operator|!=
name|mCurDepthStencilState
operator|.
name|stencilBackPassDepthPass
condition|)
block|{
name|mDepthStencilStateIsDirty
operator|=
literal|true
expr_stmt|;
block|}
break|break;
block|}
case|case
name|gl
operator|::
name|State
operator|::
name|DIRTY_BIT_CULL_FACE_ENABLED
case|:
if|if
condition|(
name|state
operator|.
name|getRasterizerState
argument_list|()
operator|.
name|cullFace
operator|!=
name|mCurRasterState
operator|.
name|cullFace
condition|)
block|{
name|mRasterizerStateIsDirty
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|gl
operator|::
name|State
operator|::
name|DIRTY_BIT_CULL_FACE
case|:
if|if
condition|(
name|state
operator|.
name|getRasterizerState
argument_list|()
operator|.
name|cullMode
operator|!=
name|mCurRasterState
operator|.
name|cullMode
condition|)
block|{
name|mRasterizerStateIsDirty
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|gl
operator|::
name|State
operator|::
name|DIRTY_BIT_FRONT_FACE
case|:
if|if
condition|(
name|state
operator|.
name|getRasterizerState
argument_list|()
operator|.
name|frontFace
operator|!=
name|mCurRasterState
operator|.
name|frontFace
condition|)
block|{
name|mRasterizerStateIsDirty
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|gl
operator|::
name|State
operator|::
name|DIRTY_BIT_POLYGON_OFFSET_FILL_ENABLED
case|:
if|if
condition|(
name|state
operator|.
name|getRasterizerState
argument_list|()
operator|.
name|polygonOffsetFill
operator|!=
name|mCurRasterState
operator|.
name|polygonOffsetFill
condition|)
block|{
name|mRasterizerStateIsDirty
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|gl
operator|::
name|State
operator|::
name|DIRTY_BIT_POLYGON_OFFSET
case|:
block|{
specifier|const
name|gl
operator|::
name|RasterizerState
modifier|&
name|rasterState
init|=
name|state
operator|.
name|getRasterizerState
argument_list|()
decl_stmt|;
if|if
condition|(
name|rasterState
operator|.
name|polygonOffsetFactor
operator|!=
name|mCurRasterState
operator|.
name|polygonOffsetFactor
operator|||
name|rasterState
operator|.
name|polygonOffsetUnits
operator|!=
name|mCurRasterState
operator|.
name|polygonOffsetUnits
condition|)
block|{
name|mRasterizerStateIsDirty
operator|=
literal|true
expr_stmt|;
block|}
break|break;
block|}
case|case
name|gl
operator|::
name|State
operator|::
name|DIRTY_BIT_RASTERIZER_DISCARD_ENABLED
case|:
if|if
condition|(
name|state
operator|.
name|getRasterizerState
argument_list|()
operator|.
name|rasterizerDiscard
operator|!=
name|mCurRasterState
operator|.
name|rasterizerDiscard
condition|)
block|{
name|mRasterizerStateIsDirty
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|gl
operator|::
name|State
operator|::
name|DIRTY_BIT_SCISSOR
case|:
if|if
condition|(
name|state
operator|.
name|getScissor
argument_list|()
operator|!=
name|mCurScissorRect
condition|)
block|{
name|mScissorStateIsDirty
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|gl
operator|::
name|State
operator|::
name|DIRTY_BIT_SCISSOR_TEST_ENABLED
case|:
if|if
condition|(
name|state
operator|.
name|isScissorTestEnabled
argument_list|()
operator|!=
name|mCurScissorEnabled
condition|)
block|{
name|mScissorStateIsDirty
operator|=
literal|true
expr_stmt|;
comment|// Rasterizer state update needs mCurScissorsEnabled and updates when it changes
name|mRasterizerStateIsDirty
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|gl
operator|::
name|State
operator|::
name|DIRTY_BIT_DEPTH_RANGE
case|:
if|if
condition|(
name|state
operator|.
name|getNearPlane
argument_list|()
operator|!=
name|mCurNear
operator|||
name|state
operator|.
name|getFarPlane
argument_list|()
operator|!=
name|mCurFar
condition|)
block|{
name|mViewportStateIsDirty
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|gl
operator|::
name|State
operator|::
name|DIRTY_BIT_VIEWPORT
case|:
if|if
condition|(
name|state
operator|.
name|getViewport
argument_list|()
operator|!=
name|mCurViewport
condition|)
block|{
name|mViewportStateIsDirty
operator|=
literal|true
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
block|}
DECL|function|setBlendState
name|gl
operator|::
name|Error
name|StateManager11
operator|::
name|setBlendState
parameter_list|(
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
parameter_list|,
specifier|const
name|gl
operator|::
name|BlendState
modifier|&
name|blendState
parameter_list|,
specifier|const
name|gl
operator|::
name|ColorF
modifier|&
name|blendColor
parameter_list|,
name|unsigned
name|int
name|sampleMask
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mBlendStateIsDirty
operator|&&
name|sampleMask
operator|==
name|mCurSampleMask
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
name|ID3D11BlendState
modifier|*
name|dxBlendState
init|=
literal|nullptr
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|mRenderer
operator|->
name|getStateCache
argument_list|()
operator|.
name|getBlendState
argument_list|(
name|framebuffer
argument_list|,
name|blendState
argument_list|,
operator|&
name|dxBlendState
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|dxBlendState
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
name|float
name|blendColors
index|[
literal|4
index|]
init|=
block|{
literal|0.0f
block|}
decl_stmt|;
if|if
condition|(
name|blendState
operator|.
name|sourceBlendRGB
operator|!=
name|GL_CONSTANT_ALPHA
operator|&&
name|blendState
operator|.
name|sourceBlendRGB
operator|!=
name|GL_ONE_MINUS_CONSTANT_ALPHA
operator|&&
name|blendState
operator|.
name|destBlendRGB
operator|!=
name|GL_CONSTANT_ALPHA
operator|&&
name|blendState
operator|.
name|destBlendRGB
operator|!=
name|GL_ONE_MINUS_CONSTANT_ALPHA
condition|)
block|{
name|blendColors
index|[
literal|0
index|]
operator|=
name|blendColor
operator|.
name|red
expr_stmt|;
name|blendColors
index|[
literal|1
index|]
operator|=
name|blendColor
operator|.
name|green
expr_stmt|;
name|blendColors
index|[
literal|2
index|]
operator|=
name|blendColor
operator|.
name|blue
expr_stmt|;
name|blendColors
index|[
literal|3
index|]
operator|=
name|blendColor
operator|.
name|alpha
expr_stmt|;
block|}
else|else
block|{
name|blendColors
index|[
literal|0
index|]
operator|=
name|blendColor
operator|.
name|alpha
expr_stmt|;
name|blendColors
index|[
literal|1
index|]
operator|=
name|blendColor
operator|.
name|alpha
expr_stmt|;
name|blendColors
index|[
literal|2
index|]
operator|=
name|blendColor
operator|.
name|alpha
expr_stmt|;
name|blendColors
index|[
literal|3
index|]
operator|=
name|blendColor
operator|.
name|alpha
expr_stmt|;
block|}
name|mRenderer
operator|->
name|getDeviceContext
argument_list|()
operator|->
name|OMSetBlendState
argument_list|(
name|dxBlendState
argument_list|,
name|blendColors
argument_list|,
name|sampleMask
argument_list|)
expr_stmt|;
name|mCurBlendState
operator|=
name|blendState
expr_stmt|;
name|mCurBlendColor
operator|=
name|blendColor
expr_stmt|;
name|mCurSampleMask
operator|=
name|sampleMask
expr_stmt|;
name|mBlendStateIsDirty
operator|=
literal|false
expr_stmt|;
return|return
name|error
return|;
block|}
DECL|function|setDepthStencilState
name|gl
operator|::
name|Error
name|StateManager11
operator|::
name|setDepthStencilState
parameter_list|(
specifier|const
name|gl
operator|::
name|State
modifier|&
name|glState
parameter_list|)
block|{
specifier|const
specifier|auto
modifier|&
name|fbo
init|=
operator|*
name|glState
operator|.
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
comment|// Disable the depth test/depth write if we are using a stencil-only attachment.
comment|// This is because ANGLE emulates stencil-only with D24S8 on D3D11 - we should neither read
comment|// nor write to the unused depth part of this emulated texture.
name|bool
name|disableDepth
init|=
operator|(
operator|!
name|fbo
operator|.
name|hasDepth
argument_list|()
operator|&&
name|fbo
operator|.
name|hasStencil
argument_list|()
operator|)
decl_stmt|;
comment|// Similarly we disable the stencil portion of the DS attachment if the app only binds depth.
name|bool
name|disableStencil
init|=
operator|(
name|fbo
operator|.
name|hasDepth
argument_list|()
operator|&&
operator|!
name|fbo
operator|.
name|hasStencil
argument_list|()
operator|)
decl_stmt|;
comment|// CurDisableDepth/Stencil are reset automatically after we call forceSetDepthStencilState.
if|if
condition|(
operator|!
name|mDepthStencilStateIsDirty
operator|&&
name|mCurDisableDepth
operator|.
name|valid
argument_list|()
operator|&&
name|disableDepth
operator|==
name|mCurDisableDepth
operator|.
name|value
argument_list|()
operator|&&
name|mCurDisableStencil
operator|.
name|valid
argument_list|()
operator|&&
name|disableStencil
operator|==
name|mCurDisableStencil
operator|.
name|value
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
specifier|const
specifier|auto
modifier|&
name|depthStencilState
init|=
name|glState
operator|.
name|getDepthStencilState
argument_list|()
decl_stmt|;
name|int
name|stencilRef
init|=
name|glState
operator|.
name|getStencilRef
argument_list|()
decl_stmt|;
name|int
name|stencilBackRef
init|=
name|glState
operator|.
name|getStencilBackRef
argument_list|()
decl_stmt|;
comment|// get the maximum size of the stencil ref
name|unsigned
name|int
name|maxStencil
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|depthStencilState
operator|.
name|stencilTest
operator|&&
name|mCurStencilSize
operator|>
literal|0
condition|)
block|{
name|maxStencil
operator|=
operator|(
literal|1
operator|<<
name|mCurStencilSize
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|ASSERT
argument_list|(
operator|(
name|depthStencilState
operator|.
name|stencilWritemask
operator|&
name|maxStencil
operator|)
operator|==
operator|(
name|depthStencilState
operator|.
name|stencilBackWritemask
operator|&
name|maxStencil
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|stencilRef
operator|==
name|stencilBackRef
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|depthStencilState
operator|.
name|stencilMask
operator|&
name|maxStencil
operator|)
operator|==
operator|(
name|depthStencilState
operator|.
name|stencilBackMask
operator|&
name|maxStencil
operator|)
argument_list|)
expr_stmt|;
name|ID3D11DepthStencilState
modifier|*
name|dxDepthStencilState
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|mRenderer
operator|->
name|getStateCache
argument_list|()
operator|.
name|getDepthStencilState
argument_list|(
name|depthStencilState
argument_list|,
name|disableDepth
argument_list|,
name|disableStencil
argument_list|,
operator|&
name|dxDepthStencilState
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|dxDepthStencilState
argument_list|)
expr_stmt|;
comment|// Max D3D11 stencil reference value is 0xFF,
comment|// corresponding to the max 8 bits in a stencil buffer
comment|// GL specifies we should clamp the ref value to the
comment|// nearest bit depth when doing stencil ops
assert|static_assert
argument_list|(
name|D3D11_DEFAULT_STENCIL_READ_MASK
operator|==
literal|0xFF
argument_list|,
literal|"Unexpected value of D3D11_DEFAULT_STENCIL_READ_MASK"
argument_list|)
assert|;
assert|static_assert
argument_list|(
name|D3D11_DEFAULT_STENCIL_WRITE_MASK
operator|==
literal|0xFF
argument_list|,
literal|"Unexpected value of D3D11_DEFAULT_STENCIL_WRITE_MASK"
argument_list|)
assert|;
name|UINT
name|dxStencilRef
init|=
name|std
operator|::
name|min
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|stencilRef
argument_list|,
literal|0xFFu
argument_list|)
decl_stmt|;
name|mRenderer
operator|->
name|getDeviceContext
argument_list|()
operator|->
name|OMSetDepthStencilState
argument_list|(
name|dxDepthStencilState
argument_list|,
name|dxStencilRef
argument_list|)
expr_stmt|;
name|mCurDepthStencilState
operator|=
name|depthStencilState
expr_stmt|;
name|mCurStencilRef
operator|=
name|stencilRef
expr_stmt|;
name|mCurStencilBackRef
operator|=
name|stencilBackRef
expr_stmt|;
name|mCurDisableDepth
operator|=
name|disableDepth
expr_stmt|;
name|mCurDisableStencil
operator|=
name|disableStencil
expr_stmt|;
name|mDepthStencilStateIsDirty
operator|=
literal|false
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|setRasterizerState
name|gl
operator|::
name|Error
name|StateManager11
operator|::
name|setRasterizerState
parameter_list|(
specifier|const
name|gl
operator|::
name|RasterizerState
modifier|&
name|rasterState
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mRasterizerStateIsDirty
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
name|ID3D11RasterizerState
modifier|*
name|dxRasterState
init|=
literal|nullptr
decl_stmt|;
name|gl
operator|::
name|Error
name|error
argument_list|(
name|GL_NO_ERROR
argument_list|)
decl_stmt|;
if|if
condition|(
name|mCurPresentPathFastEnabled
condition|)
block|{
name|gl
operator|::
name|RasterizerState
name|modifiedRasterState
init|=
name|rasterState
decl_stmt|;
comment|// If prseent path fast is active then we need invert the front face state.
comment|// This ensures that both gl_FrontFacing is correct, and front/back culling
comment|// is performed correctly.
if|if
condition|(
name|modifiedRasterState
operator|.
name|frontFace
operator|==
name|GL_CCW
condition|)
block|{
name|modifiedRasterState
operator|.
name|frontFace
operator|=
name|GL_CW
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|modifiedRasterState
operator|.
name|frontFace
operator|==
name|GL_CW
argument_list|)
expr_stmt|;
name|modifiedRasterState
operator|.
name|frontFace
operator|=
name|GL_CCW
expr_stmt|;
block|}
name|error
operator|=
name|mRenderer
operator|->
name|getStateCache
argument_list|()
operator|.
name|getRasterizerState
argument_list|(
name|modifiedRasterState
argument_list|,
name|mCurScissorEnabled
argument_list|,
operator|&
name|dxRasterState
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|mRenderer
operator|->
name|getStateCache
argument_list|()
operator|.
name|getRasterizerState
argument_list|(
name|rasterState
argument_list|,
name|mCurScissorEnabled
argument_list|,
operator|&
name|dxRasterState
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|mRenderer
operator|->
name|getDeviceContext
argument_list|()
operator|->
name|RSSetState
argument_list|(
name|dxRasterState
argument_list|)
expr_stmt|;
name|mCurRasterState
operator|=
name|rasterState
expr_stmt|;
name|mRasterizerStateIsDirty
operator|=
literal|false
expr_stmt|;
return|return
name|error
return|;
block|}
DECL|function|setScissorRectangle
name|void
name|StateManager11
operator|::
name|setScissorRectangle
parameter_list|(
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|scissor
parameter_list|,
name|bool
name|enabled
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mScissorStateIsDirty
condition|)
return|return;
name|int
name|modifiedScissorY
init|=
name|scissor
operator|.
name|y
decl_stmt|;
if|if
condition|(
name|mCurPresentPathFastEnabled
condition|)
block|{
name|modifiedScissorY
operator|=
name|mCurPresentPathFastColorBufferHeight
operator|-
name|scissor
operator|.
name|height
operator|-
name|scissor
operator|.
name|y
expr_stmt|;
block|}
if|if
condition|(
name|enabled
condition|)
block|{
name|D3D11_RECT
name|rect
decl_stmt|;
name|rect
operator|.
name|left
operator|=
name|std
operator|::
name|max
argument_list|(
literal|0
argument_list|,
name|scissor
operator|.
name|x
argument_list|)
expr_stmt|;
name|rect
operator|.
name|top
operator|=
name|std
operator|::
name|max
argument_list|(
literal|0
argument_list|,
name|modifiedScissorY
argument_list|)
expr_stmt|;
name|rect
operator|.
name|right
operator|=
name|scissor
operator|.
name|x
operator|+
name|std
operator|::
name|max
argument_list|(
literal|0
argument_list|,
name|scissor
operator|.
name|width
argument_list|)
expr_stmt|;
name|rect
operator|.
name|bottom
operator|=
name|modifiedScissorY
operator|+
name|std
operator|::
name|max
argument_list|(
literal|0
argument_list|,
name|scissor
operator|.
name|height
argument_list|)
expr_stmt|;
name|mRenderer
operator|->
name|getDeviceContext
argument_list|()
operator|->
name|RSSetScissorRects
argument_list|(
literal|1
argument_list|,
operator|&
name|rect
argument_list|)
expr_stmt|;
block|}
name|mCurScissorRect
operator|=
name|scissor
expr_stmt|;
name|mCurScissorEnabled
operator|=
name|enabled
expr_stmt|;
name|mScissorStateIsDirty
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|setViewport
name|void
name|StateManager11
operator|::
name|setViewport
parameter_list|(
specifier|const
name|gl
operator|::
name|Caps
modifier|*
name|caps
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|viewport
parameter_list|,
name|float
name|zNear
parameter_list|,
name|float
name|zFar
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mViewportStateIsDirty
condition|)
return|return;
name|float
name|actualZNear
init|=
name|gl
operator|::
name|clamp01
argument_list|(
name|zNear
argument_list|)
decl_stmt|;
name|float
name|actualZFar
init|=
name|gl
operator|::
name|clamp01
argument_list|(
name|zFar
argument_list|)
decl_stmt|;
name|int
name|dxMaxViewportBoundsX
init|=
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|caps
operator|->
name|maxViewportWidth
argument_list|)
decl_stmt|;
name|int
name|dxMaxViewportBoundsY
init|=
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|caps
operator|->
name|maxViewportHeight
argument_list|)
decl_stmt|;
name|int
name|dxMinViewportBoundsX
init|=
operator|-
name|dxMaxViewportBoundsX
decl_stmt|;
name|int
name|dxMinViewportBoundsY
init|=
operator|-
name|dxMaxViewportBoundsY
decl_stmt|;
if|if
condition|(
name|mRenderer
operator|->
name|getRenderer11DeviceCaps
argument_list|()
operator|.
name|featureLevel
operator|<=
name|D3D_FEATURE_LEVEL_9_3
condition|)
block|{
comment|// Feature Level 9 viewports shouldn't exceed the dimensions of the rendertarget.
name|dxMaxViewportBoundsX
operator|=
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|mViewportBounds
operator|.
name|width
argument_list|)
expr_stmt|;
name|dxMaxViewportBoundsY
operator|=
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|mViewportBounds
operator|.
name|height
argument_list|)
expr_stmt|;
name|dxMinViewportBoundsX
operator|=
literal|0
expr_stmt|;
name|dxMinViewportBoundsY
operator|=
literal|0
expr_stmt|;
block|}
name|int
name|dxViewportTopLeftX
init|=
name|gl
operator|::
name|clamp
argument_list|(
name|viewport
operator|.
name|x
argument_list|,
name|dxMinViewportBoundsX
argument_list|,
name|dxMaxViewportBoundsX
argument_list|)
decl_stmt|;
name|int
name|dxViewportTopLeftY
init|=
name|gl
operator|::
name|clamp
argument_list|(
name|viewport
operator|.
name|y
argument_list|,
name|dxMinViewportBoundsY
argument_list|,
name|dxMaxViewportBoundsY
argument_list|)
decl_stmt|;
name|int
name|dxViewportWidth
init|=
name|gl
operator|::
name|clamp
argument_list|(
name|viewport
operator|.
name|width
argument_list|,
literal|0
argument_list|,
name|dxMaxViewportBoundsX
operator|-
name|dxViewportTopLeftX
argument_list|)
decl_stmt|;
name|int
name|dxViewportHeight
init|=
name|gl
operator|::
name|clamp
argument_list|(
name|viewport
operator|.
name|height
argument_list|,
literal|0
argument_list|,
name|dxMaxViewportBoundsY
operator|-
name|dxViewportTopLeftY
argument_list|)
decl_stmt|;
name|D3D11_VIEWPORT
name|dxViewport
decl_stmt|;
name|dxViewport
operator|.
name|TopLeftX
operator|=
cast|static_cast
argument_list|<
name|float
argument_list|>
argument_list|(
name|dxViewportTopLeftX
argument_list|)
expr_stmt|;
if|if
condition|(
name|mCurPresentPathFastEnabled
condition|)
block|{
comment|// When present path fast is active and we're rendering to framebuffer 0, we must invert
comment|// the viewport in Y-axis.
comment|// NOTE: We delay the inversion until right before the call to RSSetViewports, and leave
comment|// dxViewportTopLeftY unchanged. This allows us to calculate viewAdjust below using the
comment|// unaltered dxViewportTopLeftY value.
name|dxViewport
operator|.
name|TopLeftY
operator|=
cast|static_cast
argument_list|<
name|float
argument_list|>
argument_list|(
name|mCurPresentPathFastColorBufferHeight
operator|-
name|dxViewportTopLeftY
operator|-
name|dxViewportHeight
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dxViewport
operator|.
name|TopLeftY
operator|=
cast|static_cast
argument_list|<
name|float
argument_list|>
argument_list|(
name|dxViewportTopLeftY
argument_list|)
expr_stmt|;
block|}
name|dxViewport
operator|.
name|Width
operator|=
cast|static_cast
argument_list|<
name|float
argument_list|>
argument_list|(
name|dxViewportWidth
argument_list|)
expr_stmt|;
name|dxViewport
operator|.
name|Height
operator|=
cast|static_cast
argument_list|<
name|float
argument_list|>
argument_list|(
name|dxViewportHeight
argument_list|)
expr_stmt|;
name|dxViewport
operator|.
name|MinDepth
operator|=
name|actualZNear
expr_stmt|;
name|dxViewport
operator|.
name|MaxDepth
operator|=
name|actualZFar
expr_stmt|;
name|mRenderer
operator|->
name|getDeviceContext
argument_list|()
operator|->
name|RSSetViewports
argument_list|(
literal|1
argument_list|,
operator|&
name|dxViewport
argument_list|)
expr_stmt|;
name|mCurViewport
operator|=
name|viewport
expr_stmt|;
name|mCurNear
operator|=
name|actualZNear
expr_stmt|;
name|mCurFar
operator|=
name|actualZFar
expr_stmt|;
comment|// On Feature Level 9_*, we must emulate large and/or negative viewports in the shaders
comment|// using viewAdjust (like the D3D9 renderer).
if|if
condition|(
name|mRenderer
operator|->
name|getRenderer11DeviceCaps
argument_list|()
operator|.
name|featureLevel
operator|<=
name|D3D_FEATURE_LEVEL_9_3
condition|)
block|{
name|mVertexConstants
operator|.
name|viewAdjust
index|[
literal|0
index|]
operator|=
cast|static_cast
argument_list|<
name|float
argument_list|>
argument_list|(
operator|(
name|viewport
operator|.
name|width
operator|-
name|dxViewportWidth
operator|)
operator|+
literal|2
operator|*
operator|(
name|viewport
operator|.
name|x
operator|-
name|dxViewportTopLeftX
operator|)
argument_list|)
operator|/
name|dxViewport
operator|.
name|Width
expr_stmt|;
name|mVertexConstants
operator|.
name|viewAdjust
index|[
literal|1
index|]
operator|=
cast|static_cast
argument_list|<
name|float
argument_list|>
argument_list|(
operator|(
name|viewport
operator|.
name|height
operator|-
name|dxViewportHeight
operator|)
operator|+
literal|2
operator|*
operator|(
name|viewport
operator|.
name|y
operator|-
name|dxViewportTopLeftY
operator|)
argument_list|)
operator|/
name|dxViewport
operator|.
name|Height
expr_stmt|;
name|mVertexConstants
operator|.
name|viewAdjust
index|[
literal|2
index|]
operator|=
cast|static_cast
argument_list|<
name|float
argument_list|>
argument_list|(
name|viewport
operator|.
name|width
argument_list|)
operator|/
name|dxViewport
operator|.
name|Width
expr_stmt|;
name|mVertexConstants
operator|.
name|viewAdjust
index|[
literal|3
index|]
operator|=
cast|static_cast
argument_list|<
name|float
argument_list|>
argument_list|(
name|viewport
operator|.
name|height
argument_list|)
operator|/
name|dxViewport
operator|.
name|Height
expr_stmt|;
block|}
name|mPixelConstants
operator|.
name|viewCoords
index|[
literal|0
index|]
operator|=
name|viewport
operator|.
name|width
operator|*
literal|0.5f
expr_stmt|;
name|mPixelConstants
operator|.
name|viewCoords
index|[
literal|1
index|]
operator|=
name|viewport
operator|.
name|height
operator|*
literal|0.5f
expr_stmt|;
name|mPixelConstants
operator|.
name|viewCoords
index|[
literal|2
index|]
operator|=
name|viewport
operator|.
name|x
operator|+
operator|(
name|viewport
operator|.
name|width
operator|*
literal|0.5f
operator|)
expr_stmt|;
name|mPixelConstants
operator|.
name|viewCoords
index|[
literal|3
index|]
operator|=
name|viewport
operator|.
name|y
operator|+
operator|(
name|viewport
operator|.
name|height
operator|*
literal|0.5f
operator|)
expr_stmt|;
comment|// Instanced pointsprite emulation requires ViewCoords to be defined in the
comment|// the vertex shader.
name|mVertexConstants
operator|.
name|viewCoords
index|[
literal|0
index|]
operator|=
name|mPixelConstants
operator|.
name|viewCoords
index|[
literal|0
index|]
expr_stmt|;
name|mVertexConstants
operator|.
name|viewCoords
index|[
literal|1
index|]
operator|=
name|mPixelConstants
operator|.
name|viewCoords
index|[
literal|1
index|]
expr_stmt|;
name|mVertexConstants
operator|.
name|viewCoords
index|[
literal|2
index|]
operator|=
name|mPixelConstants
operator|.
name|viewCoords
index|[
literal|2
index|]
expr_stmt|;
name|mVertexConstants
operator|.
name|viewCoords
index|[
literal|3
index|]
operator|=
name|mPixelConstants
operator|.
name|viewCoords
index|[
literal|3
index|]
expr_stmt|;
name|mPixelConstants
operator|.
name|depthFront
index|[
literal|0
index|]
operator|=
operator|(
name|actualZFar
operator|-
name|actualZNear
operator|)
operator|*
literal|0.5f
expr_stmt|;
name|mPixelConstants
operator|.
name|depthFront
index|[
literal|1
index|]
operator|=
operator|(
name|actualZNear
operator|+
name|actualZFar
operator|)
operator|*
literal|0.5f
expr_stmt|;
name|mVertexConstants
operator|.
name|depthRange
index|[
literal|0
index|]
operator|=
name|actualZNear
expr_stmt|;
name|mVertexConstants
operator|.
name|depthRange
index|[
literal|1
index|]
operator|=
name|actualZFar
expr_stmt|;
name|mVertexConstants
operator|.
name|depthRange
index|[
literal|2
index|]
operator|=
name|actualZFar
operator|-
name|actualZNear
expr_stmt|;
name|mPixelConstants
operator|.
name|depthRange
index|[
literal|0
index|]
operator|=
name|actualZNear
expr_stmt|;
name|mPixelConstants
operator|.
name|depthRange
index|[
literal|1
index|]
operator|=
name|actualZFar
expr_stmt|;
name|mPixelConstants
operator|.
name|depthRange
index|[
literal|2
index|]
operator|=
name|actualZFar
operator|-
name|actualZNear
expr_stmt|;
name|mPixelConstants
operator|.
name|viewScale
index|[
literal|0
index|]
operator|=
literal|1.0f
expr_stmt|;
name|mPixelConstants
operator|.
name|viewScale
index|[
literal|1
index|]
operator|=
name|mCurPresentPathFastEnabled
condition|?
literal|1.0f
else|:
operator|-
literal|1.0f
expr_stmt|;
name|mPixelConstants
operator|.
name|viewScale
index|[
literal|2
index|]
operator|=
literal|1.0f
expr_stmt|;
name|mPixelConstants
operator|.
name|viewScale
index|[
literal|3
index|]
operator|=
literal|1.0f
expr_stmt|;
name|mVertexConstants
operator|.
name|viewScale
index|[
literal|0
index|]
operator|=
name|mPixelConstants
operator|.
name|viewScale
index|[
literal|0
index|]
expr_stmt|;
name|mVertexConstants
operator|.
name|viewScale
index|[
literal|1
index|]
operator|=
name|mPixelConstants
operator|.
name|viewScale
index|[
literal|1
index|]
expr_stmt|;
name|mVertexConstants
operator|.
name|viewScale
index|[
literal|2
index|]
operator|=
name|mPixelConstants
operator|.
name|viewScale
index|[
literal|2
index|]
expr_stmt|;
name|mVertexConstants
operator|.
name|viewScale
index|[
literal|3
index|]
operator|=
name|mPixelConstants
operator|.
name|viewScale
index|[
literal|3
index|]
expr_stmt|;
name|mViewportStateIsDirty
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|invalidateRenderTarget
name|void
name|StateManager11
operator|::
name|invalidateRenderTarget
parameter_list|()
block|{
for|for
control|(
name|auto
operator|&
name|appliedRTV
operator|:
name|mAppliedRTVs
control|)
block|{
name|appliedRTV
operator|=
name|angle
operator|::
name|DirtyPointer
expr_stmt|;
block|}
name|mAppliedDSV
operator|=
name|angle
operator|::
name|DirtyPointer
expr_stmt|;
block|}
DECL|function|invalidateEverything
name|void
name|StateManager11
operator|::
name|invalidateEverything
parameter_list|()
block|{
name|mBlendStateIsDirty
operator|=
literal|true
expr_stmt|;
name|mDepthStencilStateIsDirty
operator|=
literal|true
expr_stmt|;
name|mRasterizerStateIsDirty
operator|=
literal|true
expr_stmt|;
name|mScissorStateIsDirty
operator|=
literal|true
expr_stmt|;
name|mViewportStateIsDirty
operator|=
literal|true
expr_stmt|;
comment|// We reset the current SRV data because it might not be in sync with D3D's state
comment|// anymore. For example when a currently used SRV is used as an RTV, D3D silently
comment|// remove it from its state.
name|mCurVertexSRVs
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mCurPixelSRVs
operator|.
name|clear
argument_list|()
expr_stmt|;
name|invalidateRenderTarget
argument_list|()
expr_stmt|;
block|}
DECL|function|setRenderTargets
name|bool
name|StateManager11
operator|::
name|setRenderTargets
parameter_list|(
specifier|const
name|RenderTargetArray
modifier|&
name|renderTargets
parameter_list|,
name|ID3D11DepthStencilView
modifier|*
name|depthStencil
parameter_list|)
block|{
comment|// TODO(jmadill): Use context caps?
name|UINT
name|drawBuffers
init|=
name|mRenderer
operator|->
name|getRendererCaps
argument_list|()
operator|.
name|maxDrawBuffers
decl_stmt|;
comment|// Apply the render target and depth stencil
name|size_t
name|arraySize
init|=
sizeof|sizeof
argument_list|(
name|uintptr_t
argument_list|)
operator|*
name|drawBuffers
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|renderTargets
operator|.
name|data
argument_list|()
argument_list|,
name|mAppliedRTVs
operator|.
name|data
argument_list|()
argument_list|,
name|arraySize
argument_list|)
operator|==
literal|0
operator|&&
cast|reinterpret_cast
argument_list|<
name|uintptr_t
argument_list|>
argument_list|(
name|depthStencil
argument_list|)
operator|==
name|mAppliedDSV
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// The D3D11 blend state is heavily dependent on the current render target.
name|mBlendStateIsDirty
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|UINT
name|rtIndex
init|=
literal|0
init|;
name|rtIndex
operator|<
name|drawBuffers
condition|;
name|rtIndex
operator|++
control|)
block|{
name|mAppliedRTVs
index|[
name|rtIndex
index|]
operator|=
cast|reinterpret_cast
argument_list|<
name|uintptr_t
argument_list|>
argument_list|(
name|renderTargets
index|[
name|rtIndex
index|]
argument_list|)
expr_stmt|;
block|}
name|mAppliedDSV
operator|=
cast|reinterpret_cast
argument_list|<
name|uintptr_t
argument_list|>
argument_list|(
name|depthStencil
argument_list|)
expr_stmt|;
name|mRenderer
operator|->
name|getDeviceContext
argument_list|()
operator|->
name|OMSetRenderTargets
argument_list|(
name|drawBuffers
argument_list|,
name|renderTargets
operator|.
name|data
argument_list|()
argument_list|,
name|depthStencil
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|setRenderTarget
name|void
name|StateManager11
operator|::
name|setRenderTarget
parameter_list|(
name|ID3D11RenderTargetView
modifier|*
name|renderTarget
parameter_list|,
name|ID3D11DepthStencilView
modifier|*
name|depthStencil
parameter_list|)
block|{
name|mRenderer
operator|->
name|getDeviceContext
argument_list|()
operator|->
name|OMSetRenderTargets
argument_list|(
literal|1
argument_list|,
operator|&
name|renderTarget
argument_list|,
name|depthStencil
argument_list|)
expr_stmt|;
block|}
DECL|function|setShaderResource
name|void
name|StateManager11
operator|::
name|setShaderResource
parameter_list|(
name|gl
operator|::
name|SamplerType
name|shaderType
parameter_list|,
name|UINT
name|resourceSlot
parameter_list|,
name|ID3D11ShaderResourceView
modifier|*
name|srv
parameter_list|)
block|{
name|auto
operator|&
name|currentSRVs
operator|=
operator|(
name|shaderType
operator|==
name|gl
operator|::
name|SAMPLER_VERTEX
condition|?
name|mCurVertexSRVs
else|:
name|mCurPixelSRVs
operator|)
expr_stmt|;
name|ASSERT
argument_list|(
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|resourceSlot
argument_list|)
operator|<
name|currentSRVs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|SRVRecord
modifier|&
name|record
init|=
name|currentSRVs
index|[
name|resourceSlot
index|]
decl_stmt|;
if|if
condition|(
name|record
operator|.
name|srv
operator|!=
cast|reinterpret_cast
argument_list|<
name|uintptr_t
argument_list|>
argument_list|(
name|srv
argument_list|)
condition|)
block|{
name|auto
name|deviceContext
init|=
name|mRenderer
operator|->
name|getDeviceContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|shaderType
operator|==
name|gl
operator|::
name|SAMPLER_VERTEX
condition|)
block|{
name|deviceContext
operator|->
name|VSSetShaderResources
argument_list|(
name|resourceSlot
argument_list|,
literal|1
argument_list|,
operator|&
name|srv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|deviceContext
operator|->
name|PSSetShaderResources
argument_list|(
name|resourceSlot
argument_list|,
literal|1
argument_list|,
operator|&
name|srv
argument_list|)
expr_stmt|;
block|}
name|currentSRVs
operator|.
name|update
argument_list|(
name|resourceSlot
argument_list|,
name|srv
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|clearTextures
name|gl
operator|::
name|Error
name|StateManager11
operator|::
name|clearTextures
parameter_list|(
name|gl
operator|::
name|SamplerType
name|samplerType
parameter_list|,
name|size_t
name|rangeStart
parameter_list|,
name|size_t
name|rangeEnd
parameter_list|)
block|{
if|if
condition|(
name|rangeStart
operator|==
name|rangeEnd
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
name|auto
operator|&
name|currentSRVs
operator|=
operator|(
name|samplerType
operator|==
name|gl
operator|::
name|SAMPLER_VERTEX
condition|?
name|mCurVertexSRVs
else|:
name|mCurPixelSRVs
operator|)
expr_stmt|;
name|gl
operator|::
name|Range
argument_list|<
name|size_t
argument_list|>
name|clearRange
argument_list|(
name|rangeStart
argument_list|,
name|rangeStart
argument_list|)
decl_stmt|;
name|clearRange
operator|.
name|extend
argument_list|(
name|std
operator|::
name|min
argument_list|(
name|rangeEnd
argument_list|,
name|currentSRVs
operator|.
name|highestUsed
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|clearRange
operator|.
name|empty
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
name|auto
name|deviceContext
init|=
name|mRenderer
operator|->
name|getDeviceContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|samplerType
operator|==
name|gl
operator|::
name|SAMPLER_VERTEX
condition|)
block|{
name|deviceContext
operator|->
name|VSSetShaderResources
argument_list|(
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|rangeStart
argument_list|)
argument_list|,
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|rangeEnd
operator|-
name|rangeStart
argument_list|)
argument_list|,
operator|&
name|mNullSRVs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|deviceContext
operator|->
name|PSSetShaderResources
argument_list|(
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|rangeStart
argument_list|)
argument_list|,
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|rangeEnd
operator|-
name|rangeStart
argument_list|)
argument_list|,
operator|&
name|mNullSRVs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|size_t
name|samplerIndex
init|=
name|rangeStart
init|;
name|samplerIndex
operator|<
name|rangeEnd
condition|;
operator|++
name|samplerIndex
control|)
block|{
name|currentSRVs
operator|.
name|update
argument_list|(
name|samplerIndex
argument_list|,
literal|nullptr
argument_list|)
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|unsetConflictingSRVs
name|void
name|StateManager11
operator|::
name|unsetConflictingSRVs
parameter_list|(
name|gl
operator|::
name|SamplerType
name|samplerType
parameter_list|,
name|uintptr_t
name|resource
parameter_list|,
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
parameter_list|)
block|{
name|auto
operator|&
name|currentSRVs
operator|=
operator|(
name|samplerType
operator|==
name|gl
operator|::
name|SAMPLER_VERTEX
condition|?
name|mCurVertexSRVs
else|:
name|mCurPixelSRVs
operator|)
expr_stmt|;
for|for
control|(
name|size_t
name|resourceIndex
init|=
literal|0
init|;
name|resourceIndex
operator|<
name|currentSRVs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|resourceIndex
control|)
block|{
name|auto
operator|&
name|record
operator|=
name|currentSRVs
index|[
name|resourceIndex
index|]
expr_stmt|;
if|if
condition|(
name|record
operator|.
name|srv
operator|&&
name|record
operator|.
name|resource
operator|==
name|resource
operator|&&
name|ImageIndexConflictsWithSRV
argument_list|(
name|index
argument_list|,
name|record
operator|.
name|desc
argument_list|)
condition|)
block|{
name|setShaderResource
argument_list|(
name|samplerType
argument_list|,
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|resourceIndex
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|initialize
name|void
name|StateManager11
operator|::
name|initialize
parameter_list|(
specifier|const
name|gl
operator|::
name|Caps
modifier|&
name|caps
parameter_list|)
block|{
name|mCurVertexSRVs
operator|.
name|initialize
argument_list|(
name|caps
operator|.
name|maxVertexTextureImageUnits
argument_list|)
expr_stmt|;
name|mCurPixelSRVs
operator|.
name|initialize
argument_list|(
name|caps
operator|.
name|maxTextureImageUnits
argument_list|)
expr_stmt|;
comment|// Initialize cached NULL SRV block
name|mNullSRVs
operator|.
name|resize
argument_list|(
name|caps
operator|.
name|maxTextureImageUnits
argument_list|,
literal|nullptr
argument_list|)
expr_stmt|;
block|}
DECL|function|syncFramebuffer
name|gl
operator|::
name|Error
name|StateManager11
operator|::
name|syncFramebuffer
parameter_list|(
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
parameter_list|)
block|{
comment|// Get the color render buffer and serial
comment|// Also extract the render target dimensions and view
name|unsigned
name|int
name|renderTargetWidth
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|renderTargetHeight
init|=
literal|0
decl_stmt|;
name|DXGI_FORMAT
name|renderTargetFormat
init|=
name|DXGI_FORMAT_UNKNOWN
decl_stmt|;
name|RenderTargetArray
name|framebufferRTVs
decl_stmt|;
name|bool
name|missingColorRenderTarget
init|=
literal|true
decl_stmt|;
name|framebufferRTVs
operator|.
name|fill
argument_list|(
literal|nullptr
argument_list|)
expr_stmt|;
specifier|const
name|Framebuffer11
modifier|*
name|framebuffer11
init|=
name|GetImplAs
argument_list|<
name|Framebuffer11
argument_list|>
argument_list|(
name|framebuffer
argument_list|)
decl_stmt|;
specifier|const
name|gl
operator|::
name|AttachmentList
modifier|&
name|colorbuffers
init|=
name|framebuffer11
operator|->
name|getColorAttachmentsForRender
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|colorAttachment
init|=
literal|0
init|;
name|colorAttachment
operator|<
name|colorbuffers
operator|.
name|size
argument_list|()
condition|;
operator|++
name|colorAttachment
control|)
block|{
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|colorbuffer
init|=
name|colorbuffers
index|[
name|colorAttachment
index|]
decl_stmt|;
if|if
condition|(
name|colorbuffer
condition|)
block|{
comment|// the draw buffer must be either "none", "back" for the default buffer or the same
comment|// index as this color (in order)
comment|// check for zero-sized default framebuffer, which is a special case.
comment|// in this case we do not wish to modify any state and just silently return false.
comment|// this will not report any gl error but will cause the calling method to return.
specifier|const
name|gl
operator|::
name|Extents
modifier|&
name|size
init|=
name|colorbuffer
operator|->
name|getSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|.
name|width
operator|==
literal|0
operator|||
name|size
operator|.
name|height
operator|==
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
comment|// Extract the render target dimensions and view
name|RenderTarget11
modifier|*
name|renderTarget
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|colorbuffer
operator|->
name|getRenderTarget
argument_list|(
operator|&
name|renderTarget
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|renderTarget
argument_list|)
expr_stmt|;
name|framebufferRTVs
index|[
name|colorAttachment
index|]
operator|=
name|renderTarget
operator|->
name|getRenderTargetView
argument_list|()
expr_stmt|;
name|ASSERT
argument_list|(
name|framebufferRTVs
index|[
name|colorAttachment
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|missingColorRenderTarget
condition|)
block|{
name|renderTargetWidth
operator|=
name|renderTarget
operator|->
name|getWidth
argument_list|()
expr_stmt|;
name|renderTargetHeight
operator|=
name|renderTarget
operator|->
name|getHeight
argument_list|()
expr_stmt|;
name|renderTargetFormat
operator|=
name|renderTarget
operator|->
name|getDXGIFormat
argument_list|()
expr_stmt|;
name|missingColorRenderTarget
operator|=
literal|false
expr_stmt|;
block|}
comment|// Unbind render target SRVs from the shader here to prevent D3D11 warnings.
if|if
condition|(
name|colorbuffer
operator|->
name|type
argument_list|()
operator|==
name|GL_TEXTURE
condition|)
block|{
name|uintptr_t
name|rtResource
init|=
cast|reinterpret_cast
argument_list|<
name|uintptr_t
argument_list|>
argument_list|(
name|GetViewResource
argument_list|(
name|framebufferRTVs
index|[
name|colorAttachment
index|]
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
init|=
name|colorbuffer
operator|->
name|getTextureImageIndex
argument_list|()
decl_stmt|;
comment|// The index doesn't need to be corrected for the small compressed texture
comment|// workaround
comment|// because a rendertarget is never compressed.
name|unsetConflictingSRVs
argument_list|(
name|gl
operator|::
name|SAMPLER_VERTEX
argument_list|,
name|rtResource
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|unsetConflictingSRVs
argument_list|(
name|gl
operator|::
name|SAMPLER_PIXEL
argument_list|,
name|rtResource
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Get the depth stencil buffers
name|ID3D11DepthStencilView
modifier|*
name|framebufferDSV
init|=
name|NULL
decl_stmt|;
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|depthStencil
init|=
name|framebuffer
operator|->
name|getDepthOrStencilbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|depthStencil
condition|)
block|{
name|RenderTarget11
modifier|*
name|depthStencilRenderTarget
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|depthStencil
operator|->
name|getRenderTarget
argument_list|(
operator|&
name|depthStencilRenderTarget
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|depthStencilRenderTarget
argument_list|)
expr_stmt|;
name|framebufferDSV
operator|=
name|depthStencilRenderTarget
operator|->
name|getDepthStencilView
argument_list|()
expr_stmt|;
name|ASSERT
argument_list|(
name|framebufferDSV
argument_list|)
expr_stmt|;
comment|// If there is no render buffer, the width, height and format values come from
comment|// the depth stencil
if|if
condition|(
name|missingColorRenderTarget
condition|)
block|{
name|renderTargetWidth
operator|=
name|depthStencilRenderTarget
operator|->
name|getWidth
argument_list|()
expr_stmt|;
name|renderTargetHeight
operator|=
name|depthStencilRenderTarget
operator|->
name|getHeight
argument_list|()
expr_stmt|;
block|}
comment|// Unbind render target SRVs from the shader here to prevent D3D11 warnings.
if|if
condition|(
name|depthStencil
operator|->
name|type
argument_list|()
operator|==
name|GL_TEXTURE
condition|)
block|{
name|uintptr_t
name|depthStencilResource
init|=
cast|reinterpret_cast
argument_list|<
name|uintptr_t
argument_list|>
argument_list|(
name|GetViewResource
argument_list|(
name|framebufferDSV
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|gl
operator|::
name|ImageIndex
modifier|&
name|index
init|=
name|depthStencil
operator|->
name|getTextureImageIndex
argument_list|()
decl_stmt|;
comment|// The index doesn't need to be corrected for the small compressed texture workaround
comment|// because a rendertarget is never compressed.
name|unsetConflictingSRVs
argument_list|(
name|gl
operator|::
name|SAMPLER_VERTEX
argument_list|,
name|depthStencilResource
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|unsetConflictingSRVs
argument_list|(
name|gl
operator|::
name|SAMPLER_PIXEL
argument_list|,
name|depthStencilResource
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|setRenderTargets
argument_list|(
name|framebufferRTVs
argument_list|,
name|framebufferDSV
argument_list|)
condition|)
block|{
name|setViewportBounds
argument_list|(
name|renderTargetWidth
argument_list|,
name|renderTargetHeight
argument_list|)
expr_stmt|;
block|}
name|gl
operator|::
name|Error
name|error
init|=
name|framebuffer11
operator|->
name|invalidateSwizzles
argument_list|()
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
block|}
end_namespace
begin_comment
comment|// namespace rx
end_comment
end_unit
