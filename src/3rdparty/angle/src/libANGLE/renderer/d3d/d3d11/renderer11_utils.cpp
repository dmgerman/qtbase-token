begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2012-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// renderer11_utils.cpp: Conversion functions and other utility routines
end_comment
begin_comment
comment|// specific to the D3D11 renderer.
end_comment
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/renderer11_utils.h"
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_include
include|#
directive|include
file|"common/debug.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/formatutils.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Framebuffer.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Program.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/dxgi_support_table.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/formatutils11.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/Renderer11.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/RenderTarget11.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d11/texture_format_table.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/FramebufferD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/WorkaroundsD3D.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|D3D_FL9_1_DEFAULT_MAX_ANISOTROPY
end_ifndef
begin_define
DECL|macro|D3D_FL9_1_DEFAULT_MAX_ANISOTROPY
define|#
directive|define
name|D3D_FL9_1_DEFAULT_MAX_ANISOTROPY
value|2
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D_FL9_1_SIMULTANEOUS_RENDER_TARGET_COUNT
end_ifndef
begin_define
DECL|macro|D3D_FL9_1_SIMULTANEOUS_RENDER_TARGET_COUNT
define|#
directive|define
name|D3D_FL9_1_SIMULTANEOUS_RENDER_TARGET_COUNT
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D_FL9_3_SIMULTANEOUS_RENDER_TARGET_COUNT
end_ifndef
begin_define
DECL|macro|D3D_FL9_3_SIMULTANEOUS_RENDER_TARGET_COUNT
define|#
directive|define
name|D3D_FL9_3_SIMULTANEOUS_RENDER_TARGET_COUNT
value|4
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D_FL9_1_IA_PRIMITIVE_MAX_COUNT
end_ifndef
begin_define
DECL|macro|D3D_FL9_1_IA_PRIMITIVE_MAX_COUNT
define|#
directive|define
name|D3D_FL9_1_IA_PRIMITIVE_MAX_COUNT
value|65535
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D_FL9_2_IA_PRIMITIVE_MAX_COUNT
end_ifndef
begin_define
DECL|macro|D3D_FL9_2_IA_PRIMITIVE_MAX_COUNT
define|#
directive|define
name|D3D_FL9_2_IA_PRIMITIVE_MAX_COUNT
value|1048575
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D_FL9_1_REQ_TEXTURECUBE_DIMENSION
end_ifndef
begin_define
DECL|macro|D3D_FL9_1_REQ_TEXTURECUBE_DIMENSION
define|#
directive|define
name|D3D_FL9_1_REQ_TEXTURECUBE_DIMENSION
value|512
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D_FL9_3_REQ_TEXTURECUBE_DIMENSION
end_ifndef
begin_define
DECL|macro|D3D_FL9_3_REQ_TEXTURECUBE_DIMENSION
define|#
directive|define
name|D3D_FL9_3_REQ_TEXTURECUBE_DIMENSION
value|4096
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D_FL9_1_REQ_TEXTURE2D_U_OR_V_DIMENSION
end_ifndef
begin_define
DECL|macro|D3D_FL9_1_REQ_TEXTURE2D_U_OR_V_DIMENSION
define|#
directive|define
name|D3D_FL9_1_REQ_TEXTURE2D_U_OR_V_DIMENSION
value|2048
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D_FL9_1_REQ_TEXTURE3D_U_V_OR_W_DIMENSION
end_ifndef
begin_define
DECL|macro|D3D_FL9_1_REQ_TEXTURE3D_U_V_OR_W_DIMENSION
define|#
directive|define
name|D3D_FL9_1_REQ_TEXTURE3D_U_V_OR_W_DIMENSION
value|256
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D_FL9_3_REQ_TEXTURE2D_U_OR_V_DIMENSION
end_ifndef
begin_define
DECL|macro|D3D_FL9_3_REQ_TEXTURE2D_U_OR_V_DIMENSION
define|#
directive|define
name|D3D_FL9_3_REQ_TEXTURE2D_U_OR_V_DIMENSION
value|4096
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D11_REQ_TEXTURECUBE_DIMENSION
end_ifndef
begin_define
DECL|macro|D3D11_REQ_TEXTURECUBE_DIMENSION
define|#
directive|define
name|D3D11_REQ_TEXTURECUBE_DIMENSION
value|16384
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D11_REQ_TEXTURE2D_ARRAY_AXIS_DIMENSION
end_ifndef
begin_define
DECL|macro|D3D11_REQ_TEXTURE2D_ARRAY_AXIS_DIMENSION
define|#
directive|define
name|D3D11_REQ_TEXTURE2D_ARRAY_AXIS_DIMENSION
value|2048
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D11_REQ_TEXTURE3D_U_V_OR_W_DIMENSION
end_ifndef
begin_define
DECL|macro|D3D11_REQ_TEXTURE3D_U_V_OR_W_DIMENSION
define|#
directive|define
name|D3D11_REQ_TEXTURE3D_U_V_OR_W_DIMENSION
value|2048
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D11_REQ_DRAWINDEXED_INDEX_COUNT_2_TO_EXP
end_ifndef
begin_define
DECL|macro|D3D11_REQ_DRAWINDEXED_INDEX_COUNT_2_TO_EXP
define|#
directive|define
name|D3D11_REQ_DRAWINDEXED_INDEX_COUNT_2_TO_EXP
value|32
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D11_REQ_DRAW_VERTEX_COUNT_2_TO_EXP
end_ifndef
begin_define
DECL|macro|D3D11_REQ_DRAW_VERTEX_COUNT_2_TO_EXP
define|#
directive|define
name|D3D11_REQ_DRAW_VERTEX_COUNT_2_TO_EXP
value|32
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D10_1_STANDARD_VERTEX_ELEMENT_COUNT
end_ifndef
begin_define
DECL|macro|D3D10_1_STANDARD_VERTEX_ELEMENT_COUNT
define|#
directive|define
name|D3D10_1_STANDARD_VERTEX_ELEMENT_COUNT
value|32
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D11_STANDARD_VERTEX_ELEMENT_COUNT
end_ifndef
begin_define
DECL|macro|D3D11_STANDARD_VERTEX_ELEMENT_COUNT
define|#
directive|define
name|D3D11_STANDARD_VERTEX_ELEMENT_COUNT
value|32
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D10_1_SO_BUFFER_SLOT_COUNT
end_ifndef
begin_define
DECL|macro|D3D10_1_SO_BUFFER_SLOT_COUNT
define|#
directive|define
name|D3D10_1_SO_BUFFER_SLOT_COUNT
value|4
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D11_SO_BUFFER_SLOT_COUNT
end_ifndef
begin_define
DECL|macro|D3D11_SO_BUFFER_SLOT_COUNT
define|#
directive|define
name|D3D11_SO_BUFFER_SLOT_COUNT
value|4
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT
end_ifndef
begin_define
DECL|macro|D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT
define|#
directive|define
name|D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT
value|14
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT
end_ifndef
begin_define
DECL|macro|D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT
define|#
directive|define
name|D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT
value|16
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D11_COMMONSHADER_TEXEL_OFFSET_MAX_NEGATIVE
end_ifndef
begin_define
DECL|macro|D3D11_COMMONSHADER_TEXEL_OFFSET_MAX_NEGATIVE
define|#
directive|define
name|D3D11_COMMONSHADER_TEXEL_OFFSET_MAX_NEGATIVE
value|-8
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D11_COMMONSHADER_TEXEL_OFFSET_MAX_POSITIVE
end_ifndef
begin_define
DECL|macro|D3D11_COMMONSHADER_TEXEL_OFFSET_MAX_POSITIVE
define|#
directive|define
name|D3D11_COMMONSHADER_TEXEL_OFFSET_MAX_POSITIVE
value|7
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D11_REQ_CONSTANT_BUFFER_ELEMENT_COUNT
end_ifndef
begin_define
DECL|macro|D3D11_REQ_CONSTANT_BUFFER_ELEMENT_COUNT
define|#
directive|define
name|D3D11_REQ_CONSTANT_BUFFER_ELEMENT_COUNT
value|4096
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D11_PS_INPUT_REGISTER_COUNT
end_ifndef
begin_define
DECL|macro|D3D11_PS_INPUT_REGISTER_COUNT
define|#
directive|define
name|D3D11_PS_INPUT_REGISTER_COUNT
value|32
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|D3D10_1_VS_OUTPUT_REGISTER_COUNT
end_ifndef
begin_define
DECL|macro|D3D10_1_VS_OUTPUT_REGISTER_COUNT
define|#
directive|define
name|D3D10_1_VS_OUTPUT_REGISTER_COUNT
value|32
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|ANGLE_MINGW32_COMPAT
argument_list|)
end_if
begin_decl_stmt
DECL|variable|WKPDID_D3DDebugObjectName
specifier|static
specifier|const
name|IID
name|WKPDID_D3DDebugObjectName
init|=
block|{
literal|0x429b8c22
block|,
literal|0x9188
block|,
literal|0x4b0c
block|,
literal|0x87
block|,
literal|0x42
block|,
literal|0xac
block|,
literal|0xb0
block|,
literal|0xbf
block|,
literal|0x85
block|,
literal|0xc2
block|,
literal|0x00
block|}
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_namespace
DECL|namespace|rx
namespace|namespace
name|rx
block|{
DECL|namespace|gl_d3d11
namespace|namespace
name|gl_d3d11
block|{
DECL|function|ConvertBlendFunc
name|D3D11_BLEND
name|ConvertBlendFunc
parameter_list|(
name|GLenum
name|glBlend
parameter_list|,
name|bool
name|isAlpha
parameter_list|)
block|{
name|D3D11_BLEND
name|d3dBlend
init|=
name|D3D11_BLEND_ZERO
decl_stmt|;
switch|switch
condition|(
name|glBlend
condition|)
block|{
case|case
name|GL_ZERO
case|:
name|d3dBlend
operator|=
name|D3D11_BLEND_ZERO
expr_stmt|;
break|break;
case|case
name|GL_ONE
case|:
name|d3dBlend
operator|=
name|D3D11_BLEND_ONE
expr_stmt|;
break|break;
case|case
name|GL_SRC_COLOR
case|:
name|d3dBlend
operator|=
operator|(
name|isAlpha
condition|?
name|D3D11_BLEND_SRC_ALPHA
else|:
name|D3D11_BLEND_SRC_COLOR
operator|)
expr_stmt|;
break|break;
case|case
name|GL_ONE_MINUS_SRC_COLOR
case|:
name|d3dBlend
operator|=
operator|(
name|isAlpha
condition|?
name|D3D11_BLEND_INV_SRC_ALPHA
else|:
name|D3D11_BLEND_INV_SRC_COLOR
operator|)
expr_stmt|;
break|break;
case|case
name|GL_DST_COLOR
case|:
name|d3dBlend
operator|=
operator|(
name|isAlpha
condition|?
name|D3D11_BLEND_DEST_ALPHA
else|:
name|D3D11_BLEND_DEST_COLOR
operator|)
expr_stmt|;
break|break;
case|case
name|GL_ONE_MINUS_DST_COLOR
case|:
name|d3dBlend
operator|=
operator|(
name|isAlpha
condition|?
name|D3D11_BLEND_INV_DEST_ALPHA
else|:
name|D3D11_BLEND_INV_DEST_COLOR
operator|)
expr_stmt|;
break|break;
case|case
name|GL_SRC_ALPHA
case|:
name|d3dBlend
operator|=
name|D3D11_BLEND_SRC_ALPHA
expr_stmt|;
break|break;
case|case
name|GL_ONE_MINUS_SRC_ALPHA
case|:
name|d3dBlend
operator|=
name|D3D11_BLEND_INV_SRC_ALPHA
expr_stmt|;
break|break;
case|case
name|GL_DST_ALPHA
case|:
name|d3dBlend
operator|=
name|D3D11_BLEND_DEST_ALPHA
expr_stmt|;
break|break;
case|case
name|GL_ONE_MINUS_DST_ALPHA
case|:
name|d3dBlend
operator|=
name|D3D11_BLEND_INV_DEST_ALPHA
expr_stmt|;
break|break;
case|case
name|GL_CONSTANT_COLOR
case|:
name|d3dBlend
operator|=
name|D3D11_BLEND_BLEND_FACTOR
expr_stmt|;
break|break;
case|case
name|GL_ONE_MINUS_CONSTANT_COLOR
case|:
name|d3dBlend
operator|=
name|D3D11_BLEND_INV_BLEND_FACTOR
expr_stmt|;
break|break;
case|case
name|GL_CONSTANT_ALPHA
case|:
name|d3dBlend
operator|=
name|D3D11_BLEND_BLEND_FACTOR
expr_stmt|;
break|break;
case|case
name|GL_ONE_MINUS_CONSTANT_ALPHA
case|:
name|d3dBlend
operator|=
name|D3D11_BLEND_INV_BLEND_FACTOR
expr_stmt|;
break|break;
case|case
name|GL_SRC_ALPHA_SATURATE
case|:
name|d3dBlend
operator|=
name|D3D11_BLEND_SRC_ALPHA_SAT
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
name|d3dBlend
return|;
block|}
DECL|function|ConvertBlendOp
name|D3D11_BLEND_OP
name|ConvertBlendOp
parameter_list|(
name|GLenum
name|glBlendOp
parameter_list|)
block|{
name|D3D11_BLEND_OP
name|d3dBlendOp
init|=
name|D3D11_BLEND_OP_ADD
decl_stmt|;
switch|switch
condition|(
name|glBlendOp
condition|)
block|{
case|case
name|GL_FUNC_ADD
case|:
name|d3dBlendOp
operator|=
name|D3D11_BLEND_OP_ADD
expr_stmt|;
break|break;
case|case
name|GL_FUNC_SUBTRACT
case|:
name|d3dBlendOp
operator|=
name|D3D11_BLEND_OP_SUBTRACT
expr_stmt|;
break|break;
case|case
name|GL_FUNC_REVERSE_SUBTRACT
case|:
name|d3dBlendOp
operator|=
name|D3D11_BLEND_OP_REV_SUBTRACT
expr_stmt|;
break|break;
case|case
name|GL_MIN
case|:
name|d3dBlendOp
operator|=
name|D3D11_BLEND_OP_MIN
expr_stmt|;
break|break;
case|case
name|GL_MAX
case|:
name|d3dBlendOp
operator|=
name|D3D11_BLEND_OP_MAX
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
name|d3dBlendOp
return|;
block|}
DECL|function|ConvertColorMask
name|UINT8
name|ConvertColorMask
parameter_list|(
name|bool
name|red
parameter_list|,
name|bool
name|green
parameter_list|,
name|bool
name|blue
parameter_list|,
name|bool
name|alpha
parameter_list|)
block|{
name|UINT8
name|mask
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|red
condition|)
block|{
name|mask
operator||=
name|D3D11_COLOR_WRITE_ENABLE_RED
expr_stmt|;
block|}
if|if
condition|(
name|green
condition|)
block|{
name|mask
operator||=
name|D3D11_COLOR_WRITE_ENABLE_GREEN
expr_stmt|;
block|}
if|if
condition|(
name|blue
condition|)
block|{
name|mask
operator||=
name|D3D11_COLOR_WRITE_ENABLE_BLUE
expr_stmt|;
block|}
if|if
condition|(
name|alpha
condition|)
block|{
name|mask
operator||=
name|D3D11_COLOR_WRITE_ENABLE_ALPHA
expr_stmt|;
block|}
return|return
name|mask
return|;
block|}
DECL|function|ConvertCullMode
name|D3D11_CULL_MODE
name|ConvertCullMode
parameter_list|(
name|bool
name|cullEnabled
parameter_list|,
name|GLenum
name|cullMode
parameter_list|)
block|{
name|D3D11_CULL_MODE
name|cull
init|=
name|D3D11_CULL_NONE
decl_stmt|;
if|if
condition|(
name|cullEnabled
condition|)
block|{
switch|switch
condition|(
name|cullMode
condition|)
block|{
case|case
name|GL_FRONT
case|:
name|cull
operator|=
name|D3D11_CULL_FRONT
expr_stmt|;
break|break;
case|case
name|GL_BACK
case|:
name|cull
operator|=
name|D3D11_CULL_BACK
expr_stmt|;
break|break;
case|case
name|GL_FRONT_AND_BACK
case|:
name|cull
operator|=
name|D3D11_CULL_NONE
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|cull
operator|=
name|D3D11_CULL_NONE
expr_stmt|;
block|}
return|return
name|cull
return|;
block|}
DECL|function|ConvertComparison
name|D3D11_COMPARISON_FUNC
name|ConvertComparison
parameter_list|(
name|GLenum
name|comparison
parameter_list|)
block|{
name|D3D11_COMPARISON_FUNC
name|d3dComp
init|=
name|D3D11_COMPARISON_NEVER
decl_stmt|;
switch|switch
condition|(
name|comparison
condition|)
block|{
case|case
name|GL_NEVER
case|:
name|d3dComp
operator|=
name|D3D11_COMPARISON_NEVER
expr_stmt|;
break|break;
case|case
name|GL_ALWAYS
case|:
name|d3dComp
operator|=
name|D3D11_COMPARISON_ALWAYS
expr_stmt|;
break|break;
case|case
name|GL_LESS
case|:
name|d3dComp
operator|=
name|D3D11_COMPARISON_LESS
expr_stmt|;
break|break;
case|case
name|GL_LEQUAL
case|:
name|d3dComp
operator|=
name|D3D11_COMPARISON_LESS_EQUAL
expr_stmt|;
break|break;
case|case
name|GL_EQUAL
case|:
name|d3dComp
operator|=
name|D3D11_COMPARISON_EQUAL
expr_stmt|;
break|break;
case|case
name|GL_GREATER
case|:
name|d3dComp
operator|=
name|D3D11_COMPARISON_GREATER
expr_stmt|;
break|break;
case|case
name|GL_GEQUAL
case|:
name|d3dComp
operator|=
name|D3D11_COMPARISON_GREATER_EQUAL
expr_stmt|;
break|break;
case|case
name|GL_NOTEQUAL
case|:
name|d3dComp
operator|=
name|D3D11_COMPARISON_NOT_EQUAL
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
name|d3dComp
return|;
block|}
DECL|function|ConvertDepthMask
name|D3D11_DEPTH_WRITE_MASK
name|ConvertDepthMask
parameter_list|(
name|bool
name|depthWriteEnabled
parameter_list|)
block|{
return|return
name|depthWriteEnabled
condition|?
name|D3D11_DEPTH_WRITE_MASK_ALL
else|:
name|D3D11_DEPTH_WRITE_MASK_ZERO
return|;
block|}
DECL|function|ConvertStencilMask
name|UINT8
name|ConvertStencilMask
parameter_list|(
name|GLuint
name|stencilmask
parameter_list|)
block|{
return|return
cast|static_cast
argument_list|<
name|UINT8
argument_list|>
argument_list|(
name|stencilmask
argument_list|)
return|;
block|}
DECL|function|ConvertStencilOp
name|D3D11_STENCIL_OP
name|ConvertStencilOp
parameter_list|(
name|GLenum
name|stencilOp
parameter_list|)
block|{
name|D3D11_STENCIL_OP
name|d3dStencilOp
init|=
name|D3D11_STENCIL_OP_KEEP
decl_stmt|;
switch|switch
condition|(
name|stencilOp
condition|)
block|{
case|case
name|GL_ZERO
case|:
name|d3dStencilOp
operator|=
name|D3D11_STENCIL_OP_ZERO
expr_stmt|;
break|break;
case|case
name|GL_KEEP
case|:
name|d3dStencilOp
operator|=
name|D3D11_STENCIL_OP_KEEP
expr_stmt|;
break|break;
case|case
name|GL_REPLACE
case|:
name|d3dStencilOp
operator|=
name|D3D11_STENCIL_OP_REPLACE
expr_stmt|;
break|break;
case|case
name|GL_INCR
case|:
name|d3dStencilOp
operator|=
name|D3D11_STENCIL_OP_INCR_SAT
expr_stmt|;
break|break;
case|case
name|GL_DECR
case|:
name|d3dStencilOp
operator|=
name|D3D11_STENCIL_OP_DECR_SAT
expr_stmt|;
break|break;
case|case
name|GL_INVERT
case|:
name|d3dStencilOp
operator|=
name|D3D11_STENCIL_OP_INVERT
expr_stmt|;
break|break;
case|case
name|GL_INCR_WRAP
case|:
name|d3dStencilOp
operator|=
name|D3D11_STENCIL_OP_INCR
expr_stmt|;
break|break;
case|case
name|GL_DECR_WRAP
case|:
name|d3dStencilOp
operator|=
name|D3D11_STENCIL_OP_DECR
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
name|d3dStencilOp
return|;
block|}
DECL|function|ConvertFilter
name|D3D11_FILTER
name|ConvertFilter
parameter_list|(
name|GLenum
name|minFilter
parameter_list|,
name|GLenum
name|magFilter
parameter_list|,
name|float
name|maxAnisotropy
parameter_list|,
name|GLenum
name|comparisonMode
parameter_list|)
block|{
name|bool
name|comparison
init|=
name|comparisonMode
operator|!=
name|GL_NONE
decl_stmt|;
if|if
condition|(
name|maxAnisotropy
operator|>
literal|1.0f
condition|)
block|{
return|return
name|D3D11_ENCODE_ANISOTROPIC_FILTER
argument_list|(
cast|static_cast
argument_list|<
name|D3D11_COMPARISON_FUNC
argument_list|>
argument_list|(
name|comparison
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|D3D11_FILTER_TYPE
name|dxMin
init|=
name|D3D11_FILTER_TYPE_POINT
decl_stmt|;
name|D3D11_FILTER_TYPE
name|dxMip
init|=
name|D3D11_FILTER_TYPE_POINT
decl_stmt|;
switch|switch
condition|(
name|minFilter
condition|)
block|{
case|case
name|GL_NEAREST
case|:
name|dxMin
operator|=
name|D3D11_FILTER_TYPE_POINT
expr_stmt|;
name|dxMip
operator|=
name|D3D11_FILTER_TYPE_POINT
expr_stmt|;
break|break;
case|case
name|GL_LINEAR
case|:
name|dxMin
operator|=
name|D3D11_FILTER_TYPE_LINEAR
expr_stmt|;
name|dxMip
operator|=
name|D3D11_FILTER_TYPE_POINT
expr_stmt|;
break|break;
case|case
name|GL_NEAREST_MIPMAP_NEAREST
case|:
name|dxMin
operator|=
name|D3D11_FILTER_TYPE_POINT
expr_stmt|;
name|dxMip
operator|=
name|D3D11_FILTER_TYPE_POINT
expr_stmt|;
break|break;
case|case
name|GL_LINEAR_MIPMAP_NEAREST
case|:
name|dxMin
operator|=
name|D3D11_FILTER_TYPE_LINEAR
expr_stmt|;
name|dxMip
operator|=
name|D3D11_FILTER_TYPE_POINT
expr_stmt|;
break|break;
case|case
name|GL_NEAREST_MIPMAP_LINEAR
case|:
name|dxMin
operator|=
name|D3D11_FILTER_TYPE_POINT
expr_stmt|;
name|dxMip
operator|=
name|D3D11_FILTER_TYPE_LINEAR
expr_stmt|;
break|break;
case|case
name|GL_LINEAR_MIPMAP_LINEAR
case|:
name|dxMin
operator|=
name|D3D11_FILTER_TYPE_LINEAR
expr_stmt|;
name|dxMip
operator|=
name|D3D11_FILTER_TYPE_LINEAR
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
name|D3D11_FILTER_TYPE
name|dxMag
init|=
name|D3D11_FILTER_TYPE_POINT
decl_stmt|;
switch|switch
condition|(
name|magFilter
condition|)
block|{
case|case
name|GL_NEAREST
case|:
name|dxMag
operator|=
name|D3D11_FILTER_TYPE_POINT
expr_stmt|;
break|break;
case|case
name|GL_LINEAR
case|:
name|dxMag
operator|=
name|D3D11_FILTER_TYPE_LINEAR
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
name|D3D11_ENCODE_BASIC_FILTER
argument_list|(
name|dxMin
argument_list|,
name|dxMag
argument_list|,
name|dxMip
argument_list|,
cast|static_cast
argument_list|<
name|D3D11_COMPARISON_FUNC
argument_list|>
argument_list|(
name|comparison
argument_list|)
argument_list|)
return|;
block|}
block|}
DECL|function|ConvertTextureWrap
name|D3D11_TEXTURE_ADDRESS_MODE
name|ConvertTextureWrap
parameter_list|(
name|GLenum
name|wrap
parameter_list|)
block|{
switch|switch
condition|(
name|wrap
condition|)
block|{
case|case
name|GL_REPEAT
case|:
return|return
name|D3D11_TEXTURE_ADDRESS_WRAP
return|;
case|case
name|GL_CLAMP_TO_EDGE
case|:
return|return
name|D3D11_TEXTURE_ADDRESS_CLAMP
return|;
case|case
name|GL_MIRRORED_REPEAT
case|:
return|return
name|D3D11_TEXTURE_ADDRESS_MIRROR
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
name|D3D11_TEXTURE_ADDRESS_WRAP
return|;
block|}
DECL|function|ConvertQueryType
name|D3D11_QUERY
name|ConvertQueryType
parameter_list|(
name|GLenum
name|queryType
parameter_list|)
block|{
switch|switch
condition|(
name|queryType
condition|)
block|{
case|case
name|GL_ANY_SAMPLES_PASSED_EXT
case|:
case|case
name|GL_ANY_SAMPLES_PASSED_CONSERVATIVE_EXT
case|:
return|return
name|D3D11_QUERY_OCCLUSION
return|;
case|case
name|GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN
case|:
return|return
name|D3D11_QUERY_SO_STATISTICS
return|;
case|case
name|GL_TIME_ELAPSED_EXT
case|:
comment|// Two internal queries are also created for begin/end timestamps
return|return
name|D3D11_QUERY_TIMESTAMP_DISJOINT
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|D3D11_QUERY_EVENT
return|;
block|}
block|}
block|}
comment|// namespace gl_d3d11
DECL|namespace|d3d11_gl
namespace|namespace
name|d3d11_gl
block|{
namespace|namespace
block|{
comment|// Helper functor for querying DXGI support. Saves passing the parameters repeatedly.
DECL|class|DXGISupportHelper
class|class
name|DXGISupportHelper
super|:
name|angle
operator|::
name|NonCopyable
block|{
public|public:
DECL|function|DXGISupportHelper
name|DXGISupportHelper
parameter_list|(
name|ID3D11Device
modifier|*
name|device
parameter_list|,
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
member_init_list|:
name|mDevice
argument_list|(
name|device
argument_list|)
member_init_list|,
name|mFeatureLevel
argument_list|(
name|featureLevel
argument_list|)
block|{     }
DECL|function|query
name|bool
name|query
parameter_list|(
name|DXGI_FORMAT
name|dxgiFormat
parameter_list|,
name|UINT
name|supportMask
parameter_list|)
block|{
if|if
condition|(
name|dxgiFormat
operator|==
name|DXGI_FORMAT_UNKNOWN
condition|)
return|return
literal|false
return|;
name|auto
name|dxgiSupport
init|=
name|d3d11
operator|::
name|GetDXGISupport
argument_list|(
name|dxgiFormat
argument_list|,
name|mFeatureLevel
argument_list|)
decl_stmt|;
name|UINT
name|supportedBits
init|=
name|dxgiSupport
operator|.
name|alwaysSupportedFlags
decl_stmt|;
if|if
condition|(
operator|(
name|dxgiSupport
operator|.
name|optionallySupportedFlags
operator|&
name|supportMask
operator|)
operator|!=
literal|0
condition|)
block|{
name|UINT
name|formatSupport
decl_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|mDevice
operator|->
name|CheckFormatSupport
argument_list|(
name|dxgiFormat
argument_list|,
operator|&
name|formatSupport
argument_list|)
argument_list|)
condition|)
block|{
name|supportedBits
operator||=
operator|(
name|formatSupport
operator|&
name|supportMask
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|// TODO(jmadill): find out why we fail this call sometimes in FL9_3
comment|// ERR("Error checking format support for format 0x%x", dxgiFormat);
block|}
block|}
return|return
operator|(
operator|(
name|supportedBits
operator|&
name|supportMask
operator|)
operator|==
name|supportMask
operator|)
return|;
block|}
private|private:
DECL|member|mDevice
name|ID3D11Device
modifier|*
name|mDevice
decl_stmt|;
DECL|member|mFeatureLevel
name|D3D_FEATURE_LEVEL
name|mFeatureLevel
decl_stmt|;
block|}
class|;
block|}
comment|// anonymous namespace
DECL|function|GetReservedVertexUniformVectors
name|unsigned
name|int
name|GetReservedVertexUniformVectors
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
literal|0
return|;
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|3
return|;
comment|// dx_ViewAdjust, dx_ViewCoords and dx_ViewScale
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetReservedFragmentUniformVectors
name|unsigned
name|int
name|GetReservedFragmentUniformVectors
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
literal|0
return|;
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|3
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMaximumClientVersion
name|GLint
name|GetMaximumClientVersion
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
literal|3
return|;
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|2
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GenerateTextureFormatCaps
specifier|static
name|gl
operator|::
name|TextureCaps
name|GenerateTextureFormatCaps
parameter_list|(
name|GLint
name|maxClientVersion
parameter_list|,
name|GLenum
name|internalFormat
parameter_list|,
name|ID3D11Device
modifier|*
name|device
parameter_list|,
specifier|const
name|Renderer11DeviceCaps
modifier|&
name|renderer11DeviceCaps
parameter_list|)
block|{
name|gl
operator|::
name|TextureCaps
name|textureCaps
decl_stmt|;
name|DXGISupportHelper
name|support
argument_list|(
name|device
argument_list|,
name|renderer11DeviceCaps
operator|.
name|featureLevel
argument_list|)
decl_stmt|;
specifier|const
name|d3d11
operator|::
name|TextureFormat
modifier|&
name|formatInfo
init|=
name|d3d11
operator|::
name|GetTextureFormatInfo
argument_list|(
name|internalFormat
argument_list|,
name|renderer11DeviceCaps
argument_list|)
decl_stmt|;
specifier|const
name|gl
operator|::
name|InternalFormat
modifier|&
name|internalFormatInfo
init|=
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|internalFormat
argument_list|)
decl_stmt|;
name|UINT
name|texSupportMask
init|=
name|D3D11_FORMAT_SUPPORT_TEXTURE2D
decl_stmt|;
if|if
condition|(
name|internalFormatInfo
operator|.
name|depthBits
operator|==
literal|0
operator|&&
name|internalFormatInfo
operator|.
name|stencilBits
operator|==
literal|0
condition|)
block|{
name|texSupportMask
operator||=
name|D3D11_FORMAT_SUPPORT_TEXTURECUBE
expr_stmt|;
if|if
condition|(
name|maxClientVersion
operator|>
literal|2
condition|)
block|{
name|texSupportMask
operator||=
name|D3D11_FORMAT_SUPPORT_TEXTURE3D
expr_stmt|;
block|}
block|}
name|textureCaps
operator|.
name|texturable
operator|=
name|support
operator|.
name|query
argument_list|(
name|formatInfo
operator|.
name|texFormat
argument_list|,
name|texSupportMask
argument_list|)
expr_stmt|;
name|textureCaps
operator|.
name|filterable
operator|=
name|support
operator|.
name|query
argument_list|(
name|formatInfo
operator|.
name|srvFormat
argument_list|,
name|D3D11_FORMAT_SUPPORT_SHADER_SAMPLE
argument_list|)
expr_stmt|;
name|textureCaps
operator|.
name|renderable
operator|=
operator|(
name|support
operator|.
name|query
argument_list|(
name|formatInfo
operator|.
name|rtvFormat
argument_list|,
name|D3D11_FORMAT_SUPPORT_RENDER_TARGET
argument_list|)
operator|)
operator|||
operator|(
name|support
operator|.
name|query
argument_list|(
name|formatInfo
operator|.
name|dsvFormat
argument_list|,
name|D3D11_FORMAT_SUPPORT_DEPTH_STENCIL
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|support
operator|.
name|query
argument_list|(
name|formatInfo
operator|.
name|renderFormat
argument_list|,
name|D3D11_FORMAT_SUPPORT_MULTISAMPLE_RENDERTARGET
argument_list|)
condition|)
block|{
comment|// Assume 1x
name|textureCaps
operator|.
name|sampleCounts
operator|.
name|insert
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|sampleCount
init|=
literal|2
init|;
name|sampleCount
operator|<=
name|D3D11_MAX_MULTISAMPLE_SAMPLE_COUNT
condition|;
name|sampleCount
operator|*=
literal|2
control|)
block|{
name|UINT
name|qualityCount
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|device
operator|->
name|CheckMultisampleQualityLevels
argument_list|(
name|formatInfo
operator|.
name|renderFormat
argument_list|,
name|sampleCount
argument_list|,
operator|&
name|qualityCount
argument_list|)
argument_list|)
condition|)
block|{
comment|// Assume we always support lower sample counts
if|if
condition|(
name|qualityCount
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|textureCaps
operator|.
name|sampleCounts
operator|.
name|insert
argument_list|(
name|sampleCount
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|textureCaps
return|;
block|}
DECL|function|GetNPOTTextureSupport
specifier|static
name|bool
name|GetNPOTTextureSupport
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
literal|true
return|;
comment|// From http://msdn.microsoft.com/en-us/library/windows/desktop/ff476876.aspx
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|false
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|GetMaximumAnisotropy
specifier|static
name|float
name|GetMaximumAnisotropy
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_MAX_MAXANISOTROPY
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_MAX_MAXANISOTROPY
return|;
comment|// From http://msdn.microsoft.com/en-us/library/windows/desktop/ff476876.aspx
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
return|return
literal|16
return|;
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
name|D3D_FL9_1_DEFAULT_MAX_ANISOTROPY
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetOcclusionQuerySupport
specifier|static
name|bool
name|GetOcclusionQuerySupport
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
literal|true
return|;
comment|// From http://msdn.microsoft.com/en-us/library/windows/desktop/ff476150.aspx ID3D11Device::CreateQuery
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
return|return
literal|true
return|;
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|false
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|GetEventQuerySupport
specifier|static
name|bool
name|GetEventQuerySupport
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
comment|// From http://msdn.microsoft.com/en-us/library/windows/desktop/ff476150.aspx ID3D11Device::CreateQuery
switch|switch
condition|(
name|featureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|true
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|GetInstancingSupport
specifier|static
name|bool
name|GetInstancingSupport
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
comment|// From http://msdn.microsoft.com/en-us/library/windows/desktop/ff476150.aspx ID3D11Device::CreateInputLayout
switch|switch
condition|(
name|featureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
literal|true
return|;
comment|// Feature Level 9_3 supports instancing, but slot 0 in the input layout must not be instanced.
comment|// D3D9 has a similar restriction, where stream 0 must not be instanced.
comment|// This restriction can be worked around by remapping any non-instanced slot to slot 0.
comment|// This works because HLSL uses shader semantics to match the vertex inputs to the elements in the input layout, rather than the slots.
comment|// Note that we only support instancing via ANGLE_instanced_array on 9_3, since 9_3 doesn't support OpenGL ES 3.0
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
return|return
literal|true
return|;
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|false
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|GetFramebufferMultisampleSupport
specifier|static
name|bool
name|GetFramebufferMultisampleSupport
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
literal|true
return|;
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|false
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|GetFramebufferBlitSupport
specifier|static
name|bool
name|GetFramebufferBlitSupport
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
literal|true
return|;
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|false
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|GetDerivativeInstructionSupport
specifier|static
name|bool
name|GetDerivativeInstructionSupport
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
comment|// http://msdn.microsoft.com/en-us/library/windows/desktop/bb509588.aspx states that shader model
comment|// ps_2_x is required for the ddx (and other derivative functions).
comment|// http://msdn.microsoft.com/en-us/library/windows/desktop/ff476876.aspx states that feature level
comment|// 9.3 supports shader model ps_2_x.
switch|switch
condition|(
name|featureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
return|return
literal|true
return|;
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|false
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|GetShaderTextureLODSupport
specifier|static
name|bool
name|GetShaderTextureLODSupport
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
literal|true
return|;
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|false
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|GetMaximumSimultaneousRenderTargets
specifier|static
name|size_t
name|GetMaximumSimultaneousRenderTargets
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
comment|// From http://msdn.microsoft.com/en-us/library/windows/desktop/ff476150.aspx ID3D11Device::CreateInputLayout
switch|switch
condition|(
name|featureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_SIMULTANEOUS_RENDER_TARGET_COUNT
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_SIMULTANEOUS_RENDER_TARGET_COUNT
return|;
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
return|return
name|D3D_FL9_3_SIMULTANEOUS_RENDER_TARGET_COUNT
return|;
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
name|D3D_FL9_1_SIMULTANEOUS_RENDER_TARGET_COUNT
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMaximum2DTextureSize
specifier|static
name|size_t
name|GetMaximum2DTextureSize
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_REQ_TEXTURE2D_U_OR_V_DIMENSION
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_REQ_TEXTURE2D_U_OR_V_DIMENSION
return|;
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
return|return
name|D3D_FL9_3_REQ_TEXTURE2D_U_OR_V_DIMENSION
return|;
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
name|D3D_FL9_1_REQ_TEXTURE2D_U_OR_V_DIMENSION
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMaximumCubeMapTextureSize
specifier|static
name|size_t
name|GetMaximumCubeMapTextureSize
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|ANGLE_ENABLE_D3D11_1
argument_list|)
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
endif|#
directive|endif
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_REQ_TEXTURECUBE_DIMENSION
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_REQ_TEXTURECUBE_DIMENSION
return|;
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
return|return
name|D3D_FL9_3_REQ_TEXTURECUBE_DIMENSION
return|;
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
name|D3D_FL9_1_REQ_TEXTURECUBE_DIMENSION
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMaximum2DTextureArraySize
specifier|static
name|size_t
name|GetMaximum2DTextureArraySize
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|ANGLE_ENABLE_D3D11_1
argument_list|)
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
endif|#
directive|endif
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_REQ_TEXTURE2D_ARRAY_AXIS_DIMENSION
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_REQ_TEXTURE2D_ARRAY_AXIS_DIMENSION
return|;
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|0
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMaximum3DTextureSize
specifier|static
name|size_t
name|GetMaximum3DTextureSize
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_REQ_TEXTURE3D_U_V_OR_W_DIMENSION
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_REQ_TEXTURE3D_U_V_OR_W_DIMENSION
return|;
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
name|D3D_FL9_1_REQ_TEXTURE3D_U_V_OR_W_DIMENSION
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMaximumViewportSize
specifier|static
name|size_t
name|GetMaximumViewportSize
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_VIEWPORT_BOUNDS_MAX
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_VIEWPORT_BOUNDS_MAX
return|;
comment|// No constants for D3D11 Feature Level 9 viewport size limits, use the maximum texture sizes
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
return|return
name|D3D_FL9_3_REQ_TEXTURE2D_U_OR_V_DIMENSION
return|;
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
name|D3D_FL9_1_REQ_TEXTURE2D_U_OR_V_DIMENSION
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMaximumDrawIndexedIndexCount
specifier|static
name|size_t
name|GetMaximumDrawIndexedIndexCount
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
comment|// D3D11 allows up to 2^32 elements, but we report max signed int for convenience since that's what's
comment|// returned from glGetInteger
assert|static_assert
argument_list|(
name|D3D11_REQ_DRAWINDEXED_INDEX_COUNT_2_TO_EXP
operator|==
literal|32
argument_list|,
literal|"Unexpected D3D11 constant value."
argument_list|)
assert|;
assert|static_assert
argument_list|(
name|D3D10_REQ_DRAWINDEXED_INDEX_COUNT_2_TO_EXP
operator|==
literal|32
argument_list|,
literal|"Unexpected D3D11 constant value."
argument_list|)
assert|;
switch|switch
condition|(
name|featureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|std
operator|::
name|numeric_limits
argument_list|<
name|GLint
argument_list|>
operator|::
name|max
argument_list|()
return|;
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
return|return
name|D3D_FL9_2_IA_PRIMITIVE_MAX_COUNT
return|;
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
name|D3D_FL9_1_IA_PRIMITIVE_MAX_COUNT
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMaximumDrawVertexCount
specifier|static
name|size_t
name|GetMaximumDrawVertexCount
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
comment|// D3D11 allows up to 2^32 elements, but we report max signed int for convenience since that's what's
comment|// returned from glGetInteger
assert|static_assert
argument_list|(
name|D3D11_REQ_DRAW_VERTEX_COUNT_2_TO_EXP
operator|==
literal|32
argument_list|,
literal|"Unexpected D3D11 constant value."
argument_list|)
assert|;
assert|static_assert
argument_list|(
name|D3D10_REQ_DRAW_VERTEX_COUNT_2_TO_EXP
operator|==
literal|32
argument_list|,
literal|"Unexpected D3D11 constant value."
argument_list|)
assert|;
switch|switch
condition|(
name|featureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|std
operator|::
name|numeric_limits
argument_list|<
name|GLint
argument_list|>
operator|::
name|max
argument_list|()
return|;
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
return|return
name|D3D_FL9_2_IA_PRIMITIVE_MAX_COUNT
return|;
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
name|D3D_FL9_1_IA_PRIMITIVE_MAX_COUNT
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMaximumVertexInputSlots
specifier|static
name|size_t
name|GetMaximumVertexInputSlots
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_STANDARD_VERTEX_ELEMENT_COUNT
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
return|return
name|D3D10_1_STANDARD_VERTEX_ELEMENT_COUNT
return|;
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_STANDARD_VERTEX_ELEMENT_COUNT
return|;
comment|// From http://http://msdn.microsoft.com/en-us/library/windows/desktop/ff476876.aspx "Max Input Slots"
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|16
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMaximumVertexUniformVectors
specifier|static
name|size_t
name|GetMaximumVertexUniformVectors
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
comment|// TODO(geofflang): Remove hard-coded limit once the gl-uniform-arrays test can pass
switch|switch
condition|(
name|featureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
literal|1024
return|;
comment|// D3D11_REQ_CONSTANT_BUFFER_ELEMENT_COUNT;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
literal|1024
return|;
comment|// D3D10_REQ_CONSTANT_BUFFER_ELEMENT_COUNT;
comment|// From http://msdn.microsoft.com/en-us/library/windows/desktop/ff476149.aspx ID3D11DeviceContext::VSSetConstantBuffers
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|255
operator|-
name|d3d11_gl
operator|::
name|GetReservedVertexUniformVectors
argument_list|(
name|featureLevel
argument_list|)
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetReservedVertexUniformBuffers
specifier|static
name|size_t
name|GetReservedVertexUniformBuffers
parameter_list|()
block|{
comment|// Reserve one buffer for the application uniforms, and one for driver uniforms
return|return
literal|2
return|;
block|}
DECL|function|GetMaximumVertexUniformBlocks
specifier|static
name|size_t
name|GetMaximumVertexUniformBlocks
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT
operator|-
name|GetReservedVertexUniformBuffers
argument_list|()
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT
operator|-
name|GetReservedVertexUniformBuffers
argument_list|()
return|;
comment|// Uniform blocks not supported on D3D11 Feature Level 9
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|0
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetReservedVertexOutputVectors
specifier|static
name|size_t
name|GetReservedVertexOutputVectors
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
comment|// According to The OpenGL ES Shading Language specifications
comment|// (Language Version 1.00 section 10.16, Language Version 3.10 section 12.21)
comment|// built-in special variables (e.g. gl_FragCoord, or gl_PointCoord)
comment|// which are statically used in the shader should be included in the variable packing algorithm.
comment|// Therefore, we should not reserve output vectors for them.
switch|switch
condition|(
name|featureLevel
condition|)
block|{
comment|// We must reserve one output vector for dx_Position.
comment|// We also reserve one for gl_Position, which we unconditionally output on Feature Levels 10_0+,
comment|// even if it's unused in the shader (e.g. for transform feedback). TODO: This could be improved.
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
literal|2
return|;
comment|// Just reserve dx_Position on Feature Level 9, since we don't ever need to output gl_Position.
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|1
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
DECL|function|GetMaximumVertexOutputVectors
specifier|static
name|size_t
name|GetMaximumVertexOutputVectors
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
assert|static_assert
argument_list|(
name|gl
operator|::
name|IMPLEMENTATION_MAX_VARYING_VECTORS
operator|==
name|D3D11_VS_OUTPUT_REGISTER_COUNT
argument_list|,
literal|"Unexpected D3D11 constant value."
argument_list|)
assert|;
switch|switch
condition|(
name|featureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_VS_OUTPUT_REGISTER_COUNT
operator|-
name|GetReservedVertexOutputVectors
argument_list|(
name|featureLevel
argument_list|)
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
return|return
name|D3D10_1_VS_OUTPUT_REGISTER_COUNT
operator|-
name|GetReservedVertexOutputVectors
argument_list|(
name|featureLevel
argument_list|)
return|;
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_VS_OUTPUT_REGISTER_COUNT
operator|-
name|GetReservedVertexOutputVectors
argument_list|(
name|featureLevel
argument_list|)
return|;
comment|// Use Shader Model 2.X limits
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|8
operator|-
name|GetReservedVertexOutputVectors
argument_list|(
name|featureLevel
argument_list|)
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMaximumVertexTextureUnits
specifier|static
name|size_t
name|GetMaximumVertexTextureUnits
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_COMMONSHADER_SAMPLER_SLOT_COUNT
return|;
comment|// Vertex textures not supported on D3D11 Feature Level 9 according to
comment|// http://msdn.microsoft.com/en-us/library/windows/desktop/ff476149.aspx
comment|// ID3D11DeviceContext::VSSetSamplers and ID3D11DeviceContext::VSSetShaderResources
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|0
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMaximumPixelUniformVectors
specifier|static
name|size_t
name|GetMaximumPixelUniformVectors
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
comment|// TODO(geofflang): Remove hard-coded limit once the gl-uniform-arrays test can pass
switch|switch
condition|(
name|featureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
literal|1024
return|;
comment|// D3D11_REQ_CONSTANT_BUFFER_ELEMENT_COUNT;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
literal|1024
return|;
comment|// D3D10_REQ_CONSTANT_BUFFER_ELEMENT_COUNT;
comment|// From http://msdn.microsoft.com/en-us/library/windows/desktop/ff476149.aspx ID3D11DeviceContext::PSSetConstantBuffers
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|32
operator|-
name|d3d11_gl
operator|::
name|GetReservedFragmentUniformVectors
argument_list|(
name|featureLevel
argument_list|)
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetReservedPixelUniformBuffers
specifier|static
name|size_t
name|GetReservedPixelUniformBuffers
parameter_list|()
block|{
comment|// Reserve one buffer for the application uniforms, and one for driver uniforms
return|return
literal|2
return|;
block|}
DECL|function|GetMaximumPixelUniformBlocks
specifier|static
name|size_t
name|GetMaximumPixelUniformBlocks
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT
operator|-
name|GetReservedPixelUniformBuffers
argument_list|()
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT
operator|-
name|GetReservedPixelUniformBuffers
argument_list|()
return|;
comment|// Uniform blocks not supported on D3D11 Feature Level 9
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|0
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMaximumPixelInputVectors
specifier|static
name|size_t
name|GetMaximumPixelInputVectors
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_PS_INPUT_REGISTER_COUNT
operator|-
name|GetReservedVertexOutputVectors
argument_list|(
name|featureLevel
argument_list|)
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_PS_INPUT_REGISTER_COUNT
operator|-
name|GetReservedVertexOutputVectors
argument_list|(
name|featureLevel
argument_list|)
return|;
comment|// Use Shader Model 2.X limits
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
return|return
literal|8
operator|-
name|GetReservedVertexOutputVectors
argument_list|(
name|featureLevel
argument_list|)
return|;
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|8
operator|-
name|GetReservedVertexOutputVectors
argument_list|(
name|featureLevel
argument_list|)
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMaximumPixelTextureUnits
specifier|static
name|size_t
name|GetMaximumPixelTextureUnits
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_COMMONSHADER_SAMPLER_SLOT_COUNT
return|;
comment|// http://msdn.microsoft.com/en-us/library/windows/desktop/ff476149.aspx ID3D11DeviceContext::PSSetShaderResources
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|16
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMinimumTexelOffset
specifier|static
name|int
name|GetMinimumTexelOffset
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_COMMONSHADER_TEXEL_OFFSET_MAX_NEGATIVE
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_COMMONSHADER_TEXEL_OFFSET_MAX_NEGATIVE
return|;
comment|// Sampling functions with offsets are not available below shader model 4.0.
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|0
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMaximumTexelOffset
specifier|static
name|int
name|GetMaximumTexelOffset
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_COMMONSHADER_TEXEL_OFFSET_MAX_POSITIVE
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D11_COMMONSHADER_TEXEL_OFFSET_MAX_POSITIVE
return|;
comment|// Sampling functions with offsets are not available below shader model 4.0.
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|0
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMaximumConstantBufferSize
specifier|static
name|size_t
name|GetMaximumConstantBufferSize
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
comment|// Returns a size_t despite the limit being a GLuint64 because size_t is the maximum size of
comment|// any buffer that could be allocated.
specifier|const
name|size_t
name|bytesPerComponent
init|=
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|float
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|featureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_REQ_CONSTANT_BUFFER_ELEMENT_COUNT
operator|*
name|bytesPerComponent
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_REQ_CONSTANT_BUFFER_ELEMENT_COUNT
operator|*
name|bytesPerComponent
return|;
comment|// Limits from http://msdn.microsoft.com/en-us/library/windows/desktop/ff476501.aspx remarks section
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|4096
operator|*
name|bytesPerComponent
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMaximumStreamOutputBuffers
specifier|static
name|size_t
name|GetMaximumStreamOutputBuffers
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|D3D11_SO_BUFFER_SLOT_COUNT
return|;
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
return|return
name|D3D10_1_SO_BUFFER_SLOT_COUNT
return|;
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|D3D10_SO_BUFFER_SLOT_COUNT
return|;
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|0
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMaximumStreamOutputInterleavedComponents
specifier|static
name|size_t
name|GetMaximumStreamOutputInterleavedComponents
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
name|GetMaximumVertexOutputVectors
argument_list|(
name|featureLevel
argument_list|)
operator|*
literal|4
return|;
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|0
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GetMaximumStreamOutputSeparateComponents
specifier|static
name|size_t
name|GetMaximumStreamOutputSeparateComponents
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
switch|switch
condition|(
name|featureLevel
condition|)
block|{
case|case
name|D3D_FEATURE_LEVEL_11_1
case|:
case|case
name|D3D_FEATURE_LEVEL_11_0
case|:
return|return
name|GetMaximumStreamOutputInterleavedComponents
argument_list|(
name|featureLevel
argument_list|)
operator|/
name|GetMaximumStreamOutputBuffers
argument_list|(
name|featureLevel
argument_list|)
return|;
comment|// D3D 10 and 10.1 only allow one output per output slot if an output slot other than zero is used.
case|case
name|D3D_FEATURE_LEVEL_10_1
case|:
case|case
name|D3D_FEATURE_LEVEL_10_0
case|:
return|return
literal|4
return|;
case|case
name|D3D_FEATURE_LEVEL_9_3
case|:
case|case
name|D3D_FEATURE_LEVEL_9_2
case|:
case|case
name|D3D_FEATURE_LEVEL_9_1
case|:
return|return
literal|0
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|GenerateCaps
name|void
name|GenerateCaps
parameter_list|(
name|ID3D11Device
modifier|*
name|device
parameter_list|,
name|ID3D11DeviceContext
modifier|*
name|deviceContext
parameter_list|,
specifier|const
name|Renderer11DeviceCaps
modifier|&
name|renderer11DeviceCaps
parameter_list|,
name|gl
operator|::
name|Caps
modifier|*
name|caps
parameter_list|,
name|gl
operator|::
name|TextureCapsMap
modifier|*
name|textureCapsMap
parameter_list|,
name|gl
operator|::
name|Extensions
modifier|*
name|extensions
parameter_list|,
name|gl
operator|::
name|Limitations
modifier|*
name|limitations
parameter_list|)
block|{
name|GLuint
name|maxSamples
init|=
literal|0
decl_stmt|;
name|D3D_FEATURE_LEVEL
name|featureLevel
init|=
name|renderer11DeviceCaps
operator|.
name|featureLevel
decl_stmt|;
specifier|const
name|gl
operator|::
name|FormatSet
modifier|&
name|allFormats
init|=
name|gl
operator|::
name|GetAllSizedInternalFormats
argument_list|()
decl_stmt|;
for|for
control|(
name|gl
operator|::
name|FormatSet
operator|::
name|const_iterator
name|internalFormat
init|=
name|allFormats
operator|.
name|begin
argument_list|()
init|;
name|internalFormat
operator|!=
name|allFormats
operator|.
name|end
argument_list|()
condition|;
operator|++
name|internalFormat
control|)
block|{
name|gl
operator|::
name|TextureCaps
name|textureCaps
init|=
name|GenerateTextureFormatCaps
argument_list|(
name|GetMaximumClientVersion
argument_list|(
name|featureLevel
argument_list|)
argument_list|,
operator|*
name|internalFormat
argument_list|,
name|device
argument_list|,
name|renderer11DeviceCaps
argument_list|)
decl_stmt|;
name|textureCapsMap
operator|->
name|insert
argument_list|(
operator|*
name|internalFormat
argument_list|,
name|textureCaps
argument_list|)
expr_stmt|;
name|maxSamples
operator|=
name|std
operator|::
name|max
argument_list|(
name|maxSamples
argument_list|,
name|textureCaps
operator|.
name|getMaxSamples
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
operator|*
name|internalFormat
argument_list|)
operator|.
name|compressed
condition|)
block|{
name|caps
operator|->
name|compressedTextureFormats
operator|.
name|push_back
argument_list|(
operator|*
name|internalFormat
argument_list|)
expr_stmt|;
block|}
block|}
comment|// GL core feature limits
comment|// Reserve MAX_UINT for D3D11's primitive restart.
name|caps
operator|->
name|maxElementIndex
operator|=
expr|static_cast
operator|<
name|GLint64
operator|>
operator|(
name|std
operator|::
name|numeric_limits
argument_list|<
name|unsigned
name|int
argument_list|>
operator|::
name|max
argument_list|()
operator|-
literal|1
operator|)
expr_stmt|;
name|caps
operator|->
name|max3DTextureSize
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|GetMaximum3DTextureSize
argument_list|(
name|featureLevel
argument_list|)
argument_list|)
expr_stmt|;
name|caps
operator|->
name|max2DTextureSize
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|GetMaximum2DTextureSize
argument_list|(
name|featureLevel
argument_list|)
argument_list|)
expr_stmt|;
name|caps
operator|->
name|maxCubeMapTextureSize
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|GetMaximumCubeMapTextureSize
argument_list|(
name|featureLevel
argument_list|)
argument_list|)
expr_stmt|;
name|caps
operator|->
name|maxArrayTextureLayers
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|GetMaximum2DTextureArraySize
argument_list|(
name|featureLevel
argument_list|)
argument_list|)
expr_stmt|;
comment|// Unimplemented, set to minimum required
name|caps
operator|->
name|maxLODBias
operator|=
literal|2.0f
expr_stmt|;
comment|// No specific limits on render target size, maximum 2D texture size is equivalent
name|caps
operator|->
name|maxRenderbufferSize
operator|=
name|caps
operator|->
name|max2DTextureSize
expr_stmt|;
comment|// Maximum draw buffers and color attachments are the same, max color attachments could eventually be
comment|// increased to 16
name|caps
operator|->
name|maxDrawBuffers
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|GetMaximumSimultaneousRenderTargets
argument_list|(
name|featureLevel
argument_list|)
argument_list|)
expr_stmt|;
name|caps
operator|->
name|maxColorAttachments
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|GetMaximumSimultaneousRenderTargets
argument_list|(
name|featureLevel
argument_list|)
argument_list|)
expr_stmt|;
comment|// D3D11 has the same limit for viewport width and height
name|caps
operator|->
name|maxViewportWidth
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|GetMaximumViewportSize
argument_list|(
name|featureLevel
argument_list|)
argument_list|)
expr_stmt|;
name|caps
operator|->
name|maxViewportHeight
operator|=
name|caps
operator|->
name|maxViewportWidth
expr_stmt|;
comment|// Choose a reasonable maximum, enforced in the shader.
name|caps
operator|->
name|minAliasedPointSize
operator|=
literal|1.0f
expr_stmt|;
name|caps
operator|->
name|maxAliasedPointSize
operator|=
literal|1024.0f
expr_stmt|;
comment|// Wide lines not supported
name|caps
operator|->
name|minAliasedLineWidth
operator|=
literal|1.0f
expr_stmt|;
name|caps
operator|->
name|maxAliasedLineWidth
operator|=
literal|1.0f
expr_stmt|;
comment|// Primitive count limits
name|caps
operator|->
name|maxElementsIndices
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|GetMaximumDrawIndexedIndexCount
argument_list|(
name|featureLevel
argument_list|)
argument_list|)
expr_stmt|;
name|caps
operator|->
name|maxElementsVertices
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|GetMaximumDrawVertexCount
argument_list|(
name|featureLevel
argument_list|)
argument_list|)
expr_stmt|;
comment|// Program and shader binary formats (no supported shader binary formats)
name|caps
operator|->
name|programBinaryFormats
operator|.
name|push_back
argument_list|(
name|GL_PROGRAM_BINARY_ANGLE
argument_list|)
expr_stmt|;
name|caps
operator|->
name|vertexHighpFloat
operator|.
name|setIEEEFloat
argument_list|()
expr_stmt|;
name|caps
operator|->
name|vertexMediumpFloat
operator|.
name|setIEEEFloat
argument_list|()
expr_stmt|;
name|caps
operator|->
name|vertexLowpFloat
operator|.
name|setIEEEFloat
argument_list|()
expr_stmt|;
name|caps
operator|->
name|fragmentHighpFloat
operator|.
name|setIEEEFloat
argument_list|()
expr_stmt|;
name|caps
operator|->
name|fragmentMediumpFloat
operator|.
name|setIEEEFloat
argument_list|()
expr_stmt|;
name|caps
operator|->
name|fragmentLowpFloat
operator|.
name|setIEEEFloat
argument_list|()
expr_stmt|;
comment|// 32-bit integers are natively supported
name|caps
operator|->
name|vertexHighpInt
operator|.
name|setTwosComplementInt
argument_list|(
literal|32
argument_list|)
expr_stmt|;
name|caps
operator|->
name|vertexMediumpInt
operator|.
name|setTwosComplementInt
argument_list|(
literal|32
argument_list|)
expr_stmt|;
name|caps
operator|->
name|vertexLowpInt
operator|.
name|setTwosComplementInt
argument_list|(
literal|32
argument_list|)
expr_stmt|;
name|caps
operator|->
name|fragmentHighpInt
operator|.
name|setTwosComplementInt
argument_list|(
literal|32
argument_list|)
expr_stmt|;
name|caps
operator|->
name|fragmentMediumpInt
operator|.
name|setTwosComplementInt
argument_list|(
literal|32
argument_list|)
expr_stmt|;
name|caps
operator|->
name|fragmentLowpInt
operator|.
name|setTwosComplementInt
argument_list|(
literal|32
argument_list|)
expr_stmt|;
comment|// We do not wait for server fence objects internally, so report a max timeout of zero.
name|caps
operator|->
name|maxServerWaitTimeout
operator|=
literal|0
expr_stmt|;
comment|// Vertex shader limits
name|caps
operator|->
name|maxVertexAttributes
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|GetMaximumVertexInputSlots
argument_list|(
name|featureLevel
argument_list|)
argument_list|)
expr_stmt|;
name|caps
operator|->
name|maxVertexUniformComponents
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|GetMaximumVertexUniformVectors
argument_list|(
name|featureLevel
argument_list|)
argument_list|)
operator|*
literal|4
expr_stmt|;
name|caps
operator|->
name|maxVertexUniformVectors
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|GetMaximumVertexUniformVectors
argument_list|(
name|featureLevel
argument_list|)
argument_list|)
expr_stmt|;
name|caps
operator|->
name|maxVertexUniformBlocks
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|GetMaximumVertexUniformBlocks
argument_list|(
name|featureLevel
argument_list|)
argument_list|)
expr_stmt|;
name|caps
operator|->
name|maxVertexOutputComponents
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|GetMaximumVertexOutputVectors
argument_list|(
name|featureLevel
argument_list|)
argument_list|)
operator|*
literal|4
expr_stmt|;
name|caps
operator|->
name|maxVertexTextureImageUnits
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|GetMaximumVertexTextureUnits
argument_list|(
name|featureLevel
argument_list|)
argument_list|)
expr_stmt|;
comment|// Fragment shader limits
name|caps
operator|->
name|maxFragmentUniformComponents
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|GetMaximumPixelUniformVectors
argument_list|(
name|featureLevel
argument_list|)
argument_list|)
operator|*
literal|4
expr_stmt|;
name|caps
operator|->
name|maxFragmentUniformVectors
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|GetMaximumPixelUniformVectors
argument_list|(
name|featureLevel
argument_list|)
argument_list|)
expr_stmt|;
name|caps
operator|->
name|maxFragmentUniformBlocks
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|GetMaximumPixelUniformBlocks
argument_list|(
name|featureLevel
argument_list|)
argument_list|)
expr_stmt|;
name|caps
operator|->
name|maxFragmentInputComponents
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|GetMaximumPixelInputVectors
argument_list|(
name|featureLevel
argument_list|)
argument_list|)
operator|*
literal|4
expr_stmt|;
name|caps
operator|->
name|maxTextureImageUnits
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|GetMaximumPixelTextureUnits
argument_list|(
name|featureLevel
argument_list|)
argument_list|)
expr_stmt|;
name|caps
operator|->
name|minProgramTexelOffset
operator|=
name|GetMinimumTexelOffset
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
name|caps
operator|->
name|maxProgramTexelOffset
operator|=
name|GetMaximumTexelOffset
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
comment|// Aggregate shader limits
name|caps
operator|->
name|maxUniformBufferBindings
operator|=
name|caps
operator|->
name|maxVertexUniformBlocks
operator|+
name|caps
operator|->
name|maxFragmentUniformBlocks
expr_stmt|;
name|caps
operator|->
name|maxUniformBlockSize
operator|=
name|GetMaximumConstantBufferSize
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
comment|// With DirectX 11.1, constant buffer offset and size must be a multiple of 16 constants of 16 bytes each.
comment|// https://msdn.microsoft.com/en-us/library/windows/desktop/hh404649%28v=vs.85%29.aspx
comment|// With DirectX 11.0, we emulate UBO offsets using copies of ranges of the UBO however
comment|// we still keep the same alignment as 11.1 for consistency.
name|caps
operator|->
name|uniformBufferOffsetAlignment
operator|=
literal|256
expr_stmt|;
name|caps
operator|->
name|maxCombinedUniformBlocks
operator|=
name|caps
operator|->
name|maxVertexUniformBlocks
operator|+
name|caps
operator|->
name|maxFragmentUniformBlocks
expr_stmt|;
name|caps
operator|->
name|maxCombinedVertexUniformComponents
operator|=
operator|(
cast|static_cast
argument_list|<
name|GLint64
argument_list|>
argument_list|(
name|caps
operator|->
name|maxVertexUniformBlocks
argument_list|)
operator|*
cast|static_cast
argument_list|<
name|GLint64
argument_list|>
argument_list|(
name|caps
operator|->
name|maxUniformBlockSize
operator|/
literal|4
argument_list|)
operator|)
operator|+
cast|static_cast
argument_list|<
name|GLint64
argument_list|>
argument_list|(
name|caps
operator|->
name|maxVertexUniformComponents
argument_list|)
expr_stmt|;
name|caps
operator|->
name|maxCombinedFragmentUniformComponents
operator|=
operator|(
cast|static_cast
argument_list|<
name|GLint64
argument_list|>
argument_list|(
name|caps
operator|->
name|maxFragmentUniformBlocks
argument_list|)
operator|*
cast|static_cast
argument_list|<
name|GLint64
argument_list|>
argument_list|(
name|caps
operator|->
name|maxUniformBlockSize
operator|/
literal|4
argument_list|)
operator|)
operator|+
cast|static_cast
argument_list|<
name|GLint64
argument_list|>
argument_list|(
name|caps
operator|->
name|maxFragmentUniformComponents
argument_list|)
expr_stmt|;
name|caps
operator|->
name|maxVaryingComponents
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|GetMaximumVertexOutputVectors
argument_list|(
name|featureLevel
argument_list|)
argument_list|)
operator|*
literal|4
expr_stmt|;
name|caps
operator|->
name|maxVaryingVectors
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|GetMaximumVertexOutputVectors
argument_list|(
name|featureLevel
argument_list|)
argument_list|)
expr_stmt|;
name|caps
operator|->
name|maxCombinedTextureImageUnits
operator|=
name|caps
operator|->
name|maxVertexTextureImageUnits
operator|+
name|caps
operator|->
name|maxTextureImageUnits
expr_stmt|;
comment|// Transform feedback limits
name|caps
operator|->
name|maxTransformFeedbackInterleavedComponents
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|GetMaximumStreamOutputInterleavedComponents
argument_list|(
name|featureLevel
argument_list|)
argument_list|)
expr_stmt|;
name|caps
operator|->
name|maxTransformFeedbackSeparateAttributes
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|GetMaximumStreamOutputBuffers
argument_list|(
name|featureLevel
argument_list|)
argument_list|)
expr_stmt|;
name|caps
operator|->
name|maxTransformFeedbackSeparateComponents
operator|=
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|GetMaximumStreamOutputSeparateComponents
argument_list|(
name|featureLevel
argument_list|)
argument_list|)
expr_stmt|;
comment|// Multisample limits
name|caps
operator|->
name|maxSamples
operator|=
name|maxSamples
expr_stmt|;
comment|// GL extension support
name|extensions
operator|->
name|setTextureExtensionSupport
argument_list|(
operator|*
name|textureCapsMap
argument_list|)
expr_stmt|;
name|extensions
operator|->
name|elementIndexUint
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|getProgramBinary
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|rgb8rgba8
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|readFormatBGRA
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|pixelBufferObject
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|mapBuffer
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|mapBufferRange
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|textureNPOT
operator|=
name|GetNPOTTextureSupport
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
name|extensions
operator|->
name|drawBuffers
operator|=
name|GetMaximumSimultaneousRenderTargets
argument_list|(
name|featureLevel
argument_list|)
operator|>
literal|1
expr_stmt|;
name|extensions
operator|->
name|textureStorage
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|textureFilterAnisotropic
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|maxTextureAnisotropy
operator|=
name|GetMaximumAnisotropy
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
name|extensions
operator|->
name|occlusionQueryBoolean
operator|=
name|GetOcclusionQuerySupport
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
name|extensions
operator|->
name|fence
operator|=
name|GetEventQuerySupport
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
name|extensions
operator|->
name|timerQuery
operator|=
literal|false
expr_stmt|;
comment|// Unimplemented
name|extensions
operator|->
name|disjointTimerQuery
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|queryCounterBitsTimeElapsed
operator|=
literal|64
expr_stmt|;
name|extensions
operator|->
name|queryCounterBitsTimestamp
operator|=
literal|0
expr_stmt|;
comment|// Timestamps cannot be supported due to D3D11 limitations
name|extensions
operator|->
name|robustness
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|blendMinMax
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|framebufferBlit
operator|=
name|GetFramebufferBlitSupport
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
name|extensions
operator|->
name|framebufferMultisample
operator|=
name|GetFramebufferMultisampleSupport
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
name|extensions
operator|->
name|instancedArrays
operator|=
name|GetInstancingSupport
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
name|extensions
operator|->
name|packReverseRowOrder
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|standardDerivatives
operator|=
name|GetDerivativeInstructionSupport
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
name|extensions
operator|->
name|shaderTextureLOD
operator|=
name|GetShaderTextureLODSupport
argument_list|(
name|featureLevel
argument_list|)
expr_stmt|;
name|extensions
operator|->
name|fragDepth
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|textureUsage
operator|=
literal|true
expr_stmt|;
comment|// This could be false since it has no effect in D3D11
name|extensions
operator|->
name|discardFramebuffer
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|translatedShaderSource
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|fboRenderMipmap
operator|=
literal|false
expr_stmt|;
name|extensions
operator|->
name|debugMarker
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|eglImage
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|unpackSubimage
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|packSubimage
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|vertexArrayObject
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|noError
operator|=
literal|true
expr_stmt|;
name|extensions
operator|->
name|lossyETCDecode
operator|=
literal|true
expr_stmt|;
comment|// D3D11 Feature Level 10_0+ uses SV_IsFrontFace in HLSL to emulate gl_FrontFacing.
comment|// D3D11 Feature Level 9_3 doesn't support SV_IsFrontFace, and has no equivalent, so can't support gl_FrontFacing.
name|limitations
operator|->
name|noFrontFacingSupport
operator|=
operator|(
name|renderer11DeviceCaps
operator|.
name|featureLevel
operator|<=
name|D3D_FEATURE_LEVEL_9_3
operator|)
expr_stmt|;
comment|// D3D11 Feature Level 9_3 doesn't support alpha-to-coverage
name|limitations
operator|->
name|noSampleAlphaToCoverageSupport
operator|=
operator|(
name|renderer11DeviceCaps
operator|.
name|featureLevel
operator|<=
name|D3D_FEATURE_LEVEL_9_3
operator|)
expr_stmt|;
comment|// D3D11 Feature Levels 9_3 and below do not support non-constant loop indexing and require
comment|// additional
comment|// pre-validation of the shader at compile time to produce a better error message.
name|limitations
operator|->
name|shadersRequireIndexedLoopValidation
operator|=
operator|(
name|renderer11DeviceCaps
operator|.
name|featureLevel
operator|<=
name|D3D_FEATURE_LEVEL_9_3
operator|)
expr_stmt|;
comment|// D3D11 has no concept of separate masks and refs for front and back faces in the depth stencil
comment|// state.
name|limitations
operator|->
name|noSeparateStencilRefsAndMasks
operator|=
literal|true
expr_stmt|;
comment|// D3D11 cannot support constant color and alpha blend funcs together
name|limitations
operator|->
name|noSimultaneousConstantColorAndAlphaBlendFunc
operator|=
literal|true
expr_stmt|;
ifdef|#
directive|ifdef
name|ANGLE_ENABLE_WINDOWS_STORE
comment|// Setting a non-zero divisor on attribute zero doesn't work on certain Windows Phone 8-era devices.
comment|// We should prevent developers from doing this on ALL Windows Store devices. This will maintain consistency across all Windows devices.
comment|// We allow non-zero divisors on attribute zero if the Client Version>= 3, since devices affected by this issue don't support ES3+.
name|limitations
operator|->
name|attributeZeroRequiresZeroDivisorInEXT
operator|=
literal|true
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|// namespace d3d11_gl
DECL|namespace|d3d11
namespace|namespace
name|d3d11
block|{
DECL|function|GetDeviceType
name|ANGLED3D11DeviceType
name|GetDeviceType
parameter_list|(
name|ID3D11Device
modifier|*
name|device
parameter_list|)
block|{
comment|// Note that this function returns an ANGLED3D11DeviceType rather than a D3D_DRIVER_TYPE value,
comment|// since it is difficult to tell Software and Reference devices apart
name|IDXGIDevice
modifier|*
name|dxgiDevice
init|=
literal|nullptr
decl_stmt|;
name|IDXGIAdapter
modifier|*
name|dxgiAdapter
init|=
literal|nullptr
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ANGLE_ENABLE_D3D11_1
argument_list|)
name|IDXGIAdapter2
modifier|*
name|dxgiAdapter2
init|=
literal|nullptr
decl_stmt|;
endif|#
directive|endif
name|ANGLED3D11DeviceType
name|retDeviceType
init|=
name|ANGLE_D3D11_DEVICE_TYPE_UNKNOWN
decl_stmt|;
name|HRESULT
name|hr
init|=
name|device
operator|->
name|QueryInterface
argument_list|(
name|__uuidof
argument_list|(
name|IDXGIDevice
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dxgiDevice
argument_list|)
decl_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|hr
argument_list|)
condition|)
block|{
name|hr
operator|=
name|dxgiDevice
operator|->
name|GetParent
argument_list|(
name|__uuidof
argument_list|(
name|IDXGIAdapter
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dxgiAdapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|hr
argument_list|)
condition|)
block|{
name|std
operator|::
name|wstring
name|adapterString
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ANGLE_ENABLE_D3D11_1
argument_list|)
name|HRESULT
name|adapter2hr
init|=
name|dxgiAdapter
operator|->
name|QueryInterface
argument_list|(
name|__uuidof
argument_list|(
name|dxgiAdapter2
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dxgiAdapter2
argument_list|)
decl_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|adapter2hr
argument_list|)
condition|)
block|{
comment|// On D3D_FEATURE_LEVEL_9_*, IDXGIAdapter::GetDesc returns "Software Adapter"
comment|// for the description string. Try to use IDXGIAdapter2::GetDesc2 to get the
comment|// actual hardware values if possible.
name|DXGI_ADAPTER_DESC2
name|adapterDesc2
decl_stmt|;
name|dxgiAdapter2
operator|->
name|GetDesc2
argument_list|(
operator|&
name|adapterDesc2
argument_list|)
expr_stmt|;
name|adapterString
operator|=
name|std
operator|::
name|wstring
argument_list|(
name|adapterDesc2
operator|.
name|Description
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|DXGI_ADAPTER_DESC
name|adapterDesc
decl_stmt|;
name|dxgiAdapter
operator|->
name|GetDesc
argument_list|(
operator|&
name|adapterDesc
argument_list|)
expr_stmt|;
name|adapterString
operator|=
name|std
operator|::
name|wstring
argument_list|(
name|adapterDesc
operator|.
name|Description
argument_list|)
expr_stmt|;
block|}
comment|// Both Reference and Software adapters will be 'Software Adapter'
specifier|const
name|bool
name|isSoftwareDevice
init|=
operator|(
name|adapterString
operator|.
name|find
argument_list|(
name|std
operator|::
name|wstring
argument_list|(
literal|L"Software Adapter"
argument_list|)
argument_list|)
operator|!=
name|std
operator|::
name|string
operator|::
name|npos
operator|)
decl_stmt|;
specifier|const
name|bool
name|isNullDevice
init|=
operator|(
name|adapterString
operator|==
literal|L""
operator|)
decl_stmt|;
specifier|const
name|bool
name|isWARPDevice
init|=
operator|(
name|adapterString
operator|.
name|find
argument_list|(
name|std
operator|::
name|wstring
argument_list|(
literal|L"Basic Render"
argument_list|)
argument_list|)
operator|!=
name|std
operator|::
name|string
operator|::
name|npos
operator|)
decl_stmt|;
if|if
condition|(
name|isSoftwareDevice
operator|||
name|isNullDevice
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|isWARPDevice
argument_list|)
expr_stmt|;
name|retDeviceType
operator|=
name|ANGLE_D3D11_DEVICE_TYPE_SOFTWARE_REF_OR_NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isWARPDevice
condition|)
block|{
name|retDeviceType
operator|=
name|ANGLE_D3D11_DEVICE_TYPE_WARP
expr_stmt|;
block|}
else|else
block|{
name|retDeviceType
operator|=
name|ANGLE_D3D11_DEVICE_TYPE_HARDWARE
expr_stmt|;
block|}
block|}
block|}
name|SafeRelease
argument_list|(
name|dxgiDevice
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|dxgiAdapter
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ANGLE_ENABLE_D3D11_1
argument_list|)
name|SafeRelease
argument_list|(
name|dxgiAdapter2
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|retDeviceType
return|;
block|}
DECL|function|MakeValidSize
name|void
name|MakeValidSize
parameter_list|(
name|bool
name|isImage
parameter_list|,
name|DXGI_FORMAT
name|format
parameter_list|,
name|GLsizei
modifier|*
name|requestWidth
parameter_list|,
name|GLsizei
modifier|*
name|requestHeight
parameter_list|,
name|int
modifier|*
name|levelOffset
parameter_list|)
block|{
specifier|const
name|DXGIFormat
modifier|&
name|dxgiFormatInfo
init|=
name|d3d11
operator|::
name|GetDXGIFormatInfo
argument_list|(
name|format
argument_list|)
decl_stmt|;
name|int
name|upsampleCount
init|=
literal|0
decl_stmt|;
comment|// Don't expand the size of full textures that are at least (blockWidth x blockHeight) already.
if|if
condition|(
name|isImage
operator|||
operator|*
name|requestWidth
operator|<
cast|static_cast
argument_list|<
name|GLsizei
argument_list|>
argument_list|(
name|dxgiFormatInfo
operator|.
name|blockWidth
argument_list|)
operator|||
operator|*
name|requestHeight
operator|<
cast|static_cast
argument_list|<
name|GLsizei
argument_list|>
argument_list|(
name|dxgiFormatInfo
operator|.
name|blockHeight
argument_list|)
condition|)
block|{
while|while
condition|(
operator|*
name|requestWidth
operator|%
name|dxgiFormatInfo
operator|.
name|blockWidth
operator|!=
literal|0
operator|||
operator|*
name|requestHeight
operator|%
name|dxgiFormatInfo
operator|.
name|blockHeight
operator|!=
literal|0
condition|)
block|{
operator|*
name|requestWidth
operator|<<=
literal|1
expr_stmt|;
operator|*
name|requestHeight
operator|<<=
literal|1
expr_stmt|;
name|upsampleCount
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|levelOffset
operator|=
name|upsampleCount
expr_stmt|;
block|}
DECL|function|GenerateInitialTextureData
name|void
name|GenerateInitialTextureData
parameter_list|(
name|GLint
name|internalFormat
parameter_list|,
specifier|const
name|Renderer11DeviceCaps
modifier|&
name|renderer11DeviceCaps
parameter_list|,
name|GLuint
name|width
parameter_list|,
name|GLuint
name|height
parameter_list|,
name|GLuint
name|depth
parameter_list|,
name|GLuint
name|mipLevels
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|D3D11_SUBRESOURCE_DATA
argument_list|>
modifier|*
name|outSubresourceData
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|std
operator|::
name|vector
argument_list|<
name|BYTE
argument_list|>
argument_list|>
modifier|*
name|outData
parameter_list|)
block|{
specifier|const
name|d3d11
operator|::
name|TextureFormat
modifier|&
name|d3dFormatInfo
init|=
name|d3d11
operator|::
name|GetTextureFormatInfo
argument_list|(
name|internalFormat
argument_list|,
name|renderer11DeviceCaps
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|d3dFormatInfo
operator|.
name|dataInitializerFunction
operator|!=
name|NULL
argument_list|)
expr_stmt|;
specifier|const
name|d3d11
operator|::
name|DXGIFormat
modifier|&
name|dxgiFormatInfo
init|=
name|d3d11
operator|::
name|GetDXGIFormatInfo
argument_list|(
name|d3dFormatInfo
operator|.
name|texFormat
argument_list|)
decl_stmt|;
name|outSubresourceData
operator|->
name|resize
argument_list|(
name|mipLevels
argument_list|)
expr_stmt|;
name|outData
operator|->
name|resize
argument_list|(
name|mipLevels
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mipLevels
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|mipWidth
init|=
name|std
operator|::
name|max
argument_list|(
name|width
operator|>>
name|i
argument_list|,
literal|1U
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|mipHeight
init|=
name|std
operator|::
name|max
argument_list|(
name|height
operator|>>
name|i
argument_list|,
literal|1U
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|mipDepth
init|=
name|std
operator|::
name|max
argument_list|(
name|depth
operator|>>
name|i
argument_list|,
literal|1U
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|rowWidth
init|=
name|dxgiFormatInfo
operator|.
name|pixelBytes
operator|*
name|mipWidth
decl_stmt|;
name|unsigned
name|int
name|imageSize
init|=
name|rowWidth
operator|*
name|height
decl_stmt|;
name|outData
operator|->
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|resize
argument_list|(
name|rowWidth
operator|*
name|mipHeight
operator|*
name|mipDepth
argument_list|)
expr_stmt|;
name|d3dFormatInfo
operator|.
name|dataInitializerFunction
argument_list|(
name|mipWidth
argument_list|,
name|mipHeight
argument_list|,
name|mipDepth
argument_list|,
name|outData
operator|->
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|data
argument_list|()
argument_list|,
name|rowWidth
argument_list|,
name|imageSize
argument_list|)
expr_stmt|;
name|outSubresourceData
operator|->
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|pSysMem
operator|=
name|outData
operator|->
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|data
argument_list|()
expr_stmt|;
name|outSubresourceData
operator|->
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|SysMemPitch
operator|=
name|rowWidth
expr_stmt|;
name|outSubresourceData
operator|->
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|SysMemSlicePitch
operator|=
name|imageSize
expr_stmt|;
block|}
block|}
DECL|function|GetPrimitiveRestartIndex
name|UINT
name|GetPrimitiveRestartIndex
parameter_list|()
block|{
return|return
name|std
operator|::
name|numeric_limits
argument_list|<
name|UINT
argument_list|>
operator|::
name|max
argument_list|()
return|;
block|}
DECL|function|SetPositionTexCoordVertex
name|void
name|SetPositionTexCoordVertex
parameter_list|(
name|PositionTexCoordVertex
modifier|*
name|vertex
parameter_list|,
name|float
name|x
parameter_list|,
name|float
name|y
parameter_list|,
name|float
name|u
parameter_list|,
name|float
name|v
parameter_list|)
block|{
name|vertex
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|vertex
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|vertex
operator|->
name|u
operator|=
name|u
expr_stmt|;
name|vertex
operator|->
name|v
operator|=
name|v
expr_stmt|;
block|}
DECL|function|SetPositionLayerTexCoord3DVertex
name|void
name|SetPositionLayerTexCoord3DVertex
parameter_list|(
name|PositionLayerTexCoord3DVertex
modifier|*
name|vertex
parameter_list|,
name|float
name|x
parameter_list|,
name|float
name|y
parameter_list|,
name|unsigned
name|int
name|layer
parameter_list|,
name|float
name|u
parameter_list|,
name|float
name|v
parameter_list|,
name|float
name|s
parameter_list|)
block|{
name|vertex
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|vertex
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|vertex
operator|->
name|l
operator|=
name|layer
expr_stmt|;
name|vertex
operator|->
name|u
operator|=
name|u
expr_stmt|;
name|vertex
operator|->
name|v
operator|=
name|v
expr_stmt|;
name|vertex
operator|->
name|s
operator|=
name|s
expr_stmt|;
block|}
DECL|function|SetDebugName
name|HRESULT
name|SetDebugName
parameter_list|(
name|ID3D11DeviceChild
modifier|*
name|resource
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_DEBUG
argument_list|)
name|UINT
name|existingDataSize
init|=
literal|0
decl_stmt|;
name|resource
operator|->
name|GetPrivateData
argument_list|(
name|WKPDID_D3DDebugObjectName
argument_list|,
operator|&
name|existingDataSize
argument_list|,
literal|nullptr
argument_list|)
expr_stmt|;
comment|// Don't check the HRESULT- if it failed then that probably just means that no private data
comment|// exists yet
if|if
condition|(
name|existingDataSize
operator|>
literal|0
condition|)
block|{
comment|// In some cases, ANGLE will try to apply two names to one object, which causes
comment|// a D3D SDK Layers warning. This can occur if, for example, you 'create' two objects
comment|// (e.g.Rasterizer States) with identical DESCs on the same device. D3D11 will optimize
comment|// these calls and return the same object both times.
specifier|static
specifier|const
name|char
modifier|*
name|multipleNamesUsed
init|=
literal|"Multiple names set by ANGLE"
decl_stmt|;
comment|// Remove the existing name
name|HRESULT
name|hr
init|=
name|resource
operator|->
name|SetPrivateData
argument_list|(
name|WKPDID_D3DDebugObjectName
argument_list|,
literal|0
argument_list|,
literal|nullptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|hr
argument_list|)
condition|)
block|{
return|return
name|hr
return|;
block|}
comment|// Apply the new name
return|return
name|resource
operator|->
name|SetPrivateData
argument_list|(
name|WKPDID_D3DDebugObjectName
argument_list|,
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|strlen
argument_list|(
name|multipleNamesUsed
argument_list|)
argument_list|)
argument_list|,
name|multipleNamesUsed
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|resource
operator|->
name|SetPrivateData
argument_list|(
name|WKPDID_D3DDebugObjectName
argument_list|,
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
block|}
else|#
directive|else
return|return
name|S_OK
return|;
endif|#
directive|endif
block|}
DECL|function|LazyInputLayout
name|LazyInputLayout
operator|::
name|LazyInputLayout
parameter_list|(
specifier|const
name|D3D11_INPUT_ELEMENT_DESC
modifier|*
name|inputDesc
parameter_list|,
name|size_t
name|inputDescLen
parameter_list|,
specifier|const
name|BYTE
modifier|*
name|byteCode
parameter_list|,
name|size_t
name|byteCodeLen
parameter_list|,
specifier|const
name|char
modifier|*
name|debugName
parameter_list|)
member_init_list|:
name|mInputDesc
argument_list|(
name|inputDescLen
argument_list|)
member_init_list|,
name|mByteCodeLen
argument_list|(
name|byteCodeLen
argument_list|)
member_init_list|,
name|mByteCode
argument_list|(
name|byteCode
argument_list|)
member_init_list|,
name|mDebugName
argument_list|(
name|debugName
argument_list|)
block|{
name|memcpy
argument_list|(
operator|&
name|mInputDesc
index|[
literal|0
index|]
argument_list|,
name|inputDesc
argument_list|,
sizeof|sizeof
argument_list|(
name|D3D11_INPUT_ELEMENT_DESC
argument_list|)
operator|*
name|inputDescLen
argument_list|)
expr_stmt|;
block|}
DECL|function|resolve
name|ID3D11InputLayout
modifier|*
name|LazyInputLayout
operator|::
name|resolve
parameter_list|(
name|ID3D11Device
modifier|*
name|device
parameter_list|)
block|{
name|checkAssociatedDevice
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|mResource
operator|==
literal|nullptr
condition|)
block|{
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateInputLayout
argument_list|(
operator|&
name|mInputDesc
index|[
literal|0
index|]
argument_list|,
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|mInputDesc
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
name|mByteCode
argument_list|,
name|mByteCodeLen
argument_list|,
operator|&
name|mResource
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|UNUSED_ASSERTION_VARIABLE
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mResource
argument_list|,
name|mDebugName
argument_list|)
expr_stmt|;
block|}
return|return
name|mResource
return|;
block|}
DECL|function|LazyBlendState
name|LazyBlendState
operator|::
name|LazyBlendState
parameter_list|(
specifier|const
name|D3D11_BLEND_DESC
modifier|&
name|desc
parameter_list|,
specifier|const
name|char
modifier|*
name|debugName
parameter_list|)
member_init_list|:
name|mDesc
argument_list|(
name|desc
argument_list|)
member_init_list|,
name|mDebugName
argument_list|(
name|debugName
argument_list|)
block|{ }
DECL|function|resolve
name|ID3D11BlendState
modifier|*
name|LazyBlendState
operator|::
name|resolve
parameter_list|(
name|ID3D11Device
modifier|*
name|device
parameter_list|)
block|{
name|checkAssociatedDevice
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|mResource
operator|==
literal|nullptr
condition|)
block|{
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateBlendState
argument_list|(
operator|&
name|mDesc
argument_list|,
operator|&
name|mResource
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|UNUSED_ASSERTION_VARIABLE
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|d3d11
operator|::
name|SetDebugName
argument_list|(
name|mResource
argument_list|,
name|mDebugName
argument_list|)
expr_stmt|;
block|}
return|return
name|mResource
return|;
block|}
DECL|function|GenerateWorkarounds
name|WorkaroundsD3D
name|GenerateWorkarounds
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
block|{
name|WorkaroundsD3D
name|workarounds
decl_stmt|;
name|workarounds
operator|.
name|mrtPerfWorkaround
operator|=
literal|true
expr_stmt|;
name|workarounds
operator|.
name|setDataFasterThanImageUpload
operator|=
literal|true
expr_stmt|;
name|workarounds
operator|.
name|zeroMaxLodWorkaround
operator|=
operator|(
name|featureLevel
operator|<=
name|D3D_FEATURE_LEVEL_9_3
operator|)
expr_stmt|;
name|workarounds
operator|.
name|useInstancedPointSpriteEmulation
operator|=
operator|(
name|featureLevel
operator|<=
name|D3D_FEATURE_LEVEL_9_3
operator|)
expr_stmt|;
return|return
name|workarounds
return|;
block|}
block|}
comment|// namespace d3d11
DECL|function|TextureHelper11
name|TextureHelper11
operator|::
name|TextureHelper11
parameter_list|()
member_init_list|:
name|mTextureType
argument_list|(
name|GL_NONE
argument_list|)
member_init_list|,
name|mFormat
argument_list|(
name|DXGI_FORMAT_UNKNOWN
argument_list|)
member_init_list|,
name|mSampleCount
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mTexture2D
argument_list|(
literal|nullptr
argument_list|)
member_init_list|,
name|mTexture3D
argument_list|(
literal|nullptr
argument_list|)
block|{ }
DECL|function|TextureHelper11
name|TextureHelper11
operator|::
name|TextureHelper11
parameter_list|(
name|TextureHelper11
modifier|&&
name|toCopy
parameter_list|)
member_init_list|:
name|mTextureType
argument_list|(
name|toCopy
operator|.
name|mTextureType
argument_list|)
member_init_list|,
name|mExtents
argument_list|(
name|toCopy
operator|.
name|mExtents
argument_list|)
member_init_list|,
name|mFormat
argument_list|(
name|toCopy
operator|.
name|mFormat
argument_list|)
member_init_list|,
name|mSampleCount
argument_list|(
name|toCopy
operator|.
name|mSampleCount
argument_list|)
member_init_list|,
name|mTexture2D
argument_list|(
name|toCopy
operator|.
name|mTexture2D
argument_list|)
member_init_list|,
name|mTexture3D
argument_list|(
name|toCopy
operator|.
name|mTexture3D
argument_list|)
block|{
name|toCopy
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
comment|// static
DECL|function|MakeAndReference
name|TextureHelper11
name|TextureHelper11
operator|::
name|MakeAndReference
parameter_list|(
name|ID3D11Resource
modifier|*
name|genericResource
parameter_list|)
block|{
name|TextureHelper11
name|newHelper
decl_stmt|;
name|newHelper
operator|.
name|mTexture2D
operator|=
name|d3d11
operator|::
name|DynamicCastComObject
argument_list|<
name|ID3D11Texture2D
argument_list|>
argument_list|(
name|genericResource
argument_list|)
expr_stmt|;
name|newHelper
operator|.
name|mTexture3D
operator|=
name|d3d11
operator|::
name|DynamicCastComObject
argument_list|<
name|ID3D11Texture3D
argument_list|>
argument_list|(
name|genericResource
argument_list|)
expr_stmt|;
name|newHelper
operator|.
name|mTextureType
operator|=
name|newHelper
operator|.
name|mTexture2D
condition|?
name|GL_TEXTURE_2D
else|:
name|GL_TEXTURE_3D
expr_stmt|;
name|newHelper
operator|.
name|initDesc
argument_list|()
expr_stmt|;
return|return
name|newHelper
return|;
block|}
comment|// static
DECL|function|MakeAndPossess2D
name|TextureHelper11
name|TextureHelper11
operator|::
name|MakeAndPossess2D
parameter_list|(
name|ID3D11Texture2D
modifier|*
name|texToOwn
parameter_list|)
block|{
name|TextureHelper11
name|newHelper
decl_stmt|;
name|newHelper
operator|.
name|mTexture2D
operator|=
name|texToOwn
expr_stmt|;
name|newHelper
operator|.
name|mTextureType
operator|=
name|GL_TEXTURE_2D
expr_stmt|;
name|newHelper
operator|.
name|initDesc
argument_list|()
expr_stmt|;
return|return
name|newHelper
return|;
block|}
comment|// static
DECL|function|MakeAndPossess3D
name|TextureHelper11
name|TextureHelper11
operator|::
name|MakeAndPossess3D
parameter_list|(
name|ID3D11Texture3D
modifier|*
name|texToOwn
parameter_list|)
block|{
name|TextureHelper11
name|newHelper
decl_stmt|;
name|newHelper
operator|.
name|mTexture3D
operator|=
name|texToOwn
expr_stmt|;
name|newHelper
operator|.
name|mTextureType
operator|=
name|GL_TEXTURE_3D
expr_stmt|;
name|newHelper
operator|.
name|initDesc
argument_list|()
expr_stmt|;
return|return
name|newHelper
return|;
block|}
DECL|function|initDesc
name|void
name|TextureHelper11
operator|::
name|initDesc
parameter_list|()
block|{
if|if
condition|(
name|mTextureType
operator|==
name|GL_TEXTURE_2D
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|mTexture3D
argument_list|)
expr_stmt|;
name|D3D11_TEXTURE2D_DESC
name|desc2D
decl_stmt|;
name|mTexture2D
operator|->
name|GetDesc
argument_list|(
operator|&
name|desc2D
argument_list|)
expr_stmt|;
name|mExtents
operator|.
name|width
operator|=
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|desc2D
operator|.
name|Width
argument_list|)
expr_stmt|;
name|mExtents
operator|.
name|height
operator|=
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|desc2D
operator|.
name|Height
argument_list|)
expr_stmt|;
name|mExtents
operator|.
name|depth
operator|=
literal|1
expr_stmt|;
name|mFormat
operator|=
name|desc2D
operator|.
name|Format
expr_stmt|;
name|mSampleCount
operator|=
name|desc2D
operator|.
name|SampleDesc
operator|.
name|Count
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|mTexture3D
operator|&&
name|mTextureType
operator|==
name|GL_TEXTURE_3D
argument_list|)
expr_stmt|;
name|D3D11_TEXTURE3D_DESC
name|desc3D
decl_stmt|;
name|mTexture3D
operator|->
name|GetDesc
argument_list|(
operator|&
name|desc3D
argument_list|)
expr_stmt|;
name|mExtents
operator|.
name|width
operator|=
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|desc3D
operator|.
name|Width
argument_list|)
expr_stmt|;
name|mExtents
operator|.
name|height
operator|=
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|desc3D
operator|.
name|Height
argument_list|)
expr_stmt|;
name|mExtents
operator|.
name|depth
operator|=
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|desc3D
operator|.
name|Depth
argument_list|)
expr_stmt|;
name|mFormat
operator|=
name|desc3D
operator|.
name|Format
expr_stmt|;
name|mSampleCount
operator|=
literal|1
expr_stmt|;
block|}
block|}
DECL|function|~TextureHelper11
name|TextureHelper11
operator|::
name|~
name|TextureHelper11
parameter_list|()
block|{
name|SafeRelease
argument_list|(
name|mTexture2D
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mTexture3D
argument_list|)
expr_stmt|;
block|}
DECL|function|getResource
name|ID3D11Resource
modifier|*
name|TextureHelper11
operator|::
name|getResource
parameter_list|()
specifier|const
block|{
return|return
name|mTexture2D
condition|?
cast|static_cast
argument_list|<
name|ID3D11Resource
operator|*
argument_list|>
argument_list|(
name|mTexture2D
argument_list|)
else|:
cast|static_cast
argument_list|<
name|ID3D11Resource
operator|*
argument_list|>
argument_list|(
name|mTexture3D
argument_list|)
return|;
block|}
DECL|function|operator =
name|TextureHelper11
modifier|&
name|TextureHelper11
operator|::
name|operator
name|=
parameter_list|(
name|TextureHelper11
modifier|&&
name|texture
parameter_list|)
block|{
name|SafeRelease
argument_list|(
name|mTexture2D
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mTexture3D
argument_list|)
expr_stmt|;
name|mTextureType
operator|=
name|texture
operator|.
name|mTextureType
expr_stmt|;
name|mExtents
operator|=
name|texture
operator|.
name|mExtents
expr_stmt|;
name|mFormat
operator|=
name|texture
operator|.
name|mFormat
expr_stmt|;
name|mSampleCount
operator|=
name|texture
operator|.
name|mSampleCount
expr_stmt|;
name|mTexture2D
operator|=
name|texture
operator|.
name|mTexture2D
expr_stmt|;
name|mTexture3D
operator|=
name|texture
operator|.
name|mTexture3D
expr_stmt|;
name|texture
operator|.
name|reset
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
DECL|function|reset
name|void
name|TextureHelper11
operator|::
name|reset
parameter_list|()
block|{
name|mTextureType
operator|=
name|GL_NONE
expr_stmt|;
name|mExtents
operator|=
name|gl
operator|::
name|Extents
argument_list|()
expr_stmt|;
name|mFormat
operator|=
name|DXGI_FORMAT_UNKNOWN
expr_stmt|;
name|mSampleCount
operator|=
literal|0
expr_stmt|;
name|mTexture2D
operator|=
literal|nullptr
expr_stmt|;
name|mTexture3D
operator|=
literal|nullptr
expr_stmt|;
block|}
DECL|function|CreateStagingTexture
name|gl
operator|::
name|ErrorOrResult
argument_list|<
name|TextureHelper11
argument_list|>
name|CreateStagingTexture
parameter_list|(
name|GLenum
name|textureType
parameter_list|,
name|DXGI_FORMAT
name|dxgiFormat
parameter_list|,
specifier|const
name|gl
operator|::
name|Extents
modifier|&
name|size
parameter_list|,
name|ID3D11Device
modifier|*
name|device
parameter_list|)
block|{
if|if
condition|(
name|textureType
operator|==
name|GL_TEXTURE_2D
condition|)
block|{
name|D3D11_TEXTURE2D_DESC
name|stagingDesc
decl_stmt|;
name|stagingDesc
operator|.
name|Width
operator|=
name|size
operator|.
name|width
expr_stmt|;
name|stagingDesc
operator|.
name|Height
operator|=
name|size
operator|.
name|height
expr_stmt|;
name|stagingDesc
operator|.
name|MipLevels
operator|=
literal|1
expr_stmt|;
name|stagingDesc
operator|.
name|ArraySize
operator|=
literal|1
expr_stmt|;
name|stagingDesc
operator|.
name|Format
operator|=
name|dxgiFormat
expr_stmt|;
name|stagingDesc
operator|.
name|SampleDesc
operator|.
name|Count
operator|=
literal|1
expr_stmt|;
name|stagingDesc
operator|.
name|SampleDesc
operator|.
name|Quality
operator|=
literal|0
expr_stmt|;
name|stagingDesc
operator|.
name|Usage
operator|=
name|D3D11_USAGE_STAGING
expr_stmt|;
name|stagingDesc
operator|.
name|BindFlags
operator|=
literal|0
expr_stmt|;
name|stagingDesc
operator|.
name|CPUAccessFlags
operator|=
name|D3D11_CPU_ACCESS_READ
expr_stmt|;
name|stagingDesc
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|ID3D11Texture2D
modifier|*
name|stagingTex
init|=
literal|nullptr
decl_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateTexture2D
argument_list|(
operator|&
name|stagingDesc
argument_list|,
literal|nullptr
argument_list|,
operator|&
name|stagingTex
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"CreateStagingTextureFor failed, HRESULT: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
return|return
name|TextureHelper11
operator|::
name|MakeAndPossess2D
argument_list|(
name|stagingTex
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|textureType
operator|==
name|GL_TEXTURE_3D
argument_list|)
expr_stmt|;
name|D3D11_TEXTURE3D_DESC
name|stagingDesc
decl_stmt|;
name|stagingDesc
operator|.
name|Width
operator|=
name|size
operator|.
name|width
expr_stmt|;
name|stagingDesc
operator|.
name|Height
operator|=
name|size
operator|.
name|height
expr_stmt|;
name|stagingDesc
operator|.
name|Depth
operator|=
literal|1
expr_stmt|;
name|stagingDesc
operator|.
name|MipLevels
operator|=
literal|1
expr_stmt|;
name|stagingDesc
operator|.
name|Format
operator|=
name|dxgiFormat
expr_stmt|;
name|stagingDesc
operator|.
name|Usage
operator|=
name|D3D11_USAGE_STAGING
expr_stmt|;
name|stagingDesc
operator|.
name|BindFlags
operator|=
literal|0
expr_stmt|;
name|stagingDesc
operator|.
name|CPUAccessFlags
operator|=
name|D3D11_CPU_ACCESS_READ
expr_stmt|;
name|stagingDesc
operator|.
name|MiscFlags
operator|=
literal|0
expr_stmt|;
name|ID3D11Texture3D
modifier|*
name|stagingTex
init|=
literal|nullptr
decl_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateTexture3D
argument_list|(
operator|&
name|stagingDesc
argument_list|,
literal|nullptr
argument_list|,
operator|&
name|stagingTex
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"CreateStagingTextureFor failed, HRESULT: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
return|return
name|TextureHelper11
operator|::
name|MakeAndPossess3D
argument_list|(
name|stagingTex
argument_list|)
return|;
block|}
DECL|function|UsePresentPathFast
name|bool
name|UsePresentPathFast
parameter_list|(
specifier|const
name|Renderer11
modifier|*
name|renderer
parameter_list|,
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|framebufferAttachment
parameter_list|)
block|{
if|if
condition|(
name|framebufferAttachment
operator|==
literal|nullptr
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
operator|(
name|framebufferAttachment
operator|->
name|type
argument_list|()
operator|==
name|GL_FRAMEBUFFER_DEFAULT
operator|&&
name|renderer
operator|->
name|presentPathFastEnabled
argument_list|()
operator|)
return|;
block|}
block|}
end_namespace
begin_comment
comment|// namespace rx
end_comment
end_unit
