begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2012-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// renderer11_utils.h: Conversion functions and other utility routines
end_comment
begin_comment
comment|// specific to the D3D11 renderer.
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|LIBANGLE_RENDERER_D3D_D3D11_RENDERER11_UTILS_H_
end_ifndef
begin_define
DECL|macro|LIBANGLE_RENDERER_D3D_D3D11_RENDERER11_UTILS_H_
define|#
directive|define
name|LIBANGLE_RENDERER_D3D_D3D11_RENDERER11_UTILS_H_
end_define
begin_include
include|#
directive|include
file|<array>
end_include
begin_include
include|#
directive|include
file|<vector>
end_include
begin_include
include|#
directive|include
file|"libANGLE/angletypes.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Caps.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Error.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/RendererD3D.h"
end_include
begin_decl_stmt
name|namespace
name|gl
block|{
name|class
name|FramebufferAttachment
decl_stmt|;
block|}
end_decl_stmt
begin_decl_stmt
name|namespace
name|rx
block|{
name|class
name|Renderer11
decl_stmt|;
name|class
name|RenderTarget11
decl_stmt|;
struct_decl|struct
name|WorkaroundsD3D
struct_decl|;
struct_decl|struct
name|Renderer11DeviceCaps
struct_decl|;
name|using
name|RenderTargetArray
init|=
name|std
operator|::
name|array
operator|<
name|ID3D11RenderTargetView
operator|*
decl_stmt|,
name|gl
decl|::
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
decl|>
decl_stmt|;
name|namespace
name|gl_d3d11
block|{
name|D3D11_BLEND
name|ConvertBlendFunc
parameter_list|(
name|GLenum
name|glBlend
parameter_list|,
name|bool
name|isAlpha
parameter_list|)
function_decl|;
name|D3D11_BLEND_OP
name|ConvertBlendOp
parameter_list|(
name|GLenum
name|glBlendOp
parameter_list|)
function_decl|;
name|UINT8
name|ConvertColorMask
parameter_list|(
name|bool
name|maskRed
parameter_list|,
name|bool
name|maskGreen
parameter_list|,
name|bool
name|maskBlue
parameter_list|,
name|bool
name|maskAlpha
parameter_list|)
function_decl|;
name|D3D11_CULL_MODE
name|ConvertCullMode
parameter_list|(
name|bool
name|cullEnabled
parameter_list|,
name|GLenum
name|cullMode
parameter_list|)
function_decl|;
name|D3D11_COMPARISON_FUNC
name|ConvertComparison
parameter_list|(
name|GLenum
name|comparison
parameter_list|)
function_decl|;
name|D3D11_DEPTH_WRITE_MASK
name|ConvertDepthMask
parameter_list|(
name|bool
name|depthWriteEnabled
parameter_list|)
function_decl|;
name|UINT8
name|ConvertStencilMask
parameter_list|(
name|GLuint
name|stencilmask
parameter_list|)
function_decl|;
name|D3D11_STENCIL_OP
name|ConvertStencilOp
parameter_list|(
name|GLenum
name|stencilOp
parameter_list|)
function_decl|;
name|D3D11_FILTER
name|ConvertFilter
parameter_list|(
name|GLenum
name|minFilter
parameter_list|,
name|GLenum
name|magFilter
parameter_list|,
name|float
name|maxAnisotropy
parameter_list|,
name|GLenum
name|comparisonMode
parameter_list|)
function_decl|;
name|D3D11_TEXTURE_ADDRESS_MODE
name|ConvertTextureWrap
parameter_list|(
name|GLenum
name|wrap
parameter_list|)
function_decl|;
name|D3D11_QUERY
name|ConvertQueryType
parameter_list|(
name|GLenum
name|queryType
parameter_list|)
function_decl|;
block|}
comment|// namespace gl_d3d11
name|namespace
name|d3d11_gl
block|{
name|unsigned
name|int
name|GetReservedVertexUniformVectors
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
function_decl|;
name|unsigned
name|int
name|GetReservedFragmentUniformVectors
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
function_decl|;
name|GLint
name|GetMaximumClientVersion
parameter_list|(
name|D3D_FEATURE_LEVEL
name|featureLevel
parameter_list|)
function_decl|;
name|void
name|GenerateCaps
argument_list|(
name|ID3D11Device
operator|*
name|device
argument_list|,
name|ID3D11DeviceContext
operator|*
name|deviceContext
argument_list|,
specifier|const
name|Renderer11DeviceCaps
operator|&
name|renderer11DeviceCaps
argument_list|,
name|gl
operator|::
name|Caps
operator|*
name|caps
argument_list|,
name|gl
operator|::
name|TextureCapsMap
operator|*
name|textureCapsMap
argument_list|,
name|gl
operator|::
name|Extensions
operator|*
name|extensions
argument_list|,
name|gl
operator|::
name|Limitations
operator|*
name|limitations
argument_list|)
decl_stmt|;
block|}
comment|// namespace d3d11_gl
name|namespace
name|d3d11
block|{
enum|enum
name|ANGLED3D11DeviceType
block|{
name|ANGLE_D3D11_DEVICE_TYPE_UNKNOWN
block|,
name|ANGLE_D3D11_DEVICE_TYPE_HARDWARE
block|,
name|ANGLE_D3D11_DEVICE_TYPE_SOFTWARE_REF_OR_NULL
block|,
name|ANGLE_D3D11_DEVICE_TYPE_WARP
block|, }
enum|;
name|ANGLED3D11DeviceType
name|GetDeviceType
parameter_list|(
name|ID3D11Device
modifier|*
name|device
parameter_list|)
function_decl|;
name|void
name|MakeValidSize
parameter_list|(
name|bool
name|isImage
parameter_list|,
name|DXGI_FORMAT
name|format
parameter_list|,
name|GLsizei
modifier|*
name|requestWidth
parameter_list|,
name|GLsizei
modifier|*
name|requestHeight
parameter_list|,
name|int
modifier|*
name|levelOffset
parameter_list|)
function_decl|;
name|void
name|GenerateInitialTextureData
argument_list|(
name|GLint
name|internalFormat
argument_list|,
specifier|const
name|Renderer11DeviceCaps
operator|&
name|renderer11DeviceCaps
argument_list|,
name|GLuint
name|width
argument_list|,
name|GLuint
name|height
argument_list|,
name|GLuint
name|depth
argument_list|,
name|GLuint
name|mipLevels
argument_list|,
name|std
operator|::
name|vector
operator|<
name|D3D11_SUBRESOURCE_DATA
operator|>
operator|*
name|outSubresourceData
argument_list|,
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|vector
operator|<
name|BYTE
operator|>>
operator|*
name|outData
argument_list|)
decl_stmt|;
name|UINT
name|GetPrimitiveRestartIndex
parameter_list|()
function_decl|;
struct|struct
name|PositionTexCoordVertex
block|{
name|float
name|x
decl_stmt|,
name|y
decl_stmt|;
name|float
name|u
decl_stmt|,
name|v
decl_stmt|;
block|}
struct|;
name|void
name|SetPositionTexCoordVertex
parameter_list|(
name|PositionTexCoordVertex
modifier|*
name|vertex
parameter_list|,
name|float
name|x
parameter_list|,
name|float
name|y
parameter_list|,
name|float
name|u
parameter_list|,
name|float
name|v
parameter_list|)
function_decl|;
struct|struct
name|PositionLayerTexCoord3DVertex
block|{
name|float
name|x
decl_stmt|,
name|y
decl_stmt|;
name|unsigned
name|int
name|l
decl_stmt|;
name|float
name|u
decl_stmt|,
name|v
decl_stmt|,
name|s
decl_stmt|;
block|}
struct|;
name|void
name|SetPositionLayerTexCoord3DVertex
parameter_list|(
name|PositionLayerTexCoord3DVertex
modifier|*
name|vertex
parameter_list|,
name|float
name|x
parameter_list|,
name|float
name|y
parameter_list|,
name|unsigned
name|int
name|layer
parameter_list|,
name|float
name|u
parameter_list|,
name|float
name|v
parameter_list|,
name|float
name|s
parameter_list|)
function_decl|;
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|PositionDepthColorVertex
block|{
name|float
name|x
block|,
name|y
block|,
name|z
block|;
name|T
name|r
block|,
name|g
block|,
name|b
block|,
name|a
block|; }
expr_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|SetPositionDepthColorVertex
argument_list|(
argument|PositionDepthColorVertex<T>* vertex
argument_list|,
argument|float x
argument_list|,
argument|float y
argument_list|,
argument|float z
argument_list|,
argument|const gl::Color<T>&color
argument_list|)
block|{
name|vertex
operator|->
name|x
operator|=
name|x
block|;
name|vertex
operator|->
name|y
operator|=
name|y
block|;
name|vertex
operator|->
name|z
operator|=
name|z
block|;
name|vertex
operator|->
name|r
operator|=
name|color
operator|.
name|red
block|;
name|vertex
operator|->
name|g
operator|=
name|color
operator|.
name|green
block|;
name|vertex
operator|->
name|b
operator|=
name|color
operator|.
name|blue
block|;
name|vertex
operator|->
name|a
operator|=
name|color
operator|.
name|alpha
block|; }
name|HRESULT
name|SetDebugName
argument_list|(
name|ID3D11DeviceChild
operator|*
name|resource
argument_list|,
specifier|const
name|char
operator|*
name|name
argument_list|)
expr_stmt|;
name|template
operator|<
name|typename
name|outType
operator|>
name|outType
operator|*
name|DynamicCastComObject
argument_list|(
argument|IUnknown* object
argument_list|)
block|{
name|outType
operator|*
name|outObject
operator|=
name|NULL
block|;
name|HRESULT
name|result
operator|=
name|object
operator|->
name|QueryInterface
argument_list|(
name|__uuidof
argument_list|(
name|outType
argument_list|)
argument_list|,
name|reinterpret_cast
operator|<
name|void
operator|*
operator|*
operator|>
operator|(
operator|&
name|outObject
operator|)
argument_list|)
block|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|outObject
return|;
block|}
else|else
block|{
name|SafeRelease
argument_list|(
name|outObject
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
specifier|inline
name|bool
name|isDeviceLostError
argument_list|(
argument|HRESULT errorCode
argument_list|)
block|{
switch|switch
condition|(
name|errorCode
condition|)
block|{
case|case
name|DXGI_ERROR_DEVICE_HUNG
case|:
case|case
name|DXGI_ERROR_DEVICE_REMOVED
case|:
case|case
name|DXGI_ERROR_DEVICE_RESET
case|:
case|case
name|DXGI_ERROR_DRIVER_INTERNAL_ERROR
case|:
case|case
name|DXGI_ERROR_NOT_CURRENTLY_AVAILABLE
case|:
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
specifier|inline
name|ID3D11VertexShader
operator|*
name|CompileVS
argument_list|(
argument|ID3D11Device *device
argument_list|,
argument|const BYTE *byteCode
argument_list|,
argument|size_t N
argument_list|,
argument|const char *name
argument_list|)
block|{
name|ID3D11VertexShader
operator|*
name|vs
operator|=
name|nullptr
block|;
name|HRESULT
name|result
operator|=
name|device
operator|->
name|CreateVertexShader
argument_list|(
name|byteCode
argument_list|,
name|N
argument_list|,
name|nullptr
argument_list|,
operator|&
name|vs
argument_list|)
block|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
block|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|SetDebugName
argument_list|(
name|vs
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|vs
return|;
block|}
return|return
name|nullptr
return|;
block|}
name|template
operator|<
name|unsigned
name|int
name|N
operator|>
name|ID3D11VertexShader
operator|*
name|CompileVS
argument_list|(
argument|ID3D11Device *device
argument_list|,
argument|const BYTE (&byteCode)[N]
argument_list|,
argument|const char *name
argument_list|)
block|{
return|return
name|CompileVS
argument_list|(
name|device
argument_list|,
name|byteCode
argument_list|,
name|N
argument_list|,
name|name
argument_list|)
return|;
block|}
specifier|inline
name|ID3D11GeometryShader
modifier|*
name|CompileGS
parameter_list|(
name|ID3D11Device
modifier|*
name|device
parameter_list|,
specifier|const
name|BYTE
modifier|*
name|byteCode
parameter_list|,
name|size_t
name|N
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|ID3D11GeometryShader
modifier|*
name|gs
init|=
name|nullptr
decl_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreateGeometryShader
argument_list|(
name|byteCode
argument_list|,
name|N
argument_list|,
name|nullptr
argument_list|,
operator|&
name|gs
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|SetDebugName
argument_list|(
name|gs
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|gs
return|;
block|}
return|return
name|nullptr
return|;
block|}
name|template
operator|<
name|unsigned
name|int
name|N
operator|>
name|ID3D11GeometryShader
operator|*
name|CompileGS
argument_list|(
argument|ID3D11Device *device
argument_list|,
argument|const BYTE (&byteCode)[N]
argument_list|,
argument|const char *name
argument_list|)
block|{
return|return
name|CompileGS
argument_list|(
name|device
argument_list|,
name|byteCode
argument_list|,
name|N
argument_list|,
name|name
argument_list|)
return|;
block|}
specifier|inline
name|ID3D11PixelShader
modifier|*
name|CompilePS
parameter_list|(
name|ID3D11Device
modifier|*
name|device
parameter_list|,
specifier|const
name|BYTE
modifier|*
name|byteCode
parameter_list|,
name|size_t
name|N
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|ID3D11PixelShader
modifier|*
name|ps
init|=
name|nullptr
decl_stmt|;
name|HRESULT
name|result
init|=
name|device
operator|->
name|CreatePixelShader
argument_list|(
name|byteCode
argument_list|,
name|N
argument_list|,
name|nullptr
argument_list|,
operator|&
name|ps
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|SetDebugName
argument_list|(
name|ps
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|ps
return|;
block|}
return|return
name|nullptr
return|;
block|}
name|template
operator|<
name|unsigned
name|int
name|N
operator|>
name|ID3D11PixelShader
operator|*
name|CompilePS
argument_list|(
argument|ID3D11Device *device
argument_list|,
argument|const BYTE (&byteCode)[N]
argument_list|,
argument|const char *name
argument_list|)
block|{
return|return
name|CompilePS
argument_list|(
name|device
argument_list|,
name|byteCode
argument_list|,
name|N
argument_list|,
name|name
argument_list|)
return|;
block|}
name|template
operator|<
name|typename
name|ResourceType
operator|>
name|class
name|LazyResource
operator|:
name|public
name|angle
operator|::
name|NonCopyable
block|{
name|public
operator|:
name|LazyResource
argument_list|()
operator|:
name|mResource
argument_list|(
name|nullptr
argument_list|)
block|,
name|mAssociatedDevice
argument_list|(
argument|nullptr
argument_list|)
block|{}
name|virtual
operator|~
name|LazyResource
argument_list|()
block|{
name|release
argument_list|()
block|; }
name|virtual
name|ResourceType
operator|*
name|resolve
argument_list|(
name|ID3D11Device
operator|*
name|device
argument_list|)
operator|=
literal|0
block|;
name|void
name|release
argument_list|()
block|{
name|SafeRelease
argument_list|(
name|mResource
argument_list|)
block|; }
name|protected
operator|:
name|void
name|checkAssociatedDevice
argument_list|(
name|ID3D11Device
operator|*
name|device
argument_list|)
block|;
name|ResourceType
operator|*
name|mResource
block|;
name|ID3D11Device
operator|*
name|mAssociatedDevice
block|; }
expr_stmt|;
name|template
operator|<
name|typename
name|ResourceType
operator|>
name|void
name|LazyResource
operator|<
name|ResourceType
operator|>
operator|::
name|checkAssociatedDevice
argument_list|(
argument|ID3D11Device *device
argument_list|)
block|{
name|ASSERT
argument_list|(
name|mAssociatedDevice
operator|==
name|nullptr
operator|||
name|device
operator|==
name|mAssociatedDevice
argument_list|)
block|;
name|mAssociatedDevice
operator|=
name|device
block|; }
name|template
operator|<
name|typename
name|D3D11ShaderType
operator|>
name|class
name|LazyShader
name|final
operator|:
name|public
name|LazyResource
operator|<
name|D3D11ShaderType
operator|>
block|{
name|public
operator|:
comment|// All parameters must be constexpr. Not supported in VS2013.
name|LazyShader
argument_list|(
argument|const BYTE *byteCode
argument_list|,
argument|size_t byteCodeSize
argument_list|,
argument|const char *name
argument_list|)
operator|:
name|mByteCode
argument_list|(
name|byteCode
argument_list|)
block|,
name|mByteCodeSize
argument_list|(
name|byteCodeSize
argument_list|)
block|,
name|mName
argument_list|(
argument|name
argument_list|)
block|{     }
name|D3D11ShaderType
operator|*
name|resolve
argument_list|(
argument|ID3D11Device *device
argument_list|)
name|override
block|;
name|private
operator|:
specifier|const
name|BYTE
operator|*
name|mByteCode
block|;
name|size_t
name|mByteCodeSize
block|;
specifier|const
name|char
operator|*
name|mName
block|; }
expr_stmt|;
name|template
operator|<
operator|>
specifier|inline
name|ID3D11VertexShader
operator|*
name|LazyShader
operator|<
name|ID3D11VertexShader
operator|>
operator|::
name|resolve
argument_list|(
argument|ID3D11Device *device
argument_list|)
block|{
name|checkAssociatedDevice
argument_list|(
name|device
argument_list|)
block|;
if|if
condition|(
name|mResource
operator|==
name|nullptr
condition|)
block|{
name|mResource
operator|=
name|CompileVS
argument_list|(
name|device
argument_list|,
name|mByteCode
argument_list|,
name|mByteCodeSize
argument_list|,
name|mName
argument_list|)
expr_stmt|;
block|}
return|return
name|mResource
return|;
block|}
name|template
operator|<
operator|>
specifier|inline
name|ID3D11GeometryShader
operator|*
name|LazyShader
operator|<
name|ID3D11GeometryShader
operator|>
operator|::
name|resolve
argument_list|(
argument|ID3D11Device *device
argument_list|)
block|{
name|checkAssociatedDevice
argument_list|(
name|device
argument_list|)
block|;
if|if
condition|(
name|mResource
operator|==
name|nullptr
condition|)
block|{
name|mResource
operator|=
name|CompileGS
argument_list|(
name|device
argument_list|,
name|mByteCode
argument_list|,
name|mByteCodeSize
argument_list|,
name|mName
argument_list|)
expr_stmt|;
block|}
return|return
name|mResource
return|;
block|}
name|template
operator|<
operator|>
specifier|inline
name|ID3D11PixelShader
operator|*
name|LazyShader
operator|<
name|ID3D11PixelShader
operator|>
operator|::
name|resolve
argument_list|(
argument|ID3D11Device *device
argument_list|)
block|{
name|checkAssociatedDevice
argument_list|(
name|device
argument_list|)
block|;
if|if
condition|(
name|mResource
operator|==
name|nullptr
condition|)
block|{
name|mResource
operator|=
name|CompilePS
argument_list|(
name|device
argument_list|,
name|mByteCode
argument_list|,
name|mByteCodeSize
argument_list|,
name|mName
argument_list|)
expr_stmt|;
block|}
return|return
name|mResource
return|;
block|}
name|class
name|LazyInputLayout
name|final
range|:
name|public
name|LazyResource
operator|<
name|ID3D11InputLayout
operator|>
block|{
name|public
operator|:
name|LazyInputLayout
argument_list|(
argument|const D3D11_INPUT_ELEMENT_DESC *inputDesc
argument_list|,
argument|size_t inputDescLen
argument_list|,
argument|const BYTE *byteCode
argument_list|,
argument|size_t byteCodeLen
argument_list|,
argument|const char *debugName
argument_list|)
block|;
name|ID3D11InputLayout
operator|*
name|resolve
argument_list|(
argument|ID3D11Device *device
argument_list|)
name|override
block|;
name|private
operator|:
name|std
operator|::
name|vector
operator|<
name|D3D11_INPUT_ELEMENT_DESC
operator|>
name|mInputDesc
block|;
name|size_t
name|mByteCodeLen
block|;
specifier|const
name|BYTE
operator|*
name|mByteCode
block|;
specifier|const
name|char
operator|*
name|mDebugName
block|; }
decl_stmt|;
name|class
name|LazyBlendState
name|final
range|:
name|public
name|LazyResource
operator|<
name|ID3D11BlendState
operator|>
block|{
name|public
operator|:
name|LazyBlendState
argument_list|(
specifier|const
name|D3D11_BLEND_DESC
operator|&
name|desc
argument_list|,
specifier|const
name|char
operator|*
name|debugName
argument_list|)
block|;
name|ID3D11BlendState
operator|*
name|resolve
argument_list|(
argument|ID3D11Device *device
argument_list|)
name|override
block|;
name|private
operator|:
name|D3D11_BLEND_DESC
name|mDesc
block|;
specifier|const
name|char
operator|*
name|mDebugName
block|; }
decl_stmt|;
comment|// Copy data to small D3D11 buffers, such as for small constant buffers, which use one struct to
comment|// represent an entire buffer.
name|template
operator|<
name|class
name|T
operator|>
name|void
name|SetBufferData
argument_list|(
argument|ID3D11DeviceContext *context
argument_list|,
argument|ID3D11Buffer *constantBuffer
argument_list|,
argument|const T&value
argument_list|)
block|{
name|D3D11_MAPPED_SUBRESOURCE
name|mappedResource
operator|=
block|{}
block|;
name|HRESULT
name|result
operator|=
name|context
operator|->
name|Map
argument_list|(
name|constantBuffer
argument_list|,
literal|0
argument_list|,
name|D3D11_MAP_WRITE_DISCARD
argument_list|,
literal|0
argument_list|,
operator|&
name|mappedResource
argument_list|)
block|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
block|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|mappedResource
operator|.
name|pData
argument_list|,
operator|&
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|->
name|Unmap
argument_list|(
name|constantBuffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|WorkaroundsD3D
name|GenerateWorkarounds
argument_list|(
argument|D3D_FEATURE_LEVEL featureLevel
argument_list|)
expr_stmt|;
block|}
comment|// namespace d3d11
comment|// A helper class which wraps a 2D or 3D texture.
name|class
name|TextureHelper11
range|:
name|angle
operator|::
name|NonCopyable
block|{
name|public
operator|:
name|TextureHelper11
argument_list|()
block|;
name|TextureHelper11
argument_list|(
name|TextureHelper11
operator|&&
name|toCopy
argument_list|)
block|;
operator|~
name|TextureHelper11
argument_list|()
block|;
name|TextureHelper11
operator|&
name|operator
operator|=
operator|(
name|TextureHelper11
operator|&&
name|texture
operator|)
block|;
specifier|static
name|TextureHelper11
name|MakeAndReference
argument_list|(
name|ID3D11Resource
operator|*
name|genericResource
argument_list|)
block|;
specifier|static
name|TextureHelper11
name|MakeAndPossess2D
argument_list|(
name|ID3D11Texture2D
operator|*
name|texToOwn
argument_list|)
block|;
specifier|static
name|TextureHelper11
name|MakeAndPossess3D
argument_list|(
name|ID3D11Texture3D
operator|*
name|texToOwn
argument_list|)
block|;
name|GLenum
name|getTextureType
argument_list|()
specifier|const
block|{
return|return
name|mTextureType
return|;
block|}
name|gl
operator|::
name|Extents
name|getExtents
argument_list|()
specifier|const
block|{
return|return
name|mExtents
return|;
block|}
name|DXGI_FORMAT
name|getFormat
argument_list|()
specifier|const
block|{
return|return
name|mFormat
return|;
block|}
name|int
name|getSampleCount
argument_list|()
specifier|const
block|{
return|return
name|mSampleCount
return|;
block|}
name|ID3D11Texture2D
operator|*
name|getTexture2D
argument_list|()
specifier|const
block|{
return|return
name|mTexture2D
return|;
block|}
name|ID3D11Texture3D
operator|*
name|getTexture3D
argument_list|()
specifier|const
block|{
return|return
name|mTexture3D
return|;
block|}
name|ID3D11Resource
operator|*
name|getResource
argument_list|()
specifier|const
block|;
name|private
operator|:
name|void
name|reset
argument_list|()
block|;
name|void
name|initDesc
argument_list|()
block|;
name|GLenum
name|mTextureType
block|;
name|gl
operator|::
name|Extents
name|mExtents
block|;
name|DXGI_FORMAT
name|mFormat
block|;
name|int
name|mSampleCount
block|;
name|ID3D11Texture2D
operator|*
name|mTexture2D
block|;
name|ID3D11Texture3D
operator|*
name|mTexture3D
block|; }
decl_stmt|;
name|gl
operator|::
name|ErrorOrResult
operator|<
name|TextureHelper11
operator|>
name|CreateStagingTexture
argument_list|(
argument|GLenum textureType
argument_list|,
argument|DXGI_FORMAT dxgiFormat
argument_list|,
argument|const gl::Extents&size
argument_list|,
argument|ID3D11Device *device
argument_list|)
expr_stmt|;
name|bool
name|UsePresentPathFast
argument_list|(
specifier|const
name|Renderer11
operator|*
name|renderer
argument_list|,
specifier|const
name|gl
operator|::
name|FramebufferAttachment
operator|*
name|colorbuffer
argument_list|)
decl_stmt|;
block|}
end_decl_stmt
begin_comment
comment|// namespace rx
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// LIBANGLE_RENDERER_D3D_D3D11_RENDERER11_UTILS_H_
end_comment
end_unit
