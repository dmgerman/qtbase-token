begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2012-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Renderer9.cpp: Implements a back-end specific class for the D3D9 renderer.
end_comment
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d9/Renderer9.h"
end_include
begin_include
include|#
directive|include
file|<sstream>
end_include
begin_include
include|#
directive|include
file|<EGL/eglext.h>
end_include
begin_include
include|#
directive|include
file|"common/utilities.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/angletypes.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Buffer.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Display.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/features.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/formatutils.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Framebuffer.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/FramebufferAttachment.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Program.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Renderbuffer.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d9/Blit9.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d9/Buffer9.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d9/Fence9.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d9/formatutils9.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d9/Framebuffer9.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d9/Image9.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d9/IndexBuffer9.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d9/Query9.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d9/renderer9_utils.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d9/RenderTarget9.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d9/ShaderExecutable9.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d9/SwapChain9.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d9/TextureStorage9.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d9/VertexArray9.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/d3d9/VertexBuffer9.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/CompilerD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/DeviceD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/FramebufferD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/IndexDataManager.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/ProgramD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/RenderbufferD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/ShaderD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/SurfaceD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/TextureD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/d3d/TransformFeedbackD3D.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/State.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Surface.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Texture.h"
end_include
begin_include
include|#
directive|include
file|"third_party/trace_event/trace_event.h"
end_include
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ANGLE_COMPILE_OPTIMIZATION_LEVEL
argument_list|)
end_if
begin_define
DECL|macro|ANGLE_COMPILE_OPTIMIZATION_LEVEL
define|#
directive|define
name|ANGLE_COMPILE_OPTIMIZATION_LEVEL
value|D3DCOMPILE_OPTIMIZATION_LEVEL3
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// Enable ANGLE_SUPPORT_SHADER_MODEL_2 if you wish devices with only shader model 2.
end_comment
begin_comment
comment|// Such a device would not be conformant.
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|ANGLE_SUPPORT_SHADER_MODEL_2
end_ifndef
begin_define
DECL|macro|ANGLE_SUPPORT_SHADER_MODEL_2
define|#
directive|define
name|ANGLE_SUPPORT_SHADER_MODEL_2
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_namespace
DECL|namespace|rx
namespace|namespace
name|rx
block|{
enum|enum
block|{
DECL|enumerator|MAX_VERTEX_CONSTANT_VECTORS_D3D9
name|MAX_VERTEX_CONSTANT_VECTORS_D3D9
init|=
literal|256
block|,
DECL|enumerator|MAX_PIXEL_CONSTANT_VECTORS_SM2
name|MAX_PIXEL_CONSTANT_VECTORS_SM2
init|=
literal|32
block|,
DECL|enumerator|MAX_PIXEL_CONSTANT_VECTORS_SM3
name|MAX_PIXEL_CONSTANT_VECTORS_SM3
init|=
literal|224
block|,
DECL|enumerator|MAX_VARYING_VECTORS_SM2
name|MAX_VARYING_VECTORS_SM2
init|=
literal|8
block|,
DECL|enumerator|MAX_VARYING_VECTORS_SM3
name|MAX_VARYING_VECTORS_SM3
init|=
literal|10
block|,
DECL|enumerator|MAX_TEXTURE_IMAGE_UNITS_VTF_SM3
name|MAX_TEXTURE_IMAGE_UNITS_VTF_SM3
init|=
literal|4
block|}
enum|;
DECL|function|Renderer9
name|Renderer9
operator|::
name|Renderer9
parameter_list|(
name|egl
operator|::
name|Display
modifier|*
name|display
parameter_list|)
member_init_list|:
name|RendererD3D
argument_list|(
name|display
argument_list|)
member_init_list|,
name|mStateManager
argument_list|(
name|this
argument_list|)
block|{
name|mD3d9Module
operator|=
name|NULL
expr_stmt|;
name|mD3d9
operator|=
name|NULL
expr_stmt|;
name|mD3d9Ex
operator|=
name|NULL
expr_stmt|;
name|mDevice
operator|=
name|NULL
expr_stmt|;
name|mDeviceEx
operator|=
name|NULL
expr_stmt|;
name|mDeviceWindow
operator|=
name|NULL
expr_stmt|;
name|mBlit
operator|=
name|NULL
expr_stmt|;
name|mAdapter
operator|=
name|D3DADAPTER_DEFAULT
expr_stmt|;
specifier|const
name|egl
operator|::
name|AttributeMap
modifier|&
name|attributes
init|=
name|display
operator|->
name|getAttributeMap
argument_list|()
decl_stmt|;
name|EGLint
name|requestedDeviceType
init|=
name|attributes
operator|.
name|get
argument_list|(
name|EGL_PLATFORM_ANGLE_DEVICE_TYPE_ANGLE
argument_list|,
name|EGL_PLATFORM_ANGLE_DEVICE_TYPE_HARDWARE_ANGLE
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|requestedDeviceType
condition|)
block|{
case|case
name|EGL_PLATFORM_ANGLE_DEVICE_TYPE_HARDWARE_ANGLE
case|:
name|mDeviceType
operator|=
name|D3DDEVTYPE_HAL
expr_stmt|;
break|break;
case|case
name|EGL_PLATFORM_ANGLE_DEVICE_TYPE_REFERENCE_ANGLE
case|:
name|mDeviceType
operator|=
name|D3DDEVTYPE_REF
expr_stmt|;
break|break;
case|case
name|EGL_PLATFORM_ANGLE_DEVICE_TYPE_NULL_ANGLE
case|:
name|mDeviceType
operator|=
name|D3DDEVTYPE_NULLREF
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
name|mMaskedClearSavedState
operator|=
name|NULL
expr_stmt|;
name|mVertexDataManager
operator|=
name|NULL
expr_stmt|;
name|mIndexDataManager
operator|=
name|NULL
expr_stmt|;
name|mLineLoopIB
operator|=
name|NULL
expr_stmt|;
name|mCountingIB
operator|=
name|NULL
expr_stmt|;
name|mMaxNullColorbufferLRU
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_NULL_COLORBUFFER_CACHE_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
name|mNullColorbufferCache
index|[
name|i
index|]
operator|.
name|lruCount
operator|=
literal|0
expr_stmt|;
name|mNullColorbufferCache
index|[
name|i
index|]
operator|.
name|width
operator|=
literal|0
expr_stmt|;
name|mNullColorbufferCache
index|[
name|i
index|]
operator|.
name|height
operator|=
literal|0
expr_stmt|;
name|mNullColorbufferCache
index|[
name|i
index|]
operator|.
name|buffer
operator|=
name|NULL
expr_stmt|;
block|}
name|mAppliedVertexShader
operator|=
name|NULL
expr_stmt|;
name|mAppliedPixelShader
operator|=
name|NULL
expr_stmt|;
name|mAppliedProgramSerial
operator|=
literal|0
expr_stmt|;
name|initializeDebugAnnotator
argument_list|()
expr_stmt|;
name|mEGLDevice
operator|=
literal|nullptr
expr_stmt|;
block|}
DECL|function|~Renderer9
name|Renderer9
operator|::
name|~
name|Renderer9
parameter_list|()
block|{
if|if
condition|(
name|mDevice
condition|)
block|{
comment|// If the device is lost, reset it first to prevent leaving the driver in an unstable state
if|if
condition|(
name|testDeviceLost
argument_list|()
condition|)
block|{
name|resetDevice
argument_list|()
expr_stmt|;
block|}
block|}
name|release
argument_list|()
expr_stmt|;
block|}
DECL|function|release
name|void
name|Renderer9
operator|::
name|release
parameter_list|()
block|{
name|RendererD3D
operator|::
name|cleanup
argument_list|()
expr_stmt|;
name|releaseDeviceResources
argument_list|()
expr_stmt|;
name|SafeDelete
argument_list|(
name|mEGLDevice
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mDevice
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mDeviceEx
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mD3d9
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|mD3d9Ex
argument_list|)
expr_stmt|;
name|mCompiler
operator|.
name|release
argument_list|()
expr_stmt|;
if|if
condition|(
name|mDeviceWindow
condition|)
block|{
name|DestroyWindow
argument_list|(
name|mDeviceWindow
argument_list|)
expr_stmt|;
name|mDeviceWindow
operator|=
name|NULL
expr_stmt|;
block|}
name|mD3d9Module
operator|=
name|NULL
expr_stmt|;
block|}
DECL|function|initialize
name|egl
operator|::
name|Error
name|Renderer9
operator|::
name|initialize
parameter_list|()
block|{
name|TRACE_EVENT0
argument_list|(
literal|"gpu.angle"
argument_list|,
literal|"GetModuleHandle_d3d9"
argument_list|)
expr_stmt|;
name|mD3d9Module
operator|=
name|GetModuleHandle
argument_list|(
name|TEXT
argument_list|(
literal|"d3d9.dll"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mD3d9Module
operator|==
name|NULL
condition|)
block|{
return|return
name|egl
operator|::
name|Error
argument_list|(
name|EGL_NOT_INITIALIZED
argument_list|,
name|D3D9_INIT_MISSING_DEP
argument_list|,
literal|"No D3D9 module found."
argument_list|)
return|;
block|}
typedef|typedef
name|HRESULT
function_decl|(
name|WINAPI
modifier|*
name|Direct3DCreate9ExFunc
function_decl|)
parameter_list|(
name|UINT
parameter_list|,
name|IDirect3D9Ex
modifier|*
modifier|*
parameter_list|)
function_decl|;
name|Direct3DCreate9ExFunc
name|Direct3DCreate9ExPtr
init|=
cast|reinterpret_cast
argument_list|<
name|Direct3DCreate9ExFunc
argument_list|>
argument_list|(
name|GetProcAddress
argument_list|(
name|mD3d9Module
argument_list|,
literal|"Direct3DCreate9Ex"
argument_list|)
argument_list|)
decl_stmt|;
comment|// Use Direct3D9Ex if available. Among other things, this version is less
comment|// inclined to report a lost context, for example when the user switches
comment|// desktop. Direct3D9Ex is available in Windows Vista and later if suitable drivers are available.
if|if
condition|(
name|ANGLE_D3D9EX
operator|==
name|ANGLE_ENABLED
operator|&&
name|Direct3DCreate9ExPtr
operator|&&
name|SUCCEEDED
argument_list|(
name|Direct3DCreate9ExPtr
argument_list|(
name|D3D_SDK_VERSION
argument_list|,
operator|&
name|mD3d9Ex
argument_list|)
argument_list|)
condition|)
block|{
name|TRACE_EVENT0
argument_list|(
literal|"gpu.angle"
argument_list|,
literal|"D3d9Ex_QueryInterface"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mD3d9Ex
argument_list|)
expr_stmt|;
name|mD3d9Ex
operator|->
name|QueryInterface
argument_list|(
name|IID_IDirect3D9
argument_list|,
cast|reinterpret_cast
argument_list|<
name|void
operator|*
operator|*
argument_list|>
argument_list|(
operator|&
name|mD3d9
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mD3d9
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TRACE_EVENT0
argument_list|(
literal|"gpu.angle"
argument_list|,
literal|"Direct3DCreate9"
argument_list|)
expr_stmt|;
name|mD3d9
operator|=
name|Direct3DCreate9
argument_list|(
name|D3D_SDK_VERSION
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mD3d9
condition|)
block|{
return|return
name|egl
operator|::
name|Error
argument_list|(
name|EGL_NOT_INITIALIZED
argument_list|,
name|D3D9_INIT_MISSING_DEP
argument_list|,
literal|"Could not create D3D9 device."
argument_list|)
return|;
block|}
if|if
condition|(
name|mDisplay
operator|->
name|getNativeDisplayId
argument_list|()
operator|!=
literal|nullptr
condition|)
block|{
comment|//  UNIMPLEMENTED();   // FIXME: Determine which adapter index the device context corresponds to
block|}
name|HRESULT
name|result
decl_stmt|;
comment|// Give up on getting device caps after about one second.
block|{
name|TRACE_EVENT0
argument_list|(
literal|"gpu.angle"
argument_list|,
literal|"GetDeviceCaps"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
operator|++
name|i
control|)
block|{
name|result
operator|=
name|mD3d9
operator|->
name|GetDeviceCaps
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
operator|&
name|mDeviceCaps
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|D3DERR_NOTAVAILABLE
condition|)
block|{
name|Sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|// Give the driver some time to initialize/recover
block|}
elseif|else
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
comment|// D3DERR_OUTOFVIDEOMEMORY, E_OUTOFMEMORY, D3DERR_INVALIDDEVICE, or another error we can't recover from
block|{
return|return
name|egl
operator|::
name|Error
argument_list|(
name|EGL_NOT_INITIALIZED
argument_list|,
name|D3D9_INIT_OTHER_ERROR
argument_list|,
literal|"Failed to get device caps: Error code 0x%x\n"
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
block|}
if|#
directive|if
name|ANGLE_SUPPORT_SHADER_MODEL_2
name|size_t
name|minShaderModel
init|=
literal|2
decl_stmt|;
else|#
directive|else
name|size_t
name|minShaderModel
init|=
literal|3
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|mDeviceCaps
operator|.
name|PixelShaderVersion
operator|<
name|D3DPS_VERSION
argument_list|(
name|minShaderModel
argument_list|,
literal|0
argument_list|)
condition|)
block|{
return|return
name|egl
operator|::
name|Error
argument_list|(
name|EGL_NOT_INITIALIZED
argument_list|,
name|D3D9_INIT_UNSUPPORTED_VERSION
argument_list|,
literal|"Renderer does not support PS %u.%u.aborting!"
argument_list|,
name|minShaderModel
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|// When DirectX9 is running with an older DirectX8 driver, a StretchRect from a regular texture to a render target texture is not supported.
comment|// This is required by Texture2D::ensureRenderTarget.
if|if
condition|(
operator|(
name|mDeviceCaps
operator|.
name|DevCaps2
operator|&
name|D3DDEVCAPS2_CAN_STRETCHRECT_FROM_TEXTURES
operator|)
operator|==
literal|0
condition|)
block|{
return|return
name|egl
operator|::
name|Error
argument_list|(
name|EGL_NOT_INITIALIZED
argument_list|,
name|D3D9_INIT_UNSUPPORTED_STRETCHRECT
argument_list|,
literal|"Renderer does not support StretctRect from textures."
argument_list|)
return|;
block|}
block|{
name|TRACE_EVENT0
argument_list|(
literal|"gpu.angle"
argument_list|,
literal|"GetAdapterIdentifier"
argument_list|)
expr_stmt|;
name|mD3d9
operator|->
name|GetAdapterIdentifier
argument_list|(
name|mAdapter
argument_list|,
literal|0
argument_list|,
operator|&
name|mAdapterIdentifier
argument_list|)
expr_stmt|;
block|}
specifier|static
specifier|const
name|TCHAR
name|windowName
index|[]
init|=
name|TEXT
argument_list|(
literal|"AngleHiddenWindow"
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|TCHAR
name|className
index|[]
init|=
name|TEXT
argument_list|(
literal|"STATIC"
argument_list|)
decl_stmt|;
block|{
name|TRACE_EVENT0
argument_list|(
literal|"gpu.angle"
argument_list|,
literal|"CreateWindowEx"
argument_list|)
expr_stmt|;
name|mDeviceWindow
operator|=
name|CreateWindowEx
argument_list|(
name|WS_EX_NOACTIVATE
argument_list|,
name|className
argument_list|,
name|windowName
argument_list|,
name|WS_DISABLED
operator||
name|WS_POPUP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|HWND_MESSAGE
argument_list|,
name|NULL
argument_list|,
name|GetModuleHandle
argument_list|(
name|NULL
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|D3DPRESENT_PARAMETERS
name|presentParameters
init|=
name|getDefaultPresentParameters
argument_list|()
decl_stmt|;
name|DWORD
name|behaviorFlags
init|=
name|D3DCREATE_FPU_PRESERVE
operator||
name|D3DCREATE_NOWINDOWCHANGES
operator||
name|D3DCREATE_MULTITHREADED
decl_stmt|;
block|{
name|TRACE_EVENT0
argument_list|(
literal|"gpu.angle"
argument_list|,
literal|"D3d9_CreateDevice"
argument_list|)
expr_stmt|;
name|result
operator|=
name|mD3d9
operator|->
name|CreateDevice
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|mDeviceWindow
argument_list|,
name|behaviorFlags
operator||
name|D3DCREATE_HARDWARE_VERTEXPROCESSING
operator||
name|D3DCREATE_PUREDEVICE
argument_list|,
operator|&
name|presentParameters
argument_list|,
operator|&
name|mDevice
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|D3DERR_OUTOFVIDEOMEMORY
operator|||
name|result
operator|==
name|E_OUTOFMEMORY
operator|||
name|result
operator|==
name|D3DERR_DEVICELOST
condition|)
block|{
return|return
name|egl
operator|::
name|Error
argument_list|(
name|EGL_BAD_ALLOC
argument_list|,
name|D3D9_INIT_OUT_OF_MEMORY
argument_list|,
literal|"CreateDevice failed: device lost of out of memory"
argument_list|)
return|;
block|}
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|TRACE_EVENT0
argument_list|(
literal|"gpu.angle"
argument_list|,
literal|"D3d9_CreateDevice2"
argument_list|)
expr_stmt|;
name|result
operator|=
name|mD3d9
operator|->
name|CreateDevice
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|mDeviceWindow
argument_list|,
name|behaviorFlags
operator||
name|D3DCREATE_SOFTWARE_VERTEXPROCESSING
argument_list|,
operator|&
name|presentParameters
argument_list|,
operator|&
name|mDevice
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|result
operator|==
name|D3DERR_OUTOFVIDEOMEMORY
operator|||
name|result
operator|==
name|E_OUTOFMEMORY
operator|||
name|result
operator|==
name|D3DERR_NOTAVAILABLE
operator|||
name|result
operator|==
name|D3DERR_DEVICELOST
argument_list|)
expr_stmt|;
return|return
name|egl
operator|::
name|Error
argument_list|(
name|EGL_BAD_ALLOC
argument_list|,
name|D3D9_INIT_OUT_OF_MEMORY
argument_list|,
literal|"CreateDevice2 failed: device lost, not available, or of out of memory"
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|mD3d9Ex
condition|)
block|{
name|TRACE_EVENT0
argument_list|(
literal|"gpu.angle"
argument_list|,
literal|"mDevice_QueryInterface"
argument_list|)
expr_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|QueryInterface
argument_list|(
name|IID_IDirect3DDevice9Ex
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|mDeviceEx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|{
name|TRACE_EVENT0
argument_list|(
literal|"gpu.angle"
argument_list|,
literal|"ShaderCache initialize"
argument_list|)
expr_stmt|;
name|mVertexShaderCache
operator|.
name|initialize
argument_list|(
name|mDevice
argument_list|)
expr_stmt|;
name|mPixelShaderCache
operator|.
name|initialize
argument_list|(
name|mDevice
argument_list|)
expr_stmt|;
block|}
name|D3DDISPLAYMODE
name|currentDisplayMode
decl_stmt|;
name|mD3d9
operator|->
name|GetAdapterDisplayMode
argument_list|(
name|mAdapter
argument_list|,
operator|&
name|currentDisplayMode
argument_list|)
expr_stmt|;
comment|// Check vertex texture support
comment|// Only Direct3D 10 ready devices support all the necessary vertex texture formats.
comment|// We test this using D3D9 by checking support for the R16F format.
name|mVertexTextureSupport
operator|=
name|mDeviceCaps
operator|.
name|PixelShaderVersion
operator|>=
name|D3DPS_VERSION
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
operator|&&
name|SUCCEEDED
argument_list|(
name|mD3d9
operator|->
name|CheckDeviceFormat
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
name|currentDisplayMode
operator|.
name|Format
argument_list|,
name|D3DUSAGE_QUERY_VERTEXTEXTURE
argument_list|,
name|D3DRTYPE_TEXTURE
argument_list|,
name|D3DFMT_R16F
argument_list|)
argument_list|)
expr_stmt|;
name|initializeDevice
argument_list|()
expr_stmt|;
return|return
name|egl
operator|::
name|Error
argument_list|(
name|EGL_SUCCESS
argument_list|)
return|;
block|}
comment|// do any one-time device initialization
comment|// NOTE: this is also needed after a device lost/reset
comment|// to reset the scene status and ensure the default states are reset.
DECL|function|initializeDevice
name|void
name|Renderer9
operator|::
name|initializeDevice
parameter_list|()
block|{
comment|// Permanent non-default states
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_POINTSPRITEENABLE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_LASTPIXEL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mDeviceCaps
operator|.
name|PixelShaderVersion
operator|>=
name|D3DPS_VERSION
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_POINTSIZE_MAX
argument_list|,
operator|(
name|DWORD
operator|&
operator|)
name|mDeviceCaps
operator|.
name|MaxPointSize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_POINTSIZE_MAX
argument_list|,
literal|0x3F800000
argument_list|)
expr_stmt|;
comment|// 1.0f
block|}
specifier|const
name|gl
operator|::
name|Caps
modifier|&
name|rendererCaps
init|=
name|getRendererCaps
argument_list|()
decl_stmt|;
name|mCurVertexSamplerStates
operator|.
name|resize
argument_list|(
name|rendererCaps
operator|.
name|maxVertexTextureImageUnits
argument_list|)
expr_stmt|;
name|mCurPixelSamplerStates
operator|.
name|resize
argument_list|(
name|rendererCaps
operator|.
name|maxTextureImageUnits
argument_list|)
expr_stmt|;
name|mCurVertexTextures
operator|.
name|resize
argument_list|(
name|rendererCaps
operator|.
name|maxVertexTextureImageUnits
argument_list|)
expr_stmt|;
name|mCurPixelTextures
operator|.
name|resize
argument_list|(
name|rendererCaps
operator|.
name|maxTextureImageUnits
argument_list|)
expr_stmt|;
name|markAllStateDirty
argument_list|()
expr_stmt|;
name|mSceneStarted
operator|=
literal|false
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|mBlit
argument_list|)
expr_stmt|;
name|mBlit
operator|=
operator|new
name|Blit9
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|mBlit
operator|->
name|initialize
argument_list|()
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|mVertexDataManager
operator|&&
operator|!
name|mIndexDataManager
argument_list|)
expr_stmt|;
name|mVertexDataManager
operator|=
operator|new
name|VertexDataManager
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|mIndexDataManager
operator|=
operator|new
name|IndexDataManager
argument_list|(
name|this
argument_list|,
name|getRendererClass
argument_list|()
argument_list|)
expr_stmt|;
comment|// TODO(jmadill): use context caps, and place in common D3D location
name|mTranslatedAttribCache
operator|.
name|resize
argument_list|(
name|getRendererCaps
argument_list|()
operator|.
name|maxVertexAttributes
argument_list|)
expr_stmt|;
block|}
DECL|function|getDefaultPresentParameters
name|D3DPRESENT_PARAMETERS
name|Renderer9
operator|::
name|getDefaultPresentParameters
parameter_list|()
block|{
name|D3DPRESENT_PARAMETERS
name|presentParameters
init|=
block|{
literal|0
block|}
decl_stmt|;
comment|// The default swap chain is never actually used. Surface will create a new swap chain with the proper parameters.
name|presentParameters
operator|.
name|AutoDepthStencilFormat
operator|=
name|D3DFMT_UNKNOWN
expr_stmt|;
name|presentParameters
operator|.
name|BackBufferCount
operator|=
literal|1
expr_stmt|;
name|presentParameters
operator|.
name|BackBufferFormat
operator|=
name|D3DFMT_UNKNOWN
expr_stmt|;
name|presentParameters
operator|.
name|BackBufferWidth
operator|=
literal|1
expr_stmt|;
name|presentParameters
operator|.
name|BackBufferHeight
operator|=
literal|1
expr_stmt|;
name|presentParameters
operator|.
name|EnableAutoDepthStencil
operator|=
name|FALSE
expr_stmt|;
name|presentParameters
operator|.
name|Flags
operator|=
literal|0
expr_stmt|;
name|presentParameters
operator|.
name|hDeviceWindow
operator|=
name|mDeviceWindow
expr_stmt|;
name|presentParameters
operator|.
name|MultiSampleQuality
operator|=
literal|0
expr_stmt|;
name|presentParameters
operator|.
name|MultiSampleType
operator|=
name|D3DMULTISAMPLE_NONE
expr_stmt|;
name|presentParameters
operator|.
name|PresentationInterval
operator|=
name|D3DPRESENT_INTERVAL_DEFAULT
expr_stmt|;
name|presentParameters
operator|.
name|SwapEffect
operator|=
name|D3DSWAPEFFECT_DISCARD
expr_stmt|;
name|presentParameters
operator|.
name|Windowed
operator|=
name|TRUE
expr_stmt|;
return|return
name|presentParameters
return|;
block|}
DECL|function|generateConfigs
name|egl
operator|::
name|ConfigSet
name|Renderer9
operator|::
name|generateConfigs
parameter_list|()
specifier|const
block|{
specifier|static
specifier|const
name|GLenum
name|colorBufferFormats
index|[]
init|=
block|{
name|GL_BGR5_A1_ANGLEX
block|,
name|GL_BGRA8_EXT
block|,
name|GL_RGB565
block|,      }
decl_stmt|;
specifier|static
specifier|const
name|GLenum
name|depthStencilBufferFormats
index|[]
init|=
block|{
name|GL_NONE
block|,
name|GL_DEPTH_COMPONENT32_OES
block|,
name|GL_DEPTH24_STENCIL8_OES
block|,
name|GL_DEPTH_COMPONENT24_OES
block|,
name|GL_DEPTH_COMPONENT16
block|,     }
decl_stmt|;
specifier|const
name|gl
operator|::
name|Caps
modifier|&
name|rendererCaps
init|=
name|getRendererCaps
argument_list|()
decl_stmt|;
specifier|const
name|gl
operator|::
name|TextureCapsMap
modifier|&
name|rendererTextureCaps
init|=
name|getRendererTextureCaps
argument_list|()
decl_stmt|;
name|D3DDISPLAYMODE
name|currentDisplayMode
decl_stmt|;
name|mD3d9
operator|->
name|GetAdapterDisplayMode
argument_list|(
name|mAdapter
argument_list|,
operator|&
name|currentDisplayMode
argument_list|)
expr_stmt|;
comment|// Determine the min and max swap intervals
name|int
name|minSwapInterval
init|=
literal|4
decl_stmt|;
name|int
name|maxSwapInterval
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mDeviceCaps
operator|.
name|PresentationIntervals
operator|&
name|D3DPRESENT_INTERVAL_IMMEDIATE
condition|)
block|{
name|minSwapInterval
operator|=
name|std
operator|::
name|min
argument_list|(
name|minSwapInterval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|maxSwapInterval
operator|=
name|std
operator|::
name|max
argument_list|(
name|maxSwapInterval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mDeviceCaps
operator|.
name|PresentationIntervals
operator|&
name|D3DPRESENT_INTERVAL_ONE
condition|)
block|{
name|minSwapInterval
operator|=
name|std
operator|::
name|min
argument_list|(
name|minSwapInterval
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|maxSwapInterval
operator|=
name|std
operator|::
name|max
argument_list|(
name|maxSwapInterval
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mDeviceCaps
operator|.
name|PresentationIntervals
operator|&
name|D3DPRESENT_INTERVAL_TWO
condition|)
block|{
name|minSwapInterval
operator|=
name|std
operator|::
name|min
argument_list|(
name|minSwapInterval
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|maxSwapInterval
operator|=
name|std
operator|::
name|max
argument_list|(
name|maxSwapInterval
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mDeviceCaps
operator|.
name|PresentationIntervals
operator|&
name|D3DPRESENT_INTERVAL_THREE
condition|)
block|{
name|minSwapInterval
operator|=
name|std
operator|::
name|min
argument_list|(
name|minSwapInterval
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|maxSwapInterval
operator|=
name|std
operator|::
name|max
argument_list|(
name|maxSwapInterval
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mDeviceCaps
operator|.
name|PresentationIntervals
operator|&
name|D3DPRESENT_INTERVAL_FOUR
condition|)
block|{
name|minSwapInterval
operator|=
name|std
operator|::
name|min
argument_list|(
name|minSwapInterval
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|maxSwapInterval
operator|=
name|std
operator|::
name|max
argument_list|(
name|maxSwapInterval
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|egl
operator|::
name|ConfigSet
name|configs
decl_stmt|;
for|for
control|(
name|size_t
name|formatIndex
init|=
literal|0
init|;
name|formatIndex
operator|<
name|ArraySize
argument_list|(
name|colorBufferFormats
argument_list|)
condition|;
name|formatIndex
operator|++
control|)
block|{
name|GLenum
name|colorBufferInternalFormat
init|=
name|colorBufferFormats
index|[
name|formatIndex
index|]
decl_stmt|;
specifier|const
name|gl
operator|::
name|TextureCaps
modifier|&
name|colorBufferFormatCaps
init|=
name|rendererTextureCaps
operator|.
name|get
argument_list|(
name|colorBufferInternalFormat
argument_list|)
decl_stmt|;
if|if
condition|(
name|colorBufferFormatCaps
operator|.
name|renderable
condition|)
block|{
for|for
control|(
name|size_t
name|depthStencilIndex
init|=
literal|0
init|;
name|depthStencilIndex
operator|<
name|ArraySize
argument_list|(
name|depthStencilBufferFormats
argument_list|)
condition|;
name|depthStencilIndex
operator|++
control|)
block|{
name|GLenum
name|depthStencilBufferInternalFormat
init|=
name|depthStencilBufferFormats
index|[
name|depthStencilIndex
index|]
decl_stmt|;
specifier|const
name|gl
operator|::
name|TextureCaps
modifier|&
name|depthStencilBufferFormatCaps
init|=
name|rendererTextureCaps
operator|.
name|get
argument_list|(
name|depthStencilBufferInternalFormat
argument_list|)
decl_stmt|;
if|if
condition|(
name|depthStencilBufferFormatCaps
operator|.
name|renderable
operator|||
name|depthStencilBufferInternalFormat
operator|==
name|GL_NONE
condition|)
block|{
specifier|const
name|gl
operator|::
name|InternalFormat
modifier|&
name|colorBufferFormatInfo
init|=
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|colorBufferInternalFormat
argument_list|)
decl_stmt|;
specifier|const
name|gl
operator|::
name|InternalFormat
modifier|&
name|depthStencilBufferFormatInfo
init|=
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|depthStencilBufferInternalFormat
argument_list|)
decl_stmt|;
specifier|const
name|d3d9
operator|::
name|TextureFormat
modifier|&
name|d3d9ColorBufferFormatInfo
init|=
name|d3d9
operator|::
name|GetTextureFormatInfo
argument_list|(
name|colorBufferInternalFormat
argument_list|)
decl_stmt|;
name|egl
operator|::
name|Config
name|config
decl_stmt|;
name|config
operator|.
name|renderTargetFormat
operator|=
name|colorBufferInternalFormat
expr_stmt|;
name|config
operator|.
name|depthStencilFormat
operator|=
name|depthStencilBufferInternalFormat
expr_stmt|;
name|config
operator|.
name|bufferSize
operator|=
name|colorBufferFormatInfo
operator|.
name|pixelBytes
operator|*
literal|8
expr_stmt|;
name|config
operator|.
name|redSize
operator|=
name|colorBufferFormatInfo
operator|.
name|redBits
expr_stmt|;
name|config
operator|.
name|greenSize
operator|=
name|colorBufferFormatInfo
operator|.
name|greenBits
expr_stmt|;
name|config
operator|.
name|blueSize
operator|=
name|colorBufferFormatInfo
operator|.
name|blueBits
expr_stmt|;
name|config
operator|.
name|luminanceSize
operator|=
name|colorBufferFormatInfo
operator|.
name|luminanceBits
expr_stmt|;
name|config
operator|.
name|alphaSize
operator|=
name|colorBufferFormatInfo
operator|.
name|alphaBits
expr_stmt|;
name|config
operator|.
name|alphaMaskSize
operator|=
literal|0
expr_stmt|;
name|config
operator|.
name|bindToTextureRGB
operator|=
operator|(
name|colorBufferFormatInfo
operator|.
name|format
operator|==
name|GL_RGB
operator|)
expr_stmt|;
name|config
operator|.
name|bindToTextureRGBA
operator|=
operator|(
name|colorBufferFormatInfo
operator|.
name|format
operator|==
name|GL_RGBA
operator|||
name|colorBufferFormatInfo
operator|.
name|format
operator|==
name|GL_BGRA_EXT
operator|)
expr_stmt|;
name|config
operator|.
name|colorBufferType
operator|=
name|EGL_RGB_BUFFER
expr_stmt|;
comment|// Mark as slow if blits to the back-buffer won't be straight forward
name|config
operator|.
name|configCaveat
operator|=
operator|(
name|currentDisplayMode
operator|.
name|Format
operator|==
name|d3d9ColorBufferFormatInfo
operator|.
name|renderFormat
operator|)
condition|?
name|EGL_NONE
else|:
name|EGL_SLOW_CONFIG
expr_stmt|;
name|config
operator|.
name|configID
operator|=
cast|static_cast
argument_list|<
name|EGLint
argument_list|>
argument_list|(
name|configs
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|config
operator|.
name|conformant
operator|=
name|EGL_OPENGL_ES2_BIT
expr_stmt|;
name|config
operator|.
name|depthSize
operator|=
name|depthStencilBufferFormatInfo
operator|.
name|depthBits
expr_stmt|;
name|config
operator|.
name|level
operator|=
literal|0
expr_stmt|;
name|config
operator|.
name|matchNativePixmap
operator|=
name|EGL_NONE
expr_stmt|;
name|config
operator|.
name|maxPBufferWidth
operator|=
name|rendererCaps
operator|.
name|max2DTextureSize
expr_stmt|;
name|config
operator|.
name|maxPBufferHeight
operator|=
name|rendererCaps
operator|.
name|max2DTextureSize
expr_stmt|;
name|config
operator|.
name|maxPBufferPixels
operator|=
name|rendererCaps
operator|.
name|max2DTextureSize
operator|*
name|rendererCaps
operator|.
name|max2DTextureSize
expr_stmt|;
name|config
operator|.
name|maxSwapInterval
operator|=
name|maxSwapInterval
expr_stmt|;
name|config
operator|.
name|minSwapInterval
operator|=
name|minSwapInterval
expr_stmt|;
name|config
operator|.
name|nativeRenderable
operator|=
name|EGL_FALSE
expr_stmt|;
name|config
operator|.
name|nativeVisualID
operator|=
literal|0
expr_stmt|;
name|config
operator|.
name|nativeVisualType
operator|=
name|EGL_NONE
expr_stmt|;
name|config
operator|.
name|renderableType
operator|=
name|EGL_OPENGL_ES2_BIT
expr_stmt|;
name|config
operator|.
name|sampleBuffers
operator|=
literal|0
expr_stmt|;
comment|// FIXME: enumerate multi-sampling
name|config
operator|.
name|samples
operator|=
literal|0
expr_stmt|;
name|config
operator|.
name|stencilSize
operator|=
name|depthStencilBufferFormatInfo
operator|.
name|stencilBits
expr_stmt|;
name|config
operator|.
name|surfaceType
operator|=
name|EGL_PBUFFER_BIT
operator||
name|EGL_WINDOW_BIT
operator||
name|EGL_SWAP_BEHAVIOR_PRESERVED_BIT
expr_stmt|;
name|config
operator|.
name|transparentType
operator|=
name|EGL_NONE
expr_stmt|;
name|config
operator|.
name|transparentRedValue
operator|=
literal|0
expr_stmt|;
name|config
operator|.
name|transparentGreenValue
operator|=
literal|0
expr_stmt|;
name|config
operator|.
name|transparentBlueValue
operator|=
literal|0
expr_stmt|;
name|configs
operator|.
name|add
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|ASSERT
argument_list|(
name|configs
operator|.
name|size
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
return|return
name|configs
return|;
block|}
DECL|function|generateDisplayExtensions
name|void
name|Renderer9
operator|::
name|generateDisplayExtensions
parameter_list|(
name|egl
operator|::
name|DisplayExtensions
modifier|*
name|outExtensions
parameter_list|)
specifier|const
block|{
name|outExtensions
operator|->
name|createContextRobustness
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|getShareHandleSupport
argument_list|()
condition|)
block|{
name|outExtensions
operator|->
name|d3dShareHandleClientBuffer
operator|=
literal|true
expr_stmt|;
name|outExtensions
operator|->
name|surfaceD3DTexture2DShareHandle
operator|=
literal|true
expr_stmt|;
block|}
name|outExtensions
operator|->
name|querySurfacePointer
operator|=
literal|true
expr_stmt|;
name|outExtensions
operator|->
name|windowFixedSize
operator|=
literal|true
expr_stmt|;
name|outExtensions
operator|->
name|postSubBuffer
operator|=
literal|true
expr_stmt|;
name|outExtensions
operator|->
name|createContext
operator|=
literal|true
expr_stmt|;
name|outExtensions
operator|->
name|deviceQuery
operator|=
literal|true
expr_stmt|;
name|outExtensions
operator|->
name|createContextNoError
operator|=
literal|true
expr_stmt|;
name|outExtensions
operator|->
name|image
operator|=
literal|true
expr_stmt|;
name|outExtensions
operator|->
name|imageBase
operator|=
literal|true
expr_stmt|;
name|outExtensions
operator|->
name|glTexture2DImage
operator|=
literal|true
expr_stmt|;
name|outExtensions
operator|->
name|glRenderbufferImage
operator|=
literal|true
expr_stmt|;
name|outExtensions
operator|->
name|flexibleSurfaceCompatibility
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|startScene
name|void
name|Renderer9
operator|::
name|startScene
parameter_list|()
block|{
if|if
condition|(
operator|!
name|mSceneStarted
condition|)
block|{
name|long
name|result
init|=
name|mDevice
operator|->
name|BeginScene
argument_list|()
decl_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
condition|)
block|{
comment|// This is defensive checking against the device being
comment|// lost at unexpected times.
name|mSceneStarted
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
DECL|function|endScene
name|void
name|Renderer9
operator|::
name|endScene
parameter_list|()
block|{
if|if
condition|(
name|mSceneStarted
condition|)
block|{
comment|// EndScene can fail if the device was lost, for example due
comment|// to a TDR during a draw call.
name|mDevice
operator|->
name|EndScene
argument_list|()
expr_stmt|;
name|mSceneStarted
operator|=
literal|false
expr_stmt|;
block|}
block|}
DECL|function|flush
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|flush
parameter_list|()
block|{
name|IDirect3DQuery9
modifier|*
name|query
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|allocateEventQuery
argument_list|(
operator|&
name|query
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|HRESULT
name|result
init|=
name|query
operator|->
name|Issue
argument_list|(
name|D3DISSUE_END
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|result
operator|==
name|D3DERR_OUTOFVIDEOMEMORY
operator|||
name|result
operator|==
name|E_OUTOFMEMORY
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to issue event query, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
comment|// Grab the query data once
name|result
operator|=
name|query
operator|->
name|GetData
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|D3DGETDATA_FLUSH
argument_list|)
expr_stmt|;
name|freeEventQuery
argument_list|(
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
if|if
condition|(
name|d3d9
operator|::
name|isDeviceLostError
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|notifyDeviceLost
argument_list|()
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to get event query data, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|finish
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|finish
parameter_list|()
block|{
name|IDirect3DQuery9
modifier|*
name|query
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|allocateEventQuery
argument_list|(
operator|&
name|query
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|HRESULT
name|result
init|=
name|query
operator|->
name|Issue
argument_list|(
name|D3DISSUE_END
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|result
operator|==
name|D3DERR_OUTOFVIDEOMEMORY
operator|||
name|result
operator|==
name|E_OUTOFMEMORY
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to issue event query, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
comment|// Grab the query data once
name|result
operator|=
name|query
operator|->
name|GetData
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|D3DGETDATA_FLUSH
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
if|if
condition|(
name|d3d9
operator|::
name|isDeviceLostError
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|notifyDeviceLost
argument_list|()
expr_stmt|;
block|}
name|freeEventQuery
argument_list|(
name|query
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to get event query data, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
comment|// Loop until the query completes
while|while
condition|(
name|result
operator|==
name|S_FALSE
condition|)
block|{
comment|// Keep polling, but allow other threads to do something useful first
name|ScheduleYield
argument_list|()
expr_stmt|;
name|result
operator|=
name|query
operator|->
name|GetData
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|D3DGETDATA_FLUSH
argument_list|)
expr_stmt|;
comment|// explicitly check for device loss
comment|// some drivers seem to return S_FALSE even if the device is lost
comment|// instead of D3DERR_DEVICELOST like they should
if|if
condition|(
name|result
operator|==
name|S_FALSE
operator|&&
name|testDeviceLost
argument_list|()
condition|)
block|{
name|result
operator|=
name|D3DERR_DEVICELOST
expr_stmt|;
block|}
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
if|if
condition|(
name|d3d9
operator|::
name|isDeviceLostError
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|notifyDeviceLost
argument_list|()
expr_stmt|;
block|}
name|freeEventQuery
argument_list|(
name|query
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to get event query data, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
name|freeEventQuery
argument_list|(
name|query
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|createSwapChain
name|SwapChainD3D
modifier|*
name|Renderer9
operator|::
name|createSwapChain
parameter_list|(
name|NativeWindow
name|nativeWindow
parameter_list|,
name|HANDLE
name|shareHandle
parameter_list|,
name|GLenum
name|backBufferFormat
parameter_list|,
name|GLenum
name|depthBufferFormat
parameter_list|,
name|EGLint
name|orientation
parameter_list|)
block|{
return|return
operator|new
name|SwapChain9
argument_list|(
name|this
argument_list|,
name|nativeWindow
argument_list|,
name|shareHandle
argument_list|,
name|backBufferFormat
argument_list|,
name|depthBufferFormat
argument_list|,
name|orientation
argument_list|)
return|;
block|}
DECL|function|createCompiler
name|CompilerImpl
modifier|*
name|Renderer9
operator|::
name|createCompiler
parameter_list|()
block|{
return|return
operator|new
name|CompilerD3D
argument_list|(
name|SH_HLSL_3_0_OUTPUT
argument_list|)
return|;
block|}
DECL|function|getD3DDevice
name|void
modifier|*
name|Renderer9
operator|::
name|getD3DDevice
parameter_list|()
block|{
return|return
cast|reinterpret_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
name|mDevice
argument_list|)
return|;
block|}
DECL|function|allocateEventQuery
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|allocateEventQuery
parameter_list|(
name|IDirect3DQuery9
modifier|*
modifier|*
name|outQuery
parameter_list|)
block|{
if|if
condition|(
name|mEventQueryPool
operator|.
name|empty
argument_list|()
condition|)
block|{
name|HRESULT
name|result
init|=
name|mDevice
operator|->
name|CreateQuery
argument_list|(
name|D3DQUERYTYPE_EVENT
argument_list|,
name|outQuery
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|result
operator|==
name|D3DERR_OUTOFVIDEOMEMORY
operator|||
name|result
operator|==
name|E_OUTOFMEMORY
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to allocate event query, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
else|else
block|{
operator|*
name|outQuery
operator|=
name|mEventQueryPool
operator|.
name|back
argument_list|()
expr_stmt|;
name|mEventQueryPool
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|freeEventQuery
name|void
name|Renderer9
operator|::
name|freeEventQuery
parameter_list|(
name|IDirect3DQuery9
modifier|*
name|query
parameter_list|)
block|{
if|if
condition|(
name|mEventQueryPool
operator|.
name|size
argument_list|()
operator|>
literal|1000
condition|)
block|{
name|SafeRelease
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mEventQueryPool
operator|.
name|push_back
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|createVertexShader
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|createVertexShader
parameter_list|(
specifier|const
name|DWORD
modifier|*
name|function
parameter_list|,
name|size_t
name|length
parameter_list|,
name|IDirect3DVertexShader9
modifier|*
modifier|*
name|outShader
parameter_list|)
block|{
return|return
name|mVertexShaderCache
operator|.
name|create
argument_list|(
name|function
argument_list|,
name|length
argument_list|,
name|outShader
argument_list|)
return|;
block|}
DECL|function|createPixelShader
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|createPixelShader
parameter_list|(
specifier|const
name|DWORD
modifier|*
name|function
parameter_list|,
name|size_t
name|length
parameter_list|,
name|IDirect3DPixelShader9
modifier|*
modifier|*
name|outShader
parameter_list|)
block|{
return|return
name|mPixelShaderCache
operator|.
name|create
argument_list|(
name|function
argument_list|,
name|length
argument_list|,
name|outShader
argument_list|)
return|;
block|}
DECL|function|createVertexBuffer
name|HRESULT
name|Renderer9
operator|::
name|createVertexBuffer
parameter_list|(
name|UINT
name|Length
parameter_list|,
name|DWORD
name|Usage
parameter_list|,
name|IDirect3DVertexBuffer9
modifier|*
modifier|*
name|ppVertexBuffer
parameter_list|)
block|{
name|D3DPOOL
name|Pool
init|=
name|getBufferPool
argument_list|(
name|Usage
argument_list|)
decl_stmt|;
return|return
name|mDevice
operator|->
name|CreateVertexBuffer
argument_list|(
name|Length
argument_list|,
name|Usage
argument_list|,
literal|0
argument_list|,
name|Pool
argument_list|,
name|ppVertexBuffer
argument_list|,
name|NULL
argument_list|)
return|;
block|}
DECL|function|createVertexBuffer
name|VertexBuffer
modifier|*
name|Renderer9
operator|::
name|createVertexBuffer
parameter_list|()
block|{
return|return
operator|new
name|VertexBuffer9
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|function|createIndexBuffer
name|HRESULT
name|Renderer9
operator|::
name|createIndexBuffer
parameter_list|(
name|UINT
name|Length
parameter_list|,
name|DWORD
name|Usage
parameter_list|,
name|D3DFORMAT
name|Format
parameter_list|,
name|IDirect3DIndexBuffer9
modifier|*
modifier|*
name|ppIndexBuffer
parameter_list|)
block|{
name|D3DPOOL
name|Pool
init|=
name|getBufferPool
argument_list|(
name|Usage
argument_list|)
decl_stmt|;
return|return
name|mDevice
operator|->
name|CreateIndexBuffer
argument_list|(
name|Length
argument_list|,
name|Usage
argument_list|,
name|Format
argument_list|,
name|Pool
argument_list|,
name|ppIndexBuffer
argument_list|,
name|NULL
argument_list|)
return|;
block|}
DECL|function|createIndexBuffer
name|IndexBuffer
modifier|*
name|Renderer9
operator|::
name|createIndexBuffer
parameter_list|()
block|{
return|return
operator|new
name|IndexBuffer9
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|function|createBuffer
name|BufferImpl
modifier|*
name|Renderer9
operator|::
name|createBuffer
parameter_list|()
block|{
return|return
operator|new
name|Buffer9
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|function|createVertexArray
name|VertexArrayImpl
modifier|*
name|Renderer9
operator|::
name|createVertexArray
parameter_list|(
specifier|const
name|gl
operator|::
name|VertexArray
operator|::
name|Data
modifier|&
name|data
parameter_list|)
block|{
return|return
operator|new
name|VertexArray9
argument_list|(
name|data
argument_list|)
return|;
block|}
DECL|function|createQuery
name|QueryImpl
modifier|*
name|Renderer9
operator|::
name|createQuery
parameter_list|(
name|GLenum
name|type
parameter_list|)
block|{
return|return
operator|new
name|Query9
argument_list|(
name|this
argument_list|,
name|type
argument_list|)
return|;
block|}
DECL|function|createFenceNV
name|FenceNVImpl
modifier|*
name|Renderer9
operator|::
name|createFenceNV
parameter_list|()
block|{
return|return
operator|new
name|FenceNV9
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|function|createFenceSync
name|FenceSyncImpl
modifier|*
name|Renderer9
operator|::
name|createFenceSync
parameter_list|()
block|{
comment|// Renderer9 doesn't support ES 3.0 and its sync objects.
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
DECL|function|createTransformFeedback
name|TransformFeedbackImpl
modifier|*
name|Renderer9
operator|::
name|createTransformFeedback
parameter_list|()
block|{
return|return
operator|new
name|TransformFeedbackD3D
argument_list|()
return|;
block|}
DECL|function|supportsFastCopyBufferToTexture
name|bool
name|Renderer9
operator|::
name|supportsFastCopyBufferToTexture
parameter_list|(
name|GLenum
name|internalFormat
parameter_list|)
specifier|const
block|{
comment|// Pixel buffer objects are not supported in D3D9, since D3D9 is ES2-only and PBOs are ES3.
return|return
literal|false
return|;
block|}
DECL|function|fastCopyBufferToTexture
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|fastCopyBufferToTexture
parameter_list|(
specifier|const
name|gl
operator|::
name|PixelUnpackState
modifier|&
name|unpack
parameter_list|,
name|unsigned
name|int
name|offset
parameter_list|,
name|RenderTargetD3D
modifier|*
name|destRenderTarget
parameter_list|,
name|GLenum
name|destinationFormat
parameter_list|,
name|GLenum
name|sourcePixelsType
parameter_list|,
specifier|const
name|gl
operator|::
name|Box
modifier|&
name|destArea
parameter_list|)
block|{
comment|// Pixel buffer objects are not supported in D3D9, since D3D9 is ES2-only and PBOs are ES3.
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
DECL|function|generateSwizzle
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|generateSwizzle
parameter_list|(
name|gl
operator|::
name|Texture
modifier|*
name|texture
parameter_list|)
block|{
comment|// Swizzled textures are not available in ES2 or D3D9
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
DECL|function|setSamplerState
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|setSamplerState
parameter_list|(
name|gl
operator|::
name|SamplerType
name|type
parameter_list|,
name|int
name|index
parameter_list|,
name|gl
operator|::
name|Texture
modifier|*
name|texture
parameter_list|,
specifier|const
name|gl
operator|::
name|SamplerState
modifier|&
name|samplerState
parameter_list|)
block|{
name|CurSamplerState
modifier|&
name|appliedSampler
init|=
operator|(
name|type
operator|==
name|gl
operator|::
name|SAMPLER_PIXEL
operator|)
condition|?
name|mCurPixelSamplerStates
index|[
name|index
index|]
else|:
name|mCurVertexSamplerStates
index|[
name|index
index|]
decl_stmt|;
comment|// Make sure to add the level offset for our tiny compressed texture workaround
name|TextureD3D
modifier|*
name|textureD3D
init|=
name|GetImplAs
argument_list|<
name|TextureD3D
argument_list|>
argument_list|(
name|texture
argument_list|)
decl_stmt|;
name|TextureStorage
modifier|*
name|storage
init|=
literal|nullptr
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|textureD3D
operator|->
name|getNativeTexture
argument_list|(
operator|&
name|storage
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
comment|// Storage should exist, texture should be complete
name|ASSERT
argument_list|(
name|storage
argument_list|)
expr_stmt|;
name|DWORD
name|baseLevel
init|=
name|texture
operator|->
name|getBaseLevel
argument_list|()
operator|+
name|storage
operator|->
name|getTopLevel
argument_list|()
decl_stmt|;
if|if
condition|(
name|appliedSampler
operator|.
name|forceSet
operator|||
name|appliedSampler
operator|.
name|baseLevel
operator|!=
name|baseLevel
operator|||
name|memcmp
argument_list|(
operator|&
name|samplerState
argument_list|,
operator|&
name|appliedSampler
argument_list|,
sizeof|sizeof
argument_list|(
name|gl
operator|::
name|SamplerState
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|d3dSamplerOffset
init|=
operator|(
name|type
operator|==
name|gl
operator|::
name|SAMPLER_PIXEL
operator|)
condition|?
literal|0
else|:
name|D3DVERTEXTEXTURESAMPLER0
decl_stmt|;
name|int
name|d3dSampler
init|=
name|index
operator|+
name|d3dSamplerOffset
decl_stmt|;
name|mDevice
operator|->
name|SetSamplerState
argument_list|(
name|d3dSampler
argument_list|,
name|D3DSAMP_ADDRESSU
argument_list|,
name|gl_d3d9
operator|::
name|ConvertTextureWrap
argument_list|(
name|samplerState
operator|.
name|wrapS
argument_list|)
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetSamplerState
argument_list|(
name|d3dSampler
argument_list|,
name|D3DSAMP_ADDRESSV
argument_list|,
name|gl_d3d9
operator|::
name|ConvertTextureWrap
argument_list|(
name|samplerState
operator|.
name|wrapT
argument_list|)
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetSamplerState
argument_list|(
name|d3dSampler
argument_list|,
name|D3DSAMP_MAGFILTER
argument_list|,
name|gl_d3d9
operator|::
name|ConvertMagFilter
argument_list|(
name|samplerState
operator|.
name|magFilter
argument_list|,
name|samplerState
operator|.
name|maxAnisotropy
argument_list|)
argument_list|)
expr_stmt|;
name|D3DTEXTUREFILTERTYPE
name|d3dMinFilter
decl_stmt|,
name|d3dMipFilter
decl_stmt|;
name|float
name|lodBias
decl_stmt|;
name|gl_d3d9
operator|::
name|ConvertMinFilter
argument_list|(
name|samplerState
operator|.
name|minFilter
argument_list|,
operator|&
name|d3dMinFilter
argument_list|,
operator|&
name|d3dMipFilter
argument_list|,
operator|&
name|lodBias
argument_list|,
name|samplerState
operator|.
name|maxAnisotropy
argument_list|,
name|baseLevel
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetSamplerState
argument_list|(
name|d3dSampler
argument_list|,
name|D3DSAMP_MINFILTER
argument_list|,
name|d3dMinFilter
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetSamplerState
argument_list|(
name|d3dSampler
argument_list|,
name|D3DSAMP_MIPFILTER
argument_list|,
name|d3dMipFilter
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetSamplerState
argument_list|(
name|d3dSampler
argument_list|,
name|D3DSAMP_MAXMIPLEVEL
argument_list|,
name|baseLevel
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetSamplerState
argument_list|(
name|d3dSampler
argument_list|,
name|D3DSAMP_MIPMAPLODBIAS
argument_list|,
cast|static_cast
argument_list|<
name|DWORD
argument_list|>
argument_list|(
name|lodBias
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|getRendererExtensions
argument_list|()
operator|.
name|textureFilterAnisotropic
condition|)
block|{
name|mDevice
operator|->
name|SetSamplerState
argument_list|(
name|d3dSampler
argument_list|,
name|D3DSAMP_MAXANISOTROPY
argument_list|,
operator|(
name|DWORD
operator|)
name|samplerState
operator|.
name|maxAnisotropy
argument_list|)
expr_stmt|;
block|}
block|}
name|appliedSampler
operator|.
name|forceSet
operator|=
literal|false
expr_stmt|;
name|appliedSampler
operator|.
name|samplerState
operator|=
name|samplerState
expr_stmt|;
name|appliedSampler
operator|.
name|baseLevel
operator|=
name|baseLevel
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|setTexture
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|setTexture
parameter_list|(
name|gl
operator|::
name|SamplerType
name|type
parameter_list|,
name|int
name|index
parameter_list|,
name|gl
operator|::
name|Texture
modifier|*
name|texture
parameter_list|)
block|{
name|int
name|d3dSamplerOffset
init|=
operator|(
name|type
operator|==
name|gl
operator|::
name|SAMPLER_PIXEL
operator|)
condition|?
literal|0
else|:
name|D3DVERTEXTEXTURESAMPLER0
decl_stmt|;
name|int
name|d3dSampler
init|=
name|index
operator|+
name|d3dSamplerOffset
decl_stmt|;
name|IDirect3DBaseTexture9
modifier|*
name|d3dTexture
init|=
name|NULL
decl_stmt|;
name|bool
name|forceSetTexture
init|=
literal|false
decl_stmt|;
name|std
operator|::
name|vector
argument_list|<
name|uintptr_t
argument_list|>
modifier|&
name|appliedTextures
init|=
operator|(
name|type
operator|==
name|gl
operator|::
name|SAMPLER_PIXEL
operator|)
condition|?
name|mCurPixelTextures
else|:
name|mCurVertexTextures
decl_stmt|;
if|if
condition|(
name|texture
condition|)
block|{
name|TextureD3D
modifier|*
name|textureImpl
init|=
name|GetImplAs
argument_list|<
name|TextureD3D
argument_list|>
argument_list|(
name|texture
argument_list|)
decl_stmt|;
name|TextureStorage
modifier|*
name|texStorage
init|=
literal|nullptr
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|textureImpl
operator|->
name|getNativeTexture
argument_list|(
operator|&
name|texStorage
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
comment|// Texture should be complete and have a storage
name|ASSERT
argument_list|(
name|texStorage
argument_list|)
expr_stmt|;
name|TextureStorage9
modifier|*
name|storage9
init|=
name|GetAs
argument_list|<
name|TextureStorage9
argument_list|>
argument_list|(
name|texStorage
argument_list|)
decl_stmt|;
name|error
operator|=
name|storage9
operator|->
name|getBaseTexture
argument_list|(
operator|&
name|d3dTexture
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
comment|// If we get NULL back from getBaseTexture here, something went wrong
comment|// in the texture class and we're unexpectedly missing the d3d texture
name|ASSERT
argument_list|(
name|d3dTexture
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|forceSetTexture
operator|=
name|textureImpl
operator|->
name|hasDirtyImages
argument_list|()
expr_stmt|;
name|textureImpl
operator|->
name|resetDirty
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|forceSetTexture
operator|||
name|appliedTextures
index|[
name|index
index|]
operator|!=
cast|reinterpret_cast
argument_list|<
name|uintptr_t
argument_list|>
argument_list|(
name|d3dTexture
argument_list|)
condition|)
block|{
name|mDevice
operator|->
name|SetTexture
argument_list|(
name|d3dSampler
argument_list|,
name|d3dTexture
argument_list|)
expr_stmt|;
block|}
name|appliedTextures
index|[
name|index
index|]
operator|=
cast|reinterpret_cast
argument_list|<
name|uintptr_t
argument_list|>
argument_list|(
name|d3dTexture
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|setUniformBuffers
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|setUniformBuffers
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
comment|/*data*/
parameter_list|,
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|GLint
argument_list|>
modifier|&
comment|/*vertexUniformBuffers*/
parameter_list|,
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|GLint
argument_list|>
modifier|&
comment|/*fragmentUniformBuffers*/
parameter_list|)
block|{
comment|// No effect in ES2/D3D9
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|syncState
name|void
name|Renderer9
operator|::
name|syncState
parameter_list|(
specifier|const
name|gl
operator|::
name|State
modifier|&
name|state
parameter_list|,
specifier|const
name|gl
operator|::
name|State
operator|::
name|DirtyBits
modifier|&
name|bitmask
parameter_list|)
block|{
name|mStateManager
operator|.
name|syncState
argument_list|(
name|state
argument_list|,
name|bitmask
argument_list|)
expr_stmt|;
block|}
DECL|function|updateState
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|updateState
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLenum
name|drawMode
parameter_list|)
block|{
comment|// Applies the render target surface, depth stencil surface, viewport rectangle and
comment|// scissor rectangle to the renderer
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebufferObject
init|=
name|data
operator|.
name|state
operator|->
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|framebufferObject
operator|&&
name|framebufferObject
operator|->
name|checkStatus
argument_list|(
name|data
argument_list|)
operator|==
name|GL_FRAMEBUFFER_COMPLETE
argument_list|)
expr_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|applyRenderTarget
argument_list|(
name|framebufferObject
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
comment|// Setting viewport state
name|setViewport
argument_list|(
name|data
operator|.
name|caps
argument_list|,
name|data
operator|.
name|state
operator|->
name|getViewport
argument_list|()
argument_list|,
name|data
operator|.
name|state
operator|->
name|getNearPlane
argument_list|()
argument_list|,
name|data
operator|.
name|state
operator|->
name|getFarPlane
argument_list|()
argument_list|,
name|drawMode
argument_list|,
name|data
operator|.
name|state
operator|->
name|getRasterizerState
argument_list|()
operator|.
name|frontFace
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Setting scissors state
name|setScissorRectangle
argument_list|(
name|data
operator|.
name|state
operator|->
name|getScissor
argument_list|()
argument_list|,
name|data
operator|.
name|state
operator|->
name|isScissorTestEnabled
argument_list|()
argument_list|)
expr_stmt|;
comment|// Setting blend, depth stencil, and rasterizer states
name|int
name|samples
init|=
name|framebufferObject
operator|->
name|getSamples
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|gl
operator|::
name|RasterizerState
name|rasterizer
init|=
name|data
operator|.
name|state
operator|->
name|getRasterizerState
argument_list|()
decl_stmt|;
name|rasterizer
operator|.
name|pointDrawMode
operator|=
operator|(
name|drawMode
operator|==
name|GL_POINTS
operator|)
expr_stmt|;
name|rasterizer
operator|.
name|multiSample
operator|=
operator|(
name|samples
operator|!=
literal|0
operator|)
expr_stmt|;
name|unsigned
name|int
name|mask
init|=
name|GetBlendSampleMask
argument_list|(
name|data
argument_list|,
name|samples
argument_list|)
decl_stmt|;
name|error
operator|=
name|setBlendDepthRasterStates
argument_list|(
name|data
argument_list|,
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|mStateManager
operator|.
name|resetDirtyBits
argument_list|()
expr_stmt|;
return|return
name|error
return|;
block|}
DECL|function|setScissorRectangle
name|void
name|Renderer9
operator|::
name|setScissorRectangle
parameter_list|(
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|scissor
parameter_list|,
name|bool
name|enabled
parameter_list|)
block|{
name|mStateManager
operator|.
name|setScissorState
argument_list|(
name|scissor
argument_list|,
name|enabled
argument_list|)
expr_stmt|;
block|}
DECL|function|setBlendDepthRasterStates
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|setBlendDepthRasterStates
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|glData
parameter_list|,
name|GLenum
name|drawMode
parameter_list|)
block|{
name|int
name|samples
init|=
name|glData
operator|.
name|state
operator|->
name|getDrawFramebuffer
argument_list|()
operator|->
name|getSamples
argument_list|(
name|glData
argument_list|)
decl_stmt|;
name|gl
operator|::
name|RasterizerState
name|rasterizer
init|=
name|glData
operator|.
name|state
operator|->
name|getRasterizerState
argument_list|()
decl_stmt|;
name|rasterizer
operator|.
name|pointDrawMode
operator|=
operator|(
name|drawMode
operator|==
name|GL_POINTS
operator|)
expr_stmt|;
name|rasterizer
operator|.
name|multiSample
operator|=
operator|(
name|samples
operator|!=
literal|0
operator|)
expr_stmt|;
name|unsigned
name|int
name|mask
init|=
name|GetBlendSampleMask
argument_list|(
name|glData
argument_list|,
name|samples
argument_list|)
decl_stmt|;
return|return
name|mStateManager
operator|.
name|setBlendDepthRasterStates
argument_list|(
operator|*
name|glData
operator|.
name|state
argument_list|,
name|mask
argument_list|)
return|;
block|}
DECL|function|setViewport
name|void
name|Renderer9
operator|::
name|setViewport
parameter_list|(
specifier|const
name|gl
operator|::
name|Caps
modifier|*
name|caps
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|viewport
parameter_list|,
name|float
name|zNear
parameter_list|,
name|float
name|zFar
parameter_list|,
name|GLenum
name|drawMode
parameter_list|,
name|GLenum
name|frontFace
parameter_list|,
name|bool
name|ignoreViewport
parameter_list|)
block|{
name|mStateManager
operator|.
name|setViewportState
argument_list|(
name|caps
argument_list|,
name|viewport
argument_list|,
name|zNear
argument_list|,
name|zFar
argument_list|,
name|drawMode
argument_list|,
name|frontFace
argument_list|,
name|ignoreViewport
argument_list|)
expr_stmt|;
block|}
DECL|function|applyPrimitiveType
name|bool
name|Renderer9
operator|::
name|applyPrimitiveType
parameter_list|(
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|bool
name|usesPointSize
parameter_list|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|GL_POINTS
case|:
name|mPrimitiveType
operator|=
name|D3DPT_POINTLIST
expr_stmt|;
name|mPrimitiveCount
operator|=
name|count
expr_stmt|;
break|break;
case|case
name|GL_LINES
case|:
name|mPrimitiveType
operator|=
name|D3DPT_LINELIST
expr_stmt|;
name|mPrimitiveCount
operator|=
name|count
operator|/
literal|2
expr_stmt|;
break|break;
case|case
name|GL_LINE_LOOP
case|:
name|mPrimitiveType
operator|=
name|D3DPT_LINESTRIP
expr_stmt|;
name|mPrimitiveCount
operator|=
name|count
operator|-
literal|1
expr_stmt|;
comment|// D3D doesn't support line loops, so we draw the last line separately
break|break;
case|case
name|GL_LINE_STRIP
case|:
name|mPrimitiveType
operator|=
name|D3DPT_LINESTRIP
expr_stmt|;
name|mPrimitiveCount
operator|=
name|count
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|GL_TRIANGLES
case|:
name|mPrimitiveType
operator|=
name|D3DPT_TRIANGLELIST
expr_stmt|;
name|mPrimitiveCount
operator|=
name|count
operator|/
literal|3
expr_stmt|;
break|break;
case|case
name|GL_TRIANGLE_STRIP
case|:
name|mPrimitiveType
operator|=
name|D3DPT_TRIANGLESTRIP
expr_stmt|;
name|mPrimitiveCount
operator|=
name|count
operator|-
literal|2
expr_stmt|;
break|break;
case|case
name|GL_TRIANGLE_FAN
case|:
name|mPrimitiveType
operator|=
name|D3DPT_TRIANGLEFAN
expr_stmt|;
name|mPrimitiveCount
operator|=
name|count
operator|-
literal|2
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|mPrimitiveCount
operator|>
literal|0
return|;
block|}
DECL|function|getNullColorbuffer
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|getNullColorbuffer
parameter_list|(
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|depthbuffer
parameter_list|,
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|*
modifier|*
name|outColorBuffer
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|depthbuffer
argument_list|)
expr_stmt|;
specifier|const
name|gl
operator|::
name|Extents
modifier|&
name|size
init|=
name|depthbuffer
operator|->
name|getSize
argument_list|()
decl_stmt|;
comment|// search cached nullcolorbuffers
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_NULL_COLORBUFFER_CACHE_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mNullColorbufferCache
index|[
name|i
index|]
operator|.
name|buffer
operator|!=
name|NULL
operator|&&
name|mNullColorbufferCache
index|[
name|i
index|]
operator|.
name|width
operator|==
name|size
operator|.
name|width
operator|&&
name|mNullColorbufferCache
index|[
name|i
index|]
operator|.
name|height
operator|==
name|size
operator|.
name|height
condition|)
block|{
name|mNullColorbufferCache
index|[
name|i
index|]
operator|.
name|lruCount
operator|=
operator|++
name|mMaxNullColorbufferLRU
expr_stmt|;
operator|*
name|outColorBuffer
operator|=
name|mNullColorbufferCache
index|[
name|i
index|]
operator|.
name|buffer
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
block|}
name|gl
operator|::
name|Renderbuffer
modifier|*
name|nullRenderbuffer
init|=
operator|new
name|gl
operator|::
name|Renderbuffer
argument_list|(
name|createRenderbuffer
argument_list|()
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|nullRenderbuffer
operator|->
name|setStorage
argument_list|(
name|GL_NONE
argument_list|,
name|size
operator|.
name|width
argument_list|,
name|size
operator|.
name|height
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
name|SafeDelete
argument_list|(
name|nullRenderbuffer
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|nullbuffer
init|=
operator|new
name|gl
operator|::
name|FramebufferAttachment
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|GL_NONE
argument_list|,
name|gl
operator|::
name|ImageIndex
operator|::
name|MakeInvalid
argument_list|()
argument_list|,
name|nullRenderbuffer
argument_list|)
decl_stmt|;
comment|// add nullbuffer to the cache
name|NullColorbufferCacheEntry
modifier|*
name|oldest
init|=
operator|&
name|mNullColorbufferCache
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|NUM_NULL_COLORBUFFER_CACHE_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mNullColorbufferCache
index|[
name|i
index|]
operator|.
name|lruCount
operator|<
name|oldest
operator|->
name|lruCount
condition|)
block|{
name|oldest
operator|=
operator|&
name|mNullColorbufferCache
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
operator|delete
name|oldest
operator|->
name|buffer
expr_stmt|;
name|oldest
operator|->
name|buffer
operator|=
name|nullbuffer
expr_stmt|;
name|oldest
operator|->
name|lruCount
operator|=
operator|++
name|mMaxNullColorbufferLRU
expr_stmt|;
name|oldest
operator|->
name|width
operator|=
name|size
operator|.
name|width
expr_stmt|;
name|oldest
operator|->
name|height
operator|=
name|size
operator|.
name|height
expr_stmt|;
operator|*
name|outColorBuffer
operator|=
name|nullbuffer
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|applyRenderTarget
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|applyRenderTarget
parameter_list|(
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|colorAttachment
parameter_list|,
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|depthStencilAttachment
parameter_list|)
block|{
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|renderAttachment
init|=
name|colorAttachment
decl_stmt|;
name|gl
operator|::
name|Error
name|error
argument_list|(
name|GL_NO_ERROR
argument_list|)
decl_stmt|;
comment|// if there is no color attachment we must synthesize a NULL colorattachment
comment|// to keep the D3D runtime happy.  This should only be possible if depth texturing.
if|if
condition|(
name|renderAttachment
operator|==
literal|nullptr
condition|)
block|{
name|error
operator|=
name|getNullColorbuffer
argument_list|(
name|depthStencilAttachment
argument_list|,
operator|&
name|renderAttachment
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
name|ASSERT
argument_list|(
name|renderAttachment
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
name|size_t
name|renderTargetWidth
init|=
literal|0
decl_stmt|;
name|size_t
name|renderTargetHeight
init|=
literal|0
decl_stmt|;
name|D3DFORMAT
name|renderTargetFormat
init|=
name|D3DFMT_UNKNOWN
decl_stmt|;
name|RenderTarget9
modifier|*
name|renderTarget
init|=
literal|nullptr
decl_stmt|;
name|error
operator|=
name|renderAttachment
operator|->
name|getRenderTarget
argument_list|(
operator|&
name|renderTarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|renderTarget
argument_list|)
expr_stmt|;
name|bool
name|renderTargetChanged
init|=
literal|false
decl_stmt|;
name|unsigned
name|int
name|renderTargetSerial
init|=
name|renderTarget
operator|->
name|getSerial
argument_list|()
decl_stmt|;
if|if
condition|(
name|renderTargetSerial
operator|!=
name|mAppliedRenderTargetSerial
condition|)
block|{
comment|// Apply the render target on the device
name|IDirect3DSurface9
modifier|*
name|renderTargetSurface
init|=
name|renderTarget
operator|->
name|getSurface
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|renderTargetSurface
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderTarget
argument_list|(
literal|0
argument_list|,
name|renderTargetSurface
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|renderTargetSurface
argument_list|)
expr_stmt|;
name|renderTargetWidth
operator|=
name|renderTarget
operator|->
name|getWidth
argument_list|()
expr_stmt|;
name|renderTargetHeight
operator|=
name|renderTarget
operator|->
name|getHeight
argument_list|()
expr_stmt|;
name|renderTargetFormat
operator|=
name|renderTarget
operator|->
name|getD3DFormat
argument_list|()
expr_stmt|;
name|mAppliedRenderTargetSerial
operator|=
name|renderTargetSerial
expr_stmt|;
name|renderTargetChanged
operator|=
literal|true
expr_stmt|;
block|}
name|RenderTarget9
modifier|*
name|depthStencilRenderTarget
init|=
literal|nullptr
decl_stmt|;
name|unsigned
name|int
name|depthStencilSerial
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|depthStencilAttachment
operator|!=
literal|nullptr
condition|)
block|{
name|error
operator|=
name|depthStencilAttachment
operator|->
name|getRenderTarget
argument_list|(
operator|&
name|depthStencilRenderTarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|depthStencilRenderTarget
argument_list|)
expr_stmt|;
name|depthStencilSerial
operator|=
name|depthStencilRenderTarget
operator|->
name|getSerial
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|depthStencilSerial
operator|!=
name|mAppliedDepthStencilSerial
operator|||
operator|!
name|mDepthStencilInitialized
condition|)
block|{
name|unsigned
name|int
name|depthSize
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|stencilSize
init|=
literal|0
decl_stmt|;
comment|// Apply the depth stencil on the device
if|if
condition|(
name|depthStencilRenderTarget
condition|)
block|{
name|IDirect3DSurface9
modifier|*
name|depthStencilSurface
init|=
name|depthStencilRenderTarget
operator|->
name|getSurface
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|depthStencilSurface
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetDepthStencilSurface
argument_list|(
name|depthStencilSurface
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|depthStencilSurface
argument_list|)
expr_stmt|;
name|depthSize
operator|=
name|depthStencilAttachment
operator|->
name|getDepthSize
argument_list|()
expr_stmt|;
name|stencilSize
operator|=
name|depthStencilAttachment
operator|->
name|getStencilSize
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|mDevice
operator|->
name|SetDepthStencilSurface
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
name|mStateManager
operator|.
name|updateDepthSizeIfChanged
argument_list|(
name|mDepthStencilInitialized
argument_list|,
name|depthSize
argument_list|)
expr_stmt|;
name|mStateManager
operator|.
name|updateStencilSizeIfChanged
argument_list|(
name|mDepthStencilInitialized
argument_list|,
name|stencilSize
argument_list|)
expr_stmt|;
name|mAppliedDepthStencilSerial
operator|=
name|depthStencilSerial
expr_stmt|;
name|mDepthStencilInitialized
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|renderTargetChanged
operator|||
operator|!
name|mRenderTargetDescInitialized
condition|)
block|{
name|mStateManager
operator|.
name|forceSetBlendState
argument_list|()
expr_stmt|;
name|mStateManager
operator|.
name|forceSetScissorState
argument_list|()
expr_stmt|;
name|mStateManager
operator|.
name|setRenderTargetBounds
argument_list|(
name|renderTargetWidth
argument_list|,
name|renderTargetHeight
argument_list|)
expr_stmt|;
name|mRenderTargetDescInitialized
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|applyRenderTarget
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|applyRenderTarget
parameter_list|(
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
parameter_list|)
block|{
return|return
name|applyRenderTarget
argument_list|(
name|framebuffer
operator|->
name|getColorbuffer
argument_list|(
literal|0
argument_list|)
argument_list|,
name|framebuffer
operator|->
name|getDepthOrStencilbuffer
argument_list|()
argument_list|)
return|;
block|}
DECL|function|applyVertexBuffer
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|applyVertexBuffer
parameter_list|(
specifier|const
name|gl
operator|::
name|State
modifier|&
name|state
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLint
name|first
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLsizei
name|instances
parameter_list|,
name|TranslatedIndexData
modifier|*
comment|/*indexInfo*/
parameter_list|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|mVertexDataManager
operator|->
name|prepareVertexData
argument_list|(
name|state
argument_list|,
name|first
argument_list|,
name|count
argument_list|,
operator|&
name|mTranslatedAttribCache
argument_list|,
name|instances
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
return|return
name|mVertexDeclarationCache
operator|.
name|applyDeclaration
argument_list|(
name|mDevice
argument_list|,
name|mTranslatedAttribCache
argument_list|,
name|state
operator|.
name|getProgram
argument_list|()
argument_list|,
name|instances
argument_list|,
operator|&
name|mRepeatDraw
argument_list|)
return|;
block|}
comment|// Applies the indices and element array bindings to the Direct3D 9 device
DECL|function|applyIndexBuffer
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|applyIndexBuffer
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|TranslatedIndexData
modifier|*
name|indexInfo
parameter_list|)
block|{
name|gl
operator|::
name|VertexArray
modifier|*
name|vao
init|=
name|data
operator|.
name|state
operator|->
name|getVertexArray
argument_list|()
decl_stmt|;
name|gl
operator|::
name|Buffer
modifier|*
name|elementArrayBuffer
init|=
name|vao
operator|->
name|getElementArrayBuffer
argument_list|()
operator|.
name|get
argument_list|()
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|mIndexDataManager
operator|->
name|prepareIndexData
argument_list|(
name|type
argument_list|,
name|count
argument_list|,
name|elementArrayBuffer
argument_list|,
name|indices
argument_list|,
name|indexInfo
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
comment|// Directly binding the storage buffer is not supported for d3d9
name|ASSERT
argument_list|(
name|indexInfo
operator|->
name|storage
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|indexInfo
operator|->
name|serial
operator|!=
name|mAppliedIBSerial
condition|)
block|{
name|IndexBuffer9
modifier|*
name|indexBuffer
init|=
name|GetAs
argument_list|<
name|IndexBuffer9
argument_list|>
argument_list|(
name|indexInfo
operator|->
name|indexBuffer
argument_list|)
decl_stmt|;
name|mDevice
operator|->
name|SetIndices
argument_list|(
name|indexBuffer
operator|->
name|getBuffer
argument_list|()
argument_list|)
expr_stmt|;
name|mAppliedIBSerial
operator|=
name|indexInfo
operator|->
name|serial
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|applyTransformFeedbackBuffers
name|void
name|Renderer9
operator|::
name|applyTransformFeedbackBuffers
parameter_list|(
specifier|const
name|gl
operator|::
name|State
modifier|&
name|state
parameter_list|)
block|{
name|ASSERT
argument_list|(
operator|!
name|state
operator|.
name|isTransformFeedbackActiveUnpaused
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|function|drawArraysImpl
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|drawArraysImpl
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLsizei
name|instances
parameter_list|)
block|{
name|ASSERT
argument_list|(
operator|!
name|data
operator|.
name|state
operator|->
name|isTransformFeedbackActiveUnpaused
argument_list|()
argument_list|)
expr_stmt|;
name|startScene
argument_list|()
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|GL_LINE_LOOP
condition|)
block|{
return|return
name|drawLineLoop
argument_list|(
name|count
argument_list|,
name|GL_NONE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|instances
operator|>
literal|0
condition|)
block|{
name|StaticIndexBufferInterface
modifier|*
name|countingIB
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|getCountingIB
argument_list|(
name|count
argument_list|,
operator|&
name|countingIB
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
name|mAppliedIBSerial
operator|!=
name|countingIB
operator|->
name|getSerial
argument_list|()
condition|)
block|{
name|IndexBuffer9
modifier|*
name|indexBuffer
init|=
name|GetAs
argument_list|<
name|IndexBuffer9
argument_list|>
argument_list|(
name|countingIB
operator|->
name|getIndexBuffer
argument_list|()
argument_list|)
decl_stmt|;
name|mDevice
operator|->
name|SetIndices
argument_list|(
name|indexBuffer
operator|->
name|getBuffer
argument_list|()
argument_list|)
expr_stmt|;
name|mAppliedIBSerial
operator|=
name|countingIB
operator|->
name|getSerial
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mRepeatDraw
condition|;
name|i
operator|++
control|)
block|{
name|mDevice
operator|->
name|DrawIndexedPrimitive
argument_list|(
name|mPrimitiveType
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|count
argument_list|,
literal|0
argument_list|,
name|mPrimitiveCount
argument_list|)
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
else|else
comment|// Regular case
block|{
name|mDevice
operator|->
name|DrawPrimitive
argument_list|(
name|mPrimitiveType
argument_list|,
literal|0
argument_list|,
name|mPrimitiveCount
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
block|}
DECL|function|drawElementsImpl
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|drawElementsImpl
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
specifier|const
name|TranslatedIndexData
modifier|&
name|indexInfo
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|GLsizei
comment|/*instances*/
parameter_list|)
block|{
name|startScene
argument_list|()
expr_stmt|;
name|int
name|minIndex
init|=
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|indexInfo
operator|.
name|indexRange
operator|.
name|start
argument_list|)
decl_stmt|;
name|gl
operator|::
name|VertexArray
modifier|*
name|vao
init|=
name|data
operator|.
name|state
operator|->
name|getVertexArray
argument_list|()
decl_stmt|;
name|gl
operator|::
name|Buffer
modifier|*
name|elementArrayBuffer
init|=
name|vao
operator|->
name|getElementArrayBuffer
argument_list|()
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|GL_POINTS
condition|)
block|{
return|return
name|drawIndexedPoints
argument_list|(
name|count
argument_list|,
name|type
argument_list|,
name|indices
argument_list|,
name|minIndex
argument_list|,
name|elementArrayBuffer
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|GL_LINE_LOOP
condition|)
block|{
return|return
name|drawLineLoop
argument_list|(
name|count
argument_list|,
name|type
argument_list|,
name|indices
argument_list|,
name|minIndex
argument_list|,
name|elementArrayBuffer
argument_list|)
return|;
block|}
else|else
block|{
name|size_t
name|vertexCount
init|=
name|indexInfo
operator|.
name|indexRange
operator|.
name|vertexCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mRepeatDraw
condition|;
name|i
operator|++
control|)
block|{
name|mDevice
operator|->
name|DrawIndexedPrimitive
argument_list|(
name|mPrimitiveType
argument_list|,
operator|-
name|minIndex
argument_list|,
name|minIndex
argument_list|,
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|vertexCount
argument_list|)
argument_list|,
name|indexInfo
operator|.
name|startIndex
argument_list|,
name|mPrimitiveCount
argument_list|)
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
block|}
DECL|function|drawLineLoop
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|drawLineLoop
parameter_list|(
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|int
name|minIndex
parameter_list|,
name|gl
operator|::
name|Buffer
modifier|*
name|elementArrayBuffer
parameter_list|)
block|{
comment|// Get the raw indices for an indexed draw
if|if
condition|(
name|type
operator|!=
name|GL_NONE
operator|&&
name|elementArrayBuffer
condition|)
block|{
name|BufferD3D
modifier|*
name|storage
init|=
name|GetImplAs
argument_list|<
name|BufferD3D
argument_list|>
argument_list|(
name|elementArrayBuffer
argument_list|)
decl_stmt|;
name|intptr_t
name|offset
init|=
cast|reinterpret_cast
argument_list|<
name|intptr_t
argument_list|>
argument_list|(
name|indices
argument_list|)
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|bufferData
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|storage
operator|->
name|getData
argument_list|(
operator|&
name|bufferData
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|indices
operator|=
name|bufferData
operator|+
name|offset
expr_stmt|;
block|}
name|unsigned
name|int
name|startIndex
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|getRendererExtensions
argument_list|()
operator|.
name|elementIndexUint
condition|)
block|{
if|if
condition|(
operator|!
name|mLineLoopIB
condition|)
block|{
name|mLineLoopIB
operator|=
operator|new
name|StreamingIndexBufferInterface
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|mLineLoopIB
operator|->
name|reserveBufferSpace
argument_list|(
name|INITIAL_INDEX_BUFFER_SIZE
argument_list|,
name|GL_UNSIGNED_INT
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
name|SafeDelete
argument_list|(
name|mLineLoopIB
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
comment|// Checked by Renderer9::applyPrimitiveType
name|ASSERT
argument_list|(
name|count
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|count
argument_list|)
operator|+
literal|1
operator|>
operator|(
name|std
operator|::
name|numeric_limits
argument_list|<
name|unsigned
name|int
argument_list|>
operator|::
name|max
argument_list|()
operator|/
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
operator|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create a 32-bit looping index buffer for GL_LINE_LOOP, too many indices required."
argument_list|)
return|;
block|}
specifier|const
name|unsigned
name|int
name|spaceNeeded
init|=
operator|(
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|count
argument_list|)
operator|+
literal|1
operator|)
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|mLineLoopIB
operator|->
name|reserveBufferSpace
argument_list|(
name|spaceNeeded
argument_list|,
name|GL_UNSIGNED_INT
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|void
modifier|*
name|mappedMemory
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|error
operator|=
name|mLineLoopIB
operator|->
name|mapBuffer
argument_list|(
name|spaceNeeded
argument_list|,
operator|&
name|mappedMemory
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|startIndex
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|offset
argument_list|)
operator|/
literal|4
expr_stmt|;
name|unsigned
name|int
modifier|*
name|data
init|=
cast|reinterpret_cast
argument_list|<
name|unsigned
name|int
operator|*
argument_list|>
argument_list|(
name|mappedMemory
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_NONE
case|:
comment|// Non-indexed draw
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
name|data
index|[
name|count
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_BYTE
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLubyte
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
index|]
expr_stmt|;
block|}
name|data
index|[
name|count
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLubyte
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_SHORT
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLushort
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
index|]
expr_stmt|;
block|}
name|data
index|[
name|count
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLushort
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_INT
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLuint
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
index|]
expr_stmt|;
block|}
name|data
index|[
name|count
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLuint
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
name|error
operator|=
name|mLineLoopIB
operator|->
name|unmapBuffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|mLineLoopIB
condition|)
block|{
name|mLineLoopIB
operator|=
operator|new
name|StreamingIndexBufferInterface
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|mLineLoopIB
operator|->
name|reserveBufferSpace
argument_list|(
name|INITIAL_INDEX_BUFFER_SIZE
argument_list|,
name|GL_UNSIGNED_SHORT
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
name|SafeDelete
argument_list|(
name|mLineLoopIB
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
comment|// Checked by Renderer9::applyPrimitiveType
name|ASSERT
argument_list|(
name|count
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|count
argument_list|)
operator|+
literal|1
operator|>
operator|(
name|std
operator|::
name|numeric_limits
argument_list|<
name|unsigned
name|short
argument_list|>
operator|::
name|max
argument_list|()
operator|/
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
operator|)
condition|)
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create a 16-bit looping index buffer for GL_LINE_LOOP, too many indices required."
argument_list|)
return|;
block|}
specifier|const
name|unsigned
name|int
name|spaceNeeded
init|=
operator|(
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|count
argument_list|)
operator|+
literal|1
operator|)
operator|*
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|mLineLoopIB
operator|->
name|reserveBufferSpace
argument_list|(
name|spaceNeeded
argument_list|,
name|GL_UNSIGNED_SHORT
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|void
modifier|*
name|mappedMemory
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
name|error
operator|=
name|mLineLoopIB
operator|->
name|mapBuffer
argument_list|(
name|spaceNeeded
argument_list|,
operator|&
name|mappedMemory
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|startIndex
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|offset
argument_list|)
operator|/
literal|2
expr_stmt|;
name|unsigned
name|short
modifier|*
name|data
init|=
cast|reinterpret_cast
argument_list|<
name|unsigned
name|short
operator|*
argument_list|>
argument_list|(
name|mappedMemory
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_NONE
case|:
comment|// Non-indexed draw
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|short
argument_list|>
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|data
index|[
name|count
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_BYTE
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLubyte
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
index|]
expr_stmt|;
block|}
name|data
index|[
name|count
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLubyte
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_SHORT
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLushort
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
index|]
expr_stmt|;
block|}
name|data
index|[
name|count
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLushort
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_INT
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|short
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|GLuint
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|data
index|[
name|count
index|]
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|short
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|GLuint
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
name|error
operator|=
name|mLineLoopIB
operator|->
name|unmapBuffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
if|if
condition|(
name|mAppliedIBSerial
operator|!=
name|mLineLoopIB
operator|->
name|getSerial
argument_list|()
condition|)
block|{
name|IndexBuffer9
modifier|*
name|indexBuffer
init|=
name|GetAs
argument_list|<
name|IndexBuffer9
argument_list|>
argument_list|(
name|mLineLoopIB
operator|->
name|getIndexBuffer
argument_list|()
argument_list|)
decl_stmt|;
name|mDevice
operator|->
name|SetIndices
argument_list|(
name|indexBuffer
operator|->
name|getBuffer
argument_list|()
argument_list|)
expr_stmt|;
name|mAppliedIBSerial
operator|=
name|mLineLoopIB
operator|->
name|getSerial
argument_list|()
expr_stmt|;
block|}
name|mDevice
operator|->
name|DrawIndexedPrimitive
argument_list|(
name|D3DPT_LINESTRIP
argument_list|,
operator|-
name|minIndex
argument_list|,
name|minIndex
argument_list|,
name|count
argument_list|,
name|startIndex
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|drawPoints
specifier|static
name|gl
operator|::
name|Error
name|drawPoints
parameter_list|(
name|IDirect3DDevice9
modifier|*
name|device
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|int
name|minIndex
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|indexValue
init|=
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|T
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
index|]
argument_list|)
operator|-
name|minIndex
decl_stmt|;
name|device
operator|->
name|DrawPrimitive
argument_list|(
name|D3DPT_POINTLIST
argument_list|,
name|indexValue
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|drawIndexedPoints
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|drawIndexedPoints
parameter_list|(
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|int
name|minIndex
parameter_list|,
name|gl
operator|::
name|Buffer
modifier|*
name|elementArrayBuffer
parameter_list|)
block|{
comment|// Drawing index point lists is unsupported in d3d9, fall back to a regular DrawPrimitive call
comment|// for each individual point. This call is not expected to happen often.
if|if
condition|(
name|elementArrayBuffer
condition|)
block|{
name|BufferD3D
modifier|*
name|storage
init|=
name|GetImplAs
argument_list|<
name|BufferD3D
argument_list|>
argument_list|(
name|elementArrayBuffer
argument_list|)
decl_stmt|;
name|intptr_t
name|offset
init|=
cast|reinterpret_cast
argument_list|<
name|intptr_t
argument_list|>
argument_list|(
name|indices
argument_list|)
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|bufferData
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|storage
operator|->
name|getData
argument_list|(
operator|&
name|bufferData
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|indices
operator|=
name|bufferData
operator|+
name|offset
expr_stmt|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_UNSIGNED_BYTE
case|:
return|return
name|drawPoints
argument_list|<
name|GLubyte
argument_list|>
argument_list|(
name|mDevice
argument_list|,
name|count
argument_list|,
name|indices
argument_list|,
name|minIndex
argument_list|)
return|;
case|case
name|GL_UNSIGNED_SHORT
case|:
return|return
name|drawPoints
argument_list|<
name|GLushort
argument_list|>
argument_list|(
name|mDevice
argument_list|,
name|count
argument_list|,
name|indices
argument_list|,
name|minIndex
argument_list|)
return|;
case|case
name|GL_UNSIGNED_INT
case|:
return|return
name|drawPoints
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|mDevice
argument_list|,
name|count
argument_list|,
name|indices
argument_list|,
name|minIndex
argument_list|)
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
block|}
DECL|function|getCountingIB
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|getCountingIB
parameter_list|(
name|size_t
name|count
parameter_list|,
name|StaticIndexBufferInterface
modifier|*
modifier|*
name|outIB
parameter_list|)
block|{
comment|// Update the counting index buffer if it is not large enough or has not been created yet.
if|if
condition|(
name|count
operator|<=
literal|65536
condition|)
comment|// 16-bit indices
block|{
specifier|const
name|unsigned
name|int
name|spaceNeeded
init|=
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|count
argument_list|)
operator|*
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|mCountingIB
operator|||
name|mCountingIB
operator|->
name|getBufferSize
argument_list|()
operator|<
name|spaceNeeded
condition|)
block|{
name|SafeDelete
argument_list|(
name|mCountingIB
argument_list|)
expr_stmt|;
name|mCountingIB
operator|=
operator|new
name|StaticIndexBufferInterface
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|mCountingIB
operator|->
name|reserveBufferSpace
argument_list|(
name|spaceNeeded
argument_list|,
name|GL_UNSIGNED_SHORT
argument_list|)
expr_stmt|;
name|void
modifier|*
name|mappedMemory
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|mCountingIB
operator|->
name|mapBuffer
argument_list|(
name|spaceNeeded
argument_list|,
operator|&
name|mappedMemory
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|unsigned
name|short
modifier|*
name|data
init|=
cast|reinterpret_cast
argument_list|<
name|unsigned
name|short
operator|*
argument_list|>
argument_list|(
name|mappedMemory
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|short
argument_list|>
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|mCountingIB
operator|->
name|unmapBuffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|getRendererExtensions
argument_list|()
operator|.
name|elementIndexUint
condition|)
block|{
specifier|const
name|unsigned
name|int
name|spaceNeeded
init|=
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|count
argument_list|)
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|mCountingIB
operator|||
name|mCountingIB
operator|->
name|getBufferSize
argument_list|()
operator|<
name|spaceNeeded
condition|)
block|{
name|SafeDelete
argument_list|(
name|mCountingIB
argument_list|)
expr_stmt|;
name|mCountingIB
operator|=
operator|new
name|StaticIndexBufferInterface
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|mCountingIB
operator|->
name|reserveBufferSpace
argument_list|(
name|spaceNeeded
argument_list|,
name|GL_UNSIGNED_INT
argument_list|)
expr_stmt|;
name|void
modifier|*
name|mappedMemory
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|mCountingIB
operator|->
name|mapBuffer
argument_list|(
name|spaceNeeded
argument_list|,
operator|&
name|mappedMemory
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|unsigned
name|int
modifier|*
name|data
init|=
cast|reinterpret_cast
argument_list|<
name|unsigned
name|int
operator|*
argument_list|>
argument_list|(
name|mappedMemory
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
name|error
operator|=
name|mCountingIB
operator|->
name|unmapBuffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
block|}
else|else
block|{
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Could not create a counting index buffer for glDrawArraysInstanced."
argument_list|)
return|;
block|}
operator|*
name|outIB
operator|=
name|mCountingIB
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|applyShadersImpl
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|applyShadersImpl
parameter_list|(
specifier|const
name|gl
operator|::
name|Data
modifier|&
name|data
parameter_list|,
name|GLenum
comment|/*drawMode*/
parameter_list|)
block|{
name|ProgramD3D
modifier|*
name|programD3D
init|=
name|GetImplAs
argument_list|<
name|ProgramD3D
argument_list|>
argument_list|(
name|data
operator|.
name|state
operator|->
name|getProgram
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
specifier|auto
modifier|&
name|inputLayout
init|=
name|programD3D
operator|->
name|getCachedInputLayout
argument_list|()
decl_stmt|;
name|ShaderExecutableD3D
modifier|*
name|vertexExe
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|programD3D
operator|->
name|getVertexExecutableForInputLayout
argument_list|(
name|inputLayout
argument_list|,
operator|&
name|vertexExe
argument_list|,
literal|nullptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|drawFramebuffer
init|=
name|data
operator|.
name|state
operator|->
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
name|ShaderExecutableD3D
modifier|*
name|pixelExe
init|=
name|NULL
decl_stmt|;
name|error
operator|=
name|programD3D
operator|->
name|getPixelExecutableForFramebuffer
argument_list|(
name|drawFramebuffer
argument_list|,
operator|&
name|pixelExe
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|IDirect3DVertexShader9
modifier|*
name|vertexShader
init|=
operator|(
name|vertexExe
condition|?
name|GetAs
argument_list|<
name|ShaderExecutable9
argument_list|>
argument_list|(
name|vertexExe
argument_list|)
operator|->
name|getVertexShader
argument_list|()
else|:
literal|nullptr
operator|)
decl_stmt|;
name|IDirect3DPixelShader9
modifier|*
name|pixelShader
init|=
operator|(
name|pixelExe
condition|?
name|GetAs
argument_list|<
name|ShaderExecutable9
argument_list|>
argument_list|(
name|pixelExe
argument_list|)
operator|->
name|getPixelShader
argument_list|()
else|:
literal|nullptr
operator|)
decl_stmt|;
if|if
condition|(
name|vertexShader
operator|!=
name|mAppliedVertexShader
condition|)
block|{
name|mDevice
operator|->
name|SetVertexShader
argument_list|(
name|vertexShader
argument_list|)
expr_stmt|;
name|mAppliedVertexShader
operator|=
name|vertexShader
expr_stmt|;
block|}
if|if
condition|(
name|pixelShader
operator|!=
name|mAppliedPixelShader
condition|)
block|{
name|mDevice
operator|->
name|SetPixelShader
argument_list|(
name|pixelShader
argument_list|)
expr_stmt|;
name|mAppliedPixelShader
operator|=
name|pixelShader
expr_stmt|;
block|}
comment|// D3D9 has a quirk where creating multiple shaders with the same content
comment|// can return the same shader pointer. Because GL programs store different data
comment|// per-program, checking the program serial guarantees we upload fresh
comment|// uniform data even if our shader pointers are the same.
comment|// https://code.google.com/p/angleproject/issues/detail?id=661
name|unsigned
name|int
name|programSerial
init|=
name|programD3D
operator|->
name|getSerial
argument_list|()
decl_stmt|;
if|if
condition|(
name|programSerial
operator|!=
name|mAppliedProgramSerial
condition|)
block|{
name|programD3D
operator|->
name|dirtyAllUniforms
argument_list|()
expr_stmt|;
name|mStateManager
operator|.
name|forceSetDXUniformsState
argument_list|()
expr_stmt|;
name|mAppliedProgramSerial
operator|=
name|programSerial
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|applyUniforms
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|applyUniforms
parameter_list|(
specifier|const
name|ProgramD3D
modifier|&
name|programD3D
parameter_list|,
name|GLenum
comment|/*drawMode*/
parameter_list|,
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|D3DUniform
modifier|*
argument_list|>
modifier|&
name|uniformArray
parameter_list|)
block|{
for|for
control|(
specifier|const
name|D3DUniform
modifier|*
name|targetUniform
range|:
name|uniformArray
control|)
block|{
if|if
condition|(
operator|!
name|targetUniform
operator|->
name|dirty
condition|)
continue|continue;
name|GLfloat
modifier|*
name|f
init|=
operator|(
name|GLfloat
operator|*
operator|)
name|targetUniform
operator|->
name|data
decl_stmt|;
name|GLint
modifier|*
name|i
init|=
operator|(
name|GLint
operator|*
operator|)
name|targetUniform
operator|->
name|data
decl_stmt|;
switch|switch
condition|(
name|targetUniform
operator|->
name|type
condition|)
block|{
case|case
name|GL_SAMPLER_2D
case|:
case|case
name|GL_SAMPLER_CUBE
case|:
break|break;
case|case
name|GL_BOOL
case|:
case|case
name|GL_BOOL_VEC2
case|:
case|case
name|GL_BOOL_VEC3
case|:
case|case
name|GL_BOOL_VEC4
case|:
name|applyUniformnbv
argument_list|(
name|targetUniform
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_FLOAT
case|:
case|case
name|GL_FLOAT_VEC2
case|:
case|case
name|GL_FLOAT_VEC3
case|:
case|case
name|GL_FLOAT_VEC4
case|:
case|case
name|GL_FLOAT_MAT2
case|:
case|case
name|GL_FLOAT_MAT3
case|:
case|case
name|GL_FLOAT_MAT4
case|:
name|applyUniformnfv
argument_list|(
name|targetUniform
argument_list|,
name|f
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_INT
case|:
case|case
name|GL_INT_VEC2
case|:
case|case
name|GL_INT_VEC3
case|:
case|case
name|GL_INT_VEC4
case|:
name|applyUniformniv
argument_list|(
name|targetUniform
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Driver uniforms
name|mStateManager
operator|.
name|setShaderConstants
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|applyUniformnfv
name|void
name|Renderer9
operator|::
name|applyUniformnfv
parameter_list|(
specifier|const
name|D3DUniform
modifier|*
name|targetUniform
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
name|targetUniform
operator|->
name|isReferencedByFragmentShader
argument_list|()
condition|)
block|{
name|mDevice
operator|->
name|SetPixelShaderConstantF
argument_list|(
name|targetUniform
operator|->
name|psRegisterIndex
argument_list|,
name|v
argument_list|,
name|targetUniform
operator|->
name|registerCount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targetUniform
operator|->
name|isReferencedByVertexShader
argument_list|()
condition|)
block|{
name|mDevice
operator|->
name|SetVertexShaderConstantF
argument_list|(
name|targetUniform
operator|->
name|vsRegisterIndex
argument_list|,
name|v
argument_list|,
name|targetUniform
operator|->
name|registerCount
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|applyUniformniv
name|void
name|Renderer9
operator|::
name|applyUniformniv
parameter_list|(
specifier|const
name|D3DUniform
modifier|*
name|targetUniform
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|targetUniform
operator|->
name|registerCount
operator|<=
name|MAX_VERTEX_CONSTANT_VECTORS_D3D9
argument_list|)
expr_stmt|;
name|GLfloat
name|vector
index|[
name|MAX_VERTEX_CONSTANT_VECTORS_D3D9
index|]
index|[
literal|4
index|]
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|targetUniform
operator|->
name|registerCount
condition|;
name|i
operator|++
control|)
block|{
name|vector
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
operator|(
name|GLfloat
operator|)
name|v
index|[
literal|4
operator|*
name|i
operator|+
literal|0
index|]
expr_stmt|;
name|vector
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
operator|(
name|GLfloat
operator|)
name|v
index|[
literal|4
operator|*
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|vector
index|[
name|i
index|]
index|[
literal|2
index|]
operator|=
operator|(
name|GLfloat
operator|)
name|v
index|[
literal|4
operator|*
name|i
operator|+
literal|2
index|]
expr_stmt|;
name|vector
index|[
name|i
index|]
index|[
literal|3
index|]
operator|=
operator|(
name|GLfloat
operator|)
name|v
index|[
literal|4
operator|*
name|i
operator|+
literal|3
index|]
expr_stmt|;
block|}
name|applyUniformnfv
argument_list|(
name|targetUniform
argument_list|,
operator|(
name|GLfloat
operator|*
operator|)
name|vector
argument_list|)
expr_stmt|;
block|}
DECL|function|applyUniformnbv
name|void
name|Renderer9
operator|::
name|applyUniformnbv
parameter_list|(
specifier|const
name|D3DUniform
modifier|*
name|targetUniform
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|targetUniform
operator|->
name|registerCount
operator|<=
name|MAX_VERTEX_CONSTANT_VECTORS_D3D9
argument_list|)
expr_stmt|;
name|GLfloat
name|vector
index|[
name|MAX_VERTEX_CONSTANT_VECTORS_D3D9
index|]
index|[
literal|4
index|]
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|targetUniform
operator|->
name|registerCount
condition|;
name|i
operator|++
control|)
block|{
name|vector
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
operator|(
name|v
index|[
literal|4
operator|*
name|i
operator|+
literal|0
index|]
operator|==
name|GL_FALSE
operator|)
condition|?
literal|0.0f
else|:
literal|1.0f
expr_stmt|;
name|vector
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
operator|(
name|v
index|[
literal|4
operator|*
name|i
operator|+
literal|1
index|]
operator|==
name|GL_FALSE
operator|)
condition|?
literal|0.0f
else|:
literal|1.0f
expr_stmt|;
name|vector
index|[
name|i
index|]
index|[
literal|2
index|]
operator|=
operator|(
name|v
index|[
literal|4
operator|*
name|i
operator|+
literal|2
index|]
operator|==
name|GL_FALSE
operator|)
condition|?
literal|0.0f
else|:
literal|1.0f
expr_stmt|;
name|vector
index|[
name|i
index|]
index|[
literal|3
index|]
operator|=
operator|(
name|v
index|[
literal|4
operator|*
name|i
operator|+
literal|3
index|]
operator|==
name|GL_FALSE
operator|)
condition|?
literal|0.0f
else|:
literal|1.0f
expr_stmt|;
block|}
name|applyUniformnfv
argument_list|(
name|targetUniform
argument_list|,
operator|(
name|GLfloat
operator|*
operator|)
name|vector
argument_list|)
expr_stmt|;
block|}
DECL|function|clear
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|clear
parameter_list|(
specifier|const
name|ClearParameters
modifier|&
name|clearParams
parameter_list|,
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|colorBuffer
parameter_list|,
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|depthStencilBuffer
parameter_list|)
block|{
if|if
condition|(
name|clearParams
operator|.
name|colorClearType
operator|!=
name|GL_FLOAT
condition|)
block|{
comment|// Clearing buffers with non-float values is not supported by Renderer9 and ES 2.0
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|bool
name|clearColor
init|=
name|clearParams
operator|.
name|clearColor
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ArraySize
argument_list|(
name|clearParams
operator|.
name|clearColor
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|clearParams
operator|.
name|clearColor
index|[
name|i
index|]
operator|!=
name|clearColor
condition|)
block|{
comment|// Clearing individual buffers other than buffer zero is not supported by Renderer9 and ES 2.0
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
block|}
name|float
name|depth
init|=
name|gl
operator|::
name|clamp01
argument_list|(
name|clearParams
operator|.
name|depthClearValue
argument_list|)
decl_stmt|;
name|DWORD
name|stencil
init|=
name|clearParams
operator|.
name|stencilClearValue
operator|&
literal|0x000000FF
decl_stmt|;
name|unsigned
name|int
name|stencilUnmasked
init|=
literal|0x0
decl_stmt|;
if|if
condition|(
name|clearParams
operator|.
name|clearStencil
operator|&&
name|depthStencilBuffer
operator|->
name|getStencilSize
argument_list|()
operator|>
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|depthStencilBuffer
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
name|RenderTargetD3D
modifier|*
name|stencilRenderTarget
init|=
literal|nullptr
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|depthStencilBuffer
operator|->
name|getRenderTarget
argument_list|(
operator|&
name|stencilRenderTarget
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|RenderTarget9
modifier|*
name|stencilRenderTarget9
init|=
name|GetAs
argument_list|<
name|RenderTarget9
argument_list|>
argument_list|(
name|stencilRenderTarget
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|stencilRenderTarget9
argument_list|)
expr_stmt|;
specifier|const
name|d3d9
operator|::
name|D3DFormat
modifier|&
name|d3dFormatInfo
init|=
name|d3d9
operator|::
name|GetD3DFormatInfo
argument_list|(
name|stencilRenderTarget9
operator|->
name|getD3DFormat
argument_list|()
argument_list|)
decl_stmt|;
name|stencilUnmasked
operator|=
operator|(
literal|0x1
operator|<<
name|d3dFormatInfo
operator|.
name|stencilBits
operator|)
operator|-
literal|1
expr_stmt|;
block|}
specifier|const
name|bool
name|needMaskedStencilClear
init|=
name|clearParams
operator|.
name|clearStencil
operator|&&
operator|(
name|clearParams
operator|.
name|stencilWriteMask
operator|&
name|stencilUnmasked
operator|)
operator|!=
name|stencilUnmasked
decl_stmt|;
name|bool
name|needMaskedColorClear
init|=
literal|false
decl_stmt|;
name|D3DCOLOR
name|color
init|=
name|D3DCOLOR_ARGB
argument_list|(
literal|255
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|clearColor
condition|)
block|{
name|ASSERT
argument_list|(
name|colorBuffer
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
name|RenderTargetD3D
modifier|*
name|colorRenderTarget
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|colorBuffer
operator|->
name|getRenderTarget
argument_list|(
operator|&
name|colorRenderTarget
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|RenderTarget9
modifier|*
name|colorRenderTarget9
init|=
name|GetAs
argument_list|<
name|RenderTarget9
argument_list|>
argument_list|(
name|colorRenderTarget
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|colorRenderTarget9
argument_list|)
expr_stmt|;
specifier|const
name|gl
operator|::
name|InternalFormat
modifier|&
name|formatInfo
init|=
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|colorBuffer
operator|->
name|getInternalFormat
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|d3d9
operator|::
name|D3DFormat
modifier|&
name|d3dFormatInfo
init|=
name|d3d9
operator|::
name|GetD3DFormatInfo
argument_list|(
name|colorRenderTarget9
operator|->
name|getD3DFormat
argument_list|()
argument_list|)
decl_stmt|;
name|color
operator|=
name|D3DCOLOR_ARGB
argument_list|(
name|gl
operator|::
name|unorm
argument_list|<
literal|8
argument_list|>
argument_list|(
operator|(
name|formatInfo
operator|.
name|alphaBits
operator|==
literal|0
operator|&&
name|d3dFormatInfo
operator|.
name|alphaBits
operator|>
literal|0
operator|)
condition|?
literal|1.0f
else|:
name|clearParams
operator|.
name|colorFClearValue
operator|.
name|alpha
argument_list|)
argument_list|,
name|gl
operator|::
name|unorm
argument_list|<
literal|8
argument_list|>
argument_list|(
operator|(
name|formatInfo
operator|.
name|redBits
operator|==
literal|0
operator|&&
name|d3dFormatInfo
operator|.
name|redBits
operator|>
literal|0
operator|)
condition|?
literal|0.0f
else|:
name|clearParams
operator|.
name|colorFClearValue
operator|.
name|red
argument_list|)
argument_list|,
name|gl
operator|::
name|unorm
argument_list|<
literal|8
argument_list|>
argument_list|(
operator|(
name|formatInfo
operator|.
name|greenBits
operator|==
literal|0
operator|&&
name|d3dFormatInfo
operator|.
name|greenBits
operator|>
literal|0
operator|)
condition|?
literal|0.0f
else|:
name|clearParams
operator|.
name|colorFClearValue
operator|.
name|green
argument_list|)
argument_list|,
name|gl
operator|::
name|unorm
argument_list|<
literal|8
argument_list|>
argument_list|(
operator|(
name|formatInfo
operator|.
name|blueBits
operator|==
literal|0
operator|&&
name|d3dFormatInfo
operator|.
name|blueBits
operator|>
literal|0
operator|)
condition|?
literal|0.0f
else|:
name|clearParams
operator|.
name|colorFClearValue
operator|.
name|blue
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|formatInfo
operator|.
name|redBits
operator|>
literal|0
operator|&&
operator|!
name|clearParams
operator|.
name|colorMaskRed
operator|)
operator|||
operator|(
name|formatInfo
operator|.
name|greenBits
operator|>
literal|0
operator|&&
operator|!
name|clearParams
operator|.
name|colorMaskGreen
operator|)
operator|||
operator|(
name|formatInfo
operator|.
name|blueBits
operator|>
literal|0
operator|&&
operator|!
name|clearParams
operator|.
name|colorMaskBlue
operator|)
operator|||
operator|(
name|formatInfo
operator|.
name|alphaBits
operator|>
literal|0
operator|&&
operator|!
name|clearParams
operator|.
name|colorMaskAlpha
operator|)
condition|)
block|{
name|needMaskedColorClear
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|needMaskedColorClear
operator|||
name|needMaskedStencilClear
condition|)
block|{
comment|// State which is altered in all paths from this point to the clear call is saved.
comment|// State which is altered in only some paths will be flagged dirty in the case that
comment|//  that path is taken.
name|HRESULT
name|hr
decl_stmt|;
if|if
condition|(
name|mMaskedClearSavedState
operator|==
name|NULL
condition|)
block|{
name|hr
operator|=
name|mDevice
operator|->
name|BeginStateBlock
argument_list|()
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|hr
argument_list|)
operator|||
name|hr
operator|==
name|D3DERR_OUTOFVIDEOMEMORY
operator|||
name|hr
operator|==
name|E_OUTOFMEMORY
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ZWRITEENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ZFUNC
argument_list|,
name|D3DCMP_ALWAYS
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ZENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_CULLMODE
argument_list|,
name|D3DCULL_NONE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_FILLMODE
argument_list|,
name|D3DFILL_SOLID
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ALPHATESTENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ALPHABLENDENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_CLIPPLANEENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_COLORWRITEENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_STENCILENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetPixelShader
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetVertexShader
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetFVF
argument_list|(
name|D3DFVF_XYZRHW
operator||
name|D3DFVF_DIFFUSE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetStreamSource
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_SEPARATEALPHABLENDENABLE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetTextureStageState
argument_list|(
literal|0
argument_list|,
name|D3DTSS_COLOROP
argument_list|,
name|D3DTOP_SELECTARG1
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetTextureStageState
argument_list|(
literal|0
argument_list|,
name|D3DTSS_COLORARG1
argument_list|,
name|D3DTA_TFACTOR
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetTextureStageState
argument_list|(
literal|0
argument_list|,
name|D3DTSS_ALPHAOP
argument_list|,
name|D3DTOP_SELECTARG1
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetTextureStageState
argument_list|(
literal|0
argument_list|,
name|D3DTSS_ALPHAARG1
argument_list|,
name|D3DTA_TFACTOR
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_TEXTUREFACTOR
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_MULTISAMPLEMASK
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
condition|;
name|i
operator|++
control|)
block|{
name|mDevice
operator|->
name|SetStreamSourceFreq
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|hr
operator|=
name|mDevice
operator|->
name|EndStateBlock
argument_list|(
operator|&
name|mMaskedClearSavedState
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|hr
argument_list|)
operator|||
name|hr
operator|==
name|D3DERR_OUTOFVIDEOMEMORY
operator|||
name|hr
operator|==
name|E_OUTOFMEMORY
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|mMaskedClearSavedState
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mMaskedClearSavedState
operator|!=
name|NULL
condition|)
block|{
name|hr
operator|=
name|mMaskedClearSavedState
operator|->
name|Capture
argument_list|()
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|hr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ZWRITEENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ZFUNC
argument_list|,
name|D3DCMP_ALWAYS
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ZENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_CULLMODE
argument_list|,
name|D3DCULL_NONE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_FILLMODE
argument_list|,
name|D3DFILL_SOLID
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ALPHATESTENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ALPHABLENDENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_CLIPPLANEENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|clearColor
condition|)
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_COLORWRITEENABLE
argument_list|,
name|gl_d3d9
operator|::
name|ConvertColorMask
argument_list|(
name|clearParams
operator|.
name|colorMaskRed
argument_list|,
name|clearParams
operator|.
name|colorMaskGreen
argument_list|,
name|clearParams
operator|.
name|colorMaskBlue
argument_list|,
name|clearParams
operator|.
name|colorMaskAlpha
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_COLORWRITEENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stencilUnmasked
operator|!=
literal|0x0
operator|&&
name|clearParams
operator|.
name|clearStencil
condition|)
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_STENCILENABLE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_TWOSIDEDSTENCILMODE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_STENCILFUNC
argument_list|,
name|D3DCMP_ALWAYS
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_STENCILREF
argument_list|,
name|stencil
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_STENCILWRITEMASK
argument_list|,
name|clearParams
operator|.
name|stencilWriteMask
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_STENCILFAIL
argument_list|,
name|D3DSTENCILOP_REPLACE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_STENCILZFAIL
argument_list|,
name|D3DSTENCILOP_REPLACE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_STENCILPASS
argument_list|,
name|D3DSTENCILOP_REPLACE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_STENCILENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|mDevice
operator|->
name|SetPixelShader
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetVertexShader
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetFVF
argument_list|(
name|D3DFVF_XYZRHW
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_SEPARATEALPHABLENDENABLE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetTextureStageState
argument_list|(
literal|0
argument_list|,
name|D3DTSS_COLOROP
argument_list|,
name|D3DTOP_SELECTARG1
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetTextureStageState
argument_list|(
literal|0
argument_list|,
name|D3DTSS_COLORARG1
argument_list|,
name|D3DTA_TFACTOR
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetTextureStageState
argument_list|(
literal|0
argument_list|,
name|D3DTSS_ALPHAOP
argument_list|,
name|D3DTOP_SELECTARG1
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetTextureStageState
argument_list|(
literal|0
argument_list|,
name|D3DTSS_ALPHAARG1
argument_list|,
name|D3DTA_TFACTOR
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_TEXTUREFACTOR
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_MULTISAMPLEMASK
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
condition|;
name|i
operator|++
control|)
block|{
name|mDevice
operator|->
name|SetStreamSourceFreq
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|int
name|renderTargetWidth
init|=
name|mStateManager
operator|.
name|getRenderTargetWidth
argument_list|()
decl_stmt|;
name|int
name|renderTargetHeight
init|=
name|mStateManager
operator|.
name|getRenderTargetHeight
argument_list|()
decl_stmt|;
name|float
name|quad
index|[
literal|4
index|]
index|[
literal|4
index|]
decl_stmt|;
comment|// A quadrilateral covering the target, aligned to match the edges
name|quad
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
operator|-
literal|0.5f
expr_stmt|;
name|quad
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|renderTargetHeight
operator|-
literal|0.5f
expr_stmt|;
name|quad
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
literal|0.0f
expr_stmt|;
name|quad
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|=
literal|1.0f
expr_stmt|;
name|quad
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|renderTargetWidth
operator|-
literal|0.5f
expr_stmt|;
name|quad
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|renderTargetHeight
operator|-
literal|0.5f
expr_stmt|;
name|quad
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
literal|0.0f
expr_stmt|;
name|quad
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|=
literal|1.0f
expr_stmt|;
name|quad
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
operator|-
literal|0.5f
expr_stmt|;
name|quad
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
operator|-
literal|0.5f
expr_stmt|;
name|quad
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
literal|0.0f
expr_stmt|;
name|quad
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|=
literal|1.0f
expr_stmt|;
name|quad
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
name|renderTargetWidth
operator|-
literal|0.5f
expr_stmt|;
name|quad
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
operator|-
literal|0.5f
expr_stmt|;
name|quad
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|=
literal|0.0f
expr_stmt|;
name|quad
index|[
literal|3
index|]
index|[
literal|3
index|]
operator|=
literal|1.0f
expr_stmt|;
name|startScene
argument_list|()
expr_stmt|;
name|mDevice
operator|->
name|DrawPrimitiveUP
argument_list|(
name|D3DPT_TRIANGLESTRIP
argument_list|,
literal|2
argument_list|,
name|quad
argument_list|,
sizeof|sizeof
argument_list|(
name|float
index|[
literal|4
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|clearParams
operator|.
name|clearDepth
condition|)
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ZENABLE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ZWRITEENABLE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|Clear
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|D3DCLEAR_ZBUFFER
argument_list|,
name|color
argument_list|,
name|depth
argument_list|,
name|stencil
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mMaskedClearSavedState
operator|!=
name|NULL
condition|)
block|{
name|mMaskedClearSavedState
operator|->
name|Apply
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|clearColor
operator|||
name|clearParams
operator|.
name|clearDepth
operator|||
name|clearParams
operator|.
name|clearStencil
condition|)
block|{
name|DWORD
name|dxClearFlags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|clearColor
condition|)
block|{
name|dxClearFlags
operator||=
name|D3DCLEAR_TARGET
expr_stmt|;
block|}
if|if
condition|(
name|clearParams
operator|.
name|clearDepth
condition|)
block|{
name|dxClearFlags
operator||=
name|D3DCLEAR_ZBUFFER
expr_stmt|;
block|}
if|if
condition|(
name|clearParams
operator|.
name|clearStencil
condition|)
block|{
name|dxClearFlags
operator||=
name|D3DCLEAR_STENCIL
expr_stmt|;
block|}
name|mDevice
operator|->
name|Clear
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|dxClearFlags
argument_list|,
name|color
argument_list|,
name|depth
argument_list|,
name|stencil
argument_list|)
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|markAllStateDirty
name|void
name|Renderer9
operator|::
name|markAllStateDirty
parameter_list|()
block|{
name|mAppliedRenderTargetSerial
operator|=
literal|0
expr_stmt|;
name|mAppliedDepthStencilSerial
operator|=
literal|0
expr_stmt|;
name|mDepthStencilInitialized
operator|=
literal|false
expr_stmt|;
name|mRenderTargetDescInitialized
operator|=
literal|false
expr_stmt|;
name|mStateManager
operator|.
name|forceSetRasterState
argument_list|()
expr_stmt|;
name|mStateManager
operator|.
name|forceSetDepthStencilState
argument_list|()
expr_stmt|;
name|mStateManager
operator|.
name|forceSetBlendState
argument_list|()
expr_stmt|;
name|mStateManager
operator|.
name|forceSetScissorState
argument_list|()
expr_stmt|;
name|mStateManager
operator|.
name|forceSetViewportState
argument_list|()
expr_stmt|;
name|ASSERT
argument_list|(
name|mCurVertexSamplerStates
operator|.
name|size
argument_list|()
operator|==
name|mCurVertexTextures
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mCurVertexTextures
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|mCurVertexSamplerStates
index|[
name|i
index|]
operator|.
name|forceSet
operator|=
literal|true
expr_stmt|;
name|mCurVertexTextures
index|[
name|i
index|]
operator|=
name|angle
operator|::
name|DirtyPointer
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|mCurPixelSamplerStates
operator|.
name|size
argument_list|()
operator|==
name|mCurPixelTextures
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mCurPixelSamplerStates
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|mCurPixelSamplerStates
index|[
name|i
index|]
operator|.
name|forceSet
operator|=
literal|true
expr_stmt|;
name|mCurPixelTextures
index|[
name|i
index|]
operator|=
name|angle
operator|::
name|DirtyPointer
expr_stmt|;
block|}
name|mAppliedIBSerial
operator|=
literal|0
expr_stmt|;
name|mAppliedVertexShader
operator|=
name|NULL
expr_stmt|;
name|mAppliedPixelShader
operator|=
name|NULL
expr_stmt|;
name|mAppliedProgramSerial
operator|=
literal|0
expr_stmt|;
name|mStateManager
operator|.
name|forceSetDXUniformsState
argument_list|()
expr_stmt|;
name|mVertexDeclarationCache
operator|.
name|markStateDirty
argument_list|()
expr_stmt|;
block|}
DECL|function|releaseDeviceResources
name|void
name|Renderer9
operator|::
name|releaseDeviceResources
parameter_list|()
block|{
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mEventQueryPool
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|SafeRelease
argument_list|(
name|mEventQueryPool
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|mEventQueryPool
operator|.
name|clear
argument_list|()
expr_stmt|;
name|SafeRelease
argument_list|(
name|mMaskedClearSavedState
argument_list|)
expr_stmt|;
name|mVertexShaderCache
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mPixelShaderCache
operator|.
name|clear
argument_list|()
expr_stmt|;
name|SafeDelete
argument_list|(
name|mBlit
argument_list|)
expr_stmt|;
name|SafeDelete
argument_list|(
name|mVertexDataManager
argument_list|)
expr_stmt|;
name|SafeDelete
argument_list|(
name|mIndexDataManager
argument_list|)
expr_stmt|;
name|SafeDelete
argument_list|(
name|mLineLoopIB
argument_list|)
expr_stmt|;
name|SafeDelete
argument_list|(
name|mCountingIB
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_NULL_COLORBUFFER_CACHE_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
name|SafeDelete
argument_list|(
name|mNullColorbufferCache
index|[
name|i
index|]
operator|.
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
comment|// set notify to true to broadcast a message to all contexts of the device loss
DECL|function|testDeviceLost
name|bool
name|Renderer9
operator|::
name|testDeviceLost
parameter_list|()
block|{
name|HRESULT
name|status
init|=
name|getDeviceStatusCode
argument_list|()
decl_stmt|;
name|bool
name|isLost
init|=
name|FAILED
argument_list|(
name|status
argument_list|)
decl_stmt|;
if|if
condition|(
name|isLost
condition|)
block|{
comment|// ensure we note the device loss --
comment|// we'll probably get this done again by notifyDeviceLost
comment|// but best to remember it!
comment|// Note that we don't want to clear the device loss status here
comment|// -- this needs to be done by resetDevice
name|mDeviceLost
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|isLost
return|;
block|}
DECL|function|getDeviceStatusCode
name|HRESULT
name|Renderer9
operator|::
name|getDeviceStatusCode
parameter_list|()
block|{
name|HRESULT
name|status
init|=
name|D3D_OK
decl_stmt|;
if|if
condition|(
name|mDeviceEx
condition|)
block|{
name|status
operator|=
name|mDeviceEx
operator|->
name|CheckDeviceState
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mDevice
condition|)
block|{
name|status
operator|=
name|mDevice
operator|->
name|TestCooperativeLevel
argument_list|()
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
DECL|function|testDeviceResettable
name|bool
name|Renderer9
operator|::
name|testDeviceResettable
parameter_list|()
block|{
comment|// On D3D9Ex, DEVICELOST represents a hung device that needs to be restarted
comment|// DEVICEREMOVED indicates the device has been stopped and must be recreated
switch|switch
condition|(
name|getDeviceStatusCode
argument_list|()
condition|)
block|{
case|case
name|D3DERR_DEVICENOTRESET
case|:
case|case
name|D3DERR_DEVICEHUNG
case|:
return|return
literal|true
return|;
case|case
name|D3DERR_DEVICELOST
case|:
return|return
operator|(
name|mDeviceEx
operator|!=
name|NULL
operator|)
return|;
case|case
name|D3DERR_DEVICEREMOVED
case|:
name|ASSERT
argument_list|(
name|mDeviceEx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
name|isRemovedDeviceResettable
argument_list|()
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
DECL|function|resetDevice
name|bool
name|Renderer9
operator|::
name|resetDevice
parameter_list|()
block|{
name|releaseDeviceResources
argument_list|()
expr_stmt|;
name|D3DPRESENT_PARAMETERS
name|presentParameters
init|=
name|getDefaultPresentParameters
argument_list|()
decl_stmt|;
name|HRESULT
name|result
init|=
name|D3D_OK
decl_stmt|;
name|bool
name|lost
init|=
name|testDeviceLost
argument_list|()
decl_stmt|;
name|bool
name|removedDevice
init|=
operator|(
name|getDeviceStatusCode
argument_list|()
operator|==
name|D3DERR_DEVICEREMOVED
operator|)
decl_stmt|;
comment|// Device Removed is a feature which is only present with D3D9Ex
name|ASSERT
argument_list|(
name|mDeviceEx
operator|!=
name|NULL
operator|||
operator|!
name|removedDevice
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|attempts
init|=
literal|3
init|;
name|lost
operator|&&
name|attempts
operator|>
literal|0
condition|;
name|attempts
operator|--
control|)
block|{
if|if
condition|(
name|removedDevice
condition|)
block|{
comment|// Device removed, which may trigger on driver reinstallation,
comment|// may cause a longer wait other reset attempts before the
comment|// system is ready to handle creating a new device.
name|Sleep
argument_list|(
literal|800
argument_list|)
expr_stmt|;
name|lost
operator|=
operator|!
name|resetRemovedDevice
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mDeviceEx
condition|)
block|{
name|Sleep
argument_list|(
literal|500
argument_list|)
expr_stmt|;
comment|// Give the graphics driver some CPU time
name|result
operator|=
name|mDeviceEx
operator|->
name|ResetEx
argument_list|(
operator|&
name|presentParameters
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|lost
operator|=
name|testDeviceLost
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|mDevice
operator|->
name|TestCooperativeLevel
argument_list|()
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|D3DERR_DEVICELOST
condition|)
block|{
name|Sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|// Give the graphics driver some CPU time
name|result
operator|=
name|mDevice
operator|->
name|TestCooperativeLevel
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|D3DERR_DEVICENOTRESET
condition|)
block|{
name|result
operator|=
name|mDevice
operator|->
name|Reset
argument_list|(
operator|&
name|presentParameters
argument_list|)
expr_stmt|;
block|}
name|lost
operator|=
name|testDeviceLost
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Reset/ResetEx failed multiple times: 0x%08X"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|removedDevice
operator|&&
name|lost
condition|)
block|{
name|ERR
argument_list|(
literal|"Device lost reset failed multiple times"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// If the device was removed, we already finished re-initialization in resetRemovedDevice
if|if
condition|(
operator|!
name|removedDevice
condition|)
block|{
comment|// reset device defaults
name|initializeDevice
argument_list|()
expr_stmt|;
block|}
name|mDeviceLost
operator|=
literal|false
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|isRemovedDeviceResettable
name|bool
name|Renderer9
operator|::
name|isRemovedDeviceResettable
parameter_list|()
specifier|const
block|{
name|bool
name|success
init|=
literal|false
decl_stmt|;
if|#
directive|if
name|ANGLE_D3D9EX
operator|==
name|ANGLE_ENABLED
name|IDirect3D9Ex
modifier|*
name|d3d9Ex
init|=
name|NULL
decl_stmt|;
typedef|typedef
name|HRESULT
function_decl|(
name|WINAPI
modifier|*
name|Direct3DCreate9ExFunc
function_decl|)
parameter_list|(
name|UINT
parameter_list|,
name|IDirect3D9Ex
modifier|*
modifier|*
parameter_list|)
function_decl|;
name|Direct3DCreate9ExFunc
name|Direct3DCreate9ExPtr
init|=
cast|reinterpret_cast
argument_list|<
name|Direct3DCreate9ExFunc
argument_list|>
argument_list|(
name|GetProcAddress
argument_list|(
name|mD3d9Module
argument_list|,
literal|"Direct3DCreate9Ex"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|Direct3DCreate9ExPtr
operator|&&
name|SUCCEEDED
argument_list|(
name|Direct3DCreate9ExPtr
argument_list|(
name|D3D_SDK_VERSION
argument_list|,
operator|&
name|d3d9Ex
argument_list|)
argument_list|)
condition|)
block|{
name|D3DCAPS9
name|deviceCaps
decl_stmt|;
name|HRESULT
name|result
init|=
name|d3d9Ex
operator|->
name|GetDeviceCaps
argument_list|(
name|mAdapter
argument_list|,
name|mDeviceType
argument_list|,
operator|&
name|deviceCaps
argument_list|)
decl_stmt|;
name|success
operator|=
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
name|SafeRelease
argument_list|(
name|d3d9Ex
argument_list|)
expr_stmt|;
else|#
directive|else
name|ASSERT
argument_list|(
name|UNREACHABLE
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|success
return|;
block|}
DECL|function|resetRemovedDevice
name|bool
name|Renderer9
operator|::
name|resetRemovedDevice
parameter_list|()
block|{
comment|// From http://msdn.microsoft.com/en-us/library/windows/desktop/bb172554(v=vs.85).aspx:
comment|// The hardware adapter has been removed. Application must destroy the device, do enumeration of
comment|// adapters and create another Direct3D device. If application continues rendering without
comment|// calling Reset, the rendering calls will succeed. Applies to Direct3D 9Ex only.
name|release
argument_list|()
expr_stmt|;
return|return
operator|!
name|initialize
argument_list|()
operator|.
name|isError
argument_list|()
return|;
block|}
DECL|function|getVendorId
name|VendorID
name|Renderer9
operator|::
name|getVendorId
parameter_list|()
specifier|const
block|{
return|return
cast|static_cast
argument_list|<
name|VendorID
argument_list|>
argument_list|(
name|mAdapterIdentifier
operator|.
name|VendorId
argument_list|)
return|;
block|}
DECL|function|getRendererDescription
name|std
operator|::
name|string
name|Renderer9
operator|::
name|getRendererDescription
parameter_list|()
specifier|const
block|{
name|std
operator|::
name|ostringstream
name|rendererString
decl_stmt|;
name|rendererString
operator|<<
name|mAdapterIdentifier
operator|.
name|Description
expr_stmt|;
if|if
condition|(
name|getShareHandleSupport
argument_list|()
condition|)
block|{
name|rendererString
operator|<<
literal|" Direct3D9Ex"
expr_stmt|;
block|}
else|else
block|{
name|rendererString
operator|<<
literal|" Direct3D9"
expr_stmt|;
block|}
name|rendererString
operator|<<
literal|" vs_"
operator|<<
name|D3DSHADER_VERSION_MAJOR
argument_list|(
name|mDeviceCaps
operator|.
name|VertexShaderVersion
argument_list|)
operator|<<
literal|"_"
operator|<<
name|D3DSHADER_VERSION_MINOR
argument_list|(
name|mDeviceCaps
operator|.
name|VertexShaderVersion
argument_list|)
expr_stmt|;
name|rendererString
operator|<<
literal|" ps_"
operator|<<
name|D3DSHADER_VERSION_MAJOR
argument_list|(
name|mDeviceCaps
operator|.
name|PixelShaderVersion
argument_list|)
operator|<<
literal|"_"
operator|<<
name|D3DSHADER_VERSION_MINOR
argument_list|(
name|mDeviceCaps
operator|.
name|PixelShaderVersion
argument_list|)
expr_stmt|;
return|return
name|rendererString
operator|.
name|str
argument_list|()
return|;
block|}
DECL|function|getAdapterIdentifier
name|DeviceIdentifier
name|Renderer9
operator|::
name|getAdapterIdentifier
parameter_list|()
specifier|const
block|{
name|DeviceIdentifier
name|deviceIdentifier
init|=
block|{
literal|0
block|}
decl_stmt|;
name|deviceIdentifier
operator|.
name|VendorId
operator|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|mAdapterIdentifier
operator|.
name|VendorId
argument_list|)
expr_stmt|;
name|deviceIdentifier
operator|.
name|DeviceId
operator|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|mAdapterIdentifier
operator|.
name|DeviceId
argument_list|)
expr_stmt|;
name|deviceIdentifier
operator|.
name|SubSysId
operator|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|mAdapterIdentifier
operator|.
name|SubSysId
argument_list|)
expr_stmt|;
name|deviceIdentifier
operator|.
name|Revision
operator|=
cast|static_cast
argument_list|<
name|UINT
argument_list|>
argument_list|(
name|mAdapterIdentifier
operator|.
name|Revision
argument_list|)
expr_stmt|;
name|deviceIdentifier
operator|.
name|FeatureLevel
operator|=
literal|0
expr_stmt|;
return|return
name|deviceIdentifier
return|;
block|}
DECL|function|getReservedVertexUniformVectors
name|unsigned
name|int
name|Renderer9
operator|::
name|getReservedVertexUniformVectors
parameter_list|()
specifier|const
block|{
return|return
name|d3d9_gl
operator|::
name|GetReservedVertexUniformVectors
argument_list|()
return|;
block|}
DECL|function|getReservedFragmentUniformVectors
name|unsigned
name|int
name|Renderer9
operator|::
name|getReservedFragmentUniformVectors
parameter_list|()
specifier|const
block|{
return|return
name|d3d9_gl
operator|::
name|GetReservedFragmentUniformVectors
argument_list|()
return|;
block|}
DECL|function|getReservedVertexUniformBuffers
name|unsigned
name|int
name|Renderer9
operator|::
name|getReservedVertexUniformBuffers
parameter_list|()
specifier|const
block|{
return|return
literal|0
return|;
block|}
DECL|function|getReservedFragmentUniformBuffers
name|unsigned
name|int
name|Renderer9
operator|::
name|getReservedFragmentUniformBuffers
parameter_list|()
specifier|const
block|{
return|return
literal|0
return|;
block|}
DECL|function|getShareHandleSupport
name|bool
name|Renderer9
operator|::
name|getShareHandleSupport
parameter_list|()
specifier|const
block|{
comment|// PIX doesn't seem to support using share handles, so disable them.
return|return
operator|(
name|mD3d9Ex
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|gl
operator|::
name|DebugAnnotationsActive
argument_list|()
return|;
block|}
DECL|function|getMajorShaderModel
name|int
name|Renderer9
operator|::
name|getMajorShaderModel
parameter_list|()
specifier|const
block|{
return|return
name|D3DSHADER_VERSION_MAJOR
argument_list|(
name|mDeviceCaps
operator|.
name|PixelShaderVersion
argument_list|)
return|;
block|}
DECL|function|getMinorShaderModel
name|int
name|Renderer9
operator|::
name|getMinorShaderModel
parameter_list|()
specifier|const
block|{
return|return
name|D3DSHADER_VERSION_MINOR
argument_list|(
name|mDeviceCaps
operator|.
name|PixelShaderVersion
argument_list|)
return|;
block|}
DECL|function|getShaderModelSuffix
name|std
operator|::
name|string
name|Renderer9
operator|::
name|getShaderModelSuffix
parameter_list|()
specifier|const
block|{
return|return
literal|""
return|;
block|}
DECL|function|getCapsDeclTypes
name|DWORD
name|Renderer9
operator|::
name|getCapsDeclTypes
parameter_list|()
specifier|const
block|{
return|return
name|mDeviceCaps
operator|.
name|DeclTypes
return|;
block|}
DECL|function|getBufferPool
name|D3DPOOL
name|Renderer9
operator|::
name|getBufferPool
parameter_list|(
name|DWORD
name|usage
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|mD3d9Ex
operator|!=
name|NULL
condition|)
block|{
return|return
name|D3DPOOL_DEFAULT
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|usage
operator|&
name|D3DUSAGE_DYNAMIC
operator|)
condition|)
block|{
return|return
name|D3DPOOL_MANAGED
return|;
block|}
block|}
return|return
name|D3DPOOL_DEFAULT
return|;
block|}
DECL|function|copyImage2D
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|copyImage2D
parameter_list|(
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|sourceRect
parameter_list|,
name|GLenum
name|destFormat
parameter_list|,
specifier|const
name|gl
operator|::
name|Offset
modifier|&
name|destOffset
parameter_list|,
name|TextureStorage
modifier|*
name|storage
parameter_list|,
name|GLint
name|level
parameter_list|)
block|{
name|RECT
name|rect
decl_stmt|;
name|rect
operator|.
name|left
operator|=
name|sourceRect
operator|.
name|x
expr_stmt|;
name|rect
operator|.
name|top
operator|=
name|sourceRect
operator|.
name|y
expr_stmt|;
name|rect
operator|.
name|right
operator|=
name|sourceRect
operator|.
name|x
operator|+
name|sourceRect
operator|.
name|width
expr_stmt|;
name|rect
operator|.
name|bottom
operator|=
name|sourceRect
operator|.
name|y
operator|+
name|sourceRect
operator|.
name|height
expr_stmt|;
return|return
name|mBlit
operator|->
name|copy2D
argument_list|(
name|framebuffer
argument_list|,
name|rect
argument_list|,
name|destFormat
argument_list|,
name|destOffset
argument_list|,
name|storage
argument_list|,
name|level
argument_list|)
return|;
block|}
DECL|function|copyImageCube
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|copyImageCube
parameter_list|(
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|sourceRect
parameter_list|,
name|GLenum
name|destFormat
parameter_list|,
specifier|const
name|gl
operator|::
name|Offset
modifier|&
name|destOffset
parameter_list|,
name|TextureStorage
modifier|*
name|storage
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|)
block|{
name|RECT
name|rect
decl_stmt|;
name|rect
operator|.
name|left
operator|=
name|sourceRect
operator|.
name|x
expr_stmt|;
name|rect
operator|.
name|top
operator|=
name|sourceRect
operator|.
name|y
expr_stmt|;
name|rect
operator|.
name|right
operator|=
name|sourceRect
operator|.
name|x
operator|+
name|sourceRect
operator|.
name|width
expr_stmt|;
name|rect
operator|.
name|bottom
operator|=
name|sourceRect
operator|.
name|y
operator|+
name|sourceRect
operator|.
name|height
expr_stmt|;
return|return
name|mBlit
operator|->
name|copyCube
argument_list|(
name|framebuffer
argument_list|,
name|rect
argument_list|,
name|destFormat
argument_list|,
name|destOffset
argument_list|,
name|storage
argument_list|,
name|target
argument_list|,
name|level
argument_list|)
return|;
block|}
DECL|function|copyImage3D
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|copyImage3D
parameter_list|(
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|sourceRect
parameter_list|,
name|GLenum
name|destFormat
parameter_list|,
specifier|const
name|gl
operator|::
name|Offset
modifier|&
name|destOffset
parameter_list|,
name|TextureStorage
modifier|*
name|storage
parameter_list|,
name|GLint
name|level
parameter_list|)
block|{
comment|// 3D textures are not available in the D3D9 backend.
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
DECL|function|copyImage2DArray
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|copyImage2DArray
parameter_list|(
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
parameter_list|,
specifier|const
name|gl
operator|::
name|Rectangle
modifier|&
name|sourceRect
parameter_list|,
name|GLenum
name|destFormat
parameter_list|,
specifier|const
name|gl
operator|::
name|Offset
modifier|&
name|destOffset
parameter_list|,
name|TextureStorage
modifier|*
name|storage
parameter_list|,
name|GLint
name|level
parameter_list|)
block|{
comment|// 2D array textures are not available in the D3D9 backend.
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
DECL|function|createRenderTarget
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|createRenderTarget
parameter_list|(
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLsizei
name|samples
parameter_list|,
name|RenderTargetD3D
modifier|*
modifier|*
name|outRT
parameter_list|)
block|{
specifier|const
name|d3d9
operator|::
name|TextureFormat
modifier|&
name|d3d9FormatInfo
init|=
name|d3d9
operator|::
name|GetTextureFormatInfo
argument_list|(
name|format
argument_list|)
decl_stmt|;
specifier|const
name|gl
operator|::
name|TextureCaps
modifier|&
name|textureCaps
init|=
name|getRendererTextureCaps
argument_list|()
operator|.
name|get
argument_list|(
name|format
argument_list|)
decl_stmt|;
name|GLuint
name|supportedSamples
init|=
name|textureCaps
operator|.
name|getNearestSamples
argument_list|(
name|samples
argument_list|)
decl_stmt|;
name|IDirect3DTexture9
modifier|*
name|texture
init|=
literal|nullptr
decl_stmt|;
name|IDirect3DSurface9
modifier|*
name|renderTarget
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|width
operator|>
literal|0
operator|&&
name|height
operator|>
literal|0
condition|)
block|{
name|bool
name|requiresInitialization
init|=
literal|false
decl_stmt|;
name|HRESULT
name|result
init|=
name|D3DERR_INVALIDCALL
decl_stmt|;
specifier|const
name|gl
operator|::
name|InternalFormat
modifier|&
name|formatInfo
init|=
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|format
argument_list|)
decl_stmt|;
if|if
condition|(
name|formatInfo
operator|.
name|depthBits
operator|>
literal|0
operator|||
name|formatInfo
operator|.
name|stencilBits
operator|>
literal|0
condition|)
block|{
name|result
operator|=
name|mDevice
operator|->
name|CreateDepthStencilSurface
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|d3d9FormatInfo
operator|.
name|renderFormat
argument_list|,
name|gl_d3d9
operator|::
name|GetMultisampleType
argument_list|(
name|supportedSamples
argument_list|)
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
operator|&
name|renderTarget
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|requiresInitialization
operator|=
operator|(
name|d3d9FormatInfo
operator|.
name|dataInitializerFunction
operator|!=
literal|nullptr
operator|)
expr_stmt|;
if|if
condition|(
name|supportedSamples
operator|>
literal|0
condition|)
block|{
name|result
operator|=
name|mDevice
operator|->
name|CreateRenderTarget
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|d3d9FormatInfo
operator|.
name|renderFormat
argument_list|,
name|gl_d3d9
operator|::
name|GetMultisampleType
argument_list|(
name|supportedSamples
argument_list|)
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
operator|&
name|renderTarget
argument_list|,
literal|nullptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|mDevice
operator|->
name|CreateTexture
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
literal|1
argument_list|,
name|D3DUSAGE_RENDERTARGET
argument_list|,
name|d3d9FormatInfo
operator|.
name|texFormat
argument_list|,
name|getTexturePool
argument_list|(
name|D3DUSAGE_RENDERTARGET
argument_list|)
argument_list|,
operator|&
name|texture
argument_list|,
literal|nullptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|result
operator|=
name|texture
operator|->
name|GetSurfaceLevel
argument_list|(
literal|0
argument_list|,
operator|&
name|renderTarget
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|result
operator|==
name|D3DERR_OUTOFVIDEOMEMORY
operator|||
name|result
operator|==
name|E_OUTOFMEMORY
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to create render target, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
if|if
condition|(
name|requiresInitialization
condition|)
block|{
comment|// This format requires that the data be initialized before the render target can be used
comment|// Unfortunately this requires a Get call on the d3d device but it is far better than having
comment|// to mark the render target as lockable and copy data to the gpu.
name|IDirect3DSurface9
modifier|*
name|prevRenderTarget
init|=
name|NULL
decl_stmt|;
name|mDevice
operator|->
name|GetRenderTarget
argument_list|(
literal|0
argument_list|,
operator|&
name|prevRenderTarget
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderTarget
argument_list|(
literal|0
argument_list|,
name|renderTarget
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|Clear
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|D3DCLEAR_TARGET
argument_list|,
name|D3DCOLOR_RGBA
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
argument_list|,
literal|0.0f
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderTarget
argument_list|(
literal|0
argument_list|,
name|prevRenderTarget
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|outRT
operator|=
operator|new
name|TextureRenderTarget9
argument_list|(
name|texture
argument_list|,
literal|0
argument_list|,
name|renderTarget
argument_list|,
name|format
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|1
argument_list|,
name|supportedSamples
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|createRenderTargetCopy
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|createRenderTargetCopy
parameter_list|(
name|RenderTargetD3D
modifier|*
name|source
parameter_list|,
name|RenderTargetD3D
modifier|*
modifier|*
name|outRT
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|source
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
name|RenderTargetD3D
modifier|*
name|newRT
init|=
literal|nullptr
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|createRenderTarget
argument_list|(
name|source
operator|->
name|getWidth
argument_list|()
argument_list|,
name|source
operator|->
name|getHeight
argument_list|()
argument_list|,
name|source
operator|->
name|getInternalFormat
argument_list|()
argument_list|,
name|source
operator|->
name|getSamples
argument_list|()
argument_list|,
operator|&
name|newRT
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|RenderTarget9
modifier|*
name|source9
init|=
name|GetAs
argument_list|<
name|RenderTarget9
argument_list|>
argument_list|(
name|source
argument_list|)
decl_stmt|;
name|RenderTarget9
modifier|*
name|dest9
init|=
name|GetAs
argument_list|<
name|RenderTarget9
argument_list|>
argument_list|(
name|newRT
argument_list|)
decl_stmt|;
name|HRESULT
name|result
init|=
name|mDevice
operator|->
name|StretchRect
argument_list|(
name|source9
operator|->
name|getSurface
argument_list|()
argument_list|,
literal|nullptr
argument_list|,
name|dest9
operator|->
name|getSurface
argument_list|()
argument_list|,
literal|nullptr
argument_list|,
name|D3DTEXF_NONE
argument_list|)
decl_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|result
operator|==
name|D3DERR_OUTOFVIDEOMEMORY
operator|||
name|result
operator|==
name|E_OUTOFMEMORY
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to copy render target, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
operator|*
name|outRT
operator|=
name|newRT
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|createFramebuffer
name|FramebufferImpl
modifier|*
name|Renderer9
operator|::
name|createFramebuffer
parameter_list|(
specifier|const
name|gl
operator|::
name|Framebuffer
operator|::
name|Data
modifier|&
name|data
parameter_list|)
block|{
return|return
operator|new
name|Framebuffer9
argument_list|(
name|data
argument_list|,
name|this
argument_list|)
return|;
block|}
DECL|function|createShader
name|ShaderImpl
modifier|*
name|Renderer9
operator|::
name|createShader
parameter_list|(
specifier|const
name|gl
operator|::
name|Shader
operator|::
name|Data
modifier|&
name|data
parameter_list|)
block|{
return|return
operator|new
name|ShaderD3D
argument_list|(
name|data
argument_list|)
return|;
block|}
DECL|function|createProgram
name|ProgramImpl
modifier|*
name|Renderer9
operator|::
name|createProgram
parameter_list|(
specifier|const
name|gl
operator|::
name|Program
operator|::
name|Data
modifier|&
name|data
parameter_list|)
block|{
return|return
operator|new
name|ProgramD3D
argument_list|(
name|data
argument_list|,
name|this
argument_list|)
return|;
block|}
DECL|function|loadExecutable
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|loadExecutable
parameter_list|(
specifier|const
name|void
modifier|*
name|function
parameter_list|,
name|size_t
name|length
parameter_list|,
name|ShaderType
name|type
parameter_list|,
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|D3DVarying
argument_list|>
modifier|&
name|streamOutVaryings
parameter_list|,
name|bool
name|separatedOutputBuffers
parameter_list|,
name|ShaderExecutableD3D
modifier|*
modifier|*
name|outExecutable
parameter_list|)
block|{
comment|// Transform feedback is not supported in ES2 or D3D9
name|ASSERT
argument_list|(
name|streamOutVaryings
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SHADER_VERTEX
case|:
block|{
name|IDirect3DVertexShader9
modifier|*
name|vshader
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|createVertexShader
argument_list|(
operator|(
name|DWORD
operator|*
operator|)
name|function
argument_list|,
name|length
argument_list|,
operator|&
name|vshader
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
operator|*
name|outExecutable
operator|=
operator|new
name|ShaderExecutable9
argument_list|(
name|function
argument_list|,
name|length
argument_list|,
name|vshader
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SHADER_PIXEL
case|:
block|{
name|IDirect3DPixelShader9
modifier|*
name|pshader
init|=
name|NULL
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|createPixelShader
argument_list|(
operator|(
name|DWORD
operator|*
operator|)
name|function
argument_list|,
name|length
argument_list|,
operator|&
name|pshader
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
operator|*
name|outExecutable
operator|=
operator|new
name|ShaderExecutable9
argument_list|(
name|function
argument_list|,
name|length
argument_list|,
name|pshader
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|compileToExecutable
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|compileToExecutable
parameter_list|(
name|gl
operator|::
name|InfoLog
modifier|&
name|infoLog
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|shaderHLSL
parameter_list|,
name|ShaderType
name|type
parameter_list|,
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|D3DVarying
argument_list|>
modifier|&
name|streamOutVaryings
parameter_list|,
name|bool
name|separatedOutputBuffers
parameter_list|,
specifier|const
name|D3DCompilerWorkarounds
modifier|&
name|workarounds
parameter_list|,
name|ShaderExecutableD3D
modifier|*
modifier|*
name|outExectuable
parameter_list|)
block|{
comment|// Transform feedback is not supported in ES2 or D3D9
name|ASSERT
argument_list|(
name|streamOutVaryings
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|char
modifier|*
name|profileType
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SHADER_VERTEX
case|:
name|profileType
operator|=
literal|"vs"
expr_stmt|;
break|break;
case|case
name|SHADER_PIXEL
case|:
name|profileType
operator|=
literal|"ps"
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|unsigned
name|int
name|profileMajorVersion
init|=
operator|(
name|getMajorShaderModel
argument_list|()
operator|>=
literal|3
operator|)
condition|?
literal|3
else|:
literal|2
decl_stmt|;
name|unsigned
name|int
name|profileMinorVersion
init|=
literal|0
decl_stmt|;
name|std
operator|::
name|string
name|profile
init|=
name|FormatString
argument_list|(
literal|"%s_%u_%u"
argument_list|,
name|profileType
argument_list|,
name|profileMajorVersion
argument_list|,
name|profileMinorVersion
argument_list|)
decl_stmt|;
name|UINT
name|flags
init|=
name|ANGLE_COMPILE_OPTIMIZATION_LEVEL
decl_stmt|;
if|if
condition|(
name|workarounds
operator|.
name|skipOptimization
condition|)
block|{
name|flags
operator|=
name|D3DCOMPILE_SKIP_OPTIMIZATION
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|workarounds
operator|.
name|useMaxOptimization
condition|)
block|{
name|flags
operator|=
name|D3DCOMPILE_OPTIMIZATION_LEVEL3
expr_stmt|;
block|}
if|if
condition|(
name|gl
operator|::
name|DebugAnnotationsActive
argument_list|()
condition|)
block|{
ifndef|#
directive|ifndef
name|NDEBUG
name|flags
operator|=
name|D3DCOMPILE_SKIP_OPTIMIZATION
expr_stmt|;
endif|#
directive|endif
name|flags
operator||=
name|D3DCOMPILE_DEBUG
expr_stmt|;
block|}
comment|// Sometimes D3DCompile will fail with the default compilation flags for complicated shaders when it would otherwise pass with alternative options.
comment|// Try the default flags first and if compilation fails, try some alternatives.
name|std
operator|::
name|vector
argument_list|<
name|CompileConfig
argument_list|>
name|configs
decl_stmt|;
name|configs
operator|.
name|push_back
argument_list|(
name|CompileConfig
argument_list|(
name|flags
argument_list|,
literal|"default"
argument_list|)
argument_list|)
expr_stmt|;
name|configs
operator|.
name|push_back
argument_list|(
name|CompileConfig
argument_list|(
name|flags
operator||
name|D3DCOMPILE_AVOID_FLOW_CONTROL
argument_list|,
literal|"avoid flow control"
argument_list|)
argument_list|)
expr_stmt|;
name|configs
operator|.
name|push_back
argument_list|(
name|CompileConfig
argument_list|(
name|flags
operator||
name|D3DCOMPILE_PREFER_FLOW_CONTROL
argument_list|,
literal|"prefer flow control"
argument_list|)
argument_list|)
expr_stmt|;
name|ID3DBlob
modifier|*
name|binary
init|=
name|NULL
decl_stmt|;
name|std
operator|::
name|string
name|debugInfo
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|mCompiler
operator|.
name|compileToBinary
argument_list|(
name|infoLog
argument_list|,
name|shaderHLSL
argument_list|,
name|profile
argument_list|,
name|configs
argument_list|,
name|NULL
argument_list|,
operator|&
name|binary
argument_list|,
operator|&
name|debugInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
comment|// It's possible that binary is NULL if the compiler failed in all configurations.  Set the executable to NULL
comment|// and return GL_NO_ERROR to signify that there was a link error but the internal state is still OK.
if|if
condition|(
operator|!
name|binary
condition|)
block|{
operator|*
name|outExectuable
operator|=
name|NULL
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
name|error
operator|=
name|loadExecutable
argument_list|(
name|binary
operator|->
name|GetBufferPointer
argument_list|()
argument_list|,
name|binary
operator|->
name|GetBufferSize
argument_list|()
argument_list|,
name|type
argument_list|,
name|streamOutVaryings
argument_list|,
name|separatedOutputBuffers
argument_list|,
name|outExectuable
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|binary
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
operator|!
name|debugInfo
operator|.
name|empty
argument_list|()
condition|)
block|{
operator|(
operator|*
name|outExectuable
operator|)
operator|->
name|appendDebugInfo
argument_list|(
name|debugInfo
argument_list|)
expr_stmt|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|createUniformStorage
name|UniformStorageD3D
modifier|*
name|Renderer9
operator|::
name|createUniformStorage
parameter_list|(
name|size_t
name|storageSize
parameter_list|)
block|{
return|return
operator|new
name|UniformStorageD3D
argument_list|(
name|storageSize
argument_list|)
return|;
block|}
DECL|function|boxFilter
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|boxFilter
parameter_list|(
name|IDirect3DSurface9
modifier|*
name|source
parameter_list|,
name|IDirect3DSurface9
modifier|*
name|dest
parameter_list|)
block|{
return|return
name|mBlit
operator|->
name|boxFilter
argument_list|(
name|source
argument_list|,
name|dest
argument_list|)
return|;
block|}
DECL|function|getTexturePool
name|D3DPOOL
name|Renderer9
operator|::
name|getTexturePool
parameter_list|(
name|DWORD
name|usage
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|mD3d9Ex
operator|!=
name|NULL
condition|)
block|{
return|return
name|D3DPOOL_DEFAULT
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|usage
operator|&
operator|(
name|D3DUSAGE_DEPTHSTENCIL
operator||
name|D3DUSAGE_RENDERTARGET
operator|)
operator|)
condition|)
block|{
return|return
name|D3DPOOL_MANAGED
return|;
block|}
block|}
return|return
name|D3DPOOL_DEFAULT
return|;
block|}
DECL|function|copyToRenderTarget
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|copyToRenderTarget
parameter_list|(
name|IDirect3DSurface9
modifier|*
name|dest
parameter_list|,
name|IDirect3DSurface9
modifier|*
name|source
parameter_list|,
name|bool
name|fromManaged
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|source
operator|&&
name|dest
argument_list|)
expr_stmt|;
name|HRESULT
name|result
init|=
name|D3DERR_OUTOFVIDEOMEMORY
decl_stmt|;
if|if
condition|(
name|fromManaged
condition|)
block|{
name|D3DSURFACE_DESC
name|desc
decl_stmt|;
name|source
operator|->
name|GetDesc
argument_list|(
operator|&
name|desc
argument_list|)
expr_stmt|;
name|IDirect3DSurface9
modifier|*
name|surf
init|=
literal|0
decl_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|CreateOffscreenPlainSurface
argument_list|(
name|desc
operator|.
name|Width
argument_list|,
name|desc
operator|.
name|Height
argument_list|,
name|desc
operator|.
name|Format
argument_list|,
name|D3DPOOL_SYSTEMMEM
argument_list|,
operator|&
name|surf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|Image9
operator|::
name|copyLockableSurfaces
argument_list|(
name|surf
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|UpdateSurface
argument_list|(
name|surf
argument_list|,
name|NULL
argument_list|,
name|dest
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SafeRelease
argument_list|(
name|surf
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|endScene
argument_list|()
expr_stmt|;
name|result
operator|=
name|mDevice
operator|->
name|StretchRect
argument_list|(
name|source
argument_list|,
name|NULL
argument_list|,
name|dest
argument_list|,
name|NULL
argument_list|,
name|D3DTEXF_NONE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|result
operator|==
name|D3DERR_OUTOFVIDEOMEMORY
operator|||
name|result
operator|==
name|E_OUTOFMEMORY
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|"Failed to blit internal texture, result: 0x%X."
argument_list|,
name|result
argument_list|)
return|;
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|createImage
name|ImageD3D
modifier|*
name|Renderer9
operator|::
name|createImage
parameter_list|()
block|{
return|return
operator|new
name|Image9
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|function|generateMipmap
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|generateMipmap
parameter_list|(
name|ImageD3D
modifier|*
name|dest
parameter_list|,
name|ImageD3D
modifier|*
name|src
parameter_list|)
block|{
name|Image9
modifier|*
name|src9
init|=
name|GetAs
argument_list|<
name|Image9
argument_list|>
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|Image9
modifier|*
name|dst9
init|=
name|GetAs
argument_list|<
name|Image9
argument_list|>
argument_list|(
name|dest
argument_list|)
decl_stmt|;
return|return
name|Image9
operator|::
name|generateMipmap
argument_list|(
name|dst9
argument_list|,
name|src9
argument_list|)
return|;
block|}
DECL|function|generateMipmapsUsingD3D
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|generateMipmapsUsingD3D
parameter_list|(
name|TextureStorage
modifier|*
name|storage
parameter_list|,
specifier|const
name|gl
operator|::
name|TextureState
modifier|&
name|textureState
parameter_list|)
block|{
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|createTextureStorage2D
name|TextureStorage
modifier|*
name|Renderer9
operator|::
name|createTextureStorage2D
parameter_list|(
name|SwapChainD3D
modifier|*
name|swapChain
parameter_list|)
block|{
name|SwapChain9
modifier|*
name|swapChain9
init|=
name|GetAs
argument_list|<
name|SwapChain9
argument_list|>
argument_list|(
name|swapChain
argument_list|)
decl_stmt|;
return|return
operator|new
name|TextureStorage9_2D
argument_list|(
name|this
argument_list|,
name|swapChain9
argument_list|)
return|;
block|}
DECL|function|createTextureStorageEGLImage
name|TextureStorage
modifier|*
name|Renderer9
operator|::
name|createTextureStorageEGLImage
parameter_list|(
name|EGLImageD3D
modifier|*
name|eglImage
parameter_list|)
block|{
return|return
operator|new
name|TextureStorage9_EGLImage
argument_list|(
name|this
argument_list|,
name|eglImage
argument_list|)
return|;
block|}
DECL|function|createTextureStorage2D
name|TextureStorage
modifier|*
name|Renderer9
operator|::
name|createTextureStorage2D
parameter_list|(
name|GLenum
name|internalformat
parameter_list|,
name|bool
name|renderTarget
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|int
name|levels
parameter_list|,
name|bool
name|hintLevelZeroOnly
parameter_list|)
block|{
return|return
operator|new
name|TextureStorage9_2D
argument_list|(
name|this
argument_list|,
name|internalformat
argument_list|,
name|renderTarget
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|levels
argument_list|)
return|;
block|}
DECL|function|createTextureStorageCube
name|TextureStorage
modifier|*
name|Renderer9
operator|::
name|createTextureStorageCube
parameter_list|(
name|GLenum
name|internalformat
parameter_list|,
name|bool
name|renderTarget
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|levels
parameter_list|,
name|bool
name|hintLevelZeroOnly
parameter_list|)
block|{
return|return
operator|new
name|TextureStorage9_Cube
argument_list|(
name|this
argument_list|,
name|internalformat
argument_list|,
name|renderTarget
argument_list|,
name|size
argument_list|,
name|levels
argument_list|,
name|hintLevelZeroOnly
argument_list|)
return|;
block|}
DECL|function|createTextureStorage3D
name|TextureStorage
modifier|*
name|Renderer9
operator|::
name|createTextureStorage3D
parameter_list|(
name|GLenum
name|internalformat
parameter_list|,
name|bool
name|renderTarget
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|depth
parameter_list|,
name|int
name|levels
parameter_list|)
block|{
comment|// 3D textures are not supported by the D3D9 backend.
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
DECL|function|createTextureStorage2DArray
name|TextureStorage
modifier|*
name|Renderer9
operator|::
name|createTextureStorage2DArray
parameter_list|(
name|GLenum
name|internalformat
parameter_list|,
name|bool
name|renderTarget
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|depth
parameter_list|,
name|int
name|levels
parameter_list|)
block|{
comment|// 2D array textures are not supported by the D3D9 backend.
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
DECL|function|createTexture
name|TextureImpl
modifier|*
name|Renderer9
operator|::
name|createTexture
parameter_list|(
name|GLenum
name|target
parameter_list|)
block|{
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TEXTURE_2D
case|:
return|return
operator|new
name|TextureD3D_2D
argument_list|(
name|this
argument_list|)
return|;
case|case
name|GL_TEXTURE_CUBE_MAP
case|:
return|return
operator|new
name|TextureD3D_Cube
argument_list|(
name|this
argument_list|)
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
DECL|function|createRenderbuffer
name|RenderbufferImpl
modifier|*
name|Renderer9
operator|::
name|createRenderbuffer
parameter_list|()
block|{
name|RenderbufferD3D
modifier|*
name|renderbuffer
init|=
operator|new
name|RenderbufferD3D
argument_list|(
name|this
argument_list|)
decl_stmt|;
return|return
name|renderbuffer
return|;
block|}
DECL|function|getLUID
name|bool
name|Renderer9
operator|::
name|getLUID
parameter_list|(
name|LUID
modifier|*
name|adapterLuid
parameter_list|)
specifier|const
block|{
name|adapterLuid
operator|->
name|HighPart
operator|=
literal|0
expr_stmt|;
name|adapterLuid
operator|->
name|LowPart
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mD3d9Ex
condition|)
block|{
name|mD3d9Ex
operator|->
name|GetAdapterLUID
argument_list|(
name|mAdapter
argument_list|,
name|adapterLuid
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|function|getVertexConversionType
name|VertexConversionType
name|Renderer9
operator|::
name|getVertexConversionType
parameter_list|(
name|gl
operator|::
name|VertexFormatType
name|vertexFormatType
parameter_list|)
specifier|const
block|{
return|return
name|d3d9
operator|::
name|GetVertexFormatInfo
argument_list|(
name|getCapsDeclTypes
argument_list|()
argument_list|,
name|vertexFormatType
argument_list|)
operator|.
name|conversionType
return|;
block|}
DECL|function|getVertexComponentType
name|GLenum
name|Renderer9
operator|::
name|getVertexComponentType
parameter_list|(
name|gl
operator|::
name|VertexFormatType
name|vertexFormatType
parameter_list|)
specifier|const
block|{
return|return
name|d3d9
operator|::
name|GetVertexFormatInfo
argument_list|(
name|getCapsDeclTypes
argument_list|()
argument_list|,
name|vertexFormatType
argument_list|)
operator|.
name|componentType
return|;
block|}
DECL|function|generateCaps
name|void
name|Renderer9
operator|::
name|generateCaps
parameter_list|(
name|gl
operator|::
name|Caps
modifier|*
name|outCaps
parameter_list|,
name|gl
operator|::
name|TextureCapsMap
modifier|*
name|outTextureCaps
parameter_list|,
name|gl
operator|::
name|Extensions
modifier|*
name|outExtensions
parameter_list|,
name|gl
operator|::
name|Limitations
modifier|*
name|outLimitations
parameter_list|)
specifier|const
block|{
name|d3d9_gl
operator|::
name|GenerateCaps
argument_list|(
name|mD3d9
argument_list|,
name|mDevice
argument_list|,
name|mDeviceType
argument_list|,
name|mAdapter
argument_list|,
name|outCaps
argument_list|,
name|outTextureCaps
argument_list|,
name|outExtensions
argument_list|,
name|outLimitations
argument_list|)
expr_stmt|;
block|}
DECL|function|generateWorkarounds
name|WorkaroundsD3D
name|Renderer9
operator|::
name|generateWorkarounds
parameter_list|()
specifier|const
block|{
return|return
name|d3d9
operator|::
name|GenerateWorkarounds
argument_list|()
return|;
block|}
DECL|function|createAnnotator
name|void
name|Renderer9
operator|::
name|createAnnotator
parameter_list|()
block|{
name|mAnnotator
operator|=
operator|new
name|DebugAnnotator9
argument_list|()
expr_stmt|;
block|}
DECL|function|clearTextures
name|gl
operator|::
name|Error
name|Renderer9
operator|::
name|clearTextures
parameter_list|(
name|gl
operator|::
name|SamplerType
name|samplerType
parameter_list|,
name|size_t
name|rangeStart
parameter_list|,
name|size_t
name|rangeEnd
parameter_list|)
block|{
comment|// TODO(jmadill): faster way?
for|for
control|(
name|size_t
name|samplerIndex
init|=
name|rangeStart
init|;
name|samplerIndex
operator|<
name|rangeEnd
condition|;
name|samplerIndex
operator|++
control|)
block|{
name|gl
operator|::
name|Error
name|error
init|=
name|setTexture
argument_list|(
name|samplerType
argument_list|,
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|samplerIndex
argument_list|)
argument_list|,
literal|nullptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|getEGLDevice
name|egl
operator|::
name|Error
name|Renderer9
operator|::
name|getEGLDevice
parameter_list|(
name|DeviceImpl
modifier|*
modifier|*
name|device
parameter_list|)
block|{
if|if
condition|(
name|mEGLDevice
operator|==
literal|nullptr
condition|)
block|{
name|ASSERT
argument_list|(
name|mDevice
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
name|mEGLDevice
operator|=
operator|new
name|DeviceD3D
argument_list|()
expr_stmt|;
name|egl
operator|::
name|Error
name|error
init|=
name|mEGLDevice
operator|->
name|initialize
argument_list|(
cast|reinterpret_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
name|mDevice
argument_list|)
argument_list|,
name|EGL_D3D9_DEVICE_ANGLE
argument_list|,
name|EGL_FALSE
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
name|SafeDelete
argument_list|(
name|mEGLDevice
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
operator|*
name|device
operator|=
cast|static_cast
argument_list|<
name|DeviceImpl
operator|*
argument_list|>
argument_list|(
name|mEGLDevice
argument_list|)
expr_stmt|;
return|return
name|egl
operator|::
name|Error
argument_list|(
name|EGL_SUCCESS
argument_list|)
return|;
block|}
DECL|function|CurSamplerState
name|Renderer9
operator|::
name|CurSamplerState
operator|::
name|CurSamplerState
parameter_list|()
member_init_list|:
name|forceSet
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|baseLevel
argument_list|(
name|std
operator|::
name|numeric_limits
argument_list|<
name|size_t
argument_list|>
operator|::
name|max
argument_list|()
argument_list|)
member_init_list|,
name|samplerState
argument_list|()
block|{ }
block|}
end_namespace
end_unit
