begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2013 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// angletypes.h : Defines a variety of structures and enum types that are used throughout libGLESv2
end_comment
begin_include
include|#
directive|include
file|"libANGLE/angletypes.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Program.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/VertexAttribute.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/State.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/VertexArray.h"
end_include
begin_namespace
DECL|namespace|gl
namespace|namespace
name|gl
block|{
DECL|function|GetPrimitiveType
name|PrimitiveType
name|GetPrimitiveType
parameter_list|(
name|GLenum
name|drawMode
parameter_list|)
block|{
switch|switch
condition|(
name|drawMode
condition|)
block|{
case|case
name|GL_POINTS
case|:
return|return
name|PRIMITIVE_POINTS
return|;
case|case
name|GL_LINES
case|:
return|return
name|PRIMITIVE_LINES
return|;
case|case
name|GL_LINE_STRIP
case|:
return|return
name|PRIMITIVE_LINE_STRIP
return|;
case|case
name|GL_LINE_LOOP
case|:
return|return
name|PRIMITIVE_LINE_LOOP
return|;
case|case
name|GL_TRIANGLES
case|:
return|return
name|PRIMITIVE_TRIANGLES
return|;
case|case
name|GL_TRIANGLE_STRIP
case|:
return|return
name|PRIMITIVE_TRIANGLE_STRIP
return|;
case|case
name|GL_TRIANGLE_FAN
case|:
return|return
name|PRIMITIVE_TRIANGLE_FAN
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|PRIMITIVE_TYPE_MAX
return|;
block|}
block|}
DECL|function|SamplerState
name|SamplerState
operator|::
name|SamplerState
parameter_list|()
member_init_list|:
name|minFilter
argument_list|(
name|GL_NEAREST_MIPMAP_LINEAR
argument_list|)
member_init_list|,
name|magFilter
argument_list|(
name|GL_LINEAR
argument_list|)
member_init_list|,
name|wrapS
argument_list|(
name|GL_REPEAT
argument_list|)
member_init_list|,
name|wrapT
argument_list|(
name|GL_REPEAT
argument_list|)
member_init_list|,
name|wrapR
argument_list|(
name|GL_REPEAT
argument_list|)
member_init_list|,
name|maxAnisotropy
argument_list|(
literal|1.0f
argument_list|)
member_init_list|,
name|minLod
argument_list|(
operator|-
literal|1000.0f
argument_list|)
member_init_list|,
name|maxLod
argument_list|(
literal|1000.0f
argument_list|)
member_init_list|,
name|compareMode
argument_list|(
name|GL_NONE
argument_list|)
member_init_list|,
name|compareFunc
argument_list|(
name|GL_LEQUAL
argument_list|)
block|{ }
DECL|function|TextureState
name|TextureState
operator|::
name|TextureState
parameter_list|()
member_init_list|:
name|swizzleRed
argument_list|(
name|GL_RED
argument_list|)
member_init_list|,
name|swizzleGreen
argument_list|(
name|GL_GREEN
argument_list|)
member_init_list|,
name|swizzleBlue
argument_list|(
name|GL_BLUE
argument_list|)
member_init_list|,
name|swizzleAlpha
argument_list|(
name|GL_ALPHA
argument_list|)
member_init_list|,
name|samplerState
argument_list|()
member_init_list|,
name|baseLevel
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|maxLevel
argument_list|(
literal|1000
argument_list|)
member_init_list|,
name|immutableFormat
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|immutableLevels
argument_list|(
literal|0
argument_list|)
block|{ }
DECL|function|swizzleRequired
name|bool
name|TextureState
operator|::
name|swizzleRequired
parameter_list|()
specifier|const
block|{
return|return
name|swizzleRed
operator|!=
name|GL_RED
operator|||
name|swizzleGreen
operator|!=
name|GL_GREEN
operator|||
name|swizzleBlue
operator|!=
name|GL_BLUE
operator|||
name|swizzleAlpha
operator|!=
name|GL_ALPHA
return|;
block|}
DECL|function|MinMax
specifier|static
name|void
name|MinMax
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|,
name|int
modifier|*
name|minimum
parameter_list|,
name|int
modifier|*
name|maximum
parameter_list|)
block|{
if|if
condition|(
name|a
operator|<
name|b
condition|)
block|{
operator|*
name|minimum
operator|=
name|a
expr_stmt|;
operator|*
name|maximum
operator|=
name|b
expr_stmt|;
block|}
else|else
block|{
operator|*
name|minimum
operator|=
name|b
expr_stmt|;
operator|*
name|maximum
operator|=
name|a
expr_stmt|;
block|}
block|}
DECL|function|ClipRectangle
name|bool
name|ClipRectangle
parameter_list|(
specifier|const
name|Rectangle
modifier|&
name|source
parameter_list|,
specifier|const
name|Rectangle
modifier|&
name|clip
parameter_list|,
name|Rectangle
modifier|*
name|intersection
parameter_list|)
block|{
name|int
name|minSourceX
decl_stmt|,
name|maxSourceX
decl_stmt|,
name|minSourceY
decl_stmt|,
name|maxSourceY
decl_stmt|;
name|MinMax
argument_list|(
name|source
operator|.
name|x
argument_list|,
name|source
operator|.
name|x
operator|+
name|source
operator|.
name|width
argument_list|,
operator|&
name|minSourceX
argument_list|,
operator|&
name|maxSourceX
argument_list|)
expr_stmt|;
name|MinMax
argument_list|(
name|source
operator|.
name|y
argument_list|,
name|source
operator|.
name|y
operator|+
name|source
operator|.
name|height
argument_list|,
operator|&
name|minSourceY
argument_list|,
operator|&
name|maxSourceY
argument_list|)
expr_stmt|;
name|int
name|minClipX
decl_stmt|,
name|maxClipX
decl_stmt|,
name|minClipY
decl_stmt|,
name|maxClipY
decl_stmt|;
name|MinMax
argument_list|(
name|clip
operator|.
name|x
argument_list|,
name|clip
operator|.
name|x
operator|+
name|clip
operator|.
name|width
argument_list|,
operator|&
name|minClipX
argument_list|,
operator|&
name|maxClipX
argument_list|)
expr_stmt|;
name|MinMax
argument_list|(
name|clip
operator|.
name|y
argument_list|,
name|clip
operator|.
name|y
operator|+
name|clip
operator|.
name|height
argument_list|,
operator|&
name|minClipY
argument_list|,
operator|&
name|maxClipY
argument_list|)
expr_stmt|;
if|if
condition|(
name|minSourceX
operator|>=
name|maxClipX
operator|||
name|maxSourceX
operator|<=
name|minClipX
operator|||
name|minSourceY
operator|>=
name|maxClipY
operator|||
name|maxSourceY
operator|<=
name|minClipY
condition|)
block|{
if|if
condition|(
name|intersection
condition|)
block|{
name|intersection
operator|->
name|x
operator|=
name|minSourceX
expr_stmt|;
name|intersection
operator|->
name|y
operator|=
name|maxSourceY
expr_stmt|;
name|intersection
operator|->
name|width
operator|=
name|maxSourceX
operator|-
name|minSourceX
expr_stmt|;
name|intersection
operator|->
name|height
operator|=
name|maxSourceY
operator|-
name|minSourceY
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
else|else
block|{
if|if
condition|(
name|intersection
condition|)
block|{
name|intersection
operator|->
name|x
operator|=
name|std
operator|::
name|max
argument_list|(
name|minSourceX
argument_list|,
name|minClipX
argument_list|)
expr_stmt|;
name|intersection
operator|->
name|y
operator|=
name|std
operator|::
name|max
argument_list|(
name|minSourceY
argument_list|,
name|minClipY
argument_list|)
expr_stmt|;
name|intersection
operator|->
name|width
operator|=
name|std
operator|::
name|min
argument_list|(
name|maxSourceX
argument_list|,
name|maxClipX
argument_list|)
operator|-
name|std
operator|::
name|max
argument_list|(
name|minSourceX
argument_list|,
name|minClipX
argument_list|)
expr_stmt|;
name|intersection
operator|->
name|height
operator|=
name|std
operator|::
name|min
argument_list|(
name|maxSourceY
argument_list|,
name|maxClipY
argument_list|)
operator|-
name|std
operator|::
name|max
argument_list|(
name|minSourceY
argument_list|,
name|minClipY
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
DECL|function|operator ==
name|bool
name|Box
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|Box
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|x
operator|==
name|other
operator|.
name|x
operator|&&
name|y
operator|==
name|other
operator|.
name|y
operator|&&
name|z
operator|==
name|other
operator|.
name|z
operator|&&
name|width
operator|==
name|other
operator|.
name|width
operator|&&
name|height
operator|==
name|other
operator|.
name|height
operator|&&
name|depth
operator|==
name|other
operator|.
name|depth
operator|)
return|;
block|}
DECL|function|operator !=
name|bool
name|Box
operator|::
name|operator
name|!=
parameter_list|(
specifier|const
name|Box
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|other
operator|)
return|;
block|}
DECL|function|operator ==
name|bool
name|operator
name|==
parameter_list|(
specifier|const
name|Extents
modifier|&
name|lhs
parameter_list|,
specifier|const
name|Extents
modifier|&
name|rhs
parameter_list|)
block|{
return|return
name|lhs
operator|.
name|width
operator|==
name|rhs
operator|.
name|width
operator|&&
name|lhs
operator|.
name|height
operator|==
name|rhs
operator|.
name|height
operator|&&
name|lhs
operator|.
name|depth
operator|==
name|rhs
operator|.
name|depth
return|;
block|}
DECL|function|operator !=
name|bool
name|operator
name|!=
parameter_list|(
specifier|const
name|Extents
modifier|&
name|lhs
parameter_list|,
specifier|const
name|Extents
modifier|&
name|rhs
parameter_list|)
block|{
return|return
operator|!
operator|(
name|lhs
operator|==
name|rhs
operator|)
return|;
block|}
block|}
end_namespace
end_unit
