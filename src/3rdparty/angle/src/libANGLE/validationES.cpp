begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2013-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// validationES.h: Validation functions for generic OpenGL ES entry point parameters
end_comment
begin_include
include|#
directive|include
file|"libANGLE/validationES.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/validationES2.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/validationES3.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Context.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Display.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Texture.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Framebuffer.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/FramebufferAttachment.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/formatutils.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Image.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Query.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Program.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Uniform.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/TransformFeedback.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/VertexArray.h"
end_include
begin_include
include|#
directive|include
file|"common/mathutil.h"
end_include
begin_include
include|#
directive|include
file|"common/utilities.h"
end_include
begin_namespace
DECL|namespace|gl
namespace|namespace
name|gl
block|{
DECL|member|g_ExceedsMaxElementErrorMessage
specifier|const
name|char
modifier|*
name|g_ExceedsMaxElementErrorMessage
init|=
literal|"Element value exceeds maximum element index."
decl_stmt|;
namespace|namespace
block|{
DECL|function|ValidateDrawAttribs
name|bool
name|ValidateDrawAttribs
parameter_list|(
name|ValidationContext
modifier|*
name|context
parameter_list|,
name|GLint
name|primcount
parameter_list|,
name|GLint
name|maxVertex
parameter_list|)
block|{
specifier|const
name|gl
operator|::
name|State
modifier|&
name|state
init|=
name|context
operator|->
name|getState
argument_list|()
decl_stmt|;
specifier|const
name|gl
operator|::
name|Program
modifier|*
name|program
init|=
name|state
operator|.
name|getProgram
argument_list|()
decl_stmt|;
specifier|const
name|VertexArray
modifier|*
name|vao
init|=
name|state
operator|.
name|getVertexArray
argument_list|()
decl_stmt|;
specifier|const
specifier|auto
modifier|&
name|vertexAttribs
init|=
name|vao
operator|->
name|getVertexAttributes
argument_list|()
decl_stmt|;
name|size_t
name|maxEnabledAttrib
init|=
name|vao
operator|->
name|getMaxEnabledAttribute
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|attributeIndex
init|=
literal|0
init|;
name|attributeIndex
operator|<
name|maxEnabledAttrib
condition|;
operator|++
name|attributeIndex
control|)
block|{
specifier|const
name|VertexAttribute
modifier|&
name|attrib
init|=
name|vertexAttribs
index|[
name|attributeIndex
index|]
decl_stmt|;
if|if
condition|(
name|program
operator|->
name|isAttribLocationActive
argument_list|(
name|attributeIndex
argument_list|)
operator|&&
name|attrib
operator|.
name|enabled
condition|)
block|{
name|gl
operator|::
name|Buffer
modifier|*
name|buffer
init|=
name|attrib
operator|.
name|buffer
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|buffer
condition|)
block|{
name|GLint64
name|attribStride
init|=
cast|static_cast
argument_list|<
name|GLint64
argument_list|>
argument_list|(
name|ComputeVertexAttributeStride
argument_list|(
name|attrib
argument_list|)
argument_list|)
decl_stmt|;
name|GLint64
name|maxVertexElement
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|attrib
operator|.
name|divisor
operator|>
literal|0
condition|)
block|{
name|maxVertexElement
operator|=
cast|static_cast
argument_list|<
name|GLint64
argument_list|>
argument_list|(
name|primcount
argument_list|)
operator|/
cast|static_cast
argument_list|<
name|GLint64
argument_list|>
argument_list|(
name|attrib
operator|.
name|divisor
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|maxVertexElement
operator|=
cast|static_cast
argument_list|<
name|GLint64
argument_list|>
argument_list|(
name|maxVertex
argument_list|)
expr_stmt|;
block|}
comment|// If we're drawing zero vertices, we have enough data.
if|if
condition|(
name|maxVertexElement
operator|>
literal|0
condition|)
block|{
comment|// Note: Last vertex element does not take the full stride!
name|GLint64
name|attribSize
init|=
cast|static_cast
argument_list|<
name|GLint64
argument_list|>
argument_list|(
name|ComputeVertexAttributeTypeSize
argument_list|(
name|attrib
argument_list|)
argument_list|)
decl_stmt|;
name|GLint64
name|attribDataSize
init|=
operator|(
name|maxVertexElement
operator|-
literal|1
operator|)
operator|*
name|attribStride
operator|+
name|attribSize
decl_stmt|;
comment|// [OpenGL ES 3.0.2] section 2.9.4 page 40:
comment|// We can return INVALID_OPERATION if our vertex attribute does not have
comment|// enough backing data.
if|if
condition|(
name|attribDataSize
operator|>
name|buffer
operator|->
name|getSize
argument_list|()
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|attrib
operator|.
name|pointer
operator|==
name|NULL
condition|)
block|{
comment|// This is an application error that would normally result in a crash,
comment|// but we catch it and return an error
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"An enabled vertex array has no buffer and no pointer."
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
comment|// anonymous namespace
DECL|function|ValidCap
name|bool
name|ValidCap
parameter_list|(
specifier|const
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|cap
parameter_list|)
block|{
switch|switch
condition|(
name|cap
condition|)
block|{
case|case
name|GL_CULL_FACE
case|:
case|case
name|GL_POLYGON_OFFSET_FILL
case|:
case|case
name|GL_SAMPLE_ALPHA_TO_COVERAGE
case|:
case|case
name|GL_SAMPLE_COVERAGE
case|:
case|case
name|GL_SCISSOR_TEST
case|:
case|case
name|GL_STENCIL_TEST
case|:
case|case
name|GL_DEPTH_TEST
case|:
case|case
name|GL_BLEND
case|:
case|case
name|GL_DITHER
case|:
return|return
literal|true
return|;
case|case
name|GL_PRIMITIVE_RESTART_FIXED_INDEX
case|:
case|case
name|GL_RASTERIZER_DISCARD
case|:
return|return
operator|(
name|context
operator|->
name|getClientVersion
argument_list|()
operator|>=
literal|3
operator|)
return|;
case|case
name|GL_DEBUG_OUTPUT_SYNCHRONOUS
case|:
case|case
name|GL_DEBUG_OUTPUT
case|:
return|return
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|debug
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
DECL|function|ValidTextureTarget
name|bool
name|ValidTextureTarget
parameter_list|(
specifier|const
name|ValidationContext
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|)
block|{
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TEXTURE_2D
case|:
case|case
name|GL_TEXTURE_CUBE_MAP
case|:
return|return
literal|true
return|;
case|case
name|GL_TEXTURE_3D
case|:
case|case
name|GL_TEXTURE_2D_ARRAY
case|:
return|return
operator|(
name|context
operator|->
name|getClientVersion
argument_list|()
operator|>=
literal|3
operator|)
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
DECL|function|ValidTexture2DTarget
name|bool
name|ValidTexture2DTarget
parameter_list|(
specifier|const
name|ValidationContext
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|)
block|{
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TEXTURE_2D
case|:
case|case
name|GL_TEXTURE_CUBE_MAP
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
DECL|function|ValidTexture3DTarget
name|bool
name|ValidTexture3DTarget
parameter_list|(
specifier|const
name|ValidationContext
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|)
block|{
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TEXTURE_3D
case|:
case|case
name|GL_TEXTURE_2D_ARRAY
case|:
return|return
operator|(
name|context
operator|->
name|getClientVersion
argument_list|()
operator|>=
literal|3
operator|)
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|// This function differs from ValidTextureTarget in that the target must be
comment|// usable as the destination of a 2D operation-- so a cube face is valid, but
comment|// GL_TEXTURE_CUBE_MAP is not.
comment|// Note: duplicate of IsInternalTextureTarget
DECL|function|ValidTexture2DDestinationTarget
name|bool
name|ValidTexture2DDestinationTarget
parameter_list|(
specifier|const
name|ValidationContext
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|)
block|{
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TEXTURE_2D
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_X
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Y
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Z
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
DECL|function|ValidTexture3DDestinationTarget
name|bool
name|ValidTexture3DDestinationTarget
parameter_list|(
specifier|const
name|ValidationContext
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|)
block|{
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TEXTURE_3D
case|:
case|case
name|GL_TEXTURE_2D_ARRAY
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
DECL|function|ValidFramebufferTarget
name|bool
name|ValidFramebufferTarget
parameter_list|(
name|GLenum
name|target
parameter_list|)
block|{
assert|static_assert
argument_list|(
name|GL_DRAW_FRAMEBUFFER_ANGLE
operator|==
name|GL_DRAW_FRAMEBUFFER
operator|&&
name|GL_READ_FRAMEBUFFER_ANGLE
operator|==
name|GL_READ_FRAMEBUFFER
argument_list|,
literal|"ANGLE framebuffer enums must equal the ES3 framebuffer enums."
argument_list|)
assert|;
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_FRAMEBUFFER
case|:
return|return
literal|true
return|;
case|case
name|GL_READ_FRAMEBUFFER
case|:
return|return
literal|true
return|;
case|case
name|GL_DRAW_FRAMEBUFFER
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
DECL|function|ValidBufferTarget
name|bool
name|ValidBufferTarget
parameter_list|(
specifier|const
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|)
block|{
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_ARRAY_BUFFER
case|:
case|case
name|GL_ELEMENT_ARRAY_BUFFER
case|:
return|return
literal|true
return|;
case|case
name|GL_PIXEL_PACK_BUFFER
case|:
case|case
name|GL_PIXEL_UNPACK_BUFFER
case|:
return|return
operator|(
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|pixelBufferObject
operator|||
name|context
operator|->
name|getClientVersion
argument_list|()
operator|>=
literal|3
operator|)
return|;
case|case
name|GL_COPY_READ_BUFFER
case|:
case|case
name|GL_COPY_WRITE_BUFFER
case|:
case|case
name|GL_TRANSFORM_FEEDBACK_BUFFER
case|:
case|case
name|GL_UNIFORM_BUFFER
case|:
return|return
operator|(
name|context
operator|->
name|getClientVersion
argument_list|()
operator|>=
literal|3
operator|)
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
DECL|function|ValidBufferParameter
name|bool
name|ValidBufferParameter
parameter_list|(
specifier|const
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|pname
parameter_list|)
block|{
specifier|const
name|Extensions
modifier|&
name|extensions
init|=
name|context
operator|->
name|getExtensions
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_BUFFER_USAGE
case|:
case|case
name|GL_BUFFER_SIZE
case|:
return|return
literal|true
return|;
case|case
name|GL_BUFFER_ACCESS_OES
case|:
return|return
name|extensions
operator|.
name|mapBuffer
return|;
case|case
name|GL_BUFFER_MAPPED
case|:
assert|static_assert
argument_list|(
name|GL_BUFFER_MAPPED
operator|==
name|GL_BUFFER_MAPPED_OES
argument_list|,
literal|"GL enums should be equal."
argument_list|)
assert|;
return|return
operator|(
name|context
operator|->
name|getClientVersion
argument_list|()
operator|>=
literal|3
operator|)
operator|||
name|extensions
operator|.
name|mapBuffer
operator|||
name|extensions
operator|.
name|mapBufferRange
return|;
comment|// GL_BUFFER_MAP_POINTER is a special case, and may only be
comment|// queried with GetBufferPointerv
case|case
name|GL_BUFFER_ACCESS_FLAGS
case|:
case|case
name|GL_BUFFER_MAP_OFFSET
case|:
case|case
name|GL_BUFFER_MAP_LENGTH
case|:
return|return
operator|(
name|context
operator|->
name|getClientVersion
argument_list|()
operator|>=
literal|3
operator|)
operator|||
name|extensions
operator|.
name|mapBufferRange
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
DECL|function|ValidMipLevel
name|bool
name|ValidMipLevel
parameter_list|(
specifier|const
name|ValidationContext
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|)
block|{
specifier|const
specifier|auto
modifier|&
name|caps
init|=
name|context
operator|->
name|getCaps
argument_list|()
decl_stmt|;
name|size_t
name|maxDimension
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TEXTURE_2D
case|:
name|maxDimension
operator|=
name|caps
operator|.
name|max2DTextureSize
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_CUBE_MAP
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_X
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Y
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Z
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
case|:
name|maxDimension
operator|=
name|caps
operator|.
name|maxCubeMapTextureSize
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_3D
case|:
name|maxDimension
operator|=
name|caps
operator|.
name|max3DTextureSize
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_2D_ARRAY
case|:
name|maxDimension
operator|=
name|caps
operator|.
name|max2DTextureSize
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
name|level
operator|<=
name|gl
operator|::
name|log2
argument_list|(
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|maxDimension
argument_list|)
argument_list|)
return|;
block|}
DECL|function|ValidImageSizeParameters
name|bool
name|ValidImageSizeParameters
parameter_list|(
specifier|const
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|depth
parameter_list|,
name|bool
name|isSubImage
parameter_list|)
block|{
if|if
condition|(
name|level
operator|<
literal|0
operator|||
name|width
operator|<
literal|0
operator|||
name|height
operator|<
literal|0
operator|||
name|depth
operator|<
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// TexSubImage parameters can be NPOT without textureNPOT extension,
comment|// as long as the destination texture is POT.
if|if
condition|(
operator|!
name|isSubImage
operator|&&
operator|!
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|textureNPOT
operator|&&
operator|(
name|level
operator|!=
literal|0
operator|&&
operator|(
operator|!
name|gl
operator|::
name|isPow2
argument_list|(
name|width
argument_list|)
operator|||
operator|!
name|gl
operator|::
name|isPow2
argument_list|(
name|height
argument_list|)
operator|||
operator|!
name|gl
operator|::
name|isPow2
argument_list|(
name|depth
argument_list|)
operator|)
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|ValidMipLevel
argument_list|(
name|context
argument_list|,
name|target
argument_list|,
name|level
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|CompressedTextureFormatRequiresExactSize
name|bool
name|CompressedTextureFormatRequiresExactSize
parameter_list|(
name|GLenum
name|internalFormat
parameter_list|)
block|{
comment|// List of compressed format that require that the texture size is smaller than or a multiple of
comment|// the compressed block size.
switch|switch
condition|(
name|internalFormat
condition|)
block|{
case|case
name|GL_COMPRESSED_RGB_S3TC_DXT1_EXT
case|:
case|case
name|GL_COMPRESSED_RGBA_S3TC_DXT1_EXT
case|:
case|case
name|GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE
case|:
case|case
name|GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE
case|:
case|case
name|GL_ETC1_RGB8_LOSSY_DECODE_ANGLE
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
DECL|function|ValidCompressedImageSize
name|bool
name|ValidCompressedImageSize
parameter_list|(
specifier|const
name|ValidationContext
modifier|*
name|context
parameter_list|,
name|GLenum
name|internalFormat
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
specifier|const
name|gl
operator|::
name|InternalFormat
modifier|&
name|formatInfo
init|=
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|internalFormat
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|formatInfo
operator|.
name|compressed
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|width
operator|<
literal|0
operator|||
name|height
operator|<
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|CompressedTextureFormatRequiresExactSize
argument_list|(
name|internalFormat
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|width
argument_list|)
operator|>
name|formatInfo
operator|.
name|compressedBlockWidth
operator|&&
name|width
operator|%
name|formatInfo
operator|.
name|compressedBlockWidth
operator|!=
literal|0
operator|)
operator|||
operator|(
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|height
argument_list|)
operator|>
name|formatInfo
operator|.
name|compressedBlockHeight
operator|&&
name|height
operator|%
name|formatInfo
operator|.
name|compressedBlockHeight
operator|!=
literal|0
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidQueryType
name|bool
name|ValidQueryType
parameter_list|(
specifier|const
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|queryType
parameter_list|)
block|{
assert|static_assert
argument_list|(
name|GL_ANY_SAMPLES_PASSED
operator|==
name|GL_ANY_SAMPLES_PASSED_EXT
argument_list|,
literal|"GL extension enums not equal."
argument_list|)
assert|;
assert|static_assert
argument_list|(
name|GL_ANY_SAMPLES_PASSED_CONSERVATIVE
operator|==
name|GL_ANY_SAMPLES_PASSED_CONSERVATIVE_EXT
argument_list|,
literal|"GL extension enums not equal."
argument_list|)
assert|;
switch|switch
condition|(
name|queryType
condition|)
block|{
case|case
name|GL_ANY_SAMPLES_PASSED
case|:
case|case
name|GL_ANY_SAMPLES_PASSED_CONSERVATIVE
case|:
return|return
literal|true
return|;
case|case
name|GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN
case|:
return|return
operator|(
name|context
operator|->
name|getClientVersion
argument_list|()
operator|>=
literal|3
operator|)
return|;
case|case
name|GL_TIME_ELAPSED_EXT
case|:
return|return
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|disjointTimerQuery
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
DECL|function|GetValidProgram
name|Program
modifier|*
name|GetValidProgram
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLuint
name|id
parameter_list|)
block|{
comment|// ES3 spec (section 2.11.1) -- "Commands that accept shader or program object names will generate the
comment|// error INVALID_VALUE if the provided name is not the name of either a shader or program object and
comment|// INVALID_OPERATION if the provided name identifies an object that is not the expected type."
name|Program
modifier|*
name|validProgram
init|=
name|context
operator|->
name|getProgram
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|validProgram
condition|)
block|{
if|if
condition|(
name|context
operator|->
name|getShader
argument_list|(
name|id
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"Expected a program name, but found a shader name"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|"Program name is not valid"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|validProgram
return|;
block|}
DECL|function|GetValidShader
name|Shader
modifier|*
name|GetValidShader
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLuint
name|id
parameter_list|)
block|{
comment|// See ValidProgram for spec details.
name|Shader
modifier|*
name|validShader
init|=
name|context
operator|->
name|getShader
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|validShader
condition|)
block|{
if|if
condition|(
name|context
operator|->
name|getProgram
argument_list|(
name|id
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"Expected a shader name, but found a program name"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|"Shader name is invalid"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|validShader
return|;
block|}
DECL|function|ValidateAttachmentTarget
name|bool
name|ValidateAttachmentTarget
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|attachment
parameter_list|)
block|{
if|if
condition|(
name|attachment
operator|>=
name|GL_COLOR_ATTACHMENT0_EXT
operator|&&
name|attachment
operator|<=
name|GL_COLOR_ATTACHMENT15_EXT
condition|)
block|{
specifier|const
name|unsigned
name|int
name|colorAttachment
init|=
operator|(
name|attachment
operator|-
name|GL_COLOR_ATTACHMENT0_EXT
operator|)
decl_stmt|;
if|if
condition|(
name|colorAttachment
operator|>=
name|context
operator|->
name|getCaps
argument_list|()
operator|.
name|maxColorAttachments
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|attachment
condition|)
block|{
case|case
name|GL_DEPTH_ATTACHMENT
case|:
case|case
name|GL_STENCIL_ATTACHMENT
case|:
break|break;
case|case
name|GL_DEPTH_STENCIL_ATTACHMENT
case|:
if|if
condition|(
name|context
operator|->
name|getClientVersion
argument_list|()
operator|<
literal|3
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateRenderbufferStorageParametersBase
name|bool
name|ValidateRenderbufferStorageParametersBase
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLsizei
name|samples
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_RENDERBUFFER
case|:
break|break;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|width
operator|<
literal|0
operator|||
name|height
operator|<
literal|0
operator|||
name|samples
operator|<
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|TextureCaps
modifier|&
name|formatCaps
init|=
name|context
operator|->
name|getTextureCaps
argument_list|()
operator|.
name|get
argument_list|(
name|internalformat
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|formatCaps
operator|.
name|renderable
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// ANGLE_framebuffer_multisample does not explicitly state that the internal format must be
comment|// sized but it does state that the format must be in the ES2.0 spec table 4.5 which contains
comment|// only sized internal formats.
specifier|const
name|gl
operator|::
name|InternalFormat
modifier|&
name|formatInfo
init|=
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|internalformat
argument_list|)
decl_stmt|;
if|if
condition|(
name|formatInfo
operator|.
name|pixelBytes
operator|==
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|std
operator|::
name|max
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
argument_list|)
operator|>
name|context
operator|->
name|getCaps
argument_list|()
operator|.
name|maxRenderbufferSize
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|GLuint
name|handle
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getRenderbufferId
argument_list|()
decl_stmt|;
if|if
condition|(
name|handle
operator|==
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateRenderbufferStorageParametersANGLE
name|bool
name|ValidateRenderbufferStorageParametersANGLE
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLsizei
name|samples
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|samples
operator|==
literal|0
operator|||
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|framebufferMultisample
argument_list|)
expr_stmt|;
comment|// ANGLE_framebuffer_multisample states that the value of samples must be less than or equal
comment|// to MAX_SAMPLES_ANGLE (Context::getCaps().maxSamples) otherwise GL_INVALID_VALUE is
comment|// generated.
if|if
condition|(
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|samples
argument_list|)
operator|>
name|context
operator|->
name|getCaps
argument_list|()
operator|.
name|maxSamples
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// ANGLE_framebuffer_multisample states GL_OUT_OF_MEMORY is generated on a failure to create
comment|// the specified storage. This is different than ES 3.0 in which a sample number higher
comment|// than the maximum sample number supported  by this format generates a GL_INVALID_VALUE.
comment|// The TextureCaps::getMaxSamples method is only guarenteed to be valid when the context is ES3.
if|if
condition|(
name|context
operator|->
name|getClientVersion
argument_list|()
operator|>=
literal|3
condition|)
block|{
specifier|const
name|TextureCaps
modifier|&
name|formatCaps
init|=
name|context
operator|->
name|getTextureCaps
argument_list|()
operator|.
name|get
argument_list|(
name|internalformat
argument_list|)
decl_stmt|;
if|if
condition|(
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|samples
argument_list|)
operator|>
name|formatCaps
operator|.
name|getMaxSamples
argument_list|()
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
name|ValidateRenderbufferStorageParametersBase
argument_list|(
name|context
argument_list|,
name|target
argument_list|,
name|samples
argument_list|,
name|internalformat
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
return|;
block|}
DECL|function|ValidateFramebufferRenderbufferParameters
name|bool
name|ValidateFramebufferRenderbufferParameters
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLenum
name|attachment
parameter_list|,
name|GLenum
name|renderbuffertarget
parameter_list|,
name|GLuint
name|renderbuffer
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ValidFramebufferTarget
argument_list|(
name|target
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getTargetFramebuffer
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|framebuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|framebuffer
operator|->
name|id
argument_list|()
operator|==
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"Cannot change default FBO's attachments"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|ValidateAttachmentTarget
argument_list|(
name|context
argument_list|,
name|attachment
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// [OpenGL ES 2.0.25] Section 4.4.3 page 112
comment|// [OpenGL ES 3.0.2] Section 4.4.2 page 201
comment|// 'renderbuffer' must be either zero or the name of an existing renderbuffer object of
comment|// type 'renderbuffertarget', otherwise an INVALID_OPERATION error is generated.
if|if
condition|(
name|renderbuffer
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|context
operator|->
name|getRenderbuffer
argument_list|(
name|renderbuffer
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateBlitFramebufferParameters
name|bool
name|ValidateBlitFramebufferParameters
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLint
name|srcX0
parameter_list|,
name|GLint
name|srcY0
parameter_list|,
name|GLint
name|srcX1
parameter_list|,
name|GLint
name|srcY1
parameter_list|,
name|GLint
name|dstX0
parameter_list|,
name|GLint
name|dstY0
parameter_list|,
name|GLint
name|dstX1
parameter_list|,
name|GLint
name|dstY1
parameter_list|,
name|GLbitfield
name|mask
parameter_list|,
name|GLenum
name|filter
parameter_list|)
block|{
switch|switch
condition|(
name|filter
condition|)
block|{
case|case
name|GL_NEAREST
case|:
break|break;
case|case
name|GL_LINEAR
case|:
break|break;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
operator|~
operator|(
name|GL_COLOR_BUFFER_BIT
operator||
name|GL_STENCIL_BUFFER_BIT
operator||
name|GL_DEPTH_BUFFER_BIT
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
block|{
comment|// ES3.0 spec, section 4.3.2 specifies that a mask of zero is valid and no
comment|// buffers are copied.
return|return
literal|false
return|;
block|}
comment|// ES3.0 spec, section 4.3.2 states that linear filtering is only available for the
comment|// color buffer, leaving only nearest being unfiltered from above
if|if
condition|(
operator|(
name|mask
operator|&
operator|~
name|GL_COLOR_BUFFER_BIT
operator|)
operator|!=
literal|0
operator|&&
name|filter
operator|!=
name|GL_NEAREST
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getReadFramebuffer
argument_list|()
operator|->
name|id
argument_list|()
operator|==
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getDrawFramebuffer
argument_list|()
operator|->
name|id
argument_list|()
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|readFramebuffer
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getReadFramebuffer
argument_list|()
decl_stmt|;
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|drawFramebuffer
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|readFramebuffer
operator|||
operator|!
name|drawFramebuffer
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_FRAMEBUFFER_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|readFramebuffer
operator|->
name|checkStatus
argument_list|(
name|context
operator|->
name|getData
argument_list|()
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_FRAMEBUFFER_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|drawFramebuffer
operator|->
name|checkStatus
argument_list|(
name|context
operator|->
name|getData
argument_list|()
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_FRAMEBUFFER_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|drawFramebuffer
operator|->
name|getSamples
argument_list|(
name|context
operator|->
name|getData
argument_list|()
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|bool
name|sameBounds
init|=
name|srcX0
operator|==
name|dstX0
operator|&&
name|srcY0
operator|==
name|dstY0
operator|&&
name|srcX1
operator|==
name|dstX1
operator|&&
name|srcY1
operator|==
name|dstY1
decl_stmt|;
if|if
condition|(
name|mask
operator|&
name|GL_COLOR_BUFFER_BIT
condition|)
block|{
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|readColorBuffer
init|=
name|readFramebuffer
operator|->
name|getReadColorbuffer
argument_list|()
decl_stmt|;
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|drawColorBuffer
init|=
name|drawFramebuffer
operator|->
name|getFirstColorbuffer
argument_list|()
decl_stmt|;
specifier|const
name|Extensions
modifier|&
name|extensions
init|=
name|context
operator|->
name|getExtensions
argument_list|()
decl_stmt|;
if|if
condition|(
name|readColorBuffer
operator|&&
name|drawColorBuffer
condition|)
block|{
name|GLenum
name|readInternalFormat
init|=
name|readColorBuffer
operator|->
name|getInternalFormat
argument_list|()
decl_stmt|;
specifier|const
name|InternalFormat
modifier|&
name|readFormatInfo
init|=
name|GetInternalFormatInfo
argument_list|(
name|readInternalFormat
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|drawbufferIdx
init|=
literal|0
init|;
name|drawbufferIdx
operator|<
name|drawFramebuffer
operator|->
name|getDrawbufferStateCount
argument_list|()
condition|;
operator|++
name|drawbufferIdx
control|)
block|{
specifier|const
name|FramebufferAttachment
modifier|*
name|attachment
init|=
name|drawFramebuffer
operator|->
name|getDrawBuffer
argument_list|(
name|drawbufferIdx
argument_list|)
decl_stmt|;
if|if
condition|(
name|attachment
condition|)
block|{
name|GLenum
name|drawInternalFormat
init|=
name|attachment
operator|->
name|getInternalFormat
argument_list|()
decl_stmt|;
specifier|const
name|InternalFormat
modifier|&
name|drawFormatInfo
init|=
name|GetInternalFormatInfo
argument_list|(
name|drawInternalFormat
argument_list|)
decl_stmt|;
comment|// The GL ES 3.0.2 spec (pg 193) states that:
comment|// 1) If the read buffer is fixed point format, the draw buffer must be as well
comment|// 2) If the read buffer is an unsigned integer format, the draw buffer must be as well
comment|// 3) If the read buffer is a signed integer format, the draw buffer must be as well
comment|// Changes with EXT_color_buffer_float:
comment|// Case 1) is changed to fixed point OR floating point
name|GLenum
name|readComponentType
init|=
name|readFormatInfo
operator|.
name|componentType
decl_stmt|;
name|GLenum
name|drawComponentType
init|=
name|drawFormatInfo
operator|.
name|componentType
decl_stmt|;
name|bool
name|readFixedPoint
init|=
operator|(
name|readComponentType
operator|==
name|GL_UNSIGNED_NORMALIZED
operator|||
name|readComponentType
operator|==
name|GL_SIGNED_NORMALIZED
operator|)
decl_stmt|;
name|bool
name|drawFixedPoint
init|=
operator|(
name|drawComponentType
operator|==
name|GL_UNSIGNED_NORMALIZED
operator|||
name|drawComponentType
operator|==
name|GL_SIGNED_NORMALIZED
operator|)
decl_stmt|;
if|if
condition|(
name|extensions
operator|.
name|colorBufferFloat
condition|)
block|{
name|bool
name|readFixedOrFloat
init|=
operator|(
name|readFixedPoint
operator|||
name|readComponentType
operator|==
name|GL_FLOAT
operator|)
decl_stmt|;
name|bool
name|drawFixedOrFloat
init|=
operator|(
name|drawFixedPoint
operator|||
name|drawComponentType
operator|==
name|GL_FLOAT
operator|)
decl_stmt|;
if|if
condition|(
name|readFixedOrFloat
operator|!=
name|drawFixedOrFloat
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"If the read buffer contains fixed-point or "
literal|"floating-point values, the draw buffer "
literal|"must as well."
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|readFixedPoint
operator|!=
name|drawFixedPoint
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"If the read buffer contains fixed-point "
literal|"values, the draw buffer must as well."
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|readComponentType
operator|==
name|GL_UNSIGNED_INT
operator|&&
name|drawComponentType
operator|!=
name|GL_UNSIGNED_INT
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|readComponentType
operator|==
name|GL_INT
operator|&&
name|drawComponentType
operator|!=
name|GL_INT
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|readColorBuffer
operator|->
name|getSamples
argument_list|()
operator|>
literal|0
operator|&&
operator|(
name|readInternalFormat
operator|!=
name|drawInternalFormat
operator|||
operator|!
name|sameBounds
operator|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|readFormatInfo
operator|.
name|componentType
operator|==
name|GL_INT
operator|||
name|readFormatInfo
operator|.
name|componentType
operator|==
name|GL_UNSIGNED_INT
operator|)
operator|&&
name|filter
operator|==
name|GL_LINEAR
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
name|GLenum
name|masks
index|[]
init|=
block|{
name|GL_DEPTH_BUFFER_BIT
block|,
name|GL_STENCIL_BUFFER_BIT
block|}
decl_stmt|;
name|GLenum
name|attachments
index|[]
init|=
block|{
name|GL_DEPTH_ATTACHMENT
block|,
name|GL_STENCIL_ATTACHMENT
block|}
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
name|masks
index|[
name|i
index|]
condition|)
block|{
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|readBuffer
init|=
name|readFramebuffer
operator|->
name|getAttachment
argument_list|(
name|attachments
index|[
name|i
index|]
argument_list|)
decl_stmt|;
specifier|const
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|drawBuffer
init|=
name|drawFramebuffer
operator|->
name|getAttachment
argument_list|(
name|attachments
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|readBuffer
operator|&&
name|drawBuffer
condition|)
block|{
if|if
condition|(
name|readBuffer
operator|->
name|getInternalFormat
argument_list|()
operator|!=
name|drawBuffer
operator|->
name|getInternalFormat
argument_list|()
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|readBuffer
operator|->
name|getSamples
argument_list|()
operator|>
literal|0
operator|&&
operator|!
name|sameBounds
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateGetVertexAttribParameters
name|bool
name|ValidateGetVertexAttribParameters
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|pname
parameter_list|)
block|{
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_VERTEX_ATTRIB_ARRAY_ENABLED
case|:
case|case
name|GL_VERTEX_ATTRIB_ARRAY_SIZE
case|:
case|case
name|GL_VERTEX_ATTRIB_ARRAY_STRIDE
case|:
case|case
name|GL_VERTEX_ATTRIB_ARRAY_TYPE
case|:
case|case
name|GL_VERTEX_ATTRIB_ARRAY_NORMALIZED
case|:
case|case
name|GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING
case|:
case|case
name|GL_CURRENT_VERTEX_ATTRIB
case|:
return|return
literal|true
return|;
case|case
name|GL_VERTEX_ATTRIB_ARRAY_DIVISOR
case|:
comment|// Don't verify ES3 context because GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE uses
comment|// the same constant.
assert|static_assert
argument_list|(
name|GL_VERTEX_ATTRIB_ARRAY_DIVISOR
operator|==
name|GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE
argument_list|,
literal|"ANGLE extension enums not equal to GL enums."
argument_list|)
assert|;
return|return
literal|true
return|;
case|case
name|GL_VERTEX_ATTRIB_ARRAY_INTEGER
case|:
if|if
condition|(
name|context
operator|->
name|getClientVersion
argument_list|()
operator|<
literal|3
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|ValidateTexParamParameters
name|bool
name|ValidateTexParamParameters
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLint
name|param
parameter_list|)
block|{
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_TEXTURE_WRAP_R
case|:
case|case
name|GL_TEXTURE_SWIZZLE_R
case|:
case|case
name|GL_TEXTURE_SWIZZLE_G
case|:
case|case
name|GL_TEXTURE_SWIZZLE_B
case|:
case|case
name|GL_TEXTURE_SWIZZLE_A
case|:
case|case
name|GL_TEXTURE_BASE_LEVEL
case|:
case|case
name|GL_TEXTURE_MAX_LEVEL
case|:
case|case
name|GL_TEXTURE_COMPARE_MODE
case|:
case|case
name|GL_TEXTURE_COMPARE_FUNC
case|:
case|case
name|GL_TEXTURE_MIN_LOD
case|:
case|case
name|GL_TEXTURE_MAX_LOD
case|:
if|if
condition|(
name|context
operator|->
name|getClientVersion
argument_list|()
operator|<
literal|3
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_TEXTURE_WRAP_S
case|:
case|case
name|GL_TEXTURE_WRAP_T
case|:
case|case
name|GL_TEXTURE_WRAP_R
case|:
switch|switch
condition|(
name|param
condition|)
block|{
case|case
name|GL_REPEAT
case|:
case|case
name|GL_CLAMP_TO_EDGE
case|:
case|case
name|GL_MIRRORED_REPEAT
case|:
return|return
literal|true
return|;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
case|case
name|GL_TEXTURE_MIN_FILTER
case|:
switch|switch
condition|(
name|param
condition|)
block|{
case|case
name|GL_NEAREST
case|:
case|case
name|GL_LINEAR
case|:
case|case
name|GL_NEAREST_MIPMAP_NEAREST
case|:
case|case
name|GL_LINEAR_MIPMAP_NEAREST
case|:
case|case
name|GL_NEAREST_MIPMAP_LINEAR
case|:
case|case
name|GL_LINEAR_MIPMAP_LINEAR
case|:
return|return
literal|true
return|;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|GL_TEXTURE_MAG_FILTER
case|:
switch|switch
condition|(
name|param
condition|)
block|{
case|case
name|GL_NEAREST
case|:
case|case
name|GL_LINEAR
case|:
return|return
literal|true
return|;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|GL_TEXTURE_USAGE_ANGLE
case|:
switch|switch
condition|(
name|param
condition|)
block|{
case|case
name|GL_NONE
case|:
case|case
name|GL_FRAMEBUFFER_ATTACHMENT_ANGLE
case|:
return|return
literal|true
return|;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|GL_TEXTURE_MAX_ANISOTROPY_EXT
case|:
if|if
condition|(
operator|!
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|textureFilterAnisotropic
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// we assume the parameter passed to this validation method is truncated, not rounded
if|if
condition|(
name|param
operator|<
literal|1
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
case|case
name|GL_TEXTURE_MIN_LOD
case|:
case|case
name|GL_TEXTURE_MAX_LOD
case|:
comment|// any value is permissible
return|return
literal|true
return|;
case|case
name|GL_TEXTURE_COMPARE_MODE
case|:
comment|// Acceptable mode parameters from GLES 3.0.2 spec, table 3.17
switch|switch
condition|(
name|param
condition|)
block|{
case|case
name|GL_NONE
case|:
case|case
name|GL_COMPARE_REF_TO_TEXTURE
case|:
return|return
literal|true
return|;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|GL_TEXTURE_COMPARE_FUNC
case|:
comment|// Acceptable function parameters from GLES 3.0.2 spec, table 3.17
switch|switch
condition|(
name|param
condition|)
block|{
case|case
name|GL_LEQUAL
case|:
case|case
name|GL_GEQUAL
case|:
case|case
name|GL_LESS
case|:
case|case
name|GL_GREATER
case|:
case|case
name|GL_EQUAL
case|:
case|case
name|GL_NOTEQUAL
case|:
case|case
name|GL_ALWAYS
case|:
case|case
name|GL_NEVER
case|:
return|return
literal|true
return|;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|GL_TEXTURE_SWIZZLE_R
case|:
case|case
name|GL_TEXTURE_SWIZZLE_G
case|:
case|case
name|GL_TEXTURE_SWIZZLE_B
case|:
case|case
name|GL_TEXTURE_SWIZZLE_A
case|:
switch|switch
condition|(
name|param
condition|)
block|{
case|case
name|GL_RED
case|:
case|case
name|GL_GREEN
case|:
case|case
name|GL_BLUE
case|:
case|case
name|GL_ALPHA
case|:
case|case
name|GL_ZERO
case|:
case|case
name|GL_ONE
case|:
return|return
literal|true
return|;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|GL_TEXTURE_BASE_LEVEL
case|:
case|case
name|GL_TEXTURE_MAX_LEVEL
case|:
if|if
condition|(
name|param
operator|<
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|ValidateSamplerObjectParameter
name|bool
name|ValidateSamplerObjectParameter
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|pname
parameter_list|)
block|{
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_TEXTURE_MIN_FILTER
case|:
case|case
name|GL_TEXTURE_MAG_FILTER
case|:
case|case
name|GL_TEXTURE_WRAP_S
case|:
case|case
name|GL_TEXTURE_WRAP_T
case|:
case|case
name|GL_TEXTURE_WRAP_R
case|:
case|case
name|GL_TEXTURE_MIN_LOD
case|:
case|case
name|GL_TEXTURE_MAX_LOD
case|:
case|case
name|GL_TEXTURE_COMPARE_MODE
case|:
case|case
name|GL_TEXTURE_COMPARE_FUNC
case|:
return|return
literal|true
return|;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|ValidateReadPixels
name|bool
name|ValidateReadPixels
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLvoid
modifier|*
name|pixels
parameter_list|)
block|{
if|if
condition|(
name|width
operator|<
literal|0
operator|||
name|height
operator|<
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|"width and height must be positive"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getReadFramebuffer
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|framebuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|framebuffer
operator|->
name|checkStatus
argument_list|(
name|context
operator|->
name|getData
argument_list|()
argument_list|)
operator|!=
name|GL_FRAMEBUFFER_COMPLETE
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_FRAMEBUFFER_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getReadFramebuffer
argument_list|()
operator|->
name|id
argument_list|()
operator|!=
literal|0
operator|&&
name|framebuffer
operator|->
name|getSamples
argument_list|(
name|context
operator|->
name|getData
argument_list|()
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|FramebufferAttachment
modifier|*
name|readBuffer
init|=
name|framebuffer
operator|->
name|getReadColorbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|readBuffer
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|GLenum
name|currentFormat
init|=
name|framebuffer
operator|->
name|getImplementationColorReadFormat
argument_list|()
decl_stmt|;
name|GLenum
name|currentType
init|=
name|framebuffer
operator|->
name|getImplementationColorReadType
argument_list|()
decl_stmt|;
name|GLenum
name|currentInternalFormat
init|=
name|readBuffer
operator|->
name|getInternalFormat
argument_list|()
decl_stmt|;
name|GLuint
name|clientVersion
init|=
name|context
operator|->
name|getClientVersion
argument_list|()
decl_stmt|;
name|bool
name|validReadFormat
init|=
operator|(
name|clientVersion
operator|<
literal|3
operator|)
condition|?
name|ValidES2ReadFormatType
argument_list|(
name|context
argument_list|,
name|format
argument_list|,
name|type
argument_list|)
else|:
name|ValidES3ReadFormatType
argument_list|(
name|context
argument_list|,
name|currentInternalFormat
argument_list|,
name|format
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|currentFormat
operator|==
name|format
operator|&&
name|currentType
operator|==
name|type
operator|)
operator|&&
operator|!
name|validReadFormat
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateReadnPixelsEXT
name|bool
name|ValidateReadnPixelsEXT
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLsizei
name|bufSize
parameter_list|,
name|GLvoid
modifier|*
name|pixels
parameter_list|)
block|{
if|if
condition|(
name|bufSize
operator|<
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|"bufSize must be a positive number"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|GLenum
name|sizedInternalFormat
init|=
name|GetSizedInternalFormat
argument_list|(
name|format
argument_list|,
name|type
argument_list|)
decl_stmt|;
specifier|const
name|InternalFormat
modifier|&
name|sizedFormatInfo
init|=
name|GetInternalFormatInfo
argument_list|(
name|sizedInternalFormat
argument_list|)
decl_stmt|;
name|GLsizei
name|outputPitch
init|=
name|sizedFormatInfo
operator|.
name|computeRowPitch
argument_list|(
name|type
argument_list|,
name|width
argument_list|,
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getPackAlignment
argument_list|()
argument_list|,
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getPackRowLength
argument_list|()
argument_list|)
decl_stmt|;
comment|// sized query sanity check
name|int
name|requiredSize
init|=
name|outputPitch
operator|*
name|height
decl_stmt|;
if|if
condition|(
name|requiredSize
operator|>
name|bufSize
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|ValidateReadPixels
argument_list|(
name|context
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|pixels
argument_list|)
return|;
block|}
DECL|function|ValidateGenQueriesBase
name|bool
name|ValidateGenQueriesBase
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLsizei
name|n
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|ids
parameter_list|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|"Query count< 0"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateGenQueriesEXT
name|bool
name|ValidateGenQueriesEXT
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLsizei
name|n
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|ids
parameter_list|)
block|{
if|if
condition|(
operator|!
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|occlusionQueryBoolean
operator|&&
operator|!
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|disjointTimerQuery
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"Query extension not enabled"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|ValidateGenQueriesBase
argument_list|(
name|context
argument_list|,
name|n
argument_list|,
name|ids
argument_list|)
return|;
block|}
DECL|function|ValidateDeleteQueriesBase
name|bool
name|ValidateDeleteQueriesBase
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLsizei
name|n
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|ids
parameter_list|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|"Query count< 0"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateDeleteQueriesEXT
name|bool
name|ValidateDeleteQueriesEXT
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLsizei
name|n
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|ids
parameter_list|)
block|{
if|if
condition|(
operator|!
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|occlusionQueryBoolean
operator|&&
operator|!
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|disjointTimerQuery
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"Query extension not enabled"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|ValidateDeleteQueriesBase
argument_list|(
name|context
argument_list|,
name|n
argument_list|,
name|ids
argument_list|)
return|;
block|}
DECL|function|ValidateBeginQueryBase
name|bool
name|ValidateBeginQueryBase
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLuint
name|id
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ValidQueryType
argument_list|(
name|context
argument_list|,
name|target
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|"Invalid query target"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|id
operator|==
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"Query id is 0"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// From EXT_occlusion_query_boolean: If BeginQueryEXT is called with an<id>
comment|// of zero, if the active query object name for<target> is non-zero (for the
comment|// targets ANY_SAMPLES_PASSED_EXT and ANY_SAMPLES_PASSED_CONSERVATIVE_EXT, if
comment|// the active query for either target is non-zero), if<id> is the name of an
comment|// existing query object whose type does not match<target>, or if<id> is the
comment|// active query object name for any query type, the error INVALID_OPERATION is
comment|// generated.
comment|// Ensure no other queries are active
comment|// NOTE: If other queries than occlusion are supported, we will need to check
comment|// separately that:
comment|//    a) The query ID passed is not the current active query for any target/type
comment|//    b) There are no active queries for the requested target (and in the case
comment|//       of GL_ANY_SAMPLES_PASSED_EXT and GL_ANY_SAMPLES_PASSED_CONSERVATIVE_EXT,
comment|//       no query may be active for either if glBeginQuery targets either.
comment|// TODO(ewell): I think this needs to be changed for timer and occlusion queries to work at the
comment|// same time
if|if
condition|(
name|context
operator|->
name|getState
argument_list|()
operator|.
name|isQueryActive
argument_list|()
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"Other query is active"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|Query
modifier|*
name|queryObject
init|=
name|context
operator|->
name|getQuery
argument_list|(
name|id
argument_list|,
literal|true
argument_list|,
name|target
argument_list|)
decl_stmt|;
comment|// check that name was obtained with glGenQueries
if|if
condition|(
operator|!
name|queryObject
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"Invalid query id"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// check for type mismatch
if|if
condition|(
name|queryObject
operator|->
name|getType
argument_list|()
operator|!=
name|target
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"Query type does not match target"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateBeginQueryEXT
name|bool
name|ValidateBeginQueryEXT
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLuint
name|id
parameter_list|)
block|{
if|if
condition|(
operator|!
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|occlusionQueryBoolean
operator|&&
operator|!
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|disjointTimerQuery
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"Query extension not enabled"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|ValidateBeginQueryBase
argument_list|(
name|context
argument_list|,
name|target
argument_list|,
name|id
argument_list|)
return|;
block|}
DECL|function|ValidateEndQueryBase
name|bool
name|ValidateEndQueryBase
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ValidQueryType
argument_list|(
name|context
argument_list|,
name|target
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|"Invalid query target"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|Query
modifier|*
name|queryObject
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getActiveQuery
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|queryObject
operator|==
literal|nullptr
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"Query target not active"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateEndQueryEXT
name|bool
name|ValidateEndQueryEXT
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|)
block|{
if|if
condition|(
operator|!
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|occlusionQueryBoolean
operator|&&
operator|!
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|disjointTimerQuery
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"Query extension not enabled"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|ValidateEndQueryBase
argument_list|(
name|context
argument_list|,
name|target
argument_list|)
return|;
block|}
DECL|function|ValidateQueryCounterEXT
name|bool
name|ValidateQueryCounterEXT
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLuint
name|id
parameter_list|,
name|GLenum
name|target
parameter_list|)
block|{
if|if
condition|(
operator|!
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|disjointTimerQuery
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"Disjoint timer query not enabled"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|target
operator|!=
name|GL_TIMESTAMP_EXT
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|"Invalid query target"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|Query
modifier|*
name|queryObject
init|=
name|context
operator|->
name|getQuery
argument_list|(
name|id
argument_list|,
literal|true
argument_list|,
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|queryObject
operator|==
literal|nullptr
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"Invalid query id"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|context
operator|->
name|getState
argument_list|()
operator|.
name|isQueryActive
argument_list|(
name|queryObject
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"Query is active"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateGetQueryivBase
name|bool
name|ValidateGetQueryivBase
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLenum
name|pname
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ValidQueryType
argument_list|(
name|context
argument_list|,
name|target
argument_list|)
operator|&&
name|target
operator|!=
name|GL_TIMESTAMP_EXT
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|"Invalid query type"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_CURRENT_QUERY_EXT
case|:
if|if
condition|(
name|target
operator|==
name|GL_TIMESTAMP_EXT
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|"Cannot use current query for timestamp"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|GL_QUERY_COUNTER_BITS_EXT
case|:
if|if
condition|(
operator|!
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|disjointTimerQuery
operator|||
operator|(
name|target
operator|!=
name|GL_TIMESTAMP_EXT
operator|&&
name|target
operator|!=
name|GL_TIME_ELAPSED_EXT
operator|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|"Invalid pname"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|"Invalid pname"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateGetQueryivEXT
name|bool
name|ValidateGetQueryivEXT
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLint
modifier|*
name|params
parameter_list|)
block|{
if|if
condition|(
operator|!
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|occlusionQueryBoolean
operator|&&
operator|!
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|disjointTimerQuery
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"Query extension not enabled"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|ValidateGetQueryivBase
argument_list|(
name|context
argument_list|,
name|target
argument_list|,
name|pname
argument_list|)
return|;
block|}
DECL|function|ValidateGetQueryObjectValueBase
name|bool
name|ValidateGetQueryObjectValueBase
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLuint
name|id
parameter_list|,
name|GLenum
name|pname
parameter_list|)
block|{
name|Query
modifier|*
name|queryObject
init|=
name|context
operator|->
name|getQuery
argument_list|(
name|id
argument_list|,
literal|false
argument_list|,
name|GL_NONE
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|queryObject
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"Query does not exist"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|context
operator|->
name|getState
argument_list|()
operator|.
name|isQueryActive
argument_list|(
name|queryObject
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"Query currently active"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_QUERY_RESULT_EXT
case|:
case|case
name|GL_QUERY_RESULT_AVAILABLE_EXT
case|:
break|break;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|"Invalid pname enum"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateGetQueryObjectivEXT
name|bool
name|ValidateGetQueryObjectivEXT
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLuint
name|id
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLint
modifier|*
name|params
parameter_list|)
block|{
if|if
condition|(
operator|!
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|disjointTimerQuery
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"Timer query extension not enabled"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|ValidateGetQueryObjectValueBase
argument_list|(
name|context
argument_list|,
name|id
argument_list|,
name|pname
argument_list|)
return|;
block|}
DECL|function|ValidateGetQueryObjectuivEXT
name|bool
name|ValidateGetQueryObjectuivEXT
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLuint
name|id
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLuint
modifier|*
name|params
parameter_list|)
block|{
if|if
condition|(
operator|!
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|disjointTimerQuery
operator|&&
operator|!
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|occlusionQueryBoolean
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"Query extension not enabled"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|ValidateGetQueryObjectValueBase
argument_list|(
name|context
argument_list|,
name|id
argument_list|,
name|pname
argument_list|)
return|;
block|}
DECL|function|ValidateGetQueryObjecti64vEXT
name|bool
name|ValidateGetQueryObjecti64vEXT
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLuint
name|id
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLint64
modifier|*
name|params
parameter_list|)
block|{
if|if
condition|(
operator|!
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|disjointTimerQuery
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"Timer query extension not enabled"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|ValidateGetQueryObjectValueBase
argument_list|(
name|context
argument_list|,
name|id
argument_list|,
name|pname
argument_list|)
return|;
block|}
DECL|function|ValidateGetQueryObjectui64vEXT
name|bool
name|ValidateGetQueryObjectui64vEXT
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLuint
name|id
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLuint64
modifier|*
name|params
parameter_list|)
block|{
if|if
condition|(
operator|!
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|disjointTimerQuery
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"Timer query extension not enabled"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|ValidateGetQueryObjectValueBase
argument_list|(
name|context
argument_list|,
name|id
argument_list|,
name|pname
argument_list|)
return|;
block|}
DECL|function|ValidateUniformCommonBase
specifier|static
name|bool
name|ValidateUniformCommonBase
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|targetUniformType
parameter_list|,
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|LinkedUniform
modifier|*
modifier|*
name|uniformOut
parameter_list|)
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|gl
operator|::
name|Program
modifier|*
name|program
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getProgram
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|program
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|location
operator|==
operator|-
literal|1
condition|)
block|{
comment|// Silently ignore the uniform command
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|program
operator|->
name|isValidUniformLocation
argument_list|(
name|location
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|LinkedUniform
modifier|&
name|uniform
init|=
name|program
operator|->
name|getUniformByLocation
argument_list|(
name|location
argument_list|)
decl_stmt|;
comment|// attempting to write an array to a non-array uniform is an INVALID_OPERATION
if|if
condition|(
operator|!
name|uniform
operator|.
name|isArray
argument_list|()
operator|&&
name|count
operator|>
literal|1
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
operator|*
name|uniformOut
operator|=
operator|&
name|uniform
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|ValidateUniform
name|bool
name|ValidateUniform
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|uniformType
parameter_list|,
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|)
block|{
comment|// Check for ES3 uniform entry points
if|if
condition|(
name|VariableComponentType
argument_list|(
name|uniformType
argument_list|)
operator|==
name|GL_UNSIGNED_INT
operator|&&
name|context
operator|->
name|getClientVersion
argument_list|()
operator|<
literal|3
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|LinkedUniform
modifier|*
name|uniform
init|=
literal|nullptr
decl_stmt|;
if|if
condition|(
operator|!
name|ValidateUniformCommonBase
argument_list|(
name|context
argument_list|,
name|uniformType
argument_list|,
name|location
argument_list|,
name|count
argument_list|,
operator|&
name|uniform
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|GLenum
name|targetBoolType
init|=
name|VariableBoolVectorType
argument_list|(
name|uniformType
argument_list|)
decl_stmt|;
name|bool
name|samplerUniformCheck
init|=
operator|(
name|IsSamplerType
argument_list|(
name|uniform
operator|->
name|type
argument_list|)
operator|&&
name|uniformType
operator|==
name|GL_INT
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|samplerUniformCheck
operator|&&
name|uniformType
operator|!=
name|uniform
operator|->
name|type
operator|&&
name|targetBoolType
operator|!=
name|uniform
operator|->
name|type
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateUniformMatrix
name|bool
name|ValidateUniformMatrix
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|matrixType
parameter_list|,
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|)
block|{
comment|// Check for ES3 uniform entry points
name|int
name|rows
init|=
name|VariableRowCount
argument_list|(
name|matrixType
argument_list|)
decl_stmt|;
name|int
name|cols
init|=
name|VariableColumnCount
argument_list|(
name|matrixType
argument_list|)
decl_stmt|;
if|if
condition|(
name|rows
operator|!=
name|cols
operator|&&
name|context
operator|->
name|getClientVersion
argument_list|()
operator|<
literal|3
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|transpose
operator|!=
name|GL_FALSE
operator|&&
name|context
operator|->
name|getClientVersion
argument_list|()
operator|<
literal|3
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|LinkedUniform
modifier|*
name|uniform
init|=
literal|nullptr
decl_stmt|;
if|if
condition|(
operator|!
name|ValidateUniformCommonBase
argument_list|(
name|context
argument_list|,
name|matrixType
argument_list|,
name|location
argument_list|,
name|count
argument_list|,
operator|&
name|uniform
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|uniform
operator|->
name|type
operator|!=
name|matrixType
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateStateQuery
name|bool
name|ValidateStateQuery
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLenum
modifier|*
name|nativeType
parameter_list|,
name|unsigned
name|int
modifier|*
name|numParams
parameter_list|)
block|{
if|if
condition|(
operator|!
name|context
operator|->
name|getQueryParameterInfo
argument_list|(
name|pname
argument_list|,
name|nativeType
argument_list|,
name|numParams
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|Caps
modifier|&
name|caps
init|=
name|context
operator|->
name|getCaps
argument_list|()
decl_stmt|;
if|if
condition|(
name|pname
operator|>=
name|GL_DRAW_BUFFER0
operator|&&
name|pname
operator|<=
name|GL_DRAW_BUFFER15
condition|)
block|{
name|unsigned
name|int
name|colorAttachment
init|=
operator|(
name|pname
operator|-
name|GL_DRAW_BUFFER0
operator|)
decl_stmt|;
if|if
condition|(
name|colorAttachment
operator|>=
name|caps
operator|.
name|maxDrawBuffers
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_TEXTURE_BINDING_2D
case|:
case|case
name|GL_TEXTURE_BINDING_CUBE_MAP
case|:
case|case
name|GL_TEXTURE_BINDING_3D
case|:
case|case
name|GL_TEXTURE_BINDING_2D_ARRAY
case|:
if|if
condition|(
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getActiveSampler
argument_list|()
operator|>=
name|caps
operator|.
name|maxCombinedTextureImageUnits
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|GL_IMPLEMENTATION_COLOR_READ_TYPE
case|:
case|case
name|GL_IMPLEMENTATION_COLOR_READ_FORMAT
case|:
block|{
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getReadFramebuffer
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|framebuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|framebuffer
operator|->
name|checkStatus
argument_list|(
name|context
operator|->
name|getData
argument_list|()
argument_list|)
operator|!=
name|GL_FRAMEBUFFER_COMPLETE
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|FramebufferAttachment
modifier|*
name|attachment
init|=
name|framebuffer
operator|->
name|getReadColorbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|attachment
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
break|break;
default|default:
break|break;
block|}
comment|// pname is valid, but there are no parameters to return
if|if
condition|(
name|numParams
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateCopyTexImageParametersBase
name|bool
name|ValidateCopyTexImageParametersBase
parameter_list|(
name|ValidationContext
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|bool
name|isSubImage
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLint
name|zoffset
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLint
name|border
parameter_list|,
name|GLenum
modifier|*
name|textureFormatOut
parameter_list|)
block|{
if|if
condition|(
name|level
operator|<
literal|0
operator|||
name|xoffset
operator|<
literal|0
operator|||
name|yoffset
operator|<
literal|0
operator|||
name|zoffset
operator|<
literal|0
operator|||
name|width
operator|<
literal|0
operator|||
name|height
operator|<
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|std
operator|::
name|numeric_limits
argument_list|<
name|GLsizei
argument_list|>
operator|::
name|max
argument_list|()
operator|-
name|xoffset
operator|<
name|width
operator|||
name|std
operator|::
name|numeric_limits
argument_list|<
name|GLsizei
argument_list|>
operator|::
name|max
argument_list|()
operator|-
name|yoffset
operator|<
name|height
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|border
operator|!=
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|ValidMipLevel
argument_list|(
name|context
argument_list|,
name|target
argument_list|,
name|level
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getReadFramebuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|framebuffer
operator|->
name|checkStatus
argument_list|(
name|context
operator|->
name|getData
argument_list|()
argument_list|)
operator|!=
name|GL_FRAMEBUFFER_COMPLETE
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_FRAMEBUFFER_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
specifier|auto
modifier|&
name|state
init|=
name|context
operator|->
name|getState
argument_list|()
decl_stmt|;
if|if
condition|(
name|state
operator|.
name|getReadFramebuffer
argument_list|()
operator|->
name|id
argument_list|()
operator|!=
literal|0
operator|&&
name|framebuffer
operator|->
name|getSamples
argument_list|(
name|context
operator|->
name|getData
argument_list|()
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|gl
operator|::
name|Caps
modifier|&
name|caps
init|=
name|context
operator|->
name|getCaps
argument_list|()
decl_stmt|;
name|GLuint
name|maxDimension
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TEXTURE_2D
case|:
name|maxDimension
operator|=
name|caps
operator|.
name|max2DTextureSize
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_X
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Y
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Z
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
case|:
name|maxDimension
operator|=
name|caps
operator|.
name|maxCubeMapTextureSize
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_2D_ARRAY
case|:
name|maxDimension
operator|=
name|caps
operator|.
name|max2DTextureSize
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_3D
case|:
name|maxDimension
operator|=
name|caps
operator|.
name|max3DTextureSize
expr_stmt|;
break|break;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|gl
operator|::
name|Texture
modifier|*
name|texture
init|=
name|state
operator|.
name|getTargetTexture
argument_list|(
name|IsCubeMapTextureTarget
argument_list|(
name|target
argument_list|)
condition|?
name|GL_TEXTURE_CUBE_MAP
else|:
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|texture
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|texture
operator|->
name|getImmutableFormat
argument_list|()
operator|&&
operator|!
name|isSubImage
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|gl
operator|::
name|InternalFormat
modifier|&
name|formatInfo
init|=
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|internalformat
argument_list|)
decl_stmt|;
if|if
condition|(
name|formatInfo
operator|.
name|depthBits
operator|>
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|formatInfo
operator|.
name|compressed
operator|&&
operator|!
name|ValidCompressedImageSize
argument_list|(
name|context
argument_list|,
name|internalformat
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|isSubImage
condition|)
block|{
if|if
condition|(
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|xoffset
operator|+
name|width
argument_list|)
operator|>
name|texture
operator|->
name|getWidth
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
operator|||
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|yoffset
operator|+
name|height
argument_list|)
operator|>
name|texture
operator|->
name|getHeight
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
operator|||
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|zoffset
argument_list|)
operator|>=
name|texture
operator|->
name|getDepth
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|IsCubeMapTextureTarget
argument_list|(
name|target
argument_list|)
operator|&&
name|width
operator|!=
name|height
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|formatInfo
operator|.
name|textureSupport
argument_list|(
name|context
operator|->
name|getClientVersion
argument_list|()
argument_list|,
name|context
operator|->
name|getExtensions
argument_list|()
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|int
name|maxLevelDimension
init|=
operator|(
name|maxDimension
operator|>>
name|level
operator|)
decl_stmt|;
if|if
condition|(
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|width
argument_list|)
operator|>
name|maxLevelDimension
operator|||
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|height
argument_list|)
operator|>
name|maxLevelDimension
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
operator|*
name|textureFormatOut
operator|=
name|texture
operator|->
name|getInternalFormat
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|ValidateDrawBase
specifier|static
name|bool
name|ValidateDrawBase
parameter_list|(
name|ValidationContext
modifier|*
name|context
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLsizei
name|primcount
parameter_list|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|GL_POINTS
case|:
case|case
name|GL_LINES
case|:
case|case
name|GL_LINE_LOOP
case|:
case|case
name|GL_LINE_STRIP
case|:
case|case
name|GL_TRIANGLES
case|:
case|case
name|GL_TRIANGLE_STRIP
case|:
case|case
name|GL_TRIANGLE_FAN
case|:
break|break;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|State
modifier|&
name|state
init|=
name|context
operator|->
name|getState
argument_list|()
decl_stmt|;
comment|// Check for mapped buffers
if|if
condition|(
name|state
operator|.
name|hasMappedBuffer
argument_list|(
name|GL_ARRAY_BUFFER
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|context
operator|->
name|getLimitations
argument_list|()
operator|.
name|noSeparateStencilRefsAndMasks
condition|)
block|{
specifier|const
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
specifier|const
name|FramebufferAttachment
modifier|*
name|stencilBuffer
init|=
name|framebuffer
operator|->
name|getStencilbuffer
argument_list|()
decl_stmt|;
name|GLuint
name|stencilBits
init|=
name|stencilBuffer
condition|?
name|stencilBuffer
operator|->
name|getStencilSize
argument_list|()
else|:
literal|0
decl_stmt|;
name|GLuint
name|minimumRequiredStencilMask
init|=
operator|(
literal|1
operator|<<
name|stencilBits
operator|)
operator|-
literal|1
decl_stmt|;
specifier|const
name|DepthStencilState
modifier|&
name|depthStencilState
init|=
name|state
operator|.
name|getDepthStencilState
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|depthStencilState
operator|.
name|stencilWritemask
operator|&
name|minimumRequiredStencilMask
operator|)
operator|!=
operator|(
name|depthStencilState
operator|.
name|stencilBackWritemask
operator|&
name|minimumRequiredStencilMask
operator|)
operator|||
name|state
operator|.
name|getStencilRef
argument_list|()
operator|!=
name|state
operator|.
name|getStencilBackRef
argument_list|()
operator|||
operator|(
name|depthStencilState
operator|.
name|stencilMask
operator|&
name|minimumRequiredStencilMask
operator|)
operator|!=
operator|(
name|depthStencilState
operator|.
name|stencilBackMask
operator|&
name|minimumRequiredStencilMask
operator|)
condition|)
block|{
comment|// Note: these separate values are not supported in WebGL, due to D3D's limitations. See
comment|// Section 6.10 of the WebGL 1.0 spec
name|ERR
argument_list|(
literal|"This ANGLE implementation does not support separate front/back stencil "
literal|"writemasks, reference values, or stencil mask values."
argument_list|)
expr_stmt|;
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|fbo
init|=
name|state
operator|.
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|fbo
operator|||
name|fbo
operator|->
name|checkStatus
argument_list|(
name|context
operator|->
name|getData
argument_list|()
argument_list|)
operator|!=
name|GL_FRAMEBUFFER_COMPLETE
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_FRAMEBUFFER_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|gl
operator|::
name|Program
modifier|*
name|program
init|=
name|state
operator|.
name|getProgram
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|program
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|program
operator|->
name|validateSamplers
argument_list|(
name|NULL
argument_list|,
name|context
operator|->
name|getCaps
argument_list|()
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Uniform buffer validation
for|for
control|(
name|unsigned
name|int
name|uniformBlockIndex
init|=
literal|0
init|;
name|uniformBlockIndex
operator|<
name|program
operator|->
name|getActiveUniformBlockCount
argument_list|()
condition|;
name|uniformBlockIndex
operator|++
control|)
block|{
specifier|const
name|gl
operator|::
name|UniformBlock
modifier|&
name|uniformBlock
init|=
name|program
operator|->
name|getUniformBlockByIndex
argument_list|(
name|uniformBlockIndex
argument_list|)
decl_stmt|;
name|GLuint
name|blockBinding
init|=
name|program
operator|->
name|getUniformBlockBinding
argument_list|(
name|uniformBlockIndex
argument_list|)
decl_stmt|;
specifier|const
name|OffsetBindingPointer
argument_list|<
name|Buffer
argument_list|>
modifier|&
name|uniformBuffer
init|=
name|state
operator|.
name|getIndexedUniformBuffer
argument_list|(
name|blockBinding
argument_list|)
decl_stmt|;
if|if
condition|(
name|uniformBuffer
operator|.
name|get
argument_list|()
operator|==
literal|nullptr
condition|)
block|{
comment|// undefined behaviour
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"It is undefined behaviour to have a used but unbound uniform buffer."
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|size_t
name|uniformBufferSize
init|=
name|uniformBuffer
operator|.
name|getSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|uniformBufferSize
operator|==
literal|0
condition|)
block|{
comment|// Bind the whole buffer.
name|uniformBufferSize
operator|=
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|uniformBuffer
operator|->
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uniformBufferSize
operator|<
name|uniformBlock
operator|.
name|dataSize
condition|)
block|{
comment|// undefined behaviour
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"It is undefined behaviour to use a uniform buffer that is too small."
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|// No-op if zero count
return|return
operator|(
name|count
operator|>
literal|0
operator|)
return|;
block|}
DECL|function|ValidateDrawArrays
name|bool
name|ValidateDrawArrays
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLint
name|first
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLsizei
name|primcount
parameter_list|)
block|{
if|if
condition|(
name|first
operator|<
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|State
modifier|&
name|state
init|=
name|context
operator|->
name|getState
argument_list|()
decl_stmt|;
name|gl
operator|::
name|TransformFeedback
modifier|*
name|curTransformFeedback
init|=
name|state
operator|.
name|getCurrentTransformFeedback
argument_list|()
decl_stmt|;
if|if
condition|(
name|curTransformFeedback
operator|&&
name|curTransformFeedback
operator|->
name|isActive
argument_list|()
operator|&&
operator|!
name|curTransformFeedback
operator|->
name|isPaused
argument_list|()
operator|&&
name|curTransformFeedback
operator|->
name|getPrimitiveMode
argument_list|()
operator|!=
name|mode
condition|)
block|{
comment|// It is an invalid operation to call DrawArrays or DrawArraysInstanced with a draw mode
comment|// that does not match the current transform feedback object's draw mode (if transform feedback
comment|// is active), (3.0.2, section 2.14, pg 86)
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|ValidateDrawBase
argument_list|(
name|context
argument_list|,
name|mode
argument_list|,
name|count
argument_list|,
name|primcount
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|ValidateDrawAttribs
argument_list|(
name|context
argument_list|,
name|primcount
argument_list|,
name|count
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateDrawArraysInstanced
name|bool
name|ValidateDrawArraysInstanced
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLint
name|first
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLsizei
name|primcount
parameter_list|)
block|{
if|if
condition|(
name|primcount
operator|<
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|ValidateDrawArrays
argument_list|(
name|context
argument_list|,
name|mode
argument_list|,
name|first
argument_list|,
name|count
argument_list|,
name|primcount
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// No-op if zero primitive count
return|return
operator|(
name|primcount
operator|>
literal|0
operator|)
return|;
block|}
DECL|function|ValidateDrawInstancedANGLE
specifier|static
name|bool
name|ValidateDrawInstancedANGLE
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|)
block|{
comment|// Verify there is at least one active attribute with a divisor of zero
specifier|const
name|gl
operator|::
name|State
modifier|&
name|state
init|=
name|context
operator|->
name|getState
argument_list|()
decl_stmt|;
name|gl
operator|::
name|Program
modifier|*
name|program
init|=
name|state
operator|.
name|getProgram
argument_list|()
decl_stmt|;
specifier|const
name|VertexArray
modifier|*
name|vao
init|=
name|state
operator|.
name|getVertexArray
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|attributeIndex
init|=
literal|0
init|;
name|attributeIndex
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|attributeIndex
operator|++
control|)
block|{
specifier|const
name|VertexAttribute
modifier|&
name|attrib
init|=
name|vao
operator|->
name|getVertexAttribute
argument_list|(
name|attributeIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|program
operator|->
name|isAttribLocationActive
argument_list|(
name|attributeIndex
argument_list|)
operator|&&
name|attrib
operator|.
name|divisor
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"ANGLE_instanced_arrays requires that at least one active attribute"
literal|"has a divisor of zero."
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
DECL|function|ValidateDrawArraysInstancedANGLE
name|bool
name|ValidateDrawArraysInstancedANGLE
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLint
name|first
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLsizei
name|primcount
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ValidateDrawInstancedANGLE
argument_list|(
name|context
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|ValidateDrawArraysInstanced
argument_list|(
name|context
argument_list|,
name|mode
argument_list|,
name|first
argument_list|,
name|count
argument_list|,
name|primcount
argument_list|)
return|;
block|}
DECL|function|ValidateDrawElements
name|bool
name|ValidateDrawElements
parameter_list|(
name|ValidationContext
modifier|*
name|context
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|GLsizei
name|primcount
parameter_list|,
name|IndexRange
modifier|*
name|indexRangeOut
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_UNSIGNED_BYTE
case|:
case|case
name|GL_UNSIGNED_SHORT
case|:
break|break;
case|case
name|GL_UNSIGNED_INT
case|:
if|if
condition|(
name|context
operator|->
name|getClientVersion
argument_list|()
operator|<
literal|3
operator|&&
operator|!
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|elementIndexUint
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|State
modifier|&
name|state
init|=
name|context
operator|->
name|getState
argument_list|()
decl_stmt|;
name|gl
operator|::
name|TransformFeedback
modifier|*
name|curTransformFeedback
init|=
name|state
operator|.
name|getCurrentTransformFeedback
argument_list|()
decl_stmt|;
if|if
condition|(
name|curTransformFeedback
operator|&&
name|curTransformFeedback
operator|->
name|isActive
argument_list|()
operator|&&
operator|!
name|curTransformFeedback
operator|->
name|isPaused
argument_list|()
condition|)
block|{
comment|// It is an invalid operation to call DrawElements, DrawRangeElements or DrawElementsInstanced
comment|// while transform feedback is active, (3.0.2, section 2.14, pg 86)
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Check for mapped buffers
if|if
condition|(
name|state
operator|.
name|hasMappedBuffer
argument_list|(
name|GL_ELEMENT_ARRAY_BUFFER
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|gl
operator|::
name|VertexArray
modifier|*
name|vao
init|=
name|state
operator|.
name|getVertexArray
argument_list|()
decl_stmt|;
name|gl
operator|::
name|Buffer
modifier|*
name|elementArrayBuffer
init|=
name|vao
operator|->
name|getElementArrayBuffer
argument_list|()
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|indices
operator|&&
operator|!
name|elementArrayBuffer
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|elementArrayBuffer
condition|)
block|{
specifier|const
name|gl
operator|::
name|Type
modifier|&
name|typeInfo
init|=
name|gl
operator|::
name|GetTypeInfo
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|GLint64
name|offset
init|=
cast|reinterpret_cast
argument_list|<
name|GLint64
argument_list|>
argument_list|(
name|indices
argument_list|)
decl_stmt|;
name|GLint64
name|byteCount
init|=
cast|static_cast
argument_list|<
name|GLint64
argument_list|>
argument_list|(
name|typeInfo
operator|.
name|bytes
argument_list|)
operator|*
cast|static_cast
argument_list|<
name|GLint64
argument_list|>
argument_list|(
name|count
argument_list|)
operator|+
name|offset
decl_stmt|;
comment|// check for integer overflows
if|if
condition|(
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|count
argument_list|)
operator|>
operator|(
name|std
operator|::
name|numeric_limits
argument_list|<
name|GLuint
argument_list|>
operator|::
name|max
argument_list|()
operator|/
name|typeInfo
operator|.
name|bytes
operator|)
operator|||
name|byteCount
operator|>
cast|static_cast
argument_list|<
name|GLint64
argument_list|>
argument_list|(
name|std
operator|::
name|numeric_limits
argument_list|<
name|GLuint
argument_list|>
operator|::
name|max
argument_list|()
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Check for reading past the end of the bound buffer object
if|if
condition|(
name|byteCount
operator|>
name|elementArrayBuffer
operator|->
name|getSize
argument_list|()
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|indices
condition|)
block|{
comment|// Catch this programming error here
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|ValidateDrawBase
argument_list|(
name|context
argument_list|,
name|mode
argument_list|,
name|count
argument_list|,
name|primcount
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Use max index to validate if our vertex buffers are large enough for the pull.
comment|// TODO: offer fast path, with disabled index validation.
comment|// TODO: also disable index checking on back-ends that are robust to out-of-range accesses.
if|if
condition|(
name|elementArrayBuffer
condition|)
block|{
name|uintptr_t
name|offset
init|=
cast|reinterpret_cast
argument_list|<
name|uintptr_t
argument_list|>
argument_list|(
name|indices
argument_list|)
decl_stmt|;
name|Error
name|error
init|=
name|elementArrayBuffer
operator|->
name|getIndexRange
argument_list|(
name|type
argument_list|,
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|offset
argument_list|)
argument_list|,
name|count
argument_list|,
name|state
operator|.
name|isPrimitiveRestartEnabled
argument_list|()
argument_list|,
name|indexRangeOut
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|error
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
operator|*
name|indexRangeOut
operator|=
name|ComputeIndexRange
argument_list|(
name|type
argument_list|,
name|indices
argument_list|,
name|count
argument_list|,
name|state
operator|.
name|isPrimitiveRestartEnabled
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// If we use an index greater than our maximum supported index range, return an error.
comment|// The ES3 spec does not specify behaviour here, it is undefined, but ANGLE should always
comment|// return an error if possible here.
if|if
condition|(
cast|static_cast
argument_list|<
name|GLuint64
argument_list|>
argument_list|(
name|indexRangeOut
operator|->
name|end
argument_list|)
operator|>=
name|context
operator|->
name|getCaps
argument_list|()
operator|.
name|maxElementIndex
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
name|g_ExceedsMaxElementErrorMessage
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|ValidateDrawAttribs
argument_list|(
name|context
argument_list|,
name|primcount
argument_list|,
cast|static_cast
argument_list|<
name|GLsizei
argument_list|>
argument_list|(
name|indexRangeOut
operator|->
name|end
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// No op if there are no real indices in the index data (all are primitive restart).
return|return
operator|(
name|indexRangeOut
operator|->
name|vertexIndexCount
operator|>
literal|0
operator|)
return|;
block|}
DECL|function|ValidateDrawElementsInstanced
name|bool
name|ValidateDrawElementsInstanced
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|GLsizei
name|primcount
parameter_list|,
name|IndexRange
modifier|*
name|indexRangeOut
parameter_list|)
block|{
if|if
condition|(
name|primcount
operator|<
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|ValidateDrawElements
argument_list|(
name|context
argument_list|,
name|mode
argument_list|,
name|count
argument_list|,
name|type
argument_list|,
name|indices
argument_list|,
name|primcount
argument_list|,
name|indexRangeOut
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// No-op zero primitive count
return|return
operator|(
name|primcount
operator|>
literal|0
operator|)
return|;
block|}
DECL|function|ValidateDrawElementsInstancedANGLE
name|bool
name|ValidateDrawElementsInstancedANGLE
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|GLsizei
name|primcount
parameter_list|,
name|IndexRange
modifier|*
name|indexRangeOut
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ValidateDrawInstancedANGLE
argument_list|(
name|context
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|ValidateDrawElementsInstanced
argument_list|(
name|context
argument_list|,
name|mode
argument_list|,
name|count
argument_list|,
name|type
argument_list|,
name|indices
argument_list|,
name|primcount
argument_list|,
name|indexRangeOut
argument_list|)
return|;
block|}
DECL|function|ValidateFramebufferTextureBase
name|bool
name|ValidateFramebufferTextureBase
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLenum
name|attachment
parameter_list|,
name|GLuint
name|texture
parameter_list|,
name|GLint
name|level
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ValidFramebufferTarget
argument_list|(
name|target
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|ValidateAttachmentTarget
argument_list|(
name|context
argument_list|,
name|attachment
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|texture
operator|!=
literal|0
condition|)
block|{
name|gl
operator|::
name|Texture
modifier|*
name|tex
init|=
name|context
operator|->
name|getTexture
argument_list|(
name|texture
argument_list|)
decl_stmt|;
if|if
condition|(
name|tex
operator|==
name|NULL
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|level
operator|<
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getTargetFramebuffer
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|framebuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|framebuffer
operator|->
name|id
argument_list|()
operator|==
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"Cannot change default FBO's attachments"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateFramebufferTexture2D
name|bool
name|ValidateFramebufferTexture2D
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLenum
name|attachment
parameter_list|,
name|GLenum
name|textarget
parameter_list|,
name|GLuint
name|texture
parameter_list|,
name|GLint
name|level
parameter_list|)
block|{
comment|// Attachments are required to be bound to level 0 without ES3 or the GL_OES_fbo_render_mipmap extension
if|if
condition|(
name|context
operator|->
name|getClientVersion
argument_list|()
operator|<
literal|3
operator|&&
operator|!
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|fboRenderMipmap
operator|&&
name|level
operator|!=
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|ValidateFramebufferTextureBase
argument_list|(
name|context
argument_list|,
name|target
argument_list|,
name|attachment
argument_list|,
name|texture
argument_list|,
name|level
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|texture
operator|!=
literal|0
condition|)
block|{
name|gl
operator|::
name|Texture
modifier|*
name|tex
init|=
name|context
operator|->
name|getTexture
argument_list|(
name|texture
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|tex
argument_list|)
expr_stmt|;
specifier|const
name|gl
operator|::
name|Caps
modifier|&
name|caps
init|=
name|context
operator|->
name|getCaps
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|textarget
condition|)
block|{
case|case
name|GL_TEXTURE_2D
case|:
block|{
if|if
condition|(
name|level
operator|>
name|gl
operator|::
name|log2
argument_list|(
name|caps
operator|.
name|max2DTextureSize
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|tex
operator|->
name|getTarget
argument_list|()
operator|!=
name|GL_TEXTURE_2D
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
break|break;
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_X
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Y
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Z
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
case|:
block|{
if|if
condition|(
name|level
operator|>
name|gl
operator|::
name|log2
argument_list|(
name|caps
operator|.
name|maxCubeMapTextureSize
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|tex
operator|->
name|getTarget
argument_list|()
operator|!=
name|GL_TEXTURE_CUBE_MAP
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
break|break;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|gl
operator|::
name|InternalFormat
modifier|&
name|internalFormatInfo
init|=
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|tex
operator|->
name|getInternalFormat
argument_list|(
name|textarget
argument_list|,
name|level
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|internalFormatInfo
operator|.
name|compressed
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateGetUniformBase
name|bool
name|ValidateGetUniformBase
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLuint
name|program
parameter_list|,
name|GLint
name|location
parameter_list|)
block|{
if|if
condition|(
name|program
operator|==
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|gl
operator|::
name|Program
modifier|*
name|programObject
init|=
name|GetValidProgram
argument_list|(
name|context
argument_list|,
name|program
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|programObject
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|programObject
operator|||
operator|!
name|programObject
operator|->
name|isLinked
argument_list|()
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|programObject
operator|->
name|isValidUniformLocation
argument_list|(
name|location
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateGetUniformfv
name|bool
name|ValidateGetUniformfv
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLuint
name|program
parameter_list|,
name|GLint
name|location
parameter_list|,
name|GLfloat
modifier|*
name|params
parameter_list|)
block|{
return|return
name|ValidateGetUniformBase
argument_list|(
name|context
argument_list|,
name|program
argument_list|,
name|location
argument_list|)
return|;
block|}
DECL|function|ValidateGetUniformiv
name|bool
name|ValidateGetUniformiv
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLuint
name|program
parameter_list|,
name|GLint
name|location
parameter_list|,
name|GLint
modifier|*
name|params
parameter_list|)
block|{
return|return
name|ValidateGetUniformBase
argument_list|(
name|context
argument_list|,
name|program
argument_list|,
name|location
argument_list|)
return|;
block|}
DECL|function|ValidateSizedGetUniform
specifier|static
name|bool
name|ValidateSizedGetUniform
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLuint
name|program
parameter_list|,
name|GLint
name|location
parameter_list|,
name|GLsizei
name|bufSize
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ValidateGetUniformBase
argument_list|(
name|context
argument_list|,
name|program
argument_list|,
name|location
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|gl
operator|::
name|Program
modifier|*
name|programObject
init|=
name|context
operator|->
name|getProgram
argument_list|(
name|program
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|programObject
argument_list|)
expr_stmt|;
comment|// sized queries -- ensure the provided buffer is large enough
specifier|const
name|LinkedUniform
modifier|&
name|uniform
init|=
name|programObject
operator|->
name|getUniformByLocation
argument_list|(
name|location
argument_list|)
decl_stmt|;
name|size_t
name|requiredBytes
init|=
name|VariableExternalSize
argument_list|(
name|uniform
operator|.
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|bufSize
argument_list|)
operator|<
name|requiredBytes
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateGetnUniformfvEXT
name|bool
name|ValidateGetnUniformfvEXT
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLuint
name|program
parameter_list|,
name|GLint
name|location
parameter_list|,
name|GLsizei
name|bufSize
parameter_list|,
name|GLfloat
modifier|*
name|params
parameter_list|)
block|{
return|return
name|ValidateSizedGetUniform
argument_list|(
name|context
argument_list|,
name|program
argument_list|,
name|location
argument_list|,
name|bufSize
argument_list|)
return|;
block|}
DECL|function|ValidateGetnUniformivEXT
name|bool
name|ValidateGetnUniformivEXT
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLuint
name|program
parameter_list|,
name|GLint
name|location
parameter_list|,
name|GLsizei
name|bufSize
parameter_list|,
name|GLint
modifier|*
name|params
parameter_list|)
block|{
return|return
name|ValidateSizedGetUniform
argument_list|(
name|context
argument_list|,
name|program
argument_list|,
name|location
argument_list|,
name|bufSize
argument_list|)
return|;
block|}
DECL|function|ValidateDiscardFramebufferBase
name|bool
name|ValidateDiscardFramebufferBase
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLsizei
name|numAttachments
parameter_list|,
specifier|const
name|GLenum
modifier|*
name|attachments
parameter_list|,
name|bool
name|defaultFramebuffer
parameter_list|)
block|{
if|if
condition|(
name|numAttachments
operator|<
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|"numAttachments must not be less than zero"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
for|for
control|(
name|GLsizei
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numAttachments
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|attachments
index|[
name|i
index|]
operator|>=
name|GL_COLOR_ATTACHMENT0
operator|&&
name|attachments
index|[
name|i
index|]
operator|<=
name|GL_COLOR_ATTACHMENT15
condition|)
block|{
if|if
condition|(
name|defaultFramebuffer
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|"Invalid attachment when the default framebuffer is bound"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|attachments
index|[
name|i
index|]
operator|>=
name|GL_COLOR_ATTACHMENT0
operator|+
name|context
operator|->
name|getCaps
argument_list|()
operator|.
name|maxColorAttachments
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"Requested color attachment is greater than the maximum supported color attachments"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|attachments
index|[
name|i
index|]
condition|)
block|{
case|case
name|GL_DEPTH_ATTACHMENT
case|:
case|case
name|GL_STENCIL_ATTACHMENT
case|:
case|case
name|GL_DEPTH_STENCIL_ATTACHMENT
case|:
if|if
condition|(
name|defaultFramebuffer
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|"Invalid attachment when the default framebuffer is bound"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|GL_COLOR
case|:
case|case
name|GL_DEPTH
case|:
case|case
name|GL_STENCIL
case|:
if|if
condition|(
operator|!
name|defaultFramebuffer
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|"Invalid attachment when the default framebuffer is not bound"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|"Invalid attachment"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateInsertEventMarkerEXT
name|bool
name|ValidateInsertEventMarkerEXT
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLsizei
name|length
parameter_list|,
specifier|const
name|char
modifier|*
name|marker
parameter_list|)
block|{
comment|// Note that debug marker calls must not set error state
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|marker
operator|==
literal|nullptr
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidatePushGroupMarkerEXT
name|bool
name|ValidatePushGroupMarkerEXT
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLsizei
name|length
parameter_list|,
specifier|const
name|char
modifier|*
name|marker
parameter_list|)
block|{
comment|// Note that debug marker calls must not set error state
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|length
operator|>
literal|0
operator|&&
name|marker
operator|==
literal|nullptr
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateEGLImageTargetTexture2DOES
name|bool
name|ValidateEGLImageTargetTexture2DOES
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|egl
operator|::
name|Display
modifier|*
name|display
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|egl
operator|::
name|Image
modifier|*
name|image
parameter_list|)
block|{
if|if
condition|(
operator|!
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|eglImage
operator|&&
operator|!
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|eglImageExternal
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TEXTURE_2D
case|:
break|break;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|"invalid texture target."
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|display
operator|->
name|isValidImage
argument_list|(
name|image
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|"EGL image is not valid."
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|image
operator|->
name|getSamples
argument_list|()
operator|>
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"cannot create a 2D texture from a multisampled EGL image."
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|TextureCaps
modifier|&
name|textureCaps
init|=
name|context
operator|->
name|getTextureCaps
argument_list|()
operator|.
name|get
argument_list|(
name|image
operator|->
name|getInternalFormat
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|textureCaps
operator|.
name|texturable
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"EGL image internal format is not supported as a texture."
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateEGLImageTargetRenderbufferStorageOES
name|bool
name|ValidateEGLImageTargetRenderbufferStorageOES
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|egl
operator|::
name|Display
modifier|*
name|display
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|egl
operator|::
name|Image
modifier|*
name|image
parameter_list|)
block|{
if|if
condition|(
operator|!
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|eglImage
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_RENDERBUFFER
case|:
break|break;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|"invalid renderbuffer target."
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|display
operator|->
name|isValidImage
argument_list|(
name|image
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|"EGL image is not valid."
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|TextureCaps
modifier|&
name|textureCaps
init|=
name|context
operator|->
name|getTextureCaps
argument_list|()
operator|.
name|get
argument_list|(
name|image
operator|->
name|getInternalFormat
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|textureCaps
operator|.
name|renderable
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"EGL image internal format is not supported as a renderbuffer."
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateBindVertexArrayBase
name|bool
name|ValidateBindVertexArrayBase
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLuint
name|array
parameter_list|)
block|{
if|if
condition|(
operator|!
name|context
operator|->
name|isVertexArrayGenerated
argument_list|(
name|array
argument_list|)
condition|)
block|{
comment|// The default VAO should always exist
name|ASSERT
argument_list|(
name|array
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateDeleteVertexArraysBase
name|bool
name|ValidateDeleteVertexArraysBase
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLsizei
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateGenVertexArraysBase
name|bool
name|ValidateGenVertexArraysBase
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLsizei
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateProgramBinaryBase
name|bool
name|ValidateProgramBinaryBase
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLuint
name|program
parameter_list|,
name|GLenum
name|binaryFormat
parameter_list|,
specifier|const
name|void
modifier|*
name|binary
parameter_list|,
name|GLint
name|length
parameter_list|)
block|{
name|Program
modifier|*
name|programObject
init|=
name|GetValidProgram
argument_list|(
name|context
argument_list|,
name|program
argument_list|)
decl_stmt|;
if|if
condition|(
name|programObject
operator|==
literal|nullptr
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|const
name|std
operator|::
name|vector
argument_list|<
name|GLenum
argument_list|>
modifier|&
name|programBinaryFormats
init|=
name|context
operator|->
name|getCaps
argument_list|()
operator|.
name|programBinaryFormats
decl_stmt|;
if|if
condition|(
name|std
operator|::
name|find
argument_list|(
name|programBinaryFormats
operator|.
name|begin
argument_list|()
argument_list|,
name|programBinaryFormats
operator|.
name|end
argument_list|()
argument_list|,
name|binaryFormat
argument_list|)
operator|==
name|programBinaryFormats
operator|.
name|end
argument_list|()
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|"Program binary format is not valid."
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateGetProgramBinaryBase
name|bool
name|ValidateGetProgramBinaryBase
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLuint
name|program
parameter_list|,
name|GLsizei
name|bufSize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|,
name|GLenum
modifier|*
name|binaryFormat
parameter_list|,
name|void
modifier|*
name|binary
parameter_list|)
block|{
name|Program
modifier|*
name|programObject
init|=
name|GetValidProgram
argument_list|(
name|context
argument_list|,
name|program
argument_list|)
decl_stmt|;
if|if
condition|(
name|programObject
operator|==
literal|nullptr
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|programObject
operator|->
name|isLinked
argument_list|()
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"Program is not linked."
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateCopyTexImage2D
name|bool
name|ValidateCopyTexImage2D
parameter_list|(
name|ValidationContext
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLint
name|border
parameter_list|)
block|{
if|if
condition|(
name|context
operator|->
name|getClientVersion
argument_list|()
operator|<
literal|3
condition|)
block|{
return|return
name|ValidateES2CopyTexImageParameters
argument_list|(
name|context
argument_list|,
name|target
argument_list|,
name|level
argument_list|,
name|internalformat
argument_list|,
literal|false
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|border
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|context
operator|->
name|getClientVersion
argument_list|()
operator|==
literal|3
argument_list|)
expr_stmt|;
return|return
name|ValidateES3CopyTexImage2DParameters
argument_list|(
name|context
argument_list|,
name|target
argument_list|,
name|level
argument_list|,
name|internalformat
argument_list|,
literal|false
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|border
argument_list|)
return|;
block|}
DECL|function|ValidateFramebufferRenderbuffer
name|bool
name|ValidateFramebufferRenderbuffer
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLenum
name|attachment
parameter_list|,
name|GLenum
name|renderbuffertarget
parameter_list|,
name|GLuint
name|renderbuffer
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ValidFramebufferTarget
argument_list|(
name|target
argument_list|)
operator|||
operator|(
name|renderbuffertarget
operator|!=
name|GL_RENDERBUFFER
operator|&&
name|renderbuffer
operator|!=
literal|0
operator|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|ValidateFramebufferRenderbufferParameters
argument_list|(
name|context
argument_list|,
name|target
argument_list|,
name|attachment
argument_list|,
name|renderbuffertarget
argument_list|,
name|renderbuffer
argument_list|)
return|;
block|}
DECL|function|ValidateDrawBuffersBase
name|bool
name|ValidateDrawBuffersBase
parameter_list|(
name|ValidationContext
modifier|*
name|context
parameter_list|,
name|GLsizei
name|n
parameter_list|,
specifier|const
name|GLenum
modifier|*
name|bufs
parameter_list|)
block|{
comment|// INVALID_VALUE is generated if n is negative or greater than value of MAX_DRAW_BUFFERS
if|if
condition|(
name|n
operator|<
literal|0
operator|||
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|n
argument_list|)
operator|>
name|context
operator|->
name|getCaps
argument_list|()
operator|.
name|maxDrawBuffers
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|"n must be non-negative and no greater than MAX_DRAW_BUFFERS"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|ASSERT
argument_list|(
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getDrawFramebuffer
argument_list|()
argument_list|)
expr_stmt|;
name|GLuint
name|frameBufferId
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getDrawFramebuffer
argument_list|()
operator|->
name|id
argument_list|()
decl_stmt|;
name|GLuint
name|maxColorAttachment
init|=
name|GL_COLOR_ATTACHMENT0_EXT
operator|+
name|context
operator|->
name|getCaps
argument_list|()
operator|.
name|maxColorAttachments
decl_stmt|;
comment|// This should come first before the check for the default frame buffer
comment|// because when we switch to ES3.1+, invalid enums will return INVALID_ENUM
comment|// rather than INVALID_OPERATION
for|for
control|(
name|int
name|colorAttachment
init|=
literal|0
init|;
name|colorAttachment
operator|<
name|n
condition|;
name|colorAttachment
operator|++
control|)
block|{
specifier|const
name|GLenum
name|attachment
init|=
name|GL_COLOR_ATTACHMENT0_EXT
operator|+
name|colorAttachment
decl_stmt|;
if|if
condition|(
name|bufs
index|[
name|colorAttachment
index|]
operator|!=
name|GL_NONE
operator|&&
name|bufs
index|[
name|colorAttachment
index|]
operator|!=
name|GL_BACK
operator|&&
operator|(
name|bufs
index|[
name|colorAttachment
index|]
operator|<
name|GL_COLOR_ATTACHMENT0_EXT
operator|||
name|bufs
index|[
name|colorAttachment
index|]
operator|>=
name|maxColorAttachment
operator|)
condition|)
block|{
comment|// Value in bufs is not NONE, BACK, or GL_COLOR_ATTACHMENTi
comment|// In the 3.0 specs, the error should return GL_INVALID_OPERATION.
comment|// When we move to 3.1 specs, we should change the error to be GL_INVALID_ENUM
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"Invalid buffer value"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|bufs
index|[
name|colorAttachment
index|]
operator|!=
name|GL_NONE
operator|&&
name|bufs
index|[
name|colorAttachment
index|]
operator|!=
name|attachment
operator|&&
name|frameBufferId
operator|!=
literal|0
condition|)
block|{
comment|// INVALID_OPERATION-GL is bound to buffer and ith argument
comment|// is not COLOR_ATTACHMENTi or NONE
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"Ith value does not match COLOR_ATTACHMENTi or NONE"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|// INVALID_OPERATION is generated if GL is bound to the default framebuffer
comment|// and n is not 1 or bufs is bound to value other than BACK and NONE
if|if
condition|(
name|frameBufferId
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|!=
literal|1
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"n must be 1 when GL is bound to the default framebuffer"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|bufs
index|[
literal|0
index|]
operator|!=
name|GL_NONE
operator|&&
name|bufs
index|[
literal|0
index|]
operator|!=
name|GL_BACK
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"Only NONE or BACK are valid values when drawing to the default framebuffer"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateCopyTexSubImage2D
name|bool
name|ValidateCopyTexSubImage2D
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
if|if
condition|(
name|context
operator|->
name|getClientVersion
argument_list|()
operator|<
literal|3
condition|)
block|{
return|return
name|ValidateES2CopyTexImageParameters
argument_list|(
name|context
argument_list|,
name|target
argument_list|,
name|level
argument_list|,
name|GL_NONE
argument_list|,
literal|true
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
name|ValidateES3CopyTexImage2DParameters
argument_list|(
name|context
argument_list|,
name|target
argument_list|,
name|level
argument_list|,
name|GL_NONE
argument_list|,
literal|true
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
literal|0
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
end_namespace
begin_comment
comment|// namespace gl
end_comment
end_unit
