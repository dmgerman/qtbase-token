begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2013-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// validationES.h: Validation functions for generic OpenGL ES entry point parameters
end_comment
begin_include
include|#
directive|include
file|"libANGLE/validationES.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/validationES2.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/validationES3.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Context.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Texture.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Framebuffer.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/FramebufferAttachment.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/formatutils.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Query.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Program.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Uniform.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/TransformFeedback.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/VertexArray.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/BufferImpl.h"
end_include
begin_include
include|#
directive|include
file|"common/mathutil.h"
end_include
begin_include
include|#
directive|include
file|"common/utilities.h"
end_include
begin_namespace
DECL|namespace|gl
namespace|namespace
name|gl
block|{
DECL|function|ValidCap
name|bool
name|ValidCap
parameter_list|(
specifier|const
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|cap
parameter_list|)
block|{
switch|switch
condition|(
name|cap
condition|)
block|{
case|case
name|GL_CULL_FACE
case|:
case|case
name|GL_POLYGON_OFFSET_FILL
case|:
case|case
name|GL_SAMPLE_ALPHA_TO_COVERAGE
case|:
case|case
name|GL_SAMPLE_COVERAGE
case|:
case|case
name|GL_SCISSOR_TEST
case|:
case|case
name|GL_STENCIL_TEST
case|:
case|case
name|GL_DEPTH_TEST
case|:
case|case
name|GL_BLEND
case|:
case|case
name|GL_DITHER
case|:
return|return
literal|true
return|;
case|case
name|GL_PRIMITIVE_RESTART_FIXED_INDEX
case|:
case|case
name|GL_RASTERIZER_DISCARD
case|:
return|return
operator|(
name|context
operator|->
name|getClientVersion
argument_list|()
operator|>=
literal|3
operator|)
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
DECL|function|ValidTextureTarget
name|bool
name|ValidTextureTarget
parameter_list|(
specifier|const
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|)
block|{
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TEXTURE_2D
case|:
case|case
name|GL_TEXTURE_CUBE_MAP
case|:
return|return
literal|true
return|;
case|case
name|GL_TEXTURE_3D
case|:
case|case
name|GL_TEXTURE_2D_ARRAY
case|:
return|return
operator|(
name|context
operator|->
name|getClientVersion
argument_list|()
operator|>=
literal|3
operator|)
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|// This function differs from ValidTextureTarget in that the target must be
comment|// usable as the destination of a 2D operation-- so a cube face is valid, but
comment|// GL_TEXTURE_CUBE_MAP is not.
comment|// Note: duplicate of IsInternalTextureTarget
DECL|function|ValidTexture2DDestinationTarget
name|bool
name|ValidTexture2DDestinationTarget
parameter_list|(
specifier|const
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|)
block|{
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TEXTURE_2D
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_X
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Y
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Z
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
case|:
return|return
literal|true
return|;
case|case
name|GL_TEXTURE_2D_ARRAY
case|:
case|case
name|GL_TEXTURE_3D
case|:
return|return
operator|(
name|context
operator|->
name|getClientVersion
argument_list|()
operator|>=
literal|3
operator|)
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
DECL|function|ValidFramebufferTarget
name|bool
name|ValidFramebufferTarget
parameter_list|(
name|GLenum
name|target
parameter_list|)
block|{
assert|static_assert
argument_list|(
name|GL_DRAW_FRAMEBUFFER_ANGLE
operator|==
name|GL_DRAW_FRAMEBUFFER
operator|&&
name|GL_READ_FRAMEBUFFER_ANGLE
operator|==
name|GL_READ_FRAMEBUFFER
argument_list|,
literal|"ANGLE framebuffer enums must equal the ES3 framebuffer enums."
argument_list|)
assert|;
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_FRAMEBUFFER
case|:
return|return
literal|true
return|;
case|case
name|GL_READ_FRAMEBUFFER
case|:
return|return
literal|true
return|;
case|case
name|GL_DRAW_FRAMEBUFFER
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
DECL|function|ValidBufferTarget
name|bool
name|ValidBufferTarget
parameter_list|(
specifier|const
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|)
block|{
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_ARRAY_BUFFER
case|:
case|case
name|GL_ELEMENT_ARRAY_BUFFER
case|:
return|return
literal|true
return|;
case|case
name|GL_PIXEL_PACK_BUFFER
case|:
case|case
name|GL_PIXEL_UNPACK_BUFFER
case|:
return|return
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|pixelBufferObject
return|;
case|case
name|GL_COPY_READ_BUFFER
case|:
case|case
name|GL_COPY_WRITE_BUFFER
case|:
case|case
name|GL_TRANSFORM_FEEDBACK_BUFFER
case|:
case|case
name|GL_UNIFORM_BUFFER
case|:
return|return
operator|(
name|context
operator|->
name|getClientVersion
argument_list|()
operator|>=
literal|3
operator|)
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
DECL|function|ValidBufferParameter
name|bool
name|ValidBufferParameter
parameter_list|(
specifier|const
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|pname
parameter_list|)
block|{
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_BUFFER_USAGE
case|:
case|case
name|GL_BUFFER_SIZE
case|:
return|return
literal|true
return|;
comment|// GL_BUFFER_MAP_POINTER is a special case, and may only be
comment|// queried with GetBufferPointerv
case|case
name|GL_BUFFER_ACCESS_FLAGS
case|:
case|case
name|GL_BUFFER_MAPPED
case|:
case|case
name|GL_BUFFER_MAP_OFFSET
case|:
case|case
name|GL_BUFFER_MAP_LENGTH
case|:
return|return
operator|(
name|context
operator|->
name|getClientVersion
argument_list|()
operator|>=
literal|3
operator|)
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
DECL|function|ValidMipLevel
name|bool
name|ValidMipLevel
parameter_list|(
specifier|const
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|)
block|{
name|size_t
name|maxDimension
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TEXTURE_2D
case|:
name|maxDimension
operator|=
name|context
operator|->
name|getCaps
argument_list|()
operator|.
name|max2DTextureSize
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_CUBE_MAP
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_X
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Y
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Z
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
case|:
name|maxDimension
operator|=
name|context
operator|->
name|getCaps
argument_list|()
operator|.
name|maxCubeMapTextureSize
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_3D
case|:
name|maxDimension
operator|=
name|context
operator|->
name|getCaps
argument_list|()
operator|.
name|max3DTextureSize
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_2D_ARRAY
case|:
name|maxDimension
operator|=
name|context
operator|->
name|getCaps
argument_list|()
operator|.
name|max2DTextureSize
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
name|level
operator|<=
name|gl
operator|::
name|log2
argument_list|(
name|maxDimension
argument_list|)
return|;
block|}
DECL|function|ValidImageSize
name|bool
name|ValidImageSize
parameter_list|(
specifier|const
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|depth
parameter_list|)
block|{
if|if
condition|(
name|level
operator|<
literal|0
operator|||
name|width
operator|<
literal|0
operator|||
name|height
operator|<
literal|0
operator|||
name|depth
operator|<
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|textureNPOT
operator|&&
operator|(
name|level
operator|!=
literal|0
operator|&&
operator|(
operator|!
name|gl
operator|::
name|isPow2
argument_list|(
name|width
argument_list|)
operator|||
operator|!
name|gl
operator|::
name|isPow2
argument_list|(
name|height
argument_list|)
operator|||
operator|!
name|gl
operator|::
name|isPow2
argument_list|(
name|depth
argument_list|)
operator|)
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|ValidMipLevel
argument_list|(
name|context
argument_list|,
name|target
argument_list|,
name|level
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidCompressedImageSize
name|bool
name|ValidCompressedImageSize
parameter_list|(
specifier|const
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|internalFormat
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
specifier|const
name|gl
operator|::
name|InternalFormat
modifier|&
name|formatInfo
init|=
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|internalFormat
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|formatInfo
operator|.
name|compressed
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|width
operator|<
literal|0
operator|||
operator|(
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|width
argument_list|)
operator|>
name|formatInfo
operator|.
name|compressedBlockWidth
operator|&&
name|width
operator|%
name|formatInfo
operator|.
name|compressedBlockWidth
operator|!=
literal|0
operator|)
operator|||
name|height
operator|<
literal|0
operator|||
operator|(
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|height
argument_list|)
operator|>
name|formatInfo
operator|.
name|compressedBlockHeight
operator|&&
name|height
operator|%
name|formatInfo
operator|.
name|compressedBlockHeight
operator|!=
literal|0
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidQueryType
name|bool
name|ValidQueryType
parameter_list|(
specifier|const
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|queryType
parameter_list|)
block|{
assert|static_assert
argument_list|(
name|GL_ANY_SAMPLES_PASSED
operator|==
name|GL_ANY_SAMPLES_PASSED_EXT
argument_list|,
literal|"GL extension enums not equal."
argument_list|)
assert|;
assert|static_assert
argument_list|(
name|GL_ANY_SAMPLES_PASSED_CONSERVATIVE
operator|==
name|GL_ANY_SAMPLES_PASSED_CONSERVATIVE_EXT
argument_list|,
literal|"GL extension enums not equal."
argument_list|)
assert|;
switch|switch
condition|(
name|queryType
condition|)
block|{
case|case
name|GL_ANY_SAMPLES_PASSED
case|:
case|case
name|GL_ANY_SAMPLES_PASSED_CONSERVATIVE
case|:
return|return
literal|true
return|;
case|case
name|GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN
case|:
return|return
operator|(
name|context
operator|->
name|getClientVersion
argument_list|()
operator|>=
literal|3
operator|)
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
DECL|function|ValidProgram
name|bool
name|ValidProgram
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLuint
name|id
parameter_list|)
block|{
comment|// ES3 spec (section 2.11.1) -- "Commands that accept shader or program object names will generate the
comment|// error INVALID_VALUE if the provided name is not the name of either a shader or program object and
comment|// INVALID_OPERATION if the provided name identifies an object that is not the expected type."
if|if
condition|(
name|context
operator|->
name|getProgram
argument_list|(
name|id
argument_list|)
operator|!=
name|NULL
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|context
operator|->
name|getShader
argument_list|(
name|id
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|// ID is the wrong type
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
comment|// No shader/program object has this ID
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|ValidateAttachmentTarget
name|bool
name|ValidateAttachmentTarget
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|attachment
parameter_list|)
block|{
if|if
condition|(
name|attachment
operator|>=
name|GL_COLOR_ATTACHMENT0_EXT
operator|&&
name|attachment
operator|<=
name|GL_COLOR_ATTACHMENT15_EXT
condition|)
block|{
specifier|const
name|unsigned
name|int
name|colorAttachment
init|=
operator|(
name|attachment
operator|-
name|GL_COLOR_ATTACHMENT0_EXT
operator|)
decl_stmt|;
if|if
condition|(
name|colorAttachment
operator|>=
name|context
operator|->
name|getCaps
argument_list|()
operator|.
name|maxColorAttachments
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|attachment
condition|)
block|{
case|case
name|GL_DEPTH_ATTACHMENT
case|:
case|case
name|GL_STENCIL_ATTACHMENT
case|:
break|break;
case|case
name|GL_DEPTH_STENCIL_ATTACHMENT
case|:
if|if
condition|(
name|context
operator|->
name|getClientVersion
argument_list|()
operator|<
literal|3
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateRenderbufferStorageParametersBase
name|bool
name|ValidateRenderbufferStorageParametersBase
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLsizei
name|samples
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_RENDERBUFFER
case|:
break|break;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|width
operator|<
literal|0
operator|||
name|height
operator|<
literal|0
operator|||
name|samples
operator|<
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|TextureCaps
modifier|&
name|formatCaps
init|=
name|context
operator|->
name|getTextureCaps
argument_list|()
operator|.
name|get
argument_list|(
name|internalformat
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|formatCaps
operator|.
name|renderable
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// ANGLE_framebuffer_multisample does not explicitly state that the internal format must be
comment|// sized but it does state that the format must be in the ES2.0 spec table 4.5 which contains
comment|// only sized internal formats.
specifier|const
name|gl
operator|::
name|InternalFormat
modifier|&
name|formatInfo
init|=
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|internalformat
argument_list|)
decl_stmt|;
if|if
condition|(
name|formatInfo
operator|.
name|pixelBytes
operator|==
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|std
operator|::
name|max
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
argument_list|)
operator|>
name|context
operator|->
name|getCaps
argument_list|()
operator|.
name|maxRenderbufferSize
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|GLuint
name|handle
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getRenderbufferId
argument_list|()
decl_stmt|;
if|if
condition|(
name|handle
operator|==
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateRenderbufferStorageParametersANGLE
name|bool
name|ValidateRenderbufferStorageParametersANGLE
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLsizei
name|samples
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|samples
operator|==
literal|0
operator|||
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|framebufferMultisample
argument_list|)
expr_stmt|;
comment|// ANGLE_framebuffer_multisample states that the value of samples must be less than or equal
comment|// to MAX_SAMPLES_ANGLE (Context::getExtensions().maxSamples) otherwise GL_INVALID_VALUE is
comment|// generated.
if|if
condition|(
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|samples
argument_list|)
operator|>
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|maxSamples
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// ANGLE_framebuffer_multisample states GL_OUT_OF_MEMORY is generated on a failure to create
comment|// the specified storage. This is different than ES 3.0 in which a sample number higher
comment|// than the maximum sample number supported  by this format generates a GL_INVALID_VALUE.
specifier|const
name|TextureCaps
modifier|&
name|formatCaps
init|=
name|context
operator|->
name|getTextureCaps
argument_list|()
operator|.
name|get
argument_list|(
name|internalformat
argument_list|)
decl_stmt|;
if|if
condition|(
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|samples
argument_list|)
operator|>
name|formatCaps
operator|.
name|getMaxSamples
argument_list|()
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|ValidateRenderbufferStorageParametersBase
argument_list|(
name|context
argument_list|,
name|target
argument_list|,
name|samples
argument_list|,
name|internalformat
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
return|;
block|}
DECL|function|ValidateFramebufferRenderbufferParameters
name|bool
name|ValidateFramebufferRenderbufferParameters
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLenum
name|attachment
parameter_list|,
name|GLenum
name|renderbuffertarget
parameter_list|,
name|GLuint
name|renderbuffer
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ValidFramebufferTarget
argument_list|(
name|target
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getTargetFramebuffer
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|GLuint
name|framebufferHandle
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getTargetFramebuffer
argument_list|(
name|target
argument_list|)
operator|->
name|id
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|framebuffer
operator|||
operator|(
name|framebufferHandle
operator|==
literal|0
operator|&&
name|renderbuffer
operator|!=
literal|0
operator|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|ValidateAttachmentTarget
argument_list|(
name|context
argument_list|,
name|attachment
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// [OpenGL ES 2.0.25] Section 4.4.3 page 112
comment|// [OpenGL ES 3.0.2] Section 4.4.2 page 201
comment|// 'renderbuffer' must be either zero or the name of an existing renderbuffer object of
comment|// type 'renderbuffertarget', otherwise an INVALID_OPERATION error is generated.
if|if
condition|(
name|renderbuffer
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|context
operator|->
name|getRenderbuffer
argument_list|(
name|renderbuffer
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|IsPartialBlit
specifier|static
name|bool
name|IsPartialBlit
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|readBuffer
parameter_list|,
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|writeBuffer
parameter_list|,
name|GLint
name|srcX0
parameter_list|,
name|GLint
name|srcY0
parameter_list|,
name|GLint
name|srcX1
parameter_list|,
name|GLint
name|srcY1
parameter_list|,
name|GLint
name|dstX0
parameter_list|,
name|GLint
name|dstY0
parameter_list|,
name|GLint
name|dstX1
parameter_list|,
name|GLint
name|dstY1
parameter_list|)
block|{
if|if
condition|(
name|srcX0
operator|!=
literal|0
operator|||
name|srcY0
operator|!=
literal|0
operator|||
name|dstX0
operator|!=
literal|0
operator|||
name|dstY0
operator|!=
literal|0
operator|||
name|dstX1
operator|!=
name|writeBuffer
operator|->
name|getWidth
argument_list|()
operator|||
name|dstY1
operator|!=
name|writeBuffer
operator|->
name|getHeight
argument_list|()
operator|||
name|srcX1
operator|!=
name|readBuffer
operator|->
name|getWidth
argument_list|()
operator|||
name|srcY1
operator|!=
name|readBuffer
operator|->
name|getHeight
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|context
operator|->
name|getState
argument_list|()
operator|.
name|isScissorTestEnabled
argument_list|()
condition|)
block|{
specifier|const
name|Rectangle
modifier|&
name|scissor
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getScissor
argument_list|()
decl_stmt|;
return|return
name|scissor
operator|.
name|x
operator|>
literal|0
operator|||
name|scissor
operator|.
name|y
operator|>
literal|0
operator|||
name|scissor
operator|.
name|width
operator|<
name|writeBuffer
operator|->
name|getWidth
argument_list|()
operator|||
name|scissor
operator|.
name|height
operator|<
name|writeBuffer
operator|->
name|getHeight
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
DECL|function|ValidateBlitFramebufferParameters
name|bool
name|ValidateBlitFramebufferParameters
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLint
name|srcX0
parameter_list|,
name|GLint
name|srcY0
parameter_list|,
name|GLint
name|srcX1
parameter_list|,
name|GLint
name|srcY1
parameter_list|,
name|GLint
name|dstX0
parameter_list|,
name|GLint
name|dstY0
parameter_list|,
name|GLint
name|dstX1
parameter_list|,
name|GLint
name|dstY1
parameter_list|,
name|GLbitfield
name|mask
parameter_list|,
name|GLenum
name|filter
parameter_list|,
name|bool
name|fromAngleExtension
parameter_list|)
block|{
switch|switch
condition|(
name|filter
condition|)
block|{
case|case
name|GL_NEAREST
case|:
break|break;
case|case
name|GL_LINEAR
case|:
if|if
condition|(
name|fromAngleExtension
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
operator|~
operator|(
name|GL_COLOR_BUFFER_BIT
operator||
name|GL_STENCIL_BUFFER_BIT
operator||
name|GL_DEPTH_BUFFER_BIT
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
block|{
comment|// ES3.0 spec, section 4.3.2 specifies that a mask of zero is valid and no
comment|// buffers are copied.
return|return
literal|false
return|;
block|}
if|if
condition|(
name|fromAngleExtension
operator|&&
operator|(
name|srcX1
operator|-
name|srcX0
operator|!=
name|dstX1
operator|-
name|dstX0
operator|||
name|srcY1
operator|-
name|srcY0
operator|!=
name|dstY1
operator|-
name|dstY0
operator|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Scaling and flipping in BlitFramebufferANGLE not supported by this implementation."
argument_list|)
expr_stmt|;
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// ES3.0 spec, section 4.3.2 states that linear filtering is only available for the
comment|// color buffer, leaving only nearest being unfiltered from above
if|if
condition|(
operator|(
name|mask
operator|&
operator|~
name|GL_COLOR_BUFFER_BIT
operator|)
operator|!=
literal|0
operator|&&
name|filter
operator|!=
name|GL_NEAREST
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getReadFramebuffer
argument_list|()
operator|->
name|id
argument_list|()
operator|==
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getDrawFramebuffer
argument_list|()
operator|->
name|id
argument_list|()
condition|)
block|{
if|if
condition|(
name|fromAngleExtension
condition|)
block|{
name|ERR
argument_list|(
literal|"Blits with the same source and destination framebuffer are not supported by this "
literal|"implementation."
argument_list|)
expr_stmt|;
block|}
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|gl
operator|::
name|Framebuffer
modifier|*
name|readFramebuffer
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getReadFramebuffer
argument_list|()
decl_stmt|;
name|gl
operator|::
name|Framebuffer
modifier|*
name|drawFramebuffer
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|readFramebuffer
operator|||
operator|!
name|drawFramebuffer
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_FRAMEBUFFER_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|readFramebuffer
operator|->
name|checkStatus
argument_list|(
name|context
operator|->
name|getData
argument_list|()
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_FRAMEBUFFER_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|drawFramebuffer
operator|->
name|checkStatus
argument_list|(
name|context
operator|->
name|getData
argument_list|()
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_FRAMEBUFFER_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|drawFramebuffer
operator|->
name|getSamples
argument_list|(
name|context
operator|->
name|getData
argument_list|()
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|bool
name|sameBounds
init|=
name|srcX0
operator|==
name|dstX0
operator|&&
name|srcY0
operator|==
name|dstY0
operator|&&
name|srcX1
operator|==
name|dstX1
operator|&&
name|srcY1
operator|==
name|dstY1
decl_stmt|;
if|if
condition|(
name|mask
operator|&
name|GL_COLOR_BUFFER_BIT
condition|)
block|{
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|readColorBuffer
init|=
name|readFramebuffer
operator|->
name|getReadColorbuffer
argument_list|()
decl_stmt|;
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|drawColorBuffer
init|=
name|drawFramebuffer
operator|->
name|getFirstColorbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|readColorBuffer
operator|&&
name|drawColorBuffer
condition|)
block|{
name|GLenum
name|readInternalFormat
init|=
name|readColorBuffer
operator|->
name|getInternalFormat
argument_list|()
decl_stmt|;
specifier|const
name|InternalFormat
modifier|&
name|readFormatInfo
init|=
name|GetInternalFormatInfo
argument_list|(
name|readInternalFormat
argument_list|)
decl_stmt|;
for|for
control|(
name|GLuint
name|i
init|=
literal|0
init|;
name|i
operator|<
name|context
operator|->
name|getCaps
argument_list|()
operator|.
name|maxColorAttachments
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|drawFramebuffer
operator|->
name|isEnabledColorAttachment
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|GLenum
name|drawInternalFormat
init|=
name|drawFramebuffer
operator|->
name|getColorbuffer
argument_list|(
name|i
argument_list|)
operator|->
name|getInternalFormat
argument_list|()
decl_stmt|;
specifier|const
name|InternalFormat
modifier|&
name|drawFormatInfo
init|=
name|GetInternalFormatInfo
argument_list|(
name|drawInternalFormat
argument_list|)
decl_stmt|;
comment|// The GL ES 3.0.2 spec (pg 193) states that:
comment|// 1) If the read buffer is fixed point format, the draw buffer must be as well
comment|// 2) If the read buffer is an unsigned integer format, the draw buffer must be as well
comment|// 3) If the read buffer is a signed integer format, the draw buffer must be as well
if|if
condition|(
operator|(
name|readFormatInfo
operator|.
name|componentType
operator|==
name|GL_UNSIGNED_NORMALIZED
operator|||
name|readFormatInfo
operator|.
name|componentType
operator|==
name|GL_SIGNED_NORMALIZED
operator|)
operator|&&
operator|!
operator|(
name|drawFormatInfo
operator|.
name|componentType
operator|==
name|GL_UNSIGNED_NORMALIZED
operator|||
name|drawFormatInfo
operator|.
name|componentType
operator|==
name|GL_SIGNED_NORMALIZED
operator|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|readFormatInfo
operator|.
name|componentType
operator|==
name|GL_UNSIGNED_INT
operator|&&
name|drawFormatInfo
operator|.
name|componentType
operator|!=
name|GL_UNSIGNED_INT
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|readFormatInfo
operator|.
name|componentType
operator|==
name|GL_INT
operator|&&
name|drawFormatInfo
operator|.
name|componentType
operator|!=
name|GL_INT
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|readColorBuffer
operator|->
name|getSamples
argument_list|()
operator|>
literal|0
operator|&&
operator|(
name|readInternalFormat
operator|!=
name|drawInternalFormat
operator|||
operator|!
name|sameBounds
operator|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|readFormatInfo
operator|.
name|componentType
operator|==
name|GL_INT
operator|||
name|readFormatInfo
operator|.
name|componentType
operator|==
name|GL_UNSIGNED_INT
operator|)
operator|&&
name|filter
operator|==
name|GL_LINEAR
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|fromAngleExtension
condition|)
block|{
name|FramebufferAttachment
modifier|*
name|readColorAttachment
init|=
name|readFramebuffer
operator|->
name|getReadColorbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|readColorAttachment
operator|||
operator|(
operator|!
operator|(
name|readColorAttachment
operator|->
name|type
argument_list|()
operator|==
name|GL_TEXTURE
operator|&&
name|readColorAttachment
operator|->
name|getTextureImageIndex
argument_list|()
operator|->
name|type
operator|==
name|GL_TEXTURE_2D
operator|)
operator|&&
name|readColorAttachment
operator|->
name|type
argument_list|()
operator|!=
name|GL_RENDERBUFFER
operator|&&
name|readColorAttachment
operator|->
name|type
argument_list|()
operator|!=
name|GL_FRAMEBUFFER_DEFAULT
operator|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
for|for
control|(
name|GLuint
name|colorAttachment
init|=
literal|0
init|;
name|colorAttachment
operator|<
name|context
operator|->
name|getCaps
argument_list|()
operator|.
name|maxColorAttachments
condition|;
operator|++
name|colorAttachment
control|)
block|{
if|if
condition|(
name|drawFramebuffer
operator|->
name|isEnabledColorAttachment
argument_list|(
name|colorAttachment
argument_list|)
condition|)
block|{
name|FramebufferAttachment
modifier|*
name|attachment
init|=
name|drawFramebuffer
operator|->
name|getColorbuffer
argument_list|(
name|colorAttachment
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|attachment
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|attachment
operator|->
name|type
argument_list|()
operator|==
name|GL_TEXTURE
operator|&&
name|attachment
operator|->
name|getTextureImageIndex
argument_list|()
operator|->
name|type
operator|==
name|GL_TEXTURE_2D
operator|)
operator|&&
name|attachment
operator|->
name|type
argument_list|()
operator|!=
name|GL_RENDERBUFFER
operator|&&
name|attachment
operator|->
name|type
argument_list|()
operator|!=
name|GL_FRAMEBUFFER_DEFAULT
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Return an error if the destination formats do not match
if|if
condition|(
name|attachment
operator|->
name|getInternalFormat
argument_list|()
operator|!=
name|readColorBuffer
operator|->
name|getInternalFormat
argument_list|()
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
name|int
name|readSamples
init|=
name|readFramebuffer
operator|->
name|getSamples
argument_list|(
name|context
operator|->
name|getData
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|readSamples
operator|!=
literal|0
operator|&&
name|IsPartialBlit
argument_list|(
name|context
argument_list|,
name|readColorBuffer
argument_list|,
name|drawColorBuffer
argument_list|,
name|srcX0
argument_list|,
name|srcY0
argument_list|,
name|srcX1
argument_list|,
name|srcY1
argument_list|,
name|dstX0
argument_list|,
name|dstY0
argument_list|,
name|dstX1
argument_list|,
name|dstY1
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
block|}
name|GLenum
name|masks
index|[]
init|=
block|{
name|GL_DEPTH_BUFFER_BIT
block|,
name|GL_STENCIL_BUFFER_BIT
block|}
decl_stmt|;
name|GLenum
name|attachments
index|[]
init|=
block|{
name|GL_DEPTH_ATTACHMENT
block|,
name|GL_STENCIL_ATTACHMENT
block|}
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
name|masks
index|[
name|i
index|]
condition|)
block|{
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|readBuffer
init|=
name|readFramebuffer
operator|->
name|getAttachment
argument_list|(
name|attachments
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|drawBuffer
init|=
name|drawFramebuffer
operator|->
name|getAttachment
argument_list|(
name|attachments
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|readBuffer
operator|&&
name|drawBuffer
condition|)
block|{
if|if
condition|(
name|readBuffer
operator|->
name|getInternalFormat
argument_list|()
operator|!=
name|drawBuffer
operator|->
name|getInternalFormat
argument_list|()
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|readBuffer
operator|->
name|getSamples
argument_list|()
operator|>
literal|0
operator|&&
operator|!
name|sameBounds
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|fromAngleExtension
condition|)
block|{
if|if
condition|(
name|IsPartialBlit
argument_list|(
name|context
argument_list|,
name|readBuffer
argument_list|,
name|drawBuffer
argument_list|,
name|srcX0
argument_list|,
name|srcY0
argument_list|,
name|srcX1
argument_list|,
name|srcY1
argument_list|,
name|dstX0
argument_list|,
name|dstY0
argument_list|,
name|dstX1
argument_list|,
name|dstY1
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"Only whole-buffer depth and stencil blits are supported by this implementation."
argument_list|)
expr_stmt|;
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
comment|// only whole-buffer copies are permitted
return|return
literal|false
return|;
block|}
if|if
condition|(
name|readBuffer
operator|->
name|getSamples
argument_list|()
operator|!=
literal|0
operator|||
name|drawBuffer
operator|->
name|getSamples
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateGetVertexAttribParameters
name|bool
name|ValidateGetVertexAttribParameters
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|pname
parameter_list|)
block|{
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_VERTEX_ATTRIB_ARRAY_ENABLED
case|:
case|case
name|GL_VERTEX_ATTRIB_ARRAY_SIZE
case|:
case|case
name|GL_VERTEX_ATTRIB_ARRAY_STRIDE
case|:
case|case
name|GL_VERTEX_ATTRIB_ARRAY_TYPE
case|:
case|case
name|GL_VERTEX_ATTRIB_ARRAY_NORMALIZED
case|:
case|case
name|GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING
case|:
case|case
name|GL_CURRENT_VERTEX_ATTRIB
case|:
return|return
literal|true
return|;
case|case
name|GL_VERTEX_ATTRIB_ARRAY_DIVISOR
case|:
comment|// Don't verify ES3 context because GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE uses
comment|// the same constant.
assert|static_assert
argument_list|(
name|GL_VERTEX_ATTRIB_ARRAY_DIVISOR
operator|==
name|GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE
argument_list|,
literal|"ANGLE extension enums not equal to GL enums."
argument_list|)
assert|;
return|return
literal|true
return|;
case|case
name|GL_VERTEX_ATTRIB_ARRAY_INTEGER
case|:
if|if
condition|(
name|context
operator|->
name|getClientVersion
argument_list|()
operator|<
literal|3
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|ValidateTexParamParameters
name|bool
name|ValidateTexParamParameters
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLint
name|param
parameter_list|)
block|{
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_TEXTURE_WRAP_R
case|:
case|case
name|GL_TEXTURE_SWIZZLE_R
case|:
case|case
name|GL_TEXTURE_SWIZZLE_G
case|:
case|case
name|GL_TEXTURE_SWIZZLE_B
case|:
case|case
name|GL_TEXTURE_SWIZZLE_A
case|:
case|case
name|GL_TEXTURE_BASE_LEVEL
case|:
case|case
name|GL_TEXTURE_MAX_LEVEL
case|:
case|case
name|GL_TEXTURE_COMPARE_MODE
case|:
case|case
name|GL_TEXTURE_COMPARE_FUNC
case|:
case|case
name|GL_TEXTURE_MIN_LOD
case|:
case|case
name|GL_TEXTURE_MAX_LOD
case|:
if|if
condition|(
name|context
operator|->
name|getClientVersion
argument_list|()
operator|<
literal|3
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_TEXTURE_WRAP_S
case|:
case|case
name|GL_TEXTURE_WRAP_T
case|:
case|case
name|GL_TEXTURE_WRAP_R
case|:
switch|switch
condition|(
name|param
condition|)
block|{
case|case
name|GL_REPEAT
case|:
case|case
name|GL_CLAMP_TO_EDGE
case|:
case|case
name|GL_MIRRORED_REPEAT
case|:
return|return
literal|true
return|;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
case|case
name|GL_TEXTURE_MIN_FILTER
case|:
switch|switch
condition|(
name|param
condition|)
block|{
case|case
name|GL_NEAREST
case|:
case|case
name|GL_LINEAR
case|:
case|case
name|GL_NEAREST_MIPMAP_NEAREST
case|:
case|case
name|GL_LINEAR_MIPMAP_NEAREST
case|:
case|case
name|GL_NEAREST_MIPMAP_LINEAR
case|:
case|case
name|GL_LINEAR_MIPMAP_LINEAR
case|:
return|return
literal|true
return|;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|GL_TEXTURE_MAG_FILTER
case|:
switch|switch
condition|(
name|param
condition|)
block|{
case|case
name|GL_NEAREST
case|:
case|case
name|GL_LINEAR
case|:
return|return
literal|true
return|;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|GL_TEXTURE_USAGE_ANGLE
case|:
switch|switch
condition|(
name|param
condition|)
block|{
case|case
name|GL_NONE
case|:
case|case
name|GL_FRAMEBUFFER_ATTACHMENT_ANGLE
case|:
return|return
literal|true
return|;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|GL_TEXTURE_MAX_ANISOTROPY_EXT
case|:
if|if
condition|(
operator|!
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|textureFilterAnisotropic
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// we assume the parameter passed to this validation method is truncated, not rounded
if|if
condition|(
name|param
operator|<
literal|1
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
case|case
name|GL_TEXTURE_MIN_LOD
case|:
case|case
name|GL_TEXTURE_MAX_LOD
case|:
comment|// any value is permissible
return|return
literal|true
return|;
case|case
name|GL_TEXTURE_COMPARE_MODE
case|:
comment|// Acceptable mode parameters from GLES 3.0.2 spec, table 3.17
switch|switch
condition|(
name|param
condition|)
block|{
case|case
name|GL_NONE
case|:
case|case
name|GL_COMPARE_REF_TO_TEXTURE
case|:
return|return
literal|true
return|;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|GL_TEXTURE_COMPARE_FUNC
case|:
comment|// Acceptable function parameters from GLES 3.0.2 spec, table 3.17
switch|switch
condition|(
name|param
condition|)
block|{
case|case
name|GL_LEQUAL
case|:
case|case
name|GL_GEQUAL
case|:
case|case
name|GL_LESS
case|:
case|case
name|GL_GREATER
case|:
case|case
name|GL_EQUAL
case|:
case|case
name|GL_NOTEQUAL
case|:
case|case
name|GL_ALWAYS
case|:
case|case
name|GL_NEVER
case|:
return|return
literal|true
return|;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|GL_TEXTURE_SWIZZLE_R
case|:
case|case
name|GL_TEXTURE_SWIZZLE_G
case|:
case|case
name|GL_TEXTURE_SWIZZLE_B
case|:
case|case
name|GL_TEXTURE_SWIZZLE_A
case|:
switch|switch
condition|(
name|param
condition|)
block|{
case|case
name|GL_RED
case|:
case|case
name|GL_GREEN
case|:
case|case
name|GL_BLUE
case|:
case|case
name|GL_ALPHA
case|:
case|case
name|GL_ZERO
case|:
case|case
name|GL_ONE
case|:
return|return
literal|true
return|;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|GL_TEXTURE_BASE_LEVEL
case|:
case|case
name|GL_TEXTURE_MAX_LEVEL
case|:
if|if
condition|(
name|param
operator|<
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|ValidateSamplerObjectParameter
name|bool
name|ValidateSamplerObjectParameter
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|pname
parameter_list|)
block|{
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_TEXTURE_MIN_FILTER
case|:
case|case
name|GL_TEXTURE_MAG_FILTER
case|:
case|case
name|GL_TEXTURE_WRAP_S
case|:
case|case
name|GL_TEXTURE_WRAP_T
case|:
case|case
name|GL_TEXTURE_WRAP_R
case|:
case|case
name|GL_TEXTURE_MIN_LOD
case|:
case|case
name|GL_TEXTURE_MAX_LOD
case|:
case|case
name|GL_TEXTURE_COMPARE_MODE
case|:
case|case
name|GL_TEXTURE_COMPARE_FUNC
case|:
return|return
literal|true
return|;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|ValidateReadPixelsParameters
name|bool
name|ValidateReadPixelsParameters
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLsizei
modifier|*
name|bufSize
parameter_list|,
name|GLvoid
modifier|*
name|pixels
parameter_list|)
block|{
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getReadFramebuffer
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|framebuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|framebuffer
operator|->
name|checkStatus
argument_list|(
name|context
operator|->
name|getData
argument_list|()
argument_list|)
operator|!=
name|GL_FRAMEBUFFER_COMPLETE
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_FRAMEBUFFER_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getReadFramebuffer
argument_list|()
operator|->
name|id
argument_list|()
operator|!=
literal|0
operator|&&
name|framebuffer
operator|->
name|getSamples
argument_list|(
name|context
operator|->
name|getData
argument_list|()
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|FramebufferAttachment
modifier|*
name|readBuffer
init|=
name|framebuffer
operator|->
name|getReadColorbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|readBuffer
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|GLenum
name|currentFormat
init|=
name|framebuffer
operator|->
name|getImplementationColorReadFormat
argument_list|()
decl_stmt|;
name|GLenum
name|currentType
init|=
name|framebuffer
operator|->
name|getImplementationColorReadType
argument_list|()
decl_stmt|;
name|GLenum
name|currentInternalFormat
init|=
name|readBuffer
operator|->
name|getInternalFormat
argument_list|()
decl_stmt|;
name|GLuint
name|clientVersion
init|=
name|context
operator|->
name|getClientVersion
argument_list|()
decl_stmt|;
name|bool
name|validReadFormat
init|=
operator|(
name|clientVersion
operator|<
literal|3
operator|)
condition|?
name|ValidES2ReadFormatType
argument_list|(
name|context
argument_list|,
name|format
argument_list|,
name|type
argument_list|)
else|:
name|ValidES3ReadFormatType
argument_list|(
name|context
argument_list|,
name|currentInternalFormat
argument_list|,
name|format
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|currentFormat
operator|==
name|format
operator|&&
name|currentType
operator|==
name|type
operator|)
operator|&&
operator|!
name|validReadFormat
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|GLenum
name|sizedInternalFormat
init|=
name|GetSizedInternalFormat
argument_list|(
name|format
argument_list|,
name|type
argument_list|)
decl_stmt|;
specifier|const
name|InternalFormat
modifier|&
name|sizedFormatInfo
init|=
name|GetInternalFormatInfo
argument_list|(
name|sizedInternalFormat
argument_list|)
decl_stmt|;
name|GLsizei
name|outputPitch
init|=
name|sizedFormatInfo
operator|.
name|computeRowPitch
argument_list|(
name|type
argument_list|,
name|width
argument_list|,
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getPackAlignment
argument_list|()
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|// sized query sanity check
if|if
condition|(
name|bufSize
condition|)
block|{
name|int
name|requiredSize
init|=
name|outputPitch
operator|*
name|height
decl_stmt|;
if|if
condition|(
name|requiredSize
operator|>
operator|*
name|bufSize
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateBeginQuery
name|bool
name|ValidateBeginQuery
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLuint
name|id
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ValidQueryType
argument_list|(
name|context
argument_list|,
name|target
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|id
operator|==
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// From EXT_occlusion_query_boolean: If BeginQueryEXT is called with an<id>
comment|// of zero, if the active query object name for<target> is non-zero (for the
comment|// targets ANY_SAMPLES_PASSED_EXT and ANY_SAMPLES_PASSED_CONSERVATIVE_EXT, if
comment|// the active query for either target is non-zero), if<id> is the name of an
comment|// existing query object whose type does not match<target>, or if<id> is the
comment|// active query object name for any query type, the error INVALID_OPERATION is
comment|// generated.
comment|// Ensure no other queries are active
comment|// NOTE: If other queries than occlusion are supported, we will need to check
comment|// separately that:
comment|//    a) The query ID passed is not the current active query for any target/type
comment|//    b) There are no active queries for the requested target (and in the case
comment|//       of GL_ANY_SAMPLES_PASSED_EXT and GL_ANY_SAMPLES_PASSED_CONSERVATIVE_EXT,
comment|//       no query may be active for either if glBeginQuery targets either.
if|if
condition|(
name|context
operator|->
name|getState
argument_list|()
operator|.
name|isQueryActive
argument_list|()
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|Query
modifier|*
name|queryObject
init|=
name|context
operator|->
name|getQuery
argument_list|(
name|id
argument_list|,
literal|true
argument_list|,
name|target
argument_list|)
decl_stmt|;
comment|// check that name was obtained with glGenQueries
if|if
condition|(
operator|!
name|queryObject
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// check for type mismatch
if|if
condition|(
name|queryObject
operator|->
name|getType
argument_list|()
operator|!=
name|target
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateEndQuery
name|bool
name|ValidateEndQuery
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ValidQueryType
argument_list|(
name|context
argument_list|,
name|target
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|Query
modifier|*
name|queryObject
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getActiveQuery
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|queryObject
operator|==
name|NULL
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateUniformCommonBase
specifier|static
name|bool
name|ValidateUniformCommonBase
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|targetUniformType
parameter_list|,
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|LinkedUniform
modifier|*
modifier|*
name|uniformOut
parameter_list|)
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|gl
operator|::
name|Program
modifier|*
name|program
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getProgram
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|program
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|location
operator|==
operator|-
literal|1
condition|)
block|{
comment|// Silently ignore the uniform command
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|program
operator|->
name|isValidUniformLocation
argument_list|(
name|location
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|LinkedUniform
modifier|*
name|uniform
init|=
name|program
operator|->
name|getUniformByLocation
argument_list|(
name|location
argument_list|)
decl_stmt|;
comment|// attempting to write an array to a non-array uniform is an INVALID_OPERATION
if|if
condition|(
name|uniform
operator|->
name|elementCount
argument_list|()
operator|==
literal|1
operator|&&
name|count
operator|>
literal|1
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
operator|*
name|uniformOut
operator|=
name|uniform
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|ValidateUniform
name|bool
name|ValidateUniform
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|uniformType
parameter_list|,
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|)
block|{
comment|// Check for ES3 uniform entry points
if|if
condition|(
name|VariableComponentType
argument_list|(
name|uniformType
argument_list|)
operator|==
name|GL_UNSIGNED_INT
operator|&&
name|context
operator|->
name|getClientVersion
argument_list|()
operator|<
literal|3
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|LinkedUniform
modifier|*
name|uniform
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|ValidateUniformCommonBase
argument_list|(
name|context
argument_list|,
name|uniformType
argument_list|,
name|location
argument_list|,
name|count
argument_list|,
operator|&
name|uniform
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|GLenum
name|targetBoolType
init|=
name|VariableBoolVectorType
argument_list|(
name|uniformType
argument_list|)
decl_stmt|;
name|bool
name|samplerUniformCheck
init|=
operator|(
name|IsSamplerType
argument_list|(
name|uniform
operator|->
name|type
argument_list|)
operator|&&
name|uniformType
operator|==
name|GL_INT
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|samplerUniformCheck
operator|&&
name|uniformType
operator|!=
name|uniform
operator|->
name|type
operator|&&
name|targetBoolType
operator|!=
name|uniform
operator|->
name|type
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateUniformMatrix
name|bool
name|ValidateUniformMatrix
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|matrixType
parameter_list|,
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|)
block|{
comment|// Check for ES3 uniform entry points
name|int
name|rows
init|=
name|VariableRowCount
argument_list|(
name|matrixType
argument_list|)
decl_stmt|;
name|int
name|cols
init|=
name|VariableColumnCount
argument_list|(
name|matrixType
argument_list|)
decl_stmt|;
if|if
condition|(
name|rows
operator|!=
name|cols
operator|&&
name|context
operator|->
name|getClientVersion
argument_list|()
operator|<
literal|3
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|transpose
operator|!=
name|GL_FALSE
operator|&&
name|context
operator|->
name|getClientVersion
argument_list|()
operator|<
literal|3
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|LinkedUniform
modifier|*
name|uniform
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|ValidateUniformCommonBase
argument_list|(
name|context
argument_list|,
name|matrixType
argument_list|,
name|location
argument_list|,
name|count
argument_list|,
operator|&
name|uniform
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|uniform
operator|->
name|type
operator|!=
name|matrixType
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateStateQuery
name|bool
name|ValidateStateQuery
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLenum
modifier|*
name|nativeType
parameter_list|,
name|unsigned
name|int
modifier|*
name|numParams
parameter_list|)
block|{
if|if
condition|(
operator|!
name|context
operator|->
name|getQueryParameterInfo
argument_list|(
name|pname
argument_list|,
name|nativeType
argument_list|,
name|numParams
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|Caps
modifier|&
name|caps
init|=
name|context
operator|->
name|getCaps
argument_list|()
decl_stmt|;
if|if
condition|(
name|pname
operator|>=
name|GL_DRAW_BUFFER0
operator|&&
name|pname
operator|<=
name|GL_DRAW_BUFFER15
condition|)
block|{
name|unsigned
name|int
name|colorAttachment
init|=
operator|(
name|pname
operator|-
name|GL_DRAW_BUFFER0
operator|)
decl_stmt|;
if|if
condition|(
name|colorAttachment
operator|>=
name|caps
operator|.
name|maxDrawBuffers
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_TEXTURE_BINDING_2D
case|:
case|case
name|GL_TEXTURE_BINDING_CUBE_MAP
case|:
case|case
name|GL_TEXTURE_BINDING_3D
case|:
case|case
name|GL_TEXTURE_BINDING_2D_ARRAY
case|:
if|if
condition|(
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getActiveSampler
argument_list|()
operator|>=
name|caps
operator|.
name|maxCombinedTextureImageUnits
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|GL_IMPLEMENTATION_COLOR_READ_TYPE
case|:
case|case
name|GL_IMPLEMENTATION_COLOR_READ_FORMAT
case|:
block|{
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getReadFramebuffer
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|framebuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|framebuffer
operator|->
name|checkStatus
argument_list|(
name|context
operator|->
name|getData
argument_list|()
argument_list|)
operator|!=
name|GL_FRAMEBUFFER_COMPLETE
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|FramebufferAttachment
modifier|*
name|attachment
init|=
name|framebuffer
operator|->
name|getReadColorbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|attachment
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
break|break;
default|default:
break|break;
block|}
comment|// pname is valid, but there are no parameters to return
if|if
condition|(
name|numParams
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateCopyTexImageParametersBase
name|bool
name|ValidateCopyTexImageParametersBase
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|bool
name|isSubImage
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLint
name|zoffset
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLint
name|border
parameter_list|,
name|GLenum
modifier|*
name|textureFormatOut
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ValidTexture2DDestinationTarget
argument_list|(
name|context
argument_list|,
name|target
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|level
operator|<
literal|0
operator|||
name|xoffset
operator|<
literal|0
operator|||
name|yoffset
operator|<
literal|0
operator|||
name|zoffset
operator|<
literal|0
operator|||
name|width
operator|<
literal|0
operator|||
name|height
operator|<
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|std
operator|::
name|numeric_limits
argument_list|<
name|GLsizei
argument_list|>
operator|::
name|max
argument_list|()
operator|-
name|xoffset
operator|<
name|width
operator|||
name|std
operator|::
name|numeric_limits
argument_list|<
name|GLsizei
argument_list|>
operator|::
name|max
argument_list|()
operator|-
name|yoffset
operator|<
name|height
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|border
operator|!=
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|ValidMipLevel
argument_list|(
name|context
argument_list|,
name|target
argument_list|,
name|level
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getReadFramebuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|framebuffer
operator|->
name|checkStatus
argument_list|(
name|context
operator|->
name|getData
argument_list|()
argument_list|)
operator|!=
name|GL_FRAMEBUFFER_COMPLETE
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_FRAMEBUFFER_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getReadFramebuffer
argument_list|()
operator|->
name|id
argument_list|()
operator|!=
literal|0
operator|&&
name|framebuffer
operator|->
name|getSamples
argument_list|(
name|context
operator|->
name|getData
argument_list|()
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|gl
operator|::
name|Caps
modifier|&
name|caps
init|=
name|context
operator|->
name|getCaps
argument_list|()
decl_stmt|;
name|GLuint
name|maxDimension
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TEXTURE_2D
case|:
name|maxDimension
operator|=
name|caps
operator|.
name|max2DTextureSize
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_X
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Y
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Z
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
case|:
name|maxDimension
operator|=
name|caps
operator|.
name|maxCubeMapTextureSize
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_2D_ARRAY
case|:
name|maxDimension
operator|=
name|caps
operator|.
name|max2DTextureSize
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_3D
case|:
name|maxDimension
operator|=
name|caps
operator|.
name|max3DTextureSize
expr_stmt|;
break|break;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|gl
operator|::
name|Texture
modifier|*
name|texture
init|=
name|context
operator|->
name|getTargetTexture
argument_list|(
name|IsCubeMapTextureTarget
argument_list|(
name|target
argument_list|)
condition|?
name|GL_TEXTURE_CUBE_MAP
else|:
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|texture
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|texture
operator|->
name|isImmutable
argument_list|()
operator|&&
operator|!
name|isSubImage
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|gl
operator|::
name|InternalFormat
modifier|&
name|formatInfo
init|=
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|internalformat
argument_list|)
decl_stmt|;
if|if
condition|(
name|formatInfo
operator|.
name|depthBits
operator|>
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|formatInfo
operator|.
name|compressed
operator|&&
operator|!
name|ValidCompressedImageSize
argument_list|(
name|context
argument_list|,
name|internalformat
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|isSubImage
condition|)
block|{
if|if
condition|(
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|xoffset
operator|+
name|width
argument_list|)
operator|>
name|texture
operator|->
name|getWidth
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
operator|||
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|yoffset
operator|+
name|height
argument_list|)
operator|>
name|texture
operator|->
name|getHeight
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
operator|||
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|zoffset
argument_list|)
operator|>=
name|texture
operator|->
name|getDepth
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|IsCubeMapTextureTarget
argument_list|(
name|target
argument_list|)
operator|&&
name|width
operator|!=
name|height
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|formatInfo
operator|.
name|textureSupport
argument_list|(
name|context
operator|->
name|getClientVersion
argument_list|()
argument_list|,
name|context
operator|->
name|getExtensions
argument_list|()
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|int
name|maxLevelDimension
init|=
operator|(
name|maxDimension
operator|>>
name|level
operator|)
decl_stmt|;
if|if
condition|(
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|width
argument_list|)
operator|>
name|maxLevelDimension
operator|||
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|height
argument_list|)
operator|>
name|maxLevelDimension
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
operator|*
name|textureFormatOut
operator|=
name|texture
operator|->
name|getInternalFormat
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|ValidateDrawBase
specifier|static
name|bool
name|ValidateDrawBase
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLsizei
name|maxVertex
parameter_list|,
name|GLsizei
name|primcount
parameter_list|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|GL_POINTS
case|:
case|case
name|GL_LINES
case|:
case|case
name|GL_LINE_LOOP
case|:
case|case
name|GL_LINE_STRIP
case|:
case|case
name|GL_TRIANGLES
case|:
case|case
name|GL_TRIANGLE_STRIP
case|:
case|case
name|GL_TRIANGLE_FAN
case|:
break|break;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|State
modifier|&
name|state
init|=
name|context
operator|->
name|getState
argument_list|()
decl_stmt|;
comment|// Check for mapped buffers
if|if
condition|(
name|state
operator|.
name|hasMappedBuffer
argument_list|(
name|GL_ARRAY_BUFFER
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|gl
operator|::
name|DepthStencilState
modifier|&
name|depthStencilState
init|=
name|state
operator|.
name|getDepthStencilState
argument_list|()
decl_stmt|;
if|if
condition|(
name|depthStencilState
operator|.
name|stencilWritemask
operator|!=
name|depthStencilState
operator|.
name|stencilBackWritemask
operator|||
name|state
operator|.
name|getStencilRef
argument_list|()
operator|!=
name|state
operator|.
name|getStencilBackRef
argument_list|()
operator|||
name|depthStencilState
operator|.
name|stencilMask
operator|!=
name|depthStencilState
operator|.
name|stencilBackMask
condition|)
block|{
comment|// Note: these separate values are not supported in WebGL, due to D3D's limitations.
comment|// See Section 6.10 of the WebGL 1.0 spec
name|ERR
argument_list|(
literal|"This ANGLE implementation does not support separate front/back stencil "
literal|"writemasks, reference values, or stencil mask values."
argument_list|)
expr_stmt|;
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|fbo
init|=
name|state
operator|.
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|fbo
operator|||
name|fbo
operator|->
name|checkStatus
argument_list|(
name|context
operator|->
name|getData
argument_list|()
argument_list|)
operator|!=
name|GL_FRAMEBUFFER_COMPLETE
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_FRAMEBUFFER_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|gl
operator|::
name|Program
modifier|*
name|program
init|=
name|state
operator|.
name|getProgram
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|program
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|program
operator|->
name|validateSamplers
argument_list|(
name|NULL
argument_list|,
name|context
operator|->
name|getCaps
argument_list|()
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Buffer validations
specifier|const
name|VertexArray
modifier|*
name|vao
init|=
name|state
operator|.
name|getVertexArray
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|attributeIndex
init|=
literal|0
init|;
name|attributeIndex
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|attributeIndex
operator|++
control|)
block|{
specifier|const
name|VertexAttribute
modifier|&
name|attrib
init|=
name|vao
operator|->
name|getVertexAttribute
argument_list|(
name|attributeIndex
argument_list|)
decl_stmt|;
name|bool
name|attribActive
init|=
operator|(
name|program
operator|->
name|getSemanticIndex
argument_list|(
name|attributeIndex
argument_list|)
operator|!=
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|attribActive
operator|&&
name|attrib
operator|.
name|enabled
condition|)
block|{
name|gl
operator|::
name|Buffer
modifier|*
name|buffer
init|=
name|attrib
operator|.
name|buffer
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|buffer
condition|)
block|{
name|GLint64
name|attribStride
init|=
cast|static_cast
argument_list|<
name|GLint64
argument_list|>
argument_list|(
name|ComputeVertexAttributeStride
argument_list|(
name|attrib
argument_list|)
argument_list|)
decl_stmt|;
name|GLint64
name|maxVertexElement
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|attrib
operator|.
name|divisor
operator|>
literal|0
condition|)
block|{
name|maxVertexElement
operator|=
cast|static_cast
argument_list|<
name|GLint64
argument_list|>
argument_list|(
name|primcount
argument_list|)
operator|/
cast|static_cast
argument_list|<
name|GLint64
argument_list|>
argument_list|(
name|attrib
operator|.
name|divisor
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|maxVertexElement
operator|=
cast|static_cast
argument_list|<
name|GLint64
argument_list|>
argument_list|(
name|maxVertex
argument_list|)
expr_stmt|;
block|}
name|GLint64
name|attribDataSize
init|=
name|maxVertexElement
operator|*
name|attribStride
decl_stmt|;
comment|// [OpenGL ES 3.0.2] section 2.9.4 page 40:
comment|// We can return INVALID_OPERATION if our vertex attribute does not have
comment|// enough backing data.
if|if
condition|(
name|attribDataSize
operator|>
name|buffer
operator|->
name|getSize
argument_list|()
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|attrib
operator|.
name|pointer
operator|==
name|NULL
condition|)
block|{
comment|// This is an application error that would normally result in a crash,
comment|// but we catch it and return an error
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"An enabled vertex array has no buffer and no pointer."
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
comment|// Uniform buffer validation
for|for
control|(
name|unsigned
name|int
name|uniformBlockIndex
init|=
literal|0
init|;
name|uniformBlockIndex
operator|<
name|program
operator|->
name|getActiveUniformBlockCount
argument_list|()
condition|;
name|uniformBlockIndex
operator|++
control|)
block|{
specifier|const
name|gl
operator|::
name|UniformBlock
modifier|*
name|uniformBlock
init|=
name|program
operator|->
name|getUniformBlockByIndex
argument_list|(
name|uniformBlockIndex
argument_list|)
decl_stmt|;
name|GLuint
name|blockBinding
init|=
name|program
operator|->
name|getUniformBlockBinding
argument_list|(
name|uniformBlockIndex
argument_list|)
decl_stmt|;
specifier|const
name|gl
operator|::
name|Buffer
modifier|*
name|uniformBuffer
init|=
name|state
operator|.
name|getIndexedUniformBuffer
argument_list|(
name|blockBinding
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|uniformBuffer
condition|)
block|{
comment|// undefined behaviour
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"It is undefined behaviour to have a used but unbound uniform buffer."
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|size_t
name|uniformBufferSize
init|=
name|state
operator|.
name|getIndexedUniformBufferSize
argument_list|(
name|blockBinding
argument_list|)
decl_stmt|;
if|if
condition|(
name|uniformBufferSize
operator|==
literal|0
condition|)
block|{
comment|// Bind the whole buffer.
name|uniformBufferSize
operator|=
name|uniformBuffer
operator|->
name|getSize
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|uniformBufferSize
operator|<
name|uniformBlock
operator|->
name|dataSize
condition|)
block|{
comment|// undefined behaviour
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"It is undefined behaviour to use a uniform buffer that is too small."
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|// No-op if zero count
return|return
operator|(
name|count
operator|>
literal|0
operator|)
return|;
block|}
DECL|function|ValidateDrawArrays
name|bool
name|ValidateDrawArrays
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLint
name|first
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLsizei
name|primcount
parameter_list|)
block|{
if|if
condition|(
name|first
operator|<
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|State
modifier|&
name|state
init|=
name|context
operator|->
name|getState
argument_list|()
decl_stmt|;
name|gl
operator|::
name|TransformFeedback
modifier|*
name|curTransformFeedback
init|=
name|state
operator|.
name|getCurrentTransformFeedback
argument_list|()
decl_stmt|;
if|if
condition|(
name|curTransformFeedback
operator|&&
name|curTransformFeedback
operator|->
name|isStarted
argument_list|()
operator|&&
operator|!
name|curTransformFeedback
operator|->
name|isPaused
argument_list|()
operator|&&
name|curTransformFeedback
operator|->
name|getDrawMode
argument_list|()
operator|!=
name|mode
condition|)
block|{
comment|// It is an invalid operation to call DrawArrays or DrawArraysInstanced with a draw mode
comment|// that does not match the current transform feedback object's draw mode (if transform feedback
comment|// is active), (3.0.2, section 2.14, pg 86)
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|ValidateDrawBase
argument_list|(
name|context
argument_list|,
name|mode
argument_list|,
name|count
argument_list|,
name|count
argument_list|,
name|primcount
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateDrawArraysInstanced
name|bool
name|ValidateDrawArraysInstanced
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLint
name|first
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLsizei
name|primcount
parameter_list|)
block|{
if|if
condition|(
name|primcount
operator|<
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|ValidateDrawArrays
argument_list|(
name|context
argument_list|,
name|mode
argument_list|,
name|first
argument_list|,
name|count
argument_list|,
name|primcount
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// No-op if zero primitive count
return|return
operator|(
name|primcount
operator|>
literal|0
operator|)
return|;
block|}
DECL|function|ValidateDrawInstancedANGLE
specifier|static
name|bool
name|ValidateDrawInstancedANGLE
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|)
block|{
comment|// Verify there is at least one active attribute with a divisor of zero
specifier|const
name|gl
operator|::
name|State
modifier|&
name|state
init|=
name|context
operator|->
name|getState
argument_list|()
decl_stmt|;
name|gl
operator|::
name|Program
modifier|*
name|program
init|=
name|state
operator|.
name|getProgram
argument_list|()
decl_stmt|;
specifier|const
name|VertexArray
modifier|*
name|vao
init|=
name|state
operator|.
name|getVertexArray
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|attributeIndex
init|=
literal|0
init|;
name|attributeIndex
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|attributeIndex
operator|++
control|)
block|{
specifier|const
name|VertexAttribute
modifier|&
name|attrib
init|=
name|vao
operator|->
name|getVertexAttribute
argument_list|(
name|attributeIndex
argument_list|)
decl_stmt|;
name|bool
name|active
init|=
operator|(
name|program
operator|->
name|getSemanticIndex
argument_list|(
name|attributeIndex
argument_list|)
operator|!=
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|active
operator|&&
name|attrib
operator|.
name|divisor
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"ANGLE_instanced_arrays requires that at least one active attribute"
literal|"has a divisor of zero."
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
DECL|function|ValidateDrawArraysInstancedANGLE
name|bool
name|ValidateDrawArraysInstancedANGLE
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLint
name|first
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLsizei
name|primcount
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ValidateDrawInstancedANGLE
argument_list|(
name|context
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|ValidateDrawArraysInstanced
argument_list|(
name|context
argument_list|,
name|mode
argument_list|,
name|first
argument_list|,
name|count
argument_list|,
name|primcount
argument_list|)
return|;
block|}
DECL|function|ValidateDrawElements
name|bool
name|ValidateDrawElements
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|GLsizei
name|primcount
parameter_list|,
name|rx
operator|::
name|RangeUI
modifier|*
name|indexRangeOut
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_UNSIGNED_BYTE
case|:
case|case
name|GL_UNSIGNED_SHORT
case|:
break|break;
case|case
name|GL_UNSIGNED_INT
case|:
if|if
condition|(
operator|!
name|context
operator|->
name|getExtensions
argument_list|()
operator|.
name|elementIndexUint
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|State
modifier|&
name|state
init|=
name|context
operator|->
name|getState
argument_list|()
decl_stmt|;
name|gl
operator|::
name|TransformFeedback
modifier|*
name|curTransformFeedback
init|=
name|state
operator|.
name|getCurrentTransformFeedback
argument_list|()
decl_stmt|;
if|if
condition|(
name|curTransformFeedback
operator|&&
name|curTransformFeedback
operator|->
name|isStarted
argument_list|()
operator|&&
operator|!
name|curTransformFeedback
operator|->
name|isPaused
argument_list|()
condition|)
block|{
comment|// It is an invalid operation to call DrawElements, DrawRangeElements or DrawElementsInstanced
comment|// while transform feedback is active, (3.0.2, section 2.14, pg 86)
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Check for mapped buffers
if|if
condition|(
name|state
operator|.
name|hasMappedBuffer
argument_list|(
name|GL_ELEMENT_ARRAY_BUFFER
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|gl
operator|::
name|VertexArray
modifier|*
name|vao
init|=
name|state
operator|.
name|getVertexArray
argument_list|()
decl_stmt|;
name|gl
operator|::
name|Buffer
modifier|*
name|elementArrayBuffer
init|=
name|vao
operator|->
name|getElementArrayBuffer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|indices
operator|&&
operator|!
name|elementArrayBuffer
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|elementArrayBuffer
condition|)
block|{
specifier|const
name|gl
operator|::
name|Type
modifier|&
name|typeInfo
init|=
name|gl
operator|::
name|GetTypeInfo
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|GLint64
name|offset
init|=
cast|reinterpret_cast
argument_list|<
name|GLint64
argument_list|>
argument_list|(
name|indices
argument_list|)
decl_stmt|;
name|GLint64
name|byteCount
init|=
cast|static_cast
argument_list|<
name|GLint64
argument_list|>
argument_list|(
name|typeInfo
operator|.
name|bytes
argument_list|)
operator|*
cast|static_cast
argument_list|<
name|GLint64
argument_list|>
argument_list|(
name|count
argument_list|)
operator|+
name|offset
decl_stmt|;
comment|// check for integer overflows
if|if
condition|(
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|count
argument_list|)
operator|>
operator|(
name|std
operator|::
name|numeric_limits
argument_list|<
name|GLuint
argument_list|>
operator|::
name|max
argument_list|()
operator|/
name|typeInfo
operator|.
name|bytes
operator|)
operator|||
name|byteCount
operator|>
cast|static_cast
argument_list|<
name|GLint64
argument_list|>
argument_list|(
name|std
operator|::
name|numeric_limits
argument_list|<
name|GLuint
argument_list|>
operator|::
name|max
argument_list|()
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Check for reading past the end of the bound buffer object
if|if
condition|(
name|byteCount
operator|>
name|elementArrayBuffer
operator|->
name|getSize
argument_list|()
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|indices
condition|)
block|{
comment|// Catch this programming error here
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Use max index to validate if our vertex buffers are large enough for the pull.
comment|// TODO: offer fast path, with disabled index validation.
comment|// TODO: also disable index checking on back-ends that are robust to out-of-range accesses.
if|if
condition|(
name|elementArrayBuffer
condition|)
block|{
name|uintptr_t
name|offset
init|=
cast|reinterpret_cast
argument_list|<
name|uintptr_t
argument_list|>
argument_list|(
name|indices
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|elementArrayBuffer
operator|->
name|getIndexRangeCache
argument_list|()
operator|->
name|findRange
argument_list|(
name|type
argument_list|,
name|offset
argument_list|,
name|count
argument_list|,
name|indexRangeOut
argument_list|)
condition|)
block|{
name|rx
operator|::
name|BufferImpl
modifier|*
name|bufferImpl
init|=
name|elementArrayBuffer
operator|->
name|getImplementation
argument_list|()
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|dataPointer
init|=
name|NULL
decl_stmt|;
name|Error
name|error
init|=
name|bufferImpl
operator|->
name|getData
argument_list|(
operator|&
name|dataPointer
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|error
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|uint8_t
modifier|*
name|offsetPointer
init|=
name|dataPointer
operator|+
name|offset
decl_stmt|;
operator|*
name|indexRangeOut
operator|=
name|rx
operator|::
name|IndexRangeCache
operator|::
name|ComputeRange
argument_list|(
name|type
argument_list|,
name|offsetPointer
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|elementArrayBuffer
operator|->
name|getIndexRangeCache
argument_list|()
operator|->
name|addRange
argument_list|(
name|type
argument_list|,
name|offset
argument_list|,
name|count
argument_list|,
operator|*
name|indexRangeOut
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|indexRangeOut
operator|=
name|rx
operator|::
name|IndexRangeCache
operator|::
name|ComputeRange
argument_list|(
name|type
argument_list|,
name|indices
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ValidateDrawBase
argument_list|(
name|context
argument_list|,
name|mode
argument_list|,
name|count
argument_list|,
cast|static_cast
argument_list|<
name|GLsizei
argument_list|>
argument_list|(
name|indexRangeOut
operator|->
name|end
argument_list|)
argument_list|,
name|primcount
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateDrawElementsInstanced
name|bool
name|ValidateDrawElementsInstanced
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|GLsizei
name|primcount
parameter_list|,
name|rx
operator|::
name|RangeUI
modifier|*
name|indexRangeOut
parameter_list|)
block|{
if|if
condition|(
name|primcount
operator|<
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|ValidateDrawElements
argument_list|(
name|context
argument_list|,
name|mode
argument_list|,
name|count
argument_list|,
name|type
argument_list|,
name|indices
argument_list|,
name|primcount
argument_list|,
name|indexRangeOut
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// No-op zero primitive count
return|return
operator|(
name|primcount
operator|>
literal|0
operator|)
return|;
block|}
DECL|function|ValidateDrawElementsInstancedANGLE
name|bool
name|ValidateDrawElementsInstancedANGLE
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|GLsizei
name|primcount
parameter_list|,
name|rx
operator|::
name|RangeUI
modifier|*
name|indexRangeOut
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ValidateDrawInstancedANGLE
argument_list|(
name|context
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|ValidateDrawElementsInstanced
argument_list|(
name|context
argument_list|,
name|mode
argument_list|,
name|count
argument_list|,
name|type
argument_list|,
name|indices
argument_list|,
name|primcount
argument_list|,
name|indexRangeOut
argument_list|)
return|;
block|}
DECL|function|ValidateFramebufferTextureBase
name|bool
name|ValidateFramebufferTextureBase
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLenum
name|attachment
parameter_list|,
name|GLuint
name|texture
parameter_list|,
name|GLint
name|level
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ValidFramebufferTarget
argument_list|(
name|target
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|ValidateAttachmentTarget
argument_list|(
name|context
argument_list|,
name|attachment
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|texture
operator|!=
literal|0
condition|)
block|{
name|gl
operator|::
name|Texture
modifier|*
name|tex
init|=
name|context
operator|->
name|getTexture
argument_list|(
name|texture
argument_list|)
decl_stmt|;
if|if
condition|(
name|tex
operator|==
name|NULL
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|level
operator|<
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
specifier|const
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getTargetFramebuffer
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|GLuint
name|framebufferHandle
init|=
name|context
operator|->
name|getState
argument_list|()
operator|.
name|getTargetFramebuffer
argument_list|(
name|target
argument_list|)
operator|->
name|id
argument_list|()
decl_stmt|;
if|if
condition|(
name|framebufferHandle
operator|==
literal|0
operator|||
operator|!
name|framebuffer
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateFramebufferTexture2D
name|bool
name|ValidateFramebufferTexture2D
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLenum
name|attachment
parameter_list|,
name|GLenum
name|textarget
parameter_list|,
name|GLuint
name|texture
parameter_list|,
name|GLint
name|level
parameter_list|)
block|{
comment|// Attachments are required to be bound to level 0 in ES2
if|if
condition|(
name|context
operator|->
name|getClientVersion
argument_list|()
operator|<
literal|3
operator|&&
name|level
operator|!=
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|ValidateFramebufferTextureBase
argument_list|(
name|context
argument_list|,
name|target
argument_list|,
name|attachment
argument_list|,
name|texture
argument_list|,
name|level
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|texture
operator|!=
literal|0
condition|)
block|{
name|gl
operator|::
name|Texture
modifier|*
name|tex
init|=
name|context
operator|->
name|getTexture
argument_list|(
name|texture
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|tex
argument_list|)
expr_stmt|;
specifier|const
name|gl
operator|::
name|Caps
modifier|&
name|caps
init|=
name|context
operator|->
name|getCaps
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|textarget
condition|)
block|{
case|case
name|GL_TEXTURE_2D
case|:
block|{
if|if
condition|(
name|level
operator|>
name|gl
operator|::
name|log2
argument_list|(
name|caps
operator|.
name|max2DTextureSize
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|tex
operator|->
name|getTarget
argument_list|()
operator|!=
name|GL_TEXTURE_2D
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
break|break;
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_X
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Y
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Z
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
case|:
block|{
if|if
condition|(
name|level
operator|>
name|gl
operator|::
name|log2
argument_list|(
name|caps
operator|.
name|maxCubeMapTextureSize
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|tex
operator|->
name|getTarget
argument_list|()
operator|!=
name|GL_TEXTURE_CUBE_MAP
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
break|break;
default|default:
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|gl
operator|::
name|InternalFormat
modifier|&
name|internalFormatInfo
init|=
name|gl
operator|::
name|GetInternalFormatInfo
argument_list|(
name|tex
operator|->
name|getInternalFormat
argument_list|(
name|textarget
argument_list|,
name|level
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|internalFormatInfo
operator|.
name|compressed
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateGetUniformBase
name|bool
name|ValidateGetUniformBase
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLuint
name|program
parameter_list|,
name|GLint
name|location
parameter_list|)
block|{
if|if
condition|(
name|program
operator|==
literal|0
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|ValidProgram
argument_list|(
name|context
argument_list|,
name|program
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|gl
operator|::
name|Program
modifier|*
name|programObject
init|=
name|context
operator|->
name|getProgram
argument_list|(
name|program
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|programObject
operator|||
operator|!
name|programObject
operator|->
name|isLinked
argument_list|()
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|programObject
operator|->
name|isValidUniformLocation
argument_list|(
name|location
argument_list|)
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateGetUniformfv
name|bool
name|ValidateGetUniformfv
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLuint
name|program
parameter_list|,
name|GLint
name|location
parameter_list|,
name|GLfloat
modifier|*
name|params
parameter_list|)
block|{
return|return
name|ValidateGetUniformBase
argument_list|(
name|context
argument_list|,
name|program
argument_list|,
name|location
argument_list|)
return|;
block|}
DECL|function|ValidateGetUniformiv
name|bool
name|ValidateGetUniformiv
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLuint
name|program
parameter_list|,
name|GLint
name|location
parameter_list|,
name|GLint
modifier|*
name|params
parameter_list|)
block|{
return|return
name|ValidateGetUniformBase
argument_list|(
name|context
argument_list|,
name|program
argument_list|,
name|location
argument_list|)
return|;
block|}
DECL|function|ValidateSizedGetUniform
specifier|static
name|bool
name|ValidateSizedGetUniform
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLuint
name|program
parameter_list|,
name|GLint
name|location
parameter_list|,
name|GLsizei
name|bufSize
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ValidateGetUniformBase
argument_list|(
name|context
argument_list|,
name|program
argument_list|,
name|location
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|gl
operator|::
name|Program
modifier|*
name|programObject
init|=
name|context
operator|->
name|getProgram
argument_list|(
name|program
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|programObject
argument_list|)
expr_stmt|;
comment|// sized queries -- ensure the provided buffer is large enough
name|LinkedUniform
modifier|*
name|uniform
init|=
name|programObject
operator|->
name|getUniformByLocation
argument_list|(
name|location
argument_list|)
decl_stmt|;
name|size_t
name|requiredBytes
init|=
name|VariableExternalSize
argument_list|(
name|uniform
operator|->
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
cast|static_cast
argument_list|<
name|size_t
argument_list|>
argument_list|(
name|bufSize
argument_list|)
operator|<
name|requiredBytes
condition|)
block|{
name|context
operator|->
name|recordError
argument_list|(
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|ValidateGetnUniformfvEXT
name|bool
name|ValidateGetnUniformfvEXT
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLuint
name|program
parameter_list|,
name|GLint
name|location
parameter_list|,
name|GLsizei
name|bufSize
parameter_list|,
name|GLfloat
modifier|*
name|params
parameter_list|)
block|{
return|return
name|ValidateSizedGetUniform
argument_list|(
name|context
argument_list|,
name|program
argument_list|,
name|location
argument_list|,
name|bufSize
argument_list|)
return|;
block|}
DECL|function|ValidateGetnUniformivEXT
name|bool
name|ValidateGetnUniformivEXT
parameter_list|(
name|Context
modifier|*
name|context
parameter_list|,
name|GLuint
name|program
parameter_list|,
name|GLint
name|location
parameter_list|,
name|GLsizei
name|bufSize
parameter_list|,
name|GLint
modifier|*
name|params
parameter_list|)
block|{
return|return
name|ValidateSizedGetUniform
argument_list|(
name|context
argument_list|,
name|program
argument_list|,
name|location
argument_list|,
name|bufSize
argument_list|)
return|;
block|}
block|}
end_namespace
end_unit
