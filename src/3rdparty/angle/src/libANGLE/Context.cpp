begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Context.cpp: Implements the gl::Context class, managing all GL state and performing
end_comment
begin_comment
comment|// rendering operations. It is the GLES2 specific implementation of EGLContext.
end_comment
begin_include
include|#
directive|include
file|"libANGLE/Context.h"
end_include
begin_include
include|#
directive|include
file|<iterator>
end_include
begin_include
include|#
directive|include
file|<sstream>
end_include
begin_include
include|#
directive|include
file|"common/platform.h"
end_include
begin_include
include|#
directive|include
file|"common/utilities.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Buffer.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Compiler.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Display.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Fence.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Framebuffer.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/FramebufferAttachment.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Program.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Query.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Renderbuffer.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/ResourceManager.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Sampler.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Surface.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Texture.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/TransformFeedback.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/VertexArray.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/formatutils.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/validationES.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/Renderer.h"
end_include
begin_namespace
DECL|namespace|gl
namespace|namespace
name|gl
block|{
DECL|function|Context
name|Context
operator|::
name|Context
parameter_list|(
specifier|const
name|egl
operator|::
name|Config
modifier|*
name|config
parameter_list|,
name|int
name|clientVersion
parameter_list|,
specifier|const
name|Context
modifier|*
name|shareContext
parameter_list|,
name|rx
operator|::
name|Renderer
modifier|*
name|renderer
parameter_list|,
name|bool
name|notifyResets
parameter_list|,
name|bool
name|robustAccess
parameter_list|)
member_init_list|:
name|mRenderer
argument_list|(
name|renderer
argument_list|)
block|{
name|ASSERT
argument_list|(
name|robustAccess
operator|==
literal|false
argument_list|)
expr_stmt|;
comment|// Unimplemented
name|initCaps
argument_list|(
name|clientVersion
argument_list|)
expr_stmt|;
name|mState
operator|.
name|initialize
argument_list|(
name|mCaps
argument_list|,
name|clientVersion
argument_list|)
expr_stmt|;
name|mClientVersion
operator|=
name|clientVersion
expr_stmt|;
name|mConfigID
operator|=
name|config
operator|->
name|configID
expr_stmt|;
name|mClientType
operator|=
name|EGL_OPENGL_ES_API
expr_stmt|;
name|mRenderBuffer
operator|=
name|EGL_NONE
expr_stmt|;
name|mFenceNVHandleAllocator
operator|.
name|setBaseHandle
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|shareContext
operator|!=
name|NULL
condition|)
block|{
name|mResourceManager
operator|=
name|shareContext
operator|->
name|mResourceManager
expr_stmt|;
name|mResourceManager
operator|->
name|addRef
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|mResourceManager
operator|=
operator|new
name|ResourceManager
argument_list|(
name|mRenderer
argument_list|)
expr_stmt|;
block|}
comment|// [OpenGL ES 2.0.24] section 3.7 page 83:
comment|// In the initial state, TEXTURE_2D and TEXTURE_CUBE_MAP have twodimensional
comment|// and cube map texture state vectors respectively associated with them.
comment|// In order that access to these initial textures not be lost, they are treated as texture
comment|// objects all of whose names are 0.
name|Texture
modifier|*
name|zeroTexture2D
init|=
operator|new
name|Texture
argument_list|(
name|mRenderer
operator|->
name|createTexture
argument_list|(
name|GL_TEXTURE_2D
argument_list|)
argument_list|,
literal|0
argument_list|,
name|GL_TEXTURE_2D
argument_list|)
decl_stmt|;
name|mZeroTextures
index|[
name|GL_TEXTURE_2D
index|]
operator|.
name|set
argument_list|(
name|zeroTexture2D
argument_list|)
expr_stmt|;
name|Texture
modifier|*
name|zeroTextureCube
init|=
operator|new
name|Texture
argument_list|(
name|mRenderer
operator|->
name|createTexture
argument_list|(
name|GL_TEXTURE_CUBE_MAP
argument_list|)
argument_list|,
literal|0
argument_list|,
name|GL_TEXTURE_CUBE_MAP
argument_list|)
decl_stmt|;
name|mZeroTextures
index|[
name|GL_TEXTURE_CUBE_MAP
index|]
operator|.
name|set
argument_list|(
name|zeroTextureCube
argument_list|)
expr_stmt|;
if|if
condition|(
name|mClientVersion
operator|>=
literal|3
condition|)
block|{
comment|// TODO: These could also be enabled via extension
name|Texture
modifier|*
name|zeroTexture3D
init|=
operator|new
name|Texture
argument_list|(
name|mRenderer
operator|->
name|createTexture
argument_list|(
name|GL_TEXTURE_3D
argument_list|)
argument_list|,
literal|0
argument_list|,
name|GL_TEXTURE_3D
argument_list|)
decl_stmt|;
name|mZeroTextures
index|[
name|GL_TEXTURE_3D
index|]
operator|.
name|set
argument_list|(
name|zeroTexture3D
argument_list|)
expr_stmt|;
name|Texture
modifier|*
name|zeroTexture2DArray
init|=
operator|new
name|Texture
argument_list|(
name|mRenderer
operator|->
name|createTexture
argument_list|(
name|GL_TEXTURE_2D_ARRAY
argument_list|)
argument_list|,
literal|0
argument_list|,
name|GL_TEXTURE_2D_ARRAY
argument_list|)
decl_stmt|;
name|mZeroTextures
index|[
name|GL_TEXTURE_2D_ARRAY
index|]
operator|.
name|set
argument_list|(
name|zeroTexture2DArray
argument_list|)
expr_stmt|;
block|}
name|mState
operator|.
name|initializeZeroTextures
argument_list|(
name|mZeroTextures
argument_list|)
expr_stmt|;
name|bindVertexArray
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindArrayBuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindElementArrayBuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindReadFramebuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindDrawFramebuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindRenderbuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindGenericUniformBuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mCaps
operator|.
name|maxCombinedUniformBlocks
condition|;
name|i
operator|++
control|)
block|{
name|bindIndexedUniformBuffer
argument_list|(
literal|0
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|bindGenericTransformFeedbackBuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mCaps
operator|.
name|maxTransformFeedbackSeparateAttributes
condition|;
name|i
operator|++
control|)
block|{
name|bindIndexedTransformFeedbackBuffer
argument_list|(
literal|0
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|bindCopyReadBuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindCopyWriteBuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindPixelPackBuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindPixelUnpackBuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// [OpenGL ES 3.0.2] section 2.14.1 pg 85:
comment|// In the initial state, a default transform feedback object is bound and treated as
comment|// a transform feedback object with a name of zero. That object is bound any time
comment|// BindTransformFeedback is called with id of zero
name|mTransformFeedbackZero
operator|.
name|set
argument_list|(
operator|new
name|TransformFeedback
argument_list|(
name|mRenderer
operator|->
name|createTransformFeedback
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|bindTransformFeedback
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|mHasBeenCurrent
operator|=
literal|false
expr_stmt|;
name|mContextLost
operator|=
literal|false
expr_stmt|;
name|mResetStatus
operator|=
name|GL_NO_ERROR
expr_stmt|;
name|mResetStrategy
operator|=
operator|(
name|notifyResets
condition|?
name|GL_LOSE_CONTEXT_ON_RESET_EXT
else|:
name|GL_NO_RESET_NOTIFICATION_EXT
operator|)
expr_stmt|;
name|mRobustAccess
operator|=
name|robustAccess
expr_stmt|;
name|mCompiler
operator|=
operator|new
name|Compiler
argument_list|(
name|mRenderer
operator|->
name|createCompiler
argument_list|(
name|getData
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|~Context
name|Context
operator|::
name|~
name|Context
parameter_list|()
block|{
name|mState
operator|.
name|reset
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|mFramebufferMap
operator|.
name|empty
argument_list|()
condition|)
block|{
comment|// Delete the framebuffer in reverse order to destroy the framebuffer zero last.
name|deleteFramebuffer
argument_list|(
name|mFramebufferMap
operator|.
name|rbegin
argument_list|()
operator|->
name|first
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|mFenceNVMap
operator|.
name|empty
argument_list|()
condition|)
block|{
name|deleteFenceNV
argument_list|(
name|mFenceNVMap
operator|.
name|begin
argument_list|()
operator|->
name|first
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|mQueryMap
operator|.
name|empty
argument_list|()
condition|)
block|{
name|deleteQuery
argument_list|(
name|mQueryMap
operator|.
name|begin
argument_list|()
operator|->
name|first
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|mVertexArrayMap
operator|.
name|empty
argument_list|()
condition|)
block|{
name|deleteVertexArray
argument_list|(
name|mVertexArrayMap
operator|.
name|begin
argument_list|()
operator|->
name|first
argument_list|)
expr_stmt|;
block|}
name|mTransformFeedbackZero
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|mTransformFeedbackMap
operator|.
name|empty
argument_list|()
condition|)
block|{
name|deleteTransformFeedback
argument_list|(
name|mTransformFeedbackMap
operator|.
name|begin
argument_list|()
operator|->
name|first
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|auto
name|it
init|=
name|mZeroTextures
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|mZeroTextures
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|it
operator|->
name|second
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
name|mZeroTextures
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|mResourceManager
condition|)
block|{
name|mResourceManager
operator|->
name|release
argument_list|()
expr_stmt|;
block|}
name|SafeDelete
argument_list|(
name|mCompiler
argument_list|)
expr_stmt|;
block|}
DECL|function|makeCurrent
name|void
name|Context
operator|::
name|makeCurrent
parameter_list|(
name|egl
operator|::
name|Surface
modifier|*
name|surface
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mHasBeenCurrent
condition|)
block|{
name|initRendererString
argument_list|()
expr_stmt|;
name|initExtensionStrings
argument_list|()
expr_stmt|;
name|mState
operator|.
name|setViewportParams
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|surface
operator|->
name|getWidth
argument_list|()
argument_list|,
name|surface
operator|->
name|getHeight
argument_list|()
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setScissorParams
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|surface
operator|->
name|getWidth
argument_list|()
argument_list|,
name|surface
operator|->
name|getHeight
argument_list|()
argument_list|)
expr_stmt|;
name|mHasBeenCurrent
operator|=
literal|true
expr_stmt|;
block|}
comment|// TODO(jmadill): do not allocate new pointers here
name|Framebuffer
modifier|*
name|framebufferZero
init|=
operator|new
name|DefaultFramebuffer
argument_list|(
name|mCaps
argument_list|,
name|mRenderer
argument_list|,
name|surface
argument_list|)
decl_stmt|;
name|setFramebufferZero
argument_list|(
name|framebufferZero
argument_list|)
expr_stmt|;
name|mRenderBuffer
operator|=
name|surface
operator|->
name|getRenderBuffer
argument_list|()
expr_stmt|;
block|}
comment|// NOTE: this function should not assume that this context is current!
DECL|function|markContextLost
name|void
name|Context
operator|::
name|markContextLost
parameter_list|()
block|{
if|if
condition|(
name|mResetStrategy
operator|==
name|GL_LOSE_CONTEXT_ON_RESET_EXT
condition|)
name|mResetStatus
operator|=
name|GL_UNKNOWN_CONTEXT_RESET_EXT
expr_stmt|;
name|mContextLost
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|isContextLost
name|bool
name|Context
operator|::
name|isContextLost
parameter_list|()
block|{
return|return
name|mContextLost
return|;
block|}
DECL|function|createBuffer
name|GLuint
name|Context
operator|::
name|createBuffer
parameter_list|()
block|{
return|return
name|mResourceManager
operator|->
name|createBuffer
argument_list|()
return|;
block|}
DECL|function|createProgram
name|GLuint
name|Context
operator|::
name|createProgram
parameter_list|()
block|{
return|return
name|mResourceManager
operator|->
name|createProgram
argument_list|()
return|;
block|}
DECL|function|createShader
name|GLuint
name|Context
operator|::
name|createShader
parameter_list|(
name|GLenum
name|type
parameter_list|)
block|{
return|return
name|mResourceManager
operator|->
name|createShader
argument_list|(
name|getData
argument_list|()
argument_list|,
name|type
argument_list|)
return|;
block|}
DECL|function|createTexture
name|GLuint
name|Context
operator|::
name|createTexture
parameter_list|()
block|{
return|return
name|mResourceManager
operator|->
name|createTexture
argument_list|()
return|;
block|}
DECL|function|createRenderbuffer
name|GLuint
name|Context
operator|::
name|createRenderbuffer
parameter_list|()
block|{
return|return
name|mResourceManager
operator|->
name|createRenderbuffer
argument_list|()
return|;
block|}
DECL|function|createFenceSync
name|GLsync
name|Context
operator|::
name|createFenceSync
parameter_list|()
block|{
name|GLuint
name|handle
init|=
name|mResourceManager
operator|->
name|createFenceSync
argument_list|()
decl_stmt|;
return|return
cast|reinterpret_cast
argument_list|<
name|GLsync
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
name|uintptr_t
argument_list|>
argument_list|(
name|handle
argument_list|)
argument_list|)
return|;
block|}
DECL|function|createVertexArray
name|GLuint
name|Context
operator|::
name|createVertexArray
parameter_list|()
block|{
name|GLuint
name|handle
init|=
name|mVertexArrayHandleAllocator
operator|.
name|allocate
argument_list|()
decl_stmt|;
comment|// Although the spec states VAO state is not initialized until the object is bound,
comment|// we create it immediately. The resulting behaviour is transparent to the application,
comment|// since it's not currently possible to access the state until the object is bound.
name|VertexArray
modifier|*
name|vertexArray
init|=
operator|new
name|VertexArray
argument_list|(
name|mRenderer
operator|->
name|createVertexArray
argument_list|()
argument_list|,
name|handle
argument_list|,
name|MAX_VERTEX_ATTRIBS
argument_list|)
decl_stmt|;
name|mVertexArrayMap
index|[
name|handle
index|]
operator|=
name|vertexArray
expr_stmt|;
return|return
name|handle
return|;
block|}
DECL|function|createSampler
name|GLuint
name|Context
operator|::
name|createSampler
parameter_list|()
block|{
return|return
name|mResourceManager
operator|->
name|createSampler
argument_list|()
return|;
block|}
DECL|function|createTransformFeedback
name|GLuint
name|Context
operator|::
name|createTransformFeedback
parameter_list|()
block|{
name|GLuint
name|handle
init|=
name|mTransformFeedbackAllocator
operator|.
name|allocate
argument_list|()
decl_stmt|;
name|TransformFeedback
modifier|*
name|transformFeedback
init|=
operator|new
name|TransformFeedback
argument_list|(
name|mRenderer
operator|->
name|createTransformFeedback
argument_list|()
argument_list|,
name|handle
argument_list|)
decl_stmt|;
name|transformFeedback
operator|->
name|addRef
argument_list|()
expr_stmt|;
name|mTransformFeedbackMap
index|[
name|handle
index|]
operator|=
name|transformFeedback
expr_stmt|;
return|return
name|handle
return|;
block|}
comment|// Returns an unused framebuffer name
DECL|function|createFramebuffer
name|GLuint
name|Context
operator|::
name|createFramebuffer
parameter_list|()
block|{
name|GLuint
name|handle
init|=
name|mFramebufferHandleAllocator
operator|.
name|allocate
argument_list|()
decl_stmt|;
name|mFramebufferMap
index|[
name|handle
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|handle
return|;
block|}
DECL|function|createFenceNV
name|GLuint
name|Context
operator|::
name|createFenceNV
parameter_list|()
block|{
name|GLuint
name|handle
init|=
name|mFenceNVHandleAllocator
operator|.
name|allocate
argument_list|()
decl_stmt|;
name|mFenceNVMap
index|[
name|handle
index|]
operator|=
operator|new
name|FenceNV
argument_list|(
name|mRenderer
operator|->
name|createFenceNV
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|handle
return|;
block|}
comment|// Returns an unused query name
DECL|function|createQuery
name|GLuint
name|Context
operator|::
name|createQuery
parameter_list|()
block|{
name|GLuint
name|handle
init|=
name|mQueryHandleAllocator
operator|.
name|allocate
argument_list|()
decl_stmt|;
name|mQueryMap
index|[
name|handle
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|handle
return|;
block|}
DECL|function|deleteBuffer
name|void
name|Context
operator|::
name|deleteBuffer
parameter_list|(
name|GLuint
name|buffer
parameter_list|)
block|{
if|if
condition|(
name|mResourceManager
operator|->
name|getBuffer
argument_list|(
name|buffer
argument_list|)
condition|)
block|{
name|detachBuffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
name|mResourceManager
operator|->
name|deleteBuffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
DECL|function|deleteShader
name|void
name|Context
operator|::
name|deleteShader
parameter_list|(
name|GLuint
name|shader
parameter_list|)
block|{
name|mResourceManager
operator|->
name|deleteShader
argument_list|(
name|shader
argument_list|)
expr_stmt|;
block|}
DECL|function|deleteProgram
name|void
name|Context
operator|::
name|deleteProgram
parameter_list|(
name|GLuint
name|program
parameter_list|)
block|{
name|mResourceManager
operator|->
name|deleteProgram
argument_list|(
name|program
argument_list|)
expr_stmt|;
block|}
DECL|function|deleteTexture
name|void
name|Context
operator|::
name|deleteTexture
parameter_list|(
name|GLuint
name|texture
parameter_list|)
block|{
if|if
condition|(
name|mResourceManager
operator|->
name|getTexture
argument_list|(
name|texture
argument_list|)
condition|)
block|{
name|detachTexture
argument_list|(
name|texture
argument_list|)
expr_stmt|;
block|}
name|mResourceManager
operator|->
name|deleteTexture
argument_list|(
name|texture
argument_list|)
expr_stmt|;
block|}
DECL|function|deleteRenderbuffer
name|void
name|Context
operator|::
name|deleteRenderbuffer
parameter_list|(
name|GLuint
name|renderbuffer
parameter_list|)
block|{
if|if
condition|(
name|mResourceManager
operator|->
name|getRenderbuffer
argument_list|(
name|renderbuffer
argument_list|)
condition|)
block|{
name|detachRenderbuffer
argument_list|(
name|renderbuffer
argument_list|)
expr_stmt|;
block|}
name|mResourceManager
operator|->
name|deleteRenderbuffer
argument_list|(
name|renderbuffer
argument_list|)
expr_stmt|;
block|}
DECL|function|deleteFenceSync
name|void
name|Context
operator|::
name|deleteFenceSync
parameter_list|(
name|GLsync
name|fenceSync
parameter_list|)
block|{
comment|// The spec specifies the underlying Fence object is not deleted until all current
comment|// wait commands finish. However, since the name becomes invalid, we cannot query the fence,
comment|// and since our API is currently designed for being called from a single thread, we can delete
comment|// the fence immediately.
name|mResourceManager
operator|->
name|deleteFenceSync
argument_list|(
cast|reinterpret_cast
argument_list|<
name|uintptr_t
argument_list|>
argument_list|(
name|fenceSync
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|deleteVertexArray
name|void
name|Context
operator|::
name|deleteVertexArray
parameter_list|(
name|GLuint
name|vertexArray
parameter_list|)
block|{
name|auto
name|vertexArrayObject
init|=
name|mVertexArrayMap
operator|.
name|find
argument_list|(
name|vertexArray
argument_list|)
decl_stmt|;
if|if
condition|(
name|vertexArrayObject
operator|!=
name|mVertexArrayMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|detachVertexArray
argument_list|(
name|vertexArray
argument_list|)
expr_stmt|;
name|mVertexArrayHandleAllocator
operator|.
name|release
argument_list|(
name|vertexArrayObject
operator|->
name|first
argument_list|)
expr_stmt|;
operator|delete
name|vertexArrayObject
operator|->
name|second
expr_stmt|;
name|mVertexArrayMap
operator|.
name|erase
argument_list|(
name|vertexArrayObject
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|deleteSampler
name|void
name|Context
operator|::
name|deleteSampler
parameter_list|(
name|GLuint
name|sampler
parameter_list|)
block|{
if|if
condition|(
name|mResourceManager
operator|->
name|getSampler
argument_list|(
name|sampler
argument_list|)
condition|)
block|{
name|detachSampler
argument_list|(
name|sampler
argument_list|)
expr_stmt|;
block|}
name|mResourceManager
operator|->
name|deleteSampler
argument_list|(
name|sampler
argument_list|)
expr_stmt|;
block|}
DECL|function|deleteTransformFeedback
name|void
name|Context
operator|::
name|deleteTransformFeedback
parameter_list|(
name|GLuint
name|transformFeedback
parameter_list|)
block|{
name|auto
name|iter
init|=
name|mTransformFeedbackMap
operator|.
name|find
argument_list|(
name|transformFeedback
argument_list|)
decl_stmt|;
if|if
condition|(
name|iter
operator|!=
name|mTransformFeedbackMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|detachTransformFeedback
argument_list|(
name|transformFeedback
argument_list|)
expr_stmt|;
name|mTransformFeedbackAllocator
operator|.
name|release
argument_list|(
name|transformFeedback
argument_list|)
expr_stmt|;
name|iter
operator|->
name|second
operator|->
name|release
argument_list|()
expr_stmt|;
name|mTransformFeedbackMap
operator|.
name|erase
argument_list|(
name|iter
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|deleteFramebuffer
name|void
name|Context
operator|::
name|deleteFramebuffer
parameter_list|(
name|GLuint
name|framebuffer
parameter_list|)
block|{
name|FramebufferMap
operator|::
name|iterator
name|framebufferObject
init|=
name|mFramebufferMap
operator|.
name|find
argument_list|(
name|framebuffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|framebufferObject
operator|!=
name|mFramebufferMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|detachFramebuffer
argument_list|(
name|framebuffer
argument_list|)
expr_stmt|;
name|mFramebufferHandleAllocator
operator|.
name|release
argument_list|(
name|framebufferObject
operator|->
name|first
argument_list|)
expr_stmt|;
operator|delete
name|framebufferObject
operator|->
name|second
expr_stmt|;
name|mFramebufferMap
operator|.
name|erase
argument_list|(
name|framebufferObject
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|deleteFenceNV
name|void
name|Context
operator|::
name|deleteFenceNV
parameter_list|(
name|GLuint
name|fence
parameter_list|)
block|{
name|FenceNVMap
operator|::
name|iterator
name|fenceObject
init|=
name|mFenceNVMap
operator|.
name|find
argument_list|(
name|fence
argument_list|)
decl_stmt|;
if|if
condition|(
name|fenceObject
operator|!=
name|mFenceNVMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|mFenceNVHandleAllocator
operator|.
name|release
argument_list|(
name|fenceObject
operator|->
name|first
argument_list|)
expr_stmt|;
operator|delete
name|fenceObject
operator|->
name|second
expr_stmt|;
name|mFenceNVMap
operator|.
name|erase
argument_list|(
name|fenceObject
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|deleteQuery
name|void
name|Context
operator|::
name|deleteQuery
parameter_list|(
name|GLuint
name|query
parameter_list|)
block|{
name|QueryMap
operator|::
name|iterator
name|queryObject
init|=
name|mQueryMap
operator|.
name|find
argument_list|(
name|query
argument_list|)
decl_stmt|;
if|if
condition|(
name|queryObject
operator|!=
name|mQueryMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|mQueryHandleAllocator
operator|.
name|release
argument_list|(
name|queryObject
operator|->
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|queryObject
operator|->
name|second
condition|)
block|{
name|queryObject
operator|->
name|second
operator|->
name|release
argument_list|()
expr_stmt|;
block|}
name|mQueryMap
operator|.
name|erase
argument_list|(
name|queryObject
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|getBuffer
name|Buffer
modifier|*
name|Context
operator|::
name|getBuffer
parameter_list|(
name|GLuint
name|handle
parameter_list|)
block|{
return|return
name|mResourceManager
operator|->
name|getBuffer
argument_list|(
name|handle
argument_list|)
return|;
block|}
DECL|function|getShader
name|Shader
modifier|*
name|Context
operator|::
name|getShader
parameter_list|(
name|GLuint
name|handle
parameter_list|)
specifier|const
block|{
return|return
name|mResourceManager
operator|->
name|getShader
argument_list|(
name|handle
argument_list|)
return|;
block|}
DECL|function|getProgram
name|Program
modifier|*
name|Context
operator|::
name|getProgram
parameter_list|(
name|GLuint
name|handle
parameter_list|)
specifier|const
block|{
return|return
name|mResourceManager
operator|->
name|getProgram
argument_list|(
name|handle
argument_list|)
return|;
block|}
DECL|function|getTexture
name|Texture
modifier|*
name|Context
operator|::
name|getTexture
parameter_list|(
name|GLuint
name|handle
parameter_list|)
specifier|const
block|{
return|return
name|mResourceManager
operator|->
name|getTexture
argument_list|(
name|handle
argument_list|)
return|;
block|}
DECL|function|getRenderbuffer
name|Renderbuffer
modifier|*
name|Context
operator|::
name|getRenderbuffer
parameter_list|(
name|GLuint
name|handle
parameter_list|)
block|{
return|return
name|mResourceManager
operator|->
name|getRenderbuffer
argument_list|(
name|handle
argument_list|)
return|;
block|}
DECL|function|getFenceSync
name|FenceSync
modifier|*
name|Context
operator|::
name|getFenceSync
parameter_list|(
name|GLsync
name|handle
parameter_list|)
specifier|const
block|{
return|return
name|mResourceManager
operator|->
name|getFenceSync
argument_list|(
cast|reinterpret_cast
argument_list|<
name|uintptr_t
argument_list|>
argument_list|(
name|handle
argument_list|)
argument_list|)
return|;
block|}
DECL|function|getVertexArray
name|VertexArray
modifier|*
name|Context
operator|::
name|getVertexArray
parameter_list|(
name|GLuint
name|handle
parameter_list|)
specifier|const
block|{
name|auto
name|vertexArray
init|=
name|mVertexArrayMap
operator|.
name|find
argument_list|(
name|handle
argument_list|)
decl_stmt|;
if|if
condition|(
name|vertexArray
operator|==
name|mVertexArrayMap
operator|.
name|end
argument_list|()
condition|)
block|{
return|return
name|NULL
return|;
block|}
else|else
block|{
return|return
name|vertexArray
operator|->
name|second
return|;
block|}
block|}
DECL|function|getSampler
name|Sampler
modifier|*
name|Context
operator|::
name|getSampler
parameter_list|(
name|GLuint
name|handle
parameter_list|)
specifier|const
block|{
return|return
name|mResourceManager
operator|->
name|getSampler
argument_list|(
name|handle
argument_list|)
return|;
block|}
DECL|function|getTransformFeedback
name|TransformFeedback
modifier|*
name|Context
operator|::
name|getTransformFeedback
parameter_list|(
name|GLuint
name|handle
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|handle
operator|==
literal|0
condition|)
block|{
return|return
name|mTransformFeedbackZero
operator|.
name|get
argument_list|()
return|;
block|}
else|else
block|{
name|TransformFeedbackMap
operator|::
name|const_iterator
name|iter
init|=
name|mTransformFeedbackMap
operator|.
name|find
argument_list|(
name|handle
argument_list|)
decl_stmt|;
return|return
operator|(
name|iter
operator|!=
name|mTransformFeedbackMap
operator|.
name|end
argument_list|()
operator|)
condition|?
name|iter
operator|->
name|second
else|:
name|NULL
return|;
block|}
block|}
DECL|function|isSampler
name|bool
name|Context
operator|::
name|isSampler
parameter_list|(
name|GLuint
name|samplerName
parameter_list|)
specifier|const
block|{
return|return
name|mResourceManager
operator|->
name|isSampler
argument_list|(
name|samplerName
argument_list|)
return|;
block|}
DECL|function|bindArrayBuffer
name|void
name|Context
operator|::
name|bindArrayBuffer
parameter_list|(
name|unsigned
name|int
name|buffer
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkBufferAllocation
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setArrayBufferBinding
argument_list|(
name|getBuffer
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindElementArrayBuffer
name|void
name|Context
operator|::
name|bindElementArrayBuffer
parameter_list|(
name|unsigned
name|int
name|buffer
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkBufferAllocation
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|getVertexArray
argument_list|()
operator|->
name|setElementArrayBuffer
argument_list|(
name|getBuffer
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindTexture
name|void
name|Context
operator|::
name|bindTexture
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLuint
name|handle
parameter_list|)
block|{
name|Texture
modifier|*
name|texture
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|handle
operator|==
literal|0
condition|)
block|{
name|texture
operator|=
name|mZeroTextures
index|[
name|target
index|]
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|mResourceManager
operator|->
name|checkTextureAllocation
argument_list|(
name|handle
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|texture
operator|=
name|getTexture
argument_list|(
name|handle
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|texture
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setSamplerTexture
argument_list|(
name|target
argument_list|,
name|texture
argument_list|)
expr_stmt|;
block|}
DECL|function|bindReadFramebuffer
name|void
name|Context
operator|::
name|bindReadFramebuffer
parameter_list|(
name|GLuint
name|framebuffer
parameter_list|)
block|{
if|if
condition|(
operator|!
name|getFramebuffer
argument_list|(
name|framebuffer
argument_list|)
condition|)
block|{
name|mFramebufferMap
index|[
name|framebuffer
index|]
operator|=
operator|new
name|Framebuffer
argument_list|(
name|mCaps
argument_list|,
name|mRenderer
argument_list|,
name|framebuffer
argument_list|)
expr_stmt|;
block|}
name|mState
operator|.
name|setReadFramebufferBinding
argument_list|(
name|getFramebuffer
argument_list|(
name|framebuffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindDrawFramebuffer
name|void
name|Context
operator|::
name|bindDrawFramebuffer
parameter_list|(
name|GLuint
name|framebuffer
parameter_list|)
block|{
if|if
condition|(
operator|!
name|getFramebuffer
argument_list|(
name|framebuffer
argument_list|)
condition|)
block|{
name|mFramebufferMap
index|[
name|framebuffer
index|]
operator|=
operator|new
name|Framebuffer
argument_list|(
name|mCaps
argument_list|,
name|mRenderer
argument_list|,
name|framebuffer
argument_list|)
expr_stmt|;
block|}
name|mState
operator|.
name|setDrawFramebufferBinding
argument_list|(
name|getFramebuffer
argument_list|(
name|framebuffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindRenderbuffer
name|void
name|Context
operator|::
name|bindRenderbuffer
parameter_list|(
name|GLuint
name|renderbuffer
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkRenderbufferAllocation
argument_list|(
name|renderbuffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setRenderbufferBinding
argument_list|(
name|getRenderbuffer
argument_list|(
name|renderbuffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindVertexArray
name|void
name|Context
operator|::
name|bindVertexArray
parameter_list|(
name|GLuint
name|vertexArray
parameter_list|)
block|{
if|if
condition|(
operator|!
name|getVertexArray
argument_list|(
name|vertexArray
argument_list|)
condition|)
block|{
name|VertexArray
modifier|*
name|vertexArrayObject
init|=
operator|new
name|VertexArray
argument_list|(
name|mRenderer
operator|->
name|createVertexArray
argument_list|()
argument_list|,
name|vertexArray
argument_list|,
name|MAX_VERTEX_ATTRIBS
argument_list|)
decl_stmt|;
name|mVertexArrayMap
index|[
name|vertexArray
index|]
operator|=
name|vertexArrayObject
expr_stmt|;
block|}
name|mState
operator|.
name|setVertexArrayBinding
argument_list|(
name|getVertexArray
argument_list|(
name|vertexArray
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindSampler
name|void
name|Context
operator|::
name|bindSampler
parameter_list|(
name|GLuint
name|textureUnit
parameter_list|,
name|GLuint
name|sampler
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|textureUnit
operator|<
name|mCaps
operator|.
name|maxCombinedTextureImageUnits
argument_list|)
expr_stmt|;
name|mResourceManager
operator|->
name|checkSamplerAllocation
argument_list|(
name|sampler
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setSamplerBinding
argument_list|(
name|textureUnit
argument_list|,
name|getSampler
argument_list|(
name|sampler
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindGenericUniformBuffer
name|void
name|Context
operator|::
name|bindGenericUniformBuffer
parameter_list|(
name|GLuint
name|buffer
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkBufferAllocation
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setGenericUniformBufferBinding
argument_list|(
name|getBuffer
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindIndexedUniformBuffer
name|void
name|Context
operator|::
name|bindIndexedUniformBuffer
parameter_list|(
name|GLuint
name|buffer
parameter_list|,
name|GLuint
name|index
parameter_list|,
name|GLintptr
name|offset
parameter_list|,
name|GLsizeiptr
name|size
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkBufferAllocation
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setIndexedUniformBufferBinding
argument_list|(
name|index
argument_list|,
name|getBuffer
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
DECL|function|bindGenericTransformFeedbackBuffer
name|void
name|Context
operator|::
name|bindGenericTransformFeedbackBuffer
parameter_list|(
name|GLuint
name|buffer
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkBufferAllocation
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setGenericTransformFeedbackBufferBinding
argument_list|(
name|getBuffer
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindIndexedTransformFeedbackBuffer
name|void
name|Context
operator|::
name|bindIndexedTransformFeedbackBuffer
parameter_list|(
name|GLuint
name|buffer
parameter_list|,
name|GLuint
name|index
parameter_list|,
name|GLintptr
name|offset
parameter_list|,
name|GLsizeiptr
name|size
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkBufferAllocation
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setIndexedTransformFeedbackBufferBinding
argument_list|(
name|index
argument_list|,
name|getBuffer
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
DECL|function|bindCopyReadBuffer
name|void
name|Context
operator|::
name|bindCopyReadBuffer
parameter_list|(
name|GLuint
name|buffer
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkBufferAllocation
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setCopyReadBufferBinding
argument_list|(
name|getBuffer
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindCopyWriteBuffer
name|void
name|Context
operator|::
name|bindCopyWriteBuffer
parameter_list|(
name|GLuint
name|buffer
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkBufferAllocation
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setCopyWriteBufferBinding
argument_list|(
name|getBuffer
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindPixelPackBuffer
name|void
name|Context
operator|::
name|bindPixelPackBuffer
parameter_list|(
name|GLuint
name|buffer
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkBufferAllocation
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setPixelPackBufferBinding
argument_list|(
name|getBuffer
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindPixelUnpackBuffer
name|void
name|Context
operator|::
name|bindPixelUnpackBuffer
parameter_list|(
name|GLuint
name|buffer
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkBufferAllocation
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setPixelUnpackBufferBinding
argument_list|(
name|getBuffer
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|useProgram
name|void
name|Context
operator|::
name|useProgram
parameter_list|(
name|GLuint
name|program
parameter_list|)
block|{
name|mState
operator|.
name|setProgram
argument_list|(
name|getProgram
argument_list|(
name|program
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindTransformFeedback
name|void
name|Context
operator|::
name|bindTransformFeedback
parameter_list|(
name|GLuint
name|transformFeedback
parameter_list|)
block|{
name|mState
operator|.
name|setTransformFeedbackBinding
argument_list|(
name|getTransformFeedback
argument_list|(
name|transformFeedback
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|beginQuery
name|Error
name|Context
operator|::
name|beginQuery
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLuint
name|query
parameter_list|)
block|{
name|Query
modifier|*
name|queryObject
init|=
name|getQuery
argument_list|(
name|query
argument_list|,
literal|true
argument_list|,
name|target
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|queryObject
argument_list|)
expr_stmt|;
comment|// begin query
name|Error
name|error
init|=
name|queryObject
operator|->
name|begin
argument_list|()
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
comment|// set query as active for specified target only if begin succeeded
name|mState
operator|.
name|setActiveQuery
argument_list|(
name|target
argument_list|,
name|queryObject
argument_list|)
expr_stmt|;
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|endQuery
name|Error
name|Context
operator|::
name|endQuery
parameter_list|(
name|GLenum
name|target
parameter_list|)
block|{
name|Query
modifier|*
name|queryObject
init|=
name|mState
operator|.
name|getActiveQuery
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|queryObject
argument_list|)
expr_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|queryObject
operator|->
name|end
argument_list|()
decl_stmt|;
comment|// Always unbind the query, even if there was an error. This may delete the query object.
name|mState
operator|.
name|setActiveQuery
argument_list|(
name|target
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
DECL|function|setFramebufferZero
name|void
name|Context
operator|::
name|setFramebufferZero
parameter_list|(
name|Framebuffer
modifier|*
name|buffer
parameter_list|)
block|{
comment|// First, check to see if the old default framebuffer
comment|// was set for draw or read framebuffer, and change
comment|// the bindings to point to the new one before deleting it.
if|if
condition|(
name|mState
operator|.
name|getDrawFramebuffer
argument_list|()
operator|->
name|id
argument_list|()
operator|==
literal|0
condition|)
block|{
name|mState
operator|.
name|setDrawFramebufferBinding
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mState
operator|.
name|getReadFramebuffer
argument_list|()
operator|->
name|id
argument_list|()
operator|==
literal|0
condition|)
block|{
name|mState
operator|.
name|setReadFramebufferBinding
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
operator|delete
name|mFramebufferMap
index|[
literal|0
index|]
expr_stmt|;
name|mFramebufferMap
index|[
literal|0
index|]
operator|=
name|buffer
expr_stmt|;
block|}
DECL|function|getFramebuffer
name|Framebuffer
modifier|*
name|Context
operator|::
name|getFramebuffer
parameter_list|(
name|unsigned
name|int
name|handle
parameter_list|)
specifier|const
block|{
name|FramebufferMap
operator|::
name|const_iterator
name|framebuffer
init|=
name|mFramebufferMap
operator|.
name|find
argument_list|(
name|handle
argument_list|)
decl_stmt|;
if|if
condition|(
name|framebuffer
operator|==
name|mFramebufferMap
operator|.
name|end
argument_list|()
condition|)
block|{
return|return
name|NULL
return|;
block|}
else|else
block|{
return|return
name|framebuffer
operator|->
name|second
return|;
block|}
block|}
DECL|function|getFenceNV
name|FenceNV
modifier|*
name|Context
operator|::
name|getFenceNV
parameter_list|(
name|unsigned
name|int
name|handle
parameter_list|)
block|{
name|FenceNVMap
operator|::
name|iterator
name|fence
init|=
name|mFenceNVMap
operator|.
name|find
argument_list|(
name|handle
argument_list|)
decl_stmt|;
if|if
condition|(
name|fence
operator|==
name|mFenceNVMap
operator|.
name|end
argument_list|()
condition|)
block|{
return|return
name|NULL
return|;
block|}
else|else
block|{
return|return
name|fence
operator|->
name|second
return|;
block|}
block|}
DECL|function|getQuery
name|Query
modifier|*
name|Context
operator|::
name|getQuery
parameter_list|(
name|unsigned
name|int
name|handle
parameter_list|,
name|bool
name|create
parameter_list|,
name|GLenum
name|type
parameter_list|)
block|{
name|QueryMap
operator|::
name|iterator
name|query
init|=
name|mQueryMap
operator|.
name|find
argument_list|(
name|handle
argument_list|)
decl_stmt|;
if|if
condition|(
name|query
operator|==
name|mQueryMap
operator|.
name|end
argument_list|()
condition|)
block|{
return|return
name|NULL
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|query
operator|->
name|second
operator|&&
name|create
condition|)
block|{
name|query
operator|->
name|second
operator|=
operator|new
name|Query
argument_list|(
name|mRenderer
operator|->
name|createQuery
argument_list|(
name|type
argument_list|)
argument_list|,
name|handle
argument_list|)
expr_stmt|;
name|query
operator|->
name|second
operator|->
name|addRef
argument_list|()
expr_stmt|;
block|}
return|return
name|query
operator|->
name|second
return|;
block|}
block|}
DECL|function|getTargetTexture
name|Texture
modifier|*
name|Context
operator|::
name|getTargetTexture
parameter_list|(
name|GLenum
name|target
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|ValidTextureTarget
argument_list|(
name|this
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|getSamplerTexture
argument_list|(
name|mState
operator|.
name|getActiveSampler
argument_list|()
argument_list|,
name|target
argument_list|)
return|;
block|}
DECL|function|getSamplerTexture
name|Texture
modifier|*
name|Context
operator|::
name|getSamplerTexture
parameter_list|(
name|unsigned
name|int
name|sampler
parameter_list|,
name|GLenum
name|type
parameter_list|)
specifier|const
block|{
return|return
name|mState
operator|.
name|getSamplerTexture
argument_list|(
name|sampler
argument_list|,
name|type
argument_list|)
return|;
block|}
DECL|function|getCompiler
name|Compiler
modifier|*
name|Context
operator|::
name|getCompiler
parameter_list|()
specifier|const
block|{
return|return
name|mCompiler
return|;
block|}
DECL|function|getBooleanv
name|void
name|Context
operator|::
name|getBooleanv
parameter_list|(
name|GLenum
name|pname
parameter_list|,
name|GLboolean
modifier|*
name|params
parameter_list|)
block|{
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_SHADER_COMPILER
case|:
operator|*
name|params
operator|=
name|GL_TRUE
expr_stmt|;
break|break;
case|case
name|GL_CONTEXT_ROBUST_ACCESS_EXT
case|:
operator|*
name|params
operator|=
name|mRobustAccess
condition|?
name|GL_TRUE
else|:
name|GL_FALSE
expr_stmt|;
break|break;
default|default:
name|mState
operator|.
name|getBooleanv
argument_list|(
name|pname
argument_list|,
name|params
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
DECL|function|getFloatv
name|void
name|Context
operator|::
name|getFloatv
parameter_list|(
name|GLenum
name|pname
parameter_list|,
name|GLfloat
modifier|*
name|params
parameter_list|)
block|{
comment|// Queries about context capabilities and maximums are answered by Context.
comment|// Queries about current GL state values are answered by State.
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_ALIASED_LINE_WIDTH_RANGE
case|:
name|params
index|[
literal|0
index|]
operator|=
name|mCaps
operator|.
name|minAliasedLineWidth
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|mCaps
operator|.
name|maxAliasedLineWidth
expr_stmt|;
break|break;
case|case
name|GL_ALIASED_POINT_SIZE_RANGE
case|:
name|params
index|[
literal|0
index|]
operator|=
name|mCaps
operator|.
name|minAliasedPointSize
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|mCaps
operator|.
name|maxAliasedPointSize
expr_stmt|;
break|break;
case|case
name|GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT
case|:
name|ASSERT
argument_list|(
name|mExtensions
operator|.
name|textureFilterAnisotropic
argument_list|)
expr_stmt|;
operator|*
name|params
operator|=
name|mExtensions
operator|.
name|maxTextureAnisotropy
expr_stmt|;
break|break;
default|default:
name|mState
operator|.
name|getFloatv
argument_list|(
name|pname
argument_list|,
name|params
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
DECL|function|getIntegerv
name|void
name|Context
operator|::
name|getIntegerv
parameter_list|(
name|GLenum
name|pname
parameter_list|,
name|GLint
modifier|*
name|params
parameter_list|)
block|{
comment|// Queries about context capabilities and maximums are answered by Context.
comment|// Queries about current GL state values are answered by State.
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_MAX_VERTEX_ATTRIBS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxVertexAttributes
expr_stmt|;
break|break;
case|case
name|GL_MAX_VERTEX_UNIFORM_VECTORS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxVertexUniformVectors
expr_stmt|;
break|break;
case|case
name|GL_MAX_VERTEX_UNIFORM_COMPONENTS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxVertexUniformComponents
expr_stmt|;
break|break;
case|case
name|GL_MAX_VARYING_VECTORS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxVaryingVectors
expr_stmt|;
break|break;
case|case
name|GL_MAX_VARYING_COMPONENTS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxVertexOutputComponents
expr_stmt|;
break|break;
case|case
name|GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxCombinedTextureImageUnits
expr_stmt|;
break|break;
case|case
name|GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxVertexTextureImageUnits
expr_stmt|;
break|break;
case|case
name|GL_MAX_TEXTURE_IMAGE_UNITS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxTextureImageUnits
expr_stmt|;
break|break;
case|case
name|GL_MAX_FRAGMENT_UNIFORM_VECTORS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxFragmentUniformVectors
expr_stmt|;
break|break;
case|case
name|GL_MAX_FRAGMENT_UNIFORM_COMPONENTS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxFragmentInputComponents
expr_stmt|;
break|break;
case|case
name|GL_MAX_RENDERBUFFER_SIZE
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxRenderbufferSize
expr_stmt|;
break|break;
case|case
name|GL_MAX_COLOR_ATTACHMENTS_EXT
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxColorAttachments
expr_stmt|;
break|break;
case|case
name|GL_MAX_DRAW_BUFFERS_EXT
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxDrawBuffers
expr_stmt|;
break|break;
comment|//case GL_FRAMEBUFFER_BINDING:                    // now equivalent to GL_DRAW_FRAMEBUFFER_BINDING_ANGLE
case|case
name|GL_SUBPIXEL_BITS
case|:
operator|*
name|params
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|GL_MAX_TEXTURE_SIZE
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|max2DTextureSize
expr_stmt|;
break|break;
case|case
name|GL_MAX_CUBE_MAP_TEXTURE_SIZE
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxCubeMapTextureSize
expr_stmt|;
break|break;
case|case
name|GL_MAX_3D_TEXTURE_SIZE
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|max3DTextureSize
expr_stmt|;
break|break;
case|case
name|GL_MAX_ARRAY_TEXTURE_LAYERS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxArrayTextureLayers
expr_stmt|;
break|break;
case|case
name|GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|uniformBufferOffsetAlignment
expr_stmt|;
break|break;
case|case
name|GL_MAX_UNIFORM_BUFFER_BINDINGS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxUniformBufferBindings
expr_stmt|;
break|break;
case|case
name|GL_MAX_VERTEX_UNIFORM_BLOCKS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxVertexUniformBlocks
expr_stmt|;
break|break;
case|case
name|GL_MAX_FRAGMENT_UNIFORM_BLOCKS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxFragmentUniformBlocks
expr_stmt|;
break|break;
case|case
name|GL_MAX_COMBINED_UNIFORM_BLOCKS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxCombinedTextureImageUnits
expr_stmt|;
break|break;
case|case
name|GL_MAJOR_VERSION
case|:
operator|*
name|params
operator|=
name|mClientVersion
expr_stmt|;
break|break;
case|case
name|GL_MINOR_VERSION
case|:
operator|*
name|params
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|GL_MAX_ELEMENTS_INDICES
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxElementsIndices
expr_stmt|;
break|break;
case|case
name|GL_MAX_ELEMENTS_VERTICES
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxElementsVertices
expr_stmt|;
break|break;
case|case
name|GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxTransformFeedbackInterleavedComponents
expr_stmt|;
break|break;
case|case
name|GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxTransformFeedbackSeparateAttributes
expr_stmt|;
break|break;
case|case
name|GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxTransformFeedbackSeparateComponents
expr_stmt|;
break|break;
case|case
name|GL_NUM_COMPRESSED_TEXTURE_FORMATS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|compressedTextureFormats
operator|.
name|size
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_MAX_SAMPLES_ANGLE
case|:
operator|*
name|params
operator|=
name|mExtensions
operator|.
name|maxSamples
expr_stmt|;
break|break;
case|case
name|GL_MAX_VIEWPORT_DIMS
case|:
block|{
name|params
index|[
literal|0
index|]
operator|=
name|mCaps
operator|.
name|maxViewportWidth
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|mCaps
operator|.
name|maxViewportHeight
expr_stmt|;
block|}
break|break;
case|case
name|GL_COMPRESSED_TEXTURE_FORMATS
case|:
name|std
operator|::
name|copy
argument_list|(
name|mCaps
operator|.
name|compressedTextureFormats
operator|.
name|begin
argument_list|()
argument_list|,
name|mCaps
operator|.
name|compressedTextureFormats
operator|.
name|end
argument_list|()
argument_list|,
name|params
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_RESET_NOTIFICATION_STRATEGY_EXT
case|:
operator|*
name|params
operator|=
name|mResetStrategy
expr_stmt|;
break|break;
case|case
name|GL_NUM_SHADER_BINARY_FORMATS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|shaderBinaryFormats
operator|.
name|size
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_SHADER_BINARY_FORMATS
case|:
name|std
operator|::
name|copy
argument_list|(
name|mCaps
operator|.
name|shaderBinaryFormats
operator|.
name|begin
argument_list|()
argument_list|,
name|mCaps
operator|.
name|shaderBinaryFormats
operator|.
name|end
argument_list|()
argument_list|,
name|params
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_NUM_PROGRAM_BINARY_FORMATS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|programBinaryFormats
operator|.
name|size
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_PROGRAM_BINARY_FORMATS
case|:
name|std
operator|::
name|copy
argument_list|(
name|mCaps
operator|.
name|programBinaryFormats
operator|.
name|begin
argument_list|()
argument_list|,
name|mCaps
operator|.
name|programBinaryFormats
operator|.
name|end
argument_list|()
argument_list|,
name|params
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_NUM_EXTENSIONS
case|:
operator|*
name|params
operator|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|mExtensionStrings
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|mState
operator|.
name|getIntegerv
argument_list|(
name|getData
argument_list|()
argument_list|,
name|pname
argument_list|,
name|params
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
DECL|function|getInteger64v
name|void
name|Context
operator|::
name|getInteger64v
parameter_list|(
name|GLenum
name|pname
parameter_list|,
name|GLint64
modifier|*
name|params
parameter_list|)
block|{
comment|// Queries about context capabilities and maximums are answered by Context.
comment|// Queries about current GL state values are answered by State.
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_MAX_ELEMENT_INDEX
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxElementIndex
expr_stmt|;
break|break;
case|case
name|GL_MAX_UNIFORM_BLOCK_SIZE
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxUniformBlockSize
expr_stmt|;
break|break;
case|case
name|GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxCombinedVertexUniformComponents
expr_stmt|;
break|break;
case|case
name|GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxCombinedFragmentUniformComponents
expr_stmt|;
break|break;
case|case
name|GL_MAX_SERVER_WAIT_TIMEOUT
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxServerWaitTimeout
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
DECL|function|getIndexedIntegerv
name|bool
name|Context
operator|::
name|getIndexedIntegerv
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLuint
name|index
parameter_list|,
name|GLint
modifier|*
name|data
parameter_list|)
block|{
comment|// Queries about context capabilities and maximums are answered by Context.
comment|// Queries about current GL state values are answered by State.
comment|// Indexed integer queries all refer to current state, so this function is a
comment|// mere passthrough.
return|return
name|mState
operator|.
name|getIndexedIntegerv
argument_list|(
name|target
argument_list|,
name|index
argument_list|,
name|data
argument_list|)
return|;
block|}
DECL|function|getIndexedInteger64v
name|bool
name|Context
operator|::
name|getIndexedInteger64v
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLuint
name|index
parameter_list|,
name|GLint64
modifier|*
name|data
parameter_list|)
block|{
comment|// Queries about context capabilities and maximums are answered by Context.
comment|// Queries about current GL state values are answered by State.
comment|// Indexed integer queries all refer to current state, so this function is a
comment|// mere passthrough.
return|return
name|mState
operator|.
name|getIndexedInteger64v
argument_list|(
name|target
argument_list|,
name|index
argument_list|,
name|data
argument_list|)
return|;
block|}
DECL|function|getQueryParameterInfo
name|bool
name|Context
operator|::
name|getQueryParameterInfo
parameter_list|(
name|GLenum
name|pname
parameter_list|,
name|GLenum
modifier|*
name|type
parameter_list|,
name|unsigned
name|int
modifier|*
name|numParams
parameter_list|)
block|{
if|if
condition|(
name|pname
operator|>=
name|GL_DRAW_BUFFER0_EXT
operator|&&
name|pname
operator|<=
name|GL_DRAW_BUFFER15_EXT
condition|)
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// Please note: the query type returned for DEPTH_CLEAR_VALUE in this implementation
comment|// is FLOAT rather than INT, as would be suggested by the GL ES 2.0 spec. This is due
comment|// to the fact that it is stored internally as a float, and so would require conversion
comment|// if returned from Context::getIntegerv. Since this conversion is already implemented
comment|// in the case that one calls glGetIntegerv to retrieve a float-typed state variable, we
comment|// place DEPTH_CLEAR_VALUE with the floats. This should make no difference to the calling
comment|// application.
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_COMPRESSED_TEXTURE_FORMATS
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
name|mCaps
operator|.
name|compressedTextureFormats
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_PROGRAM_BINARY_FORMATS_OES
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
name|mCaps
operator|.
name|programBinaryFormats
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_SHADER_BINARY_FORMATS
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
name|mCaps
operator|.
name|shaderBinaryFormats
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_MAX_VERTEX_ATTRIBS
case|:
case|case
name|GL_MAX_VERTEX_UNIFORM_VECTORS
case|:
case|case
name|GL_MAX_VARYING_VECTORS
case|:
case|case
name|GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS
case|:
case|case
name|GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS
case|:
case|case
name|GL_MAX_TEXTURE_IMAGE_UNITS
case|:
case|case
name|GL_MAX_FRAGMENT_UNIFORM_VECTORS
case|:
case|case
name|GL_MAX_RENDERBUFFER_SIZE
case|:
case|case
name|GL_MAX_COLOR_ATTACHMENTS_EXT
case|:
case|case
name|GL_MAX_DRAW_BUFFERS_EXT
case|:
case|case
name|GL_NUM_SHADER_BINARY_FORMATS
case|:
case|case
name|GL_NUM_COMPRESSED_TEXTURE_FORMATS
case|:
case|case
name|GL_ARRAY_BUFFER_BINDING
case|:
comment|//case GL_FRAMEBUFFER_BINDING: // equivalent to DRAW_FRAMEBUFFER_BINDING_ANGLE
case|case
name|GL_DRAW_FRAMEBUFFER_BINDING_ANGLE
case|:
case|case
name|GL_READ_FRAMEBUFFER_BINDING_ANGLE
case|:
case|case
name|GL_RENDERBUFFER_BINDING
case|:
case|case
name|GL_CURRENT_PROGRAM
case|:
case|case
name|GL_PACK_ALIGNMENT
case|:
case|case
name|GL_PACK_REVERSE_ROW_ORDER_ANGLE
case|:
case|case
name|GL_UNPACK_ALIGNMENT
case|:
case|case
name|GL_GENERATE_MIPMAP_HINT
case|:
case|case
name|GL_FRAGMENT_SHADER_DERIVATIVE_HINT_OES
case|:
case|case
name|GL_RED_BITS
case|:
case|case
name|GL_GREEN_BITS
case|:
case|case
name|GL_BLUE_BITS
case|:
case|case
name|GL_ALPHA_BITS
case|:
case|case
name|GL_DEPTH_BITS
case|:
case|case
name|GL_STENCIL_BITS
case|:
case|case
name|GL_ELEMENT_ARRAY_BUFFER_BINDING
case|:
case|case
name|GL_CULL_FACE_MODE
case|:
case|case
name|GL_FRONT_FACE
case|:
case|case
name|GL_ACTIVE_TEXTURE
case|:
case|case
name|GL_STENCIL_FUNC
case|:
case|case
name|GL_STENCIL_VALUE_MASK
case|:
case|case
name|GL_STENCIL_REF
case|:
case|case
name|GL_STENCIL_FAIL
case|:
case|case
name|GL_STENCIL_PASS_DEPTH_FAIL
case|:
case|case
name|GL_STENCIL_PASS_DEPTH_PASS
case|:
case|case
name|GL_STENCIL_BACK_FUNC
case|:
case|case
name|GL_STENCIL_BACK_VALUE_MASK
case|:
case|case
name|GL_STENCIL_BACK_REF
case|:
case|case
name|GL_STENCIL_BACK_FAIL
case|:
case|case
name|GL_STENCIL_BACK_PASS_DEPTH_FAIL
case|:
case|case
name|GL_STENCIL_BACK_PASS_DEPTH_PASS
case|:
case|case
name|GL_DEPTH_FUNC
case|:
case|case
name|GL_BLEND_SRC_RGB
case|:
case|case
name|GL_BLEND_SRC_ALPHA
case|:
case|case
name|GL_BLEND_DST_RGB
case|:
case|case
name|GL_BLEND_DST_ALPHA
case|:
case|case
name|GL_BLEND_EQUATION_RGB
case|:
case|case
name|GL_BLEND_EQUATION_ALPHA
case|:
case|case
name|GL_STENCIL_WRITEMASK
case|:
case|case
name|GL_STENCIL_BACK_WRITEMASK
case|:
case|case
name|GL_STENCIL_CLEAR_VALUE
case|:
case|case
name|GL_SUBPIXEL_BITS
case|:
case|case
name|GL_MAX_TEXTURE_SIZE
case|:
case|case
name|GL_MAX_CUBE_MAP_TEXTURE_SIZE
case|:
case|case
name|GL_SAMPLE_BUFFERS
case|:
case|case
name|GL_SAMPLES
case|:
case|case
name|GL_IMPLEMENTATION_COLOR_READ_TYPE
case|:
case|case
name|GL_IMPLEMENTATION_COLOR_READ_FORMAT
case|:
case|case
name|GL_TEXTURE_BINDING_2D
case|:
case|case
name|GL_TEXTURE_BINDING_CUBE_MAP
case|:
case|case
name|GL_RESET_NOTIFICATION_STRATEGY_EXT
case|:
case|case
name|GL_NUM_PROGRAM_BINARY_FORMATS_OES
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_MAX_SAMPLES_ANGLE
case|:
block|{
if|if
condition|(
name|mExtensions
operator|.
name|framebufferMultisample
condition|)
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
case|case
name|GL_PIXEL_PACK_BUFFER_BINDING
case|:
case|case
name|GL_PIXEL_UNPACK_BUFFER_BINDING
case|:
block|{
if|if
condition|(
name|mExtensions
operator|.
name|pixelBufferObject
condition|)
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
case|case
name|GL_MAX_VIEWPORT_DIMS
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|2
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_VIEWPORT
case|:
case|case
name|GL_SCISSOR_BOX
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|4
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_SHADER_COMPILER
case|:
case|case
name|GL_SAMPLE_COVERAGE_INVERT
case|:
case|case
name|GL_DEPTH_WRITEMASK
case|:
case|case
name|GL_CULL_FACE
case|:
comment|// CULL_FACE through DITHER are natural to IsEnabled,
case|case
name|GL_POLYGON_OFFSET_FILL
case|:
comment|// but can be retrieved through the Get{Type}v queries.
case|case
name|GL_SAMPLE_ALPHA_TO_COVERAGE
case|:
comment|// For this purpose, they are treated here as bool-natural
case|case
name|GL_SAMPLE_COVERAGE
case|:
case|case
name|GL_SCISSOR_TEST
case|:
case|case
name|GL_STENCIL_TEST
case|:
case|case
name|GL_DEPTH_TEST
case|:
case|case
name|GL_BLEND
case|:
case|case
name|GL_DITHER
case|:
case|case
name|GL_CONTEXT_ROBUST_ACCESS_EXT
case|:
block|{
operator|*
name|type
operator|=
name|GL_BOOL
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_COLOR_WRITEMASK
case|:
block|{
operator|*
name|type
operator|=
name|GL_BOOL
expr_stmt|;
operator|*
name|numParams
operator|=
literal|4
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_POLYGON_OFFSET_FACTOR
case|:
case|case
name|GL_POLYGON_OFFSET_UNITS
case|:
case|case
name|GL_SAMPLE_COVERAGE_VALUE
case|:
case|case
name|GL_DEPTH_CLEAR_VALUE
case|:
case|case
name|GL_LINE_WIDTH
case|:
block|{
operator|*
name|type
operator|=
name|GL_FLOAT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_ALIASED_LINE_WIDTH_RANGE
case|:
case|case
name|GL_ALIASED_POINT_SIZE_RANGE
case|:
case|case
name|GL_DEPTH_RANGE
case|:
block|{
operator|*
name|type
operator|=
name|GL_FLOAT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|2
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_COLOR_CLEAR_VALUE
case|:
case|case
name|GL_BLEND_COLOR
case|:
block|{
operator|*
name|type
operator|=
name|GL_FLOAT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|4
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT
case|:
if|if
condition|(
operator|!
name|mExtensions
operator|.
name|maxTextureAnisotropy
condition|)
block|{
return|return
literal|false
return|;
block|}
operator|*
name|type
operator|=
name|GL_FLOAT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|mClientVersion
operator|<
literal|3
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Check for ES3.0+ parameter names
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_MAX_UNIFORM_BUFFER_BINDINGS
case|:
case|case
name|GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT
case|:
case|case
name|GL_UNIFORM_BUFFER_BINDING
case|:
case|case
name|GL_TRANSFORM_FEEDBACK_BINDING
case|:
case|case
name|GL_COPY_READ_BUFFER_BINDING
case|:
case|case
name|GL_COPY_WRITE_BUFFER_BINDING
case|:
case|case
name|GL_TEXTURE_BINDING_3D
case|:
case|case
name|GL_TEXTURE_BINDING_2D_ARRAY
case|:
case|case
name|GL_MAX_3D_TEXTURE_SIZE
case|:
case|case
name|GL_MAX_ARRAY_TEXTURE_LAYERS
case|:
case|case
name|GL_MAX_VERTEX_UNIFORM_BLOCKS
case|:
case|case
name|GL_MAX_FRAGMENT_UNIFORM_BLOCKS
case|:
case|case
name|GL_MAX_COMBINED_UNIFORM_BLOCKS
case|:
case|case
name|GL_MAX_VARYING_COMPONENTS
case|:
case|case
name|GL_VERTEX_ARRAY_BINDING
case|:
case|case
name|GL_MAX_VERTEX_UNIFORM_COMPONENTS
case|:
case|case
name|GL_MAX_FRAGMENT_UNIFORM_COMPONENTS
case|:
case|case
name|GL_NUM_EXTENSIONS
case|:
case|case
name|GL_MAJOR_VERSION
case|:
case|case
name|GL_MINOR_VERSION
case|:
case|case
name|GL_MAX_ELEMENTS_INDICES
case|:
case|case
name|GL_MAX_ELEMENTS_VERTICES
case|:
case|case
name|GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS
case|:
case|case
name|GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS
case|:
case|case
name|GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_MAX_ELEMENT_INDEX
case|:
case|case
name|GL_MAX_UNIFORM_BLOCK_SIZE
case|:
case|case
name|GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS
case|:
case|case
name|GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS
case|:
case|case
name|GL_MAX_SERVER_WAIT_TIMEOUT
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT_64_ANGLEX
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_TRANSFORM_FEEDBACK_ACTIVE
case|:
case|case
name|GL_TRANSFORM_FEEDBACK_PAUSED
case|:
block|{
operator|*
name|type
operator|=
name|GL_BOOL
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|function|getIndexedQueryParameterInfo
name|bool
name|Context
operator|::
name|getIndexedQueryParameterInfo
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLenum
modifier|*
name|type
parameter_list|,
name|unsigned
name|int
modifier|*
name|numParams
parameter_list|)
block|{
if|if
condition|(
name|mClientVersion
operator|<
literal|3
condition|)
block|{
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TRANSFORM_FEEDBACK_BUFFER_BINDING
case|:
case|case
name|GL_UNIFORM_BUFFER_BINDING
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_TRANSFORM_FEEDBACK_BUFFER_START
case|:
case|case
name|GL_TRANSFORM_FEEDBACK_BUFFER_SIZE
case|:
case|case
name|GL_UNIFORM_BUFFER_START
case|:
case|case
name|GL_UNIFORM_BUFFER_SIZE
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT_64_ANGLEX
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|function|drawArrays
name|Error
name|Context
operator|::
name|drawArrays
parameter_list|(
name|GLenum
name|mode
parameter_list|,
name|GLint
name|first
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLsizei
name|instances
parameter_list|)
block|{
return|return
name|mRenderer
operator|->
name|drawArrays
argument_list|(
name|getData
argument_list|()
argument_list|,
name|mode
argument_list|,
name|first
argument_list|,
name|count
argument_list|,
name|instances
argument_list|)
return|;
block|}
DECL|function|drawElements
name|Error
name|Context
operator|::
name|drawElements
parameter_list|(
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|GLsizei
name|instances
parameter_list|,
specifier|const
name|rx
operator|::
name|RangeUI
modifier|&
name|indexRange
parameter_list|)
block|{
return|return
name|mRenderer
operator|->
name|drawElements
argument_list|(
name|getData
argument_list|()
argument_list|,
name|mode
argument_list|,
name|count
argument_list|,
name|type
argument_list|,
name|indices
argument_list|,
name|instances
argument_list|,
name|indexRange
argument_list|)
return|;
block|}
DECL|function|flush
name|Error
name|Context
operator|::
name|flush
parameter_list|()
block|{
return|return
name|mRenderer
operator|->
name|flush
argument_list|()
return|;
block|}
DECL|function|finish
name|Error
name|Context
operator|::
name|finish
parameter_list|()
block|{
return|return
name|mRenderer
operator|->
name|finish
argument_list|()
return|;
block|}
DECL|function|recordError
name|void
name|Context
operator|::
name|recordError
parameter_list|(
specifier|const
name|Error
modifier|&
name|error
parameter_list|)
block|{
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
name|mErrors
operator|.
name|insert
argument_list|(
name|error
operator|.
name|getCode
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Get one of the recorded errors and clear its flag, if any.
comment|// [OpenGL ES 2.0.24] section 2.5 page 13.
DECL|function|getError
name|GLenum
name|Context
operator|::
name|getError
parameter_list|()
block|{
if|if
condition|(
name|mErrors
operator|.
name|empty
argument_list|()
condition|)
block|{
return|return
name|GL_NO_ERROR
return|;
block|}
else|else
block|{
name|GLenum
name|error
init|=
operator|*
name|mErrors
operator|.
name|begin
argument_list|()
decl_stmt|;
name|mErrors
operator|.
name|erase
argument_list|(
name|mErrors
operator|.
name|begin
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
DECL|function|getResetStatus
name|GLenum
name|Context
operator|::
name|getResetStatus
parameter_list|()
block|{
comment|//TODO(jmadill): needs MANGLE reworking
if|if
condition|(
name|mResetStatus
operator|==
name|GL_NO_ERROR
operator|&&
operator|!
name|mContextLost
condition|)
block|{
comment|// mResetStatus will be set by the markContextLost callback
comment|// in the case a notification is sent
if|if
condition|(
name|mRenderer
operator|->
name|testDeviceLost
argument_list|()
condition|)
block|{
name|mRenderer
operator|->
name|notifyDeviceLost
argument_list|()
expr_stmt|;
block|}
block|}
name|GLenum
name|status
init|=
name|mResetStatus
decl_stmt|;
if|if
condition|(
name|mResetStatus
operator|!=
name|GL_NO_ERROR
condition|)
block|{
name|ASSERT
argument_list|(
name|mContextLost
argument_list|)
expr_stmt|;
if|if
condition|(
name|mRenderer
operator|->
name|testDeviceResettable
argument_list|()
condition|)
block|{
name|mResetStatus
operator|=
name|GL_NO_ERROR
expr_stmt|;
block|}
block|}
return|return
name|status
return|;
block|}
DECL|function|isResetNotificationEnabled
name|bool
name|Context
operator|::
name|isResetNotificationEnabled
parameter_list|()
block|{
return|return
operator|(
name|mResetStrategy
operator|==
name|GL_LOSE_CONTEXT_ON_RESET_EXT
operator|)
return|;
block|}
DECL|function|getClientVersion
name|int
name|Context
operator|::
name|getClientVersion
parameter_list|()
specifier|const
block|{
return|return
name|mClientVersion
return|;
block|}
DECL|function|getConfigID
name|EGLint
name|Context
operator|::
name|getConfigID
parameter_list|()
specifier|const
block|{
return|return
name|mConfigID
return|;
block|}
DECL|function|getClientType
name|EGLenum
name|Context
operator|::
name|getClientType
parameter_list|()
specifier|const
block|{
return|return
name|mClientType
return|;
block|}
DECL|function|getRenderBuffer
name|EGLenum
name|Context
operator|::
name|getRenderBuffer
parameter_list|()
specifier|const
block|{
return|return
name|mRenderBuffer
return|;
block|}
DECL|function|getCaps
specifier|const
name|Caps
modifier|&
name|Context
operator|::
name|getCaps
parameter_list|()
specifier|const
block|{
return|return
name|mCaps
return|;
block|}
DECL|function|getTextureCaps
specifier|const
name|TextureCapsMap
modifier|&
name|Context
operator|::
name|getTextureCaps
parameter_list|()
specifier|const
block|{
return|return
name|mTextureCaps
return|;
block|}
DECL|function|getExtensions
specifier|const
name|Extensions
modifier|&
name|Context
operator|::
name|getExtensions
parameter_list|()
specifier|const
block|{
return|return
name|mExtensions
return|;
block|}
DECL|function|detachTexture
name|void
name|Context
operator|::
name|detachTexture
parameter_list|(
name|GLuint
name|texture
parameter_list|)
block|{
comment|// Simple pass-through to State's detachTexture method, as textures do not require
comment|// allocation map management either here or in the resource manager at detach time.
comment|// Zero textures are held by the Context, and we don't attempt to request them from
comment|// the State.
name|mState
operator|.
name|detachTexture
argument_list|(
name|mZeroTextures
argument_list|,
name|texture
argument_list|)
expr_stmt|;
block|}
DECL|function|detachBuffer
name|void
name|Context
operator|::
name|detachBuffer
parameter_list|(
name|GLuint
name|buffer
parameter_list|)
block|{
comment|// Buffer detachment is handled by Context, because the buffer must also be
comment|// attached from any VAOs in existence, and Context holds the VAO map.
comment|// [OpenGL ES 2.0.24] section 2.9 page 22:
comment|// If a buffer object is deleted while it is bound, all bindings to that object in the current context
comment|// (i.e. in the thread that called Delete-Buffers) are reset to zero.
name|mState
operator|.
name|removeArrayBufferBinding
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|// mark as freed among the vertex array objects
for|for
control|(
name|auto
name|vaoIt
init|=
name|mVertexArrayMap
operator|.
name|begin
argument_list|()
init|;
name|vaoIt
operator|!=
name|mVertexArrayMap
operator|.
name|end
argument_list|()
condition|;
name|vaoIt
operator|++
control|)
block|{
name|vaoIt
operator|->
name|second
operator|->
name|detachBuffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|detachFramebuffer
name|void
name|Context
operator|::
name|detachFramebuffer
parameter_list|(
name|GLuint
name|framebuffer
parameter_list|)
block|{
comment|// Framebuffer detachment is handled by Context, because 0 is a valid
comment|// Framebuffer object, and a pointer to it must be passed from Context
comment|// to State at binding time.
comment|// [OpenGL ES 2.0.24] section 4.4 page 107:
comment|// If a framebuffer that is currently bound to the target FRAMEBUFFER is deleted, it is as though
comment|// BindFramebuffer had been executed with the target of FRAMEBUFFER and framebuffer of zero.
if|if
condition|(
name|mState
operator|.
name|removeReadFramebufferBinding
argument_list|(
name|framebuffer
argument_list|)
operator|&&
name|framebuffer
operator|!=
literal|0
condition|)
block|{
name|bindReadFramebuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mState
operator|.
name|removeDrawFramebufferBinding
argument_list|(
name|framebuffer
argument_list|)
operator|&&
name|framebuffer
operator|!=
literal|0
condition|)
block|{
name|bindDrawFramebuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|detachRenderbuffer
name|void
name|Context
operator|::
name|detachRenderbuffer
parameter_list|(
name|GLuint
name|renderbuffer
parameter_list|)
block|{
name|mState
operator|.
name|detachRenderbuffer
argument_list|(
name|renderbuffer
argument_list|)
expr_stmt|;
block|}
DECL|function|detachVertexArray
name|void
name|Context
operator|::
name|detachVertexArray
parameter_list|(
name|GLuint
name|vertexArray
parameter_list|)
block|{
comment|// Vertex array detachment is handled by Context, because 0 is a valid
comment|// VAO, and a pointer to it must be passed from Context to State at
comment|// binding time.
comment|// [OpenGL ES 3.0.2] section 2.10 page 43:
comment|// If a vertex array object that is currently bound is deleted, the binding
comment|// for that object reverts to zero and the default vertex array becomes current.
if|if
condition|(
name|mState
operator|.
name|removeVertexArrayBinding
argument_list|(
name|vertexArray
argument_list|)
condition|)
block|{
name|bindVertexArray
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|detachTransformFeedback
name|void
name|Context
operator|::
name|detachTransformFeedback
parameter_list|(
name|GLuint
name|transformFeedback
parameter_list|)
block|{
name|mState
operator|.
name|detachTransformFeedback
argument_list|(
name|transformFeedback
argument_list|)
expr_stmt|;
block|}
DECL|function|detachSampler
name|void
name|Context
operator|::
name|detachSampler
parameter_list|(
name|GLuint
name|sampler
parameter_list|)
block|{
name|mState
operator|.
name|detachSampler
argument_list|(
name|sampler
argument_list|)
expr_stmt|;
block|}
DECL|function|setVertexAttribDivisor
name|void
name|Context
operator|::
name|setVertexAttribDivisor
parameter_list|(
name|GLuint
name|index
parameter_list|,
name|GLuint
name|divisor
parameter_list|)
block|{
name|mState
operator|.
name|getVertexArray
argument_list|()
operator|->
name|setVertexAttribDivisor
argument_list|(
name|index
argument_list|,
name|divisor
argument_list|)
expr_stmt|;
block|}
DECL|function|samplerParameteri
name|void
name|Context
operator|::
name|samplerParameteri
parameter_list|(
name|GLuint
name|sampler
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLint
name|param
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkSamplerAllocation
argument_list|(
name|sampler
argument_list|)
expr_stmt|;
name|Sampler
modifier|*
name|samplerObject
init|=
name|getSampler
argument_list|(
name|sampler
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|samplerObject
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_TEXTURE_MIN_FILTER
case|:
name|samplerObject
operator|->
name|setMinFilter
argument_list|(
cast|static_cast
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_MAG_FILTER
case|:
name|samplerObject
operator|->
name|setMagFilter
argument_list|(
cast|static_cast
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_WRAP_S
case|:
name|samplerObject
operator|->
name|setWrapS
argument_list|(
cast|static_cast
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_WRAP_T
case|:
name|samplerObject
operator|->
name|setWrapT
argument_list|(
cast|static_cast
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_WRAP_R
case|:
name|samplerObject
operator|->
name|setWrapR
argument_list|(
cast|static_cast
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_MIN_LOD
case|:
name|samplerObject
operator|->
name|setMinLod
argument_list|(
cast|static_cast
argument_list|<
name|GLfloat
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_MAX_LOD
case|:
name|samplerObject
operator|->
name|setMaxLod
argument_list|(
cast|static_cast
argument_list|<
name|GLfloat
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_COMPARE_MODE
case|:
name|samplerObject
operator|->
name|setComparisonMode
argument_list|(
cast|static_cast
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_COMPARE_FUNC
case|:
name|samplerObject
operator|->
name|setComparisonFunc
argument_list|(
cast|static_cast
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
DECL|function|samplerParameterf
name|void
name|Context
operator|::
name|samplerParameterf
parameter_list|(
name|GLuint
name|sampler
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLfloat
name|param
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkSamplerAllocation
argument_list|(
name|sampler
argument_list|)
expr_stmt|;
name|Sampler
modifier|*
name|samplerObject
init|=
name|getSampler
argument_list|(
name|sampler
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|samplerObject
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_TEXTURE_MIN_FILTER
case|:
name|samplerObject
operator|->
name|setMinFilter
argument_list|(
name|uiround
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_MAG_FILTER
case|:
name|samplerObject
operator|->
name|setMagFilter
argument_list|(
name|uiround
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_WRAP_S
case|:
name|samplerObject
operator|->
name|setWrapS
argument_list|(
name|uiround
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_WRAP_T
case|:
name|samplerObject
operator|->
name|setWrapT
argument_list|(
name|uiround
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_WRAP_R
case|:
name|samplerObject
operator|->
name|setWrapR
argument_list|(
name|uiround
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_MIN_LOD
case|:
name|samplerObject
operator|->
name|setMinLod
argument_list|(
name|param
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_MAX_LOD
case|:
name|samplerObject
operator|->
name|setMaxLod
argument_list|(
name|param
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_COMPARE_MODE
case|:
name|samplerObject
operator|->
name|setComparisonMode
argument_list|(
name|uiround
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_COMPARE_FUNC
case|:
name|samplerObject
operator|->
name|setComparisonFunc
argument_list|(
name|uiround
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
DECL|function|getSamplerParameteri
name|GLint
name|Context
operator|::
name|getSamplerParameteri
parameter_list|(
name|GLuint
name|sampler
parameter_list|,
name|GLenum
name|pname
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkSamplerAllocation
argument_list|(
name|sampler
argument_list|)
expr_stmt|;
name|Sampler
modifier|*
name|samplerObject
init|=
name|getSampler
argument_list|(
name|sampler
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|samplerObject
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_TEXTURE_MIN_FILTER
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getMinFilter
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_MAG_FILTER
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getMagFilter
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_WRAP_S
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getWrapS
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_WRAP_T
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getWrapT
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_WRAP_R
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getWrapR
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_MIN_LOD
case|:
return|return
name|uiround
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getMinLod
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_MAX_LOD
case|:
return|return
name|uiround
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getMaxLod
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_COMPARE_MODE
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getComparisonMode
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_COMPARE_FUNC
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getComparisonFunc
argument_list|()
argument_list|)
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|getSamplerParameterf
name|GLfloat
name|Context
operator|::
name|getSamplerParameterf
parameter_list|(
name|GLuint
name|sampler
parameter_list|,
name|GLenum
name|pname
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkSamplerAllocation
argument_list|(
name|sampler
argument_list|)
expr_stmt|;
name|Sampler
modifier|*
name|samplerObject
init|=
name|getSampler
argument_list|(
name|sampler
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|samplerObject
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_TEXTURE_MIN_FILTER
case|:
return|return
cast|static_cast
argument_list|<
name|GLfloat
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getMinFilter
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_MAG_FILTER
case|:
return|return
cast|static_cast
argument_list|<
name|GLfloat
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getMagFilter
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_WRAP_S
case|:
return|return
cast|static_cast
argument_list|<
name|GLfloat
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getWrapS
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_WRAP_T
case|:
return|return
cast|static_cast
argument_list|<
name|GLfloat
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getWrapT
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_WRAP_R
case|:
return|return
cast|static_cast
argument_list|<
name|GLfloat
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getWrapR
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_MIN_LOD
case|:
return|return
name|samplerObject
operator|->
name|getMinLod
argument_list|()
return|;
case|case
name|GL_TEXTURE_MAX_LOD
case|:
return|return
name|samplerObject
operator|->
name|getMaxLod
argument_list|()
return|;
case|case
name|GL_TEXTURE_COMPARE_MODE
case|:
return|return
cast|static_cast
argument_list|<
name|GLfloat
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getComparisonMode
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_COMPARE_FUNC
case|:
return|return
cast|static_cast
argument_list|<
name|GLfloat
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getComparisonFunc
argument_list|()
argument_list|)
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|initRendererString
name|void
name|Context
operator|::
name|initRendererString
parameter_list|()
block|{
name|std
operator|::
name|ostringstream
name|rendererString
decl_stmt|;
name|rendererString
operator|<<
literal|"ANGLE ("
expr_stmt|;
name|rendererString
operator|<<
name|mRenderer
operator|->
name|getRendererDescription
argument_list|()
expr_stmt|;
name|rendererString
operator|<<
literal|")"
expr_stmt|;
name|mRendererString
operator|=
name|MakeStaticString
argument_list|(
name|rendererString
operator|.
name|str
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|function|getRendererString
specifier|const
name|std
operator|::
name|string
modifier|&
name|Context
operator|::
name|getRendererString
parameter_list|()
specifier|const
block|{
return|return
name|mRendererString
return|;
block|}
DECL|function|initExtensionStrings
name|void
name|Context
operator|::
name|initExtensionStrings
parameter_list|()
block|{
name|mExtensionStrings
operator|=
name|mExtensions
operator|.
name|getStrings
argument_list|()
expr_stmt|;
name|std
operator|::
name|ostringstream
name|combinedStringStream
decl_stmt|;
name|std
operator|::
name|copy
argument_list|(
name|mExtensionStrings
operator|.
name|begin
argument_list|()
argument_list|,
name|mExtensionStrings
operator|.
name|end
argument_list|()
argument_list|,
name|std
operator|::
name|ostream_iterator
argument_list|<
name|std
operator|::
name|string
argument_list|>
argument_list|(
name|combinedStringStream
argument_list|,
literal|" "
argument_list|)
argument_list|)
expr_stmt|;
name|mExtensionString
operator|=
name|combinedStringStream
operator|.
name|str
argument_list|()
expr_stmt|;
block|}
DECL|function|getExtensionString
specifier|const
name|std
operator|::
name|string
modifier|&
name|Context
operator|::
name|getExtensionString
parameter_list|()
specifier|const
block|{
return|return
name|mExtensionString
return|;
block|}
DECL|function|getExtensionString
specifier|const
name|std
operator|::
name|string
modifier|&
name|Context
operator|::
name|getExtensionString
parameter_list|(
name|size_t
name|idx
parameter_list|)
specifier|const
block|{
return|return
name|mExtensionStrings
index|[
name|idx
index|]
return|;
block|}
DECL|function|getExtensionStringCount
name|size_t
name|Context
operator|::
name|getExtensionStringCount
parameter_list|()
specifier|const
block|{
return|return
name|mExtensionStrings
operator|.
name|size
argument_list|()
return|;
block|}
DECL|function|initCaps
name|void
name|Context
operator|::
name|initCaps
parameter_list|(
name|GLuint
name|clientVersion
parameter_list|)
block|{
name|mCaps
operator|=
name|mRenderer
operator|->
name|getRendererCaps
argument_list|()
expr_stmt|;
name|mExtensions
operator|=
name|mRenderer
operator|->
name|getRendererExtensions
argument_list|()
expr_stmt|;
if|if
condition|(
name|clientVersion
operator|<
literal|3
condition|)
block|{
comment|// Disable ES3+ extensions
name|mExtensions
operator|.
name|colorBufferFloat
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|clientVersion
operator|>
literal|2
condition|)
block|{
comment|// FIXME(geofflang): Don't support EXT_sRGB in non-ES2 contexts
comment|//mExtensions.sRGB = false;
block|}
comment|// Apply implementation limits
name|mCaps
operator|.
name|maxVertexAttributes
operator|=
name|std
operator|::
name|min
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|mCaps
operator|.
name|maxVertexAttributes
argument_list|,
name|MAX_VERTEX_ATTRIBS
argument_list|)
expr_stmt|;
name|mCaps
operator|.
name|maxVertexUniformBlocks
operator|=
name|std
operator|::
name|min
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|mCaps
operator|.
name|maxVertexUniformBlocks
argument_list|,
name|IMPLEMENTATION_MAX_VERTEX_SHADER_UNIFORM_BUFFERS
argument_list|)
expr_stmt|;
name|mCaps
operator|.
name|maxVertexOutputComponents
operator|=
name|std
operator|::
name|min
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|mCaps
operator|.
name|maxVertexOutputComponents
argument_list|,
name|IMPLEMENTATION_MAX_VARYING_VECTORS
operator|*
literal|4
argument_list|)
expr_stmt|;
name|mCaps
operator|.
name|maxFragmentInputComponents
operator|=
name|std
operator|::
name|min
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|mCaps
operator|.
name|maxFragmentInputComponents
argument_list|,
name|IMPLEMENTATION_MAX_VARYING_VECTORS
operator|*
literal|4
argument_list|)
expr_stmt|;
name|GLuint
name|maxSamples
init|=
literal|0
decl_stmt|;
name|mCaps
operator|.
name|compressedTextureFormats
operator|.
name|clear
argument_list|()
expr_stmt|;
specifier|const
name|TextureCapsMap
modifier|&
name|rendererFormats
init|=
name|mRenderer
operator|->
name|getRendererTextureCaps
argument_list|()
decl_stmt|;
for|for
control|(
name|TextureCapsMap
operator|::
name|const_iterator
name|i
init|=
name|rendererFormats
operator|.
name|begin
argument_list|()
init|;
name|i
operator|!=
name|rendererFormats
operator|.
name|end
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|GLenum
name|format
init|=
name|i
operator|->
name|first
decl_stmt|;
name|TextureCaps
name|formatCaps
init|=
name|i
operator|->
name|second
decl_stmt|;
specifier|const
name|InternalFormat
modifier|&
name|formatInfo
init|=
name|GetInternalFormatInfo
argument_list|(
name|format
argument_list|)
decl_stmt|;
comment|// Update the format caps based on the client version and extensions
name|formatCaps
operator|.
name|texturable
operator|=
name|formatInfo
operator|.
name|textureSupport
argument_list|(
name|clientVersion
argument_list|,
name|mExtensions
argument_list|)
expr_stmt|;
name|formatCaps
operator|.
name|renderable
operator|=
name|formatInfo
operator|.
name|renderSupport
argument_list|(
name|clientVersion
argument_list|,
name|mExtensions
argument_list|)
expr_stmt|;
name|formatCaps
operator|.
name|filterable
operator|=
name|formatInfo
operator|.
name|filterSupport
argument_list|(
name|clientVersion
argument_list|,
name|mExtensions
argument_list|)
expr_stmt|;
comment|// OpenGL ES does not support multisampling with integer formats
if|if
condition|(
operator|!
name|formatInfo
operator|.
name|renderSupport
operator|||
name|formatInfo
operator|.
name|componentType
operator|==
name|GL_INT
operator|||
name|formatInfo
operator|.
name|componentType
operator|==
name|GL_UNSIGNED_INT
condition|)
block|{
name|formatCaps
operator|.
name|sampleCounts
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|maxSamples
operator|=
name|std
operator|::
name|max
argument_list|(
name|maxSamples
argument_list|,
name|formatCaps
operator|.
name|getMaxSamples
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|formatCaps
operator|.
name|texturable
operator|&&
name|formatInfo
operator|.
name|compressed
condition|)
block|{
name|mCaps
operator|.
name|compressedTextureFormats
operator|.
name|push_back
argument_list|(
name|format
argument_list|)
expr_stmt|;
block|}
name|mTextureCaps
operator|.
name|insert
argument_list|(
name|format
argument_list|,
name|formatCaps
argument_list|)
expr_stmt|;
block|}
name|mExtensions
operator|.
name|maxSamples
operator|=
name|maxSamples
expr_stmt|;
block|}
DECL|function|getData
name|Data
name|Context
operator|::
name|getData
parameter_list|()
specifier|const
block|{
return|return
name|Data
argument_list|(
name|mClientVersion
argument_list|,
name|mState
argument_list|,
name|mCaps
argument_list|,
name|mTextureCaps
argument_list|,
name|mExtensions
argument_list|,
name|mResourceManager
argument_list|)
return|;
block|}
block|}
end_namespace
end_unit
