begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Context.cpp: Implements the gl::Context class, managing all GL state and performing
end_comment
begin_comment
comment|// rendering operations. It is the GLES2 specific implementation of EGLContext.
end_comment
begin_include
include|#
directive|include
file|"libANGLE/Context.h"
end_include
begin_include
include|#
directive|include
file|<iterator>
end_include
begin_include
include|#
directive|include
file|<sstream>
end_include
begin_include
include|#
directive|include
file|"common/platform.h"
end_include
begin_include
include|#
directive|include
file|"common/utilities.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Buffer.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Compiler.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Display.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Fence.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Framebuffer.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/FramebufferAttachment.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Program.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Query.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Renderbuffer.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/ResourceManager.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Sampler.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Surface.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/Texture.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/TransformFeedback.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/VertexArray.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/formatutils.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/validationES.h"
end_include
begin_include
include|#
directive|include
file|"libANGLE/renderer/Renderer.h"
end_include
begin_namespace
namespace|namespace
block|{
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|GetQueryObjectParameter
name|gl
operator|::
name|Error
name|GetQueryObjectParameter
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|GLuint
name|id
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|T
modifier|*
name|params
parameter_list|)
block|{
name|gl
operator|::
name|Query
modifier|*
name|queryObject
init|=
name|context
operator|->
name|getQuery
argument_list|(
name|id
argument_list|,
literal|false
argument_list|,
name|GL_NONE
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|queryObject
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_QUERY_RESULT_EXT
case|:
return|return
name|queryObject
operator|->
name|getResult
argument_list|(
name|params
argument_list|)
return|;
case|case
name|GL_QUERY_RESULT_AVAILABLE_EXT
case|:
block|{
name|bool
name|available
decl_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|queryObject
operator|->
name|isResultAvailable
argument_list|(
operator|&
name|available
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
operator|*
name|params
operator|=
cast|static_cast
argument_list|<
name|T
argument_list|>
argument_list|(
name|available
condition|?
name|GL_TRUE
else|:
name|GL_FALSE
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|gl
operator|::
name|Error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|"Unreachable Error"
argument_list|)
return|;
block|}
block|}
DECL|function|MarkTransformFeedbackBufferUsage
name|void
name|MarkTransformFeedbackBufferUsage
parameter_list|(
name|gl
operator|::
name|TransformFeedback
modifier|*
name|transformFeedback
parameter_list|)
block|{
if|if
condition|(
name|transformFeedback
operator|&&
name|transformFeedback
operator|->
name|isActive
argument_list|()
operator|&&
operator|!
name|transformFeedback
operator|->
name|isPaused
argument_list|()
condition|)
block|{
for|for
control|(
name|size_t
name|tfBufferIndex
init|=
literal|0
init|;
name|tfBufferIndex
operator|<
name|transformFeedback
operator|->
name|getIndexedBufferCount
argument_list|()
condition|;
name|tfBufferIndex
operator|++
control|)
block|{
specifier|const
name|OffsetBindingPointer
argument_list|<
name|gl
operator|::
name|Buffer
argument_list|>
modifier|&
name|buffer
init|=
name|transformFeedback
operator|->
name|getIndexedBuffer
argument_list|(
name|tfBufferIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|buffer
operator|.
name|get
argument_list|()
operator|!=
literal|nullptr
condition|)
block|{
name|buffer
operator|->
name|onTransformFeedback
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// Attribute map queries.
DECL|function|GetClientVersion
name|EGLint
name|GetClientVersion
parameter_list|(
specifier|const
name|egl
operator|::
name|AttributeMap
modifier|&
name|attribs
parameter_list|)
block|{
return|return
name|attribs
operator|.
name|get
argument_list|(
name|EGL_CONTEXT_CLIENT_VERSION
argument_list|,
literal|1
argument_list|)
return|;
block|}
DECL|function|GetResetStrategy
name|GLenum
name|GetResetStrategy
parameter_list|(
specifier|const
name|egl
operator|::
name|AttributeMap
modifier|&
name|attribs
parameter_list|)
block|{
name|EGLenum
name|attrib
init|=
name|attribs
operator|.
name|get
argument_list|(
name|EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_EXT
argument_list|,
name|EGL_NO_RESET_NOTIFICATION_EXT
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|attrib
condition|)
block|{
case|case
name|EGL_NO_RESET_NOTIFICATION
case|:
return|return
name|GL_NO_RESET_NOTIFICATION_EXT
return|;
case|case
name|EGL_LOSE_CONTEXT_ON_RESET
case|:
return|return
name|GL_LOSE_CONTEXT_ON_RESET_EXT
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|GL_NONE
return|;
block|}
block|}
DECL|function|GetRobustAccess
name|bool
name|GetRobustAccess
parameter_list|(
specifier|const
name|egl
operator|::
name|AttributeMap
modifier|&
name|attribs
parameter_list|)
block|{
return|return
operator|(
name|attribs
operator|.
name|get
argument_list|(
name|EGL_CONTEXT_OPENGL_ROBUST_ACCESS_EXT
argument_list|,
name|EGL_FALSE
argument_list|)
operator|==
name|EGL_TRUE
operator|)
return|;
block|}
DECL|function|GetDebug
name|bool
name|GetDebug
parameter_list|(
specifier|const
name|egl
operator|::
name|AttributeMap
modifier|&
name|attribs
parameter_list|)
block|{
return|return
operator|(
name|attribs
operator|.
name|get
argument_list|(
name|EGL_CONTEXT_OPENGL_DEBUG
argument_list|,
name|EGL_FALSE
argument_list|)
operator|==
name|EGL_TRUE
operator|)
return|;
block|}
DECL|function|GetNoError
name|bool
name|GetNoError
parameter_list|(
specifier|const
name|egl
operator|::
name|AttributeMap
modifier|&
name|attribs
parameter_list|)
block|{
return|return
operator|(
name|attribs
operator|.
name|get
argument_list|(
name|EGL_CONTEXT_OPENGL_NO_ERROR_KHR
argument_list|,
name|EGL_FALSE
argument_list|)
operator|==
name|EGL_TRUE
operator|)
return|;
block|}
block|}
end_namespace
begin_comment
comment|// anonymous namespace
end_comment
begin_namespace
DECL|namespace|gl
namespace|namespace
name|gl
block|{
DECL|function|Context
name|Context
operator|::
name|Context
parameter_list|(
specifier|const
name|egl
operator|::
name|Config
modifier|*
name|config
parameter_list|,
specifier|const
name|Context
modifier|*
name|shareContext
parameter_list|,
name|rx
operator|::
name|Renderer
modifier|*
name|renderer
parameter_list|,
specifier|const
name|egl
operator|::
name|AttributeMap
modifier|&
name|attribs
parameter_list|)
member_init_list|:
name|ValidationContext
argument_list|(
name|GetClientVersion
argument_list|(
name|attribs
argument_list|)
argument_list|,
name|mState
argument_list|,
name|mCaps
argument_list|,
name|mTextureCaps
argument_list|,
name|mExtensions
argument_list|,
literal|nullptr
argument_list|,
name|mLimitations
argument_list|,
name|GetNoError
argument_list|(
name|attribs
argument_list|)
argument_list|)
member_init_list|,
name|mCompiler
argument_list|(
literal|nullptr
argument_list|)
member_init_list|,
name|mRenderer
argument_list|(
name|renderer
argument_list|)
member_init_list|,
name|mClientVersion
argument_list|(
name|GetClientVersion
argument_list|(
name|attribs
argument_list|)
argument_list|)
member_init_list|,
name|mConfig
argument_list|(
name|config
argument_list|)
member_init_list|,
name|mClientType
argument_list|(
name|EGL_OPENGL_ES_API
argument_list|)
member_init_list|,
name|mHasBeenCurrent
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mContextLost
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mResetStatus
argument_list|(
name|GL_NO_ERROR
argument_list|)
member_init_list|,
name|mResetStrategy
argument_list|(
name|GetResetStrategy
argument_list|(
name|attribs
argument_list|)
argument_list|)
member_init_list|,
name|mRobustAccess
argument_list|(
name|GetRobustAccess
argument_list|(
name|attribs
argument_list|)
argument_list|)
member_init_list|,
name|mCurrentSurface
argument_list|(
literal|nullptr
argument_list|)
member_init_list|,
name|mResourceManager
argument_list|(
literal|nullptr
argument_list|)
block|{
name|ASSERT
argument_list|(
operator|!
name|mRobustAccess
argument_list|)
expr_stmt|;
comment|// Unimplemented
name|initCaps
argument_list|(
name|mClientVersion
argument_list|)
expr_stmt|;
name|mState
operator|.
name|initialize
argument_list|(
name|mCaps
argument_list|,
name|mExtensions
argument_list|,
name|mClientVersion
argument_list|,
name|GetDebug
argument_list|(
name|attribs
argument_list|)
argument_list|)
expr_stmt|;
name|mFenceNVHandleAllocator
operator|.
name|setBaseHandle
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|shareContext
operator|!=
name|NULL
condition|)
block|{
name|mResourceManager
operator|=
name|shareContext
operator|->
name|mResourceManager
expr_stmt|;
name|mResourceManager
operator|->
name|addRef
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|mResourceManager
operator|=
operator|new
name|ResourceManager
argument_list|(
name|mRenderer
argument_list|)
expr_stmt|;
block|}
name|mData
operator|.
name|resourceManager
operator|=
name|mResourceManager
expr_stmt|;
comment|// [OpenGL ES 2.0.24] section 3.7 page 83:
comment|// In the initial state, TEXTURE_2D and TEXTURE_CUBE_MAP have twodimensional
comment|// and cube map texture state vectors respectively associated with them.
comment|// In order that access to these initial textures not be lost, they are treated as texture
comment|// objects all of whose names are 0.
name|Texture
modifier|*
name|zeroTexture2D
init|=
operator|new
name|Texture
argument_list|(
name|mRenderer
operator|->
name|createTexture
argument_list|(
name|GL_TEXTURE_2D
argument_list|)
argument_list|,
literal|0
argument_list|,
name|GL_TEXTURE_2D
argument_list|)
decl_stmt|;
name|mZeroTextures
index|[
name|GL_TEXTURE_2D
index|]
operator|.
name|set
argument_list|(
name|zeroTexture2D
argument_list|)
expr_stmt|;
name|Texture
modifier|*
name|zeroTextureCube
init|=
operator|new
name|Texture
argument_list|(
name|mRenderer
operator|->
name|createTexture
argument_list|(
name|GL_TEXTURE_CUBE_MAP
argument_list|)
argument_list|,
literal|0
argument_list|,
name|GL_TEXTURE_CUBE_MAP
argument_list|)
decl_stmt|;
name|mZeroTextures
index|[
name|GL_TEXTURE_CUBE_MAP
index|]
operator|.
name|set
argument_list|(
name|zeroTextureCube
argument_list|)
expr_stmt|;
if|if
condition|(
name|mClientVersion
operator|>=
literal|3
condition|)
block|{
comment|// TODO: These could also be enabled via extension
name|Texture
modifier|*
name|zeroTexture3D
init|=
operator|new
name|Texture
argument_list|(
name|mRenderer
operator|->
name|createTexture
argument_list|(
name|GL_TEXTURE_3D
argument_list|)
argument_list|,
literal|0
argument_list|,
name|GL_TEXTURE_3D
argument_list|)
decl_stmt|;
name|mZeroTextures
index|[
name|GL_TEXTURE_3D
index|]
operator|.
name|set
argument_list|(
name|zeroTexture3D
argument_list|)
expr_stmt|;
name|Texture
modifier|*
name|zeroTexture2DArray
init|=
operator|new
name|Texture
argument_list|(
name|mRenderer
operator|->
name|createTexture
argument_list|(
name|GL_TEXTURE_2D_ARRAY
argument_list|)
argument_list|,
literal|0
argument_list|,
name|GL_TEXTURE_2D_ARRAY
argument_list|)
decl_stmt|;
name|mZeroTextures
index|[
name|GL_TEXTURE_2D_ARRAY
index|]
operator|.
name|set
argument_list|(
name|zeroTexture2DArray
argument_list|)
expr_stmt|;
block|}
name|mState
operator|.
name|initializeZeroTextures
argument_list|(
name|mZeroTextures
argument_list|)
expr_stmt|;
name|bindVertexArray
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindArrayBuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindElementArrayBuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindRenderbuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindGenericUniformBuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mCaps
operator|.
name|maxCombinedUniformBlocks
condition|;
name|i
operator|++
control|)
block|{
name|bindIndexedUniformBuffer
argument_list|(
literal|0
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|bindCopyReadBuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindCopyWriteBuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindPixelPackBuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindPixelUnpackBuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mClientVersion
operator|>=
literal|3
condition|)
block|{
comment|// [OpenGL ES 3.0.2] section 2.14.1 pg 85:
comment|// In the initial state, a default transform feedback object is bound and treated as
comment|// a transform feedback object with a name of zero. That object is bound any time
comment|// BindTransformFeedback is called with id of zero
name|bindTransformFeedback
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|mCompiler
operator|=
operator|new
name|Compiler
argument_list|(
name|mRenderer
argument_list|,
name|getData
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|function|~Context
name|Context
operator|::
name|~
name|Context
parameter_list|()
block|{
name|mState
operator|.
name|reset
argument_list|()
expr_stmt|;
for|for
control|(
name|auto
name|framebuffer
range|:
name|mFramebufferMap
control|)
block|{
comment|// Default framebuffer are owned by their respective Surface
if|if
condition|(
name|framebuffer
operator|.
name|second
operator|!=
literal|nullptr
operator|&&
name|framebuffer
operator|.
name|second
operator|->
name|id
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|SafeDelete
argument_list|(
name|framebuffer
operator|.
name|second
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|auto
name|fence
range|:
name|mFenceNVMap
control|)
block|{
name|SafeDelete
argument_list|(
name|fence
operator|.
name|second
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|auto
name|query
range|:
name|mQueryMap
control|)
block|{
if|if
condition|(
name|query
operator|.
name|second
operator|!=
literal|nullptr
condition|)
block|{
name|query
operator|.
name|second
operator|->
name|release
argument_list|()
expr_stmt|;
block|}
block|}
for|for
control|(
name|auto
name|vertexArray
range|:
name|mVertexArrayMap
control|)
block|{
name|SafeDelete
argument_list|(
name|vertexArray
operator|.
name|second
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|auto
name|transformFeedback
range|:
name|mTransformFeedbackMap
control|)
block|{
if|if
condition|(
name|transformFeedback
operator|.
name|second
operator|!=
literal|nullptr
condition|)
block|{
name|transformFeedback
operator|.
name|second
operator|->
name|release
argument_list|()
expr_stmt|;
block|}
block|}
for|for
control|(
name|auto
operator|&
name|zeroTexture
operator|:
name|mZeroTextures
control|)
block|{
name|zeroTexture
operator|.
name|second
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
name|mZeroTextures
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|mCurrentSurface
operator|!=
literal|nullptr
condition|)
block|{
name|releaseSurface
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|mResourceManager
condition|)
block|{
name|mResourceManager
operator|->
name|release
argument_list|()
expr_stmt|;
block|}
name|SafeDelete
argument_list|(
name|mCompiler
argument_list|)
expr_stmt|;
block|}
DECL|function|makeCurrent
name|void
name|Context
operator|::
name|makeCurrent
parameter_list|(
name|egl
operator|::
name|Surface
modifier|*
name|surface
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|surface
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mHasBeenCurrent
condition|)
block|{
name|initRendererString
argument_list|()
expr_stmt|;
name|initExtensionStrings
argument_list|()
expr_stmt|;
name|mState
operator|.
name|setViewportParams
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|surface
operator|->
name|getWidth
argument_list|()
argument_list|,
name|surface
operator|->
name|getHeight
argument_list|()
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setScissorParams
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|surface
operator|->
name|getWidth
argument_list|()
argument_list|,
name|surface
operator|->
name|getHeight
argument_list|()
argument_list|)
expr_stmt|;
name|mHasBeenCurrent
operator|=
literal|true
expr_stmt|;
block|}
comment|// TODO(jmadill): Rework this when we support ContextImpl
name|mState
operator|.
name|setAllDirtyBits
argument_list|()
expr_stmt|;
if|if
condition|(
name|mCurrentSurface
condition|)
block|{
name|releaseSurface
argument_list|()
expr_stmt|;
block|}
name|surface
operator|->
name|setIsCurrent
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|mCurrentSurface
operator|=
name|surface
expr_stmt|;
comment|// Update default framebuffer, the binding of the previous default
comment|// framebuffer (or lack of) will have a nullptr.
block|{
name|Framebuffer
modifier|*
name|newDefault
init|=
name|surface
operator|->
name|getDefaultFramebuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|mState
operator|.
name|getReadFramebuffer
argument_list|()
operator|==
literal|nullptr
condition|)
block|{
name|mState
operator|.
name|setReadFramebufferBinding
argument_list|(
name|newDefault
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mState
operator|.
name|getDrawFramebuffer
argument_list|()
operator|==
literal|nullptr
condition|)
block|{
name|mState
operator|.
name|setDrawFramebufferBinding
argument_list|(
name|newDefault
argument_list|)
expr_stmt|;
block|}
name|mFramebufferMap
index|[
literal|0
index|]
operator|=
name|newDefault
expr_stmt|;
block|}
comment|// Notify the renderer of a context switch
name|mRenderer
operator|->
name|onMakeCurrent
argument_list|(
name|getData
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|function|releaseSurface
name|void
name|Context
operator|::
name|releaseSurface
parameter_list|()
block|{
name|ASSERT
argument_list|(
name|mCurrentSurface
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
comment|// Remove the default framebuffer
block|{
name|Framebuffer
modifier|*
name|currentDefault
init|=
name|mCurrentSurface
operator|->
name|getDefaultFramebuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|mState
operator|.
name|getReadFramebuffer
argument_list|()
operator|==
name|currentDefault
condition|)
block|{
name|mState
operator|.
name|setReadFramebufferBinding
argument_list|(
literal|nullptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mState
operator|.
name|getDrawFramebuffer
argument_list|()
operator|==
name|currentDefault
condition|)
block|{
name|mState
operator|.
name|setDrawFramebufferBinding
argument_list|(
literal|nullptr
argument_list|)
expr_stmt|;
block|}
name|mFramebufferMap
operator|.
name|erase
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|mCurrentSurface
operator|->
name|setIsCurrent
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|mCurrentSurface
operator|=
literal|nullptr
expr_stmt|;
block|}
comment|// NOTE: this function should not assume that this context is current!
DECL|function|markContextLost
name|void
name|Context
operator|::
name|markContextLost
parameter_list|()
block|{
if|if
condition|(
name|mResetStrategy
operator|==
name|GL_LOSE_CONTEXT_ON_RESET_EXT
condition|)
name|mResetStatus
operator|=
name|GL_UNKNOWN_CONTEXT_RESET_EXT
expr_stmt|;
name|mContextLost
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|isContextLost
name|bool
name|Context
operator|::
name|isContextLost
parameter_list|()
block|{
return|return
name|mContextLost
return|;
block|}
DECL|function|createBuffer
name|GLuint
name|Context
operator|::
name|createBuffer
parameter_list|()
block|{
return|return
name|mResourceManager
operator|->
name|createBuffer
argument_list|()
return|;
block|}
DECL|function|createProgram
name|GLuint
name|Context
operator|::
name|createProgram
parameter_list|()
block|{
return|return
name|mResourceManager
operator|->
name|createProgram
argument_list|()
return|;
block|}
DECL|function|createShader
name|GLuint
name|Context
operator|::
name|createShader
parameter_list|(
name|GLenum
name|type
parameter_list|)
block|{
return|return
name|mResourceManager
operator|->
name|createShader
argument_list|(
name|mRenderer
operator|->
name|getRendererLimitations
argument_list|()
argument_list|,
name|type
argument_list|)
return|;
block|}
DECL|function|createTexture
name|GLuint
name|Context
operator|::
name|createTexture
parameter_list|()
block|{
return|return
name|mResourceManager
operator|->
name|createTexture
argument_list|()
return|;
block|}
DECL|function|createRenderbuffer
name|GLuint
name|Context
operator|::
name|createRenderbuffer
parameter_list|()
block|{
return|return
name|mResourceManager
operator|->
name|createRenderbuffer
argument_list|()
return|;
block|}
DECL|function|createFenceSync
name|GLsync
name|Context
operator|::
name|createFenceSync
parameter_list|()
block|{
name|GLuint
name|handle
init|=
name|mResourceManager
operator|->
name|createFenceSync
argument_list|()
decl_stmt|;
return|return
cast|reinterpret_cast
argument_list|<
name|GLsync
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
name|uintptr_t
argument_list|>
argument_list|(
name|handle
argument_list|)
argument_list|)
return|;
block|}
DECL|function|createVertexArray
name|GLuint
name|Context
operator|::
name|createVertexArray
parameter_list|()
block|{
name|GLuint
name|vertexArray
init|=
name|mVertexArrayHandleAllocator
operator|.
name|allocate
argument_list|()
decl_stmt|;
name|mVertexArrayMap
index|[
name|vertexArray
index|]
operator|=
literal|nullptr
expr_stmt|;
return|return
name|vertexArray
return|;
block|}
DECL|function|createSampler
name|GLuint
name|Context
operator|::
name|createSampler
parameter_list|()
block|{
return|return
name|mResourceManager
operator|->
name|createSampler
argument_list|()
return|;
block|}
DECL|function|createTransformFeedback
name|GLuint
name|Context
operator|::
name|createTransformFeedback
parameter_list|()
block|{
name|GLuint
name|transformFeedback
init|=
name|mTransformFeedbackAllocator
operator|.
name|allocate
argument_list|()
decl_stmt|;
name|mTransformFeedbackMap
index|[
name|transformFeedback
index|]
operator|=
literal|nullptr
expr_stmt|;
return|return
name|transformFeedback
return|;
block|}
comment|// Returns an unused framebuffer name
DECL|function|createFramebuffer
name|GLuint
name|Context
operator|::
name|createFramebuffer
parameter_list|()
block|{
name|GLuint
name|handle
init|=
name|mFramebufferHandleAllocator
operator|.
name|allocate
argument_list|()
decl_stmt|;
name|mFramebufferMap
index|[
name|handle
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|handle
return|;
block|}
DECL|function|createFenceNV
name|GLuint
name|Context
operator|::
name|createFenceNV
parameter_list|()
block|{
name|GLuint
name|handle
init|=
name|mFenceNVHandleAllocator
operator|.
name|allocate
argument_list|()
decl_stmt|;
name|mFenceNVMap
index|[
name|handle
index|]
operator|=
operator|new
name|FenceNV
argument_list|(
name|mRenderer
operator|->
name|createFenceNV
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|handle
return|;
block|}
comment|// Returns an unused query name
DECL|function|createQuery
name|GLuint
name|Context
operator|::
name|createQuery
parameter_list|()
block|{
name|GLuint
name|handle
init|=
name|mQueryHandleAllocator
operator|.
name|allocate
argument_list|()
decl_stmt|;
name|mQueryMap
index|[
name|handle
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|handle
return|;
block|}
DECL|function|deleteBuffer
name|void
name|Context
operator|::
name|deleteBuffer
parameter_list|(
name|GLuint
name|buffer
parameter_list|)
block|{
if|if
condition|(
name|mResourceManager
operator|->
name|getBuffer
argument_list|(
name|buffer
argument_list|)
condition|)
block|{
name|detachBuffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
name|mResourceManager
operator|->
name|deleteBuffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
DECL|function|deleteShader
name|void
name|Context
operator|::
name|deleteShader
parameter_list|(
name|GLuint
name|shader
parameter_list|)
block|{
name|mResourceManager
operator|->
name|deleteShader
argument_list|(
name|shader
argument_list|)
expr_stmt|;
block|}
DECL|function|deleteProgram
name|void
name|Context
operator|::
name|deleteProgram
parameter_list|(
name|GLuint
name|program
parameter_list|)
block|{
name|mResourceManager
operator|->
name|deleteProgram
argument_list|(
name|program
argument_list|)
expr_stmt|;
block|}
DECL|function|deleteTexture
name|void
name|Context
operator|::
name|deleteTexture
parameter_list|(
name|GLuint
name|texture
parameter_list|)
block|{
if|if
condition|(
name|mResourceManager
operator|->
name|getTexture
argument_list|(
name|texture
argument_list|)
condition|)
block|{
name|detachTexture
argument_list|(
name|texture
argument_list|)
expr_stmt|;
block|}
name|mResourceManager
operator|->
name|deleteTexture
argument_list|(
name|texture
argument_list|)
expr_stmt|;
block|}
DECL|function|deleteRenderbuffer
name|void
name|Context
operator|::
name|deleteRenderbuffer
parameter_list|(
name|GLuint
name|renderbuffer
parameter_list|)
block|{
if|if
condition|(
name|mResourceManager
operator|->
name|getRenderbuffer
argument_list|(
name|renderbuffer
argument_list|)
condition|)
block|{
name|detachRenderbuffer
argument_list|(
name|renderbuffer
argument_list|)
expr_stmt|;
block|}
name|mResourceManager
operator|->
name|deleteRenderbuffer
argument_list|(
name|renderbuffer
argument_list|)
expr_stmt|;
block|}
DECL|function|deleteFenceSync
name|void
name|Context
operator|::
name|deleteFenceSync
parameter_list|(
name|GLsync
name|fenceSync
parameter_list|)
block|{
comment|// The spec specifies the underlying Fence object is not deleted until all current
comment|// wait commands finish. However, since the name becomes invalid, we cannot query the fence,
comment|// and since our API is currently designed for being called from a single thread, we can delete
comment|// the fence immediately.
name|mResourceManager
operator|->
name|deleteFenceSync
argument_list|(
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
cast|reinterpret_cast
argument_list|<
name|uintptr_t
argument_list|>
argument_list|(
name|fenceSync
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|deleteVertexArray
name|void
name|Context
operator|::
name|deleteVertexArray
parameter_list|(
name|GLuint
name|vertexArray
parameter_list|)
block|{
name|auto
name|iter
init|=
name|mVertexArrayMap
operator|.
name|find
argument_list|(
name|vertexArray
argument_list|)
decl_stmt|;
if|if
condition|(
name|iter
operator|!=
name|mVertexArrayMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|VertexArray
modifier|*
name|vertexArrayObject
init|=
name|iter
operator|->
name|second
decl_stmt|;
if|if
condition|(
name|vertexArrayObject
operator|!=
literal|nullptr
condition|)
block|{
name|detachVertexArray
argument_list|(
name|vertexArray
argument_list|)
expr_stmt|;
operator|delete
name|vertexArrayObject
expr_stmt|;
block|}
name|mVertexArrayMap
operator|.
name|erase
argument_list|(
name|iter
argument_list|)
expr_stmt|;
name|mVertexArrayHandleAllocator
operator|.
name|release
argument_list|(
name|vertexArray
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|deleteSampler
name|void
name|Context
operator|::
name|deleteSampler
parameter_list|(
name|GLuint
name|sampler
parameter_list|)
block|{
if|if
condition|(
name|mResourceManager
operator|->
name|getSampler
argument_list|(
name|sampler
argument_list|)
condition|)
block|{
name|detachSampler
argument_list|(
name|sampler
argument_list|)
expr_stmt|;
block|}
name|mResourceManager
operator|->
name|deleteSampler
argument_list|(
name|sampler
argument_list|)
expr_stmt|;
block|}
DECL|function|deleteTransformFeedback
name|void
name|Context
operator|::
name|deleteTransformFeedback
parameter_list|(
name|GLuint
name|transformFeedback
parameter_list|)
block|{
name|auto
name|iter
init|=
name|mTransformFeedbackMap
operator|.
name|find
argument_list|(
name|transformFeedback
argument_list|)
decl_stmt|;
if|if
condition|(
name|iter
operator|!=
name|mTransformFeedbackMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|TransformFeedback
modifier|*
name|transformFeedbackObject
init|=
name|iter
operator|->
name|second
decl_stmt|;
if|if
condition|(
name|transformFeedbackObject
operator|!=
literal|nullptr
condition|)
block|{
name|detachTransformFeedback
argument_list|(
name|transformFeedback
argument_list|)
expr_stmt|;
name|transformFeedbackObject
operator|->
name|release
argument_list|()
expr_stmt|;
block|}
name|mTransformFeedbackMap
operator|.
name|erase
argument_list|(
name|iter
argument_list|)
expr_stmt|;
name|mTransformFeedbackAllocator
operator|.
name|release
argument_list|(
name|transformFeedback
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|deleteFramebuffer
name|void
name|Context
operator|::
name|deleteFramebuffer
parameter_list|(
name|GLuint
name|framebuffer
parameter_list|)
block|{
name|FramebufferMap
operator|::
name|iterator
name|framebufferObject
init|=
name|mFramebufferMap
operator|.
name|find
argument_list|(
name|framebuffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|framebufferObject
operator|!=
name|mFramebufferMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|detachFramebuffer
argument_list|(
name|framebuffer
argument_list|)
expr_stmt|;
name|mFramebufferHandleAllocator
operator|.
name|release
argument_list|(
name|framebufferObject
operator|->
name|first
argument_list|)
expr_stmt|;
operator|delete
name|framebufferObject
operator|->
name|second
expr_stmt|;
name|mFramebufferMap
operator|.
name|erase
argument_list|(
name|framebufferObject
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|deleteFenceNV
name|void
name|Context
operator|::
name|deleteFenceNV
parameter_list|(
name|GLuint
name|fence
parameter_list|)
block|{
name|FenceNVMap
operator|::
name|iterator
name|fenceObject
init|=
name|mFenceNVMap
operator|.
name|find
argument_list|(
name|fence
argument_list|)
decl_stmt|;
if|if
condition|(
name|fenceObject
operator|!=
name|mFenceNVMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|mFenceNVHandleAllocator
operator|.
name|release
argument_list|(
name|fenceObject
operator|->
name|first
argument_list|)
expr_stmt|;
operator|delete
name|fenceObject
operator|->
name|second
expr_stmt|;
name|mFenceNVMap
operator|.
name|erase
argument_list|(
name|fenceObject
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|deleteQuery
name|void
name|Context
operator|::
name|deleteQuery
parameter_list|(
name|GLuint
name|query
parameter_list|)
block|{
name|QueryMap
operator|::
name|iterator
name|queryObject
init|=
name|mQueryMap
operator|.
name|find
argument_list|(
name|query
argument_list|)
decl_stmt|;
if|if
condition|(
name|queryObject
operator|!=
name|mQueryMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|mQueryHandleAllocator
operator|.
name|release
argument_list|(
name|queryObject
operator|->
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|queryObject
operator|->
name|second
condition|)
block|{
name|queryObject
operator|->
name|second
operator|->
name|release
argument_list|()
expr_stmt|;
block|}
name|mQueryMap
operator|.
name|erase
argument_list|(
name|queryObject
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|getBuffer
name|Buffer
modifier|*
name|Context
operator|::
name|getBuffer
parameter_list|(
name|GLuint
name|handle
parameter_list|)
specifier|const
block|{
return|return
name|mResourceManager
operator|->
name|getBuffer
argument_list|(
name|handle
argument_list|)
return|;
block|}
DECL|function|getShader
name|Shader
modifier|*
name|Context
operator|::
name|getShader
parameter_list|(
name|GLuint
name|handle
parameter_list|)
specifier|const
block|{
return|return
name|mResourceManager
operator|->
name|getShader
argument_list|(
name|handle
argument_list|)
return|;
block|}
DECL|function|getProgram
name|Program
modifier|*
name|Context
operator|::
name|getProgram
parameter_list|(
name|GLuint
name|handle
parameter_list|)
specifier|const
block|{
return|return
name|mResourceManager
operator|->
name|getProgram
argument_list|(
name|handle
argument_list|)
return|;
block|}
DECL|function|getTexture
name|Texture
modifier|*
name|Context
operator|::
name|getTexture
parameter_list|(
name|GLuint
name|handle
parameter_list|)
specifier|const
block|{
return|return
name|mResourceManager
operator|->
name|getTexture
argument_list|(
name|handle
argument_list|)
return|;
block|}
DECL|function|getRenderbuffer
name|Renderbuffer
modifier|*
name|Context
operator|::
name|getRenderbuffer
parameter_list|(
name|GLuint
name|handle
parameter_list|)
specifier|const
block|{
return|return
name|mResourceManager
operator|->
name|getRenderbuffer
argument_list|(
name|handle
argument_list|)
return|;
block|}
DECL|function|getFenceSync
name|FenceSync
modifier|*
name|Context
operator|::
name|getFenceSync
parameter_list|(
name|GLsync
name|handle
parameter_list|)
specifier|const
block|{
return|return
name|mResourceManager
operator|->
name|getFenceSync
argument_list|(
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
cast|reinterpret_cast
argument_list|<
name|uintptr_t
argument_list|>
argument_list|(
name|handle
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
DECL|function|getVertexArray
name|VertexArray
modifier|*
name|Context
operator|::
name|getVertexArray
parameter_list|(
name|GLuint
name|handle
parameter_list|)
specifier|const
block|{
name|auto
name|vertexArray
init|=
name|mVertexArrayMap
operator|.
name|find
argument_list|(
name|handle
argument_list|)
decl_stmt|;
return|return
operator|(
name|vertexArray
operator|!=
name|mVertexArrayMap
operator|.
name|end
argument_list|()
operator|)
condition|?
name|vertexArray
operator|->
name|second
else|:
literal|nullptr
return|;
block|}
DECL|function|getSampler
name|Sampler
modifier|*
name|Context
operator|::
name|getSampler
parameter_list|(
name|GLuint
name|handle
parameter_list|)
specifier|const
block|{
return|return
name|mResourceManager
operator|->
name|getSampler
argument_list|(
name|handle
argument_list|)
return|;
block|}
DECL|function|getTransformFeedback
name|TransformFeedback
modifier|*
name|Context
operator|::
name|getTransformFeedback
parameter_list|(
name|GLuint
name|handle
parameter_list|)
specifier|const
block|{
name|auto
name|iter
init|=
name|mTransformFeedbackMap
operator|.
name|find
argument_list|(
name|handle
argument_list|)
decl_stmt|;
return|return
operator|(
name|iter
operator|!=
name|mTransformFeedbackMap
operator|.
name|end
argument_list|()
operator|)
condition|?
name|iter
operator|->
name|second
else|:
literal|nullptr
return|;
block|}
DECL|function|getLabeledObject
name|LabeledObject
modifier|*
name|Context
operator|::
name|getLabeledObject
parameter_list|(
name|GLenum
name|identifier
parameter_list|,
name|GLuint
name|name
parameter_list|)
specifier|const
block|{
switch|switch
condition|(
name|identifier
condition|)
block|{
case|case
name|GL_BUFFER
case|:
return|return
name|getBuffer
argument_list|(
name|name
argument_list|)
return|;
case|case
name|GL_SHADER
case|:
return|return
name|getShader
argument_list|(
name|name
argument_list|)
return|;
case|case
name|GL_PROGRAM
case|:
return|return
name|getProgram
argument_list|(
name|name
argument_list|)
return|;
case|case
name|GL_VERTEX_ARRAY
case|:
return|return
name|getVertexArray
argument_list|(
name|name
argument_list|)
return|;
case|case
name|GL_QUERY
case|:
return|return
name|getQuery
argument_list|(
name|name
argument_list|)
return|;
case|case
name|GL_TRANSFORM_FEEDBACK
case|:
return|return
name|getTransformFeedback
argument_list|(
name|name
argument_list|)
return|;
case|case
name|GL_SAMPLER
case|:
return|return
name|getSampler
argument_list|(
name|name
argument_list|)
return|;
case|case
name|GL_TEXTURE
case|:
return|return
name|getTexture
argument_list|(
name|name
argument_list|)
return|;
case|case
name|GL_RENDERBUFFER
case|:
return|return
name|getRenderbuffer
argument_list|(
name|name
argument_list|)
return|;
case|case
name|GL_FRAMEBUFFER
case|:
return|return
name|getFramebuffer
argument_list|(
name|name
argument_list|)
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|nullptr
return|;
block|}
block|}
DECL|function|getLabeledObjectFromPtr
name|LabeledObject
modifier|*
name|Context
operator|::
name|getLabeledObjectFromPtr
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
specifier|const
block|{
return|return
name|getFenceSync
argument_list|(
cast|reinterpret_cast
argument_list|<
name|GLsync
argument_list|>
argument_list|(
cast|const_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
name|ptr
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
DECL|function|isSampler
name|bool
name|Context
operator|::
name|isSampler
parameter_list|(
name|GLuint
name|samplerName
parameter_list|)
specifier|const
block|{
return|return
name|mResourceManager
operator|->
name|isSampler
argument_list|(
name|samplerName
argument_list|)
return|;
block|}
DECL|function|bindArrayBuffer
name|void
name|Context
operator|::
name|bindArrayBuffer
parameter_list|(
name|unsigned
name|int
name|buffer
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkBufferAllocation
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setArrayBufferBinding
argument_list|(
name|getBuffer
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindElementArrayBuffer
name|void
name|Context
operator|::
name|bindElementArrayBuffer
parameter_list|(
name|unsigned
name|int
name|buffer
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkBufferAllocation
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|getVertexArray
argument_list|()
operator|->
name|setElementArrayBuffer
argument_list|(
name|getBuffer
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindTexture
name|void
name|Context
operator|::
name|bindTexture
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLuint
name|handle
parameter_list|)
block|{
name|Texture
modifier|*
name|texture
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|handle
operator|==
literal|0
condition|)
block|{
name|texture
operator|=
name|mZeroTextures
index|[
name|target
index|]
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|mResourceManager
operator|->
name|checkTextureAllocation
argument_list|(
name|handle
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|texture
operator|=
name|getTexture
argument_list|(
name|handle
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|texture
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setSamplerTexture
argument_list|(
name|target
argument_list|,
name|texture
argument_list|)
expr_stmt|;
block|}
DECL|function|bindReadFramebuffer
name|void
name|Context
operator|::
name|bindReadFramebuffer
parameter_list|(
name|GLuint
name|framebufferHandle
parameter_list|)
block|{
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|checkFramebufferAllocation
argument_list|(
name|framebufferHandle
argument_list|)
decl_stmt|;
name|mState
operator|.
name|setReadFramebufferBinding
argument_list|(
name|framebuffer
argument_list|)
expr_stmt|;
block|}
DECL|function|bindDrawFramebuffer
name|void
name|Context
operator|::
name|bindDrawFramebuffer
parameter_list|(
name|GLuint
name|framebufferHandle
parameter_list|)
block|{
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|checkFramebufferAllocation
argument_list|(
name|framebufferHandle
argument_list|)
decl_stmt|;
name|mState
operator|.
name|setDrawFramebufferBinding
argument_list|(
name|framebuffer
argument_list|)
expr_stmt|;
block|}
DECL|function|bindRenderbuffer
name|void
name|Context
operator|::
name|bindRenderbuffer
parameter_list|(
name|GLuint
name|renderbuffer
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkRenderbufferAllocation
argument_list|(
name|renderbuffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setRenderbufferBinding
argument_list|(
name|getRenderbuffer
argument_list|(
name|renderbuffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindVertexArray
name|void
name|Context
operator|::
name|bindVertexArray
parameter_list|(
name|GLuint
name|vertexArray
parameter_list|)
block|{
name|checkVertexArrayAllocation
argument_list|(
name|vertexArray
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setVertexArrayBinding
argument_list|(
name|getVertexArray
argument_list|(
name|vertexArray
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindSampler
name|void
name|Context
operator|::
name|bindSampler
parameter_list|(
name|GLuint
name|textureUnit
parameter_list|,
name|GLuint
name|sampler
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|textureUnit
operator|<
name|mCaps
operator|.
name|maxCombinedTextureImageUnits
argument_list|)
expr_stmt|;
name|mResourceManager
operator|->
name|checkSamplerAllocation
argument_list|(
name|sampler
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setSamplerBinding
argument_list|(
name|textureUnit
argument_list|,
name|getSampler
argument_list|(
name|sampler
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindGenericUniformBuffer
name|void
name|Context
operator|::
name|bindGenericUniformBuffer
parameter_list|(
name|GLuint
name|buffer
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkBufferAllocation
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setGenericUniformBufferBinding
argument_list|(
name|getBuffer
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindIndexedUniformBuffer
name|void
name|Context
operator|::
name|bindIndexedUniformBuffer
parameter_list|(
name|GLuint
name|buffer
parameter_list|,
name|GLuint
name|index
parameter_list|,
name|GLintptr
name|offset
parameter_list|,
name|GLsizeiptr
name|size
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkBufferAllocation
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setIndexedUniformBufferBinding
argument_list|(
name|index
argument_list|,
name|getBuffer
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
DECL|function|bindGenericTransformFeedbackBuffer
name|void
name|Context
operator|::
name|bindGenericTransformFeedbackBuffer
parameter_list|(
name|GLuint
name|buffer
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkBufferAllocation
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|getCurrentTransformFeedback
argument_list|()
operator|->
name|bindGenericBuffer
argument_list|(
name|getBuffer
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindIndexedTransformFeedbackBuffer
name|void
name|Context
operator|::
name|bindIndexedTransformFeedbackBuffer
parameter_list|(
name|GLuint
name|buffer
parameter_list|,
name|GLuint
name|index
parameter_list|,
name|GLintptr
name|offset
parameter_list|,
name|GLsizeiptr
name|size
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkBufferAllocation
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|getCurrentTransformFeedback
argument_list|()
operator|->
name|bindIndexedBuffer
argument_list|(
name|index
argument_list|,
name|getBuffer
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
DECL|function|bindCopyReadBuffer
name|void
name|Context
operator|::
name|bindCopyReadBuffer
parameter_list|(
name|GLuint
name|buffer
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkBufferAllocation
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setCopyReadBufferBinding
argument_list|(
name|getBuffer
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindCopyWriteBuffer
name|void
name|Context
operator|::
name|bindCopyWriteBuffer
parameter_list|(
name|GLuint
name|buffer
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkBufferAllocation
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setCopyWriteBufferBinding
argument_list|(
name|getBuffer
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindPixelPackBuffer
name|void
name|Context
operator|::
name|bindPixelPackBuffer
parameter_list|(
name|GLuint
name|buffer
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkBufferAllocation
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setPixelPackBufferBinding
argument_list|(
name|getBuffer
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindPixelUnpackBuffer
name|void
name|Context
operator|::
name|bindPixelUnpackBuffer
parameter_list|(
name|GLuint
name|buffer
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkBufferAllocation
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setPixelUnpackBufferBinding
argument_list|(
name|getBuffer
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|useProgram
name|void
name|Context
operator|::
name|useProgram
parameter_list|(
name|GLuint
name|program
parameter_list|)
block|{
name|mState
operator|.
name|setProgram
argument_list|(
name|getProgram
argument_list|(
name|program
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindTransformFeedback
name|void
name|Context
operator|::
name|bindTransformFeedback
parameter_list|(
name|GLuint
name|transformFeedback
parameter_list|)
block|{
name|checkTransformFeedbackAllocation
argument_list|(
name|transformFeedback
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setTransformFeedbackBinding
argument_list|(
name|getTransformFeedback
argument_list|(
name|transformFeedback
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|beginQuery
name|Error
name|Context
operator|::
name|beginQuery
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLuint
name|query
parameter_list|)
block|{
name|Query
modifier|*
name|queryObject
init|=
name|getQuery
argument_list|(
name|query
argument_list|,
literal|true
argument_list|,
name|target
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|queryObject
argument_list|)
expr_stmt|;
comment|// begin query
name|Error
name|error
init|=
name|queryObject
operator|->
name|begin
argument_list|()
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
comment|// set query as active for specified target only if begin succeeded
name|mState
operator|.
name|setActiveQuery
argument_list|(
name|target
argument_list|,
name|queryObject
argument_list|)
expr_stmt|;
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|endQuery
name|Error
name|Context
operator|::
name|endQuery
parameter_list|(
name|GLenum
name|target
parameter_list|)
block|{
name|Query
modifier|*
name|queryObject
init|=
name|mState
operator|.
name|getActiveQuery
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|queryObject
argument_list|)
expr_stmt|;
name|gl
operator|::
name|Error
name|error
init|=
name|queryObject
operator|->
name|end
argument_list|()
decl_stmt|;
comment|// Always unbind the query, even if there was an error. This may delete the query object.
name|mState
operator|.
name|setActiveQuery
argument_list|(
name|target
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
DECL|function|queryCounter
name|Error
name|Context
operator|::
name|queryCounter
parameter_list|(
name|GLuint
name|id
parameter_list|,
name|GLenum
name|target
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|target
operator|==
name|GL_TIMESTAMP_EXT
argument_list|)
expr_stmt|;
name|Query
modifier|*
name|queryObject
init|=
name|getQuery
argument_list|(
name|id
argument_list|,
literal|true
argument_list|,
name|target
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|queryObject
argument_list|)
expr_stmt|;
return|return
name|queryObject
operator|->
name|queryCounter
argument_list|()
return|;
block|}
DECL|function|getQueryiv
name|void
name|Context
operator|::
name|getQueryiv
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLint
modifier|*
name|params
parameter_list|)
block|{
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_CURRENT_QUERY_EXT
case|:
name|params
index|[
literal|0
index|]
operator|=
name|getState
argument_list|()
operator|.
name|getActiveQueryId
argument_list|(
name|target
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_QUERY_COUNTER_BITS_EXT
case|:
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TIME_ELAPSED_EXT
case|:
name|params
index|[
literal|0
index|]
operator|=
name|getExtensions
argument_list|()
operator|.
name|queryCounterBitsTimeElapsed
expr_stmt|;
break|break;
case|case
name|GL_TIMESTAMP_EXT
case|:
name|params
index|[
literal|0
index|]
operator|=
name|getExtensions
argument_list|()
operator|.
name|queryCounterBitsTimestamp
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
name|params
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
DECL|function|getQueryObjectiv
name|Error
name|Context
operator|::
name|getQueryObjectiv
parameter_list|(
name|GLuint
name|id
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLint
modifier|*
name|params
parameter_list|)
block|{
return|return
name|GetQueryObjectParameter
argument_list|(
name|this
argument_list|,
name|id
argument_list|,
name|pname
argument_list|,
name|params
argument_list|)
return|;
block|}
DECL|function|getQueryObjectuiv
name|Error
name|Context
operator|::
name|getQueryObjectuiv
parameter_list|(
name|GLuint
name|id
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLuint
modifier|*
name|params
parameter_list|)
block|{
return|return
name|GetQueryObjectParameter
argument_list|(
name|this
argument_list|,
name|id
argument_list|,
name|pname
argument_list|,
name|params
argument_list|)
return|;
block|}
DECL|function|getQueryObjecti64v
name|Error
name|Context
operator|::
name|getQueryObjecti64v
parameter_list|(
name|GLuint
name|id
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLint64
modifier|*
name|params
parameter_list|)
block|{
return|return
name|GetQueryObjectParameter
argument_list|(
name|this
argument_list|,
name|id
argument_list|,
name|pname
argument_list|,
name|params
argument_list|)
return|;
block|}
DECL|function|getQueryObjectui64v
name|Error
name|Context
operator|::
name|getQueryObjectui64v
parameter_list|(
name|GLuint
name|id
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLuint64
modifier|*
name|params
parameter_list|)
block|{
return|return
name|GetQueryObjectParameter
argument_list|(
name|this
argument_list|,
name|id
argument_list|,
name|pname
argument_list|,
name|params
argument_list|)
return|;
block|}
DECL|function|getFramebuffer
name|Framebuffer
modifier|*
name|Context
operator|::
name|getFramebuffer
parameter_list|(
name|unsigned
name|int
name|handle
parameter_list|)
specifier|const
block|{
name|auto
name|framebufferIt
init|=
name|mFramebufferMap
operator|.
name|find
argument_list|(
name|handle
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|framebufferIt
operator|==
name|mFramebufferMap
operator|.
name|end
argument_list|()
operator|)
condition|?
literal|nullptr
else|:
name|framebufferIt
operator|->
name|second
operator|)
return|;
block|}
DECL|function|getFenceNV
name|FenceNV
modifier|*
name|Context
operator|::
name|getFenceNV
parameter_list|(
name|unsigned
name|int
name|handle
parameter_list|)
block|{
name|FenceNVMap
operator|::
name|iterator
name|fence
init|=
name|mFenceNVMap
operator|.
name|find
argument_list|(
name|handle
argument_list|)
decl_stmt|;
if|if
condition|(
name|fence
operator|==
name|mFenceNVMap
operator|.
name|end
argument_list|()
condition|)
block|{
return|return
name|NULL
return|;
block|}
else|else
block|{
return|return
name|fence
operator|->
name|second
return|;
block|}
block|}
DECL|function|getQuery
name|Query
modifier|*
name|Context
operator|::
name|getQuery
parameter_list|(
name|unsigned
name|int
name|handle
parameter_list|,
name|bool
name|create
parameter_list|,
name|GLenum
name|type
parameter_list|)
block|{
name|QueryMap
operator|::
name|iterator
name|query
init|=
name|mQueryMap
operator|.
name|find
argument_list|(
name|handle
argument_list|)
decl_stmt|;
if|if
condition|(
name|query
operator|==
name|mQueryMap
operator|.
name|end
argument_list|()
condition|)
block|{
return|return
name|NULL
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|query
operator|->
name|second
operator|&&
name|create
condition|)
block|{
name|query
operator|->
name|second
operator|=
operator|new
name|Query
argument_list|(
name|mRenderer
operator|->
name|createQuery
argument_list|(
name|type
argument_list|)
argument_list|,
name|handle
argument_list|)
expr_stmt|;
name|query
operator|->
name|second
operator|->
name|addRef
argument_list|()
expr_stmt|;
block|}
return|return
name|query
operator|->
name|second
return|;
block|}
block|}
DECL|function|getQuery
name|Query
modifier|*
name|Context
operator|::
name|getQuery
parameter_list|(
name|GLuint
name|handle
parameter_list|)
specifier|const
block|{
name|auto
name|iter
init|=
name|mQueryMap
operator|.
name|find
argument_list|(
name|handle
argument_list|)
decl_stmt|;
return|return
operator|(
name|iter
operator|!=
name|mQueryMap
operator|.
name|end
argument_list|()
operator|)
condition|?
name|iter
operator|->
name|second
else|:
literal|nullptr
return|;
block|}
DECL|function|getTargetTexture
name|Texture
modifier|*
name|Context
operator|::
name|getTargetTexture
parameter_list|(
name|GLenum
name|target
parameter_list|)
specifier|const
block|{
name|ASSERT
argument_list|(
name|ValidTextureTarget
argument_list|(
name|this
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|mState
operator|.
name|getTargetTexture
argument_list|(
name|target
argument_list|)
return|;
block|}
DECL|function|getSamplerTexture
name|Texture
modifier|*
name|Context
operator|::
name|getSamplerTexture
parameter_list|(
name|unsigned
name|int
name|sampler
parameter_list|,
name|GLenum
name|type
parameter_list|)
specifier|const
block|{
return|return
name|mState
operator|.
name|getSamplerTexture
argument_list|(
name|sampler
argument_list|,
name|type
argument_list|)
return|;
block|}
DECL|function|getCompiler
name|Compiler
modifier|*
name|Context
operator|::
name|getCompiler
parameter_list|()
specifier|const
block|{
return|return
name|mCompiler
return|;
block|}
DECL|function|getBooleanv
name|void
name|Context
operator|::
name|getBooleanv
parameter_list|(
name|GLenum
name|pname
parameter_list|,
name|GLboolean
modifier|*
name|params
parameter_list|)
block|{
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_SHADER_COMPILER
case|:
operator|*
name|params
operator|=
name|GL_TRUE
expr_stmt|;
break|break;
case|case
name|GL_CONTEXT_ROBUST_ACCESS_EXT
case|:
operator|*
name|params
operator|=
name|mRobustAccess
condition|?
name|GL_TRUE
else|:
name|GL_FALSE
expr_stmt|;
break|break;
default|default:
name|mState
operator|.
name|getBooleanv
argument_list|(
name|pname
argument_list|,
name|params
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
DECL|function|getFloatv
name|void
name|Context
operator|::
name|getFloatv
parameter_list|(
name|GLenum
name|pname
parameter_list|,
name|GLfloat
modifier|*
name|params
parameter_list|)
block|{
comment|// Queries about context capabilities and maximums are answered by Context.
comment|// Queries about current GL state values are answered by State.
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_ALIASED_LINE_WIDTH_RANGE
case|:
name|params
index|[
literal|0
index|]
operator|=
name|mCaps
operator|.
name|minAliasedLineWidth
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|mCaps
operator|.
name|maxAliasedLineWidth
expr_stmt|;
break|break;
case|case
name|GL_ALIASED_POINT_SIZE_RANGE
case|:
name|params
index|[
literal|0
index|]
operator|=
name|mCaps
operator|.
name|minAliasedPointSize
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|mCaps
operator|.
name|maxAliasedPointSize
expr_stmt|;
break|break;
case|case
name|GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT
case|:
name|ASSERT
argument_list|(
name|mExtensions
operator|.
name|textureFilterAnisotropic
argument_list|)
expr_stmt|;
operator|*
name|params
operator|=
name|mExtensions
operator|.
name|maxTextureAnisotropy
expr_stmt|;
break|break;
case|case
name|GL_MAX_TEXTURE_LOD_BIAS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxLODBias
expr_stmt|;
break|break;
default|default:
name|mState
operator|.
name|getFloatv
argument_list|(
name|pname
argument_list|,
name|params
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
DECL|function|getIntegerv
name|void
name|Context
operator|::
name|getIntegerv
parameter_list|(
name|GLenum
name|pname
parameter_list|,
name|GLint
modifier|*
name|params
parameter_list|)
block|{
comment|// Queries about context capabilities and maximums are answered by Context.
comment|// Queries about current GL state values are answered by State.
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_MAX_VERTEX_ATTRIBS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxVertexAttributes
expr_stmt|;
break|break;
case|case
name|GL_MAX_VERTEX_UNIFORM_VECTORS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxVertexUniformVectors
expr_stmt|;
break|break;
case|case
name|GL_MAX_VERTEX_UNIFORM_COMPONENTS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxVertexUniformComponents
expr_stmt|;
break|break;
case|case
name|GL_MAX_VARYING_VECTORS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxVaryingVectors
expr_stmt|;
break|break;
case|case
name|GL_MAX_VARYING_COMPONENTS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxVertexOutputComponents
expr_stmt|;
break|break;
case|case
name|GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxCombinedTextureImageUnits
expr_stmt|;
break|break;
case|case
name|GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxVertexTextureImageUnits
expr_stmt|;
break|break;
case|case
name|GL_MAX_TEXTURE_IMAGE_UNITS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxTextureImageUnits
expr_stmt|;
break|break;
case|case
name|GL_MAX_FRAGMENT_UNIFORM_VECTORS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxFragmentUniformVectors
expr_stmt|;
break|break;
case|case
name|GL_MAX_FRAGMENT_UNIFORM_COMPONENTS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxFragmentUniformComponents
expr_stmt|;
break|break;
case|case
name|GL_MAX_RENDERBUFFER_SIZE
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxRenderbufferSize
expr_stmt|;
break|break;
case|case
name|GL_MAX_COLOR_ATTACHMENTS_EXT
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxColorAttachments
expr_stmt|;
break|break;
case|case
name|GL_MAX_DRAW_BUFFERS_EXT
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxDrawBuffers
expr_stmt|;
break|break;
comment|//case GL_FRAMEBUFFER_BINDING:                    // now equivalent to GL_DRAW_FRAMEBUFFER_BINDING_ANGLE
case|case
name|GL_SUBPIXEL_BITS
case|:
operator|*
name|params
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|GL_MAX_TEXTURE_SIZE
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|max2DTextureSize
expr_stmt|;
break|break;
case|case
name|GL_MAX_CUBE_MAP_TEXTURE_SIZE
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxCubeMapTextureSize
expr_stmt|;
break|break;
case|case
name|GL_MAX_3D_TEXTURE_SIZE
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|max3DTextureSize
expr_stmt|;
break|break;
case|case
name|GL_MAX_ARRAY_TEXTURE_LAYERS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxArrayTextureLayers
expr_stmt|;
break|break;
case|case
name|GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|uniformBufferOffsetAlignment
expr_stmt|;
break|break;
case|case
name|GL_MAX_UNIFORM_BUFFER_BINDINGS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxUniformBufferBindings
expr_stmt|;
break|break;
case|case
name|GL_MAX_VERTEX_UNIFORM_BLOCKS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxVertexUniformBlocks
expr_stmt|;
break|break;
case|case
name|GL_MAX_FRAGMENT_UNIFORM_BLOCKS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxFragmentUniformBlocks
expr_stmt|;
break|break;
case|case
name|GL_MAX_COMBINED_UNIFORM_BLOCKS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxCombinedTextureImageUnits
expr_stmt|;
break|break;
case|case
name|GL_MAX_VERTEX_OUTPUT_COMPONENTS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxVertexOutputComponents
expr_stmt|;
break|break;
case|case
name|GL_MAX_FRAGMENT_INPUT_COMPONENTS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxFragmentInputComponents
expr_stmt|;
break|break;
case|case
name|GL_MIN_PROGRAM_TEXEL_OFFSET
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|minProgramTexelOffset
expr_stmt|;
break|break;
case|case
name|GL_MAX_PROGRAM_TEXEL_OFFSET
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxProgramTexelOffset
expr_stmt|;
break|break;
case|case
name|GL_MAJOR_VERSION
case|:
operator|*
name|params
operator|=
name|mClientVersion
expr_stmt|;
break|break;
case|case
name|GL_MINOR_VERSION
case|:
operator|*
name|params
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|GL_MAX_ELEMENTS_INDICES
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxElementsIndices
expr_stmt|;
break|break;
case|case
name|GL_MAX_ELEMENTS_VERTICES
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxElementsVertices
expr_stmt|;
break|break;
case|case
name|GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxTransformFeedbackInterleavedComponents
expr_stmt|;
break|break;
case|case
name|GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxTransformFeedbackSeparateAttributes
expr_stmt|;
break|break;
case|case
name|GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxTransformFeedbackSeparateComponents
expr_stmt|;
break|break;
case|case
name|GL_NUM_COMPRESSED_TEXTURE_FORMATS
case|:
operator|*
name|params
operator|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|mCaps
operator|.
name|compressedTextureFormats
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_MAX_SAMPLES_ANGLE
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxSamples
expr_stmt|;
break|break;
case|case
name|GL_MAX_VIEWPORT_DIMS
case|:
block|{
name|params
index|[
literal|0
index|]
operator|=
name|mCaps
operator|.
name|maxViewportWidth
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|mCaps
operator|.
name|maxViewportHeight
expr_stmt|;
block|}
break|break;
case|case
name|GL_COMPRESSED_TEXTURE_FORMATS
case|:
name|std
operator|::
name|copy
argument_list|(
name|mCaps
operator|.
name|compressedTextureFormats
operator|.
name|begin
argument_list|()
argument_list|,
name|mCaps
operator|.
name|compressedTextureFormats
operator|.
name|end
argument_list|()
argument_list|,
name|params
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_RESET_NOTIFICATION_STRATEGY_EXT
case|:
operator|*
name|params
operator|=
name|mResetStrategy
expr_stmt|;
break|break;
case|case
name|GL_NUM_SHADER_BINARY_FORMATS
case|:
operator|*
name|params
operator|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|mCaps
operator|.
name|shaderBinaryFormats
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_SHADER_BINARY_FORMATS
case|:
name|std
operator|::
name|copy
argument_list|(
name|mCaps
operator|.
name|shaderBinaryFormats
operator|.
name|begin
argument_list|()
argument_list|,
name|mCaps
operator|.
name|shaderBinaryFormats
operator|.
name|end
argument_list|()
argument_list|,
name|params
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_NUM_PROGRAM_BINARY_FORMATS
case|:
operator|*
name|params
operator|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|mCaps
operator|.
name|programBinaryFormats
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_PROGRAM_BINARY_FORMATS
case|:
name|std
operator|::
name|copy
argument_list|(
name|mCaps
operator|.
name|programBinaryFormats
operator|.
name|begin
argument_list|()
argument_list|,
name|mCaps
operator|.
name|programBinaryFormats
operator|.
name|end
argument_list|()
argument_list|,
name|params
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_NUM_EXTENSIONS
case|:
operator|*
name|params
operator|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|mExtensionStrings
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
break|break;
comment|// GL_KHR_debug
case|case
name|GL_MAX_DEBUG_MESSAGE_LENGTH
case|:
operator|*
name|params
operator|=
name|mExtensions
operator|.
name|maxDebugMessageLength
expr_stmt|;
break|break;
case|case
name|GL_MAX_DEBUG_LOGGED_MESSAGES
case|:
operator|*
name|params
operator|=
name|mExtensions
operator|.
name|maxDebugLoggedMessages
expr_stmt|;
break|break;
case|case
name|GL_MAX_DEBUG_GROUP_STACK_DEPTH
case|:
operator|*
name|params
operator|=
name|mExtensions
operator|.
name|maxDebugGroupStackDepth
expr_stmt|;
break|break;
case|case
name|GL_MAX_LABEL_LENGTH
case|:
operator|*
name|params
operator|=
name|mExtensions
operator|.
name|maxLabelLength
expr_stmt|;
break|break;
comment|// GL_EXT_disjoint_timer_query
case|case
name|GL_GPU_DISJOINT_EXT
case|:
operator|*
name|params
operator|=
name|mRenderer
operator|->
name|getGPUDisjoint
argument_list|()
expr_stmt|;
break|break;
default|default:
name|mState
operator|.
name|getIntegerv
argument_list|(
name|getData
argument_list|()
argument_list|,
name|pname
argument_list|,
name|params
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
DECL|function|getInteger64v
name|void
name|Context
operator|::
name|getInteger64v
parameter_list|(
name|GLenum
name|pname
parameter_list|,
name|GLint64
modifier|*
name|params
parameter_list|)
block|{
comment|// Queries about context capabilities and maximums are answered by Context.
comment|// Queries about current GL state values are answered by State.
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_MAX_ELEMENT_INDEX
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxElementIndex
expr_stmt|;
break|break;
case|case
name|GL_MAX_UNIFORM_BLOCK_SIZE
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxUniformBlockSize
expr_stmt|;
break|break;
case|case
name|GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxCombinedVertexUniformComponents
expr_stmt|;
break|break;
case|case
name|GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxCombinedFragmentUniformComponents
expr_stmt|;
break|break;
case|case
name|GL_MAX_SERVER_WAIT_TIMEOUT
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxServerWaitTimeout
expr_stmt|;
break|break;
comment|// GL_EXT_disjoint_timer_query
case|case
name|GL_TIMESTAMP_EXT
case|:
operator|*
name|params
operator|=
name|mRenderer
operator|->
name|getTimestamp
argument_list|()
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
DECL|function|getPointerv
name|void
name|Context
operator|::
name|getPointerv
parameter_list|(
name|GLenum
name|pname
parameter_list|,
name|void
modifier|*
modifier|*
name|params
parameter_list|)
specifier|const
block|{
name|mState
operator|.
name|getPointerv
argument_list|(
name|pname
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
DECL|function|getIndexedIntegerv
name|bool
name|Context
operator|::
name|getIndexedIntegerv
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLuint
name|index
parameter_list|,
name|GLint
modifier|*
name|data
parameter_list|)
block|{
comment|// Queries about context capabilities and maximums are answered by Context.
comment|// Queries about current GL state values are answered by State.
comment|// Indexed integer queries all refer to current state, so this function is a
comment|// mere passthrough.
return|return
name|mState
operator|.
name|getIndexedIntegerv
argument_list|(
name|target
argument_list|,
name|index
argument_list|,
name|data
argument_list|)
return|;
block|}
DECL|function|getIndexedInteger64v
name|bool
name|Context
operator|::
name|getIndexedInteger64v
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLuint
name|index
parameter_list|,
name|GLint64
modifier|*
name|data
parameter_list|)
block|{
comment|// Queries about context capabilities and maximums are answered by Context.
comment|// Queries about current GL state values are answered by State.
comment|// Indexed integer queries all refer to current state, so this function is a
comment|// mere passthrough.
return|return
name|mState
operator|.
name|getIndexedInteger64v
argument_list|(
name|target
argument_list|,
name|index
argument_list|,
name|data
argument_list|)
return|;
block|}
DECL|function|getQueryParameterInfo
name|bool
name|Context
operator|::
name|getQueryParameterInfo
parameter_list|(
name|GLenum
name|pname
parameter_list|,
name|GLenum
modifier|*
name|type
parameter_list|,
name|unsigned
name|int
modifier|*
name|numParams
parameter_list|)
block|{
if|if
condition|(
name|pname
operator|>=
name|GL_DRAW_BUFFER0_EXT
operator|&&
name|pname
operator|<=
name|GL_DRAW_BUFFER15_EXT
condition|)
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// Please note: the query type returned for DEPTH_CLEAR_VALUE in this implementation
comment|// is FLOAT rather than INT, as would be suggested by the GL ES 2.0 spec. This is due
comment|// to the fact that it is stored internally as a float, and so would require conversion
comment|// if returned from Context::getIntegerv. Since this conversion is already implemented
comment|// in the case that one calls glGetIntegerv to retrieve a float-typed state variable, we
comment|// place DEPTH_CLEAR_VALUE with the floats. This should make no difference to the calling
comment|// application.
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_COMPRESSED_TEXTURE_FORMATS
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|mCaps
operator|.
name|compressedTextureFormats
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_PROGRAM_BINARY_FORMATS_OES
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|mCaps
operator|.
name|programBinaryFormats
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_SHADER_BINARY_FORMATS
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|mCaps
operator|.
name|shaderBinaryFormats
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_MAX_VERTEX_ATTRIBS
case|:
case|case
name|GL_MAX_VERTEX_UNIFORM_VECTORS
case|:
case|case
name|GL_MAX_VARYING_VECTORS
case|:
case|case
name|GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS
case|:
case|case
name|GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS
case|:
case|case
name|GL_MAX_TEXTURE_IMAGE_UNITS
case|:
case|case
name|GL_MAX_FRAGMENT_UNIFORM_VECTORS
case|:
case|case
name|GL_MAX_RENDERBUFFER_SIZE
case|:
case|case
name|GL_MAX_COLOR_ATTACHMENTS_EXT
case|:
case|case
name|GL_MAX_DRAW_BUFFERS_EXT
case|:
case|case
name|GL_NUM_SHADER_BINARY_FORMATS
case|:
case|case
name|GL_NUM_COMPRESSED_TEXTURE_FORMATS
case|:
case|case
name|GL_ARRAY_BUFFER_BINDING
case|:
comment|//case GL_FRAMEBUFFER_BINDING: // equivalent to DRAW_FRAMEBUFFER_BINDING_ANGLE
case|case
name|GL_DRAW_FRAMEBUFFER_BINDING_ANGLE
case|:
case|case
name|GL_READ_FRAMEBUFFER_BINDING_ANGLE
case|:
case|case
name|GL_RENDERBUFFER_BINDING
case|:
case|case
name|GL_CURRENT_PROGRAM
case|:
case|case
name|GL_PACK_ALIGNMENT
case|:
case|case
name|GL_PACK_REVERSE_ROW_ORDER_ANGLE
case|:
case|case
name|GL_UNPACK_ALIGNMENT
case|:
case|case
name|GL_GENERATE_MIPMAP_HINT
case|:
case|case
name|GL_FRAGMENT_SHADER_DERIVATIVE_HINT_OES
case|:
case|case
name|GL_RED_BITS
case|:
case|case
name|GL_GREEN_BITS
case|:
case|case
name|GL_BLUE_BITS
case|:
case|case
name|GL_ALPHA_BITS
case|:
case|case
name|GL_DEPTH_BITS
case|:
case|case
name|GL_STENCIL_BITS
case|:
case|case
name|GL_ELEMENT_ARRAY_BUFFER_BINDING
case|:
case|case
name|GL_CULL_FACE_MODE
case|:
case|case
name|GL_FRONT_FACE
case|:
case|case
name|GL_ACTIVE_TEXTURE
case|:
case|case
name|GL_STENCIL_FUNC
case|:
case|case
name|GL_STENCIL_VALUE_MASK
case|:
case|case
name|GL_STENCIL_REF
case|:
case|case
name|GL_STENCIL_FAIL
case|:
case|case
name|GL_STENCIL_PASS_DEPTH_FAIL
case|:
case|case
name|GL_STENCIL_PASS_DEPTH_PASS
case|:
case|case
name|GL_STENCIL_BACK_FUNC
case|:
case|case
name|GL_STENCIL_BACK_VALUE_MASK
case|:
case|case
name|GL_STENCIL_BACK_REF
case|:
case|case
name|GL_STENCIL_BACK_FAIL
case|:
case|case
name|GL_STENCIL_BACK_PASS_DEPTH_FAIL
case|:
case|case
name|GL_STENCIL_BACK_PASS_DEPTH_PASS
case|:
case|case
name|GL_DEPTH_FUNC
case|:
case|case
name|GL_BLEND_SRC_RGB
case|:
case|case
name|GL_BLEND_SRC_ALPHA
case|:
case|case
name|GL_BLEND_DST_RGB
case|:
case|case
name|GL_BLEND_DST_ALPHA
case|:
case|case
name|GL_BLEND_EQUATION_RGB
case|:
case|case
name|GL_BLEND_EQUATION_ALPHA
case|:
case|case
name|GL_STENCIL_WRITEMASK
case|:
case|case
name|GL_STENCIL_BACK_WRITEMASK
case|:
case|case
name|GL_STENCIL_CLEAR_VALUE
case|:
case|case
name|GL_SUBPIXEL_BITS
case|:
case|case
name|GL_MAX_TEXTURE_SIZE
case|:
case|case
name|GL_MAX_CUBE_MAP_TEXTURE_SIZE
case|:
case|case
name|GL_SAMPLE_BUFFERS
case|:
case|case
name|GL_SAMPLES
case|:
case|case
name|GL_IMPLEMENTATION_COLOR_READ_TYPE
case|:
case|case
name|GL_IMPLEMENTATION_COLOR_READ_FORMAT
case|:
case|case
name|GL_TEXTURE_BINDING_2D
case|:
case|case
name|GL_TEXTURE_BINDING_CUBE_MAP
case|:
case|case
name|GL_RESET_NOTIFICATION_STRATEGY_EXT
case|:
case|case
name|GL_NUM_PROGRAM_BINARY_FORMATS_OES
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_MAX_SAMPLES_ANGLE
case|:
block|{
if|if
condition|(
name|mExtensions
operator|.
name|framebufferMultisample
condition|)
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
case|case
name|GL_MAX_VIEWPORT_DIMS
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|2
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_VIEWPORT
case|:
case|case
name|GL_SCISSOR_BOX
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|4
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_SHADER_COMPILER
case|:
case|case
name|GL_SAMPLE_COVERAGE_INVERT
case|:
case|case
name|GL_DEPTH_WRITEMASK
case|:
case|case
name|GL_CULL_FACE
case|:
comment|// CULL_FACE through DITHER are natural to IsEnabled,
case|case
name|GL_POLYGON_OFFSET_FILL
case|:
comment|// but can be retrieved through the Get{Type}v queries.
case|case
name|GL_SAMPLE_ALPHA_TO_COVERAGE
case|:
comment|// For this purpose, they are treated here as bool-natural
case|case
name|GL_SAMPLE_COVERAGE
case|:
case|case
name|GL_SCISSOR_TEST
case|:
case|case
name|GL_STENCIL_TEST
case|:
case|case
name|GL_DEPTH_TEST
case|:
case|case
name|GL_BLEND
case|:
case|case
name|GL_DITHER
case|:
case|case
name|GL_CONTEXT_ROBUST_ACCESS_EXT
case|:
block|{
operator|*
name|type
operator|=
name|GL_BOOL
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_COLOR_WRITEMASK
case|:
block|{
operator|*
name|type
operator|=
name|GL_BOOL
expr_stmt|;
operator|*
name|numParams
operator|=
literal|4
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_POLYGON_OFFSET_FACTOR
case|:
case|case
name|GL_POLYGON_OFFSET_UNITS
case|:
case|case
name|GL_SAMPLE_COVERAGE_VALUE
case|:
case|case
name|GL_DEPTH_CLEAR_VALUE
case|:
case|case
name|GL_LINE_WIDTH
case|:
block|{
operator|*
name|type
operator|=
name|GL_FLOAT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_ALIASED_LINE_WIDTH_RANGE
case|:
case|case
name|GL_ALIASED_POINT_SIZE_RANGE
case|:
case|case
name|GL_DEPTH_RANGE
case|:
block|{
operator|*
name|type
operator|=
name|GL_FLOAT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|2
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_COLOR_CLEAR_VALUE
case|:
case|case
name|GL_BLEND_COLOR
case|:
block|{
operator|*
name|type
operator|=
name|GL_FLOAT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|4
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT
case|:
if|if
condition|(
operator|!
name|mExtensions
operator|.
name|maxTextureAnisotropy
condition|)
block|{
return|return
literal|false
return|;
block|}
operator|*
name|type
operator|=
name|GL_FLOAT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
return|return
literal|true
return|;
case|case
name|GL_TIMESTAMP_EXT
case|:
if|if
condition|(
operator|!
name|mExtensions
operator|.
name|disjointTimerQuery
condition|)
block|{
return|return
literal|false
return|;
block|}
operator|*
name|type
operator|=
name|GL_INT_64_ANGLEX
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
return|return
literal|true
return|;
case|case
name|GL_GPU_DISJOINT_EXT
case|:
if|if
condition|(
operator|!
name|mExtensions
operator|.
name|disjointTimerQuery
condition|)
block|{
return|return
literal|false
return|;
block|}
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|mExtensions
operator|.
name|debug
condition|)
block|{
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_DEBUG_LOGGED_MESSAGES
case|:
case|case
name|GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH
case|:
case|case
name|GL_DEBUG_GROUP_STACK_DEPTH
case|:
case|case
name|GL_MAX_DEBUG_MESSAGE_LENGTH
case|:
case|case
name|GL_MAX_DEBUG_LOGGED_MESSAGES
case|:
case|case
name|GL_MAX_DEBUG_GROUP_STACK_DEPTH
case|:
case|case
name|GL_MAX_LABEL_LENGTH
case|:
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
return|return
literal|true
return|;
case|case
name|GL_DEBUG_OUTPUT_SYNCHRONOUS
case|:
case|case
name|GL_DEBUG_OUTPUT
case|:
operator|*
name|type
operator|=
name|GL_BOOL
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
comment|// Check for ES3.0+ parameter names which are also exposed as ES2 extensions
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_PACK_ROW_LENGTH
case|:
case|case
name|GL_PACK_SKIP_ROWS
case|:
case|case
name|GL_PACK_SKIP_PIXELS
case|:
if|if
condition|(
operator|(
name|mClientVersion
operator|<
literal|3
operator|)
operator|&&
operator|!
name|mExtensions
operator|.
name|packSubimage
condition|)
block|{
return|return
literal|false
return|;
block|}
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
return|return
literal|true
return|;
case|case
name|GL_UNPACK_ROW_LENGTH
case|:
case|case
name|GL_UNPACK_SKIP_ROWS
case|:
case|case
name|GL_UNPACK_SKIP_PIXELS
case|:
if|if
condition|(
operator|(
name|mClientVersion
operator|<
literal|3
operator|)
operator|&&
operator|!
name|mExtensions
operator|.
name|unpackSubimage
condition|)
block|{
return|return
literal|false
return|;
block|}
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
return|return
literal|true
return|;
case|case
name|GL_VERTEX_ARRAY_BINDING
case|:
if|if
condition|(
operator|(
name|mClientVersion
operator|<
literal|3
operator|)
operator|&&
operator|!
name|mExtensions
operator|.
name|vertexArrayObject
condition|)
block|{
return|return
literal|false
return|;
block|}
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
return|return
literal|true
return|;
case|case
name|GL_PIXEL_PACK_BUFFER_BINDING
case|:
case|case
name|GL_PIXEL_UNPACK_BUFFER_BINDING
case|:
if|if
condition|(
operator|(
name|mClientVersion
operator|<
literal|3
operator|)
operator|&&
operator|!
name|mExtensions
operator|.
name|pixelBufferObject
condition|)
block|{
return|return
literal|false
return|;
block|}
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|mClientVersion
operator|<
literal|3
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Check for ES3.0+ parameter names
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_MAX_UNIFORM_BUFFER_BINDINGS
case|:
case|case
name|GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT
case|:
case|case
name|GL_UNIFORM_BUFFER_BINDING
case|:
case|case
name|GL_TRANSFORM_FEEDBACK_BINDING
case|:
case|case
name|GL_TRANSFORM_FEEDBACK_BUFFER_BINDING
case|:
case|case
name|GL_COPY_READ_BUFFER_BINDING
case|:
case|case
name|GL_COPY_WRITE_BUFFER_BINDING
case|:
case|case
name|GL_TEXTURE_BINDING_3D
case|:
case|case
name|GL_TEXTURE_BINDING_2D_ARRAY
case|:
case|case
name|GL_MAX_3D_TEXTURE_SIZE
case|:
case|case
name|GL_MAX_ARRAY_TEXTURE_LAYERS
case|:
case|case
name|GL_MAX_VERTEX_UNIFORM_BLOCKS
case|:
case|case
name|GL_MAX_FRAGMENT_UNIFORM_BLOCKS
case|:
case|case
name|GL_MAX_COMBINED_UNIFORM_BLOCKS
case|:
case|case
name|GL_MAX_VERTEX_OUTPUT_COMPONENTS
case|:
case|case
name|GL_MAX_FRAGMENT_INPUT_COMPONENTS
case|:
case|case
name|GL_MAX_VARYING_COMPONENTS
case|:
case|case
name|GL_MAX_VERTEX_UNIFORM_COMPONENTS
case|:
case|case
name|GL_MAX_FRAGMENT_UNIFORM_COMPONENTS
case|:
case|case
name|GL_MIN_PROGRAM_TEXEL_OFFSET
case|:
case|case
name|GL_MAX_PROGRAM_TEXEL_OFFSET
case|:
case|case
name|GL_NUM_EXTENSIONS
case|:
case|case
name|GL_MAJOR_VERSION
case|:
case|case
name|GL_MINOR_VERSION
case|:
case|case
name|GL_MAX_ELEMENTS_INDICES
case|:
case|case
name|GL_MAX_ELEMENTS_VERTICES
case|:
case|case
name|GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS
case|:
case|case
name|GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS
case|:
case|case
name|GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS
case|:
case|case
name|GL_UNPACK_IMAGE_HEIGHT
case|:
case|case
name|GL_UNPACK_SKIP_IMAGES
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_MAX_ELEMENT_INDEX
case|:
case|case
name|GL_MAX_UNIFORM_BLOCK_SIZE
case|:
case|case
name|GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS
case|:
case|case
name|GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS
case|:
case|case
name|GL_MAX_SERVER_WAIT_TIMEOUT
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT_64_ANGLEX
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_TRANSFORM_FEEDBACK_ACTIVE
case|:
case|case
name|GL_TRANSFORM_FEEDBACK_PAUSED
case|:
case|case
name|GL_PRIMITIVE_RESTART_FIXED_INDEX
case|:
case|case
name|GL_RASTERIZER_DISCARD
case|:
block|{
operator|*
name|type
operator|=
name|GL_BOOL
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_MAX_TEXTURE_LOD_BIAS
case|:
block|{
operator|*
name|type
operator|=
name|GL_FLOAT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|function|getIndexedQueryParameterInfo
name|bool
name|Context
operator|::
name|getIndexedQueryParameterInfo
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLenum
modifier|*
name|type
parameter_list|,
name|unsigned
name|int
modifier|*
name|numParams
parameter_list|)
block|{
if|if
condition|(
name|mClientVersion
operator|<
literal|3
condition|)
block|{
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TRANSFORM_FEEDBACK_BUFFER_BINDING
case|:
case|case
name|GL_UNIFORM_BUFFER_BINDING
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_TRANSFORM_FEEDBACK_BUFFER_START
case|:
case|case
name|GL_TRANSFORM_FEEDBACK_BUFFER_SIZE
case|:
case|case
name|GL_UNIFORM_BUFFER_START
case|:
case|case
name|GL_UNIFORM_BUFFER_SIZE
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT_64_ANGLEX
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|function|drawArrays
name|Error
name|Context
operator|::
name|drawArrays
parameter_list|(
name|GLenum
name|mode
parameter_list|,
name|GLint
name|first
parameter_list|,
name|GLsizei
name|count
parameter_list|)
block|{
name|syncRendererState
argument_list|()
expr_stmt|;
name|Error
name|error
init|=
name|mRenderer
operator|->
name|drawArrays
argument_list|(
name|getData
argument_list|()
argument_list|,
name|mode
argument_list|,
name|first
argument_list|,
name|count
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|MarkTransformFeedbackBufferUsage
argument_list|(
name|mState
operator|.
name|getCurrentTransformFeedback
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|drawArraysInstanced
name|Error
name|Context
operator|::
name|drawArraysInstanced
parameter_list|(
name|GLenum
name|mode
parameter_list|,
name|GLint
name|first
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLsizei
name|instanceCount
parameter_list|)
block|{
name|syncRendererState
argument_list|()
expr_stmt|;
name|Error
name|error
init|=
name|mRenderer
operator|->
name|drawArraysInstanced
argument_list|(
name|getData
argument_list|()
argument_list|,
name|mode
argument_list|,
name|first
argument_list|,
name|count
argument_list|,
name|instanceCount
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
return|return
name|error
return|;
block|}
name|MarkTransformFeedbackBufferUsage
argument_list|(
name|mState
operator|.
name|getCurrentTransformFeedback
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|Error
argument_list|(
name|GL_NO_ERROR
argument_list|)
return|;
block|}
DECL|function|drawElements
name|Error
name|Context
operator|::
name|drawElements
parameter_list|(
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
specifier|const
name|IndexRange
modifier|&
name|indexRange
parameter_list|)
block|{
name|syncRendererState
argument_list|()
expr_stmt|;
return|return
name|mRenderer
operator|->
name|drawElements
argument_list|(
name|getData
argument_list|()
argument_list|,
name|mode
argument_list|,
name|count
argument_list|,
name|type
argument_list|,
name|indices
argument_list|,
name|indexRange
argument_list|)
return|;
block|}
DECL|function|drawElementsInstanced
name|Error
name|Context
operator|::
name|drawElementsInstanced
parameter_list|(
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|GLsizei
name|instances
parameter_list|,
specifier|const
name|IndexRange
modifier|&
name|indexRange
parameter_list|)
block|{
name|syncRendererState
argument_list|()
expr_stmt|;
return|return
name|mRenderer
operator|->
name|drawElementsInstanced
argument_list|(
name|getData
argument_list|()
argument_list|,
name|mode
argument_list|,
name|count
argument_list|,
name|type
argument_list|,
name|indices
argument_list|,
name|instances
argument_list|,
name|indexRange
argument_list|)
return|;
block|}
DECL|function|drawRangeElements
name|Error
name|Context
operator|::
name|drawRangeElements
parameter_list|(
name|GLenum
name|mode
parameter_list|,
name|GLuint
name|start
parameter_list|,
name|GLuint
name|end
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
specifier|const
name|IndexRange
modifier|&
name|indexRange
parameter_list|)
block|{
name|syncRendererState
argument_list|()
expr_stmt|;
return|return
name|mRenderer
operator|->
name|drawRangeElements
argument_list|(
name|getData
argument_list|()
argument_list|,
name|mode
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|type
argument_list|,
name|indices
argument_list|,
name|indexRange
argument_list|)
return|;
block|}
DECL|function|flush
name|Error
name|Context
operator|::
name|flush
parameter_list|()
block|{
return|return
name|mRenderer
operator|->
name|flush
argument_list|()
return|;
block|}
DECL|function|finish
name|Error
name|Context
operator|::
name|finish
parameter_list|()
block|{
return|return
name|mRenderer
operator|->
name|finish
argument_list|()
return|;
block|}
DECL|function|insertEventMarker
name|void
name|Context
operator|::
name|insertEventMarker
parameter_list|(
name|GLsizei
name|length
parameter_list|,
specifier|const
name|char
modifier|*
name|marker
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|mRenderer
argument_list|)
expr_stmt|;
name|mRenderer
operator|->
name|insertEventMarker
argument_list|(
name|length
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
DECL|function|pushGroupMarker
name|void
name|Context
operator|::
name|pushGroupMarker
parameter_list|(
name|GLsizei
name|length
parameter_list|,
specifier|const
name|char
modifier|*
name|marker
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|mRenderer
argument_list|)
expr_stmt|;
name|mRenderer
operator|->
name|pushGroupMarker
argument_list|(
name|length
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
DECL|function|popGroupMarker
name|void
name|Context
operator|::
name|popGroupMarker
parameter_list|()
block|{
name|ASSERT
argument_list|(
name|mRenderer
argument_list|)
expr_stmt|;
name|mRenderer
operator|->
name|popGroupMarker
argument_list|()
expr_stmt|;
block|}
DECL|function|recordError
name|void
name|Context
operator|::
name|recordError
parameter_list|(
specifier|const
name|Error
modifier|&
name|error
parameter_list|)
block|{
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
name|mErrors
operator|.
name|insert
argument_list|(
name|error
operator|.
name|getCode
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|.
name|getMessage
argument_list|()
operator|.
name|empty
argument_list|()
condition|)
block|{
name|auto
operator|&
name|debug
operator|=
name|mState
operator|.
name|getDebug
argument_list|()
expr_stmt|;
name|debug
operator|.
name|insertMessage
argument_list|(
name|GL_DEBUG_SOURCE_API
argument_list|,
name|GL_DEBUG_TYPE_ERROR
argument_list|,
name|error
operator|.
name|getID
argument_list|()
argument_list|,
name|GL_DEBUG_SEVERITY_HIGH
argument_list|,
name|error
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Get one of the recorded errors and clear its flag, if any.
comment|// [OpenGL ES 2.0.24] section 2.5 page 13.
DECL|function|getError
name|GLenum
name|Context
operator|::
name|getError
parameter_list|()
block|{
if|if
condition|(
name|mErrors
operator|.
name|empty
argument_list|()
condition|)
block|{
return|return
name|GL_NO_ERROR
return|;
block|}
else|else
block|{
name|GLenum
name|error
init|=
operator|*
name|mErrors
operator|.
name|begin
argument_list|()
decl_stmt|;
name|mErrors
operator|.
name|erase
argument_list|(
name|mErrors
operator|.
name|begin
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
DECL|function|getResetStatus
name|GLenum
name|Context
operator|::
name|getResetStatus
parameter_list|()
block|{
comment|//TODO(jmadill): needs MANGLE reworking
if|if
condition|(
name|mResetStatus
operator|==
name|GL_NO_ERROR
operator|&&
operator|!
name|mContextLost
condition|)
block|{
comment|// mResetStatus will be set by the markContextLost callback
comment|// in the case a notification is sent
if|if
condition|(
name|mRenderer
operator|->
name|testDeviceLost
argument_list|()
condition|)
block|{
name|mRenderer
operator|->
name|notifyDeviceLost
argument_list|()
expr_stmt|;
block|}
block|}
name|GLenum
name|status
init|=
name|mResetStatus
decl_stmt|;
if|if
condition|(
name|mResetStatus
operator|!=
name|GL_NO_ERROR
condition|)
block|{
name|ASSERT
argument_list|(
name|mContextLost
argument_list|)
expr_stmt|;
if|if
condition|(
name|mRenderer
operator|->
name|testDeviceResettable
argument_list|()
condition|)
block|{
name|mResetStatus
operator|=
name|GL_NO_ERROR
expr_stmt|;
block|}
block|}
return|return
name|status
return|;
block|}
DECL|function|isResetNotificationEnabled
name|bool
name|Context
operator|::
name|isResetNotificationEnabled
parameter_list|()
block|{
return|return
operator|(
name|mResetStrategy
operator|==
name|GL_LOSE_CONTEXT_ON_RESET_EXT
operator|)
return|;
block|}
DECL|function|getConfig
specifier|const
name|egl
operator|::
name|Config
modifier|*
name|Context
operator|::
name|getConfig
parameter_list|()
specifier|const
block|{
return|return
name|mConfig
return|;
block|}
DECL|function|getClientType
name|EGLenum
name|Context
operator|::
name|getClientType
parameter_list|()
specifier|const
block|{
return|return
name|mClientType
return|;
block|}
DECL|function|getRenderBuffer
name|EGLenum
name|Context
operator|::
name|getRenderBuffer
parameter_list|()
specifier|const
block|{
name|auto
name|framebufferIt
init|=
name|mFramebufferMap
operator|.
name|find
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|framebufferIt
operator|!=
name|mFramebufferMap
operator|.
name|end
argument_list|()
condition|)
block|{
specifier|const
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|framebufferIt
operator|->
name|second
decl_stmt|;
specifier|const
name|FramebufferAttachment
modifier|*
name|backAttachment
init|=
name|framebuffer
operator|->
name|getAttachment
argument_list|(
name|GL_BACK
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|backAttachment
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
return|return
name|backAttachment
operator|->
name|getSurface
argument_list|()
operator|->
name|getRenderBuffer
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|EGL_NONE
return|;
block|}
block|}
DECL|function|checkVertexArrayAllocation
name|void
name|Context
operator|::
name|checkVertexArrayAllocation
parameter_list|(
name|GLuint
name|vertexArray
parameter_list|)
block|{
comment|// Only called after a prior call to Gen.
if|if
condition|(
operator|!
name|getVertexArray
argument_list|(
name|vertexArray
argument_list|)
condition|)
block|{
name|VertexArray
modifier|*
name|vertexArrayObject
init|=
operator|new
name|VertexArray
argument_list|(
name|mRenderer
argument_list|,
name|vertexArray
argument_list|,
name|MAX_VERTEX_ATTRIBS
argument_list|)
decl_stmt|;
name|mVertexArrayMap
index|[
name|vertexArray
index|]
operator|=
name|vertexArrayObject
expr_stmt|;
block|}
block|}
DECL|function|checkTransformFeedbackAllocation
name|void
name|Context
operator|::
name|checkTransformFeedbackAllocation
parameter_list|(
name|GLuint
name|transformFeedback
parameter_list|)
block|{
comment|// Only called after a prior call to Gen.
if|if
condition|(
operator|!
name|getTransformFeedback
argument_list|(
name|transformFeedback
argument_list|)
condition|)
block|{
name|TransformFeedback
modifier|*
name|transformFeedbackObject
init|=
operator|new
name|TransformFeedback
argument_list|(
name|mRenderer
operator|->
name|createTransformFeedback
argument_list|()
argument_list|,
name|transformFeedback
argument_list|,
name|mCaps
argument_list|)
decl_stmt|;
name|transformFeedbackObject
operator|->
name|addRef
argument_list|()
expr_stmt|;
name|mTransformFeedbackMap
index|[
name|transformFeedback
index|]
operator|=
name|transformFeedbackObject
expr_stmt|;
block|}
block|}
DECL|function|checkFramebufferAllocation
name|Framebuffer
modifier|*
name|Context
operator|::
name|checkFramebufferAllocation
parameter_list|(
name|GLuint
name|framebuffer
parameter_list|)
block|{
comment|// Can be called from Bind without a prior call to Gen.
name|auto
name|framebufferIt
init|=
name|mFramebufferMap
operator|.
name|find
argument_list|(
name|framebuffer
argument_list|)
decl_stmt|;
name|bool
name|neverCreated
init|=
name|framebufferIt
operator|==
name|mFramebufferMap
operator|.
name|end
argument_list|()
decl_stmt|;
if|if
condition|(
name|neverCreated
operator|||
name|framebufferIt
operator|->
name|second
operator|==
literal|nullptr
condition|)
block|{
name|Framebuffer
modifier|*
name|newFBO
init|=
operator|new
name|Framebuffer
argument_list|(
name|mCaps
argument_list|,
name|mRenderer
argument_list|,
name|framebuffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|neverCreated
condition|)
block|{
name|mFramebufferHandleAllocator
operator|.
name|reserve
argument_list|(
name|framebuffer
argument_list|)
expr_stmt|;
name|mFramebufferMap
index|[
name|framebuffer
index|]
operator|=
name|newFBO
expr_stmt|;
return|return
name|newFBO
return|;
block|}
name|framebufferIt
operator|->
name|second
operator|=
name|newFBO
expr_stmt|;
block|}
return|return
name|framebufferIt
operator|->
name|second
return|;
block|}
DECL|function|isVertexArrayGenerated
name|bool
name|Context
operator|::
name|isVertexArrayGenerated
parameter_list|(
name|GLuint
name|vertexArray
parameter_list|)
block|{
return|return
name|mVertexArrayMap
operator|.
name|find
argument_list|(
name|vertexArray
argument_list|)
operator|!=
name|mVertexArrayMap
operator|.
name|end
argument_list|()
return|;
block|}
DECL|function|isTransformFeedbackGenerated
name|bool
name|Context
operator|::
name|isTransformFeedbackGenerated
parameter_list|(
name|GLuint
name|transformFeedback
parameter_list|)
block|{
return|return
name|mTransformFeedbackMap
operator|.
name|find
argument_list|(
name|transformFeedback
argument_list|)
operator|!=
name|mTransformFeedbackMap
operator|.
name|end
argument_list|()
return|;
block|}
DECL|function|detachTexture
name|void
name|Context
operator|::
name|detachTexture
parameter_list|(
name|GLuint
name|texture
parameter_list|)
block|{
comment|// Simple pass-through to State's detachTexture method, as textures do not require
comment|// allocation map management either here or in the resource manager at detach time.
comment|// Zero textures are held by the Context, and we don't attempt to request them from
comment|// the State.
name|mState
operator|.
name|detachTexture
argument_list|(
name|mZeroTextures
argument_list|,
name|texture
argument_list|)
expr_stmt|;
block|}
DECL|function|detachBuffer
name|void
name|Context
operator|::
name|detachBuffer
parameter_list|(
name|GLuint
name|buffer
parameter_list|)
block|{
comment|// Simple pass-through to State's detachBuffer method, since
comment|// only buffer attachments to container objects that are bound to the current context
comment|// should be detached. And all those are available in State.
comment|// [OpenGL ES 3.2] section 5.1.2 page 45:
comment|// Attachments to unbound container objects, such as
comment|// deletion of a buffer attached to a vertex array object which is not bound to the context,
comment|// are not affected and continue to act as references on the deleted object
name|mState
operator|.
name|detachBuffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
DECL|function|detachFramebuffer
name|void
name|Context
operator|::
name|detachFramebuffer
parameter_list|(
name|GLuint
name|framebuffer
parameter_list|)
block|{
comment|// Framebuffer detachment is handled by Context, because 0 is a valid
comment|// Framebuffer object, and a pointer to it must be passed from Context
comment|// to State at binding time.
comment|// [OpenGL ES 2.0.24] section 4.4 page 107:
comment|// If a framebuffer that is currently bound to the target FRAMEBUFFER is deleted, it is as though
comment|// BindFramebuffer had been executed with the target of FRAMEBUFFER and framebuffer of zero.
if|if
condition|(
name|mState
operator|.
name|removeReadFramebufferBinding
argument_list|(
name|framebuffer
argument_list|)
operator|&&
name|framebuffer
operator|!=
literal|0
condition|)
block|{
name|bindReadFramebuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mState
operator|.
name|removeDrawFramebufferBinding
argument_list|(
name|framebuffer
argument_list|)
operator|&&
name|framebuffer
operator|!=
literal|0
condition|)
block|{
name|bindDrawFramebuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|detachRenderbuffer
name|void
name|Context
operator|::
name|detachRenderbuffer
parameter_list|(
name|GLuint
name|renderbuffer
parameter_list|)
block|{
name|mState
operator|.
name|detachRenderbuffer
argument_list|(
name|renderbuffer
argument_list|)
expr_stmt|;
block|}
DECL|function|detachVertexArray
name|void
name|Context
operator|::
name|detachVertexArray
parameter_list|(
name|GLuint
name|vertexArray
parameter_list|)
block|{
comment|// Vertex array detachment is handled by Context, because 0 is a valid
comment|// VAO, and a pointer to it must be passed from Context to State at
comment|// binding time.
comment|// [OpenGL ES 3.0.2] section 2.10 page 43:
comment|// If a vertex array object that is currently bound is deleted, the binding
comment|// for that object reverts to zero and the default vertex array becomes current.
if|if
condition|(
name|mState
operator|.
name|removeVertexArrayBinding
argument_list|(
name|vertexArray
argument_list|)
condition|)
block|{
name|bindVertexArray
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|detachTransformFeedback
name|void
name|Context
operator|::
name|detachTransformFeedback
parameter_list|(
name|GLuint
name|transformFeedback
parameter_list|)
block|{
name|mState
operator|.
name|detachTransformFeedback
argument_list|(
name|transformFeedback
argument_list|)
expr_stmt|;
block|}
DECL|function|detachSampler
name|void
name|Context
operator|::
name|detachSampler
parameter_list|(
name|GLuint
name|sampler
parameter_list|)
block|{
name|mState
operator|.
name|detachSampler
argument_list|(
name|sampler
argument_list|)
expr_stmt|;
block|}
DECL|function|setVertexAttribDivisor
name|void
name|Context
operator|::
name|setVertexAttribDivisor
parameter_list|(
name|GLuint
name|index
parameter_list|,
name|GLuint
name|divisor
parameter_list|)
block|{
name|mState
operator|.
name|setVertexAttribDivisor
argument_list|(
name|index
argument_list|,
name|divisor
argument_list|)
expr_stmt|;
block|}
DECL|function|samplerParameteri
name|void
name|Context
operator|::
name|samplerParameteri
parameter_list|(
name|GLuint
name|sampler
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLint
name|param
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkSamplerAllocation
argument_list|(
name|sampler
argument_list|)
expr_stmt|;
name|Sampler
modifier|*
name|samplerObject
init|=
name|getSampler
argument_list|(
name|sampler
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|samplerObject
argument_list|)
expr_stmt|;
comment|// clang-format off
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_TEXTURE_MIN_FILTER
case|:
name|samplerObject
operator|->
name|setMinFilter
argument_list|(
cast|static_cast
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_MAG_FILTER
case|:
name|samplerObject
operator|->
name|setMagFilter
argument_list|(
cast|static_cast
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_WRAP_S
case|:
name|samplerObject
operator|->
name|setWrapS
argument_list|(
cast|static_cast
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_WRAP_T
case|:
name|samplerObject
operator|->
name|setWrapT
argument_list|(
cast|static_cast
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_WRAP_R
case|:
name|samplerObject
operator|->
name|setWrapR
argument_list|(
cast|static_cast
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_MAX_ANISOTROPY_EXT
case|:
name|samplerObject
operator|->
name|setMaxAnisotropy
argument_list|(
name|std
operator|::
name|min
argument_list|(
cast|static_cast
argument_list|<
name|GLfloat
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|,
name|getExtensions
argument_list|()
operator|.
name|maxTextureAnisotropy
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_MIN_LOD
case|:
name|samplerObject
operator|->
name|setMinLod
argument_list|(
cast|static_cast
argument_list|<
name|GLfloat
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_MAX_LOD
case|:
name|samplerObject
operator|->
name|setMaxLod
argument_list|(
cast|static_cast
argument_list|<
name|GLfloat
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_COMPARE_MODE
case|:
name|samplerObject
operator|->
name|setCompareMode
argument_list|(
cast|static_cast
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_COMPARE_FUNC
case|:
name|samplerObject
operator|->
name|setCompareFunc
argument_list|(
cast|static_cast
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
comment|// clang-format on
block|}
DECL|function|samplerParameterf
name|void
name|Context
operator|::
name|samplerParameterf
parameter_list|(
name|GLuint
name|sampler
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLfloat
name|param
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkSamplerAllocation
argument_list|(
name|sampler
argument_list|)
expr_stmt|;
name|Sampler
modifier|*
name|samplerObject
init|=
name|getSampler
argument_list|(
name|sampler
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|samplerObject
argument_list|)
expr_stmt|;
comment|// clang-format off
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_TEXTURE_MIN_FILTER
case|:
name|samplerObject
operator|->
name|setMinFilter
argument_list|(
name|uiround
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_MAG_FILTER
case|:
name|samplerObject
operator|->
name|setMagFilter
argument_list|(
name|uiround
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_WRAP_S
case|:
name|samplerObject
operator|->
name|setWrapS
argument_list|(
name|uiround
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_WRAP_T
case|:
name|samplerObject
operator|->
name|setWrapT
argument_list|(
name|uiround
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_WRAP_R
case|:
name|samplerObject
operator|->
name|setWrapR
argument_list|(
name|uiround
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_MAX_ANISOTROPY_EXT
case|:
name|samplerObject
operator|->
name|setMaxAnisotropy
argument_list|(
name|std
operator|::
name|min
argument_list|(
name|param
argument_list|,
name|getExtensions
argument_list|()
operator|.
name|maxTextureAnisotropy
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_MIN_LOD
case|:
name|samplerObject
operator|->
name|setMinLod
argument_list|(
name|param
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_MAX_LOD
case|:
name|samplerObject
operator|->
name|setMaxLod
argument_list|(
name|param
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_COMPARE_MODE
case|:
name|samplerObject
operator|->
name|setCompareMode
argument_list|(
name|uiround
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_COMPARE_FUNC
case|:
name|samplerObject
operator|->
name|setCompareFunc
argument_list|(
name|uiround
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
comment|// clang-format on
block|}
DECL|function|getSamplerParameteri
name|GLint
name|Context
operator|::
name|getSamplerParameteri
parameter_list|(
name|GLuint
name|sampler
parameter_list|,
name|GLenum
name|pname
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkSamplerAllocation
argument_list|(
name|sampler
argument_list|)
expr_stmt|;
name|Sampler
modifier|*
name|samplerObject
init|=
name|getSampler
argument_list|(
name|sampler
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|samplerObject
argument_list|)
expr_stmt|;
comment|// clang-format off
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_TEXTURE_MIN_FILTER
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getMinFilter
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_MAG_FILTER
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getMagFilter
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_WRAP_S
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getWrapS
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_WRAP_T
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getWrapT
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_WRAP_R
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getWrapR
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_MAX_ANISOTROPY_EXT
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getMaxAnisotropy
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_MIN_LOD
case|:
return|return
name|uiround
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getMinLod
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_MAX_LOD
case|:
return|return
name|uiround
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getMaxLod
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_COMPARE_MODE
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getCompareMode
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_COMPARE_FUNC
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getCompareFunc
argument_list|()
argument_list|)
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|// clang-format on
block|}
DECL|function|getSamplerParameterf
name|GLfloat
name|Context
operator|::
name|getSamplerParameterf
parameter_list|(
name|GLuint
name|sampler
parameter_list|,
name|GLenum
name|pname
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkSamplerAllocation
argument_list|(
name|sampler
argument_list|)
expr_stmt|;
name|Sampler
modifier|*
name|samplerObject
init|=
name|getSampler
argument_list|(
name|sampler
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|samplerObject
argument_list|)
expr_stmt|;
comment|// clang-format off
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_TEXTURE_MIN_FILTER
case|:
return|return
cast|static_cast
argument_list|<
name|GLfloat
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getMinFilter
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_MAG_FILTER
case|:
return|return
cast|static_cast
argument_list|<
name|GLfloat
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getMagFilter
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_WRAP_S
case|:
return|return
cast|static_cast
argument_list|<
name|GLfloat
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getWrapS
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_WRAP_T
case|:
return|return
cast|static_cast
argument_list|<
name|GLfloat
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getWrapT
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_WRAP_R
case|:
return|return
cast|static_cast
argument_list|<
name|GLfloat
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getWrapR
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_MAX_ANISOTROPY_EXT
case|:
return|return
name|samplerObject
operator|->
name|getMaxAnisotropy
argument_list|()
return|;
case|case
name|GL_TEXTURE_MIN_LOD
case|:
return|return
name|samplerObject
operator|->
name|getMinLod
argument_list|()
return|;
case|case
name|GL_TEXTURE_MAX_LOD
case|:
return|return
name|samplerObject
operator|->
name|getMaxLod
argument_list|()
return|;
case|case
name|GL_TEXTURE_COMPARE_MODE
case|:
return|return
cast|static_cast
argument_list|<
name|GLfloat
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getCompareMode
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_COMPARE_FUNC
case|:
return|return
cast|static_cast
argument_list|<
name|GLfloat
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getCompareFunc
argument_list|()
argument_list|)
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|// clang-format on
block|}
DECL|function|initRendererString
name|void
name|Context
operator|::
name|initRendererString
parameter_list|()
block|{
name|std
operator|::
name|ostringstream
name|rendererString
decl_stmt|;
name|rendererString
operator|<<
literal|"ANGLE ("
expr_stmt|;
name|rendererString
operator|<<
name|mRenderer
operator|->
name|getRendererDescription
argument_list|()
expr_stmt|;
name|rendererString
operator|<<
literal|")"
expr_stmt|;
name|mRendererString
operator|=
name|MakeStaticString
argument_list|(
name|rendererString
operator|.
name|str
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|function|getRendererString
specifier|const
name|std
operator|::
name|string
modifier|&
name|Context
operator|::
name|getRendererString
parameter_list|()
specifier|const
block|{
return|return
name|mRendererString
return|;
block|}
DECL|function|initExtensionStrings
name|void
name|Context
operator|::
name|initExtensionStrings
parameter_list|()
block|{
name|mExtensionStrings
operator|=
name|mExtensions
operator|.
name|getStrings
argument_list|()
expr_stmt|;
name|std
operator|::
name|ostringstream
name|combinedStringStream
decl_stmt|;
name|std
operator|::
name|copy
argument_list|(
name|mExtensionStrings
operator|.
name|begin
argument_list|()
argument_list|,
name|mExtensionStrings
operator|.
name|end
argument_list|()
argument_list|,
name|std
operator|::
name|ostream_iterator
argument_list|<
name|std
operator|::
name|string
argument_list|>
argument_list|(
name|combinedStringStream
argument_list|,
literal|" "
argument_list|)
argument_list|)
expr_stmt|;
name|mExtensionString
operator|=
name|combinedStringStream
operator|.
name|str
argument_list|()
expr_stmt|;
block|}
DECL|function|getExtensionString
specifier|const
name|std
operator|::
name|string
modifier|&
name|Context
operator|::
name|getExtensionString
parameter_list|()
specifier|const
block|{
return|return
name|mExtensionString
return|;
block|}
DECL|function|getExtensionString
specifier|const
name|std
operator|::
name|string
modifier|&
name|Context
operator|::
name|getExtensionString
parameter_list|(
name|size_t
name|idx
parameter_list|)
specifier|const
block|{
return|return
name|mExtensionStrings
index|[
name|idx
index|]
return|;
block|}
DECL|function|getExtensionStringCount
name|size_t
name|Context
operator|::
name|getExtensionStringCount
parameter_list|()
specifier|const
block|{
return|return
name|mExtensionStrings
operator|.
name|size
argument_list|()
return|;
block|}
DECL|function|initCaps
name|void
name|Context
operator|::
name|initCaps
parameter_list|(
name|GLuint
name|clientVersion
parameter_list|)
block|{
name|mCaps
operator|=
name|mRenderer
operator|->
name|getRendererCaps
argument_list|()
expr_stmt|;
name|mExtensions
operator|=
name|mRenderer
operator|->
name|getRendererExtensions
argument_list|()
expr_stmt|;
name|mLimitations
operator|=
name|mRenderer
operator|->
name|getRendererLimitations
argument_list|()
expr_stmt|;
if|if
condition|(
name|clientVersion
operator|<
literal|3
condition|)
block|{
comment|// Disable ES3+ extensions
name|mExtensions
operator|.
name|colorBufferFloat
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|clientVersion
operator|>
literal|2
condition|)
block|{
comment|// FIXME(geofflang): Don't support EXT_sRGB in non-ES2 contexts
comment|//mExtensions.sRGB = false;
block|}
comment|// Explicitly enable GL_KHR_debug
name|mExtensions
operator|.
name|debug
operator|=
literal|true
expr_stmt|;
name|mExtensions
operator|.
name|maxDebugMessageLength
operator|=
literal|1024
expr_stmt|;
name|mExtensions
operator|.
name|maxDebugLoggedMessages
operator|=
literal|1024
expr_stmt|;
name|mExtensions
operator|.
name|maxDebugGroupStackDepth
operator|=
literal|1024
expr_stmt|;
name|mExtensions
operator|.
name|maxLabelLength
operator|=
literal|1024
expr_stmt|;
comment|// Apply implementation limits
name|mCaps
operator|.
name|maxVertexAttributes
operator|=
name|std
operator|::
name|min
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|mCaps
operator|.
name|maxVertexAttributes
argument_list|,
name|MAX_VERTEX_ATTRIBS
argument_list|)
expr_stmt|;
name|mCaps
operator|.
name|maxVertexUniformBlocks
operator|=
name|std
operator|::
name|min
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|mCaps
operator|.
name|maxVertexUniformBlocks
argument_list|,
name|IMPLEMENTATION_MAX_VERTEX_SHADER_UNIFORM_BUFFERS
argument_list|)
expr_stmt|;
name|mCaps
operator|.
name|maxVertexOutputComponents
operator|=
name|std
operator|::
name|min
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|mCaps
operator|.
name|maxVertexOutputComponents
argument_list|,
name|IMPLEMENTATION_MAX_VARYING_VECTORS
operator|*
literal|4
argument_list|)
expr_stmt|;
name|mCaps
operator|.
name|maxFragmentInputComponents
operator|=
name|std
operator|::
name|min
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|mCaps
operator|.
name|maxFragmentInputComponents
argument_list|,
name|IMPLEMENTATION_MAX_VARYING_VECTORS
operator|*
literal|4
argument_list|)
expr_stmt|;
name|mCaps
operator|.
name|compressedTextureFormats
operator|.
name|clear
argument_list|()
expr_stmt|;
specifier|const
name|TextureCapsMap
modifier|&
name|rendererFormats
init|=
name|mRenderer
operator|->
name|getRendererTextureCaps
argument_list|()
decl_stmt|;
for|for
control|(
name|TextureCapsMap
operator|::
name|const_iterator
name|i
init|=
name|rendererFormats
operator|.
name|begin
argument_list|()
init|;
name|i
operator|!=
name|rendererFormats
operator|.
name|end
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|GLenum
name|format
init|=
name|i
operator|->
name|first
decl_stmt|;
name|TextureCaps
name|formatCaps
init|=
name|i
operator|->
name|second
decl_stmt|;
specifier|const
name|InternalFormat
modifier|&
name|formatInfo
init|=
name|GetInternalFormatInfo
argument_list|(
name|format
argument_list|)
decl_stmt|;
comment|// Update the format caps based on the client version and extensions.
comment|// Caps are AND'd with the renderer caps because some core formats are still unsupported in
comment|// ES3.
name|formatCaps
operator|.
name|texturable
operator|=
name|formatCaps
operator|.
name|texturable
operator|&&
name|formatInfo
operator|.
name|textureSupport
argument_list|(
name|clientVersion
argument_list|,
name|mExtensions
argument_list|)
expr_stmt|;
name|formatCaps
operator|.
name|renderable
operator|=
name|formatCaps
operator|.
name|renderable
operator|&&
name|formatInfo
operator|.
name|renderSupport
argument_list|(
name|clientVersion
argument_list|,
name|mExtensions
argument_list|)
expr_stmt|;
name|formatCaps
operator|.
name|filterable
operator|=
name|formatCaps
operator|.
name|filterable
operator|&&
name|formatInfo
operator|.
name|filterSupport
argument_list|(
name|clientVersion
argument_list|,
name|mExtensions
argument_list|)
expr_stmt|;
comment|// OpenGL ES does not support multisampling with integer formats
if|if
condition|(
operator|!
name|formatInfo
operator|.
name|renderSupport
operator|||
name|formatInfo
operator|.
name|componentType
operator|==
name|GL_INT
operator|||
name|formatInfo
operator|.
name|componentType
operator|==
name|GL_UNSIGNED_INT
condition|)
block|{
name|formatCaps
operator|.
name|sampleCounts
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|formatCaps
operator|.
name|texturable
operator|&&
name|formatInfo
operator|.
name|compressed
condition|)
block|{
name|mCaps
operator|.
name|compressedTextureFormats
operator|.
name|push_back
argument_list|(
name|format
argument_list|)
expr_stmt|;
block|}
name|mTextureCaps
operator|.
name|insert
argument_list|(
name|format
argument_list|,
name|formatCaps
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|syncRendererState
name|void
name|Context
operator|::
name|syncRendererState
parameter_list|()
block|{
specifier|const
name|State
operator|::
name|DirtyBits
modifier|&
name|dirtyBits
init|=
name|mState
operator|.
name|getDirtyBits
argument_list|()
decl_stmt|;
name|mRenderer
operator|->
name|syncState
argument_list|(
name|mState
argument_list|,
name|dirtyBits
argument_list|)
expr_stmt|;
name|mState
operator|.
name|clearDirtyBits
argument_list|()
expr_stmt|;
name|mState
operator|.
name|syncDirtyObjects
argument_list|()
expr_stmt|;
block|}
DECL|function|syncRendererState
name|void
name|Context
operator|::
name|syncRendererState
parameter_list|(
specifier|const
name|State
operator|::
name|DirtyBits
modifier|&
name|bitMask
parameter_list|)
block|{
specifier|const
name|State
operator|::
name|DirtyBits
modifier|&
name|dirtyBits
init|=
operator|(
name|mState
operator|.
name|getDirtyBits
argument_list|()
operator|&
name|bitMask
operator|)
decl_stmt|;
name|mRenderer
operator|->
name|syncState
argument_list|(
name|mState
argument_list|,
name|dirtyBits
argument_list|)
expr_stmt|;
name|mState
operator|.
name|clearDirtyBits
argument_list|(
name|dirtyBits
argument_list|)
expr_stmt|;
comment|// TODO(jmadill): Filter objects by bitMask somehow?
name|mState
operator|.
name|syncDirtyObjects
argument_list|()
expr_stmt|;
block|}
DECL|function|blitFramebuffer
name|void
name|Context
operator|::
name|blitFramebuffer
parameter_list|(
name|GLint
name|srcX0
parameter_list|,
name|GLint
name|srcY0
parameter_list|,
name|GLint
name|srcX1
parameter_list|,
name|GLint
name|srcY1
parameter_list|,
name|GLint
name|dstX0
parameter_list|,
name|GLint
name|dstY0
parameter_list|,
name|GLint
name|dstX1
parameter_list|,
name|GLint
name|dstY1
parameter_list|,
name|GLbitfield
name|mask
parameter_list|,
name|GLenum
name|filter
parameter_list|)
block|{
name|Framebuffer
modifier|*
name|readFramebuffer
init|=
name|mState
operator|.
name|getReadFramebuffer
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|readFramebuffer
argument_list|)
expr_stmt|;
name|Framebuffer
modifier|*
name|drawFramebuffer
init|=
name|mState
operator|.
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|drawFramebuffer
argument_list|)
expr_stmt|;
name|Rectangle
name|srcArea
argument_list|(
name|srcX0
argument_list|,
name|srcY0
argument_list|,
name|srcX1
operator|-
name|srcX0
argument_list|,
name|srcY1
operator|-
name|srcY0
argument_list|)
decl_stmt|;
name|Rectangle
name|dstArea
argument_list|(
name|dstX0
argument_list|,
name|dstY0
argument_list|,
name|dstX1
operator|-
name|dstX0
argument_list|,
name|dstY1
operator|-
name|dstY0
argument_list|)
decl_stmt|;
name|syncRendererState
argument_list|(
name|mState
operator|.
name|blitStateBitMask
argument_list|()
argument_list|)
expr_stmt|;
name|Error
name|error
init|=
name|drawFramebuffer
operator|->
name|blit
argument_list|(
name|mState
argument_list|,
name|srcArea
argument_list|,
name|dstArea
argument_list|,
name|mask
argument_list|,
name|filter
argument_list|,
name|readFramebuffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
name|recordError
argument_list|(
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
DECL|function|clear
name|void
name|Context
operator|::
name|clear
parameter_list|(
name|GLbitfield
name|mask
parameter_list|)
block|{
comment|// Sync the clear state
name|syncRendererState
argument_list|(
name|mState
operator|.
name|clearStateBitMask
argument_list|()
argument_list|)
expr_stmt|;
name|Error
name|error
init|=
name|mState
operator|.
name|getDrawFramebuffer
argument_list|()
operator|->
name|clear
argument_list|(
name|mData
argument_list|,
name|mask
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
name|recordError
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|clearBufferfv
name|void
name|Context
operator|::
name|clearBufferfv
parameter_list|(
name|GLenum
name|buffer
parameter_list|,
name|GLint
name|drawbuffer
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|values
parameter_list|)
block|{
comment|// Sync the clear state
name|syncRendererState
argument_list|(
name|mState
operator|.
name|clearStateBitMask
argument_list|()
argument_list|)
expr_stmt|;
name|Error
name|error
init|=
name|mState
operator|.
name|getDrawFramebuffer
argument_list|()
operator|->
name|clearBufferfv
argument_list|(
name|mData
argument_list|,
name|buffer
argument_list|,
name|drawbuffer
argument_list|,
name|values
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
name|recordError
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|clearBufferuiv
name|void
name|Context
operator|::
name|clearBufferuiv
parameter_list|(
name|GLenum
name|buffer
parameter_list|,
name|GLint
name|drawbuffer
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|values
parameter_list|)
block|{
comment|// Sync the clear state
name|syncRendererState
argument_list|(
name|mState
operator|.
name|clearStateBitMask
argument_list|()
argument_list|)
expr_stmt|;
name|Error
name|error
init|=
name|mState
operator|.
name|getDrawFramebuffer
argument_list|()
operator|->
name|clearBufferuiv
argument_list|(
name|mData
argument_list|,
name|buffer
argument_list|,
name|drawbuffer
argument_list|,
name|values
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
name|recordError
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|clearBufferiv
name|void
name|Context
operator|::
name|clearBufferiv
parameter_list|(
name|GLenum
name|buffer
parameter_list|,
name|GLint
name|drawbuffer
parameter_list|,
specifier|const
name|GLint
modifier|*
name|values
parameter_list|)
block|{
comment|// Sync the clear state
name|syncRendererState
argument_list|(
name|mState
operator|.
name|clearStateBitMask
argument_list|()
argument_list|)
expr_stmt|;
name|Error
name|error
init|=
name|mState
operator|.
name|getDrawFramebuffer
argument_list|()
operator|->
name|clearBufferiv
argument_list|(
name|mData
argument_list|,
name|buffer
argument_list|,
name|drawbuffer
argument_list|,
name|values
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
name|recordError
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|clearBufferfi
name|void
name|Context
operator|::
name|clearBufferfi
parameter_list|(
name|GLenum
name|buffer
parameter_list|,
name|GLint
name|drawbuffer
parameter_list|,
name|GLfloat
name|depth
parameter_list|,
name|GLint
name|stencil
parameter_list|)
block|{
name|Framebuffer
modifier|*
name|framebufferObject
init|=
name|mState
operator|.
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|framebufferObject
argument_list|)
expr_stmt|;
comment|// If a buffer is not present, the clear has no effect
if|if
condition|(
name|framebufferObject
operator|->
name|getDepthbuffer
argument_list|()
operator|==
literal|nullptr
operator|&&
name|framebufferObject
operator|->
name|getStencilbuffer
argument_list|()
operator|==
literal|nullptr
condition|)
block|{
return|return;
block|}
comment|// Sync the clear state
name|syncRendererState
argument_list|(
name|mState
operator|.
name|clearStateBitMask
argument_list|()
argument_list|)
expr_stmt|;
name|Error
name|error
init|=
name|framebufferObject
operator|->
name|clearBufferfi
argument_list|(
name|mData
argument_list|,
name|buffer
argument_list|,
name|drawbuffer
argument_list|,
name|depth
argument_list|,
name|stencil
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
name|recordError
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|readPixels
name|void
name|Context
operator|::
name|readPixels
parameter_list|(
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLvoid
modifier|*
name|pixels
parameter_list|)
block|{
comment|// Sync pack state
name|syncRendererState
argument_list|(
name|mState
operator|.
name|packStateBitMask
argument_list|()
argument_list|)
expr_stmt|;
name|Framebuffer
modifier|*
name|framebufferObject
init|=
name|mState
operator|.
name|getReadFramebuffer
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|framebufferObject
argument_list|)
expr_stmt|;
name|Rectangle
name|area
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
decl_stmt|;
name|Error
name|error
init|=
name|framebufferObject
operator|->
name|readPixels
argument_list|(
name|mState
argument_list|,
name|area
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|pixels
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
name|recordError
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|copyTexImage2D
name|void
name|Context
operator|::
name|copyTexImage2D
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLint
name|border
parameter_list|)
block|{
comment|// Only sync the read FBO
name|mState
operator|.
name|syncDirtyObject
argument_list|(
name|GL_READ_FRAMEBUFFER
argument_list|)
expr_stmt|;
name|Rectangle
name|sourceArea
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
decl_stmt|;
specifier|const
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|mState
operator|.
name|getReadFramebuffer
argument_list|()
decl_stmt|;
name|Texture
modifier|*
name|texture
init|=
name|getTargetTexture
argument_list|(
name|IsCubeMapTextureTarget
argument_list|(
name|target
argument_list|)
condition|?
name|GL_TEXTURE_CUBE_MAP
else|:
name|target
argument_list|)
decl_stmt|;
name|Error
name|error
init|=
name|texture
operator|->
name|copyImage
argument_list|(
name|target
argument_list|,
name|level
argument_list|,
name|sourceArea
argument_list|,
name|internalformat
argument_list|,
name|framebuffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
name|recordError
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|copyTexSubImage2D
name|void
name|Context
operator|::
name|copyTexSubImage2D
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
comment|// Only sync the read FBO
name|mState
operator|.
name|syncDirtyObject
argument_list|(
name|GL_READ_FRAMEBUFFER
argument_list|)
expr_stmt|;
name|Offset
name|destOffset
argument_list|(
name|xoffset
argument_list|,
name|yoffset
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|Rectangle
name|sourceArea
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
decl_stmt|;
specifier|const
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|mState
operator|.
name|getReadFramebuffer
argument_list|()
decl_stmt|;
name|Texture
modifier|*
name|texture
init|=
name|getTargetTexture
argument_list|(
name|IsCubeMapTextureTarget
argument_list|(
name|target
argument_list|)
condition|?
name|GL_TEXTURE_CUBE_MAP
else|:
name|target
argument_list|)
decl_stmt|;
name|Error
name|error
init|=
name|texture
operator|->
name|copySubImage
argument_list|(
name|target
argument_list|,
name|level
argument_list|,
name|destOffset
argument_list|,
name|sourceArea
argument_list|,
name|framebuffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
name|recordError
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|copyTexSubImage3D
name|void
name|Context
operator|::
name|copyTexSubImage3D
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLint
name|zoffset
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
comment|// Only sync the read FBO
name|mState
operator|.
name|syncDirtyObject
argument_list|(
name|GL_READ_FRAMEBUFFER
argument_list|)
expr_stmt|;
name|Offset
name|destOffset
argument_list|(
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|zoffset
argument_list|)
decl_stmt|;
name|Rectangle
name|sourceArea
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
decl_stmt|;
specifier|const
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|mState
operator|.
name|getReadFramebuffer
argument_list|()
decl_stmt|;
name|Texture
modifier|*
name|texture
init|=
name|getTargetTexture
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|Error
name|error
init|=
name|texture
operator|->
name|copySubImage
argument_list|(
name|target
argument_list|,
name|level
argument_list|,
name|destOffset
argument_list|,
name|sourceArea
argument_list|,
name|framebuffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
name|recordError
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|framebufferTexture2D
name|void
name|Context
operator|::
name|framebufferTexture2D
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLenum
name|attachment
parameter_list|,
name|GLenum
name|textarget
parameter_list|,
name|GLuint
name|texture
parameter_list|,
name|GLint
name|level
parameter_list|)
block|{
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|mState
operator|.
name|getTargetFramebuffer
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|framebuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|texture
operator|!=
literal|0
condition|)
block|{
name|Texture
modifier|*
name|textureObj
init|=
name|getTexture
argument_list|(
name|texture
argument_list|)
decl_stmt|;
name|ImageIndex
name|index
init|=
name|ImageIndex
operator|::
name|MakeInvalid
argument_list|()
decl_stmt|;
if|if
condition|(
name|textarget
operator|==
name|GL_TEXTURE_2D
condition|)
block|{
name|index
operator|=
name|ImageIndex
operator|::
name|Make2D
argument_list|(
name|level
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|IsCubeMapTextureTarget
argument_list|(
name|textarget
argument_list|)
argument_list|)
expr_stmt|;
name|index
operator|=
name|ImageIndex
operator|::
name|MakeCube
argument_list|(
name|textarget
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
name|framebuffer
operator|->
name|setAttachment
argument_list|(
name|GL_TEXTURE
argument_list|,
name|attachment
argument_list|,
name|index
argument_list|,
name|textureObj
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|framebuffer
operator|->
name|resetAttachment
argument_list|(
name|attachment
argument_list|)
expr_stmt|;
block|}
name|mState
operator|.
name|setObjectDirty
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
DECL|function|framebufferRenderbuffer
name|void
name|Context
operator|::
name|framebufferRenderbuffer
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLenum
name|attachment
parameter_list|,
name|GLenum
name|renderbuffertarget
parameter_list|,
name|GLuint
name|renderbuffer
parameter_list|)
block|{
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|mState
operator|.
name|getTargetFramebuffer
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|framebuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|renderbuffer
operator|!=
literal|0
condition|)
block|{
name|Renderbuffer
modifier|*
name|renderbufferObject
init|=
name|getRenderbuffer
argument_list|(
name|renderbuffer
argument_list|)
decl_stmt|;
name|framebuffer
operator|->
name|setAttachment
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|attachment
argument_list|,
name|gl
operator|::
name|ImageIndex
operator|::
name|MakeInvalid
argument_list|()
argument_list|,
name|renderbufferObject
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|framebuffer
operator|->
name|resetAttachment
argument_list|(
name|attachment
argument_list|)
expr_stmt|;
block|}
name|mState
operator|.
name|setObjectDirty
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
DECL|function|framebufferTextureLayer
name|void
name|Context
operator|::
name|framebufferTextureLayer
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLenum
name|attachment
parameter_list|,
name|GLuint
name|texture
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLint
name|layer
parameter_list|)
block|{
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|mState
operator|.
name|getTargetFramebuffer
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|framebuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|texture
operator|!=
literal|0
condition|)
block|{
name|Texture
modifier|*
name|textureObject
init|=
name|getTexture
argument_list|(
name|texture
argument_list|)
decl_stmt|;
name|ImageIndex
name|index
init|=
name|ImageIndex
operator|::
name|MakeInvalid
argument_list|()
decl_stmt|;
if|if
condition|(
name|textureObject
operator|->
name|getTarget
argument_list|()
operator|==
name|GL_TEXTURE_3D
condition|)
block|{
name|index
operator|=
name|ImageIndex
operator|::
name|Make3D
argument_list|(
name|level
argument_list|,
name|layer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|textureObject
operator|->
name|getTarget
argument_list|()
operator|==
name|GL_TEXTURE_2D_ARRAY
argument_list|)
expr_stmt|;
name|index
operator|=
name|ImageIndex
operator|::
name|Make2DArray
argument_list|(
name|level
argument_list|,
name|layer
argument_list|)
expr_stmt|;
block|}
name|framebuffer
operator|->
name|setAttachment
argument_list|(
name|GL_TEXTURE
argument_list|,
name|attachment
argument_list|,
name|index
argument_list|,
name|textureObject
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|framebuffer
operator|->
name|resetAttachment
argument_list|(
name|attachment
argument_list|)
expr_stmt|;
block|}
name|mState
operator|.
name|setObjectDirty
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
DECL|function|drawBuffers
name|void
name|Context
operator|::
name|drawBuffers
parameter_list|(
name|GLsizei
name|n
parameter_list|,
specifier|const
name|GLenum
modifier|*
name|bufs
parameter_list|)
block|{
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|mState
operator|.
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|framebuffer
argument_list|)
expr_stmt|;
name|framebuffer
operator|->
name|setDrawBuffers
argument_list|(
name|n
argument_list|,
name|bufs
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setObjectDirty
argument_list|(
name|GL_DRAW_FRAMEBUFFER
argument_list|)
expr_stmt|;
block|}
DECL|function|readBuffer
name|void
name|Context
operator|::
name|readBuffer
parameter_list|(
name|GLenum
name|mode
parameter_list|)
block|{
name|Framebuffer
modifier|*
name|readFBO
init|=
name|mState
operator|.
name|getReadFramebuffer
argument_list|()
decl_stmt|;
name|readFBO
operator|->
name|setReadBuffer
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setObjectDirty
argument_list|(
name|GL_READ_FRAMEBUFFER
argument_list|)
expr_stmt|;
block|}
DECL|function|discardFramebuffer
name|void
name|Context
operator|::
name|discardFramebuffer
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLsizei
name|numAttachments
parameter_list|,
specifier|const
name|GLenum
modifier|*
name|attachments
parameter_list|)
block|{
comment|// Only sync the FBO
name|mState
operator|.
name|syncDirtyObject
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|mState
operator|.
name|getTargetFramebuffer
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|framebuffer
argument_list|)
expr_stmt|;
comment|// The specification isn't clear what should be done when the framebuffer isn't complete.
comment|// We leave it up to the framebuffer implementation to decide what to do.
name|Error
name|error
init|=
name|framebuffer
operator|->
name|discard
argument_list|(
name|numAttachments
argument_list|,
name|attachments
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
name|recordError
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|invalidateFramebuffer
name|void
name|Context
operator|::
name|invalidateFramebuffer
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLsizei
name|numAttachments
parameter_list|,
specifier|const
name|GLenum
modifier|*
name|attachments
parameter_list|)
block|{
comment|// Only sync the FBO
name|mState
operator|.
name|syncDirtyObject
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|mState
operator|.
name|getTargetFramebuffer
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|framebuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|framebuffer
operator|->
name|checkStatus
argument_list|(
name|mData
argument_list|)
operator|==
name|GL_FRAMEBUFFER_COMPLETE
condition|)
block|{
name|Error
name|error
init|=
name|framebuffer
operator|->
name|invalidate
argument_list|(
name|numAttachments
argument_list|,
name|attachments
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
name|recordError
argument_list|(
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
DECL|function|invalidateSubFramebuffer
name|void
name|Context
operator|::
name|invalidateSubFramebuffer
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLsizei
name|numAttachments
parameter_list|,
specifier|const
name|GLenum
modifier|*
name|attachments
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
comment|// Only sync the FBO
name|mState
operator|.
name|syncDirtyObject
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|mState
operator|.
name|getTargetFramebuffer
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|framebuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|framebuffer
operator|->
name|checkStatus
argument_list|(
name|mData
argument_list|)
operator|==
name|GL_FRAMEBUFFER_COMPLETE
condition|)
block|{
name|Rectangle
name|area
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
decl_stmt|;
name|Error
name|error
init|=
name|framebuffer
operator|->
name|invalidateSub
argument_list|(
name|numAttachments
argument_list|,
name|attachments
argument_list|,
name|area
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|isError
argument_list|()
condition|)
block|{
name|recordError
argument_list|(
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
end_namespace
begin_comment
comment|// namespace gl
end_comment
end_unit
