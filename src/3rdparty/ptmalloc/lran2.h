begin_unit
begin_comment
comment|/* lran2.h  * by Wolfram Gloger 1996.  *  * A small, portable pseudo-random number generator.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|_LRAN2_H
end_ifndef
begin_define
DECL|macro|_LRAN2_H
define|#
directive|define
name|_LRAN2_H
end_define
begin_define
DECL|macro|LRAN2_MAX
define|#
directive|define
name|LRAN2_MAX
value|714025l
end_define
begin_comment
DECL|macro|LRAN2_MAX
comment|/* constants for portable */
end_comment
begin_define
DECL|macro|IA
define|#
directive|define
name|IA
value|1366l
end_define
begin_comment
DECL|macro|IA
comment|/* random number generator */
end_comment
begin_define
DECL|macro|IC
define|#
directive|define
name|IC
value|150889l
end_define
begin_comment
DECL|macro|IC
comment|/* (see e.g. `Numerical Recipes') */
end_comment
begin_struct
DECL|struct|lran2_st
struct|struct
name|lran2_st
block|{
DECL|member|x
DECL|member|y
DECL|member|v
name|long
name|x
decl_stmt|,
name|y
decl_stmt|,
name|v
index|[
literal|97
index|]
decl_stmt|;
block|}
struct|;
end_struct
begin_function
specifier|static
name|void
DECL|function|lran2_init
name|lran2_init
parameter_list|(
name|struct
name|lran2_st
modifier|*
name|d
parameter_list|,
name|long
name|seed
parameter_list|)
block|{
name|long
name|x
decl_stmt|;
name|int
name|j
decl_stmt|;
name|x
operator|=
operator|(
name|IC
operator|-
name|seed
operator|)
operator|%
name|LRAN2_MAX
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
name|x
operator|=
operator|-
name|x
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|97
condition|;
name|j
operator|++
control|)
block|{
name|x
operator|=
operator|(
name|IA
operator|*
name|x
operator|+
name|IC
operator|)
operator|%
name|LRAN2_MAX
expr_stmt|;
name|d
operator|->
name|v
index|[
name|j
index|]
operator|=
name|x
expr_stmt|;
block|}
name|d
operator|->
name|x
operator|=
operator|(
name|IA
operator|*
name|x
operator|+
name|IC
operator|)
operator|%
name|LRAN2_MAX
expr_stmt|;
name|d
operator|->
name|y
operator|=
name|d
operator|->
name|x
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef
begin_function
name|__inline__
endif|#
directive|endif
specifier|static
name|long
DECL|function|lran2
name|lran2
parameter_list|(
name|struct
name|lran2_st
modifier|*
name|d
parameter_list|)
block|{
name|int
name|j
init|=
operator|(
name|d
operator|->
name|y
operator|%
literal|97
operator|)
decl_stmt|;
name|d
operator|->
name|y
operator|=
name|d
operator|->
name|v
index|[
name|j
index|]
expr_stmt|;
name|d
operator|->
name|x
operator|=
operator|(
name|IA
operator|*
name|d
operator|->
name|x
operator|+
name|IC
operator|)
operator|%
name|LRAN2_MAX
expr_stmt|;
name|d
operator|->
name|v
index|[
name|j
index|]
operator|=
name|d
operator|->
name|x
expr_stmt|;
return|return
name|d
operator|->
name|y
return|;
block|}
end_function
begin_undef
DECL|macro|IA
undef|#
directive|undef
name|IA
end_undef
begin_undef
DECL|macro|IC
undef|#
directive|undef
name|IC
end_undef
begin_endif
endif|#
directive|endif
end_endif
end_unit
