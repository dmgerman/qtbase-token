begin_unit
begin_comment
comment|/* Basic platform-independent macro definitions for mutexes,    thread-specific data and parameters for malloc.    Posix threads (pthreads) version.    Copyright (C) 2004 Wolfram Gloger<wg@malloc.de>.  Permission to use, copy, modify, distribute, and sell this software and its documentation for any purpose is hereby granted without fee, provided that (i) the above copyright notices and this permission notice appear in all copies of the software and related documentation, and (ii) the name of Wolfram Gloger may not be used in any advertising or publicity relating to the software.  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL WOLFRAM GLOGER BE LIABLE FOR ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|_PTHREAD_MALLOC_MACHINE_H
end_ifndef
begin_define
DECL|macro|_PTHREAD_MALLOC_MACHINE_H
define|#
directive|define
name|_PTHREAD_MALLOC_MACHINE_H
end_define
begin_include
include|#
directive|include
file|<pthread.h>
end_include
begin_undef
DECL|macro|thread_atfork_static
undef|#
directive|undef
name|thread_atfork_static
end_undef
begin_comment
comment|/* Use fast inline spinlocks with gcc.  */
end_comment
begin_if
if|#
directive|if
operator|(
name|defined
name|__i386__
operator|||
name|defined
name|__x86_64__
operator|)
operator|&&
name|defined
name|__GNUC__
operator|&&
expr|\
operator|!
name|defined
name|USE_NO_SPINLOCKS
end_if
begin_include
include|#
directive|include
file|<time.h>
end_include
begin_include
include|#
directive|include
file|<sched.h>
end_include
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|lock
specifier|volatile
name|unsigned
name|int
name|lock
decl_stmt|;
DECL|member|pad0_
name|int
name|pad0_
decl_stmt|;
block|}
DECL|typedef|mutex_t
name|mutex_t
typedef|;
end_typedef
begin_define
DECL|macro|MUTEX_INITIALIZER
define|#
directive|define
name|MUTEX_INITIALIZER
value|{ 0 }
end_define
begin_define
DECL|macro|mutex_init
define|#
directive|define
name|mutex_init
parameter_list|(
name|m
parameter_list|)
value|((m)->lock = 0)
end_define
begin_function
DECL|function|mutex_lock
specifier|static
specifier|inline
name|int
name|mutex_lock
parameter_list|(
name|mutex_t
modifier|*
name|m
parameter_list|)
block|{
name|int
name|cnt
init|=
literal|0
decl_stmt|,
name|r
decl_stmt|;
name|struct
name|timespec
name|tm
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
asm|__asm__
specifier|__volatile__
asm|("xchgl %0, %1"        : "=r"(r), "=m"(m->lock)        : "0"(1), "m"(m->lock)        : "memory");
if|if
condition|(
operator|!
name|r
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|cnt
operator|<
literal|50
condition|)
block|{
name|sched_yield
argument_list|()
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
else|else
block|{
name|tm
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|tm
operator|.
name|tv_nsec
operator|=
literal|2000001
expr_stmt|;
name|nanosleep
argument_list|(
operator|&
name|tm
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|mutex_trylock
specifier|static
specifier|inline
name|int
name|mutex_trylock
parameter_list|(
name|mutex_t
modifier|*
name|m
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
asm|__asm__
specifier|__volatile__
asm|("xchgl %0, %1"      : "=r"(r), "=m"(m->lock)      : "0"(1), "m"(m->lock)      : "memory");
return|return
name|r
return|;
block|}
end_function
begin_function
DECL|function|mutex_unlock
specifier|static
specifier|inline
name|int
name|mutex_unlock
parameter_list|(
name|mutex_t
modifier|*
name|m
parameter_list|)
block|{
asm|__asm__
specifier|__volatile__
asm|("movl %1, %0" : "=m" (m->lock) : "g"(0) : "memory");
return|return
literal|0
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* Normal pthread mutex.  */
end_comment
begin_typedef
DECL|typedef|mutex_t
typedef|typedef
name|pthread_mutex_t
name|mutex_t
typedef|;
end_typedef
begin_define
DECL|macro|MUTEX_INITIALIZER
define|#
directive|define
name|MUTEX_INITIALIZER
value|PTHREAD_MUTEX_INITIALIZER
end_define
begin_define
DECL|macro|mutex_init
define|#
directive|define
name|mutex_init
parameter_list|(
name|m
parameter_list|)
value|pthread_mutex_init(m, NULL)
end_define
begin_define
DECL|macro|mutex_lock
define|#
directive|define
name|mutex_lock
parameter_list|(
name|m
parameter_list|)
value|pthread_mutex_lock(m)
end_define
begin_define
DECL|macro|mutex_trylock
define|#
directive|define
name|mutex_trylock
parameter_list|(
name|m
parameter_list|)
value|pthread_mutex_trylock(m)
end_define
begin_define
DECL|macro|mutex_unlock
define|#
directive|define
name|mutex_unlock
parameter_list|(
name|m
parameter_list|)
value|pthread_mutex_unlock(m)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* (__i386__ || __x86_64__)&& __GNUC__&& !USE_NO_SPINLOCKS */
end_comment
begin_comment
comment|/* thread specific data */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__sgi
argument_list|)
operator|||
name|defined
argument_list|(
name|USE_TSD_DATA_HACK
argument_list|)
end_if
begin_comment
comment|/* Hack for thread-specific data, e.g. on Irix 6.x.  We can't use    pthread_setspecific because that function calls malloc() itself.    The hack only works when pthread_t can be converted to an integral    type. */
end_comment
begin_typedef
DECL|typedef|tsd_key_t
typedef|typedef
name|void
modifier|*
name|tsd_key_t
index|[
literal|256
index|]
typedef|;
end_typedef
begin_define
DECL|macro|tsd_key_create
define|#
directive|define
name|tsd_key_create
parameter_list|(
name|key
parameter_list|,
name|destr
parameter_list|)
value|do { \   int i; \   for(i=0; i<256; i++) (*key)[i] = 0; \ } while(0)
end_define
begin_define
DECL|macro|tsd_setspecific
define|#
directive|define
name|tsd_setspecific
parameter_list|(
name|key
parameter_list|,
name|data
parameter_list|)
define|\
value|(key[(unsigned)pthread_self() % 256] = (data))
end_define
begin_define
DECL|macro|tsd_getspecific
define|#
directive|define
name|tsd_getspecific
parameter_list|(
name|key
parameter_list|,
name|vptr
parameter_list|)
define|\
value|(vptr = key[(unsigned)pthread_self() % 256])
end_define
begin_else
else|#
directive|else
end_else
begin_typedef
DECL|typedef|tsd_key_t
typedef|typedef
name|pthread_key_t
name|tsd_key_t
typedef|;
end_typedef
begin_define
DECL|macro|tsd_key_create
define|#
directive|define
name|tsd_key_create
parameter_list|(
name|key
parameter_list|,
name|destr
parameter_list|)
value|pthread_key_create(key, destr)
end_define
begin_define
DECL|macro|tsd_setspecific
define|#
directive|define
name|tsd_setspecific
parameter_list|(
name|key
parameter_list|,
name|data
parameter_list|)
value|pthread_setspecific(key, data)
end_define
begin_define
DECL|macro|tsd_getspecific
define|#
directive|define
name|tsd_getspecific
parameter_list|(
name|key
parameter_list|,
name|vptr
parameter_list|)
value|(vptr = pthread_getspecific(key))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* at fork */
end_comment
begin_define
DECL|macro|thread_atfork
define|#
directive|define
name|thread_atfork
parameter_list|(
name|prepare
parameter_list|,
name|parent
parameter_list|,
name|child
parameter_list|)
define|\
value|pthread_atfork(prepare, parent, child)
end_define
begin_include
include|#
directive|include
file|<sysdeps/generic/malloc-machine.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !defined(_MALLOC_MACHINE_H) */
end_comment
end_unit
