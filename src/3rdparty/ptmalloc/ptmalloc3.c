begin_unit
begin_comment
comment|/*  * $Id: ptmalloc3.c,v 1.8 2006/03/31 15:57:28 wg Exp $  *   ptmalloc3 -- wrapper for Doug Lea's malloc-2.8.3 with concurrent              allocations  Copyright (c) 2005, 2006 Wolfram Gloger<ptmalloc@malloc.de>  Permission to use, copy, modify, distribute, and sell this software and its documentation for any purpose is hereby granted without fee, provided that (i) the above copyright notices and this permission notice appear in all copies of the software and related documentation, and (ii) the name of Wolfram Gloger may not be used in any advertising or publicity relating to the software.  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL WOLFRAM GLOGER BE LIABLE FOR ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.   */
end_comment
begin_comment
comment|/*  * TODO: optimization / better integration with malloc.c (partly done)  *       malloc_{get,set}_state (probably hard to keep compatibility)  *       debugging hooks  *       better mstats  */
end_comment
begin_include
include|#
directive|include
file|<sys/types.h>
end_include
begin_comment
comment|/* For size_t */
end_comment
begin_include
include|#
directive|include
file|<sys/mman.h>
end_include
begin_comment
comment|/* for mmap */
end_comment
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_comment
comment|/* for memset */
end_comment
begin_include
include|#
directive|include
file|<malloc-machine.h>
end_include
begin_include
include|#
directive|include
file|"malloc-2.8.3.h"
end_include
begin_comment
comment|/* ----------------------------------------------------------------------- */
end_comment
begin_comment
comment|/* The following section is replicated from malloc.c */
end_comment
begin_include
include|#
directive|include
file|"malloc-private.h"
end_include
begin_comment
comment|/* end of definitions replicated from malloc.c */
end_comment
begin_define
DECL|macro|munmap_chunk
define|#
directive|define
name|munmap_chunk
parameter_list|(
name|mst
parameter_list|,
name|p
parameter_list|)
value|do {                         \   size_t prevsize = (p)->prev_foot& ~IS_MMAPPED_BIT;     \   size_t psize = chunksize(p) + prevsize + MMAP_FOOT_PAD; \   if (CALL_MUNMAP((char*)(p) - prevsize, psize) == 0)     \     ((struct malloc_state*)(mst))->footprint -= psize;    \ } while (0)
end_define
begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment
begin_comment
comment|/* Minimum size for a newly created arena.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|ARENA_SIZE_MIN
end_ifndef
begin_define
DECL|macro|ARENA_SIZE_MIN
define|#
directive|define
name|ARENA_SIZE_MIN
value|(128*1024)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|HAVE_MEMCPY
define|#
directive|define
name|HAVE_MEMCPY
value|1
end_define
begin_comment
comment|/* If THREAD_STATS is non-zero, some statistics on mutex locking are    computed.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|THREAD_STATS
end_ifndef
begin_define
DECL|macro|THREAD_STATS
define|#
directive|define
name|THREAD_STATS
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|MALLOC_DEBUG
end_ifndef
begin_define
DECL|macro|MALLOC_DEBUG
define|#
directive|define
name|MALLOC_DEBUG
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|my_powerof2
define|#
directive|define
name|my_powerof2
parameter_list|(
name|x
parameter_list|)
value|((((x)-1)&(x))==0)
end_define
begin_comment
comment|/* Already initialized? */
end_comment
begin_decl_stmt
DECL|variable|__malloc_initialized
name|int
name|__malloc_initialized
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_ifndef
ifndef|#
directive|ifndef
name|RETURN_ADDRESS
end_ifndef
begin_define
DECL|macro|RETURN_ADDRESS
define|#
directive|define
name|RETURN_ADDRESS
parameter_list|(
name|X_
parameter_list|)
value|(NULL)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|THREAD_STATS
end_if
begin_define
DECL|macro|THREAD_STAT
define|#
directive|define
name|THREAD_STAT
parameter_list|(
name|x
parameter_list|)
value|x
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|THREAD_STAT
define|#
directive|define
name|THREAD_STAT
parameter_list|(
name|x
parameter_list|)
value|do ; while(0)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef
begin_comment
comment|/* Special defines for the GNU C library.  */
end_comment
begin_define
DECL|macro|public_cALLOc
define|#
directive|define
name|public_cALLOc
value|__libc_calloc
end_define
begin_define
DECL|macro|public_fREe
define|#
directive|define
name|public_fREe
value|__libc_free
end_define
begin_define
DECL|macro|public_cFREe
define|#
directive|define
name|public_cFREe
value|__libc_cfree
end_define
begin_define
DECL|macro|public_mALLOc
define|#
directive|define
name|public_mALLOc
value|__libc_malloc
end_define
begin_define
DECL|macro|public_mEMALIGn
define|#
directive|define
name|public_mEMALIGn
value|__libc_memalign
end_define
begin_define
DECL|macro|public_rEALLOc
define|#
directive|define
name|public_rEALLOc
value|__libc_realloc
end_define
begin_define
DECL|macro|public_vALLOc
define|#
directive|define
name|public_vALLOc
value|__libc_valloc
end_define
begin_define
DECL|macro|public_pVALLOc
define|#
directive|define
name|public_pVALLOc
value|__libc_pvalloc
end_define
begin_define
DECL|macro|public_pMEMALIGn
define|#
directive|define
name|public_pMEMALIGn
value|__posix_memalign
end_define
begin_define
DECL|macro|public_mALLINFo
define|#
directive|define
name|public_mALLINFo
value|__libc_mallinfo
end_define
begin_define
DECL|macro|public_mALLOPt
define|#
directive|define
name|public_mALLOPt
value|__libc_mallopt
end_define
begin_define
DECL|macro|public_mTRIm
define|#
directive|define
name|public_mTRIm
value|__malloc_trim
end_define
begin_define
DECL|macro|public_mSTATs
define|#
directive|define
name|public_mSTATs
value|__malloc_stats
end_define
begin_define
DECL|macro|public_mUSABLe
define|#
directive|define
name|public_mUSABLe
value|__malloc_usable_size
end_define
begin_define
DECL|macro|public_iCALLOc
define|#
directive|define
name|public_iCALLOc
value|__libc_independent_calloc
end_define
begin_define
DECL|macro|public_iCOMALLOc
define|#
directive|define
name|public_iCOMALLOc
value|__libc_independent_comalloc
end_define
begin_define
DECL|macro|public_gET_STATe
define|#
directive|define
name|public_gET_STATe
value|__malloc_get_state
end_define
begin_define
DECL|macro|public_sET_STATe
define|#
directive|define
name|public_sET_STATe
value|__malloc_set_state
end_define
begin_define
DECL|macro|malloc_getpagesize
define|#
directive|define
name|malloc_getpagesize
value|__getpagesize()
end_define
begin_define
DECL|macro|open
define|#
directive|define
name|open
value|__open
end_define
begin_define
DECL|macro|mmap
define|#
directive|define
name|mmap
value|__mmap
end_define
begin_define
DECL|macro|munmap
define|#
directive|define
name|munmap
value|__munmap
end_define
begin_define
DECL|macro|mremap
define|#
directive|define
name|mremap
value|__mremap
end_define
begin_define
DECL|macro|mprotect
define|#
directive|define
name|mprotect
value|__mprotect
end_define
begin_define
DECL|macro|MORECORE
define|#
directive|define
name|MORECORE
value|(*__morecore)
end_define
begin_define
DECL|macro|MORECORE_FAILURE
define|#
directive|define
name|MORECORE_FAILURE
value|0
end_define
begin_function_decl
name|void
modifier|*
name|__default_morecore
parameter_list|(
name|ptrdiff_t
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
DECL|variable|__morecore
name|void
modifier|*
function_decl|(
modifier|*
name|__morecore
function_decl|)
parameter_list|(
name|ptrdiff_t
parameter_list|)
init|=
name|__default_morecore
function_decl|;
end_function_decl
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !_LIBC */
end_comment
begin_define
DECL|macro|public_cALLOc
define|#
directive|define
name|public_cALLOc
value|calloc
end_define
begin_define
DECL|macro|public_fREe
define|#
directive|define
name|public_fREe
value|free
end_define
begin_define
DECL|macro|public_cFREe
define|#
directive|define
name|public_cFREe
value|cfree
end_define
begin_define
DECL|macro|public_mALLOc
define|#
directive|define
name|public_mALLOc
value|malloc
end_define
begin_define
DECL|macro|public_mEMALIGn
define|#
directive|define
name|public_mEMALIGn
value|memalign
end_define
begin_define
DECL|macro|public_rEALLOc
define|#
directive|define
name|public_rEALLOc
value|realloc
end_define
begin_define
DECL|macro|public_vALLOc
define|#
directive|define
name|public_vALLOc
value|valloc
end_define
begin_define
DECL|macro|public_pVALLOc
define|#
directive|define
name|public_pVALLOc
value|pvalloc
end_define
begin_define
DECL|macro|public_pMEMALIGn
define|#
directive|define
name|public_pMEMALIGn
value|posix_memalign
end_define
begin_define
DECL|macro|public_mALLINFo
define|#
directive|define
name|public_mALLINFo
value|mallinfo
end_define
begin_define
DECL|macro|public_mALLOPt
define|#
directive|define
name|public_mALLOPt
value|mallopt
end_define
begin_define
DECL|macro|public_mTRIm
define|#
directive|define
name|public_mTRIm
value|malloc_trim
end_define
begin_define
DECL|macro|public_mSTATs
define|#
directive|define
name|public_mSTATs
value|malloc_stats
end_define
begin_define
DECL|macro|public_mUSABLe
define|#
directive|define
name|public_mUSABLe
value|malloc_usable_size
end_define
begin_define
DECL|macro|public_iCALLOc
define|#
directive|define
name|public_iCALLOc
value|independent_calloc
end_define
begin_define
DECL|macro|public_iCOMALLOc
define|#
directive|define
name|public_iCOMALLOc
value|independent_comalloc
end_define
begin_define
DECL|macro|public_gET_STATe
define|#
directive|define
name|public_gET_STATe
value|malloc_get_state
end_define
begin_define
DECL|macro|public_sET_STATe
define|#
directive|define
name|public_sET_STATe
value|malloc_set_state
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* _LIBC */
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
name|_LIBC
operator|&&
operator|(
operator|!
name|defined
name|__GNUC__
operator|||
name|__GNUC__
operator|<
literal|3
operator|)
end_if
begin_define
DECL|macro|__builtin_expect
define|#
directive|define
name|__builtin_expect
parameter_list|(
name|expr
parameter_list|,
name|val
parameter_list|)
value|(expr)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|MALLOC_DEBUG
end_if
begin_include
include|#
directive|include
file|<assert.h>
end_include
begin_else
else|#
directive|else
end_else
begin_undef
DECL|macro|assert
undef|#
directive|undef
name|assert
end_undef
begin_define
DECL|macro|assert
define|#
directive|define
name|assert
parameter_list|(
name|x
parameter_list|)
value|((void)0)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* USE_STARTER determines if and when the special "starter" hook    functions are used: not at all (0), during ptmalloc_init (first bit    set), or from the beginning until an explicit call to ptmalloc_init    (second bit set).  This is necessary if thread-related    initialization functions (e.g.  pthread_key_create) require    malloc() calls (set USE_STARTER=1), or if those functions initially    cannot be used at all (set USE_STARTER=2 and perform an explicit    ptmalloc_init() when the thread library is ready, typically at the    start of main()). */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|USE_STARTER
end_ifndef
begin_ifndef
ifndef|#
directive|ifndef
name|_LIBC
end_ifndef
begin_define
DECL|macro|USE_STARTER
define|#
directive|define
name|USE_STARTER
value|1
end_define
begin_else
else|#
directive|else
end_else
begin_if
if|#
directive|if
name|USE___THREAD
operator|||
operator|(
name|defined
name|USE_TLS
operator|&&
operator|!
name|defined
name|SHARED
operator|)
end_if
begin_comment
comment|/* These routines are never needed in this configuration.  */
end_comment
begin_define
DECL|macro|USE_STARTER
define|#
directive|define
name|USE_STARTER
value|0
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|USE_STARTER
define|#
directive|define
name|USE_STARTER
value|(USE_TLS ? 4 : 1)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*----------------------------------------------------------------------*/
end_comment
begin_comment
comment|/* Arenas */
end_comment
begin_decl_stmt
DECL|variable|arena_key
specifier|static
name|tsd_key_t
name|arena_key
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|list_lock
specifier|static
name|mutex_t
name|list_lock
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* Arena structure */
end_comment
begin_struct
DECL|struct|malloc_arena
struct|struct
name|malloc_arena
block|{
comment|/* Serialize access.  */
DECL|member|mutex
name|mutex_t
name|mutex
decl_stmt|;
comment|/* Statistics for locking.  Only used if THREAD_STATS is defined.  */
DECL|member|stat_lock_direct
DECL|member|stat_lock_loop
DECL|member|stat_lock_wait
name|long
name|stat_lock_direct
decl_stmt|,
name|stat_lock_loop
decl_stmt|,
name|stat_lock_wait
decl_stmt|;
DECL|member|stat_starter
name|long
name|stat_starter
decl_stmt|;
comment|/* Linked list */
DECL|member|next
name|struct
name|malloc_arena
modifier|*
name|next
decl_stmt|;
comment|/* Space for mstate.  The size is just the minimum such that      create_mspace_with_base can be successfully called.  */
DECL|member|buf_
name|char
name|buf_
index|[
name|pad_request
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|malloc_state
argument_list|)
argument_list|)
operator|+
name|TOP_FOOT_SIZE
operator|+
name|CHUNK_ALIGN_MASK
operator|+
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct
begin_define
DECL|macro|MSPACE_OFFSET
define|#
directive|define
name|MSPACE_OFFSET
value|(((offsetof(struct malloc_arena, buf_) \ 			 + CHUNK_ALIGN_MASK)& ~CHUNK_ALIGN_MASK))
end_define
begin_define
DECL|macro|arena_to_mspace
define|#
directive|define
name|arena_to_mspace
parameter_list|(
name|a
parameter_list|)
value|((void *)chunk2mem((char*)(a) + MSPACE_OFFSET))
end_define
begin_comment
comment|/* check for chunk from non-main arena */
end_comment
begin_define
DECL|macro|chunk_non_main_arena
define|#
directive|define
name|chunk_non_main_arena
parameter_list|(
name|p
parameter_list|)
value|((p)->head& NON_MAIN_ARENA)
end_define
begin_function_decl
specifier|static
name|struct
name|malloc_arena
modifier|*
name|_int_new_arena
parameter_list|(
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Buffer for the main arena. */
end_comment
begin_decl_stmt
DECL|variable|main_arena
specifier|static
name|struct
name|malloc_arena
name|main_arena
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* For now, store arena in footer.  This means typically 4bytes more    overhead for each non-main-arena chunk, but is fast and easy to    compute.  Note that the pointer stored in the extra footer must be    properly aligned, though. */
end_comment
begin_define
DECL|macro|FOOTER_OVERHEAD
define|#
directive|define
name|FOOTER_OVERHEAD
define|\
value|(2*sizeof(struct malloc_arena*) - SIZE_T_SIZE)
end_define
begin_define
DECL|macro|arena_for_chunk
define|#
directive|define
name|arena_for_chunk
parameter_list|(
name|ptr
parameter_list|)
define|\
value|(chunk_non_main_arena(ptr) ? *(struct malloc_arena**)              \   ((char*)(ptr) + chunksize(ptr) - (FOOTER_OVERHEAD - SIZE_T_SIZE)) \   :&main_arena)
end_define
begin_comment
comment|/* special because of extra overhead */
end_comment
begin_define
DECL|macro|arena_for_mmap_chunk
define|#
directive|define
name|arena_for_mmap_chunk
parameter_list|(
name|ptr
parameter_list|)
define|\
value|(chunk_non_main_arena(ptr) ? *(struct malloc_arena**)             \   ((char*)(ptr) + chunksize(ptr) - sizeof(struct malloc_arena*))   \   :&main_arena)
end_define
begin_define
DECL|macro|set_non_main_arena
define|#
directive|define
name|set_non_main_arena
parameter_list|(
name|mem
parameter_list|,
name|ar_ptr
parameter_list|)
value|do {                   		      \   mchunkptr P = mem2chunk(mem);                                               \   size_t SZ = chunksize(P) - (is_mmapped(P) ? sizeof(struct malloc_arena*)    \                               : (FOOTER_OVERHEAD - SIZE_T_SIZE));             \   assert((unsigned long)((char*)(P) + SZ)%sizeof(struct malloc_arena*) == 0); \   *(struct malloc_arena**)((char*)(P) + SZ) = (ar_ptr);                       \   P->head |= NON_MAIN_ARENA;                                                  \ } while (0)
end_define
begin_comment
comment|/* arena_get() acquires an arena and locks the corresponding mutex.    First, try the one last locked successfully by this thread.  (This    is the common case and handled with a macro for speed.)  Then, loop    once over the circularly linked list of arenas.  If no arena is    readily available, create a new one.  In this latter case, `size'    is just a hint as to how much memory will be required immediately    in the new arena. */
end_comment
begin_define
DECL|macro|arena_get
define|#
directive|define
name|arena_get
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
value|do { \   void *vptr = NULL; \   ptr = (struct malloc_arena*)tsd_getspecific(arena_key, vptr); \   if(ptr&& !mutex_trylock(&ptr->mutex)) { \     THREAD_STAT(++(ptr->stat_lock_direct)); \   } else \     ptr = arena_get2(ptr, (size)); \ } while(0)
end_define
begin_function
specifier|static
name|struct
name|malloc_arena
modifier|*
DECL|function|arena_get2
name|arena_get2
parameter_list|(
name|struct
name|malloc_arena
modifier|*
name|a_tsd
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|struct
name|malloc_arena
modifier|*
name|a
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|a_tsd
condition|)
name|a
operator|=
name|a_tsd
operator|=
operator|&
name|main_arena
expr_stmt|;
else|else
block|{
name|a
operator|=
name|a_tsd
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|a
condition|)
block|{
comment|/* This can only happen while initializing the new arena. */
operator|(
name|void
operator|)
name|mutex_lock
argument_list|(
operator|&
name|main_arena
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|THREAD_STAT
argument_list|(
operator|++
operator|(
name|main_arena
operator|.
name|stat_lock_wait
operator|)
argument_list|)
expr_stmt|;
return|return
operator|&
name|main_arena
return|;
block|}
block|}
comment|/* Check the global, circularly linked list for available arenas. */
name|repeat
label|:
do|do
block|{
if|if
condition|(
operator|!
name|mutex_trylock
argument_list|(
operator|&
name|a
operator|->
name|mutex
argument_list|)
condition|)
block|{
name|THREAD_STAT
argument_list|(
operator|++
operator|(
name|a
operator|->
name|stat_lock_loop
operator|)
argument_list|)
expr_stmt|;
name|tsd_setspecific
argument_list|(
name|arena_key
argument_list|,
operator|(
name|void
operator|*
operator|)
name|a
argument_list|)
expr_stmt|;
return|return
name|a
return|;
block|}
name|a
operator|=
name|a
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|a
operator|!=
name|a_tsd
condition|)
do|;
comment|/* If not even the list_lock can be obtained, try again.  This can      happen during `atfork', or for example on systems where thread      creation makes it temporarily impossible to obtain _any_      locks. */
if|if
condition|(
name|mutex_trylock
argument_list|(
operator|&
name|list_lock
argument_list|)
condition|)
block|{
name|a
operator|=
name|a_tsd
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
operator|(
name|void
operator|)
name|mutex_unlock
argument_list|(
operator|&
name|list_lock
argument_list|)
expr_stmt|;
comment|/* Nothing immediately available, so generate a new arena.  */
name|a
operator|=
name|_int_new_arena
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|a
condition|)
return|return
literal|0
return|;
name|tsd_setspecific
argument_list|(
name|arena_key
argument_list|,
operator|(
name|void
operator|*
operator|)
name|a
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|a
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|err
operator|=
name|mutex_lock
argument_list|(
operator|&
name|a
operator|->
name|mutex
argument_list|)
expr_stmt|;
comment|/* remember result */
comment|/* Add the new arena to the global list.  */
operator|(
name|void
operator|)
name|mutex_lock
argument_list|(
operator|&
name|list_lock
argument_list|)
expr_stmt|;
name|a
operator|->
name|next
operator|=
name|main_arena
operator|.
name|next
expr_stmt|;
name|atomic_write_barrier
argument_list|()
expr_stmt|;
name|main_arena
operator|.
name|next
operator|=
name|a
expr_stmt|;
operator|(
name|void
operator|)
name|mutex_unlock
argument_list|(
operator|&
name|list_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
comment|/* locking failed; keep arena for further attempts later */
return|return
literal|0
return|;
name|THREAD_STAT
argument_list|(
operator|++
operator|(
name|a
operator|->
name|stat_lock_loop
operator|)
argument_list|)
expr_stmt|;
return|return
name|a
return|;
block|}
end_function
begin_comment
comment|/* Create a new arena with room for a chunk of size "size".  */
end_comment
begin_function
specifier|static
name|struct
name|malloc_arena
modifier|*
DECL|function|_int_new_arena
name|_int_new_arena
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|struct
name|malloc_arena
modifier|*
name|a
decl_stmt|;
name|size_t
name|mmap_sz
init|=
sizeof|sizeof
argument_list|(
operator|*
name|a
argument_list|)
operator|+
name|pad_request
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|void
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|mmap_sz
operator|<
name|ARENA_SIZE_MIN
condition|)
name|mmap_sz
operator|=
name|ARENA_SIZE_MIN
expr_stmt|;
comment|/* conservative estimate for page size */
name|mmap_sz
operator|=
operator|(
name|mmap_sz
operator|+
literal|8191
operator|)
operator|&
operator|~
operator|(
name|size_t
operator|)
literal|8191
expr_stmt|;
name|a
operator|=
name|CALL_MMAP
argument_list|(
name|mmap_sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|a
operator|==
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
return|return
literal|0
return|;
name|m
operator|=
name|create_mspace_with_base
argument_list|(
operator|(
name|char
operator|*
operator|)
name|a
operator|+
name|MSPACE_OFFSET
argument_list|,
name|mmap_sz
operator|-
name|MSPACE_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|CALL_MUNMAP
argument_list|(
name|a
argument_list|,
name|mmap_sz
argument_list|)
expr_stmt|;
name|a
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/*a->next = NULL;*/
comment|/*a->system_mem = a->max_system_mem = h->size;*/
block|}
return|return
name|a
return|;
block|}
end_function
begin_comment
comment|/*------------------------------------------------------------------------*/
end_comment
begin_comment
comment|/* Hook mechanism for proper initialization and atfork support. */
end_comment
begin_comment
comment|/* Define and initialize the hook variables.  These weak definitions must    appear before any use of the variables in a function.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|weak_variable
end_ifndef
begin_ifndef
ifndef|#
directive|ifndef
name|_LIBC
end_ifndef
begin_define
DECL|macro|weak_variable
define|#
directive|define
name|weak_variable
end_define
begin_comment
DECL|macro|weak_variable
comment|/**/
end_comment
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* In GNU libc we want the hook variables to be weak definitions to    avoid a problem with Emacs.  */
end_comment
begin_define
DECL|macro|weak_variable
define|#
directive|define
name|weak_variable
value|weak_function
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|!
operator|(
name|USE_STARTER
operator|&
literal|2
operator|)
end_if
begin_define
DECL|macro|free_hook_ini
define|#
directive|define
name|free_hook_ini
value|NULL
end_define
begin_comment
comment|/* Forward declarations.  */
end_comment
begin_function_decl
specifier|static
name|void
modifier|*
name|malloc_hook_ini
parameter_list|(
name|size_t
name|sz
parameter_list|,
specifier|const
name|void
modifier|*
name|caller
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
modifier|*
name|realloc_hook_ini
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|sz
parameter_list|,
specifier|const
name|void
modifier|*
name|caller
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
modifier|*
name|memalign_hook_ini
parameter_list|(
name|size_t
name|alignment
parameter_list|,
name|size_t
name|sz
parameter_list|,
specifier|const
name|void
modifier|*
name|caller
parameter_list|)
function_decl|;
end_function_decl
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|free_hook_ini
define|#
directive|define
name|free_hook_ini
value|free_starter
end_define
begin_define
DECL|macro|malloc_hook_ini
define|#
directive|define
name|malloc_hook_ini
value|malloc_starter
end_define
begin_define
DECL|macro|realloc_hook_ini
define|#
directive|define
name|realloc_hook_ini
value|NULL
end_define
begin_define
DECL|macro|memalign_hook_ini
define|#
directive|define
name|memalign_hook_ini
value|memalign_starter
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function_decl
DECL|variable|__malloc_initialize_hook
name|void
name|weak_variable
function_decl|(
modifier|*
name|__malloc_initialize_hook
function_decl|)
parameter_list|(
name|void
parameter_list|)
init|=
name|NULL
function_decl|;
end_function_decl
begin_function_decl
DECL|variable|__free_hook
name|void
name|weak_variable
function_decl|(
modifier|*
name|__free_hook
function_decl|)
parameter_list|(
name|void
modifier|*
name|__ptr
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
init|=
name|free_hook_ini
function_decl|;
end_function_decl
begin_function_decl
DECL|variable|__malloc_hook
name|void
modifier|*
name|weak_variable
function_decl|(
modifier|*
name|__malloc_hook
function_decl|)
parameter_list|(
name|size_t
name|__size
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
init|=
name|malloc_hook_ini
function_decl|;
end_function_decl
begin_function_decl
DECL|variable|__realloc_hook
name|void
modifier|*
name|weak_variable
function_decl|(
modifier|*
name|__realloc_hook
function_decl|)
parameter_list|(
name|void
modifier|*
name|__ptr
parameter_list|,
name|size_t
name|__size
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
init|=
name|realloc_hook_ini
function_decl|;
end_function_decl
begin_function_decl
DECL|variable|__memalign_hook
name|void
modifier|*
name|weak_variable
function_decl|(
modifier|*
name|__memalign_hook
function_decl|)
parameter_list|(
name|size_t
name|__alignment
parameter_list|,
name|size_t
name|__size
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
init|=
name|memalign_hook_ini
function_decl|;
end_function_decl
begin_comment
comment|/*void weak_variable (*__after_morecore_hook) (void) = NULL;*/
end_comment
begin_comment
comment|/* The initial hooks just call the initialization routine, then do the    normal work. */
end_comment
begin_if
if|#
directive|if
operator|!
operator|(
name|USE_STARTER
operator|&
literal|2
operator|)
end_if
begin_function_decl
specifier|static
endif|#
directive|endif
name|void
name|ptmalloc_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl
begin_if
if|#
directive|if
operator|!
operator|(
name|USE_STARTER
operator|&
literal|2
operator|)
end_if
begin_function
specifier|static
name|void
modifier|*
DECL|function|malloc_hook_ini
name|malloc_hook_ini
parameter_list|(
name|size_t
name|sz
parameter_list|,
specifier|const
name|void
modifier|*
name|caller
parameter_list|)
block|{
name|__malloc_hook
operator|=
name|NULL
expr_stmt|;
name|ptmalloc_init
argument_list|()
expr_stmt|;
return|return
name|public_mALLOc
argument_list|(
name|sz
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|void
modifier|*
DECL|function|realloc_hook_ini
name|realloc_hook_ini
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|sz
parameter_list|,
specifier|const
name|void
modifier|*
name|caller
parameter_list|)
block|{
name|__malloc_hook
operator|=
name|NULL
expr_stmt|;
name|__realloc_hook
operator|=
name|NULL
expr_stmt|;
name|ptmalloc_init
argument_list|()
expr_stmt|;
return|return
name|public_rEALLOc
argument_list|(
name|ptr
argument_list|,
name|sz
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|void
modifier|*
DECL|function|memalign_hook_ini
name|memalign_hook_ini
parameter_list|(
name|size_t
name|alignment
parameter_list|,
name|size_t
name|sz
parameter_list|,
specifier|const
name|void
modifier|*
name|caller
parameter_list|)
block|{
name|__memalign_hook
operator|=
name|NULL
expr_stmt|;
name|ptmalloc_init
argument_list|()
expr_stmt|;
return|return
name|public_mEMALIGn
argument_list|(
name|alignment
argument_list|,
name|sz
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !(USE_STARTER& 2) */
end_comment
begin_comment
comment|/*----------------------------------------------------------------------*/
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
name|NO_THREADS
operator|&&
name|USE_STARTER
end_if
begin_comment
comment|/* The following hooks are used when the global initialization in    ptmalloc_init() hasn't completed yet. */
end_comment
begin_function
specifier|static
name|void
modifier|*
DECL|function|malloc_starter
name|malloc_starter
parameter_list|(
name|size_t
name|sz
parameter_list|,
specifier|const
name|void
modifier|*
name|caller
parameter_list|)
block|{
name|void
modifier|*
name|victim
decl_stmt|;
comment|/*ptmalloc_init_minimal();*/
name|victim
operator|=
name|mspace_malloc
argument_list|(
name|arena_to_mspace
argument_list|(
operator|&
name|main_arena
argument_list|)
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|THREAD_STAT
argument_list|(
operator|++
name|main_arena
operator|.
name|stat_starter
argument_list|)
expr_stmt|;
return|return
name|victim
return|;
block|}
end_function
begin_function
specifier|static
name|void
modifier|*
DECL|function|memalign_starter
name|memalign_starter
parameter_list|(
name|size_t
name|align
parameter_list|,
name|size_t
name|sz
parameter_list|,
specifier|const
name|void
modifier|*
name|caller
parameter_list|)
block|{
name|void
modifier|*
name|victim
decl_stmt|;
comment|/*ptmalloc_init_minimal();*/
name|victim
operator|=
name|mspace_memalign
argument_list|(
name|arena_to_mspace
argument_list|(
operator|&
name|main_arena
argument_list|)
argument_list|,
name|align
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|THREAD_STAT
argument_list|(
operator|++
name|main_arena
operator|.
name|stat_starter
argument_list|)
expr_stmt|;
return|return
name|victim
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|free_starter
name|free_starter
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
specifier|const
name|void
modifier|*
name|caller
parameter_list|)
block|{
if|if
condition|(
name|mem
condition|)
block|{
name|mchunkptr
name|p
init|=
name|mem2chunk
argument_list|(
name|mem
argument_list|)
decl_stmt|;
name|void
modifier|*
name|msp
init|=
name|arena_to_mspace
argument_list|(
operator|&
name|main_arena
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_mmapped
argument_list|(
name|p
argument_list|)
condition|)
name|munmap_chunk
argument_list|(
name|msp
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
name|mspace_free
argument_list|(
name|msp
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
name|THREAD_STAT
argument_list|(
operator|++
name|main_arena
operator|.
name|stat_starter
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !defined NO_THREADS&& USE_STARTER */
end_comment
begin_comment
comment|/*----------------------------------------------------------------------*/
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|NO_THREADS
end_ifndef
begin_comment
comment|/* atfork support.  */
end_comment
begin_function_decl
DECL|variable|save_malloc_hook
specifier|static
name|void
modifier|*
function_decl|(
modifier|*
name|save_malloc_hook
function_decl|)
parameter_list|(
name|size_t
name|__size
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_if
if|#
directive|if
operator|!
name|defined
name|_LIBC
operator|||
operator|!
name|defined
name|USE_TLS
operator|||
operator|(
name|defined
name|SHARED
operator|&&
operator|!
name|USE___THREAD
operator|)
end_if
begin_function_decl
DECL|variable|save_memalign_hook
specifier|static
name|void
modifier|*
function_decl|(
modifier|*
name|save_memalign_hook
function_decl|)
parameter_list|(
name|size_t
name|__align
parameter_list|,
name|size_t
name|__size
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_function_decl
DECL|variable|save_free_hook
specifier|static
name|void
function_decl|(
modifier|*
name|save_free_hook
function_decl|)
parameter_list|(
name|void
modifier|*
name|__ptr
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_decl_stmt
DECL|variable|save_arena
specifier|static
name|void
modifier|*
name|save_arena
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* Magic value for the thread-specific arena pointer when    malloc_atfork() is in use.  */
end_comment
begin_define
DECL|macro|ATFORK_ARENA_PTR
define|#
directive|define
name|ATFORK_ARENA_PTR
value|((void*)-1)
end_define
begin_comment
comment|/* The following hooks are used while the `atfork' handling mechanism    is active. */
end_comment
begin_function
specifier|static
name|void
modifier|*
DECL|function|malloc_atfork
name|malloc_atfork
parameter_list|(
name|size_t
name|sz
parameter_list|,
specifier|const
name|void
modifier|*
name|caller
parameter_list|)
block|{
name|void
modifier|*
name|vptr
init|=
name|NULL
decl_stmt|;
name|tsd_getspecific
argument_list|(
name|arena_key
argument_list|,
name|vptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|vptr
operator|==
name|ATFORK_ARENA_PTR
condition|)
block|{
comment|/* We are the only thread that may allocate at all.  */
return|return
name|mspace_malloc
argument_list|(
name|arena_to_mspace
argument_list|(
operator|&
name|main_arena
argument_list|)
argument_list|,
name|sz
argument_list|)
return|;
block|}
else|else
block|{
comment|/* Suspend the thread until the `atfork' handlers have completed.        By that time, the hooks will have been reset as well, so that        mALLOc() can be used again. */
operator|(
name|void
operator|)
name|mutex_lock
argument_list|(
operator|&
name|list_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mutex_unlock
argument_list|(
operator|&
name|list_lock
argument_list|)
expr_stmt|;
return|return
name|public_mALLOc
argument_list|(
name|sz
argument_list|)
return|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|free_atfork
name|free_atfork
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
specifier|const
name|void
modifier|*
name|caller
parameter_list|)
block|{
name|void
modifier|*
name|vptr
init|=
name|NULL
decl_stmt|;
name|struct
name|malloc_arena
modifier|*
name|ar_ptr
decl_stmt|;
name|mchunkptr
name|p
decl_stmt|;
comment|/* chunk corresponding to mem */
if|if
condition|(
name|mem
operator|==
literal|0
condition|)
comment|/* free(0) has no effect */
return|return;
name|p
operator|=
name|mem2chunk
argument_list|(
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_mmapped
argument_list|(
name|p
argument_list|)
condition|)
block|{
comment|/* release mmapped memory. */
name|ar_ptr
operator|=
name|arena_for_mmap_chunk
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|munmap_chunk
argument_list|(
name|arena_to_mspace
argument_list|(
name|ar_ptr
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
name|ar_ptr
operator|=
name|arena_for_chunk
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|tsd_getspecific
argument_list|(
name|arena_key
argument_list|,
name|vptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|vptr
operator|!=
name|ATFORK_ARENA_PTR
condition|)
operator|(
name|void
operator|)
name|mutex_lock
argument_list|(
operator|&
name|ar_ptr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|mspace_free
argument_list|(
name|arena_to_mspace
argument_list|(
name|ar_ptr
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|vptr
operator|!=
name|ATFORK_ARENA_PTR
condition|)
operator|(
name|void
operator|)
name|mutex_unlock
argument_list|(
operator|&
name|ar_ptr
operator|->
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* The following two functions are registered via thread_atfork() to    make sure that the mutexes remain in a consistent state in the    fork()ed version of a thread.  Also adapt the malloc and free hooks    temporarily, because the `atfork' handler mechanism may use    malloc/free internally (e.g. in LinuxThreads). */
end_comment
begin_function
specifier|static
name|void
DECL|function|ptmalloc_lock_all
name|ptmalloc_lock_all
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|malloc_arena
modifier|*
name|ar_ptr
decl_stmt|;
if|if
condition|(
name|__malloc_initialized
operator|<
literal|1
condition|)
return|return;
operator|(
name|void
operator|)
name|mutex_lock
argument_list|(
operator|&
name|list_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|ar_ptr
operator|=
operator|&
name|main_arena
init|;
condition|;
control|)
block|{
operator|(
name|void
operator|)
name|mutex_lock
argument_list|(
operator|&
name|ar_ptr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|ar_ptr
operator|=
name|ar_ptr
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|ar_ptr
operator|==
operator|&
name|main_arena
condition|)
break|break;
block|}
name|save_malloc_hook
operator|=
name|__malloc_hook
expr_stmt|;
name|save_free_hook
operator|=
name|__free_hook
expr_stmt|;
name|__malloc_hook
operator|=
name|malloc_atfork
expr_stmt|;
name|__free_hook
operator|=
name|free_atfork
expr_stmt|;
comment|/* Only the current thread may perform malloc/free calls now. */
name|tsd_getspecific
argument_list|(
name|arena_key
argument_list|,
name|save_arena
argument_list|)
expr_stmt|;
name|tsd_setspecific
argument_list|(
name|arena_key
argument_list|,
name|ATFORK_ARENA_PTR
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ptmalloc_unlock_all
name|ptmalloc_unlock_all
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|malloc_arena
modifier|*
name|ar_ptr
decl_stmt|;
if|if
condition|(
name|__malloc_initialized
operator|<
literal|1
condition|)
return|return;
name|tsd_setspecific
argument_list|(
name|arena_key
argument_list|,
name|save_arena
argument_list|)
expr_stmt|;
name|__malloc_hook
operator|=
name|save_malloc_hook
expr_stmt|;
name|__free_hook
operator|=
name|save_free_hook
expr_stmt|;
for|for
control|(
name|ar_ptr
operator|=
operator|&
name|main_arena
init|;
condition|;
control|)
block|{
operator|(
name|void
operator|)
name|mutex_unlock
argument_list|(
operator|&
name|ar_ptr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|ar_ptr
operator|=
name|ar_ptr
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|ar_ptr
operator|==
operator|&
name|main_arena
condition|)
break|break;
block|}
operator|(
name|void
operator|)
name|mutex_unlock
argument_list|(
operator|&
name|list_lock
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef
begin_comment
comment|/* In LinuxThreads, unlocking a mutex in the child process after a    fork() is currently unsafe, whereas re-initializing it is safe and    does not leak resources.  Therefore, a special atfork handler is    installed for the child. */
end_comment
begin_function
specifier|static
name|void
DECL|function|ptmalloc_unlock_all2
name|ptmalloc_unlock_all2
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|malloc_arena
modifier|*
name|ar_ptr
decl_stmt|;
if|if
condition|(
name|__malloc_initialized
operator|<
literal|1
condition|)
return|return;
if|#
directive|if
name|defined
name|_LIBC
operator|||
literal|1
comment|/*defined MALLOC_HOOKS*/
name|tsd_setspecific
argument_list|(
name|arena_key
argument_list|,
name|save_arena
argument_list|)
expr_stmt|;
name|__malloc_hook
operator|=
name|save_malloc_hook
expr_stmt|;
name|__free_hook
operator|=
name|save_free_hook
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|ar_ptr
operator|=
operator|&
name|main_arena
init|;
condition|;
control|)
block|{
operator|(
name|void
operator|)
name|mutex_init
argument_list|(
operator|&
name|ar_ptr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|ar_ptr
operator|=
name|ar_ptr
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|ar_ptr
operator|==
operator|&
name|main_arena
condition|)
break|break;
block|}
operator|(
name|void
operator|)
name|mutex_init
argument_list|(
operator|&
name|list_lock
argument_list|)
expr_stmt|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|ptmalloc_unlock_all2
define|#
directive|define
name|ptmalloc_unlock_all2
value|ptmalloc_unlock_all
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !defined NO_THREADS */
end_comment
begin_comment
comment|/*---------------------------------------------------------------------*/
end_comment
begin_if
if|#
directive|if
operator|!
operator|(
name|USE_STARTER
operator|&
literal|2
operator|)
end_if
begin_function
specifier|static
endif|#
directive|endif
name|void
DECL|function|ptmalloc_init
name|ptmalloc_init
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|secure
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|mspace
decl_stmt|;
if|if
condition|(
name|__malloc_initialized
operator|>=
literal|0
condition|)
return|return;
name|__malloc_initialized
operator|=
literal|0
expr_stmt|;
comment|/*if (mp_.pagesize == 0)     ptmalloc_init_minimal();*/
ifndef|#
directive|ifndef
name|NO_THREADS
if|#
directive|if
name|USE_STARTER
operator|&
literal|1
comment|/* With some threads implementations, creating thread-specific data      or initializing a mutex may call malloc() itself.  Provide a      simple starter version (realloc() won't work). */
name|save_malloc_hook
operator|=
name|__malloc_hook
expr_stmt|;
name|save_memalign_hook
operator|=
name|__memalign_hook
expr_stmt|;
name|save_free_hook
operator|=
name|__free_hook
expr_stmt|;
name|__malloc_hook
operator|=
name|malloc_starter
expr_stmt|;
name|__memalign_hook
operator|=
name|memalign_starter
expr_stmt|;
name|__free_hook
operator|=
name|free_starter
expr_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
comment|/* Initialize the pthreads interface. */
if|if
condition|(
name|__pthread_initialize
operator|!=
name|NULL
condition|)
name|__pthread_initialize
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* !defined _LIBC */
endif|#
directive|endif
comment|/* USE_STARTER& 1 */
endif|#
directive|endif
comment|/* !defined NO_THREADS */
name|mutex_init
argument_list|(
operator|&
name|main_arena
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|main_arena
operator|.
name|next
operator|=
operator|&
name|main_arena
expr_stmt|;
name|mspace
operator|=
name|create_mspace_with_base
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|main_arena
operator|+
name|MSPACE_OFFSET
argument_list|,
sizeof|sizeof
argument_list|(
name|main_arena
argument_list|)
operator|-
name|MSPACE_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|mspace
operator|==
name|arena_to_mspace
argument_list|(
operator|&
name|main_arena
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|list_lock
argument_list|)
expr_stmt|;
name|tsd_key_create
argument_list|(
operator|&
name|arena_key
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tsd_setspecific
argument_list|(
name|arena_key
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|main_arena
argument_list|)
expr_stmt|;
name|thread_atfork
argument_list|(
name|ptmalloc_lock_all
argument_list|,
name|ptmalloc_unlock_all
argument_list|,
name|ptmalloc_unlock_all2
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_THREADS
if|#
directive|if
name|USE_STARTER
operator|&
literal|1
name|__malloc_hook
operator|=
name|save_malloc_hook
expr_stmt|;
name|__memalign_hook
operator|=
name|save_memalign_hook
expr_stmt|;
name|__free_hook
operator|=
name|save_free_hook
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|USE_STARTER
operator|&
literal|2
name|__malloc_hook
operator|=
literal|0
expr_stmt|;
name|__memalign_hook
operator|=
literal|0
expr_stmt|;
name|__free_hook
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_LIBC
name|secure
operator|=
name|__libc_enable_secure
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|secure
condition|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|getenv
argument_list|(
literal|"MALLOC_TRIM_THRESHOLD_"
argument_list|)
operator|)
condition|)
name|public_mALLOPt
argument_list|(
name|M_TRIM_THRESHOLD
argument_list|,
name|atoi
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|getenv
argument_list|(
literal|"MALLOC_TOP_PAD_"
argument_list|)
operator|)
operator|||
operator|(
name|s
operator|=
name|getenv
argument_list|(
literal|"MALLOC_GRANULARITY_"
argument_list|)
operator|)
condition|)
name|public_mALLOPt
argument_list|(
name|M_GRANULARITY
argument_list|,
name|atoi
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|getenv
argument_list|(
literal|"MALLOC_MMAP_THRESHOLD_"
argument_list|)
operator|)
condition|)
name|public_mALLOPt
argument_list|(
name|M_MMAP_THRESHOLD
argument_list|,
name|atoi
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
comment|/*if ((s = getenv("MALLOC_MMAP_MAX_"))) this is no longer available       public_mALLOPt(M_MMAP_MAX, atoi(s));*/
block|}
name|s
operator|=
name|getenv
argument_list|(
literal|"MALLOC_CHECK_"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|s
condition|)
block|{
comment|/*if(s[0]) mALLOPt(M_CHECK_ACTION, (int)(s[0] - '0'));       __malloc_check_init();*/
block|}
if|if
condition|(
name|__malloc_initialize_hook
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|__malloc_initialize_hook
call|)
argument_list|()
expr_stmt|;
name|__malloc_initialized
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_comment
comment|/*------------------------ Public wrappers. --------------------------------*/
end_comment
begin_function
name|void
modifier|*
DECL|function|public_mALLOc
name|public_mALLOc
parameter_list|(
name|size_t
name|bytes
parameter_list|)
block|{
name|struct
name|malloc_arena
modifier|*
name|ar_ptr
decl_stmt|;
name|void
modifier|*
name|victim
decl_stmt|;
name|void
modifier|*
function_decl|(
modifier|*
name|hook
function_decl|)
parameter_list|(
name|size_t
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
init|=
name|__malloc_hook
function_decl|;
if|if
condition|(
name|hook
operator|!=
name|NULL
condition|)
return|return
call|(
modifier|*
name|hook
call|)
argument_list|(
name|bytes
argument_list|,
name|RETURN_ADDRESS
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
name|arena_get
argument_list|(
name|ar_ptr
argument_list|,
name|bytes
operator|+
name|FOOTER_OVERHEAD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ar_ptr
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ar_ptr
operator|!=
operator|&
name|main_arena
condition|)
name|bytes
operator|+=
name|FOOTER_OVERHEAD
expr_stmt|;
name|victim
operator|=
name|mspace_malloc
argument_list|(
name|arena_to_mspace
argument_list|(
name|ar_ptr
argument_list|)
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|victim
operator|&&
name|ar_ptr
operator|!=
operator|&
name|main_arena
condition|)
name|set_non_main_arena
argument_list|(
name|victim
argument_list|,
name|ar_ptr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mutex_unlock
argument_list|(
operator|&
name|ar_ptr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|victim
operator|||
name|is_mmapped
argument_list|(
name|mem2chunk
argument_list|(
name|victim
argument_list|)
argument_list|)
operator|||
name|ar_ptr
operator|==
name|arena_for_chunk
argument_list|(
name|mem2chunk
argument_list|(
name|victim
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|victim
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|libc_hidden_def
end_ifdef
begin_macro
DECL|function|libc_hidden_def
name|libc_hidden_def
argument_list|(
argument|public_mALLOc
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|void
name|public_fREe
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|)
block|{
name|struct
name|malloc_arena
modifier|*
name|ar_ptr
decl_stmt|;
name|mchunkptr
name|p
decl_stmt|;
comment|/* chunk corresponding to mem */
name|void
function_decl|(
modifier|*
name|hook
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
init|=
name|__free_hook
function_decl|;
if|if
condition|(
name|hook
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|hook
call|)
argument_list|(
name|mem
argument_list|,
name|RETURN_ADDRESS
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mem
operator|==
literal|0
condition|)
comment|/* free(0) has no effect */
return|return;
name|p
operator|=
name|mem2chunk
argument_list|(
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_mmapped
argument_list|(
name|p
argument_list|)
condition|)
block|{
comment|/* release mmapped memory. */
name|ar_ptr
operator|=
name|arena_for_mmap_chunk
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|munmap_chunk
argument_list|(
name|arena_to_mspace
argument_list|(
name|ar_ptr
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
name|ar_ptr
operator|=
name|arena_for_chunk
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|#
directive|if
name|THREAD_STATS
if|if
condition|(
operator|!
name|mutex_trylock
argument_list|(
operator|&
name|ar_ptr
operator|->
name|mutex
argument_list|)
condition|)
operator|++
operator|(
name|ar_ptr
operator|->
name|stat_lock_direct
operator|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|mutex_lock
argument_list|(
operator|&
name|ar_ptr
operator|->
name|mutex
argument_list|)
expr_stmt|;
operator|++
operator|(
name|ar_ptr
operator|->
name|stat_lock_wait
operator|)
expr_stmt|;
block|}
else|#
directive|else
operator|(
name|void
operator|)
name|mutex_lock
argument_list|(
operator|&
name|ar_ptr
operator|->
name|mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mspace_free
argument_list|(
name|arena_to_mspace
argument_list|(
name|ar_ptr
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mutex_unlock
argument_list|(
operator|&
name|ar_ptr
operator|->
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|libc_hidden_def
end_ifdef
begin_macro
DECL|function|libc_hidden_def
name|libc_hidden_def
argument_list|(
argument|public_fREe
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|void
modifier|*
name|public_rEALLOc
parameter_list|(
name|void
modifier|*
name|oldmem
parameter_list|,
name|size_t
name|bytes
parameter_list|)
block|{
name|struct
name|malloc_arena
modifier|*
name|ar_ptr
decl_stmt|;
name|mchunkptr
name|oldp
decl_stmt|;
comment|/* chunk corresponding to oldmem */
name|void
modifier|*
name|newp
decl_stmt|;
comment|/* chunk to return */
name|void
modifier|*
function_decl|(
modifier|*
name|hook
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
init|=
name|__realloc_hook
function_decl|;
if|if
condition|(
name|hook
operator|!=
name|NULL
condition|)
return|return
call|(
modifier|*
name|hook
call|)
argument_list|(
name|oldmem
argument_list|,
name|bytes
argument_list|,
name|RETURN_ADDRESS
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
if|#
directive|if
name|REALLOC_ZERO_BYTES_FREES
if|if
condition|(
name|bytes
operator|==
literal|0
operator|&&
name|oldmem
operator|!=
name|NULL
condition|)
block|{
name|public_fREe
argument_list|(
name|oldmem
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* realloc of null is supposed to be same as malloc */
if|if
condition|(
name|oldmem
operator|==
literal|0
condition|)
return|return
name|public_mALLOc
argument_list|(
name|bytes
argument_list|)
return|;
name|oldp
operator|=
name|mem2chunk
argument_list|(
name|oldmem
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_mmapped
argument_list|(
name|oldp
argument_list|)
condition|)
name|ar_ptr
operator|=
name|arena_for_mmap_chunk
argument_list|(
name|oldp
argument_list|)
expr_stmt|;
comment|/* FIXME: use mmap_resize */
else|else
name|ar_ptr
operator|=
name|arena_for_chunk
argument_list|(
name|oldp
argument_list|)
expr_stmt|;
if|#
directive|if
name|THREAD_STATS
if|if
condition|(
operator|!
name|mutex_trylock
argument_list|(
operator|&
name|ar_ptr
operator|->
name|mutex
argument_list|)
condition|)
operator|++
operator|(
name|ar_ptr
operator|->
name|stat_lock_direct
operator|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|mutex_lock
argument_list|(
operator|&
name|ar_ptr
operator|->
name|mutex
argument_list|)
expr_stmt|;
operator|++
operator|(
name|ar_ptr
operator|->
name|stat_lock_wait
operator|)
expr_stmt|;
block|}
else|#
directive|else
operator|(
name|void
operator|)
name|mutex_lock
argument_list|(
operator|&
name|ar_ptr
operator|->
name|mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_THREADS
comment|/* As in malloc(), remember this arena for the next allocation. */
name|tsd_setspecific
argument_list|(
name|arena_key
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ar_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ar_ptr
operator|!=
operator|&
name|main_arena
condition|)
name|bytes
operator|+=
name|FOOTER_OVERHEAD
expr_stmt|;
name|newp
operator|=
name|mspace_realloc
argument_list|(
name|arena_to_mspace
argument_list|(
name|ar_ptr
argument_list|)
argument_list|,
name|oldmem
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|newp
operator|&&
name|ar_ptr
operator|!=
operator|&
name|main_arena
condition|)
name|set_non_main_arena
argument_list|(
name|newp
argument_list|,
name|ar_ptr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mutex_unlock
argument_list|(
operator|&
name|ar_ptr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|newp
operator|||
name|is_mmapped
argument_list|(
name|mem2chunk
argument_list|(
name|newp
argument_list|)
argument_list|)
operator|||
name|ar_ptr
operator|==
name|arena_for_chunk
argument_list|(
name|mem2chunk
argument_list|(
name|newp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|newp
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|libc_hidden_def
end_ifdef
begin_macro
DECL|function|libc_hidden_def
name|libc_hidden_def
argument_list|(
argument|public_rEALLOc
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|void
modifier|*
name|public_mEMALIGn
parameter_list|(
name|size_t
name|alignment
parameter_list|,
name|size_t
name|bytes
parameter_list|)
block|{
name|struct
name|malloc_arena
modifier|*
name|ar_ptr
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
function_decl|(
modifier|*
name|hook
function_decl|)
parameter_list|(
name|size_t
parameter_list|,
name|size_t
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
init|=
name|__memalign_hook
function_decl|;
if|if
condition|(
name|hook
operator|!=
name|NULL
condition|)
return|return
call|(
modifier|*
name|hook
call|)
argument_list|(
name|alignment
argument_list|,
name|bytes
argument_list|,
name|RETURN_ADDRESS
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
comment|/* If need less alignment than we give anyway, just relay to malloc */
if|if
condition|(
name|alignment
operator|<=
name|MALLOC_ALIGNMENT
condition|)
return|return
name|public_mALLOc
argument_list|(
name|bytes
argument_list|)
return|;
comment|/* Otherwise, ensure that it is at least a minimum chunk size */
if|if
condition|(
name|alignment
operator|<
name|MIN_CHUNK_SIZE
condition|)
name|alignment
operator|=
name|MIN_CHUNK_SIZE
expr_stmt|;
name|arena_get
argument_list|(
name|ar_ptr
argument_list|,
name|bytes
operator|+
name|FOOTER_OVERHEAD
operator|+
name|alignment
operator|+
name|MIN_CHUNK_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ar_ptr
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ar_ptr
operator|!=
operator|&
name|main_arena
condition|)
name|bytes
operator|+=
name|FOOTER_OVERHEAD
expr_stmt|;
name|p
operator|=
name|mspace_memalign
argument_list|(
name|arena_to_mspace
argument_list|(
name|ar_ptr
argument_list|)
argument_list|,
name|alignment
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
name|ar_ptr
operator|!=
operator|&
name|main_arena
condition|)
name|set_non_main_arena
argument_list|(
name|p
argument_list|,
name|ar_ptr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mutex_unlock
argument_list|(
operator|&
name|ar_ptr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|p
operator|||
name|is_mmapped
argument_list|(
name|mem2chunk
argument_list|(
name|p
argument_list|)
argument_list|)
operator|||
name|ar_ptr
operator|==
name|arena_for_chunk
argument_list|(
name|mem2chunk
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|libc_hidden_def
end_ifdef
begin_macro
DECL|function|libc_hidden_def
name|libc_hidden_def
argument_list|(
argument|public_mEMALIGn
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|void
modifier|*
name|public_vALLOc
parameter_list|(
name|size_t
name|bytes
parameter_list|)
block|{
name|struct
name|malloc_arena
modifier|*
name|ar_ptr
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|__malloc_initialized
operator|<
literal|0
condition|)
name|ptmalloc_init
argument_list|()
expr_stmt|;
name|arena_get
argument_list|(
name|ar_ptr
argument_list|,
name|bytes
operator|+
name|FOOTER_OVERHEAD
operator|+
name|MIN_CHUNK_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ar_ptr
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ar_ptr
operator|!=
operator|&
name|main_arena
condition|)
name|bytes
operator|+=
name|FOOTER_OVERHEAD
expr_stmt|;
name|p
operator|=
name|mspace_memalign
argument_list|(
name|arena_to_mspace
argument_list|(
name|ar_ptr
argument_list|)
argument_list|,
literal|4096
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
name|ar_ptr
operator|!=
operator|&
name|main_arena
condition|)
name|set_non_main_arena
argument_list|(
name|p
argument_list|,
name|ar_ptr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mutex_unlock
argument_list|(
operator|&
name|ar_ptr
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_function
name|int
DECL|function|public_pMEMALIGn
name|public_pMEMALIGn
parameter_list|(
name|void
modifier|*
modifier|*
name|memptr
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|mem
decl_stmt|;
comment|/* Test whether the SIZE argument is valid.  It must be a power of      two multiple of sizeof (void *).  */
if|if
condition|(
name|alignment
operator|%
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|my_powerof2
argument_list|(
name|alignment
operator|/
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|alignment
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
name|mem
operator|=
name|public_mEMALIGn
argument_list|(
name|alignment
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|!=
name|NULL
condition|)
block|{
operator|*
name|memptr
operator|=
name|mem
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|ENOMEM
return|;
block|}
end_function
begin_function
name|void
modifier|*
DECL|function|public_cALLOc
name|public_cALLOc
parameter_list|(
name|size_t
name|n_elements
parameter_list|,
name|size_t
name|elem_size
parameter_list|)
block|{
name|struct
name|malloc_arena
modifier|*
name|ar_ptr
decl_stmt|;
name|size_t
name|bytes
decl_stmt|,
name|sz
decl_stmt|;
name|void
modifier|*
name|mem
decl_stmt|;
name|void
modifier|*
function_decl|(
modifier|*
name|hook
function_decl|)
parameter_list|(
name|size_t
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
init|=
name|__malloc_hook
function_decl|;
comment|/* size_t is unsigned so the behavior on overflow is defined.  */
name|bytes
operator|=
name|n_elements
operator|*
name|elem_size
expr_stmt|;
DECL|macro|HALF_INTERNAL_SIZE_T
define|#
directive|define
name|HALF_INTERNAL_SIZE_T
define|\
value|(((size_t) 1)<< (8 * sizeof (size_t) / 2))
if|if
condition|(
name|__builtin_expect
argument_list|(
operator|(
name|n_elements
operator||
name|elem_size
operator|)
operator|>=
name|HALF_INTERNAL_SIZE_T
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|elem_size
operator|!=
literal|0
operator|&&
name|bytes
operator|/
name|elem_size
operator|!=
name|n_elements
condition|)
block|{
comment|/*MALLOC_FAILURE_ACTION;*/
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|hook
operator|!=
name|NULL
condition|)
block|{
name|sz
operator|=
name|bytes
expr_stmt|;
name|mem
operator|=
call|(
modifier|*
name|hook
call|)
argument_list|(
name|sz
argument_list|,
name|RETURN_ADDRESS
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|==
literal|0
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|HAVE_MEMCPY
return|return
name|memset
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|,
name|sz
argument_list|)
return|;
else|#
directive|else
while|while
condition|(
name|sz
operator|>
literal|0
condition|)
operator|(
operator|(
name|char
operator|*
operator|)
name|mem
operator|)
index|[
operator|--
name|sz
index|]
operator|=
literal|0
expr_stmt|;
comment|/* rather inefficient */
return|return
name|mem
return|;
endif|#
directive|endif
block|}
name|arena_get
argument_list|(
name|ar_ptr
argument_list|,
name|bytes
operator|+
name|FOOTER_OVERHEAD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ar_ptr
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ar_ptr
operator|!=
operator|&
name|main_arena
condition|)
name|bytes
operator|+=
name|FOOTER_OVERHEAD
expr_stmt|;
name|mem
operator|=
name|mspace_calloc
argument_list|(
name|arena_to_mspace
argument_list|(
name|ar_ptr
argument_list|)
argument_list|,
name|bytes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|&&
name|ar_ptr
operator|!=
operator|&
name|main_arena
condition|)
name|set_non_main_arena
argument_list|(
name|mem
argument_list|,
name|ar_ptr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mutex_unlock
argument_list|(
operator|&
name|ar_ptr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|mem
operator|||
name|is_mmapped
argument_list|(
name|mem2chunk
argument_list|(
name|mem
argument_list|)
argument_list|)
operator|||
name|ar_ptr
operator|==
name|arena_for_chunk
argument_list|(
name|mem2chunk
argument_list|(
name|mem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|mem
return|;
block|}
end_function
begin_function
name|void
modifier|*
modifier|*
DECL|function|public_iCALLOc
name|public_iCALLOc
parameter_list|(
name|size_t
name|n
parameter_list|,
name|size_t
name|elem_size
parameter_list|,
name|void
modifier|*
name|chunks
index|[]
parameter_list|)
block|{
name|struct
name|malloc_arena
modifier|*
name|ar_ptr
decl_stmt|;
name|void
modifier|*
modifier|*
name|m
decl_stmt|;
name|arena_get
argument_list|(
name|ar_ptr
argument_list|,
name|n
operator|*
operator|(
name|elem_size
operator|+
name|FOOTER_OVERHEAD
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ar_ptr
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ar_ptr
operator|!=
operator|&
name|main_arena
condition|)
name|elem_size
operator|+=
name|FOOTER_OVERHEAD
expr_stmt|;
name|m
operator|=
name|mspace_independent_calloc
argument_list|(
name|arena_to_mspace
argument_list|(
name|ar_ptr
argument_list|)
argument_list|,
name|n
argument_list|,
name|elem_size
argument_list|,
name|chunks
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|&&
name|ar_ptr
operator|!=
operator|&
name|main_arena
condition|)
block|{
while|while
condition|(
name|n
operator|>
literal|0
condition|)
name|set_non_main_arena
argument_list|(
name|m
index|[
operator|--
name|n
index|]
argument_list|,
name|ar_ptr
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|mutex_unlock
argument_list|(
operator|&
name|ar_ptr
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function
begin_function
name|void
modifier|*
modifier|*
DECL|function|public_iCOMALLOc
name|public_iCOMALLOc
parameter_list|(
name|size_t
name|n
parameter_list|,
name|size_t
name|sizes
index|[]
parameter_list|,
name|void
modifier|*
name|chunks
index|[]
parameter_list|)
block|{
name|struct
name|malloc_arena
modifier|*
name|ar_ptr
decl_stmt|;
name|size_t
modifier|*
name|m_sizes
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|void
modifier|*
modifier|*
name|m
decl_stmt|;
name|arena_get
argument_list|(
name|ar_ptr
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ar_ptr
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ar_ptr
operator|!=
operator|&
name|main_arena
condition|)
block|{
comment|/* Temporary m_sizes[] array is ugly but it would be surprising to        change the original sizes[]... */
name|m_sizes
operator|=
name|mspace_malloc
argument_list|(
name|arena_to_mspace
argument_list|(
name|ar_ptr
argument_list|)
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m_sizes
condition|)
block|{
operator|(
name|void
operator|)
name|mutex_unlock
argument_list|(
operator|&
name|ar_ptr
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|m_sizes
index|[
name|i
index|]
operator|=
name|sizes
index|[
name|i
index|]
operator|+
name|FOOTER_OVERHEAD
expr_stmt|;
if|if
condition|(
operator|!
name|chunks
condition|)
block|{
name|chunks
operator|=
name|mspace_malloc
argument_list|(
name|arena_to_mspace
argument_list|(
name|ar_ptr
argument_list|)
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|+
name|FOOTER_OVERHEAD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|chunks
condition|)
block|{
name|mspace_free
argument_list|(
name|arena_to_mspace
argument_list|(
name|ar_ptr
argument_list|)
argument_list|,
name|m_sizes
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mutex_unlock
argument_list|(
operator|&
name|ar_ptr
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|set_non_main_arena
argument_list|(
name|chunks
argument_list|,
name|ar_ptr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|m_sizes
operator|=
name|sizes
expr_stmt|;
name|m
operator|=
name|mspace_independent_comalloc
argument_list|(
name|arena_to_mspace
argument_list|(
name|ar_ptr
argument_list|)
argument_list|,
name|n
argument_list|,
name|m_sizes
argument_list|,
name|chunks
argument_list|)
expr_stmt|;
if|if
condition|(
name|ar_ptr
operator|!=
operator|&
name|main_arena
condition|)
block|{
name|mspace_free
argument_list|(
name|arena_to_mspace
argument_list|(
name|ar_ptr
argument_list|)
argument_list|,
name|m_sizes
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|set_non_main_arena
argument_list|(
name|m
index|[
name|i
index|]
argument_list|,
name|ar_ptr
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|mutex_unlock
argument_list|(
operator|&
name|ar_ptr
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function
begin_if
if|#
directive|if
literal|0
operator|&&
operator|!
name|defined
name|_LIBC
end_if
begin_endif
unit|void public_cFREe(void* m) {   public_fREe(m); }
endif|#
directive|endif
end_endif
begin_comment
comment|/* _LIBC */
end_comment
begin_function
name|int
DECL|function|public_mTRIm
name|public_mTRIm
parameter_list|(
name|size_t
name|s
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
operator|(
name|void
operator|)
name|mutex_lock
argument_list|(
operator|&
name|main_arena
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|result
operator|=
name|mspace_trim
argument_list|(
name|arena_to_mspace
argument_list|(
operator|&
name|main_arena
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mutex_unlock
argument_list|(
operator|&
name|main_arena
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
name|size_t
DECL|function|public_mUSABLe
name|public_mUSABLe
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|)
block|{
if|if
condition|(
name|mem
operator|!=
literal|0
condition|)
block|{
name|mchunkptr
name|p
init|=
name|mem2chunk
argument_list|(
name|mem
argument_list|)
decl_stmt|;
if|if
condition|(
name|cinuse
argument_list|(
name|p
argument_list|)
condition|)
return|return
name|chunksize
argument_list|(
name|p
argument_list|)
operator|-
name|overhead_for
argument_list|(
name|p
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
name|int
DECL|function|public_mALLOPt
name|public_mALLOPt
parameter_list|(
name|int
name|p
parameter_list|,
name|int
name|v
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
name|result
operator|=
name|mspace_mallopt
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
name|void
DECL|function|public_mSTATs
name|public_mSTATs
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|malloc_arena
modifier|*
name|ar_ptr
decl_stmt|;
comment|/*unsigned long in_use_b, system_b, avail_b;*/
if|#
directive|if
name|THREAD_STATS
name|long
name|stat_lock_direct
init|=
literal|0
decl_stmt|,
name|stat_lock_loop
init|=
literal|0
decl_stmt|,
name|stat_lock_wait
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|__malloc_initialized
operator|<
literal|0
condition|)
name|ptmalloc_init
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ar_ptr
operator|=
operator|&
name|main_arena
init|;
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|malloc_state
modifier|*
name|msp
init|=
name|arena_to_mspace
argument_list|(
name|ar_ptr
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Arena %d:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|mspace_malloc_stats
argument_list|(
name|msp
argument_list|)
expr_stmt|;
if|#
directive|if
name|THREAD_STATS
name|stat_lock_direct
operator|+=
name|ar_ptr
operator|->
name|stat_lock_direct
expr_stmt|;
name|stat_lock_loop
operator|+=
name|ar_ptr
operator|->
name|stat_lock_loop
expr_stmt|;
name|stat_lock_wait
operator|+=
name|ar_ptr
operator|->
name|stat_lock_wait
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|MALLOC_DEBUG
operator|>
literal|1
condition|)
block|{
name|struct
name|malloc_segment
modifier|*
name|mseg
init|=
operator|&
name|msp
operator|->
name|seg
decl_stmt|;
while|while
condition|(
name|mseg
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" seg %08lx-%08lx\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|mseg
operator|->
name|base
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|mseg
operator|->
name|base
operator|+
name|mseg
operator|->
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|mseg
operator|=
name|mseg
operator|->
name|next
expr_stmt|;
block|}
block|}
name|ar_ptr
operator|=
name|ar_ptr
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|ar_ptr
operator|==
operator|&
name|main_arena
condition|)
break|break;
block|}
if|#
directive|if
name|THREAD_STATS
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"locked directly  = %10ld\n"
argument_list|,
name|stat_lock_direct
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"locked in loop   = %10ld\n"
argument_list|,
name|stat_lock_loop
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"locked waiting   = %10ld\n"
argument_list|,
name|stat_lock_wait
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"locked total     = %10ld\n"
argument_list|,
name|stat_lock_direct
operator|+
name|stat_lock_loop
operator|+
name|stat_lock_wait
argument_list|)
expr_stmt|;
if|if
condition|(
name|main_arena
operator|.
name|stat_starter
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"starter hooks    = %10ld\n"
argument_list|,
name|main_arena
operator|.
name|stat_starter
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*  * Local variables:  * c-basic-offset: 2  * End:  */
end_comment
end_unit
