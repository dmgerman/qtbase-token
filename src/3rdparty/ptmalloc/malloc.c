begin_unit
begin_comment
comment|/*   $Id: malloc.c,v 1.4 2006/03/30 16:47:29 wg Exp $    This version of malloc.c was adapted for ptmalloc3 by Wolfram Gloger<wg@malloc.de>.  Therefore, some of the comments below do not apply   for this modified version.  However, it is the intention to keep   differences to Doug Lea's original version minimal, hence the   comments were mostly left unchanged.   -----------------------------------------------------------------------    This is a version (aka dlmalloc) of malloc/free/realloc written by   Doug Lea and released to the public domain, as explained at   http://creativecommons.org/licenses/publicdomain.  Send questions,   comments, complaints, performance data, etc to dl@cs.oswego.edu  * Version pre-2.8.4 Wed Mar 29 19:46:29 2006    (dl at gee)     Note: There may be an updated version of this malloc obtainable at            ftp://gee.cs.oswego.edu/pub/misc/malloc.c          Check before installing!  * Quickstart    This library is all in one file to simplify the most common usage:   ftp it, compile it (-O3), and link it into another program. All of   the compile-time options default to reasonable values for use on   most platforms.  You might later want to step through various   compile-time and dynamic tuning options.    For convenience, an include file for code using this malloc is at:      ftp://gee.cs.oswego.edu/pub/misc/malloc-2.8.3.h   You don't really need this .h file unless you call functions not   defined in your system include files.  The .h file contains only the   excerpts from this file needed for using this malloc on ANSI C/C++   systems, so long as you haven't changed compile-time options about   naming and tuning parameters.  If you do, then you can create your   own malloc.h that does include all settings by cutting at the point   indicated below. Note that you may already by default be using a C   library containing a malloc that is based on some version of this   malloc (for example in linux). You might still want to use the one   in this file to customize settings or to avoid overheads associated   with library versions.  * Vital statistics:    Supported pointer/size_t representation:       4 or 8 bytes        size_t MUST be an unsigned type of the same width as        pointers. (If you are using an ancient system that declares        size_t as a signed type, or need it to be a different width        than pointers, you can use a previous release of this malloc        (e.g. 2.7.2) supporting these.)    Alignment:                                     8 bytes (default)        This suffices for nearly all current machines and C compilers.        However, you can define MALLOC_ALIGNMENT to be wider than this        if necessary (up to 128bytes), at the expense of using more space.    Minimum overhead per allocated chunk:   4 or  8 bytes (if 4byte sizes)                                           8 or 16 bytes (if 8byte sizes)        Each malloced chunk has a hidden word of overhead holding size        and status information, and additional cross-check word        if FOOTERS is defined.    Minimum allocated size: 4-byte ptrs:  16 bytes    (including overhead)                           8-byte ptrs:  32 bytes    (including overhead)         Even a request for zero bytes (i.e., malloc(0)) returns a        pointer to something of the minimum allocatable size.        The maximum overhead wastage (i.e., number of extra bytes        allocated than were requested in malloc) is less than or equal        to the minimum size, except for requests>= mmap_threshold that        are serviced via mmap(), where the worst case wastage is about        32 bytes plus the remainder from a system page (the minimal        mmap unit); typically 4096 or 8192 bytes.    Security: static-safe; optionally more or less        The "security" of malloc refers to the ability of malicious        code to accentuate the effects of errors (for example, freeing        space that is not currently malloc'ed or overwriting past the        ends of chunks) in code that calls malloc.  This malloc        guarantees not to modify any memory locations below the base of        heap, i.e., static variables, even in the presence of usage        errors.  The routines additionally detect most improper frees        and reallocs.  All this holds as long as the static bookkeeping        for malloc itself is not corrupted by some other means.  This        is only one aspect of security -- these checks do not, and        cannot, detect all possible programming errors.         If FOOTERS is defined nonzero, then each allocated chunk        carries an additional check word to verify that it was malloced        from its space.  These check words are the same within each        execution of a program using malloc, but differ across        executions, so externally crafted fake chunks cannot be        freed. This improves security by rejecting frees/reallocs that        could corrupt heap memory, in addition to the checks preventing        writes to statics that are always on.  This may further improve        security at the expense of time and space overhead.  (Note that        FOOTERS may also be worth using with MSPACES.)         By default detected errors cause the program to abort (calling        "abort()"). You can override this to instead proceed past        errors by defining PROCEED_ON_ERROR.  In this case, a bad free        has no effect, and a malloc that encounters a bad address        caused by user overwrites will ignore the bad address by        dropping pointers and indices to all known memory. This may        be appropriate for programs that should continue if at all        possible in the face of programming errors, although they may        run out of memory because dropped memory is never reclaimed.         If you don't like either of these options, you can define        CORRUPTION_ERROR_ACTION and USAGE_ERROR_ACTION to do anything        else. And if if you are sure that your program using malloc has        no errors or vulnerabilities, you can define INSECURE to 1,        which might (or might not) provide a small performance improvement.    Thread-safety: NOT thread-safe unless USE_LOCKS defined        When USE_LOCKS is defined, each public call to malloc, free,        etc is surrounded with either a pthread mutex or a win32        spinlock (depending on WIN32). This is not especially fast, and        can be a major bottleneck.  It is designed only to provide        minimal protection in concurrent environments, and to provide a        basis for extensions.  If you are using malloc in a concurrent        program, consider instead using nedmalloc        (http://www.nedprod.com/programs/portable/nedmalloc/) or        ptmalloc (See http://www.malloc.de), which are derived        from versions of this malloc.    System requirements: Any combination of MORECORE and/or MMAP/MUNMAP        This malloc can use unix sbrk or any emulation (invoked using        the CALL_MORECORE macro) and/or mmap/munmap or any emulation        (invoked using CALL_MMAP/CALL_MUNMAP) to get and release system        memory.  On most unix systems, it tends to work best if both        MORECORE and MMAP are enabled.  On Win32, it uses emulations        based on VirtualAlloc. It also uses common C library functions        like memset.    Compliance: I believe it is compliant with the Single Unix Specification        (See http://www.unix.org). Also SVID/XPG, ANSI C, and probably        others as well.  * Overview of algorithms    This is not the fastest, most space-conserving, most portable, or   most tunable malloc ever written. However it is among the fastest   while also being among the most space-conserving, portable and   tunable.  Consistent balance across these factors results in a good   general-purpose allocator for malloc-intensive programs.    In most ways, this malloc is a best-fit allocator. Generally, it   chooses the best-fitting existing chunk for a request, with ties   broken in approximately least-recently-used order. (This strategy   normally maintains low fragmentation.) However, for requests less   than 256bytes, it deviates from best-fit when there is not an   exactly fitting available chunk by preferring to use space adjacent   to that used for the previous small request, as well as by breaking   ties in approximately most-recently-used order. (These enhance   locality of series of small allocations.)  And for very large requests   (>= 256Kb by default), it relies on system memory mapping   facilities, if supported.  (This helps avoid carrying around and   possibly fragmenting memory used only for large chunks.)    All operations (except malloc_stats and mallinfo) have execution   times that are bounded by a constant factor of the number of bits in   a size_t, not counting any clearing in calloc or copying in realloc,   or actions surrounding MORECORE and MMAP that have times   proportional to the number of non-contiguous regions returned by   system allocation routines, which is often just 1. In real-time   applications, you can optionally suppress segment traversals using   NO_SEGMENT_TRAVERSAL, which assures bounded execution even when   system allocators return non-contiguous spaces, at the typical   expense of carrying around more memory and increased fragmentation.    The implementation is not very modular and seriously overuses   macros. Perhaps someday all C compilers will do as good a job   inlining modular code as can now be done by brute-force expansion,   but now, enough of them seem not to.    Some compilers issue a lot of warnings about code that is   dead/unreachable only on some platforms, and also about intentional   uses of negation on unsigned types. All known cases of each can be   ignored.    For a longer but out of date high-level description, see      http://gee.cs.oswego.edu/dl/html/malloc.html  * MSPACES   If MSPACES is defined, then in addition to malloc, free, etc.,   this file also defines mspace_malloc, mspace_free, etc. These   are versions of malloc routines that take an "mspace" argument   obtained using create_mspace, to control all internal bookkeeping.   If ONLY_MSPACES is defined, only these versions are compiled.   So if you would like to use this allocator for only some allocations,   and your system malloc for others, you can compile with   ONLY_MSPACES and then do something like...     static mspace mymspace = create_mspace(0,0); // for example     #define mymalloc(bytes)  mspace_malloc(mymspace, bytes)    (Note: If you only need one instance of an mspace, you can instead   use "USE_DL_PREFIX" to relabel the global malloc.)    You can similarly create thread-local allocators by storing   mspaces as thread-locals. For example:     static __thread mspace tlms = 0;     void*  tlmalloc(size_t bytes) {       if (tlms == 0) tlms = create_mspace(0, 0);       return mspace_malloc(tlms, bytes);     }     void  tlfree(void* mem) { mspace_free(tlms, mem); }    Unless FOOTERS is defined, each mspace is completely independent.   You cannot allocate from one and free to another (although   conformance is only weakly checked, so usage errors are not always   caught). If FOOTERS is defined, then each chunk carries around a tag   indicating its originating mspace, and frees are directed to their   originating spaces.   -------------------------  Compile-time options ---------------------------  Be careful in setting #define values for numerical constants of type size_t. On some systems, literal values are not automatically extended to size_t precision unless they are explicitly casted. You can also use the symbolic values MAX_SIZE_T, SIZE_T_ONE, etc below.  WIN32                    default: defined if _WIN32 defined   Defining WIN32 sets up defaults for MS environment and compilers.   Otherwise defaults are for unix.  MALLOC_ALIGNMENT         default: (size_t)8   Controls the minimum alignment for malloc'ed chunks.  It must be a   power of two and at least 8, even on machines for which smaller   alignments would suffice. It may be defined as larger than this   though. Note however that code and data structures are optimized for   the case of 8-byte alignment.  MSPACES                  default: 0 (false)   If true, compile in support for independent allocation spaces.   This is only supported if HAVE_MMAP is true.  ONLY_MSPACES             default: 0 (false)   If true, only compile in mspace versions, not regular versions.  USE_LOCKS                default: 0 (false)   Causes each call to each public routine to be surrounded with   pthread or WIN32 mutex lock/unlock. (If set true, this can be   overridden on a per-mspace basis for mspace versions.) If set to a   non-zero value other than 1, locks are used, but their   implementation is left out, so lock functions must be supplied manually.  USE_SPIN_LOCKS           default: 1 iff USE_LOCKS and on x86 using gcc or MSC   If true, uses custom spin locks for locking. This is currently   supported only for x86 platforms using gcc or recent MS compilers.   Otherwise, posix locks or win32 critical sections are used.  FOOTERS                  default: 0   If true, provide extra checking and dispatching by placing   information in the footers of allocated chunks. This adds   space and time overhead.  INSECURE                 default: 0   If true, omit checks for usage errors and heap space overwrites.  USE_DL_PREFIX            default: NOT defined   Causes compiler to prefix all public routines with the string 'dl'.   This can be useful when you only want to use this malloc in one part   of a program, using your regular system malloc elsewhere.  ABORT                    default: defined as abort()   Defines how to abort on failed checks.  On most systems, a failed   check cannot die with an "assert" or even print an informative   message, because the underlying print routines in turn call malloc,   which will fail again.  Generally, the best policy is to simply call   abort(). It's not very useful to do more than this because many   errors due to overwriting will show up as address faults (null, odd   addresses etc) rather than malloc-triggered checks, so will also   abort.  Also, most compilers know that abort() does not return, so   can better optimize code conditionally calling it.  PROCEED_ON_ERROR           default: defined as 0 (false)   Controls whether detected bad addresses cause them to bypassed   rather than aborting. If set, detected bad arguments to free and   realloc are ignored. And all bookkeeping information is zeroed out   upon a detected overwrite of freed heap space, thus losing the   ability to ever return it from malloc again, but enabling the   application to proceed. If PROCEED_ON_ERROR is defined, the   static variable malloc_corruption_error_count is compiled in   and can be examined to see if errors have occurred. This option   generates slower code than the default abort policy.  DEBUG                    default: NOT defined   The DEBUG setting is mainly intended for people trying to modify   this code or diagnose problems when porting to new platforms.   However, it may also be able to better isolate user errors than just   using runtime checks.  The assertions in the check routines spell   out in more detail the assumptions and invariants underlying the   algorithms.  The checking is fairly extensive, and will slow down   execution noticeably. Calling malloc_stats or mallinfo with DEBUG   set will attempt to check every non-mmapped allocated and free chunk   in the course of computing the summaries.  ABORT_ON_ASSERT_FAILURE   default: defined as 1 (true)   Debugging assertion failures can be nearly impossible if your   version of the assert macro causes malloc to be called, which will   lead to a cascade of further failures, blowing the runtime stack.   ABORT_ON_ASSERT_FAILURE cause assertions failures to call abort(),   which will usually make debugging easier.  MALLOC_FAILURE_ACTION     default: sets errno to ENOMEM, or no-op on win32   The action to take before "return 0" when malloc fails to be able to   return memory because there is none available.  HAVE_MORECORE             default: 1 (true) unless win32 or ONLY_MSPACES   True if this system supports sbrk or an emulation of it.  MORECORE                  default: sbrk   The name of the sbrk-style system routine to call to obtain more   memory.  See below for guidance on writing custom MORECORE   functions. The type of the argument to sbrk/MORECORE varies across   systems.  It cannot be size_t, because it supports negative   arguments, so it is normally the signed type of the same width as   size_t (sometimes declared as "intptr_t").  It doesn't much matter   though. Internally, we only call it with arguments less than half   the max value of a size_t, which should work across all reasonable   possibilities, although sometimes generating compiler warnings.  See   near the end of this file for guidelines for creating a custom   version of MORECORE.  MORECORE_CONTIGUOUS       default: 1 (true) if HAVE_MORECORE   If true, take advantage of fact that consecutive calls to MORECORE   with positive arguments always return contiguous increasing   addresses.  This is true of unix sbrk. It does not hurt too much to   set it true anyway, since malloc copes with non-contiguities.   Setting it false when definitely non-contiguous saves time   and possibly wasted space it would take to discover this though.  MORECORE_CANNOT_TRIM      default: NOT defined   True if MORECORE cannot release space back to the system when given   negative arguments. This is generally necessary only if you are   using a hand-crafted MORECORE function that cannot handle negative   arguments.  NO_SEGMENT_TRAVERSAL       default: 0   If non-zero, suppresses traversals of memory segments   returned by either MORECORE or CALL_MMAP. This disables   merging of segments that are contiguous, and selectively   releasing them to the OS if unused, but bounds execution times.  HAVE_MMAP                 default: 1 (true)   True if this system supports mmap or an emulation of it.  If so, and   HAVE_MORECORE is not true, MMAP is used for all system   allocation. If set and HAVE_MORECORE is true as well, MMAP is   primarily used to directly allocate very large blocks. It is also   used as a backup strategy in cases where MORECORE fails to provide   space from system. Note: A single call to MUNMAP is assumed to be   able to unmap memory that may have be allocated using multiple calls   to MMAP, so long as they are adjacent.  HAVE_MREMAP               default: 1 on linux, else 0   If true realloc() uses mremap() to re-allocate large blocks and   extend or shrink allocation spaces.  MMAP_CLEARS               default: 1 except on WINCE.   True if mmap clears memory so calloc doesn't need to. This is true   for standard unix mmap using /dev/zero and on WIN32 except for WINCE.  USE_BUILTIN_FFS            default: 0 (i.e., not used)   Causes malloc to use the builtin ffs() function to compute indices.   Some compilers may recognize and intrinsify ffs to be faster than the   supplied C version. Also, the case of x86 using gcc is special-cased   to an asm instruction, so is already as fast as it can be, and so   this setting has no effect. Similarly for Win32 under recent MS compilers.   (On most x86s, the asm version is only slightly faster than the C version.)  malloc_getpagesize         default: derive from system includes, or 4096.   The system page size. To the extent possible, this malloc manages   memory from the system in page-size units.  This may be (and   usually is) a function rather than a constant. This is ignored   if WIN32, where page size is determined using getSystemInfo during   initialization.  USE_DEV_RANDOM             default: 0 (i.e., not used)   Causes malloc to use /dev/random to initialize secure magic seed for   stamping footers. Otherwise, the current time is used.  NO_MALLINFO                default: 0   If defined, don't compile "mallinfo". This can be a simple way   of dealing with mismatches between system declarations and   those in this file.  MALLINFO_FIELD_TYPE        default: size_t   The type of the fields in the mallinfo struct. This was originally   defined as "int" in SVID etc, but is more usefully defined as   size_t. The value is used only if  HAVE_USR_INCLUDE_MALLOC_H is not set  REALLOC_ZERO_BYTES_FREES    default: not defined   This should be set if a call to realloc with zero bytes should   be the same as a call to free. Some people think it should. Otherwise,   since this malloc returns a unique pointer for malloc(0), so does   realloc(p, 0).  LACKS_UNISTD_H, LACKS_FCNTL_H, LACKS_SYS_PARAM_H, LACKS_SYS_MMAN_H LACKS_STRINGS_H, LACKS_STRING_H, LACKS_SYS_TYPES_H,  LACKS_ERRNO_H LACKS_STDLIB_H                default: NOT defined unless on WIN32   Define these if your system does not have these header files.   You might need to manually insert some of the declarations they provide.  DEFAULT_GRANULARITY        default: page size if MORECORE_CONTIGUOUS,                                 system_info.dwAllocationGranularity in WIN32,                                 otherwise 64K.       Also settable using mallopt(M_GRANULARITY, x)   The unit for allocating and deallocating memory from the system.  On   most systems with contiguous MORECORE, there is no reason to   make this more than a page. However, systems with MMAP tend to   either require or encourage larger granularities.  You can increase   this value to prevent system allocation functions to be called so   often, especially if they are slow.  The value must be at least one   page and must be a power of two.  Setting to 0 causes initialization   to either page size or win32 region size.  (Note: In previous   versions of malloc, the equivalent of this option was called   "TOP_PAD")  DEFAULT_TRIM_THRESHOLD    default: 2MB       Also settable using mallopt(M_TRIM_THRESHOLD, x)   The maximum amount of unused top-most memory to keep before   releasing via malloc_trim in free().  Automatic trimming is mainly   useful in long-lived programs using contiguous MORECORE.  Because   trimming via sbrk can be slow on some systems, and can sometimes be   wasteful (in cases where programs immediately afterward allocate   more large chunks) the value should be high enough so that your   overall system performance would improve by releasing this much   memory.  As a rough guide, you might set to a value close to the   average size of a process (program) running on your system.   Releasing this much memory would allow such a process to run in   memory.  Generally, it is worth tuning trim thresholds when a   program undergoes phases where several large chunks are allocated   and released in ways that can reuse each other's storage, perhaps   mixed with phases where there are no such chunks at all. The trim   value must be greater than page size to have any useful effect.  To   disable trimming completely, you can set to MAX_SIZE_T. Note that the trick   some people use of mallocing a huge space and then freeing it at   program startup, in an attempt to reserve system memory, doesn't   have the intended effect under automatic trimming, since that memory   will immediately be returned to the system.  DEFAULT_MMAP_THRESHOLD       default: 256K       Also settable using mallopt(M_MMAP_THRESHOLD, x)   The request size threshold for using MMAP to directly service a   request. Requests of at least this size that cannot be allocated   using already-existing space will be serviced via mmap.  (If enough   normal freed space already exists it is used instead.)  Using mmap   segregates relatively large chunks of memory so that they can be   individually obtained and released from the host system. A request   serviced through mmap is never reused by any other request (at least   not directly; the system may just so happen to remap successive   requests to the same locations).  Segregating space in this way has   the benefits that: Mmapped space can always be individually released   back to the system, which helps keep the system level memory demands   of a long-lived program low.  Also, mapped memory doesn't become   `locked' between other chunks, as can happen with normally allocated   chunks, which means that even trimming via malloc_trim would not   release them.  However, it has the disadvantage that the space   cannot be reclaimed, consolidated, and then used to service later   requests, as happens with normal chunks.  The advantages of mmap   nearly always outweigh disadvantages for "large" chunks, but the   value of "large" may vary across systems.  The default is an   empirically derived value that works well in most systems. You can   disable mmap by setting to MAX_SIZE_T.  MAX_RELEASE_CHECK_RATE   default: 255 unless not HAVE_MMAP   The number of consolidated frees between checks to release   unused segments when freeing. When using non-contiguous segments,   especially with multiple mspaces, checking only for topmost space   doesn't always suffice to trigger trimming. To compensate for this,   free() will, with a period of MAX_RELEASE_CHECK_RATE (or the   current number of segments, if greater) try to release unused   segments to the OS when freeing chunks that result in   consolidation. The best value for this parameter is a compromise   between slowing down frees with relatively costly checks that   rarely trigger versus holding on to unused memory. To effectively   disable, set to MAX_SIZE_T. This may lead to a very slight speed   improvement at the expense of carrying around more memory. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|WIN32
end_ifndef
begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef
begin_define
DECL|macro|WIN32
define|#
directive|define
name|WIN32
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* _WIN32 */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* WIN32 */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|WIN32
end_ifdef
begin_define
DECL|macro|WIN32_LEAN_AND_MEAN
define|#
directive|define
name|WIN32_LEAN_AND_MEAN
end_define
begin_include
include|#
directive|include
file|<windows.h>
end_include
begin_define
DECL|macro|HAVE_MMAP
define|#
directive|define
name|HAVE_MMAP
value|1
end_define
begin_define
DECL|macro|HAVE_MORECORE
define|#
directive|define
name|HAVE_MORECORE
value|0
end_define
begin_define
DECL|macro|LACKS_UNISTD_H
define|#
directive|define
name|LACKS_UNISTD_H
end_define
begin_define
DECL|macro|LACKS_SYS_PARAM_H
define|#
directive|define
name|LACKS_SYS_PARAM_H
end_define
begin_define
DECL|macro|LACKS_SYS_MMAN_H
define|#
directive|define
name|LACKS_SYS_MMAN_H
end_define
begin_define
DECL|macro|LACKS_STRING_H
define|#
directive|define
name|LACKS_STRING_H
end_define
begin_define
DECL|macro|LACKS_STRINGS_H
define|#
directive|define
name|LACKS_STRINGS_H
end_define
begin_define
DECL|macro|LACKS_SYS_TYPES_H
define|#
directive|define
name|LACKS_SYS_TYPES_H
end_define
begin_define
DECL|macro|LACKS_ERRNO_H
define|#
directive|define
name|LACKS_ERRNO_H
end_define
begin_define
DECL|macro|MALLOC_FAILURE_ACTION
define|#
directive|define
name|MALLOC_FAILURE_ACTION
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32_WCE
end_ifdef
begin_comment
comment|/* WINCE reportedly does not clear */
end_comment
begin_define
DECL|macro|MMAP_CLEARS
define|#
directive|define
name|MMAP_CLEARS
value|0
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|MMAP_CLEARS
define|#
directive|define
name|MMAP_CLEARS
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* _WIN32_WCE */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* WIN32 */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|DARWIN
argument_list|)
operator|||
name|defined
argument_list|(
name|_DARWIN
argument_list|)
end_if
begin_comment
comment|/* Mac OSX docs advise not to use sbrk; it seems better to use mmap */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_MORECORE
end_ifndef
begin_define
DECL|macro|HAVE_MORECORE
define|#
directive|define
name|HAVE_MORECORE
value|0
end_define
begin_define
DECL|macro|HAVE_MMAP
define|#
directive|define
name|HAVE_MMAP
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HAVE_MORECORE */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* DARWIN */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|LACKS_SYS_TYPES_H
end_ifndef
begin_include
include|#
directive|include
file|<sys/types.h>
end_include
begin_comment
comment|/* For size_t */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* LACKS_SYS_TYPES_H */
end_comment
begin_comment
comment|/* The maximum possible size_t value has all bits set */
end_comment
begin_define
DECL|macro|MAX_SIZE_T
define|#
directive|define
name|MAX_SIZE_T
value|(~(size_t)0)
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|ONLY_MSPACES
end_ifndef
begin_define
DECL|macro|ONLY_MSPACES
define|#
directive|define
name|ONLY_MSPACES
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* ONLY_MSPACES */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|MSPACES
end_ifndef
begin_if
if|#
directive|if
name|ONLY_MSPACES
end_if
begin_define
DECL|macro|MSPACES
define|#
directive|define
name|MSPACES
value|1
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* ONLY_MSPACES */
end_comment
begin_define
DECL|macro|MSPACES
define|#
directive|define
name|MSPACES
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* ONLY_MSPACES */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* MSPACES */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|MALLOC_ALIGNMENT
end_ifndef
begin_define
DECL|macro|MALLOC_ALIGNMENT
define|#
directive|define
name|MALLOC_ALIGNMENT
value|((size_t)8U)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* MALLOC_ALIGNMENT */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|FOOTERS
end_ifndef
begin_define
DECL|macro|FOOTERS
define|#
directive|define
name|FOOTERS
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FOOTERS */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|ABORT
end_ifndef
begin_define
DECL|macro|ABORT
define|#
directive|define
name|ABORT
value|abort()
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* ABORT */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|ABORT_ON_ASSERT_FAILURE
end_ifndef
begin_define
DECL|macro|ABORT_ON_ASSERT_FAILURE
define|#
directive|define
name|ABORT_ON_ASSERT_FAILURE
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* ABORT_ON_ASSERT_FAILURE */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|PROCEED_ON_ERROR
end_ifndef
begin_define
DECL|macro|PROCEED_ON_ERROR
define|#
directive|define
name|PROCEED_ON_ERROR
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PROCEED_ON_ERROR */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|USE_LOCKS
end_ifndef
begin_define
DECL|macro|USE_LOCKS
define|#
directive|define
name|USE_LOCKS
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* USE_LOCKS */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|USE_SPIN_LOCKS
end_ifndef
begin_if
if|#
directive|if
name|USE_LOCKS
operator|&&
operator|(
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__x86_64__
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|_MSC_VER
operator|>=
literal|1310
operator|)
end_if
begin_define
DECL|macro|USE_SPIN_LOCKS
define|#
directive|define
name|USE_SPIN_LOCKS
value|1
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|USE_SPIN_LOCKS
define|#
directive|define
name|USE_SPIN_LOCKS
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* USE_LOCKS&& ... */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* USE_SPIN_LOCKS */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|INSECURE
end_ifndef
begin_define
DECL|macro|INSECURE
define|#
directive|define
name|INSECURE
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* INSECURE */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_MMAP
end_ifndef
begin_define
DECL|macro|HAVE_MMAP
define|#
directive|define
name|HAVE_MMAP
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HAVE_MMAP */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|MMAP_CLEARS
end_ifndef
begin_define
DECL|macro|MMAP_CLEARS
define|#
directive|define
name|MMAP_CLEARS
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* MMAP_CLEARS */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_MREMAP
end_ifndef
begin_ifdef
ifdef|#
directive|ifdef
name|linux
end_ifdef
begin_define
DECL|macro|HAVE_MREMAP
define|#
directive|define
name|HAVE_MREMAP
value|1
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* linux */
end_comment
begin_define
DECL|macro|HAVE_MREMAP
define|#
directive|define
name|HAVE_MREMAP
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* linux */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HAVE_MREMAP */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|MALLOC_FAILURE_ACTION
end_ifndef
begin_define
DECL|macro|MALLOC_FAILURE_ACTION
define|#
directive|define
name|MALLOC_FAILURE_ACTION
value|errno = ENOMEM;
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* MALLOC_FAILURE_ACTION */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_MORECORE
end_ifndef
begin_if
if|#
directive|if
name|ONLY_MSPACES
end_if
begin_define
DECL|macro|HAVE_MORECORE
define|#
directive|define
name|HAVE_MORECORE
value|0
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* ONLY_MSPACES */
end_comment
begin_define
DECL|macro|HAVE_MORECORE
define|#
directive|define
name|HAVE_MORECORE
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* ONLY_MSPACES */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HAVE_MORECORE */
end_comment
begin_if
if|#
directive|if
operator|!
name|HAVE_MORECORE
end_if
begin_define
DECL|macro|MORECORE_CONTIGUOUS
define|#
directive|define
name|MORECORE_CONTIGUOUS
value|0
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !HAVE_MORECORE */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|MORECORE
end_ifndef
begin_define
DECL|macro|MORECORE
define|#
directive|define
name|MORECORE
value|sbrk
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* MORECORE */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|MORECORE_CONTIGUOUS
end_ifndef
begin_define
DECL|macro|MORECORE_CONTIGUOUS
define|#
directive|define
name|MORECORE_CONTIGUOUS
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* MORECORE_CONTIGUOUS */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HAVE_MORECORE */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_GRANULARITY
end_ifndef
begin_if
if|#
directive|if
name|MORECORE_CONTIGUOUS
end_if
begin_define
DECL|macro|DEFAULT_GRANULARITY
define|#
directive|define
name|DEFAULT_GRANULARITY
value|(0)
end_define
begin_comment
DECL|macro|DEFAULT_GRANULARITY
comment|/* 0 means to compute in init_mparams */
end_comment
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* MORECORE_CONTIGUOUS */
end_comment
begin_define
DECL|macro|DEFAULT_GRANULARITY
define|#
directive|define
name|DEFAULT_GRANULARITY
value|((size_t)64U * (size_t)1024U)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* MORECORE_CONTIGUOUS */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* DEFAULT_GRANULARITY */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_TRIM_THRESHOLD
end_ifndef
begin_ifndef
ifndef|#
directive|ifndef
name|MORECORE_CANNOT_TRIM
end_ifndef
begin_define
DECL|macro|DEFAULT_TRIM_THRESHOLD
define|#
directive|define
name|DEFAULT_TRIM_THRESHOLD
value|((size_t)2U * (size_t)1024U * (size_t)1024U)
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* MORECORE_CANNOT_TRIM */
end_comment
begin_define
DECL|macro|DEFAULT_TRIM_THRESHOLD
define|#
directive|define
name|DEFAULT_TRIM_THRESHOLD
value|MAX_SIZE_T
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* MORECORE_CANNOT_TRIM */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* DEFAULT_TRIM_THRESHOLD */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_MMAP_THRESHOLD
end_ifndef
begin_if
if|#
directive|if
name|HAVE_MMAP
end_if
begin_define
DECL|macro|DEFAULT_MMAP_THRESHOLD
define|#
directive|define
name|DEFAULT_MMAP_THRESHOLD
value|((size_t)256U * (size_t)1024U)
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* HAVE_MMAP */
end_comment
begin_define
DECL|macro|DEFAULT_MMAP_THRESHOLD
define|#
directive|define
name|DEFAULT_MMAP_THRESHOLD
value|MAX_SIZE_T
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HAVE_MMAP */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* DEFAULT_MMAP_THRESHOLD */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|MAX_RELEASE_CHECK_RATE
end_ifndef
begin_if
if|#
directive|if
name|HAVE_MMAP
end_if
begin_define
DECL|macro|MAX_RELEASE_CHECK_RATE
define|#
directive|define
name|MAX_RELEASE_CHECK_RATE
value|255
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|MAX_RELEASE_CHECK_RATE
define|#
directive|define
name|MAX_RELEASE_CHECK_RATE
value|MAX_SIZE_T
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HAVE_MMAP */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* MAX_RELEASE_CHECK_RATE */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|USE_BUILTIN_FFS
end_ifndef
begin_define
DECL|macro|USE_BUILTIN_FFS
define|#
directive|define
name|USE_BUILTIN_FFS
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* USE_BUILTIN_FFS */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|USE_DEV_RANDOM
end_ifndef
begin_define
DECL|macro|USE_DEV_RANDOM
define|#
directive|define
name|USE_DEV_RANDOM
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* USE_DEV_RANDOM */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|NO_MALLINFO
end_ifndef
begin_define
DECL|macro|NO_MALLINFO
define|#
directive|define
name|NO_MALLINFO
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* NO_MALLINFO */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|MALLINFO_FIELD_TYPE
end_ifndef
begin_define
DECL|macro|MALLINFO_FIELD_TYPE
define|#
directive|define
name|MALLINFO_FIELD_TYPE
value|size_t
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* MALLINFO_FIELD_TYPE */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|NO_SEGMENT_TRAVERSAL
end_ifndef
begin_define
DECL|macro|NO_SEGMENT_TRAVERSAL
define|#
directive|define
name|NO_SEGMENT_TRAVERSAL
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* NO_SEGMENT_TRAVERSAL */
end_comment
begin_comment
comment|/*   mallopt tuning options.  SVID/XPG defines four standard parameter   numbers for mallopt, normally defined in malloc.h.  None of these   are used in this malloc, so setting them has no effect. But this   malloc does support the following options. */
end_comment
begin_define
DECL|macro|M_TRIM_THRESHOLD
define|#
directive|define
name|M_TRIM_THRESHOLD
value|(-1)
end_define
begin_define
DECL|macro|M_GRANULARITY
define|#
directive|define
name|M_GRANULARITY
value|(-2)
end_define
begin_define
DECL|macro|M_MMAP_THRESHOLD
define|#
directive|define
name|M_MMAP_THRESHOLD
value|(-3)
end_define
begin_comment
comment|/* ------------------------ Mallinfo declarations ------------------------ */
end_comment
begin_if
if|#
directive|if
operator|!
name|NO_MALLINFO
end_if
begin_comment
comment|/*   This version of malloc supports the standard SVID/XPG mallinfo   routine that returns a struct containing usage properties and   statistics. It should work on any system that has a   /usr/include/malloc.h defining struct mallinfo.  The main   declaration needed is the mallinfo struct that is returned (by-copy)   by mallinfo().  The malloinfo struct contains a bunch of fields that   are not even meaningful in this version of malloc.  These fields are   are instead filled by mallinfo() with other numbers that might be of   interest.    HAVE_USR_INCLUDE_MALLOC_H should be set if you have a   /usr/include/malloc.h file that includes a declaration of struct   mallinfo.  If so, it is included; else a compliant version is   declared below.  These must be precisely the same for mallinfo() to   work.  The original SVID version of this struct, defined on most   systems with mallinfo, declares all fields as ints. But some others   define as unsigned long. If your system defines the fields using a   type of different width than listed here, you MUST #include your   system version and #define HAVE_USR_INCLUDE_MALLOC_H. */
end_comment
begin_comment
comment|/* #define HAVE_USR_INCLUDE_MALLOC_H */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_USR_INCLUDE_MALLOC_H
end_ifdef
begin_include
include|#
directive|include
file|"/usr/include/malloc.h"
end_include
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* HAVE_USR_INCLUDE_MALLOC_H */
end_comment
begin_struct
DECL|struct|mallinfo
struct|struct
name|mallinfo
block|{
DECL|member|arena
name|MALLINFO_FIELD_TYPE
name|arena
decl_stmt|;
comment|/* non-mmapped space allocated from system */
DECL|member|ordblks
name|MALLINFO_FIELD_TYPE
name|ordblks
decl_stmt|;
comment|/* number of free chunks */
DECL|member|smblks
name|MALLINFO_FIELD_TYPE
name|smblks
decl_stmt|;
comment|/* always 0 */
DECL|member|hblks
name|MALLINFO_FIELD_TYPE
name|hblks
decl_stmt|;
comment|/* always 0 */
DECL|member|hblkhd
name|MALLINFO_FIELD_TYPE
name|hblkhd
decl_stmt|;
comment|/* space in mmapped regions */
DECL|member|usmblks
name|MALLINFO_FIELD_TYPE
name|usmblks
decl_stmt|;
comment|/* maximum total allocated space */
DECL|member|fsmblks
name|MALLINFO_FIELD_TYPE
name|fsmblks
decl_stmt|;
comment|/* always 0 */
DECL|member|uordblks
name|MALLINFO_FIELD_TYPE
name|uordblks
decl_stmt|;
comment|/* total allocated space */
DECL|member|fordblks
name|MALLINFO_FIELD_TYPE
name|fordblks
decl_stmt|;
comment|/* total free space */
DECL|member|keepcost
name|MALLINFO_FIELD_TYPE
name|keepcost
decl_stmt|;
comment|/* releasable (via malloc_trim) space */
block|}
struct|;
end_struct
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HAVE_USR_INCLUDE_MALLOC_H */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* NO_MALLINFO */
end_comment
begin_comment
comment|/*   Try to persuade compilers to inline. The most critical functions for   inlining are defined as macros, so these aren't used for them. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|FORCEINLINE
end_ifndef
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
end_if
begin_define
DECL|macro|FORCEINLINE
define|#
directive|define
name|FORCEINLINE
value|__inline __attribute__ ((always_inline))
end_define
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_elif
begin_define
DECL|macro|FORCEINLINE
define|#
directive|define
name|FORCEINLINE
value|__forceinline
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|NOINLINE
end_ifndef
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
end_if
begin_define
DECL|macro|NOINLINE
define|#
directive|define
name|NOINLINE
value|__attribute__ ((noinline))
end_define
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_elif
begin_define
DECL|macro|NOINLINE
define|#
directive|define
name|NOINLINE
value|__declspec(noinline)
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|NOINLINE
define|#
directive|define
name|NOINLINE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef
begin_extern
extern|extern
literal|"C"
block|{
ifndef|#
directive|ifndef
name|FORCEINLINE
DECL|macro|FORCEINLINE
define|#
directive|define
name|FORCEINLINE
value|inline
endif|#
directive|endif
endif|#
directive|endif
comment|/* __cplusplus */
ifndef|#
directive|ifndef
name|FORCEINLINE
DECL|macro|FORCEINLINE
define|#
directive|define
name|FORCEINLINE
endif|#
directive|endif
if|#
directive|if
operator|!
name|ONLY_MSPACES
comment|/* ------------------- Declarations of public routines ------------------- */
ifndef|#
directive|ifndef
name|USE_DL_PREFIX
DECL|macro|dlcalloc
define|#
directive|define
name|dlcalloc
value|calloc
DECL|macro|dlfree
define|#
directive|define
name|dlfree
value|free
DECL|macro|dlmalloc
define|#
directive|define
name|dlmalloc
value|malloc
DECL|macro|dlmemalign
define|#
directive|define
name|dlmemalign
value|memalign
DECL|macro|dlrealloc
define|#
directive|define
name|dlrealloc
value|realloc
DECL|macro|dlvalloc
define|#
directive|define
name|dlvalloc
value|valloc
DECL|macro|dlpvalloc
define|#
directive|define
name|dlpvalloc
value|pvalloc
DECL|macro|dlmallinfo
define|#
directive|define
name|dlmallinfo
value|mallinfo
DECL|macro|dlmallopt
define|#
directive|define
name|dlmallopt
value|mallopt
DECL|macro|dlmalloc_trim
define|#
directive|define
name|dlmalloc_trim
value|malloc_trim
DECL|macro|dlmalloc_stats
define|#
directive|define
name|dlmalloc_stats
value|malloc_stats
DECL|macro|dlmalloc_usable_size
define|#
directive|define
name|dlmalloc_usable_size
value|malloc_usable_size
DECL|macro|dlmalloc_footprint
define|#
directive|define
name|dlmalloc_footprint
value|malloc_footprint
DECL|macro|dlmalloc_max_footprint
define|#
directive|define
name|dlmalloc_max_footprint
value|malloc_max_footprint
DECL|macro|dlindependent_calloc
define|#
directive|define
name|dlindependent_calloc
value|independent_calloc
DECL|macro|dlindependent_comalloc
define|#
directive|define
name|dlindependent_comalloc
value|independent_comalloc
endif|#
directive|endif
comment|/* USE_DL_PREFIX */
comment|/*   malloc(size_t n)   Returns a pointer to a newly allocated chunk of at least n bytes, or   null if no space is available, in which case errno is set to ENOMEM   on ANSI C systems.    If n is zero, malloc returns a minimum-sized chunk. (The minimum   size is 16 bytes on most 32bit systems, and 32 bytes on 64bit   systems.)  Note that size_t is an unsigned type, so calls with   arguments that would be negative if signed are interpreted as   requests for huge amounts of space, which will often fail. The   maximum supported value of n differs across systems, but is in all   cases less than the maximum representable value of a size_t. */
name|void
modifier|*
name|dlmalloc
parameter_list|(
name|size_t
parameter_list|)
function_decl|;
comment|/*   free(void* p)   Releases the chunk of memory pointed to by p, that had been previously   allocated using malloc or a related routine such as realloc.   It has no effect if p is null. If p was not malloced or already   freed, free(p) will by default cause the current program to abort. */
name|void
name|dlfree
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
comment|/*   calloc(size_t n_elements, size_t element_size);   Returns a pointer to n_elements * element_size bytes, with all locations   set to zero. */
name|void
modifier|*
name|dlcalloc
parameter_list|(
name|size_t
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
comment|/*   realloc(void* p, size_t n)   Returns a pointer to a chunk of size n that contains the same data   as does chunk p up to the minimum of (n, p's size) bytes, or null   if no space is available.    The returned pointer may or may not be the same as p. The algorithm   prefers extending p in most cases when possible, otherwise it   employs the equivalent of a malloc-copy-free sequence.    If p is null, realloc is equivalent to malloc.    If space is not available, realloc returns null, errno is set (if on   ANSI) and p is NOT freed.    if n is for fewer bytes than already held by p, the newly unused   space is lopped off and freed if possible.  realloc with a size   argument of zero (re)allocates a minimum-sized chunk.    The old unix realloc convention of allowing the last-free'd chunk   to be used as an argument to realloc is not supported. */
name|void
modifier|*
name|dlrealloc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
comment|/*   memalign(size_t alignment, size_t n);   Returns a pointer to a newly allocated chunk of n bytes, aligned   in accord with the alignment argument.    The alignment argument should be a power of two. If the argument is   not a power of two, the nearest greater power is used.   8-byte alignment is guaranteed by normal malloc calls, so don't   bother calling memalign with an argument of 8 or less.    Overreliance on memalign is a sure way to fragment space. */
name|void
modifier|*
name|dlmemalign
parameter_list|(
name|size_t
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
comment|/*   valloc(size_t n);   Equivalent to memalign(pagesize, n), where pagesize is the page   size of the system. If the pagesize is unknown, 4096 is used. */
name|void
modifier|*
name|dlvalloc
parameter_list|(
name|size_t
parameter_list|)
function_decl|;
comment|/*   mallopt(int parameter_number, int parameter_value)   Sets tunable parameters The format is to provide a   (parameter-number, parameter-value) pair.  mallopt then sets the   corresponding parameter to the argument value if it can (i.e., so   long as the value is meaningful), and returns 1 if successful else   0.  SVID/XPG/ANSI defines four standard param numbers for mallopt,   normally defined in malloc.h.  None of these are use in this malloc,   so setting them has no effect. But this malloc also supports other   options in mallopt. See below for details.  Briefly, supported   parameters are as follows (listed defaults are for "typical"   configurations).    Symbol            param #  default    allowed param values   M_TRIM_THRESHOLD     -1   2*1024*1024   any   (MAX_SIZE_T disables)   M_GRANULARITY        -2     page size   any power of 2>= page size   M_MMAP_THRESHOLD     -3      256*1024   any   (or 0 if no MMAP support) */
name|int
name|dlmallopt
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/*   malloc_footprint();   Returns the number of bytes obtained from the system.  The total   number of bytes allocated by malloc, realloc etc., is less than this   value. Unlike mallinfo, this function returns only a precomputed   result, so can be called frequently to monitor memory consumption.   Even if locks are otherwise defined, this function does not use them,   so results might not be up to date. */
name|size_t
name|dlmalloc_footprint
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/*   malloc_max_footprint();   Returns the maximum number of bytes obtained from the system. This   value will be greater than current footprint if deallocated space   has been reclaimed by the system. The peak number of bytes allocated   by malloc, realloc etc., is less than this value. Unlike mallinfo,   this function returns only a precomputed result, so can be called   frequently to monitor memory consumption.  Even if locks are   otherwise defined, this function does not use them, so results might   not be up to date. */
name|size_t
name|dlmalloc_max_footprint
parameter_list|(
name|void
parameter_list|)
function_decl|;
if|#
directive|if
operator|!
name|NO_MALLINFO
comment|/*   mallinfo()   Returns (by copy) a struct containing various summary statistics:    arena:     current total non-mmapped bytes allocated from system   ordblks:   the number of free chunks   smblks:    always zero.   hblks:     current number of mmapped regions   hblkhd:    total bytes held in mmapped regions   usmblks:   the maximum total allocated space. This will be greater                 than current total if trimming has occurred.   fsmblks:   always zero   uordblks:  current total allocated space (normal or mmapped)   fordblks:  total free space   keepcost:  the maximum number of bytes that could ideally be released                back to system via malloc_trim. ("ideally" means that                it ignores page restrictions etc.)    Because these fields are ints, but internal bookkeeping may   be kept as longs, the reported values may wrap around zero and   thus be inaccurate. */
name|struct
name|mallinfo
name|dlmallinfo
parameter_list|(
name|void
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* NO_MALLINFO */
comment|/*   independent_calloc(size_t n_elements, size_t element_size, void* chunks[]);    independent_calloc is similar to calloc, but instead of returning a   single cleared space, it returns an array of pointers to n_elements   independent elements that can hold contents of size elem_size, each   of which starts out cleared, and can be independently freed,   realloc'ed etc. The elements are guaranteed to be adjacently   allocated (this is not guaranteed to occur with multiple callocs or   mallocs), which may also improve cache locality in some   applications.    The "chunks" argument is optional (i.e., may be null, which is   probably the most typical usage). If it is null, the returned array   is itself dynamically allocated and should also be freed when it is   no longer needed. Otherwise, the chunks array must be of at least   n_elements in length. It is filled in with the pointers to the   chunks.    In either case, independent_calloc returns this pointer array, or   null if the allocation failed.  If n_elements is zero and "chunks"   is null, it returns a chunk representing an array with zero elements   (which should be freed if not wanted).    Each element must be individually freed when it is no longer   needed. If you'd like to instead be able to free all at once, you   should instead use regular calloc and assign pointers into this   space to represent elements.  (In this case though, you cannot   independently free elements.)    independent_calloc simplifies and speeds up implementations of many   kinds of pools.  It may also be useful when constructing large data   structures that initially have a fixed number of fixed-sized nodes,   but the number is not known at compile time, and some of the nodes   may later need to be freed. For example:    struct Node { int item; struct Node* next; };    struct Node* build_list() {     struct Node** pool;     int n = read_number_of_nodes_needed();     if (n<= 0) return 0;     pool = (struct Node**)(independent_calloc(n, sizeof(struct Node), 0);     if (pool == 0) die();     // organize into a linked list...     struct Node* first = pool[0];     for (i = 0; i< n-1; ++i)       pool[i]->next = pool[i+1];     free(pool);     // Can now free the array (or not, if it is needed later)     return first;   } */
name|void
modifier|*
modifier|*
name|dlindependent_calloc
parameter_list|(
name|size_t
parameter_list|,
name|size_t
parameter_list|,
name|void
modifier|*
modifier|*
parameter_list|)
function_decl|;
comment|/*   independent_comalloc(size_t n_elements, size_t sizes[], void* chunks[]);    independent_comalloc allocates, all at once, a set of n_elements   chunks with sizes indicated in the "sizes" array.    It returns   an array of pointers to these elements, each of which can be   independently freed, realloc'ed etc. The elements are guaranteed to   be adjacently allocated (this is not guaranteed to occur with   multiple callocs or mallocs), which may also improve cache locality   in some applications.    The "chunks" argument is optional (i.e., may be null). If it is null   the returned array is itself dynamically allocated and should also   be freed when it is no longer needed. Otherwise, the chunks array   must be of at least n_elements in length. It is filled in with the   pointers to the chunks.    In either case, independent_comalloc returns this pointer array, or   null if the allocation failed.  If n_elements is zero and chunks is   null, it returns a chunk representing an array with zero elements   (which should be freed if not wanted).    Each element must be individually freed when it is no longer   needed. If you'd like to instead be able to free all at once, you   should instead use a single regular malloc, and assign pointers at   particular offsets in the aggregate space. (In this case though, you   cannot independently free elements.)    independent_comallac differs from independent_calloc in that each   element may have a different size, and also that it does not   automatically clear elements.    independent_comalloc can be used to speed up allocation in cases   where several structs or objects must always be allocated at the   same time.  For example:    struct Head { ... }   struct Foot { ... }    void send_message(char* msg) {     int msglen = strlen(msg);     size_t sizes[3] = { sizeof(struct Head), msglen, sizeof(struct Foot) };     void* chunks[3];     if (independent_comalloc(3, sizes, chunks) == 0)       die();     struct Head* head = (struct Head*)(chunks[0]);     char*        body = (char*)(chunks[1]);     struct Foot* foot = (struct Foot*)(chunks[2]);     // ...   }    In general though, independent_comalloc is worth using only for   larger values of n_elements. For small values, you probably won't   detect enough difference from series of malloc calls to bother.    Overuse of independent_comalloc can increase overall memory usage,   since it cannot reuse existing noncontiguous small chunks that   might be available for some of the elements. */
name|void
modifier|*
modifier|*
name|dlindependent_comalloc
parameter_list|(
name|size_t
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|void
modifier|*
modifier|*
parameter_list|)
function_decl|;
comment|/*   pvalloc(size_t n);   Equivalent to valloc(minimum-page-that-holds(n)), that is,   round up n to nearest pagesize.  */
name|void
modifier|*
name|dlpvalloc
parameter_list|(
name|size_t
parameter_list|)
function_decl|;
comment|/*   malloc_trim(size_t pad);    If possible, gives memory back to the system (via negative arguments   to sbrk) if there is unused memory at the `high' end of the malloc   pool or in unused MMAP segments. You can call this after freeing   large blocks of memory to potentially reduce the system-level memory   requirements of a program. However, it cannot guarantee to reduce   memory. Under some allocation patterns, some large free blocks of   memory will be locked between two used chunks, so they cannot be   given back to the system.    The `pad' argument to malloc_trim represents the amount of free   trailing space to leave untrimmed. If this argument is zero, only   the minimum amount of memory to maintain internal data structures   will be left. Non-zero arguments can be supplied to maintain enough   trailing space to service future expected allocations without having   to re-obtain memory from the system.    Malloc_trim returns 1 if it actually released any memory, else 0. */
name|int
name|dlmalloc_trim
parameter_list|(
name|size_t
parameter_list|)
function_decl|;
comment|/*   malloc_usable_size(void* p);    Returns the number of bytes you can actually use in   an allocated chunk, which may be more than you requested (although   often not) due to alignment and minimum size constraints.   You can use this many bytes without worrying about   overwriting other allocated objects. This is not a particularly great   programming practice. malloc_usable_size can be more useful in   debugging and assertions, for example:    p = malloc(n);   assert(malloc_usable_size(p)>= 256); */
name|size_t
name|dlmalloc_usable_size
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
comment|/*   malloc_stats();   Prints on stderr the amount of space obtained from the system (both   via sbrk and mmap), the maximum amount (which may be more than   current if malloc_trim and/or munmap got called), and the current   number of bytes allocated via malloc (or realloc, etc) but not yet   freed. Note that this is the number of bytes allocated, not the   number requested. It will be larger than the number requested   because of alignment and bookkeeping overhead. Because it includes   alignment wastage as being in use, this figure may be greater than   zero even when no user-level chunks are allocated.    The reported current and maximum system memory can be inaccurate if   a program makes other calls to system memory allocation functions   (normally sbrk) outside of malloc.    malloc_stats prints only the most commonly interesting statistics.   More information can be obtained by calling mallinfo. */
name|void
name|dlmalloc_stats
parameter_list|(
name|void
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* ONLY_MSPACES */
if|#
directive|if
name|MSPACES
comment|/*   mspace is an opaque type representing an independent   region of space that supports mspace_malloc, etc. */
DECL|typedef|mspace
typedef|typedef
name|void
modifier|*
name|mspace
typedef|;
comment|/*   create_mspace creates and returns a new independent space with the   given initial capacity, or, if 0, the default granularity size.  It   returns null if there is no system memory available to create the   space.  If argument locked is non-zero, the space uses a separate   lock to control access. The capacity of the space will grow   dynamically as needed to service mspace_malloc requests.  You can   control the sizes of incremental increases of this space by   compiling with a different DEFAULT_GRANULARITY or dynamically   setting with mallopt(M_GRANULARITY, value). */
name|mspace
name|create_mspace
parameter_list|(
name|size_t
name|capacity
parameter_list|,
name|int
name|locked
parameter_list|)
function_decl|;
comment|/*   destroy_mspace destroys the given space, and attempts to return all   of its memory back to the system, returning the total number of   bytes freed. After destruction, the results of access to all memory   used by the space become undefined. */
name|size_t
name|destroy_mspace
parameter_list|(
name|mspace
name|msp
parameter_list|)
function_decl|;
comment|/*   create_mspace_with_base uses the memory supplied as the initial base   of a new mspace. Part (less than 128*sizeof(size_t) bytes) of this   space is used for bookkeeping, so the capacity must be at least this   large. (Otherwise 0 is returned.) When this initial space is   exhausted, additional memory will be obtained from the system.   Destroying this space will deallocate all additionally allocated   space (if possible) but not the initial base. */
name|mspace
name|create_mspace_with_base
parameter_list|(
name|void
modifier|*
name|base
parameter_list|,
name|size_t
name|capacity
parameter_list|,
name|int
name|locked
parameter_list|)
function_decl|;
comment|/*   mspace_malloc behaves as malloc, but operates within   the given space. */
name|void
modifier|*
name|mspace_malloc
parameter_list|(
name|mspace
name|msp
parameter_list|,
name|size_t
name|bytes
parameter_list|)
function_decl|;
comment|/*   mspace_free behaves as free, but operates within   the given space.    If compiled with FOOTERS==1, mspace_free is not actually needed.   free may be called instead of mspace_free because freed chunks from   any space are handled by their originating spaces. */
name|void
name|mspace_free
parameter_list|(
name|mspace
name|msp
parameter_list|,
name|void
modifier|*
name|mem
parameter_list|)
function_decl|;
comment|/*   mspace_realloc behaves as realloc, but operates within   the given space.    If compiled with FOOTERS==1, mspace_realloc is not actually   needed.  realloc may be called instead of mspace_realloc because   realloced chunks from any space are handled by their originating   spaces. */
name|void
modifier|*
name|mspace_realloc
parameter_list|(
name|mspace
name|msp
parameter_list|,
name|void
modifier|*
name|mem
parameter_list|,
name|size_t
name|newsize
parameter_list|)
function_decl|;
comment|/*   mspace_calloc behaves as calloc, but operates within   the given space. */
name|void
modifier|*
name|mspace_calloc
parameter_list|(
name|mspace
name|msp
parameter_list|,
name|size_t
name|n_elements
parameter_list|,
name|size_t
name|elem_size
parameter_list|)
function_decl|;
comment|/*   mspace_memalign behaves as memalign, but operates within   the given space. */
name|void
modifier|*
name|mspace_memalign
parameter_list|(
name|mspace
name|msp
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|size_t
name|bytes
parameter_list|)
function_decl|;
comment|/*   mspace_independent_calloc behaves as independent_calloc, but   operates within the given space. */
name|void
modifier|*
modifier|*
name|mspace_independent_calloc
parameter_list|(
name|mspace
name|msp
parameter_list|,
name|size_t
name|n_elements
parameter_list|,
name|size_t
name|elem_size
parameter_list|,
name|void
modifier|*
name|chunks
index|[]
parameter_list|)
function_decl|;
comment|/*   mspace_independent_comalloc behaves as independent_comalloc, but   operates within the given space. */
name|void
modifier|*
modifier|*
name|mspace_independent_comalloc
parameter_list|(
name|mspace
name|msp
parameter_list|,
name|size_t
name|n_elements
parameter_list|,
name|size_t
name|sizes
index|[]
parameter_list|,
name|void
modifier|*
name|chunks
index|[]
parameter_list|)
function_decl|;
comment|/*   mspace_footprint() returns the number of bytes obtained from the   system for this space. */
name|size_t
name|mspace_footprint
parameter_list|(
name|mspace
name|msp
parameter_list|)
function_decl|;
comment|/*   mspace_max_footprint() returns the peak number of bytes obtained from the   system for this space. */
name|size_t
name|mspace_max_footprint
parameter_list|(
name|mspace
name|msp
parameter_list|)
function_decl|;
if|#
directive|if
operator|!
name|NO_MALLINFO
comment|/*   mspace_mallinfo behaves as mallinfo, but reports properties of   the given space. */
name|struct
name|mallinfo
name|mspace_mallinfo
parameter_list|(
name|mspace
name|msp
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* NO_MALLINFO */
comment|/*   mspace_malloc_stats behaves as malloc_stats, but reports   properties of the given space. */
name|void
name|mspace_malloc_stats
parameter_list|(
name|mspace
name|msp
parameter_list|)
function_decl|;
comment|/*   mspace_trim behaves as malloc_trim, but   operates within the given space. */
name|int
name|mspace_trim
parameter_list|(
name|mspace
name|msp
parameter_list|,
name|size_t
name|pad
parameter_list|)
function_decl|;
comment|/*   An alias for mallopt. */
name|int
name|mspace_mallopt
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* MSPACES */
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_comment
comment|/* end of extern "C" */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* __cplusplus */
end_comment
begin_comment
comment|/*   ========================================================================   To make a fully customizable malloc.h header file, cut everything   above this line, put into file malloc.h, edit to suit, and #include it   on the next line, as well as in programs that use this malloc.   ======================================================================== */
end_comment
begin_comment
comment|/* #include "malloc.h" */
end_comment
begin_comment
comment|/*------------------------------ internal #includes ---------------------- */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|WIN32
end_ifdef
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4146
name|)
end_pragma
begin_comment
comment|/* no "unsigned" warnings */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* WIN32 */
end_comment
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_comment
comment|/* for printing in malloc_stats */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|LACKS_ERRNO_H
end_ifndef
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_comment
comment|/* for MALLOC_FAILURE_ACTION */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* LACKS_ERRNO_H */
end_comment
begin_if
if|#
directive|if
name|FOOTERS
end_if
begin_include
include|#
directive|include
file|<time.h>
end_include
begin_comment
comment|/* for magic initialization */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FOOTERS */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|LACKS_STDLIB_H
end_ifndef
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_comment
comment|/* for abort() */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* LACKS_STDLIB_H */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef
begin_if
if|#
directive|if
name|ABORT_ON_ASSERT_FAILURE
end_if
begin_define
DECL|macro|assert
define|#
directive|define
name|assert
parameter_list|(
name|x
parameter_list|)
value|if(!(x)) ABORT
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* ABORT_ON_ASSERT_FAILURE */
end_comment
begin_include
include|#
directive|include
file|<assert.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* ABORT_ON_ASSERT_FAILURE */
end_comment
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* DEBUG */
end_comment
begin_define
DECL|macro|assert
define|#
directive|define
name|assert
parameter_list|(
name|x
parameter_list|)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* DEBUG */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|LACKS_STRING_H
end_ifndef
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_comment
comment|/* for memset etc */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* LACKS_STRING_H */
end_comment
begin_if
if|#
directive|if
name|USE_BUILTIN_FFS
end_if
begin_ifndef
ifndef|#
directive|ifndef
name|LACKS_STRINGS_H
end_ifndef
begin_include
include|#
directive|include
file|<strings.h>
end_include
begin_comment
comment|/* for ffs */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* LACKS_STRINGS_H */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* USE_BUILTIN_FFS */
end_comment
begin_if
if|#
directive|if
name|HAVE_MMAP
end_if
begin_ifndef
ifndef|#
directive|ifndef
name|LACKS_SYS_MMAN_H
end_ifndef
begin_include
include|#
directive|include
file|<sys/mman.h>
end_include
begin_comment
comment|/* for mmap */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* LACKS_SYS_MMAN_H */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|LACKS_FCNTL_H
end_ifndef
begin_include
include|#
directive|include
file|<fcntl.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* LACKS_FCNTL_H */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HAVE_MMAP */
end_comment
begin_if
if|#
directive|if
name|HAVE_MORECORE
end_if
begin_ifndef
ifndef|#
directive|ifndef
name|LACKS_UNISTD_H
end_ifndef
begin_include
include|#
directive|include
file|<unistd.h>
end_include
begin_comment
comment|/* for sbrk */
end_comment
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* LACKS_UNISTD_H */
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if
begin_function_decl
specifier|extern
name|void
modifier|*
name|sbrk
parameter_list|(
name|ptrdiff_t
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FreeBSD etc */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* LACKS_UNISTD_H */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HAVE_MMAP */
end_comment
begin_comment
comment|/* Declarations for locking */
end_comment
begin_if
if|#
directive|if
name|USE_LOCKS
end_if
begin_ifndef
ifndef|#
directive|ifndef
name|WIN32
end_ifndef
begin_include
include|#
directive|include
file|<pthread.h>
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__SVR4
argument_list|)
operator|&&
name|defined
argument_list|(
name|__sun
argument_list|)
end_if
begin_comment
comment|/* solaris */
end_comment
begin_include
include|#
directive|include
file|<thread.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* solaris */
end_comment
begin_else
else|#
directive|else
end_else
begin_ifndef
ifndef|#
directive|ifndef
name|_M_AMD64
end_ifndef
begin_comment
comment|/* These are already defined on AMD64 builds */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef
begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* __cplusplus */
name|LONG
name|__cdecl
name|_InterlockedCompareExchange
parameter_list|(
name|LPLONG
specifier|volatile
name|Dest
parameter_list|,
name|LONG
name|Exchange
parameter_list|,
name|LONG
name|Comp
parameter_list|)
function_decl|;
name|LONG
name|__cdecl
name|_InterlockedExchange
parameter_list|(
name|LPLONG
specifier|volatile
name|Target
parameter_list|,
name|LONG
name|Value
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* __cplusplus */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* _M_AMD64 */
end_comment
begin_pragma
pragma|#
directive|pragma
name|intrinsic
name|(
name|_InterlockedCompareExchange
name|)
end_pragma
begin_pragma
pragma|#
directive|pragma
name|intrinsic
name|(
name|_InterlockedExchange
name|)
end_pragma
begin_define
DECL|macro|interlockedcompareexchange
define|#
directive|define
name|interlockedcompareexchange
value|_InterlockedCompareExchange
end_define
begin_define
DECL|macro|interlockedexchange
define|#
directive|define
name|interlockedexchange
value|_InterlockedExchange
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Win32 */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* USE_LOCKS */
end_comment
begin_comment
comment|/* Declarations for bit scanning on win32 */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|_MSC_VER
operator|>=
literal|1300
end_if
begin_ifndef
ifndef|#
directive|ifndef
name|BitScanForward
end_ifndef
begin_comment
comment|/* Try to avoid pulling in WinNT.h */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef
begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* __cplusplus */
name|unsigned
name|char
name|_BitScanForward
parameter_list|(
name|unsigned
name|long
modifier|*
name|index
parameter_list|,
name|unsigned
name|long
name|mask
parameter_list|)
function_decl|;
name|unsigned
name|char
name|_BitScanReverse
parameter_list|(
name|unsigned
name|long
modifier|*
name|index
parameter_list|,
name|unsigned
name|long
name|mask
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* __cplusplus */
end_comment
begin_define
DECL|macro|BitScanForward
define|#
directive|define
name|BitScanForward
value|_BitScanForward
end_define
begin_define
DECL|macro|BitScanReverse
define|#
directive|define
name|BitScanReverse
value|_BitScanReverse
end_define
begin_pragma
pragma|#
directive|pragma
name|intrinsic
name|(
name|_BitScanForward
name|)
end_pragma
begin_pragma
pragma|#
directive|pragma
name|intrinsic
name|(
name|_BitScanReverse
name|)
end_pragma
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* BitScanForward */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* defined(_MSC_VER)&& _MSC_VER>=1300 */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|WIN32
end_ifndef
begin_ifndef
ifndef|#
directive|ifndef
name|malloc_getpagesize
end_ifndef
begin_ifdef
ifdef|#
directive|ifdef
name|_SC_PAGESIZE
end_ifdef
begin_comment
comment|/* some SVR4 systems omit an underscore */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|_SC_PAGE_SIZE
end_ifndef
begin_define
DECL|macro|_SC_PAGE_SIZE
define|#
directive|define
name|_SC_PAGE_SIZE
value|_SC_PAGESIZE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|_SC_PAGE_SIZE
end_ifdef
begin_define
DECL|macro|malloc_getpagesize
define|#
directive|define
name|malloc_getpagesize
value|sysconf(_SC_PAGE_SIZE)
end_define
begin_else
else|#
directive|else
end_else
begin_if
if|#
directive|if
name|defined
argument_list|(
name|BSD
argument_list|)
operator|||
name|defined
argument_list|(
name|DGUX
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_GETPAGESIZE
argument_list|)
end_if
begin_function_decl
specifier|extern
name|size_t
name|getpagesize
parameter_list|()
function_decl|;
end_function_decl
begin_define
DECL|macro|malloc_getpagesize
define|#
directive|define
name|malloc_getpagesize
value|getpagesize()
end_define
begin_else
else|#
directive|else
end_else
begin_ifdef
ifdef|#
directive|ifdef
name|WIN32
end_ifdef
begin_comment
comment|/* use supplied emulation of getpagesize */
end_comment
begin_define
DECL|macro|malloc_getpagesize
define|#
directive|define
name|malloc_getpagesize
value|getpagesize()
end_define
begin_else
else|#
directive|else
end_else
begin_ifndef
ifndef|#
directive|ifndef
name|LACKS_SYS_PARAM_H
end_ifndef
begin_include
include|#
directive|include
file|<sys/param.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|EXEC_PAGESIZE
end_ifdef
begin_define
DECL|macro|malloc_getpagesize
define|#
directive|define
name|malloc_getpagesize
value|EXEC_PAGESIZE
end_define
begin_else
else|#
directive|else
end_else
begin_ifdef
ifdef|#
directive|ifdef
name|NBPG
end_ifdef
begin_ifndef
ifndef|#
directive|ifndef
name|CLSIZE
end_ifndef
begin_define
DECL|macro|malloc_getpagesize
define|#
directive|define
name|malloc_getpagesize
value|NBPG
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|malloc_getpagesize
define|#
directive|define
name|malloc_getpagesize
value|(NBPG * CLSIZE)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_else
else|#
directive|else
end_else
begin_ifdef
ifdef|#
directive|ifdef
name|NBPC
end_ifdef
begin_define
DECL|macro|malloc_getpagesize
define|#
directive|define
name|malloc_getpagesize
value|NBPC
end_define
begin_else
else|#
directive|else
end_else
begin_ifdef
ifdef|#
directive|ifdef
name|PAGESIZE
end_ifdef
begin_define
DECL|macro|malloc_getpagesize
define|#
directive|define
name|malloc_getpagesize
value|PAGESIZE
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* just guess */
end_comment
begin_define
DECL|macro|malloc_getpagesize
define|#
directive|define
name|malloc_getpagesize
value|((size_t)4096U)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* ------------------- size_t and alignment properties -------------------- */
end_comment
begin_comment
comment|/* The byte and bit size of a size_t */
end_comment
begin_define
DECL|macro|SIZE_T_SIZE
define|#
directive|define
name|SIZE_T_SIZE
value|(sizeof(size_t))
end_define
begin_define
DECL|macro|SIZE_T_BITSIZE
define|#
directive|define
name|SIZE_T_BITSIZE
value|(sizeof(size_t)<< 3)
end_define
begin_comment
comment|/* Some constants coerced to size_t */
end_comment
begin_comment
comment|/* Annoying but necessary to avoid errors on some platforms */
end_comment
begin_define
DECL|macro|SIZE_T_ZERO
define|#
directive|define
name|SIZE_T_ZERO
value|((size_t)0)
end_define
begin_define
DECL|macro|SIZE_T_ONE
define|#
directive|define
name|SIZE_T_ONE
value|((size_t)1)
end_define
begin_define
DECL|macro|SIZE_T_TWO
define|#
directive|define
name|SIZE_T_TWO
value|((size_t)2)
end_define
begin_define
DECL|macro|SIZE_T_FOUR
define|#
directive|define
name|SIZE_T_FOUR
value|((size_t)4)
end_define
begin_define
DECL|macro|TWO_SIZE_T_SIZES
define|#
directive|define
name|TWO_SIZE_T_SIZES
value|(SIZE_T_SIZE<<1)
end_define
begin_define
DECL|macro|FOUR_SIZE_T_SIZES
define|#
directive|define
name|FOUR_SIZE_T_SIZES
value|(SIZE_T_SIZE<<2)
end_define
begin_define
DECL|macro|SIX_SIZE_T_SIZES
define|#
directive|define
name|SIX_SIZE_T_SIZES
value|(FOUR_SIZE_T_SIZES+TWO_SIZE_T_SIZES)
end_define
begin_define
DECL|macro|HALF_MAX_SIZE_T
define|#
directive|define
name|HALF_MAX_SIZE_T
value|(MAX_SIZE_T / 2U)
end_define
begin_comment
comment|/* The bit mask value corresponding to MALLOC_ALIGNMENT */
end_comment
begin_define
DECL|macro|CHUNK_ALIGN_MASK
define|#
directive|define
name|CHUNK_ALIGN_MASK
value|(MALLOC_ALIGNMENT - SIZE_T_ONE)
end_define
begin_comment
comment|/* True if address a has acceptable alignment */
end_comment
begin_define
DECL|macro|is_aligned
define|#
directive|define
name|is_aligned
parameter_list|(
name|A
parameter_list|)
value|(((size_t)((A))& (CHUNK_ALIGN_MASK)) == 0)
end_define
begin_comment
comment|/* the number of bytes to offset an address to align it */
end_comment
begin_define
DECL|macro|align_offset
define|#
directive|define
name|align_offset
parameter_list|(
name|A
parameter_list|)
define|\
value|((((size_t)(A)& CHUNK_ALIGN_MASK) == 0)? 0 :\   ((MALLOC_ALIGNMENT - ((size_t)(A)& CHUNK_ALIGN_MASK))& CHUNK_ALIGN_MASK))
end_define
begin_comment
comment|/* -------------------------- MMAP preliminaries ------------------------- */
end_comment
begin_comment
comment|/*    If HAVE_MORECORE or HAVE_MMAP are false, we just define calls and    checks to fail so compiler optimizer can delete code rather than    using so many "#if"s. */
end_comment
begin_comment
comment|/* MORECORE and MMAP must return MFAIL on failure */
end_comment
begin_define
DECL|macro|MFAIL
define|#
directive|define
name|MFAIL
value|((void*)(MAX_SIZE_T))
end_define
begin_define
DECL|macro|CMFAIL
define|#
directive|define
name|CMFAIL
value|((char*)(MFAIL))
end_define
begin_comment
DECL|macro|CMFAIL
comment|/* defined for convenience */
end_comment
begin_if
if|#
directive|if
operator|!
name|HAVE_MMAP
end_if
begin_define
DECL|macro|IS_MMAPPED_BIT
define|#
directive|define
name|IS_MMAPPED_BIT
value|(SIZE_T_ZERO)
end_define
begin_define
DECL|macro|USE_MMAP_BIT
define|#
directive|define
name|USE_MMAP_BIT
value|(SIZE_T_ZERO)
end_define
begin_define
DECL|macro|CALL_MMAP
define|#
directive|define
name|CALL_MMAP
parameter_list|(
name|s
parameter_list|)
value|MFAIL
end_define
begin_define
DECL|macro|CALL_MUNMAP
define|#
directive|define
name|CALL_MUNMAP
parameter_list|(
name|a
parameter_list|,
name|s
parameter_list|)
value|(-1)
end_define
begin_define
DECL|macro|DIRECT_MMAP
define|#
directive|define
name|DIRECT_MMAP
parameter_list|(
name|s
parameter_list|)
value|MFAIL
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* HAVE_MMAP */
end_comment
begin_define
DECL|macro|IS_MMAPPED_BIT
define|#
directive|define
name|IS_MMAPPED_BIT
value|(SIZE_T_ONE)
end_define
begin_define
DECL|macro|USE_MMAP_BIT
define|#
directive|define
name|USE_MMAP_BIT
value|(SIZE_T_ONE)
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|WIN32
end_ifndef
begin_define
DECL|macro|CALL_MUNMAP
define|#
directive|define
name|CALL_MUNMAP
parameter_list|(
name|a
parameter_list|,
name|s
parameter_list|)
value|munmap((a), (s))
end_define
begin_define
DECL|macro|MMAP_PROT
define|#
directive|define
name|MMAP_PROT
value|(PROT_READ|PROT_WRITE)
end_define
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAP_ANONYMOUS
argument_list|)
operator|&&
name|defined
argument_list|(
name|MAP_ANON
argument_list|)
end_if
begin_define
DECL|macro|MAP_ANONYMOUS
define|#
directive|define
name|MAP_ANONYMOUS
value|MAP_ANON
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* MAP_ANON */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|MAP_ANONYMOUS
end_ifdef
begin_define
DECL|macro|MMAP_FLAGS
define|#
directive|define
name|MMAP_FLAGS
value|(MAP_PRIVATE|MAP_ANONYMOUS)
end_define
begin_define
DECL|macro|CALL_MMAP
define|#
directive|define
name|CALL_MMAP
parameter_list|(
name|s
parameter_list|)
value|mmap(0, (s), MMAP_PROT, MMAP_FLAGS, -1, 0)
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* MAP_ANONYMOUS */
end_comment
begin_comment
comment|/*    Nearly all versions of mmap support MAP_ANONYMOUS, so the following    is unlikely to be needed, but is supplied just in case. */
end_comment
begin_define
DECL|macro|MMAP_FLAGS
define|#
directive|define
name|MMAP_FLAGS
value|(MAP_PRIVATE)
end_define
begin_decl_stmt
DECL|variable|dev_zero_fd
specifier|static
name|int
name|dev_zero_fd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|dev_zero_fd
comment|/* Cached file descriptor for /dev/zero. */
end_comment
begin_define
DECL|macro|CALL_MMAP
define|#
directive|define
name|CALL_MMAP
parameter_list|(
name|s
parameter_list|)
value|((dev_zero_fd< 0) ? \            (dev_zero_fd = open("/dev/zero", O_RDWR), \             mmap(0, (s), MMAP_PROT, MMAP_FLAGS, dev_zero_fd, 0)) : \             mmap(0, (s), MMAP_PROT, MMAP_FLAGS, dev_zero_fd, 0))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* MAP_ANONYMOUS */
end_comment
begin_define
DECL|macro|DIRECT_MMAP
define|#
directive|define
name|DIRECT_MMAP
parameter_list|(
name|s
parameter_list|)
value|CALL_MMAP(s)
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* WIN32 */
end_comment
begin_comment
comment|/* Win32 MMAP via VirtualAlloc */
end_comment
begin_function
DECL|function|win32mmap
specifier|static
name|FORCEINLINE
name|void
modifier|*
name|win32mmap
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ptr
init|=
name|VirtualAlloc
argument_list|(
literal|0
argument_list|,
name|size
argument_list|,
name|MEM_RESERVE
operator||
name|MEM_COMMIT
argument_list|,
name|PAGE_READWRITE
argument_list|)
decl_stmt|;
return|return
operator|(
name|ptr
operator|!=
literal|0
operator|)
condition|?
name|ptr
else|:
name|MFAIL
return|;
block|}
end_function
begin_comment
comment|/* For direct MMAP, use MEM_TOP_DOWN to minimize interference */
end_comment
begin_function
DECL|function|win32direct_mmap
specifier|static
name|FORCEINLINE
name|void
modifier|*
name|win32direct_mmap
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ptr
init|=
name|VirtualAlloc
argument_list|(
literal|0
argument_list|,
name|size
argument_list|,
name|MEM_RESERVE
operator||
name|MEM_COMMIT
operator||
name|MEM_TOP_DOWN
argument_list|,
name|PAGE_READWRITE
argument_list|)
decl_stmt|;
return|return
operator|(
name|ptr
operator|!=
literal|0
operator|)
condition|?
name|ptr
else|:
name|MFAIL
return|;
block|}
end_function
begin_comment
comment|/* This function supports releasing coalesed segments */
end_comment
begin_function
DECL|function|win32munmap
specifier|static
name|FORCEINLINE
name|int
name|win32munmap
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|MEMORY_BASIC_INFORMATION
name|minfo
decl_stmt|;
name|char
modifier|*
name|cptr
init|=
operator|(
name|char
operator|*
operator|)
name|ptr
decl_stmt|;
while|while
condition|(
name|size
condition|)
block|{
if|if
condition|(
name|VirtualQuery
argument_list|(
name|cptr
argument_list|,
operator|&
name|minfo
argument_list|,
sizeof|sizeof
argument_list|(
name|minfo
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|minfo
operator|.
name|BaseAddress
operator|!=
name|cptr
operator|||
name|minfo
operator|.
name|AllocationBase
operator|!=
name|cptr
operator|||
name|minfo
operator|.
name|State
operator|!=
name|MEM_COMMIT
operator|||
name|minfo
operator|.
name|RegionSize
operator|>
name|size
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|VirtualFree
argument_list|(
name|cptr
argument_list|,
literal|0
argument_list|,
name|MEM_RELEASE
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|cptr
operator|+=
name|minfo
operator|.
name|RegionSize
expr_stmt|;
name|size
operator|-=
name|minfo
operator|.
name|RegionSize
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_define
DECL|macro|CALL_MMAP
define|#
directive|define
name|CALL_MMAP
parameter_list|(
name|s
parameter_list|)
value|win32mmap(s)
end_define
begin_define
DECL|macro|CALL_MUNMAP
define|#
directive|define
name|CALL_MUNMAP
parameter_list|(
name|a
parameter_list|,
name|s
parameter_list|)
value|win32munmap((a), (s))
end_define
begin_define
DECL|macro|DIRECT_MMAP
define|#
directive|define
name|DIRECT_MMAP
parameter_list|(
name|s
parameter_list|)
value|win32direct_mmap(s)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* WIN32 */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HAVE_MMAP */
end_comment
begin_if
if|#
directive|if
name|HAVE_MMAP
operator|&&
name|HAVE_MREMAP
end_if
begin_define
DECL|macro|CALL_MREMAP
define|#
directive|define
name|CALL_MREMAP
parameter_list|(
name|addr
parameter_list|,
name|osz
parameter_list|,
name|nsz
parameter_list|,
name|mv
parameter_list|)
value|mremap((addr), (osz), (nsz), (mv))
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* HAVE_MMAP&& HAVE_MREMAP */
end_comment
begin_define
DECL|macro|CALL_MREMAP
define|#
directive|define
name|CALL_MREMAP
parameter_list|(
name|addr
parameter_list|,
name|osz
parameter_list|,
name|nsz
parameter_list|,
name|mv
parameter_list|)
value|((void)(addr),(void)(osz), \                                          (void)(nsz), (void)(mv),MFAIL)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HAVE_MMAP&& HAVE_MREMAP */
end_comment
begin_if
if|#
directive|if
name|HAVE_MORECORE
end_if
begin_define
DECL|macro|CALL_MORECORE
define|#
directive|define
name|CALL_MORECORE
parameter_list|(
name|S
parameter_list|)
value|MORECORE(S)
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* HAVE_MORECORE */
end_comment
begin_define
DECL|macro|CALL_MORECORE
define|#
directive|define
name|CALL_MORECORE
parameter_list|(
name|S
parameter_list|)
value|MFAIL
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HAVE_MORECORE */
end_comment
begin_comment
comment|/* mstate bit set if continguous morecore disabled or failed */
end_comment
begin_define
DECL|macro|USE_NONCONTIGUOUS_BIT
define|#
directive|define
name|USE_NONCONTIGUOUS_BIT
value|(4U)
end_define
begin_comment
comment|/* segment bit set in create_mspace_with_base */
end_comment
begin_define
DECL|macro|EXTERN_BIT
define|#
directive|define
name|EXTERN_BIT
value|(8U)
end_define
begin_comment
comment|/* --------------------------- Lock preliminaries ------------------------ */
end_comment
begin_comment
comment|/*   When locks are defined, there are up to two global locks:    * If HAVE_MORECORE, morecore_mutex protects sequences of calls to     MORECORE.  In many cases sys_alloc requires two calls, that should     not be interleaved with calls by other threads.  This does not     protect against direct calls to MORECORE by other threads not     using this lock, so there is still code to cope the best we can on     interference.    * magic_init_mutex ensures that mparams.magic and other     unique mparams values are initialized only once.     To enable use in layered extensions, locks are reentrant.     Because lock-protected regions generally have bounded times, we use    the supplied simple spinlocks in the custom versions for x86.     If USE_LOCKS is> 1, the definitions of lock routines here are    bypassed, in which case you will need to define at least    INITIAL_LOCK, ACQUIRE_LOCK, RELEASE_LOCK, and    NULL_LOCK_INITIALIZER, and possibly TRY_LOCK and IS_LOCKED    (The latter two are not used in this malloc, but are    commonly needed in extensions.) */
end_comment
begin_if
if|#
directive|if
name|USE_LOCKS
operator|==
literal|1
end_if
begin_if
if|#
directive|if
name|USE_SPIN_LOCKS
end_if
begin_ifndef
ifndef|#
directive|ifndef
name|WIN32
end_ifndef
begin_comment
comment|/* Custom pthread-style spin locks on x86 and x64 for gcc */
end_comment
begin_struct
DECL|struct|pthread_mlock_t
struct|struct
name|pthread_mlock_t
block|{
DECL|member|threadid
specifier|volatile
name|pthread_t
name|threadid
decl_stmt|;
DECL|member|c
specifier|volatile
name|unsigned
name|int
name|c
decl_stmt|;
DECL|member|l
specifier|volatile
name|unsigned
name|int
name|l
decl_stmt|;
block|}
struct|;
end_struct
begin_define
DECL|macro|MLOCK_T
define|#
directive|define
name|MLOCK_T
value|struct pthread_mlock_t
end_define
begin_define
DECL|macro|CURRENT_THREAD
define|#
directive|define
name|CURRENT_THREAD
value|pthread_self()
end_define
begin_define
DECL|macro|SPINS_PER_YIELD
define|#
directive|define
name|SPINS_PER_YIELD
value|63
end_define
begin_function
DECL|function|pthread_acquire_lock
specifier|static
name|FORCEINLINE
name|int
name|pthread_acquire_lock
parameter_list|(
name|MLOCK_T
modifier|*
name|sl
parameter_list|)
block|{
if|if
condition|(
name|CURRENT_THREAD
operator|==
name|sl
operator|->
name|threadid
condition|)
operator|++
name|sl
operator|->
name|c
expr_stmt|;
else|else
block|{
name|int
name|spins
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|ret
decl_stmt|;
asm|__asm__
specifier|__volatile__
asm|("lock cmpxchgl %2,(%1)" : "=a" (ret) : "r" (&sl->l), "r" (1), "a" (0));
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|assert
argument_list|(
operator|!
name|sl
operator|->
name|threadid
argument_list|)
expr_stmt|;
name|sl
operator|->
name|threadid
operator|=
name|CURRENT_THREAD
expr_stmt|;
name|sl
operator|->
name|c
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
operator|++
name|spins
operator|&
name|SPINS_PER_YIELD
operator|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__SVR4
argument_list|)
operator|&&
name|defined
argument_list|(
name|__sun
argument_list|)
comment|/* solaris */
name|thr_yield
argument_list|()
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|linux
name|sched_yield
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* no-op yield on unknown systems */
empty_stmt|;
endif|#
directive|endif
comment|/* linux */
endif|#
directive|endif
comment|/* solaris */
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|pthread_release_lock
specifier|static
name|FORCEINLINE
name|void
name|pthread_release_lock
parameter_list|(
name|MLOCK_T
modifier|*
name|sl
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|assert
argument_list|(
name|CURRENT_THREAD
operator|==
name|sl
operator|->
name|threadid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|sl
operator|->
name|c
condition|)
block|{
name|sl
operator|->
name|threadid
operator|=
literal|0
expr_stmt|;
asm|__asm__
specifier|__volatile__
asm|("xchgl %2,(%1)" : "=r" (ret) : "r" (&sl->l), "0" (0));
block|}
block|}
end_function
begin_function
DECL|function|pthread_try_lock
specifier|static
name|FORCEINLINE
name|int
name|pthread_try_lock
parameter_list|(
name|MLOCK_T
modifier|*
name|sl
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
asm|__asm__
specifier|__volatile__
asm|("lock cmpxchgl %2,(%1)" : "=a" (ret) : "r" (&sl->l), "r" (1), "a" (0));
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|assert
argument_list|(
operator|!
name|sl
operator|->
name|threadid
argument_list|)
expr_stmt|;
name|sl
operator|->
name|threadid
operator|=
name|CURRENT_THREAD
expr_stmt|;
name|sl
operator|->
name|c
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_define
DECL|macro|INITIAL_LOCK
define|#
directive|define
name|INITIAL_LOCK
parameter_list|(
name|sl
parameter_list|)
value|(memset((sl), 0, sizeof(MLOCK_T)), 0)
end_define
begin_define
DECL|macro|ACQUIRE_LOCK
define|#
directive|define
name|ACQUIRE_LOCK
parameter_list|(
name|sl
parameter_list|)
value|pthread_acquire_lock(sl)
end_define
begin_define
DECL|macro|RELEASE_LOCK
define|#
directive|define
name|RELEASE_LOCK
parameter_list|(
name|sl
parameter_list|)
value|pthread_release_lock(sl)
end_define
begin_define
DECL|macro|TRY_LOCK
define|#
directive|define
name|TRY_LOCK
parameter_list|(
name|sl
parameter_list|)
value|pthread_try_lock(sl)
end_define
begin_define
DECL|macro|IS_LOCKED
define|#
directive|define
name|IS_LOCKED
parameter_list|(
name|sl
parameter_list|)
value|((sl)->l)
end_define
begin_decl_stmt
DECL|variable|magic_init_mutex
specifier|static
name|MLOCK_T
name|magic_init_mutex
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_if
if|#
directive|if
name|HAVE_MORECORE
end_if
begin_decl_stmt
DECL|variable|morecore_mutex
specifier|static
name|MLOCK_T
name|morecore_mutex
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HAVE_MORECORE */
end_comment
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* WIN32 */
end_comment
begin_comment
comment|/* Custom win32-style spin locks on x86 and x64 for MSC */
end_comment
begin_struct
DECL|struct|win32_mlock_t
struct|struct
name|win32_mlock_t
block|{
DECL|member|threadid
specifier|volatile
name|long
name|threadid
decl_stmt|;
DECL|member|c
specifier|volatile
name|unsigned
name|int
name|c
decl_stmt|;
DECL|member|l
name|long
name|l
decl_stmt|;
block|}
struct|;
end_struct
begin_define
DECL|macro|MLOCK_T
define|#
directive|define
name|MLOCK_T
value|struct win32_mlock_t
end_define
begin_define
DECL|macro|CURRENT_THREAD
define|#
directive|define
name|CURRENT_THREAD
value|GetCurrentThreadId()
end_define
begin_define
DECL|macro|SPINS_PER_YIELD
define|#
directive|define
name|SPINS_PER_YIELD
value|63
end_define
begin_function
DECL|function|win32_acquire_lock
specifier|static
name|FORCEINLINE
name|int
name|win32_acquire_lock
parameter_list|(
name|MLOCK_T
modifier|*
name|sl
parameter_list|)
block|{
name|long
name|mythreadid
init|=
name|CURRENT_THREAD
decl_stmt|;
if|if
condition|(
name|mythreadid
operator|==
name|sl
operator|->
name|threadid
condition|)
operator|++
name|sl
operator|->
name|c
expr_stmt|;
else|else
block|{
name|int
name|spins
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|interlockedexchange
argument_list|(
operator|&
name|sl
operator|->
name|l
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|assert
argument_list|(
operator|!
name|sl
operator|->
name|threadid
argument_list|)
expr_stmt|;
name|sl
operator|->
name|threadid
operator|=
name|mythreadid
expr_stmt|;
name|sl
operator|->
name|c
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
operator|++
name|spins
operator|&
name|SPINS_PER_YIELD
operator|)
operator|==
literal|0
condition|)
name|SleepEx
argument_list|(
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|win32_release_lock
specifier|static
name|FORCEINLINE
name|void
name|win32_release_lock
parameter_list|(
name|MLOCK_T
modifier|*
name|sl
parameter_list|)
block|{
name|assert
argument_list|(
name|CURRENT_THREAD
operator|==
name|sl
operator|->
name|threadid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|sl
operator|->
name|c
condition|)
block|{
name|sl
operator|->
name|threadid
operator|=
literal|0
expr_stmt|;
name|interlockedexchange
argument_list|(
operator|&
name|sl
operator|->
name|l
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|win32_try_lock
specifier|static
name|FORCEINLINE
name|int
name|win32_try_lock
parameter_list|(
name|MLOCK_T
modifier|*
name|sl
parameter_list|)
block|{
if|if
condition|(
operator|!
name|interlockedexchange
argument_list|(
operator|&
name|sl
operator|->
name|l
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|assert
argument_list|(
operator|!
name|sl
operator|->
name|threadid
argument_list|)
expr_stmt|;
name|sl
operator|->
name|threadid
operator|=
name|CURRENT_THREAD
expr_stmt|;
name|sl
operator|->
name|c
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_define
DECL|macro|INITIAL_LOCK
define|#
directive|define
name|INITIAL_LOCK
parameter_list|(
name|sl
parameter_list|)
value|(memset(sl, 0, sizeof(MLOCK_T)), 0)
end_define
begin_define
DECL|macro|ACQUIRE_LOCK
define|#
directive|define
name|ACQUIRE_LOCK
parameter_list|(
name|sl
parameter_list|)
value|win32_acquire_lock(sl)
end_define
begin_define
DECL|macro|RELEASE_LOCK
define|#
directive|define
name|RELEASE_LOCK
parameter_list|(
name|sl
parameter_list|)
value|win32_release_lock(sl)
end_define
begin_define
DECL|macro|TRY_LOCK
define|#
directive|define
name|TRY_LOCK
parameter_list|(
name|sl
parameter_list|)
value|win32_try_lock(sl)
end_define
begin_define
DECL|macro|IS_LOCKED
define|#
directive|define
name|IS_LOCKED
parameter_list|(
name|sl
parameter_list|)
value|((sl)->l)
end_define
begin_decl_stmt
DECL|variable|magic_init_mutex
specifier|static
name|MLOCK_T
name|magic_init_mutex
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_if
if|#
directive|if
name|HAVE_MORECORE
end_if
begin_decl_stmt
DECL|variable|morecore_mutex
specifier|static
name|MLOCK_T
name|morecore_mutex
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HAVE_MORECORE */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* WIN32 */
end_comment
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* USE_SPIN_LOCKS */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|WIN32
end_ifndef
begin_comment
comment|/* pthreads-based locks */
end_comment
begin_struct
DECL|struct|pthread_mlock_t
struct|struct
name|pthread_mlock_t
block|{
DECL|member|c
specifier|volatile
name|unsigned
name|int
name|c
decl_stmt|;
DECL|member|l
name|pthread_mutex_t
name|l
decl_stmt|;
block|}
struct|;
end_struct
begin_define
DECL|macro|MLOCK_T
define|#
directive|define
name|MLOCK_T
value|struct pthread_mlock_t
end_define
begin_define
DECL|macro|CURRENT_THREAD
define|#
directive|define
name|CURRENT_THREAD
value|pthread_self()
end_define
begin_function
DECL|function|pthread_acquire_lock
specifier|static
name|FORCEINLINE
name|int
name|pthread_acquire_lock
parameter_list|(
name|MLOCK_T
modifier|*
name|sl
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pthread_mutex_lock
argument_list|(
operator|&
operator|(
name|sl
operator|)
operator|->
name|l
argument_list|)
condition|)
block|{
name|sl
operator|->
name|c
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|pthread_release_lock
specifier|static
name|FORCEINLINE
name|void
name|pthread_release_lock
parameter_list|(
name|MLOCK_T
modifier|*
name|sl
parameter_list|)
block|{
operator|--
name|sl
operator|->
name|c
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
operator|(
name|sl
operator|)
operator|->
name|l
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|pthread_try_lock
specifier|static
name|FORCEINLINE
name|int
name|pthread_try_lock
parameter_list|(
name|MLOCK_T
modifier|*
name|sl
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pthread_mutex_trylock
argument_list|(
operator|&
operator|(
name|sl
operator|)
operator|->
name|l
argument_list|)
condition|)
block|{
name|sl
operator|->
name|c
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|pthread_init_lock
specifier|static
name|FORCEINLINE
name|int
name|pthread_init_lock
parameter_list|(
name|MLOCK_T
modifier|*
name|sl
parameter_list|)
block|{
name|pthread_mutexattr_t
name|attr
decl_stmt|;
name|sl
operator|->
name|c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pthread_mutexattr_init
argument_list|(
operator|&
name|attr
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|pthread_mutexattr_settype
argument_list|(
operator|&
name|attr
argument_list|,
name|PTHREAD_MUTEX_RECURSIVE
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|pthread_mutex_init
argument_list|(
operator|&
name|sl
operator|->
name|l
argument_list|,
operator|&
name|attr
argument_list|)
condition|)
return|return
literal|1
return|;
name|pthread_mutexattr_destroy
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|pthread_islocked
specifier|static
name|FORCEINLINE
name|int
name|pthread_islocked
parameter_list|(
name|MLOCK_T
modifier|*
name|sl
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pthread_try_lock
argument_list|(
name|sl
argument_list|)
condition|)
block|{
name|int
name|ret
init|=
operator|(
name|sl
operator|->
name|c
operator|!=
literal|0
operator|)
decl_stmt|;
name|pthread_mutex_unlock
argument_list|(
name|sl
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_define
DECL|macro|INITIAL_LOCK
define|#
directive|define
name|INITIAL_LOCK
parameter_list|(
name|sl
parameter_list|)
value|pthread_init_lock(sl)
end_define
begin_define
DECL|macro|ACQUIRE_LOCK
define|#
directive|define
name|ACQUIRE_LOCK
parameter_list|(
name|sl
parameter_list|)
value|pthread_acquire_lock(sl)
end_define
begin_define
DECL|macro|RELEASE_LOCK
define|#
directive|define
name|RELEASE_LOCK
parameter_list|(
name|sl
parameter_list|)
value|pthread_release_lock(sl)
end_define
begin_define
DECL|macro|TRY_LOCK
define|#
directive|define
name|TRY_LOCK
parameter_list|(
name|sl
parameter_list|)
value|pthread_try_lock(sl)
end_define
begin_define
DECL|macro|IS_LOCKED
define|#
directive|define
name|IS_LOCKED
parameter_list|(
name|sl
parameter_list|)
value|pthread_islocked(sl)
end_define
begin_decl_stmt
DECL|variable|magic_init_mutex
specifier|static
name|MLOCK_T
name|magic_init_mutex
init|=
block|{
literal|0
block|,
name|PTHREAD_MUTEX_INITIALIZER
block|}
decl_stmt|;
end_decl_stmt
begin_if
if|#
directive|if
name|HAVE_MORECORE
end_if
begin_decl_stmt
DECL|variable|morecore_mutex
specifier|static
name|MLOCK_T
name|morecore_mutex
init|=
block|{
literal|0
block|,
name|PTHREAD_MUTEX_INITIALIZER
block|}
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HAVE_MORECORE */
end_comment
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* WIN32 */
end_comment
begin_comment
comment|/* Win32 critical sections */
end_comment
begin_define
DECL|macro|MLOCK_T
define|#
directive|define
name|MLOCK_T
value|CRITICAL_SECTION
end_define
begin_define
DECL|macro|CURRENT_THREAD
define|#
directive|define
name|CURRENT_THREAD
value|GetCurrentThreadId()
end_define
begin_define
DECL|macro|INITIAL_LOCK
define|#
directive|define
name|INITIAL_LOCK
parameter_list|(
name|s
parameter_list|)
value|(!InitializeCriticalSectionAndSpinCount((s), 4000)
end_define
begin_define
DECL|macro|ACQUIRE_LOCK
define|#
directive|define
name|ACQUIRE_LOCK
parameter_list|(
name|s
parameter_list|)
value|( (!((s))->DebugInfo ? INITIAL_LOCK((s)) : 0), !EnterCriticalSection((s)), 0)
end_define
begin_define
DECL|macro|RELEASE_LOCK
define|#
directive|define
name|RELEASE_LOCK
parameter_list|(
name|s
parameter_list|)
value|( LeaveCriticalSection((s)), 0 )
end_define
begin_define
DECL|macro|TRY_LOCK
define|#
directive|define
name|TRY_LOCK
parameter_list|(
name|s
parameter_list|)
value|( TryEnterCriticalSection((s)) )
end_define
begin_define
DECL|macro|IS_LOCKED
define|#
directive|define
name|IS_LOCKED
parameter_list|(
name|s
parameter_list|)
value|( (s)->LockCount>= 0 )
end_define
begin_define
DECL|macro|NULL_LOCK_INITIALIZER
define|#
directive|define
name|NULL_LOCK_INITIALIZER
end_define
begin_decl_stmt
DECL|variable|magic_init_mutex
specifier|static
name|MLOCK_T
name|magic_init_mutex
decl_stmt|;
end_decl_stmt
begin_if
if|#
directive|if
name|HAVE_MORECORE
end_if
begin_decl_stmt
DECL|variable|morecore_mutex
specifier|static
name|MLOCK_T
name|morecore_mutex
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HAVE_MORECORE */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* WIN32 */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* USE_SPIN_LOCKS */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* USE_LOCKS == 1 */
end_comment
begin_comment
comment|/* -----------------------  User-defined locks ------------------------ */
end_comment
begin_if
if|#
directive|if
name|USE_LOCKS
operator|>
literal|1
end_if
begin_comment
comment|/* Define your own lock implementation here */
end_comment
begin_comment
comment|/* #define INITIAL_LOCK(sl)  ... */
end_comment
begin_comment
comment|/* #define ACQUIRE_LOCK(sl)  ... */
end_comment
begin_comment
comment|/* #define RELEASE_LOCK(sl)  ... */
end_comment
begin_comment
comment|/* #define TRY_LOCK(sl) ... */
end_comment
begin_comment
comment|/* #define IS_LOCKED(sl) ... */
end_comment
begin_comment
comment|/* #define NULL_LOCK_INITIALIZER ... */
end_comment
begin_decl_stmt
DECL|variable|magic_init_mutex
specifier|static
name|MLOCK_T
name|magic_init_mutex
init|=
name|NULL_LOCK_INITIALIZER
decl_stmt|;
end_decl_stmt
begin_if
if|#
directive|if
name|HAVE_MORECORE
end_if
begin_decl_stmt
DECL|variable|morecore_mutex
specifier|static
name|MLOCK_T
name|morecore_mutex
init|=
name|NULL_LOCK_INITIALIZER
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HAVE_MORECORE */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* USE_LOCKS> 1 */
end_comment
begin_comment
comment|/* -----------------------  Lock-based state ------------------------ */
end_comment
begin_if
if|#
directive|if
name|USE_LOCKS
end_if
begin_define
DECL|macro|USE_LOCK_BIT
define|#
directive|define
name|USE_LOCK_BIT
value|(2U)
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* USE_LOCKS */
end_comment
begin_define
DECL|macro|USE_LOCK_BIT
define|#
directive|define
name|USE_LOCK_BIT
value|(0U)
end_define
begin_define
DECL|macro|INITIAL_LOCK
define|#
directive|define
name|INITIAL_LOCK
parameter_list|(
name|l
parameter_list|)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* USE_LOCKS */
end_comment
begin_if
if|#
directive|if
name|USE_LOCKS
operator|&&
name|HAVE_MORECORE
end_if
begin_define
DECL|macro|ACQUIRE_MORECORE_LOCK
define|#
directive|define
name|ACQUIRE_MORECORE_LOCK
parameter_list|()
value|ACQUIRE_LOCK(&morecore_mutex);
end_define
begin_define
DECL|macro|RELEASE_MORECORE_LOCK
define|#
directive|define
name|RELEASE_MORECORE_LOCK
parameter_list|()
value|RELEASE_LOCK(&morecore_mutex);
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* USE_LOCKS&& HAVE_MORECORE */
end_comment
begin_define
DECL|macro|ACQUIRE_MORECORE_LOCK
define|#
directive|define
name|ACQUIRE_MORECORE_LOCK
parameter_list|()
end_define
begin_define
DECL|macro|RELEASE_MORECORE_LOCK
define|#
directive|define
name|RELEASE_MORECORE_LOCK
parameter_list|()
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* USE_LOCKS&& HAVE_MORECORE */
end_comment
begin_if
if|#
directive|if
name|USE_LOCKS
end_if
begin_define
DECL|macro|ACQUIRE_MAGIC_INIT_LOCK
define|#
directive|define
name|ACQUIRE_MAGIC_INIT_LOCK
parameter_list|()
value|ACQUIRE_LOCK(&magic_init_mutex);
end_define
begin_define
DECL|macro|RELEASE_MAGIC_INIT_LOCK
define|#
directive|define
name|RELEASE_MAGIC_INIT_LOCK
parameter_list|()
value|RELEASE_LOCK(&magic_init_mutex);
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* USE_LOCKS */
end_comment
begin_define
DECL|macro|ACQUIRE_MAGIC_INIT_LOCK
define|#
directive|define
name|ACQUIRE_MAGIC_INIT_LOCK
parameter_list|()
end_define
begin_define
DECL|macro|RELEASE_MAGIC_INIT_LOCK
define|#
directive|define
name|RELEASE_MAGIC_INIT_LOCK
parameter_list|()
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* USE_LOCKS */
end_comment
begin_comment
comment|/* -----------------------  Chunk representations ------------------------ */
end_comment
begin_comment
comment|/*   (The following includes lightly edited explanations by Colin Plumb.)    The malloc_chunk declaration below is misleading (but accurate and   necessary).  It declares a "view" into memory allowing access to   necessary fields at known offsets from a given base.    Chunks of memory are maintained using a `boundary tag' method as   originally described by Knuth.  (See the paper by Paul Wilson   ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a survey of such   techniques.)  Sizes of free chunks are stored both in the front of   each chunk and at the end.  This makes consolidating fragmented   chunks into bigger chunks fast.  The head fields also hold bits   representing whether chunks are free or in use.    Here are some pictures to make it clearer.  They are "exploded" to   show that the state of a chunk can be thought of as extending from   the high 31 bits of the head field of its header through the   prev_foot and PINUSE_BIT bit of the following chunk header.    A chunk that's in use looks like:     chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+            | Size of previous chunk (if P = 1)                             |            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|          | Size of this chunk                                         1| +-+    mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+          |                                                               |          +-                                                             -+          |                                                               |          +-                                                             -+          |                                                               :          +-      size - sizeof(size_t) available payload bytes          -+          :                                                               |  chunk-> +-                                                             -+          |                                                               |          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |1|        | Size of next chunk (may or may not be in use)               | +-+  mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+      And if it's free, it looks like this:     chunk-> +-                                                             -+            | User payload (must be in use, or we would have merged!)       |            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|          | Size of this chunk                                         0| +-+    mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+          | Next pointer                                                  |          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+          | Prev pointer                                                  |          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+          |                                                               :          +-      size - sizeof(struct chunk) unused bytes               -+          :                                                               |  chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+          | Size of this chunk                                            |          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0|        | Size of next chunk (must be in use, or we would have merged)| +-+  mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+        |                                                               :        +- User payload                                                -+        :                                                               |        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                                                                      |0|                                                                      +-+   Note that since we always merge adjacent free chunks, the chunks   adjacent to a free chunk must be in use.    Given a pointer to a chunk (which can be derived trivially from the   payload pointer) we can, in O(1) time, find out whether the adjacent   chunks are free, and if so, unlink them from the lists that they   are on and merge them with the current chunk.    Chunks always begin on even word boundaries, so the mem portion   (which is returned to the user) is also on an even word boundary, and   thus at least double-word aligned.    The P (PINUSE_BIT) bit, stored in the unused low-order bit of the   chunk size (which is always a multiple of two words), is an in-use   bit for the *previous* chunk.  If that bit is *clear*, then the   word before the current chunk size contains the previous chunk   size, and can be used to find the front of the previous chunk.   The very first chunk allocated always has this bit set, preventing   access to non-existent (or non-owned) memory. If pinuse is set for   any given chunk, then you CANNOT determine the size of the   previous chunk, and might even get a memory addressing fault when   trying to do so.    The C (CINUSE_BIT) bit, stored in the unused second-lowest bit of   the chunk size redundantly records whether the current chunk is   inuse. This redundancy enables usage checks within free and realloc,   and reduces indirection when freeing and consolidating chunks.    Each freshly allocated chunk must have both cinuse and pinuse set.   That is, each allocated chunk borders either a previously allocated   and still in-use chunk, or the base of its memory arena. This is   ensured by making all allocations from the the `lowest' part of any   found chunk.  Further, no free chunk physically borders another one,   so each free chunk is known to be preceded and followed by either   inuse chunks or the ends of memory.    Note that the `foot' of the current chunk is actually represented   as the prev_foot of the NEXT chunk. This makes it easier to   deal with alignments etc but can be very confusing when trying   to extend or adapt this code.    The exceptions to all this are       1. The special chunk `top' is the top-most available chunk (i.e.,         the one bordering the end of available memory). It is treated         specially.  Top is never included in any bin, is used only if         no other chunk is available, and is released back to the         system if it is very large (see M_TRIM_THRESHOLD).  In effect,         the top chunk is treated as larger (and thus less well         fitting) than any other available chunk.  The top chunk         doesn't update its trailing size field since there is no next         contiguous chunk that would have to index off it. However,         space is still allocated for it (TOP_FOOT_SIZE) to enable         separation or merging when space is extended.       3. Chunks allocated via mmap, which have the lowest-order bit         (IS_MMAPPED_BIT) set in their prev_foot fields, and do not set         PINUSE_BIT in their head fields.  Because they are allocated         one-by-one, each must carry its own prev_foot field, which is         also used to hold the offset this chunk has within its mmapped         region, which is needed to preserve alignment. Each mmapped         chunk is trailed by the first two fields of a fake next-chunk         for sake of usage checks.  */
end_comment
begin_struct
DECL|struct|malloc_chunk
struct|struct
name|malloc_chunk
block|{
DECL|member|prev_foot
name|size_t
name|prev_foot
decl_stmt|;
comment|/* Size of previous chunk (if free).  */
DECL|member|head
name|size_t
name|head
decl_stmt|;
comment|/* Size and inuse bits. */
DECL|member|fd
name|struct
name|malloc_chunk
modifier|*
name|fd
decl_stmt|;
comment|/* double links -- used only if free. */
DECL|member|bk
name|struct
name|malloc_chunk
modifier|*
name|bk
decl_stmt|;
block|}
struct|;
end_struct
begin_typedef
DECL|typedef|mchunk
typedef|typedef
name|struct
name|malloc_chunk
name|mchunk
typedef|;
end_typedef
begin_typedef
DECL|typedef|mchunkptr
typedef|typedef
name|struct
name|malloc_chunk
modifier|*
name|mchunkptr
typedef|;
end_typedef
begin_typedef
DECL|typedef|sbinptr
typedef|typedef
name|struct
name|malloc_chunk
modifier|*
name|sbinptr
typedef|;
end_typedef
begin_comment
DECL|typedef|sbinptr
comment|/* The type of bins of chunks */
end_comment
begin_typedef
DECL|typedef|bindex_t
typedef|typedef
name|unsigned
name|int
name|bindex_t
typedef|;
end_typedef
begin_comment
DECL|typedef|bindex_t
comment|/* Described below */
end_comment
begin_typedef
DECL|typedef|binmap_t
typedef|typedef
name|unsigned
name|int
name|binmap_t
typedef|;
end_typedef
begin_comment
DECL|typedef|binmap_t
comment|/* Described below */
end_comment
begin_typedef
DECL|typedef|flag_t
typedef|typedef
name|unsigned
name|int
name|flag_t
typedef|;
end_typedef
begin_comment
DECL|typedef|flag_t
comment|/* The type of various bit flag sets */
end_comment
begin_comment
comment|/* ------------------- Chunks sizes and alignments ----------------------- */
end_comment
begin_define
DECL|macro|MCHUNK_SIZE
define|#
directive|define
name|MCHUNK_SIZE
value|(sizeof(mchunk))
end_define
begin_if
if|#
directive|if
name|FOOTERS
end_if
begin_define
DECL|macro|CHUNK_OVERHEAD
define|#
directive|define
name|CHUNK_OVERHEAD
value|(TWO_SIZE_T_SIZES)
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* FOOTERS */
end_comment
begin_define
DECL|macro|CHUNK_OVERHEAD
define|#
directive|define
name|CHUNK_OVERHEAD
value|(SIZE_T_SIZE)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FOOTERS */
end_comment
begin_comment
comment|/* MMapped chunks need a second word of overhead ... */
end_comment
begin_define
DECL|macro|MMAP_CHUNK_OVERHEAD
define|#
directive|define
name|MMAP_CHUNK_OVERHEAD
value|(TWO_SIZE_T_SIZES)
end_define
begin_comment
comment|/* ... and additional padding for fake next-chunk at foot */
end_comment
begin_define
DECL|macro|MMAP_FOOT_PAD
define|#
directive|define
name|MMAP_FOOT_PAD
value|(FOUR_SIZE_T_SIZES)
end_define
begin_comment
comment|/* The smallest size we can malloc is an aligned minimal chunk */
end_comment
begin_define
DECL|macro|MIN_CHUNK_SIZE
define|#
directive|define
name|MIN_CHUNK_SIZE
define|\
value|((MCHUNK_SIZE + CHUNK_ALIGN_MASK)& ~CHUNK_ALIGN_MASK)
end_define
begin_comment
comment|/* conversion from malloc headers to user pointers, and back */
end_comment
begin_define
DECL|macro|chunk2mem
define|#
directive|define
name|chunk2mem
parameter_list|(
name|p
parameter_list|)
value|((void*)((char*)(p)       + TWO_SIZE_T_SIZES))
end_define
begin_define
DECL|macro|mem2chunk
define|#
directive|define
name|mem2chunk
parameter_list|(
name|mem
parameter_list|)
value|((mchunkptr)((char*)(mem) - TWO_SIZE_T_SIZES))
end_define
begin_comment
comment|/* chunk associated with aligned address A */
end_comment
begin_define
DECL|macro|align_as_chunk
define|#
directive|define
name|align_as_chunk
parameter_list|(
name|A
parameter_list|)
value|(mchunkptr)((A) + align_offset(chunk2mem(A)))
end_define
begin_comment
comment|/* Bounds on request (not chunk) sizes. */
end_comment
begin_define
DECL|macro|MAX_REQUEST
define|#
directive|define
name|MAX_REQUEST
value|((-MIN_CHUNK_SIZE)<< 2)
end_define
begin_define
DECL|macro|MIN_REQUEST
define|#
directive|define
name|MIN_REQUEST
value|(MIN_CHUNK_SIZE - CHUNK_OVERHEAD - SIZE_T_ONE)
end_define
begin_comment
comment|/* pad request bytes into a usable size */
end_comment
begin_define
DECL|macro|pad_request
define|#
directive|define
name|pad_request
parameter_list|(
name|req
parameter_list|)
define|\
value|(((req) + CHUNK_OVERHEAD + CHUNK_ALIGN_MASK)& ~CHUNK_ALIGN_MASK)
end_define
begin_comment
comment|/* pad request, checking for minimum (but not maximum) */
end_comment
begin_define
DECL|macro|request2size
define|#
directive|define
name|request2size
parameter_list|(
name|req
parameter_list|)
define|\
value|(((req)< MIN_REQUEST)? MIN_CHUNK_SIZE : pad_request(req))
end_define
begin_comment
comment|/* ------------------ Operations on head and foot fields ----------------- */
end_comment
begin_comment
comment|/*   The head field of a chunk is or'ed with PINUSE_BIT when previous   adjacent chunk in use, and or'ed with CINUSE_BIT if this chunk is in   use. If the chunk was obtained with mmap, the prev_foot field has   IS_MMAPPED_BIT set, otherwise holding the offset of the base of the   mmapped region to the base of the chunk.    FLAG4_BIT is not used by this malloc, but might be useful in extensions. */
end_comment
begin_define
DECL|macro|PINUSE_BIT
define|#
directive|define
name|PINUSE_BIT
value|(SIZE_T_ONE)
end_define
begin_define
DECL|macro|CINUSE_BIT
define|#
directive|define
name|CINUSE_BIT
value|(SIZE_T_TWO)
end_define
begin_define
DECL|macro|FLAG4_BIT
define|#
directive|define
name|FLAG4_BIT
value|(SIZE_T_FOUR)
end_define
begin_define
DECL|macro|INUSE_BITS
define|#
directive|define
name|INUSE_BITS
value|(PINUSE_BIT|CINUSE_BIT)
end_define
begin_define
DECL|macro|FLAG_BITS
define|#
directive|define
name|FLAG_BITS
value|(PINUSE_BIT|CINUSE_BIT|FLAG4_BIT)
end_define
begin_comment
comment|/* Head value for fenceposts */
end_comment
begin_define
DECL|macro|FENCEPOST_HEAD
define|#
directive|define
name|FENCEPOST_HEAD
value|(INUSE_BITS|SIZE_T_SIZE)
end_define
begin_comment
comment|/* extraction of fields from head words */
end_comment
begin_define
DECL|macro|cinuse
define|#
directive|define
name|cinuse
parameter_list|(
name|p
parameter_list|)
value|((p)->head& CINUSE_BIT)
end_define
begin_define
DECL|macro|pinuse
define|#
directive|define
name|pinuse
parameter_list|(
name|p
parameter_list|)
value|((p)->head& PINUSE_BIT)
end_define
begin_define
DECL|macro|chunksize
define|#
directive|define
name|chunksize
parameter_list|(
name|p
parameter_list|)
value|((p)->head& ~(FLAG_BITS))
end_define
begin_define
DECL|macro|clear_pinuse
define|#
directive|define
name|clear_pinuse
parameter_list|(
name|p
parameter_list|)
value|((p)->head&= ~PINUSE_BIT)
end_define
begin_define
DECL|macro|clear_cinuse
define|#
directive|define
name|clear_cinuse
parameter_list|(
name|p
parameter_list|)
value|((p)->head&= ~CINUSE_BIT)
end_define
begin_comment
comment|/* Treat space at ptr +/- offset as a chunk */
end_comment
begin_define
DECL|macro|chunk_plus_offset
define|#
directive|define
name|chunk_plus_offset
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
value|((mchunkptr)(((char*)(p)) + (s)))
end_define
begin_define
DECL|macro|chunk_minus_offset
define|#
directive|define
name|chunk_minus_offset
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
value|((mchunkptr)(((char*)(p)) - (s)))
end_define
begin_comment
comment|/* Ptr to next or previous physical malloc_chunk. */
end_comment
begin_define
DECL|macro|next_chunk
define|#
directive|define
name|next_chunk
parameter_list|(
name|p
parameter_list|)
value|((mchunkptr)( ((char*)(p)) + ((p)->head& ~FLAG_BITS)))
end_define
begin_define
DECL|macro|prev_chunk
define|#
directive|define
name|prev_chunk
parameter_list|(
name|p
parameter_list|)
value|((mchunkptr)( ((char*)(p)) - ((p)->prev_foot) ))
end_define
begin_comment
comment|/* extract next chunk's pinuse bit */
end_comment
begin_define
DECL|macro|next_pinuse
define|#
directive|define
name|next_pinuse
parameter_list|(
name|p
parameter_list|)
value|((next_chunk(p)->head)& PINUSE_BIT)
end_define
begin_comment
comment|/* Get/set size at footer */
end_comment
begin_define
DECL|macro|get_foot
define|#
directive|define
name|get_foot
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
value|(((mchunkptr)((char*)(p) + (s)))->prev_foot)
end_define
begin_define
DECL|macro|set_foot
define|#
directive|define
name|set_foot
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
value|(((mchunkptr)((char*)(p) + (s)))->prev_foot = (s))
end_define
begin_comment
comment|/* Set size, pinuse bit, and foot */
end_comment
begin_define
DECL|macro|set_size_and_pinuse_of_free_chunk
define|#
directive|define
name|set_size_and_pinuse_of_free_chunk
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
define|\
value|((p)->head = (s|PINUSE_BIT), set_foot(p, s))
end_define
begin_comment
comment|/* Set size, pinuse bit, foot, and clear next pinuse */
end_comment
begin_define
DECL|macro|set_free_with_pinuse
define|#
directive|define
name|set_free_with_pinuse
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
define|\
value|(clear_pinuse(n), set_size_and_pinuse_of_free_chunk(p, s))
end_define
begin_define
DECL|macro|is_mmapped
define|#
directive|define
name|is_mmapped
parameter_list|(
name|p
parameter_list|)
define|\
value|(!((p)->head& PINUSE_BIT)&& ((p)->prev_foot& IS_MMAPPED_BIT))
end_define
begin_comment
comment|/* Get the internal overhead associated with chunk p */
end_comment
begin_define
DECL|macro|overhead_for
define|#
directive|define
name|overhead_for
parameter_list|(
name|p
parameter_list|)
define|\
value|(is_mmapped(p)? MMAP_CHUNK_OVERHEAD : CHUNK_OVERHEAD)
end_define
begin_comment
comment|/* Return true if malloced space is not necessarily cleared */
end_comment
begin_if
if|#
directive|if
name|MMAP_CLEARS
end_if
begin_define
DECL|macro|calloc_must_clear
define|#
directive|define
name|calloc_must_clear
parameter_list|(
name|p
parameter_list|)
value|(!is_mmapped(p))
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* MMAP_CLEARS */
end_comment
begin_define
DECL|macro|calloc_must_clear
define|#
directive|define
name|calloc_must_clear
parameter_list|(
name|p
parameter_list|)
value|(1)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* MMAP_CLEARS */
end_comment
begin_comment
comment|/* ---------------------- Overlaid data structures ----------------------- */
end_comment
begin_comment
comment|/*   When chunks are not in use, they are treated as nodes of either   lists or trees.    "Small"  chunks are stored in circular doubly-linked lists, and look   like this:      chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+             |             Size of previous chunk                            |             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     `head:' |             Size of chunk, in bytes                         |P|       mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+             |             Forward pointer to next chunk in list             |             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+             |             Back pointer to previous chunk in list            |             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+             |             Unused space (may be 0 bytes long)                .             .                                                               .             .                                                               | nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     `foot:' |             Size of chunk, in bytes                           |             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    Larger chunks are kept in a form of bitwise digital trees (aka   tries) keyed on chunksizes.  Because malloc_tree_chunks are only for   free chunks greater than 256 bytes, their size doesn't impose any   constraints on user chunk sizes.  Each node looks like:      chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+             |             Size of previous chunk                            |             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     `head:' |             Size of chunk, in bytes                         |P|       mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+             |             Forward pointer to next chunk of same size        |             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+             |             Back pointer to previous chunk of same size       |             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+             |             Pointer to left child (child[0])                  |             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+             |             Pointer to right child (child[1])                 |             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+             |             Pointer to parent                                 |             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+             |             bin index of this chunk                           |             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+             |             Unused space                                      .             .                                                               | nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     `foot:' |             Size of chunk, in bytes                           |             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    Each tree holding treenodes is a tree of unique chunk sizes.  Chunks   of the same size are arranged in a circularly-linked list, with only   the oldest chunk (the next to be used, in our FIFO ordering)   actually in the tree.  (Tree members are distinguished by a non-null   parent pointer.)  If a chunk with the same size an an existing node   is inserted, it is linked off the existing node using pointers that   work in the same way as fd/bk pointers of small chunks.    Each tree contains a power of 2 sized range of chunk sizes (the   smallest is 0x100<= x< 0x180), which is is divided in half at each   tree level, with the chunks in the smaller half of the range (0x100<= x< 0x140 for the top nose) in the left subtree and the larger   half (0x140<= x< 0x180) in the right subtree.  This is, of course,   done by inspecting individual bits.    Using these rules, each node's left subtree contains all smaller   sizes than its right subtree.  However, the node at the root of each   subtree has no particular ordering relationship to either.  (The   dividing line between the subtree sizes is based on trie relation.)   If we remove the last chunk of a given size from the interior of the   tree, we need to replace it with a leaf node.  The tree ordering   rules permit a node to be replaced by any leaf below it.    The smallest chunk in a tree (a common operation in a best-fit   allocator) can be found by walking a path to the leftmost leaf in   the tree.  Unlike a usual binary tree, where we follow left child   pointers until we reach a null, here we follow the right child   pointer any time the left one is null, until we reach a leaf with   both child pointers null. The smallest chunk in the tree will be   somewhere along that path.    The worst case number of steps to add, find, or remove a node is   bounded by the number of bits differentiating chunks within   bins. Under current bin calculations, this ranges from 6 up to 21   (for 32 bit sizes) or up to 53 (for 64 bit sizes). The typical case   is of course much better. */
end_comment
begin_struct
DECL|struct|malloc_tree_chunk
struct|struct
name|malloc_tree_chunk
block|{
comment|/* The first four fields must be compatible with malloc_chunk */
DECL|member|prev_foot
name|size_t
name|prev_foot
decl_stmt|;
DECL|member|head
name|size_t
name|head
decl_stmt|;
DECL|member|fd
name|struct
name|malloc_tree_chunk
modifier|*
name|fd
decl_stmt|;
DECL|member|bk
name|struct
name|malloc_tree_chunk
modifier|*
name|bk
decl_stmt|;
DECL|member|child
name|struct
name|malloc_tree_chunk
modifier|*
name|child
index|[
literal|2
index|]
decl_stmt|;
DECL|member|parent
name|struct
name|malloc_tree_chunk
modifier|*
name|parent
decl_stmt|;
DECL|member|index
name|bindex_t
name|index
decl_stmt|;
block|}
struct|;
end_struct
begin_typedef
DECL|typedef|tchunk
typedef|typedef
name|struct
name|malloc_tree_chunk
name|tchunk
typedef|;
end_typedef
begin_typedef
DECL|typedef|tchunkptr
typedef|typedef
name|struct
name|malloc_tree_chunk
modifier|*
name|tchunkptr
typedef|;
end_typedef
begin_typedef
DECL|typedef|tbinptr
typedef|typedef
name|struct
name|malloc_tree_chunk
modifier|*
name|tbinptr
typedef|;
end_typedef
begin_comment
DECL|typedef|tbinptr
comment|/* The type of bins of trees */
end_comment
begin_comment
comment|/* A little helper macro for trees */
end_comment
begin_define
DECL|macro|leftmost_child
define|#
directive|define
name|leftmost_child
parameter_list|(
name|t
parameter_list|)
value|((t)->child[0] != 0? (t)->child[0] : (t)->child[1])
end_define
begin_comment
comment|/* ----------------------------- Segments -------------------------------- */
end_comment
begin_comment
comment|/*   Each malloc space may include non-contiguous segments, held in a   list headed by an embedded malloc_segment record representing the   top-most space. Segments also include flags holding properties of   the space. Large chunks that are directly allocated by mmap are not   included in this list. They are instead independently created and   destroyed without otherwise keeping track of them.    Segment management mainly comes into play for spaces allocated by   MMAP.  Any call to MMAP might or might not return memory that is   adjacent to an existing segment.  MORECORE normally contiguously   extends the current space, so this space is almost always adjacent,   which is simpler and faster to deal with. (This is why MORECORE is   used preferentially to MMAP when both are available -- see   sys_alloc.)  When allocating using MMAP, we don't use any of the   hinting mechanisms (inconsistently) supported in various   implementations of unix mmap, or distinguish reserving from   committing memory. Instead, we just ask for space, and exploit   contiguity when we get it.  It is probably possible to do   better than this on some systems, but no general scheme seems   to be significantly better.    Management entails a simpler variant of the consolidation scheme   used for chunks to reduce fragmentation -- new adjacent memory is   normally prepended or appended to an existing segment. However,   there are limitations compared to chunk consolidation that mostly   reflect the fact that segment processing is relatively infrequent   (occurring only when getting memory from system) and that we   don't expect to have huge numbers of segments:    * Segments are not indexed, so traversal requires linear scans.  (It     would be possible to index these, but is not worth the extra     overhead and complexity for most programs on most platforms.)   * New segments are only appended to old ones when holding top-most     memory; if they cannot be prepended to others, they are held in     different segments.    Except for the top-most segment of an mstate, each segment record   is kept at the tail of its segment. Segments are added by pushing   segment records onto the list headed by&mstate.seg for the   containing mstate.    Segment flags control allocation/merge/deallocation policies:   * If EXTERN_BIT set, then we did not allocate this segment,     and so should not try to deallocate or merge with others.     (This currently holds only for the initial segment passed     into create_mspace_with_base.)   * If IS_MMAPPED_BIT set, the segment may be merged with     other surrounding mmapped segments and trimmed/de-allocated     using munmap.   * If neither bit is set, then the segment was obtained using     MORECORE so can be merged with surrounding MORECORE'd segments     and deallocated/trimmed using MORECORE with negative arguments. */
end_comment
begin_struct
DECL|struct|malloc_segment
struct|struct
name|malloc_segment
block|{
DECL|member|base
name|char
modifier|*
name|base
decl_stmt|;
comment|/* base address */
DECL|member|size
name|size_t
name|size
decl_stmt|;
comment|/* allocated size */
DECL|member|next
name|struct
name|malloc_segment
modifier|*
name|next
decl_stmt|;
comment|/* ptr to next segment */
DECL|member|sflags
name|flag_t
name|sflags
decl_stmt|;
comment|/* mmap and extern flag */
block|}
struct|;
end_struct
begin_define
DECL|macro|is_mmapped_segment
define|#
directive|define
name|is_mmapped_segment
parameter_list|(
name|S
parameter_list|)
value|((S)->sflags& IS_MMAPPED_BIT)
end_define
begin_define
DECL|macro|is_extern_segment
define|#
directive|define
name|is_extern_segment
parameter_list|(
name|S
parameter_list|)
value|((S)->sflags& EXTERN_BIT)
end_define
begin_typedef
DECL|typedef|msegment
typedef|typedef
name|struct
name|malloc_segment
name|msegment
typedef|;
end_typedef
begin_typedef
DECL|typedef|msegmentptr
typedef|typedef
name|struct
name|malloc_segment
modifier|*
name|msegmentptr
typedef|;
end_typedef
begin_comment
comment|/* ---------------------------- malloc_state ----------------------------- */
end_comment
begin_comment
comment|/*    A malloc_state holds all of the bookkeeping for a space.    The main fields are:    Top     The topmost chunk of the currently active segment. Its size is     cached in topsize.  The actual size of topmost space is     topsize+TOP_FOOT_SIZE, which includes space reserved for adding     fenceposts and segment records if necessary when getting more     space from the system.  The size at which to autotrim top is     cached from mparams in trim_check, except that it is disabled if     an autotrim fails.    Designated victim (dv)     This is the preferred chunk for servicing small requests that     don't have exact fits.  It is normally the chunk split off most     recently to service another small request.  Its size is cached in     dvsize. The link fields of this chunk are not maintained since it     is not kept in a bin.    SmallBins     An array of bin headers for free chunks.  These bins hold chunks     with sizes less than MIN_LARGE_SIZE bytes. Each bin contains     chunks of all the same size, spaced 8 bytes apart.  To simplify     use in double-linked lists, each bin header acts as a malloc_chunk     pointing to the real first node, if it exists (else pointing to     itself).  This avoids special-casing for headers.  But to avoid     waste, we allocate only the fd/bk pointers of bins, and then use     repositioning tricks to treat these as the fields of a chunk.    TreeBins     Treebins are pointers to the roots of trees holding a range of     sizes. There are 2 equally spaced treebins for each power of two     from TREE_SHIFT to TREE_SHIFT+16. The last bin holds anything     larger.    Bin maps     There is one bit map for small bins ("smallmap") and one for     treebins ("treemap).  Each bin sets its bit when non-empty, and     clears the bit when empty.  Bit operations are then used to avoid     bin-by-bin searching -- nearly all "search" is done without ever     looking at bins that won't be selected.  The bit maps     conservatively use 32 bits per map word, even if on 64bit system.     For a good description of some of the bit-based techniques used     here, see Henry S. Warren Jr's book "Hacker's Delight" (and     supplement at http://hackersdelight.org/). Many of these are     intended to reduce the branchiness of paths through malloc etc, as     well as to reduce the number of memory locations read or written.    Segments     A list of segments headed by an embedded malloc_segment record     representing the initial space.    Address check support     The least_addr field is the least address ever obtained from     MORECORE or MMAP. Attempted frees and reallocs of any address less     than this are trapped (unless INSECURE is defined).    Magic tag     A cross-check field that should always hold same value as mparams.magic.    Flags     Bits recording whether to use MMAP, locks, or contiguous MORECORE    Statistics     Each space keeps track of current and maximum system memory     obtained via MORECORE or MMAP.    Trim support     Fields holding the amount of unused topmost memory that should trigger     timming, and a counter to force periodic scanning to release unused     non-topmost segments.    Locking     If USE_LOCKS is defined, the "mutex" lock is acquired and released     around every public call using this mspace.    Extension support     A void* pointer and a size_t field that can be used to help implement     extensions to this malloc. */
end_comment
begin_comment
comment|/* Bin types, widths and sizes */
end_comment
begin_define
DECL|macro|NSMALLBINS
define|#
directive|define
name|NSMALLBINS
value|(32U)
end_define
begin_define
DECL|macro|NTREEBINS
define|#
directive|define
name|NTREEBINS
value|(32U)
end_define
begin_define
DECL|macro|SMALLBIN_SHIFT
define|#
directive|define
name|SMALLBIN_SHIFT
value|(3U)
end_define
begin_define
DECL|macro|SMALLBIN_WIDTH
define|#
directive|define
name|SMALLBIN_WIDTH
value|(SIZE_T_ONE<< SMALLBIN_SHIFT)
end_define
begin_define
DECL|macro|TREEBIN_SHIFT
define|#
directive|define
name|TREEBIN_SHIFT
value|(8U)
end_define
begin_define
DECL|macro|MIN_LARGE_SIZE
define|#
directive|define
name|MIN_LARGE_SIZE
value|(SIZE_T_ONE<< TREEBIN_SHIFT)
end_define
begin_define
DECL|macro|MAX_SMALL_SIZE
define|#
directive|define
name|MAX_SMALL_SIZE
value|(MIN_LARGE_SIZE - SIZE_T_ONE)
end_define
begin_define
DECL|macro|MAX_SMALL_REQUEST
define|#
directive|define
name|MAX_SMALL_REQUEST
value|(MAX_SMALL_SIZE - CHUNK_ALIGN_MASK - CHUNK_OVERHEAD)
end_define
begin_struct
DECL|struct|malloc_state
struct|struct
name|malloc_state
block|{
DECL|member|smallmap
name|binmap_t
name|smallmap
decl_stmt|;
DECL|member|treemap
name|binmap_t
name|treemap
decl_stmt|;
DECL|member|dvsize
name|size_t
name|dvsize
decl_stmt|;
DECL|member|topsize
name|size_t
name|topsize
decl_stmt|;
DECL|member|least_addr
name|char
modifier|*
name|least_addr
decl_stmt|;
DECL|member|dv
name|mchunkptr
name|dv
decl_stmt|;
DECL|member|top
name|mchunkptr
name|top
decl_stmt|;
DECL|member|trim_check
name|size_t
name|trim_check
decl_stmt|;
DECL|member|release_checks
name|size_t
name|release_checks
decl_stmt|;
DECL|member|magic
name|size_t
name|magic
decl_stmt|;
DECL|member|smallbins
name|mchunkptr
name|smallbins
index|[
operator|(
name|NSMALLBINS
operator|+
literal|1
operator|)
operator|*
literal|2
index|]
decl_stmt|;
DECL|member|treebins
name|tbinptr
name|treebins
index|[
name|NTREEBINS
index|]
decl_stmt|;
DECL|member|footprint
name|size_t
name|footprint
decl_stmt|;
DECL|member|max_footprint
name|size_t
name|max_footprint
decl_stmt|;
DECL|member|mflags
name|flag_t
name|mflags
decl_stmt|;
if|#
directive|if
name|USE_LOCKS
DECL|member|mutex
name|MLOCK_T
name|mutex
decl_stmt|;
comment|/* locate lock among fields that rarely change */
endif|#
directive|endif
comment|/* USE_LOCKS */
DECL|member|seg
name|msegment
name|seg
decl_stmt|;
DECL|member|extp
name|void
modifier|*
name|extp
decl_stmt|;
comment|/* Unused but available for extensions */
DECL|member|exts
name|size_t
name|exts
decl_stmt|;
block|}
struct|;
end_struct
begin_typedef
DECL|typedef|mstate
typedef|typedef
name|struct
name|malloc_state
modifier|*
name|mstate
typedef|;
end_typedef
begin_comment
comment|/* ------------- Global malloc_state and malloc_params ------------------- */
end_comment
begin_comment
comment|/*   malloc_params holds global properties, including those that can be   dynamically set using mallopt. There is a single instance, mparams,   initialized in init_mparams. */
end_comment
begin_struct
DECL|struct|malloc_params
struct|struct
name|malloc_params
block|{
DECL|member|magic
name|size_t
name|magic
decl_stmt|;
DECL|member|page_size
name|size_t
name|page_size
decl_stmt|;
DECL|member|granularity
name|size_t
name|granularity
decl_stmt|;
DECL|member|mmap_threshold
name|size_t
name|mmap_threshold
decl_stmt|;
DECL|member|trim_threshold
name|size_t
name|trim_threshold
decl_stmt|;
DECL|member|default_mflags
name|flag_t
name|default_mflags
decl_stmt|;
block|}
struct|;
end_struct
begin_decl_stmt
DECL|variable|mparams
specifier|static
name|struct
name|malloc_params
name|mparams
decl_stmt|;
end_decl_stmt
begin_if
if|#
directive|if
operator|!
name|ONLY_MSPACES
end_if
begin_comment
comment|/* The global malloc_state used for all non-"mspace" calls */
end_comment
begin_decl_stmt
DECL|variable|_gm_
specifier|static
name|struct
name|malloc_state
name|_gm_
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|gm
define|#
directive|define
name|gm
value|(&_gm_)
end_define
begin_define
DECL|macro|is_global
define|#
directive|define
name|is_global
parameter_list|(
name|M
parameter_list|)
value|((M) ==&_gm_)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !ONLY_MSPACES */
end_comment
begin_define
DECL|macro|is_initialized
define|#
directive|define
name|is_initialized
parameter_list|(
name|M
parameter_list|)
value|((M)->top != 0)
end_define
begin_comment
comment|/* -------------------------- system alloc setup ------------------------- */
end_comment
begin_comment
comment|/* Operations on mflags */
end_comment
begin_define
DECL|macro|use_lock
define|#
directive|define
name|use_lock
parameter_list|(
name|M
parameter_list|)
value|((M)->mflags&   USE_LOCK_BIT)
end_define
begin_define
DECL|macro|enable_lock
define|#
directive|define
name|enable_lock
parameter_list|(
name|M
parameter_list|)
value|((M)->mflags |=  USE_LOCK_BIT)
end_define
begin_define
DECL|macro|disable_lock
define|#
directive|define
name|disable_lock
parameter_list|(
name|M
parameter_list|)
value|((M)->mflags&= ~USE_LOCK_BIT)
end_define
begin_define
DECL|macro|use_mmap
define|#
directive|define
name|use_mmap
parameter_list|(
name|M
parameter_list|)
value|((M)->mflags&   USE_MMAP_BIT)
end_define
begin_define
DECL|macro|enable_mmap
define|#
directive|define
name|enable_mmap
parameter_list|(
name|M
parameter_list|)
value|((M)->mflags |=  USE_MMAP_BIT)
end_define
begin_define
DECL|macro|disable_mmap
define|#
directive|define
name|disable_mmap
parameter_list|(
name|M
parameter_list|)
value|((M)->mflags&= ~USE_MMAP_BIT)
end_define
begin_define
DECL|macro|use_noncontiguous
define|#
directive|define
name|use_noncontiguous
parameter_list|(
name|M
parameter_list|)
value|((M)->mflags&   USE_NONCONTIGUOUS_BIT)
end_define
begin_define
DECL|macro|disable_contiguous
define|#
directive|define
name|disable_contiguous
parameter_list|(
name|M
parameter_list|)
value|((M)->mflags |=  USE_NONCONTIGUOUS_BIT)
end_define
begin_define
DECL|macro|set_lock
define|#
directive|define
name|set_lock
parameter_list|(
name|M
parameter_list|,
name|L
parameter_list|)
define|\
value|((M)->mflags = (L)?\   ((M)->mflags | USE_LOCK_BIT) :\   ((M)->mflags& ~USE_LOCK_BIT))
end_define
begin_comment
comment|/* page-align a size */
end_comment
begin_define
DECL|macro|page_align
define|#
directive|define
name|page_align
parameter_list|(
name|S
parameter_list|)
define|\
value|(((S) + (mparams.page_size - SIZE_T_ONE))& ~(mparams.page_size - SIZE_T_ONE))
end_define
begin_comment
comment|/* granularity-align a size */
end_comment
begin_define
DECL|macro|granularity_align
define|#
directive|define
name|granularity_align
parameter_list|(
name|S
parameter_list|)
define|\
value|(((S) + (mparams.granularity - SIZE_T_ONE))\& ~(mparams.granularity - SIZE_T_ONE))
end_define
begin_comment
comment|/* For mmap, use granularity alignment on windows, else page-align */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|WIN32
end_ifdef
begin_define
DECL|macro|mmap_align
define|#
directive|define
name|mmap_align
parameter_list|(
name|S
parameter_list|)
value|granularity_align(S)
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|mmap_align
define|#
directive|define
name|mmap_align
parameter_list|(
name|S
parameter_list|)
value|page_align(S)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|is_page_aligned
define|#
directive|define
name|is_page_aligned
parameter_list|(
name|S
parameter_list|)
define|\
value|(((size_t)(S)& (mparams.page_size - SIZE_T_ONE)) == 0)
end_define
begin_define
DECL|macro|is_granularity_aligned
define|#
directive|define
name|is_granularity_aligned
parameter_list|(
name|S
parameter_list|)
define|\
value|(((size_t)(S)& (mparams.granularity - SIZE_T_ONE)) == 0)
end_define
begin_comment
comment|/*  True if segment S holds address A */
end_comment
begin_define
DECL|macro|segment_holds
define|#
directive|define
name|segment_holds
parameter_list|(
name|S
parameter_list|,
name|A
parameter_list|)
define|\
value|((char*)(A)>= S->base&& (char*)(A)< S->base + S->size)
end_define
begin_comment
comment|/* Return segment holding given address */
end_comment
begin_function
DECL|function|segment_holding
specifier|static
name|msegmentptr
name|segment_holding
parameter_list|(
name|mstate
name|m
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|)
block|{
name|msegmentptr
name|sp
init|=
operator|&
name|m
operator|->
name|seg
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|addr
operator|>=
name|sp
operator|->
name|base
operator|&&
name|addr
operator|<
name|sp
operator|->
name|base
operator|+
name|sp
operator|->
name|size
condition|)
return|return
name|sp
return|;
if|if
condition|(
operator|(
name|sp
operator|=
name|sp
operator|->
name|next
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
block|}
end_function
begin_comment
comment|/* Return true if segment contains a segment link */
end_comment
begin_function
DECL|function|has_segment_link
specifier|static
name|int
name|has_segment_link
parameter_list|(
name|mstate
name|m
parameter_list|,
name|msegmentptr
name|ss
parameter_list|)
block|{
name|msegmentptr
name|sp
init|=
operator|&
name|m
operator|->
name|seg
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|sp
operator|>=
name|ss
operator|->
name|base
operator|&&
operator|(
name|char
operator|*
operator|)
name|sp
operator|<
name|ss
operator|->
name|base
operator|+
name|ss
operator|->
name|size
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|sp
operator|=
name|sp
operator|->
name|next
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|MORECORE_CANNOT_TRIM
end_ifndef
begin_define
DECL|macro|should_trim
define|#
directive|define
name|should_trim
parameter_list|(
name|M
parameter_list|,
name|s
parameter_list|)
value|((s)> (M)->trim_check)
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* MORECORE_CANNOT_TRIM */
end_comment
begin_define
DECL|macro|should_trim
define|#
directive|define
name|should_trim
parameter_list|(
name|M
parameter_list|,
name|s
parameter_list|)
value|(0)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* MORECORE_CANNOT_TRIM */
end_comment
begin_comment
comment|/*   TOP_FOOT_SIZE is padding at the end of a segment, including space   that may be needed to place segment records and fenceposts when new   noncontiguous segments are added. */
end_comment
begin_define
DECL|macro|TOP_FOOT_SIZE
define|#
directive|define
name|TOP_FOOT_SIZE
define|\
value|(align_offset(chunk2mem(0))+pad_request(sizeof(struct malloc_segment))+MIN_CHUNK_SIZE)
end_define
begin_comment
comment|/* -------------------------------  Hooks -------------------------------- */
end_comment
begin_comment
comment|/*   PREACTION should be defined to return 0 on success, and nonzero on   failure. If you are not using locking, you can redefine these to do   anything you like. */
end_comment
begin_if
if|#
directive|if
name|USE_LOCKS
end_if
begin_comment
comment|/* Ensure locks are initialized */
end_comment
begin_define
DECL|macro|GLOBALLY_INITIALIZE
define|#
directive|define
name|GLOBALLY_INITIALIZE
parameter_list|()
value|(mparams.page_size == 0&& init_mparams())
end_define
begin_define
DECL|macro|PREACTION
define|#
directive|define
name|PREACTION
parameter_list|(
name|M
parameter_list|)
value|((GLOBALLY_INITIALIZE() || use_lock(M))? ACQUIRE_LOCK(&(M)->mutex) : 0)
end_define
begin_define
DECL|macro|POSTACTION
define|#
directive|define
name|POSTACTION
parameter_list|(
name|M
parameter_list|)
value|{ if (use_lock(M)) RELEASE_LOCK(&(M)->mutex); }
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* USE_LOCKS */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|PREACTION
end_ifndef
begin_define
DECL|macro|PREACTION
define|#
directive|define
name|PREACTION
parameter_list|(
name|M
parameter_list|)
value|(0)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PREACTION */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|POSTACTION
end_ifndef
begin_define
DECL|macro|POSTACTION
define|#
directive|define
name|POSTACTION
parameter_list|(
name|M
parameter_list|)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* POSTACTION */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* USE_LOCKS */
end_comment
begin_comment
comment|/*   CORRUPTION_ERROR_ACTION is triggered upon detected bad addresses.   USAGE_ERROR_ACTION is triggered on detected bad frees and   reallocs. The argument p is an address that might have triggered the   fault. It is ignored by the two predefined actions, but might be   useful in custom actions that try to help diagnose errors. */
end_comment
begin_if
if|#
directive|if
name|PROCEED_ON_ERROR
end_if
begin_comment
comment|/* A count of the number of corruption errors causing resets */
end_comment
begin_decl_stmt
DECL|variable|malloc_corruption_error_count
name|int
name|malloc_corruption_error_count
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* default corruption action */
end_comment
begin_function_decl
specifier|static
name|void
name|reset_on_error
parameter_list|(
name|mstate
name|m
parameter_list|)
function_decl|;
end_function_decl
begin_define
DECL|macro|CORRUPTION_ERROR_ACTION
define|#
directive|define
name|CORRUPTION_ERROR_ACTION
parameter_list|(
name|m
parameter_list|)
value|reset_on_error(m)
end_define
begin_define
DECL|macro|USAGE_ERROR_ACTION
define|#
directive|define
name|USAGE_ERROR_ACTION
parameter_list|(
name|m
parameter_list|,
name|p
parameter_list|)
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* PROCEED_ON_ERROR */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|CORRUPTION_ERROR_ACTION
end_ifndef
begin_define
DECL|macro|CORRUPTION_ERROR_ACTION
define|#
directive|define
name|CORRUPTION_ERROR_ACTION
parameter_list|(
name|m
parameter_list|)
value|ABORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* CORRUPTION_ERROR_ACTION */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|USAGE_ERROR_ACTION
end_ifndef
begin_define
DECL|macro|USAGE_ERROR_ACTION
define|#
directive|define
name|USAGE_ERROR_ACTION
parameter_list|(
name|m
parameter_list|,
name|p
parameter_list|)
value|ABORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* USAGE_ERROR_ACTION */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PROCEED_ON_ERROR */
end_comment
begin_comment
comment|/* -------------------------- Debugging setup ---------------------------- */
end_comment
begin_if
if|#
directive|if
operator|!
name|DEBUG
end_if
begin_define
DECL|macro|check_free_chunk
define|#
directive|define
name|check_free_chunk
parameter_list|(
name|M
parameter_list|,
name|P
parameter_list|)
end_define
begin_define
DECL|macro|check_inuse_chunk
define|#
directive|define
name|check_inuse_chunk
parameter_list|(
name|M
parameter_list|,
name|P
parameter_list|)
end_define
begin_define
DECL|macro|check_malloced_chunk
define|#
directive|define
name|check_malloced_chunk
parameter_list|(
name|M
parameter_list|,
name|P
parameter_list|,
name|N
parameter_list|)
end_define
begin_define
DECL|macro|check_mmapped_chunk
define|#
directive|define
name|check_mmapped_chunk
parameter_list|(
name|M
parameter_list|,
name|P
parameter_list|)
end_define
begin_define
DECL|macro|check_malloc_state
define|#
directive|define
name|check_malloc_state
parameter_list|(
name|M
parameter_list|)
end_define
begin_define
DECL|macro|check_top_chunk
define|#
directive|define
name|check_top_chunk
parameter_list|(
name|M
parameter_list|,
name|P
parameter_list|)
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* DEBUG */
end_comment
begin_define
DECL|macro|check_free_chunk
define|#
directive|define
name|check_free_chunk
parameter_list|(
name|M
parameter_list|,
name|P
parameter_list|)
value|do_check_free_chunk(M,P)
end_define
begin_define
DECL|macro|check_inuse_chunk
define|#
directive|define
name|check_inuse_chunk
parameter_list|(
name|M
parameter_list|,
name|P
parameter_list|)
value|do_check_inuse_chunk(M,P)
end_define
begin_define
DECL|macro|check_top_chunk
define|#
directive|define
name|check_top_chunk
parameter_list|(
name|M
parameter_list|,
name|P
parameter_list|)
value|do_check_top_chunk(M,P)
end_define
begin_define
DECL|macro|check_malloced_chunk
define|#
directive|define
name|check_malloced_chunk
parameter_list|(
name|M
parameter_list|,
name|P
parameter_list|,
name|N
parameter_list|)
value|do_check_malloced_chunk(M,P,N)
end_define
begin_define
DECL|macro|check_mmapped_chunk
define|#
directive|define
name|check_mmapped_chunk
parameter_list|(
name|M
parameter_list|,
name|P
parameter_list|)
value|do_check_mmapped_chunk(M,P)
end_define
begin_define
DECL|macro|check_malloc_state
define|#
directive|define
name|check_malloc_state
parameter_list|(
name|M
parameter_list|)
value|do_check_malloc_state(M)
end_define
begin_function_decl
specifier|static
name|void
name|do_check_any_chunk
parameter_list|(
name|mstate
name|m
parameter_list|,
name|mchunkptr
name|p
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|do_check_top_chunk
parameter_list|(
name|mstate
name|m
parameter_list|,
name|mchunkptr
name|p
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|do_check_mmapped_chunk
parameter_list|(
name|mstate
name|m
parameter_list|,
name|mchunkptr
name|p
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|do_check_inuse_chunk
parameter_list|(
name|mstate
name|m
parameter_list|,
name|mchunkptr
name|p
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|do_check_free_chunk
parameter_list|(
name|mstate
name|m
parameter_list|,
name|mchunkptr
name|p
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|do_check_malloced_chunk
parameter_list|(
name|mstate
name|m
parameter_list|,
name|void
modifier|*
name|mem
parameter_list|,
name|size_t
name|s
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|do_check_tree
parameter_list|(
name|mstate
name|m
parameter_list|,
name|tchunkptr
name|t
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|do_check_treebin
parameter_list|(
name|mstate
name|m
parameter_list|,
name|bindex_t
name|i
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|do_check_smallbin
parameter_list|(
name|mstate
name|m
parameter_list|,
name|bindex_t
name|i
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|do_check_malloc_state
parameter_list|(
name|mstate
name|m
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|bin_find
parameter_list|(
name|mstate
name|m
parameter_list|,
name|mchunkptr
name|x
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|size_t
name|traverse_and_check
parameter_list|(
name|mstate
name|m
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* DEBUG */
end_comment
begin_comment
comment|/* ---------------------------- Indexing Bins ---------------------------- */
end_comment
begin_define
DECL|macro|is_small
define|#
directive|define
name|is_small
parameter_list|(
name|s
parameter_list|)
value|(((s)>> SMALLBIN_SHIFT)< NSMALLBINS)
end_define
begin_define
DECL|macro|small_index
define|#
directive|define
name|small_index
parameter_list|(
name|s
parameter_list|)
value|((s)>> SMALLBIN_SHIFT)
end_define
begin_define
DECL|macro|small_index2size
define|#
directive|define
name|small_index2size
parameter_list|(
name|i
parameter_list|)
value|((i)<< SMALLBIN_SHIFT)
end_define
begin_define
DECL|macro|MIN_SMALL_INDEX
define|#
directive|define
name|MIN_SMALL_INDEX
value|(small_index(MIN_CHUNK_SIZE))
end_define
begin_comment
comment|/* addressing by index. See above about smallbin repositioning */
end_comment
begin_define
DECL|macro|smallbin_at
define|#
directive|define
name|smallbin_at
parameter_list|(
name|M
parameter_list|,
name|i
parameter_list|)
value|((sbinptr)((char*)&((M)->smallbins[(i)<<1])))
end_define
begin_define
DECL|macro|treebin_at
define|#
directive|define
name|treebin_at
parameter_list|(
name|M
parameter_list|,
name|i
parameter_list|)
value|(&((M)->treebins[i]))
end_define
begin_comment
comment|/* assign tree index for size S to variable I */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__x86_64__
argument_list|)
operator|)
end_if
begin_define
DECL|macro|compute_tree_index
define|#
directive|define
name|compute_tree_index
parameter_list|(
name|S
parameter_list|,
name|I
parameter_list|)
define|\
value|{\   unsigned int X = S>> TREEBIN_SHIFT;\   if (X == 0)\     I = 0;\   else if (X> 0xFFFF)\     I = NTREEBINS-1;\   else {\     unsigned int K;\     __asm__("bsrl\t%1, %0\n\t" : "=r" (K) : "g"  (X));\     I =  (bindex_t)((K<< 1) + ((S>> (K + (TREEBIN_SHIFT-1))& 1)));\   }\ }
end_define
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|_MSC_VER
operator|>=
literal|1300
end_elif
begin_define
DECL|macro|compute_tree_index
define|#
directive|define
name|compute_tree_index
parameter_list|(
name|S
parameter_list|,
name|I
parameter_list|)
define|\
value|{\   size_t X = S>> TREEBIN_SHIFT;\   if (X == 0)\     I = 0;\   else if (X> 0xFFFF)\     I = NTREEBINS-1;\   else {\     unsigned int K;\     _BitScanReverse((DWORD *)&K, X);\     I =  (bindex_t)((K<< 1) + ((S>> (K + (TREEBIN_SHIFT-1))& 1)));\   }\ }
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* GNUC */
end_comment
begin_define
DECL|macro|compute_tree_index
define|#
directive|define
name|compute_tree_index
parameter_list|(
name|S
parameter_list|,
name|I
parameter_list|)
define|\
value|{\   size_t X = S>> TREEBIN_SHIFT;\   if (X == 0)\     I = 0;\   else if (X> 0xFFFF)\     I = NTREEBINS-1;\   else {\     unsigned int Y = (unsigned int)X;\     unsigned int N = ((Y - 0x100)>> 16)& 8;\     unsigned int K = (((Y<<= N) - 0x1000)>> 16)& 4;\     N += K;\     N += K = (((Y<<= K) - 0x4000)>> 16)& 2;\     K = 14 - N + ((Y<<= K)>> 15);\     I = (K<< 1) + ((S>> (K + (TREEBIN_SHIFT-1))& 1));\   }\ }
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* GNUC */
end_comment
begin_comment
comment|/* Bit representing maximum resolved size in a treebin at i */
end_comment
begin_define
DECL|macro|bit_for_tree_index
define|#
directive|define
name|bit_for_tree_index
parameter_list|(
name|i
parameter_list|)
define|\
value|(i == NTREEBINS-1)? (SIZE_T_BITSIZE-1) : (((i)>> 1) + TREEBIN_SHIFT - 2)
end_define
begin_comment
comment|/* Shift placing maximum resolved bit in a treebin at i as sign bit */
end_comment
begin_define
DECL|macro|leftshift_for_tree_index
define|#
directive|define
name|leftshift_for_tree_index
parameter_list|(
name|i
parameter_list|)
define|\
value|((i == NTREEBINS-1)? 0 : \     ((SIZE_T_BITSIZE-SIZE_T_ONE) - (((i)>> 1) + TREEBIN_SHIFT - 2)))
end_define
begin_comment
comment|/* The size of the smallest chunk held in bin with index i */
end_comment
begin_define
DECL|macro|minsize_for_tree_index
define|#
directive|define
name|minsize_for_tree_index
parameter_list|(
name|i
parameter_list|)
define|\
value|((SIZE_T_ONE<< (((i)>> 1) + TREEBIN_SHIFT)) |  \    (((size_t)((i)& SIZE_T_ONE))<< (((i)>> 1) + TREEBIN_SHIFT - 1)))
end_define
begin_comment
comment|/* ------------------------ Operations on bin maps ----------------------- */
end_comment
begin_comment
comment|/* bit corresponding to given index */
end_comment
begin_define
DECL|macro|idx2bit
define|#
directive|define
name|idx2bit
parameter_list|(
name|i
parameter_list|)
value|((binmap_t)(1)<< (i))
end_define
begin_comment
comment|/* Mark/Clear bits with given index */
end_comment
begin_define
DECL|macro|mark_smallmap
define|#
directive|define
name|mark_smallmap
parameter_list|(
name|M
parameter_list|,
name|i
parameter_list|)
value|((M)->smallmap |=  idx2bit(i))
end_define
begin_define
DECL|macro|clear_smallmap
define|#
directive|define
name|clear_smallmap
parameter_list|(
name|M
parameter_list|,
name|i
parameter_list|)
value|((M)->smallmap&= ~idx2bit(i))
end_define
begin_define
DECL|macro|smallmap_is_marked
define|#
directive|define
name|smallmap_is_marked
parameter_list|(
name|M
parameter_list|,
name|i
parameter_list|)
value|((M)->smallmap&   idx2bit(i))
end_define
begin_define
DECL|macro|mark_treemap
define|#
directive|define
name|mark_treemap
parameter_list|(
name|M
parameter_list|,
name|i
parameter_list|)
value|((M)->treemap  |=  idx2bit(i))
end_define
begin_define
DECL|macro|clear_treemap
define|#
directive|define
name|clear_treemap
parameter_list|(
name|M
parameter_list|,
name|i
parameter_list|)
value|((M)->treemap&= ~idx2bit(i))
end_define
begin_define
DECL|macro|treemap_is_marked
define|#
directive|define
name|treemap_is_marked
parameter_list|(
name|M
parameter_list|,
name|i
parameter_list|)
value|((M)->treemap&   idx2bit(i))
end_define
begin_comment
comment|/* index corresponding to given bit */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__x86_64__
argument_list|)
operator|)
end_if
begin_define
DECL|macro|compute_bit2idx
define|#
directive|define
name|compute_bit2idx
parameter_list|(
name|X
parameter_list|,
name|I
parameter_list|)
define|\
value|{\   unsigned int J;\   __asm__("bsfl\t%1, %0\n\t" : "=r" (J) : "g" (X));\   I = (bindex_t)J;\ }
end_define
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|_MSC_VER
operator|>=
literal|1300
end_elif
begin_define
DECL|macro|compute_bit2idx
define|#
directive|define
name|compute_bit2idx
parameter_list|(
name|X
parameter_list|,
name|I
parameter_list|)
define|\
value|{\   unsigned int J;\   _BitScanForward((DWORD *)&J, X);\   I = (bindex_t)J;\ }
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* GNUC */
end_comment
begin_if
if|#
directive|if
name|USE_BUILTIN_FFS
end_if
begin_define
DECL|macro|compute_bit2idx
define|#
directive|define
name|compute_bit2idx
parameter_list|(
name|X
parameter_list|,
name|I
parameter_list|)
value|I = ffs(X)-1
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* USE_BUILTIN_FFS */
end_comment
begin_define
DECL|macro|compute_bit2idx
define|#
directive|define
name|compute_bit2idx
parameter_list|(
name|X
parameter_list|,
name|I
parameter_list|)
define|\
value|{\   unsigned int Y = X - 1;\   unsigned int K = Y>> (16-4)& 16;\   unsigned int N = K;        Y>>= K;\   N += K = Y>> (8-3)&  8;  Y>>= K;\   N += K = Y>> (4-2)&  4;  Y>>= K;\   N += K = Y>> (2-1)&  2;  Y>>= K;\   N += K = Y>> (1-0)&  1;  Y>>= K;\   I = (bindex_t)(N + Y);\ }
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* USE_BUILTIN_FFS */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* GNUC */
end_comment
begin_comment
comment|/* isolate the least set bit of a bitmap */
end_comment
begin_define
DECL|macro|least_bit
define|#
directive|define
name|least_bit
parameter_list|(
name|x
parameter_list|)
value|((x)& -(x))
end_define
begin_comment
comment|/* mask with all bits to left of least bit of x on */
end_comment
begin_define
DECL|macro|left_bits
define|#
directive|define
name|left_bits
parameter_list|(
name|x
parameter_list|)
value|((x<<1) | -(x<<1))
end_define
begin_comment
comment|/* mask with all bits to left of or equal to least bit of x on */
end_comment
begin_define
DECL|macro|same_or_left_bits
define|#
directive|define
name|same_or_left_bits
parameter_list|(
name|x
parameter_list|)
value|((x) | -(x))
end_define
begin_comment
comment|/* ----------------------- Runtime Check Support ------------------------- */
end_comment
begin_comment
comment|/*   For security, the main invariant is that malloc/free/etc never   writes to a static address other than malloc_state, unless static   malloc_state itself has been corrupted, which cannot occur via   malloc (because of these checks). In essence this means that we   believe all pointers, sizes, maps etc held in malloc_state, but   check all of those linked or offsetted from other embedded data   structures.  These checks are interspersed with main code in a way   that tends to minimize their run-time cost.    When FOOTERS is defined, in addition to range checking, we also   verify footer fields of inuse chunks, which can be used guarantee   that the mstate controlling malloc/free is intact.  This is a   streamlined version of the approach described by William Robertson   et al in "Run-time Detection of Heap-based Overflows" LISA'03   http://www.usenix.org/events/lisa03/tech/robertson.html The footer   of an inuse chunk holds the xor of its mstate and a random seed,   that is checked upon calls to free() and realloc().  This is   (probablistically) unguessable from outside the program, but can be   computed by any code successfully malloc'ing any chunk, so does not   itself provide protection against code that has already broken   security through some other means.  Unlike Robertson et al, we   always dynamically check addresses of all offset chunks (previous,   next, etc). This turns out to be cheaper than relying on hashes. */
end_comment
begin_if
if|#
directive|if
operator|!
name|INSECURE
end_if
begin_comment
comment|/* Check if address a is at least as high as any from MORECORE or MMAP */
end_comment
begin_define
DECL|macro|ok_address
define|#
directive|define
name|ok_address
parameter_list|(
name|M
parameter_list|,
name|a
parameter_list|)
value|((char*)(a)>= (M)->least_addr)
end_define
begin_comment
comment|/* Check if address of next chunk n is higher than base chunk p */
end_comment
begin_define
DECL|macro|ok_next
define|#
directive|define
name|ok_next
parameter_list|(
name|p
parameter_list|,
name|n
parameter_list|)
value|((char*)(p)< (char*)(n))
end_define
begin_comment
comment|/* Check if p has its cinuse bit on */
end_comment
begin_define
DECL|macro|ok_cinuse
define|#
directive|define
name|ok_cinuse
parameter_list|(
name|p
parameter_list|)
value|cinuse(p)
end_define
begin_comment
comment|/* Check if p has its pinuse bit on */
end_comment
begin_define
DECL|macro|ok_pinuse
define|#
directive|define
name|ok_pinuse
parameter_list|(
name|p
parameter_list|)
value|pinuse(p)
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !INSECURE */
end_comment
begin_define
DECL|macro|ok_address
define|#
directive|define
name|ok_address
parameter_list|(
name|M
parameter_list|,
name|a
parameter_list|)
value|(1)
end_define
begin_define
DECL|macro|ok_next
define|#
directive|define
name|ok_next
parameter_list|(
name|b
parameter_list|,
name|n
parameter_list|)
value|(1)
end_define
begin_define
DECL|macro|ok_cinuse
define|#
directive|define
name|ok_cinuse
parameter_list|(
name|p
parameter_list|)
value|(1)
end_define
begin_define
DECL|macro|ok_pinuse
define|#
directive|define
name|ok_pinuse
parameter_list|(
name|p
parameter_list|)
value|(1)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !INSECURE */
end_comment
begin_if
if|#
directive|if
operator|(
name|FOOTERS
operator|&&
operator|!
name|INSECURE
operator|)
end_if
begin_comment
comment|/* Check if (alleged) mstate m has expected magic field */
end_comment
begin_define
DECL|macro|ok_magic
define|#
directive|define
name|ok_magic
parameter_list|(
name|M
parameter_list|)
value|((M)->magic == mparams.magic)
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* (FOOTERS&& !INSECURE) */
end_comment
begin_define
DECL|macro|ok_magic
define|#
directive|define
name|ok_magic
parameter_list|(
name|M
parameter_list|)
value|(1)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* (FOOTERS&& !INSECURE) */
end_comment
begin_comment
comment|/* In gcc, use __builtin_expect to minimize impact of checks */
end_comment
begin_if
if|#
directive|if
operator|!
name|INSECURE
end_if
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|__GNUC__
operator|>=
literal|3
end_if
begin_define
DECL|macro|RTCHECK
define|#
directive|define
name|RTCHECK
parameter_list|(
name|e
parameter_list|)
value|__builtin_expect(e, 1)
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* GNUC */
end_comment
begin_define
DECL|macro|RTCHECK
define|#
directive|define
name|RTCHECK
parameter_list|(
name|e
parameter_list|)
value|(e)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* GNUC */
end_comment
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !INSECURE */
end_comment
begin_define
DECL|macro|RTCHECK
define|#
directive|define
name|RTCHECK
parameter_list|(
name|e
parameter_list|)
value|(1)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !INSECURE */
end_comment
begin_comment
comment|/* macros to set up inuse chunks with or without footers */
end_comment
begin_if
if|#
directive|if
operator|!
name|FOOTERS
end_if
begin_define
DECL|macro|mark_inuse_foot
define|#
directive|define
name|mark_inuse_foot
parameter_list|(
name|M
parameter_list|,
name|p
parameter_list|,
name|s
parameter_list|)
end_define
begin_comment
comment|/* Set cinuse bit and pinuse bit of next chunk */
end_comment
begin_define
DECL|macro|set_inuse
define|#
directive|define
name|set_inuse
parameter_list|(
name|M
parameter_list|,
name|p
parameter_list|,
name|s
parameter_list|)
define|\
value|((p)->head = (((p)->head& PINUSE_BIT)|s|CINUSE_BIT),\   ((mchunkptr)(((char*)(p)) + (s)))->head |= PINUSE_BIT)
end_define
begin_comment
comment|/* Set cinuse and pinuse of this chunk and pinuse of next chunk */
end_comment
begin_define
DECL|macro|set_inuse_and_pinuse
define|#
directive|define
name|set_inuse_and_pinuse
parameter_list|(
name|M
parameter_list|,
name|p
parameter_list|,
name|s
parameter_list|)
define|\
value|((p)->head = (s|PINUSE_BIT|CINUSE_BIT),\   ((mchunkptr)(((char*)(p)) + (s)))->head |= PINUSE_BIT)
end_define
begin_comment
comment|/* Set size, cinuse and pinuse bit of this chunk */
end_comment
begin_define
DECL|macro|set_size_and_pinuse_of_inuse_chunk
define|#
directive|define
name|set_size_and_pinuse_of_inuse_chunk
parameter_list|(
name|M
parameter_list|,
name|p
parameter_list|,
name|s
parameter_list|)
define|\
value|((p)->head = (s|PINUSE_BIT|CINUSE_BIT))
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* FOOTERS */
end_comment
begin_comment
comment|/* Set foot of inuse chunk to be xor of mstate and seed */
end_comment
begin_define
DECL|macro|mark_inuse_foot
define|#
directive|define
name|mark_inuse_foot
parameter_list|(
name|M
parameter_list|,
name|p
parameter_list|,
name|s
parameter_list|)
define|\
value|(((mchunkptr)((char*)(p) + (s)))->prev_foot = ((size_t)(M) ^ mparams.magic))
end_define
begin_define
DECL|macro|get_mstate_for
define|#
directive|define
name|get_mstate_for
parameter_list|(
name|p
parameter_list|)
define|\
value|((mstate)(((mchunkptr)((char*)(p) +\     (chunksize(p))))->prev_foot ^ mparams.magic))
end_define
begin_define
DECL|macro|set_inuse
define|#
directive|define
name|set_inuse
parameter_list|(
name|M
parameter_list|,
name|p
parameter_list|,
name|s
parameter_list|)
define|\
value|((p)->head = (((p)->head& PINUSE_BIT)|s|CINUSE_BIT),\   (((mchunkptr)(((char*)(p)) + (s)))->head |= PINUSE_BIT), \   mark_inuse_foot(M,p,s))
end_define
begin_define
DECL|macro|set_inuse_and_pinuse
define|#
directive|define
name|set_inuse_and_pinuse
parameter_list|(
name|M
parameter_list|,
name|p
parameter_list|,
name|s
parameter_list|)
define|\
value|((p)->head = (s|PINUSE_BIT|CINUSE_BIT),\   (((mchunkptr)(((char*)(p)) + (s)))->head |= PINUSE_BIT),\  mark_inuse_foot(M,p,s))
end_define
begin_define
DECL|macro|set_size_and_pinuse_of_inuse_chunk
define|#
directive|define
name|set_size_and_pinuse_of_inuse_chunk
parameter_list|(
name|M
parameter_list|,
name|p
parameter_list|,
name|s
parameter_list|)
define|\
value|((p)->head = (s|PINUSE_BIT|CINUSE_BIT),\   mark_inuse_foot(M, p, s))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !FOOTERS */
end_comment
begin_comment
comment|/* ---------------------------- setting mparams -------------------------- */
end_comment
begin_comment
comment|/* Initialize mparams */
end_comment
begin_function
DECL|function|init_mparams
specifier|static
name|int
name|init_mparams
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|mparams
operator|.
name|page_size
operator|==
literal|0
condition|)
block|{
name|size_t
name|s
decl_stmt|;
name|mparams
operator|.
name|mmap_threshold
operator|=
name|DEFAULT_MMAP_THRESHOLD
expr_stmt|;
name|mparams
operator|.
name|trim_threshold
operator|=
name|DEFAULT_TRIM_THRESHOLD
expr_stmt|;
if|#
directive|if
name|MORECORE_CONTIGUOUS
name|mparams
operator|.
name|default_mflags
operator|=
name|USE_LOCK_BIT
operator||
name|USE_MMAP_BIT
expr_stmt|;
else|#
directive|else
comment|/* MORECORE_CONTIGUOUS */
name|mparams
operator|.
name|default_mflags
operator|=
name|USE_LOCK_BIT
operator||
name|USE_MMAP_BIT
operator||
name|USE_NONCONTIGUOUS_BIT
expr_stmt|;
endif|#
directive|endif
comment|/* MORECORE_CONTIGUOUS */
if|#
directive|if
operator|(
name|FOOTERS
operator|&&
operator|!
name|INSECURE
operator|)
block|{
if|#
directive|if
name|USE_DEV_RANDOM
name|int
name|fd
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
index|]
decl_stmt|;
comment|/* Try to use /dev/urandom, else fall back on using time */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/urandom"
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
block|{
name|s
operator|=
operator|*
operator|(
operator|(
name|size_t
operator|*
operator|)
name|buf
operator|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* USE_DEV_RANDOM */
name|s
operator|=
call|(
name|size_t
call|)
argument_list|(
name|time
argument_list|(
literal|0
argument_list|)
operator|^
operator|(
name|size_t
operator|)
literal|0x55555555U
argument_list|)
expr_stmt|;
name|s
operator||=
operator|(
name|size_t
operator|)
literal|8U
expr_stmt|;
comment|/* ensure nonzero */
name|s
operator|&=
operator|~
operator|(
name|size_t
operator|)
literal|7U
expr_stmt|;
comment|/* improve chances of fault for bad values */
block|}
else|#
directive|else
comment|/* (FOOTERS&& !INSECURE) */
name|s
operator|=
operator|(
name|size_t
operator|)
literal|0x58585858U
expr_stmt|;
endif|#
directive|endif
comment|/* (FOOTERS&& !INSECURE) */
name|ACQUIRE_MAGIC_INIT_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|mparams
operator|.
name|magic
operator|==
literal|0
condition|)
block|{
name|mparams
operator|.
name|magic
operator|=
name|s
expr_stmt|;
if|#
directive|if
operator|!
name|ONLY_MSPACES
comment|/* Set up lock for main malloc area */
name|INITIAL_LOCK
argument_list|(
operator|&
name|gm
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|gm
operator|->
name|mflags
operator|=
name|mparams
operator|.
name|default_mflags
expr_stmt|;
endif|#
directive|endif
block|}
name|RELEASE_MAGIC_INIT_LOCK
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|WIN32
name|mparams
operator|.
name|page_size
operator|=
name|malloc_getpagesize
expr_stmt|;
name|mparams
operator|.
name|granularity
operator|=
operator|(
operator|(
name|DEFAULT_GRANULARITY
operator|!=
literal|0
operator|)
condition|?
name|DEFAULT_GRANULARITY
else|:
name|mparams
operator|.
name|page_size
operator|)
expr_stmt|;
else|#
directive|else
comment|/* WIN32 */
block|{
name|SYSTEM_INFO
name|system_info
decl_stmt|;
name|GetSystemInfo
argument_list|(
operator|&
name|system_info
argument_list|)
expr_stmt|;
name|mparams
operator|.
name|page_size
operator|=
name|system_info
operator|.
name|dwPageSize
expr_stmt|;
name|mparams
operator|.
name|granularity
operator|=
name|system_info
operator|.
name|dwAllocationGranularity
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* WIN32 */
comment|/* Sanity-check configuration:        size_t must be unsigned and as wide as pointer type.        ints must be at least 4 bytes.        alignment must be at least 8.        Alignment, min chunk size, and page size must all be powers of 2.     */
if|if
condition|(
operator|(
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
operator|||
operator|(
name|MAX_SIZE_T
operator|<
name|MIN_CHUNK_SIZE
operator|)
operator|||
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|<
literal|4
operator|)
operator|||
operator|(
name|MALLOC_ALIGNMENT
operator|<
operator|(
name|size_t
operator|)
literal|8U
operator|)
operator|||
operator|(
operator|(
name|MALLOC_ALIGNMENT
operator|&
operator|(
name|MALLOC_ALIGNMENT
operator|-
name|SIZE_T_ONE
operator|)
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|MCHUNK_SIZE
operator|&
operator|(
name|MCHUNK_SIZE
operator|-
name|SIZE_T_ONE
operator|)
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|mparams
operator|.
name|granularity
operator|&
operator|(
name|mparams
operator|.
name|granularity
operator|-
name|SIZE_T_ONE
operator|)
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|mparams
operator|.
name|page_size
operator|&
operator|(
name|mparams
operator|.
name|page_size
operator|-
name|SIZE_T_ONE
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
name|ABORT
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* support for mallopt */
end_comment
begin_function
DECL|function|change_mparam
specifier|static
name|int
name|change_mparam
parameter_list|(
name|int
name|param_number
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|size_t
name|val
init|=
operator|(
name|size_t
operator|)
name|value
decl_stmt|;
name|init_mparams
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|param_number
condition|)
block|{
case|case
name|M_TRIM_THRESHOLD
case|:
name|mparams
operator|.
name|trim_threshold
operator|=
name|val
expr_stmt|;
return|return
literal|1
return|;
case|case
name|M_GRANULARITY
case|:
if|if
condition|(
name|val
operator|>=
name|mparams
operator|.
name|page_size
operator|&&
operator|(
operator|(
name|val
operator|&
operator|(
name|val
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|mparams
operator|.
name|granularity
operator|=
name|val
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
case|case
name|M_MMAP_THRESHOLD
case|:
name|mparams
operator|.
name|mmap_threshold
operator|=
name|val
expr_stmt|;
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function
begin_if
if|#
directive|if
name|DEBUG
end_if
begin_comment
comment|/* ------------------------- Debugging Support --------------------------- */
end_comment
begin_comment
comment|/* Check properties of any chunk, whether free, inuse, mmapped etc  */
end_comment
begin_function
DECL|function|do_check_any_chunk
specifier|static
name|void
name|do_check_any_chunk
parameter_list|(
name|mstate
name|m
parameter_list|,
name|mchunkptr
name|p
parameter_list|)
block|{
name|assert
argument_list|(
operator|(
name|is_aligned
argument_list|(
name|chunk2mem
argument_list|(
name|p
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|p
operator|->
name|head
operator|==
name|FENCEPOST_HEAD
operator|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ok_address
argument_list|(
name|m
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Check properties of top chunk */
end_comment
begin_function
DECL|function|do_check_top_chunk
specifier|static
name|void
name|do_check_top_chunk
parameter_list|(
name|mstate
name|m
parameter_list|,
name|mchunkptr
name|p
parameter_list|)
block|{
name|msegmentptr
name|sp
init|=
name|segment_holding
argument_list|(
name|m
argument_list|,
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
decl_stmt|;
name|size_t
name|sz
init|=
name|p
operator|->
name|head
operator|&
operator|~
name|INUSE_BITS
decl_stmt|;
comment|/* third-lowest bit can be set! */
name|assert
argument_list|(
name|sp
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|is_aligned
argument_list|(
name|chunk2mem
argument_list|(
name|p
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|p
operator|->
name|head
operator|==
name|FENCEPOST_HEAD
operator|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ok_address
argument_list|(
name|m
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|sz
operator|==
name|m
operator|->
name|topsize
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|sz
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|sz
operator|==
operator|(
operator|(
name|sp
operator|->
name|base
operator|+
name|sp
operator|->
name|size
operator|)
operator|-
operator|(
name|char
operator|*
operator|)
name|p
operator|)
operator|-
name|TOP_FOOT_SIZE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pinuse
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|pinuse
argument_list|(
name|chunk_plus_offset
argument_list|(
name|p
argument_list|,
name|sz
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Check properties of (inuse) mmapped chunks */
end_comment
begin_function
DECL|function|do_check_mmapped_chunk
specifier|static
name|void
name|do_check_mmapped_chunk
parameter_list|(
name|mstate
name|m
parameter_list|,
name|mchunkptr
name|p
parameter_list|)
block|{
name|size_t
name|sz
init|=
name|chunksize
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|size_t
name|len
init|=
operator|(
name|sz
operator|+
operator|(
name|p
operator|->
name|prev_foot
operator|&
operator|~
name|IS_MMAPPED_BIT
operator|)
operator|+
name|MMAP_FOOT_PAD
operator|)
decl_stmt|;
name|assert
argument_list|(
name|is_mmapped
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|use_mmap
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|is_aligned
argument_list|(
name|chunk2mem
argument_list|(
name|p
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|p
operator|->
name|head
operator|==
name|FENCEPOST_HEAD
operator|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ok_address
argument_list|(
name|m
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|is_small
argument_list|(
name|sz
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|len
operator|&
operator|(
name|mparams
operator|.
name|page_size
operator|-
name|SIZE_T_ONE
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|chunk_plus_offset
argument_list|(
name|p
argument_list|,
name|sz
argument_list|)
operator|->
name|head
operator|==
name|FENCEPOST_HEAD
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|chunk_plus_offset
argument_list|(
name|p
argument_list|,
name|sz
operator|+
name|SIZE_T_SIZE
argument_list|)
operator|->
name|head
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Check properties of inuse chunks */
end_comment
begin_function
DECL|function|do_check_inuse_chunk
specifier|static
name|void
name|do_check_inuse_chunk
parameter_list|(
name|mstate
name|m
parameter_list|,
name|mchunkptr
name|p
parameter_list|)
block|{
name|do_check_any_chunk
argument_list|(
name|m
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|cinuse
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|next_pinuse
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If not pinuse and not mmapped, previous chunk has OK offset */
name|assert
argument_list|(
name|is_mmapped
argument_list|(
name|p
argument_list|)
operator|||
name|pinuse
argument_list|(
name|p
argument_list|)
operator|||
name|next_chunk
argument_list|(
name|prev_chunk
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_mmapped
argument_list|(
name|p
argument_list|)
condition|)
name|do_check_mmapped_chunk
argument_list|(
name|m
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Check properties of free chunks */
end_comment
begin_function
DECL|function|do_check_free_chunk
specifier|static
name|void
name|do_check_free_chunk
parameter_list|(
name|mstate
name|m
parameter_list|,
name|mchunkptr
name|p
parameter_list|)
block|{
name|size_t
name|sz
init|=
name|chunksize
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|mchunkptr
name|next
init|=
name|chunk_plus_offset
argument_list|(
name|p
argument_list|,
name|sz
argument_list|)
decl_stmt|;
name|do_check_any_chunk
argument_list|(
name|m
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|cinuse
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|next_pinuse
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|is_mmapped
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|m
operator|->
name|dv
operator|&&
name|p
operator|!=
name|m
operator|->
name|top
condition|)
block|{
if|if
condition|(
name|sz
operator|>=
name|MIN_CHUNK_SIZE
condition|)
block|{
name|assert
argument_list|(
operator|(
name|sz
operator|&
name|CHUNK_ALIGN_MASK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|is_aligned
argument_list|(
name|chunk2mem
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|next
operator|->
name|prev_foot
operator|==
name|sz
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pinuse
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|next
operator|==
name|m
operator|->
name|top
operator|||
name|cinuse
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|p
operator|->
name|fd
operator|->
name|bk
operator|==
name|p
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|p
operator|->
name|bk
operator|->
name|fd
operator|==
name|p
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* markers are always of size SIZE_T_SIZE */
name|assert
argument_list|(
name|sz
operator|==
name|SIZE_T_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* Check properties of malloced chunks at the point they are malloced */
end_comment
begin_function
DECL|function|do_check_malloced_chunk
specifier|static
name|void
name|do_check_malloced_chunk
parameter_list|(
name|mstate
name|m
parameter_list|,
name|void
modifier|*
name|mem
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
if|if
condition|(
name|mem
operator|!=
literal|0
condition|)
block|{
name|mchunkptr
name|p
init|=
name|mem2chunk
argument_list|(
name|mem
argument_list|)
decl_stmt|;
name|size_t
name|sz
init|=
name|p
operator|->
name|head
operator|&
operator|~
operator|(
name|PINUSE_BIT
operator||
name|CINUSE_BIT
operator|)
decl_stmt|;
name|do_check_inuse_chunk
argument_list|(
name|m
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|sz
operator|&
name|CHUNK_ALIGN_MASK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|sz
operator|>=
name|MIN_CHUNK_SIZE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|sz
operator|>=
name|s
argument_list|)
expr_stmt|;
comment|/* unless mmapped, size is less than MIN_CHUNK_SIZE more than request */
name|assert
argument_list|(
name|is_mmapped
argument_list|(
name|p
argument_list|)
operator|||
name|sz
operator|<
operator|(
name|s
operator|+
name|MIN_CHUNK_SIZE
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* Check a tree and its subtrees.  */
end_comment
begin_function
DECL|function|do_check_tree
specifier|static
name|void
name|do_check_tree
parameter_list|(
name|mstate
name|m
parameter_list|,
name|tchunkptr
name|t
parameter_list|)
block|{
name|tchunkptr
name|head
init|=
literal|0
decl_stmt|;
name|tchunkptr
name|u
init|=
name|t
decl_stmt|;
name|bindex_t
name|tindex
init|=
name|t
operator|->
name|index
decl_stmt|;
name|size_t
name|tsize
init|=
name|chunksize
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|bindex_t
name|idx
decl_stmt|;
name|compute_tree_index
argument_list|(
name|tsize
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tindex
operator|==
name|idx
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tsize
operator|>=
name|MIN_LARGE_SIZE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tsize
operator|>=
name|minsize_for_tree_index
argument_list|(
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|idx
operator|==
name|NTREEBINS
operator|-
literal|1
operator|)
operator|||
operator|(
name|tsize
operator|<
name|minsize_for_tree_index
argument_list|(
operator|(
name|idx
operator|+
literal|1
operator|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* traverse through chain of same-sized nodes */
name|do_check_any_chunk
argument_list|(
name|m
argument_list|,
operator|(
operator|(
name|mchunkptr
operator|)
name|u
operator|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|u
operator|->
name|index
operator|==
name|tindex
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|chunksize
argument_list|(
name|u
argument_list|)
operator|==
name|tsize
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|cinuse
argument_list|(
name|u
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|next_pinuse
argument_list|(
name|u
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|u
operator|->
name|fd
operator|->
name|bk
operator|==
name|u
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|u
operator|->
name|bk
operator|->
name|fd
operator|==
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|->
name|parent
operator|==
literal|0
condition|)
block|{
name|assert
argument_list|(
name|u
operator|->
name|child
index|[
literal|0
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|u
operator|->
name|child
index|[
literal|1
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|head
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* only one node on chain has parent */
name|head
operator|=
name|u
expr_stmt|;
name|assert
argument_list|(
name|u
operator|->
name|parent
operator|!=
name|u
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|u
operator|->
name|parent
operator|->
name|child
index|[
literal|0
index|]
operator|==
name|u
operator|||
name|u
operator|->
name|parent
operator|->
name|child
index|[
literal|1
index|]
operator|==
name|u
operator|||
operator|*
operator|(
operator|(
name|tbinptr
operator|*
operator|)
operator|(
name|u
operator|->
name|parent
operator|)
operator|)
operator|==
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|->
name|child
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|assert
argument_list|(
name|u
operator|->
name|child
index|[
literal|0
index|]
operator|->
name|parent
operator|==
name|u
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|u
operator|->
name|child
index|[
literal|0
index|]
operator|!=
name|u
argument_list|)
expr_stmt|;
name|do_check_tree
argument_list|(
name|m
argument_list|,
name|u
operator|->
name|child
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|u
operator|->
name|child
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
name|assert
argument_list|(
name|u
operator|->
name|child
index|[
literal|1
index|]
operator|->
name|parent
operator|==
name|u
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|u
operator|->
name|child
index|[
literal|1
index|]
operator|!=
name|u
argument_list|)
expr_stmt|;
name|do_check_tree
argument_list|(
name|m
argument_list|,
name|u
operator|->
name|child
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|u
operator|->
name|child
index|[
literal|0
index|]
operator|!=
literal|0
operator|&&
name|u
operator|->
name|child
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
name|assert
argument_list|(
name|chunksize
argument_list|(
name|u
operator|->
name|child
index|[
literal|0
index|]
argument_list|)
operator|<
name|chunksize
argument_list|(
name|u
operator|->
name|child
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|u
operator|=
name|u
operator|->
name|fd
expr_stmt|;
block|}
do|while
condition|(
name|u
operator|!=
name|t
condition|)
do|;
name|assert
argument_list|(
name|head
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  Check all the chunks in a treebin.  */
end_comment
begin_function
DECL|function|do_check_treebin
specifier|static
name|void
name|do_check_treebin
parameter_list|(
name|mstate
name|m
parameter_list|,
name|bindex_t
name|i
parameter_list|)
block|{
name|tbinptr
modifier|*
name|tb
init|=
name|treebin_at
argument_list|(
name|m
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tchunkptr
name|t
init|=
operator|*
name|tb
decl_stmt|;
name|int
name|empty
init|=
operator|(
name|m
operator|->
name|treemap
operator|&
operator|(
literal|1U
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
decl_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
name|assert
argument_list|(
name|empty
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|empty
condition|)
name|do_check_tree
argument_list|(
name|m
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  Check all the chunks in a smallbin.  */
end_comment
begin_function
DECL|function|do_check_smallbin
specifier|static
name|void
name|do_check_smallbin
parameter_list|(
name|mstate
name|m
parameter_list|,
name|bindex_t
name|i
parameter_list|)
block|{
name|sbinptr
name|b
init|=
name|smallbin_at
argument_list|(
name|m
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|mchunkptr
name|p
init|=
name|b
operator|->
name|bk
decl_stmt|;
name|unsigned
name|int
name|empty
init|=
operator|(
name|m
operator|->
name|smallmap
operator|&
operator|(
literal|1U
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|b
condition|)
name|assert
argument_list|(
name|empty
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|empty
condition|)
block|{
for|for
control|(
init|;
name|p
operator|!=
name|b
condition|;
name|p
operator|=
name|p
operator|->
name|bk
control|)
block|{
name|size_t
name|size
init|=
name|chunksize
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|mchunkptr
name|q
decl_stmt|;
comment|/* each chunk claims to be free */
name|do_check_free_chunk
argument_list|(
name|m
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* chunk belongs in bin */
name|assert
argument_list|(
name|small_index
argument_list|(
name|size
argument_list|)
operator|==
name|i
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|p
operator|->
name|bk
operator|==
name|b
operator|||
name|chunksize
argument_list|(
name|p
operator|->
name|bk
argument_list|)
operator|==
name|chunksize
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* chunk is followed by an inuse chunk */
name|q
operator|=
name|next_chunk
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|head
operator|!=
name|FENCEPOST_HEAD
condition|)
name|do_check_inuse_chunk
argument_list|(
name|m
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/* Find x in a bin. Used in other check functions. */
end_comment
begin_function
DECL|function|bin_find
specifier|static
name|int
name|bin_find
parameter_list|(
name|mstate
name|m
parameter_list|,
name|mchunkptr
name|x
parameter_list|)
block|{
name|size_t
name|size
init|=
name|chunksize
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_small
argument_list|(
name|size
argument_list|)
condition|)
block|{
name|bindex_t
name|sidx
init|=
name|small_index
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|sbinptr
name|b
init|=
name|smallbin_at
argument_list|(
name|m
argument_list|,
name|sidx
argument_list|)
decl_stmt|;
if|if
condition|(
name|smallmap_is_marked
argument_list|(
name|m
argument_list|,
name|sidx
argument_list|)
condition|)
block|{
name|mchunkptr
name|p
init|=
name|b
decl_stmt|;
do|do
block|{
if|if
condition|(
name|p
operator|==
name|x
condition|)
return|return
literal|1
return|;
block|}
do|while
condition|(
operator|(
name|p
operator|=
name|p
operator|->
name|fd
operator|)
operator|!=
name|b
condition|)
do|;
block|}
block|}
else|else
block|{
name|bindex_t
name|tidx
decl_stmt|;
name|compute_tree_index
argument_list|(
name|size
argument_list|,
name|tidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|treemap_is_marked
argument_list|(
name|m
argument_list|,
name|tidx
argument_list|)
condition|)
block|{
name|tchunkptr
name|t
init|=
operator|*
name|treebin_at
argument_list|(
name|m
argument_list|,
name|tidx
argument_list|)
decl_stmt|;
name|size_t
name|sizebits
init|=
name|size
operator|<<
name|leftshift_for_tree_index
argument_list|(
name|tidx
argument_list|)
decl_stmt|;
while|while
condition|(
name|t
operator|!=
literal|0
operator|&&
name|chunksize
argument_list|(
name|t
argument_list|)
operator|!=
name|size
condition|)
block|{
name|t
operator|=
name|t
operator|->
name|child
index|[
operator|(
name|sizebits
operator|>>
operator|(
name|SIZE_T_BITSIZE
operator|-
name|SIZE_T_ONE
operator|)
operator|)
operator|&
literal|1
index|]
expr_stmt|;
name|sizebits
operator|<<=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|!=
literal|0
condition|)
block|{
name|tchunkptr
name|u
init|=
name|t
decl_stmt|;
do|do
block|{
if|if
condition|(
name|u
operator|==
operator|(
name|tchunkptr
operator|)
name|x
condition|)
return|return
literal|1
return|;
block|}
do|while
condition|(
operator|(
name|u
operator|=
name|u
operator|->
name|fd
operator|)
operator|!=
name|t
condition|)
do|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* Traverse each chunk and check it; return total */
end_comment
begin_function
DECL|function|traverse_and_check
specifier|static
name|size_t
name|traverse_and_check
parameter_list|(
name|mstate
name|m
parameter_list|)
block|{
name|size_t
name|sum
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|is_initialized
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|msegmentptr
name|s
init|=
operator|&
name|m
operator|->
name|seg
decl_stmt|;
name|sum
operator|+=
name|m
operator|->
name|topsize
operator|+
name|TOP_FOOT_SIZE
expr_stmt|;
while|while
condition|(
name|s
operator|!=
literal|0
condition|)
block|{
name|mchunkptr
name|q
init|=
name|align_as_chunk
argument_list|(
name|s
operator|->
name|base
argument_list|)
decl_stmt|;
name|mchunkptr
name|lastq
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|pinuse
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|segment_holds
argument_list|(
name|s
argument_list|,
name|q
argument_list|)
operator|&&
name|q
operator|!=
name|m
operator|->
name|top
operator|&&
name|q
operator|->
name|head
operator|!=
name|FENCEPOST_HEAD
condition|)
block|{
name|sum
operator|+=
name|chunksize
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinuse
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|assert
argument_list|(
operator|!
name|bin_find
argument_list|(
name|m
argument_list|,
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|do_check_inuse_chunk
argument_list|(
name|m
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|q
operator|==
name|m
operator|->
name|dv
operator|||
name|bin_find
argument_list|(
name|m
argument_list|,
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|lastq
operator|==
literal|0
operator|||
name|cinuse
argument_list|(
name|lastq
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Not 2 consecutive free */
name|do_check_free_chunk
argument_list|(
name|m
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
name|lastq
operator|=
name|q
expr_stmt|;
name|q
operator|=
name|next_chunk
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|s
operator|->
name|next
expr_stmt|;
block|}
block|}
return|return
name|sum
return|;
block|}
end_function
begin_comment
comment|/* Check all properties of malloc_state. */
end_comment
begin_function
DECL|function|do_check_malloc_state
specifier|static
name|void
name|do_check_malloc_state
parameter_list|(
name|mstate
name|m
parameter_list|)
block|{
name|bindex_t
name|i
decl_stmt|;
name|size_t
name|total
decl_stmt|;
comment|/* check bins */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSMALLBINS
condition|;
operator|++
name|i
control|)
name|do_check_smallbin
argument_list|(
name|m
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTREEBINS
condition|;
operator|++
name|i
control|)
name|do_check_treebin
argument_list|(
name|m
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|dvsize
operator|!=
literal|0
condition|)
block|{
comment|/* check dv chunk */
name|do_check_any_chunk
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|dv
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|m
operator|->
name|dvsize
operator|==
name|chunksize
argument_list|(
name|m
operator|->
name|dv
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|m
operator|->
name|dvsize
operator|>=
name|MIN_CHUNK_SIZE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|bin_find
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|dv
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|top
operator|!=
literal|0
condition|)
block|{
comment|/* check top chunk */
name|do_check_top_chunk
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|top
argument_list|)
expr_stmt|;
comment|/*assert(m->topsize == chunksize(m->top)); redundant */
name|assert
argument_list|(
name|m
operator|->
name|topsize
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|bin_find
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|top
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|total
operator|=
name|traverse_and_check
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|total
operator|<=
name|m
operator|->
name|footprint
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|m
operator|->
name|footprint
operator|<=
name|m
operator|->
name|max_footprint
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* DEBUG */
end_comment
begin_comment
comment|/* ----------------------------- statistics ------------------------------ */
end_comment
begin_if
if|#
directive|if
operator|!
name|NO_MALLINFO
end_if
begin_function
DECL|function|internal_mallinfo
specifier|static
name|struct
name|mallinfo
name|internal_mallinfo
parameter_list|(
name|mstate
name|m
parameter_list|)
block|{
name|struct
name|mallinfo
name|nm
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
if|if
condition|(
operator|!
name|PREACTION
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|check_malloc_state
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_initialized
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|size_t
name|nfree
init|=
name|SIZE_T_ONE
decl_stmt|;
comment|/* top always free */
name|size_t
name|mfree
init|=
name|m
operator|->
name|topsize
operator|+
name|TOP_FOOT_SIZE
decl_stmt|;
name|size_t
name|sum
init|=
name|mfree
decl_stmt|;
name|msegmentptr
name|s
init|=
operator|&
name|m
operator|->
name|seg
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|0
condition|)
block|{
name|mchunkptr
name|q
init|=
name|align_as_chunk
argument_list|(
name|s
operator|->
name|base
argument_list|)
decl_stmt|;
while|while
condition|(
name|segment_holds
argument_list|(
name|s
argument_list|,
name|q
argument_list|)
operator|&&
name|q
operator|!=
name|m
operator|->
name|top
operator|&&
name|q
operator|->
name|head
operator|!=
name|FENCEPOST_HEAD
condition|)
block|{
name|size_t
name|sz
init|=
name|chunksize
argument_list|(
name|q
argument_list|)
decl_stmt|;
name|sum
operator|+=
name|sz
expr_stmt|;
if|if
condition|(
operator|!
name|cinuse
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|mfree
operator|+=
name|sz
expr_stmt|;
operator|++
name|nfree
expr_stmt|;
block|}
name|q
operator|=
name|next_chunk
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|s
operator|->
name|next
expr_stmt|;
block|}
name|nm
operator|.
name|arena
operator|=
name|sum
expr_stmt|;
name|nm
operator|.
name|ordblks
operator|=
name|nfree
expr_stmt|;
name|nm
operator|.
name|hblkhd
operator|=
name|m
operator|->
name|footprint
operator|-
name|sum
expr_stmt|;
name|nm
operator|.
name|usmblks
operator|=
name|m
operator|->
name|max_footprint
expr_stmt|;
name|nm
operator|.
name|uordblks
operator|=
name|m
operator|->
name|footprint
operator|-
name|mfree
expr_stmt|;
name|nm
operator|.
name|fordblks
operator|=
name|mfree
expr_stmt|;
name|nm
operator|.
name|keepcost
operator|=
name|m
operator|->
name|topsize
expr_stmt|;
block|}
name|POSTACTION
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
return|return
name|nm
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !NO_MALLINFO */
end_comment
begin_function
DECL|function|internal_malloc_stats
specifier|static
name|void
name|internal_malloc_stats
parameter_list|(
name|mstate
name|m
parameter_list|)
block|{
if|if
condition|(
operator|!
name|PREACTION
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|size_t
name|maxfp
init|=
literal|0
decl_stmt|;
name|size_t
name|fp
init|=
literal|0
decl_stmt|;
name|size_t
name|used
init|=
literal|0
decl_stmt|;
name|check_malloc_state
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_initialized
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|msegmentptr
name|s
init|=
operator|&
name|m
operator|->
name|seg
decl_stmt|;
name|maxfp
operator|=
name|m
operator|->
name|max_footprint
expr_stmt|;
name|fp
operator|=
name|m
operator|->
name|footprint
expr_stmt|;
name|used
operator|=
name|fp
operator|-
operator|(
name|m
operator|->
name|topsize
operator|+
name|TOP_FOOT_SIZE
operator|)
expr_stmt|;
while|while
condition|(
name|s
operator|!=
literal|0
condition|)
block|{
name|mchunkptr
name|q
init|=
name|align_as_chunk
argument_list|(
name|s
operator|->
name|base
argument_list|)
decl_stmt|;
while|while
condition|(
name|segment_holds
argument_list|(
name|s
argument_list|,
name|q
argument_list|)
operator|&&
name|q
operator|!=
name|m
operator|->
name|top
operator|&&
name|q
operator|->
name|head
operator|!=
name|FENCEPOST_HEAD
condition|)
block|{
if|if
condition|(
operator|!
name|cinuse
argument_list|(
name|q
argument_list|)
condition|)
name|used
operator|-=
name|chunksize
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|q
operator|=
name|next_chunk
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|s
operator|->
name|next
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"max system bytes = %10lu\n"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|maxfp
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"system bytes     = %10lu\n"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"in use bytes     = %10lu\n"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|used
argument_list|)
argument_list|)
expr_stmt|;
name|POSTACTION
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* ----------------------- Operations on smallbins ----------------------- */
end_comment
begin_comment
comment|/*   Various forms of linking and unlinking are defined as macros.  Even   the ones for trees, which are very long but have very short typical   paths.  This is ugly but reduces reliance on inlining support of   compilers. */
end_comment
begin_comment
comment|/* Link a free chunk into a smallbin  */
end_comment
begin_define
DECL|macro|insert_small_chunk
define|#
directive|define
name|insert_small_chunk
parameter_list|(
name|M
parameter_list|,
name|P
parameter_list|,
name|S
parameter_list|)
value|{\   bindex_t I  = small_index(S);\   mchunkptr B = smallbin_at(M, I);\   mchunkptr F = B;\   assert(S>= MIN_CHUNK_SIZE);\   if (!smallmap_is_marked(M, I))\     mark_smallmap(M, I);\   else if (RTCHECK(ok_address(M, B->fd)))\     F = B->fd;\   else {\     CORRUPTION_ERROR_ACTION(M);\   }\   B->fd = P;\   F->bk = P;\   P->fd = F;\   P->bk = B;\ }
end_define
begin_comment
comment|/* Unlink a chunk from a smallbin  */
end_comment
begin_define
DECL|macro|unlink_small_chunk
define|#
directive|define
name|unlink_small_chunk
parameter_list|(
name|M
parameter_list|,
name|P
parameter_list|,
name|S
parameter_list|)
value|{\   mchunkptr F = P->fd;\   mchunkptr B = P->bk;\   bindex_t I = small_index(S);\   assert(P != B);\   assert(P != F);\   assert(chunksize(P) == small_index2size(I));\   if (F == B)\     clear_smallmap(M, I);\   else if (RTCHECK((F == smallbin_at(M,I) || ok_address(M, F))&&\                    (B == smallbin_at(M,I) || ok_address(M, B)))) {\     F->bk = B;\     B->fd = F;\   }\   else {\     CORRUPTION_ERROR_ACTION(M);\   }\ }
end_define
begin_comment
comment|/* Unlink the first chunk from a smallbin */
end_comment
begin_define
DECL|macro|unlink_first_small_chunk
define|#
directive|define
name|unlink_first_small_chunk
parameter_list|(
name|M
parameter_list|,
name|B
parameter_list|,
name|P
parameter_list|,
name|I
parameter_list|)
value|{\   mchunkptr F = P->fd;\   assert(P != B);\   assert(P != F);\   assert(chunksize(P) == small_index2size(I));\   if (B == F)\     clear_smallmap(M, I);\   else if (RTCHECK(ok_address(M, F))) {\     B->fd = F;\     F->bk = B;\   }\   else {\     CORRUPTION_ERROR_ACTION(M);\   }\ }
end_define
begin_comment
comment|/* Replace dv node, binning the old one */
end_comment
begin_comment
comment|/* Used only when dvsize known to be small */
end_comment
begin_define
DECL|macro|replace_dv
define|#
directive|define
name|replace_dv
parameter_list|(
name|M
parameter_list|,
name|P
parameter_list|,
name|S
parameter_list|)
value|{\   size_t DVS = M->dvsize;\   if (DVS != 0) {\     mchunkptr DV = M->dv;\     assert(is_small(DVS));\     insert_small_chunk(M, DV, DVS);\   }\   M->dvsize = S;\   M->dv = P;\ }
end_define
begin_comment
comment|/* ------------------------- Operations on trees ------------------------- */
end_comment
begin_comment
comment|/* Insert chunk into tree */
end_comment
begin_define
DECL|macro|insert_large_chunk
define|#
directive|define
name|insert_large_chunk
parameter_list|(
name|M
parameter_list|,
name|X
parameter_list|,
name|S
parameter_list|)
value|{\   tbinptr* H;\   bindex_t I;\   compute_tree_index(S, I);\   H = treebin_at(M, I);\   X->index = I;\   X->child[0] = X->child[1] = 0;\   if (!treemap_is_marked(M, I)) {\     mark_treemap(M, I);\     *H = X;\     X->parent = (tchunkptr)H;\     X->fd = X->bk = X;\   }\   else {\     tchunkptr T = *H;\     size_t K = S<< leftshift_for_tree_index(I);\     for (;;) {\       if (chunksize(T) != S) {\         tchunkptr* C =&(T->child[(K>> (SIZE_T_BITSIZE-SIZE_T_ONE))& 1]);\         K<<= 1;\         if (*C != 0)\           T = *C;\         else if (RTCHECK(ok_address(M, C))) {\           *C = X;\           X->parent = T;\           X->fd = X->bk = X;\           break;\         }\         else {\           CORRUPTION_ERROR_ACTION(M);\           break;\         }\       }\       else {\         tchunkptr F = T->fd;\         if (RTCHECK(ok_address(M, T)&& ok_address(M, F))) {\           T->fd = F->bk = X;\           X->fd = F;\           X->bk = T;\           X->parent = 0;\           break;\         }\         else {\           CORRUPTION_ERROR_ACTION(M);\           break;\         }\       }\     }\   }\ }
end_define
begin_comment
comment|/*   Unlink steps:    1. If x is a chained node, unlink it from its same-sized fd/bk links      and choose its bk node as its replacement.   2. If x was the last node of its size, but not a leaf node, it must      be replaced with a leaf node (not merely one with an open left or      right), to make sure that lefts and rights of descendents      correspond properly to bit masks.  We use the rightmost descendent      of x.  We could use any other leaf, but this is easy to locate and      tends to counteract removal of leftmosts elsewhere, and so keeps      paths shorter than minimally guaranteed.  This doesn't loop much      because on average a node in a tree is near the bottom.   3. If x is the base of a chain (i.e., has parent links) relink      x's parent and children to x's replacement (or null if none). */
end_comment
begin_define
DECL|macro|unlink_large_chunk
define|#
directive|define
name|unlink_large_chunk
parameter_list|(
name|M
parameter_list|,
name|X
parameter_list|)
value|{\   tchunkptr XP = X->parent;\   tchunkptr R;\   if (X->bk != X) {\     tchunkptr F = X->fd;\     R = X->bk;\     if (RTCHECK(ok_address(M, F))) {\       F->bk = R;\       R->fd = F;\     }\     else {\       CORRUPTION_ERROR_ACTION(M);\     }\   }\   else {\     tchunkptr* RP;\     if (((R = *(RP =&(X->child[1]))) != 0) ||\         ((R = *(RP =&(X->child[0]))) != 0)) {\       tchunkptr* CP;\       while ((*(CP =&(R->child[1])) != 0) ||\              (*(CP =&(R->child[0])) != 0)) {\         R = *(RP = CP);\       }\       if (RTCHECK(ok_address(M, RP)))\         *RP = 0;\       else {\         CORRUPTION_ERROR_ACTION(M);\       }\     }\   }\   if (XP != 0) {\     tbinptr* H = treebin_at(M, X->index);\     if (X == *H) {\       if ((*H = R) == 0) \         clear_treemap(M, X->index);\     }\     else if (RTCHECK(ok_address(M, XP))) {\       if (XP->child[0] == X) \         XP->child[0] = R;\       else \         XP->child[1] = R;\     }\     else\       CORRUPTION_ERROR_ACTION(M);\     if (R != 0) {\       if (RTCHECK(ok_address(M, R))) {\         tchunkptr C0, C1;\         R->parent = XP;\         if ((C0 = X->child[0]) != 0) {\           if (RTCHECK(ok_address(M, C0))) {\             R->child[0] = C0;\             C0->parent = R;\           }\           else\             CORRUPTION_ERROR_ACTION(M);\         }\         if ((C1 = X->child[1]) != 0) {\           if (RTCHECK(ok_address(M, C1))) {\             R->child[1] = C1;\             C1->parent = R;\           }\           else\             CORRUPTION_ERROR_ACTION(M);\         }\       }\       else\         CORRUPTION_ERROR_ACTION(M);\     }\   }\ }
end_define
begin_comment
comment|/* Relays to large vs small bin operations */
end_comment
begin_define
DECL|macro|insert_chunk
define|#
directive|define
name|insert_chunk
parameter_list|(
name|M
parameter_list|,
name|P
parameter_list|,
name|S
parameter_list|)
define|\
value|if (is_small(S)) insert_small_chunk(M, P, S)\   else { tchunkptr TP = (tchunkptr)(P); insert_large_chunk(M, TP, S); }
end_define
begin_define
DECL|macro|unlink_chunk
define|#
directive|define
name|unlink_chunk
parameter_list|(
name|M
parameter_list|,
name|P
parameter_list|,
name|S
parameter_list|)
define|\
value|if (is_small(S)) unlink_small_chunk(M, P, S)\   else { tchunkptr TP = (tchunkptr)(P); unlink_large_chunk(M, TP); }
end_define
begin_comment
comment|/* Relays to internal calls to malloc/free from realloc, memalign etc */
end_comment
begin_if
if|#
directive|if
name|ONLY_MSPACES
end_if
begin_define
DECL|macro|internal_malloc
define|#
directive|define
name|internal_malloc
parameter_list|(
name|m
parameter_list|,
name|b
parameter_list|)
value|mspace_malloc(m, b)
end_define
begin_define
DECL|macro|internal_free
define|#
directive|define
name|internal_free
parameter_list|(
name|m
parameter_list|,
name|mem
parameter_list|)
value|mspace_free(m,mem);
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* ONLY_MSPACES */
end_comment
begin_if
if|#
directive|if
name|MSPACES
end_if
begin_define
DECL|macro|internal_malloc
define|#
directive|define
name|internal_malloc
parameter_list|(
name|m
parameter_list|,
name|b
parameter_list|)
define|\
value|(m == gm)? dlmalloc(b) : mspace_malloc(m, b)
end_define
begin_define
DECL|macro|internal_free
define|#
directive|define
name|internal_free
parameter_list|(
name|m
parameter_list|,
name|mem
parameter_list|)
define|\
value|if (m == gm) dlfree(mem); else mspace_free(m,mem);
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* MSPACES */
end_comment
begin_define
DECL|macro|internal_malloc
define|#
directive|define
name|internal_malloc
parameter_list|(
name|m
parameter_list|,
name|b
parameter_list|)
value|dlmalloc(b)
end_define
begin_define
DECL|macro|internal_free
define|#
directive|define
name|internal_free
parameter_list|(
name|m
parameter_list|,
name|mem
parameter_list|)
value|dlfree(mem)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* MSPACES */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* ONLY_MSPACES */
end_comment
begin_comment
comment|/* -----------------------  Direct-mmapping chunks ----------------------- */
end_comment
begin_comment
comment|/*   Directly mmapped chunks are set up with an offset to the start of   the mmapped region stored in the prev_foot field of the chunk. This   allows reconstruction of the required argument to MUNMAP when freed,   and also allows adjustment of the returned chunk to meet alignment   requirements (especially in memalign).  There is also enough space   allocated to hold a fake next chunk of size SIZE_T_SIZE to maintain   the PINUSE bit so frees can be checked. */
end_comment
begin_comment
comment|/* Malloc using mmap */
end_comment
begin_function
DECL|function|mmap_alloc
specifier|static
name|void
modifier|*
name|mmap_alloc
parameter_list|(
name|mstate
name|m
parameter_list|,
name|size_t
name|nb
parameter_list|)
block|{
name|size_t
name|mmsize
init|=
name|mmap_align
argument_list|(
name|nb
operator|+
name|SIX_SIZE_T_SIZES
operator|+
name|CHUNK_ALIGN_MASK
argument_list|)
decl_stmt|;
if|if
condition|(
name|mmsize
operator|>
name|nb
condition|)
block|{
comment|/* Check for wrap around 0 */
name|char
modifier|*
name|mm
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|DIRECT_MMAP
argument_list|(
name|mmsize
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|mm
operator|!=
name|CMFAIL
condition|)
block|{
name|size_t
name|offset
init|=
name|align_offset
argument_list|(
name|chunk2mem
argument_list|(
name|mm
argument_list|)
argument_list|)
decl_stmt|;
name|size_t
name|psize
init|=
name|mmsize
operator|-
name|offset
operator|-
name|MMAP_FOOT_PAD
decl_stmt|;
name|mchunkptr
name|p
init|=
call|(
name|mchunkptr
call|)
argument_list|(
name|mm
operator|+
name|offset
argument_list|)
decl_stmt|;
name|p
operator|->
name|prev_foot
operator|=
name|offset
operator||
name|IS_MMAPPED_BIT
expr_stmt|;
operator|(
name|p
operator|)
operator|->
name|head
operator|=
operator|(
name|psize
operator||
name|CINUSE_BIT
operator|)
expr_stmt|;
name|mark_inuse_foot
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|psize
argument_list|)
expr_stmt|;
name|chunk_plus_offset
argument_list|(
name|p
argument_list|,
name|psize
argument_list|)
operator|->
name|head
operator|=
name|FENCEPOST_HEAD
expr_stmt|;
name|chunk_plus_offset
argument_list|(
name|p
argument_list|,
name|psize
operator|+
name|SIZE_T_SIZE
argument_list|)
operator|->
name|head
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mm
operator|<
name|m
operator|->
name|least_addr
condition|)
name|m
operator|->
name|least_addr
operator|=
name|mm
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|footprint
operator|+=
name|mmsize
operator|)
operator|>
name|m
operator|->
name|max_footprint
condition|)
name|m
operator|->
name|max_footprint
operator|=
name|m
operator|->
name|footprint
expr_stmt|;
name|assert
argument_list|(
name|is_aligned
argument_list|(
name|chunk2mem
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|check_mmapped_chunk
argument_list|(
name|m
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|chunk2mem
argument_list|(
name|p
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* Realloc using mmap */
end_comment
begin_function
DECL|function|mmap_resize
specifier|static
name|mchunkptr
name|mmap_resize
parameter_list|(
name|mstate
name|m
parameter_list|,
name|mchunkptr
name|oldp
parameter_list|,
name|size_t
name|nb
parameter_list|)
block|{
name|size_t
name|oldsize
init|=
name|chunksize
argument_list|(
name|oldp
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_small
argument_list|(
name|nb
argument_list|)
condition|)
comment|/* Can't shrink mmap regions below small size */
return|return
literal|0
return|;
comment|/* Keep old chunk if big enough but not too big */
if|if
condition|(
name|oldsize
operator|>=
name|nb
operator|+
name|SIZE_T_SIZE
operator|&&
operator|(
name|oldsize
operator|-
name|nb
operator|)
operator|<=
operator|(
name|mparams
operator|.
name|granularity
operator|<<
literal|1
operator|)
condition|)
return|return
name|oldp
return|;
else|else
block|{
name|size_t
name|offset
init|=
name|oldp
operator|->
name|prev_foot
operator|&
operator|~
name|IS_MMAPPED_BIT
decl_stmt|;
name|size_t
name|oldmmsize
init|=
name|oldsize
operator|+
name|offset
operator|+
name|MMAP_FOOT_PAD
decl_stmt|;
name|size_t
name|newmmsize
init|=
name|mmap_align
argument_list|(
name|nb
operator|+
name|SIX_SIZE_T_SIZES
operator|+
name|CHUNK_ALIGN_MASK
argument_list|)
decl_stmt|;
name|char
modifier|*
name|cp
init|=
operator|(
name|char
operator|*
operator|)
name|CALL_MREMAP
argument_list|(
operator|(
name|char
operator|*
operator|)
name|oldp
operator|-
name|offset
argument_list|,
name|oldmmsize
argument_list|,
name|newmmsize
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|cp
operator|!=
name|CMFAIL
condition|)
block|{
name|mchunkptr
name|newp
init|=
call|(
name|mchunkptr
call|)
argument_list|(
name|cp
operator|+
name|offset
argument_list|)
decl_stmt|;
name|size_t
name|psize
init|=
name|newmmsize
operator|-
name|offset
operator|-
name|MMAP_FOOT_PAD
decl_stmt|;
name|newp
operator|->
name|head
operator|=
operator|(
name|psize
operator||
name|CINUSE_BIT
operator|)
expr_stmt|;
name|mark_inuse_foot
argument_list|(
name|m
argument_list|,
name|newp
argument_list|,
name|psize
argument_list|)
expr_stmt|;
name|chunk_plus_offset
argument_list|(
name|newp
argument_list|,
name|psize
argument_list|)
operator|->
name|head
operator|=
name|FENCEPOST_HEAD
expr_stmt|;
name|chunk_plus_offset
argument_list|(
name|newp
argument_list|,
name|psize
operator|+
name|SIZE_T_SIZE
argument_list|)
operator|->
name|head
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cp
operator|<
name|m
operator|->
name|least_addr
condition|)
name|m
operator|->
name|least_addr
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|footprint
operator|+=
name|newmmsize
operator|-
name|oldmmsize
operator|)
operator|>
name|m
operator|->
name|max_footprint
condition|)
name|m
operator|->
name|max_footprint
operator|=
name|m
operator|->
name|footprint
expr_stmt|;
name|check_mmapped_chunk
argument_list|(
name|m
argument_list|,
name|newp
argument_list|)
expr_stmt|;
return|return
name|newp
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* -------------------------- mspace management -------------------------- */
end_comment
begin_comment
comment|/* Initialize top chunk and its size */
end_comment
begin_function
DECL|function|init_top
specifier|static
name|void
name|init_top
parameter_list|(
name|mstate
name|m
parameter_list|,
name|mchunkptr
name|p
parameter_list|,
name|size_t
name|psize
parameter_list|)
block|{
comment|/* Ensure alignment */
name|size_t
name|offset
init|=
name|align_offset
argument_list|(
name|chunk2mem
argument_list|(
name|p
argument_list|)
argument_list|)
decl_stmt|;
name|p
operator|=
call|(
name|mchunkptr
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|+
name|offset
argument_list|)
expr_stmt|;
name|psize
operator|-=
name|offset
expr_stmt|;
name|m
operator|->
name|top
operator|=
name|p
expr_stmt|;
name|m
operator|->
name|topsize
operator|=
name|psize
expr_stmt|;
name|p
operator|->
name|head
operator|=
name|psize
operator||
name|PINUSE_BIT
expr_stmt|;
comment|/* set size of fake trailing chunk holding overhead space only once */
name|chunk_plus_offset
argument_list|(
name|p
argument_list|,
name|psize
argument_list|)
operator|->
name|head
operator|=
name|TOP_FOOT_SIZE
expr_stmt|;
name|m
operator|->
name|trim_check
operator|=
name|mparams
operator|.
name|trim_threshold
expr_stmt|;
comment|/* reset on each update */
block|}
end_function
begin_comment
comment|/* Initialize bins for a new mstate that is otherwise zeroed out */
end_comment
begin_function
DECL|function|init_bins
specifier|static
name|void
name|init_bins
parameter_list|(
name|mstate
name|m
parameter_list|)
block|{
comment|/* Establish circular links for smallbins */
name|bindex_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSMALLBINS
condition|;
operator|++
name|i
control|)
block|{
name|sbinptr
name|bin
init|=
name|smallbin_at
argument_list|(
name|m
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|bin
operator|->
name|fd
operator|=
name|bin
operator|->
name|bk
operator|=
name|bin
expr_stmt|;
block|}
block|}
end_function
begin_if
if|#
directive|if
name|PROCEED_ON_ERROR
end_if
begin_comment
comment|/* default corruption action */
end_comment
begin_function
DECL|function|reset_on_error
specifier|static
name|void
name|reset_on_error
parameter_list|(
name|mstate
name|m
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
operator|++
name|malloc_corruption_error_count
expr_stmt|;
comment|/* Reinitialize fields to forget about all memory */
name|m
operator|->
name|smallbins
operator|=
name|m
operator|->
name|treebins
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|dvsize
operator|=
name|m
operator|->
name|topsize
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|seg
operator|.
name|base
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|seg
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|seg
operator|.
name|next
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|top
operator|=
name|m
operator|->
name|dv
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTREEBINS
condition|;
operator|++
name|i
control|)
operator|*
name|treebin_at
argument_list|(
name|m
argument_list|,
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
name|init_bins
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PROCEED_ON_ERROR */
end_comment
begin_comment
comment|/* Allocate chunk and prepend remainder with chunk in successor base. */
end_comment
begin_function
DECL|function|prepend_alloc
specifier|static
name|void
modifier|*
name|prepend_alloc
parameter_list|(
name|mstate
name|m
parameter_list|,
name|char
modifier|*
name|newbase
parameter_list|,
name|char
modifier|*
name|oldbase
parameter_list|,
name|size_t
name|nb
parameter_list|)
block|{
name|mchunkptr
name|p
init|=
name|align_as_chunk
argument_list|(
name|newbase
argument_list|)
decl_stmt|;
name|mchunkptr
name|oldfirst
init|=
name|align_as_chunk
argument_list|(
name|oldbase
argument_list|)
decl_stmt|;
name|size_t
name|psize
init|=
operator|(
name|char
operator|*
operator|)
name|oldfirst
operator|-
operator|(
name|char
operator|*
operator|)
name|p
decl_stmt|;
name|mchunkptr
name|q
init|=
name|chunk_plus_offset
argument_list|(
name|p
argument_list|,
name|nb
argument_list|)
decl_stmt|;
name|size_t
name|qsize
init|=
name|psize
operator|-
name|nb
decl_stmt|;
name|set_size_and_pinuse_of_inuse_chunk
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|char
operator|*
operator|)
name|oldfirst
operator|>
operator|(
name|char
operator|*
operator|)
name|q
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pinuse
argument_list|(
name|oldfirst
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|qsize
operator|>=
name|MIN_CHUNK_SIZE
argument_list|)
expr_stmt|;
comment|/* consolidate remainder with first chunk of old base */
if|if
condition|(
name|oldfirst
operator|==
name|m
operator|->
name|top
condition|)
block|{
name|size_t
name|tsize
init|=
name|m
operator|->
name|topsize
operator|+=
name|qsize
decl_stmt|;
name|m
operator|->
name|top
operator|=
name|q
expr_stmt|;
name|q
operator|->
name|head
operator|=
name|tsize
operator||
name|PINUSE_BIT
expr_stmt|;
name|check_top_chunk
argument_list|(
name|m
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oldfirst
operator|==
name|m
operator|->
name|dv
condition|)
block|{
name|size_t
name|dsize
init|=
name|m
operator|->
name|dvsize
operator|+=
name|qsize
decl_stmt|;
name|m
operator|->
name|dv
operator|=
name|q
expr_stmt|;
name|set_size_and_pinuse_of_free_chunk
argument_list|(
name|q
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|cinuse
argument_list|(
name|oldfirst
argument_list|)
condition|)
block|{
name|size_t
name|nsize
init|=
name|chunksize
argument_list|(
name|oldfirst
argument_list|)
decl_stmt|;
name|unlink_chunk
argument_list|(
name|m
argument_list|,
name|oldfirst
argument_list|,
name|nsize
argument_list|)
expr_stmt|;
name|oldfirst
operator|=
name|chunk_plus_offset
argument_list|(
name|oldfirst
argument_list|,
name|nsize
argument_list|)
expr_stmt|;
name|qsize
operator|+=
name|nsize
expr_stmt|;
block|}
name|set_free_with_pinuse
argument_list|(
name|q
argument_list|,
name|qsize
argument_list|,
name|oldfirst
argument_list|)
expr_stmt|;
name|insert_chunk
argument_list|(
name|m
argument_list|,
name|q
argument_list|,
name|qsize
argument_list|)
expr_stmt|;
name|check_free_chunk
argument_list|(
name|m
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
name|check_malloced_chunk
argument_list|(
name|m
argument_list|,
name|chunk2mem
argument_list|(
name|p
argument_list|)
argument_list|,
name|nb
argument_list|)
expr_stmt|;
return|return
name|chunk2mem
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* Add a segment to hold a new noncontiguous region */
end_comment
begin_function
DECL|function|add_segment
specifier|static
name|void
name|add_segment
parameter_list|(
name|mstate
name|m
parameter_list|,
name|char
modifier|*
name|tbase
parameter_list|,
name|size_t
name|tsize
parameter_list|,
name|flag_t
name|mmapped
parameter_list|)
block|{
comment|/* Determine locations and sizes of segment, fenceposts, old top */
name|char
modifier|*
name|old_top
init|=
operator|(
name|char
operator|*
operator|)
name|m
operator|->
name|top
decl_stmt|;
name|msegmentptr
name|oldsp
init|=
name|segment_holding
argument_list|(
name|m
argument_list|,
name|old_top
argument_list|)
decl_stmt|;
name|char
modifier|*
name|old_end
init|=
name|oldsp
operator|->
name|base
operator|+
name|oldsp
operator|->
name|size
decl_stmt|;
name|size_t
name|ssize
init|=
name|pad_request
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|malloc_segment
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|rawsp
init|=
name|old_end
operator|-
operator|(
name|ssize
operator|+
name|FOUR_SIZE_T_SIZES
operator|+
name|CHUNK_ALIGN_MASK
operator|)
decl_stmt|;
name|size_t
name|offset
init|=
name|align_offset
argument_list|(
name|chunk2mem
argument_list|(
name|rawsp
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|asp
init|=
name|rawsp
operator|+
name|offset
decl_stmt|;
name|char
modifier|*
name|csp
init|=
operator|(
name|asp
operator|<
operator|(
name|old_top
operator|+
name|MIN_CHUNK_SIZE
operator|)
operator|)
condition|?
name|old_top
else|:
name|asp
decl_stmt|;
name|mchunkptr
name|sp
init|=
operator|(
name|mchunkptr
operator|)
name|csp
decl_stmt|;
name|msegmentptr
name|ss
init|=
call|(
name|msegmentptr
call|)
argument_list|(
name|chunk2mem
argument_list|(
name|sp
argument_list|)
argument_list|)
decl_stmt|;
name|mchunkptr
name|tnext
init|=
name|chunk_plus_offset
argument_list|(
name|sp
argument_list|,
name|ssize
argument_list|)
decl_stmt|;
name|mchunkptr
name|p
init|=
name|tnext
decl_stmt|;
name|int
name|nfences
init|=
literal|0
decl_stmt|;
comment|/* reset top to new space */
name|init_top
argument_list|(
name|m
argument_list|,
operator|(
name|mchunkptr
operator|)
name|tbase
argument_list|,
name|tsize
operator|-
name|TOP_FOOT_SIZE
argument_list|)
expr_stmt|;
comment|/* Set up segment record */
name|assert
argument_list|(
name|is_aligned
argument_list|(
name|ss
argument_list|)
argument_list|)
expr_stmt|;
name|set_size_and_pinuse_of_inuse_chunk
argument_list|(
name|m
argument_list|,
name|sp
argument_list|,
name|ssize
argument_list|)
expr_stmt|;
operator|*
name|ss
operator|=
name|m
operator|->
name|seg
expr_stmt|;
comment|/* Push current record */
name|m
operator|->
name|seg
operator|.
name|base
operator|=
name|tbase
expr_stmt|;
name|m
operator|->
name|seg
operator|.
name|size
operator|=
name|tsize
expr_stmt|;
name|m
operator|->
name|seg
operator|.
name|sflags
operator|=
name|mmapped
expr_stmt|;
name|m
operator|->
name|seg
operator|.
name|next
operator|=
name|ss
expr_stmt|;
comment|/* Insert trailing fenceposts */
for|for
control|(
init|;
condition|;
control|)
block|{
name|mchunkptr
name|nextp
init|=
name|chunk_plus_offset
argument_list|(
name|p
argument_list|,
name|SIZE_T_SIZE
argument_list|)
decl_stmt|;
name|p
operator|->
name|head
operator|=
name|FENCEPOST_HEAD
expr_stmt|;
operator|++
name|nfences
expr_stmt|;
if|if
condition|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
operator|(
name|nextp
operator|->
name|head
operator|)
operator|)
operator|<
name|old_end
condition|)
name|p
operator|=
name|nextp
expr_stmt|;
else|else
break|break;
block|}
name|assert
argument_list|(
name|nfences
operator|>=
literal|2
argument_list|)
expr_stmt|;
comment|/* Insert the rest of old top into a bin as an ordinary free chunk */
if|if
condition|(
name|csp
operator|!=
name|old_top
condition|)
block|{
name|mchunkptr
name|q
init|=
operator|(
name|mchunkptr
operator|)
name|old_top
decl_stmt|;
name|size_t
name|psize
init|=
name|csp
operator|-
name|old_top
decl_stmt|;
name|mchunkptr
name|tn
init|=
name|chunk_plus_offset
argument_list|(
name|q
argument_list|,
name|psize
argument_list|)
decl_stmt|;
name|set_free_with_pinuse
argument_list|(
name|q
argument_list|,
name|psize
argument_list|,
name|tn
argument_list|)
expr_stmt|;
name|insert_chunk
argument_list|(
name|m
argument_list|,
name|q
argument_list|,
name|psize
argument_list|)
expr_stmt|;
block|}
name|check_top_chunk
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|top
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* -------------------------- System allocation -------------------------- */
end_comment
begin_comment
comment|/* Get memory from system using MORECORE or MMAP */
end_comment
begin_function
DECL|function|sys_alloc
specifier|static
name|void
modifier|*
name|sys_alloc
parameter_list|(
name|mstate
name|m
parameter_list|,
name|size_t
name|nb
parameter_list|)
block|{
name|char
modifier|*
name|tbase
init|=
name|CMFAIL
decl_stmt|;
name|size_t
name|tsize
init|=
literal|0
decl_stmt|;
name|flag_t
name|mmap_flag
init|=
literal|0
decl_stmt|;
name|init_mparams
argument_list|()
expr_stmt|;
comment|/* Directly map large chunks */
if|if
condition|(
name|use_mmap
argument_list|(
name|m
argument_list|)
operator|&&
name|nb
operator|>=
name|mparams
operator|.
name|mmap_threshold
condition|)
block|{
name|void
modifier|*
name|mem
init|=
name|mmap_alloc
argument_list|(
name|m
argument_list|,
name|nb
argument_list|)
decl_stmt|;
if|if
condition|(
name|mem
operator|!=
literal|0
condition|)
return|return
name|mem
return|;
block|}
comment|/*     Try getting memory in any of three ways (in most-preferred to     least-preferred order):     1. A call to MORECORE that can normally contiguously extend memory.        (disabled if not MORECORE_CONTIGUOUS or not HAVE_MORECORE or        or main space is mmapped or a previous contiguous call failed)     2. A call to MMAP new space (disabled if not HAVE_MMAP).        Note that under the default settings, if MORECORE is unable to        fulfill a request, and HAVE_MMAP is true, then mmap is        used as a noncontiguous system allocator. This is a useful backup        strategy for systems with holes in address spaces -- in this case        sbrk cannot contiguously expand the heap, but mmap may be able to        find space.     3. A call to MORECORE that cannot usually contiguously extend memory.        (disabled if not HAVE_MORECORE)   */
if|if
condition|(
name|MORECORE_CONTIGUOUS
operator|&&
operator|!
name|use_noncontiguous
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|char
modifier|*
name|br
init|=
name|CMFAIL
decl_stmt|;
name|msegmentptr
name|ss
init|=
operator|(
name|m
operator|->
name|top
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|segment_holding
argument_list|(
name|m
argument_list|,
operator|(
name|char
operator|*
operator|)
name|m
operator|->
name|top
argument_list|)
decl_stmt|;
name|size_t
name|asize
init|=
literal|0
decl_stmt|;
name|ACQUIRE_MORECORE_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|ss
operator|==
literal|0
condition|)
block|{
comment|/* First time through or recovery */
name|char
modifier|*
name|base
init|=
operator|(
name|char
operator|*
operator|)
name|CALL_MORECORE
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|base
operator|!=
name|CMFAIL
condition|)
block|{
name|asize
operator|=
name|granularity_align
argument_list|(
name|nb
operator|+
name|TOP_FOOT_SIZE
operator|+
name|SIZE_T_ONE
argument_list|)
expr_stmt|;
comment|/* Adjust to end on a page boundary */
if|if
condition|(
operator|!
name|is_page_aligned
argument_list|(
name|base
argument_list|)
condition|)
name|asize
operator|+=
operator|(
name|page_align
argument_list|(
operator|(
name|size_t
operator|)
name|base
argument_list|)
operator|-
operator|(
name|size_t
operator|)
name|base
operator|)
expr_stmt|;
comment|/* Can't call MORECORE if size is negative when treated as signed */
if|if
condition|(
name|asize
operator|<
name|HALF_MAX_SIZE_T
operator|&&
operator|(
name|br
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|CALL_MORECORE
argument_list|(
name|asize
argument_list|)
operator|)
operator|)
operator|==
name|base
condition|)
block|{
name|tbase
operator|=
name|base
expr_stmt|;
name|tsize
operator|=
name|asize
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Subtract out existing available top space from MORECORE request. */
name|asize
operator|=
name|granularity_align
argument_list|(
name|nb
operator|-
name|m
operator|->
name|topsize
operator|+
name|TOP_FOOT_SIZE
operator|+
name|SIZE_T_ONE
argument_list|)
expr_stmt|;
comment|/* Use mem here only if it did continuously extend old space */
if|if
condition|(
name|asize
operator|<
name|HALF_MAX_SIZE_T
operator|&&
operator|(
name|br
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|CALL_MORECORE
argument_list|(
name|asize
argument_list|)
operator|)
operator|)
operator|==
name|ss
operator|->
name|base
operator|+
name|ss
operator|->
name|size
condition|)
block|{
name|tbase
operator|=
name|br
expr_stmt|;
name|tsize
operator|=
name|asize
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tbase
operator|==
name|CMFAIL
condition|)
block|{
comment|/* Cope with partial failure */
if|if
condition|(
name|br
operator|!=
name|CMFAIL
condition|)
block|{
comment|/* Try to use/extend the space we did get */
if|if
condition|(
name|asize
operator|<
name|HALF_MAX_SIZE_T
operator|&&
name|asize
operator|<
name|nb
operator|+
name|TOP_FOOT_SIZE
operator|+
name|SIZE_T_ONE
condition|)
block|{
name|size_t
name|esize
init|=
name|granularity_align
argument_list|(
name|nb
operator|+
name|TOP_FOOT_SIZE
operator|+
name|SIZE_T_ONE
operator|-
name|asize
argument_list|)
decl_stmt|;
if|if
condition|(
name|esize
operator|<
name|HALF_MAX_SIZE_T
condition|)
block|{
name|char
modifier|*
name|end
init|=
operator|(
name|char
operator|*
operator|)
name|CALL_MORECORE
argument_list|(
name|esize
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|!=
name|CMFAIL
condition|)
name|asize
operator|+=
name|esize
expr_stmt|;
else|else
block|{
comment|/* Can't use; try to release */
operator|(
name|void
operator|)
name|CALL_MORECORE
argument_list|(
operator|-
name|asize
argument_list|)
expr_stmt|;
name|br
operator|=
name|CMFAIL
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|br
operator|!=
name|CMFAIL
condition|)
block|{
comment|/* Use the space we did get */
name|tbase
operator|=
name|br
expr_stmt|;
name|tsize
operator|=
name|asize
expr_stmt|;
block|}
else|else
name|disable_contiguous
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* Don't try contiguous path in the future */
block|}
name|RELEASE_MORECORE_LOCK
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|HAVE_MMAP
operator|&&
name|tbase
operator|==
name|CMFAIL
condition|)
block|{
comment|/* Try MMAP */
name|size_t
name|req
init|=
name|nb
operator|+
name|TOP_FOOT_SIZE
operator|+
name|SIZE_T_ONE
decl_stmt|;
name|size_t
name|rsize
init|=
name|granularity_align
argument_list|(
name|req
argument_list|)
decl_stmt|;
if|if
condition|(
name|rsize
operator|>
name|nb
condition|)
block|{
comment|/* Fail if wraps around zero */
name|char
modifier|*
name|mp
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|CALL_MMAP
argument_list|(
name|rsize
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|mp
operator|!=
name|CMFAIL
condition|)
block|{
name|tbase
operator|=
name|mp
expr_stmt|;
name|tsize
operator|=
name|rsize
expr_stmt|;
name|mmap_flag
operator|=
name|IS_MMAPPED_BIT
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|HAVE_MORECORE
operator|&&
name|tbase
operator|==
name|CMFAIL
condition|)
block|{
comment|/* Try noncontiguous MORECORE */
name|size_t
name|asize
init|=
name|granularity_align
argument_list|(
name|nb
operator|+
name|TOP_FOOT_SIZE
operator|+
name|SIZE_T_ONE
argument_list|)
decl_stmt|;
if|if
condition|(
name|asize
operator|<
name|HALF_MAX_SIZE_T
condition|)
block|{
name|char
modifier|*
name|br
init|=
name|CMFAIL
decl_stmt|;
name|char
modifier|*
name|end
init|=
name|CMFAIL
decl_stmt|;
name|ACQUIRE_MORECORE_LOCK
argument_list|()
expr_stmt|;
name|br
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|CALL_MORECORE
argument_list|(
name|asize
argument_list|)
operator|)
expr_stmt|;
name|end
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|CALL_MORECORE
argument_list|(
literal|0
argument_list|)
operator|)
expr_stmt|;
name|RELEASE_MORECORE_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|br
operator|!=
name|CMFAIL
operator|&&
name|end
operator|!=
name|CMFAIL
operator|&&
name|br
operator|<
name|end
condition|)
block|{
name|size_t
name|ssize
init|=
name|end
operator|-
name|br
decl_stmt|;
if|if
condition|(
name|ssize
operator|>
name|nb
operator|+
name|TOP_FOOT_SIZE
condition|)
block|{
name|tbase
operator|=
name|br
expr_stmt|;
name|tsize
operator|=
name|ssize
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|tbase
operator|!=
name|CMFAIL
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|->
name|footprint
operator|+=
name|tsize
operator|)
operator|>
name|m
operator|->
name|max_footprint
condition|)
name|m
operator|->
name|max_footprint
operator|=
name|m
operator|->
name|footprint
expr_stmt|;
if|if
condition|(
operator|!
name|is_initialized
argument_list|(
name|m
argument_list|)
condition|)
block|{
comment|/* first-time initialization */
name|m
operator|->
name|seg
operator|.
name|base
operator|=
name|m
operator|->
name|least_addr
operator|=
name|tbase
expr_stmt|;
name|m
operator|->
name|seg
operator|.
name|size
operator|=
name|tsize
expr_stmt|;
name|m
operator|->
name|seg
operator|.
name|sflags
operator|=
name|mmap_flag
expr_stmt|;
name|m
operator|->
name|magic
operator|=
name|mparams
operator|.
name|magic
expr_stmt|;
name|m
operator|->
name|release_checks
operator|=
name|MAX_RELEASE_CHECK_RATE
expr_stmt|;
name|init_bins
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|ONLY_MSPACES
if|if
condition|(
name|is_global
argument_list|(
name|m
argument_list|)
condition|)
name|init_top
argument_list|(
name|m
argument_list|,
operator|(
name|mchunkptr
operator|)
name|tbase
argument_list|,
name|tsize
operator|-
name|TOP_FOOT_SIZE
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
comment|/* Offset top by embedded malloc_state */
name|mchunkptr
name|mn
init|=
name|next_chunk
argument_list|(
name|mem2chunk
argument_list|(
name|m
argument_list|)
argument_list|)
decl_stmt|;
name|init_top
argument_list|(
name|m
argument_list|,
name|mn
argument_list|,
call|(
name|size_t
call|)
argument_list|(
operator|(
name|tbase
operator|+
name|tsize
operator|)
operator|-
operator|(
name|char
operator|*
operator|)
name|mn
argument_list|)
operator|-
name|TOP_FOOT_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Try to merge with an existing segment */
name|msegmentptr
name|sp
init|=
operator|&
name|m
operator|->
name|seg
decl_stmt|;
comment|/* Only consider most recent segment if traversal suppressed */
while|while
condition|(
name|sp
operator|!=
literal|0
operator|&&
name|tbase
operator|!=
name|sp
operator|->
name|base
operator|+
name|sp
operator|->
name|size
condition|)
name|sp
operator|=
operator|(
name|NO_SEGMENT_TRAVERSAL
operator|)
condition|?
literal|0
else|:
name|sp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|sp
operator|!=
literal|0
operator|&&
operator|!
name|is_extern_segment
argument_list|(
name|sp
argument_list|)
operator|&&
operator|(
name|sp
operator|->
name|sflags
operator|&
name|IS_MMAPPED_BIT
operator|)
operator|==
name|mmap_flag
operator|&&
name|segment_holds
argument_list|(
name|sp
argument_list|,
name|m
operator|->
name|top
argument_list|)
condition|)
block|{
comment|/* append */
name|sp
operator|->
name|size
operator|+=
name|tsize
expr_stmt|;
name|init_top
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|top
argument_list|,
name|m
operator|->
name|topsize
operator|+
name|tsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tbase
operator|<
name|m
operator|->
name|least_addr
condition|)
name|m
operator|->
name|least_addr
operator|=
name|tbase
expr_stmt|;
name|sp
operator|=
operator|&
name|m
operator|->
name|seg
expr_stmt|;
while|while
condition|(
name|sp
operator|!=
literal|0
operator|&&
name|sp
operator|->
name|base
operator|!=
name|tbase
operator|+
name|tsize
condition|)
name|sp
operator|=
operator|(
name|NO_SEGMENT_TRAVERSAL
operator|)
condition|?
literal|0
else|:
name|sp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|sp
operator|!=
literal|0
operator|&&
operator|!
name|is_extern_segment
argument_list|(
name|sp
argument_list|)
operator|&&
operator|(
name|sp
operator|->
name|sflags
operator|&
name|IS_MMAPPED_BIT
operator|)
operator|==
name|mmap_flag
condition|)
block|{
name|char
modifier|*
name|oldbase
init|=
name|sp
operator|->
name|base
decl_stmt|;
name|sp
operator|->
name|base
operator|=
name|tbase
expr_stmt|;
name|sp
operator|->
name|size
operator|+=
name|tsize
expr_stmt|;
return|return
name|prepend_alloc
argument_list|(
name|m
argument_list|,
name|tbase
argument_list|,
name|oldbase
argument_list|,
name|nb
argument_list|)
return|;
block|}
else|else
name|add_segment
argument_list|(
name|m
argument_list|,
name|tbase
argument_list|,
name|tsize
argument_list|,
name|mmap_flag
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nb
operator|<
name|m
operator|->
name|topsize
condition|)
block|{
comment|/* Allocate from new or extended top space */
name|size_t
name|rsize
init|=
name|m
operator|->
name|topsize
operator|-=
name|nb
decl_stmt|;
name|mchunkptr
name|p
init|=
name|m
operator|->
name|top
decl_stmt|;
name|mchunkptr
name|r
init|=
name|m
operator|->
name|top
operator|=
name|chunk_plus_offset
argument_list|(
name|p
argument_list|,
name|nb
argument_list|)
decl_stmt|;
name|r
operator|->
name|head
operator|=
name|rsize
operator||
name|PINUSE_BIT
expr_stmt|;
name|set_size_and_pinuse_of_inuse_chunk
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|check_top_chunk
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|top
argument_list|)
expr_stmt|;
name|check_malloced_chunk
argument_list|(
name|m
argument_list|,
name|chunk2mem
argument_list|(
name|p
argument_list|)
argument_list|,
name|nb
argument_list|)
expr_stmt|;
return|return
name|chunk2mem
argument_list|(
name|p
argument_list|)
return|;
block|}
block|}
name|MALLOC_FAILURE_ACTION
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* -----------------------  system deallocation -------------------------- */
end_comment
begin_comment
comment|/* Unmap and unlink any mmapped segments that don't contain used chunks */
end_comment
begin_function
DECL|function|release_unused_segments
specifier|static
name|size_t
name|release_unused_segments
parameter_list|(
name|mstate
name|m
parameter_list|)
block|{
name|size_t
name|released
init|=
literal|0
decl_stmt|;
name|int
name|nsegs
init|=
literal|0
decl_stmt|;
name|msegmentptr
name|pred
init|=
operator|&
name|m
operator|->
name|seg
decl_stmt|;
name|msegmentptr
name|sp
init|=
name|pred
operator|->
name|next
decl_stmt|;
while|while
condition|(
name|sp
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|base
init|=
name|sp
operator|->
name|base
decl_stmt|;
name|size_t
name|size
init|=
name|sp
operator|->
name|size
decl_stmt|;
name|msegmentptr
name|next
init|=
name|sp
operator|->
name|next
decl_stmt|;
operator|++
name|nsegs
expr_stmt|;
if|if
condition|(
name|is_mmapped_segment
argument_list|(
name|sp
argument_list|)
operator|&&
operator|!
name|is_extern_segment
argument_list|(
name|sp
argument_list|)
condition|)
block|{
name|mchunkptr
name|p
init|=
name|align_as_chunk
argument_list|(
name|base
argument_list|)
decl_stmt|;
name|size_t
name|psize
init|=
name|chunksize
argument_list|(
name|p
argument_list|)
decl_stmt|;
comment|/* Can unmap if first chunk holds entire segment and not pinned */
if|if
condition|(
operator|!
name|cinuse
argument_list|(
name|p
argument_list|)
operator|&&
operator|(
name|char
operator|*
operator|)
name|p
operator|+
name|psize
operator|>=
name|base
operator|+
name|size
operator|-
name|TOP_FOOT_SIZE
condition|)
block|{
name|tchunkptr
name|tp
init|=
operator|(
name|tchunkptr
operator|)
name|p
decl_stmt|;
name|assert
argument_list|(
name|segment_holds
argument_list|(
name|sp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|m
operator|->
name|dv
condition|)
block|{
name|m
operator|->
name|dv
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|dvsize
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|unlink_large_chunk
argument_list|(
name|m
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CALL_MUNMAP
argument_list|(
name|base
argument_list|,
name|size
argument_list|)
operator|==
literal|0
condition|)
block|{
name|released
operator|+=
name|size
expr_stmt|;
name|m
operator|->
name|footprint
operator|-=
name|size
expr_stmt|;
comment|/* unlink obsoleted record */
name|sp
operator|=
name|pred
expr_stmt|;
name|sp
operator|->
name|next
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
comment|/* back out if cannot unmap */
name|insert_large_chunk
argument_list|(
name|m
argument_list|,
name|tp
argument_list|,
name|psize
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|NO_SEGMENT_TRAVERSAL
condition|)
comment|/* scan only first segment */
break|break;
name|pred
operator|=
name|sp
expr_stmt|;
name|sp
operator|=
name|next
expr_stmt|;
block|}
comment|/* Reset check counter */
name|m
operator|->
name|release_checks
operator|=
operator|(
operator|(
name|nsegs
operator|>
name|MAX_RELEASE_CHECK_RATE
operator|)
condition|?
name|nsegs
else|:
name|MAX_RELEASE_CHECK_RATE
operator|)
expr_stmt|;
return|return
name|released
return|;
block|}
end_function
begin_function
DECL|function|sys_trim
specifier|static
name|int
name|sys_trim
parameter_list|(
name|mstate
name|m
parameter_list|,
name|size_t
name|pad
parameter_list|)
block|{
name|size_t
name|released
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pad
operator|<
name|MAX_REQUEST
operator|&&
name|is_initialized
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|pad
operator|+=
name|TOP_FOOT_SIZE
expr_stmt|;
comment|/* ensure enough room for segment overhead */
if|if
condition|(
name|m
operator|->
name|topsize
operator|>
name|pad
condition|)
block|{
comment|/* Shrink top space in granularity-size units, keeping at least one */
name|size_t
name|unit
init|=
name|mparams
operator|.
name|granularity
decl_stmt|;
name|size_t
name|extra
init|=
operator|(
operator|(
name|m
operator|->
name|topsize
operator|-
name|pad
operator|+
operator|(
name|unit
operator|-
name|SIZE_T_ONE
operator|)
operator|)
operator|/
name|unit
operator|-
name|SIZE_T_ONE
operator|)
operator|*
name|unit
decl_stmt|;
name|msegmentptr
name|sp
init|=
name|segment_holding
argument_list|(
name|m
argument_list|,
operator|(
name|char
operator|*
operator|)
name|m
operator|->
name|top
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|is_extern_segment
argument_list|(
name|sp
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_mmapped_segment
argument_list|(
name|sp
argument_list|)
condition|)
block|{
if|if
condition|(
name|HAVE_MMAP
operator|&&
name|sp
operator|->
name|size
operator|>=
name|extra
operator|&&
operator|!
name|has_segment_link
argument_list|(
name|m
argument_list|,
name|sp
argument_list|)
condition|)
block|{
comment|/* can't shrink if pinned */
name|size_t
name|newsize
init|=
name|sp
operator|->
name|size
operator|-
name|extra
decl_stmt|;
comment|/* Prefer mremap, fall back to munmap */
if|if
condition|(
operator|(
name|CALL_MREMAP
argument_list|(
name|sp
operator|->
name|base
argument_list|,
name|sp
operator|->
name|size
argument_list|,
name|newsize
argument_list|,
literal|0
argument_list|)
operator|!=
name|MFAIL
operator|)
operator|||
operator|(
name|CALL_MUNMAP
argument_list|(
name|sp
operator|->
name|base
operator|+
name|newsize
argument_list|,
name|extra
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|released
operator|=
name|extra
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|HAVE_MORECORE
condition|)
block|{
if|if
condition|(
name|extra
operator|>=
name|HALF_MAX_SIZE_T
condition|)
comment|/* Avoid wrapping negative */
name|extra
operator|=
operator|(
name|HALF_MAX_SIZE_T
operator|)
operator|+
name|SIZE_T_ONE
operator|-
name|unit
expr_stmt|;
name|ACQUIRE_MORECORE_LOCK
argument_list|()
expr_stmt|;
block|{
comment|/* Make sure end of memory is where we last set it. */
name|char
modifier|*
name|old_br
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|CALL_MORECORE
argument_list|(
literal|0
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|old_br
operator|==
name|sp
operator|->
name|base
operator|+
name|sp
operator|->
name|size
condition|)
block|{
name|char
modifier|*
name|rel_br
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|CALL_MORECORE
argument_list|(
operator|-
name|extra
argument_list|)
operator|)
decl_stmt|;
name|char
modifier|*
name|new_br
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|CALL_MORECORE
argument_list|(
literal|0
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|rel_br
operator|!=
name|CMFAIL
operator|&&
name|new_br
operator|<
name|old_br
condition|)
name|released
operator|=
name|old_br
operator|-
name|new_br
expr_stmt|;
block|}
block|}
name|RELEASE_MORECORE_LOCK
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|released
operator|!=
literal|0
condition|)
block|{
name|sp
operator|->
name|size
operator|-=
name|released
expr_stmt|;
name|m
operator|->
name|footprint
operator|-=
name|released
expr_stmt|;
name|init_top
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|top
argument_list|,
name|m
operator|->
name|topsize
operator|-
name|released
argument_list|)
expr_stmt|;
name|check_top_chunk
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|top
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Unmap any unused mmapped segments */
if|if
condition|(
name|HAVE_MMAP
condition|)
name|released
operator|+=
name|release_unused_segments
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* On failure, disable autotrim to avoid repeated failed future calls */
if|if
condition|(
name|released
operator|==
literal|0
operator|&&
name|m
operator|->
name|topsize
operator|>
name|m
operator|->
name|trim_check
condition|)
name|m
operator|->
name|trim_check
operator|=
name|MAX_SIZE_T
expr_stmt|;
block|}
return|return
operator|(
name|released
operator|!=
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/* ---------------------------- malloc support --------------------------- */
end_comment
begin_comment
comment|/* allocate a large request from the best fitting chunk in a treebin */
end_comment
begin_function
DECL|function|tmalloc_large
specifier|static
name|void
modifier|*
name|tmalloc_large
parameter_list|(
name|mstate
name|m
parameter_list|,
name|size_t
name|nb
parameter_list|)
block|{
name|tchunkptr
name|v
init|=
literal|0
decl_stmt|;
name|size_t
name|rsize
init|=
operator|-
name|nb
decl_stmt|;
comment|/* Unsigned negation */
name|tchunkptr
name|t
decl_stmt|;
name|bindex_t
name|idx
decl_stmt|;
name|compute_tree_index
argument_list|(
name|nb
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
operator|*
name|treebin_at
argument_list|(
name|m
argument_list|,
name|idx
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Traverse tree for this bin looking for node with size == nb */
name|size_t
name|sizebits
init|=
name|nb
operator|<<
name|leftshift_for_tree_index
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|tchunkptr
name|rst
init|=
literal|0
decl_stmt|;
comment|/* The deepest untaken right subtree */
for|for
control|(
init|;
condition|;
control|)
block|{
name|tchunkptr
name|rt
decl_stmt|;
name|size_t
name|trem
init|=
name|chunksize
argument_list|(
name|t
argument_list|)
operator|-
name|nb
decl_stmt|;
if|if
condition|(
name|trem
operator|<
name|rsize
condition|)
block|{
name|v
operator|=
name|t
expr_stmt|;
if|if
condition|(
operator|(
name|rsize
operator|=
name|trem
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
name|rt
operator|=
name|t
operator|->
name|child
index|[
literal|1
index|]
expr_stmt|;
name|t
operator|=
name|t
operator|->
name|child
index|[
operator|(
name|sizebits
operator|>>
operator|(
name|SIZE_T_BITSIZE
operator|-
name|SIZE_T_ONE
operator|)
operator|)
operator|&
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|rt
operator|!=
literal|0
operator|&&
name|rt
operator|!=
name|t
condition|)
name|rst
operator|=
name|rt
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
block|{
name|t
operator|=
name|rst
expr_stmt|;
comment|/* set t to least subtree holding sizes> nb */
break|break;
block|}
name|sizebits
operator|<<=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|t
operator|==
literal|0
operator|&&
name|v
operator|==
literal|0
condition|)
block|{
comment|/* set t to root of next non-empty treebin */
name|binmap_t
name|leftbits
init|=
name|left_bits
argument_list|(
name|idx2bit
argument_list|(
name|idx
argument_list|)
argument_list|)
operator|&
name|m
operator|->
name|treemap
decl_stmt|;
if|if
condition|(
name|leftbits
operator|!=
literal|0
condition|)
block|{
name|bindex_t
name|i
decl_stmt|;
name|binmap_t
name|leastbit
init|=
name|least_bit
argument_list|(
name|leftbits
argument_list|)
decl_stmt|;
name|compute_bit2idx
argument_list|(
name|leastbit
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|t
operator|=
operator|*
name|treebin_at
argument_list|(
name|m
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
name|t
operator|!=
literal|0
condition|)
block|{
comment|/* find smallest of tree or subtree */
name|size_t
name|trem
init|=
name|chunksize
argument_list|(
name|t
argument_list|)
operator|-
name|nb
decl_stmt|;
if|if
condition|(
name|trem
operator|<
name|rsize
condition|)
block|{
name|rsize
operator|=
name|trem
expr_stmt|;
name|v
operator|=
name|t
expr_stmt|;
block|}
name|t
operator|=
name|leftmost_child
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
comment|/*  If dv is a better fit, return 0 so malloc will use it */
if|if
condition|(
name|v
operator|!=
literal|0
operator|&&
name|rsize
operator|<
call|(
name|size_t
call|)
argument_list|(
name|m
operator|->
name|dvsize
operator|-
name|nb
argument_list|)
condition|)
block|{
if|if
condition|(
name|RTCHECK
argument_list|(
name|ok_address
argument_list|(
name|m
argument_list|,
name|v
argument_list|)
argument_list|)
condition|)
block|{
comment|/* split */
name|mchunkptr
name|r
init|=
name|chunk_plus_offset
argument_list|(
name|v
argument_list|,
name|nb
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|chunksize
argument_list|(
name|v
argument_list|)
operator|==
name|rsize
operator|+
name|nb
argument_list|)
expr_stmt|;
if|if
condition|(
name|RTCHECK
argument_list|(
name|ok_next
argument_list|(
name|v
argument_list|,
name|r
argument_list|)
argument_list|)
condition|)
block|{
name|unlink_large_chunk
argument_list|(
name|m
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsize
operator|<
name|MIN_CHUNK_SIZE
condition|)
name|set_inuse_and_pinuse
argument_list|(
name|m
argument_list|,
name|v
argument_list|,
operator|(
name|rsize
operator|+
name|nb
operator|)
argument_list|)
expr_stmt|;
else|else
block|{
name|set_size_and_pinuse_of_inuse_chunk
argument_list|(
name|m
argument_list|,
name|v
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|set_size_and_pinuse_of_free_chunk
argument_list|(
name|r
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|insert_chunk
argument_list|(
name|m
argument_list|,
name|r
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
block|}
return|return
name|chunk2mem
argument_list|(
name|v
argument_list|)
return|;
block|}
block|}
name|CORRUPTION_ERROR_ACTION
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* allocate a small request from the best fitting chunk in a treebin */
end_comment
begin_function
DECL|function|tmalloc_small
specifier|static
name|void
modifier|*
name|tmalloc_small
parameter_list|(
name|mstate
name|m
parameter_list|,
name|size_t
name|nb
parameter_list|)
block|{
name|tchunkptr
name|t
decl_stmt|,
name|v
decl_stmt|;
name|size_t
name|rsize
decl_stmt|;
name|bindex_t
name|i
decl_stmt|;
name|binmap_t
name|leastbit
init|=
name|least_bit
argument_list|(
name|m
operator|->
name|treemap
argument_list|)
decl_stmt|;
name|compute_bit2idx
argument_list|(
name|leastbit
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|v
operator|=
name|t
operator|=
operator|*
name|treebin_at
argument_list|(
name|m
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rsize
operator|=
name|chunksize
argument_list|(
name|t
argument_list|)
operator|-
name|nb
expr_stmt|;
while|while
condition|(
operator|(
name|t
operator|=
name|leftmost_child
argument_list|(
name|t
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|size_t
name|trem
init|=
name|chunksize
argument_list|(
name|t
argument_list|)
operator|-
name|nb
decl_stmt|;
if|if
condition|(
name|trem
operator|<
name|rsize
condition|)
block|{
name|rsize
operator|=
name|trem
expr_stmt|;
name|v
operator|=
name|t
expr_stmt|;
block|}
block|}
if|if
condition|(
name|RTCHECK
argument_list|(
name|ok_address
argument_list|(
name|m
argument_list|,
name|v
argument_list|)
argument_list|)
condition|)
block|{
name|mchunkptr
name|r
init|=
name|chunk_plus_offset
argument_list|(
name|v
argument_list|,
name|nb
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|chunksize
argument_list|(
name|v
argument_list|)
operator|==
name|rsize
operator|+
name|nb
argument_list|)
expr_stmt|;
if|if
condition|(
name|RTCHECK
argument_list|(
name|ok_next
argument_list|(
name|v
argument_list|,
name|r
argument_list|)
argument_list|)
condition|)
block|{
name|unlink_large_chunk
argument_list|(
name|m
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsize
operator|<
name|MIN_CHUNK_SIZE
condition|)
name|set_inuse_and_pinuse
argument_list|(
name|m
argument_list|,
name|v
argument_list|,
operator|(
name|rsize
operator|+
name|nb
operator|)
argument_list|)
expr_stmt|;
else|else
block|{
name|set_size_and_pinuse_of_inuse_chunk
argument_list|(
name|m
argument_list|,
name|v
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|set_size_and_pinuse_of_free_chunk
argument_list|(
name|r
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|replace_dv
argument_list|(
name|m
argument_list|,
name|r
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
block|}
return|return
name|chunk2mem
argument_list|(
name|v
argument_list|)
return|;
block|}
block|}
name|CORRUPTION_ERROR_ACTION
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* --------------------------- realloc support --------------------------- */
end_comment
begin_function
DECL|function|internal_realloc
specifier|static
name|void
modifier|*
name|internal_realloc
parameter_list|(
name|mstate
name|m
parameter_list|,
name|void
modifier|*
name|oldmem
parameter_list|,
name|size_t
name|bytes
parameter_list|)
block|{
if|if
condition|(
name|bytes
operator|>=
name|MAX_REQUEST
condition|)
block|{
name|MALLOC_FAILURE_ACTION
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|PREACTION
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|mchunkptr
name|oldp
init|=
name|mem2chunk
argument_list|(
name|oldmem
argument_list|)
decl_stmt|;
name|size_t
name|oldsize
init|=
name|chunksize
argument_list|(
name|oldp
argument_list|)
decl_stmt|;
name|mchunkptr
name|next
init|=
name|chunk_plus_offset
argument_list|(
name|oldp
argument_list|,
name|oldsize
argument_list|)
decl_stmt|;
name|mchunkptr
name|newp
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|extra
init|=
literal|0
decl_stmt|;
comment|/* Try to either shrink or extend into top. Else malloc-copy-free */
if|if
condition|(
name|RTCHECK
argument_list|(
name|ok_address
argument_list|(
name|m
argument_list|,
name|oldp
argument_list|)
operator|&&
name|ok_cinuse
argument_list|(
name|oldp
argument_list|)
operator|&&
name|ok_next
argument_list|(
name|oldp
argument_list|,
name|next
argument_list|)
operator|&&
name|ok_pinuse
argument_list|(
name|next
argument_list|)
argument_list|)
condition|)
block|{
name|size_t
name|nb
init|=
name|request2size
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_mmapped
argument_list|(
name|oldp
argument_list|)
condition|)
name|newp
operator|=
name|mmap_resize
argument_list|(
name|m
argument_list|,
name|oldp
argument_list|,
name|nb
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|oldsize
operator|>=
name|nb
condition|)
block|{
comment|/* already big enough */
name|size_t
name|rsize
init|=
name|oldsize
operator|-
name|nb
decl_stmt|;
name|newp
operator|=
name|oldp
expr_stmt|;
if|if
condition|(
name|rsize
operator|>=
name|MIN_CHUNK_SIZE
condition|)
block|{
name|mchunkptr
name|remainder
init|=
name|chunk_plus_offset
argument_list|(
name|newp
argument_list|,
name|nb
argument_list|)
decl_stmt|;
name|set_inuse
argument_list|(
name|m
argument_list|,
name|newp
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|set_inuse
argument_list|(
name|m
argument_list|,
name|remainder
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|extra
operator|=
name|chunk2mem
argument_list|(
name|remainder
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|next
operator|==
name|m
operator|->
name|top
operator|&&
name|oldsize
operator|+
name|m
operator|->
name|topsize
operator|>
name|nb
condition|)
block|{
comment|/* Expand into top */
name|size_t
name|newsize
init|=
name|oldsize
operator|+
name|m
operator|->
name|topsize
decl_stmt|;
name|size_t
name|newtopsize
init|=
name|newsize
operator|-
name|nb
decl_stmt|;
name|mchunkptr
name|newtop
init|=
name|chunk_plus_offset
argument_list|(
name|oldp
argument_list|,
name|nb
argument_list|)
decl_stmt|;
name|set_inuse
argument_list|(
name|m
argument_list|,
name|oldp
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|newtop
operator|->
name|head
operator|=
name|newtopsize
operator||
name|PINUSE_BIT
expr_stmt|;
name|m
operator|->
name|top
operator|=
name|newtop
expr_stmt|;
name|m
operator|->
name|topsize
operator|=
name|newtopsize
expr_stmt|;
name|newp
operator|=
name|oldp
expr_stmt|;
block|}
block|}
else|else
block|{
name|USAGE_ERROR_ACTION
argument_list|(
name|m
argument_list|,
name|oldmem
argument_list|)
expr_stmt|;
name|POSTACTION
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|POSTACTION
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|newp
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|extra
operator|!=
literal|0
condition|)
block|{
name|internal_free
argument_list|(
name|m
argument_list|,
name|extra
argument_list|)
expr_stmt|;
block|}
name|check_inuse_chunk
argument_list|(
name|m
argument_list|,
name|newp
argument_list|)
expr_stmt|;
return|return
name|chunk2mem
argument_list|(
name|newp
argument_list|)
return|;
block|}
else|else
block|{
name|void
modifier|*
name|newmem
init|=
name|internal_malloc
argument_list|(
name|m
argument_list|,
name|bytes
argument_list|)
decl_stmt|;
if|if
condition|(
name|newmem
operator|!=
literal|0
condition|)
block|{
name|size_t
name|oc
init|=
name|oldsize
operator|-
name|overhead_for
argument_list|(
name|oldp
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|newmem
argument_list|,
name|oldmem
argument_list|,
operator|(
name|oc
operator|<
name|bytes
operator|)
condition|?
name|oc
else|:
name|bytes
argument_list|)
expr_stmt|;
name|internal_free
argument_list|(
name|m
argument_list|,
name|oldmem
argument_list|)
expr_stmt|;
block|}
return|return
name|newmem
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* --------------------------- memalign support -------------------------- */
end_comment
begin_function
DECL|function|internal_memalign
specifier|static
name|void
modifier|*
name|internal_memalign
parameter_list|(
name|mstate
name|m
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|size_t
name|bytes
parameter_list|)
block|{
if|if
condition|(
name|alignment
operator|<=
name|MALLOC_ALIGNMENT
condition|)
comment|/* Can just use malloc */
return|return
name|internal_malloc
argument_list|(
name|m
argument_list|,
name|bytes
argument_list|)
return|;
if|if
condition|(
name|alignment
operator|<
name|MIN_CHUNK_SIZE
condition|)
comment|/* must be at least a minimum chunk size */
name|alignment
operator|=
name|MIN_CHUNK_SIZE
expr_stmt|;
if|if
condition|(
operator|(
name|alignment
operator|&
operator|(
name|alignment
operator|-
name|SIZE_T_ONE
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Ensure a power of 2 */
name|size_t
name|a
init|=
name|MALLOC_ALIGNMENT
operator|<<
literal|1
decl_stmt|;
while|while
condition|(
name|a
operator|<
name|alignment
condition|)
name|a
operator|<<=
literal|1
expr_stmt|;
name|alignment
operator|=
name|a
expr_stmt|;
block|}
if|if
condition|(
name|bytes
operator|>=
name|MAX_REQUEST
operator|-
name|alignment
condition|)
block|{
if|if
condition|(
name|m
operator|!=
literal|0
condition|)
block|{
comment|/* Test isn't needed but avoids compiler warning */
name|MALLOC_FAILURE_ACTION
expr_stmt|;
block|}
block|}
else|else
block|{
name|size_t
name|nb
init|=
name|request2size
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
name|size_t
name|req
init|=
name|nb
operator|+
name|alignment
operator|+
name|MIN_CHUNK_SIZE
operator|-
name|CHUNK_OVERHEAD
decl_stmt|;
name|char
modifier|*
name|mem
init|=
operator|(
name|char
operator|*
operator|)
name|internal_malloc
argument_list|(
name|m
argument_list|,
name|req
argument_list|)
decl_stmt|;
if|if
condition|(
name|mem
operator|!=
literal|0
condition|)
block|{
name|void
modifier|*
name|leader
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|trailer
init|=
literal|0
decl_stmt|;
name|mchunkptr
name|p
init|=
name|mem2chunk
argument_list|(
name|mem
argument_list|)
decl_stmt|;
if|if
condition|(
name|PREACTION
argument_list|(
name|m
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
operator|(
call|(
name|size_t
call|)
argument_list|(
name|mem
argument_list|)
operator|)
operator|%
name|alignment
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* misaligned */
comment|/*           Find an aligned spot inside chunk.  Since we need to give           back leading space in a chunk of at least MIN_CHUNK_SIZE, if           the first calculation places us at a spot with less than           MIN_CHUNK_SIZE leader, we can move to the next aligned spot.           We've allocated enough total room so that this is always           possible.         */
name|char
modifier|*
name|br
init|=
operator|(
name|char
operator|*
operator|)
name|mem2chunk
argument_list|(
call|(
name|size_t
call|)
argument_list|(
operator|(
call|(
name|size_t
call|)
argument_list|(
name|mem
operator|+
name|alignment
operator|-
name|SIZE_T_ONE
argument_list|)
operator|)
operator|&
operator|-
name|alignment
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|pos
init|=
operator|(
call|(
name|size_t
call|)
argument_list|(
name|br
operator|-
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|)
argument_list|)
operator|>=
name|MIN_CHUNK_SIZE
operator|)
condition|?
name|br
else|:
name|br
operator|+
name|alignment
decl_stmt|;
name|mchunkptr
name|newp
init|=
operator|(
name|mchunkptr
operator|)
name|pos
decl_stmt|;
name|size_t
name|leadsize
init|=
name|pos
operator|-
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|)
decl_stmt|;
name|size_t
name|newsize
init|=
name|chunksize
argument_list|(
name|p
argument_list|)
operator|-
name|leadsize
decl_stmt|;
if|if
condition|(
name|is_mmapped
argument_list|(
name|p
argument_list|)
condition|)
block|{
comment|/* For mmapped chunks, just adjust offset */
name|newp
operator|->
name|prev_foot
operator|=
name|p
operator|->
name|prev_foot
operator|+
name|leadsize
expr_stmt|;
name|newp
operator|->
name|head
operator|=
operator|(
name|newsize
operator||
name|CINUSE_BIT
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, give back leader, use the rest */
name|set_inuse
argument_list|(
name|m
argument_list|,
name|newp
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
name|set_inuse
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|leadsize
argument_list|)
expr_stmt|;
name|leader
operator|=
name|chunk2mem
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|newp
expr_stmt|;
block|}
comment|/* Give back spare room at the end */
if|if
condition|(
operator|!
name|is_mmapped
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|size_t
name|size
init|=
name|chunksize
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|nb
operator|+
name|MIN_CHUNK_SIZE
condition|)
block|{
name|size_t
name|remainder_size
init|=
name|size
operator|-
name|nb
decl_stmt|;
name|mchunkptr
name|remainder
init|=
name|chunk_plus_offset
argument_list|(
name|p
argument_list|,
name|nb
argument_list|)
decl_stmt|;
name|set_inuse
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|set_inuse
argument_list|(
name|m
argument_list|,
name|remainder
argument_list|,
name|remainder_size
argument_list|)
expr_stmt|;
name|trailer
operator|=
name|chunk2mem
argument_list|(
name|remainder
argument_list|)
expr_stmt|;
block|}
block|}
name|assert
argument_list|(
name|chunksize
argument_list|(
name|p
argument_list|)
operator|>=
name|nb
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
operator|(
call|(
name|size_t
call|)
argument_list|(
name|chunk2mem
argument_list|(
name|p
argument_list|)
argument_list|)
operator|)
operator|%
name|alignment
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|check_inuse_chunk
argument_list|(
name|m
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|POSTACTION
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|leader
operator|!=
literal|0
condition|)
block|{
name|internal_free
argument_list|(
name|m
argument_list|,
name|leader
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trailer
operator|!=
literal|0
condition|)
block|{
name|internal_free
argument_list|(
name|m
argument_list|,
name|trailer
argument_list|)
expr_stmt|;
block|}
return|return
name|chunk2mem
argument_list|(
name|p
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* ------------------------ comalloc/coalloc support --------------------- */
end_comment
begin_function
DECL|function|ialloc
specifier|static
name|void
modifier|*
modifier|*
name|ialloc
parameter_list|(
name|mstate
name|m
parameter_list|,
name|size_t
name|n_elements
parameter_list|,
name|size_t
modifier|*
name|sizes
parameter_list|,
name|int
name|opts
parameter_list|,
name|void
modifier|*
name|chunks
index|[]
parameter_list|)
block|{
comment|/*     This provides common support for independent_X routines, handling     all of the combinations that can result.      The opts arg has:     bit 0 set if all elements are same size (using sizes[0])     bit 1 set if elements should be zeroed   */
name|size_t
name|element_size
decl_stmt|;
comment|/* chunksize of each element, if all same */
name|size_t
name|contents_size
decl_stmt|;
comment|/* total size of elements */
name|size_t
name|array_size
decl_stmt|;
comment|/* request size of pointer array */
name|void
modifier|*
name|mem
decl_stmt|;
comment|/* malloced aggregate space */
name|mchunkptr
name|p
decl_stmt|;
comment|/* corresponding chunk */
name|size_t
name|remainder_size
decl_stmt|;
comment|/* remaining bytes while splitting */
name|void
modifier|*
modifier|*
name|marray
decl_stmt|;
comment|/* either "chunks" or malloced ptr array */
name|mchunkptr
name|array_chunk
decl_stmt|;
comment|/* chunk for malloced ptr array */
name|flag_t
name|was_enabled
decl_stmt|;
comment|/* to disable mmap */
name|size_t
name|size
decl_stmt|;
name|size_t
name|i
decl_stmt|;
comment|/* compute array length, if needed */
if|if
condition|(
name|chunks
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|n_elements
operator|==
literal|0
condition|)
return|return
name|chunks
return|;
comment|/* nothing to do */
name|marray
operator|=
name|chunks
expr_stmt|;
name|array_size
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* if empty req, must still return chunk representing empty array */
if|if
condition|(
name|n_elements
operator|==
literal|0
condition|)
return|return
operator|(
name|void
operator|*
operator|*
operator|)
name|internal_malloc
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
return|;
name|marray
operator|=
literal|0
expr_stmt|;
name|array_size
operator|=
name|request2size
argument_list|(
name|n_elements
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* compute total element size */
if|if
condition|(
name|opts
operator|&
literal|0x1
condition|)
block|{
comment|/* all-same-size */
name|element_size
operator|=
name|request2size
argument_list|(
operator|*
name|sizes
argument_list|)
expr_stmt|;
name|contents_size
operator|=
name|n_elements
operator|*
name|element_size
expr_stmt|;
block|}
else|else
block|{
comment|/* add up all the sizes */
name|element_size
operator|=
literal|0
expr_stmt|;
name|contents_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|n_elements
condition|;
operator|++
name|i
control|)
name|contents_size
operator|+=
name|request2size
argument_list|(
name|sizes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|size
operator|=
name|contents_size
operator|+
name|array_size
expr_stmt|;
comment|/*      Allocate the aggregate chunk.  First disable direct-mmapping so      malloc won't use it, since we would not be able to later      free/realloc space internal to a segregated mmap region.   */
name|was_enabled
operator|=
name|use_mmap
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|disable_mmap
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|mem
operator|=
name|internal_malloc
argument_list|(
name|m
argument_list|,
name|size
operator|-
name|CHUNK_OVERHEAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|was_enabled
condition|)
name|enable_mmap
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|PREACTION
argument_list|(
name|m
argument_list|)
condition|)
return|return
literal|0
return|;
name|p
operator|=
name|mem2chunk
argument_list|(
name|mem
argument_list|)
expr_stmt|;
name|remainder_size
operator|=
name|chunksize
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|is_mmapped
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|&
literal|0x2
condition|)
block|{
comment|/* optionally clear the elements */
name|memset
argument_list|(
operator|(
name|size_t
operator|*
operator|)
name|mem
argument_list|,
literal|0
argument_list|,
name|remainder_size
operator|-
name|SIZE_T_SIZE
operator|-
name|array_size
argument_list|)
expr_stmt|;
block|}
comment|/* If not provided, allocate the pointer array as final part of chunk */
if|if
condition|(
name|marray
operator|==
literal|0
condition|)
block|{
name|size_t
name|array_chunk_size
decl_stmt|;
name|array_chunk
operator|=
name|chunk_plus_offset
argument_list|(
name|p
argument_list|,
name|contents_size
argument_list|)
expr_stmt|;
name|array_chunk_size
operator|=
name|remainder_size
operator|-
name|contents_size
expr_stmt|;
name|marray
operator|=
operator|(
name|void
operator|*
operator|*
operator|)
operator|(
name|chunk2mem
argument_list|(
name|array_chunk
argument_list|)
operator|)
expr_stmt|;
name|set_size_and_pinuse_of_inuse_chunk
argument_list|(
name|m
argument_list|,
name|array_chunk
argument_list|,
name|array_chunk_size
argument_list|)
expr_stmt|;
name|remainder_size
operator|=
name|contents_size
expr_stmt|;
block|}
comment|/* split out elements */
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
operator|++
name|i
control|)
block|{
name|marray
index|[
name|i
index|]
operator|=
name|chunk2mem
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|n_elements
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|element_size
operator|!=
literal|0
condition|)
name|size
operator|=
name|element_size
expr_stmt|;
else|else
name|size
operator|=
name|request2size
argument_list|(
name|sizes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|remainder_size
operator|-=
name|size
expr_stmt|;
name|set_size_and_pinuse_of_inuse_chunk
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|p
operator|=
name|chunk_plus_offset
argument_list|(
name|p
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* the final element absorbs any overallocation slop */
name|set_size_and_pinuse_of_inuse_chunk
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|remainder_size
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|#
directive|if
name|DEBUG
if|if
condition|(
name|marray
operator|!=
name|chunks
condition|)
block|{
comment|/* final element must have exactly exhausted chunk */
if|if
condition|(
name|element_size
operator|!=
literal|0
condition|)
block|{
name|assert
argument_list|(
name|remainder_size
operator|==
name|element_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|remainder_size
operator|==
name|request2size
argument_list|(
name|sizes
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|check_inuse_chunk
argument_list|(
name|m
argument_list|,
name|mem2chunk
argument_list|(
name|marray
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|n_elements
condition|;
operator|++
name|i
control|)
name|check_inuse_chunk
argument_list|(
name|m
argument_list|,
name|mem2chunk
argument_list|(
name|marray
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|POSTACTION
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|marray
return|;
block|}
end_function
begin_comment
comment|/* -------------------------- public routines ---------------------------- */
end_comment
begin_if
if|#
directive|if
operator|!
name|ONLY_MSPACES
end_if
begin_function
DECL|function|dlmalloc
name|void
modifier|*
name|dlmalloc
parameter_list|(
name|size_t
name|bytes
parameter_list|)
block|{
comment|/*      Basic algorithm:      If a small request (< 256 bytes minus per-chunk overhead):        1. If one exists, use a remainderless chunk in associated smallbin.           (Remainderless means that there are too few excess bytes to           represent as a chunk.)        2. If it is big enough, use the dv chunk, which is normally the           chunk adjacent to the one used for the most recent small request.        3. If one exists, split the smallest available chunk in a bin,           saving remainder in dv.        4. If it is big enough, use the top chunk.        5. If available, get memory from system and use it      Otherwise, for a large request:        1. Find the smallest available binned chunk that fits, and use it           if it is better fitting than dv chunk, splitting if necessary.        2. If better fitting than any binned chunk, use the dv chunk.        3. If it is big enough, use the top chunk.        4. If request size>= mmap threshold, try to directly mmap this chunk.        5. If available, get memory from system and use it       The ugly goto's here ensure that postaction occurs along all paths.   */
if|if
condition|(
operator|!
name|PREACTION
argument_list|(
name|gm
argument_list|)
condition|)
block|{
name|void
modifier|*
name|mem
decl_stmt|;
name|size_t
name|nb
decl_stmt|;
if|if
condition|(
name|bytes
operator|<=
name|MAX_SMALL_REQUEST
condition|)
block|{
name|bindex_t
name|idx
decl_stmt|;
name|binmap_t
name|smallbits
decl_stmt|;
name|nb
operator|=
operator|(
name|bytes
operator|<
name|MIN_REQUEST
operator|)
condition|?
name|MIN_CHUNK_SIZE
else|:
name|pad_request
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
name|idx
operator|=
name|small_index
argument_list|(
name|nb
argument_list|)
expr_stmt|;
name|smallbits
operator|=
name|gm
operator|->
name|smallmap
operator|>>
name|idx
expr_stmt|;
if|if
condition|(
operator|(
name|smallbits
operator|&
literal|0x3U
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Remainderless fit to a smallbin. */
name|mchunkptr
name|b
decl_stmt|,
name|p
decl_stmt|;
name|idx
operator|+=
operator|~
name|smallbits
operator|&
literal|1
expr_stmt|;
comment|/* Uses next bin if idx empty */
name|b
operator|=
name|smallbin_at
argument_list|(
name|gm
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|p
operator|=
name|b
operator|->
name|fd
expr_stmt|;
name|assert
argument_list|(
name|chunksize
argument_list|(
name|p
argument_list|)
operator|==
name|small_index2size
argument_list|(
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|unlink_first_small_chunk
argument_list|(
name|gm
argument_list|,
name|b
argument_list|,
name|p
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|set_inuse_and_pinuse
argument_list|(
name|gm
argument_list|,
name|p
argument_list|,
name|small_index2size
argument_list|(
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|chunk2mem
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|check_malloced_chunk
argument_list|(
name|gm
argument_list|,
name|mem
argument_list|,
name|nb
argument_list|)
expr_stmt|;
goto|goto
name|postaction
goto|;
block|}
elseif|else
if|if
condition|(
name|nb
operator|>
name|gm
operator|->
name|dvsize
condition|)
block|{
if|if
condition|(
name|smallbits
operator|!=
literal|0
condition|)
block|{
comment|/* Use chunk in next nonempty smallbin */
name|mchunkptr
name|b
decl_stmt|,
name|p
decl_stmt|,
name|r
decl_stmt|;
name|size_t
name|rsize
decl_stmt|;
name|bindex_t
name|i
decl_stmt|;
name|binmap_t
name|leftbits
init|=
operator|(
name|smallbits
operator|<<
name|idx
operator|)
operator|&
name|left_bits
argument_list|(
name|idx2bit
argument_list|(
name|idx
argument_list|)
argument_list|)
decl_stmt|;
name|binmap_t
name|leastbit
init|=
name|least_bit
argument_list|(
name|leftbits
argument_list|)
decl_stmt|;
name|compute_bit2idx
argument_list|(
name|leastbit
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|b
operator|=
name|smallbin_at
argument_list|(
name|gm
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|p
operator|=
name|b
operator|->
name|fd
expr_stmt|;
name|assert
argument_list|(
name|chunksize
argument_list|(
name|p
argument_list|)
operator|==
name|small_index2size
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|unlink_first_small_chunk
argument_list|(
name|gm
argument_list|,
name|b
argument_list|,
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rsize
operator|=
name|small_index2size
argument_list|(
name|i
argument_list|)
operator|-
name|nb
expr_stmt|;
comment|/* Fit here cannot be remainderless if 4byte sizes */
if|if
condition|(
name|SIZE_T_SIZE
operator|!=
literal|4
operator|&&
name|rsize
operator|<
name|MIN_CHUNK_SIZE
condition|)
name|set_inuse_and_pinuse
argument_list|(
name|gm
argument_list|,
name|p
argument_list|,
name|small_index2size
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|set_size_and_pinuse_of_inuse_chunk
argument_list|(
name|gm
argument_list|,
name|p
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|r
operator|=
name|chunk_plus_offset
argument_list|(
name|p
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|set_size_and_pinuse_of_free_chunk
argument_list|(
name|r
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|replace_dv
argument_list|(
name|gm
argument_list|,
name|r
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
block|}
name|mem
operator|=
name|chunk2mem
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|check_malloced_chunk
argument_list|(
name|gm
argument_list|,
name|mem
argument_list|,
name|nb
argument_list|)
expr_stmt|;
goto|goto
name|postaction
goto|;
block|}
elseif|else
if|if
condition|(
name|gm
operator|->
name|treemap
operator|!=
literal|0
operator|&&
operator|(
name|mem
operator|=
name|tmalloc_small
argument_list|(
name|gm
argument_list|,
name|nb
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|check_malloced_chunk
argument_list|(
name|gm
argument_list|,
name|mem
argument_list|,
name|nb
argument_list|)
expr_stmt|;
goto|goto
name|postaction
goto|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|bytes
operator|>=
name|MAX_REQUEST
condition|)
name|nb
operator|=
name|MAX_SIZE_T
expr_stmt|;
comment|/* Too big to allocate. Force failure (in sys alloc) */
else|else
block|{
name|nb
operator|=
name|pad_request
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|gm
operator|->
name|treemap
operator|!=
literal|0
operator|&&
operator|(
name|mem
operator|=
name|tmalloc_large
argument_list|(
name|gm
argument_list|,
name|nb
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|check_malloced_chunk
argument_list|(
name|gm
argument_list|,
name|mem
argument_list|,
name|nb
argument_list|)
expr_stmt|;
goto|goto
name|postaction
goto|;
block|}
block|}
if|if
condition|(
name|nb
operator|<=
name|gm
operator|->
name|dvsize
condition|)
block|{
name|size_t
name|rsize
init|=
name|gm
operator|->
name|dvsize
operator|-
name|nb
decl_stmt|;
name|mchunkptr
name|p
init|=
name|gm
operator|->
name|dv
decl_stmt|;
if|if
condition|(
name|rsize
operator|>=
name|MIN_CHUNK_SIZE
condition|)
block|{
comment|/* split dv */
name|mchunkptr
name|r
init|=
name|gm
operator|->
name|dv
operator|=
name|chunk_plus_offset
argument_list|(
name|p
argument_list|,
name|nb
argument_list|)
decl_stmt|;
name|gm
operator|->
name|dvsize
operator|=
name|rsize
expr_stmt|;
name|set_size_and_pinuse_of_free_chunk
argument_list|(
name|r
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|set_size_and_pinuse_of_inuse_chunk
argument_list|(
name|gm
argument_list|,
name|p
argument_list|,
name|nb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* exhaust dv */
name|size_t
name|dvs
init|=
name|gm
operator|->
name|dvsize
decl_stmt|;
name|gm
operator|->
name|dvsize
operator|=
literal|0
expr_stmt|;
name|gm
operator|->
name|dv
operator|=
literal|0
expr_stmt|;
name|set_inuse_and_pinuse
argument_list|(
name|gm
argument_list|,
name|p
argument_list|,
name|dvs
argument_list|)
expr_stmt|;
block|}
name|mem
operator|=
name|chunk2mem
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|check_malloced_chunk
argument_list|(
name|gm
argument_list|,
name|mem
argument_list|,
name|nb
argument_list|)
expr_stmt|;
goto|goto
name|postaction
goto|;
block|}
elseif|else
if|if
condition|(
name|nb
operator|<
name|gm
operator|->
name|topsize
condition|)
block|{
comment|/* Split top */
name|size_t
name|rsize
init|=
name|gm
operator|->
name|topsize
operator|-=
name|nb
decl_stmt|;
name|mchunkptr
name|p
init|=
name|gm
operator|->
name|top
decl_stmt|;
name|mchunkptr
name|r
init|=
name|gm
operator|->
name|top
operator|=
name|chunk_plus_offset
argument_list|(
name|p
argument_list|,
name|nb
argument_list|)
decl_stmt|;
name|r
operator|->
name|head
operator|=
name|rsize
operator||
name|PINUSE_BIT
expr_stmt|;
name|set_size_and_pinuse_of_inuse_chunk
argument_list|(
name|gm
argument_list|,
name|p
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|mem
operator|=
name|chunk2mem
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|check_top_chunk
argument_list|(
name|gm
argument_list|,
name|gm
operator|->
name|top
argument_list|)
expr_stmt|;
name|check_malloced_chunk
argument_list|(
name|gm
argument_list|,
name|mem
argument_list|,
name|nb
argument_list|)
expr_stmt|;
goto|goto
name|postaction
goto|;
block|}
name|mem
operator|=
name|sys_alloc
argument_list|(
name|gm
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|postaction
label|:
name|POSTACTION
argument_list|(
name|gm
argument_list|)
expr_stmt|;
return|return
name|mem
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|dlfree
name|void
name|dlfree
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|)
block|{
comment|/*      Consolidate freed chunks with preceeding or succeeding bordering      free chunks, if they exist, and then place in a bin.  Intermixed      with special cases for top, dv, mmapped chunks, and usage errors.   */
if|if
condition|(
name|mem
operator|!=
literal|0
condition|)
block|{
name|mchunkptr
name|p
init|=
name|mem2chunk
argument_list|(
name|mem
argument_list|)
decl_stmt|;
if|#
directive|if
name|FOOTERS
name|mstate
name|fm
init|=
name|get_mstate_for
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok_magic
argument_list|(
name|fm
argument_list|)
condition|)
block|{
name|USAGE_ERROR_ACTION
argument_list|(
name|fm
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
comment|/* FOOTERS */
define|#
directive|define
name|fm
value|gm
endif|#
directive|endif
comment|/* FOOTERS */
if|if
condition|(
operator|!
name|PREACTION
argument_list|(
name|fm
argument_list|)
condition|)
block|{
name|check_inuse_chunk
argument_list|(
name|fm
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|RTCHECK
argument_list|(
name|ok_address
argument_list|(
name|fm
argument_list|,
name|p
argument_list|)
operator|&&
name|ok_cinuse
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
block|{
name|size_t
name|psize
init|=
name|chunksize
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|mchunkptr
name|next
init|=
name|chunk_plus_offset
argument_list|(
name|p
argument_list|,
name|psize
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|pinuse
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|size_t
name|prevsize
init|=
name|p
operator|->
name|prev_foot
decl_stmt|;
if|if
condition|(
operator|(
name|prevsize
operator|&
name|IS_MMAPPED_BIT
operator|)
operator|!=
literal|0
condition|)
block|{
name|prevsize
operator|&=
operator|~
name|IS_MMAPPED_BIT
expr_stmt|;
name|psize
operator|+=
name|prevsize
operator|+
name|MMAP_FOOT_PAD
expr_stmt|;
if|if
condition|(
name|CALL_MUNMAP
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|-
name|prevsize
argument_list|,
name|psize
argument_list|)
operator|==
literal|0
condition|)
name|fm
operator|->
name|footprint
operator|-=
name|psize
expr_stmt|;
goto|goto
name|postaction
goto|;
block|}
else|else
block|{
name|mchunkptr
name|prev
init|=
name|chunk_minus_offset
argument_list|(
name|p
argument_list|,
name|prevsize
argument_list|)
decl_stmt|;
name|psize
operator|+=
name|prevsize
expr_stmt|;
name|p
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|RTCHECK
argument_list|(
name|ok_address
argument_list|(
name|fm
argument_list|,
name|prev
argument_list|)
argument_list|)
condition|)
block|{
comment|/* consolidate backward */
if|if
condition|(
name|p
operator|!=
name|fm
operator|->
name|dv
condition|)
block|{
name|unlink_chunk
argument_list|(
name|fm
argument_list|,
name|p
argument_list|,
name|prevsize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|next
operator|->
name|head
operator|&
name|INUSE_BITS
operator|)
operator|==
name|INUSE_BITS
condition|)
block|{
name|fm
operator|->
name|dvsize
operator|=
name|psize
expr_stmt|;
name|set_free_with_pinuse
argument_list|(
name|p
argument_list|,
name|psize
argument_list|,
name|next
argument_list|)
expr_stmt|;
goto|goto
name|postaction
goto|;
block|}
block|}
else|else
goto|goto
name|erroraction
goto|;
block|}
block|}
if|if
condition|(
name|RTCHECK
argument_list|(
name|ok_next
argument_list|(
name|p
argument_list|,
name|next
argument_list|)
operator|&&
name|ok_pinuse
argument_list|(
name|next
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|cinuse
argument_list|(
name|next
argument_list|)
condition|)
block|{
comment|/* consolidate forward */
if|if
condition|(
name|next
operator|==
name|fm
operator|->
name|top
condition|)
block|{
name|size_t
name|tsize
init|=
name|fm
operator|->
name|topsize
operator|+=
name|psize
decl_stmt|;
name|fm
operator|->
name|top
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|head
operator|=
name|tsize
operator||
name|PINUSE_BIT
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|fm
operator|->
name|dv
condition|)
block|{
name|fm
operator|->
name|dv
operator|=
literal|0
expr_stmt|;
name|fm
operator|->
name|dvsize
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|should_trim
argument_list|(
name|fm
argument_list|,
name|tsize
argument_list|)
condition|)
name|sys_trim
argument_list|(
name|fm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|postaction
goto|;
block|}
elseif|else
if|if
condition|(
name|next
operator|==
name|fm
operator|->
name|dv
condition|)
block|{
name|size_t
name|dsize
init|=
name|fm
operator|->
name|dvsize
operator|+=
name|psize
decl_stmt|;
name|fm
operator|->
name|dv
operator|=
name|p
expr_stmt|;
name|set_size_and_pinuse_of_free_chunk
argument_list|(
name|p
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
goto|goto
name|postaction
goto|;
block|}
else|else
block|{
name|size_t
name|nsize
init|=
name|chunksize
argument_list|(
name|next
argument_list|)
decl_stmt|;
name|psize
operator|+=
name|nsize
expr_stmt|;
name|unlink_chunk
argument_list|(
name|fm
argument_list|,
name|next
argument_list|,
name|nsize
argument_list|)
expr_stmt|;
name|set_size_and_pinuse_of_free_chunk
argument_list|(
name|p
argument_list|,
name|psize
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|fm
operator|->
name|dv
condition|)
block|{
name|fm
operator|->
name|dvsize
operator|=
name|psize
expr_stmt|;
goto|goto
name|postaction
goto|;
block|}
block|}
block|}
else|else
name|set_free_with_pinuse
argument_list|(
name|p
argument_list|,
name|psize
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_small
argument_list|(
name|psize
argument_list|)
condition|)
block|{
name|insert_small_chunk
argument_list|(
name|fm
argument_list|,
name|p
argument_list|,
name|psize
argument_list|)
expr_stmt|;
name|check_free_chunk
argument_list|(
name|fm
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tchunkptr
name|tp
init|=
operator|(
name|tchunkptr
operator|)
name|p
decl_stmt|;
name|insert_large_chunk
argument_list|(
name|fm
argument_list|,
name|tp
argument_list|,
name|psize
argument_list|)
expr_stmt|;
name|check_free_chunk
argument_list|(
name|fm
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|fm
operator|->
name|release_checks
operator|==
literal|0
condition|)
name|release_unused_segments
argument_list|(
name|fm
argument_list|)
expr_stmt|;
block|}
goto|goto
name|postaction
goto|;
block|}
block|}
name|erroraction
label|:
name|USAGE_ERROR_ACTION
argument_list|(
name|fm
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|postaction
label|:
name|POSTACTION
argument_list|(
name|fm
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
operator|!
name|FOOTERS
DECL|macro|fm
undef|#
directive|undef
name|fm
endif|#
directive|endif
comment|/* FOOTERS */
block|}
end_function
begin_function
DECL|function|dlcalloc
name|void
modifier|*
name|dlcalloc
parameter_list|(
name|size_t
name|n_elements
parameter_list|,
name|size_t
name|elem_size
parameter_list|)
block|{
name|void
modifier|*
name|mem
decl_stmt|;
name|size_t
name|req
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|n_elements
operator|!=
literal|0
condition|)
block|{
name|req
operator|=
name|n_elements
operator|*
name|elem_size
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|n_elements
operator||
name|elem_size
operator|)
operator|&
operator|~
operator|(
name|size_t
operator|)
literal|0xffff
operator|)
operator|&&
operator|(
name|req
operator|/
name|n_elements
operator|!=
name|elem_size
operator|)
condition|)
name|req
operator|=
name|MAX_SIZE_T
expr_stmt|;
comment|/* force downstream failure on overflow */
block|}
name|mem
operator|=
name|dlmalloc
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|!=
literal|0
operator|&&
name|calloc_must_clear
argument_list|(
name|mem2chunk
argument_list|(
name|mem
argument_list|)
argument_list|)
condition|)
name|memset
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
return|return
name|mem
return|;
block|}
end_function
begin_function
DECL|function|dlrealloc
name|void
modifier|*
name|dlrealloc
parameter_list|(
name|void
modifier|*
name|oldmem
parameter_list|,
name|size_t
name|bytes
parameter_list|)
block|{
if|if
condition|(
name|oldmem
operator|==
literal|0
condition|)
return|return
name|dlmalloc
argument_list|(
name|bytes
argument_list|)
return|;
ifdef|#
directive|ifdef
name|REALLOC_ZERO_BYTES_FREES
if|if
condition|(
name|bytes
operator|==
literal|0
condition|)
block|{
name|dlfree
argument_list|(
name|oldmem
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* REALLOC_ZERO_BYTES_FREES */
else|else
block|{
if|#
directive|if
operator|!
name|FOOTERS
name|mstate
name|m
init|=
name|gm
decl_stmt|;
else|#
directive|else
comment|/* FOOTERS */
name|mstate
name|m
init|=
name|get_mstate_for
argument_list|(
name|mem2chunk
argument_list|(
name|oldmem
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok_magic
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|USAGE_ERROR_ACTION
argument_list|(
name|m
argument_list|,
name|oldmem
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* FOOTERS */
return|return
name|internal_realloc
argument_list|(
name|m
argument_list|,
name|oldmem
argument_list|,
name|bytes
argument_list|)
return|;
block|}
block|}
end_function
begin_function
DECL|function|dlmemalign
name|void
modifier|*
name|dlmemalign
parameter_list|(
name|size_t
name|alignment
parameter_list|,
name|size_t
name|bytes
parameter_list|)
block|{
return|return
name|internal_memalign
argument_list|(
name|gm
argument_list|,
name|alignment
argument_list|,
name|bytes
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|dlindependent_calloc
name|void
modifier|*
modifier|*
name|dlindependent_calloc
parameter_list|(
name|size_t
name|n_elements
parameter_list|,
name|size_t
name|elem_size
parameter_list|,
name|void
modifier|*
name|chunks
index|[]
parameter_list|)
block|{
name|size_t
name|sz
init|=
name|elem_size
decl_stmt|;
comment|/* serves as 1-element array */
return|return
name|ialloc
argument_list|(
name|gm
argument_list|,
name|n_elements
argument_list|,
operator|&
name|sz
argument_list|,
literal|3
argument_list|,
name|chunks
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|dlindependent_comalloc
name|void
modifier|*
modifier|*
name|dlindependent_comalloc
parameter_list|(
name|size_t
name|n_elements
parameter_list|,
name|size_t
name|sizes
index|[]
parameter_list|,
name|void
modifier|*
name|chunks
index|[]
parameter_list|)
block|{
return|return
name|ialloc
argument_list|(
name|gm
argument_list|,
name|n_elements
argument_list|,
name|sizes
argument_list|,
literal|0
argument_list|,
name|chunks
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|dlvalloc
name|void
modifier|*
name|dlvalloc
parameter_list|(
name|size_t
name|bytes
parameter_list|)
block|{
name|size_t
name|pagesz
decl_stmt|;
name|init_mparams
argument_list|()
expr_stmt|;
name|pagesz
operator|=
name|mparams
operator|.
name|page_size
expr_stmt|;
return|return
name|dlmemalign
argument_list|(
name|pagesz
argument_list|,
name|bytes
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|dlpvalloc
name|void
modifier|*
name|dlpvalloc
parameter_list|(
name|size_t
name|bytes
parameter_list|)
block|{
name|size_t
name|pagesz
decl_stmt|;
name|init_mparams
argument_list|()
expr_stmt|;
name|pagesz
operator|=
name|mparams
operator|.
name|page_size
expr_stmt|;
return|return
name|dlmemalign
argument_list|(
name|pagesz
argument_list|,
operator|(
name|bytes
operator|+
name|pagesz
operator|-
name|SIZE_T_ONE
operator|)
operator|&
operator|~
operator|(
name|pagesz
operator|-
name|SIZE_T_ONE
operator|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|dlmalloc_trim
name|int
name|dlmalloc_trim
parameter_list|(
name|size_t
name|pad
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|PREACTION
argument_list|(
name|gm
argument_list|)
condition|)
block|{
name|result
operator|=
name|sys_trim
argument_list|(
name|gm
argument_list|,
name|pad
argument_list|)
expr_stmt|;
name|POSTACTION
argument_list|(
name|gm
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|dlmalloc_footprint
name|size_t
name|dlmalloc_footprint
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|gm
operator|->
name|footprint
return|;
block|}
end_function
begin_function
DECL|function|dlmalloc_max_footprint
name|size_t
name|dlmalloc_max_footprint
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|gm
operator|->
name|max_footprint
return|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|NO_MALLINFO
end_if
begin_function
DECL|function|dlmallinfo
name|struct
name|mallinfo
name|dlmallinfo
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|internal_mallinfo
argument_list|(
name|gm
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* NO_MALLINFO */
end_comment
begin_function
DECL|function|dlmalloc_stats
name|void
name|dlmalloc_stats
parameter_list|()
block|{
name|internal_malloc_stats
argument_list|(
name|gm
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|dlmalloc_usable_size
name|size_t
name|dlmalloc_usable_size
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|)
block|{
if|if
condition|(
name|mem
operator|!=
literal|0
condition|)
block|{
name|mchunkptr
name|p
init|=
name|mem2chunk
argument_list|(
name|mem
argument_list|)
decl_stmt|;
if|if
condition|(
name|cinuse
argument_list|(
name|p
argument_list|)
condition|)
return|return
name|chunksize
argument_list|(
name|p
argument_list|)
operator|-
name|overhead_for
argument_list|(
name|p
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|dlmallopt
name|int
name|dlmallopt
parameter_list|(
name|int
name|param_number
parameter_list|,
name|int
name|value
parameter_list|)
block|{
return|return
name|change_mparam
argument_list|(
name|param_number
argument_list|,
name|value
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !ONLY_MSPACES */
end_comment
begin_comment
comment|/* ----------------------------- user mspaces ---------------------------- */
end_comment
begin_if
if|#
directive|if
name|MSPACES
end_if
begin_function
DECL|function|init_user_mstate
specifier|static
name|mstate
name|init_user_mstate
parameter_list|(
name|char
modifier|*
name|tbase
parameter_list|,
name|size_t
name|tsize
parameter_list|)
block|{
name|size_t
name|msize
init|=
name|pad_request
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|malloc_state
argument_list|)
argument_list|)
decl_stmt|;
name|mchunkptr
name|mn
decl_stmt|;
name|mchunkptr
name|msp
init|=
name|align_as_chunk
argument_list|(
name|tbase
argument_list|)
decl_stmt|;
name|mstate
name|m
init|=
call|(
name|mstate
call|)
argument_list|(
name|chunk2mem
argument_list|(
name|msp
argument_list|)
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|msize
argument_list|)
expr_stmt|;
name|INITIAL_LOCK
argument_list|(
operator|&
name|m
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|msp
operator|->
name|head
operator|=
operator|(
name|msize
operator||
name|PINUSE_BIT
operator||
name|CINUSE_BIT
operator|)
expr_stmt|;
name|m
operator|->
name|seg
operator|.
name|base
operator|=
name|m
operator|->
name|least_addr
operator|=
name|tbase
expr_stmt|;
name|m
operator|->
name|seg
operator|.
name|size
operator|=
name|m
operator|->
name|footprint
operator|=
name|m
operator|->
name|max_footprint
operator|=
name|tsize
expr_stmt|;
name|m
operator|->
name|magic
operator|=
name|mparams
operator|.
name|magic
expr_stmt|;
name|m
operator|->
name|release_checks
operator|=
name|MAX_RELEASE_CHECK_RATE
expr_stmt|;
name|m
operator|->
name|mflags
operator|=
name|mparams
operator|.
name|default_mflags
expr_stmt|;
name|m
operator|->
name|extp
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|exts
operator|=
literal|0
expr_stmt|;
name|disable_contiguous
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|init_bins
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|mn
operator|=
name|next_chunk
argument_list|(
name|mem2chunk
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|init_top
argument_list|(
name|m
argument_list|,
name|mn
argument_list|,
call|(
name|size_t
call|)
argument_list|(
operator|(
name|tbase
operator|+
name|tsize
operator|)
operator|-
operator|(
name|char
operator|*
operator|)
name|mn
argument_list|)
operator|-
name|TOP_FOOT_SIZE
argument_list|)
expr_stmt|;
name|check_top_chunk
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|top
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function
begin_function
DECL|function|create_mspace
name|mspace
name|create_mspace
parameter_list|(
name|size_t
name|capacity
parameter_list|,
name|int
name|locked
parameter_list|)
block|{
name|mstate
name|m
init|=
literal|0
decl_stmt|;
name|size_t
name|msize
init|=
name|pad_request
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|malloc_state
argument_list|)
argument_list|)
decl_stmt|;
name|init_mparams
argument_list|()
expr_stmt|;
comment|/* Ensure pagesize etc initialized */
if|if
condition|(
name|capacity
operator|<
operator|(
name|size_t
operator|)
operator|-
operator|(
name|msize
operator|+
name|TOP_FOOT_SIZE
operator|+
name|mparams
operator|.
name|page_size
operator|)
condition|)
block|{
name|size_t
name|rs
init|=
operator|(
operator|(
name|capacity
operator|==
literal|0
operator|)
condition|?
name|mparams
operator|.
name|granularity
else|:
operator|(
name|capacity
operator|+
name|TOP_FOOT_SIZE
operator|+
name|msize
operator|)
operator|)
decl_stmt|;
name|size_t
name|tsize
init|=
name|granularity_align
argument_list|(
name|rs
argument_list|)
decl_stmt|;
name|char
modifier|*
name|tbase
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|CALL_MMAP
argument_list|(
name|tsize
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|tbase
operator|!=
name|CMFAIL
condition|)
block|{
name|m
operator|=
name|init_user_mstate
argument_list|(
name|tbase
argument_list|,
name|tsize
argument_list|)
expr_stmt|;
name|m
operator|->
name|seg
operator|.
name|sflags
operator|=
name|IS_MMAPPED_BIT
expr_stmt|;
name|set_lock
argument_list|(
name|m
argument_list|,
name|locked
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|mspace
operator|)
name|m
return|;
block|}
end_function
begin_function
DECL|function|create_mspace_with_base
name|mspace
name|create_mspace_with_base
parameter_list|(
name|void
modifier|*
name|base
parameter_list|,
name|size_t
name|capacity
parameter_list|,
name|int
name|locked
parameter_list|)
block|{
name|mstate
name|m
init|=
literal|0
decl_stmt|;
name|size_t
name|msize
init|=
name|pad_request
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|malloc_state
argument_list|)
argument_list|)
decl_stmt|;
name|init_mparams
argument_list|()
expr_stmt|;
comment|/* Ensure pagesize etc initialized */
if|if
condition|(
name|capacity
operator|>
name|msize
operator|+
name|TOP_FOOT_SIZE
operator|&&
name|capacity
operator|<
operator|(
name|size_t
operator|)
operator|-
operator|(
name|msize
operator|+
name|TOP_FOOT_SIZE
operator|+
name|mparams
operator|.
name|page_size
operator|)
condition|)
block|{
name|m
operator|=
name|init_user_mstate
argument_list|(
operator|(
name|char
operator|*
operator|)
name|base
argument_list|,
name|capacity
argument_list|)
expr_stmt|;
name|m
operator|->
name|seg
operator|.
name|sflags
operator|=
name|EXTERN_BIT
expr_stmt|;
name|set_lock
argument_list|(
name|m
argument_list|,
name|locked
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|mspace
operator|)
name|m
return|;
block|}
end_function
begin_function
DECL|function|destroy_mspace
name|size_t
name|destroy_mspace
parameter_list|(
name|mspace
name|msp
parameter_list|)
block|{
name|size_t
name|freed
init|=
literal|0
decl_stmt|;
name|mstate
name|ms
init|=
operator|(
name|mstate
operator|)
name|msp
decl_stmt|;
if|if
condition|(
name|ok_magic
argument_list|(
name|ms
argument_list|)
condition|)
block|{
name|msegmentptr
name|sp
init|=
operator|&
name|ms
operator|->
name|seg
decl_stmt|;
while|while
condition|(
name|sp
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|base
init|=
name|sp
operator|->
name|base
decl_stmt|;
name|size_t
name|size
init|=
name|sp
operator|->
name|size
decl_stmt|;
name|flag_t
name|flag
init|=
name|sp
operator|->
name|sflags
decl_stmt|;
name|sp
operator|=
name|sp
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|(
name|flag
operator|&
name|IS_MMAPPED_BIT
operator|)
operator|&&
operator|!
operator|(
name|flag
operator|&
name|EXTERN_BIT
operator|)
operator|&&
name|CALL_MUNMAP
argument_list|(
name|base
argument_list|,
name|size
argument_list|)
operator|==
literal|0
condition|)
name|freed
operator|+=
name|size
expr_stmt|;
block|}
block|}
else|else
block|{
name|USAGE_ERROR_ACTION
argument_list|(
name|ms
argument_list|,
name|ms
argument_list|)
expr_stmt|;
block|}
return|return
name|freed
return|;
block|}
end_function
begin_comment
comment|/*   mspace versions of routines are near-clones of the global   versions. This is not so nice but better than the alternatives. */
end_comment
begin_function
DECL|function|mspace_malloc
name|void
modifier|*
name|mspace_malloc
parameter_list|(
name|mspace
name|msp
parameter_list|,
name|size_t
name|bytes
parameter_list|)
block|{
name|mstate
name|ms
init|=
operator|(
name|mstate
operator|)
name|msp
decl_stmt|;
if|if
condition|(
operator|!
name|ok_magic
argument_list|(
name|ms
argument_list|)
condition|)
block|{
name|USAGE_ERROR_ACTION
argument_list|(
name|ms
argument_list|,
name|ms
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|PREACTION
argument_list|(
name|ms
argument_list|)
condition|)
block|{
name|void
modifier|*
name|mem
decl_stmt|;
name|size_t
name|nb
decl_stmt|;
if|if
condition|(
name|bytes
operator|<=
name|MAX_SMALL_REQUEST
condition|)
block|{
name|bindex_t
name|idx
decl_stmt|;
name|binmap_t
name|smallbits
decl_stmt|;
name|nb
operator|=
operator|(
name|bytes
operator|<
name|MIN_REQUEST
operator|)
condition|?
name|MIN_CHUNK_SIZE
else|:
name|pad_request
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
name|idx
operator|=
name|small_index
argument_list|(
name|nb
argument_list|)
expr_stmt|;
name|smallbits
operator|=
name|ms
operator|->
name|smallmap
operator|>>
name|idx
expr_stmt|;
if|if
condition|(
operator|(
name|smallbits
operator|&
literal|0x3U
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Remainderless fit to a smallbin. */
name|mchunkptr
name|b
decl_stmt|,
name|p
decl_stmt|;
name|idx
operator|+=
operator|~
name|smallbits
operator|&
literal|1
expr_stmt|;
comment|/* Uses next bin if idx empty */
name|b
operator|=
name|smallbin_at
argument_list|(
name|ms
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|p
operator|=
name|b
operator|->
name|fd
expr_stmt|;
name|assert
argument_list|(
name|chunksize
argument_list|(
name|p
argument_list|)
operator|==
name|small_index2size
argument_list|(
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|unlink_first_small_chunk
argument_list|(
name|ms
argument_list|,
name|b
argument_list|,
name|p
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|set_inuse_and_pinuse
argument_list|(
name|ms
argument_list|,
name|p
argument_list|,
name|small_index2size
argument_list|(
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|chunk2mem
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|check_malloced_chunk
argument_list|(
name|ms
argument_list|,
name|mem
argument_list|,
name|nb
argument_list|)
expr_stmt|;
goto|goto
name|postaction
goto|;
block|}
elseif|else
if|if
condition|(
name|nb
operator|>
name|ms
operator|->
name|dvsize
condition|)
block|{
if|if
condition|(
name|smallbits
operator|!=
literal|0
condition|)
block|{
comment|/* Use chunk in next nonempty smallbin */
name|mchunkptr
name|b
decl_stmt|,
name|p
decl_stmt|,
name|r
decl_stmt|;
name|size_t
name|rsize
decl_stmt|;
name|bindex_t
name|i
decl_stmt|;
name|binmap_t
name|leftbits
init|=
operator|(
name|smallbits
operator|<<
name|idx
operator|)
operator|&
name|left_bits
argument_list|(
name|idx2bit
argument_list|(
name|idx
argument_list|)
argument_list|)
decl_stmt|;
name|binmap_t
name|leastbit
init|=
name|least_bit
argument_list|(
name|leftbits
argument_list|)
decl_stmt|;
name|compute_bit2idx
argument_list|(
name|leastbit
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|b
operator|=
name|smallbin_at
argument_list|(
name|ms
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|p
operator|=
name|b
operator|->
name|fd
expr_stmt|;
name|assert
argument_list|(
name|chunksize
argument_list|(
name|p
argument_list|)
operator|==
name|small_index2size
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|unlink_first_small_chunk
argument_list|(
name|ms
argument_list|,
name|b
argument_list|,
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rsize
operator|=
name|small_index2size
argument_list|(
name|i
argument_list|)
operator|-
name|nb
expr_stmt|;
comment|/* Fit here cannot be remainderless if 4byte sizes */
if|if
condition|(
name|SIZE_T_SIZE
operator|!=
literal|4
operator|&&
name|rsize
operator|<
name|MIN_CHUNK_SIZE
condition|)
name|set_inuse_and_pinuse
argument_list|(
name|ms
argument_list|,
name|p
argument_list|,
name|small_index2size
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|set_size_and_pinuse_of_inuse_chunk
argument_list|(
name|ms
argument_list|,
name|p
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|r
operator|=
name|chunk_plus_offset
argument_list|(
name|p
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|set_size_and_pinuse_of_free_chunk
argument_list|(
name|r
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|replace_dv
argument_list|(
name|ms
argument_list|,
name|r
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
block|}
name|mem
operator|=
name|chunk2mem
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|check_malloced_chunk
argument_list|(
name|ms
argument_list|,
name|mem
argument_list|,
name|nb
argument_list|)
expr_stmt|;
goto|goto
name|postaction
goto|;
block|}
elseif|else
if|if
condition|(
name|ms
operator|->
name|treemap
operator|!=
literal|0
operator|&&
operator|(
name|mem
operator|=
name|tmalloc_small
argument_list|(
name|ms
argument_list|,
name|nb
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|check_malloced_chunk
argument_list|(
name|ms
argument_list|,
name|mem
argument_list|,
name|nb
argument_list|)
expr_stmt|;
goto|goto
name|postaction
goto|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|bytes
operator|>=
name|MAX_REQUEST
condition|)
name|nb
operator|=
name|MAX_SIZE_T
expr_stmt|;
comment|/* Too big to allocate. Force failure (in sys alloc) */
else|else
block|{
name|nb
operator|=
name|pad_request
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|ms
operator|->
name|treemap
operator|!=
literal|0
operator|&&
operator|(
name|mem
operator|=
name|tmalloc_large
argument_list|(
name|ms
argument_list|,
name|nb
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|check_malloced_chunk
argument_list|(
name|ms
argument_list|,
name|mem
argument_list|,
name|nb
argument_list|)
expr_stmt|;
goto|goto
name|postaction
goto|;
block|}
block|}
if|if
condition|(
name|nb
operator|<=
name|ms
operator|->
name|dvsize
condition|)
block|{
name|size_t
name|rsize
init|=
name|ms
operator|->
name|dvsize
operator|-
name|nb
decl_stmt|;
name|mchunkptr
name|p
init|=
name|ms
operator|->
name|dv
decl_stmt|;
if|if
condition|(
name|rsize
operator|>=
name|MIN_CHUNK_SIZE
condition|)
block|{
comment|/* split dv */
name|mchunkptr
name|r
init|=
name|ms
operator|->
name|dv
operator|=
name|chunk_plus_offset
argument_list|(
name|p
argument_list|,
name|nb
argument_list|)
decl_stmt|;
name|ms
operator|->
name|dvsize
operator|=
name|rsize
expr_stmt|;
name|set_size_and_pinuse_of_free_chunk
argument_list|(
name|r
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|set_size_and_pinuse_of_inuse_chunk
argument_list|(
name|ms
argument_list|,
name|p
argument_list|,
name|nb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* exhaust dv */
name|size_t
name|dvs
init|=
name|ms
operator|->
name|dvsize
decl_stmt|;
name|ms
operator|->
name|dvsize
operator|=
literal|0
expr_stmt|;
name|ms
operator|->
name|dv
operator|=
literal|0
expr_stmt|;
name|set_inuse_and_pinuse
argument_list|(
name|ms
argument_list|,
name|p
argument_list|,
name|dvs
argument_list|)
expr_stmt|;
block|}
name|mem
operator|=
name|chunk2mem
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|check_malloced_chunk
argument_list|(
name|ms
argument_list|,
name|mem
argument_list|,
name|nb
argument_list|)
expr_stmt|;
goto|goto
name|postaction
goto|;
block|}
elseif|else
if|if
condition|(
name|nb
operator|<
name|ms
operator|->
name|topsize
condition|)
block|{
comment|/* Split top */
name|size_t
name|rsize
init|=
name|ms
operator|->
name|topsize
operator|-=
name|nb
decl_stmt|;
name|mchunkptr
name|p
init|=
name|ms
operator|->
name|top
decl_stmt|;
name|mchunkptr
name|r
init|=
name|ms
operator|->
name|top
operator|=
name|chunk_plus_offset
argument_list|(
name|p
argument_list|,
name|nb
argument_list|)
decl_stmt|;
name|r
operator|->
name|head
operator|=
name|rsize
operator||
name|PINUSE_BIT
expr_stmt|;
name|set_size_and_pinuse_of_inuse_chunk
argument_list|(
name|ms
argument_list|,
name|p
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|mem
operator|=
name|chunk2mem
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|check_top_chunk
argument_list|(
name|ms
argument_list|,
name|ms
operator|->
name|top
argument_list|)
expr_stmt|;
name|check_malloced_chunk
argument_list|(
name|ms
argument_list|,
name|mem
argument_list|,
name|nb
argument_list|)
expr_stmt|;
goto|goto
name|postaction
goto|;
block|}
name|mem
operator|=
name|sys_alloc
argument_list|(
name|ms
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|postaction
label|:
name|POSTACTION
argument_list|(
name|ms
argument_list|)
expr_stmt|;
return|return
name|mem
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|mspace_free
name|void
name|mspace_free
parameter_list|(
name|mspace
name|msp
parameter_list|,
name|void
modifier|*
name|mem
parameter_list|)
block|{
if|if
condition|(
name|mem
operator|!=
literal|0
condition|)
block|{
name|mchunkptr
name|p
init|=
name|mem2chunk
argument_list|(
name|mem
argument_list|)
decl_stmt|;
if|#
directive|if
name|FOOTERS
name|mstate
name|fm
init|=
name|get_mstate_for
argument_list|(
name|p
argument_list|)
decl_stmt|;
else|#
directive|else
comment|/* FOOTERS */
name|mstate
name|fm
init|=
operator|(
name|mstate
operator|)
name|msp
decl_stmt|;
endif|#
directive|endif
comment|/* FOOTERS */
if|if
condition|(
operator|!
name|ok_magic
argument_list|(
name|fm
argument_list|)
condition|)
block|{
name|USAGE_ERROR_ACTION
argument_list|(
name|fm
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|PREACTION
argument_list|(
name|fm
argument_list|)
condition|)
block|{
name|check_inuse_chunk
argument_list|(
name|fm
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|RTCHECK
argument_list|(
name|ok_address
argument_list|(
name|fm
argument_list|,
name|p
argument_list|)
operator|&&
name|ok_cinuse
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
block|{
name|size_t
name|psize
init|=
name|chunksize
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|mchunkptr
name|next
init|=
name|chunk_plus_offset
argument_list|(
name|p
argument_list|,
name|psize
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|pinuse
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|size_t
name|prevsize
init|=
name|p
operator|->
name|prev_foot
decl_stmt|;
if|if
condition|(
operator|(
name|prevsize
operator|&
name|IS_MMAPPED_BIT
operator|)
operator|!=
literal|0
condition|)
block|{
name|prevsize
operator|&=
operator|~
name|IS_MMAPPED_BIT
expr_stmt|;
name|psize
operator|+=
name|prevsize
operator|+
name|MMAP_FOOT_PAD
expr_stmt|;
if|if
condition|(
name|CALL_MUNMAP
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|-
name|prevsize
argument_list|,
name|psize
argument_list|)
operator|==
literal|0
condition|)
name|fm
operator|->
name|footprint
operator|-=
name|psize
expr_stmt|;
goto|goto
name|postaction
goto|;
block|}
else|else
block|{
name|mchunkptr
name|prev
init|=
name|chunk_minus_offset
argument_list|(
name|p
argument_list|,
name|prevsize
argument_list|)
decl_stmt|;
name|psize
operator|+=
name|prevsize
expr_stmt|;
name|p
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|RTCHECK
argument_list|(
name|ok_address
argument_list|(
name|fm
argument_list|,
name|prev
argument_list|)
argument_list|)
condition|)
block|{
comment|/* consolidate backward */
if|if
condition|(
name|p
operator|!=
name|fm
operator|->
name|dv
condition|)
block|{
name|unlink_chunk
argument_list|(
name|fm
argument_list|,
name|p
argument_list|,
name|prevsize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|next
operator|->
name|head
operator|&
name|INUSE_BITS
operator|)
operator|==
name|INUSE_BITS
condition|)
block|{
name|fm
operator|->
name|dvsize
operator|=
name|psize
expr_stmt|;
name|set_free_with_pinuse
argument_list|(
name|p
argument_list|,
name|psize
argument_list|,
name|next
argument_list|)
expr_stmt|;
goto|goto
name|postaction
goto|;
block|}
block|}
else|else
goto|goto
name|erroraction
goto|;
block|}
block|}
if|if
condition|(
name|RTCHECK
argument_list|(
name|ok_next
argument_list|(
name|p
argument_list|,
name|next
argument_list|)
operator|&&
name|ok_pinuse
argument_list|(
name|next
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|cinuse
argument_list|(
name|next
argument_list|)
condition|)
block|{
comment|/* consolidate forward */
if|if
condition|(
name|next
operator|==
name|fm
operator|->
name|top
condition|)
block|{
name|size_t
name|tsize
init|=
name|fm
operator|->
name|topsize
operator|+=
name|psize
decl_stmt|;
name|fm
operator|->
name|top
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|head
operator|=
name|tsize
operator||
name|PINUSE_BIT
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|fm
operator|->
name|dv
condition|)
block|{
name|fm
operator|->
name|dv
operator|=
literal|0
expr_stmt|;
name|fm
operator|->
name|dvsize
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|should_trim
argument_list|(
name|fm
argument_list|,
name|tsize
argument_list|)
condition|)
name|sys_trim
argument_list|(
name|fm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|postaction
goto|;
block|}
elseif|else
if|if
condition|(
name|next
operator|==
name|fm
operator|->
name|dv
condition|)
block|{
name|size_t
name|dsize
init|=
name|fm
operator|->
name|dvsize
operator|+=
name|psize
decl_stmt|;
name|fm
operator|->
name|dv
operator|=
name|p
expr_stmt|;
name|set_size_and_pinuse_of_free_chunk
argument_list|(
name|p
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
goto|goto
name|postaction
goto|;
block|}
else|else
block|{
name|size_t
name|nsize
init|=
name|chunksize
argument_list|(
name|next
argument_list|)
decl_stmt|;
name|psize
operator|+=
name|nsize
expr_stmt|;
name|unlink_chunk
argument_list|(
name|fm
argument_list|,
name|next
argument_list|,
name|nsize
argument_list|)
expr_stmt|;
name|set_size_and_pinuse_of_free_chunk
argument_list|(
name|p
argument_list|,
name|psize
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|fm
operator|->
name|dv
condition|)
block|{
name|fm
operator|->
name|dvsize
operator|=
name|psize
expr_stmt|;
goto|goto
name|postaction
goto|;
block|}
block|}
block|}
else|else
name|set_free_with_pinuse
argument_list|(
name|p
argument_list|,
name|psize
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_small
argument_list|(
name|psize
argument_list|)
condition|)
block|{
name|insert_small_chunk
argument_list|(
name|fm
argument_list|,
name|p
argument_list|,
name|psize
argument_list|)
expr_stmt|;
name|check_free_chunk
argument_list|(
name|fm
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tchunkptr
name|tp
init|=
operator|(
name|tchunkptr
operator|)
name|p
decl_stmt|;
name|insert_large_chunk
argument_list|(
name|fm
argument_list|,
name|tp
argument_list|,
name|psize
argument_list|)
expr_stmt|;
name|check_free_chunk
argument_list|(
name|fm
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|fm
operator|->
name|release_checks
operator|==
literal|0
condition|)
name|release_unused_segments
argument_list|(
name|fm
argument_list|)
expr_stmt|;
block|}
goto|goto
name|postaction
goto|;
block|}
block|}
name|erroraction
label|:
name|USAGE_ERROR_ACTION
argument_list|(
name|fm
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|postaction
label|:
name|POSTACTION
argument_list|(
name|fm
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|mspace_calloc
name|void
modifier|*
name|mspace_calloc
parameter_list|(
name|mspace
name|msp
parameter_list|,
name|size_t
name|n_elements
parameter_list|,
name|size_t
name|elem_size
parameter_list|)
block|{
name|void
modifier|*
name|mem
decl_stmt|;
name|size_t
name|req
init|=
literal|0
decl_stmt|;
name|mstate
name|ms
init|=
operator|(
name|mstate
operator|)
name|msp
decl_stmt|;
if|if
condition|(
operator|!
name|ok_magic
argument_list|(
name|ms
argument_list|)
condition|)
block|{
name|USAGE_ERROR_ACTION
argument_list|(
name|ms
argument_list|,
name|ms
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|n_elements
operator|!=
literal|0
condition|)
block|{
name|req
operator|=
name|n_elements
operator|*
name|elem_size
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|n_elements
operator||
name|elem_size
operator|)
operator|&
operator|~
operator|(
name|size_t
operator|)
literal|0xffff
operator|)
operator|&&
operator|(
name|req
operator|/
name|n_elements
operator|!=
name|elem_size
operator|)
condition|)
name|req
operator|=
name|MAX_SIZE_T
expr_stmt|;
comment|/* force downstream failure on overflow */
block|}
name|mem
operator|=
name|internal_malloc
argument_list|(
name|ms
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|!=
literal|0
operator|&&
name|calloc_must_clear
argument_list|(
name|mem2chunk
argument_list|(
name|mem
argument_list|)
argument_list|)
condition|)
name|memset
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
return|return
name|mem
return|;
block|}
end_function
begin_function
DECL|function|mspace_realloc
name|void
modifier|*
name|mspace_realloc
parameter_list|(
name|mspace
name|msp
parameter_list|,
name|void
modifier|*
name|oldmem
parameter_list|,
name|size_t
name|bytes
parameter_list|)
block|{
if|if
condition|(
name|oldmem
operator|==
literal|0
condition|)
return|return
name|mspace_malloc
argument_list|(
name|msp
argument_list|,
name|bytes
argument_list|)
return|;
ifdef|#
directive|ifdef
name|REALLOC_ZERO_BYTES_FREES
if|if
condition|(
name|bytes
operator|==
literal|0
condition|)
block|{
name|mspace_free
argument_list|(
name|msp
argument_list|,
name|oldmem
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* REALLOC_ZERO_BYTES_FREES */
else|else
block|{
if|#
directive|if
name|FOOTERS
name|mchunkptr
name|p
init|=
name|mem2chunk
argument_list|(
name|oldmem
argument_list|)
decl_stmt|;
name|mstate
name|ms
init|=
name|get_mstate_for
argument_list|(
name|p
argument_list|)
decl_stmt|;
else|#
directive|else
comment|/* FOOTERS */
name|mstate
name|ms
init|=
operator|(
name|mstate
operator|)
name|msp
decl_stmt|;
endif|#
directive|endif
comment|/* FOOTERS */
if|if
condition|(
operator|!
name|ok_magic
argument_list|(
name|ms
argument_list|)
condition|)
block|{
name|USAGE_ERROR_ACTION
argument_list|(
name|ms
argument_list|,
name|ms
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|internal_realloc
argument_list|(
name|ms
argument_list|,
name|oldmem
argument_list|,
name|bytes
argument_list|)
return|;
block|}
block|}
end_function
begin_function
DECL|function|mspace_memalign
name|void
modifier|*
name|mspace_memalign
parameter_list|(
name|mspace
name|msp
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|size_t
name|bytes
parameter_list|)
block|{
name|mstate
name|ms
init|=
operator|(
name|mstate
operator|)
name|msp
decl_stmt|;
if|if
condition|(
operator|!
name|ok_magic
argument_list|(
name|ms
argument_list|)
condition|)
block|{
name|USAGE_ERROR_ACTION
argument_list|(
name|ms
argument_list|,
name|ms
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|internal_memalign
argument_list|(
name|ms
argument_list|,
name|alignment
argument_list|,
name|bytes
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|mspace_independent_calloc
name|void
modifier|*
modifier|*
name|mspace_independent_calloc
parameter_list|(
name|mspace
name|msp
parameter_list|,
name|size_t
name|n_elements
parameter_list|,
name|size_t
name|elem_size
parameter_list|,
name|void
modifier|*
name|chunks
index|[]
parameter_list|)
block|{
name|size_t
name|sz
init|=
name|elem_size
decl_stmt|;
comment|/* serves as 1-element array */
name|mstate
name|ms
init|=
operator|(
name|mstate
operator|)
name|msp
decl_stmt|;
if|if
condition|(
operator|!
name|ok_magic
argument_list|(
name|ms
argument_list|)
condition|)
block|{
name|USAGE_ERROR_ACTION
argument_list|(
name|ms
argument_list|,
name|ms
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|ialloc
argument_list|(
name|ms
argument_list|,
name|n_elements
argument_list|,
operator|&
name|sz
argument_list|,
literal|3
argument_list|,
name|chunks
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|mspace_independent_comalloc
name|void
modifier|*
modifier|*
name|mspace_independent_comalloc
parameter_list|(
name|mspace
name|msp
parameter_list|,
name|size_t
name|n_elements
parameter_list|,
name|size_t
name|sizes
index|[]
parameter_list|,
name|void
modifier|*
name|chunks
index|[]
parameter_list|)
block|{
name|mstate
name|ms
init|=
operator|(
name|mstate
operator|)
name|msp
decl_stmt|;
if|if
condition|(
operator|!
name|ok_magic
argument_list|(
name|ms
argument_list|)
condition|)
block|{
name|USAGE_ERROR_ACTION
argument_list|(
name|ms
argument_list|,
name|ms
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|ialloc
argument_list|(
name|ms
argument_list|,
name|n_elements
argument_list|,
name|sizes
argument_list|,
literal|0
argument_list|,
name|chunks
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|mspace_trim
name|int
name|mspace_trim
parameter_list|(
name|mspace
name|msp
parameter_list|,
name|size_t
name|pad
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
name|mstate
name|ms
init|=
operator|(
name|mstate
operator|)
name|msp
decl_stmt|;
if|if
condition|(
name|ok_magic
argument_list|(
name|ms
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|PREACTION
argument_list|(
name|ms
argument_list|)
condition|)
block|{
name|result
operator|=
name|sys_trim
argument_list|(
name|ms
argument_list|,
name|pad
argument_list|)
expr_stmt|;
name|POSTACTION
argument_list|(
name|ms
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|USAGE_ERROR_ACTION
argument_list|(
name|ms
argument_list|,
name|ms
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|mspace_malloc_stats
name|void
name|mspace_malloc_stats
parameter_list|(
name|mspace
name|msp
parameter_list|)
block|{
name|mstate
name|ms
init|=
operator|(
name|mstate
operator|)
name|msp
decl_stmt|;
if|if
condition|(
name|ok_magic
argument_list|(
name|ms
argument_list|)
condition|)
block|{
name|internal_malloc_stats
argument_list|(
name|ms
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|USAGE_ERROR_ACTION
argument_list|(
name|ms
argument_list|,
name|ms
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|mspace_footprint
name|size_t
name|mspace_footprint
parameter_list|(
name|mspace
name|msp
parameter_list|)
block|{
name|size_t
name|result
init|=
literal|0
decl_stmt|;
name|mstate
name|ms
init|=
operator|(
name|mstate
operator|)
name|msp
decl_stmt|;
if|if
condition|(
name|ok_magic
argument_list|(
name|ms
argument_list|)
condition|)
block|{
name|result
operator|=
name|ms
operator|->
name|footprint
expr_stmt|;
block|}
else|else
block|{
name|USAGE_ERROR_ACTION
argument_list|(
name|ms
argument_list|,
name|ms
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|mspace_max_footprint
name|size_t
name|mspace_max_footprint
parameter_list|(
name|mspace
name|msp
parameter_list|)
block|{
name|size_t
name|result
init|=
literal|0
decl_stmt|;
name|mstate
name|ms
init|=
operator|(
name|mstate
operator|)
name|msp
decl_stmt|;
if|if
condition|(
name|ok_magic
argument_list|(
name|ms
argument_list|)
condition|)
block|{
name|result
operator|=
name|ms
operator|->
name|max_footprint
expr_stmt|;
block|}
else|else
block|{
name|USAGE_ERROR_ACTION
argument_list|(
name|ms
argument_list|,
name|ms
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|NO_MALLINFO
end_if
begin_function
DECL|function|mspace_mallinfo
name|struct
name|mallinfo
name|mspace_mallinfo
parameter_list|(
name|mspace
name|msp
parameter_list|)
block|{
name|mstate
name|ms
init|=
operator|(
name|mstate
operator|)
name|msp
decl_stmt|;
if|if
condition|(
operator|!
name|ok_magic
argument_list|(
name|ms
argument_list|)
condition|)
block|{
name|USAGE_ERROR_ACTION
argument_list|(
name|ms
argument_list|,
name|ms
argument_list|)
expr_stmt|;
block|}
return|return
name|internal_mallinfo
argument_list|(
name|ms
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* NO_MALLINFO */
end_comment
begin_function
DECL|function|mspace_usable_size
name|size_t
name|mspace_usable_size
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|)
block|{
if|if
condition|(
name|mem
operator|!=
literal|0
condition|)
block|{
name|mchunkptr
name|p
init|=
name|mem2chunk
argument_list|(
name|mem
argument_list|)
decl_stmt|;
if|if
condition|(
name|cinuse
argument_list|(
name|p
argument_list|)
condition|)
return|return
name|chunksize
argument_list|(
name|p
argument_list|)
operator|-
name|overhead_for
argument_list|(
name|p
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|mspace_mallopt
name|int
name|mspace_mallopt
parameter_list|(
name|int
name|param_number
parameter_list|,
name|int
name|value
parameter_list|)
block|{
return|return
name|change_mparam
argument_list|(
name|param_number
argument_list|,
name|value
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* MSPACES */
end_comment
begin_comment
comment|/* -------------------- Alternative MORECORE functions ------------------- */
end_comment
begin_comment
comment|/*   Guidelines for creating a custom version of MORECORE:    * For best performance, MORECORE should allocate in multiples of pagesize.   * MORECORE may allocate more memory than requested. (Or even less,       but this will usually result in a malloc failure.)   * MORECORE must not allocate memory when given argument zero, but       instead return one past the end address of memory from previous       nonzero call.   * For best performance, consecutive calls to MORECORE with positive       arguments should return increasing addresses, indicating that       space has been contiguously extended.   * Even though consecutive calls to MORECORE need not return contiguous       addresses, it must be OK for malloc'ed chunks to span multiple       regions in those cases where they do happen to be contiguous.   * MORECORE need not handle negative arguments -- it may instead       just return MFAIL when given negative arguments.       Negative arguments are always multiples of pagesize. MORECORE       must not misinterpret negative args as large positive unsigned       args. You can suppress all such calls from even occurring by defining       MORECORE_CANNOT_TRIM,    As an example alternative MORECORE, here is a custom allocator   kindly contributed for pre-OSX macOS.  It uses virtually but not   necessarily physically contiguous non-paged memory (locked in,   present and won't get swapped out).  You can use it by uncommenting   this section, adding some #includes, and setting up the appropriate   defines above:        #define MORECORE osMoreCore    There is also a shutdown routine that should somehow be called for   cleanup upon program exit.    #define MAX_POOL_ENTRIES 100   #define MINIMUM_MORECORE_SIZE  (64 * 1024U)   static int next_os_pool;   void *our_os_pools[MAX_POOL_ENTRIES];    void *osMoreCore(int size)   {     void *ptr = 0;     static void *sbrk_top = 0;      if (size> 0)     {       if (size< MINIMUM_MORECORE_SIZE)          size = MINIMUM_MORECORE_SIZE;       if (CurrentExecutionLevel() == kTaskLevel)          ptr = PoolAllocateResident(size + RM_PAGE_SIZE, 0);       if (ptr == 0)       {         return (void *) MFAIL;       }       // save ptrs so they can be freed during cleanup       our_os_pools[next_os_pool] = ptr;       next_os_pool++;       ptr = (void *) ((((size_t) ptr) + RM_PAGE_MASK)& ~RM_PAGE_MASK);       sbrk_top = (char *) ptr + size;       return ptr;     }     else if (size< 0)     {       // we don't currently support shrink behavior       return (void *) MFAIL;     }     else     {       return sbrk_top;     }   }    // cleanup any allocated memory pools   // called as last thing before shutting down driver    void osCleanupMem(void)   {     void **ptr;      for (ptr = our_os_pools; ptr<&our_os_pools[MAX_POOL_ENTRIES]; ptr++)       if (*ptr)       {          PoolDeallocate(*ptr);          *ptr = 0;       }   }  */
end_comment
begin_comment
comment|/* ----------------------------------------------------------------------- History:     V2.8.4 (not yet released)       * Fix bad error check in mspace_footprint       * Adaptations for ptmalloc, courtesy of Wolfram Gloger.       * Reentrant spin locks, courtesy of Earl Chew and others       * Win32 improvements, courtesy of Niall Douglas and Earl Chew       * Add NO_SEGMENT_TRAVERSAL and MAX_RELEASE_CHECK_RATE options       * Various small adjustments to reduce warnings on some compilers       * Extension hook in malloc_state      V2.8.3 Thu Sep 22 11:16:32 2005  Doug Lea  (dl at gee)       * Add max_footprint functions       * Ensure all appropriate literals are size_t       * Fix conditional compilation problem for some #define settings       * Avoid concatenating segments with the one provided         in create_mspace_with_base       * Rename some variables to avoid compiler shadowing warnings       * Use explicit lock initialization.       * Better handling of sbrk interference.       * Simplify and fix segment insertion, trimming and mspace_destroy       * Reinstate REALLOC_ZERO_BYTES_FREES option from 2.7.x       * Thanks especially to Dennis Flanagan for help on these.      V2.8.2 Sun Jun 12 16:01:10 2005  Doug Lea  (dl at gee)       * Fix memalign brace error.      V2.8.1 Wed Jun  8 16:11:46 2005  Doug Lea  (dl at gee)       * Fix improper #endif nesting in C++       * Add explicit casts needed for C++      V2.8.0 Mon May 30 14:09:02 2005  Doug Lea  (dl at gee)       * Use trees for large bins       * Support mspaces       * Use segments to unify sbrk-based and mmap-based system allocation,         removing need for emulation on most platforms without sbrk.       * Default safety checks       * Optional footer checks. Thanks to William Robertson for the idea.       * Internal code refactoring       * Incorporate suggestions and platform-specific changes.         Thanks to Dennis Flanagan, Colin Plumb, Niall Douglas,         Aaron Bachmann,  Emery Berger, and others.       * Speed up non-fastbin processing enough to remove fastbins.       * Remove useless cfree() to avoid conflicts with other apps.       * Remove internal memcpy, memset. Compilers handle builtins better.       * Remove some options that no one ever used and rename others.      V2.7.2 Sat Aug 17 09:07:30 2002  Doug Lea  (dl at gee)       * Fix malloc_state bitmap array misdeclaration      V2.7.1 Thu Jul 25 10:58:03 2002  Doug Lea  (dl at gee)       * Allow tuning of FIRST_SORTED_BIN_SIZE       * Use PTR_UINT as type for all ptr->int casts. Thanks to John Belmonte.       * Better detection and support for non-contiguousness of MORECORE.         Thanks to Andreas Mueller, Conal Walsh, and Wolfram Gloger       * Bypass most of malloc if no frees. Thanks To Emery Berger.       * Fix freeing of old top non-contiguous chunk im sysmalloc.       * Raised default trim and map thresholds to 256K.       * Fix mmap-related #defines. Thanks to Lubos Lunak.       * Fix copy macros; added LACKS_FCNTL_H. Thanks to Neal Walfield.       * Branch-free bin calculation       * Default trim and mmap thresholds now 256K.      V2.7.0 Sun Mar 11 14:14:06 2001  Doug Lea  (dl at gee)       * Introduce independent_comalloc and independent_calloc.         Thanks to Michael Pachos for motivation and help.       * Make optional .h file available       * Allow> 2GB requests on 32bit systems.       * new WIN32 sbrk, mmap, munmap, lock code from<Walter@GeNeSys-e.de>.         Thanks also to Andreas Mueller<a.mueller at paradatec.de>,         and Anonymous.       * Allow override of MALLOC_ALIGNMENT (Thanks to Ruud Waij for         helping test this.)       * memalign: check alignment arg       * realloc: don't try to shift chunks backwards, since this         leads to  more fragmentation in some programs and doesn't         seem to help in any others.       * Collect all cases in malloc requiring system memory into sysmalloc       * Use mmap as backup to sbrk       * Place all internal state in malloc_state       * Introduce fastbins (although similar to 2.5.1)       * Many minor tunings and cosmetic improvements       * Introduce USE_PUBLIC_MALLOC_WRAPPERS, USE_MALLOC_LOCK       * Introduce MALLOC_FAILURE_ACTION, MORECORE_CONTIGUOUS         Thanks to Tony E. Bennett<tbennett@nvidia.com> and others.       * Include errno.h to support default failure action.      V2.6.6 Sun Dec  5 07:42:19 1999  Doug Lea  (dl at gee)       * return null for negative arguments       * Added Several WIN32 cleanups from Martin C. Fong<mcfong at yahoo.com>          * Add 'LACKS_SYS_PARAM_H' for those systems without 'sys/param.h'           (e.g. WIN32 platforms)          * Cleanup header file inclusion for WIN32 platforms          * Cleanup code to avoid Microsoft Visual C++ compiler complaints          * Add 'USE_DL_PREFIX' to quickly allow co-existence with existing            memory allocation routines          * Set 'malloc_getpagesize' for WIN32 platforms (needs more work)          * Use 'assert' rather than 'ASSERT' in WIN32 code to conform to            usage of 'assert' in non-WIN32 code          * Improve WIN32 'sbrk()' emulation's 'findRegion()' routine to            avoid infinite loop       * Always call 'fREe()' rather than 'free()'      V2.6.5 Wed Jun 17 15:57:31 1998  Doug Lea  (dl at gee)       * Fixed ordering problem with boundary-stamping      V2.6.3 Sun May 19 08:17:58 1996  Doug Lea  (dl at gee)       * Added pvalloc, as recommended by H.J. Liu       * Added 64bit pointer support mainly from Wolfram Gloger       * Added anonymously donated WIN32 sbrk emulation       * Malloc, calloc, getpagesize: add optimizations from Raymond Nijssen       * malloc_extend_top: fix mask error that caused wastage after         foreign sbrks       * Add linux mremap support code from HJ Liu      V2.6.2 Tue Dec  5 06:52:55 1995  Doug Lea  (dl at gee)       * Integrated most documentation with the code.       * Add support for mmap, with help from         Wolfram Gloger (Gloger@lrz.uni-muenchen.de).       * Use last_remainder in more cases.       * Pack bins using idea from  colin@nyx10.cs.du.edu       * Use ordered bins instead of best-fit threshhold       * Eliminate block-local decls to simplify tracing and debugging.       * Support another case of realloc via move into top       * Fix error occuring when initial sbrk_base not word-aligned.       * Rely on page size for units instead of SBRK_UNIT to         avoid surprises about sbrk alignment conventions.       * Add mallinfo, mallopt. Thanks to Raymond Nijssen         (raymond@es.ele.tue.nl) for the suggestion.       * Add `pad' argument to malloc_trim and top_pad mallopt parameter.       * More precautions for cases where other routines call sbrk,         courtesy of Wolfram Gloger (Gloger@lrz.uni-muenchen.de).       * Added macros etc., allowing use in linux libc from         H.J. Lu (hjl@gnu.ai.mit.edu)       * Inverted this history list      V2.6.1 Sat Dec  2 14:10:57 1995  Doug Lea  (dl at gee)       * Re-tuned and fixed to behave more nicely with V2.6.0 changes.       * Removed all preallocation code since under current scheme         the work required to undo bad preallocations exceeds         the work saved in good cases for most test programs.       * No longer use return list or unconsolidated bins since         no scheme using them consistently outperforms those that don't         given above changes.       * Use best fit for very large chunks to prevent some worst-cases.       * Added some support for debugging      V2.6.0 Sat Nov  4 07:05:23 1995  Doug Lea  (dl at gee)       * Removed footers when chunks are in use. Thanks to         Paul Wilson (wilson@cs.texas.edu) for the suggestion.      V2.5.4 Wed Nov  1 07:54:51 1995  Doug Lea  (dl at gee)       * Added malloc_trim, with help from Wolfram Gloger         (wmglo@Dent.MED.Uni-Muenchen.DE).      V2.5.3 Tue Apr 26 10:16:01 1994  Doug Lea  (dl at g)      V2.5.2 Tue Apr  5 16:20:40 1994  Doug Lea  (dl at g)       * realloc: try to expand in both directions       * malloc: swap order of clean-bin strategy;       * realloc: only conditionally expand backwards       * Try not to scavenge used bins       * Use bin counts as a guide to preallocation       * Occasionally bin return list chunks in first scan       * Add a few optimizations from colin@nyx10.cs.du.edu      V2.5.1 Sat Aug 14 15:40:43 1993  Doug Lea  (dl at g)       * faster bin computation& slightly different binning       * merged all consolidations to one part of malloc proper          (eliminating old malloc_find_space& malloc_clean_bin)       * Scan 2 returns chunks (not just 1)       * Propagate failure in realloc if malloc returns 0       * Add stuff to allow compilation on non-ANSI compilers           from kpv@research.att.com      V2.5 Sat Aug  7 07:41:59 1993  Doug Lea  (dl at g.oswego.edu)       * removed potential for odd address access in prev_chunk       * removed dependency on getpagesize.h       * misc cosmetics and a bit more internal documentation       * anticosmetics: mangled names in macros to evade debugger strangeness       * tested on sparc, hp-700, dec-mips, rs6000           with gcc& native cc (hp, dec only) allowing           Detlefs& Zorn comparison study (in SIGPLAN Notices.)      Trial version Fri Aug 28 13:14:29 1992  Doug Lea  (dl at g.oswego.edu)       * Based loosely on libg++-1.2X malloc. (It retains some of the overall          structure of old version,  but most details differ.)  */
end_comment
end_unit
