begin_unit
begin_comment
comment|/* $Id: tif_luv.c,v 1.17.2.3 2009-06-30 17:06:25 fwarmerdam Exp $ */
end_comment
begin_comment
comment|/*  * Copyright (c) 1997 Greg Ward Larson  * Copyright (c) 1997 Silicon Graphics, Inc.  *  * Permission to use, copy, modify, distribute, and sell this software and   * its documentation for any purpose is hereby granted without fee, provided  * that (i) the above copyright notices and this permission notice appear in  * all copies of the software and related documentation, and (ii) the names of  * Sam Leffler, Greg Larson and Silicon Graphics may not be used in any  * advertising or publicity relating to the software without the specific,  * prior written permission of Sam Leffler, Greg Larson and Silicon Graphics.  *   * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,   * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY   * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.    *   * IN NO EVENT SHALL SAM LEFFLER, GREG LARSON OR SILICON GRAPHICS BE LIABLE  * FOR ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,  * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF   * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE   * OF THIS SOFTWARE.  */
end_comment
begin_include
include|#
directive|include
file|"tiffiop.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|LOGLUV_SUPPORT
end_ifdef
begin_comment
comment|/*  * TIFF Library.  * LogLuv compression support for high dynamic range images.  *  * Contributed by Greg Larson.  *  * LogLuv image support uses the TIFF library to store 16 or 10-bit  * log luminance values with 8 bits each of u and v or a 14-bit index.  *  * The codec can take as input and produce as output 32-bit IEEE float values   * as well as 16-bit integer values.  A 16-bit luminance is interpreted  * as a sign bit followed by a 15-bit integer that is converted  * to and from a linear magnitude using the transformation:  *  *	L = 2^( (Le+.5)/256 - 64 )		# real from 15-bit  *  *	Le = floor( 256*(log2(L) + 64) )	# 15-bit from real  *  * The actual conversion to world luminance units in candelas per sq. meter  * requires an additional multiplier, which is stored in the TIFFTAG_STONITS.  * This value is usually set such that a reasonable exposure comes from  * clamping decoded luminances above 1 to 1 in the displayed image.  *  * The 16-bit values for u and v may be converted to real values by dividing  * each by 32768.  (This allows for negative values, which aren't useful as  * far as we know, but are left in case of future improvements in human  * color vision.)  *  * Conversion from (u,v), which is actually the CIE (u',v') system for  * you color scientists, is accomplished by the following transformation:  *  *	u = 4*x / (-2*x + 12*y + 3)  *	v = 9*y / (-2*x + 12*y + 3)  *  *	x = 9*u / (6*u - 16*v + 12)  *	y = 4*v / (6*u - 16*v + 12)  *  * This process is greatly simplified by passing 32-bit IEEE floats  * for each of three CIE XYZ coordinates.  The codec then takes care  * of conversion to and from LogLuv, though the application is still  * responsible for interpreting the TIFFTAG_STONITS calibration factor.  *  * By definition, a CIE XYZ vector of [1 1 1] corresponds to a neutral white  * point of (x,y)=(1/3,1/3).  However, most color systems assume some other  * white point, such as D65, and an absolute color conversion to XYZ then  * to another color space with a different white point may introduce an  * unwanted color cast to the image.  It is often desirable, therefore, to  * perform a white point conversion that maps the input white to [1 1 1]  * in XYZ, then record the original white point using the TIFFTAG_WHITEPOINT  * tag value.  A decoder that demands absolute color calibration may use  * this white point tag to get back the original colors, but usually it  * will be ignored and the new white point will be used instead that  * matches the output color space.  *  * Pixel information is compressed into one of two basic encodings, depending  * on the setting of the compression tag, which is one of COMPRESSION_SGILOG  * or COMPRESSION_SGILOG24.  For COMPRESSION_SGILOG, greyscale data is  * stored as:  *  *	 1       15  *	|-+---------------|  *  * COMPRESSION_SGILOG color data is stored as:  *  *	 1       15           8        8  *	|-+---------------|--------+--------|  *	 S       Le           ue       ve  *  * For the 24-bit COMPRESSION_SGILOG24 color format, the data is stored as:  *  *	     10           14  *	|----------|--------------|  *	     Le'          Ce  *  * There is no sign bit in the 24-bit case, and the (u,v) chromaticity is  * encoded as an index for optimal color resolution.  The 10 log bits are  * defined by the following conversions:  *  *	L = 2^((Le'+.5)/64 - 12)		# real from 10-bit  *  *	Le' = floor( 64*(log2(L) + 12) )	# 10-bit from real  *  * The 10 bits of the smaller format may be converted into the 15 bits of  * the larger format by multiplying by 4 and adding 13314.  Obviously,  * a smaller range of magnitudes is covered (about 5 orders of magnitude  * instead of 38), and the lack of a sign bit means that negative luminances  * are not allowed.  (Well, they aren't allowed in the real world, either,  * but they are useful for certain types of image processing.)  *  * The desired user format is controlled by the setting the internal  * pseudo tag TIFFTAG_SGILOGDATAFMT to one of:  *  SGILOGDATAFMT_FLOAT       = IEEE 32-bit float XYZ values  *  SGILOGDATAFMT_16BIT	      = 16-bit integer encodings of logL, u and v  * Raw data i/o is also possible using:  *  SGILOGDATAFMT_RAW         = 32-bit unsigned integer with encoded pixel  * In addition, the following decoding is provided for ease of display:  *  SGILOGDATAFMT_8BIT        = 8-bit default RGB gamma-corrected values  *  * For grayscale images, we provide the following data formats:  *  SGILOGDATAFMT_FLOAT       = IEEE 32-bit float Y values  *  SGILOGDATAFMT_16BIT       = 16-bit integer w/ encoded luminance  *  SGILOGDATAFMT_8BIT        = 8-bit gray monitor values  *  * Note that the COMPRESSION_SGILOG applies a simple run-length encoding  * scheme by separating the logL, u and v bytes for each row and applying  * a PackBits type of compression.  Since the 24-bit encoding is not  * adaptive, the 32-bit color format takes less space in many cases.  *  * Further control is provided over the conversion from higher-resolution  * formats to final encoded values through the pseudo tag  * TIFFTAG_SGILOGENCODE:  *  SGILOGENCODE_NODITHER     = do not dither encoded values  *  SGILOGENCODE_RANDITHER    = apply random dithering during encoding  *  * The default value of this tag is SGILOGENCODE_NODITHER for  * COMPRESSION_SGILOG to maximize run-length encoding and  * SGILOGENCODE_RANDITHER for COMPRESSION_SGILOG24 to turn  * quantization errors into noise.  */
end_comment
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|<math.h>
end_include
begin_comment
comment|/*  * State block for each open TIFF  * file using LogLuv compression/decompression.  */
end_comment
begin_typedef
DECL|typedef|LogLuvState
typedef|typedef
name|struct
name|logLuvState
name|LogLuvState
typedef|;
end_typedef
begin_struct
DECL|struct|logLuvState
struct|struct
name|logLuvState
block|{
DECL|member|user_datafmt
name|int
name|user_datafmt
decl_stmt|;
comment|/* user data format */
DECL|member|encode_meth
name|int
name|encode_meth
decl_stmt|;
comment|/* encoding method */
DECL|member|pixel_size
name|int
name|pixel_size
decl_stmt|;
comment|/* bytes per pixel */
DECL|member|tbuf
name|tidata_t
modifier|*
name|tbuf
decl_stmt|;
comment|/* translation buffer */
DECL|member|tbuflen
name|int
name|tbuflen
decl_stmt|;
comment|/* buffer length */
DECL|member|tfunc
name|void
function_decl|(
modifier|*
name|tfunc
function_decl|)
parameter_list|(
name|LogLuvState
modifier|*
parameter_list|,
name|tidata_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
DECL|member|vgetparent
name|TIFFVSetMethod
name|vgetparent
decl_stmt|;
comment|/* super-class method */
DECL|member|vsetparent
name|TIFFVSetMethod
name|vsetparent
decl_stmt|;
comment|/* super-class method */
block|}
struct|;
end_struct
begin_define
DECL|macro|DecoderState
define|#
directive|define
name|DecoderState
parameter_list|(
name|tif
parameter_list|)
value|((LogLuvState*) (tif)->tif_data)
end_define
begin_define
DECL|macro|EncoderState
define|#
directive|define
name|EncoderState
parameter_list|(
name|tif
parameter_list|)
value|((LogLuvState*) (tif)->tif_data)
end_define
begin_define
DECL|macro|SGILOGDATAFMT_UNKNOWN
define|#
directive|define
name|SGILOGDATAFMT_UNKNOWN
value|-1
end_define
begin_define
DECL|macro|MINRUN
define|#
directive|define
name|MINRUN
value|4
end_define
begin_comment
DECL|macro|MINRUN
comment|/* minimum run length */
end_comment
begin_comment
comment|/*  * Decode a string of 16-bit gray pixels.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|LogL16Decode
name|LogL16Decode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|op
parameter_list|,
name|tsize_t
name|occ
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|LogLuvState
modifier|*
name|sp
init|=
name|DecoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|int
name|shft
decl_stmt|,
name|i
decl_stmt|,
name|npixels
decl_stmt|;
name|unsigned
name|char
modifier|*
name|bp
decl_stmt|;
name|int16
modifier|*
name|tp
decl_stmt|;
name|int16
name|b
decl_stmt|;
name|int
name|cc
decl_stmt|,
name|rc
decl_stmt|;
name|assert
argument_list|(
name|s
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|npixels
operator|=
name|occ
operator|/
name|sp
operator|->
name|pixel_size
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|user_datafmt
operator|==
name|SGILOGDATAFMT_16BIT
condition|)
name|tp
operator|=
operator|(
name|int16
operator|*
operator|)
name|op
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|sp
operator|->
name|tbuflen
operator|>=
name|npixels
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|(
name|int16
operator|*
operator|)
name|sp
operator|->
name|tbuf
expr_stmt|;
block|}
name|_TIFFmemset
argument_list|(
operator|(
name|tdata_t
operator|)
name|tp
argument_list|,
literal|0
argument_list|,
name|npixels
operator|*
sizeof|sizeof
argument_list|(
name|tp
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tif
operator|->
name|tif_rawcp
expr_stmt|;
name|cc
operator|=
name|tif
operator|->
name|tif_rawcc
expr_stmt|;
comment|/* get each byte string */
for|for
control|(
name|shft
operator|=
literal|2
operator|*
literal|8
init|;
operator|(
name|shft
operator|-=
literal|8
operator|)
operator|>=
literal|0
condition|;
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npixels
operator|&&
name|cc
operator|>
literal|0
condition|;
control|)
if|if
condition|(
operator|*
name|bp
operator|>=
literal|128
condition|)
block|{
comment|/* run */
name|rc
operator|=
operator|*
name|bp
operator|++
operator|+
operator|(
literal|2
operator|-
literal|128
operator|)
expr_stmt|;
name|b
operator|=
call|(
name|int16
call|)
argument_list|(
operator|*
name|bp
operator|++
operator|<<
name|shft
argument_list|)
expr_stmt|;
name|cc
operator|-=
literal|2
expr_stmt|;
while|while
condition|(
name|rc
operator|--
operator|&&
name|i
operator|<
name|npixels
condition|)
name|tp
index|[
name|i
operator|++
index|]
operator||=
name|b
expr_stmt|;
block|}
else|else
block|{
comment|/* non-run */
name|rc
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
comment|/* nul is noop */
while|while
condition|(
operator|--
name|cc
operator|&&
name|rc
operator|--
operator|&&
name|i
operator|<
name|npixels
condition|)
name|tp
index|[
name|i
operator|++
index|]
operator||=
operator|(
name|int16
operator|)
operator|*
name|bp
operator|++
operator|<<
name|shft
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
name|npixels
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"LogL16Decode: Not enough data at row %d (short %d pixels)"
argument_list|,
name|tif
operator|->
name|tif_row
argument_list|,
name|npixels
operator|-
name|i
argument_list|)
expr_stmt|;
name|tif
operator|->
name|tif_rawcp
operator|=
operator|(
name|tidata_t
operator|)
name|bp
expr_stmt|;
name|tif
operator|->
name|tif_rawcc
operator|=
name|cc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
call|(
modifier|*
name|sp
operator|->
name|tfunc
call|)
argument_list|(
name|sp
argument_list|,
name|op
argument_list|,
name|npixels
argument_list|)
expr_stmt|;
name|tif
operator|->
name|tif_rawcp
operator|=
operator|(
name|tidata_t
operator|)
name|bp
expr_stmt|;
name|tif
operator|->
name|tif_rawcc
operator|=
name|cc
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Decode a string of 24-bit pixels.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|LogLuvDecode24
name|LogLuvDecode24
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|op
parameter_list|,
name|tsize_t
name|occ
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|LogLuvState
modifier|*
name|sp
init|=
name|DecoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|int
name|cc
decl_stmt|,
name|i
decl_stmt|,
name|npixels
decl_stmt|;
name|unsigned
name|char
modifier|*
name|bp
decl_stmt|;
name|uint32
modifier|*
name|tp
decl_stmt|;
name|assert
argument_list|(
name|s
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|npixels
operator|=
name|occ
operator|/
name|sp
operator|->
name|pixel_size
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|user_datafmt
operator|==
name|SGILOGDATAFMT_RAW
condition|)
name|tp
operator|=
operator|(
name|uint32
operator|*
operator|)
name|op
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|sp
operator|->
name|tbuflen
operator|>=
name|npixels
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|(
name|uint32
operator|*
operator|)
name|sp
operator|->
name|tbuf
expr_stmt|;
block|}
comment|/* copy to array of uint32 */
name|bp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tif
operator|->
name|tif_rawcp
expr_stmt|;
name|cc
operator|=
name|tif
operator|->
name|tif_rawcc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npixels
operator|&&
name|cc
operator|>
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|tp
index|[
name|i
index|]
operator|=
name|bp
index|[
literal|0
index|]
operator|<<
literal|16
operator||
name|bp
index|[
literal|1
index|]
operator|<<
literal|8
operator||
name|bp
index|[
literal|2
index|]
expr_stmt|;
name|bp
operator|+=
literal|3
expr_stmt|;
name|cc
operator|-=
literal|3
expr_stmt|;
block|}
name|tif
operator|->
name|tif_rawcp
operator|=
operator|(
name|tidata_t
operator|)
name|bp
expr_stmt|;
name|tif
operator|->
name|tif_rawcc
operator|=
name|cc
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|npixels
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"LogLuvDecode24: Not enough data at row %d (short %d pixels)"
argument_list|,
name|tif
operator|->
name|tif_row
argument_list|,
name|npixels
operator|-
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
call|(
modifier|*
name|sp
operator|->
name|tfunc
call|)
argument_list|(
name|sp
argument_list|,
name|op
argument_list|,
name|npixels
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Decode a string of 32-bit pixels.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|LogLuvDecode32
name|LogLuvDecode32
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|op
parameter_list|,
name|tsize_t
name|occ
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|LogLuvState
modifier|*
name|sp
decl_stmt|;
name|int
name|shft
decl_stmt|,
name|i
decl_stmt|,
name|npixels
decl_stmt|;
name|unsigned
name|char
modifier|*
name|bp
decl_stmt|;
name|uint32
modifier|*
name|tp
decl_stmt|;
name|uint32
name|b
decl_stmt|;
name|int
name|cc
decl_stmt|,
name|rc
decl_stmt|;
name|assert
argument_list|(
name|s
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sp
operator|=
name|DecoderState
argument_list|(
name|tif
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|npixels
operator|=
name|occ
operator|/
name|sp
operator|->
name|pixel_size
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|user_datafmt
operator|==
name|SGILOGDATAFMT_RAW
condition|)
name|tp
operator|=
operator|(
name|uint32
operator|*
operator|)
name|op
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|sp
operator|->
name|tbuflen
operator|>=
name|npixels
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|(
name|uint32
operator|*
operator|)
name|sp
operator|->
name|tbuf
expr_stmt|;
block|}
name|_TIFFmemset
argument_list|(
operator|(
name|tdata_t
operator|)
name|tp
argument_list|,
literal|0
argument_list|,
name|npixels
operator|*
sizeof|sizeof
argument_list|(
name|tp
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tif
operator|->
name|tif_rawcp
expr_stmt|;
name|cc
operator|=
name|tif
operator|->
name|tif_rawcc
expr_stmt|;
comment|/* get each byte string */
for|for
control|(
name|shft
operator|=
literal|4
operator|*
literal|8
init|;
operator|(
name|shft
operator|-=
literal|8
operator|)
operator|>=
literal|0
condition|;
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npixels
operator|&&
name|cc
operator|>
literal|0
condition|;
control|)
if|if
condition|(
operator|*
name|bp
operator|>=
literal|128
condition|)
block|{
comment|/* run */
name|rc
operator|=
operator|*
name|bp
operator|++
operator|+
operator|(
literal|2
operator|-
literal|128
operator|)
expr_stmt|;
name|b
operator|=
operator|(
name|uint32
operator|)
operator|*
name|bp
operator|++
operator|<<
name|shft
expr_stmt|;
name|cc
operator|-=
literal|2
expr_stmt|;
while|while
condition|(
name|rc
operator|--
operator|&&
name|i
operator|<
name|npixels
condition|)
name|tp
index|[
name|i
operator|++
index|]
operator||=
name|b
expr_stmt|;
block|}
else|else
block|{
comment|/* non-run */
name|rc
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
comment|/* nul is noop */
while|while
condition|(
operator|--
name|cc
operator|&&
name|rc
operator|--
operator|&&
name|i
operator|<
name|npixels
condition|)
name|tp
index|[
name|i
operator|++
index|]
operator||=
operator|(
name|uint32
operator|)
operator|*
name|bp
operator|++
operator|<<
name|shft
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
name|npixels
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"LogLuvDecode32: Not enough data at row %d (short %d pixels)"
argument_list|,
name|tif
operator|->
name|tif_row
argument_list|,
name|npixels
operator|-
name|i
argument_list|)
expr_stmt|;
name|tif
operator|->
name|tif_rawcp
operator|=
operator|(
name|tidata_t
operator|)
name|bp
expr_stmt|;
name|tif
operator|->
name|tif_rawcc
operator|=
name|cc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
call|(
modifier|*
name|sp
operator|->
name|tfunc
call|)
argument_list|(
name|sp
argument_list|,
name|op
argument_list|,
name|npixels
argument_list|)
expr_stmt|;
name|tif
operator|->
name|tif_rawcp
operator|=
operator|(
name|tidata_t
operator|)
name|bp
expr_stmt|;
name|tif
operator|->
name|tif_rawcc
operator|=
name|cc
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Decode a strip of pixels.  We break it into rows to  * maintain synchrony with the encode algorithm, which  * is row by row.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|LogLuvDecodeStrip
name|LogLuvDecodeStrip
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|bp
parameter_list|,
name|tsize_t
name|cc
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|tsize_t
name|rowlen
init|=
name|TIFFScanlineSize
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|cc
operator|%
name|rowlen
operator|==
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|cc
operator|&&
call|(
modifier|*
name|tif
operator|->
name|tif_decoderow
call|)
argument_list|(
name|tif
argument_list|,
name|bp
argument_list|,
name|rowlen
argument_list|,
name|s
argument_list|)
condition|)
name|bp
operator|+=
name|rowlen
operator|,
name|cc
operator|-=
name|rowlen
expr_stmt|;
return|return
operator|(
name|cc
operator|==
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Decode a tile of pixels.  We break it into rows to  * maintain synchrony with the encode algorithm, which  * is row by row.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|LogLuvDecodeTile
name|LogLuvDecodeTile
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|bp
parameter_list|,
name|tsize_t
name|cc
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|tsize_t
name|rowlen
init|=
name|TIFFTileRowSize
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|cc
operator|%
name|rowlen
operator|==
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|cc
operator|&&
call|(
modifier|*
name|tif
operator|->
name|tif_decoderow
call|)
argument_list|(
name|tif
argument_list|,
name|bp
argument_list|,
name|rowlen
argument_list|,
name|s
argument_list|)
condition|)
name|bp
operator|+=
name|rowlen
operator|,
name|cc
operator|-=
name|rowlen
expr_stmt|;
return|return
operator|(
name|cc
operator|==
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Encode a row of 16-bit pixels.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|LogL16Encode
name|LogL16Encode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|bp
parameter_list|,
name|tsize_t
name|cc
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|LogLuvState
modifier|*
name|sp
init|=
name|EncoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|int
name|shft
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|npixels
decl_stmt|;
name|tidata_t
name|op
decl_stmt|;
name|int16
modifier|*
name|tp
decl_stmt|;
name|int16
name|b
decl_stmt|;
name|int
name|occ
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|,
name|mask
decl_stmt|,
name|beg
decl_stmt|;
name|assert
argument_list|(
name|s
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|npixels
operator|=
name|cc
operator|/
name|sp
operator|->
name|pixel_size
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|user_datafmt
operator|==
name|SGILOGDATAFMT_16BIT
condition|)
name|tp
operator|=
operator|(
name|int16
operator|*
operator|)
name|bp
expr_stmt|;
else|else
block|{
name|tp
operator|=
operator|(
name|int16
operator|*
operator|)
name|sp
operator|->
name|tbuf
expr_stmt|;
name|assert
argument_list|(
name|sp
operator|->
name|tbuflen
operator|>=
name|npixels
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sp
operator|->
name|tfunc
call|)
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|npixels
argument_list|)
expr_stmt|;
block|}
comment|/* compress each byte string */
name|op
operator|=
name|tif
operator|->
name|tif_rawcp
expr_stmt|;
name|occ
operator|=
name|tif
operator|->
name|tif_rawdatasize
operator|-
name|tif
operator|->
name|tif_rawcc
expr_stmt|;
for|for
control|(
name|shft
operator|=
literal|2
operator|*
literal|8
init|;
operator|(
name|shft
operator|-=
literal|8
operator|)
operator|>=
literal|0
condition|;
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npixels
condition|;
name|i
operator|+=
name|rc
control|)
block|{
if|if
condition|(
name|occ
operator|<
literal|4
condition|)
block|{
name|tif
operator|->
name|tif_rawcp
operator|=
name|op
expr_stmt|;
name|tif
operator|->
name|tif_rawcc
operator|=
name|tif
operator|->
name|tif_rawdatasize
operator|-
name|occ
expr_stmt|;
if|if
condition|(
operator|!
name|TIFFFlushData1
argument_list|(
name|tif
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|op
operator|=
name|tif
operator|->
name|tif_rawcp
expr_stmt|;
name|occ
operator|=
name|tif
operator|->
name|tif_rawdatasize
operator|-
name|tif
operator|->
name|tif_rawcc
expr_stmt|;
block|}
name|mask
operator|=
literal|0xff
operator|<<
name|shft
expr_stmt|;
comment|/* find next run */
for|for
control|(
name|beg
operator|=
name|i
init|;
name|beg
operator|<
name|npixels
condition|;
name|beg
operator|+=
name|rc
control|)
block|{
name|b
operator|=
call|(
name|int16
call|)
argument_list|(
name|tp
index|[
name|beg
index|]
operator|&
name|mask
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|rc
operator|<
literal|127
operator|+
literal|2
operator|&&
name|beg
operator|+
name|rc
operator|<
name|npixels
operator|&&
operator|(
name|tp
index|[
name|beg
operator|+
name|rc
index|]
operator|&
name|mask
operator|)
operator|==
name|b
condition|)
name|rc
operator|++
expr_stmt|;
if|if
condition|(
name|rc
operator|>=
name|MINRUN
condition|)
break|break;
comment|/* long enough */
block|}
if|if
condition|(
name|beg
operator|-
name|i
operator|>
literal|1
operator|&&
name|beg
operator|-
name|i
operator|<
name|MINRUN
condition|)
block|{
name|b
operator|=
call|(
name|int16
call|)
argument_list|(
name|tp
index|[
name|i
index|]
operator|&
name|mask
argument_list|)
expr_stmt|;
comment|/*check short run */
name|j
operator|=
name|i
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|tp
index|[
name|j
operator|++
index|]
operator|&
name|mask
operator|)
operator|==
name|b
condition|)
if|if
condition|(
name|j
operator|==
name|beg
condition|)
block|{
operator|*
name|op
operator|++
operator|=
call|(
name|tidataval_t
call|)
argument_list|(
literal|128
operator|-
literal|2
operator|+
name|j
operator|-
name|i
argument_list|)
expr_stmt|;
operator|*
name|op
operator|++
operator|=
call|(
name|tidataval_t
call|)
argument_list|(
name|b
operator|>>
name|shft
argument_list|)
expr_stmt|;
name|occ
operator|-=
literal|2
expr_stmt|;
name|i
operator|=
name|beg
expr_stmt|;
break|break;
block|}
block|}
while|while
condition|(
name|i
operator|<
name|beg
condition|)
block|{
comment|/* write out non-run */
if|if
condition|(
operator|(
name|j
operator|=
name|beg
operator|-
name|i
operator|)
operator|>
literal|127
condition|)
name|j
operator|=
literal|127
expr_stmt|;
if|if
condition|(
name|occ
operator|<
name|j
operator|+
literal|3
condition|)
block|{
name|tif
operator|->
name|tif_rawcp
operator|=
name|op
expr_stmt|;
name|tif
operator|->
name|tif_rawcc
operator|=
name|tif
operator|->
name|tif_rawdatasize
operator|-
name|occ
expr_stmt|;
if|if
condition|(
operator|!
name|TIFFFlushData1
argument_list|(
name|tif
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|op
operator|=
name|tif
operator|->
name|tif_rawcp
expr_stmt|;
name|occ
operator|=
name|tif
operator|->
name|tif_rawdatasize
operator|-
name|tif
operator|->
name|tif_rawcc
expr_stmt|;
block|}
operator|*
name|op
operator|++
operator|=
operator|(
name|tidataval_t
operator|)
name|j
expr_stmt|;
name|occ
operator|--
expr_stmt|;
while|while
condition|(
name|j
operator|--
condition|)
block|{
operator|*
name|op
operator|++
operator|=
call|(
name|tidataval_t
call|)
argument_list|(
name|tp
index|[
name|i
operator|++
index|]
operator|>>
name|shft
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|occ
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rc
operator|>=
name|MINRUN
condition|)
block|{
comment|/* write out run */
operator|*
name|op
operator|++
operator|=
call|(
name|tidataval_t
call|)
argument_list|(
literal|128
operator|-
literal|2
operator|+
name|rc
argument_list|)
expr_stmt|;
operator|*
name|op
operator|++
operator|=
call|(
name|tidataval_t
call|)
argument_list|(
name|tp
index|[
name|beg
index|]
operator|>>
name|shft
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|occ
operator|-=
literal|2
expr_stmt|;
block|}
else|else
name|rc
operator|=
literal|0
expr_stmt|;
block|}
name|tif
operator|->
name|tif_rawcp
operator|=
name|op
expr_stmt|;
name|tif
operator|->
name|tif_rawcc
operator|=
name|tif
operator|->
name|tif_rawdatasize
operator|-
name|occ
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Encode a row of 24-bit pixels.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|LogLuvEncode24
name|LogLuvEncode24
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|bp
parameter_list|,
name|tsize_t
name|cc
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|LogLuvState
modifier|*
name|sp
init|=
name|EncoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|npixels
decl_stmt|,
name|occ
decl_stmt|;
name|tidata_t
name|op
decl_stmt|;
name|uint32
modifier|*
name|tp
decl_stmt|;
name|assert
argument_list|(
name|s
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|npixels
operator|=
name|cc
operator|/
name|sp
operator|->
name|pixel_size
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|user_datafmt
operator|==
name|SGILOGDATAFMT_RAW
condition|)
name|tp
operator|=
operator|(
name|uint32
operator|*
operator|)
name|bp
expr_stmt|;
else|else
block|{
name|tp
operator|=
operator|(
name|uint32
operator|*
operator|)
name|sp
operator|->
name|tbuf
expr_stmt|;
name|assert
argument_list|(
name|sp
operator|->
name|tbuflen
operator|>=
name|npixels
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sp
operator|->
name|tfunc
call|)
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|npixels
argument_list|)
expr_stmt|;
block|}
comment|/* write out encoded pixels */
name|op
operator|=
name|tif
operator|->
name|tif_rawcp
expr_stmt|;
name|occ
operator|=
name|tif
operator|->
name|tif_rawdatasize
operator|-
name|tif
operator|->
name|tif_rawcc
expr_stmt|;
for|for
control|(
name|i
operator|=
name|npixels
init|;
name|i
operator|--
condition|;
control|)
block|{
if|if
condition|(
name|occ
operator|<
literal|3
condition|)
block|{
name|tif
operator|->
name|tif_rawcp
operator|=
name|op
expr_stmt|;
name|tif
operator|->
name|tif_rawcc
operator|=
name|tif
operator|->
name|tif_rawdatasize
operator|-
name|occ
expr_stmt|;
if|if
condition|(
operator|!
name|TIFFFlushData1
argument_list|(
name|tif
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|op
operator|=
name|tif
operator|->
name|tif_rawcp
expr_stmt|;
name|occ
operator|=
name|tif
operator|->
name|tif_rawdatasize
operator|-
name|tif
operator|->
name|tif_rawcc
expr_stmt|;
block|}
operator|*
name|op
operator|++
operator|=
call|(
name|tidataval_t
call|)
argument_list|(
operator|*
name|tp
operator|>>
literal|16
argument_list|)
expr_stmt|;
operator|*
name|op
operator|++
operator|=
call|(
name|tidataval_t
call|)
argument_list|(
operator|*
name|tp
operator|>>
literal|8
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
name|op
operator|++
operator|=
call|(
name|tidataval_t
call|)
argument_list|(
operator|*
name|tp
operator|++
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|occ
operator|-=
literal|3
expr_stmt|;
block|}
name|tif
operator|->
name|tif_rawcp
operator|=
name|op
expr_stmt|;
name|tif
operator|->
name|tif_rawcc
operator|=
name|tif
operator|->
name|tif_rawdatasize
operator|-
name|occ
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Encode a row of 32-bit pixels.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|LogLuvEncode32
name|LogLuvEncode32
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|bp
parameter_list|,
name|tsize_t
name|cc
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|LogLuvState
modifier|*
name|sp
init|=
name|EncoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|int
name|shft
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|npixels
decl_stmt|;
name|tidata_t
name|op
decl_stmt|;
name|uint32
modifier|*
name|tp
decl_stmt|;
name|uint32
name|b
decl_stmt|;
name|int
name|occ
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|,
name|mask
decl_stmt|,
name|beg
decl_stmt|;
name|assert
argument_list|(
name|s
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|npixels
operator|=
name|cc
operator|/
name|sp
operator|->
name|pixel_size
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|user_datafmt
operator|==
name|SGILOGDATAFMT_RAW
condition|)
name|tp
operator|=
operator|(
name|uint32
operator|*
operator|)
name|bp
expr_stmt|;
else|else
block|{
name|tp
operator|=
operator|(
name|uint32
operator|*
operator|)
name|sp
operator|->
name|tbuf
expr_stmt|;
name|assert
argument_list|(
name|sp
operator|->
name|tbuflen
operator|>=
name|npixels
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sp
operator|->
name|tfunc
call|)
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|npixels
argument_list|)
expr_stmt|;
block|}
comment|/* compress each byte string */
name|op
operator|=
name|tif
operator|->
name|tif_rawcp
expr_stmt|;
name|occ
operator|=
name|tif
operator|->
name|tif_rawdatasize
operator|-
name|tif
operator|->
name|tif_rawcc
expr_stmt|;
for|for
control|(
name|shft
operator|=
literal|4
operator|*
literal|8
init|;
operator|(
name|shft
operator|-=
literal|8
operator|)
operator|>=
literal|0
condition|;
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npixels
condition|;
name|i
operator|+=
name|rc
control|)
block|{
if|if
condition|(
name|occ
operator|<
literal|4
condition|)
block|{
name|tif
operator|->
name|tif_rawcp
operator|=
name|op
expr_stmt|;
name|tif
operator|->
name|tif_rawcc
operator|=
name|tif
operator|->
name|tif_rawdatasize
operator|-
name|occ
expr_stmt|;
if|if
condition|(
operator|!
name|TIFFFlushData1
argument_list|(
name|tif
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|op
operator|=
name|tif
operator|->
name|tif_rawcp
expr_stmt|;
name|occ
operator|=
name|tif
operator|->
name|tif_rawdatasize
operator|-
name|tif
operator|->
name|tif_rawcc
expr_stmt|;
block|}
name|mask
operator|=
literal|0xff
operator|<<
name|shft
expr_stmt|;
comment|/* find next run */
for|for
control|(
name|beg
operator|=
name|i
init|;
name|beg
operator|<
name|npixels
condition|;
name|beg
operator|+=
name|rc
control|)
block|{
name|b
operator|=
name|tp
index|[
name|beg
index|]
operator|&
name|mask
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|rc
operator|<
literal|127
operator|+
literal|2
operator|&&
name|beg
operator|+
name|rc
operator|<
name|npixels
operator|&&
operator|(
name|tp
index|[
name|beg
operator|+
name|rc
index|]
operator|&
name|mask
operator|)
operator|==
name|b
condition|)
name|rc
operator|++
expr_stmt|;
if|if
condition|(
name|rc
operator|>=
name|MINRUN
condition|)
break|break;
comment|/* long enough */
block|}
if|if
condition|(
name|beg
operator|-
name|i
operator|>
literal|1
operator|&&
name|beg
operator|-
name|i
operator|<
name|MINRUN
condition|)
block|{
name|b
operator|=
name|tp
index|[
name|i
index|]
operator|&
name|mask
expr_stmt|;
comment|/* check short run */
name|j
operator|=
name|i
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|tp
index|[
name|j
operator|++
index|]
operator|&
name|mask
operator|)
operator|==
name|b
condition|)
if|if
condition|(
name|j
operator|==
name|beg
condition|)
block|{
operator|*
name|op
operator|++
operator|=
call|(
name|tidataval_t
call|)
argument_list|(
literal|128
operator|-
literal|2
operator|+
name|j
operator|-
name|i
argument_list|)
expr_stmt|;
operator|*
name|op
operator|++
operator|=
call|(
name|tidataval_t
call|)
argument_list|(
name|b
operator|>>
name|shft
argument_list|)
expr_stmt|;
name|occ
operator|-=
literal|2
expr_stmt|;
name|i
operator|=
name|beg
expr_stmt|;
break|break;
block|}
block|}
while|while
condition|(
name|i
operator|<
name|beg
condition|)
block|{
comment|/* write out non-run */
if|if
condition|(
operator|(
name|j
operator|=
name|beg
operator|-
name|i
operator|)
operator|>
literal|127
condition|)
name|j
operator|=
literal|127
expr_stmt|;
if|if
condition|(
name|occ
operator|<
name|j
operator|+
literal|3
condition|)
block|{
name|tif
operator|->
name|tif_rawcp
operator|=
name|op
expr_stmt|;
name|tif
operator|->
name|tif_rawcc
operator|=
name|tif
operator|->
name|tif_rawdatasize
operator|-
name|occ
expr_stmt|;
if|if
condition|(
operator|!
name|TIFFFlushData1
argument_list|(
name|tif
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|op
operator|=
name|tif
operator|->
name|tif_rawcp
expr_stmt|;
name|occ
operator|=
name|tif
operator|->
name|tif_rawdatasize
operator|-
name|tif
operator|->
name|tif_rawcc
expr_stmt|;
block|}
operator|*
name|op
operator|++
operator|=
operator|(
name|tidataval_t
operator|)
name|j
expr_stmt|;
name|occ
operator|--
expr_stmt|;
while|while
condition|(
name|j
operator|--
condition|)
block|{
operator|*
name|op
operator|++
operator|=
call|(
name|tidataval_t
call|)
argument_list|(
name|tp
index|[
name|i
operator|++
index|]
operator|>>
name|shft
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|occ
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rc
operator|>=
name|MINRUN
condition|)
block|{
comment|/* write out run */
operator|*
name|op
operator|++
operator|=
call|(
name|tidataval_t
call|)
argument_list|(
literal|128
operator|-
literal|2
operator|+
name|rc
argument_list|)
expr_stmt|;
operator|*
name|op
operator|++
operator|=
call|(
name|tidataval_t
call|)
argument_list|(
name|tp
index|[
name|beg
index|]
operator|>>
name|shft
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|occ
operator|-=
literal|2
expr_stmt|;
block|}
else|else
name|rc
operator|=
literal|0
expr_stmt|;
block|}
name|tif
operator|->
name|tif_rawcp
operator|=
name|op
expr_stmt|;
name|tif
operator|->
name|tif_rawcc
operator|=
name|tif
operator|->
name|tif_rawdatasize
operator|-
name|occ
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Encode a strip of pixels.  We break it into rows to  * avoid encoding runs across row boundaries.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|LogLuvEncodeStrip
name|LogLuvEncodeStrip
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|bp
parameter_list|,
name|tsize_t
name|cc
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|tsize_t
name|rowlen
init|=
name|TIFFScanlineSize
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|cc
operator|%
name|rowlen
operator|==
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|cc
operator|&&
call|(
modifier|*
name|tif
operator|->
name|tif_encoderow
call|)
argument_list|(
name|tif
argument_list|,
name|bp
argument_list|,
name|rowlen
argument_list|,
name|s
argument_list|)
operator|==
literal|1
condition|)
name|bp
operator|+=
name|rowlen
operator|,
name|cc
operator|-=
name|rowlen
expr_stmt|;
return|return
operator|(
name|cc
operator|==
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Encode a tile of pixels.  We break it into rows to  * avoid encoding runs across row boundaries.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|LogLuvEncodeTile
name|LogLuvEncodeTile
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|bp
parameter_list|,
name|tsize_t
name|cc
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|tsize_t
name|rowlen
init|=
name|TIFFTileRowSize
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|cc
operator|%
name|rowlen
operator|==
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|cc
operator|&&
call|(
modifier|*
name|tif
operator|->
name|tif_encoderow
call|)
argument_list|(
name|tif
argument_list|,
name|bp
argument_list|,
name|rowlen
argument_list|,
name|s
argument_list|)
operator|==
literal|1
condition|)
name|bp
operator|+=
name|rowlen
operator|,
name|cc
operator|-=
name|rowlen
expr_stmt|;
return|return
operator|(
name|cc
operator|==
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Encode/Decode functions for converting to and from user formats.  */
end_comment
begin_include
include|#
directive|include
file|"uvcode.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|UVSCALE
end_ifndef
begin_define
DECL|macro|U_NEU
define|#
directive|define
name|U_NEU
value|0.210526316
end_define
begin_define
DECL|macro|V_NEU
define|#
directive|define
name|V_NEU
value|0.473684211
end_define
begin_define
DECL|macro|UVSCALE
define|#
directive|define
name|UVSCALE
value|410.
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|M_LN2
end_ifndef
begin_define
DECL|macro|M_LN2
define|#
directive|define
name|M_LN2
value|0.69314718055994530942
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|M_PI
end_ifndef
begin_define
DECL|macro|M_PI
define|#
directive|define
name|M_PI
value|3.14159265358979323846
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|log2
define|#
directive|define
name|log2
parameter_list|(
name|x
parameter_list|)
value|((1./M_LN2)*log(x))
end_define
begin_define
DECL|macro|exp2
define|#
directive|define
name|exp2
parameter_list|(
name|x
parameter_list|)
value|exp(M_LN2*(x))
end_define
begin_define
DECL|macro|itrunc
define|#
directive|define
name|itrunc
parameter_list|(
name|x
parameter_list|,
name|m
parameter_list|)
value|((m)==SGILOGENCODE_NODITHER ? \ 				(int)(x) : \ 				(int)((x) + rand()*(1./RAND_MAX) - .5))
end_define
begin_if
if|#
directive|if
operator|!
name|LOGLUV_PUBLIC
end_if
begin_function
specifier|static
endif|#
directive|endif
name|double
DECL|function|LogL16toY
name|LogL16toY
parameter_list|(
name|int
name|p16
parameter_list|)
comment|/* compute luminance from 16-bit LogL */
block|{
name|int
name|Le
init|=
name|p16
operator|&
literal|0x7fff
decl_stmt|;
name|double
name|Y
decl_stmt|;
if|if
condition|(
operator|!
name|Le
condition|)
return|return
operator|(
literal|0.
operator|)
return|;
name|Y
operator|=
name|exp
argument_list|(
name|M_LN2
operator|/
literal|256.
operator|*
operator|(
name|Le
operator|+
literal|.5
operator|)
operator|-
name|M_LN2
operator|*
literal|64.
argument_list|)
expr_stmt|;
return|return
operator|(
operator|!
operator|(
name|p16
operator|&
literal|0x8000
operator|)
condition|?
name|Y
else|:
operator|-
name|Y
operator|)
return|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|LOGLUV_PUBLIC
end_if
begin_function
specifier|static
endif|#
directive|endif
name|int
DECL|function|LogL16fromY
name|LogL16fromY
parameter_list|(
name|double
name|Y
parameter_list|,
name|int
name|em
parameter_list|)
comment|/* get 16-bit LogL from Y */
block|{
if|if
condition|(
name|Y
operator|>=
literal|1.8371976e19
condition|)
return|return
operator|(
literal|0x7fff
operator|)
return|;
if|if
condition|(
name|Y
operator|<=
operator|-
literal|1.8371976e19
condition|)
return|return
operator|(
literal|0xffff
operator|)
return|;
if|if
condition|(
name|Y
operator|>
literal|5.4136769e-20
condition|)
return|return
name|itrunc
argument_list|(
literal|256.
operator|*
operator|(
name|log2
argument_list|(
name|Y
argument_list|)
operator|+
literal|64.
operator|)
argument_list|,
name|em
argument_list|)
return|;
if|if
condition|(
name|Y
operator|<
operator|-
literal|5.4136769e-20
condition|)
return|return
operator|(
operator|~
literal|0x7fff
operator||
name|itrunc
argument_list|(
literal|256.
operator|*
operator|(
name|log2
argument_list|(
operator|-
name|Y
argument_list|)
operator|+
literal|64.
operator|)
argument_list|,
name|em
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|L16toY
name|L16toY
parameter_list|(
name|LogLuvState
modifier|*
name|sp
parameter_list|,
name|tidata_t
name|op
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int16
modifier|*
name|l16
init|=
operator|(
name|int16
operator|*
operator|)
name|sp
operator|->
name|tbuf
decl_stmt|;
name|float
modifier|*
name|yp
init|=
operator|(
name|float
operator|*
operator|)
name|op
decl_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
operator|*
name|yp
operator|++
operator|=
operator|(
name|float
operator|)
name|LogL16toY
argument_list|(
operator|*
name|l16
operator|++
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|L16toGry
name|L16toGry
parameter_list|(
name|LogLuvState
modifier|*
name|sp
parameter_list|,
name|tidata_t
name|op
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int16
modifier|*
name|l16
init|=
operator|(
name|int16
operator|*
operator|)
name|sp
operator|->
name|tbuf
decl_stmt|;
name|uint8
modifier|*
name|gp
init|=
operator|(
name|uint8
operator|*
operator|)
name|op
decl_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
block|{
name|double
name|Y
init|=
name|LogL16toY
argument_list|(
operator|*
name|l16
operator|++
argument_list|)
decl_stmt|;
operator|*
name|gp
operator|++
operator|=
call|(
name|uint8
call|)
argument_list|(
operator|(
name|Y
operator|<=
literal|0.
operator|)
condition|?
literal|0
else|:
operator|(
name|Y
operator|>=
literal|1.
operator|)
condition|?
literal|255
else|:
call|(
name|int
call|)
argument_list|(
literal|256.
operator|*
name|sqrt
argument_list|(
name|Y
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|L16fromY
name|L16fromY
parameter_list|(
name|LogLuvState
modifier|*
name|sp
parameter_list|,
name|tidata_t
name|op
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int16
modifier|*
name|l16
init|=
operator|(
name|int16
operator|*
operator|)
name|sp
operator|->
name|tbuf
decl_stmt|;
name|float
modifier|*
name|yp
init|=
operator|(
name|float
operator|*
operator|)
name|op
decl_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
operator|*
name|l16
operator|++
operator|=
call|(
name|int16
call|)
argument_list|(
name|LogL16fromY
argument_list|(
operator|*
name|yp
operator|++
argument_list|,
name|sp
operator|->
name|encode_meth
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|LOGLUV_PUBLIC
end_if
begin_function
specifier|static
endif|#
directive|endif
name|void
DECL|function|XYZtoRGB24
name|XYZtoRGB24
parameter_list|(
name|float
name|xyz
index|[
literal|3
index|]
parameter_list|,
name|uint8
name|rgb
index|[
literal|3
index|]
parameter_list|)
block|{
name|double
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|;
comment|/* assume CCIR-709 primaries */
name|r
operator|=
literal|2.690
operator|*
name|xyz
index|[
literal|0
index|]
operator|+
operator|-
literal|1.276
operator|*
name|xyz
index|[
literal|1
index|]
operator|+
operator|-
literal|0.414
operator|*
name|xyz
index|[
literal|2
index|]
expr_stmt|;
name|g
operator|=
operator|-
literal|1.022
operator|*
name|xyz
index|[
literal|0
index|]
operator|+
literal|1.978
operator|*
name|xyz
index|[
literal|1
index|]
operator|+
literal|0.044
operator|*
name|xyz
index|[
literal|2
index|]
expr_stmt|;
name|b
operator|=
literal|0.061
operator|*
name|xyz
index|[
literal|0
index|]
operator|+
operator|-
literal|0.224
operator|*
name|xyz
index|[
literal|1
index|]
operator|+
literal|1.163
operator|*
name|xyz
index|[
literal|2
index|]
expr_stmt|;
comment|/* assume 2.0 gamma for speed */
comment|/* could use integer sqrt approx., but this is probably faster */
name|rgb
index|[
literal|0
index|]
operator|=
call|(
name|uint8
call|)
argument_list|(
operator|(
name|r
operator|<=
literal|0.
operator|)
condition|?
literal|0
else|:
operator|(
name|r
operator|>=
literal|1.
operator|)
condition|?
literal|255
else|:
call|(
name|int
call|)
argument_list|(
literal|256.
operator|*
name|sqrt
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|rgb
index|[
literal|1
index|]
operator|=
call|(
name|uint8
call|)
argument_list|(
operator|(
name|g
operator|<=
literal|0.
operator|)
condition|?
literal|0
else|:
operator|(
name|g
operator|>=
literal|1.
operator|)
condition|?
literal|255
else|:
call|(
name|int
call|)
argument_list|(
literal|256.
operator|*
name|sqrt
argument_list|(
name|g
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|rgb
index|[
literal|2
index|]
operator|=
call|(
name|uint8
call|)
argument_list|(
operator|(
name|b
operator|<=
literal|0.
operator|)
condition|?
literal|0
else|:
operator|(
name|b
operator|>=
literal|1.
operator|)
condition|?
literal|255
else|:
call|(
name|int
call|)
argument_list|(
literal|256.
operator|*
name|sqrt
argument_list|(
name|b
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|LOGLUV_PUBLIC
end_if
begin_function
specifier|static
endif|#
directive|endif
name|double
DECL|function|LogL10toY
name|LogL10toY
parameter_list|(
name|int
name|p10
parameter_list|)
comment|/* compute luminance from 10-bit LogL */
block|{
if|if
condition|(
name|p10
operator|==
literal|0
condition|)
return|return
operator|(
literal|0.
operator|)
return|;
return|return
operator|(
name|exp
argument_list|(
name|M_LN2
operator|/
literal|64.
operator|*
operator|(
name|p10
operator|+
literal|.5
operator|)
operator|-
name|M_LN2
operator|*
literal|12.
argument_list|)
operator|)
return|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|LOGLUV_PUBLIC
end_if
begin_function
specifier|static
endif|#
directive|endif
name|int
DECL|function|LogL10fromY
name|LogL10fromY
parameter_list|(
name|double
name|Y
parameter_list|,
name|int
name|em
parameter_list|)
comment|/* get 10-bit LogL from Y */
block|{
if|if
condition|(
name|Y
operator|>=
literal|15.742
condition|)
return|return
operator|(
literal|0x3ff
operator|)
return|;
elseif|else
if|if
condition|(
name|Y
operator|<=
literal|.00024283
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
name|itrunc
argument_list|(
literal|64.
operator|*
operator|(
name|log2
argument_list|(
name|Y
argument_list|)
operator|+
literal|12.
operator|)
argument_list|,
name|em
argument_list|)
return|;
block|}
end_function
begin_define
DECL|macro|NANGLES
define|#
directive|define
name|NANGLES
value|100
end_define
begin_define
DECL|macro|uv2ang
define|#
directive|define
name|uv2ang
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|)
value|( (NANGLES*.499999999/M_PI) \ 				* atan2((v)-V_NEU,(u)-U_NEU) + .5*NANGLES )
end_define
begin_function
specifier|static
name|int
DECL|function|oog_encode
name|oog_encode
parameter_list|(
name|double
name|u
parameter_list|,
name|double
name|v
parameter_list|)
comment|/* encode out-of-gamut chroma */
block|{
specifier|static
name|int
name|oog_table
index|[
name|NANGLES
index|]
decl_stmt|;
specifier|static
name|int
name|initialized
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
comment|/* set up perimeter table */
name|double
name|eps
index|[
name|NANGLES
index|]
decl_stmt|,
name|ua
decl_stmt|,
name|va
decl_stmt|,
name|ang
decl_stmt|,
name|epsa
decl_stmt|;
name|int
name|ui
decl_stmt|,
name|vi
decl_stmt|,
name|ustep
decl_stmt|;
for|for
control|(
name|i
operator|=
name|NANGLES
init|;
name|i
operator|--
condition|;
control|)
name|eps
index|[
name|i
index|]
operator|=
literal|2.
expr_stmt|;
for|for
control|(
name|vi
operator|=
name|UV_NVS
init|;
name|vi
operator|--
condition|;
control|)
block|{
name|va
operator|=
name|UV_VSTART
operator|+
operator|(
name|vi
operator|+
literal|.5
operator|)
operator|*
name|UV_SQSIZ
expr_stmt|;
name|ustep
operator|=
name|uv_row
index|[
name|vi
index|]
operator|.
name|nus
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|vi
operator|==
name|UV_NVS
operator|-
literal|1
operator|||
name|vi
operator|==
literal|0
operator|||
name|ustep
operator|<=
literal|0
condition|)
name|ustep
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|ui
operator|=
name|uv_row
index|[
name|vi
index|]
operator|.
name|nus
operator|-
literal|1
init|;
name|ui
operator|>=
literal|0
condition|;
name|ui
operator|-=
name|ustep
control|)
block|{
name|ua
operator|=
name|uv_row
index|[
name|vi
index|]
operator|.
name|ustart
operator|+
operator|(
name|ui
operator|+
literal|.5
operator|)
operator|*
name|UV_SQSIZ
expr_stmt|;
name|ang
operator|=
name|uv2ang
argument_list|(
name|ua
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|int
operator|)
name|ang
expr_stmt|;
name|epsa
operator|=
name|fabs
argument_list|(
name|ang
operator|-
operator|(
name|i
operator|+
literal|.5
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|epsa
operator|<
name|eps
index|[
name|i
index|]
condition|)
block|{
name|oog_table
index|[
name|i
index|]
operator|=
name|uv_row
index|[
name|vi
index|]
operator|.
name|ncum
operator|+
name|ui
expr_stmt|;
name|eps
index|[
name|i
index|]
operator|=
name|epsa
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
name|NANGLES
init|;
name|i
operator|--
condition|;
control|)
comment|/* fill any holes */
if|if
condition|(
name|eps
index|[
name|i
index|]
operator|>
literal|1.5
condition|)
block|{
name|int
name|i1
decl_stmt|,
name|i2
decl_stmt|;
for|for
control|(
name|i1
operator|=
literal|1
init|;
name|i1
operator|<
name|NANGLES
operator|/
literal|2
condition|;
name|i1
operator|++
control|)
if|if
condition|(
name|eps
index|[
operator|(
name|i
operator|+
name|i1
operator|)
operator|%
name|NANGLES
index|]
operator|<
literal|1.5
condition|)
break|break;
for|for
control|(
name|i2
operator|=
literal|1
init|;
name|i2
operator|<
name|NANGLES
operator|/
literal|2
condition|;
name|i2
operator|++
control|)
if|if
condition|(
name|eps
index|[
operator|(
name|i
operator|+
name|NANGLES
operator|-
name|i2
operator|)
operator|%
name|NANGLES
index|]
operator|<
literal|1.5
condition|)
break|break;
if|if
condition|(
name|i1
operator|<
name|i2
condition|)
name|oog_table
index|[
name|i
index|]
operator|=
name|oog_table
index|[
operator|(
name|i
operator|+
name|i1
operator|)
operator|%
name|NANGLES
index|]
expr_stmt|;
else|else
name|oog_table
index|[
name|i
index|]
operator|=
name|oog_table
index|[
operator|(
name|i
operator|+
name|NANGLES
operator|-
name|i2
operator|)
operator|%
name|NANGLES
index|]
expr_stmt|;
block|}
name|initialized
operator|=
literal|1
expr_stmt|;
block|}
name|i
operator|=
operator|(
name|int
operator|)
name|uv2ang
argument_list|(
name|u
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* look up hue angle */
return|return
operator|(
name|oog_table
index|[
name|i
index|]
operator|)
return|;
block|}
end_function
begin_undef
DECL|macro|uv2ang
undef|#
directive|undef
name|uv2ang
end_undef
begin_undef
DECL|macro|NANGLES
undef|#
directive|undef
name|NANGLES
end_undef
begin_if
if|#
directive|if
operator|!
name|LOGLUV_PUBLIC
end_if
begin_function
specifier|static
endif|#
directive|endif
name|int
DECL|function|uv_encode
name|uv_encode
parameter_list|(
name|double
name|u
parameter_list|,
name|double
name|v
parameter_list|,
name|int
name|em
parameter_list|)
comment|/* encode (u',v') coordinates */
block|{
specifier|register
name|int
name|vi
decl_stmt|,
name|ui
decl_stmt|;
if|if
condition|(
name|v
operator|<
name|UV_VSTART
condition|)
return|return
name|oog_encode
argument_list|(
name|u
argument_list|,
name|v
argument_list|)
return|;
name|vi
operator|=
name|itrunc
argument_list|(
operator|(
name|v
operator|-
name|UV_VSTART
operator|)
operator|*
operator|(
literal|1.
operator|/
name|UV_SQSIZ
operator|)
argument_list|,
name|em
argument_list|)
expr_stmt|;
if|if
condition|(
name|vi
operator|>=
name|UV_NVS
condition|)
return|return
name|oog_encode
argument_list|(
name|u
argument_list|,
name|v
argument_list|)
return|;
if|if
condition|(
name|u
operator|<
name|uv_row
index|[
name|vi
index|]
operator|.
name|ustart
condition|)
return|return
name|oog_encode
argument_list|(
name|u
argument_list|,
name|v
argument_list|)
return|;
name|ui
operator|=
name|itrunc
argument_list|(
operator|(
name|u
operator|-
name|uv_row
index|[
name|vi
index|]
operator|.
name|ustart
operator|)
operator|*
operator|(
literal|1.
operator|/
name|UV_SQSIZ
operator|)
argument_list|,
name|em
argument_list|)
expr_stmt|;
if|if
condition|(
name|ui
operator|>=
name|uv_row
index|[
name|vi
index|]
operator|.
name|nus
condition|)
return|return
name|oog_encode
argument_list|(
name|u
argument_list|,
name|v
argument_list|)
return|;
return|return
operator|(
name|uv_row
index|[
name|vi
index|]
operator|.
name|ncum
operator|+
name|ui
operator|)
return|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|LOGLUV_PUBLIC
end_if
begin_function
specifier|static
endif|#
directive|endif
name|int
DECL|function|uv_decode
name|uv_decode
parameter_list|(
name|double
modifier|*
name|up
parameter_list|,
name|double
modifier|*
name|vp
parameter_list|,
name|int
name|c
parameter_list|)
comment|/* decode (u',v') index */
block|{
name|int
name|upper
decl_stmt|,
name|lower
decl_stmt|;
specifier|register
name|int
name|ui
decl_stmt|,
name|vi
decl_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
operator|||
name|c
operator|>=
name|UV_NDIVS
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|lower
operator|=
literal|0
expr_stmt|;
comment|/* binary search */
name|upper
operator|=
name|UV_NVS
expr_stmt|;
while|while
condition|(
name|upper
operator|-
name|lower
operator|>
literal|1
condition|)
block|{
name|vi
operator|=
operator|(
name|lower
operator|+
name|upper
operator|)
operator|>>
literal|1
expr_stmt|;
name|ui
operator|=
name|c
operator|-
name|uv_row
index|[
name|vi
index|]
operator|.
name|ncum
expr_stmt|;
if|if
condition|(
name|ui
operator|>
literal|0
condition|)
name|lower
operator|=
name|vi
expr_stmt|;
elseif|else
if|if
condition|(
name|ui
operator|<
literal|0
condition|)
name|upper
operator|=
name|vi
expr_stmt|;
else|else
block|{
name|lower
operator|=
name|vi
expr_stmt|;
break|break;
block|}
block|}
name|vi
operator|=
name|lower
expr_stmt|;
name|ui
operator|=
name|c
operator|-
name|uv_row
index|[
name|vi
index|]
operator|.
name|ncum
expr_stmt|;
operator|*
name|up
operator|=
name|uv_row
index|[
name|vi
index|]
operator|.
name|ustart
operator|+
operator|(
name|ui
operator|+
literal|.5
operator|)
operator|*
name|UV_SQSIZ
expr_stmt|;
operator|*
name|vp
operator|=
name|UV_VSTART
operator|+
operator|(
name|vi
operator|+
literal|.5
operator|)
operator|*
name|UV_SQSIZ
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|LOGLUV_PUBLIC
end_if
begin_function
specifier|static
endif|#
directive|endif
name|void
DECL|function|LogLuv24toXYZ
name|LogLuv24toXYZ
parameter_list|(
name|uint32
name|p
parameter_list|,
name|float
name|XYZ
index|[
literal|3
index|]
parameter_list|)
block|{
name|int
name|Ce
decl_stmt|;
name|double
name|L
decl_stmt|,
name|u
decl_stmt|,
name|v
decl_stmt|,
name|s
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/* decode luminance */
name|L
operator|=
name|LogL10toY
argument_list|(
name|p
operator|>>
literal|14
operator|&
literal|0x3ff
argument_list|)
expr_stmt|;
if|if
condition|(
name|L
operator|<=
literal|0.
condition|)
block|{
name|XYZ
index|[
literal|0
index|]
operator|=
name|XYZ
index|[
literal|1
index|]
operator|=
name|XYZ
index|[
literal|2
index|]
operator|=
literal|0.
expr_stmt|;
return|return;
block|}
comment|/* decode color */
name|Ce
operator|=
name|p
operator|&
literal|0x3fff
expr_stmt|;
if|if
condition|(
name|uv_decode
argument_list|(
operator|&
name|u
argument_list|,
operator|&
name|v
argument_list|,
name|Ce
argument_list|)
operator|<
literal|0
condition|)
block|{
name|u
operator|=
name|U_NEU
expr_stmt|;
name|v
operator|=
name|V_NEU
expr_stmt|;
block|}
name|s
operator|=
literal|1.
operator|/
operator|(
literal|6.
operator|*
name|u
operator|-
literal|16.
operator|*
name|v
operator|+
literal|12.
operator|)
expr_stmt|;
name|x
operator|=
literal|9.
operator|*
name|u
operator|*
name|s
expr_stmt|;
name|y
operator|=
literal|4.
operator|*
name|v
operator|*
name|s
expr_stmt|;
comment|/* convert to XYZ */
name|XYZ
index|[
literal|0
index|]
operator|=
call|(
name|float
call|)
argument_list|(
name|x
operator|/
name|y
operator|*
name|L
argument_list|)
expr_stmt|;
name|XYZ
index|[
literal|1
index|]
operator|=
operator|(
name|float
operator|)
name|L
expr_stmt|;
name|XYZ
index|[
literal|2
index|]
operator|=
call|(
name|float
call|)
argument_list|(
operator|(
literal|1.
operator|-
name|x
operator|-
name|y
operator|)
operator|/
name|y
operator|*
name|L
argument_list|)
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|LOGLUV_PUBLIC
end_if
begin_function
specifier|static
endif|#
directive|endif
name|uint32
DECL|function|LogLuv24fromXYZ
name|LogLuv24fromXYZ
parameter_list|(
name|float
name|XYZ
index|[
literal|3
index|]
parameter_list|,
name|int
name|em
parameter_list|)
block|{
name|int
name|Le
decl_stmt|,
name|Ce
decl_stmt|;
name|double
name|u
decl_stmt|,
name|v
decl_stmt|,
name|s
decl_stmt|;
comment|/* encode luminance */
name|Le
operator|=
name|LogL10fromY
argument_list|(
name|XYZ
index|[
literal|1
index|]
argument_list|,
name|em
argument_list|)
expr_stmt|;
comment|/* encode color */
name|s
operator|=
name|XYZ
index|[
literal|0
index|]
operator|+
literal|15.
operator|*
name|XYZ
index|[
literal|1
index|]
operator|+
literal|3.
operator|*
name|XYZ
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|Le
operator|||
name|s
operator|<=
literal|0.
condition|)
block|{
name|u
operator|=
name|U_NEU
expr_stmt|;
name|v
operator|=
name|V_NEU
expr_stmt|;
block|}
else|else
block|{
name|u
operator|=
literal|4.
operator|*
name|XYZ
index|[
literal|0
index|]
operator|/
name|s
expr_stmt|;
name|v
operator|=
literal|9.
operator|*
name|XYZ
index|[
literal|1
index|]
operator|/
name|s
expr_stmt|;
block|}
name|Ce
operator|=
name|uv_encode
argument_list|(
name|u
argument_list|,
name|v
argument_list|,
name|em
argument_list|)
expr_stmt|;
if|if
condition|(
name|Ce
operator|<
literal|0
condition|)
comment|/* never happens */
name|Ce
operator|=
name|uv_encode
argument_list|(
name|U_NEU
argument_list|,
name|V_NEU
argument_list|,
name|SGILOGENCODE_NODITHER
argument_list|)
expr_stmt|;
comment|/* combine encodings */
return|return
operator|(
name|Le
operator|<<
literal|14
operator||
name|Ce
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Luv24toXYZ
name|Luv24toXYZ
parameter_list|(
name|LogLuvState
modifier|*
name|sp
parameter_list|,
name|tidata_t
name|op
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|uint32
modifier|*
name|luv
init|=
operator|(
name|uint32
operator|*
operator|)
name|sp
operator|->
name|tbuf
decl_stmt|;
name|float
modifier|*
name|xyz
init|=
operator|(
name|float
operator|*
operator|)
name|op
decl_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
block|{
name|LogLuv24toXYZ
argument_list|(
operator|*
name|luv
argument_list|,
name|xyz
argument_list|)
expr_stmt|;
name|xyz
operator|+=
literal|3
expr_stmt|;
name|luv
operator|++
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Luv24toLuv48
name|Luv24toLuv48
parameter_list|(
name|LogLuvState
modifier|*
name|sp
parameter_list|,
name|tidata_t
name|op
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|uint32
modifier|*
name|luv
init|=
operator|(
name|uint32
operator|*
operator|)
name|sp
operator|->
name|tbuf
decl_stmt|;
name|int16
modifier|*
name|luv3
init|=
operator|(
name|int16
operator|*
operator|)
name|op
decl_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
block|{
name|double
name|u
decl_stmt|,
name|v
decl_stmt|;
operator|*
name|luv3
operator|++
operator|=
call|(
name|int16
call|)
argument_list|(
operator|(
operator|*
name|luv
operator|>>
literal|12
operator|&
literal|0xffd
operator|)
operator|+
literal|13314
argument_list|)
expr_stmt|;
if|if
condition|(
name|uv_decode
argument_list|(
operator|&
name|u
argument_list|,
operator|&
name|v
argument_list|,
operator|*
name|luv
operator|&
literal|0x3fff
argument_list|)
operator|<
literal|0
condition|)
block|{
name|u
operator|=
name|U_NEU
expr_stmt|;
name|v
operator|=
name|V_NEU
expr_stmt|;
block|}
operator|*
name|luv3
operator|++
operator|=
call|(
name|int16
call|)
argument_list|(
name|u
operator|*
operator|(
literal|1L
operator|<<
literal|15
operator|)
argument_list|)
expr_stmt|;
operator|*
name|luv3
operator|++
operator|=
call|(
name|int16
call|)
argument_list|(
name|v
operator|*
operator|(
literal|1L
operator|<<
literal|15
operator|)
argument_list|)
expr_stmt|;
name|luv
operator|++
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Luv24toRGB
name|Luv24toRGB
parameter_list|(
name|LogLuvState
modifier|*
name|sp
parameter_list|,
name|tidata_t
name|op
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|uint32
modifier|*
name|luv
init|=
operator|(
name|uint32
operator|*
operator|)
name|sp
operator|->
name|tbuf
decl_stmt|;
name|uint8
modifier|*
name|rgb
init|=
operator|(
name|uint8
operator|*
operator|)
name|op
decl_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
block|{
name|float
name|xyz
index|[
literal|3
index|]
decl_stmt|;
name|LogLuv24toXYZ
argument_list|(
operator|*
name|luv
operator|++
argument_list|,
name|xyz
argument_list|)
expr_stmt|;
name|XYZtoRGB24
argument_list|(
name|xyz
argument_list|,
name|rgb
argument_list|)
expr_stmt|;
name|rgb
operator|+=
literal|3
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Luv24fromXYZ
name|Luv24fromXYZ
parameter_list|(
name|LogLuvState
modifier|*
name|sp
parameter_list|,
name|tidata_t
name|op
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|uint32
modifier|*
name|luv
init|=
operator|(
name|uint32
operator|*
operator|)
name|sp
operator|->
name|tbuf
decl_stmt|;
name|float
modifier|*
name|xyz
init|=
operator|(
name|float
operator|*
operator|)
name|op
decl_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
block|{
operator|*
name|luv
operator|++
operator|=
name|LogLuv24fromXYZ
argument_list|(
name|xyz
argument_list|,
name|sp
operator|->
name|encode_meth
argument_list|)
expr_stmt|;
name|xyz
operator|+=
literal|3
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Luv24fromLuv48
name|Luv24fromLuv48
parameter_list|(
name|LogLuvState
modifier|*
name|sp
parameter_list|,
name|tidata_t
name|op
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|uint32
modifier|*
name|luv
init|=
operator|(
name|uint32
operator|*
operator|)
name|sp
operator|->
name|tbuf
decl_stmt|;
name|int16
modifier|*
name|luv3
init|=
operator|(
name|int16
operator|*
operator|)
name|op
decl_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
block|{
name|int
name|Le
decl_stmt|,
name|Ce
decl_stmt|;
if|if
condition|(
name|luv3
index|[
literal|0
index|]
operator|<=
literal|0
condition|)
name|Le
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|luv3
index|[
literal|0
index|]
operator|>=
operator|(
literal|1
operator|<<
literal|12
operator|)
operator|+
literal|3314
condition|)
name|Le
operator|=
operator|(
literal|1
operator|<<
literal|10
operator|)
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|sp
operator|->
name|encode_meth
operator|==
name|SGILOGENCODE_NODITHER
condition|)
name|Le
operator|=
operator|(
name|luv3
index|[
literal|0
index|]
operator|-
literal|3314
operator|)
operator|>>
literal|2
expr_stmt|;
else|else
name|Le
operator|=
name|itrunc
argument_list|(
literal|.25
operator|*
operator|(
name|luv3
index|[
literal|0
index|]
operator|-
literal|3314.
operator|)
argument_list|,
name|sp
operator|->
name|encode_meth
argument_list|)
expr_stmt|;
name|Ce
operator|=
name|uv_encode
argument_list|(
operator|(
name|luv3
index|[
literal|1
index|]
operator|+
literal|.5
operator|)
operator|/
operator|(
literal|1
operator|<<
literal|15
operator|)
argument_list|,
operator|(
name|luv3
index|[
literal|2
index|]
operator|+
literal|.5
operator|)
operator|/
operator|(
literal|1
operator|<<
literal|15
operator|)
argument_list|,
name|sp
operator|->
name|encode_meth
argument_list|)
expr_stmt|;
if|if
condition|(
name|Ce
operator|<
literal|0
condition|)
comment|/* never happens */
name|Ce
operator|=
name|uv_encode
argument_list|(
name|U_NEU
argument_list|,
name|V_NEU
argument_list|,
name|SGILOGENCODE_NODITHER
argument_list|)
expr_stmt|;
operator|*
name|luv
operator|++
operator|=
operator|(
name|uint32
operator|)
name|Le
operator|<<
literal|14
operator||
name|Ce
expr_stmt|;
name|luv3
operator|+=
literal|3
expr_stmt|;
block|}
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|LOGLUV_PUBLIC
end_if
begin_function
specifier|static
endif|#
directive|endif
name|void
DECL|function|LogLuv32toXYZ
name|LogLuv32toXYZ
parameter_list|(
name|uint32
name|p
parameter_list|,
name|float
name|XYZ
index|[
literal|3
index|]
parameter_list|)
block|{
name|double
name|L
decl_stmt|,
name|u
decl_stmt|,
name|v
decl_stmt|,
name|s
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/* decode luminance */
name|L
operator|=
name|LogL16toY
argument_list|(
operator|(
name|int
operator|)
name|p
operator|>>
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|L
operator|<=
literal|0.
condition|)
block|{
name|XYZ
index|[
literal|0
index|]
operator|=
name|XYZ
index|[
literal|1
index|]
operator|=
name|XYZ
index|[
literal|2
index|]
operator|=
literal|0.
expr_stmt|;
return|return;
block|}
comment|/* decode color */
name|u
operator|=
literal|1.
operator|/
name|UVSCALE
operator|*
operator|(
operator|(
name|p
operator|>>
literal|8
operator|&
literal|0xff
operator|)
operator|+
literal|.5
operator|)
expr_stmt|;
name|v
operator|=
literal|1.
operator|/
name|UVSCALE
operator|*
operator|(
operator|(
name|p
operator|&
literal|0xff
operator|)
operator|+
literal|.5
operator|)
expr_stmt|;
name|s
operator|=
literal|1.
operator|/
operator|(
literal|6.
operator|*
name|u
operator|-
literal|16.
operator|*
name|v
operator|+
literal|12.
operator|)
expr_stmt|;
name|x
operator|=
literal|9.
operator|*
name|u
operator|*
name|s
expr_stmt|;
name|y
operator|=
literal|4.
operator|*
name|v
operator|*
name|s
expr_stmt|;
comment|/* convert to XYZ */
name|XYZ
index|[
literal|0
index|]
operator|=
call|(
name|float
call|)
argument_list|(
name|x
operator|/
name|y
operator|*
name|L
argument_list|)
expr_stmt|;
name|XYZ
index|[
literal|1
index|]
operator|=
operator|(
name|float
operator|)
name|L
expr_stmt|;
name|XYZ
index|[
literal|2
index|]
operator|=
call|(
name|float
call|)
argument_list|(
operator|(
literal|1.
operator|-
name|x
operator|-
name|y
operator|)
operator|/
name|y
operator|*
name|L
argument_list|)
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|LOGLUV_PUBLIC
end_if
begin_function
specifier|static
endif|#
directive|endif
name|uint32
DECL|function|LogLuv32fromXYZ
name|LogLuv32fromXYZ
parameter_list|(
name|float
name|XYZ
index|[
literal|3
index|]
parameter_list|,
name|int
name|em
parameter_list|)
block|{
name|unsigned
name|int
name|Le
decl_stmt|,
name|ue
decl_stmt|,
name|ve
decl_stmt|;
name|double
name|u
decl_stmt|,
name|v
decl_stmt|,
name|s
decl_stmt|;
comment|/* encode luminance */
name|Le
operator|=
operator|(
name|unsigned
name|int
operator|)
name|LogL16fromY
argument_list|(
name|XYZ
index|[
literal|1
index|]
argument_list|,
name|em
argument_list|)
expr_stmt|;
comment|/* encode color */
name|s
operator|=
name|XYZ
index|[
literal|0
index|]
operator|+
literal|15.
operator|*
name|XYZ
index|[
literal|1
index|]
operator|+
literal|3.
operator|*
name|XYZ
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|Le
operator|||
name|s
operator|<=
literal|0.
condition|)
block|{
name|u
operator|=
name|U_NEU
expr_stmt|;
name|v
operator|=
name|V_NEU
expr_stmt|;
block|}
else|else
block|{
name|u
operator|=
literal|4.
operator|*
name|XYZ
index|[
literal|0
index|]
operator|/
name|s
expr_stmt|;
name|v
operator|=
literal|9.
operator|*
name|XYZ
index|[
literal|1
index|]
operator|/
name|s
expr_stmt|;
block|}
if|if
condition|(
name|u
operator|<=
literal|0.
condition|)
name|ue
operator|=
literal|0
expr_stmt|;
else|else
name|ue
operator|=
name|itrunc
argument_list|(
name|UVSCALE
operator|*
name|u
argument_list|,
name|em
argument_list|)
expr_stmt|;
if|if
condition|(
name|ue
operator|>
literal|255
condition|)
name|ue
operator|=
literal|255
expr_stmt|;
if|if
condition|(
name|v
operator|<=
literal|0.
condition|)
name|ve
operator|=
literal|0
expr_stmt|;
else|else
name|ve
operator|=
name|itrunc
argument_list|(
name|UVSCALE
operator|*
name|v
argument_list|,
name|em
argument_list|)
expr_stmt|;
if|if
condition|(
name|ve
operator|>
literal|255
condition|)
name|ve
operator|=
literal|255
expr_stmt|;
comment|/* combine encodings */
return|return
operator|(
name|Le
operator|<<
literal|16
operator||
name|ue
operator|<<
literal|8
operator||
name|ve
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Luv32toXYZ
name|Luv32toXYZ
parameter_list|(
name|LogLuvState
modifier|*
name|sp
parameter_list|,
name|tidata_t
name|op
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|uint32
modifier|*
name|luv
init|=
operator|(
name|uint32
operator|*
operator|)
name|sp
operator|->
name|tbuf
decl_stmt|;
name|float
modifier|*
name|xyz
init|=
operator|(
name|float
operator|*
operator|)
name|op
decl_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
block|{
name|LogLuv32toXYZ
argument_list|(
operator|*
name|luv
operator|++
argument_list|,
name|xyz
argument_list|)
expr_stmt|;
name|xyz
operator|+=
literal|3
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Luv32toLuv48
name|Luv32toLuv48
parameter_list|(
name|LogLuvState
modifier|*
name|sp
parameter_list|,
name|tidata_t
name|op
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|uint32
modifier|*
name|luv
init|=
operator|(
name|uint32
operator|*
operator|)
name|sp
operator|->
name|tbuf
decl_stmt|;
name|int16
modifier|*
name|luv3
init|=
operator|(
name|int16
operator|*
operator|)
name|op
decl_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
block|{
name|double
name|u
decl_stmt|,
name|v
decl_stmt|;
operator|*
name|luv3
operator|++
operator|=
call|(
name|int16
call|)
argument_list|(
operator|*
name|luv
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|u
operator|=
literal|1.
operator|/
name|UVSCALE
operator|*
operator|(
operator|(
operator|*
name|luv
operator|>>
literal|8
operator|&
literal|0xff
operator|)
operator|+
literal|.5
operator|)
expr_stmt|;
name|v
operator|=
literal|1.
operator|/
name|UVSCALE
operator|*
operator|(
operator|(
operator|*
name|luv
operator|&
literal|0xff
operator|)
operator|+
literal|.5
operator|)
expr_stmt|;
operator|*
name|luv3
operator|++
operator|=
call|(
name|int16
call|)
argument_list|(
name|u
operator|*
operator|(
literal|1L
operator|<<
literal|15
operator|)
argument_list|)
expr_stmt|;
operator|*
name|luv3
operator|++
operator|=
call|(
name|int16
call|)
argument_list|(
name|v
operator|*
operator|(
literal|1L
operator|<<
literal|15
operator|)
argument_list|)
expr_stmt|;
name|luv
operator|++
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Luv32toRGB
name|Luv32toRGB
parameter_list|(
name|LogLuvState
modifier|*
name|sp
parameter_list|,
name|tidata_t
name|op
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|uint32
modifier|*
name|luv
init|=
operator|(
name|uint32
operator|*
operator|)
name|sp
operator|->
name|tbuf
decl_stmt|;
name|uint8
modifier|*
name|rgb
init|=
operator|(
name|uint8
operator|*
operator|)
name|op
decl_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
block|{
name|float
name|xyz
index|[
literal|3
index|]
decl_stmt|;
name|LogLuv32toXYZ
argument_list|(
operator|*
name|luv
operator|++
argument_list|,
name|xyz
argument_list|)
expr_stmt|;
name|XYZtoRGB24
argument_list|(
name|xyz
argument_list|,
name|rgb
argument_list|)
expr_stmt|;
name|rgb
operator|+=
literal|3
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Luv32fromXYZ
name|Luv32fromXYZ
parameter_list|(
name|LogLuvState
modifier|*
name|sp
parameter_list|,
name|tidata_t
name|op
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|uint32
modifier|*
name|luv
init|=
operator|(
name|uint32
operator|*
operator|)
name|sp
operator|->
name|tbuf
decl_stmt|;
name|float
modifier|*
name|xyz
init|=
operator|(
name|float
operator|*
operator|)
name|op
decl_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
block|{
operator|*
name|luv
operator|++
operator|=
name|LogLuv32fromXYZ
argument_list|(
name|xyz
argument_list|,
name|sp
operator|->
name|encode_meth
argument_list|)
expr_stmt|;
name|xyz
operator|+=
literal|3
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Luv32fromLuv48
name|Luv32fromLuv48
parameter_list|(
name|LogLuvState
modifier|*
name|sp
parameter_list|,
name|tidata_t
name|op
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|uint32
modifier|*
name|luv
init|=
operator|(
name|uint32
operator|*
operator|)
name|sp
operator|->
name|tbuf
decl_stmt|;
name|int16
modifier|*
name|luv3
init|=
operator|(
name|int16
operator|*
operator|)
name|op
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|encode_meth
operator|==
name|SGILOGENCODE_NODITHER
condition|)
block|{
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
block|{
operator|*
name|luv
operator|++
operator|=
operator|(
name|uint32
operator|)
name|luv3
index|[
literal|0
index|]
operator|<<
literal|16
operator||
operator|(
name|luv3
index|[
literal|1
index|]
operator|*
call|(
name|uint32
call|)
argument_list|(
name|UVSCALE
operator|+
literal|.5
argument_list|)
operator|>>
literal|7
operator|&
literal|0xff00
operator|)
operator||
operator|(
name|luv3
index|[
literal|2
index|]
operator|*
call|(
name|uint32
call|)
argument_list|(
name|UVSCALE
operator|+
literal|.5
argument_list|)
operator|>>
literal|15
operator|&
literal|0xff
operator|)
expr_stmt|;
name|luv3
operator|+=
literal|3
expr_stmt|;
block|}
return|return;
block|}
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
block|{
operator|*
name|luv
operator|++
operator|=
operator|(
name|uint32
operator|)
name|luv3
index|[
literal|0
index|]
operator|<<
literal|16
operator||
operator|(
name|itrunc
argument_list|(
name|luv3
index|[
literal|1
index|]
operator|*
operator|(
name|UVSCALE
operator|/
operator|(
literal|1
operator|<<
literal|15
operator|)
operator|)
argument_list|,
name|sp
operator|->
name|encode_meth
argument_list|)
operator|<<
literal|8
operator|&
literal|0xff00
operator|)
operator||
operator|(
name|itrunc
argument_list|(
name|luv3
index|[
literal|2
index|]
operator|*
operator|(
name|UVSCALE
operator|/
operator|(
literal|1
operator|<<
literal|15
operator|)
operator|)
argument_list|,
name|sp
operator|->
name|encode_meth
argument_list|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|luv3
operator|+=
literal|3
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|_logLuvNop
name|_logLuvNop
parameter_list|(
name|LogLuvState
modifier|*
name|sp
parameter_list|,
name|tidata_t
name|op
parameter_list|,
name|int
name|n
parameter_list|)
block|{
operator|(
name|void
operator|)
name|sp
expr_stmt|;
operator|(
name|void
operator|)
name|op
expr_stmt|;
operator|(
name|void
operator|)
name|n
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|LogL16GuessDataFmt
name|LogL16GuessDataFmt
parameter_list|(
name|TIFFDirectory
modifier|*
name|td
parameter_list|)
block|{
DECL|macro|PACK
define|#
directive|define
name|PACK
parameter_list|(
name|s
parameter_list|,
name|b
parameter_list|,
name|f
parameter_list|)
value|(((b)<<6)|((s)<<3)|(f))
switch|switch
condition|(
name|PACK
argument_list|(
name|td
operator|->
name|td_samplesperpixel
argument_list|,
name|td
operator|->
name|td_bitspersample
argument_list|,
name|td
operator|->
name|td_sampleformat
argument_list|)
condition|)
block|{
case|case
name|PACK
argument_list|(
literal|1
argument_list|,
literal|32
argument_list|,
name|SAMPLEFORMAT_IEEEFP
argument_list|)
case|:
return|return
operator|(
name|SGILOGDATAFMT_FLOAT
operator|)
return|;
case|case
name|PACK
argument_list|(
literal|1
argument_list|,
literal|16
argument_list|,
name|SAMPLEFORMAT_VOID
argument_list|)
case|:
case|case
name|PACK
argument_list|(
literal|1
argument_list|,
literal|16
argument_list|,
name|SAMPLEFORMAT_INT
argument_list|)
case|:
case|case
name|PACK
argument_list|(
literal|1
argument_list|,
literal|16
argument_list|,
name|SAMPLEFORMAT_UINT
argument_list|)
case|:
return|return
operator|(
name|SGILOGDATAFMT_16BIT
operator|)
return|;
case|case
name|PACK
argument_list|(
literal|1
argument_list|,
literal|8
argument_list|,
name|SAMPLEFORMAT_VOID
argument_list|)
case|:
case|case
name|PACK
argument_list|(
literal|1
argument_list|,
literal|8
argument_list|,
name|SAMPLEFORMAT_UINT
argument_list|)
case|:
return|return
operator|(
name|SGILOGDATAFMT_8BIT
operator|)
return|;
block|}
DECL|macro|PACK
undef|#
directive|undef
name|PACK
return|return
operator|(
name|SGILOGDATAFMT_UNKNOWN
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|uint32
DECL|function|multiply
name|multiply
parameter_list|(
name|size_t
name|m1
parameter_list|,
name|size_t
name|m2
parameter_list|)
block|{
name|uint32
name|bytes
init|=
name|m1
operator|*
name|m2
decl_stmt|;
if|if
condition|(
name|m1
operator|&&
name|bytes
operator|/
name|m1
operator|!=
name|m2
condition|)
name|bytes
operator|=
literal|0
expr_stmt|;
return|return
name|bytes
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|LogL16InitState
name|LogL16InitState
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|LogLuvState
modifier|*
name|sp
init|=
name|DecoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|"LogL16InitState"
decl_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|td
operator|->
name|td_photometric
operator|==
name|PHOTOMETRIC_LOGL
argument_list|)
expr_stmt|;
comment|/* for some reason, we can't do this in TIFFInitLogL16 */
if|if
condition|(
name|sp
operator|->
name|user_datafmt
operator|==
name|SGILOGDATAFMT_UNKNOWN
condition|)
name|sp
operator|->
name|user_datafmt
operator|=
name|LogL16GuessDataFmt
argument_list|(
name|td
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|user_datafmt
condition|)
block|{
case|case
name|SGILOGDATAFMT_FLOAT
case|:
name|sp
operator|->
name|pixel_size
operator|=
sizeof|sizeof
argument_list|(
name|float
argument_list|)
expr_stmt|;
break|break;
case|case
name|SGILOGDATAFMT_16BIT
case|:
name|sp
operator|->
name|pixel_size
operator|=
sizeof|sizeof
argument_list|(
name|int16
argument_list|)
expr_stmt|;
break|break;
case|case
name|SGILOGDATAFMT_8BIT
case|:
name|sp
operator|->
name|pixel_size
operator|=
sizeof|sizeof
argument_list|(
name|uint8
argument_list|)
expr_stmt|;
break|break;
default|default:
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"No support for converting user data format to LogL"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|isTiled
argument_list|(
name|tif
argument_list|)
condition|)
name|sp
operator|->
name|tbuflen
operator|=
name|multiply
argument_list|(
name|td
operator|->
name|td_tilewidth
argument_list|,
name|td
operator|->
name|td_tilelength
argument_list|)
expr_stmt|;
else|else
name|sp
operator|->
name|tbuflen
operator|=
name|multiply
argument_list|(
name|td
operator|->
name|td_imagewidth
argument_list|,
name|td
operator|->
name|td_rowsperstrip
argument_list|)
expr_stmt|;
if|if
condition|(
name|multiply
argument_list|(
name|sp
operator|->
name|tbuflen
argument_list|,
sizeof|sizeof
argument_list|(
name|int16
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|sp
operator|->
name|tbuf
operator|=
operator|(
name|tidata_t
operator|*
operator|)
name|_TIFFmalloc
argument_list|(
name|sp
operator|->
name|tbuflen
operator|*
sizeof|sizeof
argument_list|(
name|int16
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: No space for SGILog translation buffer"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|LogLuvGuessDataFmt
name|LogLuvGuessDataFmt
parameter_list|(
name|TIFFDirectory
modifier|*
name|td
parameter_list|)
block|{
name|int
name|guess
decl_stmt|;
comment|/* 	 * If the user didn't tell us their datafmt, 	 * take our best guess from the bitspersample. 	 */
DECL|macro|PACK
define|#
directive|define
name|PACK
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)<<3)|(b))
switch|switch
condition|(
name|PACK
argument_list|(
name|td
operator|->
name|td_bitspersample
argument_list|,
name|td
operator|->
name|td_sampleformat
argument_list|)
condition|)
block|{
case|case
name|PACK
argument_list|(
literal|32
argument_list|,
name|SAMPLEFORMAT_IEEEFP
argument_list|)
case|:
name|guess
operator|=
name|SGILOGDATAFMT_FLOAT
expr_stmt|;
break|break;
case|case
name|PACK
argument_list|(
literal|32
argument_list|,
name|SAMPLEFORMAT_VOID
argument_list|)
case|:
case|case
name|PACK
argument_list|(
literal|32
argument_list|,
name|SAMPLEFORMAT_UINT
argument_list|)
case|:
case|case
name|PACK
argument_list|(
literal|32
argument_list|,
name|SAMPLEFORMAT_INT
argument_list|)
case|:
name|guess
operator|=
name|SGILOGDATAFMT_RAW
expr_stmt|;
break|break;
case|case
name|PACK
argument_list|(
literal|16
argument_list|,
name|SAMPLEFORMAT_VOID
argument_list|)
case|:
case|case
name|PACK
argument_list|(
literal|16
argument_list|,
name|SAMPLEFORMAT_INT
argument_list|)
case|:
case|case
name|PACK
argument_list|(
literal|16
argument_list|,
name|SAMPLEFORMAT_UINT
argument_list|)
case|:
name|guess
operator|=
name|SGILOGDATAFMT_16BIT
expr_stmt|;
break|break;
case|case
name|PACK
argument_list|(
literal|8
argument_list|,
name|SAMPLEFORMAT_VOID
argument_list|)
case|:
case|case
name|PACK
argument_list|(
literal|8
argument_list|,
name|SAMPLEFORMAT_UINT
argument_list|)
case|:
name|guess
operator|=
name|SGILOGDATAFMT_8BIT
expr_stmt|;
break|break;
default|default:
name|guess
operator|=
name|SGILOGDATAFMT_UNKNOWN
expr_stmt|;
break|break;
DECL|macro|PACK
undef|#
directive|undef
name|PACK
block|}
comment|/* 	 * Double-check samples per pixel. 	 */
switch|switch
condition|(
name|td
operator|->
name|td_samplesperpixel
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|guess
operator|!=
name|SGILOGDATAFMT_RAW
condition|)
name|guess
operator|=
name|SGILOGDATAFMT_UNKNOWN
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|guess
operator|==
name|SGILOGDATAFMT_RAW
condition|)
name|guess
operator|=
name|SGILOGDATAFMT_UNKNOWN
expr_stmt|;
break|break;
default|default:
name|guess
operator|=
name|SGILOGDATAFMT_UNKNOWN
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|guess
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|LogLuvInitState
name|LogLuvInitState
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|LogLuvState
modifier|*
name|sp
init|=
name|DecoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|"LogLuvInitState"
decl_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|td
operator|->
name|td_photometric
operator|==
name|PHOTOMETRIC_LOGLUV
argument_list|)
expr_stmt|;
comment|/* for some reason, we can't do this in TIFFInitLogLuv */
if|if
condition|(
name|td
operator|->
name|td_planarconfig
operator|!=
name|PLANARCONFIG_CONTIG
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"SGILog compression cannot handle non-contiguous data"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sp
operator|->
name|user_datafmt
operator|==
name|SGILOGDATAFMT_UNKNOWN
condition|)
name|sp
operator|->
name|user_datafmt
operator|=
name|LogLuvGuessDataFmt
argument_list|(
name|td
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|user_datafmt
condition|)
block|{
case|case
name|SGILOGDATAFMT_FLOAT
case|:
name|sp
operator|->
name|pixel_size
operator|=
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|float
argument_list|)
expr_stmt|;
break|break;
case|case
name|SGILOGDATAFMT_16BIT
case|:
name|sp
operator|->
name|pixel_size
operator|=
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|int16
argument_list|)
expr_stmt|;
break|break;
case|case
name|SGILOGDATAFMT_RAW
case|:
name|sp
operator|->
name|pixel_size
operator|=
sizeof|sizeof
argument_list|(
name|uint32
argument_list|)
expr_stmt|;
break|break;
case|case
name|SGILOGDATAFMT_8BIT
case|:
name|sp
operator|->
name|pixel_size
operator|=
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint8
argument_list|)
expr_stmt|;
break|break;
default|default:
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"No support for converting user data format to LogLuv"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|isTiled
argument_list|(
name|tif
argument_list|)
condition|)
name|sp
operator|->
name|tbuflen
operator|=
name|multiply
argument_list|(
name|td
operator|->
name|td_tilewidth
argument_list|,
name|td
operator|->
name|td_tilelength
argument_list|)
expr_stmt|;
else|else
name|sp
operator|->
name|tbuflen
operator|=
name|multiply
argument_list|(
name|td
operator|->
name|td_imagewidth
argument_list|,
name|td
operator|->
name|td_rowsperstrip
argument_list|)
expr_stmt|;
if|if
condition|(
name|multiply
argument_list|(
name|sp
operator|->
name|tbuflen
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|sp
operator|->
name|tbuf
operator|=
operator|(
name|tidata_t
operator|*
operator|)
name|_TIFFmalloc
argument_list|(
name|sp
operator|->
name|tbuflen
operator|*
sizeof|sizeof
argument_list|(
name|uint32
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: No space for SGILog translation buffer"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|LogLuvSetupDecode
name|LogLuvSetupDecode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|LogLuvState
modifier|*
name|sp
init|=
name|DecoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|tif
operator|->
name|tif_postdecode
operator|=
name|_TIFFNoPostDecode
expr_stmt|;
switch|switch
condition|(
name|td
operator|->
name|td_photometric
condition|)
block|{
case|case
name|PHOTOMETRIC_LOGLUV
case|:
if|if
condition|(
operator|!
name|LogLuvInitState
argument_list|(
name|tif
argument_list|)
condition|)
break|break;
if|if
condition|(
name|td
operator|->
name|td_compression
operator|==
name|COMPRESSION_SGILOG24
condition|)
block|{
name|tif
operator|->
name|tif_decoderow
operator|=
name|LogLuvDecode24
expr_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|user_datafmt
condition|)
block|{
case|case
name|SGILOGDATAFMT_FLOAT
case|:
name|sp
operator|->
name|tfunc
operator|=
name|Luv24toXYZ
expr_stmt|;
break|break;
case|case
name|SGILOGDATAFMT_16BIT
case|:
name|sp
operator|->
name|tfunc
operator|=
name|Luv24toLuv48
expr_stmt|;
break|break;
case|case
name|SGILOGDATAFMT_8BIT
case|:
name|sp
operator|->
name|tfunc
operator|=
name|Luv24toRGB
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|tif
operator|->
name|tif_decoderow
operator|=
name|LogLuvDecode32
expr_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|user_datafmt
condition|)
block|{
case|case
name|SGILOGDATAFMT_FLOAT
case|:
name|sp
operator|->
name|tfunc
operator|=
name|Luv32toXYZ
expr_stmt|;
break|break;
case|case
name|SGILOGDATAFMT_16BIT
case|:
name|sp
operator|->
name|tfunc
operator|=
name|Luv32toLuv48
expr_stmt|;
break|break;
case|case
name|SGILOGDATAFMT_8BIT
case|:
name|sp
operator|->
name|tfunc
operator|=
name|Luv32toRGB
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|PHOTOMETRIC_LOGL
case|:
if|if
condition|(
operator|!
name|LogL16InitState
argument_list|(
name|tif
argument_list|)
condition|)
break|break;
name|tif
operator|->
name|tif_decoderow
operator|=
name|LogL16Decode
expr_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|user_datafmt
condition|)
block|{
case|case
name|SGILOGDATAFMT_FLOAT
case|:
name|sp
operator|->
name|tfunc
operator|=
name|L16toY
expr_stmt|;
break|break;
case|case
name|SGILOGDATAFMT_8BIT
case|:
name|sp
operator|->
name|tfunc
operator|=
name|L16toGry
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|1
operator|)
return|;
default|default:
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"Inappropriate photometric interpretation %d for SGILog compression; %s"
argument_list|,
name|td
operator|->
name|td_photometric
argument_list|,
literal|"must be either LogLUV or LogL"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|LogLuvSetupEncode
name|LogLuvSetupEncode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|LogLuvState
modifier|*
name|sp
init|=
name|EncoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
switch|switch
condition|(
name|td
operator|->
name|td_photometric
condition|)
block|{
case|case
name|PHOTOMETRIC_LOGLUV
case|:
if|if
condition|(
operator|!
name|LogLuvInitState
argument_list|(
name|tif
argument_list|)
condition|)
break|break;
if|if
condition|(
name|td
operator|->
name|td_compression
operator|==
name|COMPRESSION_SGILOG24
condition|)
block|{
name|tif
operator|->
name|tif_encoderow
operator|=
name|LogLuvEncode24
expr_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|user_datafmt
condition|)
block|{
case|case
name|SGILOGDATAFMT_FLOAT
case|:
name|sp
operator|->
name|tfunc
operator|=
name|Luv24fromXYZ
expr_stmt|;
break|break;
case|case
name|SGILOGDATAFMT_16BIT
case|:
name|sp
operator|->
name|tfunc
operator|=
name|Luv24fromLuv48
expr_stmt|;
break|break;
case|case
name|SGILOGDATAFMT_RAW
case|:
break|break;
default|default:
goto|goto
name|notsupported
goto|;
block|}
block|}
else|else
block|{
name|tif
operator|->
name|tif_encoderow
operator|=
name|LogLuvEncode32
expr_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|user_datafmt
condition|)
block|{
case|case
name|SGILOGDATAFMT_FLOAT
case|:
name|sp
operator|->
name|tfunc
operator|=
name|Luv32fromXYZ
expr_stmt|;
break|break;
case|case
name|SGILOGDATAFMT_16BIT
case|:
name|sp
operator|->
name|tfunc
operator|=
name|Luv32fromLuv48
expr_stmt|;
break|break;
case|case
name|SGILOGDATAFMT_RAW
case|:
break|break;
default|default:
goto|goto
name|notsupported
goto|;
block|}
block|}
break|break;
case|case
name|PHOTOMETRIC_LOGL
case|:
if|if
condition|(
operator|!
name|LogL16InitState
argument_list|(
name|tif
argument_list|)
condition|)
break|break;
name|tif
operator|->
name|tif_encoderow
operator|=
name|LogL16Encode
expr_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|user_datafmt
condition|)
block|{
case|case
name|SGILOGDATAFMT_FLOAT
case|:
name|sp
operator|->
name|tfunc
operator|=
name|L16fromY
expr_stmt|;
break|break;
case|case
name|SGILOGDATAFMT_16BIT
case|:
break|break;
default|default:
goto|goto
name|notsupported
goto|;
block|}
break|break;
default|default:
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"Inappropriate photometric interpretation %d for SGILog compression; %s"
argument_list|,
name|td
operator|->
name|td_photometric
argument_list|,
literal|"must be either LogLUV or LogL"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|1
operator|)
return|;
name|notsupported
label|:
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"SGILog compression supported only for %s, or raw data"
argument_list|,
name|td
operator|->
name|td_photometric
operator|==
name|PHOTOMETRIC_LOGL
condition|?
literal|"Y, L"
else|:
literal|"XYZ, Luv"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|LogLuvClose
name|LogLuvClose
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
comment|/* 	 * For consistency, we always want to write out the same 	 * bitspersample and sampleformat for our TIFF file, 	 * regardless of the data format being used by the application. 	 * Since this routine is called after tags have been set but 	 * before they have been recorded in the file, we reset them here. 	 */
name|td
operator|->
name|td_samplesperpixel
operator|=
operator|(
name|td
operator|->
name|td_photometric
operator|==
name|PHOTOMETRIC_LOGL
operator|)
condition|?
literal|1
else|:
literal|3
expr_stmt|;
name|td
operator|->
name|td_bitspersample
operator|=
literal|16
expr_stmt|;
name|td
operator|->
name|td_sampleformat
operator|=
name|SAMPLEFORMAT_INT
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|LogLuvCleanup
name|LogLuvCleanup
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|LogLuvState
modifier|*
name|sp
init|=
operator|(
name|LogLuvState
operator|*
operator|)
name|tif
operator|->
name|tif_data
decl_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|tif
operator|->
name|tif_tagmethods
operator|.
name|vgetfield
operator|=
name|sp
operator|->
name|vgetparent
expr_stmt|;
name|tif
operator|->
name|tif_tagmethods
operator|.
name|vsetfield
operator|=
name|sp
operator|->
name|vsetparent
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|tbuf
condition|)
name|_TIFFfree
argument_list|(
name|sp
operator|->
name|tbuf
argument_list|)
expr_stmt|;
name|_TIFFfree
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|tif
operator|->
name|tif_data
operator|=
name|NULL
expr_stmt|;
name|_TIFFSetDefaultCompressionState
argument_list|(
name|tif
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|LogLuvVSetField
name|LogLuvVSetField
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|ttag_t
name|tag
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|LogLuvState
modifier|*
name|sp
init|=
name|DecoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|int
name|bps
decl_stmt|,
name|fmt
decl_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|TIFFTAG_SGILOGDATAFMT
case|:
name|sp
operator|->
name|user_datafmt
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
comment|/* 		 * Tweak the TIFF header so that the rest of libtiff knows what 		 * size of data will be passed between app and library, and 		 * assume that the app knows what it is doing and is not 		 * confused by these header manipulations... 		 */
switch|switch
condition|(
name|sp
operator|->
name|user_datafmt
condition|)
block|{
case|case
name|SGILOGDATAFMT_FLOAT
case|:
name|bps
operator|=
literal|32
operator|,
name|fmt
operator|=
name|SAMPLEFORMAT_IEEEFP
expr_stmt|;
break|break;
case|case
name|SGILOGDATAFMT_16BIT
case|:
name|bps
operator|=
literal|16
operator|,
name|fmt
operator|=
name|SAMPLEFORMAT_INT
expr_stmt|;
break|break;
case|case
name|SGILOGDATAFMT_RAW
case|:
name|bps
operator|=
literal|32
operator|,
name|fmt
operator|=
name|SAMPLEFORMAT_UINT
expr_stmt|;
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_SAMPLESPERPIXEL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SGILOGDATAFMT_8BIT
case|:
name|bps
operator|=
literal|8
operator|,
name|fmt
operator|=
name|SAMPLEFORMAT_UINT
expr_stmt|;
break|break;
default|default:
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"Unknown data format %d for LogLuv compression"
argument_list|,
name|sp
operator|->
name|user_datafmt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_BITSPERSAMPLE
argument_list|,
name|bps
argument_list|)
expr_stmt|;
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_SAMPLEFORMAT
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
comment|/* 		 * Must recalculate sizes should bits/sample change. 		 */
name|tif
operator|->
name|tif_tilesize
operator|=
name|isTiled
argument_list|(
name|tif
argument_list|)
condition|?
name|TIFFTileSize
argument_list|(
name|tif
argument_list|)
else|:
operator|(
name|tsize_t
operator|)
operator|-
literal|1
expr_stmt|;
name|tif
operator|->
name|tif_scanlinesize
operator|=
name|TIFFScanlineSize
argument_list|(
name|tif
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|TIFFTAG_SGILOGENCODE
case|:
name|sp
operator|->
name|encode_meth
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|encode_meth
operator|!=
name|SGILOGENCODE_NODITHER
operator|&&
name|sp
operator|->
name|encode_meth
operator|!=
name|SGILOGENCODE_RANDITHER
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"Unknown encoding %d for LogLuv compression"
argument_list|,
name|sp
operator|->
name|encode_meth
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
default|default:
return|return
call|(
modifier|*
name|sp
operator|->
name|vsetparent
call|)
argument_list|(
name|tif
argument_list|,
name|tag
argument_list|,
name|ap
argument_list|)
return|;
block|}
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|LogLuvVGetField
name|LogLuvVGetField
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|ttag_t
name|tag
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|LogLuvState
modifier|*
name|sp
init|=
operator|(
name|LogLuvState
operator|*
operator|)
name|tif
operator|->
name|tif_data
decl_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|TIFFTAG_SGILOGDATAFMT
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
operator|*
argument_list|)
operator|=
name|sp
operator|->
name|user_datafmt
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
default|default:
return|return
call|(
modifier|*
name|sp
operator|->
name|vgetparent
call|)
argument_list|(
name|tif
argument_list|,
name|tag
argument_list|,
name|ap
argument_list|)
return|;
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|LogLuvFieldInfo
specifier|static
specifier|const
name|TIFFFieldInfo
name|LogLuvFieldInfo
index|[]
init|=
block|{
block|{
name|TIFFTAG_SGILOGDATAFMT
block|,
literal|0
block|,
literal|0
block|,
name|TIFF_SHORT
block|,
name|FIELD_PSEUDO
block|,
name|TRUE
block|,
name|FALSE
block|,
literal|"SGILogDataFmt"
block|}
block|,
block|{
name|TIFFTAG_SGILOGENCODE
block|,
literal|0
block|,
literal|0
block|,
name|TIFF_SHORT
block|,
name|FIELD_PSEUDO
block|,
name|TRUE
block|,
name|FALSE
block|,
literal|"SGILogEncode"
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_function
name|int
DECL|function|TIFFInitSGILog
name|TIFFInitSGILog
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|int
name|scheme
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|"TIFFInitSGILog"
decl_stmt|;
name|LogLuvState
modifier|*
name|sp
decl_stmt|;
name|assert
argument_list|(
name|scheme
operator|==
name|COMPRESSION_SGILOG24
operator|||
name|scheme
operator|==
name|COMPRESSION_SGILOG
argument_list|)
expr_stmt|;
comment|/* 	 * Merge codec-specific tag information. 	 */
if|if
condition|(
operator|!
name|_TIFFMergeFieldInfo
argument_list|(
name|tif
argument_list|,
name|LogLuvFieldInfo
argument_list|,
name|TIFFArrayCount
argument_list|(
name|LogLuvFieldInfo
argument_list|)
argument_list|)
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"Merging SGILog codec-specific tags failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Allocate state block so tag methods have storage to record values. 	 */
name|tif
operator|->
name|tif_data
operator|=
operator|(
name|tidata_t
operator|)
name|_TIFFmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|LogLuvState
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tif
operator|->
name|tif_data
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|sp
operator|=
operator|(
name|LogLuvState
operator|*
operator|)
name|tif
operator|->
name|tif_data
expr_stmt|;
name|_TIFFmemset
argument_list|(
operator|(
name|tdata_t
operator|)
name|sp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|user_datafmt
operator|=
name|SGILOGDATAFMT_UNKNOWN
expr_stmt|;
name|sp
operator|->
name|encode_meth
operator|=
operator|(
name|scheme
operator|==
name|COMPRESSION_SGILOG24
operator|)
condition|?
name|SGILOGENCODE_RANDITHER
else|:
name|SGILOGENCODE_NODITHER
expr_stmt|;
name|sp
operator|->
name|tfunc
operator|=
name|_logLuvNop
expr_stmt|;
comment|/* 	 * Install codec methods. 	 * NB: tif_decoderow& tif_encoderow are filled 	 *     in at setup time. 	 */
name|tif
operator|->
name|tif_setupdecode
operator|=
name|LogLuvSetupDecode
expr_stmt|;
name|tif
operator|->
name|tif_decodestrip
operator|=
name|LogLuvDecodeStrip
expr_stmt|;
name|tif
operator|->
name|tif_decodetile
operator|=
name|LogLuvDecodeTile
expr_stmt|;
name|tif
operator|->
name|tif_setupencode
operator|=
name|LogLuvSetupEncode
expr_stmt|;
name|tif
operator|->
name|tif_encodestrip
operator|=
name|LogLuvEncodeStrip
expr_stmt|;
name|tif
operator|->
name|tif_encodetile
operator|=
name|LogLuvEncodeTile
expr_stmt|;
name|tif
operator|->
name|tif_close
operator|=
name|LogLuvClose
expr_stmt|;
name|tif
operator|->
name|tif_cleanup
operator|=
name|LogLuvCleanup
expr_stmt|;
comment|/*  	 * Override parent get/set field methods. 	 */
name|sp
operator|->
name|vgetparent
operator|=
name|tif
operator|->
name|tif_tagmethods
operator|.
name|vgetfield
expr_stmt|;
name|tif
operator|->
name|tif_tagmethods
operator|.
name|vgetfield
operator|=
name|LogLuvVGetField
expr_stmt|;
comment|/* hook for codec tags */
name|sp
operator|->
name|vsetparent
operator|=
name|tif
operator|->
name|tif_tagmethods
operator|.
name|vsetfield
expr_stmt|;
name|tif
operator|->
name|tif_tagmethods
operator|.
name|vsetfield
operator|=
name|LogLuvVSetField
expr_stmt|;
comment|/* hook for codec tags */
return|return
operator|(
literal|1
operator|)
return|;
name|bad
label|:
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: No space for LogLuv state block"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* LOGLUV_SUPPORT */
end_comment
begin_comment
comment|/* vim: set ts=8 sts=8 sw=8 noet: */
end_comment
end_unit
