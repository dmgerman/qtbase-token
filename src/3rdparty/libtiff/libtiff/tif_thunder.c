begin_unit
begin_comment
comment|/* $Id: tif_thunder.c,v 1.5 2005/12/21 12:23:13 joris Exp $ */
end_comment
begin_comment
comment|/*  * Copyright (c) 1988-1997 Sam Leffler  * Copyright (c) 1991-1997 Silicon Graphics, Inc.  *  * Permission to use, copy, modify, distribute, and sell this software and   * its documentation for any purpose is hereby granted without fee, provided  * that (i) the above copyright notices and this permission notice appear in  * all copies of the software and related documentation, and (ii) the names of  * Sam Leffler and Silicon Graphics may not be used in any advertising or  * publicity relating to the software without the specific, prior written  * permission of Sam Leffler and Silicon Graphics.  *   * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,   * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY   * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.    *   * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR  * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,  * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF   * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE   * OF THIS SOFTWARE.  */
end_comment
begin_include
include|#
directive|include
file|"tiffiop.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|THUNDER_SUPPORT
end_ifdef
begin_comment
comment|/*  * TIFF Library.  *  * ThunderScan 4-bit Compression Algorithm Support  */
end_comment
begin_comment
comment|/*  * ThunderScan uses an encoding scheme designed for  * 4-bit pixel values.  Data is encoded in bytes, with  * each byte split into a 2-bit code word and a 6-bit  * data value.  The encoding gives raw data, runs of  * pixels, or pixel values encoded as a delta from the  * previous pixel value.  For the latter, either 2-bit  * or 3-bit delta values are used, with the deltas packed  * into a single byte.  */
end_comment
begin_define
DECL|macro|THUNDER_DATA
define|#
directive|define
name|THUNDER_DATA
value|0x3f
end_define
begin_comment
DECL|macro|THUNDER_DATA
comment|/* mask for 6-bit data */
end_comment
begin_define
DECL|macro|THUNDER_CODE
define|#
directive|define
name|THUNDER_CODE
value|0xc0
end_define
begin_comment
DECL|macro|THUNDER_CODE
comment|/* mask for 2-bit code word */
end_comment
begin_comment
comment|/* code values */
end_comment
begin_define
DECL|macro|THUNDER_RUN
define|#
directive|define
name|THUNDER_RUN
value|0x00
end_define
begin_comment
DECL|macro|THUNDER_RUN
comment|/* run of pixels w/ encoded count */
end_comment
begin_define
DECL|macro|THUNDER_2BITDELTAS
define|#
directive|define
name|THUNDER_2BITDELTAS
value|0x40
end_define
begin_comment
DECL|macro|THUNDER_2BITDELTAS
comment|/* 3 pixels w/ encoded 2-bit deltas */
end_comment
begin_define
DECL|macro|DELTA2_SKIP
define|#
directive|define
name|DELTA2_SKIP
value|2
end_define
begin_comment
DECL|macro|DELTA2_SKIP
comment|/* skip code for 2-bit deltas */
end_comment
begin_define
DECL|macro|THUNDER_3BITDELTAS
define|#
directive|define
name|THUNDER_3BITDELTAS
value|0x80
end_define
begin_comment
DECL|macro|THUNDER_3BITDELTAS
comment|/* 2 pixels w/ encoded 3-bit deltas */
end_comment
begin_define
DECL|macro|DELTA3_SKIP
define|#
directive|define
name|DELTA3_SKIP
value|4
end_define
begin_comment
DECL|macro|DELTA3_SKIP
comment|/* skip code for 3-bit deltas */
end_comment
begin_define
DECL|macro|THUNDER_RAW
define|#
directive|define
name|THUNDER_RAW
value|0xc0
end_define
begin_comment
DECL|macro|THUNDER_RAW
comment|/* raw data encoded */
end_comment
begin_decl_stmt
DECL|variable|twobitdeltas
specifier|static
specifier|const
name|int
name|twobitdeltas
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|threebitdeltas
specifier|static
specifier|const
name|int
name|threebitdeltas
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|0
block|,
operator|-
literal|3
block|,
operator|-
literal|2
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|SETPIXEL
define|#
directive|define
name|SETPIXEL
parameter_list|(
name|op
parameter_list|,
name|v
parameter_list|)
value|{ \ 	lastpixel = (v)& 0xf; \ 	if (npixels++& 1) \ 	    *op++ |= lastpixel; \ 	else \ 	    op[0] = (tidataval_t) (lastpixel<< 4); \ }
end_define
begin_function
specifier|static
name|int
DECL|function|ThunderDecode
name|ThunderDecode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|op
parameter_list|,
name|tsize_t
name|maxpixels
parameter_list|)
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|bp
decl_stmt|;
specifier|register
name|tsize_t
name|cc
decl_stmt|;
name|unsigned
name|int
name|lastpixel
decl_stmt|;
name|tsize_t
name|npixels
decl_stmt|;
name|bp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tif
operator|->
name|tif_rawcp
expr_stmt|;
name|cc
operator|=
name|tif
operator|->
name|tif_rawcc
expr_stmt|;
name|lastpixel
operator|=
literal|0
expr_stmt|;
name|npixels
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cc
operator|>
literal|0
operator|&&
name|npixels
operator|<
name|maxpixels
condition|)
block|{
name|int
name|n
decl_stmt|,
name|delta
decl_stmt|;
name|n
operator|=
operator|*
name|bp
operator|++
operator|,
name|cc
operator|--
expr_stmt|;
switch|switch
condition|(
name|n
operator|&
name|THUNDER_CODE
condition|)
block|{
case|case
name|THUNDER_RUN
case|:
comment|/* pixel run */
comment|/* 			 * Replicate the last pixel n times, 			 * where n is the lower-order 6 bits. 			 */
if|if
condition|(
name|npixels
operator|&
literal|1
condition|)
block|{
name|op
index|[
literal|0
index|]
operator||=
name|lastpixel
expr_stmt|;
name|lastpixel
operator|=
operator|*
name|op
operator|++
expr_stmt|;
name|npixels
operator|++
expr_stmt|;
name|n
operator|--
expr_stmt|;
block|}
else|else
name|lastpixel
operator||=
name|lastpixel
operator|<<
literal|4
expr_stmt|;
name|npixels
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|npixels
operator|<
name|maxpixels
condition|)
block|{
for|for
control|(
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|-=
literal|2
control|)
operator|*
name|op
operator|++
operator|=
operator|(
name|tidataval_t
operator|)
name|lastpixel
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
operator|*
operator|--
name|op
operator|&=
literal|0xf0
expr_stmt|;
name|lastpixel
operator|&=
literal|0xf
expr_stmt|;
break|break;
case|case
name|THUNDER_2BITDELTAS
case|:
comment|/* 2-bit deltas */
if|if
condition|(
operator|(
name|delta
operator|=
operator|(
operator|(
name|n
operator|>>
literal|4
operator|)
operator|&
literal|3
operator|)
operator|)
operator|!=
name|DELTA2_SKIP
condition|)
name|SETPIXEL
argument_list|(
name|op
argument_list|,
name|lastpixel
operator|+
name|twobitdeltas
index|[
name|delta
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|delta
operator|=
operator|(
operator|(
name|n
operator|>>
literal|2
operator|)
operator|&
literal|3
operator|)
operator|)
operator|!=
name|DELTA2_SKIP
condition|)
name|SETPIXEL
argument_list|(
name|op
argument_list|,
name|lastpixel
operator|+
name|twobitdeltas
index|[
name|delta
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|delta
operator|=
operator|(
name|n
operator|&
literal|3
operator|)
operator|)
operator|!=
name|DELTA2_SKIP
condition|)
name|SETPIXEL
argument_list|(
name|op
argument_list|,
name|lastpixel
operator|+
name|twobitdeltas
index|[
name|delta
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|THUNDER_3BITDELTAS
case|:
comment|/* 3-bit deltas */
if|if
condition|(
operator|(
name|delta
operator|=
operator|(
operator|(
name|n
operator|>>
literal|3
operator|)
operator|&
literal|7
operator|)
operator|)
operator|!=
name|DELTA3_SKIP
condition|)
name|SETPIXEL
argument_list|(
name|op
argument_list|,
name|lastpixel
operator|+
name|threebitdeltas
index|[
name|delta
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|delta
operator|=
operator|(
name|n
operator|&
literal|7
operator|)
operator|)
operator|!=
name|DELTA3_SKIP
condition|)
name|SETPIXEL
argument_list|(
name|op
argument_list|,
name|lastpixel
operator|+
name|threebitdeltas
index|[
name|delta
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|THUNDER_RAW
case|:
comment|/* raw data */
name|SETPIXEL
argument_list|(
name|op
argument_list|,
name|n
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|tif
operator|->
name|tif_rawcp
operator|=
operator|(
name|tidata_t
operator|)
name|bp
expr_stmt|;
name|tif
operator|->
name|tif_rawcc
operator|=
name|cc
expr_stmt|;
if|if
condition|(
name|npixels
operator|!=
name|maxpixels
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"ThunderDecode: %s data at scanline %ld (%lu != %lu)"
argument_list|,
name|npixels
operator|<
name|maxpixels
condition|?
literal|"Not enough"
else|:
literal|"Too much"
argument_list|,
operator|(
name|long
operator|)
name|tif
operator|->
name|tif_row
argument_list|,
operator|(
name|long
operator|)
name|npixels
argument_list|,
operator|(
name|long
operator|)
name|maxpixels
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|ThunderDecodeRow
name|ThunderDecodeRow
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|buf
parameter_list|,
name|tsize_t
name|occ
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|tidata_t
name|row
init|=
name|buf
decl_stmt|;
operator|(
name|void
operator|)
name|s
expr_stmt|;
while|while
condition|(
operator|(
name|long
operator|)
name|occ
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ThunderDecode
argument_list|(
name|tif
argument_list|,
name|row
argument_list|,
name|tif
operator|->
name|tif_dir
operator|.
name|td_imagewidth
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|occ
operator|-=
name|tif
operator|->
name|tif_scanlinesize
expr_stmt|;
name|row
operator|+=
name|tif
operator|->
name|tif_scanlinesize
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_function
name|int
DECL|function|TIFFInitThunderScan
name|TIFFInitThunderScan
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|int
name|scheme
parameter_list|)
block|{
operator|(
name|void
operator|)
name|scheme
expr_stmt|;
name|tif
operator|->
name|tif_decoderow
operator|=
name|ThunderDecodeRow
expr_stmt|;
name|tif
operator|->
name|tif_decodestrip
operator|=
name|ThunderDecodeRow
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* THUNDER_SUPPORT */
end_comment
begin_comment
comment|/* vim: set ts=8 sts=8 sw=8 noet: */
end_comment
end_unit
