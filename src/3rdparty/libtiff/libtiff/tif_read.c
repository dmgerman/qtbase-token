begin_unit
begin_comment
comment|/* $Id: tif_read.c,v 1.16 2007/02/22 11:33:44 dron Exp $ */
end_comment
begin_comment
comment|/*  * Copyright (c) 1988-1997 Sam Leffler  * Copyright (c) 1991-1997 Silicon Graphics, Inc.  *  * Permission to use, copy, modify, distribute, and sell this software and   * its documentation for any purpose is hereby granted without fee, provided  * that (i) the above copyright notices and this permission notice appear in  * all copies of the software and related documentation, and (ii) the names of  * Sam Leffler and Silicon Graphics may not be used in any advertising or  * publicity relating to the software without the specific, prior written  * permission of Sam Leffler and Silicon Graphics.  *   * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,   * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY   * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.    *   * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR  * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,  * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF   * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE   * OF THIS SOFTWARE.  */
end_comment
begin_comment
comment|/*  * TIFF Library.  * Scanline-oriented Read Support  */
end_comment
begin_include
include|#
directive|include
file|"tiffiop.h"
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_function_decl
name|int
name|TIFFFillStrip
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|tstrip_t
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|int
name|TIFFFillTile
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|ttile_t
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|TIFFStartStrip
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|tstrip_t
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|TIFFStartTile
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|ttile_t
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|TIFFCheckRead
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl
begin_define
DECL|macro|NOSTRIP
define|#
directive|define
name|NOSTRIP
value|((tstrip_t) -1)
end_define
begin_comment
DECL|macro|NOSTRIP
comment|/* undefined state */
end_comment
begin_define
DECL|macro|NOTILE
define|#
directive|define
name|NOTILE
value|((ttile_t) -1)
end_define
begin_comment
DECL|macro|NOTILE
comment|/* undefined state */
end_comment
begin_comment
comment|/*  * Seek to a random row+sample in a file.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|TIFFSeek
name|TIFFSeek
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|uint32
name|row
parameter_list|,
name|tsample_t
name|sample
parameter_list|)
block|{
specifier|register
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|tstrip_t
name|strip
decl_stmt|;
if|if
condition|(
name|row
operator|>=
name|td
operator|->
name|td_imagelength
condition|)
block|{
comment|/* out of range */
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"%lu: Row out of range, max %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|row
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|td
operator|->
name|td_imagelength
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|td
operator|->
name|td_planarconfig
operator|==
name|PLANARCONFIG_SEPARATE
condition|)
block|{
if|if
condition|(
name|sample
operator|>=
name|td
operator|->
name|td_samplesperpixel
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"%lu: Sample out of range, max %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sample
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|td
operator|->
name|td_samplesperpixel
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|strip
operator|=
name|sample
operator|*
name|td
operator|->
name|td_stripsperimage
operator|+
name|row
operator|/
name|td
operator|->
name|td_rowsperstrip
expr_stmt|;
block|}
else|else
name|strip
operator|=
name|row
operator|/
name|td
operator|->
name|td_rowsperstrip
expr_stmt|;
if|if
condition|(
name|strip
operator|!=
name|tif
operator|->
name|tif_curstrip
condition|)
block|{
comment|/* different strip, refill */
if|if
condition|(
operator|!
name|TIFFFillStrip
argument_list|(
name|tif
argument_list|,
name|strip
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|row
operator|<
name|tif
operator|->
name|tif_row
condition|)
block|{
comment|/* 		 * Moving backwards within the same strip: backup 		 * to the start and then decode forward (below). 		 * 		 * NB: If you're planning on lots of random access within a 		 * strip, it's better to just read and decode the entire 		 * strip, and then access the decoded data in a random fashion. 		 */
if|if
condition|(
operator|!
name|TIFFStartStrip
argument_list|(
name|tif
argument_list|,
name|strip
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|row
operator|!=
name|tif
operator|->
name|tif_row
condition|)
block|{
comment|/* 		 * Seek forward to the desired row. 		 */
if|if
condition|(
operator|!
call|(
modifier|*
name|tif
operator|->
name|tif_seek
call|)
argument_list|(
name|tif
argument_list|,
name|row
operator|-
name|tif
operator|->
name|tif_row
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|tif
operator|->
name|tif_row
operator|=
name|row
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_function
name|int
DECL|function|TIFFReadScanline
name|TIFFReadScanline
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tdata_t
name|buf
parameter_list|,
name|uint32
name|row
parameter_list|,
name|tsample_t
name|sample
parameter_list|)
block|{
name|int
name|e
decl_stmt|;
if|if
condition|(
operator|!
name|TIFFCheckRead
argument_list|(
name|tif
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|e
operator|=
name|TIFFSeek
argument_list|(
name|tif
argument_list|,
name|row
argument_list|,
name|sample
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Decompress desired row into user buffer. 		 */
name|e
operator|=
call|(
modifier|*
name|tif
operator|->
name|tif_decoderow
call|)
argument_list|(
name|tif
argument_list|,
operator|(
name|tidata_t
operator|)
name|buf
argument_list|,
name|tif
operator|->
name|tif_scanlinesize
argument_list|,
name|sample
argument_list|)
expr_stmt|;
comment|/* we are now poised at the beginning of the next row */
name|tif
operator|->
name|tif_row
operator|=
name|row
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|e
condition|)
call|(
modifier|*
name|tif
operator|->
name|tif_postdecode
call|)
argument_list|(
name|tif
argument_list|,
operator|(
name|tidata_t
operator|)
name|buf
argument_list|,
name|tif
operator|->
name|tif_scanlinesize
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|e
operator|>
literal|0
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Read a strip of data and decompress the specified  * amount into the user-supplied buffer.  */
end_comment
begin_function
name|tsize_t
DECL|function|TIFFReadEncodedStrip
name|TIFFReadEncodedStrip
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tstrip_t
name|strip
parameter_list|,
name|tdata_t
name|buf
parameter_list|,
name|tsize_t
name|size
parameter_list|)
block|{
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|uint32
name|nrows
decl_stmt|;
name|tsize_t
name|stripsize
decl_stmt|;
name|tstrip_t
name|sep_strip
decl_stmt|,
name|strips_per_sep
decl_stmt|;
if|if
condition|(
operator|!
name|TIFFCheckRead
argument_list|(
name|tif
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|strip
operator|>=
name|td
operator|->
name|td_nstrips
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"%ld: Strip out of range, max %ld"
argument_list|,
operator|(
name|long
operator|)
name|strip
argument_list|,
operator|(
name|long
operator|)
name|td
operator|->
name|td_nstrips
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Calculate the strip size according to the number of 	 * rows in the strip (check for truncated last strip on any 	 * of the separations). 	 */
if|if
condition|(
name|td
operator|->
name|td_rowsperstrip
operator|>=
name|td
operator|->
name|td_imagelength
condition|)
name|strips_per_sep
operator|=
literal|1
expr_stmt|;
else|else
name|strips_per_sep
operator|=
operator|(
name|td
operator|->
name|td_imagelength
operator|+
name|td
operator|->
name|td_rowsperstrip
operator|-
literal|1
operator|)
operator|/
name|td
operator|->
name|td_rowsperstrip
expr_stmt|;
name|sep_strip
operator|=
name|strip
operator|%
name|strips_per_sep
expr_stmt|;
if|if
condition|(
name|sep_strip
operator|!=
name|strips_per_sep
operator|-
literal|1
operator|||
operator|(
name|nrows
operator|=
name|td
operator|->
name|td_imagelength
operator|%
name|td
operator|->
name|td_rowsperstrip
operator|)
operator|==
literal|0
condition|)
name|nrows
operator|=
name|td
operator|->
name|td_rowsperstrip
expr_stmt|;
name|stripsize
operator|=
name|TIFFVStripSize
argument_list|(
name|tif
argument_list|,
name|nrows
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
operator|(
name|tsize_t
operator|)
operator|-
literal|1
condition|)
name|size
operator|=
name|stripsize
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|>
name|stripsize
condition|)
name|size
operator|=
name|stripsize
expr_stmt|;
if|if
condition|(
name|TIFFFillStrip
argument_list|(
name|tif
argument_list|,
name|strip
argument_list|)
operator|&&
call|(
modifier|*
name|tif
operator|->
name|tif_decodestrip
call|)
argument_list|(
name|tif
argument_list|,
operator|(
name|tidata_t
operator|)
name|buf
argument_list|,
name|size
argument_list|,
call|(
name|tsample_t
call|)
argument_list|(
name|strip
operator|/
name|td
operator|->
name|td_stripsperimage
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
block|{
call|(
modifier|*
name|tif
operator|->
name|tif_postdecode
call|)
argument_list|(
name|tif
argument_list|,
operator|(
name|tidata_t
operator|)
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|size
operator|)
return|;
block|}
else|else
return|return
operator|(
operator|(
name|tsize_t
operator|)
operator|-
literal|1
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|tsize_t
DECL|function|TIFFReadRawStrip1
name|TIFFReadRawStrip1
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tstrip_t
name|strip
parameter_list|,
name|tdata_t
name|buf
parameter_list|,
name|tsize_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|module
parameter_list|)
block|{
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|assert
argument_list|(
operator|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_NOREADRAW
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isMapped
argument_list|(
name|tif
argument_list|)
condition|)
block|{
name|tsize_t
name|cc
decl_stmt|;
if|if
condition|(
operator|!
name|SeekOK
argument_list|(
name|tif
argument_list|,
name|td
operator|->
name|td_stripoffset
index|[
name|strip
index|]
argument_list|)
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Seek error at scanline %lu, strip %lu"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|tif
operator|->
name|tif_row
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|strip
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cc
operator|=
name|TIFFReadFile
argument_list|(
name|tif
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|!=
name|size
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Read error at scanline %lu; got %lu bytes, expected %lu"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|tif
operator|->
name|tif_row
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|cc
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|td
operator|->
name|td_stripoffset
index|[
name|strip
index|]
operator|+
name|size
operator|>
name|tif
operator|->
name|tif_size
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Read error at scanline %lu, strip %lu; got %lu bytes, expected %lu"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|tif
operator|->
name|tif_row
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|strip
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|tif
operator|->
name|tif_size
operator|-
name|td
operator|->
name|td_stripoffset
index|[
name|strip
index|]
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|_TIFFmemcpy
argument_list|(
name|buf
argument_list|,
name|tif
operator|->
name|tif_base
operator|+
name|td
operator|->
name|td_stripoffset
index|[
name|strip
index|]
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Read a strip of data from the file.  */
end_comment
begin_function
name|tsize_t
DECL|function|TIFFReadRawStrip
name|TIFFReadRawStrip
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tstrip_t
name|strip
parameter_list|,
name|tdata_t
name|buf
parameter_list|,
name|tsize_t
name|size
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|"TIFFReadRawStrip"
decl_stmt|;
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
comment|/* 	 * FIXME: butecount should have tsize_t type, but for now libtiff 	 * defines tsize_t as a signed 32-bit integer and we are losing 	 * ability to read arrays larger than 2^31 bytes. So we are using 	 * uint32 instead of tsize_t here. 	 */
name|uint32
name|bytecount
decl_stmt|;
if|if
condition|(
operator|!
name|TIFFCheckRead
argument_list|(
name|tif
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
operator|(
name|tsize_t
operator|)
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|strip
operator|>=
name|td
operator|->
name|td_nstrips
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"%lu: Strip out of range, max %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|strip
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|td
operator|->
name|td_nstrips
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|tsize_t
operator|)
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_NOREADRAW
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"Compression scheme does not support access to raw uncompressed data"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|tsize_t
operator|)
operator|-
literal|1
operator|)
return|;
block|}
name|bytecount
operator|=
name|td
operator|->
name|td_stripbytecount
index|[
name|strip
index|]
expr_stmt|;
if|if
condition|(
name|bytecount
operator|<=
literal|0
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"%lu: Invalid strip byte count, strip %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|bytecount
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|strip
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|tsize_t
operator|)
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|size
operator|!=
operator|(
name|tsize_t
operator|)
operator|-
literal|1
operator|&&
operator|(
name|uint32
operator|)
name|size
operator|<
name|bytecount
condition|)
name|bytecount
operator|=
name|size
expr_stmt|;
return|return
operator|(
name|TIFFReadRawStrip1
argument_list|(
name|tif
argument_list|,
name|strip
argument_list|,
name|buf
argument_list|,
name|bytecount
argument_list|,
name|module
argument_list|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Read the specified strip and setup for decoding. The data buffer is  * expanded, as necessary, to hold the strip's data.  */
end_comment
begin_function
name|int
DECL|function|TIFFFillStrip
name|TIFFFillStrip
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tstrip_t
name|strip
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|"TIFFFillStrip"
decl_stmt|;
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
if|if
condition|(
operator|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_NOREADRAW
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * FIXME: butecount should have tsize_t type, but for now 		 * libtiff defines tsize_t as a signed 32-bit integer and we 		 * are losing ability to read arrays larger than 2^31 bytes. 		 * So we are using uint32 instead of tsize_t here. 		 */
name|uint32
name|bytecount
init|=
name|td
operator|->
name|td_stripbytecount
index|[
name|strip
index|]
decl_stmt|;
if|if
condition|(
name|bytecount
operator|<=
literal|0
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Invalid strip byte count %lu, strip %lu"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|bytecount
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|strip
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|isMapped
argument_list|(
name|tif
argument_list|)
operator|&&
operator|(
name|isFillOrder
argument_list|(
name|tif
argument_list|,
name|td
operator|->
name|td_fillorder
argument_list|)
operator|||
operator|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_NOBITREV
operator|)
operator|)
condition|)
block|{
comment|/* 			 * The image is mapped into memory and we either don't 			 * need to flip bits or the compression routine is 			 * going to handle this operation itself.  In this 			 * case, avoid copying the raw data and instead just 			 * reference the data from the memory mapped file 			 * image.  This assumes that the decompression 			 * routines do not modify the contents of the raw data 			 * buffer (if they try to, the application will get a 			 * fault since the file is mapped read-only). 			 */
if|if
condition|(
operator|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_MYBUFFER
operator|)
operator|&&
name|tif
operator|->
name|tif_rawdata
condition|)
name|_TIFFfree
argument_list|(
name|tif
operator|->
name|tif_rawdata
argument_list|)
expr_stmt|;
name|tif
operator|->
name|tif_flags
operator|&=
operator|~
name|TIFF_MYBUFFER
expr_stmt|;
comment|/* 			 * We must check for overflow, potentially causing 			 * an OOB read. Instead of simple 			 * 			 *  td->td_stripoffset[strip]+bytecount> tif->tif_size 			 * 			 * comparison (which can overflow) we do the following 			 * two comparisons: 			 */
if|if
condition|(
name|bytecount
operator|>
name|tif
operator|->
name|tif_size
operator|||
name|td
operator|->
name|td_stripoffset
index|[
name|strip
index|]
operator|>
name|tif
operator|->
name|tif_size
operator|-
name|bytecount
condition|)
block|{
comment|/* 				 * This error message might seem strange, but 				 * it's what would happen if a read were done 				 * instead. 				 */
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Read error on strip %lu; "
literal|"got %lu bytes, expected %lu"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|strip
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|tif
operator|->
name|tif_size
operator|-
name|td
operator|->
name|td_stripoffset
index|[
name|strip
index|]
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|bytecount
argument_list|)
expr_stmt|;
name|tif
operator|->
name|tif_curstrip
operator|=
name|NOSTRIP
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|tif
operator|->
name|tif_rawdatasize
operator|=
name|bytecount
expr_stmt|;
name|tif
operator|->
name|tif_rawdata
operator|=
name|tif
operator|->
name|tif_base
operator|+
name|td
operator|->
name|td_stripoffset
index|[
name|strip
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Expand raw data buffer, if needed, to hold data 			 * strip coming from file (perhaps should set upper 			 * bound on the size of a buffer we'll use?). 			 */
if|if
condition|(
name|bytecount
operator|>
operator|(
name|uint32
operator|)
name|tif
operator|->
name|tif_rawdatasize
condition|)
block|{
name|tif
operator|->
name|tif_curstrip
operator|=
name|NOSTRIP
expr_stmt|;
if|if
condition|(
operator|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_MYBUFFER
operator|)
operator|==
literal|0
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Data buffer too small to hold strip %lu"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|strip
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|TIFFReadBufferSetup
argument_list|(
name|tif
argument_list|,
literal|0
argument_list|,
name|TIFFroundup
argument_list|(
name|bytecount
argument_list|,
literal|1024
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|uint32
operator|)
name|TIFFReadRawStrip1
argument_list|(
name|tif
argument_list|,
name|strip
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tif
operator|->
name|tif_rawdata
argument_list|,
name|bytecount
argument_list|,
name|module
argument_list|)
operator|!=
name|bytecount
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|isFillOrder
argument_list|(
name|tif
argument_list|,
name|td
operator|->
name|td_fillorder
argument_list|)
operator|&&
operator|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_NOBITREV
operator|)
operator|==
literal|0
condition|)
name|TIFFReverseBits
argument_list|(
name|tif
operator|->
name|tif_rawdata
argument_list|,
name|bytecount
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|TIFFStartStrip
argument_list|(
name|tif
argument_list|,
name|strip
argument_list|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Tile-oriented Read Support  * Contributed by Nancy Cam (Silicon Graphics).  */
end_comment
begin_comment
comment|/*  * Read and decompress a tile of data.  The  * tile is selected by the (x,y,z,s) coordinates.  */
end_comment
begin_function
name|tsize_t
DECL|function|TIFFReadTile
name|TIFFReadTile
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tdata_t
name|buf
parameter_list|,
name|uint32
name|x
parameter_list|,
name|uint32
name|y
parameter_list|,
name|uint32
name|z
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TIFFCheckRead
argument_list|(
name|tif
argument_list|,
literal|1
argument_list|)
operator|||
operator|!
name|TIFFCheckTile
argument_list|(
name|tif
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|,
name|s
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|TIFFReadEncodedTile
argument_list|(
name|tif
argument_list|,
name|TIFFComputeTile
argument_list|(
name|tif
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|,
name|s
argument_list|)
argument_list|,
name|buf
argument_list|,
operator|(
name|tsize_t
operator|)
operator|-
literal|1
argument_list|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Read a tile of data and decompress the specified  * amount into the user-supplied buffer.  */
end_comment
begin_function
name|tsize_t
DECL|function|TIFFReadEncodedTile
name|TIFFReadEncodedTile
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|ttile_t
name|tile
parameter_list|,
name|tdata_t
name|buf
parameter_list|,
name|tsize_t
name|size
parameter_list|)
block|{
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|tsize_t
name|tilesize
init|=
name|tif
operator|->
name|tif_tilesize
decl_stmt|;
if|if
condition|(
operator|!
name|TIFFCheckRead
argument_list|(
name|tif
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|tile
operator|>=
name|td
operator|->
name|td_nstrips
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"%ld: Tile out of range, max %ld"
argument_list|,
operator|(
name|long
operator|)
name|tile
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|td
operator|->
name|td_nstrips
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|size
operator|==
operator|(
name|tsize_t
operator|)
operator|-
literal|1
condition|)
name|size
operator|=
name|tilesize
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|>
name|tilesize
condition|)
name|size
operator|=
name|tilesize
expr_stmt|;
if|if
condition|(
name|TIFFFillTile
argument_list|(
name|tif
argument_list|,
name|tile
argument_list|)
operator|&&
call|(
modifier|*
name|tif
operator|->
name|tif_decodetile
call|)
argument_list|(
name|tif
argument_list|,
operator|(
name|tidata_t
operator|)
name|buf
argument_list|,
name|size
argument_list|,
call|(
name|tsample_t
call|)
argument_list|(
name|tile
operator|/
name|td
operator|->
name|td_stripsperimage
argument_list|)
argument_list|)
condition|)
block|{
call|(
modifier|*
name|tif
operator|->
name|tif_postdecode
call|)
argument_list|(
name|tif
argument_list|,
operator|(
name|tidata_t
operator|)
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|size
operator|)
return|;
block|}
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|tsize_t
DECL|function|TIFFReadRawTile1
name|TIFFReadRawTile1
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|ttile_t
name|tile
parameter_list|,
name|tdata_t
name|buf
parameter_list|,
name|tsize_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|module
parameter_list|)
block|{
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|assert
argument_list|(
operator|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_NOREADRAW
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isMapped
argument_list|(
name|tif
argument_list|)
condition|)
block|{
name|tsize_t
name|cc
decl_stmt|;
if|if
condition|(
operator|!
name|SeekOK
argument_list|(
name|tif
argument_list|,
name|td
operator|->
name|td_stripoffset
index|[
name|tile
index|]
argument_list|)
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Seek error at row %ld, col %ld, tile %ld"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
operator|(
name|long
operator|)
name|tif
operator|->
name|tif_row
argument_list|,
operator|(
name|long
operator|)
name|tif
operator|->
name|tif_col
argument_list|,
operator|(
name|long
operator|)
name|tile
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|tsize_t
operator|)
operator|-
literal|1
operator|)
return|;
block|}
name|cc
operator|=
name|TIFFReadFile
argument_list|(
name|tif
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|!=
name|size
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Read error at row %ld, col %ld; got %lu bytes, expected %lu"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
operator|(
name|long
operator|)
name|tif
operator|->
name|tif_row
argument_list|,
operator|(
name|long
operator|)
name|tif
operator|->
name|tif_col
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|cc
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|tsize_t
operator|)
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|td
operator|->
name|td_stripoffset
index|[
name|tile
index|]
operator|+
name|size
operator|>
name|tif
operator|->
name|tif_size
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Read error at row %ld, col %ld, tile %ld; got %lu bytes, expected %lu"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
operator|(
name|long
operator|)
name|tif
operator|->
name|tif_row
argument_list|,
operator|(
name|long
operator|)
name|tif
operator|->
name|tif_col
argument_list|,
operator|(
name|long
operator|)
name|tile
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|tif
operator|->
name|tif_size
operator|-
name|td
operator|->
name|td_stripoffset
index|[
name|tile
index|]
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|tsize_t
operator|)
operator|-
literal|1
operator|)
return|;
block|}
name|_TIFFmemcpy
argument_list|(
name|buf
argument_list|,
name|tif
operator|->
name|tif_base
operator|+
name|td
operator|->
name|td_stripoffset
index|[
name|tile
index|]
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Read a tile of data from the file.  */
end_comment
begin_function
name|tsize_t
DECL|function|TIFFReadRawTile
name|TIFFReadRawTile
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|ttile_t
name|tile
parameter_list|,
name|tdata_t
name|buf
parameter_list|,
name|tsize_t
name|size
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|"TIFFReadRawTile"
decl_stmt|;
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
comment|/* 	 * FIXME: butecount should have tsize_t type, but for now libtiff 	 * defines tsize_t as a signed 32-bit integer and we are losing 	 * ability to read arrays larger than 2^31 bytes. So we are using 	 * uint32 instead of tsize_t here. 	 */
name|uint32
name|bytecount
decl_stmt|;
if|if
condition|(
operator|!
name|TIFFCheckRead
argument_list|(
name|tif
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
operator|(
name|tsize_t
operator|)
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|tile
operator|>=
name|td
operator|->
name|td_nstrips
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"%lu: Tile out of range, max %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|tile
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|td
operator|->
name|td_nstrips
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|tsize_t
operator|)
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_NOREADRAW
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"Compression scheme does not support access to raw uncompressed data"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|tsize_t
operator|)
operator|-
literal|1
operator|)
return|;
block|}
name|bytecount
operator|=
name|td
operator|->
name|td_stripbytecount
index|[
name|tile
index|]
expr_stmt|;
if|if
condition|(
name|size
operator|!=
operator|(
name|tsize_t
operator|)
operator|-
literal|1
operator|&&
operator|(
name|uint32
operator|)
name|size
operator|<
name|bytecount
condition|)
name|bytecount
operator|=
name|size
expr_stmt|;
return|return
operator|(
name|TIFFReadRawTile1
argument_list|(
name|tif
argument_list|,
name|tile
argument_list|,
name|buf
argument_list|,
name|bytecount
argument_list|,
name|module
argument_list|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Read the specified tile and setup for decoding. The data buffer is  * expanded, as necessary, to hold the tile's data.  */
end_comment
begin_function
name|int
DECL|function|TIFFFillTile
name|TIFFFillTile
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|ttile_t
name|tile
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|"TIFFFillTile"
decl_stmt|;
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
if|if
condition|(
operator|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_NOREADRAW
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * FIXME: butecount should have tsize_t type, but for now 		 * libtiff defines tsize_t as a signed 32-bit integer and we 		 * are losing ability to read arrays larger than 2^31 bytes. 		 * So we are using uint32 instead of tsize_t here. 		 */
name|uint32
name|bytecount
init|=
name|td
operator|->
name|td_stripbytecount
index|[
name|tile
index|]
decl_stmt|;
if|if
condition|(
name|bytecount
operator|<=
literal|0
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"%lu: Invalid tile byte count, tile %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|bytecount
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|tile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|isMapped
argument_list|(
name|tif
argument_list|)
operator|&&
operator|(
name|isFillOrder
argument_list|(
name|tif
argument_list|,
name|td
operator|->
name|td_fillorder
argument_list|)
operator|||
operator|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_NOBITREV
operator|)
operator|)
condition|)
block|{
comment|/* 			 * The image is mapped into memory and we either don't 			 * need to flip bits or the compression routine is 			 * going to handle this operation itself.  In this 			 * case, avoid copying the raw data and instead just 			 * reference the data from the memory mapped file 			 * image.  This assumes that the decompression 			 * routines do not modify the contents of the raw data 			 * buffer (if they try to, the application will get a 			 * fault since the file is mapped read-only). 			 */
if|if
condition|(
operator|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_MYBUFFER
operator|)
operator|&&
name|tif
operator|->
name|tif_rawdata
condition|)
name|_TIFFfree
argument_list|(
name|tif
operator|->
name|tif_rawdata
argument_list|)
expr_stmt|;
name|tif
operator|->
name|tif_flags
operator|&=
operator|~
name|TIFF_MYBUFFER
expr_stmt|;
comment|/* 			 * We must check for overflow, potentially causing 			 * an OOB read. Instead of simple 			 * 			 *  td->td_stripoffset[tile]+bytecount> tif->tif_size 			 * 			 * comparison (which can overflow) we do the following 			 * two comparisons: 			 */
if|if
condition|(
name|bytecount
operator|>
name|tif
operator|->
name|tif_size
operator|||
name|td
operator|->
name|td_stripoffset
index|[
name|tile
index|]
operator|>
name|tif
operator|->
name|tif_size
operator|-
name|bytecount
condition|)
block|{
name|tif
operator|->
name|tif_curtile
operator|=
name|NOTILE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|tif
operator|->
name|tif_rawdatasize
operator|=
name|bytecount
expr_stmt|;
name|tif
operator|->
name|tif_rawdata
operator|=
name|tif
operator|->
name|tif_base
operator|+
name|td
operator|->
name|td_stripoffset
index|[
name|tile
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Expand raw data buffer, if needed, to hold data 			 * tile coming from file (perhaps should set upper 			 * bound on the size of a buffer we'll use?). 			 */
if|if
condition|(
name|bytecount
operator|>
operator|(
name|uint32
operator|)
name|tif
operator|->
name|tif_rawdatasize
condition|)
block|{
name|tif
operator|->
name|tif_curtile
operator|=
name|NOTILE
expr_stmt|;
if|if
condition|(
operator|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_MYBUFFER
operator|)
operator|==
literal|0
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Data buffer too small to hold tile %ld"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
operator|(
name|long
operator|)
name|tile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|TIFFReadBufferSetup
argument_list|(
name|tif
argument_list|,
literal|0
argument_list|,
name|TIFFroundup
argument_list|(
name|bytecount
argument_list|,
literal|1024
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|uint32
operator|)
name|TIFFReadRawTile1
argument_list|(
name|tif
argument_list|,
name|tile
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tif
operator|->
name|tif_rawdata
argument_list|,
name|bytecount
argument_list|,
name|module
argument_list|)
operator|!=
name|bytecount
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|isFillOrder
argument_list|(
name|tif
argument_list|,
name|td
operator|->
name|td_fillorder
argument_list|)
operator|&&
operator|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_NOBITREV
operator|)
operator|==
literal|0
condition|)
name|TIFFReverseBits
argument_list|(
name|tif
operator|->
name|tif_rawdata
argument_list|,
name|bytecount
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|TIFFStartTile
argument_list|(
name|tif
argument_list|,
name|tile
argument_list|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Setup the raw data buffer in preparation for  * reading a strip of raw data.  If the buffer  * is specified as zero, then a buffer of appropriate  * size is allocated by the library.  Otherwise,  * the client must guarantee that the buffer is  * large enough to hold any individual strip of  * raw data.  */
end_comment
begin_function
name|int
DECL|function|TIFFReadBufferSetup
name|TIFFReadBufferSetup
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tdata_t
name|bp
parameter_list|,
name|tsize_t
name|size
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|"TIFFReadBufferSetup"
decl_stmt|;
name|assert
argument_list|(
operator|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_NOREADRAW
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tif
operator|->
name|tif_rawdata
condition|)
block|{
if|if
condition|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_MYBUFFER
condition|)
name|_TIFFfree
argument_list|(
name|tif
operator|->
name|tif_rawdata
argument_list|)
expr_stmt|;
name|tif
operator|->
name|tif_rawdata
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|bp
condition|)
block|{
name|tif
operator|->
name|tif_rawdatasize
operator|=
name|size
expr_stmt|;
name|tif
operator|->
name|tif_rawdata
operator|=
operator|(
name|tidata_t
operator|)
name|bp
expr_stmt|;
name|tif
operator|->
name|tif_flags
operator|&=
operator|~
name|TIFF_MYBUFFER
expr_stmt|;
block|}
else|else
block|{
name|tif
operator|->
name|tif_rawdatasize
operator|=
name|TIFFroundup
argument_list|(
name|size
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|tif
operator|->
name|tif_rawdata
operator|=
operator|(
name|tidata_t
operator|)
name|_TIFFmalloc
argument_list|(
name|tif
operator|->
name|tif_rawdatasize
argument_list|)
expr_stmt|;
name|tif
operator|->
name|tif_flags
operator||=
name|TIFF_MYBUFFER
expr_stmt|;
block|}
if|if
condition|(
name|tif
operator|->
name|tif_rawdata
operator|==
name|NULL
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: No space for data buffer at scanline %ld"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
operator|(
name|long
operator|)
name|tif
operator|->
name|tif_row
argument_list|)
expr_stmt|;
name|tif
operator|->
name|tif_rawdatasize
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Set state to appear as if a  * strip has just been read in.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|TIFFStartStrip
name|TIFFStartStrip
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tstrip_t
name|strip
parameter_list|)
block|{
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
if|if
condition|(
operator|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_CODERSETUP
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|tif
operator|->
name|tif_setupdecode
call|)
argument_list|(
name|tif
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|tif
operator|->
name|tif_flags
operator||=
name|TIFF_CODERSETUP
expr_stmt|;
block|}
name|tif
operator|->
name|tif_curstrip
operator|=
name|strip
expr_stmt|;
name|tif
operator|->
name|tif_row
operator|=
operator|(
name|strip
operator|%
name|td
operator|->
name|td_stripsperimage
operator|)
operator|*
name|td
operator|->
name|td_rowsperstrip
expr_stmt|;
if|if
condition|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_NOREADRAW
condition|)
block|{
name|tif
operator|->
name|tif_rawcp
operator|=
name|NULL
expr_stmt|;
name|tif
operator|->
name|tif_rawcc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|tif
operator|->
name|tif_rawcp
operator|=
name|tif
operator|->
name|tif_rawdata
expr_stmt|;
name|tif
operator|->
name|tif_rawcc
operator|=
name|td
operator|->
name|td_stripbytecount
index|[
name|strip
index|]
expr_stmt|;
block|}
return|return
operator|(
call|(
modifier|*
name|tif
operator|->
name|tif_predecode
call|)
argument_list|(
name|tif
argument_list|,
call|(
name|tsample_t
call|)
argument_list|(
name|strip
operator|/
name|td
operator|->
name|td_stripsperimage
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Set state to appear as if a  * tile has just been read in.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|TIFFStartTile
name|TIFFStartTile
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|ttile_t
name|tile
parameter_list|)
block|{
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
if|if
condition|(
operator|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_CODERSETUP
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|tif
operator|->
name|tif_setupdecode
call|)
argument_list|(
name|tif
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|tif
operator|->
name|tif_flags
operator||=
name|TIFF_CODERSETUP
expr_stmt|;
block|}
name|tif
operator|->
name|tif_curtile
operator|=
name|tile
expr_stmt|;
name|tif
operator|->
name|tif_row
operator|=
operator|(
name|tile
operator|%
name|TIFFhowmany
argument_list|(
name|td
operator|->
name|td_imagewidth
argument_list|,
name|td
operator|->
name|td_tilewidth
argument_list|)
operator|)
operator|*
name|td
operator|->
name|td_tilelength
expr_stmt|;
name|tif
operator|->
name|tif_col
operator|=
operator|(
name|tile
operator|%
name|TIFFhowmany
argument_list|(
name|td
operator|->
name|td_imagelength
argument_list|,
name|td
operator|->
name|td_tilelength
argument_list|)
operator|)
operator|*
name|td
operator|->
name|td_tilewidth
expr_stmt|;
if|if
condition|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_NOREADRAW
condition|)
block|{
name|tif
operator|->
name|tif_rawcp
operator|=
name|NULL
expr_stmt|;
name|tif
operator|->
name|tif_rawcc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|tif
operator|->
name|tif_rawcp
operator|=
name|tif
operator|->
name|tif_rawdata
expr_stmt|;
name|tif
operator|->
name|tif_rawcc
operator|=
name|td
operator|->
name|td_stripbytecount
index|[
name|tile
index|]
expr_stmt|;
block|}
return|return
operator|(
call|(
modifier|*
name|tif
operator|->
name|tif_predecode
call|)
argument_list|(
name|tif
argument_list|,
call|(
name|tsample_t
call|)
argument_list|(
name|tile
operator|/
name|td
operator|->
name|td_stripsperimage
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|TIFFCheckRead
name|TIFFCheckRead
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|int
name|tiles
parameter_list|)
block|{
if|if
condition|(
name|tif
operator|->
name|tif_mode
operator|==
name|O_WRONLY
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"File not open for reading"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|tiles
operator|^
name|isTiled
argument_list|(
name|tif
argument_list|)
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
name|tiles
condition|?
literal|"Can not read tiles from a stripped image"
else|:
literal|"Can not read scanlines from a tiled image"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_function
name|void
DECL|function|_TIFFNoPostDecode
name|_TIFFNoPostDecode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|buf
parameter_list|,
name|tsize_t
name|cc
parameter_list|)
block|{
operator|(
name|void
operator|)
name|tif
expr_stmt|;
operator|(
name|void
operator|)
name|buf
expr_stmt|;
operator|(
name|void
operator|)
name|cc
expr_stmt|;
block|}
end_function
begin_function
name|void
DECL|function|_TIFFSwab16BitData
name|_TIFFSwab16BitData
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|buf
parameter_list|,
name|tsize_t
name|cc
parameter_list|)
block|{
operator|(
name|void
operator|)
name|tif
expr_stmt|;
name|assert
argument_list|(
operator|(
name|cc
operator|&
literal|1
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|TIFFSwabArrayOfShort
argument_list|(
operator|(
name|uint16
operator|*
operator|)
name|buf
argument_list|,
name|cc
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|void
DECL|function|_TIFFSwab24BitData
name|_TIFFSwab24BitData
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|buf
parameter_list|,
name|tsize_t
name|cc
parameter_list|)
block|{
operator|(
name|void
operator|)
name|tif
expr_stmt|;
name|assert
argument_list|(
operator|(
name|cc
operator|%
literal|3
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|TIFFSwabArrayOfTriples
argument_list|(
operator|(
name|uint8
operator|*
operator|)
name|buf
argument_list|,
name|cc
operator|/
literal|3
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|void
DECL|function|_TIFFSwab32BitData
name|_TIFFSwab32BitData
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|buf
parameter_list|,
name|tsize_t
name|cc
parameter_list|)
block|{
operator|(
name|void
operator|)
name|tif
expr_stmt|;
name|assert
argument_list|(
operator|(
name|cc
operator|&
literal|3
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|TIFFSwabArrayOfLong
argument_list|(
operator|(
name|uint32
operator|*
operator|)
name|buf
argument_list|,
name|cc
operator|/
literal|4
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|void
DECL|function|_TIFFSwab64BitData
name|_TIFFSwab64BitData
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|buf
parameter_list|,
name|tsize_t
name|cc
parameter_list|)
block|{
operator|(
name|void
operator|)
name|tif
expr_stmt|;
name|assert
argument_list|(
operator|(
name|cc
operator|&
literal|7
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|TIFFSwabArrayOfDouble
argument_list|(
operator|(
name|double
operator|*
operator|)
name|buf
argument_list|,
name|cc
operator|/
literal|8
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* vim: set ts=8 sts=8 sw=8 noet: */
end_comment
end_unit
