begin_unit
begin_comment
comment|/* $Id: tif_dirread.c,v 1.92.2.6 2009-10-29 20:04:32 bfriesen Exp $ */
end_comment
begin_comment
comment|/*  * Copyright (c) 1988-1997 Sam Leffler  * Copyright (c) 1991-1997 Silicon Graphics, Inc.  *  * Permission to use, copy, modify, distribute, and sell this software and   * its documentation for any purpose is hereby granted without fee, provided  * that (i) the above copyright notices and this permission notice appear in  * all copies of the software and related documentation, and (ii) the names of  * Sam Leffler and Silicon Graphics may not be used in any advertising or  * publicity relating to the software without the specific, prior written  * permission of Sam Leffler and Silicon Graphics.  *   * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,   * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY   * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.    *   * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR  * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,  * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF   * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE   * OF THIS SOFTWARE.  */
end_comment
begin_comment
comment|/*  * TIFF Library.  *  * Directory Read Support Routines.  */
end_comment
begin_include
include|#
directive|include
file|"tiffiop.h"
end_include
begin_define
DECL|macro|IGNORE
define|#
directive|define
name|IGNORE
value|0
end_define
begin_comment
DECL|macro|IGNORE
comment|/* tag placeholder used below */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_IEEEFP
end_ifdef
begin_define
DECL|macro|TIFFCvtIEEEFloatToNative
define|#
directive|define
name|TIFFCvtIEEEFloatToNative
parameter_list|(
name|tif
parameter_list|,
name|n
parameter_list|,
name|fp
parameter_list|)
end_define
begin_define
DECL|macro|TIFFCvtIEEEDoubleToNative
define|#
directive|define
name|TIFFCvtIEEEDoubleToNative
parameter_list|(
name|tif
parameter_list|,
name|n
parameter_list|,
name|dp
parameter_list|)
end_define
begin_else
else|#
directive|else
end_else
begin_function_decl
specifier|extern
name|void
name|TIFFCvtIEEEFloatToNative
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|uint32
parameter_list|,
name|float
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|extern
name|void
name|TIFFCvtIEEEDoubleToNative
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|uint32
parameter_list|,
name|double
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_function_decl
specifier|static
name|TIFFDirEntry
modifier|*
name|TIFFReadDirectoryFind
parameter_list|(
name|TIFFDirEntry
modifier|*
name|dir
parameter_list|,
name|uint16
name|dircount
parameter_list|,
name|uint16
name|tagid
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|EstimateStripByteCounts
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|TIFFDirEntry
modifier|*
parameter_list|,
name|uint16
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|MissingRequired
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|TIFFCheckDirOffset
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|toff_t
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|CheckDirCount
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|TIFFDirEntry
modifier|*
parameter_list|,
name|uint32
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|uint16
name|TIFFFetchDirectory
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|toff_t
parameter_list|,
name|TIFFDirEntry
modifier|*
modifier|*
parameter_list|,
name|toff_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|tsize_t
name|TIFFFetchData
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|TIFFDirEntry
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|tsize_t
name|TIFFFetchString
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|TIFFDirEntry
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|float
name|TIFFFetchRational
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|TIFFDirEntry
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|TIFFFetchNormalTag
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|TIFFDirEntry
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|TIFFFetchPerSampleShorts
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|TIFFDirEntry
modifier|*
parameter_list|,
name|uint16
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|TIFFFetchPerSampleLongs
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|TIFFDirEntry
modifier|*
parameter_list|,
name|uint32
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|TIFFFetchPerSampleAnys
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|TIFFDirEntry
modifier|*
parameter_list|,
name|double
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|TIFFFetchShortArray
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|TIFFDirEntry
modifier|*
parameter_list|,
name|uint16
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|TIFFFetchStripThing
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|TIFFDirEntry
modifier|*
parameter_list|,
name|long
parameter_list|,
name|uint32
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|TIFFFetchRefBlackWhite
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|TIFFDirEntry
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|TIFFFetchSubjectDistance
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|TIFFDirEntry
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|float
name|TIFFFetchFloat
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|TIFFDirEntry
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|TIFFFetchFloatArray
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|TIFFDirEntry
modifier|*
parameter_list|,
name|float
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|TIFFFetchDoubleArray
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|TIFFDirEntry
modifier|*
parameter_list|,
name|double
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|TIFFFetchAnyArray
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|TIFFDirEntry
modifier|*
parameter_list|,
name|double
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|TIFFFetchShortPair
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|TIFFDirEntry
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|ChopUpSingleUncompressedStrip
parameter_list|(
name|TIFF
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*  * Read the next TIFF directory from a file and convert it to the internal  * format. We read directories sequentially.  */
end_comment
begin_function
name|int
DECL|function|TIFFReadDirectory
name|TIFFReadDirectory
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|"TIFFReadDirectory"
decl_stmt|;
name|int
name|n
decl_stmt|;
name|TIFFDirectory
modifier|*
name|td
decl_stmt|;
name|TIFFDirEntry
modifier|*
name|dp
decl_stmt|,
modifier|*
name|dir
init|=
name|NULL
decl_stmt|;
name|uint16
name|iv
decl_stmt|;
name|uint32
name|v
decl_stmt|;
specifier|const
name|TIFFFieldInfo
modifier|*
name|fip
decl_stmt|;
name|size_t
name|fix
decl_stmt|;
name|uint16
name|dircount
decl_stmt|;
name|int
name|diroutoforderwarning
init|=
literal|0
decl_stmt|,
name|compressionknown
init|=
literal|0
decl_stmt|;
name|tif
operator|->
name|tif_diroff
operator|=
name|tif
operator|->
name|tif_nextdiroff
expr_stmt|;
comment|/* 	 * Check whether we have the last offset or bad offset (IFD looping). 	 */
if|if
condition|(
operator|!
name|TIFFCheckDirOffset
argument_list|(
name|tif
argument_list|,
name|tif
operator|->
name|tif_nextdiroff
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* 	 * Cleanup any previous compression state. 	 */
call|(
modifier|*
name|tif
operator|->
name|tif_cleanup
call|)
argument_list|(
name|tif
argument_list|)
expr_stmt|;
name|tif
operator|->
name|tif_curdir
operator|++
expr_stmt|;
name|dircount
operator|=
name|TIFFFetchDirectory
argument_list|(
name|tif
argument_list|,
name|tif
operator|->
name|tif_nextdiroff
argument_list|,
operator|&
name|dir
argument_list|,
operator|&
name|tif
operator|->
name|tif_nextdiroff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dircount
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Failed to read directory at offset %u"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
name|tif
operator|->
name|tif_nextdiroff
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|tif
operator|->
name|tif_flags
operator|&=
operator|~
name|TIFF_BEENWRITING
expr_stmt|;
comment|/* reset before new dir */
comment|/* 	 * Setup default value and then make a pass over 	 * the fields to check type and tag information, 	 * and to extract info required to size data 	 * structures.  A second pass is made afterwards 	 * to read in everthing not taken in the first pass. 	 */
name|td
operator|=
operator|&
name|tif
operator|->
name|tif_dir
expr_stmt|;
comment|/* free any old stuff and reinit */
name|TIFFFreeDirectory
argument_list|(
name|tif
argument_list|)
expr_stmt|;
name|TIFFDefaultDirectory
argument_list|(
name|tif
argument_list|)
expr_stmt|;
comment|/* 	 * Electronic Arts writes gray-scale TIFF files 	 * without a PlanarConfiguration directory entry. 	 * Thus we setup a default value here, even though 	 * the TIFF spec says there is no default value. 	 */
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_PLANARCONFIG
argument_list|,
name|PLANARCONFIG_CONTIG
argument_list|)
expr_stmt|;
comment|/* 	 * Sigh, we must make a separate pass through the 	 * directory for the following reason: 	 * 	 * We must process the Compression tag in the first pass 	 * in order to merge in codec-private tag definitions (otherwise 	 * we may get complaints about unknown tags).  However, the 	 * Compression tag may be dependent on the SamplesPerPixel 	 * tag value because older TIFF specs permited Compression 	 * to be written as a SamplesPerPixel-count tag entry. 	 * Thus if we don't first figure out the correct SamplesPerPixel 	 * tag value then we may end up ignoring the Compression tag 	 * value because it has an incorrect count value (if the 	 * true value of SamplesPerPixel is not 1). 	 * 	 * It sure would have been nice if Aldus had really thought 	 * this stuff through carefully. 	 */
for|for
control|(
name|dp
operator|=
name|dir
operator|,
name|n
operator|=
name|dircount
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|--
operator|,
name|dp
operator|++
control|)
block|{
if|if
condition|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_SWAB
condition|)
block|{
name|TIFFSwabArrayOfShort
argument_list|(
operator|&
name|dp
operator|->
name|tdir_tag
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|TIFFSwabArrayOfLong
argument_list|(
operator|&
name|dp
operator|->
name|tdir_count
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dp
operator|->
name|tdir_tag
operator|==
name|TIFFTAG_SAMPLESPERPIXEL
condition|)
block|{
if|if
condition|(
operator|!
name|TIFFFetchNormalTag
argument_list|(
name|tif
argument_list|,
name|dp
argument_list|)
condition|)
goto|goto
name|bad
goto|;
name|dp
operator|->
name|tdir_tag
operator|=
name|IGNORE
expr_stmt|;
block|}
block|}
comment|/* 	 * First real pass over the directory. 	 */
name|fix
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|dir
operator|,
name|n
operator|=
name|dircount
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|--
operator|,
name|dp
operator|++
control|)
block|{
if|if
condition|(
name|fix
operator|>=
name|tif
operator|->
name|tif_nfields
operator|||
name|dp
operator|->
name|tdir_tag
operator|==
name|IGNORE
condition|)
continue|continue;
comment|/* 		 * Silicon Beach (at least) writes unordered 		 * directory tags (violating the spec).  Handle 		 * it here, but be obnoxious (maybe they'll fix it?). 		 */
if|if
condition|(
name|dp
operator|->
name|tdir_tag
operator|<
name|tif
operator|->
name|tif_fieldinfo
index|[
name|fix
index|]
operator|->
name|field_tag
condition|)
block|{
if|if
condition|(
operator|!
name|diroutoforderwarning
condition|)
block|{
name|TIFFWarningExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: invalid TIFF directory; tags are not sorted in ascending order"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|)
expr_stmt|;
name|diroutoforderwarning
operator|=
literal|1
expr_stmt|;
block|}
name|fix
operator|=
literal|0
expr_stmt|;
comment|/* O(n^2) */
block|}
while|while
condition|(
name|fix
operator|<
name|tif
operator|->
name|tif_nfields
operator|&&
name|tif
operator|->
name|tif_fieldinfo
index|[
name|fix
index|]
operator|->
name|field_tag
operator|<
name|dp
operator|->
name|tdir_tag
condition|)
name|fix
operator|++
expr_stmt|;
if|if
condition|(
name|fix
operator|>=
name|tif
operator|->
name|tif_nfields
operator|||
name|tif
operator|->
name|tif_fieldinfo
index|[
name|fix
index|]
operator|->
name|field_tag
operator|!=
name|dp
operator|->
name|tdir_tag
condition|)
block|{
name|TIFFWarningExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: unknown field with tag %d (0x%x) encountered"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
name|dp
operator|->
name|tdir_tag
argument_list|,
name|dp
operator|->
name|tdir_tag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|_TIFFMergeFieldInfo
argument_list|(
name|tif
argument_list|,
name|_TIFFCreateAnonFieldInfo
argument_list|(
name|tif
argument_list|,
name|dp
operator|->
name|tdir_tag
argument_list|,
operator|(
name|TIFFDataType
operator|)
name|dp
operator|->
name|tdir_type
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|TIFFWarningExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"Registering anonymous field with tag %d (0x%x) failed"
argument_list|,
name|dp
operator|->
name|tdir_tag
argument_list|,
name|dp
operator|->
name|tdir_tag
argument_list|)
expr_stmt|;
goto|goto
name|ignore
goto|;
block|}
name|fix
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fix
operator|<
name|tif
operator|->
name|tif_nfields
operator|&&
name|tif
operator|->
name|tif_fieldinfo
index|[
name|fix
index|]
operator|->
name|field_tag
operator|<
name|dp
operator|->
name|tdir_tag
condition|)
name|fix
operator|++
expr_stmt|;
block|}
comment|/* 		 * Null out old tags that we ignore. 		 */
if|if
condition|(
name|tif
operator|->
name|tif_fieldinfo
index|[
name|fix
index|]
operator|->
name|field_bit
operator|==
name|FIELD_IGNORE
condition|)
block|{
name|ignore
label|:
name|dp
operator|->
name|tdir_tag
operator|=
name|IGNORE
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Check data type. 		 */
name|fip
operator|=
name|tif
operator|->
name|tif_fieldinfo
index|[
name|fix
index|]
expr_stmt|;
while|while
condition|(
name|dp
operator|->
name|tdir_type
operator|!=
operator|(
name|unsigned
name|short
operator|)
name|fip
operator|->
name|field_type
operator|&&
name|fix
operator|<
name|tif
operator|->
name|tif_nfields
condition|)
block|{
if|if
condition|(
name|fip
operator|->
name|field_type
operator|==
name|TIFF_ANY
condition|)
comment|/* wildcard */
break|break;
name|fip
operator|=
name|tif
operator|->
name|tif_fieldinfo
index|[
operator|++
name|fix
index|]
expr_stmt|;
if|if
condition|(
name|fix
operator|>=
name|tif
operator|->
name|tif_nfields
operator|||
name|fip
operator|->
name|field_tag
operator|!=
name|dp
operator|->
name|tdir_tag
condition|)
block|{
name|TIFFWarningExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: wrong data type %d for \"%s\"; tag ignored"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
name|dp
operator|->
name|tdir_type
argument_list|,
name|tif
operator|->
name|tif_fieldinfo
index|[
name|fix
operator|-
literal|1
index|]
operator|->
name|field_name
argument_list|)
expr_stmt|;
goto|goto
name|ignore
goto|;
block|}
block|}
comment|/* 		 * Check count if known in advance. 		 */
if|if
condition|(
name|fip
operator|->
name|field_readcount
operator|!=
name|TIFF_VARIABLE
operator|&&
name|fip
operator|->
name|field_readcount
operator|!=
name|TIFF_VARIABLE2
condition|)
block|{
name|uint32
name|expected
init|=
operator|(
name|fip
operator|->
name|field_readcount
operator|==
name|TIFF_SPP
operator|)
condition|?
operator|(
name|uint32
operator|)
name|td
operator|->
name|td_samplesperpixel
else|:
operator|(
name|uint32
operator|)
name|fip
operator|->
name|field_readcount
decl_stmt|;
if|if
condition|(
operator|!
name|CheckDirCount
argument_list|(
name|tif
argument_list|,
name|dp
argument_list|,
name|expected
argument_list|)
condition|)
goto|goto
name|ignore
goto|;
block|}
switch|switch
condition|(
name|dp
operator|->
name|tdir_tag
condition|)
block|{
case|case
name|TIFFTAG_COMPRESSION
case|:
comment|/* 			 * The 5.0 spec says the Compression tag has 			 * one value, while earlier specs say it has 			 * one value per sample.  Because of this, we 			 * accept the tag if one value is supplied. 			 */
if|if
condition|(
name|dp
operator|->
name|tdir_count
operator|==
literal|1
condition|)
block|{
name|v
operator|=
name|TIFFExtractData
argument_list|(
name|tif
argument_list|,
name|dp
operator|->
name|tdir_type
argument_list|,
name|dp
operator|->
name|tdir_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|dp
operator|->
name|tdir_tag
argument_list|,
operator|(
name|uint16
operator|)
name|v
argument_list|)
condition|)
goto|goto
name|bad
goto|;
else|else
name|compressionknown
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* XXX: workaround for broken TIFFs */
block|}
elseif|else
if|if
condition|(
name|dp
operator|->
name|tdir_type
operator|==
name|TIFF_LONG
condition|)
block|{
if|if
condition|(
operator|!
name|TIFFFetchPerSampleLongs
argument_list|(
name|tif
argument_list|,
name|dp
argument_list|,
operator|&
name|v
argument_list|)
operator|||
operator|!
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|dp
operator|->
name|tdir_tag
argument_list|,
operator|(
name|uint16
operator|)
name|v
argument_list|)
condition|)
goto|goto
name|bad
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|TIFFFetchPerSampleShorts
argument_list|(
name|tif
argument_list|,
name|dp
argument_list|,
operator|&
name|iv
argument_list|)
operator|||
operator|!
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|dp
operator|->
name|tdir_tag
argument_list|,
name|iv
argument_list|)
condition|)
goto|goto
name|bad
goto|;
block|}
name|dp
operator|->
name|tdir_tag
operator|=
name|IGNORE
expr_stmt|;
break|break;
case|case
name|TIFFTAG_STRIPOFFSETS
case|:
case|case
name|TIFFTAG_STRIPBYTECOUNTS
case|:
case|case
name|TIFFTAG_TILEOFFSETS
case|:
case|case
name|TIFFTAG_TILEBYTECOUNTS
case|:
name|TIFFSetFieldBit
argument_list|(
name|tif
argument_list|,
name|fip
operator|->
name|field_bit
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFFTAG_IMAGEWIDTH
case|:
case|case
name|TIFFTAG_IMAGELENGTH
case|:
case|case
name|TIFFTAG_IMAGEDEPTH
case|:
case|case
name|TIFFTAG_TILELENGTH
case|:
case|case
name|TIFFTAG_TILEWIDTH
case|:
case|case
name|TIFFTAG_TILEDEPTH
case|:
case|case
name|TIFFTAG_PLANARCONFIG
case|:
case|case
name|TIFFTAG_ROWSPERSTRIP
case|:
case|case
name|TIFFTAG_EXTRASAMPLES
case|:
if|if
condition|(
operator|!
name|TIFFFetchNormalTag
argument_list|(
name|tif
argument_list|,
name|dp
argument_list|)
condition|)
goto|goto
name|bad
goto|;
name|dp
operator|->
name|tdir_tag
operator|=
name|IGNORE
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * XXX: OJPEG hack. 	 * If a) compression is OJPEG, b) planarconfig tag says it's separate, 	 * c) strip offsets/bytecounts tag are both present and 	 * d) both contain exactly one value, then we consistently find 	 * that the buggy implementation of the buggy compression scheme 	 * matches contig planarconfig best. So we 'fix-up' the tag here 	 */
if|if
condition|(
operator|(
name|td
operator|->
name|td_compression
operator|==
name|COMPRESSION_OJPEG
operator|)
operator|&&
operator|(
name|td
operator|->
name|td_planarconfig
operator|==
name|PLANARCONFIG_SEPARATE
operator|)
condition|)
block|{
name|dp
operator|=
name|TIFFReadDirectoryFind
argument_list|(
name|dir
argument_list|,
name|dircount
argument_list|,
name|TIFFTAG_STRIPOFFSETS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|dp
operator|->
name|tdir_count
operator|==
literal|1
operator|)
condition|)
block|{
name|dp
operator|=
name|TIFFReadDirectoryFind
argument_list|(
name|dir
argument_list|,
name|dircount
argument_list|,
name|TIFFTAG_STRIPBYTECOUNTS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|dp
operator|->
name|tdir_count
operator|==
literal|1
operator|)
condition|)
block|{
name|td
operator|->
name|td_planarconfig
operator|=
name|PLANARCONFIG_CONTIG
expr_stmt|;
name|TIFFWarningExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
literal|"TIFFReadDirectory"
argument_list|,
literal|"Planarconfig tag value assumed incorrect, "
literal|"assuming data is contig instead of chunky"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Allocate directory structure and setup defaults. 	 */
if|if
condition|(
operator|!
name|TIFFFieldSet
argument_list|(
name|tif
argument_list|,
name|FIELD_IMAGEDIMENSIONS
argument_list|)
condition|)
block|{
name|MissingRequired
argument_list|(
name|tif
argument_list|,
literal|"ImageLength"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/*  	 * Setup appropriate structures (by strip or by tile) 	 */
if|if
condition|(
operator|!
name|TIFFFieldSet
argument_list|(
name|tif
argument_list|,
name|FIELD_TILEDIMENSIONS
argument_list|)
condition|)
block|{
name|td
operator|->
name|td_nstrips
operator|=
name|TIFFNumberOfStrips
argument_list|(
name|tif
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_tilewidth
operator|=
name|td
operator|->
name|td_imagewidth
expr_stmt|;
name|td
operator|->
name|td_tilelength
operator|=
name|td
operator|->
name|td_rowsperstrip
expr_stmt|;
name|td
operator|->
name|td_tiledepth
operator|=
name|td
operator|->
name|td_imagedepth
expr_stmt|;
name|tif
operator|->
name|tif_flags
operator|&=
operator|~
name|TIFF_ISTILED
expr_stmt|;
block|}
else|else
block|{
name|td
operator|->
name|td_nstrips
operator|=
name|TIFFNumberOfTiles
argument_list|(
name|tif
argument_list|)
expr_stmt|;
name|tif
operator|->
name|tif_flags
operator||=
name|TIFF_ISTILED
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|td
operator|->
name|td_nstrips
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: cannot handle zero number of %s"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
name|isTiled
argument_list|(
name|tif
argument_list|)
condition|?
literal|"tiles"
else|:
literal|"strips"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|td
operator|->
name|td_stripsperimage
operator|=
name|td
operator|->
name|td_nstrips
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_planarconfig
operator|==
name|PLANARCONFIG_SEPARATE
condition|)
name|td
operator|->
name|td_stripsperimage
operator|/=
name|td
operator|->
name|td_samplesperpixel
expr_stmt|;
if|if
condition|(
operator|!
name|TIFFFieldSet
argument_list|(
name|tif
argument_list|,
name|FIELD_STRIPOFFSETS
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|td
operator|->
name|td_compression
operator|==
name|COMPRESSION_OJPEG
operator|)
operator|&&
operator|(
name|isTiled
argument_list|(
name|tif
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|td
operator|->
name|td_nstrips
operator|==
literal|1
operator|)
condition|)
block|{
comment|/* 			 * XXX: OJPEG hack. 			 * If a) compression is OJPEG, b) it's not a tiled TIFF, 			 * and c) the number of strips is 1, 			 * then we tolerate the absence of stripoffsets tag, 			 * because, presumably, all required data is in the 			 * JpegInterchangeFormat stream. 			 */
name|TIFFSetFieldBit
argument_list|(
name|tif
argument_list|,
name|FIELD_STRIPOFFSETS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MissingRequired
argument_list|(
name|tif
argument_list|,
name|isTiled
argument_list|(
name|tif
argument_list|)
condition|?
literal|"TileOffsets"
else|:
literal|"StripOffsets"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
comment|/* 	 * Second pass: extract other information. 	 */
for|for
control|(
name|dp
operator|=
name|dir
operator|,
name|n
operator|=
name|dircount
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|--
operator|,
name|dp
operator|++
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|tdir_tag
operator|==
name|IGNORE
condition|)
continue|continue;
switch|switch
condition|(
name|dp
operator|->
name|tdir_tag
condition|)
block|{
case|case
name|TIFFTAG_MINSAMPLEVALUE
case|:
case|case
name|TIFFTAG_MAXSAMPLEVALUE
case|:
case|case
name|TIFFTAG_BITSPERSAMPLE
case|:
case|case
name|TIFFTAG_DATATYPE
case|:
case|case
name|TIFFTAG_SAMPLEFORMAT
case|:
comment|/* 			 * The 5.0 spec says the Compression tag has 			 * one value, while earlier specs say it has 			 * one value per sample.  Because of this, we 			 * accept the tag if one value is supplied. 			 * 			 * The MinSampleValue, MaxSampleValue, BitsPerSample 			 * DataType and SampleFormat tags are supposed to be 			 * written as one value/sample, but some vendors 			 * incorrectly write one value only -- so we accept 			 * that as well (yech). Other vendors write correct 			 * value for NumberOfSamples, but incorrect one for 			 * BitsPerSample and friends, and we will read this 			 * too. 			 */
if|if
condition|(
name|dp
operator|->
name|tdir_count
operator|==
literal|1
condition|)
block|{
name|v
operator|=
name|TIFFExtractData
argument_list|(
name|tif
argument_list|,
name|dp
operator|->
name|tdir_type
argument_list|,
name|dp
operator|->
name|tdir_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|dp
operator|->
name|tdir_tag
argument_list|,
operator|(
name|uint16
operator|)
name|v
argument_list|)
condition|)
goto|goto
name|bad
goto|;
comment|/* XXX: workaround for broken TIFFs */
block|}
elseif|else
if|if
condition|(
name|dp
operator|->
name|tdir_tag
operator|==
name|TIFFTAG_BITSPERSAMPLE
operator|&&
name|dp
operator|->
name|tdir_type
operator|==
name|TIFF_LONG
condition|)
block|{
if|if
condition|(
operator|!
name|TIFFFetchPerSampleLongs
argument_list|(
name|tif
argument_list|,
name|dp
argument_list|,
operator|&
name|v
argument_list|)
operator|||
operator|!
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|dp
operator|->
name|tdir_tag
argument_list|,
operator|(
name|uint16
operator|)
name|v
argument_list|)
condition|)
goto|goto
name|bad
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|TIFFFetchPerSampleShorts
argument_list|(
name|tif
argument_list|,
name|dp
argument_list|,
operator|&
name|iv
argument_list|)
operator|||
operator|!
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|dp
operator|->
name|tdir_tag
argument_list|,
name|iv
argument_list|)
condition|)
goto|goto
name|bad
goto|;
block|}
break|break;
case|case
name|TIFFTAG_SMINSAMPLEVALUE
case|:
case|case
name|TIFFTAG_SMAXSAMPLEVALUE
case|:
block|{
name|double
name|dv
init|=
literal|0.0
decl_stmt|;
if|if
condition|(
operator|!
name|TIFFFetchPerSampleAnys
argument_list|(
name|tif
argument_list|,
name|dp
argument_list|,
operator|&
name|dv
argument_list|)
operator|||
operator|!
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|dp
operator|->
name|tdir_tag
argument_list|,
name|dv
argument_list|)
condition|)
goto|goto
name|bad
goto|;
block|}
break|break;
case|case
name|TIFFTAG_STRIPOFFSETS
case|:
case|case
name|TIFFTAG_TILEOFFSETS
case|:
if|if
condition|(
operator|!
name|TIFFFetchStripThing
argument_list|(
name|tif
argument_list|,
name|dp
argument_list|,
name|td
operator|->
name|td_nstrips
argument_list|,
operator|&
name|td
operator|->
name|td_stripoffset
argument_list|)
condition|)
goto|goto
name|bad
goto|;
break|break;
case|case
name|TIFFTAG_STRIPBYTECOUNTS
case|:
case|case
name|TIFFTAG_TILEBYTECOUNTS
case|:
if|if
condition|(
operator|!
name|TIFFFetchStripThing
argument_list|(
name|tif
argument_list|,
name|dp
argument_list|,
name|td
operator|->
name|td_nstrips
argument_list|,
operator|&
name|td
operator|->
name|td_stripbytecount
argument_list|)
condition|)
goto|goto
name|bad
goto|;
break|break;
case|case
name|TIFFTAG_COLORMAP
case|:
case|case
name|TIFFTAG_TRANSFERFUNCTION
case|:
block|{
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* 				 * TransferFunction can have either 1x or 3x 				 * data values; Colormap can have only 3x 				 * items. 				 */
name|v
operator|=
literal|1L
operator|<<
name|td
operator|->
name|td_bitspersample
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|tdir_tag
operator|==
name|TIFFTAG_COLORMAP
operator|||
name|dp
operator|->
name|tdir_count
operator|!=
name|v
condition|)
block|{
if|if
condition|(
operator|!
name|CheckDirCount
argument_list|(
name|tif
argument_list|,
name|dp
argument_list|,
literal|3
operator|*
name|v
argument_list|)
condition|)
break|break;
block|}
name|v
operator|*=
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|_TIFFCheckMalloc
argument_list|(
name|tif
argument_list|,
name|dp
operator|->
name|tdir_count
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
argument_list|,
literal|"to read \"TransferFunction\" tag"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|TIFFFetchData
argument_list|(
name|tif
argument_list|,
name|dp
argument_list|,
name|cp
argument_list|)
condition|)
block|{
comment|/* 						 * This deals with there being 						 * only one array to apply to 						 * all samples. 						 */
name|uint32
name|c
init|=
literal|1L
operator|<<
name|td
operator|->
name|td_bitspersample
decl_stmt|;
if|if
condition|(
name|dp
operator|->
name|tdir_count
operator|==
name|c
condition|)
name|v
operator|=
literal|0L
expr_stmt|;
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|dp
operator|->
name|tdir_tag
argument_list|,
name|cp
argument_list|,
name|cp
operator|+
name|v
argument_list|,
name|cp
operator|+
literal|2
operator|*
name|v
argument_list|)
expr_stmt|;
block|}
name|_TIFFfree
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|TIFFTAG_PAGENUMBER
case|:
case|case
name|TIFFTAG_HALFTONEHINTS
case|:
case|case
name|TIFFTAG_YCBCRSUBSAMPLING
case|:
case|case
name|TIFFTAG_DOTRANGE
case|:
operator|(
name|void
operator|)
name|TIFFFetchShortPair
argument_list|(
name|tif
argument_list|,
name|dp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFFTAG_REFERENCEBLACKWHITE
case|:
operator|(
name|void
operator|)
name|TIFFFetchRefBlackWhite
argument_list|(
name|tif
argument_list|,
name|dp
argument_list|)
expr_stmt|;
break|break;
comment|/* BEGIN REV 4.0 COMPATIBILITY */
case|case
name|TIFFTAG_OSUBFILETYPE
case|:
name|v
operator|=
literal|0L
expr_stmt|;
switch|switch
condition|(
name|TIFFExtractData
argument_list|(
name|tif
argument_list|,
name|dp
operator|->
name|tdir_type
argument_list|,
name|dp
operator|->
name|tdir_offset
argument_list|)
condition|)
block|{
case|case
name|OFILETYPE_REDUCEDIMAGE
case|:
name|v
operator|=
name|FILETYPE_REDUCEDIMAGE
expr_stmt|;
break|break;
case|case
name|OFILETYPE_PAGE
case|:
name|v
operator|=
name|FILETYPE_PAGE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|v
condition|)
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_SUBFILETYPE
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
comment|/* END REV 4.0 COMPATIBILITY */
default|default:
operator|(
name|void
operator|)
name|TIFFFetchNormalTag
argument_list|(
name|tif
argument_list|,
name|dp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * OJPEG hack: 	 * - If a) compression is OJPEG, and b) photometric tag is missing, 	 * then we consistently find that photometric should be YCbCr 	 * - If a) compression is OJPEG, and b) photometric tag says it's RGB, 	 * then we consistently find that the buggy implementation of the 	 * buggy compression scheme matches photometric YCbCr instead. 	 * - If a) compression is OJPEG, and b) bitspersample tag is missing, 	 * then we consistently find bitspersample should be 8. 	 * - If a) compression is OJPEG, b) samplesperpixel tag is missing, 	 * and c) photometric is RGB or YCbCr, then we consistently find 	 * samplesperpixel should be 3 	 * - If a) compression is OJPEG, b) samplesperpixel tag is missing, 	 * and c) photometric is MINISWHITE or MINISBLACK, then we consistently 	 * find samplesperpixel should be 3 	 */
if|if
condition|(
name|td
operator|->
name|td_compression
operator|==
name|COMPRESSION_OJPEG
condition|)
block|{
if|if
condition|(
operator|!
name|TIFFFieldSet
argument_list|(
name|tif
argument_list|,
name|FIELD_PHOTOMETRIC
argument_list|)
condition|)
block|{
name|TIFFWarningExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
literal|"TIFFReadDirectory"
argument_list|,
literal|"Photometric tag is missing, assuming data is YCbCr"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_PHOTOMETRIC
argument_list|,
name|PHOTOMETRIC_YCBCR
argument_list|)
condition|)
goto|goto
name|bad
goto|;
block|}
elseif|else
if|if
condition|(
name|td
operator|->
name|td_photometric
operator|==
name|PHOTOMETRIC_RGB
condition|)
block|{
name|td
operator|->
name|td_photometric
operator|=
name|PHOTOMETRIC_YCBCR
expr_stmt|;
name|TIFFWarningExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
literal|"TIFFReadDirectory"
argument_list|,
literal|"Photometric tag value assumed incorrect, "
literal|"assuming data is YCbCr instead of RGB"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TIFFFieldSet
argument_list|(
name|tif
argument_list|,
name|FIELD_BITSPERSAMPLE
argument_list|)
condition|)
block|{
name|TIFFWarningExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
literal|"TIFFReadDirectory"
argument_list|,
literal|"BitsPerSample tag is missing, assuming 8 bits per sample"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_BITSPERSAMPLE
argument_list|,
literal|8
argument_list|)
condition|)
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|!
name|TIFFFieldSet
argument_list|(
name|tif
argument_list|,
name|FIELD_SAMPLESPERPIXEL
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|td
operator|->
name|td_photometric
operator|==
name|PHOTOMETRIC_RGB
operator|)
operator|||
operator|(
name|td
operator|->
name|td_photometric
operator|==
name|PHOTOMETRIC_YCBCR
operator|)
condition|)
block|{
name|TIFFWarningExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
literal|"TIFFReadDirectory"
argument_list|,
literal|"SamplesPerPixel tag is missing, "
literal|"assuming correct SamplesPerPixel value is 3"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_SAMPLESPERPIXEL
argument_list|,
literal|3
argument_list|)
condition|)
goto|goto
name|bad
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|td
operator|->
name|td_photometric
operator|==
name|PHOTOMETRIC_MINISWHITE
operator|)
operator|||
operator|(
name|td
operator|->
name|td_photometric
operator|==
name|PHOTOMETRIC_MINISBLACK
operator|)
condition|)
block|{
name|TIFFWarningExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
literal|"TIFFReadDirectory"
argument_list|,
literal|"SamplesPerPixel tag is missing, "
literal|"assuming correct SamplesPerPixel value is 1"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_SAMPLESPERPIXEL
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|bad
goto|;
block|}
block|}
block|}
comment|/* 	 * Verify Palette image has a Colormap. 	 */
if|if
condition|(
name|td
operator|->
name|td_photometric
operator|==
name|PHOTOMETRIC_PALETTE
operator|&&
operator|!
name|TIFFFieldSet
argument_list|(
name|tif
argument_list|,
name|FIELD_COLORMAP
argument_list|)
condition|)
block|{
name|MissingRequired
argument_list|(
name|tif
argument_list|,
literal|"Colormap"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * OJPEG hack: 	 * We do no further messing with strip/tile offsets/bytecounts in OJPEG 	 * TIFFs 	 */
if|if
condition|(
name|td
operator|->
name|td_compression
operator|!=
name|COMPRESSION_OJPEG
condition|)
block|{
comment|/* 		 * Attempt to deal with a missing StripByteCounts tag. 		 */
if|if
condition|(
operator|!
name|TIFFFieldSet
argument_list|(
name|tif
argument_list|,
name|FIELD_STRIPBYTECOUNTS
argument_list|)
condition|)
block|{
comment|/* 			 * Some manufacturers violate the spec by not giving 			 * the size of the strips.  In this case, assume there 			 * is one uncompressed strip of data. 			 */
if|if
condition|(
operator|(
name|td
operator|->
name|td_planarconfig
operator|==
name|PLANARCONFIG_CONTIG
operator|&&
name|td
operator|->
name|td_nstrips
operator|>
literal|1
operator|)
operator|||
operator|(
name|td
operator|->
name|td_planarconfig
operator|==
name|PLANARCONFIG_SEPARATE
operator|&&
name|td
operator|->
name|td_nstrips
operator|!=
name|td
operator|->
name|td_samplesperpixel
operator|)
condition|)
block|{
name|MissingRequired
argument_list|(
name|tif
argument_list|,
literal|"StripByteCounts"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|TIFFWarningExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: TIFF directory is missing required "
literal|"\"%s\" field, calculating from imagelength"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
name|_TIFFFieldWithTag
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_STRIPBYTECOUNTS
argument_list|)
operator|->
name|field_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|EstimateStripByteCounts
argument_list|(
name|tif
argument_list|,
name|dir
argument_list|,
name|dircount
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|bad
goto|;
comment|/* 		 * Assume we have wrong StripByteCount value (in case 		 * of single strip) in following cases: 		 *   - it is equal to zero along with StripOffset; 		 *   - it is larger than file itself (in case of uncompressed 		 *     image); 		 *   - it is smaller than the size of the bytes per row 		 *     multiplied on the number of rows.  The last case should 		 *     not be checked in the case of writing new image, 		 *     because we may do not know the exact strip size 		 *     until the whole image will be written and directory 		 *     dumped out. 		 */
DECL|macro|BYTECOUNTLOOKSBAD
define|#
directive|define
name|BYTECOUNTLOOKSBAD
define|\
value|( (td->td_stripbytecount[0] == 0&& td->td_stripoffset[0] != 0) || \ 		      (td->td_compression == COMPRESSION_NONE&& \ 		       td->td_stripbytecount[0]> TIFFGetFileSize(tif) - td->td_stripoffset[0]) || \ 		      (tif->tif_mode == O_RDONLY&& \ 		       td->td_compression == COMPRESSION_NONE&& \ 		       td->td_stripbytecount[0]< TIFFScanlineSize(tif) * td->td_imagelength) )
block|}
elseif|else
if|if
condition|(
name|td
operator|->
name|td_nstrips
operator|==
literal|1
operator|&&
name|td
operator|->
name|td_stripoffset
index|[
literal|0
index|]
operator|!=
literal|0
operator|&&
name|BYTECOUNTLOOKSBAD
condition|)
block|{
comment|/* 			 * XXX: Plexus (and others) sometimes give a value of 			 * zero for a tag when they don't know what the 			 * correct value is!  Try and handle the simple case 			 * of estimating the size of a one strip image. 			 */
name|TIFFWarningExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Bogus \"%s\" field, ignoring and calculating from imagelength"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
name|_TIFFFieldWithTag
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_STRIPBYTECOUNTS
argument_list|)
operator|->
name|field_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|EstimateStripByteCounts
argument_list|(
name|tif
argument_list|,
name|dir
argument_list|,
name|dircount
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|bad
goto|;
block|}
elseif|else
if|if
condition|(
name|td
operator|->
name|td_planarconfig
operator|==
name|PLANARCONFIG_CONTIG
operator|&&
name|td
operator|->
name|td_nstrips
operator|>
literal|2
operator|&&
name|td
operator|->
name|td_compression
operator|==
name|COMPRESSION_NONE
operator|&&
name|td
operator|->
name|td_stripbytecount
index|[
literal|0
index|]
operator|!=
name|td
operator|->
name|td_stripbytecount
index|[
literal|1
index|]
operator|&&
name|td
operator|->
name|td_stripbytecount
index|[
literal|0
index|]
operator|!=
literal|0
operator|&&
name|td
operator|->
name|td_stripbytecount
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * XXX: Some vendors fill StripByteCount array with                           * absolutely wrong values (it can be equal to                           * StripOffset array, for example). Catch this case                           * here. 			 */
name|TIFFWarningExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Wrong \"%s\" field, ignoring and calculating from imagelength"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
name|_TIFFFieldWithTag
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_STRIPBYTECOUNTS
argument_list|)
operator|->
name|field_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|EstimateStripByteCounts
argument_list|(
name|tif
argument_list|,
name|dir
argument_list|,
name|dircount
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|bad
goto|;
block|}
block|}
if|if
condition|(
name|dir
condition|)
block|{
name|_TIFFfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dir
argument_list|)
expr_stmt|;
name|dir
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TIFFFieldSet
argument_list|(
name|tif
argument_list|,
name|FIELD_MAXSAMPLEVALUE
argument_list|)
condition|)
name|td
operator|->
name|td_maxsamplevalue
operator|=
call|(
name|uint16
call|)
argument_list|(
operator|(
literal|1L
operator|<<
name|td
operator|->
name|td_bitspersample
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Setup default compression scheme. 	 */
comment|/* 	 * XXX: We can optimize checking for the strip bounds using the sorted 	 * bytecounts array. See also comments for TIFFAppendToStrip() 	 * function in tif_write.c. 	 */
if|if
condition|(
name|td
operator|->
name|td_nstrips
operator|>
literal|1
condition|)
block|{
name|tstrip_t
name|strip
decl_stmt|;
name|td
operator|->
name|td_stripbytecountsorted
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|strip
operator|=
literal|1
init|;
name|strip
operator|<
name|td
operator|->
name|td_nstrips
condition|;
name|strip
operator|++
control|)
block|{
if|if
condition|(
name|td
operator|->
name|td_stripoffset
index|[
name|strip
operator|-
literal|1
index|]
operator|>
name|td
operator|->
name|td_stripoffset
index|[
name|strip
index|]
condition|)
block|{
name|td
operator|->
name|td_stripbytecountsorted
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|TIFFFieldSet
argument_list|(
name|tif
argument_list|,
name|FIELD_COMPRESSION
argument_list|)
condition|)
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_COMPRESSION
argument_list|,
name|COMPRESSION_NONE
argument_list|)
expr_stmt|;
comment|/* 	 * Some manufacturers make life difficult by writing 	 * large amounts of uncompressed data as a single strip. 	 * This is contrary to the recommendations of the spec. 	 * The following makes an attempt at breaking such images 	 * into strips closer to the recommended 8k bytes.  A 	 * side effect, however, is that the RowsPerStrip tag 	 * value may be changed. 	 */
if|if
condition|(
name|td
operator|->
name|td_nstrips
operator|==
literal|1
operator|&&
name|td
operator|->
name|td_compression
operator|==
name|COMPRESSION_NONE
operator|&&
operator|(
name|tif
operator|->
name|tif_flags
operator|&
operator|(
name|TIFF_STRIPCHOP
operator||
name|TIFF_ISTILED
operator|)
operator|)
operator|==
name|TIFF_STRIPCHOP
condition|)
name|ChopUpSingleUncompressedStrip
argument_list|(
name|tif
argument_list|)
expr_stmt|;
comment|/* 	 * Reinitialize i/o since we are starting on a new directory. 	 */
name|tif
operator|->
name|tif_row
operator|=
operator|(
name|uint32
operator|)
operator|-
literal|1
expr_stmt|;
name|tif
operator|->
name|tif_curstrip
operator|=
operator|(
name|tstrip_t
operator|)
operator|-
literal|1
expr_stmt|;
name|tif
operator|->
name|tif_col
operator|=
operator|(
name|uint32
operator|)
operator|-
literal|1
expr_stmt|;
name|tif
operator|->
name|tif_curtile
operator|=
operator|(
name|ttile_t
operator|)
operator|-
literal|1
expr_stmt|;
name|tif
operator|->
name|tif_tilesize
operator|=
operator|(
name|tsize_t
operator|)
operator|-
literal|1
expr_stmt|;
name|tif
operator|->
name|tif_scanlinesize
operator|=
name|TIFFScanlineSize
argument_list|(
name|tif
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tif
operator|->
name|tif_scanlinesize
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: cannot handle zero scanline size"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|isTiled
argument_list|(
name|tif
argument_list|)
condition|)
block|{
name|tif
operator|->
name|tif_tilesize
operator|=
name|TIFFTileSize
argument_list|(
name|tif
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tif
operator|->
name|tif_tilesize
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: cannot handle zero tile size"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|TIFFStripSize
argument_list|(
name|tif
argument_list|)
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: cannot handle zero strip size"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
name|bad
label|:
if|if
condition|(
name|dir
condition|)
name|_TIFFfree
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|TIFFDirEntry
modifier|*
DECL|function|TIFFReadDirectoryFind
name|TIFFReadDirectoryFind
parameter_list|(
name|TIFFDirEntry
modifier|*
name|dir
parameter_list|,
name|uint16
name|dircount
parameter_list|,
name|uint16
name|tagid
parameter_list|)
block|{
name|TIFFDirEntry
modifier|*
name|m
decl_stmt|;
name|uint16
name|n
decl_stmt|;
for|for
control|(
name|m
operator|=
name|dir
operator|,
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|dircount
condition|;
name|m
operator|++
operator|,
name|n
operator|++
control|)
block|{
if|if
condition|(
name|m
operator|->
name|tdir_tag
operator|==
name|tagid
condition|)
return|return
operator|(
name|m
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Read custom directory from the arbitarry offset.  * The code is very similar to TIFFReadDirectory().  */
end_comment
begin_function
name|int
DECL|function|TIFFReadCustomDirectory
name|TIFFReadCustomDirectory
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|toff_t
name|diroff
parameter_list|,
specifier|const
name|TIFFFieldInfo
name|info
index|[]
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|"TIFFReadCustomDirectory"
decl_stmt|;
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|TIFFDirEntry
modifier|*
name|dp
decl_stmt|,
modifier|*
name|dir
init|=
name|NULL
decl_stmt|;
specifier|const
name|TIFFFieldInfo
modifier|*
name|fip
decl_stmt|;
name|size_t
name|fix
decl_stmt|;
name|uint16
name|i
decl_stmt|,
name|dircount
decl_stmt|;
name|_TIFFSetupFieldInfo
argument_list|(
name|tif
argument_list|,
name|info
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|dircount
operator|=
name|TIFFFetchDirectory
argument_list|(
name|tif
argument_list|,
name|diroff
argument_list|,
operator|&
name|dir
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dircount
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Failed to read custom directory at offset %u"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
name|diroff
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|TIFFFreeDirectory
argument_list|(
name|tif
argument_list|)
expr_stmt|;
name|_TIFFmemset
argument_list|(
operator|&
name|tif
operator|->
name|tif_dir
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|TIFFDirectory
argument_list|)
argument_list|)
expr_stmt|;
name|fix
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|dir
operator|,
name|i
operator|=
name|dircount
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
operator|,
name|dp
operator|++
control|)
block|{
if|if
condition|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_SWAB
condition|)
block|{
name|TIFFSwabArrayOfShort
argument_list|(
operator|&
name|dp
operator|->
name|tdir_tag
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|TIFFSwabArrayOfLong
argument_list|(
operator|&
name|dp
operator|->
name|tdir_count
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fix
operator|>=
name|tif
operator|->
name|tif_nfields
operator|||
name|dp
operator|->
name|tdir_tag
operator|==
name|IGNORE
condition|)
continue|continue;
while|while
condition|(
name|fix
operator|<
name|tif
operator|->
name|tif_nfields
operator|&&
name|tif
operator|->
name|tif_fieldinfo
index|[
name|fix
index|]
operator|->
name|field_tag
operator|<
name|dp
operator|->
name|tdir_tag
condition|)
name|fix
operator|++
expr_stmt|;
if|if
condition|(
name|fix
operator|>=
name|tif
operator|->
name|tif_nfields
operator|||
name|tif
operator|->
name|tif_fieldinfo
index|[
name|fix
index|]
operator|->
name|field_tag
operator|!=
name|dp
operator|->
name|tdir_tag
condition|)
block|{
name|TIFFWarningExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: unknown field with tag %d (0x%x) encountered"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
name|dp
operator|->
name|tdir_tag
argument_list|,
name|dp
operator|->
name|tdir_tag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|_TIFFMergeFieldInfo
argument_list|(
name|tif
argument_list|,
name|_TIFFCreateAnonFieldInfo
argument_list|(
name|tif
argument_list|,
name|dp
operator|->
name|tdir_tag
argument_list|,
operator|(
name|TIFFDataType
operator|)
name|dp
operator|->
name|tdir_type
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|TIFFWarningExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"Registering anonymous field with tag %d (0x%x) failed"
argument_list|,
name|dp
operator|->
name|tdir_tag
argument_list|,
name|dp
operator|->
name|tdir_tag
argument_list|)
expr_stmt|;
goto|goto
name|ignore
goto|;
block|}
name|fix
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fix
operator|<
name|tif
operator|->
name|tif_nfields
operator|&&
name|tif
operator|->
name|tif_fieldinfo
index|[
name|fix
index|]
operator|->
name|field_tag
operator|<
name|dp
operator|->
name|tdir_tag
condition|)
name|fix
operator|++
expr_stmt|;
block|}
comment|/* 		 * Null out old tags that we ignore. 		 */
if|if
condition|(
name|tif
operator|->
name|tif_fieldinfo
index|[
name|fix
index|]
operator|->
name|field_bit
operator|==
name|FIELD_IGNORE
condition|)
block|{
name|ignore
label|:
name|dp
operator|->
name|tdir_tag
operator|=
name|IGNORE
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Check data type. 		 */
name|fip
operator|=
name|tif
operator|->
name|tif_fieldinfo
index|[
name|fix
index|]
expr_stmt|;
while|while
condition|(
name|dp
operator|->
name|tdir_type
operator|!=
operator|(
name|unsigned
name|short
operator|)
name|fip
operator|->
name|field_type
operator|&&
name|fix
operator|<
name|tif
operator|->
name|tif_nfields
condition|)
block|{
if|if
condition|(
name|fip
operator|->
name|field_type
operator|==
name|TIFF_ANY
condition|)
comment|/* wildcard */
break|break;
name|fip
operator|=
name|tif
operator|->
name|tif_fieldinfo
index|[
operator|++
name|fix
index|]
expr_stmt|;
if|if
condition|(
name|fix
operator|>=
name|tif
operator|->
name|tif_nfields
operator|||
name|fip
operator|->
name|field_tag
operator|!=
name|dp
operator|->
name|tdir_tag
condition|)
block|{
name|TIFFWarningExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: wrong data type %d for \"%s\"; tag ignored"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
name|dp
operator|->
name|tdir_type
argument_list|,
name|tif
operator|->
name|tif_fieldinfo
index|[
name|fix
operator|-
literal|1
index|]
operator|->
name|field_name
argument_list|)
expr_stmt|;
goto|goto
name|ignore
goto|;
block|}
block|}
comment|/* 		 * Check count if known in advance. 		 */
if|if
condition|(
name|fip
operator|->
name|field_readcount
operator|!=
name|TIFF_VARIABLE
operator|&&
name|fip
operator|->
name|field_readcount
operator|!=
name|TIFF_VARIABLE2
condition|)
block|{
name|uint32
name|expected
init|=
operator|(
name|fip
operator|->
name|field_readcount
operator|==
name|TIFF_SPP
operator|)
condition|?
operator|(
name|uint32
operator|)
name|td
operator|->
name|td_samplesperpixel
else|:
operator|(
name|uint32
operator|)
name|fip
operator|->
name|field_readcount
decl_stmt|;
if|if
condition|(
operator|!
name|CheckDirCount
argument_list|(
name|tif
argument_list|,
name|dp
argument_list|,
name|expected
argument_list|)
condition|)
goto|goto
name|ignore
goto|;
block|}
comment|/* 		 * EXIF tags which need to be specifically processed. 		 */
switch|switch
condition|(
name|dp
operator|->
name|tdir_tag
condition|)
block|{
case|case
name|EXIFTAG_SUBJECTDISTANCE
case|:
operator|(
name|void
operator|)
name|TIFFFetchSubjectDistance
argument_list|(
name|tif
argument_list|,
name|dp
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|TIFFFetchNormalTag
argument_list|(
name|tif
argument_list|,
name|dp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|dir
condition|)
name|_TIFFfree
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|/*  * EXIF is important special case of custom IFD, so we have a special  * function to read it.  */
end_comment
begin_function
name|int
DECL|function|TIFFReadEXIFDirectory
name|TIFFReadEXIFDirectory
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|toff_t
name|diroff
parameter_list|)
block|{
name|size_t
name|exifFieldInfoCount
decl_stmt|;
specifier|const
name|TIFFFieldInfo
modifier|*
name|exifFieldInfo
init|=
name|_TIFFGetExifFieldInfo
argument_list|(
operator|&
name|exifFieldInfoCount
argument_list|)
decl_stmt|;
return|return
name|TIFFReadCustomDirectory
argument_list|(
name|tif
argument_list|,
name|diroff
argument_list|,
name|exifFieldInfo
argument_list|,
name|exifFieldInfoCount
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|EstimateStripByteCounts
name|EstimateStripByteCounts
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|TIFFDirEntry
modifier|*
name|dir
parameter_list|,
name|uint16
name|dircount
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|"EstimateStripByteCounts"
decl_stmt|;
name|TIFFDirEntry
modifier|*
name|dp
decl_stmt|;
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|uint32
name|strip
decl_stmt|;
if|if
condition|(
name|td
operator|->
name|td_stripbytecount
condition|)
name|_TIFFfree
argument_list|(
name|td
operator|->
name|td_stripbytecount
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_stripbytecount
operator|=
operator|(
name|uint32
operator|*
operator|)
name|_TIFFCheckMalloc
argument_list|(
name|tif
argument_list|,
name|td
operator|->
name|td_nstrips
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32
argument_list|)
argument_list|,
literal|"for \"StripByteCounts\" array"
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_stripbytecount
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|td
operator|->
name|td_compression
operator|!=
name|COMPRESSION_NONE
condition|)
block|{
name|uint32
name|space
init|=
call|(
name|uint32
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|TIFFHeader
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
operator|+
operator|(
name|dircount
operator|*
sizeof|sizeof
argument_list|(
name|TIFFDirEntry
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32
argument_list|)
argument_list|)
decl_stmt|;
name|toff_t
name|filesize
init|=
name|TIFFGetFileSize
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|uint16
name|n
decl_stmt|;
comment|/* calculate amount of space used by indirect values */
for|for
control|(
name|dp
operator|=
name|dir
operator|,
name|n
operator|=
name|dircount
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|--
operator|,
name|dp
operator|++
control|)
block|{
name|uint32
name|cc
init|=
name|TIFFDataWidth
argument_list|(
operator|(
name|TIFFDataType
operator|)
name|dp
operator|->
name|tdir_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Cannot determine size of unknown tag type %d"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
name|dp
operator|->
name|tdir_type
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|cc
operator|=
name|cc
operator|*
name|dp
operator|->
name|tdir_count
expr_stmt|;
if|if
condition|(
name|cc
operator|>
sizeof|sizeof
argument_list|(
name|uint32
argument_list|)
condition|)
name|space
operator|+=
name|cc
expr_stmt|;
block|}
name|space
operator|=
name|filesize
operator|-
name|space
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_planarconfig
operator|==
name|PLANARCONFIG_SEPARATE
condition|)
name|space
operator|/=
name|td
operator|->
name|td_samplesperpixel
expr_stmt|;
for|for
control|(
name|strip
operator|=
literal|0
init|;
name|strip
operator|<
name|td
operator|->
name|td_nstrips
condition|;
name|strip
operator|++
control|)
name|td
operator|->
name|td_stripbytecount
index|[
name|strip
index|]
operator|=
name|space
expr_stmt|;
comment|/* 		 * This gross hack handles the case were the offset to 		 * the last strip is past the place where we think the strip 		 * should begin.  Since a strip of data must be contiguous, 		 * it's safe to assume that we've overestimated the amount 		 * of data in the strip and trim this number back accordingly. 		 */
name|strip
operator|--
expr_stmt|;
if|if
condition|(
operator|(
call|(
name|toff_t
call|)
argument_list|(
name|td
operator|->
name|td_stripoffset
index|[
name|strip
index|]
operator|+
name|td
operator|->
name|td_stripbytecount
index|[
name|strip
index|]
argument_list|)
operator|)
operator|>
name|filesize
condition|)
name|td
operator|->
name|td_stripbytecount
index|[
name|strip
index|]
operator|=
name|filesize
operator|-
name|td
operator|->
name|td_stripoffset
index|[
name|strip
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isTiled
argument_list|(
name|tif
argument_list|)
condition|)
block|{
name|uint32
name|bytespertile
init|=
name|TIFFTileSize
argument_list|(
name|tif
argument_list|)
decl_stmt|;
for|for
control|(
name|strip
operator|=
literal|0
init|;
name|strip
operator|<
name|td
operator|->
name|td_nstrips
condition|;
name|strip
operator|++
control|)
name|td
operator|->
name|td_stripbytecount
index|[
name|strip
index|]
operator|=
name|bytespertile
expr_stmt|;
block|}
else|else
block|{
name|uint32
name|rowbytes
init|=
name|TIFFScanlineSize
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|uint32
name|rowsperstrip
init|=
name|td
operator|->
name|td_imagelength
operator|/
name|td
operator|->
name|td_stripsperimage
decl_stmt|;
for|for
control|(
name|strip
operator|=
literal|0
init|;
name|strip
operator|<
name|td
operator|->
name|td_nstrips
condition|;
name|strip
operator|++
control|)
name|td
operator|->
name|td_stripbytecount
index|[
name|strip
index|]
operator|=
name|rowbytes
operator|*
name|rowsperstrip
expr_stmt|;
block|}
name|TIFFSetFieldBit
argument_list|(
name|tif
argument_list|,
name|FIELD_STRIPBYTECOUNTS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TIFFFieldSet
argument_list|(
name|tif
argument_list|,
name|FIELD_ROWSPERSTRIP
argument_list|)
condition|)
name|td
operator|->
name|td_rowsperstrip
operator|=
name|td
operator|->
name|td_imagelength
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|MissingRequired
name|MissingRequired
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
specifier|const
name|char
modifier|*
name|tagname
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|"MissingRequired"
decl_stmt|;
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: TIFF directory is missing required \"%s\" field"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
name|tagname
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Check the directory offset against the list of already seen directory  * offsets. This is a trick to prevent IFD looping. The one can create TIFF  * file with looped directory pointers. We will maintain a list of already  * seen directories and check every IFD offset against that list.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|TIFFCheckDirOffset
name|TIFFCheckDirOffset
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|toff_t
name|diroff
parameter_list|)
block|{
name|uint16
name|n
decl_stmt|;
if|if
condition|(
name|diroff
operator|==
literal|0
condition|)
comment|/* no more directories */
return|return
literal|0
return|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|tif
operator|->
name|tif_dirnumber
operator|&&
name|tif
operator|->
name|tif_dirlist
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|tif
operator|->
name|tif_dirlist
index|[
name|n
index|]
operator|==
name|diroff
condition|)
return|return
literal|0
return|;
block|}
name|tif
operator|->
name|tif_dirnumber
operator|++
expr_stmt|;
if|if
condition|(
name|tif
operator|->
name|tif_dirnumber
operator|>
name|tif
operator|->
name|tif_dirlistsize
condition|)
block|{
name|toff_t
modifier|*
name|new_dirlist
decl_stmt|;
comment|/* 		 * XXX: Reduce memory allocation granularity of the dirlist 		 * array. 		 */
name|new_dirlist
operator|=
operator|(
name|toff_t
operator|*
operator|)
name|_TIFFCheckRealloc
argument_list|(
name|tif
argument_list|,
name|tif
operator|->
name|tif_dirlist
argument_list|,
name|tif
operator|->
name|tif_dirnumber
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|toff_t
argument_list|)
argument_list|,
literal|"for IFD list"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_dirlist
condition|)
return|return
literal|0
return|;
name|tif
operator|->
name|tif_dirlistsize
operator|=
literal|2
operator|*
name|tif
operator|->
name|tif_dirnumber
expr_stmt|;
name|tif
operator|->
name|tif_dirlist
operator|=
name|new_dirlist
expr_stmt|;
block|}
name|tif
operator|->
name|tif_dirlist
index|[
name|tif
operator|->
name|tif_dirnumber
operator|-
literal|1
index|]
operator|=
name|diroff
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|/*  * Check the count field of a directory entry against a known value.  The  * caller is expected to skip/ignore the tag if there is a mismatch.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|CheckDirCount
name|CheckDirCount
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|TIFFDirEntry
modifier|*
name|dir
parameter_list|,
name|uint32
name|count
parameter_list|)
block|{
if|if
condition|(
name|count
operator|>
name|dir
operator|->
name|tdir_count
condition|)
block|{
name|TIFFWarningExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"incorrect count for field \"%s\" (%u, expecting %u); tag ignored"
argument_list|,
name|_TIFFFieldWithTag
argument_list|(
name|tif
argument_list|,
name|dir
operator|->
name|tdir_tag
argument_list|)
operator|->
name|field_name
argument_list|,
name|dir
operator|->
name|tdir_count
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|count
operator|<
name|dir
operator|->
name|tdir_count
condition|)
block|{
name|TIFFWarningExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"incorrect count for field \"%s\" (%u, expecting %u); tag trimmed"
argument_list|,
name|_TIFFFieldWithTag
argument_list|(
name|tif
argument_list|,
name|dir
operator|->
name|tdir_tag
argument_list|)
operator|->
name|field_name
argument_list|,
name|dir
operator|->
name|tdir_count
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Read IFD structure from the specified offset. If the pointer to  * nextdiroff variable has been specified, read it too. Function returns a  * number of fields in the directory or 0 if failed.  */
end_comment
begin_function
specifier|static
name|uint16
DECL|function|TIFFFetchDirectory
name|TIFFFetchDirectory
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|toff_t
name|diroff
parameter_list|,
name|TIFFDirEntry
modifier|*
modifier|*
name|pdir
parameter_list|,
name|toff_t
modifier|*
name|nextdiroff
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|"TIFFFetchDirectory"
decl_stmt|;
name|TIFFDirEntry
modifier|*
name|dir
decl_stmt|;
name|uint16
name|dircount
decl_stmt|;
name|assert
argument_list|(
name|pdir
argument_list|)
expr_stmt|;
name|tif
operator|->
name|tif_diroff
operator|=
name|diroff
expr_stmt|;
if|if
condition|(
name|nextdiroff
condition|)
operator|*
name|nextdiroff
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|isMapped
argument_list|(
name|tif
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|SeekOK
argument_list|(
name|tif
argument_list|,
name|tif
operator|->
name|tif_diroff
argument_list|)
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Seek error accessing TIFF directory"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|ReadOK
argument_list|(
name|tif
argument_list|,
operator|&
name|dircount
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
argument_list|)
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Can not read TIFF directory count"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_SWAB
condition|)
name|TIFFSwabShort
argument_list|(
operator|&
name|dircount
argument_list|)
expr_stmt|;
name|dir
operator|=
operator|(
name|TIFFDirEntry
operator|*
operator|)
name|_TIFFCheckMalloc
argument_list|(
name|tif
argument_list|,
name|dircount
argument_list|,
sizeof|sizeof
argument_list|(
name|TIFFDirEntry
argument_list|)
argument_list|,
literal|"to read TIFF directory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ReadOK
argument_list|(
name|tif
argument_list|,
name|dir
argument_list|,
name|dircount
operator|*
sizeof|sizeof
argument_list|(
name|TIFFDirEntry
argument_list|)
argument_list|)
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%.100s: Can not read TIFF directory"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|)
expr_stmt|;
name|_TIFFfree
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 		 * Read offset to next directory for sequential scans if 		 * needed. 		 */
if|if
condition|(
name|nextdiroff
condition|)
operator|(
name|void
operator|)
name|ReadOK
argument_list|(
name|tif
argument_list|,
name|nextdiroff
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|toff_t
name|off
init|=
name|tif
operator|->
name|tif_diroff
decl_stmt|;
comment|/* 		 * Check for integer overflow when validating the dir_off, 		 * otherwise a very high offset may cause an OOB read and 		 * crash the client. Make two comparisons instead of 		 * 		 *  off + sizeof(uint16)> tif->tif_size 		 * 		 * to avoid overflow. 		 */
if|if
condition|(
name|tif
operator|->
name|tif_size
operator|<
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
operator|||
name|off
operator|>
name|tif
operator|->
name|tif_size
operator|-
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Can not read TIFF directory count"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|_TIFFmemcpy
argument_list|(
operator|&
name|dircount
argument_list|,
name|tif
operator|->
name|tif_base
operator|+
name|off
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|off
operator|+=
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
expr_stmt|;
if|if
condition|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_SWAB
condition|)
name|TIFFSwabShort
argument_list|(
operator|&
name|dircount
argument_list|)
expr_stmt|;
name|dir
operator|=
operator|(
name|TIFFDirEntry
operator|*
operator|)
name|_TIFFCheckMalloc
argument_list|(
name|tif
argument_list|,
name|dircount
argument_list|,
sizeof|sizeof
argument_list|(
name|TIFFDirEntry
argument_list|)
argument_list|,
literal|"to read TIFF directory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|off
operator|+
name|dircount
operator|*
sizeof|sizeof
argument_list|(
name|TIFFDirEntry
argument_list|)
operator|>
name|tif
operator|->
name|tif_size
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Can not read TIFF directory"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|)
expr_stmt|;
name|_TIFFfree
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|_TIFFmemcpy
argument_list|(
name|dir
argument_list|,
name|tif
operator|->
name|tif_base
operator|+
name|off
argument_list|,
name|dircount
operator|*
sizeof|sizeof
argument_list|(
name|TIFFDirEntry
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nextdiroff
condition|)
block|{
name|off
operator|+=
name|dircount
operator|*
sizeof|sizeof
argument_list|(
name|TIFFDirEntry
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|+
sizeof|sizeof
argument_list|(
name|uint32
argument_list|)
operator|<=
name|tif
operator|->
name|tif_size
condition|)
block|{
name|_TIFFmemcpy
argument_list|(
name|nextdiroff
argument_list|,
name|tif
operator|->
name|tif_base
operator|+
name|off
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|nextdiroff
operator|&&
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_SWAB
condition|)
name|TIFFSwabLong
argument_list|(
name|nextdiroff
argument_list|)
expr_stmt|;
operator|*
name|pdir
operator|=
name|dir
expr_stmt|;
return|return
name|dircount
return|;
block|}
end_function
begin_comment
comment|/*  * Fetch a contiguous directory item.  */
end_comment
begin_function
specifier|static
name|tsize_t
DECL|function|TIFFFetchData
name|TIFFFetchData
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|TIFFDirEntry
modifier|*
name|dir
parameter_list|,
name|char
modifier|*
name|cp
parameter_list|)
block|{
name|uint32
name|w
init|=
name|TIFFDataWidth
argument_list|(
operator|(
name|TIFFDataType
operator|)
name|dir
operator|->
name|tdir_type
argument_list|)
decl_stmt|;
comment|/*  	 * FIXME: butecount should have tsize_t type, but for now libtiff 	 * defines tsize_t as a signed 32-bit integer and we are losing 	 * ability to read arrays larger than 2^31 bytes. So we are using 	 * uint32 instead of tsize_t here. 	 */
name|uint32
name|cc
init|=
name|dir
operator|->
name|tdir_count
operator|*
name|w
decl_stmt|;
comment|/* Check for overflow. */
if|if
condition|(
operator|!
name|dir
operator|->
name|tdir_count
operator|||
operator|!
name|w
operator|||
name|cc
operator|/
name|w
operator|!=
name|dir
operator|->
name|tdir_count
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
operator|!
name|isMapped
argument_list|(
name|tif
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|SeekOK
argument_list|(
name|tif
argument_list|,
name|dir
operator|->
name|tdir_offset
argument_list|)
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
operator|!
name|ReadOK
argument_list|(
name|tif
argument_list|,
name|cp
argument_list|,
name|cc
argument_list|)
condition|)
goto|goto
name|bad
goto|;
block|}
else|else
block|{
comment|/* Check for overflow. */
if|if
condition|(
name|dir
operator|->
name|tdir_offset
operator|+
name|cc
operator|<
name|dir
operator|->
name|tdir_offset
operator|||
name|dir
operator|->
name|tdir_offset
operator|+
name|cc
operator|<
name|cc
operator|||
name|dir
operator|->
name|tdir_offset
operator|+
name|cc
operator|>
name|tif
operator|->
name|tif_size
condition|)
goto|goto
name|bad
goto|;
name|_TIFFmemcpy
argument_list|(
name|cp
argument_list|,
name|tif
operator|->
name|tif_base
operator|+
name|dir
operator|->
name|tdir_offset
argument_list|,
name|cc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_SWAB
condition|)
block|{
switch|switch
condition|(
name|dir
operator|->
name|tdir_type
condition|)
block|{
case|case
name|TIFF_SHORT
case|:
case|case
name|TIFF_SSHORT
case|:
name|TIFFSwabArrayOfShort
argument_list|(
operator|(
name|uint16
operator|*
operator|)
name|cp
argument_list|,
name|dir
operator|->
name|tdir_count
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFF_LONG
case|:
case|case
name|TIFF_SLONG
case|:
case|case
name|TIFF_FLOAT
case|:
name|TIFFSwabArrayOfLong
argument_list|(
operator|(
name|uint32
operator|*
operator|)
name|cp
argument_list|,
name|dir
operator|->
name|tdir_count
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFF_RATIONAL
case|:
case|case
name|TIFF_SRATIONAL
case|:
name|TIFFSwabArrayOfLong
argument_list|(
operator|(
name|uint32
operator|*
operator|)
name|cp
argument_list|,
literal|2
operator|*
name|dir
operator|->
name|tdir_count
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFF_DOUBLE
case|:
name|TIFFSwabArrayOfDouble
argument_list|(
operator|(
name|double
operator|*
operator|)
name|cp
argument_list|,
name|dir
operator|->
name|tdir_count
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|cc
operator|)
return|;
name|bad
label|:
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"Error fetching data for field \"%s\""
argument_list|,
name|_TIFFFieldWithTag
argument_list|(
name|tif
argument_list|,
name|dir
operator|->
name|tdir_tag
argument_list|)
operator|->
name|field_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|tsize_t
operator|)
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * Fetch an ASCII item from the file.  */
end_comment
begin_function
specifier|static
name|tsize_t
DECL|function|TIFFFetchString
name|TIFFFetchString
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|TIFFDirEntry
modifier|*
name|dir
parameter_list|,
name|char
modifier|*
name|cp
parameter_list|)
block|{
if|if
condition|(
name|dir
operator|->
name|tdir_count
operator|<=
literal|4
condition|)
block|{
name|uint32
name|l
init|=
name|dir
operator|->
name|tdir_offset
decl_stmt|;
if|if
condition|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_SWAB
condition|)
name|TIFFSwabLong
argument_list|(
operator|&
name|l
argument_list|)
expr_stmt|;
name|_TIFFmemcpy
argument_list|(
name|cp
argument_list|,
operator|&
name|l
argument_list|,
name|dir
operator|->
name|tdir_count
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|TIFFFetchData
argument_list|(
name|tif
argument_list|,
name|dir
argument_list|,
name|cp
argument_list|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Convert numerator+denominator to float.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|cvtRational
name|cvtRational
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|TIFFDirEntry
modifier|*
name|dir
parameter_list|,
name|uint32
name|num
parameter_list|,
name|uint32
name|denom
parameter_list|,
name|float
modifier|*
name|rv
parameter_list|)
block|{
if|if
condition|(
name|denom
operator|==
literal|0
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"%s: Rational with zero denominator (num = %u)"
argument_list|,
name|_TIFFFieldWithTag
argument_list|(
name|tif
argument_list|,
name|dir
operator|->
name|tdir_tag
argument_list|)
operator|->
name|field_name
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|dir
operator|->
name|tdir_type
operator|==
name|TIFF_RATIONAL
condition|)
operator|*
name|rv
operator|=
operator|(
operator|(
name|float
operator|)
name|num
operator|/
operator|(
name|float
operator|)
name|denom
operator|)
expr_stmt|;
else|else
operator|*
name|rv
operator|=
operator|(
operator|(
name|float
operator|)
operator|(
name|int32
operator|)
name|num
operator|/
operator|(
name|float
operator|)
operator|(
name|int32
operator|)
name|denom
operator|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*  * Fetch a rational item from the file at offset off and return the value as a  * floating point number.  */
end_comment
begin_function
specifier|static
name|float
DECL|function|TIFFFetchRational
name|TIFFFetchRational
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|TIFFDirEntry
modifier|*
name|dir
parameter_list|)
block|{
name|uint32
name|l
index|[
literal|2
index|]
decl_stmt|;
name|float
name|v
decl_stmt|;
return|return
operator|(
operator|!
name|TIFFFetchData
argument_list|(
name|tif
argument_list|,
name|dir
argument_list|,
operator|(
name|char
operator|*
operator|)
name|l
argument_list|)
operator|||
operator|!
name|cvtRational
argument_list|(
name|tif
argument_list|,
name|dir
argument_list|,
name|l
index|[
literal|0
index|]
argument_list|,
name|l
index|[
literal|1
index|]
argument_list|,
operator|&
name|v
argument_list|)
condition|?
literal|1.0f
else|:
name|v
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Fetch a single floating point value from the offset field and return it as  * a native float.  */
end_comment
begin_function
specifier|static
name|float
DECL|function|TIFFFetchFloat
name|TIFFFetchFloat
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|TIFFDirEntry
modifier|*
name|dir
parameter_list|)
block|{
name|float
name|v
decl_stmt|;
name|int32
name|l
init|=
name|TIFFExtractData
argument_list|(
name|tif
argument_list|,
name|dir
operator|->
name|tdir_type
argument_list|,
name|dir
operator|->
name|tdir_offset
argument_list|)
decl_stmt|;
name|_TIFFmemcpy
argument_list|(
operator|&
name|v
argument_list|,
operator|&
name|l
argument_list|,
sizeof|sizeof
argument_list|(
name|float
argument_list|)
argument_list|)
expr_stmt|;
name|TIFFCvtIEEEFloatToNative
argument_list|(
name|tif
argument_list|,
literal|1
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Fetch an array of BYTE or SBYTE values.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|TIFFFetchByteArray
name|TIFFFetchByteArray
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|TIFFDirEntry
modifier|*
name|dir
parameter_list|,
name|uint8
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
name|dir
operator|->
name|tdir_count
operator|<=
literal|4
condition|)
block|{
comment|/*          * Extract data from offset field.          */
if|if
condition|(
name|tif
operator|->
name|tif_header
operator|.
name|tiff_magic
operator|==
name|TIFF_BIGENDIAN
condition|)
block|{
if|if
condition|(
name|dir
operator|->
name|tdir_type
operator|==
name|TIFF_SBYTE
condition|)
switch|switch
condition|(
name|dir
operator|->
name|tdir_count
condition|)
block|{
case|case
literal|4
case|:
name|v
index|[
literal|3
index|]
operator|=
name|dir
operator|->
name|tdir_offset
operator|&
literal|0xff
expr_stmt|;
case|case
literal|3
case|:
name|v
index|[
literal|2
index|]
operator|=
operator|(
name|dir
operator|->
name|tdir_offset
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
case|case
literal|2
case|:
name|v
index|[
literal|1
index|]
operator|=
operator|(
name|dir
operator|->
name|tdir_offset
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
case|case
literal|1
case|:
name|v
index|[
literal|0
index|]
operator|=
name|dir
operator|->
name|tdir_offset
operator|>>
literal|24
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|dir
operator|->
name|tdir_count
condition|)
block|{
case|case
literal|4
case|:
name|v
index|[
literal|3
index|]
operator|=
name|dir
operator|->
name|tdir_offset
operator|&
literal|0xff
expr_stmt|;
case|case
literal|3
case|:
name|v
index|[
literal|2
index|]
operator|=
operator|(
name|dir
operator|->
name|tdir_offset
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
case|case
literal|2
case|:
name|v
index|[
literal|1
index|]
operator|=
operator|(
name|dir
operator|->
name|tdir_offset
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
case|case
literal|1
case|:
name|v
index|[
literal|0
index|]
operator|=
name|dir
operator|->
name|tdir_offset
operator|>>
literal|24
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|dir
operator|->
name|tdir_type
operator|==
name|TIFF_SBYTE
condition|)
switch|switch
condition|(
name|dir
operator|->
name|tdir_count
condition|)
block|{
case|case
literal|4
case|:
name|v
index|[
literal|3
index|]
operator|=
name|dir
operator|->
name|tdir_offset
operator|>>
literal|24
expr_stmt|;
case|case
literal|3
case|:
name|v
index|[
literal|2
index|]
operator|=
operator|(
name|dir
operator|->
name|tdir_offset
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
case|case
literal|2
case|:
name|v
index|[
literal|1
index|]
operator|=
operator|(
name|dir
operator|->
name|tdir_offset
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
case|case
literal|1
case|:
name|v
index|[
literal|0
index|]
operator|=
name|dir
operator|->
name|tdir_offset
operator|&
literal|0xff
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|dir
operator|->
name|tdir_count
condition|)
block|{
case|case
literal|4
case|:
name|v
index|[
literal|3
index|]
operator|=
name|dir
operator|->
name|tdir_offset
operator|>>
literal|24
expr_stmt|;
case|case
literal|3
case|:
name|v
index|[
literal|2
index|]
operator|=
operator|(
name|dir
operator|->
name|tdir_offset
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
case|case
literal|2
case|:
name|v
index|[
literal|1
index|]
operator|=
operator|(
name|dir
operator|->
name|tdir_offset
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
case|case
literal|1
case|:
name|v
index|[
literal|0
index|]
operator|=
name|dir
operator|->
name|tdir_offset
operator|&
literal|0xff
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
name|TIFFFetchData
argument_list|(
name|tif
argument_list|,
name|dir
argument_list|,
operator|(
name|char
operator|*
operator|)
name|v
argument_list|)
operator|!=
literal|0
operator|)
return|;
comment|/* XXX */
block|}
end_function
begin_comment
comment|/*  * Fetch an array of SHORT or SSHORT values.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|TIFFFetchShortArray
name|TIFFFetchShortArray
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|TIFFDirEntry
modifier|*
name|dir
parameter_list|,
name|uint16
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
name|dir
operator|->
name|tdir_count
operator|<=
literal|2
condition|)
block|{
if|if
condition|(
name|tif
operator|->
name|tif_header
operator|.
name|tiff_magic
operator|==
name|TIFF_BIGENDIAN
condition|)
block|{
switch|switch
condition|(
name|dir
operator|->
name|tdir_count
condition|)
block|{
case|case
literal|2
case|:
name|v
index|[
literal|1
index|]
operator|=
call|(
name|uint16
call|)
argument_list|(
name|dir
operator|->
name|tdir_offset
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
name|v
index|[
literal|0
index|]
operator|=
call|(
name|uint16
call|)
argument_list|(
name|dir
operator|->
name|tdir_offset
operator|>>
literal|16
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|dir
operator|->
name|tdir_count
condition|)
block|{
case|case
literal|2
case|:
name|v
index|[
literal|1
index|]
operator|=
call|(
name|uint16
call|)
argument_list|(
name|dir
operator|->
name|tdir_offset
operator|>>
literal|16
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
name|v
index|[
literal|0
index|]
operator|=
call|(
name|uint16
call|)
argument_list|(
name|dir
operator|->
name|tdir_offset
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
name|TIFFFetchData
argument_list|(
name|tif
argument_list|,
name|dir
argument_list|,
operator|(
name|char
operator|*
operator|)
name|v
argument_list|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Fetch a pair of SHORT or BYTE values. Some tags may have either BYTE  * or SHORT type and this function works with both ones.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|TIFFFetchShortPair
name|TIFFFetchShortPair
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|TIFFDirEntry
modifier|*
name|dir
parameter_list|)
block|{
comment|/* 	 * Prevent overflowing the v stack arrays below by performing a sanity 	 * check on tdir_count, this should never be greater than two. 	 */
if|if
condition|(
name|dir
operator|->
name|tdir_count
operator|>
literal|2
condition|)
block|{
name|TIFFWarningExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"unexpected count for field \"%s\", %u, expected 2; ignored"
argument_list|,
name|_TIFFFieldWithTag
argument_list|(
name|tif
argument_list|,
name|dir
operator|->
name|tdir_tag
argument_list|)
operator|->
name|field_name
argument_list|,
name|dir
operator|->
name|tdir_count
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|dir
operator|->
name|tdir_type
condition|)
block|{
case|case
name|TIFF_BYTE
case|:
case|case
name|TIFF_SBYTE
case|:
block|{
name|uint8
name|v
index|[
literal|4
index|]
decl_stmt|;
return|return
name|TIFFFetchByteArray
argument_list|(
name|tif
argument_list|,
name|dir
argument_list|,
name|v
argument_list|)
operator|&&
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|dir
operator|->
name|tdir_tag
argument_list|,
name|v
index|[
literal|0
index|]
argument_list|,
name|v
index|[
literal|1
index|]
argument_list|)
return|;
block|}
case|case
name|TIFF_SHORT
case|:
case|case
name|TIFF_SSHORT
case|:
block|{
name|uint16
name|v
index|[
literal|2
index|]
decl_stmt|;
return|return
name|TIFFFetchShortArray
argument_list|(
name|tif
argument_list|,
name|dir
argument_list|,
name|v
argument_list|)
operator|&&
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|dir
operator|->
name|tdir_tag
argument_list|,
name|v
index|[
literal|0
index|]
argument_list|,
name|v
index|[
literal|1
index|]
argument_list|)
return|;
block|}
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function
begin_comment
comment|/*  * Fetch an array of LONG or SLONG values.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|TIFFFetchLongArray
name|TIFFFetchLongArray
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|TIFFDirEntry
modifier|*
name|dir
parameter_list|,
name|uint32
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
name|dir
operator|->
name|tdir_count
operator|==
literal|1
condition|)
block|{
name|v
index|[
literal|0
index|]
operator|=
name|dir
operator|->
name|tdir_offset
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
name|TIFFFetchData
argument_list|(
name|tif
argument_list|,
name|dir
argument_list|,
operator|(
name|char
operator|*
operator|)
name|v
argument_list|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Fetch an array of RATIONAL or SRATIONAL values.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|TIFFFetchRationalArray
name|TIFFFetchRationalArray
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|TIFFDirEntry
modifier|*
name|dir
parameter_list|,
name|float
modifier|*
name|v
parameter_list|)
block|{
name|int
name|ok
init|=
literal|0
decl_stmt|;
name|uint32
modifier|*
name|l
decl_stmt|;
name|l
operator|=
operator|(
name|uint32
operator|*
operator|)
name|_TIFFCheckMalloc
argument_list|(
name|tif
argument_list|,
name|dir
operator|->
name|tdir_count
argument_list|,
name|TIFFDataWidth
argument_list|(
operator|(
name|TIFFDataType
operator|)
name|dir
operator|->
name|tdir_type
argument_list|)
argument_list|,
literal|"to fetch array of rationals"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
condition|)
block|{
if|if
condition|(
name|TIFFFetchData
argument_list|(
name|tif
argument_list|,
name|dir
argument_list|,
operator|(
name|char
operator|*
operator|)
name|l
argument_list|)
condition|)
block|{
name|uint32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dir
operator|->
name|tdir_count
condition|;
name|i
operator|++
control|)
block|{
name|ok
operator|=
name|cvtRational
argument_list|(
name|tif
argument_list|,
name|dir
argument_list|,
name|l
index|[
literal|2
operator|*
name|i
operator|+
literal|0
index|]
argument_list|,
name|l
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
argument_list|,
operator|&
name|v
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
break|break;
block|}
block|}
name|_TIFFfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|l
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ok
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Fetch an array of FLOAT values.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|TIFFFetchFloatArray
name|TIFFFetchFloatArray
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|TIFFDirEntry
modifier|*
name|dir
parameter_list|,
name|float
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
name|dir
operator|->
name|tdir_count
operator|==
literal|1
condition|)
block|{
union|union
block|{
name|float
name|f
decl_stmt|;
name|uint32
name|i
decl_stmt|;
block|}
name|float_union
union|;
name|float_union
operator|.
name|i
operator|=
name|dir
operator|->
name|tdir_offset
expr_stmt|;
name|v
index|[
literal|0
index|]
operator|=
name|float_union
operator|.
name|f
expr_stmt|;
name|TIFFCvtIEEEFloatToNative
argument_list|(
name|tif
argument_list|,
name|dir
operator|->
name|tdir_count
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|TIFFFetchData
argument_list|(
name|tif
argument_list|,
name|dir
argument_list|,
operator|(
name|char
operator|*
operator|)
name|v
argument_list|)
condition|)
block|{
name|TIFFCvtIEEEFloatToNative
argument_list|(
name|tif
argument_list|,
name|dir
operator|->
name|tdir_count
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Fetch an array of DOUBLE values.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|TIFFFetchDoubleArray
name|TIFFFetchDoubleArray
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|TIFFDirEntry
modifier|*
name|dir
parameter_list|,
name|double
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
name|TIFFFetchData
argument_list|(
name|tif
argument_list|,
name|dir
argument_list|,
operator|(
name|char
operator|*
operator|)
name|v
argument_list|)
condition|)
block|{
name|TIFFCvtIEEEDoubleToNative
argument_list|(
name|tif
argument_list|,
name|dir
operator|->
name|tdir_count
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Fetch an array of ANY values.  The actual values are returned as doubles  * which should be able hold all the types.  Yes, there really should be an  * tany_t to avoid this potential non-portability ...  Note in particular that  * we assume that the double return value vector is large enough to read in  * any fundamental type.  We use that vector as a buffer to read in the base  * type vector and then convert it in place to double (from end to front of  * course).  */
end_comment
begin_function
specifier|static
name|int
DECL|function|TIFFFetchAnyArray
name|TIFFFetchAnyArray
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|TIFFDirEntry
modifier|*
name|dir
parameter_list|,
name|double
modifier|*
name|v
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|dir
operator|->
name|tdir_type
condition|)
block|{
case|case
name|TIFF_BYTE
case|:
case|case
name|TIFF_SBYTE
case|:
if|if
condition|(
operator|!
name|TIFFFetchByteArray
argument_list|(
name|tif
argument_list|,
name|dir
argument_list|,
operator|(
name|uint8
operator|*
operator|)
name|v
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|dir
operator|->
name|tdir_type
operator|==
name|TIFF_BYTE
condition|)
block|{
name|uint8
modifier|*
name|vp
init|=
operator|(
name|uint8
operator|*
operator|)
name|v
decl_stmt|;
for|for
control|(
name|i
operator|=
name|dir
operator|->
name|tdir_count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|v
index|[
name|i
index|]
operator|=
name|vp
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|int8
modifier|*
name|vp
init|=
operator|(
name|int8
operator|*
operator|)
name|v
decl_stmt|;
for|for
control|(
name|i
operator|=
name|dir
operator|->
name|tdir_count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|v
index|[
name|i
index|]
operator|=
name|vp
index|[
name|i
index|]
expr_stmt|;
block|}
break|break;
case|case
name|TIFF_SHORT
case|:
case|case
name|TIFF_SSHORT
case|:
if|if
condition|(
operator|!
name|TIFFFetchShortArray
argument_list|(
name|tif
argument_list|,
name|dir
argument_list|,
operator|(
name|uint16
operator|*
operator|)
name|v
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|dir
operator|->
name|tdir_type
operator|==
name|TIFF_SHORT
condition|)
block|{
name|uint16
modifier|*
name|vp
init|=
operator|(
name|uint16
operator|*
operator|)
name|v
decl_stmt|;
for|for
control|(
name|i
operator|=
name|dir
operator|->
name|tdir_count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|v
index|[
name|i
index|]
operator|=
name|vp
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|int16
modifier|*
name|vp
init|=
operator|(
name|int16
operator|*
operator|)
name|v
decl_stmt|;
for|for
control|(
name|i
operator|=
name|dir
operator|->
name|tdir_count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|v
index|[
name|i
index|]
operator|=
name|vp
index|[
name|i
index|]
expr_stmt|;
block|}
break|break;
case|case
name|TIFF_LONG
case|:
case|case
name|TIFF_SLONG
case|:
if|if
condition|(
operator|!
name|TIFFFetchLongArray
argument_list|(
name|tif
argument_list|,
name|dir
argument_list|,
operator|(
name|uint32
operator|*
operator|)
name|v
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|dir
operator|->
name|tdir_type
operator|==
name|TIFF_LONG
condition|)
block|{
name|uint32
modifier|*
name|vp
init|=
operator|(
name|uint32
operator|*
operator|)
name|v
decl_stmt|;
for|for
control|(
name|i
operator|=
name|dir
operator|->
name|tdir_count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|v
index|[
name|i
index|]
operator|=
name|vp
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|int32
modifier|*
name|vp
init|=
operator|(
name|int32
operator|*
operator|)
name|v
decl_stmt|;
for|for
control|(
name|i
operator|=
name|dir
operator|->
name|tdir_count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|v
index|[
name|i
index|]
operator|=
name|vp
index|[
name|i
index|]
expr_stmt|;
block|}
break|break;
case|case
name|TIFF_RATIONAL
case|:
case|case
name|TIFF_SRATIONAL
case|:
if|if
condition|(
operator|!
name|TIFFFetchRationalArray
argument_list|(
name|tif
argument_list|,
name|dir
argument_list|,
operator|(
name|float
operator|*
operator|)
name|v
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|{
name|float
modifier|*
name|vp
init|=
operator|(
name|float
operator|*
operator|)
name|v
decl_stmt|;
for|for
control|(
name|i
operator|=
name|dir
operator|->
name|tdir_count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|v
index|[
name|i
index|]
operator|=
name|vp
index|[
name|i
index|]
expr_stmt|;
block|}
break|break;
case|case
name|TIFF_FLOAT
case|:
if|if
condition|(
operator|!
name|TIFFFetchFloatArray
argument_list|(
name|tif
argument_list|,
name|dir
argument_list|,
operator|(
name|float
operator|*
operator|)
name|v
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|{
name|float
modifier|*
name|vp
init|=
operator|(
name|float
operator|*
operator|)
name|v
decl_stmt|;
for|for
control|(
name|i
operator|=
name|dir
operator|->
name|tdir_count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|v
index|[
name|i
index|]
operator|=
name|vp
index|[
name|i
index|]
expr_stmt|;
block|}
break|break;
case|case
name|TIFF_DOUBLE
case|:
return|return
operator|(
name|TIFFFetchDoubleArray
argument_list|(
name|tif
argument_list|,
name|dir
argument_list|,
operator|(
name|double
operator|*
operator|)
name|v
argument_list|)
operator|)
return|;
default|default:
comment|/* TIFF_NOTYPE */
comment|/* TIFF_ASCII */
comment|/* TIFF_UNDEFINED */
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"cannot read TIFF_ANY type %d for field \"%s\""
argument_list|,
name|dir
operator|->
name|tdir_type
argument_list|,
name|_TIFFFieldWithTag
argument_list|(
name|tif
argument_list|,
name|dir
operator|->
name|tdir_tag
argument_list|)
operator|->
name|field_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Fetch a tag that is not handled by special case code.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|TIFFFetchNormalTag
name|TIFFFetchNormalTag
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|TIFFDirEntry
modifier|*
name|dp
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|mesg
index|[]
init|=
literal|"to fetch tag value"
decl_stmt|;
name|int
name|ok
init|=
literal|0
decl_stmt|;
specifier|const
name|TIFFFieldInfo
modifier|*
name|fip
init|=
name|_TIFFFieldWithTag
argument_list|(
name|tif
argument_list|,
name|dp
operator|->
name|tdir_tag
argument_list|)
decl_stmt|;
if|if
condition|(
name|dp
operator|->
name|tdir_count
operator|>
literal|1
condition|)
block|{
comment|/* array of values */
name|char
modifier|*
name|cp
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|dp
operator|->
name|tdir_type
condition|)
block|{
case|case
name|TIFF_BYTE
case|:
case|case
name|TIFF_SBYTE
case|:
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|_TIFFCheckMalloc
argument_list|(
name|tif
argument_list|,
name|dp
operator|->
name|tdir_count
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8
argument_list|)
argument_list|,
name|mesg
argument_list|)
expr_stmt|;
name|ok
operator|=
name|cp
operator|&&
name|TIFFFetchByteArray
argument_list|(
name|tif
argument_list|,
name|dp
argument_list|,
operator|(
name|uint8
operator|*
operator|)
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFF_SHORT
case|:
case|case
name|TIFF_SSHORT
case|:
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|_TIFFCheckMalloc
argument_list|(
name|tif
argument_list|,
name|dp
operator|->
name|tdir_count
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
argument_list|,
name|mesg
argument_list|)
expr_stmt|;
name|ok
operator|=
name|cp
operator|&&
name|TIFFFetchShortArray
argument_list|(
name|tif
argument_list|,
name|dp
argument_list|,
operator|(
name|uint16
operator|*
operator|)
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFF_LONG
case|:
case|case
name|TIFF_SLONG
case|:
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|_TIFFCheckMalloc
argument_list|(
name|tif
argument_list|,
name|dp
operator|->
name|tdir_count
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32
argument_list|)
argument_list|,
name|mesg
argument_list|)
expr_stmt|;
name|ok
operator|=
name|cp
operator|&&
name|TIFFFetchLongArray
argument_list|(
name|tif
argument_list|,
name|dp
argument_list|,
operator|(
name|uint32
operator|*
operator|)
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFF_RATIONAL
case|:
case|case
name|TIFF_SRATIONAL
case|:
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|_TIFFCheckMalloc
argument_list|(
name|tif
argument_list|,
name|dp
operator|->
name|tdir_count
argument_list|,
sizeof|sizeof
argument_list|(
name|float
argument_list|)
argument_list|,
name|mesg
argument_list|)
expr_stmt|;
name|ok
operator|=
name|cp
operator|&&
name|TIFFFetchRationalArray
argument_list|(
name|tif
argument_list|,
name|dp
argument_list|,
operator|(
name|float
operator|*
operator|)
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFF_FLOAT
case|:
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|_TIFFCheckMalloc
argument_list|(
name|tif
argument_list|,
name|dp
operator|->
name|tdir_count
argument_list|,
sizeof|sizeof
argument_list|(
name|float
argument_list|)
argument_list|,
name|mesg
argument_list|)
expr_stmt|;
name|ok
operator|=
name|cp
operator|&&
name|TIFFFetchFloatArray
argument_list|(
name|tif
argument_list|,
name|dp
argument_list|,
operator|(
name|float
operator|*
operator|)
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFF_DOUBLE
case|:
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|_TIFFCheckMalloc
argument_list|(
name|tif
argument_list|,
name|dp
operator|->
name|tdir_count
argument_list|,
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|,
name|mesg
argument_list|)
expr_stmt|;
name|ok
operator|=
name|cp
operator|&&
name|TIFFFetchDoubleArray
argument_list|(
name|tif
argument_list|,
name|dp
argument_list|,
operator|(
name|double
operator|*
operator|)
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFF_ASCII
case|:
case|case
name|TIFF_UNDEFINED
case|:
comment|/* bit of a cheat... */
comment|/* 			 * Some vendors write strings w/o the trailing 			 * NULL byte, so always append one just in case. 			 */
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|_TIFFCheckMalloc
argument_list|(
name|tif
argument_list|,
name|dp
operator|->
name|tdir_count
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|mesg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ok
operator|=
operator|(
name|cp
operator|&&
name|TIFFFetchString
argument_list|(
name|tif
argument_list|,
name|dp
argument_list|,
name|cp
argument_list|)
operator|)
operator|)
operator|!=
literal|0
condition|)
name|cp
index|[
name|dp
operator|->
name|tdir_count
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* XXX */
break|break;
block|}
if|if
condition|(
name|ok
condition|)
block|{
name|ok
operator|=
operator|(
name|fip
operator|->
name|field_passcount
condition|?
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|dp
operator|->
name|tdir_tag
argument_list|,
name|dp
operator|->
name|tdir_count
argument_list|,
name|cp
argument_list|)
else|:
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|dp
operator|->
name|tdir_tag
argument_list|,
name|cp
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
name|_TIFFfree
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CheckDirCount
argument_list|(
name|tif
argument_list|,
name|dp
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* singleton value */
switch|switch
condition|(
name|dp
operator|->
name|tdir_type
condition|)
block|{
case|case
name|TIFF_BYTE
case|:
case|case
name|TIFF_SBYTE
case|:
case|case
name|TIFF_SHORT
case|:
case|case
name|TIFF_SSHORT
case|:
comment|/* 			 * If the tag is also acceptable as a LONG or SLONG 			 * then TIFFSetField will expect an uint32 parameter 			 * passed to it (through varargs).  Thus, for machines 			 * where sizeof (int) != sizeof (uint32) we must do 			 * a careful check here.  It's hard to say if this 			 * is worth optimizing. 			 * 			 * NB: We use TIFFFieldWithTag here knowing that 			 *     it returns us the first entry in the table 			 *     for the tag and that that entry is for the 			 *     widest potential data type the tag may have. 			 */
block|{
name|TIFFDataType
name|type
init|=
name|fip
operator|->
name|field_type
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|TIFF_LONG
operator|&&
name|type
operator|!=
name|TIFF_SLONG
condition|)
block|{
name|uint16
name|v
init|=
operator|(
name|uint16
operator|)
name|TIFFExtractData
argument_list|(
name|tif
argument_list|,
name|dp
operator|->
name|tdir_type
argument_list|,
name|dp
operator|->
name|tdir_offset
argument_list|)
decl_stmt|;
name|ok
operator|=
operator|(
name|fip
operator|->
name|field_passcount
condition|?
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|dp
operator|->
name|tdir_tag
argument_list|,
literal|1
argument_list|,
operator|&
name|v
argument_list|)
else|:
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|dp
operator|->
name|tdir_tag
argument_list|,
name|v
argument_list|)
operator|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* fall thru... */
case|case
name|TIFF_LONG
case|:
case|case
name|TIFF_SLONG
case|:
block|{
name|uint32
name|v32
init|=
name|TIFFExtractData
argument_list|(
name|tif
argument_list|,
name|dp
operator|->
name|tdir_type
argument_list|,
name|dp
operator|->
name|tdir_offset
argument_list|)
decl_stmt|;
name|ok
operator|=
operator|(
name|fip
operator|->
name|field_passcount
condition|?
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|dp
operator|->
name|tdir_tag
argument_list|,
literal|1
argument_list|,
operator|&
name|v32
argument_list|)
else|:
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|dp
operator|->
name|tdir_tag
argument_list|,
name|v32
argument_list|)
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|TIFF_RATIONAL
case|:
case|case
name|TIFF_SRATIONAL
case|:
case|case
name|TIFF_FLOAT
case|:
block|{
name|float
name|v
init|=
operator|(
name|dp
operator|->
name|tdir_type
operator|==
name|TIFF_FLOAT
condition|?
name|TIFFFetchFloat
argument_list|(
name|tif
argument_list|,
name|dp
argument_list|)
else|:
name|TIFFFetchRational
argument_list|(
name|tif
argument_list|,
name|dp
argument_list|)
operator|)
decl_stmt|;
name|ok
operator|=
operator|(
name|fip
operator|->
name|field_passcount
condition|?
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|dp
operator|->
name|tdir_tag
argument_list|,
literal|1
argument_list|,
operator|&
name|v
argument_list|)
else|:
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|dp
operator|->
name|tdir_tag
argument_list|,
name|v
argument_list|)
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|TIFF_DOUBLE
case|:
block|{
name|double
name|v
decl_stmt|;
name|ok
operator|=
operator|(
name|TIFFFetchDoubleArray
argument_list|(
name|tif
argument_list|,
name|dp
argument_list|,
operator|&
name|v
argument_list|)
operator|&&
operator|(
name|fip
operator|->
name|field_passcount
condition|?
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|dp
operator|->
name|tdir_tag
argument_list|,
literal|1
argument_list|,
operator|&
name|v
argument_list|)
else|:
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|dp
operator|->
name|tdir_tag
argument_list|,
name|v
argument_list|)
operator|)
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|TIFF_ASCII
case|:
case|case
name|TIFF_UNDEFINED
case|:
comment|/* bit of a cheat... */
block|{
name|char
name|c
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|ok
operator|=
operator|(
name|TIFFFetchString
argument_list|(
name|tif
argument_list|,
name|dp
argument_list|,
name|c
argument_list|)
operator|!=
literal|0
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|c
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* XXX paranoid */
name|ok
operator|=
operator|(
name|fip
operator|->
name|field_passcount
condition|?
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|dp
operator|->
name|tdir_tag
argument_list|,
literal|1
argument_list|,
name|c
argument_list|)
else|:
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|dp
operator|->
name|tdir_tag
argument_list|,
name|c
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
return|return
operator|(
name|ok
operator|)
return|;
block|}
end_function
begin_define
DECL|macro|NITEMS
define|#
directive|define
name|NITEMS
parameter_list|(
name|x
parameter_list|)
value|(sizeof (x) / sizeof (x[0]))
end_define
begin_comment
comment|/*  * Fetch samples/pixel short values for   * the specified tag and verify that  * all values are the same.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|TIFFFetchPerSampleShorts
name|TIFFFetchPerSampleShorts
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|TIFFDirEntry
modifier|*
name|dir
parameter_list|,
name|uint16
modifier|*
name|pl
parameter_list|)
block|{
name|uint16
name|samples
init|=
name|tif
operator|->
name|tif_dir
operator|.
name|td_samplesperpixel
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|CheckDirCount
argument_list|(
name|tif
argument_list|,
name|dir
argument_list|,
operator|(
name|uint32
operator|)
name|samples
argument_list|)
condition|)
block|{
name|uint16
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|uint16
modifier|*
name|v
init|=
name|buf
decl_stmt|;
if|if
condition|(
name|dir
operator|->
name|tdir_count
operator|>
name|NITEMS
argument_list|(
name|buf
argument_list|)
condition|)
name|v
operator|=
operator|(
name|uint16
operator|*
operator|)
name|_TIFFCheckMalloc
argument_list|(
name|tif
argument_list|,
name|dir
operator|->
name|tdir_count
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
argument_list|,
literal|"to fetch per-sample values"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&&
name|TIFFFetchShortArray
argument_list|(
name|tif
argument_list|,
name|dir
argument_list|,
name|v
argument_list|)
condition|)
block|{
name|uint16
name|i
decl_stmt|;
name|int
name|check_count
init|=
name|dir
operator|->
name|tdir_count
decl_stmt|;
if|if
condition|(
name|samples
operator|<
name|check_count
condition|)
name|check_count
operator|=
name|samples
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|check_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|v
index|[
name|i
index|]
operator|!=
name|v
index|[
literal|0
index|]
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"Cannot handle different per-sample values for field \"%s\""
argument_list|,
name|_TIFFFieldWithTag
argument_list|(
name|tif
argument_list|,
name|dir
operator|->
name|tdir_tag
argument_list|)
operator|->
name|field_name
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
operator|*
name|pl
operator|=
name|v
index|[
literal|0
index|]
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
block|}
name|bad
label|:
if|if
condition|(
name|v
operator|&&
name|v
operator|!=
name|buf
condition|)
name|_TIFFfree
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Fetch samples/pixel long values for   * the specified tag and verify that  * all values are the same.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|TIFFFetchPerSampleLongs
name|TIFFFetchPerSampleLongs
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|TIFFDirEntry
modifier|*
name|dir
parameter_list|,
name|uint32
modifier|*
name|pl
parameter_list|)
block|{
name|uint16
name|samples
init|=
name|tif
operator|->
name|tif_dir
operator|.
name|td_samplesperpixel
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|CheckDirCount
argument_list|(
name|tif
argument_list|,
name|dir
argument_list|,
operator|(
name|uint32
operator|)
name|samples
argument_list|)
condition|)
block|{
name|uint32
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|uint32
modifier|*
name|v
init|=
name|buf
decl_stmt|;
if|if
condition|(
name|dir
operator|->
name|tdir_count
operator|>
name|NITEMS
argument_list|(
name|buf
argument_list|)
condition|)
name|v
operator|=
operator|(
name|uint32
operator|*
operator|)
name|_TIFFCheckMalloc
argument_list|(
name|tif
argument_list|,
name|dir
operator|->
name|tdir_count
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32
argument_list|)
argument_list|,
literal|"to fetch per-sample values"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&&
name|TIFFFetchLongArray
argument_list|(
name|tif
argument_list|,
name|dir
argument_list|,
name|v
argument_list|)
condition|)
block|{
name|uint16
name|i
decl_stmt|;
name|int
name|check_count
init|=
name|dir
operator|->
name|tdir_count
decl_stmt|;
if|if
condition|(
name|samples
operator|<
name|check_count
condition|)
name|check_count
operator|=
name|samples
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|check_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|v
index|[
name|i
index|]
operator|!=
name|v
index|[
literal|0
index|]
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"Cannot handle different per-sample values for field \"%s\""
argument_list|,
name|_TIFFFieldWithTag
argument_list|(
name|tif
argument_list|,
name|dir
operator|->
name|tdir_tag
argument_list|)
operator|->
name|field_name
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
operator|*
name|pl
operator|=
name|v
index|[
literal|0
index|]
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
block|}
name|bad
label|:
if|if
condition|(
name|v
operator|&&
name|v
operator|!=
name|buf
condition|)
name|_TIFFfree
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Fetch samples/pixel ANY values for the specified tag and verify that all  * values are the same.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|TIFFFetchPerSampleAnys
name|TIFFFetchPerSampleAnys
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|TIFFDirEntry
modifier|*
name|dir
parameter_list|,
name|double
modifier|*
name|pl
parameter_list|)
block|{
name|uint16
name|samples
init|=
name|tif
operator|->
name|tif_dir
operator|.
name|td_samplesperpixel
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|CheckDirCount
argument_list|(
name|tif
argument_list|,
name|dir
argument_list|,
operator|(
name|uint32
operator|)
name|samples
argument_list|)
condition|)
block|{
name|double
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|double
modifier|*
name|v
init|=
name|buf
decl_stmt|;
if|if
condition|(
name|dir
operator|->
name|tdir_count
operator|>
name|NITEMS
argument_list|(
name|buf
argument_list|)
condition|)
name|v
operator|=
operator|(
name|double
operator|*
operator|)
name|_TIFFCheckMalloc
argument_list|(
name|tif
argument_list|,
name|dir
operator|->
name|tdir_count
argument_list|,
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|,
literal|"to fetch per-sample values"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&&
name|TIFFFetchAnyArray
argument_list|(
name|tif
argument_list|,
name|dir
argument_list|,
name|v
argument_list|)
condition|)
block|{
name|uint16
name|i
decl_stmt|;
name|int
name|check_count
init|=
name|dir
operator|->
name|tdir_count
decl_stmt|;
if|if
condition|(
name|samples
operator|<
name|check_count
condition|)
name|check_count
operator|=
name|samples
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|check_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|v
index|[
name|i
index|]
operator|!=
name|v
index|[
literal|0
index|]
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"Cannot handle different per-sample values for field \"%s\""
argument_list|,
name|_TIFFFieldWithTag
argument_list|(
name|tif
argument_list|,
name|dir
operator|->
name|tdir_tag
argument_list|)
operator|->
name|field_name
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
operator|*
name|pl
operator|=
name|v
index|[
literal|0
index|]
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
block|}
name|bad
label|:
if|if
condition|(
name|v
operator|&&
name|v
operator|!=
name|buf
condition|)
name|_TIFFfree
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function
begin_undef
DECL|macro|NITEMS
undef|#
directive|undef
name|NITEMS
end_undef
begin_comment
comment|/*  * Fetch a set of offsets or lengths.  * While this routine says "strips", in fact it's also used for tiles.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|TIFFFetchStripThing
name|TIFFFetchStripThing
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|TIFFDirEntry
modifier|*
name|dir
parameter_list|,
name|long
name|nstrips
parameter_list|,
name|uint32
modifier|*
modifier|*
name|lpp
parameter_list|)
block|{
specifier|register
name|uint32
modifier|*
name|lp
decl_stmt|;
name|int
name|status
decl_stmt|;
name|CheckDirCount
argument_list|(
name|tif
argument_list|,
name|dir
argument_list|,
operator|(
name|uint32
operator|)
name|nstrips
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate space for strip information. 	 */
if|if
condition|(
operator|*
name|lpp
operator|==
name|NULL
operator|&&
operator|(
operator|*
name|lpp
operator|=
operator|(
name|uint32
operator|*
operator|)
name|_TIFFCheckMalloc
argument_list|(
name|tif
argument_list|,
name|nstrips
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32
argument_list|)
argument_list|,
literal|"for strip array"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|lp
operator|=
operator|*
name|lpp
expr_stmt|;
name|_TIFFmemset
argument_list|(
name|lp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32
argument_list|)
operator|*
name|nstrips
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|->
name|tdir_type
operator|==
operator|(
name|int
operator|)
name|TIFF_SHORT
condition|)
block|{
comment|/* 		 * Handle uint16->uint32 expansion. 		 */
name|uint16
modifier|*
name|dp
init|=
operator|(
name|uint16
operator|*
operator|)
name|_TIFFCheckMalloc
argument_list|(
name|tif
argument_list|,
name|dir
operator|->
name|tdir_count
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
argument_list|,
literal|"to fetch strip tag"
argument_list|)
decl_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|status
operator|=
name|TIFFFetchShortArray
argument_list|(
name|tif
argument_list|,
name|dir
argument_list|,
name|dp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nstrips
operator|&&
name|i
operator|<
operator|(
name|int
operator|)
name|dir
operator|->
name|tdir_count
condition|;
name|i
operator|++
control|)
block|{
name|lp
index|[
name|i
index|]
operator|=
name|dp
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|_TIFFfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nstrips
operator|!=
operator|(
name|int
operator|)
name|dir
operator|->
name|tdir_count
condition|)
block|{
comment|/* Special case to correct length */
name|uint32
modifier|*
name|dp
init|=
operator|(
name|uint32
operator|*
operator|)
name|_TIFFCheckMalloc
argument_list|(
name|tif
argument_list|,
name|dir
operator|->
name|tdir_count
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32
argument_list|)
argument_list|,
literal|"to fetch strip tag"
argument_list|)
decl_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|status
operator|=
name|TIFFFetchLongArray
argument_list|(
name|tif
argument_list|,
name|dir
argument_list|,
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nstrips
operator|&&
name|i
operator|<
operator|(
name|int
operator|)
name|dir
operator|->
name|tdir_count
condition|;
name|i
operator|++
control|)
block|{
name|lp
index|[
name|i
index|]
operator|=
name|dp
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|_TIFFfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
argument_list|)
expr_stmt|;
block|}
else|else
name|status
operator|=
name|TIFFFetchLongArray
argument_list|(
name|tif
argument_list|,
name|dir
argument_list|,
name|lp
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Fetch and set the RefBlackWhite tag.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|TIFFFetchRefBlackWhite
name|TIFFFetchRefBlackWhite
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|TIFFDirEntry
modifier|*
name|dir
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|mesg
index|[]
init|=
literal|"for \"ReferenceBlackWhite\" array"
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|ok
decl_stmt|;
if|if
condition|(
name|dir
operator|->
name|tdir_type
operator|==
name|TIFF_RATIONAL
condition|)
return|return
operator|(
name|TIFFFetchNormalTag
argument_list|(
name|tif
argument_list|,
name|dir
argument_list|)
operator|)
return|;
comment|/* 	 * Handle LONG's for backward compatibility. 	 */
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|_TIFFCheckMalloc
argument_list|(
name|tif
argument_list|,
name|dir
operator|->
name|tdir_count
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32
argument_list|)
argument_list|,
name|mesg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ok
operator|=
operator|(
name|cp
operator|&&
name|TIFFFetchLongArray
argument_list|(
name|tif
argument_list|,
name|dir
argument_list|,
operator|(
name|uint32
operator|*
operator|)
name|cp
argument_list|)
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|float
modifier|*
name|fp
init|=
operator|(
name|float
operator|*
operator|)
name|_TIFFCheckMalloc
argument_list|(
name|tif
argument_list|,
name|dir
operator|->
name|tdir_count
argument_list|,
sizeof|sizeof
argument_list|(
name|float
argument_list|)
argument_list|,
name|mesg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|ok
operator|=
operator|(
name|fp
operator|!=
name|NULL
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|uint32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dir
operator|->
name|tdir_count
condition|;
name|i
operator|++
control|)
name|fp
index|[
name|i
index|]
operator|=
call|(
name|float
call|)
argument_list|(
operator|(
name|uint32
operator|*
operator|)
name|cp
argument_list|)
index|[
name|i
index|]
expr_stmt|;
name|ok
operator|=
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|dir
operator|->
name|tdir_tag
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|_TIFFfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cp
condition|)
name|_TIFFfree
argument_list|(
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ok
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Fetch and set the SubjectDistance EXIF tag.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|TIFFFetchSubjectDistance
name|TIFFFetchSubjectDistance
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|TIFFDirEntry
modifier|*
name|dir
parameter_list|)
block|{
name|uint32
name|l
index|[
literal|2
index|]
decl_stmt|;
name|float
name|v
decl_stmt|;
name|int
name|ok
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TIFFFetchData
argument_list|(
name|tif
argument_list|,
name|dir
argument_list|,
operator|(
name|char
operator|*
operator|)
name|l
argument_list|)
operator|&&
name|cvtRational
argument_list|(
name|tif
argument_list|,
name|dir
argument_list|,
name|l
index|[
literal|0
index|]
argument_list|,
name|l
index|[
literal|1
index|]
argument_list|,
operator|&
name|v
argument_list|)
condition|)
block|{
comment|/* 		 * XXX: Numerator 0xFFFFFFFF means that we have infinite 		 * distance. Indicate that with a negative floating point 		 * SubjectDistance value. 		 */
name|ok
operator|=
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|dir
operator|->
name|tdir_tag
argument_list|,
operator|(
name|l
index|[
literal|0
index|]
operator|!=
literal|0xFFFFFFFF
operator|)
condition|?
name|v
else|:
operator|-
name|v
argument_list|)
expr_stmt|;
block|}
return|return
name|ok
return|;
block|}
end_function
begin_comment
comment|/*  * Replace a single strip (tile) of uncompressed data by multiple strips  * (tiles), each approximately STRIP_SIZE_DEFAULT bytes. This is useful for  * dealing with large images or for dealing with machines with a limited  * amount memory.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|ChopUpSingleUncompressedStrip
name|ChopUpSingleUncompressedStrip
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
specifier|register
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|uint32
name|bytecount
init|=
name|td
operator|->
name|td_stripbytecount
index|[
literal|0
index|]
decl_stmt|;
name|uint32
name|offset
init|=
name|td
operator|->
name|td_stripoffset
index|[
literal|0
index|]
decl_stmt|;
name|tsize_t
name|rowbytes
init|=
name|TIFFVTileSize
argument_list|(
name|tif
argument_list|,
literal|1
argument_list|)
decl_stmt|,
name|stripbytes
decl_stmt|;
name|tstrip_t
name|strip
decl_stmt|,
name|nstrips
decl_stmt|,
name|rowsperstrip
decl_stmt|;
name|uint32
modifier|*
name|newcounts
decl_stmt|;
name|uint32
modifier|*
name|newoffsets
decl_stmt|;
comment|/* 	 * Make the rows hold at least one scanline, but fill specified amount 	 * of data if possible. 	 */
if|if
condition|(
name|rowbytes
operator|>
name|STRIP_SIZE_DEFAULT
condition|)
block|{
name|stripbytes
operator|=
name|rowbytes
expr_stmt|;
name|rowsperstrip
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rowbytes
operator|>
literal|0
condition|)
block|{
name|rowsperstrip
operator|=
name|STRIP_SIZE_DEFAULT
operator|/
name|rowbytes
expr_stmt|;
name|stripbytes
operator|=
name|rowbytes
operator|*
name|rowsperstrip
expr_stmt|;
block|}
else|else
return|return;
comment|/*  	 * never increase the number of strips in an image 	 */
if|if
condition|(
name|rowsperstrip
operator|>=
name|td
operator|->
name|td_rowsperstrip
condition|)
return|return;
name|nstrips
operator|=
operator|(
name|tstrip_t
operator|)
name|TIFFhowmany
argument_list|(
name|bytecount
argument_list|,
name|stripbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|nstrips
operator|==
literal|0
condition|)
comment|/* something is wonky, do nothing. */
return|return;
name|newcounts
operator|=
operator|(
name|uint32
operator|*
operator|)
name|_TIFFCheckMalloc
argument_list|(
name|tif
argument_list|,
name|nstrips
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32
argument_list|)
argument_list|,
literal|"for chopped \"StripByteCounts\" array"
argument_list|)
expr_stmt|;
name|newoffsets
operator|=
operator|(
name|uint32
operator|*
operator|)
name|_TIFFCheckMalloc
argument_list|(
name|tif
argument_list|,
name|nstrips
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32
argument_list|)
argument_list|,
literal|"for chopped \"StripOffsets\" array"
argument_list|)
expr_stmt|;
if|if
condition|(
name|newcounts
operator|==
name|NULL
operator|||
name|newoffsets
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Unable to allocate new strip information, give up and use 		 * the original one strip information. 		 */
if|if
condition|(
name|newcounts
operator|!=
name|NULL
condition|)
name|_TIFFfree
argument_list|(
name|newcounts
argument_list|)
expr_stmt|;
if|if
condition|(
name|newoffsets
operator|!=
name|NULL
condition|)
name|_TIFFfree
argument_list|(
name|newoffsets
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Fill the strip information arrays with new bytecounts and offsets 	 * that reflect the broken-up format. 	 */
for|for
control|(
name|strip
operator|=
literal|0
init|;
name|strip
operator|<
name|nstrips
condition|;
name|strip
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|uint32
operator|)
name|stripbytes
operator|>
name|bytecount
condition|)
name|stripbytes
operator|=
name|bytecount
expr_stmt|;
name|newcounts
index|[
name|strip
index|]
operator|=
name|stripbytes
expr_stmt|;
name|newoffsets
index|[
name|strip
index|]
operator|=
name|offset
expr_stmt|;
name|offset
operator|+=
name|stripbytes
expr_stmt|;
name|bytecount
operator|-=
name|stripbytes
expr_stmt|;
block|}
comment|/* 	 * Replace old single strip info with multi-strip info. 	 */
name|td
operator|->
name|td_stripsperimage
operator|=
name|td
operator|->
name|td_nstrips
operator|=
name|nstrips
expr_stmt|;
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_ROWSPERSTRIP
argument_list|,
name|rowsperstrip
argument_list|)
expr_stmt|;
name|_TIFFfree
argument_list|(
name|td
operator|->
name|td_stripbytecount
argument_list|)
expr_stmt|;
name|_TIFFfree
argument_list|(
name|td
operator|->
name|td_stripoffset
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_stripbytecount
operator|=
name|newcounts
expr_stmt|;
name|td
operator|->
name|td_stripoffset
operator|=
name|newoffsets
expr_stmt|;
name|td
operator|->
name|td_stripbytecountsorted
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_comment
comment|/* vim: set ts=8 sts=8 sw=8 noet: */
end_comment
end_unit
