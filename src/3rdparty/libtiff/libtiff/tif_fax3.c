begin_unit
begin_comment
comment|/* $Id: tif_fax3.c,v 1.43.2.5 2009-01-01 00:10:43 bfriesen Exp $ */
end_comment
begin_comment
comment|/*  * Copyright (c) 1990-1997 Sam Leffler  * Copyright (c) 1991-1997 Silicon Graphics, Inc.  *  * Permission to use, copy, modify, distribute, and sell this software and   * its documentation for any purpose is hereby granted without fee, provided  * that (i) the above copyright notices and this permission notice appear in  * all copies of the software and related documentation, and (ii) the names of  * Sam Leffler and Silicon Graphics may not be used in any advertising or  * publicity relating to the software without the specific, prior written  * permission of Sam Leffler and Silicon Graphics.  *   * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,   * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY   * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.    *   * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR  * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,  * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF   * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE   * OF THIS SOFTWARE.  */
end_comment
begin_include
include|#
directive|include
file|"tiffiop.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|CCITT_SUPPORT
end_ifdef
begin_comment
comment|/*  * TIFF Library.  *  * CCITT Group 3 (T.4) and Group 4 (T.6) Compression Support.  *  * This file contains support for decoding and encoding TIFF  * compression algorithms 2, 3, 4, and 32771.  *  * Decoder support is derived, with permission, from the code  * in Frank Cringle's viewfax program;  *      Copyright (C) 1990, 1995  Frank D. Cringle.  */
end_comment
begin_include
include|#
directive|include
file|"tif_fax3.h"
end_include
begin_define
DECL|macro|G3CODES
define|#
directive|define
name|G3CODES
end_define
begin_include
include|#
directive|include
file|"t4.h"
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_comment
comment|/*  * Compression+decompression state blocks are  * derived from this ``base state'' block.  */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|rw_mode
name|int
name|rw_mode
decl_stmt|;
comment|/* O_RDONLY for decode, else encode */
DECL|member|mode
name|int
name|mode
decl_stmt|;
comment|/* operating mode */
DECL|member|rowbytes
name|uint32
name|rowbytes
decl_stmt|;
comment|/* bytes in a decoded scanline */
DECL|member|rowpixels
name|uint32
name|rowpixels
decl_stmt|;
comment|/* pixels in a scanline */
DECL|member|cleanfaxdata
name|uint16
name|cleanfaxdata
decl_stmt|;
comment|/* CleanFaxData tag */
DECL|member|badfaxrun
name|uint32
name|badfaxrun
decl_stmt|;
comment|/* BadFaxRun tag */
DECL|member|badfaxlines
name|uint32
name|badfaxlines
decl_stmt|;
comment|/* BadFaxLines tag */
DECL|member|groupoptions
name|uint32
name|groupoptions
decl_stmt|;
comment|/* Group 3/4 options tag */
DECL|member|recvparams
name|uint32
name|recvparams
decl_stmt|;
comment|/* encoded Class 2 session params */
DECL|member|subaddress
name|char
modifier|*
name|subaddress
decl_stmt|;
comment|/* subaddress string */
DECL|member|recvtime
name|uint32
name|recvtime
decl_stmt|;
comment|/* time spent receiving (secs) */
DECL|member|faxdcs
name|char
modifier|*
name|faxdcs
decl_stmt|;
comment|/* Table 2/T.30 encoded session params */
DECL|member|vgetparent
name|TIFFVGetMethod
name|vgetparent
decl_stmt|;
comment|/* super-class method */
DECL|member|vsetparent
name|TIFFVSetMethod
name|vsetparent
decl_stmt|;
comment|/* super-class method */
DECL|member|printdir
name|TIFFPrintMethod
name|printdir
decl_stmt|;
comment|/* super-class method */
block|}
DECL|typedef|Fax3BaseState
name|Fax3BaseState
typedef|;
end_typedef
begin_define
DECL|macro|Fax3State
define|#
directive|define
name|Fax3State
parameter_list|(
name|tif
parameter_list|)
value|((Fax3BaseState*) (tif)->tif_data)
end_define
begin_typedef
DECL|enumerator|G3_1D
DECL|enumerator|G3_2D
DECL|typedef|Ttag
typedef|typedef
enum|enum
block|{
name|G3_1D
block|,
name|G3_2D
block|}
name|Ttag
typedef|;
end_typedef
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|b
name|Fax3BaseState
name|b
decl_stmt|;
comment|/* Decoder state info */
DECL|member|bitmap
specifier|const
name|unsigned
name|char
modifier|*
name|bitmap
decl_stmt|;
comment|/* bit reversal table */
DECL|member|data
name|uint32
name|data
decl_stmt|;
comment|/* current i/o byte/word */
DECL|member|bit
name|int
name|bit
decl_stmt|;
comment|/* current i/o bit in byte */
DECL|member|EOLcnt
name|int
name|EOLcnt
decl_stmt|;
comment|/* count of EOL codes recognized */
DECL|member|fill
name|TIFFFaxFillFunc
name|fill
decl_stmt|;
comment|/* fill routine */
DECL|member|runs
name|uint32
modifier|*
name|runs
decl_stmt|;
comment|/* b&w runs for current/previous row */
DECL|member|refruns
name|uint32
modifier|*
name|refruns
decl_stmt|;
comment|/* runs for reference line */
DECL|member|curruns
name|uint32
modifier|*
name|curruns
decl_stmt|;
comment|/* runs for current line */
comment|/* Encoder state info */
DECL|member|tag
name|Ttag
name|tag
decl_stmt|;
comment|/* encoding state */
DECL|member|refline
name|unsigned
name|char
modifier|*
name|refline
decl_stmt|;
comment|/* reference line for 2d decoding */
DECL|member|k
name|int
name|k
decl_stmt|;
comment|/* #rows left that can be 2d encoded */
DECL|member|maxk
name|int
name|maxk
decl_stmt|;
comment|/* max #rows that can be 2d encoded */
DECL|member|line
name|int
name|line
decl_stmt|;
block|}
DECL|typedef|Fax3CodecState
name|Fax3CodecState
typedef|;
end_typedef
begin_define
DECL|macro|DecoderState
define|#
directive|define
name|DecoderState
parameter_list|(
name|tif
parameter_list|)
value|((Fax3CodecState*) Fax3State(tif))
end_define
begin_define
DECL|macro|EncoderState
define|#
directive|define
name|EncoderState
parameter_list|(
name|tif
parameter_list|)
value|((Fax3CodecState*) Fax3State(tif))
end_define
begin_define
DECL|macro|is2DEncoding
define|#
directive|define
name|is2DEncoding
parameter_list|(
name|sp
parameter_list|)
define|\
value|(sp->b.groupoptions& GROUP3OPT_2DENCODING)
end_define
begin_define
DECL|macro|isAligned
define|#
directive|define
name|isAligned
parameter_list|(
name|p
parameter_list|,
name|t
parameter_list|)
value|((((unsigned long)(p))& (sizeof (t)-1)) == 0)
end_define
begin_comment
comment|/*  * Group 3 and Group 4 Decoding.  */
end_comment
begin_comment
comment|/*  * These macros glue the TIFF library state to  * the state expected by Frank's decoder.  */
end_comment
begin_define
DECL|macro|DECLARE_STATE
define|#
directive|define
name|DECLARE_STATE
parameter_list|(
name|tif
parameter_list|,
name|sp
parameter_list|,
name|mod
parameter_list|)
define|\
value|static const char module[] = mod;					\     Fax3CodecState* sp = DecoderState(tif);				\     int a0;
comment|/* reference element */
value|\     int lastx = sp->b.rowpixels;
comment|/* last element in row */
value|\     uint32 BitAcc;
comment|/* bit accumulator */
value|\     int BitsAvail;
comment|/* # valid bits in BitAcc */
value|\     int RunLength;
comment|/* length of current run */
value|\     unsigned char* cp;
comment|/* next byte of input data */
value|\     unsigned char* ep;
comment|/* end of input data */
value|\     uint32* pa;
comment|/* place to stuff next run */
value|\     uint32* thisrun;
comment|/* current row's run array */
value|\     int EOLcnt;
comment|/* # EOL codes recognized */
value|\     const unsigned char* bitmap = sp->bitmap;
comment|/* input data bit reverser */
value|\     const TIFFFaxTabEnt* TabEnt
end_define
begin_define
DECL|macro|DECLARE_STATE_2D
define|#
directive|define
name|DECLARE_STATE_2D
parameter_list|(
name|tif
parameter_list|,
name|sp
parameter_list|,
name|mod
parameter_list|)
define|\
value|DECLARE_STATE(tif, sp, mod);					\     int b1;
comment|/* next change on prev line */
value|\     uint32* pb
end_define
begin_comment
comment|/* next run in reference line */
end_comment
begin_comment
unit|\
comment|/*  * Load any state that may be changed during decoding.  */
end_comment
begin_define
DECL|macro|CACHE_STATE
define|#
directive|define
name|CACHE_STATE
parameter_list|(
name|tif
parameter_list|,
name|sp
parameter_list|)
value|do {					\     BitAcc = sp->data;							\     BitsAvail = sp->bit;						\     EOLcnt = sp->EOLcnt;						\     cp = (unsigned char*) tif->tif_rawcp;				\     ep = cp + tif->tif_rawcc;						\ } while (0)
end_define
begin_comment
comment|/*  * Save state possibly changed during decoding.  */
end_comment
begin_define
DECL|macro|UNCACHE_STATE
define|#
directive|define
name|UNCACHE_STATE
parameter_list|(
name|tif
parameter_list|,
name|sp
parameter_list|)
value|do {					\     sp->bit = BitsAvail;						\     sp->data = BitAcc;							\     sp->EOLcnt = EOLcnt;						\     tif->tif_rawcc -= (tidata_t) cp - tif->tif_rawcp;			\     tif->tif_rawcp = (tidata_t) cp;					\ } while (0)
end_define
begin_comment
comment|/*  * Setup state for decoding a strip.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|Fax3PreDecode
name|Fax3PreDecode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|Fax3CodecState
modifier|*
name|sp
init|=
name|DecoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|s
expr_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sp
operator|->
name|bit
operator|=
literal|0
expr_stmt|;
comment|/* force initial read */
name|sp
operator|->
name|data
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|EOLcnt
operator|=
literal|0
expr_stmt|;
comment|/* force initial scan for EOL */
comment|/* 	 * Decoder assumes lsb-to-msb bit order.  Note that we select 	 * this here rather than in Fax3SetupState so that viewers can 	 * hold the image open, fiddle with the FillOrder tag value, 	 * and then re-decode the image.  Otherwise they'd need to close 	 * and open the image to get the state reset. 	 */
name|sp
operator|->
name|bitmap
operator|=
name|TIFFGetBitRevTable
argument_list|(
name|tif
operator|->
name|tif_dir
operator|.
name|td_fillorder
operator|!=
name|FILLORDER_LSB2MSB
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|refruns
condition|)
block|{
comment|/* init reference line to white */
name|sp
operator|->
name|refruns
index|[
literal|0
index|]
operator|=
operator|(
name|uint32
operator|)
name|sp
operator|->
name|b
operator|.
name|rowpixels
expr_stmt|;
name|sp
operator|->
name|refruns
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|sp
operator|->
name|line
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Routine for handling various errors/conditions.  * Note how they are "glued into the decoder" by  * overriding the definitions used by the decoder.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|Fax3Unexpected
name|Fax3Unexpected
parameter_list|(
specifier|const
name|char
modifier|*
name|module
parameter_list|,
name|TIFF
modifier|*
name|tif
parameter_list|,
name|uint32
name|line
parameter_list|,
name|uint32
name|a0
parameter_list|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Bad code word at line %u of %s %u (x %u)"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
name|line
argument_list|,
name|isTiled
argument_list|(
name|tif
argument_list|)
condition|?
literal|"tile"
else|:
literal|"strip"
argument_list|,
operator|(
name|isTiled
argument_list|(
name|tif
argument_list|)
condition|?
name|tif
operator|->
name|tif_curtile
else|:
name|tif
operator|->
name|tif_curstrip
operator|)
argument_list|,
name|a0
argument_list|)
expr_stmt|;
block|}
end_function
begin_define
DECL|macro|unexpected
define|#
directive|define
name|unexpected
parameter_list|(
name|table
parameter_list|,
name|a0
parameter_list|)
value|Fax3Unexpected(module, tif, sp->line, a0)
end_define
begin_function
specifier|static
name|void
DECL|function|Fax3Extension
name|Fax3Extension
parameter_list|(
specifier|const
name|char
modifier|*
name|module
parameter_list|,
name|TIFF
modifier|*
name|tif
parameter_list|,
name|uint32
name|line
parameter_list|,
name|uint32
name|a0
parameter_list|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Uncompressed data (not supported) at line %u of %s %u (x %u)"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
name|line
argument_list|,
name|isTiled
argument_list|(
name|tif
argument_list|)
condition|?
literal|"tile"
else|:
literal|"strip"
argument_list|,
operator|(
name|isTiled
argument_list|(
name|tif
argument_list|)
condition|?
name|tif
operator|->
name|tif_curtile
else|:
name|tif
operator|->
name|tif_curstrip
operator|)
argument_list|,
name|a0
argument_list|)
expr_stmt|;
block|}
end_function
begin_define
DECL|macro|extension
define|#
directive|define
name|extension
parameter_list|(
name|a0
parameter_list|)
value|Fax3Extension(module, tif, sp->line, a0)
end_define
begin_function
specifier|static
name|void
DECL|function|Fax3BadLength
name|Fax3BadLength
parameter_list|(
specifier|const
name|char
modifier|*
name|module
parameter_list|,
name|TIFF
modifier|*
name|tif
parameter_list|,
name|uint32
name|line
parameter_list|,
name|uint32
name|a0
parameter_list|,
name|uint32
name|lastx
parameter_list|)
block|{
name|TIFFWarningExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: %s at line %u of %s %u (got %u, expected %u)"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
name|a0
operator|<
name|lastx
condition|?
literal|"Premature EOL"
else|:
literal|"Line length mismatch"
argument_list|,
name|line
argument_list|,
name|isTiled
argument_list|(
name|tif
argument_list|)
condition|?
literal|"tile"
else|:
literal|"strip"
argument_list|,
operator|(
name|isTiled
argument_list|(
name|tif
argument_list|)
condition|?
name|tif
operator|->
name|tif_curtile
else|:
name|tif
operator|->
name|tif_curstrip
operator|)
argument_list|,
name|a0
argument_list|,
name|lastx
argument_list|)
expr_stmt|;
block|}
end_function
begin_define
DECL|macro|badlength
define|#
directive|define
name|badlength
parameter_list|(
name|a0
parameter_list|,
name|lastx
parameter_list|)
value|Fax3BadLength(module, tif, sp->line, a0, lastx)
end_define
begin_function
specifier|static
name|void
DECL|function|Fax3PrematureEOF
name|Fax3PrematureEOF
parameter_list|(
specifier|const
name|char
modifier|*
name|module
parameter_list|,
name|TIFF
modifier|*
name|tif
parameter_list|,
name|uint32
name|line
parameter_list|,
name|uint32
name|a0
parameter_list|)
block|{
name|TIFFWarningExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Premature EOF at line %u of %s %u (x %u)"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
name|line
argument_list|,
name|isTiled
argument_list|(
name|tif
argument_list|)
condition|?
literal|"tile"
else|:
literal|"strip"
argument_list|,
operator|(
name|isTiled
argument_list|(
name|tif
argument_list|)
condition|?
name|tif
operator|->
name|tif_curtile
else|:
name|tif
operator|->
name|tif_curstrip
operator|)
argument_list|,
name|a0
argument_list|)
expr_stmt|;
block|}
end_function
begin_define
DECL|macro|prematureEOF
define|#
directive|define
name|prematureEOF
parameter_list|(
name|a0
parameter_list|)
value|Fax3PrematureEOF(module, tif, sp->line, a0)
end_define
begin_define
DECL|macro|Nop
define|#
directive|define
name|Nop
end_define
begin_comment
comment|/*  * Decode the requested amount of G3 1D-encoded data.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|Fax3Decode1D
name|Fax3Decode1D
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|buf
parameter_list|,
name|tsize_t
name|occ
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|DECLARE_STATE
argument_list|(
name|tif
argument_list|,
name|sp
argument_list|,
literal|"Fax3Decode1D"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|s
expr_stmt|;
name|CACHE_STATE
argument_list|(
name|tif
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|thisrun
operator|=
name|sp
operator|->
name|curruns
expr_stmt|;
while|while
condition|(
operator|(
name|long
operator|)
name|occ
operator|>
literal|0
condition|)
block|{
name|a0
operator|=
literal|0
expr_stmt|;
name|RunLength
operator|=
literal|0
expr_stmt|;
name|pa
operator|=
name|thisrun
expr_stmt|;
ifdef|#
directive|ifdef
name|FAX3_DEBUG
name|printf
argument_list|(
literal|"\nBitAcc=%08X, BitsAvail = %d\n"
argument_list|,
name|BitAcc
argument_list|,
name|BitsAvail
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-------------------- %d\n"
argument_list|,
name|tif
operator|->
name|tif_row
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SYNC_EOL
argument_list|(
name|EOF1D
argument_list|)
expr_stmt|;
name|EXPAND1D
argument_list|(
name|EOF1Da
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sp
operator|->
name|fill
call|)
argument_list|(
name|buf
argument_list|,
name|thisrun
argument_list|,
name|pa
argument_list|,
name|lastx
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|sp
operator|->
name|b
operator|.
name|rowbytes
expr_stmt|;
name|occ
operator|-=
name|sp
operator|->
name|b
operator|.
name|rowbytes
expr_stmt|;
name|sp
operator|->
name|line
operator|++
expr_stmt|;
continue|continue;
name|EOF1D
label|:
comment|/* premature EOF */
name|CLEANUP_RUNS
argument_list|()
expr_stmt|;
name|EOF1Da
label|:
comment|/* premature EOF */
call|(
modifier|*
name|sp
operator|->
name|fill
call|)
argument_list|(
name|buf
argument_list|,
name|thisrun
argument_list|,
name|pa
argument_list|,
name|lastx
argument_list|)
expr_stmt|;
name|UNCACHE_STATE
argument_list|(
name|tif
argument_list|,
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|UNCACHE_STATE
argument_list|(
name|tif
argument_list|,
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_define
DECL|macro|SWAP
define|#
directive|define
name|SWAP
parameter_list|(
name|t
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|)
value|{ t x; x = (a); (a) = (b); (b) = x; }
end_define
begin_comment
comment|/*  * Decode the requested amount of G3 2D-encoded data.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|Fax3Decode2D
name|Fax3Decode2D
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|buf
parameter_list|,
name|tsize_t
name|occ
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|DECLARE_STATE_2D
argument_list|(
name|tif
argument_list|,
name|sp
argument_list|,
literal|"Fax3Decode2D"
argument_list|)
expr_stmt|;
name|int
name|is1D
decl_stmt|;
comment|/* current line is 1d/2d-encoded */
operator|(
name|void
operator|)
name|s
expr_stmt|;
name|CACHE_STATE
argument_list|(
name|tif
argument_list|,
name|sp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|long
operator|)
name|occ
operator|>
literal|0
condition|)
block|{
name|a0
operator|=
literal|0
expr_stmt|;
name|RunLength
operator|=
literal|0
expr_stmt|;
name|pa
operator|=
name|thisrun
operator|=
name|sp
operator|->
name|curruns
expr_stmt|;
ifdef|#
directive|ifdef
name|FAX3_DEBUG
name|printf
argument_list|(
literal|"\nBitAcc=%08X, BitsAvail = %d EOLcnt = %d"
argument_list|,
name|BitAcc
argument_list|,
name|BitsAvail
argument_list|,
name|EOLcnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SYNC_EOL
argument_list|(
name|EOF2D
argument_list|)
expr_stmt|;
name|NeedBits8
argument_list|(
literal|1
argument_list|,
name|EOF2D
argument_list|)
expr_stmt|;
name|is1D
operator|=
name|GetBits
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 1D/2D-encoding tag bit */
name|ClrBits
argument_list|(
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FAX3_DEBUG
name|printf
argument_list|(
literal|" %s\n-------------------- %d\n"
argument_list|,
name|is1D
condition|?
literal|"1D"
else|:
literal|"2D"
argument_list|,
name|tif
operator|->
name|tif_row
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pb
operator|=
name|sp
operator|->
name|refruns
expr_stmt|;
name|b1
operator|=
operator|*
name|pb
operator|++
expr_stmt|;
if|if
condition|(
name|is1D
condition|)
name|EXPAND1D
argument_list|(
name|EOF2Da
argument_list|)
expr_stmt|;
else|else
name|EXPAND2D
argument_list|(
name|EOF2Da
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sp
operator|->
name|fill
call|)
argument_list|(
name|buf
argument_list|,
name|thisrun
argument_list|,
name|pa
argument_list|,
name|lastx
argument_list|)
expr_stmt|;
name|SETVALUE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* imaginary change for reference */
name|SWAP
argument_list|(
name|uint32
operator|*
argument_list|,
name|sp
operator|->
name|curruns
argument_list|,
name|sp
operator|->
name|refruns
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|sp
operator|->
name|b
operator|.
name|rowbytes
expr_stmt|;
name|occ
operator|-=
name|sp
operator|->
name|b
operator|.
name|rowbytes
expr_stmt|;
name|sp
operator|->
name|line
operator|++
expr_stmt|;
continue|continue;
name|EOF2D
label|:
comment|/* premature EOF */
name|CLEANUP_RUNS
argument_list|()
expr_stmt|;
name|EOF2Da
label|:
comment|/* premature EOF */
call|(
modifier|*
name|sp
operator|->
name|fill
call|)
argument_list|(
name|buf
argument_list|,
name|thisrun
argument_list|,
name|pa
argument_list|,
name|lastx
argument_list|)
expr_stmt|;
name|UNCACHE_STATE
argument_list|(
name|tif
argument_list|,
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|UNCACHE_STATE
argument_list|(
name|tif
argument_list|,
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_undef
DECL|macro|SWAP
undef|#
directive|undef
name|SWAP
end_undef
begin_comment
comment|/*  * The ZERO& FILL macros must handle spans< 2*sizeof(long) bytes.  * For machines with 64-bit longs this is<16 bytes; otherwise  * this is<8 bytes.  We optimize the code here to reflect the  * machine characteristics.  */
end_comment
begin_if
if|#
directive|if
name|SIZEOF_LONG
operator|==
literal|8
end_if
begin_define
DECL|macro|FILL
define|#
directive|define
name|FILL
parameter_list|(
name|n
parameter_list|,
name|cp
parameter_list|)
define|\
value|switch (n) {							    \     case 15:(cp)[14] = 0xff; case 14:(cp)[13] = 0xff; case 13: (cp)[12] = 0xff;\     case 12:(cp)[11] = 0xff; case 11:(cp)[10] = 0xff; case 10: (cp)[9] = 0xff;\     case  9: (cp)[8] = 0xff; case  8: (cp)[7] = 0xff; case  7: (cp)[6] = 0xff;\     case  6: (cp)[5] = 0xff; case  5: (cp)[4] = 0xff; case  4: (cp)[3] = 0xff;\     case  3: (cp)[2] = 0xff; case  2: (cp)[1] = 0xff;			      \     case  1: (cp)[0] = 0xff; (cp) += (n); case 0:  ;			      \     }
end_define
begin_define
DECL|macro|ZERO
define|#
directive|define
name|ZERO
parameter_list|(
name|n
parameter_list|,
name|cp
parameter_list|)
define|\
value|switch (n) {							\     case 15:(cp)[14] = 0; case 14:(cp)[13] = 0; case 13: (cp)[12] = 0;	\     case 12:(cp)[11] = 0; case 11:(cp)[10] = 0; case 10: (cp)[9] = 0;	\     case  9: (cp)[8] = 0; case  8: (cp)[7] = 0; case  7: (cp)[6] = 0;	\     case  6: (cp)[5] = 0; case  5: (cp)[4] = 0; case  4: (cp)[3] = 0;	\     case  3: (cp)[2] = 0; case  2: (cp)[1] = 0;				\     case  1: (cp)[0] = 0; (cp) += (n); case 0:  ;			\     }
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|FILL
define|#
directive|define
name|FILL
parameter_list|(
name|n
parameter_list|,
name|cp
parameter_list|)
define|\
value|switch (n) {							    \     case 7: (cp)[6] = 0xff; case 6: (cp)[5] = 0xff; case 5: (cp)[4] = 0xff; \     case 4: (cp)[3] = 0xff; case 3: (cp)[2] = 0xff; case 2: (cp)[1] = 0xff; \     case 1: (cp)[0] = 0xff; (cp) += (n); case 0:  ;			    \     }
end_define
begin_define
DECL|macro|ZERO
define|#
directive|define
name|ZERO
parameter_list|(
name|n
parameter_list|,
name|cp
parameter_list|)
define|\
value|switch (n) {							\     case 7: (cp)[6] = 0; case 6: (cp)[5] = 0; case 5: (cp)[4] = 0;	\     case 4: (cp)[3] = 0; case 3: (cp)[2] = 0; case 2: (cp)[1] = 0;	\     case 1: (cp)[0] = 0; (cp) += (n); case 0:  ;			\     }
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*  * Bit-fill a row according to the white/black  * runs generated during G3/G4 decoding.  */
end_comment
begin_function
name|void
DECL|function|_TIFFFax3fillruns
name|_TIFFFax3fillruns
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|uint32
modifier|*
name|runs
parameter_list|,
name|uint32
modifier|*
name|erun
parameter_list|,
name|uint32
name|lastx
parameter_list|)
block|{
specifier|static
specifier|const
name|unsigned
name|char
name|_fillmasks
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x80
block|,
literal|0xc0
block|,
literal|0xe0
block|,
literal|0xf0
block|,
literal|0xf8
block|,
literal|0xfc
block|,
literal|0xfe
block|,
literal|0xff
block|}
decl_stmt|;
name|unsigned
name|char
modifier|*
name|cp
decl_stmt|;
name|uint32
name|x
decl_stmt|,
name|bx
decl_stmt|,
name|run
decl_stmt|;
name|int32
name|n
decl_stmt|,
name|nw
decl_stmt|;
name|long
modifier|*
name|lp
decl_stmt|;
if|if
condition|(
operator|(
name|erun
operator|-
name|runs
operator|)
operator|&
literal|1
condition|)
operator|*
name|erun
operator|++
operator|=
literal|0
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|runs
operator|<
name|erun
condition|;
name|runs
operator|+=
literal|2
control|)
block|{
name|run
operator|=
name|runs
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|x
operator|+
name|run
operator|>
name|lastx
operator|||
name|run
operator|>
name|lastx
condition|)
name|run
operator|=
name|runs
index|[
literal|0
index|]
operator|=
call|(
name|uint32
call|)
argument_list|(
name|lastx
operator|-
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|run
condition|)
block|{
name|cp
operator|=
name|buf
operator|+
operator|(
name|x
operator|>>
literal|3
operator|)
expr_stmt|;
name|bx
operator|=
name|x
operator|&
literal|7
expr_stmt|;
if|if
condition|(
name|run
operator|>
literal|8
operator|-
name|bx
condition|)
block|{
if|if
condition|(
name|bx
condition|)
block|{
comment|/* align to byte boundary */
operator|*
name|cp
operator|++
operator|&=
literal|0xff
operator|<<
operator|(
literal|8
operator|-
name|bx
operator|)
expr_stmt|;
name|run
operator|-=
literal|8
operator|-
name|bx
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|n
operator|=
name|run
operator|>>
literal|3
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* multiple bytes to fill */
if|if
condition|(
operator|(
name|n
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|)
operator|>
literal|1
condition|)
block|{
comment|/* 			     * Align to longword boundary and fill. 			     */
for|for
control|(
init|;
name|n
operator|&&
operator|!
name|isAligned
argument_list|(
name|cp
argument_list|,
name|long
argument_list|)
condition|;
name|n
operator|--
control|)
operator|*
name|cp
operator|++
operator|=
literal|0x00
expr_stmt|;
name|lp
operator|=
operator|(
name|long
operator|*
operator|)
name|cp
expr_stmt|;
name|nw
operator|=
call|(
name|int32
call|)
argument_list|(
name|n
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|-=
name|nw
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
do|do
block|{
operator|*
name|lp
operator|++
operator|=
literal|0L
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|nw
condition|)
do|;
name|cp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|lp
expr_stmt|;
block|}
name|ZERO
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|run
operator|&=
literal|7
expr_stmt|;
block|}
if|if
condition|(
name|run
condition|)
name|cp
index|[
literal|0
index|]
operator|&=
literal|0xff
operator|>>
name|run
expr_stmt|;
block|}
else|else
name|cp
index|[
literal|0
index|]
operator|&=
operator|~
operator|(
name|_fillmasks
index|[
name|run
index|]
operator|>>
name|bx
operator|)
expr_stmt|;
name|x
operator|+=
name|runs
index|[
literal|0
index|]
expr_stmt|;
block|}
name|run
operator|=
name|runs
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|x
operator|+
name|run
operator|>
name|lastx
operator|||
name|run
operator|>
name|lastx
condition|)
name|run
operator|=
name|runs
index|[
literal|1
index|]
operator|=
name|lastx
operator|-
name|x
expr_stmt|;
if|if
condition|(
name|run
condition|)
block|{
name|cp
operator|=
name|buf
operator|+
operator|(
name|x
operator|>>
literal|3
operator|)
expr_stmt|;
name|bx
operator|=
name|x
operator|&
literal|7
expr_stmt|;
if|if
condition|(
name|run
operator|>
literal|8
operator|-
name|bx
condition|)
block|{
if|if
condition|(
name|bx
condition|)
block|{
comment|/* align to byte boundary */
operator|*
name|cp
operator|++
operator||=
literal|0xff
operator|>>
name|bx
expr_stmt|;
name|run
operator|-=
literal|8
operator|-
name|bx
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|n
operator|=
name|run
operator|>>
literal|3
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* multiple bytes to fill */
if|if
condition|(
operator|(
name|n
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|)
operator|>
literal|1
condition|)
block|{
comment|/* 			     * Align to longword boundary and fill. 			     */
for|for
control|(
init|;
name|n
operator|&&
operator|!
name|isAligned
argument_list|(
name|cp
argument_list|,
name|long
argument_list|)
condition|;
name|n
operator|--
control|)
operator|*
name|cp
operator|++
operator|=
literal|0xff
expr_stmt|;
name|lp
operator|=
operator|(
name|long
operator|*
operator|)
name|cp
expr_stmt|;
name|nw
operator|=
call|(
name|int32
call|)
argument_list|(
name|n
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|-=
name|nw
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
do|do
block|{
operator|*
name|lp
operator|++
operator|=
operator|-
literal|1L
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|nw
condition|)
do|;
name|cp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|lp
expr_stmt|;
block|}
name|FILL
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|run
operator|&=
literal|7
expr_stmt|;
block|}
if|if
condition|(
name|run
condition|)
name|cp
index|[
literal|0
index|]
operator||=
literal|0xff00
operator|>>
name|run
expr_stmt|;
block|}
else|else
name|cp
index|[
literal|0
index|]
operator||=
name|_fillmasks
index|[
name|run
index|]
operator|>>
name|bx
expr_stmt|;
name|x
operator|+=
name|runs
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
name|assert
argument_list|(
name|x
operator|==
name|lastx
argument_list|)
expr_stmt|;
block|}
end_function
begin_undef
DECL|macro|ZERO
undef|#
directive|undef
name|ZERO
end_undef
begin_undef
DECL|macro|FILL
undef|#
directive|undef
name|FILL
end_undef
begin_comment
comment|/*  * Setup G3/G4-related compression/decompression state  * before data is processed.  This routine is called once  * per image -- it sets up different state based on whether  * or not decoding or encoding is being done and whether  * 1D- or 2D-encoded data is involved.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|Fax3SetupState
name|Fax3SetupState
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|Fax3BaseState
modifier|*
name|sp
init|=
name|Fax3State
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|int
name|needsRefLine
decl_stmt|;
name|Fax3CodecState
modifier|*
name|dsp
init|=
operator|(
name|Fax3CodecState
operator|*
operator|)
name|Fax3State
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|uint32
name|rowbytes
decl_stmt|,
name|rowpixels
decl_stmt|,
name|nruns
decl_stmt|;
if|if
condition|(
name|td
operator|->
name|td_bitspersample
operator|!=
literal|1
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"Bits/sample must be 1 for Group 3/4 encoding/decoding"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Calculate the scanline/tile widths. 	 */
if|if
condition|(
name|isTiled
argument_list|(
name|tif
argument_list|)
condition|)
block|{
name|rowbytes
operator|=
name|TIFFTileRowSize
argument_list|(
name|tif
argument_list|)
expr_stmt|;
name|rowpixels
operator|=
name|td
operator|->
name|td_tilewidth
expr_stmt|;
block|}
else|else
block|{
name|rowbytes
operator|=
name|TIFFScanlineSize
argument_list|(
name|tif
argument_list|)
expr_stmt|;
name|rowpixels
operator|=
name|td
operator|->
name|td_imagewidth
expr_stmt|;
block|}
name|sp
operator|->
name|rowbytes
operator|=
operator|(
name|uint32
operator|)
name|rowbytes
expr_stmt|;
name|sp
operator|->
name|rowpixels
operator|=
operator|(
name|uint32
operator|)
name|rowpixels
expr_stmt|;
comment|/* 	 * Allocate any additional space required for decoding/encoding. 	 */
name|needsRefLine
operator|=
operator|(
operator|(
name|sp
operator|->
name|groupoptions
operator|&
name|GROUP3OPT_2DENCODING
operator|)
operator|||
name|td
operator|->
name|td_compression
operator|==
name|COMPRESSION_CCITTFAX4
operator|)
expr_stmt|;
name|nruns
operator|=
name|needsRefLine
condition|?
literal|2
operator|*
name|TIFFroundup
argument_list|(
name|rowpixels
argument_list|,
literal|32
argument_list|)
else|:
name|rowpixels
expr_stmt|;
name|nruns
operator|+=
literal|3
expr_stmt|;
name|dsp
operator|->
name|runs
operator|=
operator|(
name|uint32
operator|*
operator|)
name|_TIFFCheckMalloc
argument_list|(
name|tif
argument_list|,
literal|2
operator|*
name|nruns
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32
argument_list|)
argument_list|,
literal|"for Group 3/4 run arrays"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsp
operator|->
name|runs
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dsp
operator|->
name|curruns
operator|=
name|dsp
operator|->
name|runs
expr_stmt|;
if|if
condition|(
name|needsRefLine
condition|)
name|dsp
operator|->
name|refruns
operator|=
name|dsp
operator|->
name|runs
operator|+
name|nruns
expr_stmt|;
else|else
name|dsp
operator|->
name|refruns
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_compression
operator|==
name|COMPRESSION_CCITTFAX3
operator|&&
name|is2DEncoding
argument_list|(
name|dsp
argument_list|)
condition|)
block|{
comment|/* NB: default is 1D routine */
name|tif
operator|->
name|tif_decoderow
operator|=
name|Fax3Decode2D
expr_stmt|;
name|tif
operator|->
name|tif_decodestrip
operator|=
name|Fax3Decode2D
expr_stmt|;
name|tif
operator|->
name|tif_decodetile
operator|=
name|Fax3Decode2D
expr_stmt|;
block|}
if|if
condition|(
name|needsRefLine
condition|)
block|{
comment|/* 2d encoding */
name|Fax3CodecState
modifier|*
name|esp
init|=
name|EncoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
comment|/* 		 * 2d encoding requires a scanline 		 * buffer for the ``reference line''; the 		 * scanline against which delta encoding 		 * is referenced.  The reference line must 		 * be initialized to be ``white'' (done elsewhere). 		 */
name|esp
operator|->
name|refline
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|_TIFFmalloc
argument_list|(
name|rowbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|esp
operator|->
name|refline
operator|==
name|NULL
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
literal|"Fax3SetupState"
argument_list|,
literal|"%s: No space for Group 3/4 reference line"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
comment|/* 1d encoding */
name|EncoderState
argument_list|(
name|tif
argument_list|)
operator|->
name|refline
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * CCITT Group 3 FAX Encoding.  */
end_comment
begin_define
DECL|macro|Fax3FlushBits
define|#
directive|define
name|Fax3FlushBits
parameter_list|(
name|tif
parameter_list|,
name|sp
parameter_list|)
value|{				\ 	if ((tif)->tif_rawcc>= (tif)->tif_rawdatasize)		\ 		(void) TIFFFlushData1(tif);			\ 	*(tif)->tif_rawcp++ = (tidataval_t) (sp)->data;		\ 	(tif)->tif_rawcc++;					\ 	(sp)->data = 0, (sp)->bit = 8;				\ }
end_define
begin_define
DECL|macro|_FlushBits
define|#
directive|define
name|_FlushBits
parameter_list|(
name|tif
parameter_list|)
value|{					\ 	if ((tif)->tif_rawcc>= (tif)->tif_rawdatasize)		\ 		(void) TIFFFlushData1(tif);			\ 	*(tif)->tif_rawcp++ = (tidataval_t) data;		\ 	(tif)->tif_rawcc++;					\ 	data = 0, bit = 8;					\ }
end_define
begin_decl_stmt
DECL|variable|_msbmask
specifier|static
specifier|const
name|int
name|_msbmask
index|[
literal|9
index|]
init|=
block|{
literal|0x00
block|,
literal|0x01
block|,
literal|0x03
block|,
literal|0x07
block|,
literal|0x0f
block|,
literal|0x1f
block|,
literal|0x3f
block|,
literal|0x7f
block|,
literal|0xff
block|}
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|_PutBits
define|#
directive|define
name|_PutBits
parameter_list|(
name|tif
parameter_list|,
name|bits
parameter_list|,
name|length
parameter_list|)
value|{				\ 	while (length> bit) {					\ 		data |= bits>> (length - bit);			\ 		length -= bit;					\ 		_FlushBits(tif);				\ 	}							\ 	data |= (bits& _msbmask[length])<< (bit - length);	\ 	bit -= length;						\ 	if (bit == 0)						\ 		_FlushBits(tif);				\ }
end_define
begin_comment
comment|/*  * Write a variable-length bit-value to  * the output stream.  Values are  * assumed to be at most 16 bits.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|Fax3PutBits
name|Fax3PutBits
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|unsigned
name|int
name|bits
parameter_list|,
name|unsigned
name|int
name|length
parameter_list|)
block|{
name|Fax3CodecState
modifier|*
name|sp
init|=
name|EncoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|bit
init|=
name|sp
operator|->
name|bit
decl_stmt|;
name|int
name|data
init|=
name|sp
operator|->
name|data
decl_stmt|;
name|_PutBits
argument_list|(
name|tif
argument_list|,
name|bits
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|sp
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|sp
operator|->
name|bit
operator|=
name|bit
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Write a code to the output stream.  */
end_comment
begin_define
DECL|macro|putcode
define|#
directive|define
name|putcode
parameter_list|(
name|tif
parameter_list|,
name|te
parameter_list|)
value|Fax3PutBits(tif, (te)->code, (te)->length)
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|FAX3_DEBUG
end_ifdef
begin_define
DECL|macro|DEBUG_COLOR
define|#
directive|define
name|DEBUG_COLOR
parameter_list|(
name|w
parameter_list|)
value|(tab == TIFFFaxWhiteCodes ? w "W" : w "B")
end_define
begin_define
DECL|macro|DEBUG_PRINT
define|#
directive|define
name|DEBUG_PRINT
parameter_list|(
name|what
parameter_list|,
name|len
parameter_list|)
value|{						\     int t;								\     printf("%08X/%-2d: %s%5d\t", data, bit, DEBUG_COLOR(what), len);	\     for (t = length-1; t>= 0; t--)					\ 	putchar(code& (1<<t) ? '1' : '0');				\     putchar('\n');							\ }
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*  * Write the sequence of codes that describes  * the specified span of zero's or one's.  The  * appropriate table that holds the make-up and  * terminating codes is supplied.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|putspan
name|putspan
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|int32
name|span
parameter_list|,
specifier|const
name|tableentry
modifier|*
name|tab
parameter_list|)
block|{
name|Fax3CodecState
modifier|*
name|sp
init|=
name|EncoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|bit
init|=
name|sp
operator|->
name|bit
decl_stmt|;
name|int
name|data
init|=
name|sp
operator|->
name|data
decl_stmt|;
name|unsigned
name|int
name|code
decl_stmt|,
name|length
decl_stmt|;
while|while
condition|(
name|span
operator|>=
literal|2624
condition|)
block|{
specifier|const
name|tableentry
modifier|*
name|te
init|=
operator|&
name|tab
index|[
literal|63
operator|+
operator|(
literal|2560
operator|>>
literal|6
operator|)
index|]
decl_stmt|;
name|code
operator|=
name|te
operator|->
name|code
operator|,
name|length
operator|=
name|te
operator|->
name|length
expr_stmt|;
ifdef|#
directive|ifdef
name|FAX3_DEBUG
name|DEBUG_PRINT
argument_list|(
literal|"MakeUp"
argument_list|,
name|te
operator|->
name|runlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_PutBits
argument_list|(
name|tif
argument_list|,
name|code
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|span
operator|-=
name|te
operator|->
name|runlen
expr_stmt|;
block|}
if|if
condition|(
name|span
operator|>=
literal|64
condition|)
block|{
specifier|const
name|tableentry
modifier|*
name|te
init|=
operator|&
name|tab
index|[
literal|63
operator|+
operator|(
name|span
operator|>>
literal|6
operator|)
index|]
decl_stmt|;
name|assert
argument_list|(
name|te
operator|->
name|runlen
operator|==
literal|64
operator|*
operator|(
name|span
operator|>>
literal|6
operator|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|te
operator|->
name|code
operator|,
name|length
operator|=
name|te
operator|->
name|length
expr_stmt|;
ifdef|#
directive|ifdef
name|FAX3_DEBUG
name|DEBUG_PRINT
argument_list|(
literal|"MakeUp"
argument_list|,
name|te
operator|->
name|runlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_PutBits
argument_list|(
name|tif
argument_list|,
name|code
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|span
operator|-=
name|te
operator|->
name|runlen
expr_stmt|;
block|}
name|code
operator|=
name|tab
index|[
name|span
index|]
operator|.
name|code
operator|,
name|length
operator|=
name|tab
index|[
name|span
index|]
operator|.
name|length
expr_stmt|;
ifdef|#
directive|ifdef
name|FAX3_DEBUG
name|DEBUG_PRINT
argument_list|(
literal|"  Term"
argument_list|,
name|tab
index|[
name|span
index|]
operator|.
name|runlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_PutBits
argument_list|(
name|tif
argument_list|,
name|code
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|sp
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|sp
operator|->
name|bit
operator|=
name|bit
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Write an EOL code to the output stream.  The zero-fill  * logic for byte-aligning encoded scanlines is handled  * here.  We also handle writing the tag bit for the next  * scanline when doing 2d encoding.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|Fax3PutEOL
name|Fax3PutEOL
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|Fax3CodecState
modifier|*
name|sp
init|=
name|EncoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|bit
init|=
name|sp
operator|->
name|bit
decl_stmt|;
name|int
name|data
init|=
name|sp
operator|->
name|data
decl_stmt|;
name|unsigned
name|int
name|code
decl_stmt|,
name|length
decl_stmt|,
name|tparm
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|b
operator|.
name|groupoptions
operator|&
name|GROUP3OPT_FILLBITS
condition|)
block|{
comment|/* 		 * Force bit alignment so EOL will terminate on 		 * a byte boundary.  That is, force the bit alignment 		 * to 16-12 = 4 before putting out the EOL code. 		 */
name|int
name|align
init|=
literal|8
operator|-
literal|4
decl_stmt|;
if|if
condition|(
name|align
operator|!=
name|sp
operator|->
name|bit
condition|)
block|{
if|if
condition|(
name|align
operator|>
name|sp
operator|->
name|bit
condition|)
name|align
operator|=
name|sp
operator|->
name|bit
operator|+
operator|(
literal|8
operator|-
name|align
operator|)
expr_stmt|;
else|else
name|align
operator|=
name|sp
operator|->
name|bit
operator|-
name|align
expr_stmt|;
name|code
operator|=
literal|0
expr_stmt|;
name|tparm
operator|=
name|align
expr_stmt|;
name|_PutBits
argument_list|(
name|tif
argument_list|,
literal|0
argument_list|,
name|tparm
argument_list|)
expr_stmt|;
block|}
block|}
name|code
operator|=
name|EOL
operator|,
name|length
operator|=
literal|12
expr_stmt|;
if|if
condition|(
name|is2DEncoding
argument_list|(
name|sp
argument_list|)
condition|)
name|code
operator|=
operator|(
name|code
operator|<<
literal|1
operator|)
operator||
operator|(
name|sp
operator|->
name|tag
operator|==
name|G3_1D
operator|)
operator|,
name|length
operator|++
expr_stmt|;
name|_PutBits
argument_list|(
name|tif
argument_list|,
name|code
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|sp
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|sp
operator|->
name|bit
operator|=
name|bit
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Reset encoding state at the start of a strip.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|Fax3PreEncode
name|Fax3PreEncode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|Fax3CodecState
modifier|*
name|sp
init|=
name|EncoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|s
expr_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sp
operator|->
name|bit
operator|=
literal|8
expr_stmt|;
name|sp
operator|->
name|data
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|tag
operator|=
name|G3_1D
expr_stmt|;
comment|/* 	 * This is necessary for Group 4; otherwise it isn't 	 * needed because the first scanline of each strip ends 	 * up being copied into the refline. 	 */
if|if
condition|(
name|sp
operator|->
name|refline
condition|)
name|_TIFFmemset
argument_list|(
name|sp
operator|->
name|refline
argument_list|,
literal|0x00
argument_list|,
name|sp
operator|->
name|b
operator|.
name|rowbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|is2DEncoding
argument_list|(
name|sp
argument_list|)
condition|)
block|{
name|float
name|res
init|=
name|tif
operator|->
name|tif_dir
operator|.
name|td_yresolution
decl_stmt|;
comment|/* 		 * The CCITT spec says that when doing 2d encoding, you 		 * should only do it on K consecutive scanlines, where K 		 * depends on the resolution of the image being encoded 		 * (2 for<= 200 lpi, 4 for> 200 lpi).  Since the directory 		 * code initializes td_yresolution to 0, this code will 		 * select a K of 2 unless the YResolution tag is set 		 * appropriately.  (Note also that we fudge a little here 		 * and use 150 lpi to avoid problems with units conversion.) 		 */
if|if
condition|(
name|tif
operator|->
name|tif_dir
operator|.
name|td_resolutionunit
operator|==
name|RESUNIT_CENTIMETER
condition|)
name|res
operator|*=
literal|2.54f
expr_stmt|;
comment|/* convert to inches */
name|sp
operator|->
name|maxk
operator|=
operator|(
name|res
operator|>
literal|150
condition|?
literal|4
else|:
literal|2
operator|)
expr_stmt|;
name|sp
operator|->
name|k
operator|=
name|sp
operator|->
name|maxk
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|sp
operator|->
name|k
operator|=
name|sp
operator|->
name|maxk
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|line
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|zeroruns
specifier|static
specifier|const
name|unsigned
name|char
name|zeroruns
index|[
literal|256
index|]
init|=
block|{
literal|8
block|,
literal|7
block|,
literal|6
block|,
literal|6
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
comment|/* 0x00 - 0x0f */
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
comment|/* 0x10 - 0x1f */
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
comment|/* 0x20 - 0x2f */
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
comment|/* 0x30 - 0x3f */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 0x40 - 0x4f */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 0x50 - 0x5f */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 0x60 - 0x6f */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 0x70 - 0x7f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x80 - 0x8f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x90 - 0x9f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0xa0 - 0xaf */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0xb0 - 0xbf */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0xc0 - 0xcf */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0xd0 - 0xdf */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0xe0 - 0xef */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0xf0 - 0xff */
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|oneruns
specifier|static
specifier|const
name|unsigned
name|char
name|oneruns
index|[
literal|256
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x00 - 0x0f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x10 - 0x1f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x20 - 0x2f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x30 - 0x3f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x40 - 0x4f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x50 - 0x5f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x60 - 0x6f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x70 - 0x7f */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 0x80 - 0x8f */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 0x90 - 0x9f */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 0xa0 - 0xaf */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 0xb0 - 0xbf */
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
comment|/* 0xc0 - 0xcf */
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
comment|/* 0xd0 - 0xdf */
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
comment|/* 0xe0 - 0xef */
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
comment|/* 0xf0 - 0xff */
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*  * On certain systems it pays to inline  * the routines that find pixel spans.  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|VAXC
end_ifdef
begin_function_decl
specifier|static
name|int32
name|find0span
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|int32
parameter_list|,
name|int32
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int32
name|find1span
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|int32
parameter_list|,
name|int32
parameter_list|)
function_decl|;
end_function_decl
begin_pragma
pragma|#
directive|pragma
name|inline
name|(
name|find0span
name|,
name|find1span
name|)
end_pragma
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*  * Find a span of ones or zeros using the supplied  * table.  The ``base'' of the bit string is supplied  * along with the start+end bit indices.  */
end_comment
begin_function
specifier|static
name|int32
DECL|function|find0span
name|find0span
parameter_list|(
name|unsigned
name|char
modifier|*
name|bp
parameter_list|,
name|int32
name|bs
parameter_list|,
name|int32
name|be
parameter_list|)
block|{
name|int32
name|bits
init|=
name|be
operator|-
name|bs
decl_stmt|;
name|int32
name|n
decl_stmt|,
name|span
decl_stmt|;
name|bp
operator|+=
name|bs
operator|>>
literal|3
expr_stmt|;
comment|/* 	 * Check partial byte on lhs. 	 */
if|if
condition|(
name|bits
operator|>
literal|0
operator|&&
operator|(
name|n
operator|=
operator|(
name|bs
operator|&
literal|7
operator|)
operator|)
condition|)
block|{
name|span
operator|=
name|zeroruns
index|[
operator|(
operator|*
name|bp
operator|<<
name|n
operator|)
operator|&
literal|0xff
index|]
expr_stmt|;
if|if
condition|(
name|span
operator|>
literal|8
operator|-
name|n
condition|)
comment|/* table value too generous */
name|span
operator|=
literal|8
operator|-
name|n
expr_stmt|;
if|if
condition|(
name|span
operator|>
name|bits
condition|)
comment|/* constrain span to bit range */
name|span
operator|=
name|bits
expr_stmt|;
if|if
condition|(
name|n
operator|+
name|span
operator|<
literal|8
condition|)
comment|/* doesn't extend to edge of byte */
return|return
operator|(
name|span
operator|)
return|;
name|bits
operator|-=
name|span
expr_stmt|;
name|bp
operator|++
expr_stmt|;
block|}
else|else
name|span
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bits
operator|>=
call|(
name|int32
call|)
argument_list|(
literal|2
operator|*
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
condition|)
block|{
name|long
modifier|*
name|lp
decl_stmt|;
comment|/* 		 * Align to longword boundary and check longwords. 		 */
while|while
condition|(
operator|!
name|isAligned
argument_list|(
name|bp
argument_list|,
name|long
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|!=
literal|0x00
condition|)
return|return
operator|(
name|span
operator|+
name|zeroruns
index|[
operator|*
name|bp
index|]
operator|)
return|;
name|span
operator|+=
literal|8
operator|,
name|bits
operator|-=
literal|8
expr_stmt|;
name|bp
operator|++
expr_stmt|;
block|}
name|lp
operator|=
operator|(
name|long
operator|*
operator|)
name|bp
expr_stmt|;
while|while
condition|(
operator|(
name|bits
operator|>=
call|(
name|int32
call|)
argument_list|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
literal|0
operator|==
operator|*
name|lp
operator|)
condition|)
block|{
name|span
operator|+=
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|,
name|bits
operator|-=
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|lp
operator|++
expr_stmt|;
block|}
name|bp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|lp
expr_stmt|;
block|}
comment|/* 	 * Scan full bytes for all 0's. 	 */
while|while
condition|(
name|bits
operator|>=
literal|8
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|!=
literal|0x00
condition|)
comment|/* end of run */
return|return
operator|(
name|span
operator|+
name|zeroruns
index|[
operator|*
name|bp
index|]
operator|)
return|;
name|span
operator|+=
literal|8
operator|,
name|bits
operator|-=
literal|8
expr_stmt|;
name|bp
operator|++
expr_stmt|;
block|}
comment|/* 	 * Check partial byte on rhs. 	 */
if|if
condition|(
name|bits
operator|>
literal|0
condition|)
block|{
name|n
operator|=
name|zeroruns
index|[
operator|*
name|bp
index|]
expr_stmt|;
name|span
operator|+=
operator|(
name|n
operator|>
name|bits
condition|?
name|bits
else|:
name|n
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|span
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|int32
DECL|function|find1span
name|find1span
parameter_list|(
name|unsigned
name|char
modifier|*
name|bp
parameter_list|,
name|int32
name|bs
parameter_list|,
name|int32
name|be
parameter_list|)
block|{
name|int32
name|bits
init|=
name|be
operator|-
name|bs
decl_stmt|;
name|int32
name|n
decl_stmt|,
name|span
decl_stmt|;
name|bp
operator|+=
name|bs
operator|>>
literal|3
expr_stmt|;
comment|/* 	 * Check partial byte on lhs. 	 */
if|if
condition|(
name|bits
operator|>
literal|0
operator|&&
operator|(
name|n
operator|=
operator|(
name|bs
operator|&
literal|7
operator|)
operator|)
condition|)
block|{
name|span
operator|=
name|oneruns
index|[
operator|(
operator|*
name|bp
operator|<<
name|n
operator|)
operator|&
literal|0xff
index|]
expr_stmt|;
if|if
condition|(
name|span
operator|>
literal|8
operator|-
name|n
condition|)
comment|/* table value too generous */
name|span
operator|=
literal|8
operator|-
name|n
expr_stmt|;
if|if
condition|(
name|span
operator|>
name|bits
condition|)
comment|/* constrain span to bit range */
name|span
operator|=
name|bits
expr_stmt|;
if|if
condition|(
name|n
operator|+
name|span
operator|<
literal|8
condition|)
comment|/* doesn't extend to edge of byte */
return|return
operator|(
name|span
operator|)
return|;
name|bits
operator|-=
name|span
expr_stmt|;
name|bp
operator|++
expr_stmt|;
block|}
else|else
name|span
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bits
operator|>=
call|(
name|int32
call|)
argument_list|(
literal|2
operator|*
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
condition|)
block|{
name|long
modifier|*
name|lp
decl_stmt|;
comment|/* 		 * Align to longword boundary and check longwords. 		 */
while|while
condition|(
operator|!
name|isAligned
argument_list|(
name|bp
argument_list|,
name|long
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|!=
literal|0xff
condition|)
return|return
operator|(
name|span
operator|+
name|oneruns
index|[
operator|*
name|bp
index|]
operator|)
return|;
name|span
operator|+=
literal|8
operator|,
name|bits
operator|-=
literal|8
expr_stmt|;
name|bp
operator|++
expr_stmt|;
block|}
name|lp
operator|=
operator|(
name|long
operator|*
operator|)
name|bp
expr_stmt|;
while|while
condition|(
operator|(
name|bits
operator|>=
call|(
name|int32
call|)
argument_list|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
operator|~
literal|0
operator|==
operator|*
name|lp
operator|)
condition|)
block|{
name|span
operator|+=
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|,
name|bits
operator|-=
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|lp
operator|++
expr_stmt|;
block|}
name|bp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|lp
expr_stmt|;
block|}
comment|/* 	 * Scan full bytes for all 1's. 	 */
while|while
condition|(
name|bits
operator|>=
literal|8
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|!=
literal|0xff
condition|)
comment|/* end of run */
return|return
operator|(
name|span
operator|+
name|oneruns
index|[
operator|*
name|bp
index|]
operator|)
return|;
name|span
operator|+=
literal|8
operator|,
name|bits
operator|-=
literal|8
expr_stmt|;
name|bp
operator|++
expr_stmt|;
block|}
comment|/* 	 * Check partial byte on rhs. 	 */
if|if
condition|(
name|bits
operator|>
literal|0
condition|)
block|{
name|n
operator|=
name|oneruns
index|[
operator|*
name|bp
index|]
expr_stmt|;
name|span
operator|+=
operator|(
name|n
operator|>
name|bits
condition|?
name|bits
else|:
name|n
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|span
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Return the offset of the next bit in the range  * [bs..be] that is different from the specified  * color.  The end, be, is returned if no such bit  * exists.  */
end_comment
begin_define
DECL|macro|finddiff
define|#
directive|define
name|finddiff
parameter_list|(
name|_cp
parameter_list|,
name|_bs
parameter_list|,
name|_be
parameter_list|,
name|_color
parameter_list|)
define|\
value|(_bs + (_color ? find1span(_cp,_bs,_be) : find0span(_cp,_bs,_be)))
end_define
begin_comment
comment|/*  * Like finddiff, but also check the starting bit  * against the end in case start> end.  */
end_comment
begin_define
DECL|macro|finddiff2
define|#
directive|define
name|finddiff2
parameter_list|(
name|_cp
parameter_list|,
name|_bs
parameter_list|,
name|_be
parameter_list|,
name|_color
parameter_list|)
define|\
value|(_bs< _be ? finddiff(_cp,_bs,_be,_color) : _be)
end_define
begin_comment
comment|/*  * 1d-encode a row of pixels.  The encoding is  * a sequence of all-white or all-black spans  * of pixels encoded with Huffman codes.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|Fax3Encode1DRow
name|Fax3Encode1DRow
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|unsigned
name|char
modifier|*
name|bp
parameter_list|,
name|uint32
name|bits
parameter_list|)
block|{
name|Fax3CodecState
modifier|*
name|sp
init|=
name|EncoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|int32
name|span
decl_stmt|;
name|uint32
name|bs
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|span
operator|=
name|find0span
argument_list|(
name|bp
argument_list|,
name|bs
argument_list|,
name|bits
argument_list|)
expr_stmt|;
comment|/* white span */
name|putspan
argument_list|(
name|tif
argument_list|,
name|span
argument_list|,
name|TIFFFaxWhiteCodes
argument_list|)
expr_stmt|;
name|bs
operator|+=
name|span
expr_stmt|;
if|if
condition|(
name|bs
operator|>=
name|bits
condition|)
break|break;
name|span
operator|=
name|find1span
argument_list|(
name|bp
argument_list|,
name|bs
argument_list|,
name|bits
argument_list|)
expr_stmt|;
comment|/* black span */
name|putspan
argument_list|(
name|tif
argument_list|,
name|span
argument_list|,
name|TIFFFaxBlackCodes
argument_list|)
expr_stmt|;
name|bs
operator|+=
name|span
expr_stmt|;
if|if
condition|(
name|bs
operator|>=
name|bits
condition|)
break|break;
block|}
if|if
condition|(
name|sp
operator|->
name|b
operator|.
name|mode
operator|&
operator|(
name|FAXMODE_BYTEALIGN
operator||
name|FAXMODE_WORDALIGN
operator|)
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|bit
operator|!=
literal|8
condition|)
comment|/* byte-align */
name|Fax3FlushBits
argument_list|(
name|tif
argument_list|,
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|->
name|b
operator|.
name|mode
operator|&
name|FAXMODE_WORDALIGN
operator|)
operator|&&
operator|!
name|isAligned
argument_list|(
name|tif
operator|->
name|tif_rawcp
argument_list|,
name|uint16
argument_list|)
condition|)
name|Fax3FlushBits
argument_list|(
name|tif
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|horizcode
specifier|static
specifier|const
name|tableentry
name|horizcode
init|=
block|{
literal|3
block|,
literal|0x1
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* 001 */
end_comment
begin_decl_stmt
DECL|variable|passcode
specifier|static
specifier|const
name|tableentry
name|passcode
init|=
block|{
literal|4
block|,
literal|0x1
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* 0001 */
end_comment
begin_decl_stmt
DECL|variable|vcodes
specifier|static
specifier|const
name|tableentry
name|vcodes
index|[
literal|7
index|]
init|=
block|{
block|{
literal|7
block|,
literal|0x03
block|,
literal|0
block|}
block|,
comment|/* 0000 011 */
block|{
literal|6
block|,
literal|0x03
block|,
literal|0
block|}
block|,
comment|/* 0000 11 */
block|{
literal|3
block|,
literal|0x03
block|,
literal|0
block|}
block|,
comment|/* 011 */
block|{
literal|1
block|,
literal|0x1
block|,
literal|0
block|}
block|,
comment|/* 1 */
block|{
literal|3
block|,
literal|0x2
block|,
literal|0
block|}
block|,
comment|/* 010 */
block|{
literal|6
block|,
literal|0x02
block|,
literal|0
block|}
block|,
comment|/* 0000 10 */
block|{
literal|7
block|,
literal|0x02
block|,
literal|0
block|}
comment|/* 0000 010 */
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*  * 2d-encode a row of pixels.  Consult the CCITT  * documentation for the algorithm.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|Fax3Encode2DRow
name|Fax3Encode2DRow
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|unsigned
name|char
modifier|*
name|bp
parameter_list|,
name|unsigned
name|char
modifier|*
name|rp
parameter_list|,
name|uint32
name|bits
parameter_list|)
block|{
DECL|macro|PIXEL
define|#
directive|define
name|PIXEL
parameter_list|(
name|buf
parameter_list|,
name|ix
parameter_list|)
value|((((buf)[(ix)>>3])>> (7-((ix)&7)))& 1)
name|uint32
name|a0
init|=
literal|0
decl_stmt|;
name|uint32
name|a1
init|=
operator|(
name|PIXEL
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|?
literal|0
else|:
name|finddiff
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|,
name|bits
argument_list|,
literal|0
argument_list|)
operator|)
decl_stmt|;
name|uint32
name|b1
init|=
operator|(
name|PIXEL
argument_list|(
name|rp
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|?
literal|0
else|:
name|finddiff
argument_list|(
name|rp
argument_list|,
literal|0
argument_list|,
name|bits
argument_list|,
literal|0
argument_list|)
operator|)
decl_stmt|;
name|uint32
name|a2
decl_stmt|,
name|b2
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|b2
operator|=
name|finddiff2
argument_list|(
name|rp
argument_list|,
name|b1
argument_list|,
name|bits
argument_list|,
name|PIXEL
argument_list|(
name|rp
argument_list|,
name|b1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|b2
operator|>=
name|a1
condition|)
block|{
name|int32
name|d
init|=
name|b1
operator|-
name|a1
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|-
literal|3
operator|<=
name|d
operator|&&
name|d
operator|<=
literal|3
operator|)
condition|)
block|{
comment|/* horizontal mode */
name|a2
operator|=
name|finddiff2
argument_list|(
name|bp
argument_list|,
name|a1
argument_list|,
name|bits
argument_list|,
name|PIXEL
argument_list|(
name|bp
argument_list|,
name|a1
argument_list|)
argument_list|)
expr_stmt|;
name|putcode
argument_list|(
name|tif
argument_list|,
operator|&
name|horizcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|a0
operator|+
name|a1
operator|==
literal|0
operator|||
name|PIXEL
argument_list|(
name|bp
argument_list|,
name|a0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|putspan
argument_list|(
name|tif
argument_list|,
name|a1
operator|-
name|a0
argument_list|,
name|TIFFFaxWhiteCodes
argument_list|)
expr_stmt|;
name|putspan
argument_list|(
name|tif
argument_list|,
name|a2
operator|-
name|a1
argument_list|,
name|TIFFFaxBlackCodes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putspan
argument_list|(
name|tif
argument_list|,
name|a1
operator|-
name|a0
argument_list|,
name|TIFFFaxBlackCodes
argument_list|)
expr_stmt|;
name|putspan
argument_list|(
name|tif
argument_list|,
name|a2
operator|-
name|a1
argument_list|,
name|TIFFFaxWhiteCodes
argument_list|)
expr_stmt|;
block|}
name|a0
operator|=
name|a2
expr_stmt|;
block|}
else|else
block|{
comment|/* vertical mode */
name|putcode
argument_list|(
name|tif
argument_list|,
operator|&
name|vcodes
index|[
name|d
operator|+
literal|3
index|]
argument_list|)
expr_stmt|;
name|a0
operator|=
name|a1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* pass mode */
name|putcode
argument_list|(
name|tif
argument_list|,
operator|&
name|passcode
argument_list|)
expr_stmt|;
name|a0
operator|=
name|b2
expr_stmt|;
block|}
if|if
condition|(
name|a0
operator|>=
name|bits
condition|)
break|break;
name|a1
operator|=
name|finddiff
argument_list|(
name|bp
argument_list|,
name|a0
argument_list|,
name|bits
argument_list|,
name|PIXEL
argument_list|(
name|bp
argument_list|,
name|a0
argument_list|)
argument_list|)
expr_stmt|;
name|b1
operator|=
name|finddiff
argument_list|(
name|rp
argument_list|,
name|a0
argument_list|,
name|bits
argument_list|,
operator|!
name|PIXEL
argument_list|(
name|bp
argument_list|,
name|a0
argument_list|)
argument_list|)
expr_stmt|;
name|b1
operator|=
name|finddiff
argument_list|(
name|rp
argument_list|,
name|b1
argument_list|,
name|bits
argument_list|,
name|PIXEL
argument_list|(
name|bp
argument_list|,
name|a0
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
DECL|macro|PIXEL
undef|#
directive|undef
name|PIXEL
block|}
end_function
begin_comment
comment|/*  * Encode a buffer of pixels.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|Fax3Encode
name|Fax3Encode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|bp
parameter_list|,
name|tsize_t
name|cc
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|Fax3CodecState
modifier|*
name|sp
init|=
name|EncoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|s
expr_stmt|;
while|while
condition|(
operator|(
name|long
operator|)
name|cc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|sp
operator|->
name|b
operator|.
name|mode
operator|&
name|FAXMODE_NOEOL
operator|)
operator|==
literal|0
condition|)
name|Fax3PutEOL
argument_list|(
name|tif
argument_list|)
expr_stmt|;
if|if
condition|(
name|is2DEncoding
argument_list|(
name|sp
argument_list|)
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|tag
operator|==
name|G3_1D
condition|)
block|{
if|if
condition|(
operator|!
name|Fax3Encode1DRow
argument_list|(
name|tif
argument_list|,
name|bp
argument_list|,
name|sp
operator|->
name|b
operator|.
name|rowpixels
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sp
operator|->
name|tag
operator|=
name|G3_2D
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|Fax3Encode2DRow
argument_list|(
name|tif
argument_list|,
name|bp
argument_list|,
name|sp
operator|->
name|refline
argument_list|,
name|sp
operator|->
name|b
operator|.
name|rowpixels
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sp
operator|->
name|k
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|k
operator|==
literal|0
condition|)
block|{
name|sp
operator|->
name|tag
operator|=
name|G3_1D
expr_stmt|;
name|sp
operator|->
name|k
operator|=
name|sp
operator|->
name|maxk
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|_TIFFmemcpy
argument_list|(
name|sp
operator|->
name|refline
argument_list|,
name|bp
argument_list|,
name|sp
operator|->
name|b
operator|.
name|rowbytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|Fax3Encode1DRow
argument_list|(
name|tif
argument_list|,
name|bp
argument_list|,
name|sp
operator|->
name|b
operator|.
name|rowpixels
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bp
operator|+=
name|sp
operator|->
name|b
operator|.
name|rowbytes
expr_stmt|;
name|cc
operator|-=
name|sp
operator|->
name|b
operator|.
name|rowbytes
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|Fax3PostEncode
name|Fax3PostEncode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|Fax3CodecState
modifier|*
name|sp
init|=
name|EncoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|bit
operator|!=
literal|8
condition|)
name|Fax3FlushBits
argument_list|(
name|tif
argument_list|,
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Fax3Close
name|Fax3Close
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
if|if
condition|(
operator|(
name|Fax3State
argument_list|(
name|tif
argument_list|)
operator|->
name|mode
operator|&
name|FAXMODE_NORTC
operator|)
operator|==
literal|0
condition|)
block|{
name|Fax3CodecState
modifier|*
name|sp
init|=
name|EncoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|code
init|=
name|EOL
decl_stmt|;
name|unsigned
name|int
name|length
init|=
literal|12
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|is2DEncoding
argument_list|(
name|sp
argument_list|)
condition|)
name|code
operator|=
operator|(
name|code
operator|<<
literal|1
operator|)
operator||
operator|(
name|sp
operator|->
name|tag
operator|==
name|G3_1D
operator|)
operator|,
name|length
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|Fax3PutBits
argument_list|(
name|tif
argument_list|,
name|code
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|Fax3FlushBits
argument_list|(
name|tif
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Fax3Cleanup
name|Fax3Cleanup
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|Fax3CodecState
modifier|*
name|sp
init|=
name|DecoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|tif
operator|->
name|tif_tagmethods
operator|.
name|vgetfield
operator|=
name|sp
operator|->
name|b
operator|.
name|vgetparent
expr_stmt|;
name|tif
operator|->
name|tif_tagmethods
operator|.
name|vsetfield
operator|=
name|sp
operator|->
name|b
operator|.
name|vsetparent
expr_stmt|;
name|tif
operator|->
name|tif_tagmethods
operator|.
name|printdir
operator|=
name|sp
operator|->
name|b
operator|.
name|printdir
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|runs
condition|)
name|_TIFFfree
argument_list|(
name|sp
operator|->
name|runs
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|refline
condition|)
name|_TIFFfree
argument_list|(
name|sp
operator|->
name|refline
argument_list|)
expr_stmt|;
if|if
condition|(
name|Fax3State
argument_list|(
name|tif
argument_list|)
operator|->
name|subaddress
condition|)
name|_TIFFfree
argument_list|(
name|Fax3State
argument_list|(
name|tif
argument_list|)
operator|->
name|subaddress
argument_list|)
expr_stmt|;
if|if
condition|(
name|Fax3State
argument_list|(
name|tif
argument_list|)
operator|->
name|faxdcs
condition|)
name|_TIFFfree
argument_list|(
name|Fax3State
argument_list|(
name|tif
argument_list|)
operator|->
name|faxdcs
argument_list|)
expr_stmt|;
name|_TIFFfree
argument_list|(
name|tif
operator|->
name|tif_data
argument_list|)
expr_stmt|;
name|tif
operator|->
name|tif_data
operator|=
name|NULL
expr_stmt|;
name|_TIFFSetDefaultCompressionState
argument_list|(
name|tif
argument_list|)
expr_stmt|;
block|}
end_function
begin_define
DECL|macro|FIELD_BADFAXLINES
define|#
directive|define
name|FIELD_BADFAXLINES
value|(FIELD_CODEC+0)
end_define
begin_define
DECL|macro|FIELD_CLEANFAXDATA
define|#
directive|define
name|FIELD_CLEANFAXDATA
value|(FIELD_CODEC+1)
end_define
begin_define
DECL|macro|FIELD_BADFAXRUN
define|#
directive|define
name|FIELD_BADFAXRUN
value|(FIELD_CODEC+2)
end_define
begin_define
DECL|macro|FIELD_RECVPARAMS
define|#
directive|define
name|FIELD_RECVPARAMS
value|(FIELD_CODEC+3)
end_define
begin_define
DECL|macro|FIELD_SUBADDRESS
define|#
directive|define
name|FIELD_SUBADDRESS
value|(FIELD_CODEC+4)
end_define
begin_define
DECL|macro|FIELD_RECVTIME
define|#
directive|define
name|FIELD_RECVTIME
value|(FIELD_CODEC+5)
end_define
begin_define
DECL|macro|FIELD_FAXDCS
define|#
directive|define
name|FIELD_FAXDCS
value|(FIELD_CODEC+6)
end_define
begin_define
DECL|macro|FIELD_OPTIONS
define|#
directive|define
name|FIELD_OPTIONS
value|(FIELD_CODEC+7)
end_define
begin_decl_stmt
DECL|variable|faxFieldInfo
specifier|static
specifier|const
name|TIFFFieldInfo
name|faxFieldInfo
index|[]
init|=
block|{
block|{
name|TIFFTAG_FAXMODE
block|,
literal|0
block|,
literal|0
block|,
name|TIFF_ANY
block|,
name|FIELD_PSEUDO
block|,
name|FALSE
block|,
name|FALSE
block|,
literal|"FaxMode"
block|}
block|,
block|{
name|TIFFTAG_FAXFILLFUNC
block|,
literal|0
block|,
literal|0
block|,
name|TIFF_ANY
block|,
name|FIELD_PSEUDO
block|,
name|FALSE
block|,
name|FALSE
block|,
literal|"FaxFillFunc"
block|}
block|,
block|{
name|TIFFTAG_BADFAXLINES
block|,
literal|1
block|,
literal|1
block|,
name|TIFF_LONG
block|,
name|FIELD_BADFAXLINES
block|,
name|TRUE
block|,
name|FALSE
block|,
literal|"BadFaxLines"
block|}
block|,
block|{
name|TIFFTAG_BADFAXLINES
block|,
literal|1
block|,
literal|1
block|,
name|TIFF_SHORT
block|,
name|FIELD_BADFAXLINES
block|,
name|TRUE
block|,
name|FALSE
block|,
literal|"BadFaxLines"
block|}
block|,
block|{
name|TIFFTAG_CLEANFAXDATA
block|,
literal|1
block|,
literal|1
block|,
name|TIFF_SHORT
block|,
name|FIELD_CLEANFAXDATA
block|,
name|TRUE
block|,
name|FALSE
block|,
literal|"CleanFaxData"
block|}
block|,
block|{
name|TIFFTAG_CONSECUTIVEBADFAXLINES
block|,
literal|1
block|,
literal|1
block|,
name|TIFF_LONG
block|,
name|FIELD_BADFAXRUN
block|,
name|TRUE
block|,
name|FALSE
block|,
literal|"ConsecutiveBadFaxLines"
block|}
block|,
block|{
name|TIFFTAG_CONSECUTIVEBADFAXLINES
block|,
literal|1
block|,
literal|1
block|,
name|TIFF_SHORT
block|,
name|FIELD_BADFAXRUN
block|,
name|TRUE
block|,
name|FALSE
block|,
literal|"ConsecutiveBadFaxLines"
block|}
block|,
block|{
name|TIFFTAG_FAXRECVPARAMS
block|,
literal|1
block|,
literal|1
block|,
name|TIFF_LONG
block|,
name|FIELD_RECVPARAMS
block|,
name|TRUE
block|,
name|FALSE
block|,
literal|"FaxRecvParams"
block|}
block|,
block|{
name|TIFFTAG_FAXSUBADDRESS
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|TIFF_ASCII
block|,
name|FIELD_SUBADDRESS
block|,
name|TRUE
block|,
name|FALSE
block|,
literal|"FaxSubAddress"
block|}
block|,
block|{
name|TIFFTAG_FAXRECVTIME
block|,
literal|1
block|,
literal|1
block|,
name|TIFF_LONG
block|,
name|FIELD_RECVTIME
block|,
name|TRUE
block|,
name|FALSE
block|,
literal|"FaxRecvTime"
block|}
block|,
block|{
name|TIFFTAG_FAXDCS
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|TIFF_ASCII
block|,
name|FIELD_FAXDCS
block|,
name|TRUE
block|,
name|FALSE
block|,
literal|"FaxDcs"
block|}
block|, }
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|fax3FieldInfo
specifier|static
specifier|const
name|TIFFFieldInfo
name|fax3FieldInfo
index|[]
init|=
block|{
block|{
name|TIFFTAG_GROUP3OPTIONS
block|,
literal|1
block|,
literal|1
block|,
name|TIFF_LONG
block|,
name|FIELD_OPTIONS
block|,
name|FALSE
block|,
name|FALSE
block|,
literal|"Group3Options"
block|}
block|, }
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|fax4FieldInfo
specifier|static
specifier|const
name|TIFFFieldInfo
name|fax4FieldInfo
index|[]
init|=
block|{
block|{
name|TIFFTAG_GROUP4OPTIONS
block|,
literal|1
block|,
literal|1
block|,
name|TIFF_LONG
block|,
name|FIELD_OPTIONS
block|,
name|FALSE
block|,
name|FALSE
block|,
literal|"Group4Options"
block|}
block|, }
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|N
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof (a) / sizeof (a[0]))
end_define
begin_function
specifier|static
name|int
DECL|function|Fax3VSetField
name|Fax3VSetField
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|ttag_t
name|tag
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|Fax3BaseState
modifier|*
name|sp
init|=
name|Fax3State
argument_list|(
name|tif
argument_list|)
decl_stmt|;
specifier|const
name|TIFFFieldInfo
modifier|*
name|fip
decl_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|sp
operator|->
name|vsetparent
operator|!=
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|TIFFTAG_FAXMODE
case|:
name|sp
operator|->
name|mode
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* NB: pseudo tag */
case|case
name|TIFFTAG_FAXFILLFUNC
case|:
name|DecoderState
argument_list|(
name|tif
argument_list|)
operator|->
name|fill
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|TIFFFaxFillFunc
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* NB: pseudo tag */
case|case
name|TIFFTAG_GROUP3OPTIONS
case|:
comment|/* XXX: avoid reading options if compression mismatches. */
if|if
condition|(
name|tif
operator|->
name|tif_dir
operator|.
name|td_compression
operator|==
name|COMPRESSION_CCITTFAX3
condition|)
name|sp
operator|->
name|groupoptions
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFFTAG_GROUP4OPTIONS
case|:
comment|/* XXX: avoid reading options if compression mismatches. */
if|if
condition|(
name|tif
operator|->
name|tif_dir
operator|.
name|td_compression
operator|==
name|COMPRESSION_CCITTFAX4
condition|)
name|sp
operator|->
name|groupoptions
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFFTAG_BADFAXLINES
case|:
name|sp
operator|->
name|badfaxlines
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFFTAG_CLEANFAXDATA
case|:
name|sp
operator|->
name|cleanfaxdata
operator|=
operator|(
name|uint16
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFFTAG_CONSECUTIVEBADFAXLINES
case|:
name|sp
operator|->
name|badfaxrun
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFFTAG_FAXRECVPARAMS
case|:
name|sp
operator|->
name|recvparams
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFFTAG_FAXSUBADDRESS
case|:
name|_TIFFsetString
argument_list|(
operator|&
name|sp
operator|->
name|subaddress
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFFTAG_FAXRECVTIME
case|:
name|sp
operator|->
name|recvtime
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFFTAG_FAXDCS
case|:
name|_TIFFsetString
argument_list|(
operator|&
name|sp
operator|->
name|faxdcs
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
call|(
modifier|*
name|sp
operator|->
name|vsetparent
call|)
argument_list|(
name|tif
argument_list|,
name|tag
argument_list|,
name|ap
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|fip
operator|=
name|_TIFFFieldWithTag
argument_list|(
name|tif
argument_list|,
name|tag
argument_list|)
operator|)
condition|)
name|TIFFSetFieldBit
argument_list|(
name|tif
argument_list|,
name|fip
operator|->
name|field_bit
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
name|tif
operator|->
name|tif_flags
operator||=
name|TIFF_DIRTYDIRECT
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|Fax3VGetField
name|Fax3VGetField
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|ttag_t
name|tag
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|Fax3BaseState
modifier|*
name|sp
init|=
name|Fax3State
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|TIFFTAG_FAXMODE
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
operator|*
argument_list|)
operator|=
name|sp
operator|->
name|mode
expr_stmt|;
break|break;
case|case
name|TIFFTAG_FAXFILLFUNC
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|TIFFFaxFillFunc
operator|*
argument_list|)
operator|=
name|DecoderState
argument_list|(
name|tif
argument_list|)
operator|->
name|fill
expr_stmt|;
break|break;
case|case
name|TIFFTAG_GROUP3OPTIONS
case|:
case|case
name|TIFFTAG_GROUP4OPTIONS
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
operator|*
argument_list|)
operator|=
name|sp
operator|->
name|groupoptions
expr_stmt|;
break|break;
case|case
name|TIFFTAG_BADFAXLINES
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
operator|*
argument_list|)
operator|=
name|sp
operator|->
name|badfaxlines
expr_stmt|;
break|break;
case|case
name|TIFFTAG_CLEANFAXDATA
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|sp
operator|->
name|cleanfaxdata
expr_stmt|;
break|break;
case|case
name|TIFFTAG_CONSECUTIVEBADFAXLINES
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
operator|*
argument_list|)
operator|=
name|sp
operator|->
name|badfaxrun
expr_stmt|;
break|break;
case|case
name|TIFFTAG_FAXRECVPARAMS
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
operator|*
argument_list|)
operator|=
name|sp
operator|->
name|recvparams
expr_stmt|;
break|break;
case|case
name|TIFFTAG_FAXSUBADDRESS
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
operator|*
argument_list|)
operator|=
name|sp
operator|->
name|subaddress
expr_stmt|;
break|break;
case|case
name|TIFFTAG_FAXRECVTIME
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
operator|*
argument_list|)
operator|=
name|sp
operator|->
name|recvtime
expr_stmt|;
break|break;
case|case
name|TIFFTAG_FAXDCS
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
operator|*
argument_list|)
operator|=
name|sp
operator|->
name|faxdcs
expr_stmt|;
break|break;
default|default:
return|return
call|(
modifier|*
name|sp
operator|->
name|vgetparent
call|)
argument_list|(
name|tif
argument_list|,
name|tag
argument_list|,
name|ap
argument_list|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Fax3PrintDir
name|Fax3PrintDir
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|FILE
modifier|*
name|fd
parameter_list|,
name|long
name|flags
parameter_list|)
block|{
name|Fax3BaseState
modifier|*
name|sp
init|=
name|Fax3State
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|flags
expr_stmt|;
if|if
condition|(
name|TIFFFieldSet
argument_list|(
name|tif
argument_list|,
name|FIELD_OPTIONS
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|sep
init|=
literal|" "
decl_stmt|;
if|if
condition|(
name|tif
operator|->
name|tif_dir
operator|.
name|td_compression
operator|==
name|COMPRESSION_CCITTFAX4
condition|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"  Group 4 Options:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|groupoptions
operator|&
name|GROUP4OPT_UNCOMPRESSED
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"%suncompressed data"
argument_list|,
name|sep
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"  Group 3 Options:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|groupoptions
operator|&
name|GROUP3OPT_2DENCODING
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"%s2-d encoding"
argument_list|,
name|sep
argument_list|)
operator|,
name|sep
operator|=
literal|"+"
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|groupoptions
operator|&
name|GROUP3OPT_FILLBITS
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"%sEOL padding"
argument_list|,
name|sep
argument_list|)
operator|,
name|sep
operator|=
literal|"+"
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|groupoptions
operator|&
name|GROUP3OPT_UNCOMPRESSED
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"%suncompressed data"
argument_list|,
name|sep
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|" (%lu = 0x%lx)\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sp
operator|->
name|groupoptions
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sp
operator|->
name|groupoptions
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TIFFFieldSet
argument_list|(
name|tif
argument_list|,
name|FIELD_CLEANFAXDATA
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"  Fax Data:"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|cleanfaxdata
condition|)
block|{
case|case
name|CLEANFAXDATA_CLEAN
case|:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|" clean"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLEANFAXDATA_REGENERATED
case|:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|" receiver regenerated"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLEANFAXDATA_UNCLEAN
case|:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|" uncorrected errors"
argument_list|)
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|" (%u = 0x%x)\n"
argument_list|,
name|sp
operator|->
name|cleanfaxdata
argument_list|,
name|sp
operator|->
name|cleanfaxdata
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TIFFFieldSet
argument_list|(
name|tif
argument_list|,
name|FIELD_BADFAXLINES
argument_list|)
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"  Bad Fax Lines: %lu\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sp
operator|->
name|badfaxlines
argument_list|)
expr_stmt|;
if|if
condition|(
name|TIFFFieldSet
argument_list|(
name|tif
argument_list|,
name|FIELD_BADFAXRUN
argument_list|)
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"  Consecutive Bad Fax Lines: %lu\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sp
operator|->
name|badfaxrun
argument_list|)
expr_stmt|;
if|if
condition|(
name|TIFFFieldSet
argument_list|(
name|tif
argument_list|,
name|FIELD_RECVPARAMS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"  Fax Receive Parameters: %08lx\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sp
operator|->
name|recvparams
argument_list|)
expr_stmt|;
if|if
condition|(
name|TIFFFieldSet
argument_list|(
name|tif
argument_list|,
name|FIELD_SUBADDRESS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"  Fax SubAddress: %s\n"
argument_list|,
name|sp
operator|->
name|subaddress
argument_list|)
expr_stmt|;
if|if
condition|(
name|TIFFFieldSet
argument_list|(
name|tif
argument_list|,
name|FIELD_RECVTIME
argument_list|)
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"  Fax Receive Time: %lu secs\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sp
operator|->
name|recvtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|TIFFFieldSet
argument_list|(
name|tif
argument_list|,
name|FIELD_FAXDCS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"  Fax DCS: %s\n"
argument_list|,
name|sp
operator|->
name|faxdcs
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|InitCCITTFax3
name|InitCCITTFax3
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|Fax3BaseState
modifier|*
name|sp
decl_stmt|;
comment|/* 	 * Merge codec-specific tag information. 	 */
if|if
condition|(
operator|!
name|_TIFFMergeFieldInfo
argument_list|(
name|tif
argument_list|,
name|faxFieldInfo
argument_list|,
name|N
argument_list|(
name|faxFieldInfo
argument_list|)
argument_list|)
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
literal|"InitCCITTFax3"
argument_list|,
literal|"Merging common CCITT Fax codec-specific tags failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Allocate state block so tag methods have storage to record values. 	 */
name|tif
operator|->
name|tif_data
operator|=
operator|(
name|tidata_t
operator|)
name|_TIFFmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Fax3CodecState
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tif
operator|->
name|tif_data
operator|==
name|NULL
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
literal|"TIFFInitCCITTFax3"
argument_list|,
literal|"%s: No space for state block"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sp
operator|=
name|Fax3State
argument_list|(
name|tif
argument_list|)
expr_stmt|;
name|sp
operator|->
name|rw_mode
operator|=
name|tif
operator|->
name|tif_mode
expr_stmt|;
comment|/* 	 * Override parent get/set field methods. 	 */
name|sp
operator|->
name|vgetparent
operator|=
name|tif
operator|->
name|tif_tagmethods
operator|.
name|vgetfield
expr_stmt|;
name|tif
operator|->
name|tif_tagmethods
operator|.
name|vgetfield
operator|=
name|Fax3VGetField
expr_stmt|;
comment|/* hook for codec tags */
name|sp
operator|->
name|vsetparent
operator|=
name|tif
operator|->
name|tif_tagmethods
operator|.
name|vsetfield
expr_stmt|;
name|tif
operator|->
name|tif_tagmethods
operator|.
name|vsetfield
operator|=
name|Fax3VSetField
expr_stmt|;
comment|/* hook for codec tags */
name|sp
operator|->
name|printdir
operator|=
name|tif
operator|->
name|tif_tagmethods
operator|.
name|printdir
expr_stmt|;
name|tif
operator|->
name|tif_tagmethods
operator|.
name|printdir
operator|=
name|Fax3PrintDir
expr_stmt|;
comment|/* hook for codec tags */
name|sp
operator|->
name|groupoptions
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|recvparams
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|subaddress
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|faxdcs
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|rw_mode
operator|==
name|O_RDONLY
condition|)
comment|/* FIXME: improve for in place update */
name|tif
operator|->
name|tif_flags
operator||=
name|TIFF_NOBITREV
expr_stmt|;
comment|/* decoder does bit reversal */
name|DecoderState
argument_list|(
name|tif
argument_list|)
operator|->
name|runs
operator|=
name|NULL
expr_stmt|;
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_FAXFILLFUNC
argument_list|,
name|_TIFFFax3fillruns
argument_list|)
expr_stmt|;
name|EncoderState
argument_list|(
name|tif
argument_list|)
operator|->
name|refline
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Install codec methods. 	 */
name|tif
operator|->
name|tif_setupdecode
operator|=
name|Fax3SetupState
expr_stmt|;
name|tif
operator|->
name|tif_predecode
operator|=
name|Fax3PreDecode
expr_stmt|;
name|tif
operator|->
name|tif_decoderow
operator|=
name|Fax3Decode1D
expr_stmt|;
name|tif
operator|->
name|tif_decodestrip
operator|=
name|Fax3Decode1D
expr_stmt|;
name|tif
operator|->
name|tif_decodetile
operator|=
name|Fax3Decode1D
expr_stmt|;
name|tif
operator|->
name|tif_setupencode
operator|=
name|Fax3SetupState
expr_stmt|;
name|tif
operator|->
name|tif_preencode
operator|=
name|Fax3PreEncode
expr_stmt|;
name|tif
operator|->
name|tif_postencode
operator|=
name|Fax3PostEncode
expr_stmt|;
name|tif
operator|->
name|tif_encoderow
operator|=
name|Fax3Encode
expr_stmt|;
name|tif
operator|->
name|tif_encodestrip
operator|=
name|Fax3Encode
expr_stmt|;
name|tif
operator|->
name|tif_encodetile
operator|=
name|Fax3Encode
expr_stmt|;
name|tif
operator|->
name|tif_close
operator|=
name|Fax3Close
expr_stmt|;
name|tif
operator|->
name|tif_cleanup
operator|=
name|Fax3Cleanup
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_function
name|int
DECL|function|TIFFInitCCITTFax3
name|TIFFInitCCITTFax3
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|int
name|scheme
parameter_list|)
block|{
operator|(
name|void
operator|)
name|scheme
expr_stmt|;
if|if
condition|(
name|InitCCITTFax3
argument_list|(
name|tif
argument_list|)
condition|)
block|{
comment|/* 		 * Merge codec-specific tag information. 		 */
if|if
condition|(
operator|!
name|_TIFFMergeFieldInfo
argument_list|(
name|tif
argument_list|,
name|fax3FieldInfo
argument_list|,
name|N
argument_list|(
name|fax3FieldInfo
argument_list|)
argument_list|)
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
literal|"TIFFInitCCITTFax3"
argument_list|,
literal|"Merging CCITT Fax 3 codec-specific tags failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 		 * The default format is Class/F-style w/o RTC. 		 */
return|return
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_FAXMODE
argument_list|,
name|FAXMODE_CLASSF
argument_list|)
return|;
block|}
else|else
return|return
literal|01
return|;
block|}
end_function
begin_comment
comment|/*  * CCITT Group 4 (T.6) Facsimile-compatible  * Compression Scheme Support.  */
end_comment
begin_define
DECL|macro|SWAP
define|#
directive|define
name|SWAP
parameter_list|(
name|t
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|)
value|{ t x; x = (a); (a) = (b); (b) = x; }
end_define
begin_comment
comment|/*  * Decode the requested amount of G4-encoded data.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|Fax4Decode
name|Fax4Decode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|buf
parameter_list|,
name|tsize_t
name|occ
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|DECLARE_STATE_2D
argument_list|(
name|tif
argument_list|,
name|sp
argument_list|,
literal|"Fax4Decode"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|s
expr_stmt|;
name|CACHE_STATE
argument_list|(
name|tif
argument_list|,
name|sp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|long
operator|)
name|occ
operator|>
literal|0
condition|)
block|{
name|a0
operator|=
literal|0
expr_stmt|;
name|RunLength
operator|=
literal|0
expr_stmt|;
name|pa
operator|=
name|thisrun
operator|=
name|sp
operator|->
name|curruns
expr_stmt|;
name|pb
operator|=
name|sp
operator|->
name|refruns
expr_stmt|;
name|b1
operator|=
operator|*
name|pb
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|FAX3_DEBUG
name|printf
argument_list|(
literal|"\nBitAcc=%08X, BitsAvail = %d\n"
argument_list|,
name|BitAcc
argument_list|,
name|BitsAvail
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-------------------- %d\n"
argument_list|,
name|tif
operator|->
name|tif_row
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|EXPAND2D
argument_list|(
name|EOFG4
argument_list|)
expr_stmt|;
if|if
condition|(
name|EOLcnt
condition|)
goto|goto
name|EOFG4
goto|;
call|(
modifier|*
name|sp
operator|->
name|fill
call|)
argument_list|(
name|buf
argument_list|,
name|thisrun
argument_list|,
name|pa
argument_list|,
name|lastx
argument_list|)
expr_stmt|;
name|SETVALUE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* imaginary change for reference */
name|SWAP
argument_list|(
name|uint32
operator|*
argument_list|,
name|sp
operator|->
name|curruns
argument_list|,
name|sp
operator|->
name|refruns
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|sp
operator|->
name|b
operator|.
name|rowbytes
expr_stmt|;
name|occ
operator|-=
name|sp
operator|->
name|b
operator|.
name|rowbytes
expr_stmt|;
name|sp
operator|->
name|line
operator|++
expr_stmt|;
continue|continue;
name|EOFG4
label|:
name|NeedBits16
argument_list|(
literal|13
argument_list|,
name|BADG4
argument_list|)
expr_stmt|;
name|BADG4
label|:
ifdef|#
directive|ifdef
name|FAX3_DEBUG
if|if
condition|(
name|GetBits
argument_list|(
literal|13
argument_list|)
operator|!=
literal|0x1001
condition|)
name|fputs
argument_list|(
literal|"Bad RTC\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ClrBits
argument_list|(
literal|13
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sp
operator|->
name|fill
call|)
argument_list|(
name|buf
argument_list|,
name|thisrun
argument_list|,
name|pa
argument_list|,
name|lastx
argument_list|)
expr_stmt|;
name|UNCACHE_STATE
argument_list|(
name|tif
argument_list|,
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|UNCACHE_STATE
argument_list|(
name|tif
argument_list|,
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_undef
DECL|macro|SWAP
undef|#
directive|undef
name|SWAP
end_undef
begin_comment
comment|/*  * Encode the requested amount of data.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|Fax4Encode
name|Fax4Encode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|bp
parameter_list|,
name|tsize_t
name|cc
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|Fax3CodecState
modifier|*
name|sp
init|=
name|EncoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|s
expr_stmt|;
while|while
condition|(
operator|(
name|long
operator|)
name|cc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|Fax3Encode2DRow
argument_list|(
name|tif
argument_list|,
name|bp
argument_list|,
name|sp
operator|->
name|refline
argument_list|,
name|sp
operator|->
name|b
operator|.
name|rowpixels
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|_TIFFmemcpy
argument_list|(
name|sp
operator|->
name|refline
argument_list|,
name|bp
argument_list|,
name|sp
operator|->
name|b
operator|.
name|rowbytes
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|sp
operator|->
name|b
operator|.
name|rowbytes
expr_stmt|;
name|cc
operator|-=
name|sp
operator|->
name|b
operator|.
name|rowbytes
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|Fax4PostEncode
name|Fax4PostEncode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|Fax3CodecState
modifier|*
name|sp
init|=
name|EncoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
comment|/* terminate strip w/ EOFB */
name|Fax3PutBits
argument_list|(
name|tif
argument_list|,
name|EOL
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|Fax3PutBits
argument_list|(
name|tif
argument_list|,
name|EOL
argument_list|,
literal|12
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|bit
operator|!=
literal|8
condition|)
name|Fax3FlushBits
argument_list|(
name|tif
argument_list|,
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_function
name|int
DECL|function|TIFFInitCCITTFax4
name|TIFFInitCCITTFax4
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|int
name|scheme
parameter_list|)
block|{
operator|(
name|void
operator|)
name|scheme
expr_stmt|;
if|if
condition|(
name|InitCCITTFax3
argument_list|(
name|tif
argument_list|)
condition|)
block|{
comment|/* reuse G3 support */
comment|/* 		 * Merge codec-specific tag information. 		 */
if|if
condition|(
operator|!
name|_TIFFMergeFieldInfo
argument_list|(
name|tif
argument_list|,
name|fax4FieldInfo
argument_list|,
name|N
argument_list|(
name|fax4FieldInfo
argument_list|)
argument_list|)
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
literal|"TIFFInitCCITTFax4"
argument_list|,
literal|"Merging CCITT Fax 4 codec-specific tags failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|tif
operator|->
name|tif_decoderow
operator|=
name|Fax4Decode
expr_stmt|;
name|tif
operator|->
name|tif_decodestrip
operator|=
name|Fax4Decode
expr_stmt|;
name|tif
operator|->
name|tif_decodetile
operator|=
name|Fax4Decode
expr_stmt|;
name|tif
operator|->
name|tif_encoderow
operator|=
name|Fax4Encode
expr_stmt|;
name|tif
operator|->
name|tif_encodestrip
operator|=
name|Fax4Encode
expr_stmt|;
name|tif
operator|->
name|tif_encodetile
operator|=
name|Fax4Encode
expr_stmt|;
name|tif
operator|->
name|tif_postencode
operator|=
name|Fax4PostEncode
expr_stmt|;
comment|/* 		 * Suppress RTC at the end of each strip. 		 */
return|return
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_FAXMODE
argument_list|,
name|FAXMODE_NORTC
argument_list|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * CCITT Group 3 1-D Modified Huffman RLE Compression Support.  * (Compression algorithms 2 and 32771)  */
end_comment
begin_comment
comment|/*  * Decode the requested amount of RLE-encoded data.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|Fax3DecodeRLE
name|Fax3DecodeRLE
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|buf
parameter_list|,
name|tsize_t
name|occ
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|DECLARE_STATE
argument_list|(
name|tif
argument_list|,
name|sp
argument_list|,
literal|"Fax3DecodeRLE"
argument_list|)
expr_stmt|;
name|int
name|mode
init|=
name|sp
operator|->
name|b
operator|.
name|mode
decl_stmt|;
operator|(
name|void
operator|)
name|s
expr_stmt|;
name|CACHE_STATE
argument_list|(
name|tif
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|thisrun
operator|=
name|sp
operator|->
name|curruns
expr_stmt|;
while|while
condition|(
operator|(
name|long
operator|)
name|occ
operator|>
literal|0
condition|)
block|{
name|a0
operator|=
literal|0
expr_stmt|;
name|RunLength
operator|=
literal|0
expr_stmt|;
name|pa
operator|=
name|thisrun
expr_stmt|;
ifdef|#
directive|ifdef
name|FAX3_DEBUG
name|printf
argument_list|(
literal|"\nBitAcc=%08X, BitsAvail = %d\n"
argument_list|,
name|BitAcc
argument_list|,
name|BitsAvail
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-------------------- %d\n"
argument_list|,
name|tif
operator|->
name|tif_row
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|EXPAND1D
argument_list|(
name|EOFRLE
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sp
operator|->
name|fill
call|)
argument_list|(
name|buf
argument_list|,
name|thisrun
argument_list|,
name|pa
argument_list|,
name|lastx
argument_list|)
expr_stmt|;
comment|/* 		 * Cleanup at the end of the row. 		 */
if|if
condition|(
name|mode
operator|&
name|FAXMODE_BYTEALIGN
condition|)
block|{
name|int
name|n
init|=
name|BitsAvail
operator|-
operator|(
name|BitsAvail
operator|&
operator|~
literal|7
operator|)
decl_stmt|;
name|ClrBits
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|&
name|FAXMODE_WORDALIGN
condition|)
block|{
name|int
name|n
init|=
name|BitsAvail
operator|-
operator|(
name|BitsAvail
operator|&
operator|~
literal|15
operator|)
decl_stmt|;
name|ClrBits
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|BitsAvail
operator|==
literal|0
operator|&&
operator|!
name|isAligned
argument_list|(
name|cp
argument_list|,
name|uint16
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
block|}
name|buf
operator|+=
name|sp
operator|->
name|b
operator|.
name|rowbytes
expr_stmt|;
name|occ
operator|-=
name|sp
operator|->
name|b
operator|.
name|rowbytes
expr_stmt|;
name|sp
operator|->
name|line
operator|++
expr_stmt|;
continue|continue;
name|EOFRLE
label|:
comment|/* premature EOF */
call|(
modifier|*
name|sp
operator|->
name|fill
call|)
argument_list|(
name|buf
argument_list|,
name|thisrun
argument_list|,
name|pa
argument_list|,
name|lastx
argument_list|)
expr_stmt|;
name|UNCACHE_STATE
argument_list|(
name|tif
argument_list|,
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|UNCACHE_STATE
argument_list|(
name|tif
argument_list|,
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_function
name|int
DECL|function|TIFFInitCCITTRLE
name|TIFFInitCCITTRLE
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|int
name|scheme
parameter_list|)
block|{
operator|(
name|void
operator|)
name|scheme
expr_stmt|;
if|if
condition|(
name|InitCCITTFax3
argument_list|(
name|tif
argument_list|)
condition|)
block|{
comment|/* reuse G3 support */
name|tif
operator|->
name|tif_decoderow
operator|=
name|Fax3DecodeRLE
expr_stmt|;
name|tif
operator|->
name|tif_decodestrip
operator|=
name|Fax3DecodeRLE
expr_stmt|;
name|tif
operator|->
name|tif_decodetile
operator|=
name|Fax3DecodeRLE
expr_stmt|;
comment|/* 		 * Suppress RTC+EOLs when encoding and byte-align data. 		 */
return|return
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_FAXMODE
argument_list|,
name|FAXMODE_NORTC
operator||
name|FAXMODE_NOEOL
operator||
name|FAXMODE_BYTEALIGN
argument_list|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function
begin_function
name|int
DECL|function|TIFFInitCCITTRLEW
name|TIFFInitCCITTRLEW
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|int
name|scheme
parameter_list|)
block|{
operator|(
name|void
operator|)
name|scheme
expr_stmt|;
if|if
condition|(
name|InitCCITTFax3
argument_list|(
name|tif
argument_list|)
condition|)
block|{
comment|/* reuse G3 support */
name|tif
operator|->
name|tif_decoderow
operator|=
name|Fax3DecodeRLE
expr_stmt|;
name|tif
operator|->
name|tif_decodestrip
operator|=
name|Fax3DecodeRLE
expr_stmt|;
name|tif
operator|->
name|tif_decodetile
operator|=
name|Fax3DecodeRLE
expr_stmt|;
comment|/* 		 * Suppress RTC+EOLs when encoding and word-align data. 		 */
return|return
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_FAXMODE
argument_list|,
name|FAXMODE_NORTC
operator||
name|FAXMODE_NOEOL
operator||
name|FAXMODE_WORDALIGN
argument_list|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* CCITT_SUPPORT */
end_comment
begin_comment
comment|/* vim: set ts=8 sts=8 sw=8 noet: */
end_comment
end_unit
