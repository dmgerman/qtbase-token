begin_unit
begin_comment
comment|/* $Id: tif_strip.c,v 1.19 2006/03/25 18:04:35 joris Exp $ */
end_comment
begin_comment
comment|/*  * Copyright (c) 1991-1997 Sam Leffler  * Copyright (c) 1991-1997 Silicon Graphics, Inc.  *  * Permission to use, copy, modify, distribute, and sell this software and   * its documentation for any purpose is hereby granted without fee, provided  * that (i) the above copyright notices and this permission notice appear in  * all copies of the software and related documentation, and (ii) the names of  * Sam Leffler and Silicon Graphics may not be used in any advertising or  * publicity relating to the software without the specific, prior written  * permission of Sam Leffler and Silicon Graphics.  *   * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,   * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY   * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.    *   * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR  * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,  * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF   * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE   * OF THIS SOFTWARE.  */
end_comment
begin_comment
comment|/*  * TIFF Library.  *  * Strip-organized Image Support Routines.  */
end_comment
begin_include
include|#
directive|include
file|"tiffiop.h"
end_include
begin_function
specifier|static
name|uint32
DECL|function|summarize
name|summarize
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|size_t
name|summand1
parameter_list|,
name|size_t
name|summand2
parameter_list|,
specifier|const
name|char
modifier|*
name|where
parameter_list|)
block|{
comment|/* 	 * XXX: We are using casting to uint32 here, bacause sizeof(size_t) 	 * may be larger than sizeof(uint32) on 64-bit architectures. 	 */
name|uint32
name|bytes
init|=
name|summand1
operator|+
name|summand2
decl_stmt|;
if|if
condition|(
name|bytes
operator|-
name|summand1
operator|!=
name|summand2
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"Integer overflow in %s"
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|bytes
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|bytes
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|uint32
DECL|function|multiply
name|multiply
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|size_t
name|nmemb
parameter_list|,
name|size_t
name|elem_size
parameter_list|,
specifier|const
name|char
modifier|*
name|where
parameter_list|)
block|{
name|uint32
name|bytes
init|=
name|nmemb
operator|*
name|elem_size
decl_stmt|;
if|if
condition|(
name|elem_size
operator|&&
name|bytes
operator|/
name|elem_size
operator|!=
name|nmemb
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"Integer overflow in %s"
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|bytes
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|bytes
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Compute which strip a (row,sample) value is in.  */
end_comment
begin_function
name|tstrip_t
DECL|function|TIFFComputeStrip
name|TIFFComputeStrip
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|uint32
name|row
parameter_list|,
name|tsample_t
name|sample
parameter_list|)
block|{
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|tstrip_t
name|strip
decl_stmt|;
name|strip
operator|=
name|row
operator|/
name|td
operator|->
name|td_rowsperstrip
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_planarconfig
operator|==
name|PLANARCONFIG_SEPARATE
condition|)
block|{
if|if
condition|(
name|sample
operator|>=
name|td
operator|->
name|td_samplesperpixel
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"%lu: Sample out of range, max %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sample
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|td
operator|->
name|td_samplesperpixel
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|tstrip_t
operator|)
literal|0
operator|)
return|;
block|}
name|strip
operator|+=
name|sample
operator|*
name|td
operator|->
name|td_stripsperimage
expr_stmt|;
block|}
return|return
operator|(
name|strip
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Compute how many strips are in an image.  */
end_comment
begin_function
name|tstrip_t
DECL|function|TIFFNumberOfStrips
name|TIFFNumberOfStrips
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|tstrip_t
name|nstrips
decl_stmt|;
name|nstrips
operator|=
operator|(
name|td
operator|->
name|td_rowsperstrip
operator|==
operator|(
name|uint32
operator|)
operator|-
literal|1
condition|?
literal|1
else|:
name|TIFFhowmany
argument_list|(
name|td
operator|->
name|td_imagelength
argument_list|,
name|td
operator|->
name|td_rowsperstrip
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_planarconfig
operator|==
name|PLANARCONFIG_SEPARATE
condition|)
name|nstrips
operator|=
name|multiply
argument_list|(
name|tif
argument_list|,
name|nstrips
argument_list|,
name|td
operator|->
name|td_samplesperpixel
argument_list|,
literal|"TIFFNumberOfStrips"
argument_list|)
expr_stmt|;
return|return
operator|(
name|nstrips
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Compute the # bytes in a variable height, row-aligned strip.  */
end_comment
begin_function
name|tsize_t
DECL|function|TIFFVStripSize
name|TIFFVStripSize
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|uint32
name|nrows
parameter_list|)
block|{
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
if|if
condition|(
name|nrows
operator|==
operator|(
name|uint32
operator|)
operator|-
literal|1
condition|)
name|nrows
operator|=
name|td
operator|->
name|td_imagelength
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_planarconfig
operator|==
name|PLANARCONFIG_CONTIG
operator|&&
name|td
operator|->
name|td_photometric
operator|==
name|PHOTOMETRIC_YCBCR
operator|&&
operator|!
name|isUpSampled
argument_list|(
name|tif
argument_list|)
condition|)
block|{
comment|/* 		 * Packed YCbCr data contain one Cb+Cr for every 		 * HorizontalSampling*VerticalSampling Y values. 		 * Must also roundup width and height when calculating 		 * since images that are not a multiple of the 		 * horizontal/vertical subsampling area include 		 * YCbCr data for the extended image. 		 */
name|uint16
name|ycbcrsubsampling
index|[
literal|2
index|]
decl_stmt|;
name|tsize_t
name|w
decl_stmt|,
name|scanline
decl_stmt|,
name|samplingarea
decl_stmt|;
name|TIFFGetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_YCBCRSUBSAMPLING
argument_list|,
name|ycbcrsubsampling
operator|+
literal|0
argument_list|,
name|ycbcrsubsampling
operator|+
literal|1
argument_list|)
expr_stmt|;
name|samplingarea
operator|=
name|ycbcrsubsampling
index|[
literal|0
index|]
operator|*
name|ycbcrsubsampling
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|samplingarea
operator|==
literal|0
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"Invalid YCbCr subsampling"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|w
operator|=
name|TIFFroundup
argument_list|(
name|td
operator|->
name|td_imagewidth
argument_list|,
name|ycbcrsubsampling
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|scanline
operator|=
name|TIFFhowmany8
argument_list|(
name|multiply
argument_list|(
name|tif
argument_list|,
name|w
argument_list|,
name|td
operator|->
name|td_bitspersample
argument_list|,
literal|"TIFFVStripSize"
argument_list|)
argument_list|)
expr_stmt|;
name|nrows
operator|=
name|TIFFroundup
argument_list|(
name|nrows
argument_list|,
name|ycbcrsubsampling
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* NB: don't need TIFFhowmany here 'cuz everything is rounded */
name|scanline
operator|=
name|multiply
argument_list|(
name|tif
argument_list|,
name|nrows
argument_list|,
name|scanline
argument_list|,
literal|"TIFFVStripSize"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|tsize_t
operator|)
name|summarize
argument_list|(
name|tif
argument_list|,
name|scanline
argument_list|,
name|multiply
argument_list|(
name|tif
argument_list|,
literal|2
argument_list|,
name|scanline
operator|/
name|samplingarea
argument_list|,
literal|"TIFFVStripSize"
argument_list|)
argument_list|,
literal|"TIFFVStripSize"
argument_list|)
operator|)
return|;
block|}
else|else
return|return
operator|(
operator|(
name|tsize_t
operator|)
name|multiply
argument_list|(
name|tif
argument_list|,
name|nrows
argument_list|,
name|TIFFScanlineSize
argument_list|(
name|tif
argument_list|)
argument_list|,
literal|"TIFFVStripSize"
argument_list|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Compute the # bytes in a raw strip.  */
end_comment
begin_function
name|tsize_t
DECL|function|TIFFRawStripSize
name|TIFFRawStripSize
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tstrip_t
name|strip
parameter_list|)
block|{
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|tsize_t
name|bytecount
init|=
name|td
operator|->
name|td_stripbytecount
index|[
name|strip
index|]
decl_stmt|;
if|if
condition|(
name|bytecount
operator|<=
literal|0
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"%lu: Invalid strip byte count, strip %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|bytecount
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|strip
argument_list|)
expr_stmt|;
name|bytecount
operator|=
operator|(
name|tsize_t
operator|)
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|bytecount
return|;
block|}
end_function
begin_comment
comment|/*  * Compute the # bytes in a (row-aligned) strip.  *  * Note that if RowsPerStrip is larger than the  * recorded ImageLength, then the strip size is  * truncated to reflect the actual space required  * to hold the strip.  */
end_comment
begin_function
name|tsize_t
DECL|function|TIFFStripSize
name|TIFFStripSize
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|uint32
name|rps
init|=
name|td
operator|->
name|td_rowsperstrip
decl_stmt|;
if|if
condition|(
name|rps
operator|>
name|td
operator|->
name|td_imagelength
condition|)
name|rps
operator|=
name|td
operator|->
name|td_imagelength
expr_stmt|;
return|return
operator|(
name|TIFFVStripSize
argument_list|(
name|tif
argument_list|,
name|rps
argument_list|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Compute a default strip size based on the image  * characteristics and a requested value.  If the  * request is<1 then we choose a strip size according  * to certain heuristics.  */
end_comment
begin_function
name|uint32
DECL|function|TIFFDefaultStripSize
name|TIFFDefaultStripSize
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|uint32
name|request
parameter_list|)
block|{
return|return
call|(
modifier|*
name|tif
operator|->
name|tif_defstripsize
call|)
argument_list|(
name|tif
argument_list|,
name|request
argument_list|)
return|;
block|}
end_function
begin_function
name|uint32
DECL|function|_TIFFDefaultStripSize
name|_TIFFDefaultStripSize
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|uint32
name|s
parameter_list|)
block|{
if|if
condition|(
operator|(
name|int32
operator|)
name|s
operator|<
literal|1
condition|)
block|{
comment|/* 		 * If RowsPerStrip is unspecified, try to break the 		 * image up into strips that are approximately 		 * STRIP_SIZE_DEFAULT bytes long. 		 */
name|tsize_t
name|scanline
init|=
name|TIFFScanlineSize
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|s
operator|=
operator|(
name|uint32
operator|)
name|STRIP_SIZE_DEFAULT
operator|/
operator|(
name|scanline
operator|==
literal|0
condition|?
literal|1
else|:
name|scanline
operator|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
comment|/* very wide images */
name|s
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Return the number of bytes to read/write in a call to  * one of the scanline-oriented i/o routines.  Note that  * this number may be 1/samples-per-pixel if data is  * stored as separate planes.  */
end_comment
begin_function
name|tsize_t
DECL|function|TIFFScanlineSize
name|TIFFScanlineSize
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|tsize_t
name|scanline
decl_stmt|;
if|if
condition|(
name|td
operator|->
name|td_planarconfig
operator|==
name|PLANARCONFIG_CONTIG
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|td_photometric
operator|==
name|PHOTOMETRIC_YCBCR
operator|&&
operator|!
name|isUpSampled
argument_list|(
name|tif
argument_list|)
condition|)
block|{
name|uint16
name|ycbcrsubsampling
index|[
literal|2
index|]
decl_stmt|;
name|TIFFGetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_YCBCRSUBSAMPLING
argument_list|,
name|ycbcrsubsampling
operator|+
literal|0
argument_list|,
name|ycbcrsubsampling
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ycbcrsubsampling
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"Invalid YCbCr subsampling"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|scanline
operator|=
name|TIFFroundup
argument_list|(
name|td
operator|->
name|td_imagewidth
argument_list|,
name|ycbcrsubsampling
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|scanline
operator|=
name|TIFFhowmany8
argument_list|(
name|multiply
argument_list|(
name|tif
argument_list|,
name|scanline
argument_list|,
name|td
operator|->
name|td_bitspersample
argument_list|,
literal|"TIFFScanlineSize"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|tsize_t
operator|)
name|summarize
argument_list|(
name|tif
argument_list|,
name|scanline
argument_list|,
name|multiply
argument_list|(
name|tif
argument_list|,
literal|2
argument_list|,
name|scanline
operator|/
name|ycbcrsubsampling
index|[
literal|0
index|]
argument_list|,
literal|"TIFFVStripSize"
argument_list|)
argument_list|,
literal|"TIFFVStripSize"
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|scanline
operator|=
name|multiply
argument_list|(
name|tif
argument_list|,
name|td
operator|->
name|td_imagewidth
argument_list|,
name|td
operator|->
name|td_samplesperpixel
argument_list|,
literal|"TIFFScanlineSize"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|scanline
operator|=
name|td
operator|->
name|td_imagewidth
expr_stmt|;
return|return
operator|(
operator|(
name|tsize_t
operator|)
name|TIFFhowmany8
argument_list|(
name|multiply
argument_list|(
name|tif
argument_list|,
name|scanline
argument_list|,
name|td
operator|->
name|td_bitspersample
argument_list|,
literal|"TIFFScanlineSize"
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Some stuff depends on this older version of TIFFScanlineSize  * TODO: resolve this  */
end_comment
begin_function
name|tsize_t
DECL|function|TIFFOldScanlineSize
name|TIFFOldScanlineSize
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|tsize_t
name|scanline
decl_stmt|;
name|scanline
operator|=
name|multiply
argument_list|(
name|tif
argument_list|,
name|td
operator|->
name|td_bitspersample
argument_list|,
name|td
operator|->
name|td_imagewidth
argument_list|,
literal|"TIFFScanlineSize"
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_planarconfig
operator|==
name|PLANARCONFIG_CONTIG
condition|)
name|scanline
operator|=
name|multiply
argument_list|(
name|tif
argument_list|,
name|scanline
argument_list|,
name|td
operator|->
name|td_samplesperpixel
argument_list|,
literal|"TIFFScanlineSize"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|tsize_t
operator|)
name|TIFFhowmany8
argument_list|(
name|scanline
argument_list|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Return the number of bytes to read/write in a call to  * one of the scanline-oriented i/o routines.  Note that  * this number may be 1/samples-per-pixel if data is  * stored as separate planes.  * The ScanlineSize in case of YCbCrSubsampling is defined as the  * strip size divided by the strip height, i.e. the size of a pack of vertical  * subsampling lines divided by vertical subsampling. It should thus make  * sense when multiplied by a multiple of vertical subsampling.  * Some stuff depends on this newer version of TIFFScanlineSize  * TODO: resolve this  */
end_comment
begin_function
name|tsize_t
DECL|function|TIFFNewScanlineSize
name|TIFFNewScanlineSize
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|tsize_t
name|scanline
decl_stmt|;
if|if
condition|(
name|td
operator|->
name|td_planarconfig
operator|==
name|PLANARCONFIG_CONTIG
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|td_photometric
operator|==
name|PHOTOMETRIC_YCBCR
operator|&&
operator|!
name|isUpSampled
argument_list|(
name|tif
argument_list|)
condition|)
block|{
name|uint16
name|ycbcrsubsampling
index|[
literal|2
index|]
decl_stmt|;
name|TIFFGetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_YCBCRSUBSAMPLING
argument_list|,
name|ycbcrsubsampling
operator|+
literal|0
argument_list|,
name|ycbcrsubsampling
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ycbcrsubsampling
index|[
literal|0
index|]
operator|*
name|ycbcrsubsampling
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"Invalid YCbCr subsampling"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|(
call|(
name|tsize_t
call|)
argument_list|(
operator|(
operator|(
operator|(
name|td
operator|->
name|td_imagewidth
operator|+
name|ycbcrsubsampling
index|[
literal|0
index|]
operator|-
literal|1
operator|)
operator|/
name|ycbcrsubsampling
index|[
literal|0
index|]
operator|)
operator|*
operator|(
name|ycbcrsubsampling
index|[
literal|0
index|]
operator|*
name|ycbcrsubsampling
index|[
literal|1
index|]
operator|+
literal|2
operator|)
operator|*
name|td
operator|->
name|td_bitspersample
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|)
operator|/
name|ycbcrsubsampling
index|[
literal|1
index|]
operator|)
return|;
block|}
else|else
block|{
name|scanline
operator|=
name|multiply
argument_list|(
name|tif
argument_list|,
name|td
operator|->
name|td_imagewidth
argument_list|,
name|td
operator|->
name|td_samplesperpixel
argument_list|,
literal|"TIFFScanlineSize"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|scanline
operator|=
name|td
operator|->
name|td_imagewidth
expr_stmt|;
return|return
operator|(
operator|(
name|tsize_t
operator|)
name|TIFFhowmany8
argument_list|(
name|multiply
argument_list|(
name|tif
argument_list|,
name|scanline
argument_list|,
name|td
operator|->
name|td_bitspersample
argument_list|,
literal|"TIFFScanlineSize"
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Return the number of bytes required to store a complete  * decoded and packed raster scanline (as opposed to the  * I/O size returned by TIFFScanlineSize which may be less  * if data is store as separate planes).  */
end_comment
begin_function
name|tsize_t
DECL|function|TIFFRasterScanlineSize
name|TIFFRasterScanlineSize
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|tsize_t
name|scanline
decl_stmt|;
name|scanline
operator|=
name|multiply
argument_list|(
name|tif
argument_list|,
name|td
operator|->
name|td_bitspersample
argument_list|,
name|td
operator|->
name|td_imagewidth
argument_list|,
literal|"TIFFRasterScanlineSize"
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_planarconfig
operator|==
name|PLANARCONFIG_CONTIG
condition|)
block|{
name|scanline
operator|=
name|multiply
argument_list|(
name|tif
argument_list|,
name|scanline
argument_list|,
name|td
operator|->
name|td_samplesperpixel
argument_list|,
literal|"TIFFRasterScanlineSize"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|tsize_t
operator|)
name|TIFFhowmany8
argument_list|(
name|scanline
argument_list|)
operator|)
return|;
block|}
else|else
return|return
operator|(
operator|(
name|tsize_t
operator|)
name|multiply
argument_list|(
name|tif
argument_list|,
name|TIFFhowmany8
argument_list|(
name|scanline
argument_list|)
argument_list|,
name|td
operator|->
name|td_samplesperpixel
argument_list|,
literal|"TIFFRasterScanlineSize"
argument_list|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/* vim: set ts=8 sts=8 sw=8 noet: */
end_comment
end_unit
