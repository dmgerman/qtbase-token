begin_unit
begin_comment
comment|/* $Id: tif_lzw.c,v 1.29.2.5 2009-06-22 04:57:31 fwarmerdam Exp $ */
end_comment
begin_comment
comment|/*  * Copyright (c) 1988-1997 Sam Leffler  * Copyright (c) 1991-1997 Silicon Graphics, Inc.  *  * Permission to use, copy, modify, distribute, and sell this software and   * its documentation for any purpose is hereby granted without fee, provided  * that (i) the above copyright notices and this permission notice appear in  * all copies of the software and related documentation, and (ii) the names of  * Sam Leffler and Silicon Graphics may not be used in any advertising or  * publicity relating to the software without the specific, prior written  * permission of Sam Leffler and Silicon Graphics.  *   * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,   * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY   * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.    *   * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR  * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,  * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF   * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE   * OF THIS SOFTWARE.  */
end_comment
begin_include
include|#
directive|include
file|"tiffiop.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|LZW_SUPPORT
end_ifdef
begin_comment
comment|/*  * TIFF Library.  * Rev 5.0 Lempel-Ziv& Welch Compression Support  *  * This code is derived from the compress program whose code is  * derived from software contributed to Berkeley by James A. Woods,  * derived from original work by Spencer Thomas and Joseph Orost.  *  * The original Berkeley copyright notice appears below in its entirety.  */
end_comment
begin_include
include|#
directive|include
file|"tif_predict.h"
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_comment
comment|/*  * NB: The 5.0 spec describes a different algorithm than Aldus  *     implements.  Specifically, Aldus does code length transitions  *     one code earlier than should be done (for real LZW).  *     Earlier versions of this library implemented the correct  *     LZW algorithm, but emitted codes in a bit order opposite  *     to the TIFF spec.  Thus, to maintain compatibility w/ Aldus  *     we interpret MSB-LSB ordered codes to be images written w/  *     old versions of this library, but otherwise adhere to the  *     Aldus "off by one" algorithm.  *  * Future revisions to the TIFF spec are expected to "clarify this issue".  */
end_comment
begin_define
DECL|macro|LZW_COMPAT
define|#
directive|define
name|LZW_COMPAT
end_define
begin_comment
DECL|macro|LZW_COMPAT
comment|/* include backwards compatibility code */
end_comment
begin_comment
comment|/*  * Each strip of data is supposed to be terminated by a CODE_EOI.  * If the following #define is included, the decoder will also  * check for end-of-strip w/o seeing this code.  This makes the  * library more robust, but also slower.  */
end_comment
begin_define
DECL|macro|LZW_CHECKEOS
define|#
directive|define
name|LZW_CHECKEOS
end_define
begin_comment
DECL|macro|LZW_CHECKEOS
comment|/* include checks for strips w/o EOI code */
end_comment
begin_define
DECL|macro|MAXCODE
define|#
directive|define
name|MAXCODE
parameter_list|(
name|n
parameter_list|)
value|((1L<<(n))-1)
end_define
begin_comment
comment|/*  * The TIFF spec specifies that encoded bit  * strings range from 9 to 12 bits.  */
end_comment
begin_define
DECL|macro|BITS_MIN
define|#
directive|define
name|BITS_MIN
value|9
end_define
begin_comment
DECL|macro|BITS_MIN
comment|/* start with 9 bits */
end_comment
begin_define
DECL|macro|BITS_MAX
define|#
directive|define
name|BITS_MAX
value|12
end_define
begin_comment
DECL|macro|BITS_MAX
comment|/* max of 12 bit strings */
end_comment
begin_comment
comment|/* predefined codes */
end_comment
begin_define
DECL|macro|CODE_CLEAR
define|#
directive|define
name|CODE_CLEAR
value|256
end_define
begin_comment
DECL|macro|CODE_CLEAR
comment|/* code to clear string table */
end_comment
begin_define
DECL|macro|CODE_EOI
define|#
directive|define
name|CODE_EOI
value|257
end_define
begin_comment
DECL|macro|CODE_EOI
comment|/* end-of-information code */
end_comment
begin_define
DECL|macro|CODE_FIRST
define|#
directive|define
name|CODE_FIRST
value|258
end_define
begin_comment
DECL|macro|CODE_FIRST
comment|/* first free code entry */
end_comment
begin_define
DECL|macro|CODE_MAX
define|#
directive|define
name|CODE_MAX
value|MAXCODE(BITS_MAX)
end_define
begin_define
DECL|macro|HSIZE
define|#
directive|define
name|HSIZE
value|9001L
end_define
begin_comment
DECL|macro|HSIZE
comment|/* 91% occupancy */
end_comment
begin_define
DECL|macro|HSHIFT
define|#
directive|define
name|HSHIFT
value|(13-8)
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|LZW_COMPAT
end_ifdef
begin_comment
comment|/* NB: +1024 is for compatibility with old files */
end_comment
begin_define
DECL|macro|CSIZE
define|#
directive|define
name|CSIZE
value|(MAXCODE(BITS_MAX)+1024L)
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|CSIZE
define|#
directive|define
name|CSIZE
value|(MAXCODE(BITS_MAX)+1L)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*  * State block for each open TIFF file using LZW  * compression/decompression.  Note that the predictor  * state block must be first in this data structure.  */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|predict
name|TIFFPredictorState
name|predict
decl_stmt|;
comment|/* predictor super class */
DECL|member|nbits
name|unsigned
name|short
name|nbits
decl_stmt|;
comment|/* # of bits/code */
DECL|member|maxcode
name|unsigned
name|short
name|maxcode
decl_stmt|;
comment|/* maximum code for lzw_nbits */
DECL|member|free_ent
name|unsigned
name|short
name|free_ent
decl_stmt|;
comment|/* next free entry in hash table */
DECL|member|nextdata
name|long
name|nextdata
decl_stmt|;
comment|/* next bits of i/o */
DECL|member|nextbits
name|long
name|nextbits
decl_stmt|;
comment|/* # of valid bits in lzw_nextdata */
DECL|member|rw_mode
name|int
name|rw_mode
decl_stmt|;
comment|/* preserve rw_mode from init */
block|}
DECL|typedef|LZWBaseState
name|LZWBaseState
typedef|;
end_typedef
begin_define
DECL|macro|lzw_nbits
define|#
directive|define
name|lzw_nbits
value|base.nbits
end_define
begin_define
DECL|macro|lzw_maxcode
define|#
directive|define
name|lzw_maxcode
value|base.maxcode
end_define
begin_define
DECL|macro|lzw_free_ent
define|#
directive|define
name|lzw_free_ent
value|base.free_ent
end_define
begin_define
DECL|macro|lzw_nextdata
define|#
directive|define
name|lzw_nextdata
value|base.nextdata
end_define
begin_define
DECL|macro|lzw_nextbits
define|#
directive|define
name|lzw_nextbits
value|base.nextbits
end_define
begin_comment
comment|/*  * Encoding-specific state.  */
end_comment
begin_typedef
DECL|typedef|hcode_t
typedef|typedef
name|uint16
name|hcode_t
typedef|;
end_typedef
begin_comment
DECL|typedef|hcode_t
comment|/* codes fit in 16 bits */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|hash
name|long
name|hash
decl_stmt|;
DECL|member|code
name|hcode_t
name|code
decl_stmt|;
block|}
DECL|typedef|hash_t
name|hash_t
typedef|;
end_typedef
begin_comment
comment|/*  * Decoding-specific state.  */
end_comment
begin_typedef
DECL|struct|code_ent
typedef|typedef
struct|struct
name|code_ent
block|{
DECL|member|next
name|struct
name|code_ent
modifier|*
name|next
decl_stmt|;
DECL|member|length
name|unsigned
name|short
name|length
decl_stmt|;
comment|/* string len, including this token */
DECL|member|value
name|unsigned
name|char
name|value
decl_stmt|;
comment|/* data value */
DECL|member|firstchar
name|unsigned
name|char
name|firstchar
decl_stmt|;
comment|/* first token of string */
block|}
DECL|typedef|code_t
name|code_t
typedef|;
end_typedef
begin_typedef
DECL|typedef|decodeFunc
typedef|typedef
name|int
function_decl|(
modifier|*
name|decodeFunc
function_decl|)
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|tidata_t
parameter_list|,
name|tsize_t
parameter_list|,
name|tsample_t
parameter_list|)
function_decl|;
end_typedef
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|base
name|LZWBaseState
name|base
decl_stmt|;
comment|/* Decoding specific data */
DECL|member|dec_nbitsmask
name|long
name|dec_nbitsmask
decl_stmt|;
comment|/* lzw_nbits 1 bits, right adjusted */
DECL|member|dec_restart
name|long
name|dec_restart
decl_stmt|;
comment|/* restart count */
ifdef|#
directive|ifdef
name|LZW_CHECKEOS
DECL|member|dec_bitsleft
name|long
name|dec_bitsleft
decl_stmt|;
comment|/* available bits in raw data */
endif|#
directive|endif
DECL|member|dec_decode
name|decodeFunc
name|dec_decode
decl_stmt|;
comment|/* regular or backwards compatible */
DECL|member|dec_codep
name|code_t
modifier|*
name|dec_codep
decl_stmt|;
comment|/* current recognized code */
DECL|member|dec_oldcodep
name|code_t
modifier|*
name|dec_oldcodep
decl_stmt|;
comment|/* previously recognized code */
DECL|member|dec_free_entp
name|code_t
modifier|*
name|dec_free_entp
decl_stmt|;
comment|/* next free entry */
DECL|member|dec_maxcodep
name|code_t
modifier|*
name|dec_maxcodep
decl_stmt|;
comment|/* max available entry */
DECL|member|dec_codetab
name|code_t
modifier|*
name|dec_codetab
decl_stmt|;
comment|/* kept separate for small machines */
comment|/* Encoding specific data */
DECL|member|enc_oldcode
name|int
name|enc_oldcode
decl_stmt|;
comment|/* last code encountered */
DECL|member|enc_checkpoint
name|long
name|enc_checkpoint
decl_stmt|;
comment|/* point at which to clear table */
DECL|macro|CHECK_GAP
define|#
directive|define
name|CHECK_GAP
value|10000
comment|/* enc_ratio check interval */
DECL|member|enc_ratio
name|long
name|enc_ratio
decl_stmt|;
comment|/* current compression ratio */
DECL|member|enc_incount
name|long
name|enc_incount
decl_stmt|;
comment|/* (input) data bytes encoded */
DECL|member|enc_outcount
name|long
name|enc_outcount
decl_stmt|;
comment|/* encoded (output) bytes */
DECL|member|enc_rawlimit
name|tidata_t
name|enc_rawlimit
decl_stmt|;
comment|/* bound on tif_rawdata buffer */
DECL|member|enc_hashtab
name|hash_t
modifier|*
name|enc_hashtab
decl_stmt|;
comment|/* kept separate for small machines */
block|}
DECL|typedef|LZWCodecState
name|LZWCodecState
typedef|;
end_typedef
begin_define
DECL|macro|LZWState
define|#
directive|define
name|LZWState
parameter_list|(
name|tif
parameter_list|)
value|((LZWBaseState*) (tif)->tif_data)
end_define
begin_define
DECL|macro|DecoderState
define|#
directive|define
name|DecoderState
parameter_list|(
name|tif
parameter_list|)
value|((LZWCodecState*) LZWState(tif))
end_define
begin_define
DECL|macro|EncoderState
define|#
directive|define
name|EncoderState
parameter_list|(
name|tif
parameter_list|)
value|((LZWCodecState*) LZWState(tif))
end_define
begin_function_decl
specifier|static
name|int
name|LZWDecode
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|tidata_t
parameter_list|,
name|tsize_t
parameter_list|,
name|tsample_t
parameter_list|)
function_decl|;
end_function_decl
begin_ifdef
ifdef|#
directive|ifdef
name|LZW_COMPAT
end_ifdef
begin_function_decl
specifier|static
name|int
name|LZWDecodeCompat
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|tidata_t
parameter_list|,
name|tsize_t
parameter_list|,
name|tsample_t
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_function_decl
specifier|static
name|void
name|cl_hash
parameter_list|(
name|LZWCodecState
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*  * LZW Decoder.  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|LZW_CHECKEOS
end_ifdef
begin_comment
comment|/*  * This check shouldn't be necessary because each  * strip is suppose to be terminated with CODE_EOI.  */
end_comment
begin_define
DECL|macro|NextCode
define|#
directive|define
name|NextCode
parameter_list|(
name|_tif
parameter_list|,
name|_sp
parameter_list|,
name|_bp
parameter_list|,
name|_code
parameter_list|,
name|_get
parameter_list|)
value|{				\ 	if ((_sp)->dec_bitsleft< nbits) {				\ 		TIFFWarningExt(_tif->tif_clientdata, _tif->tif_name,				\ 		    "LZWDecode: Strip %d not terminated with EOI code", \ 		    _tif->tif_curstrip);				\ 		_code = CODE_EOI;					\ 	} else {							\ 		_get(_sp,_bp,_code);					\ 		(_sp)->dec_bitsleft -= nbits;				\ 	}								\ }
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|NextCode
define|#
directive|define
name|NextCode
parameter_list|(
name|tif
parameter_list|,
name|sp
parameter_list|,
name|bp
parameter_list|,
name|code
parameter_list|,
name|get
parameter_list|)
value|get(sp, bp, code)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function
specifier|static
name|int
DECL|function|LZWSetupDecode
name|LZWSetupDecode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|LZWCodecState
modifier|*
name|sp
init|=
name|DecoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|" LZWSetupDecode"
decl_stmt|;
name|int
name|code
decl_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
comment|/*              * Allocate state block so tag methods have storage to record  			 * values.              */
name|tif
operator|->
name|tif_data
operator|=
operator|(
name|tidata_t
operator|)
name|_TIFFmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|LZWCodecState
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tif
operator|->
name|tif_data
operator|==
name|NULL
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
literal|"LZWPreDecode"
argument_list|,
literal|"No space for LZW state block"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|DecoderState
argument_list|(
name|tif
argument_list|)
operator|->
name|dec_codetab
operator|=
name|NULL
expr_stmt|;
name|DecoderState
argument_list|(
name|tif
argument_list|)
operator|->
name|dec_decode
operator|=
name|NULL
expr_stmt|;
comment|/*              * Setup predictor setup.              */
operator|(
name|void
operator|)
name|TIFFPredictorInit
argument_list|(
name|tif
argument_list|)
expr_stmt|;
name|sp
operator|=
name|DecoderState
argument_list|(
name|tif
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|dec_codetab
operator|==
name|NULL
condition|)
block|{
name|sp
operator|->
name|dec_codetab
operator|=
operator|(
name|code_t
operator|*
operator|)
name|_TIFFmalloc
argument_list|(
name|CSIZE
operator|*
sizeof|sizeof
argument_list|(
name|code_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|dec_codetab
operator|==
name|NULL
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"No space for LZW code table"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * Pre-load the table. 		 */
name|code
operator|=
literal|255
expr_stmt|;
do|do
block|{
name|sp
operator|->
name|dec_codetab
index|[
name|code
index|]
operator|.
name|value
operator|=
name|code
expr_stmt|;
name|sp
operator|->
name|dec_codetab
index|[
name|code
index|]
operator|.
name|firstchar
operator|=
name|code
expr_stmt|;
name|sp
operator|->
name|dec_codetab
index|[
name|code
index|]
operator|.
name|length
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|dec_codetab
index|[
name|code
index|]
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
block|}
do|while
condition|(
name|code
operator|--
condition|)
do|;
comment|/* 		 * Zero-out the unused entries                  */
name|_TIFFmemset
argument_list|(
operator|&
name|sp
operator|->
name|dec_codetab
index|[
name|CODE_CLEAR
index|]
argument_list|,
literal|0
argument_list|,
operator|(
name|CODE_FIRST
operator|-
name|CODE_CLEAR
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|code_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Setup state for decoding a strip.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|LZWPreDecode
name|LZWPreDecode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|LZWCodecState
modifier|*
name|sp
init|=
name|DecoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|s
expr_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|dec_codetab
operator|==
name|NULL
condition|)
block|{
name|tif
operator|->
name|tif_setupdecode
argument_list|(
name|tif
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check for old bit-reversed codes. 	 */
if|if
condition|(
name|tif
operator|->
name|tif_rawdata
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
operator|(
name|tif
operator|->
name|tif_rawdata
index|[
literal|1
index|]
operator|&
literal|0x1
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|LZW_COMPAT
if|if
condition|(
operator|!
name|sp
operator|->
name|dec_decode
condition|)
block|{
name|TIFFWarningExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"Old-style LZW codes, convert file"
argument_list|)
expr_stmt|;
comment|/* 			 * Override default decoding methods with 			 * ones that deal with the old coding. 			 * Otherwise the predictor versions set 			 * above will call the compatibility routines 			 * through the dec_decode method. 			 */
name|tif
operator|->
name|tif_decoderow
operator|=
name|LZWDecodeCompat
expr_stmt|;
name|tif
operator|->
name|tif_decodestrip
operator|=
name|LZWDecodeCompat
expr_stmt|;
name|tif
operator|->
name|tif_decodetile
operator|=
name|LZWDecodeCompat
expr_stmt|;
comment|/* 			 * If doing horizontal differencing, must 			 * re-setup the predictor logic since we 			 * switched the basic decoder methods... 			 */
call|(
modifier|*
name|tif
operator|->
name|tif_setupdecode
call|)
argument_list|(
name|tif
argument_list|)
expr_stmt|;
name|sp
operator|->
name|dec_decode
operator|=
name|LZWDecodeCompat
expr_stmt|;
block|}
name|sp
operator|->
name|lzw_maxcode
operator|=
name|MAXCODE
argument_list|(
name|BITS_MIN
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !LZW_COMPAT */
if|if
condition|(
operator|!
name|sp
operator|->
name|dec_decode
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"Old-style LZW codes not supported"
argument_list|)
expr_stmt|;
name|sp
operator|->
name|dec_decode
operator|=
name|LZWDecode
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* !LZW_COMPAT */
block|}
else|else
block|{
name|sp
operator|->
name|lzw_maxcode
operator|=
name|MAXCODE
argument_list|(
name|BITS_MIN
argument_list|)
operator|-
literal|1
expr_stmt|;
name|sp
operator|->
name|dec_decode
operator|=
name|LZWDecode
expr_stmt|;
block|}
name|sp
operator|->
name|lzw_nbits
operator|=
name|BITS_MIN
expr_stmt|;
name|sp
operator|->
name|lzw_nextbits
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|lzw_nextdata
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|dec_restart
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|dec_nbitsmask
operator|=
name|MAXCODE
argument_list|(
name|BITS_MIN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LZW_CHECKEOS
name|sp
operator|->
name|dec_bitsleft
operator|=
name|tif
operator|->
name|tif_rawcc
operator|<<
literal|3
expr_stmt|;
endif|#
directive|endif
name|sp
operator|->
name|dec_free_entp
operator|=
name|sp
operator|->
name|dec_codetab
operator|+
name|CODE_FIRST
expr_stmt|;
comment|/* 	 * Zero entries that are not yet filled in.  We do 	 * this to guard against bogus input data that causes 	 * us to index into undefined entries.  If you can 	 * come up with a way to safely bounds-check input codes 	 * while decoding then you can remove this operation. 	 */
name|_TIFFmemset
argument_list|(
name|sp
operator|->
name|dec_free_entp
argument_list|,
literal|0
argument_list|,
operator|(
name|CSIZE
operator|-
name|CODE_FIRST
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|code_t
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|dec_oldcodep
operator|=
operator|&
name|sp
operator|->
name|dec_codetab
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|sp
operator|->
name|dec_maxcodep
operator|=
operator|&
name|sp
operator|->
name|dec_codetab
index|[
name|sp
operator|->
name|dec_nbitsmask
operator|-
literal|1
index|]
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Decode a "hunk of data".  */
end_comment
begin_define
DECL|macro|GetNextCode
define|#
directive|define
name|GetNextCode
parameter_list|(
name|sp
parameter_list|,
name|bp
parameter_list|,
name|code
parameter_list|)
value|{				\ 	nextdata = (nextdata<<8) | *(bp)++;			\ 	nextbits += 8;						\ 	if (nextbits< nbits) {					\ 		nextdata = (nextdata<<8) | *(bp)++;		\ 		nextbits += 8;					\ 	}							\ 	code = (hcode_t)((nextdata>> (nextbits-nbits))& nbitsmask);	\ 	nextbits -= nbits;					\ }
end_define
begin_function
specifier|static
name|void
DECL|function|codeLoop
name|codeLoop
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"LZWDecode: Bogus encoding, loop in the code table; scanline %d"
argument_list|,
name|tif
operator|->
name|tif_row
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|LZWDecode
name|LZWDecode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|op0
parameter_list|,
name|tsize_t
name|occ0
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|LZWCodecState
modifier|*
name|sp
init|=
name|DecoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|char
modifier|*
name|op
init|=
operator|(
name|char
operator|*
operator|)
name|op0
decl_stmt|;
name|long
name|occ
init|=
operator|(
name|long
operator|)
name|occ0
decl_stmt|;
name|char
modifier|*
name|tp
decl_stmt|;
name|unsigned
name|char
modifier|*
name|bp
decl_stmt|;
name|hcode_t
name|code
decl_stmt|;
name|int
name|len
decl_stmt|;
name|long
name|nbits
decl_stmt|,
name|nextbits
decl_stmt|,
name|nextdata
decl_stmt|,
name|nbitsmask
decl_stmt|;
name|code_t
modifier|*
name|codep
decl_stmt|,
modifier|*
name|free_entp
decl_stmt|,
modifier|*
name|maxcodep
decl_stmt|,
modifier|*
name|oldcodep
decl_stmt|;
operator|(
name|void
operator|)
name|s
expr_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|sp
operator|->
name|dec_codetab
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Restart interrupted output operation. 	 */
if|if
condition|(
name|sp
operator|->
name|dec_restart
condition|)
block|{
name|long
name|residue
decl_stmt|;
name|codep
operator|=
name|sp
operator|->
name|dec_codep
expr_stmt|;
name|residue
operator|=
name|codep
operator|->
name|length
operator|-
name|sp
operator|->
name|dec_restart
expr_stmt|;
if|if
condition|(
name|residue
operator|>
name|occ
condition|)
block|{
comment|/* 			 * Residue from previous decode is sufficient 			 * to satisfy decode request.  Skip to the 			 * start of the decoded string, place decoded 			 * values in the output buffer, and return. 			 */
name|sp
operator|->
name|dec_restart
operator|+=
name|occ
expr_stmt|;
do|do
block|{
name|codep
operator|=
name|codep
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|residue
operator|>
name|occ
operator|&&
name|codep
condition|)
do|;
if|if
condition|(
name|codep
condition|)
block|{
name|tp
operator|=
name|op
operator|+
name|occ
expr_stmt|;
do|do
block|{
operator|*
operator|--
name|tp
operator|=
name|codep
operator|->
name|value
expr_stmt|;
name|codep
operator|=
name|codep
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|occ
operator|&&
name|codep
condition|)
do|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 		 * Residue satisfies only part of the decode request. 		 */
name|op
operator|+=
name|residue
operator|,
name|occ
operator|-=
name|residue
expr_stmt|;
name|tp
operator|=
name|op
expr_stmt|;
do|do
block|{
name|int
name|t
decl_stmt|;
operator|--
name|tp
expr_stmt|;
name|t
operator|=
name|codep
operator|->
name|value
expr_stmt|;
name|codep
operator|=
name|codep
operator|->
name|next
expr_stmt|;
operator|*
name|tp
operator|=
name|t
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|residue
operator|&&
name|codep
condition|)
do|;
name|sp
operator|->
name|dec_restart
operator|=
literal|0
expr_stmt|;
block|}
name|bp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tif
operator|->
name|tif_rawcp
expr_stmt|;
name|nbits
operator|=
name|sp
operator|->
name|lzw_nbits
expr_stmt|;
name|nextdata
operator|=
name|sp
operator|->
name|lzw_nextdata
expr_stmt|;
name|nextbits
operator|=
name|sp
operator|->
name|lzw_nextbits
expr_stmt|;
name|nbitsmask
operator|=
name|sp
operator|->
name|dec_nbitsmask
expr_stmt|;
name|oldcodep
operator|=
name|sp
operator|->
name|dec_oldcodep
expr_stmt|;
name|free_entp
operator|=
name|sp
operator|->
name|dec_free_entp
expr_stmt|;
name|maxcodep
operator|=
name|sp
operator|->
name|dec_maxcodep
expr_stmt|;
while|while
condition|(
name|occ
operator|>
literal|0
condition|)
block|{
name|NextCode
argument_list|(
name|tif
argument_list|,
name|sp
argument_list|,
name|bp
argument_list|,
name|code
argument_list|,
name|GetNextCode
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CODE_EOI
condition|)
break|break;
if|if
condition|(
name|code
operator|==
name|CODE_CLEAR
condition|)
block|{
name|free_entp
operator|=
name|sp
operator|->
name|dec_codetab
operator|+
name|CODE_FIRST
expr_stmt|;
name|_TIFFmemset
argument_list|(
name|free_entp
argument_list|,
literal|0
argument_list|,
operator|(
name|CSIZE
operator|-
name|CODE_FIRST
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|code_t
argument_list|)
argument_list|)
expr_stmt|;
name|nbits
operator|=
name|BITS_MIN
expr_stmt|;
name|nbitsmask
operator|=
name|MAXCODE
argument_list|(
name|BITS_MIN
argument_list|)
expr_stmt|;
name|maxcodep
operator|=
name|sp
operator|->
name|dec_codetab
operator|+
name|nbitsmask
operator|-
literal|1
expr_stmt|;
name|NextCode
argument_list|(
name|tif
argument_list|,
name|sp
argument_list|,
name|bp
argument_list|,
name|code
argument_list|,
name|GetNextCode
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CODE_EOI
condition|)
break|break;
if|if
condition|(
name|code
operator|==
name|CODE_CLEAR
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"LZWDecode: Corrupted LZW table at scanline %d"
argument_list|,
name|tif
operator|->
name|tif_row
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|op
operator|++
operator|=
operator|(
name|char
operator|)
name|code
operator|,
name|occ
operator|--
expr_stmt|;
name|oldcodep
operator|=
name|sp
operator|->
name|dec_codetab
operator|+
name|code
expr_stmt|;
continue|continue;
block|}
name|codep
operator|=
name|sp
operator|->
name|dec_codetab
operator|+
name|code
expr_stmt|;
comment|/* 	 	 * Add the new entry to the code table. 	 	 */
if|if
condition|(
name|free_entp
operator|<
operator|&
name|sp
operator|->
name|dec_codetab
index|[
literal|0
index|]
operator|||
name|free_entp
operator|>=
operator|&
name|sp
operator|->
name|dec_codetab
index|[
name|CSIZE
index|]
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"LZWDecode: Corrupted LZW table at scanline %d"
argument_list|,
name|tif
operator|->
name|tif_row
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|free_entp
operator|->
name|next
operator|=
name|oldcodep
expr_stmt|;
if|if
condition|(
name|free_entp
operator|->
name|next
operator|<
operator|&
name|sp
operator|->
name|dec_codetab
index|[
literal|0
index|]
operator|||
name|free_entp
operator|->
name|next
operator|>=
operator|&
name|sp
operator|->
name|dec_codetab
index|[
name|CSIZE
index|]
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"LZWDecode: Corrupted LZW table at scanline %d"
argument_list|,
name|tif
operator|->
name|tif_row
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|free_entp
operator|->
name|firstchar
operator|=
name|free_entp
operator|->
name|next
operator|->
name|firstchar
expr_stmt|;
name|free_entp
operator|->
name|length
operator|=
name|free_entp
operator|->
name|next
operator|->
name|length
operator|+
literal|1
expr_stmt|;
name|free_entp
operator|->
name|value
operator|=
operator|(
name|codep
operator|<
name|free_entp
operator|)
condition|?
name|codep
operator|->
name|firstchar
else|:
name|free_entp
operator|->
name|firstchar
expr_stmt|;
if|if
condition|(
operator|++
name|free_entp
operator|>
name|maxcodep
condition|)
block|{
if|if
condition|(
operator|++
name|nbits
operator|>
name|BITS_MAX
condition|)
comment|/* should not happen */
name|nbits
operator|=
name|BITS_MAX
expr_stmt|;
name|nbitsmask
operator|=
name|MAXCODE
argument_list|(
name|nbits
argument_list|)
expr_stmt|;
name|maxcodep
operator|=
name|sp
operator|->
name|dec_codetab
operator|+
name|nbitsmask
operator|-
literal|1
expr_stmt|;
block|}
name|oldcodep
operator|=
name|codep
expr_stmt|;
if|if
condition|(
name|code
operator|>=
literal|256
condition|)
block|{
comment|/* 		 	 * Code maps to a string, copy string 			 * value to output (written in reverse). 		 	 */
if|if
condition|(
name|codep
operator|->
name|length
operator|==
literal|0
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"LZWDecode: Wrong length of decoded string: "
literal|"data probably corrupted at scanline %d"
argument_list|,
name|tif
operator|->
name|tif_row
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|codep
operator|->
name|length
operator|>
name|occ
condition|)
block|{
comment|/* 				 * String is too long for decode buffer, 				 * locate portion that will fit, copy to 				 * the decode buffer, and setup restart 				 * logic for the next decoding call. 				 */
name|sp
operator|->
name|dec_codep
operator|=
name|codep
expr_stmt|;
do|do
block|{
name|codep
operator|=
name|codep
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|codep
operator|&&
name|codep
operator|->
name|length
operator|>
name|occ
condition|)
do|;
if|if
condition|(
name|codep
condition|)
block|{
name|sp
operator|->
name|dec_restart
operator|=
name|occ
expr_stmt|;
name|tp
operator|=
name|op
operator|+
name|occ
expr_stmt|;
do|do
block|{
operator|*
operator|--
name|tp
operator|=
name|codep
operator|->
name|value
expr_stmt|;
name|codep
operator|=
name|codep
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|occ
operator|&&
name|codep
condition|)
do|;
if|if
condition|(
name|codep
condition|)
name|codeLoop
argument_list|(
name|tif
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|len
operator|=
name|codep
operator|->
name|length
expr_stmt|;
name|tp
operator|=
name|op
operator|+
name|len
expr_stmt|;
do|do
block|{
name|int
name|t
decl_stmt|;
operator|--
name|tp
expr_stmt|;
name|t
operator|=
name|codep
operator|->
name|value
expr_stmt|;
name|codep
operator|=
name|codep
operator|->
name|next
expr_stmt|;
operator|*
name|tp
operator|=
name|t
expr_stmt|;
block|}
do|while
condition|(
name|codep
operator|&&
name|tp
operator|>
name|op
condition|)
do|;
if|if
condition|(
name|codep
condition|)
block|{
name|codeLoop
argument_list|(
name|tif
argument_list|)
expr_stmt|;
break|break;
block|}
name|op
operator|+=
name|len
operator|,
name|occ
operator|-=
name|len
expr_stmt|;
block|}
else|else
operator|*
name|op
operator|++
operator|=
operator|(
name|char
operator|)
name|code
operator|,
name|occ
operator|--
expr_stmt|;
block|}
name|tif
operator|->
name|tif_rawcp
operator|=
operator|(
name|tidata_t
operator|)
name|bp
expr_stmt|;
name|sp
operator|->
name|lzw_nbits
operator|=
operator|(
name|unsigned
name|short
operator|)
name|nbits
expr_stmt|;
name|sp
operator|->
name|lzw_nextdata
operator|=
name|nextdata
expr_stmt|;
name|sp
operator|->
name|lzw_nextbits
operator|=
name|nextbits
expr_stmt|;
name|sp
operator|->
name|dec_nbitsmask
operator|=
name|nbitsmask
expr_stmt|;
name|sp
operator|->
name|dec_oldcodep
operator|=
name|oldcodep
expr_stmt|;
name|sp
operator|->
name|dec_free_entp
operator|=
name|free_entp
expr_stmt|;
name|sp
operator|->
name|dec_maxcodep
operator|=
name|maxcodep
expr_stmt|;
if|if
condition|(
name|occ
operator|>
literal|0
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"LZWDecode: Not enough data at scanline %d (short %ld bytes)"
argument_list|,
name|tif
operator|->
name|tif_row
argument_list|,
name|occ
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|LZW_COMPAT
end_ifdef
begin_comment
comment|/*  * Decode a "hunk of data" for old images.  */
end_comment
begin_define
DECL|macro|GetNextCodeCompat
define|#
directive|define
name|GetNextCodeCompat
parameter_list|(
name|sp
parameter_list|,
name|bp
parameter_list|,
name|code
parameter_list|)
value|{			\ 	nextdata |= (unsigned long) *(bp)++<< nextbits;	\ 	nextbits += 8;						\ 	if (nextbits< nbits) {					\ 		nextdata |= (unsigned long) *(bp)++<< nextbits;\ 		nextbits += 8;					\ 	}							\ 	code = (hcode_t)(nextdata& nbitsmask);			\ 	nextdata>>= nbits;					\ 	nextbits -= nbits;					\ }
end_define
begin_function
specifier|static
name|int
DECL|function|LZWDecodeCompat
name|LZWDecodeCompat
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|op0
parameter_list|,
name|tsize_t
name|occ0
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|LZWCodecState
modifier|*
name|sp
init|=
name|DecoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|char
modifier|*
name|op
init|=
operator|(
name|char
operator|*
operator|)
name|op0
decl_stmt|;
name|long
name|occ
init|=
operator|(
name|long
operator|)
name|occ0
decl_stmt|;
name|char
modifier|*
name|tp
decl_stmt|;
name|unsigned
name|char
modifier|*
name|bp
decl_stmt|;
name|int
name|code
decl_stmt|,
name|nbits
decl_stmt|;
name|long
name|nextbits
decl_stmt|,
name|nextdata
decl_stmt|,
name|nbitsmask
decl_stmt|;
name|code_t
modifier|*
name|codep
decl_stmt|,
modifier|*
name|free_entp
decl_stmt|,
modifier|*
name|maxcodep
decl_stmt|,
modifier|*
name|oldcodep
decl_stmt|;
operator|(
name|void
operator|)
name|s
expr_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Restart interrupted output operation. 	 */
if|if
condition|(
name|sp
operator|->
name|dec_restart
condition|)
block|{
name|long
name|residue
decl_stmt|;
name|codep
operator|=
name|sp
operator|->
name|dec_codep
expr_stmt|;
name|residue
operator|=
name|codep
operator|->
name|length
operator|-
name|sp
operator|->
name|dec_restart
expr_stmt|;
if|if
condition|(
name|residue
operator|>
name|occ
condition|)
block|{
comment|/* 			 * Residue from previous decode is sufficient 			 * to satisfy decode request.  Skip to the 			 * start of the decoded string, place decoded 			 * values in the output buffer, and return. 			 */
name|sp
operator|->
name|dec_restart
operator|+=
name|occ
expr_stmt|;
do|do
block|{
name|codep
operator|=
name|codep
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|residue
operator|>
name|occ
condition|)
do|;
name|tp
operator|=
name|op
operator|+
name|occ
expr_stmt|;
do|do
block|{
operator|*
operator|--
name|tp
operator|=
name|codep
operator|->
name|value
expr_stmt|;
name|codep
operator|=
name|codep
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|occ
condition|)
do|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 		 * Residue satisfies only part of the decode request. 		 */
name|op
operator|+=
name|residue
operator|,
name|occ
operator|-=
name|residue
expr_stmt|;
name|tp
operator|=
name|op
expr_stmt|;
do|do
block|{
operator|*
operator|--
name|tp
operator|=
name|codep
operator|->
name|value
expr_stmt|;
name|codep
operator|=
name|codep
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|residue
condition|)
do|;
name|sp
operator|->
name|dec_restart
operator|=
literal|0
expr_stmt|;
block|}
name|bp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tif
operator|->
name|tif_rawcp
expr_stmt|;
name|nbits
operator|=
name|sp
operator|->
name|lzw_nbits
expr_stmt|;
name|nextdata
operator|=
name|sp
operator|->
name|lzw_nextdata
expr_stmt|;
name|nextbits
operator|=
name|sp
operator|->
name|lzw_nextbits
expr_stmt|;
name|nbitsmask
operator|=
name|sp
operator|->
name|dec_nbitsmask
expr_stmt|;
name|oldcodep
operator|=
name|sp
operator|->
name|dec_oldcodep
expr_stmt|;
name|free_entp
operator|=
name|sp
operator|->
name|dec_free_entp
expr_stmt|;
name|maxcodep
operator|=
name|sp
operator|->
name|dec_maxcodep
expr_stmt|;
while|while
condition|(
name|occ
operator|>
literal|0
condition|)
block|{
name|NextCode
argument_list|(
name|tif
argument_list|,
name|sp
argument_list|,
name|bp
argument_list|,
name|code
argument_list|,
name|GetNextCodeCompat
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CODE_EOI
condition|)
break|break;
if|if
condition|(
name|code
operator|==
name|CODE_CLEAR
condition|)
block|{
name|free_entp
operator|=
name|sp
operator|->
name|dec_codetab
operator|+
name|CODE_FIRST
expr_stmt|;
name|_TIFFmemset
argument_list|(
name|free_entp
argument_list|,
literal|0
argument_list|,
operator|(
name|CSIZE
operator|-
name|CODE_FIRST
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|code_t
argument_list|)
argument_list|)
expr_stmt|;
name|nbits
operator|=
name|BITS_MIN
expr_stmt|;
name|nbitsmask
operator|=
name|MAXCODE
argument_list|(
name|BITS_MIN
argument_list|)
expr_stmt|;
name|maxcodep
operator|=
name|sp
operator|->
name|dec_codetab
operator|+
name|nbitsmask
expr_stmt|;
name|NextCode
argument_list|(
name|tif
argument_list|,
name|sp
argument_list|,
name|bp
argument_list|,
name|code
argument_list|,
name|GetNextCodeCompat
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CODE_EOI
condition|)
break|break;
if|if
condition|(
name|code
operator|==
name|CODE_CLEAR
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"LZWDecode: Corrupted LZW table at scanline %d"
argument_list|,
name|tif
operator|->
name|tif_row
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|op
operator|++
operator|=
name|code
operator|,
name|occ
operator|--
expr_stmt|;
name|oldcodep
operator|=
name|sp
operator|->
name|dec_codetab
operator|+
name|code
expr_stmt|;
continue|continue;
block|}
name|codep
operator|=
name|sp
operator|->
name|dec_codetab
operator|+
name|code
expr_stmt|;
comment|/* 	 	 * Add the new entry to the code table. 	 	 */
if|if
condition|(
name|free_entp
operator|<
operator|&
name|sp
operator|->
name|dec_codetab
index|[
literal|0
index|]
operator|||
name|free_entp
operator|>=
operator|&
name|sp
operator|->
name|dec_codetab
index|[
name|CSIZE
index|]
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"LZWDecodeCompat: Corrupted LZW table at scanline %d"
argument_list|,
name|tif
operator|->
name|tif_row
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|free_entp
operator|->
name|next
operator|=
name|oldcodep
expr_stmt|;
if|if
condition|(
name|free_entp
operator|->
name|next
operator|<
operator|&
name|sp
operator|->
name|dec_codetab
index|[
literal|0
index|]
operator|||
name|free_entp
operator|->
name|next
operator|>=
operator|&
name|sp
operator|->
name|dec_codetab
index|[
name|CSIZE
index|]
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"LZWDecodeCompat: Corrupted LZW table at scanline %d"
argument_list|,
name|tif
operator|->
name|tif_row
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|free_entp
operator|->
name|firstchar
operator|=
name|free_entp
operator|->
name|next
operator|->
name|firstchar
expr_stmt|;
name|free_entp
operator|->
name|length
operator|=
name|free_entp
operator|->
name|next
operator|->
name|length
operator|+
literal|1
expr_stmt|;
name|free_entp
operator|->
name|value
operator|=
operator|(
name|codep
operator|<
name|free_entp
operator|)
condition|?
name|codep
operator|->
name|firstchar
else|:
name|free_entp
operator|->
name|firstchar
expr_stmt|;
if|if
condition|(
operator|++
name|free_entp
operator|>
name|maxcodep
condition|)
block|{
if|if
condition|(
operator|++
name|nbits
operator|>
name|BITS_MAX
condition|)
comment|/* should not happen */
name|nbits
operator|=
name|BITS_MAX
expr_stmt|;
name|nbitsmask
operator|=
name|MAXCODE
argument_list|(
name|nbits
argument_list|)
expr_stmt|;
name|maxcodep
operator|=
name|sp
operator|->
name|dec_codetab
operator|+
name|nbitsmask
expr_stmt|;
block|}
name|oldcodep
operator|=
name|codep
expr_stmt|;
if|if
condition|(
name|code
operator|>=
literal|256
condition|)
block|{
name|char
modifier|*
name|op_orig
init|=
name|op
decl_stmt|;
comment|/* 		 	 * Code maps to a string, copy string 			 * value to output (written in reverse). 		 	 */
if|if
condition|(
name|codep
operator|->
name|length
operator|==
literal|0
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"LZWDecodeCompat: Wrong length of decoded "
literal|"string: data probably corrupted at scanline %d"
argument_list|,
name|tif
operator|->
name|tif_row
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|codep
operator|->
name|length
operator|>
name|occ
condition|)
block|{
comment|/* 				 * String is too long for decode buffer, 				 * locate portion that will fit, copy to 				 * the decode buffer, and setup restart 				 * logic for the next decoding call. 				 */
name|sp
operator|->
name|dec_codep
operator|=
name|codep
expr_stmt|;
do|do
block|{
name|codep
operator|=
name|codep
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|codep
operator|->
name|length
operator|>
name|occ
condition|)
do|;
name|sp
operator|->
name|dec_restart
operator|=
name|occ
expr_stmt|;
name|tp
operator|=
name|op
operator|+
name|occ
expr_stmt|;
do|do
block|{
operator|*
operator|--
name|tp
operator|=
name|codep
operator|->
name|value
expr_stmt|;
name|codep
operator|=
name|codep
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|occ
condition|)
do|;
break|break;
block|}
name|op
operator|+=
name|codep
operator|->
name|length
operator|,
name|occ
operator|-=
name|codep
operator|->
name|length
expr_stmt|;
name|tp
operator|=
name|op
expr_stmt|;
do|do
block|{
operator|*
operator|--
name|tp
operator|=
name|codep
operator|->
name|value
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|codep
operator|=
name|codep
operator|->
name|next
operator|)
operator|!=
name|NULL
operator|&&
name|tp
operator|>
name|op_orig
condition|)
do|;
block|}
else|else
operator|*
name|op
operator|++
operator|=
name|code
operator|,
name|occ
operator|--
expr_stmt|;
block|}
name|tif
operator|->
name|tif_rawcp
operator|=
operator|(
name|tidata_t
operator|)
name|bp
expr_stmt|;
name|sp
operator|->
name|lzw_nbits
operator|=
name|nbits
expr_stmt|;
name|sp
operator|->
name|lzw_nextdata
operator|=
name|nextdata
expr_stmt|;
name|sp
operator|->
name|lzw_nextbits
operator|=
name|nextbits
expr_stmt|;
name|sp
operator|->
name|dec_nbitsmask
operator|=
name|nbitsmask
expr_stmt|;
name|sp
operator|->
name|dec_oldcodep
operator|=
name|oldcodep
expr_stmt|;
name|sp
operator|->
name|dec_free_entp
operator|=
name|free_entp
expr_stmt|;
name|sp
operator|->
name|dec_maxcodep
operator|=
name|maxcodep
expr_stmt|;
if|if
condition|(
name|occ
operator|>
literal|0
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"LZWDecodeCompat: Not enough data at scanline %d (short %ld bytes)"
argument_list|,
name|tif
operator|->
name|tif_row
argument_list|,
name|occ
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* LZW_COMPAT */
end_comment
begin_comment
comment|/*  * LZW Encoding.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|LZWSetupEncode
name|LZWSetupEncode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|LZWCodecState
modifier|*
name|sp
init|=
name|EncoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|"LZWSetupEncode"
decl_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sp
operator|->
name|enc_hashtab
operator|=
operator|(
name|hash_t
operator|*
operator|)
name|_TIFFmalloc
argument_list|(
name|HSIZE
operator|*
sizeof|sizeof
argument_list|(
name|hash_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|enc_hashtab
operator|==
name|NULL
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"No space for LZW hash table"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Reset encoding state at the start of a strip.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|LZWPreEncode
name|LZWPreEncode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|LZWCodecState
modifier|*
name|sp
init|=
name|EncoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|s
expr_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|enc_hashtab
operator|==
name|NULL
condition|)
block|{
name|tif
operator|->
name|tif_setupencode
argument_list|(
name|tif
argument_list|)
expr_stmt|;
block|}
name|sp
operator|->
name|lzw_nbits
operator|=
name|BITS_MIN
expr_stmt|;
name|sp
operator|->
name|lzw_maxcode
operator|=
name|MAXCODE
argument_list|(
name|BITS_MIN
argument_list|)
expr_stmt|;
name|sp
operator|->
name|lzw_free_ent
operator|=
name|CODE_FIRST
expr_stmt|;
name|sp
operator|->
name|lzw_nextbits
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|lzw_nextdata
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|enc_checkpoint
operator|=
name|CHECK_GAP
expr_stmt|;
name|sp
operator|->
name|enc_ratio
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|enc_incount
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|enc_outcount
operator|=
literal|0
expr_stmt|;
comment|/* 	 * The 4 here insures there is space for 2 max-sized 	 * codes in LZWEncode and LZWPostDecode. 	 */
name|sp
operator|->
name|enc_rawlimit
operator|=
name|tif
operator|->
name|tif_rawdata
operator|+
name|tif
operator|->
name|tif_rawdatasize
operator|-
literal|1
operator|-
literal|4
expr_stmt|;
name|cl_hash
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* clear hash table */
name|sp
operator|->
name|enc_oldcode
operator|=
operator|(
name|hcode_t
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* generates CODE_CLEAR in LZWEncode */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_define
DECL|macro|CALCRATIO
define|#
directive|define
name|CALCRATIO
parameter_list|(
name|sp
parameter_list|,
name|rat
parameter_list|)
value|{					\ 	if (incount> 0x007fffff) {
comment|/* NB: shift will overflow */
value|\ 		rat = outcount>> 8;				\ 		rat = (rat == 0 ? 0x7fffffff : incount/rat);	\ 	} else							\ 		rat = (incount<<8) / outcount;			\ }
end_define
begin_define
DECL|macro|PutNextCode
define|#
directive|define
name|PutNextCode
parameter_list|(
name|op
parameter_list|,
name|c
parameter_list|)
value|{					\ 	nextdata = (nextdata<< nbits) | c;			\ 	nextbits += nbits;					\ 	*op++ = (unsigned char)(nextdata>> (nextbits-8));		\ 	nextbits -= 8;						\ 	if (nextbits>= 8) {					\ 		*op++ = (unsigned char)(nextdata>> (nextbits-8));	\ 		nextbits -= 8;					\ 	}							\ 	outcount += nbits;					\ }
end_define
begin_comment
comment|/*  * Encode a chunk of pixels.  *  * Uses an open addressing double hashing (no chaining) on the   * prefix code/next character combination.  We do a variant of  * Knuth's algorithm D (vol. 3, sec. 6.4) along with G. Knott's  * relatively-prime secondary probe.  Here, the modular division  * first probe is gives way to a faster exclusive-or manipulation.   * Also do block compression with an adaptive reset, whereby the  * code table is cleared when the compression ratio decreases,  * but after the table fills.  The variable-length output codes  * are re-sized at this point, and a CODE_CLEAR is generated  * for the decoder.   */
end_comment
begin_function
specifier|static
name|int
DECL|function|LZWEncode
name|LZWEncode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|bp
parameter_list|,
name|tsize_t
name|cc
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
specifier|register
name|LZWCodecState
modifier|*
name|sp
init|=
name|EncoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
specifier|register
name|long
name|fcode
decl_stmt|;
specifier|register
name|hash_t
modifier|*
name|hp
decl_stmt|;
specifier|register
name|int
name|h
decl_stmt|,
name|c
decl_stmt|;
name|hcode_t
name|ent
decl_stmt|;
name|long
name|disp
decl_stmt|;
name|long
name|incount
decl_stmt|,
name|outcount
decl_stmt|,
name|checkpoint
decl_stmt|;
name|long
name|nextdata
decl_stmt|,
name|nextbits
decl_stmt|;
name|int
name|free_ent
decl_stmt|,
name|maxcode
decl_stmt|,
name|nbits
decl_stmt|;
name|tidata_t
name|op
decl_stmt|,
name|limit
decl_stmt|;
operator|(
name|void
operator|)
name|s
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|assert
argument_list|(
name|sp
operator|->
name|enc_hashtab
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Load local state. 	 */
name|incount
operator|=
name|sp
operator|->
name|enc_incount
expr_stmt|;
name|outcount
operator|=
name|sp
operator|->
name|enc_outcount
expr_stmt|;
name|checkpoint
operator|=
name|sp
operator|->
name|enc_checkpoint
expr_stmt|;
name|nextdata
operator|=
name|sp
operator|->
name|lzw_nextdata
expr_stmt|;
name|nextbits
operator|=
name|sp
operator|->
name|lzw_nextbits
expr_stmt|;
name|free_ent
operator|=
name|sp
operator|->
name|lzw_free_ent
expr_stmt|;
name|maxcode
operator|=
name|sp
operator|->
name|lzw_maxcode
expr_stmt|;
name|nbits
operator|=
name|sp
operator|->
name|lzw_nbits
expr_stmt|;
name|op
operator|=
name|tif
operator|->
name|tif_rawcp
expr_stmt|;
name|limit
operator|=
name|sp
operator|->
name|enc_rawlimit
expr_stmt|;
name|ent
operator|=
name|sp
operator|->
name|enc_oldcode
expr_stmt|;
if|if
condition|(
name|ent
operator|==
operator|(
name|hcode_t
operator|)
operator|-
literal|1
operator|&&
name|cc
operator|>
literal|0
condition|)
block|{
comment|/* 		 * NB: This is safe because it can only happen 		 *     at the start of a strip where we know there 		 *     is space in the data buffer. 		 */
name|PutNextCode
argument_list|(
name|op
argument_list|,
name|CODE_CLEAR
argument_list|)
expr_stmt|;
name|ent
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|cc
operator|--
expr_stmt|;
name|incount
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|cc
operator|>
literal|0
condition|)
block|{
name|c
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|cc
operator|--
expr_stmt|;
name|incount
operator|++
expr_stmt|;
name|fcode
operator|=
operator|(
operator|(
name|long
operator|)
name|c
operator|<<
name|BITS_MAX
operator|)
operator|+
name|ent
expr_stmt|;
name|h
operator|=
operator|(
name|c
operator|<<
name|HSHIFT
operator|)
operator|^
name|ent
expr_stmt|;
comment|/* xor hashing */
ifdef|#
directive|ifdef
name|_WINDOWS
comment|/* 		 * Check hash index for an overflow. 		 */
if|if
condition|(
name|h
operator|>=
name|HSIZE
condition|)
name|h
operator|-=
name|HSIZE
expr_stmt|;
endif|#
directive|endif
name|hp
operator|=
operator|&
name|sp
operator|->
name|enc_hashtab
index|[
name|h
index|]
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|hash
operator|==
name|fcode
condition|)
block|{
name|ent
operator|=
name|hp
operator|->
name|code
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|hp
operator|->
name|hash
operator|>=
literal|0
condition|)
block|{
comment|/* 			 * Primary hash failed, check secondary hash. 			 */
name|disp
operator|=
name|HSIZE
operator|-
name|h
expr_stmt|;
if|if
condition|(
name|h
operator|==
literal|0
condition|)
name|disp
operator|=
literal|1
expr_stmt|;
do|do
block|{
comment|/* 				 * Avoid pointer arithmetic 'cuz of 				 * wraparound problems with segments. 				 */
if|if
condition|(
operator|(
name|h
operator|-=
name|disp
operator|)
operator|<
literal|0
condition|)
name|h
operator|+=
name|HSIZE
expr_stmt|;
name|hp
operator|=
operator|&
name|sp
operator|->
name|enc_hashtab
index|[
name|h
index|]
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|hash
operator|==
name|fcode
condition|)
block|{
name|ent
operator|=
name|hp
operator|->
name|code
expr_stmt|;
goto|goto
name|hit
goto|;
block|}
block|}
do|while
condition|(
name|hp
operator|->
name|hash
operator|>=
literal|0
condition|)
do|;
block|}
comment|/* 		 * New entry, emit code and add to table. 		 */
comment|/* 		 * Verify there is space in the buffer for the code 		 * and any potential Clear code that might be emitted 		 * below.  The value of limit is setup so that there 		 * are at least 4 bytes free--room for 2 codes. 		 */
if|if
condition|(
name|op
operator|>
name|limit
condition|)
block|{
name|tif
operator|->
name|tif_rawcc
operator|=
call|(
name|tsize_t
call|)
argument_list|(
name|op
operator|-
name|tif
operator|->
name|tif_rawdata
argument_list|)
expr_stmt|;
name|TIFFFlushData1
argument_list|(
name|tif
argument_list|)
expr_stmt|;
name|op
operator|=
name|tif
operator|->
name|tif_rawdata
expr_stmt|;
block|}
name|PutNextCode
argument_list|(
name|op
argument_list|,
name|ent
argument_list|)
expr_stmt|;
name|ent
operator|=
name|c
expr_stmt|;
name|hp
operator|->
name|code
operator|=
name|free_ent
operator|++
expr_stmt|;
name|hp
operator|->
name|hash
operator|=
name|fcode
expr_stmt|;
if|if
condition|(
name|free_ent
operator|==
name|CODE_MAX
operator|-
literal|1
condition|)
block|{
comment|/* table is full, emit clear code and reset */
name|cl_hash
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|enc_ratio
operator|=
literal|0
expr_stmt|;
name|incount
operator|=
literal|0
expr_stmt|;
name|outcount
operator|=
literal|0
expr_stmt|;
name|free_ent
operator|=
name|CODE_FIRST
expr_stmt|;
name|PutNextCode
argument_list|(
name|op
argument_list|,
name|CODE_CLEAR
argument_list|)
expr_stmt|;
name|nbits
operator|=
name|BITS_MIN
expr_stmt|;
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|BITS_MIN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * If the next entry is going to be too big for 			 * the code size, then increase it, if possible. 			 */
if|if
condition|(
name|free_ent
operator|>
name|maxcode
condition|)
block|{
name|nbits
operator|++
expr_stmt|;
name|assert
argument_list|(
name|nbits
operator|<=
name|BITS_MAX
argument_list|)
expr_stmt|;
name|maxcode
operator|=
operator|(
name|int
operator|)
name|MAXCODE
argument_list|(
name|nbits
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|incount
operator|>=
name|checkpoint
condition|)
block|{
name|long
name|rat
decl_stmt|;
comment|/* 				 * Check compression ratio and, if things seem 				 * to be slipping, clear the hash table and 				 * reset state.  The compression ratio is a 				 * 24+8-bit fractional number. 				 */
name|checkpoint
operator|=
name|incount
operator|+
name|CHECK_GAP
expr_stmt|;
name|CALCRATIO
argument_list|(
name|sp
argument_list|,
name|rat
argument_list|)
expr_stmt|;
if|if
condition|(
name|rat
operator|<=
name|sp
operator|->
name|enc_ratio
condition|)
block|{
name|cl_hash
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|enc_ratio
operator|=
literal|0
expr_stmt|;
name|incount
operator|=
literal|0
expr_stmt|;
name|outcount
operator|=
literal|0
expr_stmt|;
name|free_ent
operator|=
name|CODE_FIRST
expr_stmt|;
name|PutNextCode
argument_list|(
name|op
argument_list|,
name|CODE_CLEAR
argument_list|)
expr_stmt|;
name|nbits
operator|=
name|BITS_MIN
expr_stmt|;
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|BITS_MIN
argument_list|)
expr_stmt|;
block|}
else|else
name|sp
operator|->
name|enc_ratio
operator|=
name|rat
expr_stmt|;
block|}
block|}
name|hit
label|:
empty_stmt|;
block|}
comment|/* 	 * Restore global state. 	 */
name|sp
operator|->
name|enc_incount
operator|=
name|incount
expr_stmt|;
name|sp
operator|->
name|enc_outcount
operator|=
name|outcount
expr_stmt|;
name|sp
operator|->
name|enc_checkpoint
operator|=
name|checkpoint
expr_stmt|;
name|sp
operator|->
name|enc_oldcode
operator|=
name|ent
expr_stmt|;
name|sp
operator|->
name|lzw_nextdata
operator|=
name|nextdata
expr_stmt|;
name|sp
operator|->
name|lzw_nextbits
operator|=
name|nextbits
expr_stmt|;
name|sp
operator|->
name|lzw_free_ent
operator|=
name|free_ent
expr_stmt|;
name|sp
operator|->
name|lzw_maxcode
operator|=
name|maxcode
expr_stmt|;
name|sp
operator|->
name|lzw_nbits
operator|=
name|nbits
expr_stmt|;
name|tif
operator|->
name|tif_rawcp
operator|=
name|op
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Finish off an encoded strip by flushing the last  * string and tacking on an End Of Information code.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|LZWPostEncode
name|LZWPostEncode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
specifier|register
name|LZWCodecState
modifier|*
name|sp
init|=
name|EncoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|tidata_t
name|op
init|=
name|tif
operator|->
name|tif_rawcp
decl_stmt|;
name|long
name|nextbits
init|=
name|sp
operator|->
name|lzw_nextbits
decl_stmt|;
name|long
name|nextdata
init|=
name|sp
operator|->
name|lzw_nextdata
decl_stmt|;
name|long
name|outcount
init|=
name|sp
operator|->
name|enc_outcount
decl_stmt|;
name|int
name|nbits
init|=
name|sp
operator|->
name|lzw_nbits
decl_stmt|;
if|if
condition|(
name|op
operator|>
name|sp
operator|->
name|enc_rawlimit
condition|)
block|{
name|tif
operator|->
name|tif_rawcc
operator|=
call|(
name|tsize_t
call|)
argument_list|(
name|op
operator|-
name|tif
operator|->
name|tif_rawdata
argument_list|)
expr_stmt|;
name|TIFFFlushData1
argument_list|(
name|tif
argument_list|)
expr_stmt|;
name|op
operator|=
name|tif
operator|->
name|tif_rawdata
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|enc_oldcode
operator|!=
operator|(
name|hcode_t
operator|)
operator|-
literal|1
condition|)
block|{
name|PutNextCode
argument_list|(
name|op
argument_list|,
name|sp
operator|->
name|enc_oldcode
argument_list|)
expr_stmt|;
name|sp
operator|->
name|enc_oldcode
operator|=
operator|(
name|hcode_t
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|PutNextCode
argument_list|(
name|op
argument_list|,
name|CODE_EOI
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextbits
operator|>
literal|0
condition|)
operator|*
name|op
operator|++
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|nextdata
operator|<<
operator|(
literal|8
operator|-
name|nextbits
operator|)
argument_list|)
expr_stmt|;
name|tif
operator|->
name|tif_rawcc
operator|=
call|(
name|tsize_t
call|)
argument_list|(
name|op
operator|-
name|tif
operator|->
name|tif_rawdata
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Reset encoding hash table.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|cl_hash
name|cl_hash
parameter_list|(
name|LZWCodecState
modifier|*
name|sp
parameter_list|)
block|{
specifier|register
name|hash_t
modifier|*
name|hp
init|=
operator|&
name|sp
operator|->
name|enc_hashtab
index|[
name|HSIZE
operator|-
literal|1
index|]
decl_stmt|;
specifier|register
name|long
name|i
init|=
name|HSIZE
operator|-
literal|8
decl_stmt|;
do|do
block|{
name|i
operator|-=
literal|8
expr_stmt|;
name|hp
index|[
operator|-
literal|7
index|]
operator|.
name|hash
operator|=
operator|-
literal|1
expr_stmt|;
name|hp
index|[
operator|-
literal|6
index|]
operator|.
name|hash
operator|=
operator|-
literal|1
expr_stmt|;
name|hp
index|[
operator|-
literal|5
index|]
operator|.
name|hash
operator|=
operator|-
literal|1
expr_stmt|;
name|hp
index|[
operator|-
literal|4
index|]
operator|.
name|hash
operator|=
operator|-
literal|1
expr_stmt|;
name|hp
index|[
operator|-
literal|3
index|]
operator|.
name|hash
operator|=
operator|-
literal|1
expr_stmt|;
name|hp
index|[
operator|-
literal|2
index|]
operator|.
name|hash
operator|=
operator|-
literal|1
expr_stmt|;
name|hp
index|[
operator|-
literal|1
index|]
operator|.
name|hash
operator|=
operator|-
literal|1
expr_stmt|;
name|hp
index|[
literal|0
index|]
operator|.
name|hash
operator|=
operator|-
literal|1
expr_stmt|;
name|hp
operator|-=
literal|8
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|>=
literal|0
condition|)
do|;
for|for
control|(
name|i
operator|+=
literal|8
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
operator|,
name|hp
operator|--
control|)
name|hp
operator|->
name|hash
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|LZWCleanup
name|LZWCleanup
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
operator|(
name|void
operator|)
name|TIFFPredictorCleanup
argument_list|(
name|tif
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tif
operator|->
name|tif_data
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DecoderState
argument_list|(
name|tif
argument_list|)
operator|->
name|dec_codetab
condition|)
name|_TIFFfree
argument_list|(
name|DecoderState
argument_list|(
name|tif
argument_list|)
operator|->
name|dec_codetab
argument_list|)
expr_stmt|;
if|if
condition|(
name|EncoderState
argument_list|(
name|tif
argument_list|)
operator|->
name|enc_hashtab
condition|)
name|_TIFFfree
argument_list|(
name|EncoderState
argument_list|(
name|tif
argument_list|)
operator|->
name|enc_hashtab
argument_list|)
expr_stmt|;
name|_TIFFfree
argument_list|(
name|tif
operator|->
name|tif_data
argument_list|)
expr_stmt|;
name|tif
operator|->
name|tif_data
operator|=
name|NULL
expr_stmt|;
name|_TIFFSetDefaultCompressionState
argument_list|(
name|tif
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|int
DECL|function|TIFFInitLZW
name|TIFFInitLZW
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|int
name|scheme
parameter_list|)
block|{
name|assert
argument_list|(
name|scheme
operator|==
name|COMPRESSION_LZW
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate state block so tag methods have storage to record values. 	 */
name|tif
operator|->
name|tif_data
operator|=
operator|(
name|tidata_t
operator|)
name|_TIFFmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|LZWCodecState
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tif
operator|->
name|tif_data
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|DecoderState
argument_list|(
name|tif
argument_list|)
operator|->
name|dec_codetab
operator|=
name|NULL
expr_stmt|;
name|DecoderState
argument_list|(
name|tif
argument_list|)
operator|->
name|dec_decode
operator|=
name|NULL
expr_stmt|;
name|EncoderState
argument_list|(
name|tif
argument_list|)
operator|->
name|enc_hashtab
operator|=
name|NULL
expr_stmt|;
name|LZWState
argument_list|(
name|tif
argument_list|)
operator|->
name|rw_mode
operator|=
name|tif
operator|->
name|tif_mode
expr_stmt|;
comment|/* 	 * Install codec methods. 	 */
name|tif
operator|->
name|tif_setupdecode
operator|=
name|LZWSetupDecode
expr_stmt|;
name|tif
operator|->
name|tif_predecode
operator|=
name|LZWPreDecode
expr_stmt|;
name|tif
operator|->
name|tif_decoderow
operator|=
name|LZWDecode
expr_stmt|;
name|tif
operator|->
name|tif_decodestrip
operator|=
name|LZWDecode
expr_stmt|;
name|tif
operator|->
name|tif_decodetile
operator|=
name|LZWDecode
expr_stmt|;
name|tif
operator|->
name|tif_setupencode
operator|=
name|LZWSetupEncode
expr_stmt|;
name|tif
operator|->
name|tif_preencode
operator|=
name|LZWPreEncode
expr_stmt|;
name|tif
operator|->
name|tif_postencode
operator|=
name|LZWPostEncode
expr_stmt|;
name|tif
operator|->
name|tif_encoderow
operator|=
name|LZWEncode
expr_stmt|;
name|tif
operator|->
name|tif_encodestrip
operator|=
name|LZWEncode
expr_stmt|;
name|tif
operator|->
name|tif_encodetile
operator|=
name|LZWEncode
expr_stmt|;
name|tif
operator|->
name|tif_cleanup
operator|=
name|LZWCleanup
expr_stmt|;
comment|/* 	 * Setup predictor setup. 	 */
operator|(
name|void
operator|)
name|TIFFPredictorInit
argument_list|(
name|tif
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
name|bad
label|:
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
literal|"TIFFInitLZW"
argument_list|,
literal|"No space for LZW state block"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Copyright (c) 1985, 1986 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * James A. Woods, derived from original work by Spencer Thomas  * and Joseph Orost.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* LZW_SUPPORT */
end_comment
begin_comment
comment|/* vim: set ts=8 sts=8 sw=8 noet: */
end_comment
end_unit
