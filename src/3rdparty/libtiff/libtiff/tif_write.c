begin_unit
begin_comment
comment|/* $Id: tif_write.c,v 1.22.2.4 2009-08-28 02:23:19 bfriesen Exp $ */
end_comment
begin_comment
comment|/*  * Copyright (c) 1988-1997 Sam Leffler  * Copyright (c) 1991-1997 Silicon Graphics, Inc.  *  * Permission to use, copy, modify, distribute, and sell this software and   * its documentation for any purpose is hereby granted without fee, provided  * that (i) the above copyright notices and this permission notice appear in  * all copies of the software and related documentation, and (ii) the names of  * Sam Leffler and Silicon Graphics may not be used in any advertising or  * publicity relating to the software without the specific, prior written  * permission of Sam Leffler and Silicon Graphics.  *   * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,   * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY   * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.    *   * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR  * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,  * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF   * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE   * OF THIS SOFTWARE.  */
end_comment
begin_comment
comment|/*  * TIFF Library.  *  * Scanline-oriented Write Support  */
end_comment
begin_include
include|#
directive|include
file|"tiffiop.h"
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_define
DECL|macro|STRIPINCR
define|#
directive|define
name|STRIPINCR
value|20
end_define
begin_comment
DECL|macro|STRIPINCR
comment|/* expansion factor on strip array */
end_comment
begin_define
DECL|macro|WRITECHECKSTRIPS
define|#
directive|define
name|WRITECHECKSTRIPS
parameter_list|(
name|tif
parameter_list|,
name|module
parameter_list|)
define|\
value|(((tif)->tif_flags&TIFF_BEENWRITING) || TIFFWriteCheck((tif),0,module))
end_define
begin_define
DECL|macro|WRITECHECKTILES
define|#
directive|define
name|WRITECHECKTILES
parameter_list|(
name|tif
parameter_list|,
name|module
parameter_list|)
define|\
value|(((tif)->tif_flags&TIFF_BEENWRITING) || TIFFWriteCheck((tif),1,module))
end_define
begin_define
DECL|macro|BUFFERCHECK
define|#
directive|define
name|BUFFERCHECK
parameter_list|(
name|tif
parameter_list|)
define|\
value|((((tif)->tif_flags& TIFF_BUFFERSETUP)&& tif->tif_rawdata) ||	\ 	    TIFFWriteBufferSetup((tif), NULL, (tsize_t) -1))
end_define
begin_function_decl
specifier|static
name|int
name|TIFFGrowStrips
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|TIFFAppendToStrip
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|tstrip_t
parameter_list|,
name|tidata_t
parameter_list|,
name|tsize_t
parameter_list|)
function_decl|;
end_function_decl
begin_function
name|int
DECL|function|TIFFWriteScanline
name|TIFFWriteScanline
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tdata_t
name|buf
parameter_list|,
name|uint32
name|row
parameter_list|,
name|tsample_t
name|sample
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|"TIFFWriteScanline"
decl_stmt|;
specifier|register
name|TIFFDirectory
modifier|*
name|td
decl_stmt|;
name|int
name|status
decl_stmt|,
name|imagegrew
init|=
literal|0
decl_stmt|;
name|tstrip_t
name|strip
decl_stmt|;
if|if
condition|(
operator|!
name|WRITECHECKSTRIPS
argument_list|(
name|tif
argument_list|,
name|module
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Handle delayed allocation of data buffer.  This 	 * permits it to be sized more intelligently (using 	 * directory information). 	 */
if|if
condition|(
operator|!
name|BUFFERCHECK
argument_list|(
name|tif
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|td
operator|=
operator|&
name|tif
operator|->
name|tif_dir
expr_stmt|;
comment|/* 	 * Extend image length if needed 	 * (but only for PlanarConfig=1). 	 */
if|if
condition|(
name|row
operator|>=
name|td
operator|->
name|td_imagelength
condition|)
block|{
comment|/* extend image */
if|if
condition|(
name|td
operator|->
name|td_planarconfig
operator|==
name|PLANARCONFIG_SEPARATE
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"Can not change \"ImageLength\" when using separate planes"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|td
operator|->
name|td_imagelength
operator|=
name|row
operator|+
literal|1
expr_stmt|;
name|imagegrew
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Calculate strip and check for crossings. 	 */
if|if
condition|(
name|td
operator|->
name|td_planarconfig
operator|==
name|PLANARCONFIG_SEPARATE
condition|)
block|{
if|if
condition|(
name|sample
operator|>=
name|td
operator|->
name|td_samplesperpixel
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"%d: Sample out of range, max %d"
argument_list|,
name|sample
argument_list|,
name|td
operator|->
name|td_samplesperpixel
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|strip
operator|=
name|sample
operator|*
name|td
operator|->
name|td_stripsperimage
operator|+
name|row
operator|/
name|td
operator|->
name|td_rowsperstrip
expr_stmt|;
block|}
else|else
name|strip
operator|=
name|row
operator|/
name|td
operator|->
name|td_rowsperstrip
expr_stmt|;
comment|/* 	 * Check strip array to make sure there's space. We don't support 	 * dynamically growing files that have data organized in separate 	 * bitplanes because it's too painful.  In that case we require that 	 * the imagelength be set properly before the first write (so that the 	 * strips array will be fully allocated above). 	 */
if|if
condition|(
name|strip
operator|>=
name|td
operator|->
name|td_nstrips
operator|&&
operator|!
name|TIFFGrowStrips
argument_list|(
name|tif
argument_list|,
literal|1
argument_list|,
name|module
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|strip
operator|!=
name|tif
operator|->
name|tif_curstrip
condition|)
block|{
comment|/* 		 * Changing strips -- flush any data present. 		 */
if|if
condition|(
operator|!
name|TIFFFlushData
argument_list|(
name|tif
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|tif
operator|->
name|tif_curstrip
operator|=
name|strip
expr_stmt|;
comment|/* 		 * Watch out for a growing image.  The value of strips/image 		 * will initially be 1 (since it can't be deduced until the 		 * imagelength is known). 		 */
if|if
condition|(
name|strip
operator|>=
name|td
operator|->
name|td_stripsperimage
operator|&&
name|imagegrew
condition|)
name|td
operator|->
name|td_stripsperimage
operator|=
name|TIFFhowmany
argument_list|(
name|td
operator|->
name|td_imagelength
argument_list|,
name|td
operator|->
name|td_rowsperstrip
argument_list|)
expr_stmt|;
name|tif
operator|->
name|tif_row
operator|=
operator|(
name|strip
operator|%
name|td
operator|->
name|td_stripsperimage
operator|)
operator|*
name|td
operator|->
name|td_rowsperstrip
expr_stmt|;
if|if
condition|(
operator|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_CODERSETUP
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|tif
operator|->
name|tif_setupencode
call|)
argument_list|(
name|tif
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|tif
operator|->
name|tif_flags
operator||=
name|TIFF_CODERSETUP
expr_stmt|;
block|}
name|tif
operator|->
name|tif_rawcc
operator|=
literal|0
expr_stmt|;
name|tif
operator|->
name|tif_rawcp
operator|=
name|tif
operator|->
name|tif_rawdata
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_stripbytecount
index|[
name|strip
index|]
operator|>
literal|0
condition|)
block|{
comment|/* if we are writing over existing tiles, zero length */
name|td
operator|->
name|td_stripbytecount
index|[
name|strip
index|]
operator|=
literal|0
expr_stmt|;
comment|/* this forces TIFFAppendToStrip() to do a seek */
name|tif
operator|->
name|tif_curoff
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
call|(
modifier|*
name|tif
operator|->
name|tif_preencode
call|)
argument_list|(
name|tif
argument_list|,
name|sample
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|tif
operator|->
name|tif_flags
operator||=
name|TIFF_POSTENCODE
expr_stmt|;
block|}
comment|/* 	 * Ensure the write is either sequential or at the 	 * beginning of a strip (or that we can randomly 	 * access the data -- i.e. no encoding). 	 */
if|if
condition|(
name|row
operator|!=
name|tif
operator|->
name|tif_row
condition|)
block|{
if|if
condition|(
name|row
operator|<
name|tif
operator|->
name|tif_row
condition|)
block|{
comment|/* 			 * Moving backwards within the same strip: 			 * backup to the start and then decode 			 * forward (below). 			 */
name|tif
operator|->
name|tif_row
operator|=
operator|(
name|strip
operator|%
name|td
operator|->
name|td_stripsperimage
operator|)
operator|*
name|td
operator|->
name|td_rowsperstrip
expr_stmt|;
name|tif
operator|->
name|tif_rawcp
operator|=
name|tif
operator|->
name|tif_rawdata
expr_stmt|;
block|}
comment|/* 		 * Seek forward to the desired row. 		 */
if|if
condition|(
operator|!
call|(
modifier|*
name|tif
operator|->
name|tif_seek
call|)
argument_list|(
name|tif
argument_list|,
name|row
operator|-
name|tif
operator|->
name|tif_row
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|tif
operator|->
name|tif_row
operator|=
name|row
expr_stmt|;
block|}
comment|/* swab if needed - note that source buffer will be altered */
name|tif
operator|->
name|tif_postdecode
argument_list|(
name|tif
argument_list|,
operator|(
name|tidata_t
operator|)
name|buf
argument_list|,
name|tif
operator|->
name|tif_scanlinesize
argument_list|)
expr_stmt|;
name|status
operator|=
call|(
modifier|*
name|tif
operator|->
name|tif_encoderow
call|)
argument_list|(
name|tif
argument_list|,
operator|(
name|tidata_t
operator|)
name|buf
argument_list|,
name|tif
operator|->
name|tif_scanlinesize
argument_list|,
name|sample
argument_list|)
expr_stmt|;
comment|/* we are now poised at the beginning of the next row */
name|tif
operator|->
name|tif_row
operator|=
name|row
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Encode the supplied data and write it to the  * specified strip.  *  * NB: Image length must be setup before writing.  */
end_comment
begin_function
name|tsize_t
DECL|function|TIFFWriteEncodedStrip
name|TIFFWriteEncodedStrip
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tstrip_t
name|strip
parameter_list|,
name|tdata_t
name|data
parameter_list|,
name|tsize_t
name|cc
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|"TIFFWriteEncodedStrip"
decl_stmt|;
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|tsample_t
name|sample
decl_stmt|;
if|if
condition|(
operator|!
name|WRITECHECKSTRIPS
argument_list|(
name|tif
argument_list|,
name|module
argument_list|)
condition|)
return|return
operator|(
operator|(
name|tsize_t
operator|)
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Check strip array to make sure there's space. 	 * We don't support dynamically growing files that 	 * have data organized in separate bitplanes because 	 * it's too painful.  In that case we require that 	 * the imagelength be set properly before the first 	 * write (so that the strips array will be fully 	 * allocated above). 	 */
if|if
condition|(
name|strip
operator|>=
name|td
operator|->
name|td_nstrips
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|td_planarconfig
operator|==
name|PLANARCONFIG_SEPARATE
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"Can not grow image by strips when using separate planes"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|tsize_t
operator|)
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|TIFFGrowStrips
argument_list|(
name|tif
argument_list|,
literal|1
argument_list|,
name|module
argument_list|)
condition|)
return|return
operator|(
operator|(
name|tsize_t
operator|)
operator|-
literal|1
operator|)
return|;
name|td
operator|->
name|td_stripsperimage
operator|=
name|TIFFhowmany
argument_list|(
name|td
operator|->
name|td_imagelength
argument_list|,
name|td
operator|->
name|td_rowsperstrip
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Handle delayed allocation of data buffer.  This 	 * permits it to be sized according to the directory 	 * info. 	 */
if|if
condition|(
operator|!
name|BUFFERCHECK
argument_list|(
name|tif
argument_list|)
condition|)
return|return
operator|(
operator|(
name|tsize_t
operator|)
operator|-
literal|1
operator|)
return|;
name|tif
operator|->
name|tif_curstrip
operator|=
name|strip
expr_stmt|;
name|tif
operator|->
name|tif_row
operator|=
operator|(
name|strip
operator|%
name|td
operator|->
name|td_stripsperimage
operator|)
operator|*
name|td
operator|->
name|td_rowsperstrip
expr_stmt|;
if|if
condition|(
operator|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_CODERSETUP
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|tif
operator|->
name|tif_setupencode
call|)
argument_list|(
name|tif
argument_list|)
condition|)
return|return
operator|(
operator|(
name|tsize_t
operator|)
operator|-
literal|1
operator|)
return|;
name|tif
operator|->
name|tif_flags
operator||=
name|TIFF_CODERSETUP
expr_stmt|;
block|}
name|tif
operator|->
name|tif_rawcc
operator|=
literal|0
expr_stmt|;
name|tif
operator|->
name|tif_rawcp
operator|=
name|tif
operator|->
name|tif_rawdata
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_stripbytecount
index|[
name|strip
index|]
operator|>
literal|0
condition|)
block|{
comment|/* Force TIFFAppendToStrip() to consider placing data at end                of file. */
name|tif
operator|->
name|tif_curoff
operator|=
literal|0
expr_stmt|;
block|}
name|tif
operator|->
name|tif_flags
operator|&=
operator|~
name|TIFF_POSTENCODE
expr_stmt|;
name|sample
operator|=
call|(
name|tsample_t
call|)
argument_list|(
name|strip
operator|/
name|td
operator|->
name|td_stripsperimage
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|tif
operator|->
name|tif_preencode
call|)
argument_list|(
name|tif
argument_list|,
name|sample
argument_list|)
condition|)
return|return
operator|(
operator|(
name|tsize_t
operator|)
operator|-
literal|1
operator|)
return|;
comment|/* swab if needed - note that source buffer will be altered */
name|tif
operator|->
name|tif_postdecode
argument_list|(
name|tif
argument_list|,
operator|(
name|tidata_t
operator|)
name|data
argument_list|,
name|cc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|tif
operator|->
name|tif_encodestrip
call|)
argument_list|(
name|tif
argument_list|,
operator|(
name|tidata_t
operator|)
name|data
argument_list|,
name|cc
argument_list|,
name|sample
argument_list|)
condition|)
return|return
operator|(
operator|(
name|tsize_t
operator|)
literal|0
operator|)
return|;
if|if
condition|(
operator|!
call|(
modifier|*
name|tif
operator|->
name|tif_postencode
call|)
argument_list|(
name|tif
argument_list|)
condition|)
return|return
operator|(
operator|(
name|tsize_t
operator|)
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|isFillOrder
argument_list|(
name|tif
argument_list|,
name|td
operator|->
name|td_fillorder
argument_list|)
operator|&&
operator|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_NOBITREV
operator|)
operator|==
literal|0
condition|)
name|TIFFReverseBits
argument_list|(
name|tif
operator|->
name|tif_rawdata
argument_list|,
name|tif
operator|->
name|tif_rawcc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tif
operator|->
name|tif_rawcc
operator|>
literal|0
operator|&&
operator|!
name|TIFFAppendToStrip
argument_list|(
name|tif
argument_list|,
name|strip
argument_list|,
name|tif
operator|->
name|tif_rawdata
argument_list|,
name|tif
operator|->
name|tif_rawcc
argument_list|)
condition|)
return|return
operator|(
operator|(
name|tsize_t
operator|)
operator|-
literal|1
operator|)
return|;
name|tif
operator|->
name|tif_rawcc
operator|=
literal|0
expr_stmt|;
name|tif
operator|->
name|tif_rawcp
operator|=
name|tif
operator|->
name|tif_rawdata
expr_stmt|;
return|return
operator|(
name|cc
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Write the supplied data to the specified strip.  *  * NB: Image length must be setup before writing.  */
end_comment
begin_function
name|tsize_t
DECL|function|TIFFWriteRawStrip
name|TIFFWriteRawStrip
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tstrip_t
name|strip
parameter_list|,
name|tdata_t
name|data
parameter_list|,
name|tsize_t
name|cc
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|"TIFFWriteRawStrip"
decl_stmt|;
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
if|if
condition|(
operator|!
name|WRITECHECKSTRIPS
argument_list|(
name|tif
argument_list|,
name|module
argument_list|)
condition|)
return|return
operator|(
operator|(
name|tsize_t
operator|)
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Check strip array to make sure there's space. 	 * We don't support dynamically growing files that 	 * have data organized in separate bitplanes because 	 * it's too painful.  In that case we require that 	 * the imagelength be set properly before the first 	 * write (so that the strips array will be fully 	 * allocated above). 	 */
if|if
condition|(
name|strip
operator|>=
name|td
operator|->
name|td_nstrips
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|td_planarconfig
operator|==
name|PLANARCONFIG_SEPARATE
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"Can not grow image by strips when using separate planes"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|tsize_t
operator|)
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 		 * Watch out for a growing image.  The value of 		 * strips/image will initially be 1 (since it 		 * can't be deduced until the imagelength is known). 		 */
if|if
condition|(
name|strip
operator|>=
name|td
operator|->
name|td_stripsperimage
condition|)
name|td
operator|->
name|td_stripsperimage
operator|=
name|TIFFhowmany
argument_list|(
name|td
operator|->
name|td_imagelength
argument_list|,
name|td
operator|->
name|td_rowsperstrip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TIFFGrowStrips
argument_list|(
name|tif
argument_list|,
literal|1
argument_list|,
name|module
argument_list|)
condition|)
return|return
operator|(
operator|(
name|tsize_t
operator|)
operator|-
literal|1
operator|)
return|;
block|}
name|tif
operator|->
name|tif_curstrip
operator|=
name|strip
expr_stmt|;
name|tif
operator|->
name|tif_row
operator|=
operator|(
name|strip
operator|%
name|td
operator|->
name|td_stripsperimage
operator|)
operator|*
name|td
operator|->
name|td_rowsperstrip
expr_stmt|;
return|return
operator|(
name|TIFFAppendToStrip
argument_list|(
name|tif
argument_list|,
name|strip
argument_list|,
operator|(
name|tidata_t
operator|)
name|data
argument_list|,
name|cc
argument_list|)
condition|?
name|cc
else|:
operator|(
name|tsize_t
operator|)
operator|-
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Write and compress a tile of data.  The  * tile is selected by the (x,y,z,s) coordinates.  */
end_comment
begin_function
name|tsize_t
DECL|function|TIFFWriteTile
name|TIFFWriteTile
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tdata_t
name|buf
parameter_list|,
name|uint32
name|x
parameter_list|,
name|uint32
name|y
parameter_list|,
name|uint32
name|z
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TIFFCheckTile
argument_list|(
name|tif
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|,
name|s
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * NB: A tile size of -1 is used instead of tif_tilesize knowing 	 *     that TIFFWriteEncodedTile will clamp this to the tile size. 	 *     This is done because the tile size may not be defined until 	 *     after the output buffer is setup in TIFFWriteBufferSetup. 	 */
return|return
operator|(
name|TIFFWriteEncodedTile
argument_list|(
name|tif
argument_list|,
name|TIFFComputeTile
argument_list|(
name|tif
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|,
name|s
argument_list|)
argument_list|,
name|buf
argument_list|,
operator|(
name|tsize_t
operator|)
operator|-
literal|1
argument_list|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Encode the supplied data and write it to the  * specified tile.  There must be space for the  * data.  The function clamps individual writes  * to a tile to the tile size, but does not (and  * can not) check that multiple writes to the same  * tile do not write more than tile size data.  *  * NB: Image length must be setup before writing; this  *     interface does not support automatically growing  *     the image on each write (as TIFFWriteScanline does).  */
end_comment
begin_function
name|tsize_t
DECL|function|TIFFWriteEncodedTile
name|TIFFWriteEncodedTile
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|ttile_t
name|tile
parameter_list|,
name|tdata_t
name|data
parameter_list|,
name|tsize_t
name|cc
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|"TIFFWriteEncodedTile"
decl_stmt|;
name|TIFFDirectory
modifier|*
name|td
decl_stmt|;
name|tsample_t
name|sample
decl_stmt|;
if|if
condition|(
operator|!
name|WRITECHECKTILES
argument_list|(
name|tif
argument_list|,
name|module
argument_list|)
condition|)
return|return
operator|(
operator|(
name|tsize_t
operator|)
operator|-
literal|1
operator|)
return|;
name|td
operator|=
operator|&
name|tif
operator|->
name|tif_dir
expr_stmt|;
if|if
condition|(
name|tile
operator|>=
name|td
operator|->
name|td_nstrips
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Tile %lu out of range, max %lu"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|tile
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|td
operator|->
name|td_nstrips
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|tsize_t
operator|)
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Handle delayed allocation of data buffer.  This 	 * permits it to be sized more intelligently (using 	 * directory information). 	 */
if|if
condition|(
operator|!
name|BUFFERCHECK
argument_list|(
name|tif
argument_list|)
condition|)
return|return
operator|(
operator|(
name|tsize_t
operator|)
operator|-
literal|1
operator|)
return|;
name|tif
operator|->
name|tif_curtile
operator|=
name|tile
expr_stmt|;
name|tif
operator|->
name|tif_rawcc
operator|=
literal|0
expr_stmt|;
name|tif
operator|->
name|tif_rawcp
operator|=
name|tif
operator|->
name|tif_rawdata
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_stripbytecount
index|[
name|tile
index|]
operator|>
literal|0
condition|)
block|{
comment|/* Force TIFFAppendToStrip() to consider placing data at end                of file. */
name|tif
operator|->
name|tif_curoff
operator|=
literal|0
expr_stmt|;
block|}
comment|/*  	 * Compute tiles per row& per column to compute 	 * current row and column 	 */
name|tif
operator|->
name|tif_row
operator|=
operator|(
name|tile
operator|%
name|TIFFhowmany
argument_list|(
name|td
operator|->
name|td_imagelength
argument_list|,
name|td
operator|->
name|td_tilelength
argument_list|)
operator|)
operator|*
name|td
operator|->
name|td_tilelength
expr_stmt|;
name|tif
operator|->
name|tif_col
operator|=
operator|(
name|tile
operator|%
name|TIFFhowmany
argument_list|(
name|td
operator|->
name|td_imagewidth
argument_list|,
name|td
operator|->
name|td_tilewidth
argument_list|)
operator|)
operator|*
name|td
operator|->
name|td_tilewidth
expr_stmt|;
if|if
condition|(
operator|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_CODERSETUP
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|tif
operator|->
name|tif_setupencode
call|)
argument_list|(
name|tif
argument_list|)
condition|)
return|return
operator|(
operator|(
name|tsize_t
operator|)
operator|-
literal|1
operator|)
return|;
name|tif
operator|->
name|tif_flags
operator||=
name|TIFF_CODERSETUP
expr_stmt|;
block|}
name|tif
operator|->
name|tif_flags
operator|&=
operator|~
name|TIFF_POSTENCODE
expr_stmt|;
name|sample
operator|=
call|(
name|tsample_t
call|)
argument_list|(
name|tile
operator|/
name|td
operator|->
name|td_stripsperimage
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|tif
operator|->
name|tif_preencode
call|)
argument_list|(
name|tif
argument_list|,
name|sample
argument_list|)
condition|)
return|return
operator|(
operator|(
name|tsize_t
operator|)
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Clamp write amount to the tile size.  This is mostly 	 * done so that callers can pass in some large number 	 * (e.g. -1) and have the tile size used instead. 	 */
if|if
condition|(
name|cc
operator|<
literal|1
operator|||
name|cc
operator|>
name|tif
operator|->
name|tif_tilesize
condition|)
name|cc
operator|=
name|tif
operator|->
name|tif_tilesize
expr_stmt|;
comment|/* swab if needed - note that source buffer will be altered */
name|tif
operator|->
name|tif_postdecode
argument_list|(
name|tif
argument_list|,
operator|(
name|tidata_t
operator|)
name|data
argument_list|,
name|cc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|tif
operator|->
name|tif_encodetile
call|)
argument_list|(
name|tif
argument_list|,
operator|(
name|tidata_t
operator|)
name|data
argument_list|,
name|cc
argument_list|,
name|sample
argument_list|)
condition|)
return|return
operator|(
operator|(
name|tsize_t
operator|)
literal|0
operator|)
return|;
if|if
condition|(
operator|!
call|(
modifier|*
name|tif
operator|->
name|tif_postencode
call|)
argument_list|(
name|tif
argument_list|)
condition|)
return|return
operator|(
operator|(
name|tsize_t
operator|)
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|isFillOrder
argument_list|(
name|tif
argument_list|,
name|td
operator|->
name|td_fillorder
argument_list|)
operator|&&
operator|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_NOBITREV
operator|)
operator|==
literal|0
condition|)
name|TIFFReverseBits
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tif
operator|->
name|tif_rawdata
argument_list|,
name|tif
operator|->
name|tif_rawcc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tif
operator|->
name|tif_rawcc
operator|>
literal|0
operator|&&
operator|!
name|TIFFAppendToStrip
argument_list|(
name|tif
argument_list|,
name|tile
argument_list|,
name|tif
operator|->
name|tif_rawdata
argument_list|,
name|tif
operator|->
name|tif_rawcc
argument_list|)
condition|)
return|return
operator|(
operator|(
name|tsize_t
operator|)
operator|-
literal|1
operator|)
return|;
name|tif
operator|->
name|tif_rawcc
operator|=
literal|0
expr_stmt|;
name|tif
operator|->
name|tif_rawcp
operator|=
name|tif
operator|->
name|tif_rawdata
expr_stmt|;
return|return
operator|(
name|cc
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Write the supplied data to the specified strip.  * There must be space for the data; we don't check  * if strips overlap!  *  * NB: Image length must be setup before writing; this  *     interface does not support automatically growing  *     the image on each write (as TIFFWriteScanline does).  */
end_comment
begin_function
name|tsize_t
DECL|function|TIFFWriteRawTile
name|TIFFWriteRawTile
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|ttile_t
name|tile
parameter_list|,
name|tdata_t
name|data
parameter_list|,
name|tsize_t
name|cc
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|"TIFFWriteRawTile"
decl_stmt|;
if|if
condition|(
operator|!
name|WRITECHECKTILES
argument_list|(
name|tif
argument_list|,
name|module
argument_list|)
condition|)
return|return
operator|(
operator|(
name|tsize_t
operator|)
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|tile
operator|>=
name|tif
operator|->
name|tif_dir
operator|.
name|td_nstrips
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Tile %lu out of range, max %lu"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|tile
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|tif
operator|->
name|tif_dir
operator|.
name|td_nstrips
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|tsize_t
operator|)
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|TIFFAppendToStrip
argument_list|(
name|tif
argument_list|,
name|tile
argument_list|,
operator|(
name|tidata_t
operator|)
name|data
argument_list|,
name|cc
argument_list|)
condition|?
name|cc
else|:
operator|(
name|tsize_t
operator|)
operator|-
literal|1
operator|)
return|;
block|}
end_function
begin_define
DECL|macro|isUnspecified
define|#
directive|define
name|isUnspecified
parameter_list|(
name|tif
parameter_list|,
name|f
parameter_list|)
define|\
value|(TIFFFieldSet(tif,f)&& (tif)->tif_dir.td_imagelength == 0)
end_define
begin_function
name|int
DECL|function|TIFFSetupStrips
name|TIFFSetupStrips
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
if|if
condition|(
name|isTiled
argument_list|(
name|tif
argument_list|)
condition|)
name|td
operator|->
name|td_stripsperimage
operator|=
name|isUnspecified
argument_list|(
name|tif
argument_list|,
name|FIELD_TILEDIMENSIONS
argument_list|)
condition|?
name|td
operator|->
name|td_samplesperpixel
else|:
name|TIFFNumberOfTiles
argument_list|(
name|tif
argument_list|)
expr_stmt|;
else|else
name|td
operator|->
name|td_stripsperimage
operator|=
name|isUnspecified
argument_list|(
name|tif
argument_list|,
name|FIELD_ROWSPERSTRIP
argument_list|)
condition|?
name|td
operator|->
name|td_samplesperpixel
else|:
name|TIFFNumberOfStrips
argument_list|(
name|tif
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_nstrips
operator|=
name|td
operator|->
name|td_stripsperimage
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_planarconfig
operator|==
name|PLANARCONFIG_SEPARATE
condition|)
name|td
operator|->
name|td_stripsperimage
operator|/=
name|td
operator|->
name|td_samplesperpixel
expr_stmt|;
name|td
operator|->
name|td_stripoffset
operator|=
operator|(
name|uint32
operator|*
operator|)
name|_TIFFmalloc
argument_list|(
name|td
operator|->
name|td_nstrips
operator|*
sizeof|sizeof
argument_list|(
name|uint32
argument_list|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_stripbytecount
operator|=
operator|(
name|uint32
operator|*
operator|)
name|_TIFFmalloc
argument_list|(
name|td
operator|->
name|td_nstrips
operator|*
sizeof|sizeof
argument_list|(
name|uint32
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_stripoffset
operator|==
name|NULL
operator|||
name|td
operator|->
name|td_stripbytecount
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Place data at the end-of-file 	 * (by setting offsets to zero). 	 */
name|_TIFFmemset
argument_list|(
name|td
operator|->
name|td_stripoffset
argument_list|,
literal|0
argument_list|,
name|td
operator|->
name|td_nstrips
operator|*
sizeof|sizeof
argument_list|(
name|uint32
argument_list|)
argument_list|)
expr_stmt|;
name|_TIFFmemset
argument_list|(
name|td
operator|->
name|td_stripbytecount
argument_list|,
literal|0
argument_list|,
name|td
operator|->
name|td_nstrips
operator|*
sizeof|sizeof
argument_list|(
name|uint32
argument_list|)
argument_list|)
expr_stmt|;
name|TIFFSetFieldBit
argument_list|(
name|tif
argument_list|,
name|FIELD_STRIPOFFSETS
argument_list|)
expr_stmt|;
name|TIFFSetFieldBit
argument_list|(
name|tif
argument_list|,
name|FIELD_STRIPBYTECOUNTS
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_undef
DECL|macro|isUnspecified
undef|#
directive|undef
name|isUnspecified
end_undef
begin_comment
comment|/*  * Verify file is writable and that the directory  * information is setup properly.  In doing the latter  * we also "freeze" the state of the directory so  * that important information is not changed.  */
end_comment
begin_function
name|int
DECL|function|TIFFWriteCheck
name|TIFFWriteCheck
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|int
name|tiles
parameter_list|,
specifier|const
name|char
modifier|*
name|module
parameter_list|)
block|{
if|if
condition|(
name|tif
operator|->
name|tif_mode
operator|==
name|O_RDONLY
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: File not open for writing"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|tiles
operator|^
name|isTiled
argument_list|(
name|tif
argument_list|)
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
name|tiles
condition|?
literal|"Can not write tiles to a stripped image"
else|:
literal|"Can not write scanlines to a tiled image"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * On the first write verify all the required information 	 * has been setup and initialize any data structures that 	 * had to wait until directory information was set. 	 * Note that a lot of our work is assumed to remain valid 	 * because we disallow any of the important parameters 	 * from changing after we start writing (i.e. once 	 * TIFF_BEENWRITING is set, TIFFSetField will only allow 	 * the image's length to be changed). 	 */
if|if
condition|(
operator|!
name|TIFFFieldSet
argument_list|(
name|tif
argument_list|,
name|FIELD_IMAGEDIMENSIONS
argument_list|)
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Must set \"ImageWidth\" before writing data"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|tif
operator|->
name|tif_dir
operator|.
name|td_samplesperpixel
operator|==
literal|1
condition|)
block|{
comment|/*  		 * Planarconfiguration is irrelevant in case of single band 		 * images and need not be included. We will set it anyway, 		 * because this field is used in other parts of library even 		 * in the single band case. 		 */
if|if
condition|(
operator|!
name|TIFFFieldSet
argument_list|(
name|tif
argument_list|,
name|FIELD_PLANARCONFIG
argument_list|)
condition|)
name|tif
operator|->
name|tif_dir
operator|.
name|td_planarconfig
operator|=
name|PLANARCONFIG_CONTIG
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|TIFFFieldSet
argument_list|(
name|tif
argument_list|,
name|FIELD_PLANARCONFIG
argument_list|)
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Must set \"PlanarConfiguration\" before writing data"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|tif
operator|->
name|tif_dir
operator|.
name|td_stripoffset
operator|==
name|NULL
operator|&&
operator|!
name|TIFFSetupStrips
argument_list|(
name|tif
argument_list|)
condition|)
block|{
name|tif
operator|->
name|tif_dir
operator|.
name|td_nstrips
operator|=
literal|0
expr_stmt|;
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: No space for %s arrays"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
name|isTiled
argument_list|(
name|tif
argument_list|)
condition|?
literal|"tile"
else|:
literal|"strip"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|tif
operator|->
name|tif_tilesize
operator|=
name|isTiled
argument_list|(
name|tif
argument_list|)
condition|?
name|TIFFTileSize
argument_list|(
name|tif
argument_list|)
else|:
operator|(
name|tsize_t
operator|)
operator|-
literal|1
expr_stmt|;
name|tif
operator|->
name|tif_scanlinesize
operator|=
name|TIFFScanlineSize
argument_list|(
name|tif
argument_list|)
expr_stmt|;
name|tif
operator|->
name|tif_flags
operator||=
name|TIFF_BEENWRITING
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Setup the raw data buffer used for encoding.  */
end_comment
begin_function
name|int
DECL|function|TIFFWriteBufferSetup
name|TIFFWriteBufferSetup
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tdata_t
name|bp
parameter_list|,
name|tsize_t
name|size
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|"TIFFWriteBufferSetup"
decl_stmt|;
if|if
condition|(
name|tif
operator|->
name|tif_rawdata
condition|)
block|{
if|if
condition|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_MYBUFFER
condition|)
block|{
name|_TIFFfree
argument_list|(
name|tif
operator|->
name|tif_rawdata
argument_list|)
expr_stmt|;
name|tif
operator|->
name|tif_flags
operator|&=
operator|~
name|TIFF_MYBUFFER
expr_stmt|;
block|}
name|tif
operator|->
name|tif_rawdata
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|==
operator|(
name|tsize_t
operator|)
operator|-
literal|1
condition|)
block|{
name|size
operator|=
operator|(
name|isTiled
argument_list|(
name|tif
argument_list|)
condition|?
name|tif
operator|->
name|tif_tilesize
else|:
name|TIFFStripSize
argument_list|(
name|tif
argument_list|)
operator|)
expr_stmt|;
comment|/* 		 * Make raw data buffer at least 8K 		 */
if|if
condition|(
name|size
operator|<
literal|8
operator|*
literal|1024
condition|)
name|size
operator|=
literal|8
operator|*
literal|1024
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
comment|/* NB: force malloc */
block|}
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
name|bp
operator|=
name|_TIFFmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: No space for output buffer"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|tif
operator|->
name|tif_flags
operator||=
name|TIFF_MYBUFFER
expr_stmt|;
block|}
else|else
name|tif
operator|->
name|tif_flags
operator|&=
operator|~
name|TIFF_MYBUFFER
expr_stmt|;
name|tif
operator|->
name|tif_rawdata
operator|=
operator|(
name|tidata_t
operator|)
name|bp
expr_stmt|;
name|tif
operator|->
name|tif_rawdatasize
operator|=
name|size
expr_stmt|;
name|tif
operator|->
name|tif_rawcc
operator|=
literal|0
expr_stmt|;
name|tif
operator|->
name|tif_rawcp
operator|=
name|tif
operator|->
name|tif_rawdata
expr_stmt|;
name|tif
operator|->
name|tif_flags
operator||=
name|TIFF_BUFFERSETUP
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Grow the strip data structures by delta strips.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|TIFFGrowStrips
name|TIFFGrowStrips
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|int
name|delta
parameter_list|,
specifier|const
name|char
modifier|*
name|module
parameter_list|)
block|{
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|uint32
modifier|*
name|new_stripoffset
decl_stmt|,
modifier|*
name|new_stripbytecount
decl_stmt|;
name|assert
argument_list|(
name|td
operator|->
name|td_planarconfig
operator|==
name|PLANARCONFIG_CONTIG
argument_list|)
expr_stmt|;
name|new_stripoffset
operator|=
operator|(
name|uint32
operator|*
operator|)
name|_TIFFrealloc
argument_list|(
name|td
operator|->
name|td_stripoffset
argument_list|,
operator|(
name|td
operator|->
name|td_nstrips
operator|+
name|delta
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint32
argument_list|)
argument_list|)
expr_stmt|;
name|new_stripbytecount
operator|=
operator|(
name|uint32
operator|*
operator|)
name|_TIFFrealloc
argument_list|(
name|td
operator|->
name|td_stripbytecount
argument_list|,
operator|(
name|td
operator|->
name|td_nstrips
operator|+
name|delta
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint32
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_stripoffset
operator|==
name|NULL
operator|||
name|new_stripbytecount
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|new_stripoffset
condition|)
name|_TIFFfree
argument_list|(
name|new_stripoffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_stripbytecount
condition|)
name|_TIFFfree
argument_list|(
name|new_stripbytecount
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_nstrips
operator|=
literal|0
expr_stmt|;
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: No space to expand strip arrays"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|td
operator|->
name|td_stripoffset
operator|=
name|new_stripoffset
expr_stmt|;
name|td
operator|->
name|td_stripbytecount
operator|=
name|new_stripbytecount
expr_stmt|;
name|_TIFFmemset
argument_list|(
name|td
operator|->
name|td_stripoffset
operator|+
name|td
operator|->
name|td_nstrips
argument_list|,
literal|0
argument_list|,
name|delta
operator|*
sizeof|sizeof
argument_list|(
name|uint32
argument_list|)
argument_list|)
expr_stmt|;
name|_TIFFmemset
argument_list|(
name|td
operator|->
name|td_stripbytecount
operator|+
name|td
operator|->
name|td_nstrips
argument_list|,
literal|0
argument_list|,
name|delta
operator|*
sizeof|sizeof
argument_list|(
name|uint32
argument_list|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_nstrips
operator|+=
name|delta
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Append the data to the specified strip.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|TIFFAppendToStrip
name|TIFFAppendToStrip
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tstrip_t
name|strip
parameter_list|,
name|tidata_t
name|data
parameter_list|,
name|tsize_t
name|cc
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|"TIFFAppendToStrip"
decl_stmt|;
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
if|if
condition|(
name|td
operator|->
name|td_stripoffset
index|[
name|strip
index|]
operator|==
literal|0
operator|||
name|tif
operator|->
name|tif_curoff
operator|==
literal|0
condition|)
block|{
name|assert
argument_list|(
name|td
operator|->
name|td_nstrips
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_stripbytecount
index|[
name|strip
index|]
operator|!=
literal|0
operator|&&
name|td
operator|->
name|td_stripoffset
index|[
name|strip
index|]
operator|!=
literal|0
operator|&&
name|td
operator|->
name|td_stripbytecount
index|[
name|strip
index|]
operator|>=
name|cc
condition|)
block|{
comment|/*                   * There is already tile data on disk, and the new tile                  * data we have to will fit in the same space.  The only                   * aspect of this that is risky is that there could be                  * more data to append to this strip before we are done                  * depending on how we are getting called.                  */
if|if
condition|(
operator|!
name|SeekOK
argument_list|(
name|tif
argument_list|,
name|td
operator|->
name|td_stripoffset
index|[
name|strip
index|]
argument_list|)
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"Seek error at scanline %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|tif
operator|->
name|tif_row
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/*                   * Seek to end of file, and set that as our location to                   * write this strip.                  */
name|td
operator|->
name|td_stripoffset
index|[
name|strip
index|]
operator|=
name|TIFFSeekFile
argument_list|(
name|tif
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
block|}
name|tif
operator|->
name|tif_curoff
operator|=
name|td
operator|->
name|td_stripoffset
index|[
name|strip
index|]
expr_stmt|;
comment|/*              * We are starting a fresh strip/tile, so set the size to zero.              */
name|td
operator|->
name|td_stripbytecount
index|[
name|strip
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|WriteOK
argument_list|(
name|tif
argument_list|,
name|data
argument_list|,
name|cc
argument_list|)
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"Write error at scanline %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|tif
operator|->
name|tif_row
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|tif
operator|->
name|tif_curoff
operator|=
name|tif
operator|->
name|tif_curoff
operator|+
name|cc
expr_stmt|;
name|td
operator|->
name|td_stripbytecount
index|[
name|strip
index|]
operator|+=
name|cc
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Internal version of TIFFFlushData that can be  * called by ``encodestrip routines'' w/o concern  * for infinite recursion.  */
end_comment
begin_function
name|int
DECL|function|TIFFFlushData1
name|TIFFFlushData1
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
if|if
condition|(
name|tif
operator|->
name|tif_rawcc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|isFillOrder
argument_list|(
name|tif
argument_list|,
name|tif
operator|->
name|tif_dir
operator|.
name|td_fillorder
argument_list|)
operator|&&
operator|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_NOBITREV
operator|)
operator|==
literal|0
condition|)
name|TIFFReverseBits
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tif
operator|->
name|tif_rawdata
argument_list|,
name|tif
operator|->
name|tif_rawcc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TIFFAppendToStrip
argument_list|(
name|tif
argument_list|,
name|isTiled
argument_list|(
name|tif
argument_list|)
condition|?
name|tif
operator|->
name|tif_curtile
else|:
name|tif
operator|->
name|tif_curstrip
argument_list|,
name|tif
operator|->
name|tif_rawdata
argument_list|,
name|tif
operator|->
name|tif_rawcc
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|tif
operator|->
name|tif_rawcc
operator|=
literal|0
expr_stmt|;
name|tif
operator|->
name|tif_rawcp
operator|=
name|tif
operator|->
name|tif_rawdata
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Set the current write offset.  This should only be  * used to set the offset to a known previous location  * (very carefully), or to 0 so that the next write gets  * appended to the end of the file.  */
end_comment
begin_function
name|void
DECL|function|TIFFSetWriteOffset
name|TIFFSetWriteOffset
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|toff_t
name|off
parameter_list|)
block|{
name|tif
operator|->
name|tif_curoff
operator|=
name|off
expr_stmt|;
block|}
end_function
begin_comment
comment|/* vim: set ts=8 sts=8 sw=8 noet: */
end_comment
end_unit
