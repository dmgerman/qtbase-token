begin_unit
begin_comment
comment|/* $Id: tif_tile.c,v 1.12 2006/02/09 16:15:43 dron Exp $ */
end_comment
begin_comment
comment|/*  * Copyright (c) 1991-1997 Sam Leffler  * Copyright (c) 1991-1997 Silicon Graphics, Inc.  *  * Permission to use, copy, modify, distribute, and sell this software and   * its documentation for any purpose is hereby granted without fee, provided  * that (i) the above copyright notices and this permission notice appear in  * all copies of the software and related documentation, and (ii) the names of  * Sam Leffler and Silicon Graphics may not be used in any advertising or  * publicity relating to the software without the specific, prior written  * permission of Sam Leffler and Silicon Graphics.  *   * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,   * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY   * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.    *   * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR  * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,  * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF   * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE   * OF THIS SOFTWARE.  */
end_comment
begin_comment
comment|/*  * TIFF Library.  *  * Tiled Image Support Routines.  */
end_comment
begin_include
include|#
directive|include
file|"tiffiop.h"
end_include
begin_function
specifier|static
name|uint32
DECL|function|summarize
name|summarize
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|size_t
name|summand1
parameter_list|,
name|size_t
name|summand2
parameter_list|,
specifier|const
name|char
modifier|*
name|where
parameter_list|)
block|{
comment|/* 	 * XXX: We are using casting to uint32 here, because sizeof(size_t) 	 * may be larger than sizeof(uint32) on 64-bit architectures. 	 */
name|uint32
name|bytes
init|=
name|summand1
operator|+
name|summand2
decl_stmt|;
if|if
condition|(
name|bytes
operator|-
name|summand1
operator|!=
name|summand2
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"Integer overflow in %s"
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|bytes
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|bytes
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|uint32
DECL|function|multiply
name|multiply
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|size_t
name|nmemb
parameter_list|,
name|size_t
name|elem_size
parameter_list|,
specifier|const
name|char
modifier|*
name|where
parameter_list|)
block|{
name|uint32
name|bytes
init|=
name|nmemb
operator|*
name|elem_size
decl_stmt|;
if|if
condition|(
name|elem_size
operator|&&
name|bytes
operator|/
name|elem_size
operator|!=
name|nmemb
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"Integer overflow in %s"
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|bytes
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|bytes
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Compute which tile an (x,y,z,s) value is in.  */
end_comment
begin_function
name|ttile_t
DECL|function|TIFFComputeTile
name|TIFFComputeTile
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|uint32
name|x
parameter_list|,
name|uint32
name|y
parameter_list|,
name|uint32
name|z
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|uint32
name|dx
init|=
name|td
operator|->
name|td_tilewidth
decl_stmt|;
name|uint32
name|dy
init|=
name|td
operator|->
name|td_tilelength
decl_stmt|;
name|uint32
name|dz
init|=
name|td
operator|->
name|td_tiledepth
decl_stmt|;
name|ttile_t
name|tile
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|td
operator|->
name|td_imagedepth
operator|==
literal|1
condition|)
name|z
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dx
operator|==
operator|(
name|uint32
operator|)
operator|-
literal|1
condition|)
name|dx
operator|=
name|td
operator|->
name|td_imagewidth
expr_stmt|;
if|if
condition|(
name|dy
operator|==
operator|(
name|uint32
operator|)
operator|-
literal|1
condition|)
name|dy
operator|=
name|td
operator|->
name|td_imagelength
expr_stmt|;
if|if
condition|(
name|dz
operator|==
operator|(
name|uint32
operator|)
operator|-
literal|1
condition|)
name|dz
operator|=
name|td
operator|->
name|td_imagedepth
expr_stmt|;
if|if
condition|(
name|dx
operator|!=
literal|0
operator|&&
name|dy
operator|!=
literal|0
operator|&&
name|dz
operator|!=
literal|0
condition|)
block|{
name|uint32
name|xpt
init|=
name|TIFFhowmany
argument_list|(
name|td
operator|->
name|td_imagewidth
argument_list|,
name|dx
argument_list|)
decl_stmt|;
name|uint32
name|ypt
init|=
name|TIFFhowmany
argument_list|(
name|td
operator|->
name|td_imagelength
argument_list|,
name|dy
argument_list|)
decl_stmt|;
name|uint32
name|zpt
init|=
name|TIFFhowmany
argument_list|(
name|td
operator|->
name|td_imagedepth
argument_list|,
name|dz
argument_list|)
decl_stmt|;
if|if
condition|(
name|td
operator|->
name|td_planarconfig
operator|==
name|PLANARCONFIG_SEPARATE
condition|)
name|tile
operator|=
operator|(
name|xpt
operator|*
name|ypt
operator|*
name|zpt
operator|)
operator|*
name|s
operator|+
operator|(
name|xpt
operator|*
name|ypt
operator|)
operator|*
operator|(
name|z
operator|/
name|dz
operator|)
operator|+
name|xpt
operator|*
operator|(
name|y
operator|/
name|dy
operator|)
operator|+
name|x
operator|/
name|dx
expr_stmt|;
else|else
name|tile
operator|=
operator|(
name|xpt
operator|*
name|ypt
operator|)
operator|*
operator|(
name|z
operator|/
name|dz
operator|)
operator|+
name|xpt
operator|*
operator|(
name|y
operator|/
name|dy
operator|)
operator|+
name|x
operator|/
name|dx
expr_stmt|;
block|}
return|return
operator|(
name|tile
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Check an (x,y,z,s) coordinate  * against the image bounds.  */
end_comment
begin_function
name|int
DECL|function|TIFFCheckTile
name|TIFFCheckTile
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|uint32
name|x
parameter_list|,
name|uint32
name|y
parameter_list|,
name|uint32
name|z
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
if|if
condition|(
name|x
operator|>=
name|td
operator|->
name|td_imagewidth
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"%lu: Col out of range, max %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|x
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|td
operator|->
name|td_imagewidth
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|y
operator|>=
name|td
operator|->
name|td_imagelength
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"%lu: Row out of range, max %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|y
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|td
operator|->
name|td_imagelength
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|z
operator|>=
name|td
operator|->
name|td_imagedepth
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"%lu: Depth out of range, max %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|z
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|td
operator|->
name|td_imagedepth
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|td
operator|->
name|td_planarconfig
operator|==
name|PLANARCONFIG_SEPARATE
operator|&&
name|s
operator|>=
name|td
operator|->
name|td_samplesperpixel
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"%lu: Sample out of range, max %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|s
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|td
operator|->
name|td_samplesperpixel
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Compute how many tiles are in an image.  */
end_comment
begin_function
name|ttile_t
DECL|function|TIFFNumberOfTiles
name|TIFFNumberOfTiles
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|uint32
name|dx
init|=
name|td
operator|->
name|td_tilewidth
decl_stmt|;
name|uint32
name|dy
init|=
name|td
operator|->
name|td_tilelength
decl_stmt|;
name|uint32
name|dz
init|=
name|td
operator|->
name|td_tiledepth
decl_stmt|;
name|ttile_t
name|ntiles
decl_stmt|;
if|if
condition|(
name|dx
operator|==
operator|(
name|uint32
operator|)
operator|-
literal|1
condition|)
name|dx
operator|=
name|td
operator|->
name|td_imagewidth
expr_stmt|;
if|if
condition|(
name|dy
operator|==
operator|(
name|uint32
operator|)
operator|-
literal|1
condition|)
name|dy
operator|=
name|td
operator|->
name|td_imagelength
expr_stmt|;
if|if
condition|(
name|dz
operator|==
operator|(
name|uint32
operator|)
operator|-
literal|1
condition|)
name|dz
operator|=
name|td
operator|->
name|td_imagedepth
expr_stmt|;
name|ntiles
operator|=
operator|(
name|dx
operator|==
literal|0
operator|||
name|dy
operator|==
literal|0
operator|||
name|dz
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|multiply
argument_list|(
name|tif
argument_list|,
name|multiply
argument_list|(
name|tif
argument_list|,
name|TIFFhowmany
argument_list|(
name|td
operator|->
name|td_imagewidth
argument_list|,
name|dx
argument_list|)
argument_list|,
name|TIFFhowmany
argument_list|(
name|td
operator|->
name|td_imagelength
argument_list|,
name|dy
argument_list|)
argument_list|,
literal|"TIFFNumberOfTiles"
argument_list|)
argument_list|,
name|TIFFhowmany
argument_list|(
name|td
operator|->
name|td_imagedepth
argument_list|,
name|dz
argument_list|)
argument_list|,
literal|"TIFFNumberOfTiles"
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_planarconfig
operator|==
name|PLANARCONFIG_SEPARATE
condition|)
name|ntiles
operator|=
name|multiply
argument_list|(
name|tif
argument_list|,
name|ntiles
argument_list|,
name|td
operator|->
name|td_samplesperpixel
argument_list|,
literal|"TIFFNumberOfTiles"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ntiles
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Compute the # bytes in each row of a tile.  */
end_comment
begin_function
name|tsize_t
DECL|function|TIFFTileRowSize
name|TIFFTileRowSize
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|tsize_t
name|rowsize
decl_stmt|;
if|if
condition|(
name|td
operator|->
name|td_tilelength
operator|==
literal|0
operator|||
name|td
operator|->
name|td_tilewidth
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|tsize_t
operator|)
literal|0
operator|)
return|;
name|rowsize
operator|=
name|multiply
argument_list|(
name|tif
argument_list|,
name|td
operator|->
name|td_bitspersample
argument_list|,
name|td
operator|->
name|td_tilewidth
argument_list|,
literal|"TIFFTileRowSize"
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_planarconfig
operator|==
name|PLANARCONFIG_CONTIG
condition|)
name|rowsize
operator|=
name|multiply
argument_list|(
name|tif
argument_list|,
name|rowsize
argument_list|,
name|td
operator|->
name|td_samplesperpixel
argument_list|,
literal|"TIFFTileRowSize"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|tsize_t
operator|)
name|TIFFhowmany8
argument_list|(
name|rowsize
argument_list|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Compute the # bytes in a variable length, row-aligned tile.  */
end_comment
begin_function
name|tsize_t
DECL|function|TIFFVTileSize
name|TIFFVTileSize
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|uint32
name|nrows
parameter_list|)
block|{
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|tsize_t
name|tilesize
decl_stmt|;
if|if
condition|(
name|td
operator|->
name|td_tilelength
operator|==
literal|0
operator|||
name|td
operator|->
name|td_tilewidth
operator|==
literal|0
operator|||
name|td
operator|->
name|td_tiledepth
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|tsize_t
operator|)
literal|0
operator|)
return|;
if|if
condition|(
name|td
operator|->
name|td_planarconfig
operator|==
name|PLANARCONFIG_CONTIG
operator|&&
name|td
operator|->
name|td_photometric
operator|==
name|PHOTOMETRIC_YCBCR
operator|&&
operator|!
name|isUpSampled
argument_list|(
name|tif
argument_list|)
condition|)
block|{
comment|/* 		 * Packed YCbCr data contain one Cb+Cr for every 		 * HorizontalSampling*VerticalSampling Y values. 		 * Must also roundup width and height when calculating 		 * since images that are not a multiple of the 		 * horizontal/vertical subsampling area include 		 * YCbCr data for the extended image. 		 */
name|tsize_t
name|w
init|=
name|TIFFroundup
argument_list|(
name|td
operator|->
name|td_tilewidth
argument_list|,
name|td
operator|->
name|td_ycbcrsubsampling
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|tsize_t
name|rowsize
init|=
name|TIFFhowmany8
argument_list|(
name|multiply
argument_list|(
name|tif
argument_list|,
name|w
argument_list|,
name|td
operator|->
name|td_bitspersample
argument_list|,
literal|"TIFFVTileSize"
argument_list|)
argument_list|)
decl_stmt|;
name|tsize_t
name|samplingarea
init|=
name|td
operator|->
name|td_ycbcrsubsampling
index|[
literal|0
index|]
operator|*
name|td
operator|->
name|td_ycbcrsubsampling
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|samplingarea
operator|==
literal|0
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"Invalid YCbCr subsampling"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|nrows
operator|=
name|TIFFroundup
argument_list|(
name|nrows
argument_list|,
name|td
operator|->
name|td_ycbcrsubsampling
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* NB: don't need TIFFhowmany here 'cuz everything is rounded */
name|tilesize
operator|=
name|multiply
argument_list|(
name|tif
argument_list|,
name|nrows
argument_list|,
name|rowsize
argument_list|,
literal|"TIFFVTileSize"
argument_list|)
expr_stmt|;
name|tilesize
operator|=
name|summarize
argument_list|(
name|tif
argument_list|,
name|tilesize
argument_list|,
name|multiply
argument_list|(
name|tif
argument_list|,
literal|2
argument_list|,
name|tilesize
operator|/
name|samplingarea
argument_list|,
literal|"TIFFVTileSize"
argument_list|)
argument_list|,
literal|"TIFFVTileSize"
argument_list|)
expr_stmt|;
block|}
else|else
name|tilesize
operator|=
name|multiply
argument_list|(
name|tif
argument_list|,
name|nrows
argument_list|,
name|TIFFTileRowSize
argument_list|(
name|tif
argument_list|)
argument_list|,
literal|"TIFFVTileSize"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|tsize_t
operator|)
name|multiply
argument_list|(
name|tif
argument_list|,
name|tilesize
argument_list|,
name|td
operator|->
name|td_tiledepth
argument_list|,
literal|"TIFFVTileSize"
argument_list|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Compute the # bytes in a row-aligned tile.  */
end_comment
begin_function
name|tsize_t
DECL|function|TIFFTileSize
name|TIFFTileSize
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
return|return
operator|(
name|TIFFVTileSize
argument_list|(
name|tif
argument_list|,
name|tif
operator|->
name|tif_dir
operator|.
name|td_tilelength
argument_list|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Compute a default tile size based on the image  * characteristics and a requested value.  If a  * request is<1 then we choose a size according  * to certain heuristics.  */
end_comment
begin_function
name|void
DECL|function|TIFFDefaultTileSize
name|TIFFDefaultTileSize
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|uint32
modifier|*
name|tw
parameter_list|,
name|uint32
modifier|*
name|th
parameter_list|)
block|{
call|(
modifier|*
name|tif
operator|->
name|tif_deftilesize
call|)
argument_list|(
name|tif
argument_list|,
name|tw
argument_list|,
name|th
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|void
DECL|function|_TIFFDefaultTileSize
name|_TIFFDefaultTileSize
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|uint32
modifier|*
name|tw
parameter_list|,
name|uint32
modifier|*
name|th
parameter_list|)
block|{
operator|(
name|void
operator|)
name|tif
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int32
operator|*
operator|)
name|tw
operator|<
literal|1
condition|)
operator|*
name|tw
operator|=
literal|256
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int32
operator|*
operator|)
name|th
operator|<
literal|1
condition|)
operator|*
name|th
operator|=
literal|256
expr_stmt|;
comment|/* roundup to a multiple of 16 per the spec */
if|if
condition|(
operator|*
name|tw
operator|&
literal|0xf
condition|)
operator|*
name|tw
operator|=
name|TIFFroundup
argument_list|(
operator|*
name|tw
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|th
operator|&
literal|0xf
condition|)
operator|*
name|th
operator|=
name|TIFFroundup
argument_list|(
operator|*
name|th
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* vim: set ts=8 sts=8 sw=8 noet: */
end_comment
end_unit
