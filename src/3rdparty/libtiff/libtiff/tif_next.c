begin_unit
begin_comment
comment|/* $Id: tif_next.c,v 1.8 2006/10/12 15:00:49 dron Exp $ */
end_comment
begin_comment
comment|/*  * Copyright (c) 1988-1997 Sam Leffler  * Copyright (c) 1991-1997 Silicon Graphics, Inc.  *  * Permission to use, copy, modify, distribute, and sell this software and   * its documentation for any purpose is hereby granted without fee, provided  * that (i) the above copyright notices and this permission notice appear in  * all copies of the software and related documentation, and (ii) the names of  * Sam Leffler and Silicon Graphics may not be used in any advertising or  * publicity relating to the software without the specific, prior written  * permission of Sam Leffler and Silicon Graphics.  *   * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,   * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY   * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.    *   * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR  * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,  * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF   * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE   * OF THIS SOFTWARE.  */
end_comment
begin_include
include|#
directive|include
file|"tiffiop.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|NEXT_SUPPORT
end_ifdef
begin_comment
comment|/*  * TIFF Library.  *  * NeXT 2-bit Grey Scale Compression Algorithm Support  */
end_comment
begin_define
DECL|macro|SETPIXEL
define|#
directive|define
name|SETPIXEL
parameter_list|(
name|op
parameter_list|,
name|v
parameter_list|)
value|{			\ 	switch (npixels++& 3) {		\ 	case 0:	op[0]  = (unsigned char) ((v)<< 6); break;	\ 	case 1:	op[0] |= (v)<< 4; break;	\ 	case 2:	op[0] |= (v)<< 2; break;	\ 	case 3:	*op++ |= (v);	   break;	\ 	}					\ }
end_define
begin_define
DECL|macro|LITERALROW
define|#
directive|define
name|LITERALROW
value|0x00
end_define
begin_define
DECL|macro|LITERALSPAN
define|#
directive|define
name|LITERALSPAN
value|0x40
end_define
begin_define
DECL|macro|WHITE
define|#
directive|define
name|WHITE
value|((1<<2)-1)
end_define
begin_function
specifier|static
name|int
DECL|function|NeXTDecode
name|NeXTDecode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|buf
parameter_list|,
name|tsize_t
name|occ
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|op
decl_stmt|;
name|tsize_t
name|cc
decl_stmt|;
name|tidata_t
name|row
decl_stmt|;
name|tsize_t
name|scanline
decl_stmt|,
name|n
decl_stmt|;
operator|(
name|void
operator|)
name|s
expr_stmt|;
comment|/* 	 * Each scanline is assumed to start off as all 	 * white (we assume a PhotometricInterpretation 	 * of ``min-is-black''). 	 */
for|for
control|(
name|op
operator|=
name|buf
operator|,
name|cc
operator|=
name|occ
init|;
name|cc
operator|--
operator|>
literal|0
condition|;
control|)
operator|*
name|op
operator|++
operator|=
literal|0xff
expr_stmt|;
name|bp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tif
operator|->
name|tif_rawcp
expr_stmt|;
name|cc
operator|=
name|tif
operator|->
name|tif_rawcc
expr_stmt|;
name|scanline
operator|=
name|tif
operator|->
name|tif_scanlinesize
expr_stmt|;
for|for
control|(
name|row
operator|=
name|buf
init|;
name|occ
operator|>
literal|0
condition|;
name|occ
operator|-=
name|scanline
operator|,
name|row
operator|+=
name|scanline
control|)
block|{
name|n
operator|=
operator|*
name|bp
operator|++
operator|,
name|cc
operator|--
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|LITERALROW
case|:
comment|/* 			 * The entire scanline is given as literal values. 			 */
if|if
condition|(
name|cc
operator|<
name|scanline
condition|)
goto|goto
name|bad
goto|;
name|_TIFFmemcpy
argument_list|(
name|row
argument_list|,
name|bp
argument_list|,
name|scanline
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|scanline
expr_stmt|;
name|cc
operator|-=
name|scanline
expr_stmt|;
break|break;
case|case
name|LITERALSPAN
case|:
block|{
name|tsize_t
name|off
decl_stmt|;
comment|/* 			 * The scanline has a literal span that begins at some 			 * offset. 			 */
name|off
operator|=
operator|(
name|bp
index|[
literal|0
index|]
operator|*
literal|256
operator|)
operator|+
name|bp
index|[
literal|1
index|]
expr_stmt|;
name|n
operator|=
operator|(
name|bp
index|[
literal|2
index|]
operator|*
literal|256
operator|)
operator|+
name|bp
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|cc
operator|<
literal|4
operator|+
name|n
operator|||
name|off
operator|+
name|n
operator|>
name|scanline
condition|)
goto|goto
name|bad
goto|;
name|_TIFFmemcpy
argument_list|(
name|row
operator|+
name|off
argument_list|,
name|bp
operator|+
literal|4
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|bp
operator|+=
literal|4
operator|+
name|n
expr_stmt|;
name|cc
operator|-=
literal|4
operator|+
name|n
expr_stmt|;
break|break;
block|}
default|default:
block|{
name|uint32
name|npixels
init|=
literal|0
decl_stmt|,
name|grey
decl_stmt|;
name|uint32
name|imagewidth
init|=
name|tif
operator|->
name|tif_dir
operator|.
name|td_imagewidth
decl_stmt|;
comment|/* 			 * The scanline is composed of a sequence of constant 			 * color ``runs''.  We shift into ``run mode'' and 			 * interpret bytes as codes of the form 			 *<color><npixels> until we've filled the scanline. 			 */
name|op
operator|=
name|row
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|grey
operator|=
operator|(
name|n
operator|>>
literal|6
operator|)
operator|&
literal|0x3
expr_stmt|;
name|n
operator|&=
literal|0x3f
expr_stmt|;
comment|/* 				 * Ensure the run does not exceed the scanline 				 * bounds, potentially resulting in a security 				 * issue. 				 */
while|while
condition|(
name|n
operator|--
operator|>
literal|0
operator|&&
name|npixels
operator|<
name|imagewidth
condition|)
name|SETPIXEL
argument_list|(
name|op
argument_list|,
name|grey
argument_list|)
expr_stmt|;
if|if
condition|(
name|npixels
operator|>=
name|imagewidth
condition|)
break|break;
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
name|n
operator|=
operator|*
name|bp
operator|++
operator|,
name|cc
operator|--
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
name|tif
operator|->
name|tif_rawcp
operator|=
operator|(
name|tidata_t
operator|)
name|bp
expr_stmt|;
name|tif
operator|->
name|tif_rawcc
operator|=
name|cc
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
name|bad
label|:
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"NeXTDecode: Not enough data for scanline %ld"
argument_list|,
operator|(
name|long
operator|)
name|tif
operator|->
name|tif_row
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function
begin_function
name|int
DECL|function|TIFFInitNeXT
name|TIFFInitNeXT
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|int
name|scheme
parameter_list|)
block|{
operator|(
name|void
operator|)
name|scheme
expr_stmt|;
name|tif
operator|->
name|tif_decoderow
operator|=
name|NeXTDecode
expr_stmt|;
name|tif
operator|->
name|tif_decodestrip
operator|=
name|NeXTDecode
expr_stmt|;
name|tif
operator|->
name|tif_decodetile
operator|=
name|NeXTDecode
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* NEXT_SUPPORT */
end_comment
begin_comment
comment|/* vim: set ts=8 sts=8 sw=8 noet: */
end_comment
end_unit
