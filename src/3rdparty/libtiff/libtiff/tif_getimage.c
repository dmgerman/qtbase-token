begin_unit
begin_comment
comment|/* $Id: tif_getimage.c,v 1.63.2.3 2009-08-30 16:21:46 bfriesen Exp $ */
end_comment
begin_comment
comment|/*  * Copyright (c) 1991-1997 Sam Leffler  * Copyright (c) 1991-1997 Silicon Graphics, Inc.  *  * Permission to use, copy, modify, distribute, and sell this software and   * its documentation for any purpose is hereby granted without fee, provided  * that (i) the above copyright notices and this permission notice appear in  * all copies of the software and related documentation, and (ii) the names of  * Sam Leffler and Silicon Graphics may not be used in any advertising or  * publicity relating to the software without the specific, prior written  * permission of Sam Leffler and Silicon Graphics.  *   * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,   * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY   * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.    *   * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR  * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,  * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF   * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE   * OF THIS SOFTWARE.  */
end_comment
begin_comment
comment|/*  * TIFF Library  *  * Read and return a packed RGBA image.  */
end_comment
begin_include
include|#
directive|include
file|"tiffiop.h"
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_function_decl
specifier|static
name|int
name|gtTileContig
parameter_list|(
name|TIFFRGBAImage
modifier|*
parameter_list|,
name|uint32
modifier|*
parameter_list|,
name|uint32
parameter_list|,
name|uint32
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|gtTileSeparate
parameter_list|(
name|TIFFRGBAImage
modifier|*
parameter_list|,
name|uint32
modifier|*
parameter_list|,
name|uint32
parameter_list|,
name|uint32
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|gtStripContig
parameter_list|(
name|TIFFRGBAImage
modifier|*
parameter_list|,
name|uint32
modifier|*
parameter_list|,
name|uint32
parameter_list|,
name|uint32
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|gtStripSeparate
parameter_list|(
name|TIFFRGBAImage
modifier|*
parameter_list|,
name|uint32
modifier|*
parameter_list|,
name|uint32
parameter_list|,
name|uint32
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|PickContigCase
parameter_list|(
name|TIFFRGBAImage
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|PickSeparateCase
parameter_list|(
name|TIFFRGBAImage
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_decl_stmt
DECL|variable|photoTag
specifier|static
specifier|const
name|char
name|photoTag
index|[]
init|=
literal|"PhotometricInterpretation"
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*   * Helper constants used in Orientation tag handling  */
end_comment
begin_define
DECL|macro|FLIP_VERTICALLY
define|#
directive|define
name|FLIP_VERTICALLY
value|0x01
end_define
begin_define
DECL|macro|FLIP_HORIZONTALLY
define|#
directive|define
name|FLIP_HORIZONTALLY
value|0x02
end_define
begin_comment
comment|/*  * Color conversion constants. We will define display types here.  */
end_comment
begin_decl_stmt
DECL|variable|display_sRGB
name|TIFFDisplay
name|display_sRGB
init|=
block|{
block|{
comment|/* XYZ -> luminance matrix */
block|{
literal|3.2410F
block|,
operator|-
literal|1.5374F
block|,
operator|-
literal|0.4986F
block|}
block|,
block|{
operator|-
literal|0.9692F
block|,
literal|1.8760F
block|,
literal|0.0416F
block|}
block|,
block|{
literal|0.0556F
block|,
operator|-
literal|0.2040F
block|,
literal|1.0570F
block|}
block|}
block|,
literal|100.0F
block|,
literal|100.0F
block|,
literal|100.0F
block|,
comment|/* Light o/p for reference white */
literal|255
block|,
literal|255
block|,
literal|255
block|,
comment|/* Pixel values for ref. white */
literal|1.0F
block|,
literal|1.0F
block|,
literal|1.0F
block|,
comment|/* Residual light o/p for black pixel */
literal|2.4F
block|,
literal|2.4F
block|,
literal|2.4F
block|,
comment|/* Gamma values for the three guns */
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*  * Check the image to see if TIFFReadRGBAImage can deal with it.  * 1/0 is returned according to whether or not the image can  * be handled.  If 0 is returned, emsg contains the reason  * why it is being rejected.  */
end_comment
begin_function
name|int
DECL|function|TIFFRGBAImageOK
name|TIFFRGBAImageOK
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|char
name|emsg
index|[
literal|1024
index|]
parameter_list|)
block|{
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|uint16
name|photometric
decl_stmt|;
name|int
name|colorchannels
decl_stmt|;
if|if
condition|(
operator|!
name|tif
operator|->
name|tif_decodestatus
condition|)
block|{
name|sprintf
argument_list|(
name|emsg
argument_list|,
literal|"Sorry, requested compression method is not configured"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
name|td
operator|->
name|td_bitspersample
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|4
case|:
case|case
literal|8
case|:
case|case
literal|16
case|:
break|break;
default|default:
name|sprintf
argument_list|(
name|emsg
argument_list|,
literal|"Sorry, can not handle images with %d-bit samples"
argument_list|,
name|td
operator|->
name|td_bitspersample
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|colorchannels
operator|=
name|td
operator|->
name|td_samplesperpixel
operator|-
name|td
operator|->
name|td_extrasamples
expr_stmt|;
if|if
condition|(
operator|!
name|TIFFGetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_PHOTOMETRIC
argument_list|,
operator|&
name|photometric
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|colorchannels
condition|)
block|{
case|case
literal|1
case|:
name|photometric
operator|=
name|PHOTOMETRIC_MINISBLACK
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|photometric
operator|=
name|PHOTOMETRIC_RGB
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|emsg
argument_list|,
literal|"Missing needed %s tag"
argument_list|,
name|photoTag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
switch|switch
condition|(
name|photometric
condition|)
block|{
case|case
name|PHOTOMETRIC_MINISWHITE
case|:
case|case
name|PHOTOMETRIC_MINISBLACK
case|:
case|case
name|PHOTOMETRIC_PALETTE
case|:
if|if
condition|(
name|td
operator|->
name|td_planarconfig
operator|==
name|PLANARCONFIG_CONTIG
operator|&&
name|td
operator|->
name|td_samplesperpixel
operator|!=
literal|1
operator|&&
name|td
operator|->
name|td_bitspersample
operator|<
literal|8
condition|)
block|{
name|sprintf
argument_list|(
name|emsg
argument_list|,
literal|"Sorry, can not handle contiguous data with %s=%d, "
literal|"and %s=%d and Bits/Sample=%d"
argument_list|,
name|photoTag
argument_list|,
name|photometric
argument_list|,
literal|"Samples/pixel"
argument_list|,
name|td
operator|->
name|td_samplesperpixel
argument_list|,
name|td
operator|->
name|td_bitspersample
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 			 * We should likely validate that any extra samples are either 			 * to be ignored, or are alpha, and if alpha we should try to use 			 * them.  But for now we won't bother with this. 			*/
break|break;
case|case
name|PHOTOMETRIC_YCBCR
case|:
comment|/* 			 * TODO: if at all meaningful and useful, make more complete 			 * support check here, or better still, refactor to let supporting 			 * code decide whether there is support and what meaningfull 			 * error to return 			 */
break|break;
case|case
name|PHOTOMETRIC_RGB
case|:
if|if
condition|(
name|colorchannels
operator|<
literal|3
condition|)
block|{
name|sprintf
argument_list|(
name|emsg
argument_list|,
literal|"Sorry, can not handle RGB image with %s=%d"
argument_list|,
literal|"Color channels"
argument_list|,
name|colorchannels
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
case|case
name|PHOTOMETRIC_SEPARATED
case|:
block|{
name|uint16
name|inkset
decl_stmt|;
name|TIFFGetFieldDefaulted
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_INKSET
argument_list|,
operator|&
name|inkset
argument_list|)
expr_stmt|;
if|if
condition|(
name|inkset
operator|!=
name|INKSET_CMYK
condition|)
block|{
name|sprintf
argument_list|(
name|emsg
argument_list|,
literal|"Sorry, can not handle separated image with %s=%d"
argument_list|,
literal|"InkSet"
argument_list|,
name|inkset
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|td
operator|->
name|td_samplesperpixel
operator|<
literal|4
condition|)
block|{
name|sprintf
argument_list|(
name|emsg
argument_list|,
literal|"Sorry, can not handle separated image with %s=%d"
argument_list|,
literal|"Samples/pixel"
argument_list|,
name|td
operator|->
name|td_samplesperpixel
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
block|}
case|case
name|PHOTOMETRIC_LOGL
case|:
if|if
condition|(
name|td
operator|->
name|td_compression
operator|!=
name|COMPRESSION_SGILOG
condition|)
block|{
name|sprintf
argument_list|(
name|emsg
argument_list|,
literal|"Sorry, LogL data must have %s=%d"
argument_list|,
literal|"Compression"
argument_list|,
name|COMPRESSION_SGILOG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
case|case
name|PHOTOMETRIC_LOGLUV
case|:
if|if
condition|(
name|td
operator|->
name|td_compression
operator|!=
name|COMPRESSION_SGILOG
operator|&&
name|td
operator|->
name|td_compression
operator|!=
name|COMPRESSION_SGILOG24
condition|)
block|{
name|sprintf
argument_list|(
name|emsg
argument_list|,
literal|"Sorry, LogLuv data must have %s=%d or %d"
argument_list|,
literal|"Compression"
argument_list|,
name|COMPRESSION_SGILOG
argument_list|,
name|COMPRESSION_SGILOG24
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|td
operator|->
name|td_planarconfig
operator|!=
name|PLANARCONFIG_CONTIG
condition|)
block|{
name|sprintf
argument_list|(
name|emsg
argument_list|,
literal|"Sorry, can not handle LogLuv images with %s=%d"
argument_list|,
literal|"Planarconfiguration"
argument_list|,
name|td
operator|->
name|td_planarconfig
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
case|case
name|PHOTOMETRIC_CIELAB
case|:
break|break;
default|default:
name|sprintf
argument_list|(
name|emsg
argument_list|,
literal|"Sorry, can not handle image with %s=%d"
argument_list|,
name|photoTag
argument_list|,
name|photometric
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_function
name|void
DECL|function|TIFFRGBAImageEnd
name|TIFFRGBAImageEnd
parameter_list|(
name|TIFFRGBAImage
modifier|*
name|img
parameter_list|)
block|{
if|if
condition|(
name|img
operator|->
name|Map
condition|)
name|_TIFFfree
argument_list|(
name|img
operator|->
name|Map
argument_list|)
operator|,
name|img
operator|->
name|Map
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|img
operator|->
name|BWmap
condition|)
name|_TIFFfree
argument_list|(
name|img
operator|->
name|BWmap
argument_list|)
operator|,
name|img
operator|->
name|BWmap
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|img
operator|->
name|PALmap
condition|)
name|_TIFFfree
argument_list|(
name|img
operator|->
name|PALmap
argument_list|)
operator|,
name|img
operator|->
name|PALmap
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|img
operator|->
name|ycbcr
condition|)
name|_TIFFfree
argument_list|(
name|img
operator|->
name|ycbcr
argument_list|)
operator|,
name|img
operator|->
name|ycbcr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|img
operator|->
name|cielab
condition|)
name|_TIFFfree
argument_list|(
name|img
operator|->
name|cielab
argument_list|)
operator|,
name|img
operator|->
name|cielab
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|img
operator|->
name|redcmap
condition|)
block|{
name|_TIFFfree
argument_list|(
name|img
operator|->
name|redcmap
argument_list|)
expr_stmt|;
name|_TIFFfree
argument_list|(
name|img
operator|->
name|greencmap
argument_list|)
expr_stmt|;
name|_TIFFfree
argument_list|(
name|img
operator|->
name|bluecmap
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|isCCITTCompression
name|isCCITTCompression
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|uint16
name|compress
decl_stmt|;
name|TIFFGetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_COMPRESSION
argument_list|,
operator|&
name|compress
argument_list|)
expr_stmt|;
return|return
operator|(
name|compress
operator|==
name|COMPRESSION_CCITTFAX3
operator|||
name|compress
operator|==
name|COMPRESSION_CCITTFAX4
operator|||
name|compress
operator|==
name|COMPRESSION_CCITTRLE
operator|||
name|compress
operator|==
name|COMPRESSION_CCITTRLEW
operator|)
return|;
block|}
end_function
begin_function
name|int
DECL|function|TIFFRGBAImageBegin
name|TIFFRGBAImageBegin
parameter_list|(
name|TIFFRGBAImage
modifier|*
name|img
parameter_list|,
name|TIFF
modifier|*
name|tif
parameter_list|,
name|int
name|stop
parameter_list|,
name|char
name|emsg
index|[
literal|1024
index|]
parameter_list|)
block|{
name|uint16
modifier|*
name|sampleinfo
decl_stmt|;
name|uint16
name|extrasamples
decl_stmt|;
name|uint16
name|planarconfig
decl_stmt|;
name|uint16
name|compress
decl_stmt|;
name|int
name|colorchannels
decl_stmt|;
name|uint16
modifier|*
name|red_orig
decl_stmt|,
modifier|*
name|green_orig
decl_stmt|,
modifier|*
name|blue_orig
decl_stmt|;
name|int
name|n_color
decl_stmt|;
comment|/* Initialize to normal values */
name|img
operator|->
name|row_offset
operator|=
literal|0
expr_stmt|;
name|img
operator|->
name|col_offset
operator|=
literal|0
expr_stmt|;
name|img
operator|->
name|redcmap
operator|=
name|NULL
expr_stmt|;
name|img
operator|->
name|greencmap
operator|=
name|NULL
expr_stmt|;
name|img
operator|->
name|bluecmap
operator|=
name|NULL
expr_stmt|;
name|img
operator|->
name|req_orientation
operator|=
name|ORIENTATION_BOTLEFT
expr_stmt|;
comment|/* It is the default */
name|img
operator|->
name|tif
operator|=
name|tif
expr_stmt|;
name|img
operator|->
name|stoponerr
operator|=
name|stop
expr_stmt|;
name|TIFFGetFieldDefaulted
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_BITSPERSAMPLE
argument_list|,
operator|&
name|img
operator|->
name|bitspersample
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|img
operator|->
name|bitspersample
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|4
case|:
case|case
literal|8
case|:
case|case
literal|16
case|:
break|break;
default|default:
name|sprintf
argument_list|(
name|emsg
argument_list|,
literal|"Sorry, can not handle images with %d-bit samples"
argument_list|,
name|img
operator|->
name|bitspersample
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|img
operator|->
name|alpha
operator|=
literal|0
expr_stmt|;
name|TIFFGetFieldDefaulted
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_SAMPLESPERPIXEL
argument_list|,
operator|&
name|img
operator|->
name|samplesperpixel
argument_list|)
expr_stmt|;
name|TIFFGetFieldDefaulted
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_EXTRASAMPLES
argument_list|,
operator|&
name|extrasamples
argument_list|,
operator|&
name|sampleinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|extrasamples
operator|>=
literal|1
condition|)
block|{
switch|switch
condition|(
name|sampleinfo
index|[
literal|0
index|]
condition|)
block|{
case|case
name|EXTRASAMPLE_UNSPECIFIED
case|:
comment|/* Workaround for some images without */
if|if
condition|(
name|img
operator|->
name|samplesperpixel
operator|>
literal|3
condition|)
comment|/* correct info about alpha channel */
name|img
operator|->
name|alpha
operator|=
name|EXTRASAMPLE_ASSOCALPHA
expr_stmt|;
break|break;
case|case
name|EXTRASAMPLE_ASSOCALPHA
case|:
comment|/* data is pre-multiplied */
case|case
name|EXTRASAMPLE_UNASSALPHA
case|:
comment|/* data is not pre-multiplied */
name|img
operator|->
name|alpha
operator|=
name|sampleinfo
index|[
literal|0
index|]
expr_stmt|;
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|DEFAULT_EXTRASAMPLE_AS_ALPHA
if|if
condition|(
operator|!
name|TIFFGetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_PHOTOMETRIC
argument_list|,
operator|&
name|img
operator|->
name|photometric
argument_list|)
condition|)
name|img
operator|->
name|photometric
operator|=
name|PHOTOMETRIC_MINISWHITE
expr_stmt|;
if|if
condition|(
name|extrasamples
operator|==
literal|0
operator|&&
name|img
operator|->
name|samplesperpixel
operator|==
literal|4
operator|&&
name|img
operator|->
name|photometric
operator|==
name|PHOTOMETRIC_RGB
condition|)
block|{
name|img
operator|->
name|alpha
operator|=
name|EXTRASAMPLE_ASSOCALPHA
expr_stmt|;
name|extrasamples
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
name|colorchannels
operator|=
name|img
operator|->
name|samplesperpixel
operator|-
name|extrasamples
expr_stmt|;
name|TIFFGetFieldDefaulted
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_COMPRESSION
argument_list|,
operator|&
name|compress
argument_list|)
expr_stmt|;
name|TIFFGetFieldDefaulted
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_PLANARCONFIG
argument_list|,
operator|&
name|planarconfig
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TIFFGetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_PHOTOMETRIC
argument_list|,
operator|&
name|img
operator|->
name|photometric
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|colorchannels
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|isCCITTCompression
argument_list|(
name|tif
argument_list|)
condition|)
name|img
operator|->
name|photometric
operator|=
name|PHOTOMETRIC_MINISWHITE
expr_stmt|;
else|else
name|img
operator|->
name|photometric
operator|=
name|PHOTOMETRIC_MINISBLACK
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|img
operator|->
name|photometric
operator|=
name|PHOTOMETRIC_RGB
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|emsg
argument_list|,
literal|"Missing needed %s tag"
argument_list|,
name|photoTag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
switch|switch
condition|(
name|img
operator|->
name|photometric
condition|)
block|{
case|case
name|PHOTOMETRIC_PALETTE
case|:
if|if
condition|(
operator|!
name|TIFFGetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_COLORMAP
argument_list|,
operator|&
name|red_orig
argument_list|,
operator|&
name|green_orig
argument_list|,
operator|&
name|blue_orig
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|emsg
argument_list|,
literal|"Missing required \"Colormap\" tag"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* copy the colormaps so we can modify them */
name|n_color
operator|=
operator|(
literal|1L
operator|<<
name|img
operator|->
name|bitspersample
operator|)
expr_stmt|;
name|img
operator|->
name|redcmap
operator|=
operator|(
name|uint16
operator|*
operator|)
name|_TIFFmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
operator|*
name|n_color
argument_list|)
expr_stmt|;
name|img
operator|->
name|greencmap
operator|=
operator|(
name|uint16
operator|*
operator|)
name|_TIFFmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
operator|*
name|n_color
argument_list|)
expr_stmt|;
name|img
operator|->
name|bluecmap
operator|=
operator|(
name|uint16
operator|*
operator|)
name|_TIFFmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
operator|*
name|n_color
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|img
operator|->
name|redcmap
operator|||
operator|!
name|img
operator|->
name|greencmap
operator|||
operator|!
name|img
operator|->
name|bluecmap
condition|)
block|{
name|sprintf
argument_list|(
name|emsg
argument_list|,
literal|"Out of memory for colormap copy"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|_TIFFmemcpy
argument_list|(
name|img
operator|->
name|redcmap
argument_list|,
name|red_orig
argument_list|,
name|n_color
operator|*
literal|2
argument_list|)
expr_stmt|;
name|_TIFFmemcpy
argument_list|(
name|img
operator|->
name|greencmap
argument_list|,
name|green_orig
argument_list|,
name|n_color
operator|*
literal|2
argument_list|)
expr_stmt|;
name|_TIFFmemcpy
argument_list|(
name|img
operator|->
name|bluecmap
argument_list|,
name|blue_orig
argument_list|,
name|n_color
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* fall thru... */
case|case
name|PHOTOMETRIC_MINISWHITE
case|:
case|case
name|PHOTOMETRIC_MINISBLACK
case|:
if|if
condition|(
name|planarconfig
operator|==
name|PLANARCONFIG_CONTIG
operator|&&
name|img
operator|->
name|samplesperpixel
operator|!=
literal|1
operator|&&
name|img
operator|->
name|bitspersample
operator|<
literal|8
condition|)
block|{
name|sprintf
argument_list|(
name|emsg
argument_list|,
literal|"Sorry, can not handle contiguous data with %s=%d, "
literal|"and %s=%d and Bits/Sample=%d"
argument_list|,
name|photoTag
argument_list|,
name|img
operator|->
name|photometric
argument_list|,
literal|"Samples/pixel"
argument_list|,
name|img
operator|->
name|samplesperpixel
argument_list|,
name|img
operator|->
name|bitspersample
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
case|case
name|PHOTOMETRIC_YCBCR
case|:
comment|/* It would probably be nice to have a reality check here. */
if|if
condition|(
name|planarconfig
operator|==
name|PLANARCONFIG_CONTIG
condition|)
comment|/* can rely on libjpeg to convert to RGB */
comment|/* XXX should restore current state on exit */
switch|switch
condition|(
name|compress
condition|)
block|{
case|case
name|COMPRESSION_JPEG
case|:
comment|/* 						 * TODO: when complete tests verify complete desubsampling 						 * and YCbCr handling, remove use of TIFFTAG_JPEGCOLORMODE in 						 * favor of tif_getimage.c native handling 						 */
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_JPEGCOLORMODE
argument_list|,
name|JPEGCOLORMODE_RGB
argument_list|)
expr_stmt|;
name|img
operator|->
name|photometric
operator|=
name|PHOTOMETRIC_RGB
expr_stmt|;
break|break;
default|default:
comment|/* do nothing */
empty_stmt|;
break|break;
block|}
comment|/* 			 * TODO: if at all meaningful and useful, make more complete 			 * support check here, or better still, refactor to let supporting 			 * code decide whether there is support and what meaningfull 			 * error to return 			 */
break|break;
case|case
name|PHOTOMETRIC_RGB
case|:
if|if
condition|(
name|colorchannels
operator|<
literal|3
condition|)
block|{
name|sprintf
argument_list|(
name|emsg
argument_list|,
literal|"Sorry, can not handle RGB image with %s=%d"
argument_list|,
literal|"Color channels"
argument_list|,
name|colorchannels
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
case|case
name|PHOTOMETRIC_SEPARATED
case|:
block|{
name|uint16
name|inkset
decl_stmt|;
name|TIFFGetFieldDefaulted
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_INKSET
argument_list|,
operator|&
name|inkset
argument_list|)
expr_stmt|;
if|if
condition|(
name|inkset
operator|!=
name|INKSET_CMYK
condition|)
block|{
name|sprintf
argument_list|(
name|emsg
argument_list|,
literal|"Sorry, can not handle separated image with %s=%d"
argument_list|,
literal|"InkSet"
argument_list|,
name|inkset
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|img
operator|->
name|samplesperpixel
operator|<
literal|4
condition|)
block|{
name|sprintf
argument_list|(
name|emsg
argument_list|,
literal|"Sorry, can not handle separated image with %s=%d"
argument_list|,
literal|"Samples/pixel"
argument_list|,
name|img
operator|->
name|samplesperpixel
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
break|break;
case|case
name|PHOTOMETRIC_LOGL
case|:
if|if
condition|(
name|compress
operator|!=
name|COMPRESSION_SGILOG
condition|)
block|{
name|sprintf
argument_list|(
name|emsg
argument_list|,
literal|"Sorry, LogL data must have %s=%d"
argument_list|,
literal|"Compression"
argument_list|,
name|COMPRESSION_SGILOG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_SGILOGDATAFMT
argument_list|,
name|SGILOGDATAFMT_8BIT
argument_list|)
expr_stmt|;
name|img
operator|->
name|photometric
operator|=
name|PHOTOMETRIC_MINISBLACK
expr_stmt|;
comment|/* little white lie */
name|img
operator|->
name|bitspersample
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|PHOTOMETRIC_LOGLUV
case|:
if|if
condition|(
name|compress
operator|!=
name|COMPRESSION_SGILOG
operator|&&
name|compress
operator|!=
name|COMPRESSION_SGILOG24
condition|)
block|{
name|sprintf
argument_list|(
name|emsg
argument_list|,
literal|"Sorry, LogLuv data must have %s=%d or %d"
argument_list|,
literal|"Compression"
argument_list|,
name|COMPRESSION_SGILOG
argument_list|,
name|COMPRESSION_SGILOG24
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|planarconfig
operator|!=
name|PLANARCONFIG_CONTIG
condition|)
block|{
name|sprintf
argument_list|(
name|emsg
argument_list|,
literal|"Sorry, can not handle LogLuv images with %s=%d"
argument_list|,
literal|"Planarconfiguration"
argument_list|,
name|planarconfig
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_SGILOGDATAFMT
argument_list|,
name|SGILOGDATAFMT_8BIT
argument_list|)
expr_stmt|;
name|img
operator|->
name|photometric
operator|=
name|PHOTOMETRIC_RGB
expr_stmt|;
comment|/* little white lie */
name|img
operator|->
name|bitspersample
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|PHOTOMETRIC_CIELAB
case|:
break|break;
default|default:
name|sprintf
argument_list|(
name|emsg
argument_list|,
literal|"Sorry, can not handle image with %s=%d"
argument_list|,
name|photoTag
argument_list|,
name|img
operator|->
name|photometric
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|img
operator|->
name|Map
operator|=
name|NULL
expr_stmt|;
name|img
operator|->
name|BWmap
operator|=
name|NULL
expr_stmt|;
name|img
operator|->
name|PALmap
operator|=
name|NULL
expr_stmt|;
name|img
operator|->
name|ycbcr
operator|=
name|NULL
expr_stmt|;
name|img
operator|->
name|cielab
operator|=
name|NULL
expr_stmt|;
name|TIFFGetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_IMAGEWIDTH
argument_list|,
operator|&
name|img
operator|->
name|width
argument_list|)
expr_stmt|;
name|TIFFGetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_IMAGELENGTH
argument_list|,
operator|&
name|img
operator|->
name|height
argument_list|)
expr_stmt|;
name|TIFFGetFieldDefaulted
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_ORIENTATION
argument_list|,
operator|&
name|img
operator|->
name|orientation
argument_list|)
expr_stmt|;
name|img
operator|->
name|isContig
operator|=
operator|!
operator|(
name|planarconfig
operator|==
name|PLANARCONFIG_SEPARATE
operator|&&
name|colorchannels
operator|>
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|img
operator|->
name|isContig
condition|)
block|{
if|if
condition|(
operator|!
name|PickContigCase
argument_list|(
name|img
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|emsg
argument_list|,
literal|"Sorry, can not handle image"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|PickSeparateCase
argument_list|(
name|img
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|emsg
argument_list|,
literal|"Sorry, can not handle image"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function
begin_function
name|int
DECL|function|TIFFRGBAImageGet
name|TIFFRGBAImageGet
parameter_list|(
name|TIFFRGBAImage
modifier|*
name|img
parameter_list|,
name|uint32
modifier|*
name|raster
parameter_list|,
name|uint32
name|w
parameter_list|,
name|uint32
name|h
parameter_list|)
block|{
if|if
condition|(
name|img
operator|->
name|get
operator|==
name|NULL
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|img
operator|->
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|TIFFFileName
argument_list|(
name|img
operator|->
name|tif
argument_list|)
argument_list|,
literal|"No \"get\" routine setup"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|img
operator|->
name|put
operator|.
name|any
operator|==
name|NULL
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|img
operator|->
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|TIFFFileName
argument_list|(
name|img
operator|->
name|tif
argument_list|)
argument_list|,
literal|"No \"put\" routine setupl; probably can not handle image format"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
call|(
modifier|*
name|img
operator|->
name|get
call|)
argument_list|(
name|img
argument_list|,
name|raster
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * Read the specified image into an ABGR-format rastertaking in account  * specified orientation.  */
end_comment
begin_function
name|int
DECL|function|TIFFReadRGBAImageOriented
name|TIFFReadRGBAImageOriented
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|uint32
name|rwidth
parameter_list|,
name|uint32
name|rheight
parameter_list|,
name|uint32
modifier|*
name|raster
parameter_list|,
name|int
name|orientation
parameter_list|,
name|int
name|stop
parameter_list|)
block|{
name|char
name|emsg
index|[
literal|1024
index|]
init|=
literal|""
decl_stmt|;
name|TIFFRGBAImage
name|img
decl_stmt|;
name|int
name|ok
decl_stmt|;
if|if
condition|(
name|TIFFRGBAImageOK
argument_list|(
name|tif
argument_list|,
name|emsg
argument_list|)
operator|&&
name|TIFFRGBAImageBegin
argument_list|(
operator|&
name|img
argument_list|,
name|tif
argument_list|,
name|stop
argument_list|,
name|emsg
argument_list|)
condition|)
block|{
name|img
operator|.
name|req_orientation
operator|=
name|orientation
expr_stmt|;
comment|/* XXX verify rwidth and rheight against width and height */
name|ok
operator|=
name|TIFFRGBAImageGet
argument_list|(
operator|&
name|img
argument_list|,
name|raster
operator|+
operator|(
name|rheight
operator|-
name|img
operator|.
name|height
operator|)
operator|*
name|rwidth
argument_list|,
name|rwidth
argument_list|,
name|img
operator|.
name|height
argument_list|)
expr_stmt|;
name|TIFFRGBAImageEnd
argument_list|(
operator|&
name|img
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|TIFFFileName
argument_list|(
name|tif
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|emsg
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|ok
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Read the specified image into an ABGR-format raster. Use bottom left  * origin for raster by default.  */
end_comment
begin_function
name|int
DECL|function|TIFFReadRGBAImage
name|TIFFReadRGBAImage
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|uint32
name|rwidth
parameter_list|,
name|uint32
name|rheight
parameter_list|,
name|uint32
modifier|*
name|raster
parameter_list|,
name|int
name|stop
parameter_list|)
block|{
return|return
name|TIFFReadRGBAImageOriented
argument_list|(
name|tif
argument_list|,
name|rwidth
argument_list|,
name|rheight
argument_list|,
name|raster
argument_list|,
name|ORIENTATION_BOTLEFT
argument_list|,
name|stop
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|setorientation
name|setorientation
parameter_list|(
name|TIFFRGBAImage
modifier|*
name|img
parameter_list|)
block|{
switch|switch
condition|(
name|img
operator|->
name|orientation
condition|)
block|{
case|case
name|ORIENTATION_TOPLEFT
case|:
case|case
name|ORIENTATION_LEFTTOP
case|:
if|if
condition|(
name|img
operator|->
name|req_orientation
operator|==
name|ORIENTATION_TOPRIGHT
operator|||
name|img
operator|->
name|req_orientation
operator|==
name|ORIENTATION_RIGHTTOP
condition|)
return|return
name|FLIP_HORIZONTALLY
return|;
elseif|else
if|if
condition|(
name|img
operator|->
name|req_orientation
operator|==
name|ORIENTATION_BOTRIGHT
operator|||
name|img
operator|->
name|req_orientation
operator|==
name|ORIENTATION_RIGHTBOT
condition|)
return|return
name|FLIP_HORIZONTALLY
operator||
name|FLIP_VERTICALLY
return|;
elseif|else
if|if
condition|(
name|img
operator|->
name|req_orientation
operator|==
name|ORIENTATION_BOTLEFT
operator|||
name|img
operator|->
name|req_orientation
operator|==
name|ORIENTATION_LEFTBOT
condition|)
return|return
name|FLIP_VERTICALLY
return|;
else|else
return|return
literal|0
return|;
case|case
name|ORIENTATION_TOPRIGHT
case|:
case|case
name|ORIENTATION_RIGHTTOP
case|:
if|if
condition|(
name|img
operator|->
name|req_orientation
operator|==
name|ORIENTATION_TOPLEFT
operator|||
name|img
operator|->
name|req_orientation
operator|==
name|ORIENTATION_LEFTTOP
condition|)
return|return
name|FLIP_HORIZONTALLY
return|;
elseif|else
if|if
condition|(
name|img
operator|->
name|req_orientation
operator|==
name|ORIENTATION_BOTRIGHT
operator|||
name|img
operator|->
name|req_orientation
operator|==
name|ORIENTATION_RIGHTBOT
condition|)
return|return
name|FLIP_VERTICALLY
return|;
elseif|else
if|if
condition|(
name|img
operator|->
name|req_orientation
operator|==
name|ORIENTATION_BOTLEFT
operator|||
name|img
operator|->
name|req_orientation
operator|==
name|ORIENTATION_LEFTBOT
condition|)
return|return
name|FLIP_HORIZONTALLY
operator||
name|FLIP_VERTICALLY
return|;
else|else
return|return
literal|0
return|;
case|case
name|ORIENTATION_BOTRIGHT
case|:
case|case
name|ORIENTATION_RIGHTBOT
case|:
if|if
condition|(
name|img
operator|->
name|req_orientation
operator|==
name|ORIENTATION_TOPLEFT
operator|||
name|img
operator|->
name|req_orientation
operator|==
name|ORIENTATION_LEFTTOP
condition|)
return|return
name|FLIP_HORIZONTALLY
operator||
name|FLIP_VERTICALLY
return|;
elseif|else
if|if
condition|(
name|img
operator|->
name|req_orientation
operator|==
name|ORIENTATION_TOPRIGHT
operator|||
name|img
operator|->
name|req_orientation
operator|==
name|ORIENTATION_RIGHTTOP
condition|)
return|return
name|FLIP_VERTICALLY
return|;
elseif|else
if|if
condition|(
name|img
operator|->
name|req_orientation
operator|==
name|ORIENTATION_BOTLEFT
operator|||
name|img
operator|->
name|req_orientation
operator|==
name|ORIENTATION_LEFTBOT
condition|)
return|return
name|FLIP_HORIZONTALLY
return|;
else|else
return|return
literal|0
return|;
case|case
name|ORIENTATION_BOTLEFT
case|:
case|case
name|ORIENTATION_LEFTBOT
case|:
if|if
condition|(
name|img
operator|->
name|req_orientation
operator|==
name|ORIENTATION_TOPLEFT
operator|||
name|img
operator|->
name|req_orientation
operator|==
name|ORIENTATION_LEFTTOP
condition|)
return|return
name|FLIP_VERTICALLY
return|;
elseif|else
if|if
condition|(
name|img
operator|->
name|req_orientation
operator|==
name|ORIENTATION_TOPRIGHT
operator|||
name|img
operator|->
name|req_orientation
operator|==
name|ORIENTATION_RIGHTTOP
condition|)
return|return
name|FLIP_HORIZONTALLY
operator||
name|FLIP_VERTICALLY
return|;
elseif|else
if|if
condition|(
name|img
operator|->
name|req_orientation
operator|==
name|ORIENTATION_BOTRIGHT
operator|||
name|img
operator|->
name|req_orientation
operator|==
name|ORIENTATION_RIGHTBOT
condition|)
return|return
name|FLIP_HORIZONTALLY
return|;
else|else
return|return
literal|0
return|;
default|default:
comment|/* NOTREACHED */
return|return
literal|0
return|;
block|}
block|}
end_function
begin_comment
comment|/*  * Get an tile-organized image that has  *	PlanarConfiguration contiguous if SamplesPerPixel> 1  * or  *	SamplesPerPixel == 1  */
end_comment
begin_function
specifier|static
name|int
DECL|function|gtTileContig
name|gtTileContig
parameter_list|(
name|TIFFRGBAImage
modifier|*
name|img
parameter_list|,
name|uint32
modifier|*
name|raster
parameter_list|,
name|uint32
name|w
parameter_list|,
name|uint32
name|h
parameter_list|)
block|{
name|TIFF
modifier|*
name|tif
init|=
name|img
operator|->
name|tif
decl_stmt|;
name|tileContigRoutine
name|put
init|=
name|img
operator|->
name|put
operator|.
name|contig
decl_stmt|;
name|uint32
name|col
decl_stmt|,
name|row
decl_stmt|,
name|y
decl_stmt|,
name|rowstoread
decl_stmt|;
name|uint32
name|pos
decl_stmt|;
name|uint32
name|tw
decl_stmt|,
name|th
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|int32
name|fromskew
decl_stmt|,
name|toskew
decl_stmt|;
name|uint32
name|nrow
decl_stmt|;
name|int
name|ret
init|=
literal|1
decl_stmt|,
name|flip
decl_stmt|;
name|buf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|_TIFFmalloc
argument_list|(
name|TIFFTileSize
argument_list|(
name|tif
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
literal|0
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|TIFFFileName
argument_list|(
name|tif
argument_list|)
argument_list|,
literal|"No space for tile buffer"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|_TIFFmemset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|TIFFTileSize
argument_list|(
name|tif
argument_list|)
argument_list|)
expr_stmt|;
name|TIFFGetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_TILEWIDTH
argument_list|,
operator|&
name|tw
argument_list|)
expr_stmt|;
name|TIFFGetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_TILELENGTH
argument_list|,
operator|&
name|th
argument_list|)
expr_stmt|;
name|flip
operator|=
name|setorientation
argument_list|(
name|img
argument_list|)
expr_stmt|;
if|if
condition|(
name|flip
operator|&
name|FLIP_VERTICALLY
condition|)
block|{
name|y
operator|=
name|h
operator|-
literal|1
expr_stmt|;
name|toskew
operator|=
operator|-
call|(
name|int32
call|)
argument_list|(
name|tw
operator|+
name|w
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|y
operator|=
literal|0
expr_stmt|;
name|toskew
operator|=
operator|-
call|(
name|int32
call|)
argument_list|(
name|tw
operator|-
name|w
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|h
condition|;
name|row
operator|+=
name|nrow
control|)
block|{
name|rowstoread
operator|=
name|th
operator|-
operator|(
name|row
operator|+
name|img
operator|->
name|row_offset
operator|)
operator|%
name|th
expr_stmt|;
name|nrow
operator|=
operator|(
name|row
operator|+
name|rowstoread
operator|>
name|h
condition|?
name|h
operator|-
name|row
else|:
name|rowstoread
operator|)
expr_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|w
condition|;
name|col
operator|+=
name|tw
control|)
block|{
if|if
condition|(
name|TIFFReadTile
argument_list|(
name|tif
argument_list|,
name|buf
argument_list|,
name|col
operator|+
name|img
operator|->
name|col_offset
argument_list|,
name|row
operator|+
name|img
operator|->
name|row_offset
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
operator|&&
name|img
operator|->
name|stoponerr
condition|)
block|{
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|pos
operator|=
operator|(
operator|(
name|row
operator|+
name|img
operator|->
name|row_offset
operator|)
operator|%
name|th
operator|)
operator|*
name|TIFFTileRowSize
argument_list|(
name|tif
argument_list|)
expr_stmt|;
if|if
condition|(
name|col
operator|+
name|tw
operator|>
name|w
condition|)
block|{
comment|/*                  * Tile is clipped horizontally.  Calculate                  * visible portion and skewing factors.                  */
name|uint32
name|npix
init|=
name|w
operator|-
name|col
decl_stmt|;
name|fromskew
operator|=
name|tw
operator|-
name|npix
expr_stmt|;
call|(
modifier|*
name|put
call|)
argument_list|(
name|img
argument_list|,
name|raster
operator|+
name|y
operator|*
name|w
operator|+
name|col
argument_list|,
name|col
argument_list|,
name|y
argument_list|,
name|npix
argument_list|,
name|nrow
argument_list|,
name|fromskew
argument_list|,
name|toskew
operator|+
name|fromskew
argument_list|,
name|buf
operator|+
name|pos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
call|(
modifier|*
name|put
call|)
argument_list|(
name|img
argument_list|,
name|raster
operator|+
name|y
operator|*
name|w
operator|+
name|col
argument_list|,
name|col
argument_list|,
name|y
argument_list|,
name|tw
argument_list|,
name|nrow
argument_list|,
literal|0
argument_list|,
name|toskew
argument_list|,
name|buf
operator|+
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
name|y
operator|+=
operator|(
name|flip
operator|&
name|FLIP_VERTICALLY
condition|?
operator|-
operator|(
name|int32
operator|)
name|nrow
else|:
operator|(
name|int32
operator|)
name|nrow
operator|)
expr_stmt|;
block|}
name|_TIFFfree
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|flip
operator|&
name|FLIP_HORIZONTALLY
condition|)
block|{
name|uint32
name|line
decl_stmt|;
for|for
control|(
name|line
operator|=
literal|0
init|;
name|line
operator|<
name|h
condition|;
name|line
operator|++
control|)
block|{
name|uint32
modifier|*
name|left
init|=
name|raster
operator|+
operator|(
name|line
operator|*
name|w
operator|)
decl_stmt|;
name|uint32
modifier|*
name|right
init|=
name|left
operator|+
name|w
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|left
operator|<
name|right
condition|)
block|{
name|uint32
name|temp
init|=
operator|*
name|left
decl_stmt|;
operator|*
name|left
operator|=
operator|*
name|right
expr_stmt|;
operator|*
name|right
operator|=
name|temp
expr_stmt|;
name|left
operator|++
operator|,
name|right
operator|--
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Get an tile-organized image that has  *	 SamplesPerPixel> 1  *	 PlanarConfiguration separated  * We assume that all such images are RGB.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|gtTileSeparate
name|gtTileSeparate
parameter_list|(
name|TIFFRGBAImage
modifier|*
name|img
parameter_list|,
name|uint32
modifier|*
name|raster
parameter_list|,
name|uint32
name|w
parameter_list|,
name|uint32
name|h
parameter_list|)
block|{
name|TIFF
modifier|*
name|tif
init|=
name|img
operator|->
name|tif
decl_stmt|;
name|tileSeparateRoutine
name|put
init|=
name|img
operator|->
name|put
operator|.
name|separate
decl_stmt|;
name|uint32
name|col
decl_stmt|,
name|row
decl_stmt|,
name|y
decl_stmt|,
name|rowstoread
decl_stmt|;
name|uint32
name|pos
decl_stmt|;
name|uint32
name|tw
decl_stmt|,
name|th
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p1
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p2
decl_stmt|;
name|unsigned
name|char
modifier|*
name|pa
decl_stmt|;
name|tsize_t
name|tilesize
decl_stmt|;
name|int32
name|fromskew
decl_stmt|,
name|toskew
decl_stmt|;
name|int
name|alpha
init|=
name|img
operator|->
name|alpha
decl_stmt|;
name|uint32
name|nrow
decl_stmt|;
name|int
name|ret
init|=
literal|1
decl_stmt|,
name|flip
decl_stmt|;
name|tilesize
operator|=
name|TIFFTileSize
argument_list|(
name|tif
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|_TIFFmalloc
argument_list|(
operator|(
name|alpha
condition|?
literal|4
else|:
literal|3
operator|)
operator|*
name|tilesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
literal|0
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|TIFFFileName
argument_list|(
name|tif
argument_list|)
argument_list|,
literal|"No space for tile buffer"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|_TIFFmemset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
operator|(
name|alpha
condition|?
literal|4
else|:
literal|3
operator|)
operator|*
name|tilesize
argument_list|)
expr_stmt|;
name|p0
operator|=
name|buf
expr_stmt|;
name|p1
operator|=
name|p0
operator|+
name|tilesize
expr_stmt|;
name|p2
operator|=
name|p1
operator|+
name|tilesize
expr_stmt|;
name|pa
operator|=
operator|(
name|alpha
condition|?
operator|(
name|p2
operator|+
name|tilesize
operator|)
else|:
name|NULL
operator|)
expr_stmt|;
name|TIFFGetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_TILEWIDTH
argument_list|,
operator|&
name|tw
argument_list|)
expr_stmt|;
name|TIFFGetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_TILELENGTH
argument_list|,
operator|&
name|th
argument_list|)
expr_stmt|;
name|flip
operator|=
name|setorientation
argument_list|(
name|img
argument_list|)
expr_stmt|;
if|if
condition|(
name|flip
operator|&
name|FLIP_VERTICALLY
condition|)
block|{
name|y
operator|=
name|h
operator|-
literal|1
expr_stmt|;
name|toskew
operator|=
operator|-
call|(
name|int32
call|)
argument_list|(
name|tw
operator|+
name|w
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|y
operator|=
literal|0
expr_stmt|;
name|toskew
operator|=
operator|-
call|(
name|int32
call|)
argument_list|(
name|tw
operator|-
name|w
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|h
condition|;
name|row
operator|+=
name|nrow
control|)
block|{
name|rowstoread
operator|=
name|th
operator|-
operator|(
name|row
operator|+
name|img
operator|->
name|row_offset
operator|)
operator|%
name|th
expr_stmt|;
name|nrow
operator|=
operator|(
name|row
operator|+
name|rowstoread
operator|>
name|h
condition|?
name|h
operator|-
name|row
else|:
name|rowstoread
operator|)
expr_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|w
condition|;
name|col
operator|+=
name|tw
control|)
block|{
if|if
condition|(
name|TIFFReadTile
argument_list|(
name|tif
argument_list|,
name|p0
argument_list|,
name|col
operator|+
name|img
operator|->
name|col_offset
argument_list|,
name|row
operator|+
name|img
operator|->
name|row_offset
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
operator|&&
name|img
operator|->
name|stoponerr
condition|)
block|{
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|TIFFReadTile
argument_list|(
name|tif
argument_list|,
name|p1
argument_list|,
name|col
operator|+
name|img
operator|->
name|col_offset
argument_list|,
name|row
operator|+
name|img
operator|->
name|row_offset
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
operator|&&
name|img
operator|->
name|stoponerr
condition|)
block|{
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|TIFFReadTile
argument_list|(
name|tif
argument_list|,
name|p2
argument_list|,
name|col
operator|+
name|img
operator|->
name|col_offset
argument_list|,
name|row
operator|+
name|img
operator|->
name|row_offset
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
operator|<
literal|0
operator|&&
name|img
operator|->
name|stoponerr
condition|)
block|{
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|alpha
condition|)
block|{
if|if
condition|(
name|TIFFReadTile
argument_list|(
name|tif
argument_list|,
name|pa
argument_list|,
name|col
operator|+
name|img
operator|->
name|col_offset
argument_list|,
name|row
operator|+
name|img
operator|->
name|row_offset
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|<
literal|0
operator|&&
name|img
operator|->
name|stoponerr
condition|)
block|{
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|pos
operator|=
operator|(
operator|(
name|row
operator|+
name|img
operator|->
name|row_offset
operator|)
operator|%
name|th
operator|)
operator|*
name|TIFFTileRowSize
argument_list|(
name|tif
argument_list|)
expr_stmt|;
if|if
condition|(
name|col
operator|+
name|tw
operator|>
name|w
condition|)
block|{
comment|/* 				 * Tile is clipped horizontally.  Calculate 				 * visible portion and skewing factors. 				 */
name|uint32
name|npix
init|=
name|w
operator|-
name|col
decl_stmt|;
name|fromskew
operator|=
name|tw
operator|-
name|npix
expr_stmt|;
call|(
modifier|*
name|put
call|)
argument_list|(
name|img
argument_list|,
name|raster
operator|+
name|y
operator|*
name|w
operator|+
name|col
argument_list|,
name|col
argument_list|,
name|y
argument_list|,
name|npix
argument_list|,
name|nrow
argument_list|,
name|fromskew
argument_list|,
name|toskew
operator|+
name|fromskew
argument_list|,
name|p0
operator|+
name|pos
argument_list|,
name|p1
operator|+
name|pos
argument_list|,
name|p2
operator|+
name|pos
argument_list|,
operator|(
name|alpha
condition|?
operator|(
name|pa
operator|+
name|pos
operator|)
else|:
name|NULL
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
call|(
modifier|*
name|put
call|)
argument_list|(
name|img
argument_list|,
name|raster
operator|+
name|y
operator|*
name|w
operator|+
name|col
argument_list|,
name|col
argument_list|,
name|y
argument_list|,
name|tw
argument_list|,
name|nrow
argument_list|,
literal|0
argument_list|,
name|toskew
argument_list|,
name|p0
operator|+
name|pos
argument_list|,
name|p1
operator|+
name|pos
argument_list|,
name|p2
operator|+
name|pos
argument_list|,
operator|(
name|alpha
condition|?
operator|(
name|pa
operator|+
name|pos
operator|)
else|:
name|NULL
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|y
operator|+=
operator|(
name|flip
operator|&
name|FLIP_VERTICALLY
condition|?
operator|-
operator|(
name|int32
operator|)
name|nrow
else|:
operator|(
name|int32
operator|)
name|nrow
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|flip
operator|&
name|FLIP_HORIZONTALLY
condition|)
block|{
name|uint32
name|line
decl_stmt|;
for|for
control|(
name|line
operator|=
literal|0
init|;
name|line
operator|<
name|h
condition|;
name|line
operator|++
control|)
block|{
name|uint32
modifier|*
name|left
init|=
name|raster
operator|+
operator|(
name|line
operator|*
name|w
operator|)
decl_stmt|;
name|uint32
modifier|*
name|right
init|=
name|left
operator|+
name|w
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|left
operator|<
name|right
condition|)
block|{
name|uint32
name|temp
init|=
operator|*
name|left
decl_stmt|;
operator|*
name|left
operator|=
operator|*
name|right
expr_stmt|;
operator|*
name|right
operator|=
name|temp
expr_stmt|;
name|left
operator|++
operator|,
name|right
operator|--
expr_stmt|;
block|}
block|}
block|}
name|_TIFFfree
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Get a strip-organized image that has  *	PlanarConfiguration contiguous if SamplesPerPixel> 1  * or  *	SamplesPerPixel == 1  */
end_comment
begin_function
specifier|static
name|int
DECL|function|gtStripContig
name|gtStripContig
parameter_list|(
name|TIFFRGBAImage
modifier|*
name|img
parameter_list|,
name|uint32
modifier|*
name|raster
parameter_list|,
name|uint32
name|w
parameter_list|,
name|uint32
name|h
parameter_list|)
block|{
name|TIFF
modifier|*
name|tif
init|=
name|img
operator|->
name|tif
decl_stmt|;
name|tileContigRoutine
name|put
init|=
name|img
operator|->
name|put
operator|.
name|contig
decl_stmt|;
name|uint32
name|row
decl_stmt|,
name|y
decl_stmt|,
name|nrow
decl_stmt|,
name|nrowsub
decl_stmt|,
name|rowstoread
decl_stmt|;
name|uint32
name|pos
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|uint32
name|rowsperstrip
decl_stmt|;
name|uint16
name|subsamplinghor
decl_stmt|,
name|subsamplingver
decl_stmt|;
name|uint32
name|imagewidth
init|=
name|img
operator|->
name|width
decl_stmt|;
name|tsize_t
name|scanline
decl_stmt|;
name|int32
name|fromskew
decl_stmt|,
name|toskew
decl_stmt|;
name|int
name|ret
init|=
literal|1
decl_stmt|,
name|flip
decl_stmt|;
name|buf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|_TIFFmalloc
argument_list|(
name|TIFFStripSize
argument_list|(
name|tif
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
literal|0
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|TIFFFileName
argument_list|(
name|tif
argument_list|)
argument_list|,
literal|"No space for strip buffer"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|_TIFFmemset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|TIFFStripSize
argument_list|(
name|tif
argument_list|)
argument_list|)
expr_stmt|;
name|flip
operator|=
name|setorientation
argument_list|(
name|img
argument_list|)
expr_stmt|;
if|if
condition|(
name|flip
operator|&
name|FLIP_VERTICALLY
condition|)
block|{
name|y
operator|=
name|h
operator|-
literal|1
expr_stmt|;
name|toskew
operator|=
operator|-
call|(
name|int32
call|)
argument_list|(
name|w
operator|+
name|w
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|y
operator|=
literal|0
expr_stmt|;
name|toskew
operator|=
operator|-
call|(
name|int32
call|)
argument_list|(
name|w
operator|-
name|w
argument_list|)
expr_stmt|;
block|}
name|TIFFGetFieldDefaulted
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_ROWSPERSTRIP
argument_list|,
operator|&
name|rowsperstrip
argument_list|)
expr_stmt|;
name|TIFFGetFieldDefaulted
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_YCBCRSUBSAMPLING
argument_list|,
operator|&
name|subsamplinghor
argument_list|,
operator|&
name|subsamplingver
argument_list|)
expr_stmt|;
name|scanline
operator|=
name|TIFFNewScanlineSize
argument_list|(
name|tif
argument_list|)
expr_stmt|;
name|fromskew
operator|=
operator|(
name|w
operator|<
name|imagewidth
condition|?
name|imagewidth
operator|-
name|w
else|:
literal|0
operator|)
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|h
condition|;
name|row
operator|+=
name|nrow
control|)
block|{
name|rowstoread
operator|=
name|rowsperstrip
operator|-
operator|(
name|row
operator|+
name|img
operator|->
name|row_offset
operator|)
operator|%
name|rowsperstrip
expr_stmt|;
name|nrow
operator|=
operator|(
name|row
operator|+
name|rowstoread
operator|>
name|h
condition|?
name|h
operator|-
name|row
else|:
name|rowstoread
operator|)
expr_stmt|;
name|nrowsub
operator|=
name|nrow
expr_stmt|;
if|if
condition|(
operator|(
name|nrowsub
operator|%
name|subsamplingver
operator|)
operator|!=
literal|0
condition|)
name|nrowsub
operator|+=
name|subsamplingver
operator|-
name|nrowsub
operator|%
name|subsamplingver
expr_stmt|;
if|if
condition|(
name|TIFFReadEncodedStrip
argument_list|(
name|tif
argument_list|,
name|TIFFComputeStrip
argument_list|(
name|tif
argument_list|,
name|row
operator|+
name|img
operator|->
name|row_offset
argument_list|,
literal|0
argument_list|)
argument_list|,
name|buf
argument_list|,
operator|(
operator|(
name|row
operator|+
name|img
operator|->
name|row_offset
operator|)
operator|%
name|rowsperstrip
operator|+
name|nrowsub
operator|)
operator|*
name|scanline
argument_list|)
operator|<
literal|0
operator|&&
name|img
operator|->
name|stoponerr
condition|)
block|{
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|pos
operator|=
operator|(
operator|(
name|row
operator|+
name|img
operator|->
name|row_offset
operator|)
operator|%
name|rowsperstrip
operator|)
operator|*
name|scanline
expr_stmt|;
call|(
modifier|*
name|put
call|)
argument_list|(
name|img
argument_list|,
name|raster
operator|+
name|y
operator|*
name|w
argument_list|,
literal|0
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|nrow
argument_list|,
name|fromskew
argument_list|,
name|toskew
argument_list|,
name|buf
operator|+
name|pos
argument_list|)
expr_stmt|;
name|y
operator|+=
operator|(
name|flip
operator|&
name|FLIP_VERTICALLY
condition|?
operator|-
operator|(
name|int32
operator|)
name|nrow
else|:
operator|(
name|int32
operator|)
name|nrow
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|flip
operator|&
name|FLIP_HORIZONTALLY
condition|)
block|{
name|uint32
name|line
decl_stmt|;
for|for
control|(
name|line
operator|=
literal|0
init|;
name|line
operator|<
name|h
condition|;
name|line
operator|++
control|)
block|{
name|uint32
modifier|*
name|left
init|=
name|raster
operator|+
operator|(
name|line
operator|*
name|w
operator|)
decl_stmt|;
name|uint32
modifier|*
name|right
init|=
name|left
operator|+
name|w
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|left
operator|<
name|right
condition|)
block|{
name|uint32
name|temp
init|=
operator|*
name|left
decl_stmt|;
operator|*
name|left
operator|=
operator|*
name|right
expr_stmt|;
operator|*
name|right
operator|=
name|temp
expr_stmt|;
name|left
operator|++
operator|,
name|right
operator|--
expr_stmt|;
block|}
block|}
block|}
name|_TIFFfree
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Get a strip-organized image with  *	 SamplesPerPixel> 1  *	 PlanarConfiguration separated  * We assume that all such images are RGB.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|gtStripSeparate
name|gtStripSeparate
parameter_list|(
name|TIFFRGBAImage
modifier|*
name|img
parameter_list|,
name|uint32
modifier|*
name|raster
parameter_list|,
name|uint32
name|w
parameter_list|,
name|uint32
name|h
parameter_list|)
block|{
name|TIFF
modifier|*
name|tif
init|=
name|img
operator|->
name|tif
decl_stmt|;
name|tileSeparateRoutine
name|put
init|=
name|img
operator|->
name|put
operator|.
name|separate
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p0
decl_stmt|,
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
name|pa
decl_stmt|;
name|uint32
name|row
decl_stmt|,
name|y
decl_stmt|,
name|nrow
decl_stmt|,
name|rowstoread
decl_stmt|;
name|uint32
name|pos
decl_stmt|;
name|tsize_t
name|scanline
decl_stmt|;
name|uint32
name|rowsperstrip
decl_stmt|,
name|offset_row
decl_stmt|;
name|uint32
name|imagewidth
init|=
name|img
operator|->
name|width
decl_stmt|;
name|tsize_t
name|stripsize
decl_stmt|;
name|int32
name|fromskew
decl_stmt|,
name|toskew
decl_stmt|;
name|int
name|alpha
init|=
name|img
operator|->
name|alpha
decl_stmt|;
name|int
name|ret
init|=
literal|1
decl_stmt|,
name|flip
decl_stmt|;
name|stripsize
operator|=
name|TIFFStripSize
argument_list|(
name|tif
argument_list|)
expr_stmt|;
name|p0
operator|=
name|buf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|_TIFFmalloc
argument_list|(
operator|(
name|alpha
condition|?
literal|4
else|:
literal|3
operator|)
operator|*
name|stripsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
literal|0
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|TIFFFileName
argument_list|(
name|tif
argument_list|)
argument_list|,
literal|"No space for tile buffer"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|_TIFFmemset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
operator|(
name|alpha
condition|?
literal|4
else|:
literal|3
operator|)
operator|*
name|stripsize
argument_list|)
expr_stmt|;
name|p1
operator|=
name|p0
operator|+
name|stripsize
expr_stmt|;
name|p2
operator|=
name|p1
operator|+
name|stripsize
expr_stmt|;
name|pa
operator|=
operator|(
name|alpha
condition|?
operator|(
name|p2
operator|+
name|stripsize
operator|)
else|:
name|NULL
operator|)
expr_stmt|;
name|flip
operator|=
name|setorientation
argument_list|(
name|img
argument_list|)
expr_stmt|;
if|if
condition|(
name|flip
operator|&
name|FLIP_VERTICALLY
condition|)
block|{
name|y
operator|=
name|h
operator|-
literal|1
expr_stmt|;
name|toskew
operator|=
operator|-
call|(
name|int32
call|)
argument_list|(
name|w
operator|+
name|w
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|y
operator|=
literal|0
expr_stmt|;
name|toskew
operator|=
operator|-
call|(
name|int32
call|)
argument_list|(
name|w
operator|-
name|w
argument_list|)
expr_stmt|;
block|}
name|TIFFGetFieldDefaulted
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_ROWSPERSTRIP
argument_list|,
operator|&
name|rowsperstrip
argument_list|)
expr_stmt|;
name|scanline
operator|=
name|TIFFScanlineSize
argument_list|(
name|tif
argument_list|)
expr_stmt|;
name|fromskew
operator|=
operator|(
name|w
operator|<
name|imagewidth
condition|?
name|imagewidth
operator|-
name|w
else|:
literal|0
operator|)
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|h
condition|;
name|row
operator|+=
name|nrow
control|)
block|{
name|rowstoread
operator|=
name|rowsperstrip
operator|-
operator|(
name|row
operator|+
name|img
operator|->
name|row_offset
operator|)
operator|%
name|rowsperstrip
expr_stmt|;
name|nrow
operator|=
operator|(
name|row
operator|+
name|rowstoread
operator|>
name|h
condition|?
name|h
operator|-
name|row
else|:
name|rowstoread
operator|)
expr_stmt|;
name|offset_row
operator|=
name|row
operator|+
name|img
operator|->
name|row_offset
expr_stmt|;
if|if
condition|(
name|TIFFReadEncodedStrip
argument_list|(
name|tif
argument_list|,
name|TIFFComputeStrip
argument_list|(
name|tif
argument_list|,
name|offset_row
argument_list|,
literal|0
argument_list|)
argument_list|,
name|p0
argument_list|,
operator|(
operator|(
name|row
operator|+
name|img
operator|->
name|row_offset
operator|)
operator|%
name|rowsperstrip
operator|+
name|nrow
operator|)
operator|*
name|scanline
argument_list|)
operator|<
literal|0
operator|&&
name|img
operator|->
name|stoponerr
condition|)
block|{
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|TIFFReadEncodedStrip
argument_list|(
name|tif
argument_list|,
name|TIFFComputeStrip
argument_list|(
name|tif
argument_list|,
name|offset_row
argument_list|,
literal|1
argument_list|)
argument_list|,
name|p1
argument_list|,
operator|(
operator|(
name|row
operator|+
name|img
operator|->
name|row_offset
operator|)
operator|%
name|rowsperstrip
operator|+
name|nrow
operator|)
operator|*
name|scanline
argument_list|)
operator|<
literal|0
operator|&&
name|img
operator|->
name|stoponerr
condition|)
block|{
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|TIFFReadEncodedStrip
argument_list|(
name|tif
argument_list|,
name|TIFFComputeStrip
argument_list|(
name|tif
argument_list|,
name|offset_row
argument_list|,
literal|2
argument_list|)
argument_list|,
name|p2
argument_list|,
operator|(
operator|(
name|row
operator|+
name|img
operator|->
name|row_offset
operator|)
operator|%
name|rowsperstrip
operator|+
name|nrow
operator|)
operator|*
name|scanline
argument_list|)
operator|<
literal|0
operator|&&
name|img
operator|->
name|stoponerr
condition|)
block|{
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|alpha
condition|)
block|{
if|if
condition|(
name|TIFFReadEncodedStrip
argument_list|(
name|tif
argument_list|,
name|TIFFComputeStrip
argument_list|(
name|tif
argument_list|,
name|offset_row
argument_list|,
literal|3
argument_list|)
argument_list|,
name|pa
argument_list|,
operator|(
operator|(
name|row
operator|+
name|img
operator|->
name|row_offset
operator|)
operator|%
name|rowsperstrip
operator|+
name|nrow
operator|)
operator|*
name|scanline
argument_list|)
operator|<
literal|0
operator|&&
name|img
operator|->
name|stoponerr
condition|)
block|{
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|pos
operator|=
operator|(
operator|(
name|row
operator|+
name|img
operator|->
name|row_offset
operator|)
operator|%
name|rowsperstrip
operator|)
operator|*
name|scanline
expr_stmt|;
call|(
modifier|*
name|put
call|)
argument_list|(
name|img
argument_list|,
name|raster
operator|+
name|y
operator|*
name|w
argument_list|,
literal|0
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|nrow
argument_list|,
name|fromskew
argument_list|,
name|toskew
argument_list|,
name|p0
operator|+
name|pos
argument_list|,
name|p1
operator|+
name|pos
argument_list|,
name|p2
operator|+
name|pos
argument_list|,
operator|(
name|alpha
condition|?
operator|(
name|pa
operator|+
name|pos
operator|)
else|:
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|y
operator|+=
operator|(
name|flip
operator|&
name|FLIP_VERTICALLY
condition|?
operator|-
operator|(
name|int32
operator|)
name|nrow
else|:
operator|(
name|int32
operator|)
name|nrow
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|flip
operator|&
name|FLIP_HORIZONTALLY
condition|)
block|{
name|uint32
name|line
decl_stmt|;
for|for
control|(
name|line
operator|=
literal|0
init|;
name|line
operator|<
name|h
condition|;
name|line
operator|++
control|)
block|{
name|uint32
modifier|*
name|left
init|=
name|raster
operator|+
operator|(
name|line
operator|*
name|w
operator|)
decl_stmt|;
name|uint32
modifier|*
name|right
init|=
name|left
operator|+
name|w
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|left
operator|<
name|right
condition|)
block|{
name|uint32
name|temp
init|=
operator|*
name|left
decl_stmt|;
operator|*
name|left
operator|=
operator|*
name|right
expr_stmt|;
operator|*
name|right
operator|=
name|temp
expr_stmt|;
name|left
operator|++
operator|,
name|right
operator|--
expr_stmt|;
block|}
block|}
block|}
name|_TIFFfree
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * The following routines move decoded data returned  * from the TIFF library into rasters filled with packed  * ABGR pixels (i.e. suitable for passing to lrecwrite.)  *  * The routines have been created according to the most  * important cases and optimized.  PickContigCase and  * PickSeparateCase analyze the parameters and select  * the appropriate "get" and "put" routine to use.  */
end_comment
begin_define
DECL|macro|REPEAT8
define|#
directive|define
name|REPEAT8
parameter_list|(
name|op
parameter_list|)
value|REPEAT4(op); REPEAT4(op)
end_define
begin_define
DECL|macro|REPEAT4
define|#
directive|define
name|REPEAT4
parameter_list|(
name|op
parameter_list|)
value|REPEAT2(op); REPEAT2(op)
end_define
begin_define
DECL|macro|REPEAT2
define|#
directive|define
name|REPEAT2
parameter_list|(
name|op
parameter_list|)
value|op; op
end_define
begin_define
DECL|macro|CASE8
define|#
directive|define
name|CASE8
parameter_list|(
name|x
parameter_list|,
name|op
parameter_list|)
define|\
value|switch (x) {			\     case 7: op; case 6: op; case 5: op;	\     case 4: op; case 3: op; case 2: op;	\     case 1: op;				\     }
end_define
begin_define
DECL|macro|CASE4
define|#
directive|define
name|CASE4
parameter_list|(
name|x
parameter_list|,
name|op
parameter_list|)
value|switch (x) { case 3: op; case 2: op; case 1: op; }
end_define
begin_define
DECL|macro|NOP
define|#
directive|define
name|NOP
end_define
begin_define
DECL|macro|UNROLL8
define|#
directive|define
name|UNROLL8
parameter_list|(
name|w
parameter_list|,
name|op1
parameter_list|,
name|op2
parameter_list|)
value|{		\     uint32 _x;				\     for (_x = w; _x>= 8; _x -= 8) {	\ 	op1;				\ 	REPEAT8(op2);			\     }					\     if (_x> 0) {			\ 	op1;				\ 	CASE8(_x,op2);			\     }					\ }
end_define
begin_define
DECL|macro|UNROLL4
define|#
directive|define
name|UNROLL4
parameter_list|(
name|w
parameter_list|,
name|op1
parameter_list|,
name|op2
parameter_list|)
value|{		\     uint32 _x;				\     for (_x = w; _x>= 4; _x -= 4) {	\ 	op1;				\ 	REPEAT4(op2);			\     }					\     if (_x> 0) {			\ 	op1;				\ 	CASE4(_x,op2);			\     }					\ }
end_define
begin_define
DECL|macro|UNROLL2
define|#
directive|define
name|UNROLL2
parameter_list|(
name|w
parameter_list|,
name|op1
parameter_list|,
name|op2
parameter_list|)
value|{		\     uint32 _x;				\     for (_x = w; _x>= 2; _x -= 2) {	\ 	op1;				\ 	REPEAT2(op2);			\     }					\     if (_x) {				\ 	op1;				\ 	op2;				\     }					\ }
end_define
begin_define
DECL|macro|SKEW
define|#
directive|define
name|SKEW
parameter_list|(
name|r
parameter_list|,
name|g
parameter_list|,
name|b
parameter_list|,
name|skew
parameter_list|)
value|{ r += skew; g += skew; b += skew; }
end_define
begin_define
DECL|macro|SKEW4
define|#
directive|define
name|SKEW4
parameter_list|(
name|r
parameter_list|,
name|g
parameter_list|,
name|b
parameter_list|,
name|a
parameter_list|,
name|skew
parameter_list|)
value|{ r += skew; g += skew; b += skew; a+= skew; }
end_define
begin_define
DECL|macro|A1
define|#
directive|define
name|A1
value|(((uint32)0xffL)<<24)
end_define
begin_define
DECL|macro|PACK
define|#
directive|define
name|PACK
parameter_list|(
name|r
parameter_list|,
name|g
parameter_list|,
name|b
parameter_list|)
define|\
value|((uint32)(r)|((uint32)(g)<<8)|((uint32)(b)<<16)|A1)
end_define
begin_define
DECL|macro|PACK4
define|#
directive|define
name|PACK4
parameter_list|(
name|r
parameter_list|,
name|g
parameter_list|,
name|b
parameter_list|,
name|a
parameter_list|)
define|\
value|((uint32)(r)|((uint32)(g)<<8)|((uint32)(b)<<16)|((uint32)(a)<<24))
end_define
begin_define
DECL|macro|W2B
define|#
directive|define
name|W2B
parameter_list|(
name|v
parameter_list|)
value|(((v)>>8)&0xff)
end_define
begin_define
DECL|macro|PACKW
define|#
directive|define
name|PACKW
parameter_list|(
name|r
parameter_list|,
name|g
parameter_list|,
name|b
parameter_list|)
define|\
value|((uint32)W2B(r)|((uint32)W2B(g)<<8)|((uint32)W2B(b)<<16)|A1)
end_define
begin_define
DECL|macro|PACKW4
define|#
directive|define
name|PACKW4
parameter_list|(
name|r
parameter_list|,
name|g
parameter_list|,
name|b
parameter_list|,
name|a
parameter_list|)
define|\
value|((uint32)W2B(r)|((uint32)W2B(g)<<8)|((uint32)W2B(b)<<16)|((uint32)W2B(a)<<24))
end_define
begin_define
DECL|macro|DECLAREContigPutFunc
define|#
directive|define
name|DECLAREContigPutFunc
parameter_list|(
name|name
parameter_list|)
define|\
value|static void name(\     TIFFRGBAImage* img, \     uint32* cp, \     uint32 x, uint32 y, \     uint32 w, uint32 h, \     int32 fromskew, int32 toskew, \     unsigned char* pp \ )
end_define
begin_comment
comment|/*  * 8-bit palette => colormap/RGB  */
end_comment
begin_macro
DECL|function|DECLAREContigPutFunc
name|DECLAREContigPutFunc
argument_list|(
argument|put8bitcmaptile
argument_list|)
end_macro
begin_block
block|{
name|uint32
modifier|*
modifier|*
name|PALmap
init|=
name|img
operator|->
name|PALmap
decl_stmt|;
name|int
name|samplesperpixel
init|=
name|img
operator|->
name|samplesperpixel
decl_stmt|;
operator|(
name|void
operator|)
name|y
expr_stmt|;
while|while
condition|(
name|h
operator|--
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|x
operator|=
name|w
init|;
name|x
operator|--
operator|>
literal|0
condition|;
control|)
block|{
operator|*
name|cp
operator|++
operator|=
name|PALmap
index|[
operator|*
name|pp
index|]
index|[
literal|0
index|]
expr_stmt|;
name|pp
operator|+=
name|samplesperpixel
expr_stmt|;
block|}
name|cp
operator|+=
name|toskew
expr_stmt|;
name|pp
operator|+=
name|fromskew
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * 4-bit palette => colormap/RGB  */
end_comment
begin_macro
DECL|function|DECLAREContigPutFunc
name|DECLAREContigPutFunc
argument_list|(
argument|put4bitcmaptile
argument_list|)
end_macro
begin_block
block|{
name|uint32
modifier|*
modifier|*
name|PALmap
init|=
name|img
operator|->
name|PALmap
decl_stmt|;
operator|(
name|void
operator|)
name|x
expr_stmt|;
operator|(
name|void
operator|)
name|y
expr_stmt|;
name|fromskew
operator|/=
literal|2
expr_stmt|;
while|while
condition|(
name|h
operator|--
operator|>
literal|0
condition|)
block|{
name|uint32
modifier|*
name|bw
decl_stmt|;
name|UNROLL2
argument_list|(
name|w
argument_list|,
name|bw
operator|=
name|PALmap
index|[
operator|*
name|pp
operator|++
index|]
argument_list|,
operator|*
name|cp
operator|++
operator|=
operator|*
name|bw
operator|++
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|toskew
expr_stmt|;
name|pp
operator|+=
name|fromskew
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * 2-bit palette => colormap/RGB  */
end_comment
begin_macro
DECL|function|DECLAREContigPutFunc
name|DECLAREContigPutFunc
argument_list|(
argument|put2bitcmaptile
argument_list|)
end_macro
begin_block
block|{
name|uint32
modifier|*
modifier|*
name|PALmap
init|=
name|img
operator|->
name|PALmap
decl_stmt|;
operator|(
name|void
operator|)
name|x
expr_stmt|;
operator|(
name|void
operator|)
name|y
expr_stmt|;
name|fromskew
operator|/=
literal|4
expr_stmt|;
while|while
condition|(
name|h
operator|--
operator|>
literal|0
condition|)
block|{
name|uint32
modifier|*
name|bw
decl_stmt|;
name|UNROLL4
argument_list|(
name|w
argument_list|,
name|bw
operator|=
name|PALmap
index|[
operator|*
name|pp
operator|++
index|]
argument_list|,
operator|*
name|cp
operator|++
operator|=
operator|*
name|bw
operator|++
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|toskew
expr_stmt|;
name|pp
operator|+=
name|fromskew
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * 1-bit palette => colormap/RGB  */
end_comment
begin_macro
DECL|function|DECLAREContigPutFunc
name|DECLAREContigPutFunc
argument_list|(
argument|put1bitcmaptile
argument_list|)
end_macro
begin_block
block|{
name|uint32
modifier|*
modifier|*
name|PALmap
init|=
name|img
operator|->
name|PALmap
decl_stmt|;
operator|(
name|void
operator|)
name|x
expr_stmt|;
operator|(
name|void
operator|)
name|y
expr_stmt|;
name|fromskew
operator|/=
literal|8
expr_stmt|;
while|while
condition|(
name|h
operator|--
operator|>
literal|0
condition|)
block|{
name|uint32
modifier|*
name|bw
decl_stmt|;
name|UNROLL8
argument_list|(
name|w
argument_list|,
name|bw
operator|=
name|PALmap
index|[
operator|*
name|pp
operator|++
index|]
argument_list|,
operator|*
name|cp
operator|++
operator|=
operator|*
name|bw
operator|++
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|toskew
expr_stmt|;
name|pp
operator|+=
name|fromskew
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * 8-bit greyscale => colormap/RGB  */
end_comment
begin_macro
DECL|function|DECLAREContigPutFunc
name|DECLAREContigPutFunc
argument_list|(
argument|putgreytile
argument_list|)
end_macro
begin_block
block|{
name|int
name|samplesperpixel
init|=
name|img
operator|->
name|samplesperpixel
decl_stmt|;
name|uint32
modifier|*
modifier|*
name|BWmap
init|=
name|img
operator|->
name|BWmap
decl_stmt|;
operator|(
name|void
operator|)
name|y
expr_stmt|;
while|while
condition|(
name|h
operator|--
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|x
operator|=
name|w
init|;
name|x
operator|--
operator|>
literal|0
condition|;
control|)
block|{
operator|*
name|cp
operator|++
operator|=
name|BWmap
index|[
operator|*
name|pp
index|]
index|[
literal|0
index|]
expr_stmt|;
name|pp
operator|+=
name|samplesperpixel
expr_stmt|;
block|}
name|cp
operator|+=
name|toskew
expr_stmt|;
name|pp
operator|+=
name|fromskew
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * 16-bit greyscale => colormap/RGB  */
end_comment
begin_macro
DECL|function|DECLAREContigPutFunc
name|DECLAREContigPutFunc
argument_list|(
argument|put16bitbwtile
argument_list|)
end_macro
begin_block
block|{
name|int
name|samplesperpixel
init|=
name|img
operator|->
name|samplesperpixel
decl_stmt|;
name|uint32
modifier|*
modifier|*
name|BWmap
init|=
name|img
operator|->
name|BWmap
decl_stmt|;
operator|(
name|void
operator|)
name|y
expr_stmt|;
while|while
condition|(
name|h
operator|--
operator|>
literal|0
condition|)
block|{
name|uint16
modifier|*
name|wp
init|=
operator|(
name|uint16
operator|*
operator|)
name|pp
decl_stmt|;
for|for
control|(
name|x
operator|=
name|w
init|;
name|x
operator|--
operator|>
literal|0
condition|;
control|)
block|{
comment|/* use high order byte of 16bit value */
operator|*
name|cp
operator|++
operator|=
name|BWmap
index|[
operator|*
name|wp
operator|>>
literal|8
index|]
index|[
literal|0
index|]
expr_stmt|;
name|pp
operator|+=
literal|2
operator|*
name|samplesperpixel
expr_stmt|;
name|wp
operator|+=
name|samplesperpixel
expr_stmt|;
block|}
name|cp
operator|+=
name|toskew
expr_stmt|;
name|pp
operator|+=
name|fromskew
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * 1-bit bilevel => colormap/RGB  */
end_comment
begin_macro
DECL|function|DECLAREContigPutFunc
name|DECLAREContigPutFunc
argument_list|(
argument|put1bitbwtile
argument_list|)
end_macro
begin_block
block|{
name|uint32
modifier|*
modifier|*
name|BWmap
init|=
name|img
operator|->
name|BWmap
decl_stmt|;
operator|(
name|void
operator|)
name|x
expr_stmt|;
operator|(
name|void
operator|)
name|y
expr_stmt|;
name|fromskew
operator|/=
literal|8
expr_stmt|;
while|while
condition|(
name|h
operator|--
operator|>
literal|0
condition|)
block|{
name|uint32
modifier|*
name|bw
decl_stmt|;
name|UNROLL8
argument_list|(
name|w
argument_list|,
name|bw
operator|=
name|BWmap
index|[
operator|*
name|pp
operator|++
index|]
argument_list|,
operator|*
name|cp
operator|++
operator|=
operator|*
name|bw
operator|++
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|toskew
expr_stmt|;
name|pp
operator|+=
name|fromskew
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * 2-bit greyscale => colormap/RGB  */
end_comment
begin_macro
DECL|function|DECLAREContigPutFunc
name|DECLAREContigPutFunc
argument_list|(
argument|put2bitbwtile
argument_list|)
end_macro
begin_block
block|{
name|uint32
modifier|*
modifier|*
name|BWmap
init|=
name|img
operator|->
name|BWmap
decl_stmt|;
operator|(
name|void
operator|)
name|x
expr_stmt|;
operator|(
name|void
operator|)
name|y
expr_stmt|;
name|fromskew
operator|/=
literal|4
expr_stmt|;
while|while
condition|(
name|h
operator|--
operator|>
literal|0
condition|)
block|{
name|uint32
modifier|*
name|bw
decl_stmt|;
name|UNROLL4
argument_list|(
name|w
argument_list|,
name|bw
operator|=
name|BWmap
index|[
operator|*
name|pp
operator|++
index|]
argument_list|,
operator|*
name|cp
operator|++
operator|=
operator|*
name|bw
operator|++
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|toskew
expr_stmt|;
name|pp
operator|+=
name|fromskew
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * 4-bit greyscale => colormap/RGB  */
end_comment
begin_macro
DECL|function|DECLAREContigPutFunc
name|DECLAREContigPutFunc
argument_list|(
argument|put4bitbwtile
argument_list|)
end_macro
begin_block
block|{
name|uint32
modifier|*
modifier|*
name|BWmap
init|=
name|img
operator|->
name|BWmap
decl_stmt|;
operator|(
name|void
operator|)
name|x
expr_stmt|;
operator|(
name|void
operator|)
name|y
expr_stmt|;
name|fromskew
operator|/=
literal|2
expr_stmt|;
while|while
condition|(
name|h
operator|--
operator|>
literal|0
condition|)
block|{
name|uint32
modifier|*
name|bw
decl_stmt|;
name|UNROLL2
argument_list|(
name|w
argument_list|,
name|bw
operator|=
name|BWmap
index|[
operator|*
name|pp
operator|++
index|]
argument_list|,
operator|*
name|cp
operator|++
operator|=
operator|*
name|bw
operator|++
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|toskew
expr_stmt|;
name|pp
operator|+=
name|fromskew
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * 8-bit packed samples, no Map => RGB  */
end_comment
begin_macro
DECL|function|DECLAREContigPutFunc
name|DECLAREContigPutFunc
argument_list|(
argument|putRGBcontig8bittile
argument_list|)
end_macro
begin_block
block|{
name|int
name|samplesperpixel
init|=
name|img
operator|->
name|samplesperpixel
decl_stmt|;
operator|(
name|void
operator|)
name|x
expr_stmt|;
operator|(
name|void
operator|)
name|y
expr_stmt|;
name|fromskew
operator|*=
name|samplesperpixel
expr_stmt|;
while|while
condition|(
name|h
operator|--
operator|>
literal|0
condition|)
block|{
name|UNROLL8
argument_list|(
argument|w
argument_list|,
argument|NOP
argument_list|,
argument|*cp++ = PACK(pp[
literal|0
argument|], pp[
literal|1
argument|], pp[
literal|2
argument|]); 	    pp += samplesperpixel
argument_list|)
empty_stmt|;
name|cp
operator|+=
name|toskew
expr_stmt|;
name|pp
operator|+=
name|fromskew
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * 8-bit packed samples => RGBA w/ associated alpha  * (known to have Map == NULL)  */
end_comment
begin_macro
DECL|function|DECLAREContigPutFunc
name|DECLAREContigPutFunc
argument_list|(
argument|putRGBAAcontig8bittile
argument_list|)
end_macro
begin_block
block|{
name|int
name|samplesperpixel
init|=
name|img
operator|->
name|samplesperpixel
decl_stmt|;
operator|(
name|void
operator|)
name|x
expr_stmt|;
operator|(
name|void
operator|)
name|y
expr_stmt|;
name|fromskew
operator|*=
name|samplesperpixel
expr_stmt|;
while|while
condition|(
name|h
operator|--
operator|>
literal|0
condition|)
block|{
name|UNROLL8
argument_list|(
argument|w
argument_list|,
argument|NOP
argument_list|,
argument|*cp++ = PACK4(pp[
literal|0
argument|], pp[
literal|1
argument|], pp[
literal|2
argument|], pp[
literal|3
argument|]); 	    pp += samplesperpixel
argument_list|)
empty_stmt|;
name|cp
operator|+=
name|toskew
expr_stmt|;
name|pp
operator|+=
name|fromskew
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * 8-bit packed samples => RGBA w/ unassociated alpha  * (known to have Map == NULL)  */
end_comment
begin_macro
DECL|function|DECLAREContigPutFunc
name|DECLAREContigPutFunc
argument_list|(
argument|putRGBUAcontig8bittile
argument_list|)
end_macro
begin_block
block|{
name|int
name|samplesperpixel
init|=
name|img
operator|->
name|samplesperpixel
decl_stmt|;
operator|(
name|void
operator|)
name|y
expr_stmt|;
name|fromskew
operator|*=
name|samplesperpixel
expr_stmt|;
while|while
condition|(
name|h
operator|--
operator|>
literal|0
condition|)
block|{
name|uint32
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|,
name|a
decl_stmt|;
for|for
control|(
name|x
operator|=
name|w
init|;
name|x
operator|--
operator|>
literal|0
condition|;
control|)
block|{
name|a
operator|=
name|pp
index|[
literal|3
index|]
expr_stmt|;
name|r
operator|=
operator|(
name|a
operator|*
name|pp
index|[
literal|0
index|]
operator|+
literal|127
operator|)
operator|/
literal|255
expr_stmt|;
name|g
operator|=
operator|(
name|a
operator|*
name|pp
index|[
literal|1
index|]
operator|+
literal|127
operator|)
operator|/
literal|255
expr_stmt|;
name|b
operator|=
operator|(
name|a
operator|*
name|pp
index|[
literal|2
index|]
operator|+
literal|127
operator|)
operator|/
literal|255
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|PACK4
argument_list|(
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|pp
operator|+=
name|samplesperpixel
expr_stmt|;
block|}
name|cp
operator|+=
name|toskew
expr_stmt|;
name|pp
operator|+=
name|fromskew
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * 16-bit packed samples => RGB  */
end_comment
begin_macro
DECL|function|DECLAREContigPutFunc
name|DECLAREContigPutFunc
argument_list|(
argument|putRGBcontig16bittile
argument_list|)
end_macro
begin_block
block|{
name|int
name|samplesperpixel
init|=
name|img
operator|->
name|samplesperpixel
decl_stmt|;
name|uint16
modifier|*
name|wp
init|=
operator|(
name|uint16
operator|*
operator|)
name|pp
decl_stmt|;
operator|(
name|void
operator|)
name|y
expr_stmt|;
name|fromskew
operator|*=
name|samplesperpixel
expr_stmt|;
while|while
condition|(
name|h
operator|--
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|x
operator|=
name|w
init|;
name|x
operator|--
operator|>
literal|0
condition|;
control|)
block|{
operator|*
name|cp
operator|++
operator|=
name|PACKW
argument_list|(
name|wp
index|[
literal|0
index|]
argument_list|,
name|wp
index|[
literal|1
index|]
argument_list|,
name|wp
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|wp
operator|+=
name|samplesperpixel
expr_stmt|;
block|}
name|cp
operator|+=
name|toskew
expr_stmt|;
name|wp
operator|+=
name|fromskew
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * 16-bit packed samples => RGBA w/ associated alpha  * (known to have Map == NULL)  */
end_comment
begin_macro
DECL|function|DECLAREContigPutFunc
name|DECLAREContigPutFunc
argument_list|(
argument|putRGBAAcontig16bittile
argument_list|)
end_macro
begin_block
block|{
name|int
name|samplesperpixel
init|=
name|img
operator|->
name|samplesperpixel
decl_stmt|;
name|uint16
modifier|*
name|wp
init|=
operator|(
name|uint16
operator|*
operator|)
name|pp
decl_stmt|;
operator|(
name|void
operator|)
name|y
expr_stmt|;
name|fromskew
operator|*=
name|samplesperpixel
expr_stmt|;
while|while
condition|(
name|h
operator|--
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|x
operator|=
name|w
init|;
name|x
operator|--
operator|>
literal|0
condition|;
control|)
block|{
operator|*
name|cp
operator|++
operator|=
name|PACKW4
argument_list|(
name|wp
index|[
literal|0
index|]
argument_list|,
name|wp
index|[
literal|1
index|]
argument_list|,
name|wp
index|[
literal|2
index|]
argument_list|,
name|wp
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|wp
operator|+=
name|samplesperpixel
expr_stmt|;
block|}
name|cp
operator|+=
name|toskew
expr_stmt|;
name|wp
operator|+=
name|fromskew
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * 16-bit packed samples => RGBA w/ unassociated alpha  * (known to have Map == NULL)  */
end_comment
begin_macro
DECL|function|DECLAREContigPutFunc
name|DECLAREContigPutFunc
argument_list|(
argument|putRGBUAcontig16bittile
argument_list|)
end_macro
begin_block
block|{
name|int
name|samplesperpixel
init|=
name|img
operator|->
name|samplesperpixel
decl_stmt|;
name|uint16
modifier|*
name|wp
init|=
operator|(
name|uint16
operator|*
operator|)
name|pp
decl_stmt|;
operator|(
name|void
operator|)
name|y
expr_stmt|;
name|fromskew
operator|*=
name|samplesperpixel
expr_stmt|;
while|while
condition|(
name|h
operator|--
operator|>
literal|0
condition|)
block|{
name|uint32
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|,
name|a
decl_stmt|;
for|for
control|(
name|x
operator|=
name|w
init|;
name|x
operator|--
operator|>
literal|0
condition|;
control|)
block|{
name|a
operator|=
name|W2B
argument_list|(
name|wp
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|r
operator|=
operator|(
name|a
operator|*
name|W2B
argument_list|(
name|wp
index|[
literal|0
index|]
argument_list|)
operator|+
literal|127
operator|)
operator|/
literal|255
expr_stmt|;
name|g
operator|=
operator|(
name|a
operator|*
name|W2B
argument_list|(
name|wp
index|[
literal|1
index|]
argument_list|)
operator|+
literal|127
operator|)
operator|/
literal|255
expr_stmt|;
name|b
operator|=
operator|(
name|a
operator|*
name|W2B
argument_list|(
name|wp
index|[
literal|2
index|]
argument_list|)
operator|+
literal|127
operator|)
operator|/
literal|255
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|PACK4
argument_list|(
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|wp
operator|+=
name|samplesperpixel
expr_stmt|;
block|}
name|cp
operator|+=
name|toskew
expr_stmt|;
name|wp
operator|+=
name|fromskew
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * 8-bit packed CMYK samples w/o Map => RGB  *  * NB: The conversion of CMYK->RGB is *very* crude.  */
end_comment
begin_macro
DECL|function|DECLAREContigPutFunc
name|DECLAREContigPutFunc
argument_list|(
argument|putRGBcontig8bitCMYKtile
argument_list|)
end_macro
begin_block
block|{
name|int
name|samplesperpixel
init|=
name|img
operator|->
name|samplesperpixel
decl_stmt|;
name|uint16
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|,
name|k
decl_stmt|;
operator|(
name|void
operator|)
name|x
expr_stmt|;
operator|(
name|void
operator|)
name|y
expr_stmt|;
name|fromskew
operator|*=
name|samplesperpixel
expr_stmt|;
while|while
condition|(
name|h
operator|--
operator|>
literal|0
condition|)
block|{
name|UNROLL8
argument_list|(
argument|w
argument_list|,
argument|NOP
argument_list|,
argument|k =
literal|255
argument|- pp[
literal|3
argument|]; 	    r = (k*(
literal|255
argument|-pp[
literal|0
argument|]))/
literal|255
argument|; 	    g = (k*(
literal|255
argument|-pp[
literal|1
argument|]))/
literal|255
argument|; 	    b = (k*(
literal|255
argument|-pp[
literal|2
argument|]))/
literal|255
argument|; 	    *cp++ = PACK(r, g, b); 	    pp += samplesperpixel
argument_list|)
empty_stmt|;
name|cp
operator|+=
name|toskew
expr_stmt|;
name|pp
operator|+=
name|fromskew
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * 8-bit packed CMYK samples w/Map => RGB  *  * NB: The conversion of CMYK->RGB is *very* crude.  */
end_comment
begin_macro
DECL|function|DECLAREContigPutFunc
name|DECLAREContigPutFunc
argument_list|(
argument|putRGBcontig8bitCMYKMaptile
argument_list|)
end_macro
begin_block
block|{
name|int
name|samplesperpixel
init|=
name|img
operator|->
name|samplesperpixel
decl_stmt|;
name|TIFFRGBValue
modifier|*
name|Map
init|=
name|img
operator|->
name|Map
decl_stmt|;
name|uint16
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|,
name|k
decl_stmt|;
operator|(
name|void
operator|)
name|y
expr_stmt|;
name|fromskew
operator|*=
name|samplesperpixel
expr_stmt|;
while|while
condition|(
name|h
operator|--
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|x
operator|=
name|w
init|;
name|x
operator|--
operator|>
literal|0
condition|;
control|)
block|{
name|k
operator|=
literal|255
operator|-
name|pp
index|[
literal|3
index|]
expr_stmt|;
name|r
operator|=
operator|(
name|k
operator|*
operator|(
literal|255
operator|-
name|pp
index|[
literal|0
index|]
operator|)
operator|)
operator|/
literal|255
expr_stmt|;
name|g
operator|=
operator|(
name|k
operator|*
operator|(
literal|255
operator|-
name|pp
index|[
literal|1
index|]
operator|)
operator|)
operator|/
literal|255
expr_stmt|;
name|b
operator|=
operator|(
name|k
operator|*
operator|(
literal|255
operator|-
name|pp
index|[
literal|2
index|]
operator|)
operator|)
operator|/
literal|255
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|PACK
argument_list|(
name|Map
index|[
name|r
index|]
argument_list|,
name|Map
index|[
name|g
index|]
argument_list|,
name|Map
index|[
name|b
index|]
argument_list|)
expr_stmt|;
name|pp
operator|+=
name|samplesperpixel
expr_stmt|;
block|}
name|pp
operator|+=
name|fromskew
expr_stmt|;
name|cp
operator|+=
name|toskew
expr_stmt|;
block|}
block|}
end_block
begin_define
DECL|macro|DECLARESepPutFunc
define|#
directive|define
name|DECLARESepPutFunc
parameter_list|(
name|name
parameter_list|)
define|\
value|static void name(\     TIFFRGBAImage* img,\     uint32* cp,\     uint32 x, uint32 y, \     uint32 w, uint32 h,\     int32 fromskew, int32 toskew,\     unsigned char* r, unsigned char* g, unsigned char* b, unsigned char* a\ )
end_define
begin_comment
comment|/*  * 8-bit unpacked samples => RGB  */
end_comment
begin_macro
DECL|function|DECLARESepPutFunc
name|DECLARESepPutFunc
argument_list|(
argument|putRGBseparate8bittile
argument_list|)
end_macro
begin_block
block|{
operator|(
name|void
operator|)
name|img
expr_stmt|;
operator|(
name|void
operator|)
name|x
expr_stmt|;
operator|(
name|void
operator|)
name|y
expr_stmt|;
operator|(
name|void
operator|)
name|a
expr_stmt|;
while|while
condition|(
name|h
operator|--
operator|>
literal|0
condition|)
block|{
name|UNROLL8
argument_list|(
name|w
argument_list|,
name|NOP
argument_list|,
operator|*
name|cp
operator|++
operator|=
name|PACK
argument_list|(
operator|*
name|r
operator|++
argument_list|,
operator|*
name|g
operator|++
argument_list|,
operator|*
name|b
operator|++
argument_list|)
argument_list|)
expr_stmt|;
name|SKEW
argument_list|(
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|,
name|fromskew
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|toskew
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * 8-bit unpacked samples => RGBA w/ associated alpha  */
end_comment
begin_macro
DECL|function|DECLARESepPutFunc
name|DECLARESepPutFunc
argument_list|(
argument|putRGBAAseparate8bittile
argument_list|)
end_macro
begin_block
block|{
operator|(
name|void
operator|)
name|img
expr_stmt|;
operator|(
name|void
operator|)
name|x
expr_stmt|;
operator|(
name|void
operator|)
name|y
expr_stmt|;
while|while
condition|(
name|h
operator|--
operator|>
literal|0
condition|)
block|{
name|UNROLL8
argument_list|(
name|w
argument_list|,
name|NOP
argument_list|,
operator|*
name|cp
operator|++
operator|=
name|PACK4
argument_list|(
operator|*
name|r
operator|++
argument_list|,
operator|*
name|g
operator|++
argument_list|,
operator|*
name|b
operator|++
argument_list|,
operator|*
name|a
operator|++
argument_list|)
argument_list|)
expr_stmt|;
name|SKEW4
argument_list|(
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|,
name|a
argument_list|,
name|fromskew
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|toskew
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * 8-bit unpacked samples => RGBA w/ unassociated alpha  */
end_comment
begin_macro
DECL|function|DECLARESepPutFunc
name|DECLARESepPutFunc
argument_list|(
argument|putRGBUAseparate8bittile
argument_list|)
end_macro
begin_block
block|{
operator|(
name|void
operator|)
name|img
expr_stmt|;
operator|(
name|void
operator|)
name|y
expr_stmt|;
while|while
condition|(
name|h
operator|--
operator|>
literal|0
condition|)
block|{
name|uint32
name|rv
decl_stmt|,
name|gv
decl_stmt|,
name|bv
decl_stmt|,
name|av
decl_stmt|;
for|for
control|(
name|x
operator|=
name|w
init|;
name|x
operator|--
operator|>
literal|0
condition|;
control|)
block|{
name|av
operator|=
operator|*
name|a
operator|++
expr_stmt|;
name|rv
operator|=
operator|(
name|av
operator|*
operator|*
name|r
operator|++
operator|+
literal|127
operator|)
operator|/
literal|255
expr_stmt|;
name|gv
operator|=
operator|(
name|av
operator|*
operator|*
name|g
operator|++
operator|+
literal|127
operator|)
operator|/
literal|255
expr_stmt|;
name|bv
operator|=
operator|(
name|av
operator|*
operator|*
name|b
operator|++
operator|+
literal|127
operator|)
operator|/
literal|255
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|PACK4
argument_list|(
name|rv
argument_list|,
name|gv
argument_list|,
name|bv
argument_list|,
name|av
argument_list|)
expr_stmt|;
block|}
name|SKEW4
argument_list|(
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|,
name|a
argument_list|,
name|fromskew
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|toskew
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * 16-bit unpacked samples => RGB  */
end_comment
begin_macro
DECL|function|DECLARESepPutFunc
name|DECLARESepPutFunc
argument_list|(
argument|putRGBseparate16bittile
argument_list|)
end_macro
begin_block
block|{
name|uint16
modifier|*
name|wr
init|=
operator|(
name|uint16
operator|*
operator|)
name|r
decl_stmt|;
name|uint16
modifier|*
name|wg
init|=
operator|(
name|uint16
operator|*
operator|)
name|g
decl_stmt|;
name|uint16
modifier|*
name|wb
init|=
operator|(
name|uint16
operator|*
operator|)
name|b
decl_stmt|;
operator|(
name|void
operator|)
name|img
expr_stmt|;
operator|(
name|void
operator|)
name|y
expr_stmt|;
operator|(
name|void
operator|)
name|a
expr_stmt|;
while|while
condition|(
name|h
operator|--
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
name|x
operator|++
control|)
operator|*
name|cp
operator|++
operator|=
name|PACKW
argument_list|(
operator|*
name|wr
operator|++
argument_list|,
operator|*
name|wg
operator|++
argument_list|,
operator|*
name|wb
operator|++
argument_list|)
expr_stmt|;
name|SKEW
argument_list|(
name|wr
argument_list|,
name|wg
argument_list|,
name|wb
argument_list|,
name|fromskew
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|toskew
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * 16-bit unpacked samples => RGBA w/ associated alpha  */
end_comment
begin_macro
DECL|function|DECLARESepPutFunc
name|DECLARESepPutFunc
argument_list|(
argument|putRGBAAseparate16bittile
argument_list|)
end_macro
begin_block
block|{
name|uint16
modifier|*
name|wr
init|=
operator|(
name|uint16
operator|*
operator|)
name|r
decl_stmt|;
name|uint16
modifier|*
name|wg
init|=
operator|(
name|uint16
operator|*
operator|)
name|g
decl_stmt|;
name|uint16
modifier|*
name|wb
init|=
operator|(
name|uint16
operator|*
operator|)
name|b
decl_stmt|;
name|uint16
modifier|*
name|wa
init|=
operator|(
name|uint16
operator|*
operator|)
name|a
decl_stmt|;
operator|(
name|void
operator|)
name|img
expr_stmt|;
operator|(
name|void
operator|)
name|y
expr_stmt|;
while|while
condition|(
name|h
operator|--
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
name|x
operator|++
control|)
operator|*
name|cp
operator|++
operator|=
name|PACKW4
argument_list|(
operator|*
name|wr
operator|++
argument_list|,
operator|*
name|wg
operator|++
argument_list|,
operator|*
name|wb
operator|++
argument_list|,
operator|*
name|wa
operator|++
argument_list|)
expr_stmt|;
name|SKEW4
argument_list|(
name|wr
argument_list|,
name|wg
argument_list|,
name|wb
argument_list|,
name|wa
argument_list|,
name|fromskew
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|toskew
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * 16-bit unpacked samples => RGBA w/ unassociated alpha  */
end_comment
begin_macro
DECL|function|DECLARESepPutFunc
name|DECLARESepPutFunc
argument_list|(
argument|putRGBUAseparate16bittile
argument_list|)
end_macro
begin_block
block|{
name|uint16
modifier|*
name|wr
init|=
operator|(
name|uint16
operator|*
operator|)
name|r
decl_stmt|;
name|uint16
modifier|*
name|wg
init|=
operator|(
name|uint16
operator|*
operator|)
name|g
decl_stmt|;
name|uint16
modifier|*
name|wb
init|=
operator|(
name|uint16
operator|*
operator|)
name|b
decl_stmt|;
name|uint16
modifier|*
name|wa
init|=
operator|(
name|uint16
operator|*
operator|)
name|a
decl_stmt|;
operator|(
name|void
operator|)
name|img
expr_stmt|;
operator|(
name|void
operator|)
name|y
expr_stmt|;
while|while
condition|(
name|h
operator|--
operator|>
literal|0
condition|)
block|{
name|uint32
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|,
name|a
decl_stmt|;
for|for
control|(
name|x
operator|=
name|w
init|;
name|x
operator|--
operator|>
literal|0
condition|;
control|)
block|{
name|a
operator|=
name|W2B
argument_list|(
operator|*
name|wa
operator|++
argument_list|)
expr_stmt|;
name|r
operator|=
operator|(
name|a
operator|*
name|W2B
argument_list|(
operator|*
name|wr
operator|++
argument_list|)
operator|+
literal|127
operator|)
operator|/
literal|255
expr_stmt|;
name|g
operator|=
operator|(
name|a
operator|*
name|W2B
argument_list|(
operator|*
name|wg
operator|++
argument_list|)
operator|+
literal|127
operator|)
operator|/
literal|255
expr_stmt|;
name|b
operator|=
operator|(
name|a
operator|*
name|W2B
argument_list|(
operator|*
name|wb
operator|++
argument_list|)
operator|+
literal|127
operator|)
operator|/
literal|255
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|PACK4
argument_list|(
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
name|SKEW4
argument_list|(
name|wr
argument_list|,
name|wg
argument_list|,
name|wb
argument_list|,
name|wa
argument_list|,
name|fromskew
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|toskew
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * 8-bit packed CIE L*a*b 1976 samples => RGB  */
end_comment
begin_macro
DECL|function|DECLAREContigPutFunc
name|DECLAREContigPutFunc
argument_list|(
argument|putcontig8bitCIELab
argument_list|)
end_macro
begin_block
block|{
name|float
name|X
decl_stmt|,
name|Y
decl_stmt|,
name|Z
decl_stmt|;
name|uint32
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|;
operator|(
name|void
operator|)
name|y
expr_stmt|;
name|fromskew
operator|*=
literal|3
expr_stmt|;
while|while
condition|(
name|h
operator|--
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|x
operator|=
name|w
init|;
name|x
operator|--
operator|>
literal|0
condition|;
control|)
block|{
name|TIFFCIELabToXYZ
argument_list|(
name|img
operator|->
name|cielab
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|pp
index|[
literal|0
index|]
argument_list|,
operator|(
name|signed
name|char
operator|)
name|pp
index|[
literal|1
index|]
argument_list|,
operator|(
name|signed
name|char
operator|)
name|pp
index|[
literal|2
index|]
argument_list|,
operator|&
name|X
argument_list|,
operator|&
name|Y
argument_list|,
operator|&
name|Z
argument_list|)
expr_stmt|;
name|TIFFXYZToRGB
argument_list|(
name|img
operator|->
name|cielab
argument_list|,
name|X
argument_list|,
name|Y
argument_list|,
name|Z
argument_list|,
operator|&
name|r
argument_list|,
operator|&
name|g
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|PACK
argument_list|(
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|pp
operator|+=
literal|3
expr_stmt|;
block|}
name|cp
operator|+=
name|toskew
expr_stmt|;
name|pp
operator|+=
name|fromskew
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * YCbCr -> RGB conversion and packing routines.  */
end_comment
begin_define
DECL|macro|YCbCrtoRGB
define|#
directive|define
name|YCbCrtoRGB
parameter_list|(
name|dst
parameter_list|,
name|Y
parameter_list|)
value|{						\ 	uint32 r, g, b;							\ 	TIFFYCbCrtoRGB(img->ycbcr, (Y), Cb, Cr,&r,&g,&b);		\ 	dst = PACK(r, g, b);						\ }
end_define
begin_comment
comment|/*  * 8-bit packed YCbCr samples => RGB   * This function is generic for different sampling sizes,   * and can handle blocks sizes that aren't multiples of the  * sampling size.  However, it is substantially less optimized  * than the specific sampling cases.  It is used as a fallback  * for difficult blocks.  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef
begin_function
DECL|function|putcontig8bitYCbCrGenericTile
specifier|static
name|void
name|putcontig8bitYCbCrGenericTile
parameter_list|(
name|TIFFRGBAImage
modifier|*
name|img
parameter_list|,
name|uint32
modifier|*
name|cp
parameter_list|,
name|uint32
name|x
parameter_list|,
name|uint32
name|y
parameter_list|,
name|uint32
name|w
parameter_list|,
name|uint32
name|h
parameter_list|,
name|int32
name|fromskew
parameter_list|,
name|int32
name|toskew
parameter_list|,
name|unsigned
name|char
modifier|*
name|pp
parameter_list|,
name|int
name|h_group
parameter_list|,
name|int
name|v_group
parameter_list|)
block|{
name|uint32
modifier|*
name|cp1
init|=
name|cp
operator|+
name|w
operator|+
name|toskew
decl_stmt|;
name|uint32
modifier|*
name|cp2
init|=
name|cp1
operator|+
name|w
operator|+
name|toskew
decl_stmt|;
name|uint32
modifier|*
name|cp3
init|=
name|cp2
operator|+
name|w
operator|+
name|toskew
decl_stmt|;
name|int32
name|incr
init|=
literal|3
operator|*
name|w
operator|+
literal|4
operator|*
name|toskew
decl_stmt|;
name|int32
name|Cb
decl_stmt|,
name|Cr
decl_stmt|;
name|int
name|group_size
init|=
name|v_group
operator|*
name|h_group
operator|+
literal|2
decl_stmt|;
operator|(
name|void
operator|)
name|y
expr_stmt|;
name|fromskew
operator|=
operator|(
name|fromskew
operator|*
name|group_size
operator|)
operator|/
name|h_group
expr_stmt|;
for|for
control|(
name|yy
operator|=
literal|0
init|;
name|yy
operator|<
name|h
condition|;
name|yy
operator|++
control|)
block|{
name|unsigned
name|char
modifier|*
name|pp_line
decl_stmt|;
name|int
name|y_line_group
init|=
name|yy
operator|/
name|v_group
decl_stmt|;
name|int
name|y_remainder
init|=
name|yy
operator|-
name|y_line_group
operator|*
name|v_group
decl_stmt|;
name|pp_line
operator|=
name|pp
operator|+
name|v_line_group
operator|*
for|for
control|(
name|xx
operator|=
literal|0
init|;
name|xx
operator|<
name|w
condition|;
name|xx
operator|++
control|)
block|{
name|Cb
operator|=
name|pp
block|}
block|}
for|for
control|(
init|;
name|h
operator|>=
literal|4
condition|;
name|h
operator|-=
literal|4
control|)
block|{
name|x
operator|=
name|w
operator|>>
literal|2
expr_stmt|;
do|do
block|{
name|Cb
operator|=
name|pp
index|[
literal|16
index|]
expr_stmt|;
name|Cr
operator|=
name|pp
index|[
literal|17
index|]
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|0
index|]
argument_list|,
name|pp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|1
index|]
argument_list|,
name|pp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|2
index|]
argument_list|,
name|pp
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|3
index|]
argument_list|,
name|pp
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp1
index|[
literal|0
index|]
argument_list|,
name|pp
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp1
index|[
literal|1
index|]
argument_list|,
name|pp
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp1
index|[
literal|2
index|]
argument_list|,
name|pp
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp1
index|[
literal|3
index|]
argument_list|,
name|pp
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp2
index|[
literal|0
index|]
argument_list|,
name|pp
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp2
index|[
literal|1
index|]
argument_list|,
name|pp
index|[
literal|9
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp2
index|[
literal|2
index|]
argument_list|,
name|pp
index|[
literal|10
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp2
index|[
literal|3
index|]
argument_list|,
name|pp
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp3
index|[
literal|0
index|]
argument_list|,
name|pp
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp3
index|[
literal|1
index|]
argument_list|,
name|pp
index|[
literal|13
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp3
index|[
literal|2
index|]
argument_list|,
name|pp
index|[
literal|14
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp3
index|[
literal|3
index|]
argument_list|,
name|pp
index|[
literal|15
index|]
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|4
operator|,
name|cp1
operator|+=
literal|4
operator|,
name|cp2
operator|+=
literal|4
operator|,
name|cp3
operator|+=
literal|4
expr_stmt|;
name|pp
operator|+=
literal|18
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|x
condition|)
do|;
name|cp
operator|+=
name|incr
operator|,
name|cp1
operator|+=
name|incr
operator|,
name|cp2
operator|+=
name|incr
operator|,
name|cp3
operator|+=
name|incr
expr_stmt|;
name|pp
operator|+=
name|fromskew
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*  * 8-bit packed YCbCr samples w/ 4,4 subsampling => RGB  */
end_comment
begin_macro
DECL|function|DECLAREContigPutFunc
name|DECLAREContigPutFunc
argument_list|(
argument|putcontig8bitYCbCr44tile
argument_list|)
end_macro
begin_block
block|{
name|uint32
modifier|*
name|cp1
init|=
name|cp
operator|+
name|w
operator|+
name|toskew
decl_stmt|;
name|uint32
modifier|*
name|cp2
init|=
name|cp1
operator|+
name|w
operator|+
name|toskew
decl_stmt|;
name|uint32
modifier|*
name|cp3
init|=
name|cp2
operator|+
name|w
operator|+
name|toskew
decl_stmt|;
name|int32
name|incr
init|=
literal|3
operator|*
name|w
operator|+
literal|4
operator|*
name|toskew
decl_stmt|;
operator|(
name|void
operator|)
name|y
expr_stmt|;
comment|/* adjust fromskew */
name|fromskew
operator|=
operator|(
name|fromskew
operator|*
literal|18
operator|)
operator|/
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|&
literal|3
operator|)
operator|==
literal|0
operator|&&
operator|(
name|w
operator|&
literal|3
operator|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
init|;
name|h
operator|>=
literal|4
condition|;
name|h
operator|-=
literal|4
control|)
block|{
name|x
operator|=
name|w
operator|>>
literal|2
expr_stmt|;
do|do
block|{
name|int32
name|Cb
init|=
name|pp
index|[
literal|16
index|]
decl_stmt|;
name|int32
name|Cr
init|=
name|pp
index|[
literal|17
index|]
decl_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|0
index|]
argument_list|,
name|pp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|1
index|]
argument_list|,
name|pp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|2
index|]
argument_list|,
name|pp
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|3
index|]
argument_list|,
name|pp
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp1
index|[
literal|0
index|]
argument_list|,
name|pp
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp1
index|[
literal|1
index|]
argument_list|,
name|pp
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp1
index|[
literal|2
index|]
argument_list|,
name|pp
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp1
index|[
literal|3
index|]
argument_list|,
name|pp
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp2
index|[
literal|0
index|]
argument_list|,
name|pp
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp2
index|[
literal|1
index|]
argument_list|,
name|pp
index|[
literal|9
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp2
index|[
literal|2
index|]
argument_list|,
name|pp
index|[
literal|10
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp2
index|[
literal|3
index|]
argument_list|,
name|pp
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp3
index|[
literal|0
index|]
argument_list|,
name|pp
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp3
index|[
literal|1
index|]
argument_list|,
name|pp
index|[
literal|13
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp3
index|[
literal|2
index|]
argument_list|,
name|pp
index|[
literal|14
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp3
index|[
literal|3
index|]
argument_list|,
name|pp
index|[
literal|15
index|]
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|4
operator|,
name|cp1
operator|+=
literal|4
operator|,
name|cp2
operator|+=
literal|4
operator|,
name|cp3
operator|+=
literal|4
expr_stmt|;
name|pp
operator|+=
literal|18
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|x
condition|)
do|;
name|cp
operator|+=
name|incr
operator|,
name|cp1
operator|+=
name|incr
operator|,
name|cp2
operator|+=
name|incr
operator|,
name|cp3
operator|+=
name|incr
expr_stmt|;
name|pp
operator|+=
name|fromskew
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|h
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|x
operator|=
name|w
init|;
name|x
operator|>
literal|0
condition|;
control|)
block|{
name|int32
name|Cb
init|=
name|pp
index|[
literal|16
index|]
decl_stmt|;
name|int32
name|Cr
init|=
name|pp
index|[
literal|17
index|]
decl_stmt|;
switch|switch
condition|(
name|x
condition|)
block|{
default|default:
switch|switch
condition|(
name|h
condition|)
block|{
default|default:
name|YCbCrtoRGB
argument_list|(
name|cp3
index|[
literal|3
index|]
argument_list|,
name|pp
index|[
literal|15
index|]
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|3
case|:
name|YCbCrtoRGB
argument_list|(
name|cp2
index|[
literal|3
index|]
argument_list|,
name|pp
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|2
case|:
name|YCbCrtoRGB
argument_list|(
name|cp1
index|[
literal|3
index|]
argument_list|,
name|pp
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|1
case|:
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|3
index|]
argument_list|,
name|pp
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
block|}
comment|/* FALLTHROUGH */
case|case
literal|3
case|:
switch|switch
condition|(
name|h
condition|)
block|{
default|default:
name|YCbCrtoRGB
argument_list|(
name|cp3
index|[
literal|2
index|]
argument_list|,
name|pp
index|[
literal|14
index|]
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|3
case|:
name|YCbCrtoRGB
argument_list|(
name|cp2
index|[
literal|2
index|]
argument_list|,
name|pp
index|[
literal|10
index|]
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|2
case|:
name|YCbCrtoRGB
argument_list|(
name|cp1
index|[
literal|2
index|]
argument_list|,
name|pp
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|1
case|:
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|2
index|]
argument_list|,
name|pp
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
block|}
comment|/* FALLTHROUGH */
case|case
literal|2
case|:
switch|switch
condition|(
name|h
condition|)
block|{
default|default:
name|YCbCrtoRGB
argument_list|(
name|cp3
index|[
literal|1
index|]
argument_list|,
name|pp
index|[
literal|13
index|]
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|3
case|:
name|YCbCrtoRGB
argument_list|(
name|cp2
index|[
literal|1
index|]
argument_list|,
name|pp
index|[
literal|9
index|]
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|2
case|:
name|YCbCrtoRGB
argument_list|(
name|cp1
index|[
literal|1
index|]
argument_list|,
name|pp
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|1
case|:
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|1
index|]
argument_list|,
name|pp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
block|}
comment|/* FALLTHROUGH */
case|case
literal|1
case|:
switch|switch
condition|(
name|h
condition|)
block|{
default|default:
name|YCbCrtoRGB
argument_list|(
name|cp3
index|[
literal|0
index|]
argument_list|,
name|pp
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|3
case|:
name|YCbCrtoRGB
argument_list|(
name|cp2
index|[
literal|0
index|]
argument_list|,
name|pp
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|2
case|:
name|YCbCrtoRGB
argument_list|(
name|cp1
index|[
literal|0
index|]
argument_list|,
name|pp
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|1
case|:
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|0
index|]
argument_list|,
name|pp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
block|}
comment|/* FALLTHROUGH */
block|}
if|if
condition|(
name|x
operator|<
literal|4
condition|)
block|{
name|cp
operator|+=
name|x
expr_stmt|;
name|cp1
operator|+=
name|x
expr_stmt|;
name|cp2
operator|+=
name|x
expr_stmt|;
name|cp3
operator|+=
name|x
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|+=
literal|4
expr_stmt|;
name|cp1
operator|+=
literal|4
expr_stmt|;
name|cp2
operator|+=
literal|4
expr_stmt|;
name|cp3
operator|+=
literal|4
expr_stmt|;
name|x
operator|-=
literal|4
expr_stmt|;
block|}
name|pp
operator|+=
literal|18
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|<=
literal|4
condition|)
break|break;
name|h
operator|-=
literal|4
expr_stmt|;
name|cp
operator|+=
name|incr
operator|,
name|cp1
operator|+=
name|incr
operator|,
name|cp2
operator|+=
name|incr
operator|,
name|cp3
operator|+=
name|incr
expr_stmt|;
name|pp
operator|+=
name|fromskew
expr_stmt|;
block|}
block|}
block|}
end_block
begin_comment
comment|/*  * 8-bit packed YCbCr samples w/ 4,2 subsampling => RGB  */
end_comment
begin_macro
DECL|function|DECLAREContigPutFunc
name|DECLAREContigPutFunc
argument_list|(
argument|putcontig8bitYCbCr42tile
argument_list|)
end_macro
begin_block
block|{
name|uint32
modifier|*
name|cp1
init|=
name|cp
operator|+
name|w
operator|+
name|toskew
decl_stmt|;
name|int32
name|incr
init|=
literal|2
operator|*
name|toskew
operator|+
name|w
decl_stmt|;
operator|(
name|void
operator|)
name|y
expr_stmt|;
name|fromskew
operator|=
operator|(
name|fromskew
operator|*
literal|10
operator|)
operator|/
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|&
literal|3
operator|)
operator|==
literal|0
operator|&&
operator|(
name|w
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
init|;
name|h
operator|>=
literal|2
condition|;
name|h
operator|-=
literal|2
control|)
block|{
name|x
operator|=
name|w
operator|>>
literal|2
expr_stmt|;
do|do
block|{
name|int32
name|Cb
init|=
name|pp
index|[
literal|8
index|]
decl_stmt|;
name|int32
name|Cr
init|=
name|pp
index|[
literal|9
index|]
decl_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|0
index|]
argument_list|,
name|pp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|1
index|]
argument_list|,
name|pp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|2
index|]
argument_list|,
name|pp
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|3
index|]
argument_list|,
name|pp
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp1
index|[
literal|0
index|]
argument_list|,
name|pp
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp1
index|[
literal|1
index|]
argument_list|,
name|pp
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp1
index|[
literal|2
index|]
argument_list|,
name|pp
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp1
index|[
literal|3
index|]
argument_list|,
name|pp
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|4
operator|,
name|cp1
operator|+=
literal|4
expr_stmt|;
name|pp
operator|+=
literal|10
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|x
condition|)
do|;
name|cp
operator|+=
name|incr
operator|,
name|cp1
operator|+=
name|incr
expr_stmt|;
name|pp
operator|+=
name|fromskew
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|h
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|x
operator|=
name|w
init|;
name|x
operator|>
literal|0
condition|;
control|)
block|{
name|int32
name|Cb
init|=
name|pp
index|[
literal|8
index|]
decl_stmt|;
name|int32
name|Cr
init|=
name|pp
index|[
literal|9
index|]
decl_stmt|;
switch|switch
condition|(
name|x
condition|)
block|{
default|default:
switch|switch
condition|(
name|h
condition|)
block|{
default|default:
name|YCbCrtoRGB
argument_list|(
name|cp1
index|[
literal|3
index|]
argument_list|,
name|pp
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|1
case|:
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|3
index|]
argument_list|,
name|pp
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
block|}
comment|/* FALLTHROUGH */
case|case
literal|3
case|:
switch|switch
condition|(
name|h
condition|)
block|{
default|default:
name|YCbCrtoRGB
argument_list|(
name|cp1
index|[
literal|2
index|]
argument_list|,
name|pp
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|1
case|:
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|2
index|]
argument_list|,
name|pp
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
block|}
comment|/* FALLTHROUGH */
case|case
literal|2
case|:
switch|switch
condition|(
name|h
condition|)
block|{
default|default:
name|YCbCrtoRGB
argument_list|(
name|cp1
index|[
literal|1
index|]
argument_list|,
name|pp
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|1
case|:
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|1
index|]
argument_list|,
name|pp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
block|}
comment|/* FALLTHROUGH */
case|case
literal|1
case|:
switch|switch
condition|(
name|h
condition|)
block|{
default|default:
name|YCbCrtoRGB
argument_list|(
name|cp1
index|[
literal|0
index|]
argument_list|,
name|pp
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|1
case|:
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|0
index|]
argument_list|,
name|pp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
block|}
comment|/* FALLTHROUGH */
block|}
if|if
condition|(
name|x
operator|<
literal|4
condition|)
block|{
name|cp
operator|+=
name|x
expr_stmt|;
name|cp1
operator|+=
name|x
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|+=
literal|4
expr_stmt|;
name|cp1
operator|+=
literal|4
expr_stmt|;
name|x
operator|-=
literal|4
expr_stmt|;
block|}
name|pp
operator|+=
literal|10
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|<=
literal|2
condition|)
break|break;
name|h
operator|-=
literal|2
expr_stmt|;
name|cp
operator|+=
name|incr
operator|,
name|cp1
operator|+=
name|incr
expr_stmt|;
name|pp
operator|+=
name|fromskew
expr_stmt|;
block|}
block|}
block|}
end_block
begin_comment
comment|/*  * 8-bit packed YCbCr samples w/ 4,1 subsampling => RGB  */
end_comment
begin_macro
DECL|function|DECLAREContigPutFunc
name|DECLAREContigPutFunc
argument_list|(
argument|putcontig8bitYCbCr41tile
argument_list|)
end_macro
begin_block
block|{
operator|(
name|void
operator|)
name|y
expr_stmt|;
comment|/* XXX adjust fromskew */
do|do
block|{
name|x
operator|=
name|w
operator|>>
literal|2
expr_stmt|;
do|do
block|{
name|int32
name|Cb
init|=
name|pp
index|[
literal|4
index|]
decl_stmt|;
name|int32
name|Cr
init|=
name|pp
index|[
literal|5
index|]
decl_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|0
index|]
argument_list|,
name|pp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|1
index|]
argument_list|,
name|pp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|2
index|]
argument_list|,
name|pp
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|3
index|]
argument_list|,
name|pp
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|4
expr_stmt|;
name|pp
operator|+=
literal|6
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|x
condition|)
do|;
if|if
condition|(
operator|(
name|w
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
block|{
name|int32
name|Cb
init|=
name|pp
index|[
literal|4
index|]
decl_stmt|;
name|int32
name|Cr
init|=
name|pp
index|[
literal|5
index|]
decl_stmt|;
switch|switch
condition|(
operator|(
name|w
operator|&
literal|3
operator|)
condition|)
block|{
case|case
literal|3
case|:
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|2
index|]
argument_list|,
name|pp
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|1
index|]
argument_list|,
name|pp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|0
index|]
argument_list|,
name|pp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
break|break;
block|}
name|cp
operator|+=
operator|(
name|w
operator|&
literal|3
operator|)
expr_stmt|;
name|pp
operator|+=
literal|6
expr_stmt|;
block|}
name|cp
operator|+=
name|toskew
expr_stmt|;
name|pp
operator|+=
name|fromskew
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|h
condition|)
do|;
block|}
end_block
begin_comment
comment|/*  * 8-bit packed YCbCr samples w/ 2,2 subsampling => RGB  */
end_comment
begin_macro
DECL|function|DECLAREContigPutFunc
name|DECLAREContigPutFunc
argument_list|(
argument|putcontig8bitYCbCr22tile
argument_list|)
end_macro
begin_block
block|{
name|uint32
modifier|*
name|cp2
decl_stmt|;
operator|(
name|void
operator|)
name|y
expr_stmt|;
name|fromskew
operator|=
operator|(
name|fromskew
operator|/
literal|2
operator|)
operator|*
literal|6
expr_stmt|;
name|cp2
operator|=
name|cp
operator|+
name|w
operator|+
name|toskew
expr_stmt|;
while|while
condition|(
name|h
operator|>=
literal|2
condition|)
block|{
name|x
operator|=
name|w
expr_stmt|;
while|while
condition|(
name|x
operator|>=
literal|2
condition|)
block|{
name|uint32
name|Cb
init|=
name|pp
index|[
literal|4
index|]
decl_stmt|;
name|uint32
name|Cr
init|=
name|pp
index|[
literal|5
index|]
decl_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|0
index|]
argument_list|,
name|pp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|1
index|]
argument_list|,
name|pp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp2
index|[
literal|0
index|]
argument_list|,
name|pp
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp2
index|[
literal|1
index|]
argument_list|,
name|pp
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|2
expr_stmt|;
name|cp2
operator|+=
literal|2
expr_stmt|;
name|pp
operator|+=
literal|6
expr_stmt|;
name|x
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|==
literal|1
condition|)
block|{
name|uint32
name|Cb
init|=
name|pp
index|[
literal|4
index|]
decl_stmt|;
name|uint32
name|Cr
init|=
name|pp
index|[
literal|5
index|]
decl_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|0
index|]
argument_list|,
name|pp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp2
index|[
literal|0
index|]
argument_list|,
name|pp
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
name|cp2
operator|++
expr_stmt|;
name|pp
operator|+=
literal|6
expr_stmt|;
block|}
name|cp
operator|+=
name|toskew
operator|*
literal|2
operator|+
name|w
expr_stmt|;
name|cp2
operator|+=
name|toskew
operator|*
literal|2
operator|+
name|w
expr_stmt|;
name|pp
operator|+=
name|fromskew
expr_stmt|;
name|h
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|==
literal|1
condition|)
block|{
name|x
operator|=
name|w
expr_stmt|;
while|while
condition|(
name|x
operator|>=
literal|2
condition|)
block|{
name|uint32
name|Cb
init|=
name|pp
index|[
literal|4
index|]
decl_stmt|;
name|uint32
name|Cr
init|=
name|pp
index|[
literal|5
index|]
decl_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|0
index|]
argument_list|,
name|pp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|1
index|]
argument_list|,
name|pp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|2
expr_stmt|;
name|cp2
operator|+=
literal|2
expr_stmt|;
name|pp
operator|+=
literal|6
expr_stmt|;
name|x
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|==
literal|1
condition|)
block|{
name|uint32
name|Cb
init|=
name|pp
index|[
literal|4
index|]
decl_stmt|;
name|uint32
name|Cr
init|=
name|pp
index|[
literal|5
index|]
decl_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|0
index|]
argument_list|,
name|pp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block
begin_comment
comment|/*  * 8-bit packed YCbCr samples w/ 2,1 subsampling => RGB  */
end_comment
begin_macro
DECL|function|DECLAREContigPutFunc
name|DECLAREContigPutFunc
argument_list|(
argument|putcontig8bitYCbCr21tile
argument_list|)
end_macro
begin_block
block|{
operator|(
name|void
operator|)
name|y
expr_stmt|;
name|fromskew
operator|=
operator|(
name|fromskew
operator|*
literal|4
operator|)
operator|/
literal|2
expr_stmt|;
do|do
block|{
name|x
operator|=
name|w
operator|>>
literal|1
expr_stmt|;
do|do
block|{
name|int32
name|Cb
init|=
name|pp
index|[
literal|2
index|]
decl_stmt|;
name|int32
name|Cr
init|=
name|pp
index|[
literal|3
index|]
decl_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|0
index|]
argument_list|,
name|pp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|1
index|]
argument_list|,
name|pp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|2
expr_stmt|;
name|pp
operator|+=
literal|4
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|x
condition|)
do|;
if|if
condition|(
operator|(
name|w
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|int32
name|Cb
init|=
name|pp
index|[
literal|2
index|]
decl_stmt|;
name|int32
name|Cr
init|=
name|pp
index|[
literal|3
index|]
decl_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|0
index|]
argument_list|,
name|pp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|1
expr_stmt|;
name|pp
operator|+=
literal|4
expr_stmt|;
block|}
name|cp
operator|+=
name|toskew
expr_stmt|;
name|pp
operator|+=
name|fromskew
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|h
condition|)
do|;
block|}
end_block
begin_comment
comment|/*  * 8-bit packed YCbCr samples w/ 1,2 subsampling => RGB  */
end_comment
begin_macro
DECL|function|DECLAREContigPutFunc
name|DECLAREContigPutFunc
argument_list|(
argument|putcontig8bitYCbCr12tile
argument_list|)
end_macro
begin_block
block|{
name|uint32
modifier|*
name|cp2
decl_stmt|;
operator|(
name|void
operator|)
name|y
expr_stmt|;
name|fromskew
operator|=
operator|(
name|fromskew
operator|/
literal|2
operator|)
operator|*
literal|4
expr_stmt|;
name|cp2
operator|=
name|cp
operator|+
name|w
operator|+
name|toskew
expr_stmt|;
while|while
condition|(
name|h
operator|>=
literal|2
condition|)
block|{
name|x
operator|=
name|w
expr_stmt|;
do|do
block|{
name|uint32
name|Cb
init|=
name|pp
index|[
literal|2
index|]
decl_stmt|;
name|uint32
name|Cr
init|=
name|pp
index|[
literal|3
index|]
decl_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|0
index|]
argument_list|,
name|pp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp2
index|[
literal|0
index|]
argument_list|,
name|pp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
name|cp2
operator|++
expr_stmt|;
name|pp
operator|+=
literal|4
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|x
condition|)
do|;
name|cp
operator|+=
name|toskew
operator|*
literal|2
operator|+
name|w
expr_stmt|;
name|cp2
operator|+=
name|toskew
operator|*
literal|2
operator|+
name|w
expr_stmt|;
name|pp
operator|+=
name|fromskew
expr_stmt|;
name|h
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|==
literal|1
condition|)
block|{
name|x
operator|=
name|w
expr_stmt|;
do|do
block|{
name|uint32
name|Cb
init|=
name|pp
index|[
literal|2
index|]
decl_stmt|;
name|uint32
name|Cr
init|=
name|pp
index|[
literal|3
index|]
decl_stmt|;
name|YCbCrtoRGB
argument_list|(
name|cp
index|[
literal|0
index|]
argument_list|,
name|pp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
name|pp
operator|+=
literal|4
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|x
condition|)
do|;
block|}
block|}
end_block
begin_comment
comment|/*  * 8-bit packed YCbCr samples w/ no subsampling => RGB  */
end_comment
begin_macro
DECL|function|DECLAREContigPutFunc
name|DECLAREContigPutFunc
argument_list|(
argument|putcontig8bitYCbCr11tile
argument_list|)
end_macro
begin_block
block|{
operator|(
name|void
operator|)
name|y
expr_stmt|;
name|fromskew
operator|*=
literal|3
expr_stmt|;
do|do
block|{
name|x
operator|=
name|w
expr_stmt|;
comment|/* was x = w>>1; patched 2000/09/25 warmerda@home.com */
do|do
block|{
name|int32
name|Cb
init|=
name|pp
index|[
literal|1
index|]
decl_stmt|;
name|int32
name|Cr
init|=
name|pp
index|[
literal|2
index|]
decl_stmt|;
name|YCbCrtoRGB
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
name|pp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|pp
operator|+=
literal|3
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|x
condition|)
do|;
name|cp
operator|+=
name|toskew
expr_stmt|;
name|pp
operator|+=
name|fromskew
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|h
condition|)
do|;
block|}
end_block
begin_comment
comment|/*  * 8-bit packed YCbCr samples w/ no subsampling => RGB  */
end_comment
begin_macro
DECL|function|DECLARESepPutFunc
name|DECLARESepPutFunc
argument_list|(
argument|putseparate8bitYCbCr11tile
argument_list|)
end_macro
begin_block
block|{
operator|(
name|void
operator|)
name|y
expr_stmt|;
operator|(
name|void
operator|)
name|a
expr_stmt|;
comment|/* TODO: naming of input vars is still off, change obfuscating declaration inside define, or resolve obfuscation */
while|while
condition|(
name|h
operator|--
operator|>
literal|0
condition|)
block|{
name|x
operator|=
name|w
expr_stmt|;
do|do
block|{
name|uint32
name|dr
decl_stmt|,
name|dg
decl_stmt|,
name|db
decl_stmt|;
name|TIFFYCbCrtoRGB
argument_list|(
name|img
operator|->
name|ycbcr
argument_list|,
operator|*
name|r
operator|++
argument_list|,
operator|*
name|g
operator|++
argument_list|,
operator|*
name|b
operator|++
argument_list|,
operator|&
name|dr
argument_list|,
operator|&
name|dg
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|PACK
argument_list|(
name|dr
argument_list|,
name|dg
argument_list|,
name|db
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|x
condition|)
do|;
name|SKEW
argument_list|(
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|,
name|fromskew
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|toskew
expr_stmt|;
block|}
block|}
end_block
begin_undef
DECL|macro|YCbCrtoRGB
undef|#
directive|undef
name|YCbCrtoRGB
end_undef
begin_function
specifier|static
name|int
DECL|function|initYCbCrConversion
name|initYCbCrConversion
parameter_list|(
name|TIFFRGBAImage
modifier|*
name|img
parameter_list|)
block|{
specifier|static
name|char
name|module
index|[]
init|=
literal|"initYCbCrConversion"
decl_stmt|;
name|float
modifier|*
name|luma
decl_stmt|,
modifier|*
name|refBlackWhite
decl_stmt|;
if|if
condition|(
name|img
operator|->
name|ycbcr
operator|==
name|NULL
condition|)
block|{
name|img
operator|->
name|ycbcr
operator|=
operator|(
name|TIFFYCbCrToRGB
operator|*
operator|)
name|_TIFFmalloc
argument_list|(
name|TIFFroundup
argument_list|(
sizeof|sizeof
argument_list|(
name|TIFFYCbCrToRGB
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
operator|+
literal|4
operator|*
literal|256
operator|*
sizeof|sizeof
argument_list|(
name|TIFFRGBValue
argument_list|)
operator|+
literal|2
operator|*
literal|256
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|+
literal|3
operator|*
literal|256
operator|*
sizeof|sizeof
argument_list|(
name|int32
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|img
operator|->
name|ycbcr
operator|==
name|NULL
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|img
operator|->
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"No space for YCbCr->RGB conversion state"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|TIFFGetFieldDefaulted
argument_list|(
name|img
operator|->
name|tif
argument_list|,
name|TIFFTAG_YCBCRCOEFFICIENTS
argument_list|,
operator|&
name|luma
argument_list|)
expr_stmt|;
name|TIFFGetFieldDefaulted
argument_list|(
name|img
operator|->
name|tif
argument_list|,
name|TIFFTAG_REFERENCEBLACKWHITE
argument_list|,
operator|&
name|refBlackWhite
argument_list|)
expr_stmt|;
if|if
condition|(
name|TIFFYCbCrToRGBInit
argument_list|(
name|img
operator|->
name|ycbcr
argument_list|,
name|luma
argument_list|,
name|refBlackWhite
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|tileContigRoutine
DECL|function|initCIELabConversion
name|initCIELabConversion
parameter_list|(
name|TIFFRGBAImage
modifier|*
name|img
parameter_list|)
block|{
specifier|static
name|char
name|module
index|[]
init|=
literal|"initCIELabConversion"
decl_stmt|;
name|float
modifier|*
name|whitePoint
decl_stmt|;
name|float
name|refWhite
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|img
operator|->
name|cielab
condition|)
block|{
name|img
operator|->
name|cielab
operator|=
operator|(
name|TIFFCIELabToRGB
operator|*
operator|)
name|_TIFFmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TIFFCIELabToRGB
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|img
operator|->
name|cielab
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|img
operator|->
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"No space for CIE L*a*b*->RGB conversion state."
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|TIFFGetFieldDefaulted
argument_list|(
name|img
operator|->
name|tif
argument_list|,
name|TIFFTAG_WHITEPOINT
argument_list|,
operator|&
name|whitePoint
argument_list|)
expr_stmt|;
name|refWhite
index|[
literal|1
index|]
operator|=
literal|100.0F
expr_stmt|;
name|refWhite
index|[
literal|0
index|]
operator|=
name|whitePoint
index|[
literal|0
index|]
operator|/
name|whitePoint
index|[
literal|1
index|]
operator|*
name|refWhite
index|[
literal|1
index|]
expr_stmt|;
name|refWhite
index|[
literal|2
index|]
operator|=
operator|(
literal|1.0F
operator|-
name|whitePoint
index|[
literal|0
index|]
operator|-
name|whitePoint
index|[
literal|1
index|]
operator|)
operator|/
name|whitePoint
index|[
literal|1
index|]
operator|*
name|refWhite
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|TIFFCIELabToRGBInit
argument_list|(
name|img
operator|->
name|cielab
argument_list|,
operator|&
name|display_sRGB
argument_list|,
name|refWhite
argument_list|)
operator|<
literal|0
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|img
operator|->
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"Failed to initialize CIE L*a*b*->RGB conversion state."
argument_list|)
expr_stmt|;
name|_TIFFfree
argument_list|(
name|img
operator|->
name|cielab
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|putcontig8bitCIELab
return|;
block|}
end_function
begin_comment
comment|/*  * Greyscale images with less than 8 bits/sample are handled  * with a table to avoid lots of shifts and masks.  The table  * is setup so that put*bwtile (below) can retrieve 8/bitspersample  * pixel values simply by indexing into the table with one  * number.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|makebwmap
name|makebwmap
parameter_list|(
name|TIFFRGBAImage
modifier|*
name|img
parameter_list|)
block|{
name|TIFFRGBValue
modifier|*
name|Map
init|=
name|img
operator|->
name|Map
decl_stmt|;
name|int
name|bitspersample
init|=
name|img
operator|->
name|bitspersample
decl_stmt|;
name|int
name|nsamples
init|=
literal|8
operator|/
name|bitspersample
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint32
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|nsamples
operator|==
literal|0
condition|)
name|nsamples
operator|=
literal|1
expr_stmt|;
name|img
operator|->
name|BWmap
operator|=
operator|(
name|uint32
operator|*
operator|*
operator|)
name|_TIFFmalloc
argument_list|(
literal|256
operator|*
sizeof|sizeof
argument_list|(
name|uint32
operator|*
argument_list|)
operator|+
operator|(
literal|256
operator|*
name|nsamples
operator|*
sizeof|sizeof
argument_list|(
name|uint32
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|img
operator|->
name|BWmap
operator|==
name|NULL
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|img
operator|->
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|TIFFFileName
argument_list|(
name|img
operator|->
name|tif
argument_list|)
argument_list|,
literal|"No space for B&W mapping table"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|p
operator|=
operator|(
name|uint32
operator|*
operator|)
operator|(
name|img
operator|->
name|BWmap
operator|+
literal|256
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|TIFFRGBValue
name|c
decl_stmt|;
name|img
operator|->
name|BWmap
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
switch|switch
condition|(
name|bitspersample
condition|)
block|{
DECL|macro|GREY
define|#
directive|define
name|GREY
parameter_list|(
name|x
parameter_list|)
value|c = Map[x]; *p++ = PACK(c,c,c);
case|case
literal|1
case|:
name|GREY
argument_list|(
name|i
operator|>>
literal|7
argument_list|)
expr_stmt|;
name|GREY
argument_list|(
operator|(
name|i
operator|>>
literal|6
operator|)
operator|&
literal|1
argument_list|)
expr_stmt|;
name|GREY
argument_list|(
operator|(
name|i
operator|>>
literal|5
operator|)
operator|&
literal|1
argument_list|)
expr_stmt|;
name|GREY
argument_list|(
operator|(
name|i
operator|>>
literal|4
operator|)
operator|&
literal|1
argument_list|)
expr_stmt|;
name|GREY
argument_list|(
operator|(
name|i
operator|>>
literal|3
operator|)
operator|&
literal|1
argument_list|)
expr_stmt|;
name|GREY
argument_list|(
operator|(
name|i
operator|>>
literal|2
operator|)
operator|&
literal|1
argument_list|)
expr_stmt|;
name|GREY
argument_list|(
operator|(
name|i
operator|>>
literal|1
operator|)
operator|&
literal|1
argument_list|)
expr_stmt|;
name|GREY
argument_list|(
name|i
operator|&
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|GREY
argument_list|(
name|i
operator|>>
literal|6
argument_list|)
expr_stmt|;
name|GREY
argument_list|(
operator|(
name|i
operator|>>
literal|4
operator|)
operator|&
literal|3
argument_list|)
expr_stmt|;
name|GREY
argument_list|(
operator|(
name|i
operator|>>
literal|2
operator|)
operator|&
literal|3
argument_list|)
expr_stmt|;
name|GREY
argument_list|(
name|i
operator|&
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|GREY
argument_list|(
name|i
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|GREY
argument_list|(
name|i
operator|&
literal|0xf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
case|case
literal|16
case|:
name|GREY
argument_list|(
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
DECL|macro|GREY
undef|#
directive|undef
name|GREY
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Construct a mapping table to convert from the range  * of the data samples to [0,255] --for display.  This  * process also handles inverting B&W images when needed.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|setupMap
name|setupMap
parameter_list|(
name|TIFFRGBAImage
modifier|*
name|img
parameter_list|)
block|{
name|int32
name|x
decl_stmt|,
name|range
decl_stmt|;
name|range
operator|=
call|(
name|int32
call|)
argument_list|(
operator|(
literal|1L
operator|<<
name|img
operator|->
name|bitspersample
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* treat 16 bit the same as eight bit */
if|if
condition|(
name|img
operator|->
name|bitspersample
operator|==
literal|16
condition|)
name|range
operator|=
operator|(
name|int32
operator|)
literal|255
expr_stmt|;
name|img
operator|->
name|Map
operator|=
operator|(
name|TIFFRGBValue
operator|*
operator|)
name|_TIFFmalloc
argument_list|(
operator|(
name|range
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|TIFFRGBValue
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|img
operator|->
name|Map
operator|==
name|NULL
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|img
operator|->
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|TIFFFileName
argument_list|(
name|img
operator|->
name|tif
argument_list|)
argument_list|,
literal|"No space for photometric conversion table"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|img
operator|->
name|photometric
operator|==
name|PHOTOMETRIC_MINISWHITE
condition|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<=
name|range
condition|;
name|x
operator|++
control|)
name|img
operator|->
name|Map
index|[
name|x
index|]
operator|=
call|(
name|TIFFRGBValue
call|)
argument_list|(
operator|(
operator|(
name|range
operator|-
name|x
operator|)
operator|*
literal|255
operator|)
operator|/
name|range
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<=
name|range
condition|;
name|x
operator|++
control|)
name|img
operator|->
name|Map
index|[
name|x
index|]
operator|=
call|(
name|TIFFRGBValue
call|)
argument_list|(
operator|(
name|x
operator|*
literal|255
operator|)
operator|/
name|range
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|img
operator|->
name|bitspersample
operator|<=
literal|16
operator|&&
operator|(
name|img
operator|->
name|photometric
operator|==
name|PHOTOMETRIC_MINISBLACK
operator|||
name|img
operator|->
name|photometric
operator|==
name|PHOTOMETRIC_MINISWHITE
operator|)
condition|)
block|{
comment|/* 	 * Use photometric mapping table to construct 	 * unpacking tables for samples<= 8 bits. 	 */
if|if
condition|(
operator|!
name|makebwmap
argument_list|(
name|img
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* no longer need Map, free it */
name|_TIFFfree
argument_list|(
name|img
operator|->
name|Map
argument_list|)
operator|,
name|img
operator|->
name|Map
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|checkcmap
name|checkcmap
parameter_list|(
name|TIFFRGBAImage
modifier|*
name|img
parameter_list|)
block|{
name|uint16
modifier|*
name|r
init|=
name|img
operator|->
name|redcmap
decl_stmt|;
name|uint16
modifier|*
name|g
init|=
name|img
operator|->
name|greencmap
decl_stmt|;
name|uint16
modifier|*
name|b
init|=
name|img
operator|->
name|bluecmap
decl_stmt|;
name|long
name|n
init|=
literal|1L
operator|<<
name|img
operator|->
name|bitspersample
decl_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
if|if
condition|(
operator|*
name|r
operator|++
operator|>=
literal|256
operator|||
operator|*
name|g
operator|++
operator|>=
literal|256
operator|||
operator|*
name|b
operator|++
operator|>=
literal|256
condition|)
return|return
operator|(
literal|16
operator|)
return|;
return|return
operator|(
literal|8
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|cvtcmap
name|cvtcmap
parameter_list|(
name|TIFFRGBAImage
modifier|*
name|img
parameter_list|)
block|{
name|uint16
modifier|*
name|r
init|=
name|img
operator|->
name|redcmap
decl_stmt|;
name|uint16
modifier|*
name|g
init|=
name|img
operator|->
name|greencmap
decl_stmt|;
name|uint16
modifier|*
name|b
init|=
name|img
operator|->
name|bluecmap
decl_stmt|;
name|long
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|(
literal|1L
operator|<<
name|img
operator|->
name|bitspersample
operator|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
DECL|macro|CVT
define|#
directive|define
name|CVT
parameter_list|(
name|x
parameter_list|)
value|((uint16)((x)>>8))
name|r
index|[
name|i
index|]
operator|=
name|CVT
argument_list|(
name|r
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|g
index|[
name|i
index|]
operator|=
name|CVT
argument_list|(
name|g
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|b
index|[
name|i
index|]
operator|=
name|CVT
argument_list|(
name|b
index|[
name|i
index|]
argument_list|)
expr_stmt|;
DECL|macro|CVT
undef|#
directive|undef
name|CVT
block|}
block|}
end_function
begin_comment
comment|/*  * Palette images with<= 8 bits/sample are handled  * with a table to avoid lots of shifts and masks.  The table  * is setup so that put*cmaptile (below) can retrieve 8/bitspersample  * pixel values simply by indexing into the table with one  * number.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|makecmap
name|makecmap
parameter_list|(
name|TIFFRGBAImage
modifier|*
name|img
parameter_list|)
block|{
name|int
name|bitspersample
init|=
name|img
operator|->
name|bitspersample
decl_stmt|;
name|int
name|nsamples
init|=
literal|8
operator|/
name|bitspersample
decl_stmt|;
name|uint16
modifier|*
name|r
init|=
name|img
operator|->
name|redcmap
decl_stmt|;
name|uint16
modifier|*
name|g
init|=
name|img
operator|->
name|greencmap
decl_stmt|;
name|uint16
modifier|*
name|b
init|=
name|img
operator|->
name|bluecmap
decl_stmt|;
name|uint32
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|img
operator|->
name|PALmap
operator|=
operator|(
name|uint32
operator|*
operator|*
operator|)
name|_TIFFmalloc
argument_list|(
literal|256
operator|*
sizeof|sizeof
argument_list|(
name|uint32
operator|*
argument_list|)
operator|+
operator|(
literal|256
operator|*
name|nsamples
operator|*
sizeof|sizeof
argument_list|(
name|uint32
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|img
operator|->
name|PALmap
operator|==
name|NULL
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|img
operator|->
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|TIFFFileName
argument_list|(
name|img
operator|->
name|tif
argument_list|)
argument_list|,
literal|"No space for Palette mapping table"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|p
operator|=
operator|(
name|uint32
operator|*
operator|)
operator|(
name|img
operator|->
name|PALmap
operator|+
literal|256
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|TIFFRGBValue
name|c
decl_stmt|;
name|img
operator|->
name|PALmap
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
DECL|macro|CMAP
define|#
directive|define
name|CMAP
parameter_list|(
name|x
parameter_list|)
value|c = (TIFFRGBValue) x; *p++ = PACK(r[c]&0xff, g[c]&0xff, b[c]&0xff);
switch|switch
condition|(
name|bitspersample
condition|)
block|{
case|case
literal|1
case|:
name|CMAP
argument_list|(
name|i
operator|>>
literal|7
argument_list|)
expr_stmt|;
name|CMAP
argument_list|(
operator|(
name|i
operator|>>
literal|6
operator|)
operator|&
literal|1
argument_list|)
expr_stmt|;
name|CMAP
argument_list|(
operator|(
name|i
operator|>>
literal|5
operator|)
operator|&
literal|1
argument_list|)
expr_stmt|;
name|CMAP
argument_list|(
operator|(
name|i
operator|>>
literal|4
operator|)
operator|&
literal|1
argument_list|)
expr_stmt|;
name|CMAP
argument_list|(
operator|(
name|i
operator|>>
literal|3
operator|)
operator|&
literal|1
argument_list|)
expr_stmt|;
name|CMAP
argument_list|(
operator|(
name|i
operator|>>
literal|2
operator|)
operator|&
literal|1
argument_list|)
expr_stmt|;
name|CMAP
argument_list|(
operator|(
name|i
operator|>>
literal|1
operator|)
operator|&
literal|1
argument_list|)
expr_stmt|;
name|CMAP
argument_list|(
name|i
operator|&
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|CMAP
argument_list|(
name|i
operator|>>
literal|6
argument_list|)
expr_stmt|;
name|CMAP
argument_list|(
operator|(
name|i
operator|>>
literal|4
operator|)
operator|&
literal|3
argument_list|)
expr_stmt|;
name|CMAP
argument_list|(
operator|(
name|i
operator|>>
literal|2
operator|)
operator|&
literal|3
argument_list|)
expr_stmt|;
name|CMAP
argument_list|(
name|i
operator|&
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|CMAP
argument_list|(
name|i
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|CMAP
argument_list|(
name|i
operator|&
literal|0xf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|CMAP
argument_list|(
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
DECL|macro|CMAP
undef|#
directive|undef
name|CMAP
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*   * Construct any mapping table used  * by the associated put routine.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|buildMap
name|buildMap
parameter_list|(
name|TIFFRGBAImage
modifier|*
name|img
parameter_list|)
block|{
switch|switch
condition|(
name|img
operator|->
name|photometric
condition|)
block|{
case|case
name|PHOTOMETRIC_RGB
case|:
case|case
name|PHOTOMETRIC_YCBCR
case|:
case|case
name|PHOTOMETRIC_SEPARATED
case|:
if|if
condition|(
name|img
operator|->
name|bitspersample
operator|==
literal|8
condition|)
break|break;
comment|/* fall thru... */
case|case
name|PHOTOMETRIC_MINISBLACK
case|:
case|case
name|PHOTOMETRIC_MINISWHITE
case|:
if|if
condition|(
operator|!
name|setupMap
argument_list|(
name|img
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|PHOTOMETRIC_PALETTE
case|:
comment|/* 	 * Convert 16-bit colormap to 8-bit (unless it looks 	 * like an old-style 8-bit colormap). 	 */
if|if
condition|(
name|checkcmap
argument_list|(
name|img
argument_list|)
operator|==
literal|16
condition|)
name|cvtcmap
argument_list|(
name|img
argument_list|)
expr_stmt|;
else|else
name|TIFFWarningExt
argument_list|(
name|img
operator|->
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|TIFFFileName
argument_list|(
name|img
operator|->
name|tif
argument_list|)
argument_list|,
literal|"Assuming 8-bit colormap"
argument_list|)
expr_stmt|;
comment|/* 	 * Use mapping table and colormap to construct 	 * unpacking tables for samples< 8 bits. 	 */
if|if
condition|(
name|img
operator|->
name|bitspersample
operator|<=
literal|8
operator|&&
operator|!
name|makecmap
argument_list|(
name|img
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Select the appropriate conversion routine for packed data.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|PickContigCase
name|PickContigCase
parameter_list|(
name|TIFFRGBAImage
modifier|*
name|img
parameter_list|)
block|{
name|img
operator|->
name|get
operator|=
name|TIFFIsTiled
argument_list|(
name|img
operator|->
name|tif
argument_list|)
condition|?
name|gtTileContig
else|:
name|gtStripContig
expr_stmt|;
name|img
operator|->
name|put
operator|.
name|contig
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|img
operator|->
name|photometric
condition|)
block|{
case|case
name|PHOTOMETRIC_RGB
case|:
switch|switch
condition|(
name|img
operator|->
name|bitspersample
condition|)
block|{
case|case
literal|8
case|:
if|if
condition|(
name|img
operator|->
name|alpha
operator|==
name|EXTRASAMPLE_ASSOCALPHA
condition|)
name|img
operator|->
name|put
operator|.
name|contig
operator|=
name|putRGBAAcontig8bittile
expr_stmt|;
elseif|else
if|if
condition|(
name|img
operator|->
name|alpha
operator|==
name|EXTRASAMPLE_UNASSALPHA
condition|)
block|{
name|img
operator|->
name|put
operator|.
name|contig
operator|=
name|putRGBUAcontig8bittile
expr_stmt|;
block|}
else|else
name|img
operator|->
name|put
operator|.
name|contig
operator|=
name|putRGBcontig8bittile
expr_stmt|;
break|break;
case|case
literal|16
case|:
if|if
condition|(
name|img
operator|->
name|alpha
operator|==
name|EXTRASAMPLE_ASSOCALPHA
condition|)
block|{
name|img
operator|->
name|put
operator|.
name|contig
operator|=
name|putRGBAAcontig16bittile
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|img
operator|->
name|alpha
operator|==
name|EXTRASAMPLE_UNASSALPHA
condition|)
block|{
name|img
operator|->
name|put
operator|.
name|contig
operator|=
name|putRGBUAcontig16bittile
expr_stmt|;
block|}
else|else
block|{
name|img
operator|->
name|put
operator|.
name|contig
operator|=
name|putRGBcontig16bittile
expr_stmt|;
block|}
break|break;
block|}
break|break;
case|case
name|PHOTOMETRIC_SEPARATED
case|:
if|if
condition|(
name|buildMap
argument_list|(
name|img
argument_list|)
condition|)
block|{
if|if
condition|(
name|img
operator|->
name|bitspersample
operator|==
literal|8
condition|)
block|{
if|if
condition|(
operator|!
name|img
operator|->
name|Map
condition|)
name|img
operator|->
name|put
operator|.
name|contig
operator|=
name|putRGBcontig8bitCMYKtile
expr_stmt|;
else|else
name|img
operator|->
name|put
operator|.
name|contig
operator|=
name|putRGBcontig8bitCMYKMaptile
expr_stmt|;
block|}
block|}
break|break;
case|case
name|PHOTOMETRIC_PALETTE
case|:
if|if
condition|(
name|buildMap
argument_list|(
name|img
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|img
operator|->
name|bitspersample
condition|)
block|{
case|case
literal|8
case|:
name|img
operator|->
name|put
operator|.
name|contig
operator|=
name|put8bitcmaptile
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|img
operator|->
name|put
operator|.
name|contig
operator|=
name|put4bitcmaptile
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|img
operator|->
name|put
operator|.
name|contig
operator|=
name|put2bitcmaptile
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|img
operator|->
name|put
operator|.
name|contig
operator|=
name|put1bitcmaptile
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|PHOTOMETRIC_MINISWHITE
case|:
case|case
name|PHOTOMETRIC_MINISBLACK
case|:
if|if
condition|(
name|buildMap
argument_list|(
name|img
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|img
operator|->
name|bitspersample
condition|)
block|{
case|case
literal|16
case|:
name|img
operator|->
name|put
operator|.
name|contig
operator|=
name|put16bitbwtile
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|img
operator|->
name|put
operator|.
name|contig
operator|=
name|putgreytile
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|img
operator|->
name|put
operator|.
name|contig
operator|=
name|put4bitbwtile
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|img
operator|->
name|put
operator|.
name|contig
operator|=
name|put2bitbwtile
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|img
operator|->
name|put
operator|.
name|contig
operator|=
name|put1bitbwtile
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|PHOTOMETRIC_YCBCR
case|:
if|if
condition|(
name|img
operator|->
name|bitspersample
operator|==
literal|8
condition|)
block|{
if|if
condition|(
name|initYCbCrConversion
argument_list|(
name|img
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 					 * The 6.0 spec says that subsampling must be 					 * one of 1, 2, or 4, and that vertical subsampling 					 * must always be<= horizontal subsampling; so 					 * there are only a few possibilities and we just 					 * enumerate the cases. 					 * Joris: added support for the [1,2] case, nonetheless, to accomodate 					 * some OJPEG files 					 */
name|uint16
name|SubsamplingHor
decl_stmt|;
name|uint16
name|SubsamplingVer
decl_stmt|;
name|TIFFGetFieldDefaulted
argument_list|(
name|img
operator|->
name|tif
argument_list|,
name|TIFFTAG_YCBCRSUBSAMPLING
argument_list|,
operator|&
name|SubsamplingHor
argument_list|,
operator|&
name|SubsamplingVer
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|SubsamplingHor
operator|<<
literal|4
operator|)
operator||
name|SubsamplingVer
condition|)
block|{
case|case
literal|0x44
case|:
name|img
operator|->
name|put
operator|.
name|contig
operator|=
name|putcontig8bitYCbCr44tile
expr_stmt|;
break|break;
case|case
literal|0x42
case|:
name|img
operator|->
name|put
operator|.
name|contig
operator|=
name|putcontig8bitYCbCr42tile
expr_stmt|;
break|break;
case|case
literal|0x41
case|:
name|img
operator|->
name|put
operator|.
name|contig
operator|=
name|putcontig8bitYCbCr41tile
expr_stmt|;
break|break;
case|case
literal|0x22
case|:
name|img
operator|->
name|put
operator|.
name|contig
operator|=
name|putcontig8bitYCbCr22tile
expr_stmt|;
break|break;
case|case
literal|0x21
case|:
name|img
operator|->
name|put
operator|.
name|contig
operator|=
name|putcontig8bitYCbCr21tile
expr_stmt|;
break|break;
case|case
literal|0x12
case|:
name|img
operator|->
name|put
operator|.
name|contig
operator|=
name|putcontig8bitYCbCr12tile
expr_stmt|;
break|break;
case|case
literal|0x11
case|:
name|img
operator|->
name|put
operator|.
name|contig
operator|=
name|putcontig8bitYCbCr11tile
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
case|case
name|PHOTOMETRIC_CIELAB
case|:
if|if
condition|(
name|buildMap
argument_list|(
name|img
argument_list|)
condition|)
block|{
if|if
condition|(
name|img
operator|->
name|bitspersample
operator|==
literal|8
condition|)
name|img
operator|->
name|put
operator|.
name|contig
operator|=
name|initCIELabConversion
argument_list|(
name|img
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
operator|(
name|img
operator|->
name|get
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|img
operator|->
name|put
operator|.
name|contig
operator|!=
name|NULL
operator|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Select the appropriate conversion routine for unpacked data.  *  * NB: we assume that unpacked single channel data is directed  *	 to the "packed routines.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|PickSeparateCase
name|PickSeparateCase
parameter_list|(
name|TIFFRGBAImage
modifier|*
name|img
parameter_list|)
block|{
name|img
operator|->
name|get
operator|=
name|TIFFIsTiled
argument_list|(
name|img
operator|->
name|tif
argument_list|)
condition|?
name|gtTileSeparate
else|:
name|gtStripSeparate
expr_stmt|;
name|img
operator|->
name|put
operator|.
name|separate
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|img
operator|->
name|photometric
condition|)
block|{
case|case
name|PHOTOMETRIC_RGB
case|:
switch|switch
condition|(
name|img
operator|->
name|bitspersample
condition|)
block|{
case|case
literal|8
case|:
if|if
condition|(
name|img
operator|->
name|alpha
operator|==
name|EXTRASAMPLE_ASSOCALPHA
condition|)
name|img
operator|->
name|put
operator|.
name|separate
operator|=
name|putRGBAAseparate8bittile
expr_stmt|;
elseif|else
if|if
condition|(
name|img
operator|->
name|alpha
operator|==
name|EXTRASAMPLE_UNASSALPHA
condition|)
block|{
name|img
operator|->
name|put
operator|.
name|separate
operator|=
name|putRGBUAseparate8bittile
expr_stmt|;
block|}
else|else
name|img
operator|->
name|put
operator|.
name|separate
operator|=
name|putRGBseparate8bittile
expr_stmt|;
break|break;
case|case
literal|16
case|:
if|if
condition|(
name|img
operator|->
name|alpha
operator|==
name|EXTRASAMPLE_ASSOCALPHA
condition|)
block|{
name|img
operator|->
name|put
operator|.
name|separate
operator|=
name|putRGBAAseparate16bittile
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|img
operator|->
name|alpha
operator|==
name|EXTRASAMPLE_UNASSALPHA
condition|)
block|{
name|img
operator|->
name|put
operator|.
name|separate
operator|=
name|putRGBUAseparate16bittile
expr_stmt|;
block|}
else|else
block|{
name|img
operator|->
name|put
operator|.
name|separate
operator|=
name|putRGBseparate16bittile
expr_stmt|;
block|}
break|break;
block|}
break|break;
case|case
name|PHOTOMETRIC_YCBCR
case|:
if|if
condition|(
operator|(
name|img
operator|->
name|bitspersample
operator|==
literal|8
operator|)
operator|&&
operator|(
name|img
operator|->
name|samplesperpixel
operator|==
literal|3
operator|)
condition|)
block|{
if|if
condition|(
name|initYCbCrConversion
argument_list|(
name|img
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|uint16
name|hs
decl_stmt|,
name|vs
decl_stmt|;
name|TIFFGetFieldDefaulted
argument_list|(
name|img
operator|->
name|tif
argument_list|,
name|TIFFTAG_YCBCRSUBSAMPLING
argument_list|,
operator|&
name|hs
argument_list|,
operator|&
name|vs
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|hs
operator|<<
literal|4
operator|)
operator||
name|vs
condition|)
block|{
case|case
literal|0x11
case|:
name|img
operator|->
name|put
operator|.
name|separate
operator|=
name|putseparate8bitYCbCr11tile
expr_stmt|;
break|break;
comment|/* TODO: add other cases here */
block|}
block|}
block|}
break|break;
block|}
return|return
operator|(
operator|(
name|img
operator|->
name|get
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|img
operator|->
name|put
operator|.
name|separate
operator|!=
name|NULL
operator|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Read a whole strip off data from the file, and convert to RGBA form.  * If this is the last strip, then it will only contain the portion of  * the strip that is actually within the image space.  The result is  * organized in bottom to top form.  */
end_comment
begin_function
name|int
DECL|function|TIFFReadRGBAStrip
name|TIFFReadRGBAStrip
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|uint32
name|row
parameter_list|,
name|uint32
modifier|*
name|raster
parameter_list|)
block|{
name|char
name|emsg
index|[
literal|1024
index|]
init|=
literal|""
decl_stmt|;
name|TIFFRGBAImage
name|img
decl_stmt|;
name|int
name|ok
decl_stmt|;
name|uint32
name|rowsperstrip
decl_stmt|,
name|rows_to_read
decl_stmt|;
if|if
condition|(
name|TIFFIsTiled
argument_list|(
name|tif
argument_list|)
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|TIFFFileName
argument_list|(
name|tif
argument_list|)
argument_list|,
literal|"Can't use TIFFReadRGBAStrip() with tiled file."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|TIFFGetFieldDefaulted
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_ROWSPERSTRIP
argument_list|,
operator|&
name|rowsperstrip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|row
operator|%
name|rowsperstrip
operator|)
operator|!=
literal|0
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|TIFFFileName
argument_list|(
name|tif
argument_list|)
argument_list|,
literal|"Row passed to TIFFReadRGBAStrip() must be first in a strip."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|TIFFRGBAImageOK
argument_list|(
name|tif
argument_list|,
name|emsg
argument_list|)
operator|&&
name|TIFFRGBAImageBegin
argument_list|(
operator|&
name|img
argument_list|,
name|tif
argument_list|,
literal|0
argument_list|,
name|emsg
argument_list|)
condition|)
block|{
name|img
operator|.
name|row_offset
operator|=
name|row
expr_stmt|;
name|img
operator|.
name|col_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|row
operator|+
name|rowsperstrip
operator|>
name|img
operator|.
name|height
condition|)
name|rows_to_read
operator|=
name|img
operator|.
name|height
operator|-
name|row
expr_stmt|;
else|else
name|rows_to_read
operator|=
name|rowsperstrip
expr_stmt|;
name|ok
operator|=
name|TIFFRGBAImageGet
argument_list|(
operator|&
name|img
argument_list|,
name|raster
argument_list|,
name|img
operator|.
name|width
argument_list|,
name|rows_to_read
argument_list|)
expr_stmt|;
name|TIFFRGBAImageEnd
argument_list|(
operator|&
name|img
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|TIFFFileName
argument_list|(
name|tif
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|emsg
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|ok
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Read a whole tile off data from the file, and convert to RGBA form.  * The returned RGBA data is organized from bottom to top of tile,  * and may include zeroed areas if the tile extends off the image.  */
end_comment
begin_function
name|int
DECL|function|TIFFReadRGBATile
name|TIFFReadRGBATile
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|uint32
name|col
parameter_list|,
name|uint32
name|row
parameter_list|,
name|uint32
modifier|*
name|raster
parameter_list|)
block|{
name|char
name|emsg
index|[
literal|1024
index|]
init|=
literal|""
decl_stmt|;
name|TIFFRGBAImage
name|img
decl_stmt|;
name|int
name|ok
decl_stmt|;
name|uint32
name|tile_xsize
decl_stmt|,
name|tile_ysize
decl_stmt|;
name|uint32
name|read_xsize
decl_stmt|,
name|read_ysize
decl_stmt|;
name|uint32
name|i_row
decl_stmt|;
comment|/*      * Verify that our request is legal - on a tile file, and on a      * tile boundary.      */
if|if
condition|(
operator|!
name|TIFFIsTiled
argument_list|(
name|tif
argument_list|)
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|TIFFFileName
argument_list|(
name|tif
argument_list|)
argument_list|,
literal|"Can't use TIFFReadRGBATile() with stripped file."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|TIFFGetFieldDefaulted
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_TILEWIDTH
argument_list|,
operator|&
name|tile_xsize
argument_list|)
expr_stmt|;
name|TIFFGetFieldDefaulted
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_TILELENGTH
argument_list|,
operator|&
name|tile_ysize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|col
operator|%
name|tile_xsize
operator|)
operator|!=
literal|0
operator|||
operator|(
name|row
operator|%
name|tile_ysize
operator|)
operator|!=
literal|0
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|TIFFFileName
argument_list|(
name|tif
argument_list|)
argument_list|,
literal|"Row/col passed to TIFFReadRGBATile() must be top"
literal|"left corner of a tile."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*      * Setup the RGBA reader.      */
if|if
condition|(
operator|!
name|TIFFRGBAImageOK
argument_list|(
name|tif
argument_list|,
name|emsg
argument_list|)
operator|||
operator|!
name|TIFFRGBAImageBegin
argument_list|(
operator|&
name|img
argument_list|,
name|tif
argument_list|,
literal|0
argument_list|,
name|emsg
argument_list|)
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|TIFFFileName
argument_list|(
name|tif
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|emsg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*      * The TIFFRGBAImageGet() function doesn't allow us to get off the      * edge of the image, even to fill an otherwise valid tile.  So we      * figure out how much we can read, and fix up the tile buffer to      * a full tile configuration afterwards.      */
if|if
condition|(
name|row
operator|+
name|tile_ysize
operator|>
name|img
operator|.
name|height
condition|)
name|read_ysize
operator|=
name|img
operator|.
name|height
operator|-
name|row
expr_stmt|;
else|else
name|read_ysize
operator|=
name|tile_ysize
expr_stmt|;
if|if
condition|(
name|col
operator|+
name|tile_xsize
operator|>
name|img
operator|.
name|width
condition|)
name|read_xsize
operator|=
name|img
operator|.
name|width
operator|-
name|col
expr_stmt|;
else|else
name|read_xsize
operator|=
name|tile_xsize
expr_stmt|;
comment|/*      * Read the chunk of imagery.      */
name|img
operator|.
name|row_offset
operator|=
name|row
expr_stmt|;
name|img
operator|.
name|col_offset
operator|=
name|col
expr_stmt|;
name|ok
operator|=
name|TIFFRGBAImageGet
argument_list|(
operator|&
name|img
argument_list|,
name|raster
argument_list|,
name|read_xsize
argument_list|,
name|read_ysize
argument_list|)
expr_stmt|;
name|TIFFRGBAImageEnd
argument_list|(
operator|&
name|img
argument_list|)
expr_stmt|;
comment|/*      * If our read was incomplete we will need to fix up the tile by      * shifting the data around as if a full tile of data is being returned.      *      * This is all the more complicated because the image is organized in      * bottom to top format.       */
if|if
condition|(
name|read_xsize
operator|==
name|tile_xsize
operator|&&
name|read_ysize
operator|==
name|tile_ysize
condition|)
return|return
operator|(
name|ok
operator|)
return|;
for|for
control|(
name|i_row
operator|=
literal|0
init|;
name|i_row
operator|<
name|read_ysize
condition|;
name|i_row
operator|++
control|)
block|{
name|memmove
argument_list|(
name|raster
operator|+
operator|(
name|tile_ysize
operator|-
name|i_row
operator|-
literal|1
operator|)
operator|*
name|tile_xsize
argument_list|,
name|raster
operator|+
operator|(
name|read_ysize
operator|-
name|i_row
operator|-
literal|1
operator|)
operator|*
name|read_xsize
argument_list|,
name|read_xsize
operator|*
sizeof|sizeof
argument_list|(
name|uint32
argument_list|)
argument_list|)
expr_stmt|;
name|_TIFFmemset
argument_list|(
name|raster
operator|+
operator|(
name|tile_ysize
operator|-
name|i_row
operator|-
literal|1
operator|)
operator|*
name|tile_xsize
operator|+
name|read_xsize
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32
argument_list|)
operator|*
operator|(
name|tile_xsize
operator|-
name|read_xsize
operator|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i_row
operator|=
name|read_ysize
init|;
name|i_row
operator|<
name|tile_ysize
condition|;
name|i_row
operator|++
control|)
block|{
name|_TIFFmemset
argument_list|(
name|raster
operator|+
operator|(
name|tile_ysize
operator|-
name|i_row
operator|-
literal|1
operator|)
operator|*
name|tile_xsize
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32
argument_list|)
operator|*
name|tile_xsize
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ok
operator|)
return|;
block|}
end_function
begin_comment
comment|/* vim: set ts=8 sts=8 sw=8 noet: */
end_comment
end_unit
