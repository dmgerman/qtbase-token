begin_unit
begin_comment
comment|/* $Id: tif_pixarlog.c,v 1.15.2.3 2009-01-01 00:10:43 bfriesen Exp $ */
end_comment
begin_comment
comment|/*  * Copyright (c) 1996-1997 Sam Leffler  * Copyright (c) 1996 Pixar  *  * Permission to use, copy, modify, distribute, and sell this software and   * its documentation for any purpose is hereby granted without fee, provided  * that (i) the above copyright notices and this permission notice appear in  * all copies of the software and related documentation, and (ii) the names of  * Pixar, Sam Leffler and Silicon Graphics may not be used in any advertising or  * publicity relating to the software without the specific, prior written  * permission of Pixar, Sam Leffler and Silicon Graphics.  *   * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,   * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY   * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.    *   * IN NO EVENT SHALL PIXAR, SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR  * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,  * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF   * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE   * OF THIS SOFTWARE.  */
end_comment
begin_include
include|#
directive|include
file|"tiffiop.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|PIXARLOG_SUPPORT
end_ifdef
begin_comment
comment|/*  * TIFF Library.  * PixarLog Compression Support  *  * Contributed by Dan McCoy.  *  * PixarLog film support uses the TIFF library to store companded  * 11 bit values into a tiff file, which are compressed using the   * zip compressor.    *  * The codec can take as input and produce as output 32-bit IEEE float values   * as well as 16-bit or 8-bit unsigned integer values.  *  * On writing any of the above are converted into the internal  * 11-bit log format.   In the case of  8 and 16 bit values, the  * input is assumed to be unsigned linear color values that represent  * the range 0-1.  In the case of IEEE values, the 0-1 range is assumed to  * be the normal linear color range, in addition over 1 values are  * accepted up to a value of about 25.0 to encode "hot" hightlights and such.  * The encoding is lossless for 8-bit values, slightly lossy for the  * other bit depths.  The actual color precision should be better  * than the human eye can perceive with extra room to allow for  * error introduced by further image computation.  As with any quantized  * color format, it is possible to perform image calculations which  * expose the quantization error. This format should certainly be less   * susceptable to such errors than standard 8-bit encodings, but more  * susceptable than straight 16-bit or 32-bit encodings.  *  * On reading the internal format is converted to the desired output format.  * The program can request which format it desires by setting the internal  * pseudo tag TIFFTAG_PIXARLOGDATAFMT to one of these possible values:  *  PIXARLOGDATAFMT_FLOAT     = provide IEEE float values.  *  PIXARLOGDATAFMT_16BIT     = provide unsigned 16-bit integer values  *  PIXARLOGDATAFMT_8BIT      = provide unsigned 8-bit integer values  *  * alternately PIXARLOGDATAFMT_8BITABGR provides unsigned 8-bit integer  * values with the difference that if there are exactly three or four channels  * (rgb or rgba) it swaps the channel order (bgr or abgr).  *  * PIXARLOGDATAFMT_11BITLOG provides the internal encoding directly  * packed in 16-bit values.   However no tools are supplied for interpreting  * these values.  *  * "hot" (over 1.0) areas written in floating point get clamped to  * 1.0 in the integer data types.  *  * When the file is closed after writing, the bit depth and sample format  * are set always to appear as if 8-bit data has been written into it.  * That way a naive program unaware of the particulars of the encoding  * gets the format it is most likely able to handle.  *  * The codec does it's own horizontal differencing step on the coded  * values so the libraries predictor stuff should be turned off.  * The codec also handle byte swapping the encoded values as necessary  * since the library does not have the information necessary  * to know the bit depth of the raw unencoded buffer.  *   */
end_comment
begin_include
include|#
directive|include
file|"tif_predict.h"
end_include
begin_include
include|#
directive|include
file|"zlib.h"
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|<math.h>
end_include
begin_comment
comment|/* Tables for converting to/from 11 bit coded values */
end_comment
begin_define
DECL|macro|TSIZE
define|#
directive|define
name|TSIZE
value|2048
end_define
begin_comment
DECL|macro|TSIZE
comment|/* decode table size (11-bit tokens) */
end_comment
begin_define
DECL|macro|TSIZEP1
define|#
directive|define
name|TSIZEP1
value|2049
end_define
begin_comment
DECL|macro|TSIZEP1
comment|/* Plus one for slop */
end_comment
begin_define
DECL|macro|ONE
define|#
directive|define
name|ONE
value|1250
end_define
begin_comment
DECL|macro|ONE
comment|/* token value of 1.0 exactly */
end_comment
begin_define
DECL|macro|RATIO
define|#
directive|define
name|RATIO
value|1.004
end_define
begin_comment
DECL|macro|RATIO
comment|/* nominal ratio for log part */
end_comment
begin_define
DECL|macro|CODE_MASK
define|#
directive|define
name|CODE_MASK
value|0x7ff
end_define
begin_comment
DECL|macro|CODE_MASK
comment|/* 11 bits. */
end_comment
begin_decl_stmt
DECL|variable|Fltsize
specifier|static
name|float
name|Fltsize
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|LogK1
DECL|variable|LogK2
specifier|static
name|float
name|LogK1
decl_stmt|,
name|LogK2
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|REPEAT
define|#
directive|define
name|REPEAT
parameter_list|(
name|n
parameter_list|,
name|op
parameter_list|)
value|{ int i; i=n; do { i--; op; } while (i>0); }
end_define
begin_function
specifier|static
name|void
DECL|function|horizontalAccumulateF
name|horizontalAccumulateF
parameter_list|(
name|uint16
modifier|*
name|wp
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|stride
parameter_list|,
name|float
modifier|*
name|op
parameter_list|,
name|float
modifier|*
name|ToLinearF
parameter_list|)
block|{
specifier|register
name|unsigned
name|int
name|cr
decl_stmt|,
name|cg
decl_stmt|,
name|cb
decl_stmt|,
name|ca
decl_stmt|,
name|mask
decl_stmt|;
specifier|register
name|float
name|t0
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|;
if|if
condition|(
name|n
operator|>=
name|stride
condition|)
block|{
name|mask
operator|=
name|CODE_MASK
expr_stmt|;
if|if
condition|(
name|stride
operator|==
literal|3
condition|)
block|{
name|t0
operator|=
name|ToLinearF
index|[
name|cr
operator|=
name|wp
index|[
literal|0
index|]
index|]
expr_stmt|;
name|t1
operator|=
name|ToLinearF
index|[
name|cg
operator|=
name|wp
index|[
literal|1
index|]
index|]
expr_stmt|;
name|t2
operator|=
name|ToLinearF
index|[
name|cb
operator|=
name|wp
index|[
literal|2
index|]
index|]
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|t0
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|t1
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|t2
expr_stmt|;
name|n
operator|-=
literal|3
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|wp
operator|+=
literal|3
expr_stmt|;
name|op
operator|+=
literal|3
expr_stmt|;
name|n
operator|-=
literal|3
expr_stmt|;
name|t0
operator|=
name|ToLinearF
index|[
operator|(
name|cr
operator|+=
name|wp
index|[
literal|0
index|]
operator|)
operator|&
name|mask
index|]
expr_stmt|;
name|t1
operator|=
name|ToLinearF
index|[
operator|(
name|cg
operator|+=
name|wp
index|[
literal|1
index|]
operator|)
operator|&
name|mask
index|]
expr_stmt|;
name|t2
operator|=
name|ToLinearF
index|[
operator|(
name|cb
operator|+=
name|wp
index|[
literal|2
index|]
operator|)
operator|&
name|mask
index|]
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|t0
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|t1
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|t2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|stride
operator|==
literal|4
condition|)
block|{
name|t0
operator|=
name|ToLinearF
index|[
name|cr
operator|=
name|wp
index|[
literal|0
index|]
index|]
expr_stmt|;
name|t1
operator|=
name|ToLinearF
index|[
name|cg
operator|=
name|wp
index|[
literal|1
index|]
index|]
expr_stmt|;
name|t2
operator|=
name|ToLinearF
index|[
name|cb
operator|=
name|wp
index|[
literal|2
index|]
index|]
expr_stmt|;
name|t3
operator|=
name|ToLinearF
index|[
name|ca
operator|=
name|wp
index|[
literal|3
index|]
index|]
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|t0
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|t1
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|t2
expr_stmt|;
name|op
index|[
literal|3
index|]
operator|=
name|t3
expr_stmt|;
name|n
operator|-=
literal|4
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|wp
operator|+=
literal|4
expr_stmt|;
name|op
operator|+=
literal|4
expr_stmt|;
name|n
operator|-=
literal|4
expr_stmt|;
name|t0
operator|=
name|ToLinearF
index|[
operator|(
name|cr
operator|+=
name|wp
index|[
literal|0
index|]
operator|)
operator|&
name|mask
index|]
expr_stmt|;
name|t1
operator|=
name|ToLinearF
index|[
operator|(
name|cg
operator|+=
name|wp
index|[
literal|1
index|]
operator|)
operator|&
name|mask
index|]
expr_stmt|;
name|t2
operator|=
name|ToLinearF
index|[
operator|(
name|cb
operator|+=
name|wp
index|[
literal|2
index|]
operator|)
operator|&
name|mask
index|]
expr_stmt|;
name|t3
operator|=
name|ToLinearF
index|[
operator|(
name|ca
operator|+=
name|wp
index|[
literal|3
index|]
operator|)
operator|&
name|mask
index|]
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|t0
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|t1
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|t2
expr_stmt|;
name|op
index|[
literal|3
index|]
operator|=
name|t3
expr_stmt|;
block|}
block|}
else|else
block|{
name|REPEAT
argument_list|(
argument|stride
argument_list|,
argument|*op = ToLinearF[*wp&mask]; wp++; op++
argument_list|)
name|n
operator|-=
name|stride
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|REPEAT
argument_list|(
argument|stride
argument_list|,
argument|wp[stride] += *wp; *op = ToLinearF[*wp&mask]; wp++; op++
argument_list|)
name|n
operator|-=
name|stride
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|horizontalAccumulate12
name|horizontalAccumulate12
parameter_list|(
name|uint16
modifier|*
name|wp
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|stride
parameter_list|,
name|int16
modifier|*
name|op
parameter_list|,
name|float
modifier|*
name|ToLinearF
parameter_list|)
block|{
specifier|register
name|unsigned
name|int
name|cr
decl_stmt|,
name|cg
decl_stmt|,
name|cb
decl_stmt|,
name|ca
decl_stmt|,
name|mask
decl_stmt|;
specifier|register
name|float
name|t0
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|;
DECL|macro|SCALE12
define|#
directive|define
name|SCALE12
value|2048.0F
DECL|macro|CLAMP12
define|#
directive|define
name|CLAMP12
parameter_list|(
name|t
parameter_list|)
value|(((t)< 3071) ? (uint16) (t) : 3071)
if|if
condition|(
name|n
operator|>=
name|stride
condition|)
block|{
name|mask
operator|=
name|CODE_MASK
expr_stmt|;
if|if
condition|(
name|stride
operator|==
literal|3
condition|)
block|{
name|t0
operator|=
name|ToLinearF
index|[
name|cr
operator|=
name|wp
index|[
literal|0
index|]
index|]
operator|*
name|SCALE12
expr_stmt|;
name|t1
operator|=
name|ToLinearF
index|[
name|cg
operator|=
name|wp
index|[
literal|1
index|]
index|]
operator|*
name|SCALE12
expr_stmt|;
name|t2
operator|=
name|ToLinearF
index|[
name|cb
operator|=
name|wp
index|[
literal|2
index|]
index|]
operator|*
name|SCALE12
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|CLAMP12
argument_list|(
name|t0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|CLAMP12
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|CLAMP12
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|n
operator|-=
literal|3
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|wp
operator|+=
literal|3
expr_stmt|;
name|op
operator|+=
literal|3
expr_stmt|;
name|n
operator|-=
literal|3
expr_stmt|;
name|t0
operator|=
name|ToLinearF
index|[
operator|(
name|cr
operator|+=
name|wp
index|[
literal|0
index|]
operator|)
operator|&
name|mask
index|]
operator|*
name|SCALE12
expr_stmt|;
name|t1
operator|=
name|ToLinearF
index|[
operator|(
name|cg
operator|+=
name|wp
index|[
literal|1
index|]
operator|)
operator|&
name|mask
index|]
operator|*
name|SCALE12
expr_stmt|;
name|t2
operator|=
name|ToLinearF
index|[
operator|(
name|cb
operator|+=
name|wp
index|[
literal|2
index|]
operator|)
operator|&
name|mask
index|]
operator|*
name|SCALE12
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|CLAMP12
argument_list|(
name|t0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|CLAMP12
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|CLAMP12
argument_list|(
name|t2
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|stride
operator|==
literal|4
condition|)
block|{
name|t0
operator|=
name|ToLinearF
index|[
name|cr
operator|=
name|wp
index|[
literal|0
index|]
index|]
operator|*
name|SCALE12
expr_stmt|;
name|t1
operator|=
name|ToLinearF
index|[
name|cg
operator|=
name|wp
index|[
literal|1
index|]
index|]
operator|*
name|SCALE12
expr_stmt|;
name|t2
operator|=
name|ToLinearF
index|[
name|cb
operator|=
name|wp
index|[
literal|2
index|]
index|]
operator|*
name|SCALE12
expr_stmt|;
name|t3
operator|=
name|ToLinearF
index|[
name|ca
operator|=
name|wp
index|[
literal|3
index|]
index|]
operator|*
name|SCALE12
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|CLAMP12
argument_list|(
name|t0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|CLAMP12
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|CLAMP12
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|op
index|[
literal|3
index|]
operator|=
name|CLAMP12
argument_list|(
name|t3
argument_list|)
expr_stmt|;
name|n
operator|-=
literal|4
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|wp
operator|+=
literal|4
expr_stmt|;
name|op
operator|+=
literal|4
expr_stmt|;
name|n
operator|-=
literal|4
expr_stmt|;
name|t0
operator|=
name|ToLinearF
index|[
operator|(
name|cr
operator|+=
name|wp
index|[
literal|0
index|]
operator|)
operator|&
name|mask
index|]
operator|*
name|SCALE12
expr_stmt|;
name|t1
operator|=
name|ToLinearF
index|[
operator|(
name|cg
operator|+=
name|wp
index|[
literal|1
index|]
operator|)
operator|&
name|mask
index|]
operator|*
name|SCALE12
expr_stmt|;
name|t2
operator|=
name|ToLinearF
index|[
operator|(
name|cb
operator|+=
name|wp
index|[
literal|2
index|]
operator|)
operator|&
name|mask
index|]
operator|*
name|SCALE12
expr_stmt|;
name|t3
operator|=
name|ToLinearF
index|[
operator|(
name|ca
operator|+=
name|wp
index|[
literal|3
index|]
operator|)
operator|&
name|mask
index|]
operator|*
name|SCALE12
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|CLAMP12
argument_list|(
name|t0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|CLAMP12
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|CLAMP12
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|op
index|[
literal|3
index|]
operator|=
name|CLAMP12
argument_list|(
name|t3
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|REPEAT
argument_list|(
argument|stride
argument_list|,
argument|t0 = ToLinearF[*wp&mask] * SCALE12;                            *op = CLAMP12(t0); wp++; op++
argument_list|)
name|n
operator|-=
name|stride
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|REPEAT
argument_list|(
argument|stride
argument_list|,
argument|wp[stride] += *wp; t0 = ToLinearF[wp[stride]&mask]*SCALE12; 		    *op = CLAMP12(t0);  wp++; op++
argument_list|)
name|n
operator|-=
name|stride
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|horizontalAccumulate16
name|horizontalAccumulate16
parameter_list|(
name|uint16
modifier|*
name|wp
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|stride
parameter_list|,
name|uint16
modifier|*
name|op
parameter_list|,
name|uint16
modifier|*
name|ToLinear16
parameter_list|)
block|{
specifier|register
name|unsigned
name|int
name|cr
decl_stmt|,
name|cg
decl_stmt|,
name|cb
decl_stmt|,
name|ca
decl_stmt|,
name|mask
decl_stmt|;
if|if
condition|(
name|n
operator|>=
name|stride
condition|)
block|{
name|mask
operator|=
name|CODE_MASK
expr_stmt|;
if|if
condition|(
name|stride
operator|==
literal|3
condition|)
block|{
name|op
index|[
literal|0
index|]
operator|=
name|ToLinear16
index|[
name|cr
operator|=
name|wp
index|[
literal|0
index|]
index|]
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|ToLinear16
index|[
name|cg
operator|=
name|wp
index|[
literal|1
index|]
index|]
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|ToLinear16
index|[
name|cb
operator|=
name|wp
index|[
literal|2
index|]
index|]
expr_stmt|;
name|n
operator|-=
literal|3
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|wp
operator|+=
literal|3
expr_stmt|;
name|op
operator|+=
literal|3
expr_stmt|;
name|n
operator|-=
literal|3
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|ToLinear16
index|[
operator|(
name|cr
operator|+=
name|wp
index|[
literal|0
index|]
operator|)
operator|&
name|mask
index|]
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|ToLinear16
index|[
operator|(
name|cg
operator|+=
name|wp
index|[
literal|1
index|]
operator|)
operator|&
name|mask
index|]
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|ToLinear16
index|[
operator|(
name|cb
operator|+=
name|wp
index|[
literal|2
index|]
operator|)
operator|&
name|mask
index|]
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|stride
operator|==
literal|4
condition|)
block|{
name|op
index|[
literal|0
index|]
operator|=
name|ToLinear16
index|[
name|cr
operator|=
name|wp
index|[
literal|0
index|]
index|]
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|ToLinear16
index|[
name|cg
operator|=
name|wp
index|[
literal|1
index|]
index|]
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|ToLinear16
index|[
name|cb
operator|=
name|wp
index|[
literal|2
index|]
index|]
expr_stmt|;
name|op
index|[
literal|3
index|]
operator|=
name|ToLinear16
index|[
name|ca
operator|=
name|wp
index|[
literal|3
index|]
index|]
expr_stmt|;
name|n
operator|-=
literal|4
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|wp
operator|+=
literal|4
expr_stmt|;
name|op
operator|+=
literal|4
expr_stmt|;
name|n
operator|-=
literal|4
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|ToLinear16
index|[
operator|(
name|cr
operator|+=
name|wp
index|[
literal|0
index|]
operator|)
operator|&
name|mask
index|]
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|ToLinear16
index|[
operator|(
name|cg
operator|+=
name|wp
index|[
literal|1
index|]
operator|)
operator|&
name|mask
index|]
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|ToLinear16
index|[
operator|(
name|cb
operator|+=
name|wp
index|[
literal|2
index|]
operator|)
operator|&
name|mask
index|]
expr_stmt|;
name|op
index|[
literal|3
index|]
operator|=
name|ToLinear16
index|[
operator|(
name|ca
operator|+=
name|wp
index|[
literal|3
index|]
operator|)
operator|&
name|mask
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|REPEAT
argument_list|(
argument|stride
argument_list|,
argument|*op = ToLinear16[*wp&mask]; wp++; op++
argument_list|)
name|n
operator|-=
name|stride
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|REPEAT
argument_list|(
argument|stride
argument_list|,
argument|wp[stride] += *wp; *op = ToLinear16[*wp&mask]; wp++; op++
argument_list|)
name|n
operator|-=
name|stride
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*   * Returns the log encoded 11-bit values with the horizontal  * differencing undone.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|horizontalAccumulate11
name|horizontalAccumulate11
parameter_list|(
name|uint16
modifier|*
name|wp
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|stride
parameter_list|,
name|uint16
modifier|*
name|op
parameter_list|)
block|{
specifier|register
name|unsigned
name|int
name|cr
decl_stmt|,
name|cg
decl_stmt|,
name|cb
decl_stmt|,
name|ca
decl_stmt|,
name|mask
decl_stmt|;
if|if
condition|(
name|n
operator|>=
name|stride
condition|)
block|{
name|mask
operator|=
name|CODE_MASK
expr_stmt|;
if|if
condition|(
name|stride
operator|==
literal|3
condition|)
block|{
name|op
index|[
literal|0
index|]
operator|=
name|cr
operator|=
name|wp
index|[
literal|0
index|]
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|cg
operator|=
name|wp
index|[
literal|1
index|]
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|cb
operator|=
name|wp
index|[
literal|2
index|]
expr_stmt|;
name|n
operator|-=
literal|3
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|wp
operator|+=
literal|3
expr_stmt|;
name|op
operator|+=
literal|3
expr_stmt|;
name|n
operator|-=
literal|3
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
operator|(
name|cr
operator|+=
name|wp
index|[
literal|0
index|]
operator|)
operator|&
name|mask
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
operator|(
name|cg
operator|+=
name|wp
index|[
literal|1
index|]
operator|)
operator|&
name|mask
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
operator|(
name|cb
operator|+=
name|wp
index|[
literal|2
index|]
operator|)
operator|&
name|mask
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|stride
operator|==
literal|4
condition|)
block|{
name|op
index|[
literal|0
index|]
operator|=
name|cr
operator|=
name|wp
index|[
literal|0
index|]
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|cg
operator|=
name|wp
index|[
literal|1
index|]
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|cb
operator|=
name|wp
index|[
literal|2
index|]
expr_stmt|;
name|op
index|[
literal|3
index|]
operator|=
name|ca
operator|=
name|wp
index|[
literal|3
index|]
expr_stmt|;
name|n
operator|-=
literal|4
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|wp
operator|+=
literal|4
expr_stmt|;
name|op
operator|+=
literal|4
expr_stmt|;
name|n
operator|-=
literal|4
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
operator|(
name|cr
operator|+=
name|wp
index|[
literal|0
index|]
operator|)
operator|&
name|mask
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
operator|(
name|cg
operator|+=
name|wp
index|[
literal|1
index|]
operator|)
operator|&
name|mask
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
operator|(
name|cb
operator|+=
name|wp
index|[
literal|2
index|]
operator|)
operator|&
name|mask
expr_stmt|;
name|op
index|[
literal|3
index|]
operator|=
operator|(
name|ca
operator|+=
name|wp
index|[
literal|3
index|]
operator|)
operator|&
name|mask
expr_stmt|;
block|}
block|}
else|else
block|{
name|REPEAT
argument_list|(
argument|stride
argument_list|,
argument|*op = *wp&mask; wp++; op++
argument_list|)
name|n
operator|-=
name|stride
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|REPEAT
argument_list|(
argument|stride
argument_list|,
argument|wp[stride] += *wp; *op = *wp&mask; wp++; op++
argument_list|)
name|n
operator|-=
name|stride
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|horizontalAccumulate8
name|horizontalAccumulate8
parameter_list|(
name|uint16
modifier|*
name|wp
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|stride
parameter_list|,
name|unsigned
name|char
modifier|*
name|op
parameter_list|,
name|unsigned
name|char
modifier|*
name|ToLinear8
parameter_list|)
block|{
specifier|register
name|unsigned
name|int
name|cr
decl_stmt|,
name|cg
decl_stmt|,
name|cb
decl_stmt|,
name|ca
decl_stmt|,
name|mask
decl_stmt|;
if|if
condition|(
name|n
operator|>=
name|stride
condition|)
block|{
name|mask
operator|=
name|CODE_MASK
expr_stmt|;
if|if
condition|(
name|stride
operator|==
literal|3
condition|)
block|{
name|op
index|[
literal|0
index|]
operator|=
name|ToLinear8
index|[
name|cr
operator|=
name|wp
index|[
literal|0
index|]
index|]
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|ToLinear8
index|[
name|cg
operator|=
name|wp
index|[
literal|1
index|]
index|]
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|ToLinear8
index|[
name|cb
operator|=
name|wp
index|[
literal|2
index|]
index|]
expr_stmt|;
name|n
operator|-=
literal|3
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|n
operator|-=
literal|3
expr_stmt|;
name|wp
operator|+=
literal|3
expr_stmt|;
name|op
operator|+=
literal|3
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|ToLinear8
index|[
operator|(
name|cr
operator|+=
name|wp
index|[
literal|0
index|]
operator|)
operator|&
name|mask
index|]
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|ToLinear8
index|[
operator|(
name|cg
operator|+=
name|wp
index|[
literal|1
index|]
operator|)
operator|&
name|mask
index|]
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|ToLinear8
index|[
operator|(
name|cb
operator|+=
name|wp
index|[
literal|2
index|]
operator|)
operator|&
name|mask
index|]
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|stride
operator|==
literal|4
condition|)
block|{
name|op
index|[
literal|0
index|]
operator|=
name|ToLinear8
index|[
name|cr
operator|=
name|wp
index|[
literal|0
index|]
index|]
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|ToLinear8
index|[
name|cg
operator|=
name|wp
index|[
literal|1
index|]
index|]
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|ToLinear8
index|[
name|cb
operator|=
name|wp
index|[
literal|2
index|]
index|]
expr_stmt|;
name|op
index|[
literal|3
index|]
operator|=
name|ToLinear8
index|[
name|ca
operator|=
name|wp
index|[
literal|3
index|]
index|]
expr_stmt|;
name|n
operator|-=
literal|4
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|n
operator|-=
literal|4
expr_stmt|;
name|wp
operator|+=
literal|4
expr_stmt|;
name|op
operator|+=
literal|4
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|ToLinear8
index|[
operator|(
name|cr
operator|+=
name|wp
index|[
literal|0
index|]
operator|)
operator|&
name|mask
index|]
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|ToLinear8
index|[
operator|(
name|cg
operator|+=
name|wp
index|[
literal|1
index|]
operator|)
operator|&
name|mask
index|]
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|ToLinear8
index|[
operator|(
name|cb
operator|+=
name|wp
index|[
literal|2
index|]
operator|)
operator|&
name|mask
index|]
expr_stmt|;
name|op
index|[
literal|3
index|]
operator|=
name|ToLinear8
index|[
operator|(
name|ca
operator|+=
name|wp
index|[
literal|3
index|]
operator|)
operator|&
name|mask
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|REPEAT
argument_list|(
argument|stride
argument_list|,
argument|*op = ToLinear8[*wp&mask]; wp++; op++
argument_list|)
name|n
operator|-=
name|stride
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|REPEAT
argument_list|(
argument|stride
argument_list|,
argument|wp[stride] += *wp; *op = ToLinear8[*wp&mask]; wp++; op++
argument_list|)
name|n
operator|-=
name|stride
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|horizontalAccumulate8abgr
name|horizontalAccumulate8abgr
parameter_list|(
name|uint16
modifier|*
name|wp
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|stride
parameter_list|,
name|unsigned
name|char
modifier|*
name|op
parameter_list|,
name|unsigned
name|char
modifier|*
name|ToLinear8
parameter_list|)
block|{
specifier|register
name|unsigned
name|int
name|cr
decl_stmt|,
name|cg
decl_stmt|,
name|cb
decl_stmt|,
name|ca
decl_stmt|,
name|mask
decl_stmt|;
specifier|register
name|unsigned
name|char
name|t0
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|;
if|if
condition|(
name|n
operator|>=
name|stride
condition|)
block|{
name|mask
operator|=
name|CODE_MASK
expr_stmt|;
if|if
condition|(
name|stride
operator|==
literal|3
condition|)
block|{
name|op
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|t1
operator|=
name|ToLinear8
index|[
name|cb
operator|=
name|wp
index|[
literal|2
index|]
index|]
expr_stmt|;
name|t2
operator|=
name|ToLinear8
index|[
name|cg
operator|=
name|wp
index|[
literal|1
index|]
index|]
expr_stmt|;
name|t3
operator|=
name|ToLinear8
index|[
name|cr
operator|=
name|wp
index|[
literal|0
index|]
index|]
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|t1
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|t2
expr_stmt|;
name|op
index|[
literal|3
index|]
operator|=
name|t3
expr_stmt|;
name|n
operator|-=
literal|3
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|n
operator|-=
literal|3
expr_stmt|;
name|wp
operator|+=
literal|3
expr_stmt|;
name|op
operator|+=
literal|4
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|t1
operator|=
name|ToLinear8
index|[
operator|(
name|cb
operator|+=
name|wp
index|[
literal|2
index|]
operator|)
operator|&
name|mask
index|]
expr_stmt|;
name|t2
operator|=
name|ToLinear8
index|[
operator|(
name|cg
operator|+=
name|wp
index|[
literal|1
index|]
operator|)
operator|&
name|mask
index|]
expr_stmt|;
name|t3
operator|=
name|ToLinear8
index|[
operator|(
name|cr
operator|+=
name|wp
index|[
literal|0
index|]
operator|)
operator|&
name|mask
index|]
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|t1
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|t2
expr_stmt|;
name|op
index|[
literal|3
index|]
operator|=
name|t3
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|stride
operator|==
literal|4
condition|)
block|{
name|t0
operator|=
name|ToLinear8
index|[
name|ca
operator|=
name|wp
index|[
literal|3
index|]
index|]
expr_stmt|;
name|t1
operator|=
name|ToLinear8
index|[
name|cb
operator|=
name|wp
index|[
literal|2
index|]
index|]
expr_stmt|;
name|t2
operator|=
name|ToLinear8
index|[
name|cg
operator|=
name|wp
index|[
literal|1
index|]
index|]
expr_stmt|;
name|t3
operator|=
name|ToLinear8
index|[
name|cr
operator|=
name|wp
index|[
literal|0
index|]
index|]
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|t0
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|t1
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|t2
expr_stmt|;
name|op
index|[
literal|3
index|]
operator|=
name|t3
expr_stmt|;
name|n
operator|-=
literal|4
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|n
operator|-=
literal|4
expr_stmt|;
name|wp
operator|+=
literal|4
expr_stmt|;
name|op
operator|+=
literal|4
expr_stmt|;
name|t0
operator|=
name|ToLinear8
index|[
operator|(
name|ca
operator|+=
name|wp
index|[
literal|3
index|]
operator|)
operator|&
name|mask
index|]
expr_stmt|;
name|t1
operator|=
name|ToLinear8
index|[
operator|(
name|cb
operator|+=
name|wp
index|[
literal|2
index|]
operator|)
operator|&
name|mask
index|]
expr_stmt|;
name|t2
operator|=
name|ToLinear8
index|[
operator|(
name|cg
operator|+=
name|wp
index|[
literal|1
index|]
operator|)
operator|&
name|mask
index|]
expr_stmt|;
name|t3
operator|=
name|ToLinear8
index|[
operator|(
name|cr
operator|+=
name|wp
index|[
literal|0
index|]
operator|)
operator|&
name|mask
index|]
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|t0
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|t1
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|t2
expr_stmt|;
name|op
index|[
literal|3
index|]
operator|=
name|t3
expr_stmt|;
block|}
block|}
else|else
block|{
name|REPEAT
argument_list|(
argument|stride
argument_list|,
argument|*op = ToLinear8[*wp&mask]; wp++; op++
argument_list|)
name|n
operator|-=
name|stride
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|REPEAT
argument_list|(
argument|stride
argument_list|,
argument|wp[stride] += *wp; *op = ToLinear8[*wp&mask]; wp++; op++
argument_list|)
name|n
operator|-=
name|stride
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*  * State block for each open TIFF  * file using PixarLog compression/decompression.  */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|predict
name|TIFFPredictorState
name|predict
decl_stmt|;
DECL|member|stream
name|z_stream
name|stream
decl_stmt|;
DECL|member|tbuf
name|uint16
modifier|*
name|tbuf
decl_stmt|;
DECL|member|stride
name|uint16
name|stride
decl_stmt|;
DECL|member|state
name|int
name|state
decl_stmt|;
DECL|member|user_datafmt
name|int
name|user_datafmt
decl_stmt|;
DECL|member|quality
name|int
name|quality
decl_stmt|;
DECL|macro|PLSTATE_INIT
define|#
directive|define
name|PLSTATE_INIT
value|1
DECL|member|vgetparent
name|TIFFVSetMethod
name|vgetparent
decl_stmt|;
comment|/* super-class method */
DECL|member|vsetparent
name|TIFFVSetMethod
name|vsetparent
decl_stmt|;
comment|/* super-class method */
DECL|member|ToLinearF
name|float
modifier|*
name|ToLinearF
decl_stmt|;
DECL|member|ToLinear16
name|uint16
modifier|*
name|ToLinear16
decl_stmt|;
DECL|member|ToLinear8
name|unsigned
name|char
modifier|*
name|ToLinear8
decl_stmt|;
DECL|member|FromLT2
name|uint16
modifier|*
name|FromLT2
decl_stmt|;
DECL|member|From14
name|uint16
modifier|*
name|From14
decl_stmt|;
comment|/* Really for 16-bit data, but we shift down 2 */
DECL|member|From8
name|uint16
modifier|*
name|From8
decl_stmt|;
block|}
DECL|typedef|PixarLogState
name|PixarLogState
typedef|;
end_typedef
begin_function
specifier|static
name|int
DECL|function|PixarLogMakeTables
name|PixarLogMakeTables
parameter_list|(
name|PixarLogState
modifier|*
name|sp
parameter_list|)
block|{
comment|/*  *    We make several tables here to convert between various external  *    representations (float, 16-bit, and 8-bit) and the internal  *    11-bit companded representation.  The 11-bit representation has two  *    distinct regions.  A linear bottom end up through .018316 in steps  *    of about .000073, and a region of constant ratio up to about 25.  *    These floating point numbers are stored in the main table ToLinearF.   *    All other tables are derived from this one.  The tables (and the  *    ratios) are continuous at the internal seam.  */
name|int
name|nlin
decl_stmt|,
name|lt2size
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|double
name|b
decl_stmt|,
name|c
decl_stmt|,
name|linstep
decl_stmt|,
name|v
decl_stmt|;
name|float
modifier|*
name|ToLinearF
decl_stmt|;
name|uint16
modifier|*
name|ToLinear16
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ToLinear8
decl_stmt|;
name|uint16
modifier|*
name|FromLT2
decl_stmt|;
name|uint16
modifier|*
name|From14
decl_stmt|;
comment|/* Really for 16-bit data, but we shift down 2 */
name|uint16
modifier|*
name|From8
decl_stmt|;
name|c
operator|=
name|log
argument_list|(
name|RATIO
argument_list|)
expr_stmt|;
name|nlin
operator|=
call|(
name|int
call|)
argument_list|(
literal|1.
operator|/
name|c
argument_list|)
expr_stmt|;
comment|/* nlin must be an integer */
name|c
operator|=
literal|1.
operator|/
name|nlin
expr_stmt|;
name|b
operator|=
name|exp
argument_list|(
operator|-
name|c
operator|*
name|ONE
argument_list|)
expr_stmt|;
comment|/* multiplicative scale factor [b*exp(c*ONE) = 1] */
name|linstep
operator|=
name|b
operator|*
name|c
operator|*
name|exp
argument_list|(
literal|1.
argument_list|)
expr_stmt|;
name|LogK1
operator|=
call|(
name|float
call|)
argument_list|(
literal|1.
operator|/
name|c
argument_list|)
expr_stmt|;
comment|/* if (v>= 2)  token = k1*log(v*k2) */
name|LogK2
operator|=
call|(
name|float
call|)
argument_list|(
literal|1.
operator|/
name|b
argument_list|)
expr_stmt|;
name|lt2size
operator|=
call|(
name|int
call|)
argument_list|(
literal|2.
operator|/
name|linstep
argument_list|)
operator|+
literal|1
expr_stmt|;
name|FromLT2
operator|=
operator|(
name|uint16
operator|*
operator|)
name|_TIFFmalloc
argument_list|(
name|lt2size
operator|*
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
argument_list|)
expr_stmt|;
name|From14
operator|=
operator|(
name|uint16
operator|*
operator|)
name|_TIFFmalloc
argument_list|(
literal|16384
operator|*
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
argument_list|)
expr_stmt|;
name|From8
operator|=
operator|(
name|uint16
operator|*
operator|)
name|_TIFFmalloc
argument_list|(
literal|256
operator|*
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
argument_list|)
expr_stmt|;
name|ToLinearF
operator|=
operator|(
name|float
operator|*
operator|)
name|_TIFFmalloc
argument_list|(
name|TSIZEP1
operator|*
sizeof|sizeof
argument_list|(
name|float
argument_list|)
argument_list|)
expr_stmt|;
name|ToLinear16
operator|=
operator|(
name|uint16
operator|*
operator|)
name|_TIFFmalloc
argument_list|(
name|TSIZEP1
operator|*
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
argument_list|)
expr_stmt|;
name|ToLinear8
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|_TIFFmalloc
argument_list|(
name|TSIZEP1
operator|*
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FromLT2
operator|==
name|NULL
operator|||
name|From14
operator|==
name|NULL
operator|||
name|From8
operator|==
name|NULL
operator|||
name|ToLinearF
operator|==
name|NULL
operator|||
name|ToLinear16
operator|==
name|NULL
operator|||
name|ToLinear8
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|FromLT2
condition|)
name|_TIFFfree
argument_list|(
name|FromLT2
argument_list|)
expr_stmt|;
if|if
condition|(
name|From14
condition|)
name|_TIFFfree
argument_list|(
name|From14
argument_list|)
expr_stmt|;
if|if
condition|(
name|From8
condition|)
name|_TIFFfree
argument_list|(
name|From8
argument_list|)
expr_stmt|;
if|if
condition|(
name|ToLinearF
condition|)
name|_TIFFfree
argument_list|(
name|ToLinearF
argument_list|)
expr_stmt|;
if|if
condition|(
name|ToLinear16
condition|)
name|_TIFFfree
argument_list|(
name|ToLinear16
argument_list|)
expr_stmt|;
if|if
condition|(
name|ToLinear8
condition|)
name|_TIFFfree
argument_list|(
name|ToLinear8
argument_list|)
expr_stmt|;
name|sp
operator|->
name|FromLT2
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|From14
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|From8
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|ToLinearF
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|ToLinear16
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|ToLinear8
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlin
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|=
name|i
operator|*
name|linstep
expr_stmt|;
name|ToLinearF
index|[
name|j
operator|++
index|]
operator|=
operator|(
name|float
operator|)
name|v
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|nlin
init|;
name|i
operator|<
name|TSIZE
condition|;
name|i
operator|++
control|)
name|ToLinearF
index|[
name|j
operator|++
index|]
operator|=
call|(
name|float
call|)
argument_list|(
name|b
operator|*
name|exp
argument_list|(
name|c
operator|*
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|ToLinearF
index|[
literal|2048
index|]
operator|=
name|ToLinearF
index|[
literal|2047
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TSIZEP1
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|=
name|ToLinearF
index|[
name|i
index|]
operator|*
literal|65535.0
operator|+
literal|0.5
expr_stmt|;
name|ToLinear16
index|[
name|i
index|]
operator|=
operator|(
name|v
operator|>
literal|65535.0
operator|)
condition|?
literal|65535
else|:
operator|(
name|uint16
operator|)
name|v
expr_stmt|;
name|v
operator|=
name|ToLinearF
index|[
name|i
index|]
operator|*
literal|255.0
operator|+
literal|0.5
expr_stmt|;
name|ToLinear8
index|[
name|i
index|]
operator|=
operator|(
name|v
operator|>
literal|255.0
operator|)
condition|?
literal|255
else|:
operator|(
name|unsigned
name|char
operator|)
name|v
expr_stmt|;
block|}
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lt2size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|*
name|linstep
operator|)
operator|*
operator|(
name|i
operator|*
name|linstep
operator|)
operator|>
name|ToLinearF
index|[
name|j
index|]
operator|*
name|ToLinearF
index|[
name|j
operator|+
literal|1
index|]
condition|)
name|j
operator|++
expr_stmt|;
name|FromLT2
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
block|}
comment|/*      * Since we lose info anyway on 16-bit data, we set up a 14-bit      * table and shift 16-bit values down two bits on input.      * saves a little table space.      */
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16384
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
operator|(
name|i
operator|/
literal|16383.
operator|)
operator|*
operator|(
name|i
operator|/
literal|16383.
operator|)
operator|>
name|ToLinearF
index|[
name|j
index|]
operator|*
name|ToLinearF
index|[
name|j
operator|+
literal|1
index|]
condition|)
name|j
operator|++
expr_stmt|;
name|From14
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
block|}
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
operator|(
name|i
operator|/
literal|255.
operator|)
operator|*
operator|(
name|i
operator|/
literal|255.
operator|)
operator|>
name|ToLinearF
index|[
name|j
index|]
operator|*
name|ToLinearF
index|[
name|j
operator|+
literal|1
index|]
condition|)
name|j
operator|++
expr_stmt|;
name|From8
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
block|}
name|Fltsize
operator|=
call|(
name|float
call|)
argument_list|(
name|lt2size
operator|/
literal|2
argument_list|)
expr_stmt|;
name|sp
operator|->
name|ToLinearF
operator|=
name|ToLinearF
expr_stmt|;
name|sp
operator|->
name|ToLinear16
operator|=
name|ToLinear16
expr_stmt|;
name|sp
operator|->
name|ToLinear8
operator|=
name|ToLinear8
expr_stmt|;
name|sp
operator|->
name|FromLT2
operator|=
name|FromLT2
expr_stmt|;
name|sp
operator|->
name|From14
operator|=
name|From14
expr_stmt|;
name|sp
operator|->
name|From8
operator|=
name|From8
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_define
DECL|macro|DecoderState
define|#
directive|define
name|DecoderState
parameter_list|(
name|tif
parameter_list|)
value|((PixarLogState*) (tif)->tif_data)
end_define
begin_define
DECL|macro|EncoderState
define|#
directive|define
name|EncoderState
parameter_list|(
name|tif
parameter_list|)
value|((PixarLogState*) (tif)->tif_data)
end_define
begin_function_decl
specifier|static
name|int
name|PixarLogEncode
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|tidata_t
parameter_list|,
name|tsize_t
parameter_list|,
name|tsample_t
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|PixarLogDecode
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|tidata_t
parameter_list|,
name|tsize_t
parameter_list|,
name|tsample_t
parameter_list|)
function_decl|;
end_function_decl
begin_define
DECL|macro|PIXARLOGDATAFMT_UNKNOWN
define|#
directive|define
name|PIXARLOGDATAFMT_UNKNOWN
value|-1
end_define
begin_function
specifier|static
name|int
DECL|function|PixarLogGuessDataFmt
name|PixarLogGuessDataFmt
parameter_list|(
name|TIFFDirectory
modifier|*
name|td
parameter_list|)
block|{
name|int
name|guess
init|=
name|PIXARLOGDATAFMT_UNKNOWN
decl_stmt|;
name|int
name|format
init|=
name|td
operator|->
name|td_sampleformat
decl_stmt|;
comment|/* If the user didn't tell us his datafmt, 	 * take our best guess from the bitspersample. 	 */
switch|switch
condition|(
name|td
operator|->
name|td_bitspersample
condition|)
block|{
case|case
literal|32
case|:
if|if
condition|(
name|format
operator|==
name|SAMPLEFORMAT_IEEEFP
condition|)
name|guess
operator|=
name|PIXARLOGDATAFMT_FLOAT
expr_stmt|;
break|break;
case|case
literal|16
case|:
if|if
condition|(
name|format
operator|==
name|SAMPLEFORMAT_VOID
operator|||
name|format
operator|==
name|SAMPLEFORMAT_UINT
condition|)
name|guess
operator|=
name|PIXARLOGDATAFMT_16BIT
expr_stmt|;
break|break;
case|case
literal|12
case|:
if|if
condition|(
name|format
operator|==
name|SAMPLEFORMAT_VOID
operator|||
name|format
operator|==
name|SAMPLEFORMAT_INT
condition|)
name|guess
operator|=
name|PIXARLOGDATAFMT_12BITPICIO
expr_stmt|;
break|break;
case|case
literal|11
case|:
if|if
condition|(
name|format
operator|==
name|SAMPLEFORMAT_VOID
operator|||
name|format
operator|==
name|SAMPLEFORMAT_UINT
condition|)
name|guess
operator|=
name|PIXARLOGDATAFMT_11BITLOG
expr_stmt|;
break|break;
case|case
literal|8
case|:
if|if
condition|(
name|format
operator|==
name|SAMPLEFORMAT_VOID
operator|||
name|format
operator|==
name|SAMPLEFORMAT_UINT
condition|)
name|guess
operator|=
name|PIXARLOGDATAFMT_8BIT
expr_stmt|;
break|break;
block|}
return|return
name|guess
return|;
block|}
end_function
begin_function
specifier|static
name|uint32
DECL|function|multiply
name|multiply
parameter_list|(
name|size_t
name|m1
parameter_list|,
name|size_t
name|m2
parameter_list|)
block|{
name|uint32
name|bytes
init|=
name|m1
operator|*
name|m2
decl_stmt|;
if|if
condition|(
name|m1
operator|&&
name|bytes
operator|/
name|m1
operator|!=
name|m2
condition|)
name|bytes
operator|=
literal|0
expr_stmt|;
return|return
name|bytes
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|PixarLogSetupDecode
name|PixarLogSetupDecode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|PixarLogState
modifier|*
name|sp
init|=
name|DecoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|tsize_t
name|tbuf_size
decl_stmt|;
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|"PixarLogSetupDecode"
decl_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Make sure no byte swapping happens on the data 	 * after decompression. */
name|tif
operator|->
name|tif_postdecode
operator|=
name|_TIFFNoPostDecode
expr_stmt|;
comment|/* for some reason, we can't do this in TIFFInitPixarLog */
name|sp
operator|->
name|stride
operator|=
operator|(
name|td
operator|->
name|td_planarconfig
operator|==
name|PLANARCONFIG_CONTIG
condition|?
name|td
operator|->
name|td_samplesperpixel
else|:
literal|1
operator|)
expr_stmt|;
name|tbuf_size
operator|=
name|multiply
argument_list|(
name|multiply
argument_list|(
name|multiply
argument_list|(
name|sp
operator|->
name|stride
argument_list|,
name|td
operator|->
name|td_imagewidth
argument_list|)
argument_list|,
name|td
operator|->
name|td_rowsperstrip
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tbuf_size
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sp
operator|->
name|tbuf
operator|=
operator|(
name|uint16
operator|*
operator|)
name|_TIFFmalloc
argument_list|(
name|tbuf_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|tbuf
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|user_datafmt
operator|==
name|PIXARLOGDATAFMT_UNKNOWN
condition|)
name|sp
operator|->
name|user_datafmt
operator|=
name|PixarLogGuessDataFmt
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|user_datafmt
operator|==
name|PIXARLOGDATAFMT_UNKNOWN
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"PixarLog compression can't handle bits depth/data format combination (depth: %d)"
argument_list|,
name|td
operator|->
name|td_bitspersample
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|inflateInit
argument_list|(
operator|&
name|sp
operator|->
name|stream
argument_list|)
operator|!=
name|Z_OK
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: %s"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
name|sp
operator|->
name|stream
operator|.
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|sp
operator|->
name|state
operator||=
name|PLSTATE_INIT
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*  * Setup state for decoding a strip.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|PixarLogPreDecode
name|PixarLogPreDecode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|PixarLogState
modifier|*
name|sp
init|=
name|DecoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|s
expr_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sp
operator|->
name|stream
operator|.
name|next_in
operator|=
name|tif
operator|->
name|tif_rawdata
expr_stmt|;
name|sp
operator|->
name|stream
operator|.
name|avail_in
operator|=
name|tif
operator|->
name|tif_rawcc
expr_stmt|;
return|return
operator|(
name|inflateReset
argument_list|(
operator|&
name|sp
operator|->
name|stream
argument_list|)
operator|==
name|Z_OK
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|PixarLogDecode
name|PixarLogDecode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|op
parameter_list|,
name|tsize_t
name|occ
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|PixarLogState
modifier|*
name|sp
init|=
name|DecoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|"PixarLogDecode"
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nsamples
decl_stmt|,
name|llen
decl_stmt|;
name|uint16
modifier|*
name|up
decl_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|user_datafmt
condition|)
block|{
case|case
name|PIXARLOGDATAFMT_FLOAT
case|:
name|nsamples
operator|=
name|occ
operator|/
sizeof|sizeof
argument_list|(
name|float
argument_list|)
expr_stmt|;
comment|/* XXX float == 32 bits */
break|break;
case|case
name|PIXARLOGDATAFMT_16BIT
case|:
case|case
name|PIXARLOGDATAFMT_12BITPICIO
case|:
case|case
name|PIXARLOGDATAFMT_11BITLOG
case|:
name|nsamples
operator|=
name|occ
operator|/
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
expr_stmt|;
comment|/* XXX uint16 == 16 bits */
break|break;
case|case
name|PIXARLOGDATAFMT_8BIT
case|:
case|case
name|PIXARLOGDATAFMT_8BITABGR
case|:
name|nsamples
operator|=
name|occ
expr_stmt|;
break|break;
default|default:
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"%d bit input not supported in PixarLog"
argument_list|,
name|td
operator|->
name|td_bitspersample
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|llen
operator|=
name|sp
operator|->
name|stride
operator|*
name|td
operator|->
name|td_imagewidth
expr_stmt|;
operator|(
name|void
operator|)
name|s
expr_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sp
operator|->
name|stream
operator|.
name|next_out
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|sp
operator|->
name|tbuf
expr_stmt|;
name|sp
operator|->
name|stream
operator|.
name|avail_out
operator|=
name|nsamples
operator|*
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
expr_stmt|;
do|do
block|{
name|int
name|state
init|=
name|inflate
argument_list|(
operator|&
name|sp
operator|->
name|stream
argument_list|,
name|Z_PARTIAL_FLUSH
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|Z_STREAM_END
condition|)
block|{
break|break;
comment|/* XXX */
block|}
if|if
condition|(
name|state
operator|==
name|Z_DATA_ERROR
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Decoding error at scanline %d, %s"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
name|tif
operator|->
name|tif_row
argument_list|,
name|sp
operator|->
name|stream
operator|.
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|inflateSync
argument_list|(
operator|&
name|sp
operator|->
name|stream
argument_list|)
operator|!=
name|Z_OK
condition|)
return|return
operator|(
literal|0
operator|)
return|;
continue|continue;
block|}
if|if
condition|(
name|state
operator|!=
name|Z_OK
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: zlib error: %s"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
name|sp
operator|->
name|stream
operator|.
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
do|while
condition|(
name|sp
operator|->
name|stream
operator|.
name|avail_out
operator|>
literal|0
condition|)
do|;
comment|/* hopefully, we got all the bytes we needed */
if|if
condition|(
name|sp
operator|->
name|stream
operator|.
name|avail_out
operator|!=
literal|0
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Not enough data at scanline %d (short %d bytes)"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
name|tif
operator|->
name|tif_row
argument_list|,
name|sp
operator|->
name|stream
operator|.
name|avail_out
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|up
operator|=
name|sp
operator|->
name|tbuf
expr_stmt|;
comment|/* Swap bytes in the data if from a different endian machine. */
if|if
condition|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_SWAB
condition|)
name|TIFFSwabArrayOfShort
argument_list|(
name|up
argument_list|,
name|nsamples
argument_list|)
expr_stmt|;
comment|/*  	 * if llen is not an exact multiple of nsamples, the decode operation 	 * may overflow the output buffer, so truncate it enough to prevent 	 * that but still salvage as much data as possible. 	 */
if|if
condition|(
name|nsamples
operator|%
name|llen
condition|)
block|{
name|TIFFWarningExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: stride %d is not a multiple of sample count, "
literal|"%d, data truncated."
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
name|llen
argument_list|,
name|nsamples
argument_list|)
expr_stmt|;
name|nsamples
operator|-=
name|nsamples
operator|%
name|llen
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsamples
condition|;
name|i
operator|+=
name|llen
operator|,
name|up
operator|+=
name|llen
control|)
block|{
switch|switch
condition|(
name|sp
operator|->
name|user_datafmt
condition|)
block|{
case|case
name|PIXARLOGDATAFMT_FLOAT
case|:
name|horizontalAccumulateF
argument_list|(
name|up
argument_list|,
name|llen
argument_list|,
name|sp
operator|->
name|stride
argument_list|,
operator|(
name|float
operator|*
operator|)
name|op
argument_list|,
name|sp
operator|->
name|ToLinearF
argument_list|)
expr_stmt|;
name|op
operator|+=
name|llen
operator|*
sizeof|sizeof
argument_list|(
name|float
argument_list|)
expr_stmt|;
break|break;
case|case
name|PIXARLOGDATAFMT_16BIT
case|:
name|horizontalAccumulate16
argument_list|(
name|up
argument_list|,
name|llen
argument_list|,
name|sp
operator|->
name|stride
argument_list|,
operator|(
name|uint16
operator|*
operator|)
name|op
argument_list|,
name|sp
operator|->
name|ToLinear16
argument_list|)
expr_stmt|;
name|op
operator|+=
name|llen
operator|*
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
expr_stmt|;
break|break;
case|case
name|PIXARLOGDATAFMT_12BITPICIO
case|:
name|horizontalAccumulate12
argument_list|(
name|up
argument_list|,
name|llen
argument_list|,
name|sp
operator|->
name|stride
argument_list|,
operator|(
name|int16
operator|*
operator|)
name|op
argument_list|,
name|sp
operator|->
name|ToLinearF
argument_list|)
expr_stmt|;
name|op
operator|+=
name|llen
operator|*
sizeof|sizeof
argument_list|(
name|int16
argument_list|)
expr_stmt|;
break|break;
case|case
name|PIXARLOGDATAFMT_11BITLOG
case|:
name|horizontalAccumulate11
argument_list|(
name|up
argument_list|,
name|llen
argument_list|,
name|sp
operator|->
name|stride
argument_list|,
operator|(
name|uint16
operator|*
operator|)
name|op
argument_list|)
expr_stmt|;
name|op
operator|+=
name|llen
operator|*
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
expr_stmt|;
break|break;
case|case
name|PIXARLOGDATAFMT_8BIT
case|:
name|horizontalAccumulate8
argument_list|(
name|up
argument_list|,
name|llen
argument_list|,
name|sp
operator|->
name|stride
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|op
argument_list|,
name|sp
operator|->
name|ToLinear8
argument_list|)
expr_stmt|;
name|op
operator|+=
name|llen
operator|*
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
expr_stmt|;
break|break;
case|case
name|PIXARLOGDATAFMT_8BITABGR
case|:
name|horizontalAccumulate8abgr
argument_list|(
name|up
argument_list|,
name|llen
argument_list|,
name|sp
operator|->
name|stride
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|op
argument_list|,
name|sp
operator|->
name|ToLinear8
argument_list|)
expr_stmt|;
name|op
operator|+=
name|llen
operator|*
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
expr_stmt|;
break|break;
default|default:
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"PixarLogDecode: unsupported bits/sample: %d"
argument_list|,
name|td
operator|->
name|td_bitspersample
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|PixarLogSetupEncode
name|PixarLogSetupEncode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|PixarLogState
modifier|*
name|sp
init|=
name|EncoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|tsize_t
name|tbuf_size
decl_stmt|;
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|"PixarLogSetupEncode"
decl_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* for some reason, we can't do this in TIFFInitPixarLog */
name|sp
operator|->
name|stride
operator|=
operator|(
name|td
operator|->
name|td_planarconfig
operator|==
name|PLANARCONFIG_CONTIG
condition|?
name|td
operator|->
name|td_samplesperpixel
else|:
literal|1
operator|)
expr_stmt|;
name|tbuf_size
operator|=
name|multiply
argument_list|(
name|multiply
argument_list|(
name|multiply
argument_list|(
name|sp
operator|->
name|stride
argument_list|,
name|td
operator|->
name|td_imagewidth
argument_list|)
argument_list|,
name|td
operator|->
name|td_rowsperstrip
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tbuf_size
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sp
operator|->
name|tbuf
operator|=
operator|(
name|uint16
operator|*
operator|)
name|_TIFFmalloc
argument_list|(
name|tbuf_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|tbuf
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|user_datafmt
operator|==
name|PIXARLOGDATAFMT_UNKNOWN
condition|)
name|sp
operator|->
name|user_datafmt
operator|=
name|PixarLogGuessDataFmt
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|user_datafmt
operator|==
name|PIXARLOGDATAFMT_UNKNOWN
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"PixarLog compression can't handle %d bit linear encodings"
argument_list|,
name|td
operator|->
name|td_bitspersample
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|deflateInit
argument_list|(
operator|&
name|sp
operator|->
name|stream
argument_list|,
name|sp
operator|->
name|quality
argument_list|)
operator|!=
name|Z_OK
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: %s"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
name|sp
operator|->
name|stream
operator|.
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|sp
operator|->
name|state
operator||=
name|PLSTATE_INIT
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*  * Reset encoding state at the start of a strip.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|PixarLogPreEncode
name|PixarLogPreEncode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|PixarLogState
modifier|*
name|sp
init|=
name|EncoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|s
expr_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sp
operator|->
name|stream
operator|.
name|next_out
operator|=
name|tif
operator|->
name|tif_rawdata
expr_stmt|;
name|sp
operator|->
name|stream
operator|.
name|avail_out
operator|=
name|tif
operator|->
name|tif_rawdatasize
expr_stmt|;
return|return
operator|(
name|deflateReset
argument_list|(
operator|&
name|sp
operator|->
name|stream
argument_list|)
operator|==
name|Z_OK
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|horizontalDifferenceF
name|horizontalDifferenceF
parameter_list|(
name|float
modifier|*
name|ip
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|stride
parameter_list|,
name|uint16
modifier|*
name|wp
parameter_list|,
name|uint16
modifier|*
name|FromLT2
parameter_list|)
block|{
name|int32
name|r1
decl_stmt|,
name|g1
decl_stmt|,
name|b1
decl_stmt|,
name|a1
decl_stmt|,
name|r2
decl_stmt|,
name|g2
decl_stmt|,
name|b2
decl_stmt|,
name|a2
decl_stmt|,
name|mask
decl_stmt|;
name|float
name|fltsize
init|=
name|Fltsize
decl_stmt|;
DECL|macro|CLAMP
define|#
directive|define
name|CLAMP
parameter_list|(
name|v
parameter_list|)
value|( (v<(float)0.)   ? 0				\ 		  : (v<(float)2.)   ? FromLT2[(int)(v*fltsize)]	\ 		  : (v>(float)24.2) ? 2047			\ 		  : LogK1*log(v*LogK2) + 0.5 )
name|mask
operator|=
name|CODE_MASK
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|stride
condition|)
block|{
if|if
condition|(
name|stride
operator|==
literal|3
condition|)
block|{
name|r2
operator|=
name|wp
index|[
literal|0
index|]
operator|=
operator|(
name|uint16
operator|)
name|CLAMP
argument_list|(
name|ip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|g2
operator|=
name|wp
index|[
literal|1
index|]
operator|=
operator|(
name|uint16
operator|)
name|CLAMP
argument_list|(
name|ip
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|b2
operator|=
name|wp
index|[
literal|2
index|]
operator|=
operator|(
name|uint16
operator|)
name|CLAMP
argument_list|(
name|ip
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|n
operator|-=
literal|3
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|n
operator|-=
literal|3
expr_stmt|;
name|wp
operator|+=
literal|3
expr_stmt|;
name|ip
operator|+=
literal|3
expr_stmt|;
name|r1
operator|=
operator|(
name|int32
operator|)
name|CLAMP
argument_list|(
name|ip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|wp
index|[
literal|0
index|]
operator|=
operator|(
name|r1
operator|-
name|r2
operator|)
operator|&
name|mask
expr_stmt|;
name|r2
operator|=
name|r1
expr_stmt|;
name|g1
operator|=
operator|(
name|int32
operator|)
name|CLAMP
argument_list|(
name|ip
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|wp
index|[
literal|1
index|]
operator|=
operator|(
name|g1
operator|-
name|g2
operator|)
operator|&
name|mask
expr_stmt|;
name|g2
operator|=
name|g1
expr_stmt|;
name|b1
operator|=
operator|(
name|int32
operator|)
name|CLAMP
argument_list|(
name|ip
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|wp
index|[
literal|2
index|]
operator|=
operator|(
name|b1
operator|-
name|b2
operator|)
operator|&
name|mask
expr_stmt|;
name|b2
operator|=
name|b1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|stride
operator|==
literal|4
condition|)
block|{
name|r2
operator|=
name|wp
index|[
literal|0
index|]
operator|=
operator|(
name|uint16
operator|)
name|CLAMP
argument_list|(
name|ip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|g2
operator|=
name|wp
index|[
literal|1
index|]
operator|=
operator|(
name|uint16
operator|)
name|CLAMP
argument_list|(
name|ip
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|b2
operator|=
name|wp
index|[
literal|2
index|]
operator|=
operator|(
name|uint16
operator|)
name|CLAMP
argument_list|(
name|ip
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|a2
operator|=
name|wp
index|[
literal|3
index|]
operator|=
operator|(
name|uint16
operator|)
name|CLAMP
argument_list|(
name|ip
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|n
operator|-=
literal|4
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|n
operator|-=
literal|4
expr_stmt|;
name|wp
operator|+=
literal|4
expr_stmt|;
name|ip
operator|+=
literal|4
expr_stmt|;
name|r1
operator|=
operator|(
name|int32
operator|)
name|CLAMP
argument_list|(
name|ip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|wp
index|[
literal|0
index|]
operator|=
operator|(
name|r1
operator|-
name|r2
operator|)
operator|&
name|mask
expr_stmt|;
name|r2
operator|=
name|r1
expr_stmt|;
name|g1
operator|=
operator|(
name|int32
operator|)
name|CLAMP
argument_list|(
name|ip
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|wp
index|[
literal|1
index|]
operator|=
operator|(
name|g1
operator|-
name|g2
operator|)
operator|&
name|mask
expr_stmt|;
name|g2
operator|=
name|g1
expr_stmt|;
name|b1
operator|=
operator|(
name|int32
operator|)
name|CLAMP
argument_list|(
name|ip
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|wp
index|[
literal|2
index|]
operator|=
operator|(
name|b1
operator|-
name|b2
operator|)
operator|&
name|mask
expr_stmt|;
name|b2
operator|=
name|b1
expr_stmt|;
name|a1
operator|=
operator|(
name|int32
operator|)
name|CLAMP
argument_list|(
name|ip
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|wp
index|[
literal|3
index|]
operator|=
operator|(
name|a1
operator|-
name|a2
operator|)
operator|&
name|mask
expr_stmt|;
name|a2
operator|=
name|a1
expr_stmt|;
block|}
block|}
else|else
block|{
name|ip
operator|+=
name|n
operator|-
literal|1
expr_stmt|;
comment|/* point to last one */
name|wp
operator|+=
name|n
operator|-
literal|1
expr_stmt|;
comment|/* point to last one */
name|n
operator|-=
name|stride
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|REPEAT
argument_list|(
argument|stride
argument_list|,
argument|wp[
literal|0
argument|] = (uint16) CLAMP(ip[
literal|0
argument|]); 				wp[stride] -= wp[
literal|0
argument|]; 				wp[stride]&= mask; 				wp--; ip--
argument_list|)
name|n
operator|-=
name|stride
expr_stmt|;
block|}
name|REPEAT
argument_list|(
argument|stride
argument_list|,
argument|wp[
literal|0
argument|] = (uint16) CLAMP(ip[
literal|0
argument|]); wp--; ip--
argument_list|)
block|}
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|horizontalDifference16
name|horizontalDifference16
parameter_list|(
name|unsigned
name|short
modifier|*
name|ip
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|stride
parameter_list|,
name|unsigned
name|short
modifier|*
name|wp
parameter_list|,
name|uint16
modifier|*
name|From14
parameter_list|)
block|{
specifier|register
name|int
name|r1
decl_stmt|,
name|g1
decl_stmt|,
name|b1
decl_stmt|,
name|a1
decl_stmt|,
name|r2
decl_stmt|,
name|g2
decl_stmt|,
name|b2
decl_stmt|,
name|a2
decl_stmt|,
name|mask
decl_stmt|;
comment|/* assumption is unsigned pixel values */
DECL|macro|CLAMP
undef|#
directive|undef
name|CLAMP
DECL|macro|CLAMP
define|#
directive|define
name|CLAMP
parameter_list|(
name|v
parameter_list|)
value|From14[(v)>> 2]
name|mask
operator|=
name|CODE_MASK
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|stride
condition|)
block|{
if|if
condition|(
name|stride
operator|==
literal|3
condition|)
block|{
name|r2
operator|=
name|wp
index|[
literal|0
index|]
operator|=
name|CLAMP
argument_list|(
name|ip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|g2
operator|=
name|wp
index|[
literal|1
index|]
operator|=
name|CLAMP
argument_list|(
name|ip
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|b2
operator|=
name|wp
index|[
literal|2
index|]
operator|=
name|CLAMP
argument_list|(
name|ip
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|n
operator|-=
literal|3
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|n
operator|-=
literal|3
expr_stmt|;
name|wp
operator|+=
literal|3
expr_stmt|;
name|ip
operator|+=
literal|3
expr_stmt|;
name|r1
operator|=
name|CLAMP
argument_list|(
name|ip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|wp
index|[
literal|0
index|]
operator|=
operator|(
name|r1
operator|-
name|r2
operator|)
operator|&
name|mask
expr_stmt|;
name|r2
operator|=
name|r1
expr_stmt|;
name|g1
operator|=
name|CLAMP
argument_list|(
name|ip
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|wp
index|[
literal|1
index|]
operator|=
operator|(
name|g1
operator|-
name|g2
operator|)
operator|&
name|mask
expr_stmt|;
name|g2
operator|=
name|g1
expr_stmt|;
name|b1
operator|=
name|CLAMP
argument_list|(
name|ip
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|wp
index|[
literal|2
index|]
operator|=
operator|(
name|b1
operator|-
name|b2
operator|)
operator|&
name|mask
expr_stmt|;
name|b2
operator|=
name|b1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|stride
operator|==
literal|4
condition|)
block|{
name|r2
operator|=
name|wp
index|[
literal|0
index|]
operator|=
name|CLAMP
argument_list|(
name|ip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|g2
operator|=
name|wp
index|[
literal|1
index|]
operator|=
name|CLAMP
argument_list|(
name|ip
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|b2
operator|=
name|wp
index|[
literal|2
index|]
operator|=
name|CLAMP
argument_list|(
name|ip
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|a2
operator|=
name|wp
index|[
literal|3
index|]
operator|=
name|CLAMP
argument_list|(
name|ip
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|n
operator|-=
literal|4
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|n
operator|-=
literal|4
expr_stmt|;
name|wp
operator|+=
literal|4
expr_stmt|;
name|ip
operator|+=
literal|4
expr_stmt|;
name|r1
operator|=
name|CLAMP
argument_list|(
name|ip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|wp
index|[
literal|0
index|]
operator|=
operator|(
name|r1
operator|-
name|r2
operator|)
operator|&
name|mask
expr_stmt|;
name|r2
operator|=
name|r1
expr_stmt|;
name|g1
operator|=
name|CLAMP
argument_list|(
name|ip
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|wp
index|[
literal|1
index|]
operator|=
operator|(
name|g1
operator|-
name|g2
operator|)
operator|&
name|mask
expr_stmt|;
name|g2
operator|=
name|g1
expr_stmt|;
name|b1
operator|=
name|CLAMP
argument_list|(
name|ip
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|wp
index|[
literal|2
index|]
operator|=
operator|(
name|b1
operator|-
name|b2
operator|)
operator|&
name|mask
expr_stmt|;
name|b2
operator|=
name|b1
expr_stmt|;
name|a1
operator|=
name|CLAMP
argument_list|(
name|ip
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|wp
index|[
literal|3
index|]
operator|=
operator|(
name|a1
operator|-
name|a2
operator|)
operator|&
name|mask
expr_stmt|;
name|a2
operator|=
name|a1
expr_stmt|;
block|}
block|}
else|else
block|{
name|ip
operator|+=
name|n
operator|-
literal|1
expr_stmt|;
comment|/* point to last one */
name|wp
operator|+=
name|n
operator|-
literal|1
expr_stmt|;
comment|/* point to last one */
name|n
operator|-=
name|stride
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|REPEAT
argument_list|(
argument|stride
argument_list|,
argument|wp[
literal|0
argument|] = CLAMP(ip[
literal|0
argument|]); 				wp[stride] -= wp[
literal|0
argument|]; 				wp[stride]&= mask; 				wp--; ip--
argument_list|)
name|n
operator|-=
name|stride
expr_stmt|;
block|}
name|REPEAT
argument_list|(
argument|stride
argument_list|,
argument|wp[
literal|0
argument|] = CLAMP(ip[
literal|0
argument|]); wp--; ip--
argument_list|)
block|}
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|horizontalDifference8
name|horizontalDifference8
parameter_list|(
name|unsigned
name|char
modifier|*
name|ip
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|stride
parameter_list|,
name|unsigned
name|short
modifier|*
name|wp
parameter_list|,
name|uint16
modifier|*
name|From8
parameter_list|)
block|{
specifier|register
name|int
name|r1
decl_stmt|,
name|g1
decl_stmt|,
name|b1
decl_stmt|,
name|a1
decl_stmt|,
name|r2
decl_stmt|,
name|g2
decl_stmt|,
name|b2
decl_stmt|,
name|a2
decl_stmt|,
name|mask
decl_stmt|;
DECL|macro|CLAMP
undef|#
directive|undef
name|CLAMP
DECL|macro|CLAMP
define|#
directive|define
name|CLAMP
parameter_list|(
name|v
parameter_list|)
value|(From8[(v)])
name|mask
operator|=
name|CODE_MASK
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|stride
condition|)
block|{
if|if
condition|(
name|stride
operator|==
literal|3
condition|)
block|{
name|r2
operator|=
name|wp
index|[
literal|0
index|]
operator|=
name|CLAMP
argument_list|(
name|ip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|g2
operator|=
name|wp
index|[
literal|1
index|]
operator|=
name|CLAMP
argument_list|(
name|ip
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|b2
operator|=
name|wp
index|[
literal|2
index|]
operator|=
name|CLAMP
argument_list|(
name|ip
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|n
operator|-=
literal|3
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|n
operator|-=
literal|3
expr_stmt|;
name|r1
operator|=
name|CLAMP
argument_list|(
name|ip
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|wp
index|[
literal|3
index|]
operator|=
operator|(
name|r1
operator|-
name|r2
operator|)
operator|&
name|mask
expr_stmt|;
name|r2
operator|=
name|r1
expr_stmt|;
name|g1
operator|=
name|CLAMP
argument_list|(
name|ip
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|wp
index|[
literal|4
index|]
operator|=
operator|(
name|g1
operator|-
name|g2
operator|)
operator|&
name|mask
expr_stmt|;
name|g2
operator|=
name|g1
expr_stmt|;
name|b1
operator|=
name|CLAMP
argument_list|(
name|ip
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|wp
index|[
literal|5
index|]
operator|=
operator|(
name|b1
operator|-
name|b2
operator|)
operator|&
name|mask
expr_stmt|;
name|b2
operator|=
name|b1
expr_stmt|;
name|wp
operator|+=
literal|3
expr_stmt|;
name|ip
operator|+=
literal|3
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|stride
operator|==
literal|4
condition|)
block|{
name|r2
operator|=
name|wp
index|[
literal|0
index|]
operator|=
name|CLAMP
argument_list|(
name|ip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|g2
operator|=
name|wp
index|[
literal|1
index|]
operator|=
name|CLAMP
argument_list|(
name|ip
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|b2
operator|=
name|wp
index|[
literal|2
index|]
operator|=
name|CLAMP
argument_list|(
name|ip
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|a2
operator|=
name|wp
index|[
literal|3
index|]
operator|=
name|CLAMP
argument_list|(
name|ip
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|n
operator|-=
literal|4
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|n
operator|-=
literal|4
expr_stmt|;
name|r1
operator|=
name|CLAMP
argument_list|(
name|ip
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|wp
index|[
literal|4
index|]
operator|=
operator|(
name|r1
operator|-
name|r2
operator|)
operator|&
name|mask
expr_stmt|;
name|r2
operator|=
name|r1
expr_stmt|;
name|g1
operator|=
name|CLAMP
argument_list|(
name|ip
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|wp
index|[
literal|5
index|]
operator|=
operator|(
name|g1
operator|-
name|g2
operator|)
operator|&
name|mask
expr_stmt|;
name|g2
operator|=
name|g1
expr_stmt|;
name|b1
operator|=
name|CLAMP
argument_list|(
name|ip
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|wp
index|[
literal|6
index|]
operator|=
operator|(
name|b1
operator|-
name|b2
operator|)
operator|&
name|mask
expr_stmt|;
name|b2
operator|=
name|b1
expr_stmt|;
name|a1
operator|=
name|CLAMP
argument_list|(
name|ip
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|wp
index|[
literal|7
index|]
operator|=
operator|(
name|a1
operator|-
name|a2
operator|)
operator|&
name|mask
expr_stmt|;
name|a2
operator|=
name|a1
expr_stmt|;
name|wp
operator|+=
literal|4
expr_stmt|;
name|ip
operator|+=
literal|4
expr_stmt|;
block|}
block|}
else|else
block|{
name|wp
operator|+=
name|n
operator|+
name|stride
operator|-
literal|1
expr_stmt|;
comment|/* point to last one */
name|ip
operator|+=
name|n
operator|+
name|stride
operator|-
literal|1
expr_stmt|;
comment|/* point to last one */
name|n
operator|-=
name|stride
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|REPEAT
argument_list|(
argument|stride
argument_list|,
argument|wp[
literal|0
argument|] = CLAMP(ip[
literal|0
argument|]); 				wp[stride] -= wp[
literal|0
argument|]; 				wp[stride]&= mask; 				wp--; ip--
argument_list|)
name|n
operator|-=
name|stride
expr_stmt|;
block|}
name|REPEAT
argument_list|(
argument|stride
argument_list|,
argument|wp[
literal|0
argument|] = CLAMP(ip[
literal|0
argument|]); wp--; ip--
argument_list|)
block|}
block|}
block|}
end_function
begin_comment
comment|/*  * Encode a chunk of pixels.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|PixarLogEncode
name|PixarLogEncode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|bp
parameter_list|,
name|tsize_t
name|cc
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|PixarLogState
modifier|*
name|sp
init|=
name|EncoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|"PixarLogEncode"
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|llen
decl_stmt|;
name|unsigned
name|short
modifier|*
name|up
decl_stmt|;
operator|(
name|void
operator|)
name|s
expr_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|user_datafmt
condition|)
block|{
case|case
name|PIXARLOGDATAFMT_FLOAT
case|:
name|n
operator|=
name|cc
operator|/
sizeof|sizeof
argument_list|(
name|float
argument_list|)
expr_stmt|;
comment|/* XXX float == 32 bits */
break|break;
case|case
name|PIXARLOGDATAFMT_16BIT
case|:
case|case
name|PIXARLOGDATAFMT_12BITPICIO
case|:
case|case
name|PIXARLOGDATAFMT_11BITLOG
case|:
name|n
operator|=
name|cc
operator|/
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
expr_stmt|;
comment|/* XXX uint16 == 16 bits */
break|break;
case|case
name|PIXARLOGDATAFMT_8BIT
case|:
case|case
name|PIXARLOGDATAFMT_8BITABGR
case|:
name|n
operator|=
name|cc
expr_stmt|;
break|break;
default|default:
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"%d bit input not supported in PixarLog"
argument_list|,
name|td
operator|->
name|td_bitspersample
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|llen
operator|=
name|sp
operator|->
name|stride
operator|*
name|td
operator|->
name|td_imagewidth
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|up
operator|=
name|sp
operator|->
name|tbuf
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|+=
name|llen
operator|,
name|up
operator|+=
name|llen
control|)
block|{
switch|switch
condition|(
name|sp
operator|->
name|user_datafmt
condition|)
block|{
case|case
name|PIXARLOGDATAFMT_FLOAT
case|:
name|horizontalDifferenceF
argument_list|(
operator|(
name|float
operator|*
operator|)
name|bp
argument_list|,
name|llen
argument_list|,
name|sp
operator|->
name|stride
argument_list|,
name|up
argument_list|,
name|sp
operator|->
name|FromLT2
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|llen
operator|*
sizeof|sizeof
argument_list|(
name|float
argument_list|)
expr_stmt|;
break|break;
case|case
name|PIXARLOGDATAFMT_16BIT
case|:
name|horizontalDifference16
argument_list|(
operator|(
name|uint16
operator|*
operator|)
name|bp
argument_list|,
name|llen
argument_list|,
name|sp
operator|->
name|stride
argument_list|,
name|up
argument_list|,
name|sp
operator|->
name|From14
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|llen
operator|*
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
expr_stmt|;
break|break;
case|case
name|PIXARLOGDATAFMT_8BIT
case|:
name|horizontalDifference8
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bp
argument_list|,
name|llen
argument_list|,
name|sp
operator|->
name|stride
argument_list|,
name|up
argument_list|,
name|sp
operator|->
name|From8
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|llen
operator|*
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
expr_stmt|;
break|break;
default|default:
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"%d bit input not supported in PixarLog"
argument_list|,
name|td
operator|->
name|td_bitspersample
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|sp
operator|->
name|stream
operator|.
name|next_in
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|sp
operator|->
name|tbuf
expr_stmt|;
name|sp
operator|->
name|stream
operator|.
name|avail_in
operator|=
name|n
operator|*
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|deflate
argument_list|(
operator|&
name|sp
operator|->
name|stream
argument_list|,
name|Z_NO_FLUSH
argument_list|)
operator|!=
name|Z_OK
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Encoder error: %s"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
name|sp
operator|->
name|stream
operator|.
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sp
operator|->
name|stream
operator|.
name|avail_out
operator|==
literal|0
condition|)
block|{
name|tif
operator|->
name|tif_rawcc
operator|=
name|tif
operator|->
name|tif_rawdatasize
expr_stmt|;
name|TIFFFlushData1
argument_list|(
name|tif
argument_list|)
expr_stmt|;
name|sp
operator|->
name|stream
operator|.
name|next_out
operator|=
name|tif
operator|->
name|tif_rawdata
expr_stmt|;
name|sp
operator|->
name|stream
operator|.
name|avail_out
operator|=
name|tif
operator|->
name|tif_rawdatasize
expr_stmt|;
block|}
block|}
do|while
condition|(
name|sp
operator|->
name|stream
operator|.
name|avail_in
operator|>
literal|0
condition|)
do|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Finish off an encoded strip by flushing the last  * string and tacking on an End Of Information code.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|PixarLogPostEncode
name|PixarLogPostEncode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|PixarLogState
modifier|*
name|sp
init|=
name|EncoderState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|"PixarLogPostEncode"
decl_stmt|;
name|int
name|state
decl_stmt|;
name|sp
operator|->
name|stream
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|state
operator|=
name|deflate
argument_list|(
operator|&
name|sp
operator|->
name|stream
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|Z_STREAM_END
case|:
case|case
name|Z_OK
case|:
if|if
condition|(
name|sp
operator|->
name|stream
operator|.
name|avail_out
operator|!=
operator|(
name|uint32
operator|)
name|tif
operator|->
name|tif_rawdatasize
condition|)
block|{
name|tif
operator|->
name|tif_rawcc
operator|=
name|tif
operator|->
name|tif_rawdatasize
operator|-
name|sp
operator|->
name|stream
operator|.
name|avail_out
expr_stmt|;
name|TIFFFlushData1
argument_list|(
name|tif
argument_list|)
expr_stmt|;
name|sp
operator|->
name|stream
operator|.
name|next_out
operator|=
name|tif
operator|->
name|tif_rawdata
expr_stmt|;
name|sp
operator|->
name|stream
operator|.
name|avail_out
operator|=
name|tif
operator|->
name|tif_rawdatasize
expr_stmt|;
block|}
break|break;
default|default:
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: zlib error: %s"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
name|sp
operator|->
name|stream
operator|.
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
do|while
condition|(
name|state
operator|!=
name|Z_STREAM_END
condition|)
do|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|PixarLogClose
name|PixarLogClose
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
comment|/* In a really sneaky maneuver, on close, we covertly modify both 	 * bitspersample and sampleformat in the directory to indicate 	 * 8-bit linear.  This way, the decode "just works" even for 	 * readers that don't know about PixarLog, or how to set 	 * the PIXARLOGDATFMT pseudo-tag. 	 */
name|td
operator|->
name|td_bitspersample
operator|=
literal|8
expr_stmt|;
name|td
operator|->
name|td_sampleformat
operator|=
name|SAMPLEFORMAT_UINT
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|PixarLogCleanup
name|PixarLogCleanup
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|PixarLogState
modifier|*
name|sp
init|=
operator|(
name|PixarLogState
operator|*
operator|)
name|tif
operator|->
name|tif_data
decl_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|TIFFPredictorCleanup
argument_list|(
name|tif
argument_list|)
expr_stmt|;
name|tif
operator|->
name|tif_tagmethods
operator|.
name|vgetfield
operator|=
name|sp
operator|->
name|vgetparent
expr_stmt|;
name|tif
operator|->
name|tif_tagmethods
operator|.
name|vsetfield
operator|=
name|sp
operator|->
name|vsetparent
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|FromLT2
condition|)
name|_TIFFfree
argument_list|(
name|sp
operator|->
name|FromLT2
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|From14
condition|)
name|_TIFFfree
argument_list|(
name|sp
operator|->
name|From14
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|From8
condition|)
name|_TIFFfree
argument_list|(
name|sp
operator|->
name|From8
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|ToLinearF
condition|)
name|_TIFFfree
argument_list|(
name|sp
operator|->
name|ToLinearF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|ToLinear16
condition|)
name|_TIFFfree
argument_list|(
name|sp
operator|->
name|ToLinear16
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|ToLinear8
condition|)
name|_TIFFfree
argument_list|(
name|sp
operator|->
name|ToLinear8
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|state
operator|&
name|PLSTATE_INIT
condition|)
block|{
if|if
condition|(
name|tif
operator|->
name|tif_mode
operator|==
name|O_RDONLY
condition|)
name|inflateEnd
argument_list|(
operator|&
name|sp
operator|->
name|stream
argument_list|)
expr_stmt|;
else|else
name|deflateEnd
argument_list|(
operator|&
name|sp
operator|->
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|tbuf
condition|)
name|_TIFFfree
argument_list|(
name|sp
operator|->
name|tbuf
argument_list|)
expr_stmt|;
name|_TIFFfree
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|tif
operator|->
name|tif_data
operator|=
name|NULL
expr_stmt|;
name|_TIFFSetDefaultCompressionState
argument_list|(
name|tif
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|PixarLogVSetField
name|PixarLogVSetField
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|ttag_t
name|tag
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|PixarLogState
modifier|*
name|sp
init|=
operator|(
name|PixarLogState
operator|*
operator|)
name|tif
operator|->
name|tif_data
decl_stmt|;
name|int
name|result
decl_stmt|;
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|"PixarLogVSetField"
decl_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|TIFFTAG_PIXARLOGQUALITY
case|:
name|sp
operator|->
name|quality
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|tif
operator|->
name|tif_mode
operator|!=
name|O_RDONLY
operator|&&
operator|(
name|sp
operator|->
name|state
operator|&
name|PLSTATE_INIT
operator|)
condition|)
block|{
if|if
condition|(
name|deflateParams
argument_list|(
operator|&
name|sp
operator|->
name|stream
argument_list|,
name|sp
operator|->
name|quality
argument_list|,
name|Z_DEFAULT_STRATEGY
argument_list|)
operator|!=
name|Z_OK
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: zlib error: %s"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
name|sp
operator|->
name|stream
operator|.
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|TIFFTAG_PIXARLOGDATAFMT
case|:
name|sp
operator|->
name|user_datafmt
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
comment|/* Tweak the TIFF header so that the rest of libtiff knows what 	 * size of data will be passed between app and library, and 	 * assume that the app knows what it is doing and is not 	 * confused by these header manipulations... 	 */
switch|switch
condition|(
name|sp
operator|->
name|user_datafmt
condition|)
block|{
case|case
name|PIXARLOGDATAFMT_8BIT
case|:
case|case
name|PIXARLOGDATAFMT_8BITABGR
case|:
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_BITSPERSAMPLE
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_SAMPLEFORMAT
argument_list|,
name|SAMPLEFORMAT_UINT
argument_list|)
expr_stmt|;
break|break;
case|case
name|PIXARLOGDATAFMT_11BITLOG
case|:
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_BITSPERSAMPLE
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_SAMPLEFORMAT
argument_list|,
name|SAMPLEFORMAT_UINT
argument_list|)
expr_stmt|;
break|break;
case|case
name|PIXARLOGDATAFMT_12BITPICIO
case|:
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_BITSPERSAMPLE
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_SAMPLEFORMAT
argument_list|,
name|SAMPLEFORMAT_INT
argument_list|)
expr_stmt|;
break|break;
case|case
name|PIXARLOGDATAFMT_16BIT
case|:
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_BITSPERSAMPLE
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_SAMPLEFORMAT
argument_list|,
name|SAMPLEFORMAT_UINT
argument_list|)
expr_stmt|;
break|break;
case|case
name|PIXARLOGDATAFMT_FLOAT
case|:
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_BITSPERSAMPLE
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_SAMPLEFORMAT
argument_list|,
name|SAMPLEFORMAT_IEEEFP
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * Must recalculate sizes should bits/sample change. 	 */
name|tif
operator|->
name|tif_tilesize
operator|=
name|isTiled
argument_list|(
name|tif
argument_list|)
condition|?
name|TIFFTileSize
argument_list|(
name|tif
argument_list|)
else|:
operator|(
name|tsize_t
operator|)
operator|-
literal|1
expr_stmt|;
name|tif
operator|->
name|tif_scanlinesize
operator|=
name|TIFFScanlineSize
argument_list|(
name|tif
argument_list|)
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
comment|/* NB: pseudo tag */
break|break;
default|default:
name|result
operator|=
call|(
modifier|*
name|sp
operator|->
name|vsetparent
call|)
argument_list|(
name|tif
argument_list|,
name|tag
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|PixarLogVGetField
name|PixarLogVGetField
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|ttag_t
name|tag
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|PixarLogState
modifier|*
name|sp
init|=
operator|(
name|PixarLogState
operator|*
operator|)
name|tif
operator|->
name|tif_data
decl_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|TIFFTAG_PIXARLOGQUALITY
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
operator|*
argument_list|)
operator|=
name|sp
operator|->
name|quality
expr_stmt|;
break|break;
case|case
name|TIFFTAG_PIXARLOGDATAFMT
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
operator|*
argument_list|)
operator|=
name|sp
operator|->
name|user_datafmt
expr_stmt|;
break|break;
default|default:
return|return
call|(
modifier|*
name|sp
operator|->
name|vgetparent
call|)
argument_list|(
name|tif
argument_list|,
name|tag
argument_list|,
name|ap
argument_list|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|pixarlogFieldInfo
specifier|static
specifier|const
name|TIFFFieldInfo
name|pixarlogFieldInfo
index|[]
init|=
block|{
block|{
name|TIFFTAG_PIXARLOGDATAFMT
block|,
literal|0
block|,
literal|0
block|,
name|TIFF_ANY
block|,
name|FIELD_PSEUDO
block|,
name|FALSE
block|,
name|FALSE
block|,
literal|""
block|}
block|,
block|{
name|TIFFTAG_PIXARLOGQUALITY
block|,
literal|0
block|,
literal|0
block|,
name|TIFF_ANY
block|,
name|FIELD_PSEUDO
block|,
name|FALSE
block|,
name|FALSE
block|,
literal|""
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_function
name|int
DECL|function|TIFFInitPixarLog
name|TIFFInitPixarLog
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|int
name|scheme
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|"TIFFInitPixarLog"
decl_stmt|;
name|PixarLogState
modifier|*
name|sp
decl_stmt|;
name|assert
argument_list|(
name|scheme
operator|==
name|COMPRESSION_PIXARLOG
argument_list|)
expr_stmt|;
comment|/* 	 * Merge codec-specific tag information. 	 */
if|if
condition|(
operator|!
name|_TIFFMergeFieldInfo
argument_list|(
name|tif
argument_list|,
name|pixarlogFieldInfo
argument_list|,
name|TIFFArrayCount
argument_list|(
name|pixarlogFieldInfo
argument_list|)
argument_list|)
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"Merging PixarLog codec-specific tags failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Allocate state block so tag methods have storage to record values. 	 */
name|tif
operator|->
name|tif_data
operator|=
operator|(
name|tidata_t
operator|)
name|_TIFFmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|PixarLogState
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tif
operator|->
name|tif_data
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|sp
operator|=
operator|(
name|PixarLogState
operator|*
operator|)
name|tif
operator|->
name|tif_data
expr_stmt|;
name|_TIFFmemset
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|stream
operator|.
name|data_type
operator|=
name|Z_BINARY
expr_stmt|;
name|sp
operator|->
name|user_datafmt
operator|=
name|PIXARLOGDATAFMT_UNKNOWN
expr_stmt|;
comment|/* 	 * Install codec methods. 	 */
name|tif
operator|->
name|tif_setupdecode
operator|=
name|PixarLogSetupDecode
expr_stmt|;
name|tif
operator|->
name|tif_predecode
operator|=
name|PixarLogPreDecode
expr_stmt|;
name|tif
operator|->
name|tif_decoderow
operator|=
name|PixarLogDecode
expr_stmt|;
name|tif
operator|->
name|tif_decodestrip
operator|=
name|PixarLogDecode
expr_stmt|;
name|tif
operator|->
name|tif_decodetile
operator|=
name|PixarLogDecode
expr_stmt|;
name|tif
operator|->
name|tif_setupencode
operator|=
name|PixarLogSetupEncode
expr_stmt|;
name|tif
operator|->
name|tif_preencode
operator|=
name|PixarLogPreEncode
expr_stmt|;
name|tif
operator|->
name|tif_postencode
operator|=
name|PixarLogPostEncode
expr_stmt|;
name|tif
operator|->
name|tif_encoderow
operator|=
name|PixarLogEncode
expr_stmt|;
name|tif
operator|->
name|tif_encodestrip
operator|=
name|PixarLogEncode
expr_stmt|;
name|tif
operator|->
name|tif_encodetile
operator|=
name|PixarLogEncode
expr_stmt|;
name|tif
operator|->
name|tif_close
operator|=
name|PixarLogClose
expr_stmt|;
name|tif
operator|->
name|tif_cleanup
operator|=
name|PixarLogCleanup
expr_stmt|;
comment|/* Override SetField so we can handle our private pseudo-tag */
name|sp
operator|->
name|vgetparent
operator|=
name|tif
operator|->
name|tif_tagmethods
operator|.
name|vgetfield
expr_stmt|;
name|tif
operator|->
name|tif_tagmethods
operator|.
name|vgetfield
operator|=
name|PixarLogVGetField
expr_stmt|;
comment|/* hook for codec tags */
name|sp
operator|->
name|vsetparent
operator|=
name|tif
operator|->
name|tif_tagmethods
operator|.
name|vsetfield
expr_stmt|;
name|tif
operator|->
name|tif_tagmethods
operator|.
name|vsetfield
operator|=
name|PixarLogVSetField
expr_stmt|;
comment|/* hook for codec tags */
comment|/* Default values for codec-specific fields */
name|sp
operator|->
name|quality
operator|=
name|Z_DEFAULT_COMPRESSION
expr_stmt|;
comment|/* default comp. level */
name|sp
operator|->
name|state
operator|=
literal|0
expr_stmt|;
comment|/* we don't wish to use the predictor,  	 * the default is none, which predictor value 1 	 */
operator|(
name|void
operator|)
name|TIFFPredictorInit
argument_list|(
name|tif
argument_list|)
expr_stmt|;
comment|/* 	 * build the companding tables  	 */
name|PixarLogMakeTables
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
name|bad
label|:
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"No space for PixarLog state block"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PIXARLOG_SUPPORT */
end_comment
begin_comment
comment|/* vim: set ts=8 sts=8 sw=8 noet: */
end_comment
end_unit
