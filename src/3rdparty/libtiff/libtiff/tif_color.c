begin_unit
begin_comment
comment|/* $Id: tif_color.c,v 1.12 2006/02/09 15:42:20 dron Exp $ */
end_comment
begin_comment
comment|/*  * Copyright (c) 1988-1997 Sam Leffler  * Copyright (c) 1991-1997 Silicon Graphics, Inc.  *  * Permission to use, copy, modify, distribute, and sell this software and   * its documentation for any purpose is hereby granted without fee, provided  * that (i) the above copyright notices and this permission notice appear in  * all copies of the software and related documentation, and (ii) the names of  * Sam Leffler and Silicon Graphics may not be used in any advertising or  * publicity relating to the software without the specific, prior written  * permission of Sam Leffler and Silicon Graphics.  *   * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,   * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY   * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.    *   * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR  * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,  * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF   * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE   * OF THIS SOFTWARE.  */
end_comment
begin_comment
comment|/*  * CIE L*a*b* to CIE XYZ and CIE XYZ to RGB conversion routines are taken  * from the VIPS library (http://www.vips.ecs.soton.ac.uk) with  * the permission of John Cupitt, the VIPS author.  */
end_comment
begin_comment
comment|/*  * TIFF Library.  *  * Color space conversion routines.  */
end_comment
begin_include
include|#
directive|include
file|"tiffiop.h"
end_include
begin_include
include|#
directive|include
file|<math.h>
end_include
begin_comment
comment|/*  * Convert color value from the CIE L*a*b* 1976 space to CIE XYZ.  */
end_comment
begin_function
name|void
DECL|function|TIFFCIELabToXYZ
name|TIFFCIELabToXYZ
parameter_list|(
name|TIFFCIELabToRGB
modifier|*
name|cielab
parameter_list|,
name|uint32
name|l
parameter_list|,
name|int32
name|a
parameter_list|,
name|int32
name|b
parameter_list|,
name|float
modifier|*
name|X
parameter_list|,
name|float
modifier|*
name|Y
parameter_list|,
name|float
modifier|*
name|Z
parameter_list|)
block|{
name|float
name|L
init|=
operator|(
name|float
operator|)
name|l
operator|*
literal|100.0F
operator|/
literal|255.0F
decl_stmt|;
name|float
name|cby
decl_stmt|,
name|tmp
decl_stmt|;
if|if
condition|(
name|L
operator|<
literal|8.856F
condition|)
block|{
operator|*
name|Y
operator|=
operator|(
name|L
operator|*
name|cielab
operator|->
name|Y0
operator|)
operator|/
literal|903.292F
expr_stmt|;
name|cby
operator|=
literal|7.787F
operator|*
operator|(
operator|*
name|Y
operator|/
name|cielab
operator|->
name|Y0
operator|)
operator|+
literal|16.0F
operator|/
literal|116.0F
expr_stmt|;
block|}
else|else
block|{
name|cby
operator|=
operator|(
name|L
operator|+
literal|16.0F
operator|)
operator|/
literal|116.0F
expr_stmt|;
operator|*
name|Y
operator|=
name|cielab
operator|->
name|Y0
operator|*
name|cby
operator|*
name|cby
operator|*
name|cby
expr_stmt|;
block|}
name|tmp
operator|=
operator|(
name|float
operator|)
name|a
operator|/
literal|500.0F
operator|+
name|cby
expr_stmt|;
if|if
condition|(
name|tmp
operator|<
literal|0.2069F
condition|)
operator|*
name|X
operator|=
name|cielab
operator|->
name|X0
operator|*
operator|(
name|tmp
operator|-
literal|0.13793F
operator|)
operator|/
literal|7.787F
expr_stmt|;
else|else
operator|*
name|X
operator|=
name|cielab
operator|->
name|X0
operator|*
name|tmp
operator|*
name|tmp
operator|*
name|tmp
expr_stmt|;
name|tmp
operator|=
name|cby
operator|-
operator|(
name|float
operator|)
name|b
operator|/
literal|200.0F
expr_stmt|;
if|if
condition|(
name|tmp
operator|<
literal|0.2069F
condition|)
operator|*
name|Z
operator|=
name|cielab
operator|->
name|Z0
operator|*
operator|(
name|tmp
operator|-
literal|0.13793F
operator|)
operator|/
literal|7.787F
expr_stmt|;
else|else
operator|*
name|Z
operator|=
name|cielab
operator|->
name|Z0
operator|*
name|tmp
operator|*
name|tmp
operator|*
name|tmp
expr_stmt|;
block|}
end_function
begin_define
DECL|macro|RINT
define|#
directive|define
name|RINT
parameter_list|(
name|R
parameter_list|)
value|((uint32)((R)>0?((R)+0.5):((R)-0.5)))
end_define
begin_comment
comment|/*  * Convert color value from the XYZ space to RGB.  */
end_comment
begin_function
name|void
DECL|function|TIFFXYZToRGB
name|TIFFXYZToRGB
parameter_list|(
name|TIFFCIELabToRGB
modifier|*
name|cielab
parameter_list|,
name|float
name|X
parameter_list|,
name|float
name|Y
parameter_list|,
name|float
name|Z
parameter_list|,
name|uint32
modifier|*
name|r
parameter_list|,
name|uint32
modifier|*
name|g
parameter_list|,
name|uint32
modifier|*
name|b
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|float
name|Yr
decl_stmt|,
name|Yg
decl_stmt|,
name|Yb
decl_stmt|;
name|float
modifier|*
name|matrix
init|=
operator|&
name|cielab
operator|->
name|display
operator|.
name|d_mat
index|[
literal|0
index|]
index|[
literal|0
index|]
decl_stmt|;
comment|/* Multiply through the matrix to get luminosity values. */
name|Yr
operator|=
name|matrix
index|[
literal|0
index|]
operator|*
name|X
operator|+
name|matrix
index|[
literal|1
index|]
operator|*
name|Y
operator|+
name|matrix
index|[
literal|2
index|]
operator|*
name|Z
expr_stmt|;
name|Yg
operator|=
name|matrix
index|[
literal|3
index|]
operator|*
name|X
operator|+
name|matrix
index|[
literal|4
index|]
operator|*
name|Y
operator|+
name|matrix
index|[
literal|5
index|]
operator|*
name|Z
expr_stmt|;
name|Yb
operator|=
name|matrix
index|[
literal|6
index|]
operator|*
name|X
operator|+
name|matrix
index|[
literal|7
index|]
operator|*
name|Y
operator|+
name|matrix
index|[
literal|8
index|]
operator|*
name|Z
expr_stmt|;
comment|/* Clip input */
name|Yr
operator|=
name|TIFFmax
argument_list|(
name|Yr
argument_list|,
name|cielab
operator|->
name|display
operator|.
name|d_Y0R
argument_list|)
expr_stmt|;
name|Yg
operator|=
name|TIFFmax
argument_list|(
name|Yg
argument_list|,
name|cielab
operator|->
name|display
operator|.
name|d_Y0G
argument_list|)
expr_stmt|;
name|Yb
operator|=
name|TIFFmax
argument_list|(
name|Yb
argument_list|,
name|cielab
operator|->
name|display
operator|.
name|d_Y0B
argument_list|)
expr_stmt|;
comment|/* Avoid overflow in case of wrong input values */
name|Yr
operator|=
name|TIFFmin
argument_list|(
name|Yr
argument_list|,
name|cielab
operator|->
name|display
operator|.
name|d_YCR
argument_list|)
expr_stmt|;
name|Yg
operator|=
name|TIFFmin
argument_list|(
name|Yg
argument_list|,
name|cielab
operator|->
name|display
operator|.
name|d_YCG
argument_list|)
expr_stmt|;
name|Yb
operator|=
name|TIFFmin
argument_list|(
name|Yb
argument_list|,
name|cielab
operator|->
name|display
operator|.
name|d_YCB
argument_list|)
expr_stmt|;
comment|/* Turn luminosity to colour value. */
name|i
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|Yr
operator|-
name|cielab
operator|->
name|display
operator|.
name|d_Y0R
operator|)
operator|/
name|cielab
operator|->
name|rstep
argument_list|)
expr_stmt|;
name|i
operator|=
name|TIFFmin
argument_list|(
name|cielab
operator|->
name|range
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|*
name|r
operator|=
name|RINT
argument_list|(
name|cielab
operator|->
name|Yr2r
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|Yg
operator|-
name|cielab
operator|->
name|display
operator|.
name|d_Y0G
operator|)
operator|/
name|cielab
operator|->
name|gstep
argument_list|)
expr_stmt|;
name|i
operator|=
name|TIFFmin
argument_list|(
name|cielab
operator|->
name|range
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|*
name|g
operator|=
name|RINT
argument_list|(
name|cielab
operator|->
name|Yg2g
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|Yb
operator|-
name|cielab
operator|->
name|display
operator|.
name|d_Y0B
operator|)
operator|/
name|cielab
operator|->
name|bstep
argument_list|)
expr_stmt|;
name|i
operator|=
name|TIFFmin
argument_list|(
name|cielab
operator|->
name|range
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|*
name|b
operator|=
name|RINT
argument_list|(
name|cielab
operator|->
name|Yb2b
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Clip output. */
operator|*
name|r
operator|=
name|TIFFmin
argument_list|(
operator|*
name|r
argument_list|,
name|cielab
operator|->
name|display
operator|.
name|d_Vrwr
argument_list|)
expr_stmt|;
operator|*
name|g
operator|=
name|TIFFmin
argument_list|(
operator|*
name|g
argument_list|,
name|cielab
operator|->
name|display
operator|.
name|d_Vrwg
argument_list|)
expr_stmt|;
operator|*
name|b
operator|=
name|TIFFmin
argument_list|(
operator|*
name|b
argument_list|,
name|cielab
operator|->
name|display
operator|.
name|d_Vrwb
argument_list|)
expr_stmt|;
block|}
end_function
begin_undef
DECL|macro|RINT
undef|#
directive|undef
name|RINT
end_undef
begin_comment
comment|/*   * Allocate conversion state structures and make look_up tables for  * the Yr,Yb,Yg<=> r,g,b conversions.  */
end_comment
begin_function
name|int
DECL|function|TIFFCIELabToRGBInit
name|TIFFCIELabToRGBInit
parameter_list|(
name|TIFFCIELabToRGB
modifier|*
name|cielab
parameter_list|,
name|TIFFDisplay
modifier|*
name|display
parameter_list|,
name|float
modifier|*
name|refWhite
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|double
name|gamma
decl_stmt|;
name|cielab
operator|->
name|range
operator|=
name|CIELABTORGB_TABLE_RANGE
expr_stmt|;
name|_TIFFmemcpy
argument_list|(
operator|&
name|cielab
operator|->
name|display
argument_list|,
name|display
argument_list|,
sizeof|sizeof
argument_list|(
name|TIFFDisplay
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Red */
name|gamma
operator|=
literal|1.0
operator|/
name|cielab
operator|->
name|display
operator|.
name|d_gammaR
expr_stmt|;
name|cielab
operator|->
name|rstep
operator|=
operator|(
name|cielab
operator|->
name|display
operator|.
name|d_YCR
operator|-
name|cielab
operator|->
name|display
operator|.
name|d_Y0R
operator|)
operator|/
name|cielab
operator|->
name|range
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|cielab
operator|->
name|range
condition|;
name|i
operator|++
control|)
block|{
name|cielab
operator|->
name|Yr2r
index|[
name|i
index|]
operator|=
name|cielab
operator|->
name|display
operator|.
name|d_Vrwr
operator|*
operator|(
operator|(
name|float
operator|)
name|pow
argument_list|(
operator|(
name|double
operator|)
name|i
operator|/
name|cielab
operator|->
name|range
argument_list|,
name|gamma
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* Green */
name|gamma
operator|=
literal|1.0
operator|/
name|cielab
operator|->
name|display
operator|.
name|d_gammaG
expr_stmt|;
name|cielab
operator|->
name|gstep
operator|=
operator|(
name|cielab
operator|->
name|display
operator|.
name|d_YCR
operator|-
name|cielab
operator|->
name|display
operator|.
name|d_Y0R
operator|)
operator|/
name|cielab
operator|->
name|range
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|cielab
operator|->
name|range
condition|;
name|i
operator|++
control|)
block|{
name|cielab
operator|->
name|Yg2g
index|[
name|i
index|]
operator|=
name|cielab
operator|->
name|display
operator|.
name|d_Vrwg
operator|*
operator|(
operator|(
name|float
operator|)
name|pow
argument_list|(
operator|(
name|double
operator|)
name|i
operator|/
name|cielab
operator|->
name|range
argument_list|,
name|gamma
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* Blue */
name|gamma
operator|=
literal|1.0
operator|/
name|cielab
operator|->
name|display
operator|.
name|d_gammaB
expr_stmt|;
name|cielab
operator|->
name|bstep
operator|=
operator|(
name|cielab
operator|->
name|display
operator|.
name|d_YCR
operator|-
name|cielab
operator|->
name|display
operator|.
name|d_Y0R
operator|)
operator|/
name|cielab
operator|->
name|range
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|cielab
operator|->
name|range
condition|;
name|i
operator|++
control|)
block|{
name|cielab
operator|->
name|Yb2b
index|[
name|i
index|]
operator|=
name|cielab
operator|->
name|display
operator|.
name|d_Vrwb
operator|*
operator|(
operator|(
name|float
operator|)
name|pow
argument_list|(
operator|(
name|double
operator|)
name|i
operator|/
name|cielab
operator|->
name|range
argument_list|,
name|gamma
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* Init reference white point */
name|cielab
operator|->
name|X0
operator|=
name|refWhite
index|[
literal|0
index|]
expr_stmt|;
name|cielab
operator|->
name|Y0
operator|=
name|refWhite
index|[
literal|1
index|]
expr_stmt|;
name|cielab
operator|->
name|Z0
operator|=
name|refWhite
index|[
literal|2
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*   * Convert color value from the YCbCr space to CIE XYZ.  * The colorspace conversion algorithm comes from the IJG v5a code;  * see below for more information on how it works.  */
end_comment
begin_define
DECL|macro|SHIFT
define|#
directive|define
name|SHIFT
value|16
end_define
begin_define
DECL|macro|FIX
define|#
directive|define
name|FIX
parameter_list|(
name|x
parameter_list|)
value|((int32)((x) * (1L<<SHIFT) + 0.5))
end_define
begin_define
DECL|macro|ONE_HALF
define|#
directive|define
name|ONE_HALF
value|((int32)(1<<(SHIFT-1)))
end_define
begin_define
DECL|macro|Code2V
define|#
directive|define
name|Code2V
parameter_list|(
name|c
parameter_list|,
name|RB
parameter_list|,
name|RW
parameter_list|,
name|CR
parameter_list|)
value|((((c)-(int32)(RB))*(float)(CR))/(float)(((RW)-(RB)) ? ((RW)-(RB)) : 1))
end_define
begin_define
DECL|macro|CLAMP
define|#
directive|define
name|CLAMP
parameter_list|(
name|f
parameter_list|,
name|min
parameter_list|,
name|max
parameter_list|)
value|((f)<(min)?(min):(f)>(max)?(max):(f))
end_define
begin_define
DECL|macro|HICLAMP
define|#
directive|define
name|HICLAMP
parameter_list|(
name|f
parameter_list|,
name|max
parameter_list|)
value|((f)>(max)?(max):(f))
end_define
begin_function
name|void
DECL|function|TIFFYCbCrtoRGB
name|TIFFYCbCrtoRGB
parameter_list|(
name|TIFFYCbCrToRGB
modifier|*
name|ycbcr
parameter_list|,
name|uint32
name|Y
parameter_list|,
name|int32
name|Cb
parameter_list|,
name|int32
name|Cr
parameter_list|,
name|uint32
modifier|*
name|r
parameter_list|,
name|uint32
modifier|*
name|g
parameter_list|,
name|uint32
modifier|*
name|b
parameter_list|)
block|{
comment|/* XXX: Only 8-bit YCbCr input supported for now */
name|Y
operator|=
name|HICLAMP
argument_list|(
name|Y
argument_list|,
literal|255
argument_list|)
operator|,
name|Cb
operator|=
name|CLAMP
argument_list|(
name|Cb
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
operator|,
name|Cr
operator|=
name|CLAMP
argument_list|(
name|Cr
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
operator|*
name|r
operator|=
name|ycbcr
operator|->
name|clamptab
index|[
name|ycbcr
operator|->
name|Y_tab
index|[
name|Y
index|]
operator|+
name|ycbcr
operator|->
name|Cr_r_tab
index|[
name|Cr
index|]
index|]
expr_stmt|;
operator|*
name|g
operator|=
name|ycbcr
operator|->
name|clamptab
index|[
name|ycbcr
operator|->
name|Y_tab
index|[
name|Y
index|]
operator|+
call|(
name|int
call|)
argument_list|(
operator|(
name|ycbcr
operator|->
name|Cb_g_tab
index|[
name|Cb
index|]
operator|+
name|ycbcr
operator|->
name|Cr_g_tab
index|[
name|Cr
index|]
operator|)
operator|>>
name|SHIFT
argument_list|)
index|]
expr_stmt|;
operator|*
name|b
operator|=
name|ycbcr
operator|->
name|clamptab
index|[
name|ycbcr
operator|->
name|Y_tab
index|[
name|Y
index|]
operator|+
name|ycbcr
operator|->
name|Cb_b_tab
index|[
name|Cb
index|]
index|]
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Initialize the YCbCr->RGB conversion tables.  The conversion  * is done according to the 6.0 spec:  *  *    R = Y + Cr*(2 - 2*LumaRed)  *    B = Y + Cb*(2 - 2*LumaBlue)  *    G =   Y  *        - LumaBlue*Cb*(2-2*LumaBlue)/LumaGreen  *        - LumaRed*Cr*(2-2*LumaRed)/LumaGreen  *  * To avoid floating point arithmetic the fractional constants that  * come out of the equations are represented as fixed point values  * in the range 0...2^16.  We also eliminate multiplications by  * pre-calculating possible values indexed by Cb and Cr (this code  * assumes conversion is being done for 8-bit samples).  */
end_comment
begin_function
name|int
DECL|function|TIFFYCbCrToRGBInit
name|TIFFYCbCrToRGBInit
parameter_list|(
name|TIFFYCbCrToRGB
modifier|*
name|ycbcr
parameter_list|,
name|float
modifier|*
name|luma
parameter_list|,
name|float
modifier|*
name|refBlackWhite
parameter_list|)
block|{
name|TIFFRGBValue
modifier|*
name|clamptab
decl_stmt|;
name|int
name|i
decl_stmt|;
DECL|macro|LumaRed
define|#
directive|define
name|LumaRed
value|luma[0]
DECL|macro|LumaGreen
define|#
directive|define
name|LumaGreen
value|luma[1]
DECL|macro|LumaBlue
define|#
directive|define
name|LumaBlue
value|luma[2]
name|clamptab
operator|=
operator|(
name|TIFFRGBValue
operator|*
operator|)
operator|(
operator|(
name|tidata_t
operator|)
name|ycbcr
operator|+
name|TIFFroundup
argument_list|(
sizeof|sizeof
argument_list|(
name|TIFFYCbCrToRGB
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|_TIFFmemset
argument_list|(
name|clamptab
argument_list|,
literal|0
argument_list|,
literal|256
argument_list|)
expr_stmt|;
comment|/* v< 0 => 0 */
name|ycbcr
operator|->
name|clamptab
operator|=
operator|(
name|clamptab
operator|+=
literal|256
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|clamptab
index|[
name|i
index|]
operator|=
operator|(
name|TIFFRGBValue
operator|)
name|i
expr_stmt|;
name|_TIFFmemset
argument_list|(
name|clamptab
operator|+
literal|256
argument_list|,
literal|255
argument_list|,
literal|2
operator|*
literal|256
argument_list|)
expr_stmt|;
comment|/* v> 255 => 255 */
name|ycbcr
operator|->
name|Cr_r_tab
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|clamptab
operator|+
literal|3
operator|*
literal|256
operator|)
expr_stmt|;
name|ycbcr
operator|->
name|Cb_b_tab
operator|=
name|ycbcr
operator|->
name|Cr_r_tab
operator|+
literal|256
expr_stmt|;
name|ycbcr
operator|->
name|Cr_g_tab
operator|=
operator|(
name|int32
operator|*
operator|)
operator|(
name|ycbcr
operator|->
name|Cb_b_tab
operator|+
literal|256
operator|)
expr_stmt|;
name|ycbcr
operator|->
name|Cb_g_tab
operator|=
name|ycbcr
operator|->
name|Cr_g_tab
operator|+
literal|256
expr_stmt|;
name|ycbcr
operator|->
name|Y_tab
operator|=
name|ycbcr
operator|->
name|Cb_g_tab
operator|+
literal|256
expr_stmt|;
block|{
name|float
name|f1
init|=
literal|2
operator|-
literal|2
operator|*
name|LumaRed
decl_stmt|;
name|int32
name|D1
init|=
name|FIX
argument_list|(
name|f1
argument_list|)
decl_stmt|;
name|float
name|f2
init|=
name|LumaRed
operator|*
name|f1
operator|/
name|LumaGreen
decl_stmt|;
name|int32
name|D2
init|=
operator|-
name|FIX
argument_list|(
name|f2
argument_list|)
decl_stmt|;
name|float
name|f3
init|=
literal|2
operator|-
literal|2
operator|*
name|LumaBlue
decl_stmt|;
name|int32
name|D3
init|=
name|FIX
argument_list|(
name|f3
argument_list|)
decl_stmt|;
name|float
name|f4
init|=
name|LumaBlue
operator|*
name|f3
operator|/
name|LumaGreen
decl_stmt|;
name|int32
name|D4
init|=
operator|-
name|FIX
argument_list|(
name|f4
argument_list|)
decl_stmt|;
name|int
name|x
decl_stmt|;
DECL|macro|LumaBlue
undef|#
directive|undef
name|LumaBlue
DECL|macro|LumaGreen
undef|#
directive|undef
name|LumaGreen
DECL|macro|LumaRed
undef|#
directive|undef
name|LumaRed
comment|/*        * i is the actual input pixel value in the range 0..255        * Cb and Cr values are in the range -128..127 (actually        * they are in a range defined by the ReferenceBlackWhite        * tag) so there is some range shifting to do here when        * constructing tables indexed by the raw pixel data.        */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|x
operator|=
operator|-
literal|128
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
operator|,
name|x
operator|++
control|)
block|{
name|int32
name|Cr
init|=
operator|(
name|int32
operator|)
name|Code2V
argument_list|(
name|x
argument_list|,
name|refBlackWhite
index|[
literal|4
index|]
operator|-
literal|128.0F
argument_list|,
name|refBlackWhite
index|[
literal|5
index|]
operator|-
literal|128.0F
argument_list|,
literal|127
argument_list|)
decl_stmt|;
name|int32
name|Cb
init|=
operator|(
name|int32
operator|)
name|Code2V
argument_list|(
name|x
argument_list|,
name|refBlackWhite
index|[
literal|2
index|]
operator|-
literal|128.0F
argument_list|,
name|refBlackWhite
index|[
literal|3
index|]
operator|-
literal|128.0F
argument_list|,
literal|127
argument_list|)
decl_stmt|;
name|ycbcr
operator|->
name|Cr_r_tab
index|[
name|i
index|]
operator|=
call|(
name|int32
call|)
argument_list|(
operator|(
name|D1
operator|*
name|Cr
operator|+
name|ONE_HALF
operator|)
operator|>>
name|SHIFT
argument_list|)
expr_stmt|;
name|ycbcr
operator|->
name|Cb_b_tab
index|[
name|i
index|]
operator|=
call|(
name|int32
call|)
argument_list|(
operator|(
name|D3
operator|*
name|Cb
operator|+
name|ONE_HALF
operator|)
operator|>>
name|SHIFT
argument_list|)
expr_stmt|;
name|ycbcr
operator|->
name|Cr_g_tab
index|[
name|i
index|]
operator|=
name|D2
operator|*
name|Cr
expr_stmt|;
name|ycbcr
operator|->
name|Cb_g_tab
index|[
name|i
index|]
operator|=
name|D4
operator|*
name|Cb
operator|+
name|ONE_HALF
expr_stmt|;
name|ycbcr
operator|->
name|Y_tab
index|[
name|i
index|]
operator|=
operator|(
name|int32
operator|)
name|Code2V
argument_list|(
name|x
operator|+
literal|128
argument_list|,
name|refBlackWhite
index|[
literal|0
index|]
argument_list|,
name|refBlackWhite
index|[
literal|1
index|]
argument_list|,
literal|255
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_undef
DECL|macro|HICLAMP
undef|#
directive|undef
name|HICLAMP
end_undef
begin_undef
DECL|macro|CLAMP
undef|#
directive|undef
name|CLAMP
end_undef
begin_undef
DECL|macro|Code2V
undef|#
directive|undef
name|Code2V
end_undef
begin_undef
DECL|macro|SHIFT
undef|#
directive|undef
name|SHIFT
end_undef
begin_undef
DECL|macro|ONE_HALF
undef|#
directive|undef
name|ONE_HALF
end_undef
begin_undef
DECL|macro|FIX
undef|#
directive|undef
name|FIX
end_undef
begin_comment
comment|/* vim: set ts=8 sts=8 sw=8 noet: */
end_comment
end_unit
